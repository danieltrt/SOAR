file_path,api_count,code
baselines/models/classifier_utils.py,4,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-12-01 22:28:41\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-02 18:36:50\n# coding=utf-8\n# Copyright 2019 The Google Research Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Utility functions for GLUE classification tasks.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\n\nfrom __future__ import print_function\n\nimport json\nimport csv\nimport os\nimport six\n\nimport tensorflow as tf\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\nclass InputExample(object):\n  """"""A single training/test example for simple sequence classification.""""""\n\n  def __init__(self, guid, text_a, text_b=None, label=None):\n    """"""Constructs a InputExample.\n    Args:\n      guid: Unique id for the example.\n      text_a: string. The untokenized text of the first sequence. For single\n        sequence tasks, only this sequence must be specified.\n      text_b: (Optional) string. The untokenized text of the second sequence.\n        Only must be specified for sequence pair tasks.\n      label: (Optional) string. The label of the example. This should be\n        specified for train and dev examples, but not for test examples.\n    """"""\n    self.guid = guid\n    self.text_a = text_a\n    self.text_b = text_b\n    self.label = label\n\n\nclass PaddingInputExample(object):\n  """"""Fake example so the num input examples is a multiple of the batch size.\n  When running eval/predict on the TPU, we need to pad the number of examples\n  to be a multiple of the batch size, because the TPU requires a fixed batch\n  size. The alternative is to drop the last batch, which is bad because it means\n  the entire output data won\'t be generated.\n  We use this class instead of `None` because treating `None` as padding\n  battches could cause silent errors.\n  """"""\n\n\nclass DataProcessor(object):\n  """"""Base class for data converters for sequence classification data sets.""""""\n\n  def get_train_examples(self, data_dir):\n    """"""Gets a collection of `InputExample`s for the train set.""""""\n    raise NotImplementedError()\n\n  def get_dev_examples(self, data_dir):\n    """"""Gets a collection of `InputExample`s for the dev set.""""""\n    raise NotImplementedError()\n\n  def get_test_examples(self, data_dir):\n    """"""Gets a collection of `InputExample`s for prediction.""""""\n    raise NotImplementedError()\n\n  def get_labels(self):\n    """"""Gets the list of labels for this data set.""""""\n    raise NotImplementedError()\n\n  @classmethod\n  def _read_tsv(cls, input_file, delimiter=""\\t"", quotechar=None):\n    """"""Reads a tab separated value file.""""""\n    with tf.gfile.Open(input_file, ""r"") as f:\n      reader = csv.reader(f, delimiter=delimiter, quotechar=quotechar)\n      lines = []\n      for line in reader:\n        lines.append(line)\n      return lines\n\n  @classmethod\n  def _read_txt(cls, input_file):\n    """"""Reads a tab separated value file.""""""\n    with tf.gfile.Open(input_file, ""r"") as f:\n      reader = f.readlines()\n      lines = []\n      for line in reader:\n        lines.append(line.strip().split(""_!_""))\n      return lines\n\n  @classmethod\n  def _read_json(cls, input_file):\n    """"""Reads a tab separated value file.""""""\n    with tf.gfile.Open(input_file, ""r"") as f:\n      reader = f.readlines()\n      lines = []\n      for line in reader:\n        lines.append(json.loads(line.strip()))\n      return lines\n\n\nclass XnliProcessor(DataProcessor):\n  """"""Processor for the XNLI data set.""""""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n  def _create_examples(self, lines, set_type):\n    """"""See base class.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      guid = ""%s-%s"" % (set_type, i)\n      text_a = convert_to_unicode(line[\'premise\'])\n      text_b = convert_to_unicode(line[\'hypo\'])\n      label = convert_to_unicode(line[\'label\']) if set_type != \'test\' else \'contradiction\'\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""contradiction"", ""entailment"", ""neutral""]\n\n\n# class TnewsProcessor(DataProcessor):\n#     """"""Processor for the MRPC data set (GLUE version).""""""\n#\n#     def get_train_examples(self, data_dir):\n#         """"""See base class.""""""\n#         return self._create_examples(\n#             self._read_txt(os.path.join(data_dir, ""toutiao_category_train.txt"")), ""train"")\n#\n#     def get_dev_examples(self, data_dir):\n#         """"""See base class.""""""\n#         return self._create_examples(\n#             self._read_txt(os.path.join(data_dir, ""toutiao_category_dev.txt"")), ""dev"")\n#\n#     def get_test_examples(self, data_dir):\n#         """"""See base class.""""""\n#         return self._create_examples(\n#             self._read_txt(os.path.join(data_dir, ""toutiao_category_test.txt"")), ""test"")\n#\n#     def get_labels(self):\n#         """"""See base class.""""""\n#         labels = []\n#         for i in range(17):\n#             if i == 5 or i == 11:\n#                 continue\n#             labels.append(str(100 + i))\n#         return labels\n#\n#     def _create_examples(self, lines, set_type):\n#         """"""Creates examples for the training and dev sets.""""""\n#         examples = []\n#         for (i, line) in enumerate(lines):\n#             if i == 0:\n#                 continue\n#             guid = ""%s-%s"" % (set_type, i)\n#             text_a = convert_to_unicode(line[3])\n#             text_b = None\n#             label = convert_to_unicode(line[1])\n#             examples.append(\n#                 InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#         return examples\n\n\nclass TnewsProcessor(DataProcessor):\n  """"""Processor for the MRPC data set (GLUE version).""""""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    labels = []\n    for i in range(17):\n      if i == 5 or i == 11:\n        continue\n      labels.append(str(100 + i))\n    return labels\n\n  def _create_examples(self, lines, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      guid = ""%s-%s"" % (set_type, i)\n      text_a = convert_to_unicode(line[\'sentence\'])\n      text_b = None\n      label = convert_to_unicode(line[\'label\']) if set_type != \'test\' else ""100""\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples\n\n\n# class iFLYTEKDataProcessor(DataProcessor):\n#     """"""Processor for the iFLYTEKData data set (GLUE version).""""""\n#\n#     def get_train_examples(self, data_dir):\n#         """"""See base class.""""""\n#         return self._create_examples(\n#             self._read_txt(os.path.join(data_dir, ""train.txt"")), ""train"")\n#\n#     def get_dev_examples(self, data_dir):\n#         """"""See base class.""""""\n#         return self._create_examples(\n#             self._read_txt(os.path.join(data_dir, ""dev.txt"")), ""dev"")\n#\n#     def get_test_examples(self, data_dir):\n#         """"""See base class.""""""\n#         return self._create_examples(\n#             self._read_txt(os.path.join(data_dir, ""test.txt"")), ""test"")\n#\n#     def get_labels(self):\n#         """"""See base class.""""""\n#         labels = []\n#         for i in range(119):\n#             labels.append(str(i))\n#         return labels\n#\n#     def _create_examples(self, lines, set_type):\n#         """"""Creates examples for the training and dev sets.""""""\n#         examples = []\n#         for (i, line) in enumerate(lines):\n#             if i == 0:\n#                 continue\n#             guid = ""%s-%s"" % (set_type, i)\n#             text_a = convert_to_unicode(line[1])\n#             text_b = None\n#             label = convert_to_unicode(line[0])\n#             examples.append(\n#                 InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#         return examples\n\n\nclass iFLYTEKDataProcessor(DataProcessor):\n  """"""Processor for the iFLYTEKData data set (GLUE version).""""""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    labels = []\n    for i in range(119):\n      labels.append(str(i))\n    return labels\n\n  def _create_examples(self, lines, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      guid = ""%s-%s"" % (set_type, i)\n      text_a = convert_to_unicode(line[\'sentence\'])\n      text_b = None\n      label = convert_to_unicode(line[\'label\']) if set_type != \'test\' else ""0""\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples\n\n\nclass AFQMCProcessor(DataProcessor):\n  """"""Processor for the internal data set. sentence pair classification""""""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""0"", ""1""]\n\n  def _create_examples(self, lines, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      guid = ""%s-%s"" % (set_type, i)\n      text_a = convert_to_unicode(line[\'sentence1\'])\n      text_b = convert_to_unicode(line[\'sentence2\'])\n      label = convert_to_unicode(line[\'label\']) if set_type != \'test\' else \'0\'\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples\n\n\nclass CMNLIProcessor(DataProcessor):\n  """"""Processor for the CMNLI data set.""""""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples_json(os.path.join(data_dir, ""train.json""), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples_json(os.path.join(data_dir, ""dev.json""), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples_json(os.path.join(data_dir, ""test.json""), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""contradiction"", ""entailment"", ""neutral""]\n\n  def _create_examples_json(self, file_name, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    lines = tf.gfile.Open(file_name, ""r"")\n    index = 0\n    for line in lines:\n      line_obj = json.loads(line)\n      index = index + 1\n      guid = ""%s-%s"" % (set_type, index)\n      text_a = convert_to_unicode(line_obj[""sentence1""])\n      text_b = convert_to_unicode(line_obj[""sentence2""])\n      label = convert_to_unicode(line_obj[""label""]) if set_type != \'test\' else \'neutral\'\n\n      if label != ""-"":\n        examples.append(InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n\n    return examples\n\n\nclass CslProcessor(DataProcessor):\n  """"""Processor for the CSL data set.""""""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""0"", ""1""]\n\n  def _create_examples(self, lines, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      guid = ""%s-%s"" % (set_type, i)\n      text_a = convert_to_unicode("" "".join(line[\'keyword\']))\n      text_b = convert_to_unicode(line[\'abst\'])\n      label = convert_to_unicode(line[\'label\']) if set_type != \'test\' else \'0\'\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples\n\n\n# class InewsProcessor(DataProcessor):\n#   """"""Processor for the MRPC data set (GLUE version).""""""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_txt(os.path.join(data_dir, ""train.txt"")), ""train"")\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_txt(os.path.join(data_dir, ""dev.txt"")), ""dev"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_txt(os.path.join(data_dir, ""test.txt"")), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     labels = [""0"", ""1"", ""2""]\n#     return labels\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     for (i, line) in enumerate(lines):\n#       if i == 0:\n#         continue\n#       guid = ""%s-%s"" % (set_type, i)\n#       text_a = convert_to_unicode(line[2])\n#       text_b = convert_to_unicode(line[3])\n#       label = convert_to_unicode(line[0]) if set_type != ""test"" else \'0\'\n#       examples.append(\n#           InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#     return examples\n#\n#\n# class THUCNewsProcessor(DataProcessor):\n#   """"""Processor for the THUCNews data set (GLUE version).""""""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_txt(os.path.join(data_dir, ""train.txt"")), ""train"")\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_txt(os.path.join(data_dir, ""dev.txt"")), ""dev"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_txt(os.path.join(data_dir, ""test.txt"")), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     labels = []\n#     for i in range(14):\n#       labels.append(str(i))\n#     return labels\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     for (i, line) in enumerate(lines):\n#       if i == 0 or len(line) < 3:\n#         continue\n#       guid = ""%s-%s"" % (set_type, i)\n#       text_a = convert_to_unicode(line[3])\n#       text_b = None\n#       label = convert_to_unicode(line[0])\n#       examples.append(\n#           InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#     return examples\n#\n# class LCQMCProcessor(DataProcessor):\n#   """"""Processor for the internal data set. sentence pair classification""""""\n#\n#   def __init__(self):\n#     self.language = ""zh""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""train.txt"")), ""train"")\n#     # dev_0827.tsv\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""dev.txt"")), ""dev"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""test.txt"")), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     return [""0"", ""1""]\n#     # return [""-1"",""0"", ""1""]\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     print(""length of lines:"", len(lines))\n#     for (i, line) in enumerate(lines):\n#       # print(\'#i:\',i,line)\n#       if i == 0:\n#         continue\n#       guid = ""%s-%s"" % (set_type, i)\n#       try:\n#         label = convert_to_unicode(line[2])\n#         text_a = convert_to_unicode(line[0])\n#         text_b = convert_to_unicode(line[1])\n#         examples.append(\n#             InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#       except Exception:\n#         print(\'###error.i:\', i, line)\n#     return examples\n#\n#\n# class JDCOMMENTProcessor(DataProcessor):\n#   """"""Processor for the internal data set. sentence pair classification""""""\n#\n#   def __init__(self):\n#     self.language = ""zh""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""jd_train.csv""), "","", ""\\""""), ""train"")\n#     # dev_0827.tsv\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""jd_dev.csv""), "","", ""\\""""), ""dev"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""jd_test.csv""), "","", ""\\""""), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     return [""1"", ""2"", ""3"", ""4"", ""5""]\n#     # return [""-1"",""0"", ""1""]\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     print(""length of lines:"", len(lines))\n#     for (i, line) in enumerate(lines):\n#       # print(\'#i:\',i,line)\n#       if i == 0:\n#         continue\n#       guid = ""%s-%s"" % (set_type, i)\n#       try:\n#         label = convert_to_unicode(line[0])\n#         text_a = convert_to_unicode(line[1])\n#         text_b = convert_to_unicode(line[2])\n#         examples.append(\n#             InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#       except Exception:\n#         print(\'###error.i:\', i, line)\n#     return examples\n#\n#\n# class BQProcessor(DataProcessor):\n#   """"""Processor for the internal data set. sentence pair classification""""""\n#\n#   def __init__(self):\n#     self.language = ""zh""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""train.txt"")), ""train"")\n#     # dev_0827.tsv\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""dev.txt"")), ""dev"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""test.txt"")), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     return [""0"", ""1""]\n#     # return [""-1"",""0"", ""1""]\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     print(""length of lines:"", len(lines))\n#     for (i, line) in enumerate(lines):\n#       # print(\'#i:\',i,line)\n#       if i == 0:\n#         continue\n#       guid = ""%s-%s"" % (set_type, i)\n#       try:\n#         label = convert_to_unicode(line[2])\n#         text_a = convert_to_unicode(line[0])\n#         text_b = convert_to_unicode(line[1])\n#         examples.append(\n#             InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#       except Exception:\n#         print(\'###error.i:\', i, line)\n#     return examples\n#\n#\n# class MnliProcessor(DataProcessor):\n#   """"""Processor for the MultiNLI data set (GLUE version).""""""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""train.tsv"")), ""train"")\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""dev_matched.tsv"")),\n#         ""dev_matched"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""test_matched.tsv"")), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     return [""contradiction"", ""entailment"", ""neutral""]\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     for (i, line) in enumerate(lines):\n#       if i == 0:\n#         continue\n#       guid = ""%s-%s"" % (set_type, convert_to_unicode(line[0]))\n#       text_a = convert_to_unicode(line[8])\n#       text_b = convert_to_unicode(line[9])\n#       if set_type == ""test"":\n#         label = ""contradiction""\n#       else:\n#         label = convert_to_unicode(line[-1])\n#       examples.append(\n#           InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#     return examples\n#\n#\n# class MrpcProcessor(DataProcessor):\n#   """"""Processor for the MRPC data set (GLUE version).""""""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""train.tsv"")), ""train"")\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""dev.tsv"")), ""dev"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""test.tsv"")), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     return [""0"", ""1""]\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     for (i, line) in enumerate(lines):\n#       if i == 0:\n#         continue\n#       guid = ""%s-%s"" % (set_type, i)\n#       text_a = convert_to_unicode(line[3])\n#       text_b = convert_to_unicode(line[4])\n#       if set_type == ""test"":\n#         label = ""0""\n#       else:\n#         label = convert_to_unicode(line[0])\n#       examples.append(\n#           InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n#     return examples\n#\n#\n# class ColaProcessor(DataProcessor):\n#   """"""Processor for the CoLA data set (GLUE version).""""""\n#\n#   def get_train_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""train.tsv"")), ""train"")\n#\n#   def get_dev_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""dev.tsv"")), ""dev"")\n#\n#   def get_test_examples(self, data_dir):\n#     """"""See base class.""""""\n#     return self._create_examples(\n#         self._read_tsv(os.path.join(data_dir, ""test.tsv"")), ""test"")\n#\n#   def get_labels(self):\n#     """"""See base class.""""""\n#     return [""0"", ""1""]\n#\n#   def _create_examples(self, lines, set_type):\n#     """"""Creates examples for the training and dev sets.""""""\n#     examples = []\n#     for (i, line) in enumerate(lines):\n#       # Only the test set has a header\n#       if set_type == ""test"" and i == 0:\n#         continue\n#       guid = ""%s-%s"" % (set_type, i)\n#       if set_type == ""test"":\n#         text_a = convert_to_unicode(line[1])\n#         label = ""0""\n#       else:\n#         text_a = convert_to_unicode(line[3])\n#         label = convert_to_unicode(line[1])\n#       examples.append(\n#           InputExample(guid=guid, text_a=text_a, text_b=None, label=label))\n#     return examples\n\nclass WSCProcessor(DataProcessor):\n  """"""Processor for the internal data set. sentence pair classification""""""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""true"", ""false""]\n\n  def _create_examples(self, lines, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      guid = ""%s-%s"" % (set_type, i)\n      text_a = convert_to_unicode(line[\'text\'])\n      text_a_list = list(text_a)\n      target = line[\'target\']\n      query = target[\'span1_text\']\n      query_idx = target[\'span1_index\']\n      pronoun = target[\'span2_text\']\n      pronoun_idx = target[\'span2_index\']\n\n      assert text_a[pronoun_idx: (pronoun_idx + len(pronoun))\n                    ] == pronoun, ""pronoun: {}"".format(pronoun)\n      assert text_a[query_idx: (query_idx + len(query))] == query, ""query: {}"".format(query)\n\n      if pronoun_idx > query_idx:\n        text_a_list.insert(query_idx, ""_"")\n        text_a_list.insert(query_idx + len(query) + 1, ""_"")\n        text_a_list.insert(pronoun_idx + 2, ""["")\n        text_a_list.insert(pronoun_idx + len(pronoun) + 2 + 1, ""]"")\n      else:\n        text_a_list.insert(pronoun_idx, ""["")\n        text_a_list.insert(pronoun_idx + len(pronoun) + 1, ""]"")\n        text_a_list.insert(query_idx + 2, ""_"")\n        text_a_list.insert(query_idx + len(query) + 2 + 1, ""_"")\n\n      text_a = """".join(text_a_list)\n\n      if set_type == ""test"":\n        label = ""true""\n      else:\n        label = line[\'label\']\n\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=None, label=label))\n    return examples\n\n\nclass COPAProcessor(DataProcessor):\n  """"""Processor for the internal data set. sentence pair classification""""""\n\n  def __init__(self):\n    self.language = ""zh""\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n    # dev_0827.tsv\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""0"", ""1""]\n\n  @classmethod\n  def _create_examples_one(self, lines, set_type):\n    examples = []\n    for (i, line) in enumerate(lines):\n      guid1 = ""%s-%s"" % (set_type, i)\n#         try:\n      if line[\'question\'] == \'cause\':\n        text_a = convert_to_unicode(line[\'premise\'] + \'\xe5\x8e\x9f\xe5\x9b\xa0\xe6\x98\xaf\xe4\xbb\x80\xe4\xb9\x88\xe5\x91\xa2\xef\xbc\x9f\' + line[\'choice0\'])\n        text_b = convert_to_unicode(line[\'premise\'] + \'\xe5\x8e\x9f\xe5\x9b\xa0\xe6\x98\xaf\xe4\xbb\x80\xe4\xb9\x88\xe5\x91\xa2\xef\xbc\x9f\' + line[\'choice1\'])\n      else:\n        text_a = convert_to_unicode(line[\'premise\'] + \'\xe9\x80\xa0\xe6\x88\x90\xe4\xba\x86\xe4\xbb\x80\xe4\xb9\x88\xe5\xbd\xb1\xe5\x93\x8d\xe5\x91\xa2\xef\xbc\x9f\' + line[\'choice0\'])\n        text_b = convert_to_unicode(line[\'premise\'] + \'\xe9\x80\xa0\xe6\x88\x90\xe4\xba\x86\xe4\xbb\x80\xe4\xb9\x88\xe5\xbd\xb1\xe5\x93\x8d\xe5\x91\xa2\xef\xbc\x9f\' + line[\'choice1\'])\n      label = convert_to_unicode(str(1 if line[\'label\'] == 0 else 0)) if set_type != \'test\' else \'0\'\n      examples.append(\n          InputExample(guid=guid1, text_a=text_a, text_b=text_b, label=label))\n#         except Exception as e:\n#             print(\'###error.i:\',e, i, line)\n    return examples\n\n  @classmethod\n  def _create_examples(self, lines, set_type):\n    examples = []\n    for (i, line) in enumerate(lines):\n      i = 2 * i\n      guid1 = ""%s-%s"" % (set_type, i)\n      guid2 = ""%s-%s"" % (set_type, i + 1)\n#         try:\n      premise = convert_to_unicode(line[\'premise\'])\n      choice0 = convert_to_unicode(line[\'choice0\'])\n      label = convert_to_unicode(str(1 if line[\'label\'] == 0 else 0)) if set_type != \'test\' else \'0\'\n      #text_a2 = convert_to_unicode(line[\'premise\'])\n      choice1 = convert_to_unicode(line[\'choice1\'])\n      label2 = convert_to_unicode(\n          str(0 if line[\'label\'] == 0 else 1)) if set_type != \'test\' else \'0\'\n      if line[\'question\'] == \'effect\':\n        text_a = premise\n        text_b = choice0\n        text_a2 = premise\n        text_b2 = choice1\n      elif line[\'question\'] == \'cause\':\n        text_a = choice0\n        text_b = premise\n        text_a2 = choice1\n        text_b2 = premise\n      else:\n        print(\'wrong format!!\')\n        return None\n      examples.append(\n          InputExample(guid=guid1, text_a=text_a, text_b=text_b, label=label))\n      examples.append(\n          InputExample(guid=guid2, text_a=text_a2, text_b=text_b2, label=label2))\n#         except Exception as e:\n#             print(\'###error.i:\',e, i, line)\n    return examples\n'"
baselines/models/albert/bert_utils.py,19,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport six\nimport tensorflow as tf\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n\t""""""Returns a list of the shape of tensor, preferring static dimensions.\n\n\tArgs:\n\t\ttensor: A tf.Tensor object to find the shape of.\n\t\texpected_rank: (optional) int. The expected rank of `tensor`. If this is\n\t\t\tspecified and the `tensor` has a different rank, and exception will be\n\t\t\tthrown.\n\t\tname: Optional name of the tensor for the error message.\n\n\tReturns:\n\t\tA list of dimensions of the shape of tensor. All static dimensions will\n\t\tbe returned as python integers, and dynamic dimensions will be returned\n\t\tas tf.Tensor scalars.\n\t""""""\n\tif name is None:\n\t\tname = tensor.name\n\n\tif expected_rank is not None:\n\t\tassert_rank(tensor, expected_rank, name)\n\n\tshape = tensor.shape.as_list()\n\n\tnon_static_indexes = []\n\tfor (index, dim) in enumerate(shape):\n\t\tif dim is None:\n\t\t\tnon_static_indexes.append(index)\n\n\tif not non_static_indexes:\n\t\treturn shape\n\n\tdyn_shape = tf.shape(tensor)\n\tfor index in non_static_indexes:\n\t\tshape[index] = dyn_shape[index]\n\treturn shape\n\ndef reshape_to_matrix(input_tensor):\n\t""""""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n\tndims = input_tensor.shape.ndims\n\tif ndims < 2:\n\t\traise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n\t\t\t\t\t\t\t\t\t\t (input_tensor.shape))\n\tif ndims == 2:\n\t\treturn input_tensor\n\n\twidth = input_tensor.shape[-1]\n\toutput_tensor = tf.reshape(input_tensor, [-1, width])\n\treturn output_tensor\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n\t""""""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n\tif len(orig_shape_list) == 2:\n\t\treturn output_tensor\n\n\toutput_shape = get_shape_list(output_tensor)\n\n\torig_dims = orig_shape_list[0:-1]\n\twidth = output_shape[-1]\n\n\treturn tf.reshape(output_tensor, orig_dims + [width])\n\ndef assert_rank(tensor, expected_rank, name=None):\n\t""""""Raises an exception if the tensor rank is not of the expected rank.\n\n\tArgs:\n\t\ttensor: A tf.Tensor to check the rank of.\n\t\texpected_rank: Python integer or list of integers, expected rank.\n\t\tname: Optional name of the tensor for the error message.\n\n\tRaises:\n\t\tValueError: If the expected shape doesn\'t match the actual shape.\n\t""""""\n\tif name is None:\n\t\tname = tensor.name\n\n\texpected_rank_dict = {}\n\tif isinstance(expected_rank, six.integer_types):\n\t\texpected_rank_dict[expected_rank] = True\n\telse:\n\t\tfor x in expected_rank:\n\t\t\texpected_rank_dict[x] = True\n\n\tactual_rank = tensor.shape.ndims\n\tif actual_rank not in expected_rank_dict:\n\t\tscope_name = tf.get_variable_scope().name\n\t\traise ValueError(\n\t\t\t\t""For the tensor `%s` in scope `%s`, the actual rank ""\n\t\t\t\t""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n\t\t\t\t(name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n\ndef gather_indexes(sequence_tensor, positions):\n\t""""""Gathers the vectors at the specific positions over a minibatch.""""""\n\tsequence_shape = get_shape_list(sequence_tensor, expected_rank=3)\n\tbatch_size = sequence_shape[0]\n\tseq_length = sequence_shape[1]\n\twidth = sequence_shape[2]\n\n\tflat_offsets = tf.reshape(\n\t\t\ttf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n\tflat_positions = tf.reshape(positions + flat_offsets, [-1])\n\tflat_sequence_tensor = tf.reshape(sequence_tensor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[batch_size * seq_length, width])\n\toutput_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n\treturn output_tensor\n\n# add sequence mask for:\n# 1. random shuffle lm modeling---xlnet with random shuffled input\n# 2. left2right and right2left language modeling\n# 3. conditional generation\ndef generate_seq2seq_mask(attention_mask, mask_sequence, seq_type, **kargs):\n\tif seq_type == \'seq2seq\':\n\t\tif mask_sequence is not None:\n\t\t\tseq_shape = get_shape_list(mask_sequence, expected_rank=2)\n\t\t\tseq_len = seq_shape[1]\n\t\t\tones = tf.ones((1, seq_len, seq_len))\n\t\t\ta_mask = tf.matrix_band_part(ones, -1, 0)\n\t\t\ts_ex12 = tf.expand_dims(tf.expand_dims(mask_sequence, 1), 2)\n\t\t\ts_ex13 = tf.expand_dims(tf.expand_dims(mask_sequence, 1), 3)\n\t\t\ta_mask = (1 - s_ex13) * (1 - s_ex12) + s_ex13 * a_mask\n\t\t\t# generate mask of batch x seq_len x seq_len\n\t\t\ta_mask = tf.reshape(a_mask, (-1, seq_len, seq_len))\n\t\t\tout_mask = attention_mask * a_mask\n\t\telse:\n\t\t\tones = tf.ones_like(attention_mask[:1])\n\t\t\tmask = (tf.matrix_band_part(ones, -1, 0))\n\t\t\tout_mask = attention_mask * mask\n\telse:\n\t\tout_mask = attention_mask\n\n\treturn out_mask\n\n'"
baselines/models/albert/create_pretraining_data.py,19,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport tokenization\nimport tensorflow as tf\nimport jieba\nimport re\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\nflags.DEFINE_bool(""non_chinese"", False,""manually set this to True if you are not doing chinese pre-train task."")\n\n\nclass TrainingInstance(object):\n  """"""A single training instance (sentence pair).""""""\n\n  def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n               is_random_next):\n    self.tokens = tokens\n    self.segment_ids = segment_ids\n    self.is_random_next = is_random_next\n    self.masked_lm_positions = masked_lm_positions\n    self.masked_lm_labels = masked_lm_labels\n\n  def __str__(self):\n    s = """"\n    s += ""tokens: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.tokens]))\n    s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n    s += ""is_random_next: %s\\n"" % self.is_random_next\n    s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n        [str(x) for x in self.masked_lm_positions]))\n    s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n    s += ""\\n""\n    return s\n\n  def __repr__(self):\n    return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n  """"""Create TF example files from `TrainingInstance`s.""""""\n  writers = []\n  for output_file in output_files:\n    writers.append(tf.python_io.TFRecordWriter(output_file))\n\n  writer_index = 0\n\n  total_written = 0\n  for (inst_index, instance) in enumerate(instances):\n    input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n    input_mask = [1] * len(input_ids)\n    segment_ids = list(instance.segment_ids)\n    assert len(input_ids) <= max_seq_length\n\n    while len(input_ids) < max_seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      segment_ids.append(0)\n\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n\n    masked_lm_positions = list(instance.masked_lm_positions)\n    masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n    masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n    while len(masked_lm_positions) < max_predictions_per_seq:\n      masked_lm_positions.append(0)\n      masked_lm_ids.append(0)\n      masked_lm_weights.append(0.0)\n\n    next_sentence_label = 1 if instance.is_random_next else 0\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(input_ids)\n    features[""input_mask""] = create_int_feature(input_mask)\n    features[""segment_ids""] = create_int_feature(segment_ids)\n    features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n    features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n    features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n    features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n    writers[writer_index].write(tf_example.SerializeToString())\n    writer_index = (writer_index + 1) % len(writers)\n\n    total_written += 1\n\n    if inst_index < 20:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in instance.tokens]))\n\n      for feature_name in features.keys():\n        feature = features[feature_name]\n        values = []\n        if feature.int64_list.value:\n          values = feature.int64_list.value\n        elif feature.float_list.value:\n          values = feature.float_list.value\n        tf.logging.info(\n            ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n  for writer in writers:\n    writer.close()\n\n  tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n  feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n  return feature\n\n\ndef create_float_feature(values):\n  feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n  return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n  """"""Create `TrainingInstance`s from raw text.""""""\n  all_documents = [[]]\n\n  # Input file format:\n  # (1) One sentence per line. These should ideally be actual sentences, not\n  # entire paragraphs or arbitrary spans of text. (Because we use the\n  # sentence boundaries for the ""next sentence prediction"" task).\n  # (2) Blank lines between documents. Document boundaries are needed so\n  # that the ""next sentence prediction"" task doesn\'t span between documents.\n  for input_file in input_files:\n    with tf.gfile.GFile(input_file, ""r"") as reader:\n      while True:\n        strings=reader.readline()\n        strings=strings.replace(""   "","" "").replace(""  "","" "") # \xe5\xa6\x82\xe6\x9e\x9c\xe6\x9c\x89\xe4\xb8\xa4\xe4\xb8\xaa\xe6\x88\x96\xe4\xb8\x89\xe4\xb8\xaa\xe7\xa9\xba\xe6\xa0\xbc\xef\xbc\x8c\xe6\x9b\xbf\xe6\x8d\xa2\xe4\xb8\xba\xe4\xb8\x80\xe4\xb8\xaa\xe7\xa9\xba\xe6\xa0\xbc\n        line = tokenization.convert_to_unicode(strings)\n        if not line:\n          break\n        line = line.strip()\n\n        # Empty lines are used as document delimiters\n        if not line:\n          all_documents.append([])\n        tokens = tokenizer.tokenize(line)\n        if tokens:\n          all_documents[-1].append(tokens)\n\n  # Remove empty documents\n  all_documents = [x for x in all_documents if x]\n  rng.shuffle(all_documents)\n\n  vocab_words = list(tokenizer.vocab.keys())\n  instances = []\n  for _ in range(dupe_factor):\n    for document_index in range(len(all_documents)):\n      instances.extend(\n        create_instances_from_document_albert( # change to albert style for sentence order prediction(SOP), 2019-08-28, brightmart\n              all_documents, document_index, max_seq_length, short_seq_prob,\n              masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n  rng.shuffle(instances)\n  return instances\n\ndef get_new_segment(segment):  # \xe6\x96\xb0\xe5\xa2\x9e\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95 ####\n    """"""\n    \xe8\xbe\x93\xe5\x85\xa5\xe4\xb8\x80\xe5\x8f\xa5\xe8\xaf\x9d\xef\xbc\x8c\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe5\x8f\xa5\xe7\xbb\x8f\xe8\xbf\x87\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe8\xaf\x9d: \xe4\xb8\xba\xe4\xba\x86\xe6\x94\xaf\xe6\x8c\x81\xe4\xb8\xad\xe6\x96\x87\xe5\x85\xa8\xe7\xa7\xb0mask\xef\xbc\x8c\xe5\xb0\x86\xe8\xa2\xab\xe5\x88\x86\xe5\xbc\x80\xe7\x9a\x84\xe8\xaf\x8d\xef\xbc\x8c\xe5\xb0\x86\xe4\xb8\x8a\xe7\x89\xb9\xe6\xae\x8a\xe6\xa0\x87\xe8\xae\xb0(""#"")\xef\xbc\x8c\xe4\xbd\xbf\xe5\xbe\x97\xe5\x90\x8e\xe7\xbb\xad\xe5\xa4\x84\xe7\x90\x86\xe6\xa8\xa1\xe5\x9d\x97\xef\xbc\x8c\xe8\x83\xbd\xe5\xa4\x9f\xe7\x9f\xa5\xe9\x81\x93\xe5\x93\xaa\xe4\xba\x9b\xe5\xad\x97\xe6\x98\xaf\xe5\xb1\x9e\xe4\xba\x8e\xe5\x90\x8c\xe4\xb8\x80\xe4\xb8\xaa\xe8\xaf\x8d\xe7\x9a\x84\xe3\x80\x82\n    :param segment: \xe4\xb8\x80\xe5\x8f\xa5\xe8\xaf\x9d. e.g.  [\'\xe6\x82\xac\', \'\xe7\x81\xb8\', \'\xe6\x8a\x80\', \'\xe6\x9c\xaf\', \'\xe5\x9f\xb9\', \'\xe8\xae\xad\', \'\xe4\xb8\x93\', \'\xe5\xae\xb6\', \'\xe6\x95\x99\', \'\xe4\xbd\xa0\', \'\xe8\x89\xbe\', \'\xe7\x81\xb8\', \'\xe9\x99\x8d\', \'\xe8\xa1\x80\', \'\xe7\xb3\x96\', \'\xef\xbc\x8c\', \'\xe4\xb8\xba\', \'\xe7\x88\xb8\', \'\xe5\xa6\x88\', \'\xe6\x94\xb6\', \'\xe5\xa5\xbd\', \'\xe4\xba\x86\', \'\xef\xbc\x81\']\n    :return: \xe4\xb8\x80\xe5\x8f\xa5\xe5\xa4\x84\xe7\x90\x86\xe8\xbf\x87\xe7\x9a\x84\xe8\xaf\x9d e.g.    [\'\xe6\x82\xac\', \'##\xe7\x81\xb8\', \'\xe6\x8a\x80\', \'\xe6\x9c\xaf\', \'\xe5\x9f\xb9\', \'\xe8\xae\xad\', \'\xe4\xb8\x93\', \'##\xe5\xae\xb6\', \'\xe6\x95\x99\', \'\xe4\xbd\xa0\', \'\xe8\x89\xbe\', \'##\xe7\x81\xb8\', \'\xe9\x99\x8d\', \'##\xe8\xa1\x80\', \'##\xe7\xb3\x96\', \'\xef\xbc\x8c\', \'\xe4\xb8\xba\', \'\xe7\x88\xb8\', \'##\xe5\xa6\x88\', \'\xe6\x94\xb6\', \'##\xe5\xa5\xbd\', \'\xe4\xba\x86\', \'\xef\xbc\x81\']\n    """"""\n    seq_cws = jieba.lcut("""".join(segment)) # \xe5\x88\x86\xe8\xaf\x8d\n    seq_cws_dict = {x: 1 for x in seq_cws} # \xe5\x88\x86\xe8\xaf\x8d\xe5\x90\x8e\xe7\x9a\x84\xe8\xaf\x8d\xe5\x8a\xa0\xe5\x85\xa5\xe5\x88\xb0\xe8\xaf\x8d\xe5\x85\xb8dict\n    new_segment = []\n    i = 0\n    while i < len(segment): # \xe4\xbb\x8e\xe5\x8f\xa5\xe5\xad\x90\xe7\x9a\x84\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe5\xad\x97\xe5\xbc\x80\xe5\xa7\x8b\xe5\xa4\x84\xe7\x90\x86\xef\xbc\x8c\xe7\x9f\xa5\xe9\x81\x93\xe5\xa4\x84\xe7\x90\x86\xe5\xae\x8c\xe6\x95\xb4\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\n      if len(re.findall(\'[\\u4E00-\\u9FA5]\', segment[i])) == 0:  # \xe5\xa6\x82\xe6\x9e\x9c\xe6\x89\xbe\xe4\xb8\x8d\xe5\x88\xb0\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84\xef\xbc\x8c\xe5\x8e\x9f\xe6\x96\x87\xe5\x8a\xa0\xe8\xbf\x9b\xe5\x8e\xbb\xe5\x8d\xb3\xe4\xb8\x8d\xe7\x94\xa8\xe7\x89\xb9\xe6\xae\x8a\xe5\xa4\x84\xe7\x90\x86\xe3\x80\x82\n        new_segment.append(segment[i])\n        i += 1\n        continue\n\n      has_add = False\n      for length in range(3, 0, -1):\n        if i + length > len(segment):\n          continue\n        if \'\'.join(segment[i:i + length]) in seq_cws_dict:\n          new_segment.append(segment[i])\n          for l in range(1, length):\n            new_segment.append(\'##\' + segment[i + l])\n          i += length\n          has_add = True\n          break\n      if not has_add:\n        new_segment.append(segment[i])\n        i += 1\n    # print(""get_new_segment.wwm.get_new_segment:"",new_segment)\n    return new_segment\n\ndef create_instances_from_document_albert(\n    all_documents, document_index, max_seq_length, short_seq_prob,\n    masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n  """"""Creates `TrainingInstance`s for a single document.\n     This method is changed to create sentence-order prediction (SOP) followed by idea from paper of ALBERT, 2019-08-28, brightmart\n  """"""\n  document = all_documents[document_index] # \xe5\xbe\x97\xe5\x88\xb0\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\n\n  # Account for [CLS], [SEP], [SEP]\n  max_num_tokens = max_seq_length - 3\n\n  # We *usually* want to fill up the entire sequence since we are padding\n  # to `max_seq_length` anyways, so short sequences are generally wasted\n  # computation. However, we *sometimes*\n  # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n  # sequences to minimize the mismatch between pre-training and fine-tuning.\n  # The `target_seq_length` is just a rough target however, whereas\n  # `max_seq_length` is a hard limit.\n  target_seq_length = max_num_tokens\n  if rng.random() < short_seq_prob: # \xe6\x9c\x89\xe4\xb8\x80\xe5\xae\x9a\xe7\x9a\x84\xe6\xaf\x94\xe4\xbe\x8b\xef\xbc\x8c\xe5\xa6\x8210%\xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe4\xbd\xbf\xe7\x94\xa8\xe6\xaf\x94\xe8\xbe\x83\xe7\x9f\xad\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\xe9\x95\xbf\xe5\xba\xa6\xef\xbc\x8c\xe4\xbb\xa5\xe7\xbc\x93\xe8\xa7\xa3\xe9\xa2\x84\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe9\x95\xbf\xe5\xba\x8f\xe5\x88\x97\xe5\x92\x8c\xe8\xb0\x83\xe4\xbc\x98\xe9\x98\xb6\xe6\xae\xb5\xef\xbc\x88\xe5\x8f\xaf\xe8\x83\xbd\xe7\x9a\x84\xef\xbc\x89\xe7\x9f\xad\xe5\xba\x8f\xe5\x88\x97\xe7\x9a\x84\xe4\xb8\x8d\xe4\xb8\x80\xe8\x87\xb4\xe6\x83\x85\xe5\x86\xb5\n    target_seq_length = rng.randint(2, max_num_tokens)\n\n  # We DON\'T just concatenate all of the tokens from a document into a long\n  # sequence and choose an arbitrary split point because this would make the\n  # next sentence prediction task too easy. Instead, we split the input into\n  # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n  # input.\n  # \xe8\xae\xbe\xe6\xb3\x95\xe4\xbd\xbf\xe7\x94\xa8\xe5\xae\x9e\xe9\x99\x85\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe8\x80\x8c\xe4\xb8\x8d\xe6\x98\xaf\xe4\xbb\xbb\xe6\x84\x8f\xe7\x9a\x84\xe6\x88\xaa\xe6\x96\xad\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe4\xbb\x8e\xe8\x80\x8c\xe6\x9b\xb4\xe5\xa5\xbd\xe7\x9a\x84\xe6\x9e\x84\xe9\x80\xa0\xe5\x8f\xa5\xe5\xad\x90\xe8\xbf\x9e\xe8\xb4\xaf\xe6\x80\xa7\xe9\xa2\x84\xe6\xb5\x8b\xe7\x9a\x84\xe4\xbb\xbb\xe5\x8a\xa1\n  instances = []\n  current_chunk = [] # \xe5\xbd\x93\xe5\x89\x8d\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe6\x96\x87\xe6\x9c\xac\xe6\xae\xb5\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\n  current_length = 0\n  i = 0\n  # print(""###document:"",document) # \xe4\xb8\x80\xe4\xb8\xaadocument\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x98\xaf\xe4\xb8\x80\xe6\x95\xb4\xe7\xaf\x87\xe6\x96\x87\xe7\xab\xa0\xe3\x80\x81\xe6\x96\xb0\xe9\x97\xbb\xe3\x80\x81\xe8\xaf\x8d\xe6\x9d\xa1\xe7\xad\x89. document:[[\'\xe6\x98\xaf\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe5\xbe\x97\', \'\xe7\xbb\x99\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\'], [\'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'\xe3\x80\x90\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'\xe3\x80\x91\', \'\xef\xbc\x8c\', \'\xe8\x8e\xb7\', \'\xe5\x8f\x96\', \'\xe8\x82\xb2\', \'\xe5\x84\xbf\', \'\xe7\x9a\x84\', \'\xe6\x99\xba\', \'\xe6\x85\xa7\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8e\', \'\xe5\xad\xa9\', \'\xe5\xad\x90\', \'\xe4\xb8\x80\', \'\xe5\x90\x8c\', \'\xe6\x88\x90\', \'\xe9\x95\xbf\', \'\xef\xbc\x81\'], [\'\xe6\x96\xb9\', \'\xe6\xb3\x95\', \':\', \'\xe6\x89\x93\', \'\xe5\xbc\x80\', \'\xe5\xbe\xae\', \'\xe4\xbf\xa1\', \'\xe2\x86\x92\', \'\xe6\xb7\xbb\', \'\xe5\x8a\xa0\', \'\xe6\x9c\x8b\', \'\xe5\x8f\x8b\', \'\xe2\x86\x92\', \'\xe6\x90\x9c\', \'\xe5\x8f\xb7\', \'\xe2\x86\x92\', \'##he\', \'##bc\', \'##x\', \'##jy\', \'##\xe2\x86\x92\', \'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'!\', \'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xad\x9d\', \'\xe9\xa1\xba\', \'\xe6\x98\xaf\', \'\xe5\x81\x9a\', \'\xe4\xba\xba\', \'\xe7\x9a\x84\', \'\xe7\xac\xac\', \'\xe4\xb8\x80\', \'\xe5\x87\x86\', \'\xe5\x88\x99\', \'\xe3\x80\x82\'], [\'\xe7\x94\xad\', \'\xe7\xae\xa1\', \'\xe5\xb0\x8f\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xe6\x80\x8e\', \'\xe4\xb9\x88\', \'\xe8\xb7\x9f\', \'\xe5\xae\xb6\', \'\xe9\x95\xbf\', \'\xe7\x8a\xaf\', \'\xe6\xb7\xb7\', \'\xe8\x9b\x8b\', \'\xef\xbc\x8c\', \'\xe9\x95\xbf\', \'\xe5\xa4\xa7\', \'\xe4\xba\x86\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe5\xba\x95\', \'\xe6\x8a\xa5\', \'\xe7\xad\x94\', \'\xe7\x88\xb6\', \'\xe6\xaf\x8d\', \'\xef\xbc\x8c\', \'\xe4\xbb\xa5\', \'\xe5\x90\x8e\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe4\xb9\x9f\', \'\xe5\xbf\x85\', \'\xe9\xa1\xbb\', \'\xe5\xad\x9d\', \'\xe9\xa1\xba\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe8\x8a\xb1\', \'\xe5\xbf\x83\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe5\xa5\xbd\', \'\xe7\x8e\xa9\', \'\xe3\x80\x82\'], [\'\xe4\xbd\x86\', \'\xe6\x88\x91\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe4\xbc\x9a\', \'\xe6\x89\xbe\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe7\xae\xa1\', \'\xe7\x9a\x84\', \'\xe4\xbd\x8f\', \'\xe6\x88\x91\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xef\xbc\x8c\', \'\xe5\x92\x8c\', \'\xe6\x88\x91\', \'\xe4\xb8\x80\', \'\xe8\xb5\xb7\', \'\xe7\x94\x9f\', \'\xe6\xb4\xbb\', \'\xe3\x80\x82\'], [\'28\', \'\xe5\xb2\x81\', \'\xe4\xbb\xa5\', \'\xe5\x89\x8d\', \'\xe5\x9c\xa8\', \'\xe6\x80\x8e\', \'\xe4\xb9\x88\', \'\xe7\x8e\xa9\', \'\xe9\x83\xbd\', \'\xe8\xa1\x8c\', \'\xef\xbc\x8c\', \'\xe4\xbd\x86\', \'\xe6\x88\x91\', \'\xe6\x9c\x80\', \'\xe5\x90\x8e\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe4\xbc\x9a\', \'\xe6\x89\xbe\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe5\x8b\xa4\', \'\xe4\xbf\xad\', \'\xe6\x8c\x81\', \'\xe5\xae\xb6\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xb8\x8d\', \'\xe4\xbc\x9a\', \'\xe8\xae\xa9\', \'\xe8\x87\xaa\', \'\xe5\xb7\xb1\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe5\x8f\x97\', \'\xe4\xb8\x80\', \'\xe7\x82\xb9\', \'\xe5\xa7\x94\', \'\xe5\xb1\x88\', \'\xef\xbc\x8c\', \'\xe6\xaf\x8f\', \'\xe6\xac\xa1\', \'\xe6\x8a\x8a\', \'\xe5\xa5\xb9\', \'\xe6\x8a\xb1\', \'\xe5\x9c\xa8\', \'\xe6\x80\x80\', \'\xe9\x87\x8c\', \'\xef\xbc\x8c\', \'\xe7\x9c\x8b\', \'\xe5\xa5\xb9\', \'\xe6\xb4\x8b\', \'\xe6\xba\xa2\', \'\xe7\x9d\x80\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe7\x9a\x84\', \'\xe8\x84\xb8\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe9\x83\xbd\', \'\xe4\xbc\x9a\', \'\xe5\xbc\x95\', \'\xe4\xbb\xa5\', \'\xe4\xb8\xba\', \'\xe5\x82\xb2\', \'\xef\xbc\x8c\', \'\xe8\xbf\x99\', \'\xe7\x89\xb9\', \'\xe4\xb9\x88\', \'\xe5\xb0\xb1\', \'\xe6\x98\xaf\', \'\xe6\x88\x91\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xb9\xb2\', \'\xe4\xbb\x80\', \'\xe4\xb9\x88\', \'\xe4\xb9\x9f\', \'\xe4\xb8\x8d\', \'\xe8\x83\xbd\', \'\xe5\xbf\x98\', \'\xe4\xba\x86\', \'\xe8\x87\xaa\', \'\xe5\xb7\xb1\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe7\xae\x97\', \'\xe5\x92\x8c\', \'\xe5\x93\xa5\', \'\xe4\xbb\xac\', \'\xe4\xb8\x80\', \'\xe8\xb5\xb7\', \'\xe5\x96\x9d\', \'\xe9\x85\x92\', \'\xef\xbc\x8c\', \'\xe5\x96\x9d\', \'\xe5\x88\xb0\', \'\xe5\xbe\x88\', \'\xe6\x99\x9a\', \'\xef\xbc\x8c\', \'\xe4\xb9\x9f\', \'\xe8\xa6\x81\', \'\xe6\x8f\x90\', \'\xe5\x89\x8d\', \'\xe6\x89\x93\', \'\xe7\x94\xb5\', \'\xe8\xaf\x9d\', \'\xe5\x91\x8a\', \'\xe8\xaf\x89\', \'\xe5\xa5\xb9\', \'\xef\xbc\x8c\', \'\xe8\xae\xa9\', \'\xe5\xa5\xb9\', \'\xe6\x97\xa9\', \'\xe7\x82\xb9\', \'\xe4\xbc\x91\', \'\xe6\x81\xaf\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe4\xb8\x8d\', \'\xe8\x83\xbd\', \'\xe6\x8a\xbd\', \'\xe7\x83\x9f\', \'\xef\xbc\x8c\', \'\xe5\x96\x9d\', \'\xe9\x85\x92\', \'\xe8\xbf\x98\', \'\xe5\x8b\x89\', \'\xe5\xbc\xba\', \'\xe8\xbf\x87\', \'\xe5\xbe\x97\', \'\xe5\x8e\xbb\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe8\xbf\x87\', \'\xe8\xaf\xa5\', \'\xe5\x96\x9d\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xe5\x96\x9d\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe8\xaf\xa5\', \'\xe5\x96\x9d\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xef\xbc\x8c\', \'\xe5\xb0\x91\', \'\xe6\x89\xaf\', \'\xe7\xba\xb3\', \'\xe6\x9e\x81\', \'\xe8\x96\x84\', \'\xe8\x9b\x8b\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\xbf\x85\', \'\xe9\xa1\xbb\', \'\xe5\x90\xac\', \'\xe6\x88\x91\', \'\xe8\xaf\x9d\', \'\xef\xbc\x8c\', \'\xe5\x9c\xa8\', \'\xe4\xba\xba\', \'\xe5\x89\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe8\xa6\x81\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe9\x9d\xa2\', \'\xe5\xad\x90\', \'\xef\xbc\x8c\', \'\xe5\x9b\x9e\', \'\xe5\xae\xb6\', \'\xe4\xba\x86\', \'\xe5\x92\xb1\', \'\xe4\xbb\x80\', \'\xe4\xb9\x88\', \'\xe9\x83\xbd\', \'\xe5\xa5\xbd\', \'\xe8\xaf\xb4\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe7\xae\x97\', \'\xe9\x9a\xbe\', \'\xe7\x9a\x84\', \'\xe5\x90\x83\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x8a\', \'\xe9\xa5\xad\', \'\xe4\xba\x86\', \'\xef\xbc\x8c\', \'\xe9\x83\xbd\', \'\xe4\xb8\x8d\', \'\xe5\xbc\xa0\', \'\xe5\x8f\xa3\', \'\xe8\xb7\x9f\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe8\xa6\x81\', \'\xe4\xb8\x80\', \'\xe5\x88\x86\', \'\xe9\x92\xb1\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe7\xae\xa1\', \'\xe4\xb8\x8a\', \'\xe5\xad\xa6\', \'\xe8\xbf\x98\', \'\xe6\x98\xaf\', \'\xe4\xb8\x8a\', \'\xe7\x8f\xad\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe9\x83\xbd\', \'\xe4\xbc\x9a\', \'\xe9\x80\x81\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\x9b\x9e\', \'\xe5\xae\xb6\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xba\xa4\', \'\xe5\xbe\x80\', \'\xe4\xb8\x8d\', \'\xe5\x88\xb0\', \'1\', \'\xe5\xb9\xb4\', \'\xef\xbc\x8c\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe4\xb8\x8d\', \'\xe4\xbc\x9a\', \'\xe5\x92\x8c\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x8f\x90\', \'\xe8\xbf\x87\', \'\xe5\x88\x86\', \'\xe7\x9a\x84\', \'\xe8\xa6\x81\', \'\xe6\xb1\x82\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe5\xb0\x8a\', \'\xe9\x87\x8d\', \'\xe5\xa5\xb9\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\xb8\xb8\', \'\xe6\x88\x8f\', \'\xe6\xb0\xb8\', \'\xe8\xbf\x9c\', \'\xe6\xaf\x94\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x8a\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe9\x87\x8d\', \'\xe8\xa6\x81\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaa\', \'\xe8\xa6\x81\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\x8f\x91\', \'\xe8\xaf\x9d\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe5\x94\xaf\', \'\xe5\x91\xbd\', \'\xe6\x98\xaf\', \'\xe4\xbb\x8e\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8a\', \'q\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe6\x98\xaf\', \'\xe4\xb8\xba\', \'\xe4\xba\x86\', \'\xe7\xad\x89\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xef\xbc\x8c\', \'\xe6\x89\x80\', \'\xe6\x9c\x89\', \'\xe6\x9a\xa7\', \'\xe6\x98\xa7\', \'\xe7\x9a\x84\', \'\xe5\xbf\x83\', \'\xe6\x83\x85\', \'\xe5\x8f\xaa\', \'\xe4\xb8\xba\', \'\xe5\xa5\xb9\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe8\x80\x8c\', \'\xe5\x86\x99\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x8f\', \'\xe5\xb8\xb8\', \'\xe5\x86\x99\', \'\xe6\x97\xa5\', \'\xe5\xbf\x97\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaf\', \'\xe6\x98\xaf\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe5\x91\x8a\', \'\xe8\xaf\x89\', \'\xe5\x85\xa8\', \'\xe4\xb8\x96\', \'\xe7\x95\x8c\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe5\xbe\x88\', \'\xe7\x88\xb1\', \'\xe5\xa5\xb9\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe8\xa6\x81\', \'\xe7\xbb\x8f\', \'\xe5\xb8\xb8\', \'\xe5\x88\xb6\', \'\xe9\x80\xa0\', \'\xe6\xb5\xaa\', \'\xe6\xbc\xab\', \'\xe3\x80\x81\', \'\xe5\x81\xb6\', \'\xe5\xb0\x94\', \'\xe8\xbf\x87\', \'\xe4\xb8\xaa\', \'\xe8\x8a\x82\', \'\xe6\x97\xa5\', \'\xe4\xb9\x9f\', \'\xe8\xa6\x81\', \'\xe9\x80\x81\', \'\xe6\x9d\x9f\', \'\xe7\x8e\xab\', \'\xe7\x91\xb0\', \'\xe8\x8a\xb1\', \'\xe7\xbb\x99\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x8a\xb1\', \'\xe5\x9b\x9e\', \'\xe5\xae\xb6\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x89\x8b\', \'\xe6\x9c\xba\', \'\xe4\xbc\x9a\', \'24\', \'\xe5\xb0\x8f\', \'\xe6\x97\xb6\', \'\xe4\xb8\xba\', \'\xe5\xa5\xb9\', \'\xe5\xbc\x80\', \'\xe6\x9c\xba\', \'\xef\xbc\x8c\', \'\xe8\xae\xa9\', \'\xe5\xa5\xb9\', \'\xe5\x8d\x8a\', \'\xe5\xa4\x9c\', \'\xe7\x97\x9b\', \'\xe7\xbb\x8f\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xef\xbc\x8c\', \'\xe5\x81\x9a\', \'\xe6\x81\xb6\', \'\xe6\xa2\xa6\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xef\xbc\x8c\', \'\xe9\x9a\x8f\', \'\xe6\x97\xb6\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe8\x81\x94\', \'\xe7\xb3\xbb\', \'\xe5\x88\xb0\', \'\xe6\x88\x91\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x8f\', \'\xe5\xb8\xb8\', \'\xe5\xb8\xa6\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\x87\xba\', \'\xe5\x8e\xbb\', \'\xe7\x8e\xa9\', \'\xef\xbc\x8c\', \'\xe5\xa5\xb9\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe8\xa6\x81\', \'\xe5\x92\x8c\', \'\xe6\x88\x91\', \'\xe6\x89\x80\', \'\xe6\x9c\x89\', \'\xe7\x9a\x84\', \'\xe5\x93\xa5\', \'\xe4\xbb\xac\', \'\xe9\x83\xbd\', \'\xe8\xae\xa4\', \'\xe8\xaf\x86\', \'\xef\xbc\x8c\', \'\xe4\xbd\x86\', \'\xe8\xa7\x81\', \'\xe9\x9d\xa2\', \'\xe8\x83\xbd\', \'\xe8\xaf\xb4\', \'\xe7\x9a\x84\', \'\xe4\xb8\x8a\', \'\xe8\xaf\x9d\', \'\xe5\xb0\xb1\', \'\xe8\xa1\x8c\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe5\x92\x8c\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe7\x9a\x84\', \'\xe5\xa7\x90\', \'\xe5\xa6\xb9\', \'\xe5\x93\xa5\', \'\xe4\xbb\xac\', \'\xe6\x90\x9e\', \'\xe5\xa5\xbd\', \'\xe5\x85\xb3\', \'\xe7\xb3\xbb\', \'\xef\xbc\x8c\', \'\xe8\xae\xa9\', \'\xe5\xa5\xb9\', \'\xe4\xbb\xac\', \'\xe7\x9b\xb8\', \'\xe4\xbf\xa1\', \'\xe6\x88\x91\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\x90\xb5\', \'\xe6\x9e\xb6\', \'\xe5\x90\x8e\', \'\xe3\x80\x81\', \'\xe4\xb9\x9f\', \'\xe8\xa6\x81\', \'\xe4\xb8\xbb\', \'\xe5\x8a\xa8\', \'\xe6\x89\x93\', \'\xe7\x94\xb5\', \'\xe8\xaf\x9d\', \'\xe5\x85\xb3\', \'\xe5\xbf\x83\', \'\xe5\xa5\xb9\', \'\xef\xbc\x8c\', \'\xe5\x92\xb1\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe7\xbb\x99\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x9c\x8d\', \'\xe4\xb8\xaa\', \'\xe8\xbd\xaf\', \'\xef\xbc\x8c\', \'\xe9\x81\x93\', \'\xe4\xb8\xaa\', \'\xe6\xad\x89\', \'\xe6\x80\x8e\', \'\xe4\xb9\x88\', \'\xe4\xba\x86\', \'\xef\xbc\x9f\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe4\xb8\x8d\', \'\xe4\xbc\x9a\', \'\xe5\xab\x8c\', \'\xe5\xbc\x83\', \'\xe8\x87\xaa\', \'\xe5\xb7\xb1\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xef\xbc\x8c\', \'\xe6\x8b\xbf\', \'\xe5\xa5\xb9\', \'\xe5\x92\x8c\', \'\xe5\x88\xab\', \'\xe4\xba\xba\', \'\xe6\xaf\x94\', \'\xef\xbc\x8c\', \'\xe8\xaf\xb4\', \'\xe5\xa5\xb9\', \'\xe8\xbf\x99\', \'\xe4\xb8\x8d\', \'\xe5\xa6\x82\', \'\xe4\xba\xba\', \'\xe5\xae\xb6\', \'\xef\xbc\x8c\', \'\xe7\xba\xb3\', \'\xe4\xb8\x8d\', \'\xe5\xa6\x82\', \'\xe4\xba\xba\', \'\xe5\xae\xb6\', \'\xe7\x9a\x84\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe9\x99\xaa\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe9\x80\x9b\', \'\xe8\xa1\x97\', \'\xe6\x97\xb6\', \'\xef\xbc\x8c\', \'\xe7\xa2\xb0\', \'\xe8\xa7\x81\', \'\xe7\x86\x9f\', \'\xe4\xba\xba\', \'\xef\xbc\x8c\', \'\xe6\x97\xa0\', \'\xe8\xae\xba\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe9\x95\xbf\', \'\xe7\x9a\x84\', \'\xe5\xa5\xbd\', \'\xe7\x9c\x8b\', \'\xe4\xb8\x8e\', \'\xe5\x90\xa6\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe9\x83\xbd\', \'\xe4\xbc\x9a\', \'\xe5\xa4\xa7\', \'\xe6\x96\xb9\', \'\xe7\x9a\x84\', \'\xe4\xbb\x8b\', \'\xe7\xbb\x8d\', \'\xe3\x80\x82\'], [\'\xe8\xb0\x81\', \'\xe8\xae\xa9\', \'\xe5\x92\xb1\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xe5\xb0\xb1\', \'\xe5\xa5\xbd\', \'\xe8\xbf\x99\', \'\xe5\x8f\xa3\', \'\xe5\x91\xa2\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe6\x83\xb3\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x9c\x80\', \'\xe5\xa5\xbd\', \'\xe7\x9a\x84\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe3\x80\x82\'], [\'\xe3\x80\x90\', \'\xe6\x88\x91\', \'\xe4\xbb\xac\', \'\xe9\x87\x8d\', \'\xe5\x9c\xa8\', \'\xe5\x88\x86\', \'\xe4\xba\xab\', \'\xe3\x80\x82\'], [\'\xe6\x89\x80\', \'\xe6\x9c\x89\', \'\xe6\x96\x87\', \'\xe5\xad\x97\', \'\xe5\x92\x8c\', \'\xe7\xbe\x8e\', \'\xe5\x9b\xbe\', \'\xef\xbc\x8c\', \'\xe6\x9d\xa5\', \'\xe8\x87\xaa\', \'\xe7\xbd\x91\', \'\xe7\xbb\x9c\', \'\xef\xbc\x8c\', \'\xe6\x99\xa8\', \'\xe6\xac\xa3\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'\xe6\x95\xb4\', \'\xe7\x90\x86\', \'\xe3\x80\x82\'], [\'\xe5\xaf\xb9\', \'\xe5\x8e\x9f\', \'\xe6\x96\x87\', \'\xe4\xbd\x9c\', \'\xe8\x80\x85\', \'\xef\xbc\x8c\', \'\xe8\xa1\xa8\', \'\xe7\xa4\xba\', \'\xe6\x95\xac\', \'\xe6\x84\x8f\', \'\xe3\x80\x82\'], [\'\xe3\x80\x91\', \'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'[UNK]\', \'[UNK]\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'\xef\xbc\x88\', \'\xe5\xbe\xae\', \'\xe4\xbf\xa1\', \'\xe5\x8f\xb7\', \'\xef\xbc\x9a\', \'he\', \'##bc\', \'##x\', \'##jy\', \'\xef\xbc\x89\', \'\xe3\x80\x82\'], [\'\xe6\x89\x93\', \'\xe5\xbc\x80\', \'\xe5\xbe\xae\', \'\xe4\xbf\xa1\', \'\xef\xbc\x8c\', \'\xe6\x89\xab\', \'\xe6\x8f\x8f\', \'\xe4\xba\x8c\', \'\xe7\xbb\xb4\', \'\xe7\xa0\x81\', \'\xef\xbc\x8c\', \'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'[UNK]\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'[UNK]\', \'\xef\xbc\x8c\', \'\xe8\x8e\xb7\', \'\xe5\x8f\x96\', \'\xe6\x9b\xb4\', \'\xe5\xa4\x9a\', \'\xe8\x82\xb2\', \'\xe5\x84\xbf\', \'\xe8\xb5\x84\', \'\xe6\xba\x90\', \'\xe3\x80\x82\'], [\'\xe7\x82\xb9\', \'\xe5\x87\xbb\', \'\xe4\xb8\x8b\', \'\xe9\x9d\xa2\', \'\xe8\xae\xa2\', \'\xe9\x98\x85\', \'\xe6\x8c\x89\', \'\xe9\x92\xae\', \'\xe8\xae\xa2\', \'\xe9\x98\x85\', \'\xef\xbc\x8c\', \'\xe4\xbc\x9a\', \'\xe6\x9c\x89\', \'\xe6\x9b\xb4\', \'\xe5\xa4\x9a\', \'\xe6\x83\x8a\', \'\xe5\x96\x9c\', \'\xe5\x93\xa6\', \'\xef\xbc\x81\']]\n  while i < len(document): # \xe4\xbb\x8e\xe6\x96\x87\xe6\xa1\xa3\xe7\x9a\x84\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe4\xbd\x8d\xe7\xbd\xae\xe5\xbc\x80\xe5\xa7\x8b\xef\xbc\x8c\xe6\x8c\x89\xe4\xb8\xaa\xe5\xbe\x80\xe4\xb8\x8b\xe7\x9c\x8b\n    segment = document[i] # segment\xe6\x98\xaf\xe5\x88\x97\xe8\xa1\xa8\xef\xbc\x8c\xe4\xbb\xa3\xe8\xa1\xa8\xe7\x9a\x84\xe6\x98\xaf\xe6\x8c\x89\xe5\xad\x97\xe5\x88\x86\xe5\xbc\x80\xe7\x9a\x84\xe4\xb8\x80\xe4\xb8\xaa\xe5\xae\x8c\xe6\x95\xb4\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe5\xa6\x82 segment=[\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe6\x83\xb3\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x9c\x80\', \'\xe5\xa5\xbd\', \'\xe7\x9a\x84\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe3\x80\x82\']\n    if FLAGS.non_chinese==False: # if non chinese is False, that means it is chinese, then do something to make chinese whole word mask works.\n      segment = get_new_segment(segment)  # whole word mask for chinese: \xe7\xbb\x93\xe5\x90\x88\xe5\x88\x86\xe8\xaf\x8d\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84whole mask\xe8\xae\xbe\xe7\xbd\xae\xe5\x8d\xb3\xe5\x9c\xa8\xe9\x9c\x80\xe8\xa6\x81\xe7\x9a\x84\xe5\x9c\xb0\xe6\x96\xb9\xe5\x8a\xa0\xe4\xb8\x8a\xe2\x80\x9c##\xe2\x80\x9d\n\n    current_chunk.append(segment) # \xe5\xb0\x86\xe4\xb8\x80\xe4\xb8\xaa\xe7\x8b\xac\xe7\xab\x8b\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\xe5\x8a\xa0\xe5\x85\xa5\xe5\x88\xb0\xe5\xbd\x93\xe5\x89\x8d\xe7\x9a\x84\xe6\x96\x87\xe6\x9c\xac\xe5\x9d\x97\xe4\xb8\xad\n    current_length += len(segment) # \xe7\xb4\xaf\xe8\xae\xa1\xe5\x88\xb0\xe4\xb8\xba\xe6\xad\xa2\xe4\xbd\x8d\xe7\xbd\xae\xe6\x8e\xa5\xe8\xa7\xa6\xe5\x88\xb0\xe5\x8f\xa5\xe5\xad\x90\xe7\x9a\x84\xe6\x80\xbb\xe9\x95\xbf\xe5\xba\xa6\n    if i == len(document) - 1 or current_length >= target_seq_length:\n      # \xe5\xa6\x82\xe6\x9e\x9c\xe7\xb4\xaf\xe8\xae\xa1\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\xe9\x95\xbf\xe5\xba\xa6\xe8\xbe\xbe\xe5\x88\xb0\xe4\xba\x86\xe7\x9b\xae\xe6\xa0\x87\xe7\x9a\x84\xe9\x95\xbf\xe5\xba\xa6\xef\xbc\x8c\xe6\x88\x96\xe5\xbd\x93\xe5\x89\x8d\xe8\xb5\xb0\xe5\x88\xb0\xe4\xba\x86\xe6\x96\x87\xe6\xa1\xa3\xe7\xbb\x93\xe5\xb0\xbe==>\xe6\x9e\x84\xe9\x80\xa0\xe5\xb9\xb6\xe6\xb7\xbb\xe5\x8a\xa0\xe5\x88\xb0\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84A\xe5\x92\x8cB\xe4\xb8\xad\xef\xbc\x9b\n      if current_chunk: # \xe5\xa6\x82\xe6\x9e\x9c\xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\xe4\xb8\x8d\xe4\xb8\xba\xe7\xa9\xba\n        # `a_end` is how many segments from `current_chunk` go into the `A`\n        # (first) sentence.\n        a_end = 1\n        if len(current_chunk) >= 2: # \xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe5\x8c\x85\xe5\x90\xab\xe8\xb6\x85\xe8\xbf\x87\xe4\xb8\xa4\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe5\x8f\x96\xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\xe7\x9a\x84\xe4\xb8\x80\xe9\x83\xa8\xe5\x88\x86\xe4\xbd\x9c\xe4\xb8\xba\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84A\xe9\x83\xa8\xe5\x88\x86\n          a_end = rng.randint(1, len(current_chunk) - 1)\n        # \xe5\xb0\x86\xe5\xbd\x93\xe5\x89\x8d\xe6\x96\x87\xe6\x9c\xac\xe6\xae\xb5\xe4\xb8\xad\xe9\x80\x89\xe5\x8f\x96\xe5\x87\xba\xe6\x9d\xa5\xe7\x9a\x84\xe5\x89\x8d\xe5\x8d\x8a\xe9\x83\xa8\xe5\x88\x86\xef\xbc\x8c\xe8\xb5\x8b\xe5\x80\xbc\xe7\xbb\x99A\xe5\x8d\xb3tokens_a\n        tokens_a = []\n        for j in range(a_end):\n          tokens_a.extend(current_chunk[j])\n\n        # \xe6\x9e\x84\xe9\x80\xa0\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84B\xe9\x83\xa8\xe5\x88\x86(\xe6\x9c\x89\xe4\xb8\x80\xe9\x83\xa8\xe5\x88\x86\xe6\x98\xaf\xe6\xad\xa3\xe5\xb8\xb8\xe7\x9a\x84\xe5\xbd\x93\xe5\x89\x8d\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe7\x9a\x84\xe5\x90\x8e\xe5\x8d\x8a\xe9\x83\xa8;\xe5\x9c\xa8\xe5\x8e\x9fBERT\xe7\x9a\x84\xe5\xae\x9e\xe7\x8e\xb0\xe4\xb8\xad\xe4\xb8\x80\xe9\x83\xa8\xe5\x88\x86\xe6\x98\xaf\xe9\x9a\x8f\xe6\x9c\xba\xe7\x9a\x84\xe4\xbb\x8e\xe5\x8f\xa6\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe9\x80\x89\xe5\x8f\x96\xe7\x9a\x84\xef\xbc\x8c\xef\xbc\x89\n        tokens_b = []\n        for j in range(a_end, len(current_chunk)):\n          tokens_b.extend(current_chunk[j])\n\n        # \xe6\x9c\x89\xe7\x99\xbe\xe5\x88\x86\xe4\xb9\x8b50%\xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xe4\xba\xa4\xe6\x8d\xa2\xe4\xb8\x80\xe4\xb8\x8btokens_a\xe5\x92\x8ctokens_b\xe7\x9a\x84\xe4\xbd\x8d\xe7\xbd\xae\n        # print(""tokens_a length1:"",len(tokens_a))\n        # print(""tokens_b length1:"",len(tokens_b)) # len(tokens_b) = 0\n\n        if len(tokens_a)==0 or len(tokens_b)==0: continue\n        if rng.random() < 0.5: # \xe4\xba\xa4\xe6\x8d\xa2\xe4\xb8\x80\xe4\xb8\x8btokens_a\xe5\x92\x8ctokens_b\n          is_random_next=True\n          temp=tokens_a\n          tokens_a=tokens_b\n          tokens_b=temp\n        else:\n          is_random_next=False\n\n        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n        assert len(tokens_a) >= 1\n        assert len(tokens_b) >= 1\n\n        # \xe6\x8a\x8atokens_a & tokens_b\xe5\x8a\xa0\xe5\x85\xa5\xe5\x88\xb0\xe6\x8c\x89\xe7\x85\xa7bert\xe7\x9a\x84\xe9\xa3\x8e\xe6\xa0\xbc\xef\xbc\x8c\xe5\x8d\xb3\xe4\xbb\xa5[CLS]tokens_a[SEP]tokens_b[SEP]\xe7\x9a\x84\xe5\xbd\xa2\xe5\xbc\x8f\xef\xbc\x8c\xe7\xbb\x93\xe5\x90\x88\xe5\x88\xb0\xe4\xb8\x80\xe8\xb5\xb7\xef\xbc\x8c\xe4\xbd\x9c\xe4\xb8\xba\xe6\x9c\x80\xe7\xbb\x88\xe7\x9a\x84tokens; \xe4\xb9\x9f\xe5\xb8\xa6\xe4\xb8\x8asegment_ids\xef\xbc\x8c\xe5\x89\x8d\xe9\x9d\xa2\xe9\x83\xa8\xe5\x88\x86segment_ids\xe7\x9a\x84\xe5\x80\xbc\xe6\x98\xaf0\xef\xbc\x8c\xe5\x90\x8e\xe9\x9d\xa2\xe9\x83\xa8\xe5\x88\x86\xe7\x9a\x84\xe5\x80\xbc\xe6\x98\xaf1.\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n          tokens.append(token)\n          segment_ids.append(0)\n\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        for token in tokens_b:\n          tokens.append(token)\n          segment_ids.append(1)\n        tokens.append(""[SEP]"")\n        segment_ids.append(1)\n\n        # \xe5\x88\x9b\xe5\xbb\xbamasked LM\xe7\x9a\x84\xe4\xbb\xbb\xe5\x8a\xa1\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae Creates the predictions for the masked LM objective\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance( # \xe5\x88\x9b\xe5\xbb\xba\xe8\xae\xad\xe7\xbb\x83\xe5\xae\x9e\xe4\xbe\x8b\xe7\x9a\x84\xe5\xaf\xb9\xe8\xb1\xa1\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n      current_chunk = [] # \xe6\xb8\x85\xe7\xa9\xba\xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\n      current_length = 0 # \xe9\x87\x8d\xe7\xbd\xae\xe5\xbd\x93\xe5\x89\x8d\xe6\x96\x87\xe6\x9c\xac\xe5\x9d\x97\xe7\x9a\x84\xe9\x95\xbf\xe5\xba\xa6\n    i += 1 # \xe6\x8e\xa5\xe7\x9d\x80\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe7\x9a\x84\xe5\x86\x85\xe5\xae\xb9\xe5\xbe\x80\xe5\x90\x8e\xe7\x9c\x8b\n\n  return instances\n\n\ndef create_instances_from_document_original( # THIS IS ORIGINAL BERT STYLE FOR CREATE DATA OF MLM AND NEXT SENTENCE PREDICTION TASK\n    all_documents, document_index, max_seq_length, short_seq_prob,\n    masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n  """"""Creates `TrainingInstance`s for a single document.""""""\n  document = all_documents[document_index] # \xe5\xbe\x97\xe5\x88\xb0\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\n\n  # Account for [CLS], [SEP], [SEP]\n  max_num_tokens = max_seq_length - 3\n\n  # We *usually* want to fill up the entire sequence since we are padding\n  # to `max_seq_length` anyways, so short sequences are generally wasted\n  # computation. However, we *sometimes*\n  # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n  # sequences to minimize the mismatch between pre-training and fine-tuning.\n  # The `target_seq_length` is just a rough target however, whereas\n  # `max_seq_length` is a hard limit.\n  target_seq_length = max_num_tokens\n  if rng.random() < short_seq_prob: # \xe6\x9c\x89\xe4\xb8\x80\xe5\xae\x9a\xe7\x9a\x84\xe6\xaf\x94\xe4\xbe\x8b\xef\xbc\x8c\xe5\xa6\x8210%\xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe4\xbd\xbf\xe7\x94\xa8\xe6\xaf\x94\xe8\xbe\x83\xe7\x9f\xad\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\xe9\x95\xbf\xe5\xba\xa6\xef\xbc\x8c\xe4\xbb\xa5\xe7\xbc\x93\xe8\xa7\xa3\xe9\xa2\x84\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe9\x95\xbf\xe5\xba\x8f\xe5\x88\x97\xe5\x92\x8c\xe8\xb0\x83\xe4\xbc\x98\xe9\x98\xb6\xe6\xae\xb5\xef\xbc\x88\xe5\x8f\xaf\xe8\x83\xbd\xe7\x9a\x84\xef\xbc\x89\xe7\x9f\xad\xe5\xba\x8f\xe5\x88\x97\xe7\x9a\x84\xe4\xb8\x8d\xe4\xb8\x80\xe8\x87\xb4\xe6\x83\x85\xe5\x86\xb5\n    target_seq_length = rng.randint(2, max_num_tokens)\n\n  # We DON\'T just concatenate all of the tokens from a document into a long\n  # sequence and choose an arbitrary split point because this would make the\n  # next sentence prediction task too easy. Instead, we split the input into\n  # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n  # input.\n  # \xe8\xae\xbe\xe6\xb3\x95\xe4\xbd\xbf\xe7\x94\xa8\xe5\xae\x9e\xe9\x99\x85\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe8\x80\x8c\xe4\xb8\x8d\xe6\x98\xaf\xe4\xbb\xbb\xe6\x84\x8f\xe7\x9a\x84\xe6\x88\xaa\xe6\x96\xad\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe4\xbb\x8e\xe8\x80\x8c\xe6\x9b\xb4\xe5\xa5\xbd\xe7\x9a\x84\xe6\x9e\x84\xe9\x80\xa0\xe5\x8f\xa5\xe5\xad\x90\xe8\xbf\x9e\xe8\xb4\xaf\xe6\x80\xa7\xe9\xa2\x84\xe6\xb5\x8b\xe7\x9a\x84\xe4\xbb\xbb\xe5\x8a\xa1\n  instances = []\n  current_chunk = [] # \xe5\xbd\x93\xe5\x89\x8d\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe6\x96\x87\xe6\x9c\xac\xe6\xae\xb5\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\n  current_length = 0\n  i = 0\n  # print(""###document:"",document) # \xe4\xb8\x80\xe4\xb8\xaadocument\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x98\xaf\xe4\xb8\x80\xe6\x95\xb4\xe7\xaf\x87\xe6\x96\x87\xe7\xab\xa0\xe3\x80\x81\xe6\x96\xb0\xe9\x97\xbb\xe3\x80\x81\xe4\xb8\x80\xe4\xb8\xaa\xe8\xaf\x8d\xe6\x9d\xa1\xe7\xad\x89. document:[[\'\xe6\x98\xaf\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe5\xbe\x97\', \'\xe7\xbb\x99\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\'], [\'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'\xe3\x80\x90\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'\xe3\x80\x91\', \'\xef\xbc\x8c\', \'\xe8\x8e\xb7\', \'\xe5\x8f\x96\', \'\xe8\x82\xb2\', \'\xe5\x84\xbf\', \'\xe7\x9a\x84\', \'\xe6\x99\xba\', \'\xe6\x85\xa7\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8e\', \'\xe5\xad\xa9\', \'\xe5\xad\x90\', \'\xe4\xb8\x80\', \'\xe5\x90\x8c\', \'\xe6\x88\x90\', \'\xe9\x95\xbf\', \'\xef\xbc\x81\'], [\'\xe6\x96\xb9\', \'\xe6\xb3\x95\', \':\', \'\xe6\x89\x93\', \'\xe5\xbc\x80\', \'\xe5\xbe\xae\', \'\xe4\xbf\xa1\', \'\xe2\x86\x92\', \'\xe6\xb7\xbb\', \'\xe5\x8a\xa0\', \'\xe6\x9c\x8b\', \'\xe5\x8f\x8b\', \'\xe2\x86\x92\', \'\xe6\x90\x9c\', \'\xe5\x8f\xb7\', \'\xe2\x86\x92\', \'##he\', \'##bc\', \'##x\', \'##jy\', \'##\xe2\x86\x92\', \'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'!\', \'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xad\x9d\', \'\xe9\xa1\xba\', \'\xe6\x98\xaf\', \'\xe5\x81\x9a\', \'\xe4\xba\xba\', \'\xe7\x9a\x84\', \'\xe7\xac\xac\', \'\xe4\xb8\x80\', \'\xe5\x87\x86\', \'\xe5\x88\x99\', \'\xe3\x80\x82\'], [\'\xe7\x94\xad\', \'\xe7\xae\xa1\', \'\xe5\xb0\x8f\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xe6\x80\x8e\', \'\xe4\xb9\x88\', \'\xe8\xb7\x9f\', \'\xe5\xae\xb6\', \'\xe9\x95\xbf\', \'\xe7\x8a\xaf\', \'\xe6\xb7\xb7\', \'\xe8\x9b\x8b\', \'\xef\xbc\x8c\', \'\xe9\x95\xbf\', \'\xe5\xa4\xa7\', \'\xe4\xba\x86\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe5\xba\x95\', \'\xe6\x8a\xa5\', \'\xe7\xad\x94\', \'\xe7\x88\xb6\', \'\xe6\xaf\x8d\', \'\xef\xbc\x8c\', \'\xe4\xbb\xa5\', \'\xe5\x90\x8e\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe4\xb9\x9f\', \'\xe5\xbf\x85\', \'\xe9\xa1\xbb\', \'\xe5\xad\x9d\', \'\xe9\xa1\xba\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe8\x8a\xb1\', \'\xe5\xbf\x83\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe5\xa5\xbd\', \'\xe7\x8e\xa9\', \'\xe3\x80\x82\'], [\'\xe4\xbd\x86\', \'\xe6\x88\x91\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe4\xbc\x9a\', \'\xe6\x89\xbe\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe7\xae\xa1\', \'\xe7\x9a\x84\', \'\xe4\xbd\x8f\', \'\xe6\x88\x91\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xef\xbc\x8c\', \'\xe5\x92\x8c\', \'\xe6\x88\x91\', \'\xe4\xb8\x80\', \'\xe8\xb5\xb7\', \'\xe7\x94\x9f\', \'\xe6\xb4\xbb\', \'\xe3\x80\x82\'], [\'28\', \'\xe5\xb2\x81\', \'\xe4\xbb\xa5\', \'\xe5\x89\x8d\', \'\xe5\x9c\xa8\', \'\xe6\x80\x8e\', \'\xe4\xb9\x88\', \'\xe7\x8e\xa9\', \'\xe9\x83\xbd\', \'\xe8\xa1\x8c\', \'\xef\xbc\x8c\', \'\xe4\xbd\x86\', \'\xe6\x88\x91\', \'\xe6\x9c\x80\', \'\xe5\x90\x8e\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe4\xbc\x9a\', \'\xe6\x89\xbe\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe5\x8b\xa4\', \'\xe4\xbf\xad\', \'\xe6\x8c\x81\', \'\xe5\xae\xb6\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xb8\x8d\', \'\xe4\xbc\x9a\', \'\xe8\xae\xa9\', \'\xe8\x87\xaa\', \'\xe5\xb7\xb1\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe5\x8f\x97\', \'\xe4\xb8\x80\', \'\xe7\x82\xb9\', \'\xe5\xa7\x94\', \'\xe5\xb1\x88\', \'\xef\xbc\x8c\', \'\xe6\xaf\x8f\', \'\xe6\xac\xa1\', \'\xe6\x8a\x8a\', \'\xe5\xa5\xb9\', \'\xe6\x8a\xb1\', \'\xe5\x9c\xa8\', \'\xe6\x80\x80\', \'\xe9\x87\x8c\', \'\xef\xbc\x8c\', \'\xe7\x9c\x8b\', \'\xe5\xa5\xb9\', \'\xe6\xb4\x8b\', \'\xe6\xba\xa2\', \'\xe7\x9d\x80\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe7\x9a\x84\', \'\xe8\x84\xb8\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe9\x83\xbd\', \'\xe4\xbc\x9a\', \'\xe5\xbc\x95\', \'\xe4\xbb\xa5\', \'\xe4\xb8\xba\', \'\xe5\x82\xb2\', \'\xef\xbc\x8c\', \'\xe8\xbf\x99\', \'\xe7\x89\xb9\', \'\xe4\xb9\x88\', \'\xe5\xb0\xb1\', \'\xe6\x98\xaf\', \'\xe6\x88\x91\', \'\xe7\x9a\x84\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xb9\xb2\', \'\xe4\xbb\x80\', \'\xe4\xb9\x88\', \'\xe4\xb9\x9f\', \'\xe4\xb8\x8d\', \'\xe8\x83\xbd\', \'\xe5\xbf\x98\', \'\xe4\xba\x86\', \'\xe8\x87\xaa\', \'\xe5\xb7\xb1\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe7\xae\x97\', \'\xe5\x92\x8c\', \'\xe5\x93\xa5\', \'\xe4\xbb\xac\', \'\xe4\xb8\x80\', \'\xe8\xb5\xb7\', \'\xe5\x96\x9d\', \'\xe9\x85\x92\', \'\xef\xbc\x8c\', \'\xe5\x96\x9d\', \'\xe5\x88\xb0\', \'\xe5\xbe\x88\', \'\xe6\x99\x9a\', \'\xef\xbc\x8c\', \'\xe4\xb9\x9f\', \'\xe8\xa6\x81\', \'\xe6\x8f\x90\', \'\xe5\x89\x8d\', \'\xe6\x89\x93\', \'\xe7\x94\xb5\', \'\xe8\xaf\x9d\', \'\xe5\x91\x8a\', \'\xe8\xaf\x89\', \'\xe5\xa5\xb9\', \'\xef\xbc\x8c\', \'\xe8\xae\xa9\', \'\xe5\xa5\xb9\', \'\xe6\x97\xa9\', \'\xe7\x82\xb9\', \'\xe4\xbc\x91\', \'\xe6\x81\xaf\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe4\xb8\x8d\', \'\xe8\x83\xbd\', \'\xe6\x8a\xbd\', \'\xe7\x83\x9f\', \'\xef\xbc\x8c\', \'\xe5\x96\x9d\', \'\xe9\x85\x92\', \'\xe8\xbf\x98\', \'\xe5\x8b\x89\', \'\xe5\xbc\xba\', \'\xe8\xbf\x87\', \'\xe5\xbe\x97\', \'\xe5\x8e\xbb\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe8\xbf\x87\', \'\xe8\xaf\xa5\', \'\xe5\x96\x9d\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xe5\x96\x9d\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe8\xaf\xa5\', \'\xe5\x96\x9d\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xef\xbc\x8c\', \'\xe5\xb0\x91\', \'\xe6\x89\xaf\', \'\xe7\xba\xb3\', \'\xe6\x9e\x81\', \'\xe8\x96\x84\', \'\xe8\x9b\x8b\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\xbf\x85\', \'\xe9\xa1\xbb\', \'\xe5\x90\xac\', \'\xe6\x88\x91\', \'\xe8\xaf\x9d\', \'\xef\xbc\x8c\', \'\xe5\x9c\xa8\', \'\xe4\xba\xba\', \'\xe5\x89\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe8\xa6\x81\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe9\x9d\xa2\', \'\xe5\xad\x90\', \'\xef\xbc\x8c\', \'\xe5\x9b\x9e\', \'\xe5\xae\xb6\', \'\xe4\xba\x86\', \'\xe5\x92\xb1\', \'\xe4\xbb\x80\', \'\xe4\xb9\x88\', \'\xe9\x83\xbd\', \'\xe5\xa5\xbd\', \'\xe8\xaf\xb4\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\xb0\xb1\', \'\xe7\xae\x97\', \'\xe9\x9a\xbe\', \'\xe7\x9a\x84\', \'\xe5\x90\x83\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x8a\', \'\xe9\xa5\xad\', \'\xe4\xba\x86\', \'\xef\xbc\x8c\', \'\xe9\x83\xbd\', \'\xe4\xb8\x8d\', \'\xe5\xbc\xa0\', \'\xe5\x8f\xa3\', \'\xe8\xb7\x9f\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe8\xa6\x81\', \'\xe4\xb8\x80\', \'\xe5\x88\x86\', \'\xe9\x92\xb1\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe7\xae\xa1\', \'\xe4\xb8\x8a\', \'\xe5\xad\xa6\', \'\xe8\xbf\x98\', \'\xe6\x98\xaf\', \'\xe4\xb8\x8a\', \'\xe7\x8f\xad\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe9\x83\xbd\', \'\xe4\xbc\x9a\', \'\xe9\x80\x81\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\x9b\x9e\', \'\xe5\xae\xb6\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xba\xa4\', \'\xe5\xbe\x80\', \'\xe4\xb8\x8d\', \'\xe5\x88\xb0\', \'1\', \'\xe5\xb9\xb4\', \'\xef\xbc\x8c\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe4\xb8\x8d\', \'\xe4\xbc\x9a\', \'\xe5\x92\x8c\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x8f\x90\', \'\xe8\xbf\x87\', \'\xe5\x88\x86\', \'\xe7\x9a\x84\', \'\xe8\xa6\x81\', \'\xe6\xb1\x82\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe5\xb0\x8a\', \'\xe9\x87\x8d\', \'\xe5\xa5\xb9\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\xb8\xb8\', \'\xe6\x88\x8f\', \'\xe6\xb0\xb8\', \'\xe8\xbf\x9c\', \'\xe6\xaf\x94\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x8a\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe9\x87\x8d\', \'\xe8\xa6\x81\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaa\', \'\xe8\xa6\x81\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\x8f\x91\', \'\xe8\xaf\x9d\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe5\x94\xaf\', \'\xe5\x91\xbd\', \'\xe6\x98\xaf\', \'\xe4\xbb\x8e\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8a\', \'q\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe6\x98\xaf\', \'\xe4\xb8\xba\', \'\xe4\xba\x86\', \'\xe7\xad\x89\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xef\xbc\x8c\', \'\xe6\x89\x80\', \'\xe6\x9c\x89\', \'\xe6\x9a\xa7\', \'\xe6\x98\xa7\', \'\xe7\x9a\x84\', \'\xe5\xbf\x83\', \'\xe6\x83\x85\', \'\xe5\x8f\xaa\', \'\xe4\xb8\xba\', \'\xe5\xa5\xb9\', \'\xe4\xb8\x80\', \'\xe4\xb8\xaa\', \'\xe5\xa5\xb3\', \'\xe4\xba\xba\', \'\xe8\x80\x8c\', \'\xe5\x86\x99\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x8f\', \'\xe5\xb8\xb8\', \'\xe5\x86\x99\', \'\xe6\x97\xa5\', \'\xe5\xbf\x97\', \'\xef\xbc\x8c\', \'\xe5\x8f\xaf\', \'\xe6\x98\xaf\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe5\x91\x8a\', \'\xe8\xaf\x89\', \'\xe5\x85\xa8\', \'\xe4\xb8\x96\', \'\xe7\x95\x8c\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe5\xbe\x88\', \'\xe7\x88\xb1\', \'\xe5\xa5\xb9\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe8\xa6\x81\', \'\xe7\xbb\x8f\', \'\xe5\xb8\xb8\', \'\xe5\x88\xb6\', \'\xe9\x80\xa0\', \'\xe6\xb5\xaa\', \'\xe6\xbc\xab\', \'\xe3\x80\x81\', \'\xe5\x81\xb6\', \'\xe5\xb0\x94\', \'\xe8\xbf\x87\', \'\xe4\xb8\xaa\', \'\xe8\x8a\x82\', \'\xe6\x97\xa5\', \'\xe4\xb9\x9f\', \'\xe8\xa6\x81\', \'\xe9\x80\x81\', \'\xe6\x9d\x9f\', \'\xe7\x8e\xab\', \'\xe7\x91\xb0\', \'\xe8\x8a\xb1\', \'\xe7\xbb\x99\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x8a\xb1\', \'\xe5\x9b\x9e\', \'\xe5\xae\xb6\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x89\x8b\', \'\xe6\x9c\xba\', \'\xe4\xbc\x9a\', \'24\', \'\xe5\xb0\x8f\', \'\xe6\x97\xb6\', \'\xe4\xb8\xba\', \'\xe5\xa5\xb9\', \'\xe5\xbc\x80\', \'\xe6\x9c\xba\', \'\xef\xbc\x8c\', \'\xe8\xae\xa9\', \'\xe5\xa5\xb9\', \'\xe5\x8d\x8a\', \'\xe5\xa4\x9c\', \'\xe7\x97\x9b\', \'\xe7\xbb\x8f\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xef\xbc\x8c\', \'\xe5\x81\x9a\', \'\xe6\x81\xb6\', \'\xe6\xa2\xa6\', \'\xe7\x9a\x84\', \'\xe6\x97\xb6\', \'\xe5\x80\x99\', \'\xef\xbc\x8c\', \'\xe9\x9a\x8f\', \'\xe6\x97\xb6\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe8\x81\x94\', \'\xe7\xb3\xbb\', \'\xe5\x88\xb0\', \'\xe6\x88\x91\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x8f\', \'\xe5\xb8\xb8\', \'\xe5\xb8\xa6\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\x87\xba\', \'\xe5\x8e\xbb\', \'\xe7\x8e\xa9\', \'\xef\xbc\x8c\', \'\xe5\xa5\xb9\', \'\xe4\xb8\x8d\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe8\xa6\x81\', \'\xe5\x92\x8c\', \'\xe6\x88\x91\', \'\xe6\x89\x80\', \'\xe6\x9c\x89\', \'\xe7\x9a\x84\', \'\xe5\x93\xa5\', \'\xe4\xbb\xac\', \'\xe9\x83\xbd\', \'\xe8\xae\xa4\', \'\xe8\xaf\x86\', \'\xef\xbc\x8c\', \'\xe4\xbd\x86\', \'\xe8\xa7\x81\', \'\xe9\x9d\xa2\', \'\xe8\x83\xbd\', \'\xe8\xaf\xb4\', \'\xe7\x9a\x84\', \'\xe4\xb8\x8a\', \'\xe8\xaf\x9d\', \'\xe5\xb0\xb1\', \'\xe8\xa1\x8c\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe5\x92\x8c\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe7\x9a\x84\', \'\xe5\xa7\x90\', \'\xe5\xa6\xb9\', \'\xe5\x93\xa5\', \'\xe4\xbb\xac\', \'\xe6\x90\x9e\', \'\xe5\xa5\xbd\', \'\xe5\x85\xb3\', \'\xe7\xb3\xbb\', \'\xef\xbc\x8c\', \'\xe8\xae\xa9\', \'\xe5\xa5\xb9\', \'\xe4\xbb\xac\', \'\xe7\x9b\xb8\', \'\xe4\xbf\xa1\', \'\xe6\x88\x91\', \'\xe4\xb8\x80\', \'\xe5\xae\x9a\', \'\xe5\x8f\xaf\', \'\xe4\xbb\xa5\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe5\x90\xb5\', \'\xe6\x9e\xb6\', \'\xe5\x90\x8e\', \'\xe3\x80\x81\', \'\xe4\xb9\x9f\', \'\xe8\xa6\x81\', \'\xe4\xb8\xbb\', \'\xe5\x8a\xa8\', \'\xe6\x89\x93\', \'\xe7\x94\xb5\', \'\xe8\xaf\x9d\', \'\xe5\x85\xb3\', \'\xe5\xbf\x83\', \'\xe5\xa5\xb9\', \'\xef\xbc\x8c\', \'\xe5\x92\xb1\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe7\xbb\x99\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x9c\x8d\', \'\xe4\xb8\xaa\', \'\xe8\xbd\xaf\', \'\xef\xbc\x8c\', \'\xe9\x81\x93\', \'\xe4\xb8\xaa\', \'\xe6\xad\x89\', \'\xe6\x80\x8e\', \'\xe4\xb9\x88\', \'\xe4\xba\x86\', \'\xef\xbc\x9f\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe7\xbb\x9d\', \'\xe5\xaf\xb9\', \'\xe4\xb8\x8d\', \'\xe4\xbc\x9a\', \'\xe5\xab\x8c\', \'\xe5\xbc\x83\', \'\xe8\x87\xaa\', \'\xe5\xb7\xb1\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xef\xbc\x8c\', \'\xe6\x8b\xbf\', \'\xe5\xa5\xb9\', \'\xe5\x92\x8c\', \'\xe5\x88\xab\', \'\xe4\xba\xba\', \'\xe6\xaf\x94\', \'\xef\xbc\x8c\', \'\xe8\xaf\xb4\', \'\xe5\xa5\xb9\', \'\xe8\xbf\x99\', \'\xe4\xb8\x8d\', \'\xe5\xa6\x82\', \'\xe4\xba\xba\', \'\xe5\xae\xb6\', \'\xef\xbc\x8c\', \'\xe7\xba\xb3\', \'\xe4\xb8\x8d\', \'\xe5\xa6\x82\', \'\xe4\xba\xba\', \'\xe5\xae\xb6\', \'\xe7\x9a\x84\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe9\x99\xaa\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe9\x80\x9b\', \'\xe8\xa1\x97\', \'\xe6\x97\xb6\', \'\xef\xbc\x8c\', \'\xe7\xa2\xb0\', \'\xe8\xa7\x81\', \'\xe7\x86\x9f\', \'\xe4\xba\xba\', \'\xef\xbc\x8c\', \'\xe6\x97\xa0\', \'\xe8\xae\xba\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe9\x95\xbf\', \'\xe7\x9a\x84\', \'\xe5\xa5\xbd\', \'\xe7\x9c\x8b\', \'\xe4\xb8\x8e\', \'\xe5\x90\xa6\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe9\x83\xbd\', \'\xe4\xbc\x9a\', \'\xe5\xa4\xa7\', \'\xe6\x96\xb9\', \'\xe7\x9a\x84\', \'\xe4\xbb\x8b\', \'\xe7\xbb\x8d\', \'\xe3\x80\x82\'], [\'\xe8\xb0\x81\', \'\xe8\xae\xa9\', \'\xe5\x92\xb1\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xe5\xb0\xb1\', \'\xe5\xa5\xbd\', \'\xe8\xbf\x99\', \'\xe5\x8f\xa3\', \'\xe5\x91\xa2\', \'\xe3\x80\x82\'], [\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe6\x83\xb3\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x9c\x80\', \'\xe5\xa5\xbd\', \'\xe7\x9a\x84\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe3\x80\x82\'], [\'\xe3\x80\x90\', \'\xe6\x88\x91\', \'\xe4\xbb\xac\', \'\xe9\x87\x8d\', \'\xe5\x9c\xa8\', \'\xe5\x88\x86\', \'\xe4\xba\xab\', \'\xe3\x80\x82\'], [\'\xe6\x89\x80\', \'\xe6\x9c\x89\', \'\xe6\x96\x87\', \'\xe5\xad\x97\', \'\xe5\x92\x8c\', \'\xe7\xbe\x8e\', \'\xe5\x9b\xbe\', \'\xef\xbc\x8c\', \'\xe6\x9d\xa5\', \'\xe8\x87\xaa\', \'\xe7\xbd\x91\', \'\xe7\xbb\x9c\', \'\xef\xbc\x8c\', \'\xe6\x99\xa8\', \'\xe6\xac\xa3\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'\xe6\x95\xb4\', \'\xe7\x90\x86\', \'\xe3\x80\x82\'], [\'\xe5\xaf\xb9\', \'\xe5\x8e\x9f\', \'\xe6\x96\x87\', \'\xe4\xbd\x9c\', \'\xe8\x80\x85\', \'\xef\xbc\x8c\', \'\xe8\xa1\xa8\', \'\xe7\xa4\xba\', \'\xe6\x95\xac\', \'\xe6\x84\x8f\', \'\xe3\x80\x82\'], [\'\xe3\x80\x91\', \'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'[UNK]\', \'[UNK]\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'\xef\xbc\x88\', \'\xe5\xbe\xae\', \'\xe4\xbf\xa1\', \'\xe5\x8f\xb7\', \'\xef\xbc\x9a\', \'he\', \'##bc\', \'##x\', \'##jy\', \'\xef\xbc\x89\', \'\xe3\x80\x82\'], [\'\xe6\x89\x93\', \'\xe5\xbc\x80\', \'\xe5\xbe\xae\', \'\xe4\xbf\xa1\', \'\xef\xbc\x8c\', \'\xe6\x89\xab\', \'\xe6\x8f\x8f\', \'\xe4\xba\x8c\', \'\xe7\xbb\xb4\', \'\xe7\xa0\x81\', \'\xef\xbc\x8c\', \'\xe5\x85\xb3\', \'\xe6\xb3\xa8\', \'[UNK]\', \'\xe6\x99\xa8\', \'\xe6\x9b\xa6\', \'\xe6\x95\x99\', \'\xe8\x82\xb2\', \'[UNK]\', \'\xef\xbc\x8c\', \'\xe8\x8e\xb7\', \'\xe5\x8f\x96\', \'\xe6\x9b\xb4\', \'\xe5\xa4\x9a\', \'\xe8\x82\xb2\', \'\xe5\x84\xbf\', \'\xe8\xb5\x84\', \'\xe6\xba\x90\', \'\xe3\x80\x82\'], [\'\xe7\x82\xb9\', \'\xe5\x87\xbb\', \'\xe4\xb8\x8b\', \'\xe9\x9d\xa2\', \'\xe8\xae\xa2\', \'\xe9\x98\x85\', \'\xe6\x8c\x89\', \'\xe9\x92\xae\', \'\xe8\xae\xa2\', \'\xe9\x98\x85\', \'\xef\xbc\x8c\', \'\xe4\xbc\x9a\', \'\xe6\x9c\x89\', \'\xe6\x9b\xb4\', \'\xe5\xa4\x9a\', \'\xe6\x83\x8a\', \'\xe5\x96\x9c\', \'\xe5\x93\xa6\', \'\xef\xbc\x81\']]\n  while i < len(document): # \xe4\xbb\x8e\xe6\x96\x87\xe6\xa1\xa3\xe7\x9a\x84\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe4\xbd\x8d\xe7\xbd\xae\xe5\xbc\x80\xe5\xa7\x8b\xef\xbc\x8c\xe6\x8c\x89\xe4\xb8\xaa\xe5\xbe\x80\xe4\xb8\x8b\xe7\x9c\x8b\n    segment = document[i] # segment\xe6\x98\xaf\xe5\x88\x97\xe8\xa1\xa8\xef\xbc\x8c\xe4\xbb\xa3\xe8\xa1\xa8\xe7\x9a\x84\xe6\x98\xaf\xe6\x8c\x89\xe5\xad\x97\xe5\x88\x86\xe5\xbc\x80\xe7\x9a\x84\xe4\xb8\x80\xe4\xb8\xaa\xe5\xae\x8c\xe6\x95\xb4\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe5\xa6\x82 segment=[\'\xe6\x88\x91\', \'\xe6\x98\xaf\', \'\xe4\xb8\x80\', \'\xe7\x88\xb7\', \'\xe4\xbb\xac\', \'\xef\xbc\x8c\', \'\xe6\x88\x91\', \'\xe6\x83\xb3\', \'\xe6\x88\x91\', \'\xe4\xbc\x9a\', \'\xe7\xbb\x99\', \'\xe6\x88\x91\', \'\xe5\xaa\xb3\', \'\xe5\xa6\x87\', \'\xe6\x9c\x80\', \'\xe5\xa5\xbd\', \'\xe7\x9a\x84\', \'\xe5\xb9\xb8\', \'\xe7\xa6\x8f\', \'\xe3\x80\x82\']\n    # print(""###i:"",i,"";segment:"",segment)\n    current_chunk.append(segment) # \xe5\xb0\x86\xe4\xb8\x80\xe4\xb8\xaa\xe7\x8b\xac\xe7\xab\x8b\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\xe5\x8a\xa0\xe5\x85\xa5\xe5\x88\xb0\xe5\xbd\x93\xe5\x89\x8d\xe7\x9a\x84\xe6\x96\x87\xe6\x9c\xac\xe5\x9d\x97\xe4\xb8\xad\n    current_length += len(segment) # \xe7\xb4\xaf\xe8\xae\xa1\xe5\x88\xb0\xe4\xb8\xba\xe6\xad\xa2\xe4\xbd\x8d\xe7\xbd\xae\xe6\x8e\xa5\xe8\xa7\xa6\xe5\x88\xb0\xe5\x8f\xa5\xe5\xad\x90\xe7\x9a\x84\xe6\x80\xbb\xe9\x95\xbf\xe5\xba\xa6\n    if i == len(document) - 1 or current_length >= target_seq_length: # \xe5\xa6\x82\xe6\x9e\x9c\xe7\xb4\xaf\xe8\xae\xa1\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\xe9\x95\xbf\xe5\xba\xa6\xe8\xbe\xbe\xe5\x88\xb0\xe4\xba\x86\xe7\x9b\xae\xe6\xa0\x87\xe7\x9a\x84\xe9\x95\xbf\xe5\xba\xa6==>\xe6\x9e\x84\xe9\x80\xa0\xe5\xb9\xb6\xe6\xb7\xbb\xe5\x8a\xa0\xe5\x88\xb0\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84A\xe5\x92\x8cB\xe4\xb8\xad\xe3\x80\x82\n      if current_chunk: # \xe5\xa6\x82\xe6\x9e\x9c\xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\xe4\xb8\x8d\xe4\xb8\xba\xe7\xa9\xba\n        # `a_end` is how many segments from `current_chunk` go into the `A`\n        # (first) sentence.\n        a_end = 1\n        if len(current_chunk) >= 2: # \xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe5\x8c\x85\xe5\x90\xab\xe8\xb6\x85\xe8\xbf\x87\xe4\xb8\xa4\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe6\x80\x8e\xe5\x8f\x96\xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\xe7\x9a\x84\xe4\xb8\x80\xe9\x83\xa8\xe5\x88\x86\xe4\xbd\x9c\xe4\xb8\xba\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84A\xe9\x83\xa8\xe5\x88\x86\n          a_end = rng.randint(1, len(current_chunk) - 1)\n        # \xe5\xb0\x86\xe5\xbd\x93\xe5\x89\x8d\xe6\x96\x87\xe6\x9c\xac\xe6\xae\xb5\xe4\xb8\xad\xe9\x80\x89\xe5\x8f\x96\xe5\x87\xba\xe6\x9d\xa5\xe7\x9a\x84\xe5\x89\x8d\xe5\x8d\x8a\xe9\x83\xa8\xe5\x88\x86\xef\xbc\x8c\xe8\xb5\x8b\xe5\x80\xbc\xe7\xbb\x99A\xe5\x8d\xb3tokens_a\n        tokens_a = []\n        for j in range(a_end):\n          tokens_a.extend(current_chunk[j])\n\n        # \xe6\x9e\x84\xe9\x80\xa0\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84B\xe9\x83\xa8\xe5\x88\x86(\xe5\x8e\x9f\xe6\x9c\xac\xe7\x9a\x84B\xe6\x9c\x89\xe4\xb8\x80\xe9\x83\xa8\xe5\x88\x86\xe6\x98\xaf\xe9\x9a\x8f\xe6\x9c\xba\xe7\x9a\x84\xe4\xbb\x8e\xe5\x8f\xa6\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe9\x80\x89\xe5\x8f\x96\xe7\x9a\x84\xef\xbc\x8c\xe6\x9c\x89\xe4\xb8\x80\xe9\x83\xa8\xe5\x88\x86\xe6\x98\xaf\xe6\xad\xa3\xe5\xb8\xb8\xe7\x9a\x84\xe5\xbd\x93\xe5\x89\x8d\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe7\x9a\x84\xe5\x90\x8e\xe5\x8d\x8a\xe9\x83\xa8\xef\xbc\x89\n        tokens_b = []\n        # Random next\n        is_random_next = False\n        if len(current_chunk) == 1 or rng.random() < 0.5: # \xe6\x9c\x8950%\xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xef\xbc\x8c\xe6\x98\xaf\xe4\xbb\x8e\xe5\x85\xb6\xe4\xbb\x96\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe9\x9a\x8f\xe6\x9c\xba\xe7\x9a\x84\xe9\x80\x89\xe5\x8f\x96\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xef\xbc\x8c\xe5\xb9\xb6\xe5\xbe\x97\xe5\x88\xb0\xe8\xbf\x99\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe7\x9a\x84\xe5\x90\x8e\xe5\x8d\x8a\xe7\x89\x88\xe6\x9c\xac\xe4\xbd\x9c\xe4\xb8\xbaB\xe5\x8d\xb3tokens_b\n          is_random_next = True\n          target_b_length = target_seq_length - len(tokens_a)\n\n          # This should rarely go for more than one iteration for large\n          # corpora. However, just to be careful, we try to make sure that\n          # the random document is not the same as the document\n          # we\'re processing.\n          random_document_index=0\n          for _ in range(10): # \xe9\x9a\x8f\xe6\x9c\xba\xe7\x9a\x84\xe9\x80\x89\xe5\x87\xba\xe4\xb8\x80\xe4\xb8\xaa\xe4\xb8\x8e\xe5\xbd\x93\xe5\x89\x8d\xe7\x9a\x84\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\x8d\xe4\xb8\x80\xe6\xa0\xb7\xe7\x9a\x84\xe6\x96\x87\xe6\xa1\xa3\xe7\x9a\x84\xe7\xb4\xa2\xe5\xbc\x95\n            random_document_index = rng.randint(0, len(all_documents) - 1)\n            if random_document_index != document_index:\n              break\n\n          random_document = all_documents[random_document_index] # \xe9\x80\x89\xe5\x87\xba\xe8\xbf\x99\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\n          random_start = rng.randint(0, len(random_document) - 1) # \xe4\xbb\x8e\xe8\xbf\x99\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe9\x80\x89\xe5\x87\xba\xe4\xb8\x80\xe4\xb8\xaa\xe6\xae\xb5\xe8\x90\xbd\xe7\x9a\x84\xe5\xbc\x80\xe5\xa7\x8b\xe4\xbd\x8d\xe7\xbd\xae\n          for j in range(random_start, len(random_document)): # \xe4\xbb\x8e\xe8\xbf\x99\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe7\x9a\x84\xe5\xbc\x80\xe5\xa7\x8b\xe4\xbd\x8d\xe7\xbd\xae\xe5\x88\xb0\xe7\xbb\x93\xe6\x9d\x9f\xef\xbc\x8c\xe4\xbd\x9c\xe4\xb8\xba\xe6\x88\x91\xe4\xbb\xac\xe7\x9a\x84\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84B\xe5\x8d\xb3tokens_b\n            tokens_b.extend(random_document[j])\n            if len(tokens_b) >= target_b_length:\n              break\n          # We didn\'t actually use these segments so we ""put them back"" so\n          # they don\'t go to waste. \xe8\xbf\x99\xe9\x87\x8c\xe6\x98\xaf\xe4\xb8\xba\xe4\xba\x86\xe9\x98\xb2\xe6\xad\xa2\xe6\x96\x87\xe6\x9c\xac\xe7\x9a\x84\xe6\xb5\xaa\xe8\xb4\xb9\xe7\x9a\x84\xe4\xb8\x80\xe4\xb8\xaa\xe5\xb0\x8f\xe6\x8a\x80\xe5\xb7\xa7\n          num_unused_segments = len(current_chunk) - a_end # e.g. 550-200=350\n          i -= num_unused_segments # i=i-num_unused_segments, e.g. i=400, num_unused_segments=350, \xe9\x82\xa3\xe4\xb9\x88 i=i-num_unused_segments=400-350=50\n        # Actual next\n        else: # \xe6\x9c\x89\xe5\x8f\xa6\xe5\xa4\x9650%\xe7\x9a\x84\xe5\x87\xa0\xe4\xb9\x8e\xef\xbc\x8c\xe4\xbb\x8e\xe5\xbd\x93\xe5\x89\x8d\xe6\x96\x87\xe6\x9c\xac\xe5\x9d\x97\xef\xbc\x88\xe9\x95\xbf\xe5\xba\xa6\xe4\xb8\xbamax_sequence_length\xef\xbc\x89\xe4\xb8\xad\xe7\x9a\x84\xe5\x90\x8e\xe6\xae\xb5\xe4\xb8\xad\xe5\xa1\xab\xe5\x85\x85\xe5\x88\xb0tokens_b\xe5\x8d\xb3\xe2\x80\x9cA[SEP]B\xe2\x80\x9c\xe4\xb8\xad\xe7\x9a\x84B\xe3\x80\x82\n          is_random_next = False\n          for j in range(a_end, len(current_chunk)):\n            tokens_b.extend(current_chunk[j])\n        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n        assert len(tokens_a) >= 1\n        assert len(tokens_b) >= 1\n\n        # \xe6\x8a\x8atokens_a & tokens_b\xe5\x8a\xa0\xe5\x85\xa5\xe5\x88\xb0\xe6\x8c\x89\xe7\x85\xa7bert\xe7\x9a\x84\xe9\xa3\x8e\xe6\xa0\xbc\xef\xbc\x8c\xe5\x8d\xb3\xe4\xbb\xa5[CLS]tokens_a[SEP]tokens_b[SEP]\xe7\x9a\x84\xe5\xbd\xa2\xe5\xbc\x8f\xef\xbc\x8c\xe7\xbb\x93\xe5\x90\x88\xe5\x88\xb0\xe4\xb8\x80\xe8\xb5\xb7\xef\xbc\x8c\xe4\xbd\x9c\xe4\xb8\xba\xe6\x9c\x80\xe7\xbb\x88\xe7\x9a\x84tokens; \xe4\xb9\x9f\xe5\xb8\xa6\xe4\xb8\x8asegment_ids\xef\xbc\x8c\xe5\x89\x8d\xe9\x9d\xa2\xe9\x83\xa8\xe5\x88\x86segment_ids\xe7\x9a\x84\xe5\x80\xbc\xe6\x98\xaf0\xef\xbc\x8c\xe5\x90\x8e\xe9\x9d\xa2\xe9\x83\xa8\xe5\x88\x86\xe7\x9a\x84\xe5\x80\xbc\xe6\x98\xaf1.\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n          tokens.append(token)\n          segment_ids.append(0)\n\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        for token in tokens_b:\n          tokens.append(token)\n          segment_ids.append(1)\n        tokens.append(""[SEP]"")\n        segment_ids.append(1)\n\n        # \xe5\x88\x9b\xe5\xbb\xbamasked LM\xe7\x9a\x84\xe4\xbb\xbb\xe5\x8a\xa1\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae Creates the predictions for the masked LM objective\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance( # \xe5\x88\x9b\xe5\xbb\xba\xe8\xae\xad\xe7\xbb\x83\xe5\xae\x9e\xe4\xbe\x8b\xe7\x9a\x84\xe5\xaf\xb9\xe8\xb1\xa1\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n      current_chunk = [] # \xe6\xb8\x85\xe7\xa9\xba\xe5\xbd\x93\xe5\x89\x8d\xe5\x9d\x97\n      current_length = 0 # \xe9\x87\x8d\xe7\xbd\xae\xe5\xbd\x93\xe5\x89\x8d\xe6\x96\x87\xe6\x9c\xac\xe5\x9d\x97\xe7\x9a\x84\xe9\x95\xbf\xe5\xba\xa6\n    i += 1 # \xe6\x8e\xa5\xe7\x9d\x80\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe7\x9a\x84\xe5\x86\x85\xe5\xae\xb9\xe5\xbe\x80\xe5\x90\x8e\xe7\x9c\x8b\n\n  return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n  """"""Creates the predictions for the masked LM objective.""""""\n\n  cand_indexes = []\n  for (i, token) in enumerate(tokens):\n    if token == ""[CLS]"" or token == ""[SEP]"":\n      continue\n    # Whole Word Masking means that if we mask all of the wordpieces\n    # corresponding to an original word. When a word has been split into\n    # WordPieces, the first token does not have any marker and any subsequence\n    # tokens are prefixed with ##. So whenever we see the ## token, we\n    # append it to the previous set of word indexes.\n    #\n    # Note that Whole Word Masking does *not* change the training code\n    # at all -- we still predict each WordPiece independently, softmaxed\n    # over the entire vocabulary.\n    if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n            token.startswith(""##"")):\n      cand_indexes[-1].append(i)\n    else:\n      cand_indexes.append([i])\n\n  rng.shuffle(cand_indexes)\n\n  if FLAGS.non_chinese==False: # if non chinese is False, that means it is chinese, then try to remove ""##"" which is added previously\n    output_tokens = [t[2:] if len(re.findall(\'##[\\u4E00-\\u9FA5]\', t)) > 0 else t for t in tokens]  # \xe5\x8e\xbb\xe6\x8e\x89""##""\n  else: # english and other language, which is not chinese\n    output_tokens = list(tokens)\n\n  num_to_predict = min(max_predictions_per_seq,\n                       max(1, int(round(len(tokens) * masked_lm_prob))))\n\n  masked_lms = []\n  covered_indexes = set()\n  for index_set in cand_indexes:\n    if len(masked_lms) >= num_to_predict:\n      break\n    # If adding a whole-word mask would exceed the maximum number of\n    # predictions, then just skip this candidate.\n    if len(masked_lms) + len(index_set) > num_to_predict:\n      continue\n    is_any_index_covered = False\n    for index in index_set:\n      if index in covered_indexes:\n        is_any_index_covered = True\n        break\n    if is_any_index_covered:\n      continue\n    for index in index_set:\n      covered_indexes.add(index)\n\n      masked_token = None\n      # 80% of the time, replace with [MASK]\n      if rng.random() < 0.8:\n        masked_token = ""[MASK]""\n      else:\n        # 10% of the time, keep original\n        if rng.random() < 0.5:\n          if FLAGS.non_chinese == False: # if non chinese is False, that means it is chinese, then try to remove ""##"" which is added previously\n            masked_token = tokens[index][2:] if len(re.findall(\'##[\\u4E00-\\u9FA5]\', tokens[index])) > 0 else tokens[index]  # \xe5\x8e\xbb\xe6\x8e\x89""##""\n          else:\n            masked_token = tokens[index]\n        # 10% of the time, replace with random word\n        else:\n          masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n      output_tokens[index] = masked_token\n\n      masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n  assert len(masked_lms) <= num_to_predict\n  masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n  masked_lm_positions = []\n  masked_lm_labels = []\n  for p in masked_lms:\n    masked_lm_positions.append(p.index)\n    masked_lm_labels.append(p.label)\n\n  # tf.logging.info(\'%s\' % (tokens))\n  # tf.logging.info(\'%s\' % (output_tokens))\n  return (output_tokens, masked_lm_positions, masked_lm_labels)\n\ndef create_masked_lm_predictions_original(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n  """"""Creates the predictions for the masked LM objective.""""""\n\n  cand_indexes = []\n  for (i, token) in enumerate(tokens):\n    if token == ""[CLS]"" or token == ""[SEP]"":\n      continue\n    # Whole Word Masking means that if we mask all of the wordpieces\n    # corresponding to an original word. When a word has been split into\n    # WordPieces, the first token does not have any marker and any subsequence\n    # tokens are prefixed with ##. So whenever we see the ## token, we\n    # append it to the previous set of word indexes.\n    #\n    # Note that Whole Word Masking does *not* change the training code\n    # at all -- we still predict each WordPiece independently, softmaxed\n    # over the entire vocabulary.\n    if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n        token.startswith(""##"")):\n      cand_indexes[-1].append(i)\n    else:\n      cand_indexes.append([i])\n\n  rng.shuffle(cand_indexes)\n\n  output_tokens = list(tokens)\n\n  num_to_predict = min(max_predictions_per_seq,\n                       max(1, int(round(len(tokens) * masked_lm_prob))))\n\n  masked_lms = []\n  covered_indexes = set()\n  for index_set in cand_indexes:\n    if len(masked_lms) >= num_to_predict:\n      break\n    # If adding a whole-word mask would exceed the maximum number of\n    # predictions, then just skip this candidate.\n    if len(masked_lms) + len(index_set) > num_to_predict:\n      continue\n    is_any_index_covered = False\n    for index in index_set:\n      if index in covered_indexes:\n        is_any_index_covered = True\n        break\n    if is_any_index_covered:\n      continue\n    for index in index_set:\n      covered_indexes.add(index)\n\n      masked_token = None\n      # 80% of the time, replace with [MASK]\n      if rng.random() < 0.8:\n        masked_token = ""[MASK]""\n      else:\n        # 10% of the time, keep original\n        if rng.random() < 0.5:\n          masked_token = tokens[index]\n        # 10% of the time, replace with random word\n        else:\n          masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n      output_tokens[index] = masked_token\n\n      masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n  assert len(masked_lms) <= num_to_predict\n  masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n  masked_lm_positions = []\n  masked_lm_labels = []\n  for p in masked_lms:\n    masked_lm_positions.append(p.index)\n    masked_lm_labels.append(p.label)\n\n  return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n  """"""Truncates a pair of sequences to a maximum sequence length.""""""\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_num_tokens:\n      break\n\n    trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n    assert len(trunc_tokens) >= 1\n\n    # We want to sometimes truncate from the front and sometimes from the\n    # back to add more randomness and avoid biases.\n    if rng.random() < 0.5:\n      del trunc_tokens[0]\n    else:\n      trunc_tokens.pop()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Reading from input files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"", input_file)\n\n  rng = random.Random(FLAGS.random_seed)\n  instances = create_training_instances(\n      input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n      FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n      rng)\n\n  output_files = FLAGS.output_file.split("","")\n  tf.logging.info(""*** Writing to output files ***"")\n  for output_file in output_files:\n    tf.logging.info(""  %s"", output_file)\n\n  write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                  FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""output_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  tf.app.run()'"
baselines/models/albert/modeling.py,103,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The main BERT model and related functions.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport numpy as np\nimport six\nimport tensorflow as tf\nimport bert_utils\n\nclass BertConfig(object):\n  """"""Configuration for `BertModel`.""""""\n\n  def __init__(self,\n               vocab_size,\n               hidden_size=768,\n               num_hidden_layers=12,\n               num_attention_heads=12,\n               intermediate_size=3072,\n               hidden_act=""gelu"",\n               hidden_dropout_prob=0.1,\n               attention_probs_dropout_prob=0.1,\n               max_position_embeddings=512,\n               type_vocab_size=16,\n               initializer_range=0.02):\n    """"""Constructs BertConfig.\n\n    Args:\n      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.\n      hidden_size: Size of the encoder layers and the pooler layer.\n      num_hidden_layers: Number of hidden layers in the Transformer encoder.\n      num_attention_heads: Number of attention heads for each attention layer in\n        the Transformer encoder.\n      intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n        layer in the Transformer encoder.\n      hidden_act: The non-linear activation function (function or string) in the\n        encoder and pooler.\n      hidden_dropout_prob: The dropout probability for all fully connected\n        layers in the embeddings, encoder, and pooler.\n      attention_probs_dropout_prob: The dropout ratio for the attention\n        probabilities.\n      max_position_embeddings: The maximum sequence length that this model might\n        ever be used with. Typically set this to something large just in case\n        (e.g., 512 or 1024 or 2048).\n      type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n        `BertModel`.\n      initializer_range: The stdev of the truncated_normal_initializer for\n        initializing all weight matrices.\n    """"""\n    self.vocab_size = vocab_size\n    self.hidden_size = hidden_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.hidden_act = hidden_act\n    self.intermediate_size = intermediate_size\n    self.hidden_dropout_prob = hidden_dropout_prob\n    self.attention_probs_dropout_prob = attention_probs_dropout_prob\n    self.max_position_embeddings = max_position_embeddings\n    self.type_vocab_size = type_vocab_size\n    self.initializer_range = initializer_range\n\n  @classmethod\n  def from_dict(cls, json_object):\n    """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n    config = BertConfig(vocab_size=None)\n    for (key, value) in six.iteritems(json_object):\n      config.__dict__[key] = value\n    return config\n\n  @classmethod\n  def from_json_file(cls, json_file):\n    """"""Constructs a `BertConfig` from a json file of parameters.""""""\n    with tf.gfile.GFile(json_file, ""r"") as reader:\n      text = reader.read()\n    return cls.from_dict(json.loads(text))\n\n  def to_dict(self):\n    """"""Serializes this instance to a Python dictionary.""""""\n    output = copy.deepcopy(self.__dict__)\n    return output\n\n  def to_json_string(self):\n    """"""Serializes this instance to a JSON string.""""""\n    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass BertModel(object):\n  """"""BERT model (""Bidirectional Encoder Representations from Transformers"").\n\n  Example usage:\n\n  ```python\n  # Already been converted into WordPiece token ids\n  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])\n  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])\n  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])\n\n  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,\n    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)\n\n  model = modeling.BertModel(config=config, is_training=True,\n    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)\n\n  label_embeddings = tf.get_variable(...)\n  pooled_output = model.get_pooled_output()\n  logits = tf.matmul(pooled_output, label_embeddings)\n  ...\n  ```\n  """"""\n\n  def __init__(self,\n               config,\n               is_training,\n               input_ids,\n               input_mask=None,\n               token_type_ids=None,\n               use_one_hot_embeddings=False,\n               scope=None):\n    """"""Constructor for BertModel.\n\n    Args:\n      config: `BertConfig` instance.\n      is_training: bool. true for training model, false for eval model. Controls\n        whether dropout will be applied.\n      input_ids: int32 Tensor of shape [batch_size, seq_length].\n      input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].\n      token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      use_one_hot_embeddings: (optional) bool. Whether to use one-hot word\n        embeddings or tf.embedding_lookup() for the word embeddings.\n      scope: (optional) variable scope. Defaults to ""bert"".\n\n    Raises:\n      ValueError: The config is invalid or one of the input tensor shapes\n        is invalid.\n    """"""\n    config = copy.deepcopy(config)\n    if not is_training:\n      config.hidden_dropout_prob = 0.0\n      config.attention_probs_dropout_prob = 0.0\n\n    input_shape = get_shape_list(input_ids, expected_rank=2)\n    batch_size = input_shape[0]\n    seq_length = input_shape[1]\n\n    if input_mask is None:\n      input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    if token_type_ids is None:\n      token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    with tf.variable_scope(scope, default_name=""bert""):\n      with tf.variable_scope(""embeddings""):\n        # Perform embedding lookup on the word ids, but use stype of factorized embedding parameterization from albert. add by brightmart, 2019-09-28\n        (self.embedding_output, self.embedding_table,self.embedding_table_2) = embedding_lookup_factorized(\n            input_ids=input_ids,\n            vocab_size=config.vocab_size,\n            hidden_size=config.hidden_size,\n            embedding_size=config.embedding_size,\n            initializer_range=config.initializer_range,\n            word_embedding_name=""word_embeddings"",\n            use_one_hot_embeddings=use_one_hot_embeddings)\n\n        # Add positional embeddings and token type embeddings, then layer\n        # normalize and perform dropout.\n        self.embedding_output = embedding_postprocessor(\n            input_tensor=self.embedding_output,\n            use_token_type=True,\n            token_type_ids=token_type_ids,\n            token_type_vocab_size=config.type_vocab_size,\n            token_type_embedding_name=""token_type_embeddings"",\n            use_position_embeddings=True,\n            position_embedding_name=""position_embeddings"",\n            initializer_range=config.initializer_range,\n            max_position_embeddings=config.max_position_embeddings,\n            dropout_prob=config.hidden_dropout_prob)\n\n      with tf.variable_scope(""encoder""):\n        # This converts a 2D mask of shape [batch_size, seq_length] to a 3D\n        # mask of shape [batch_size, seq_length, seq_length] which is used\n        # for the attention scores.\n        attention_mask = create_attention_mask_from_input_mask(\n            input_ids, input_mask)\n\n        # Run the stacked transformer.\n        # `sequence_output` shape = [batch_size, seq_length, hidden_size].\n        ln_type=config.ln_type\n        print(""ln_type:"",ln_type)\n        if ln_type==\'postln\' or ln_type is None: # currently, base or large of albert used post-LN structure\n            print(""old structure of transformer.use: transformer_model,which use post-LN"")\n            self.all_encoder_layers = transformer_model(\n                input_tensor=self.embedding_output,\n                attention_mask=attention_mask,\n                hidden_size=config.hidden_size,\n                num_hidden_layers=config.num_hidden_layers,\n                num_attention_heads=config.num_attention_heads,\n                intermediate_size=config.intermediate_size,\n                intermediate_act_fn=get_activation(config.hidden_act),\n                hidden_dropout_prob=config.hidden_dropout_prob,\n                attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n                initializer_range=config.initializer_range,\n                do_return_all_layers=True)\n        else: # xlarge or xxlarge of albert, used pre-LN structure\n            print(""new structure of transformer.use: prelln_transformer_model,which use pre-LN"")\n            self.all_encoder_layers = prelln_transformer_model( # change by brightmart, 4th, oct, 2019. pre-Layer Normalization can converge fast and better. check paper: ON LAYER NORMALIZATION IN THE TRANSFORMER ARCHITECTURE\n                input_tensor=self.embedding_output,\n                attention_mask=attention_mask,\n                hidden_size=config.hidden_size,\n                num_hidden_layers=config.num_hidden_layers,\n                num_attention_heads=config.num_attention_heads,\n                intermediate_size=config.intermediate_size,\n                intermediate_act_fn=get_activation(config.hidden_act),\n                hidden_dropout_prob=config.hidden_dropout_prob,\n                attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n                initializer_range=config.initializer_range,\n                do_return_all_layers=True,\n                shared_type=\'all\') #  do_return_all_layers=True\n\n      self.sequence_output = self.all_encoder_layers[-1] # [batch_size, seq_length, hidden_size]\n      # The ""pooler"" converts the encoded sequence tensor of shape\n      # [batch_size, seq_length, hidden_size] to a tensor of shape\n      # [batch_size, hidden_size]. This is necessary for segment-level\n      # (or segment-pair-level) classification tasks where we need a fixed\n      # dimensional representation of the segment.\n      with tf.variable_scope(""pooler""):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token. We assume that this has been pre-trained\n        first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)\n        self.pooled_output = tf.layers.dense(\n            first_token_tensor,\n            config.hidden_size,\n            activation=tf.tanh,\n            kernel_initializer=create_initializer(config.initializer_range))\n\n  def get_pooled_output(self):\n    return self.pooled_output\n\n  def get_sequence_output(self):\n    """"""Gets final hidden layer of encoder.\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the final hidden of the transformer encoder.\n    """"""\n    return self.sequence_output\n\n  def get_all_encoder_layers(self):\n    return self.all_encoder_layers\n\n  def get_embedding_output(self):\n    """"""Gets output of the embedding lookup (i.e., input to the transformer).\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the output of the embedding layer, after summing the word\n      embeddings with the positional embeddings and the token type embeddings,\n      then performing layer normalization. This is the input to the transformer.\n    """"""\n    return self.embedding_output\n\n  def get_embedding_table(self):\n    return self.embedding_table\n\n  def get_embedding_table_2(self):\n    return self.embedding_table_2\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef get_activation(activation_string):\n  """"""Maps a string to a Python function, e.g., ""relu"" => `tf.nn.relu`.\n\n  Args:\n    activation_string: String name of the activation function.\n\n  Returns:\n    A Python function corresponding to the activation function. If\n    `activation_string` is None, empty, or ""linear"", this will return None.\n    If `activation_string` is not a string, it will return `activation_string`.\n\n  Raises:\n    ValueError: The `activation_string` does not correspond to a known\n      activation.\n  """"""\n\n  # We assume that anything that""s not a string is already an activation\n  # function, so we just return it.\n  if not isinstance(activation_string, six.string_types):\n    return activation_string\n\n  if not activation_string:\n    return None\n\n  act = activation_string.lower()\n  if act == ""linear"":\n    return None\n  elif act == ""relu"":\n    return tf.nn.relu\n  elif act == ""gelu"":\n    return gelu\n  elif act == ""tanh"":\n    return tf.tanh\n  else:\n    raise ValueError(""Unsupported activation: %s"" % act)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    if name not in name_to_variable:\n      continue\n    assignment_map[name] = name\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\ndef dropout(input_tensor, dropout_prob):\n  """"""Perform dropout.\n\n  Args:\n    input_tensor: float Tensor.\n    dropout_prob: Python float. The probability of dropping out a value (NOT of\n      *keeping* a dimension as in `tf.nn.dropout`).\n\n  Returns:\n    A version of `input_tensor` with dropout applied.\n  """"""\n  if dropout_prob is None or dropout_prob == 0.0:\n    return input_tensor\n\n  output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob)\n  return output\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n  """"""Runs layer normalization followed by dropout.""""""\n  output_tensor = layer_norm(input_tensor, name)\n  output_tensor = dropout(output_tensor, dropout_prob)\n  return output_tensor\n\n\ndef create_initializer(initializer_range=0.02):\n  """"""Creates a `truncated_normal_initializer` with the given range.""""""\n  return tf.truncated_normal_initializer(stddev=initializer_range)\n\n\ndef embedding_lookup(input_ids,\n                     vocab_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n  """"""Looks up words embeddings for id tensor.\n\n  Args:\n    input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n      ids.\n    vocab_size: int. Size of the embedding vocabulary.\n    embedding_size: int. Width of the word embeddings.\n    initializer_range: float. Embedding initialization range.\n    word_embedding_name: string. Name of the embedding table.\n    use_one_hot_embeddings: bool. If True, use one-hot method for word\n      embeddings. If False, use `tf.gather()`.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, embedding_size].\n  """"""\n  # This function assumes that the input is of shape [batch_size, seq_length,\n  # num_inputs].\n  #\n  # If the input is a 2D tensor of shape [batch_size, seq_length], we\n  # reshape to [batch_size, seq_length, 1].\n  if input_ids.shape.ndims == 2:\n    input_ids = tf.expand_dims(input_ids, axis=[-1]) # shape of input_ids is:[ batch_size, seq_length, 1]\n\n  embedding_table = tf.get_variable( # [vocab_size, embedding_size]\n      name=word_embedding_name,\n      shape=[vocab_size, embedding_size],\n      initializer=create_initializer(initializer_range))\n\n  flat_input_ids = tf.reshape(input_ids, [-1]) # one rank. shape as (batch_size * sequence_length,)\n  if use_one_hot_embeddings:\n    one_hot_input_ids = tf.one_hot(flat_input_ids, depth=vocab_size) # one_hot_input_ids=[batch_size * sequence_length,vocab_size]\n    output = tf.matmul(one_hot_input_ids, embedding_table) # output=[batch_size * sequence_length,embedding_size]\n  else:\n    output = tf.gather(embedding_table, flat_input_ids) # [vocab_size, embedding_size]*[batch_size * sequence_length,]--->[batch_size * sequence_length,embedding_size]\n\n  input_shape = get_shape_list(input_ids) # input_shape=[ batch_size, seq_length, 1]\n\n  output = tf.reshape(output,input_shape[0:-1] + [input_shape[-1] * embedding_size]) # output=[batch_size,sequence_length,embedding_size]\n  return (output, embedding_table)\n\ndef embedding_lookup_factorized(input_ids, # Factorized embedding parameterization provide by albert\n                     vocab_size,\n                     hidden_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n    """"""Looks up words embeddings for id tensor, but in a factorized style followed by albert. it is used to reduce much percentage of parameters previous exists.\n       Check ""Factorized embedding parameterization"" session in the paper.\n\n     Args:\n       input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n         ids.\n       vocab_size: int. Size of the embedding vocabulary.\n       embedding_size: int. Width of the word embeddings.\n       initializer_range: float. Embedding initialization range.\n       word_embedding_name: string. Name of the embedding table.\n       use_one_hot_embeddings: bool. If True, use one-hot method for word\n         embeddings. If False, use `tf.gather()`.\n\n     Returns:\n       float Tensor of shape [batch_size, seq_length, embedding_size].\n     """"""\n    # This function assumes that the input is of shape [batch_size, seq_length,\n    # num_inputs].\n    #\n    # If the input is a 2D tensor of shape [batch_size, seq_length], we\n    # reshape to [batch_size, seq_length, 1].\n\n    # 1.first project one-hot vectors into a lower dimensional embedding space of size E\n    print(""embedding_lookup_factorized. factorized embedding parameterization is used."")\n    if input_ids.shape.ndims == 2:\n        input_ids = tf.expand_dims(input_ids, axis=[-1])  # shape of input_ids is:[ batch_size, seq_length, 1]\n\n    embedding_table = tf.get_variable(  # [vocab_size, embedding_size]\n        name=word_embedding_name,\n        shape=[vocab_size, embedding_size],\n        initializer=create_initializer(initializer_range))\n\n    flat_input_ids = tf.reshape(input_ids, [-1])  # one rank. shape as (batch_size * sequence_length,)\n    if use_one_hot_embeddings:\n        one_hot_input_ids = tf.one_hot(flat_input_ids,depth=vocab_size)  # one_hot_input_ids=[batch_size * sequence_length,vocab_size]\n        output_middle = tf.matmul(one_hot_input_ids, embedding_table)  # output=[batch_size * sequence_length,embedding_size]\n    else:\n        output_middle = tf.gather(embedding_table,flat_input_ids)  # [vocab_size, embedding_size]*[batch_size * sequence_length,]--->[batch_size * sequence_length,embedding_size]\n\n    # 2. project vector(output_middle) to the hidden space\n    project_variable = tf.get_variable(  # [embedding_size, hidden_size]\n        name=word_embedding_name+""_2"",\n        shape=[embedding_size, hidden_size],\n        initializer=create_initializer(initializer_range))\n    output = tf.matmul(output_middle, project_variable) # ([batch_size * sequence_length, embedding_size] * [embedding_size, hidden_size])--->[batch_size * sequence_length, hidden_size]\n    # reshape back to 3 rank\n    input_shape = get_shape_list(input_ids)  # input_shape=[ batch_size, seq_length, 1]\n    batch_size, sequene_length, _=input_shape\n    output = tf.reshape(output, (batch_size,sequene_length,hidden_size))  # output=[batch_size, sequence_length, hidden_size]\n    return (output, embedding_table, project_variable)\n\n\ndef embedding_postprocessor(input_tensor,\n                            use_token_type=False,\n                            token_type_ids=None,\n                            token_type_vocab_size=16,\n                            token_type_embedding_name=""token_type_embeddings"",\n                            use_position_embeddings=True,\n                            position_embedding_name=""position_embeddings"",\n                            initializer_range=0.02,\n                            max_position_embeddings=512,\n                            dropout_prob=0.1):\n  """"""Performs various post-processing on a word embedding tensor.\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length,\n      embedding_size].\n    use_token_type: bool. Whether to add embeddings for `token_type_ids`.\n    token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      Must be specified if `use_token_type` is True.\n    token_type_vocab_size: int. The vocabulary size of `token_type_ids`.\n    token_type_embedding_name: string. The name of the embedding table variable\n      for token type ids.\n    use_position_embeddings: bool. Whether to add position embeddings for the\n      position of each token in the sequence.\n    position_embedding_name: string. The name of the embedding table variable\n      for positional embeddings.\n    initializer_range: float. Range of the weight initialization.\n    max_position_embeddings: int. Maximum sequence length that might ever be\n      used with this model. This can be longer than the sequence length of\n      input_tensor, but cannot be shorter.\n    dropout_prob: float. Dropout probability applied to the final output tensor.\n\n  Returns:\n    float tensor with same shape as `input_tensor`.\n\n  Raises:\n    ValueError: One of the tensor shapes or input values is invalid.\n  """"""\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  width = input_shape[2]\n\n  output = input_tensor\n\n  if use_token_type:\n    if token_type_ids is None:\n      raise ValueError(""`token_type_ids` must be specified if""\n                       ""`use_token_type` is True."")\n    token_type_table = tf.get_variable(\n        name=token_type_embedding_name,\n        shape=[token_type_vocab_size, width],\n        initializer=create_initializer(initializer_range))\n    # This vocab will be small so we always do one-hot here, since it is always\n    # faster for a small vocabulary.\n    flat_token_type_ids = tf.reshape(token_type_ids, [-1])\n    one_hot_ids = tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)\n    token_type_embeddings = tf.matmul(one_hot_ids, token_type_table)\n    token_type_embeddings = tf.reshape(token_type_embeddings,\n                                       [batch_size, seq_length, width])\n    output += token_type_embeddings\n\n  if use_position_embeddings:\n    assert_op = tf.assert_less_equal(seq_length, max_position_embeddings)\n    with tf.control_dependencies([assert_op]):\n      full_position_embeddings = tf.get_variable(\n          name=position_embedding_name,\n          shape=[max_position_embeddings, width],\n          initializer=create_initializer(initializer_range))\n      # Since the position embedding table is a learned variable, we create it\n      # using a (long) sequence length `max_position_embeddings`. The actual\n      # sequence length might be shorter than this, for faster training of\n      # tasks that do not have long sequences.\n      #\n      # So `full_position_embeddings` is effectively an embedding table\n      # for position [0, 1, 2, ..., max_position_embeddings-1], and the current\n      # sequence has positions [0, 1, 2, ... seq_length-1], so we can just\n      # perform a slice.\n      position_embeddings = tf.slice(full_position_embeddings, [0, 0],\n                                     [seq_length, -1])\n      num_dims = len(output.shape.as_list())\n\n      # Only the last two dimensions are relevant (`seq_length` and `width`), so\n      # we broadcast among the first dimensions, which is typically just\n      # the batch size.\n      position_broadcast_shape = []\n      for _ in range(num_dims - 2):\n        position_broadcast_shape.append(1)\n      position_broadcast_shape.extend([seq_length, width])\n      position_embeddings = tf.reshape(position_embeddings,\n                                       position_broadcast_shape)\n      output += position_embeddings\n\n  output = layer_norm_and_dropout(output, dropout_prob)\n  return output\n\n\ndef create_attention_mask_from_input_mask(from_tensor, to_mask):\n  """"""Create 3D attention mask from a 2D tensor mask.\n\n  Args:\n    from_tensor: 2D or 3D Tensor of shape [batch_size, from_seq_length, ...].\n    to_mask: int32 Tensor of shape [batch_size, to_seq_length].\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length, to_seq_length].\n  """"""\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  batch_size = from_shape[0]\n  from_seq_length = from_shape[1]\n\n  to_shape = get_shape_list(to_mask, expected_rank=2)\n  to_seq_length = to_shape[1]\n\n  to_mask = tf.cast(\n      tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)\n\n  # We don\'t assume that `from_tensor` is a mask (although it could be). We\n  # don\'t actually care if we attend *from* padding tokens (only *to* padding)\n  # tokens so we create a tensor of all ones.\n  #\n  # `broadcast_ones` = [batch_size, from_seq_length, 1]\n  broadcast_ones = tf.ones(\n      shape=[batch_size, from_seq_length, 1], dtype=tf.float32)\n\n  # Here we broadcast along two dimensions to create the mask.\n  mask = broadcast_ones * to_mask\n\n  return mask\n\n\ndef attention_layer(from_tensor,\n                    to_tensor,\n                    attention_mask=None,\n                    num_attention_heads=1,\n                    size_per_head=512,\n                    query_act=None,\n                    key_act=None,\n                    value_act=None,\n                    attention_probs_dropout_prob=0.0,\n                    initializer_range=0.02,\n                    do_return_2d_tensor=False,\n                    batch_size=None,\n                    from_seq_length=None,\n                    to_seq_length=None):\n  """"""Performs multi-headed attention from `from_tensor` to `to_tensor`.\n\n  This is an implementation of multi-headed attention based on ""Attention\n  is all you Need"". If `from_tensor` and `to_tensor` are the same, then\n  this is self-attention. Each timestep in `from_tensor` attends to the\n  corresponding sequence in `to_tensor`, and returns a fixed-with vector.\n\n  This function first projects `from_tensor` into a ""query"" tensor and\n  `to_tensor` into ""key"" and ""value"" tensors. These are (effectively) a list\n  of tensors of length `num_attention_heads`, where each tensor is of shape\n  [batch_size, seq_length, size_per_head].\n\n  Then, the query and key tensors are dot-producted and scaled. These are\n  softmaxed to obtain attention probabilities. The value tensors are then\n  interpolated by these probabilities, then concatenated back to a single\n  tensor and returned.\n\n  In practice, the multi-headed attention are done with transposes and\n  reshapes rather than actual separate tensors.\n\n  Args:\n    from_tensor: float Tensor of shape [batch_size, from_seq_length,\n      from_width].\n    to_tensor: float Tensor of shape [batch_size, to_seq_length, to_width].\n    attention_mask: (optional) int32 Tensor of shape [batch_size,\n      from_seq_length, to_seq_length]. The values should be 1 or 0. The\n      attention scores will effectively be set to -infinity for any positions in\n      the mask that are 0, and will be unchanged for positions that are 1.\n    num_attention_heads: int. Number of attention heads.\n    size_per_head: int. Size of each attention head.\n    query_act: (optional) Activation function for the query transform.\n    key_act: (optional) Activation function for the key transform.\n    value_act: (optional) Activation function for the value transform.\n    attention_probs_dropout_prob: (optional) float. Dropout probability of the\n      attention probabilities.\n    initializer_range: float. Range of the weight initializer.\n    do_return_2d_tensor: bool. If True, the output will be of shape [batch_size\n      * from_seq_length, num_attention_heads * size_per_head]. If False, the\n      output will be of shape [batch_size, from_seq_length, num_attention_heads\n      * size_per_head].\n    batch_size: (Optional) int. If the input is 2D, this might be the batch size\n      of the 3D version of the `from_tensor` and `to_tensor`.\n    from_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `from_tensor`.\n    to_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `to_tensor`.\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length,\n      num_attention_heads * size_per_head]. (If `do_return_2d_tensor` is\n      true, this will be of shape [batch_size * from_seq_length,\n      num_attention_heads * size_per_head]).\n\n  Raises:\n    ValueError: Any of the arguments or tensor shapes are invalid.\n  """"""\n\n  def transpose_for_scores(input_tensor, batch_size, num_attention_heads,\n                           seq_length, width):\n    output_tensor = tf.reshape(\n        input_tensor, [batch_size, seq_length, num_attention_heads, width])\n\n    output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])\n    return output_tensor\n\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])\n\n  if len(from_shape) != len(to_shape):\n    raise ValueError(\n        ""The rank of `from_tensor` must match the rank of `to_tensor`."")\n\n  if len(from_shape) == 3:\n    batch_size = from_shape[0]\n    from_seq_length = from_shape[1]\n    to_seq_length = to_shape[1]\n  elif len(from_shape) == 2:\n    if (batch_size is None or from_seq_length is None or to_seq_length is None):\n      raise ValueError(\n          ""When passing in rank 2 tensors to attention_layer, the values ""\n          ""for `batch_size`, `from_seq_length`, and `to_seq_length` ""\n          ""must all be specified."")\n\n  # Scalar dimensions referenced here:\n  #   B = batch size (number of sequences)\n  #   F = `from_tensor` sequence length\n  #   T = `to_tensor` sequence length\n  #   N = `num_attention_heads`\n  #   H = `size_per_head`\n\n  from_tensor_2d = reshape_to_matrix(from_tensor)\n  to_tensor_2d = reshape_to_matrix(to_tensor)\n\n  # `query_layer` = [B*F, N*H]\n  query_layer = tf.layers.dense(\n      from_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=query_act,\n      name=""query"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `key_layer` = [B*T, N*H]\n  key_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=key_act,\n      name=""key"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `value_layer` = [B*T, N*H]\n  value_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=value_act,\n      name=""value"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `query_layer` = [B, N, F, H]\n  query_layer = transpose_for_scores(query_layer, batch_size,\n                                     num_attention_heads, from_seq_length,\n                                     size_per_head)\n\n  # `key_layer` = [B, N, T, H]\n  key_layer = transpose_for_scores(key_layer, batch_size, num_attention_heads,\n                                   to_seq_length, size_per_head)\n\n  # Take the dot product between ""query"" and ""key"" to get the raw\n  # attention scores.\n  # `attention_scores` = [B, N, F, T]\n  attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)\n  attention_scores = tf.multiply(attention_scores,\n                                 1.0 / math.sqrt(float(size_per_head)))\n\n  if attention_mask is not None:\n    # `attention_mask` = [B, 1, F, T]\n    attention_mask = tf.expand_dims(attention_mask, axis=[1])\n\n    # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n    # masked positions, this operation will create a tensor which is 0.0 for\n    # positions we want to attend and -10000.0 for masked positions.\n    adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0\n\n    # Since we are adding it to the raw scores before the softmax, this is\n    # effectively the same as removing these entirely.\n    attention_scores += adder\n\n  # Normalize the attention scores to probabilities.\n  # `attention_probs` = [B, N, F, T]\n  attention_probs = tf.nn.softmax(attention_scores)\n\n  # This is actually dropping out entire tokens to attend to, which might\n  # seem a bit unusual, but is taken from the original Transformer paper.\n  attention_probs = dropout(attention_probs, attention_probs_dropout_prob)\n\n  # `value_layer` = [B, T, N, H]\n  value_layer = tf.reshape(\n      value_layer,\n      [batch_size, to_seq_length, num_attention_heads, size_per_head])\n\n  # `value_layer` = [B, N, T, H]\n  value_layer = tf.transpose(value_layer, [0, 2, 1, 3])\n\n  # `context_layer` = [B, N, F, H]\n  context_layer = tf.matmul(attention_probs, value_layer)\n\n  # `context_layer` = [B, F, N, H]\n  context_layer = tf.transpose(context_layer, [0, 2, 1, 3])\n\n  if do_return_2d_tensor:\n    # `context_layer` = [B*F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size * from_seq_length, num_attention_heads * size_per_head])\n  else:\n    # `context_layer` = [B, F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size, from_seq_length, num_attention_heads * size_per_head])\n\n  return context_layer\n\n\ndef transformer_model(input_tensor,\n                      attention_mask=None,\n                      hidden_size=768,\n                      num_hidden_layers=12,\n                      num_attention_heads=12,\n                      intermediate_size=3072,\n                      intermediate_act_fn=gelu,\n                      hidden_dropout_prob=0.1,\n                      attention_probs_dropout_prob=0.1,\n                      initializer_range=0.02,\n                      do_return_all_layers=False,\n                      share_parameter_across_layers=True):\n  """"""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n  This is almost an exact implementation of the original Transformer encoder.\n\n  See the original paper:\n  https://arxiv.org/abs/1706.03762\n\n  Also see:\n  https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n    attention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n      seq_length], with 1 for positions that can be attended to and 0 in\n      positions that should not be.\n    hidden_size: int. Hidden size of the Transformer.\n    num_hidden_layers: int. Number of layers (blocks) in the Transformer.\n    num_attention_heads: int. Number of attention heads in the Transformer.\n    intermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n      forward) layer.\n    intermediate_act_fn: function. The non-linear activation function to apply\n      to the output of the intermediate/feed-forward layer.\n    hidden_dropout_prob: float. Dropout probability for the hidden layers.\n    attention_probs_dropout_prob: float. Dropout probability of the attention\n      probabilities.\n    initializer_range: float. Range of the initializer (stddev of truncated\n      normal).\n    do_return_all_layers: Whether to also return all layers or just the final\n      layer.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, hidden_size], the final\n    hidden layer of the Transformer.\n\n  Raises:\n    ValueError: A Tensor shape or parameter is invalid.\n  """"""\n  if hidden_size % num_attention_heads != 0:\n    raise ValueError(\n        ""The hidden size (%d) is not a multiple of the number of attention ""\n        ""heads (%d)"" % (hidden_size, num_attention_heads))\n\n  attention_head_size = int(hidden_size / num_attention_heads)\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  input_width = input_shape[2]\n\n  # The Transformer performs sum residuals on all layers so the input needs\n  # to be the same as the hidden size.\n  if input_width != hidden_size:\n    raise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n                     (input_width, hidden_size))\n\n  # We keep the representation as a 2D tensor to avoid re-shaping it back and\n  # forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n  # the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n  # help the optimizer.\n  prev_output = reshape_to_matrix(input_tensor)\n\n  all_layer_outputs = []\n  for layer_idx in range(num_hidden_layers):\n    if share_parameter_across_layers:\n        name_variable_scope=""layer_shared""\n    else:\n        name_variable_scope=""layer_%d"" % layer_idx\n    # share all parameters across layers. add by brightmart, 2019-09-28. previous it is like this: ""layer_%d"" % layer_idx\n    with tf.variable_scope(name_variable_scope, reuse=True if (share_parameter_across_layers and layer_idx>0) else False):\n\n      layer_input = prev_output\n\n      with tf.variable_scope(""attention""):\n        attention_heads = []\n        with tf.variable_scope(""self""):\n          attention_head = attention_layer(\n              from_tensor=layer_input,\n              to_tensor=layer_input,\n              attention_mask=attention_mask,\n              num_attention_heads=num_attention_heads,\n              size_per_head=attention_head_size,\n              attention_probs_dropout_prob=attention_probs_dropout_prob,\n              initializer_range=initializer_range,\n              do_return_2d_tensor=True,\n              batch_size=batch_size,\n              from_seq_length=seq_length,\n              to_seq_length=seq_length)\n          attention_heads.append(attention_head)\n\n        attention_output = None\n        if len(attention_heads) == 1:\n          attention_output = attention_heads[0]\n        else:\n          # In the case where we have other sequences, we just concatenate\n          # them to the self-attention head before the projection.\n          attention_output = tf.concat(attention_heads, axis=-1)\n\n        # Run a linear projection of `hidden_size` then add a residual\n        # with `layer_input`.\n        with tf.variable_scope(""output""):\n          attention_output = tf.layers.dense(\n              attention_output,\n              hidden_size,\n              kernel_initializer=create_initializer(initializer_range))\n          attention_output = dropout(attention_output, hidden_dropout_prob)\n          attention_output = layer_norm(attention_output + layer_input)\n\n      # The activation is only applied to the ""intermediate"" hidden layer.\n      with tf.variable_scope(""intermediate""):\n        intermediate_output = tf.layers.dense(\n            attention_output,\n            intermediate_size,\n            activation=intermediate_act_fn,\n            kernel_initializer=create_initializer(initializer_range))\n\n      # Down-project back to `hidden_size` then add the residual.\n      with tf.variable_scope(""output""):\n        layer_output = tf.layers.dense(\n            intermediate_output,\n            hidden_size,\n            kernel_initializer=create_initializer(initializer_range))\n        layer_output = dropout(layer_output, hidden_dropout_prob)\n        layer_output = layer_norm(layer_output + attention_output)\n        prev_output = layer_output\n        all_layer_outputs.append(layer_output)\n\n  if do_return_all_layers:\n    final_outputs = []\n    for layer_output in all_layer_outputs:\n      final_output = reshape_from_matrix(layer_output, input_shape)\n      final_outputs.append(final_output)\n    return final_outputs\n  else:\n    final_output = reshape_from_matrix(prev_output, input_shape)\n    return final_output\n\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n  """"""Returns a list of the shape of tensor, preferring static dimensions.\n\n  Args:\n    tensor: A tf.Tensor object to find the shape of.\n    expected_rank: (optional) int. The expected rank of `tensor`. If this is\n      specified and the `tensor` has a different rank, and exception will be\n      thrown.\n    name: Optional name of the tensor for the error message.\n\n  Returns:\n    A list of dimensions of the shape of tensor. All static dimensions will\n    be returned as python integers, and dynamic dimensions will be returned\n    as tf.Tensor scalars.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  if expected_rank is not None:\n    assert_rank(tensor, expected_rank, name)\n\n  shape = tensor.shape.as_list()\n\n  non_static_indexes = []\n  for (index, dim) in enumerate(shape):\n    if dim is None:\n      non_static_indexes.append(index)\n\n  if not non_static_indexes:\n    return shape\n\n  dyn_shape = tf.shape(tensor)\n  for index in non_static_indexes:\n    shape[index] = dyn_shape[index]\n  return shape\n\n\ndef reshape_to_matrix(input_tensor):\n  """"""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n  ndims = input_tensor.shape.ndims\n  if ndims < 2:\n    raise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n                     (input_tensor.shape))\n  if ndims == 2:\n    return input_tensor\n\n  width = input_tensor.shape[-1]\n  output_tensor = tf.reshape(input_tensor, [-1, width])\n  return output_tensor\n\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n  """"""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n  if len(orig_shape_list) == 2:\n    return output_tensor\n\n  output_shape = get_shape_list(output_tensor)\n\n  orig_dims = orig_shape_list[0:-1]\n  width = output_shape[-1]\n\n  return tf.reshape(output_tensor, orig_dims + [width])\n\n\ndef assert_rank(tensor, expected_rank, name=None):\n  """"""Raises an exception if the tensor rank is not of the expected rank.\n\n  Args:\n    tensor: A tf.Tensor to check the rank of.\n    expected_rank: Python integer or list of integers, expected rank.\n    name: Optional name of the tensor for the error message.\n\n  Raises:\n    ValueError: If the expected shape doesn\'t match the actual shape.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  expected_rank_dict = {}\n  if isinstance(expected_rank, six.integer_types):\n    expected_rank_dict[expected_rank] = True\n  else:\n    for x in expected_rank:\n      expected_rank_dict[x] = True\n\n  actual_rank = tensor.shape.ndims\n  if actual_rank not in expected_rank_dict:\n    scope_name = tf.get_variable_scope().name\n    raise ValueError(\n        ""For the tensor `%s` in scope `%s`, the actual rank ""\n        ""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n        (name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n\ndef prelln_transformer_model(input_tensor,\n\t\t\t\t\t\tattention_mask=None,\n\t\t\t\t\t\thidden_size=768,\n\t\t\t\t\t\tnum_hidden_layers=12,\n\t\t\t\t\t\tnum_attention_heads=12,\n\t\t\t\t\t\tintermediate_size=3072,\n\t\t\t\t\t\tintermediate_act_fn=gelu,\n\t\t\t\t\t\thidden_dropout_prob=0.1,\n\t\t\t\t\t\tattention_probs_dropout_prob=0.1,\n\t\t\t\t\t\tinitializer_range=0.02,\n\t\t\t\t\t\tdo_return_all_layers=False,\n\t\t\t\t\t\tshared_type=\'all\', # None,\n\t\t\t\t\t\tadapter_fn=None):\n\t""""""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n\tThis is almost an exact implementation of the original Transformer encoder.\n\n\tSee the original paper:\n\thttps://arxiv.org/abs/1706.03762\n\n\tAlso see:\n\thttps://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n\tArgs:\n\t\tinput_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n\t\tattention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n\t\t\tseq_length], with 1 for positions that can be attended to and 0 in\n\t\t\tpositions that should not be.\n\t\thidden_size: int. Hidden size of the Transformer.\n\t\tnum_hidden_layers: int. Number of layers (blocks) in the Transformer.\n\t\tnum_attention_heads: int. Number of attention heads in the Transformer.\n\t\tintermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n\t\t\tforward) layer.\n\t\tintermediate_act_fn: function. The non-linear activation function to apply\n\t\t\tto the output of the intermediate/feed-forward layer.\n\t\thidden_dropout_prob: float. Dropout probability for the hidden layers.\n\t\tattention_probs_dropout_prob: float. Dropout probability of the attention\n\t\t\tprobabilities.\n\t\tinitializer_range: float. Range of the initializer (stddev of truncated\n\t\t\tnormal).\n\t\tdo_return_all_layers: Whether to also return all layers or just the final\n\t\t\tlayer.\n\n\tReturns:\n\t\tfloat Tensor of shape [batch_size, seq_length, hidden_size], the final\n\t\thidden layer of the Transformer.\n\n\tRaises:\n\t\tValueError: A Tensor shape or parameter is invalid.\n\t""""""\n\tif hidden_size % num_attention_heads != 0:\n\t\traise ValueError(\n\t\t\t\t""The hidden size (%d) is not a multiple of the number of attention ""\n\t\t\t\t""heads (%d)"" % (hidden_size, num_attention_heads))\n\n\tattention_head_size = int(hidden_size / num_attention_heads)\n\n\tinput_shape = bert_utils.get_shape_list(input_tensor, expected_rank=3)\n\tbatch_size = input_shape[0]\n\tseq_length = input_shape[1]\n\tinput_width = input_shape[2]\n\n\t# The Transformer performs sum residuals on all layers so the input needs\n\t# to be the same as the hidden size.\n\tif input_width != hidden_size:\n\t\traise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n\t\t\t\t\t\t\t\t\t\t (input_width, hidden_size))\n\n\t# We keep the representation as a 2D tensor to avoid re-shaping it back and\n\t# forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n\t# the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n\t# help the optimizer.\n\tprev_output = bert_utils.reshape_to_matrix(input_tensor)\n\n\tall_layer_outputs = []\n\n\tdef layer_scope(idx, shared_type):\n\t\tif shared_type == \'all\':\n\t\t\ttmp = {\n\t\t\t\t""layer"":""layer_shared"",\n\t\t\t\t\'attention\':\'attention\',\n\t\t\t\t\'intermediate\':\'intermediate\',\n\t\t\t\t\'output\':\'output\'\n\t\t\t}\n\t\telif shared_type == \'attention\':\n\t\t\ttmp = {\n\t\t\t\t""layer"":""layer_shared"",\n\t\t\t\t\'attention\':\'attention\',\n\t\t\t\t\'intermediate\':\'intermediate_{}\'.format(idx),\n\t\t\t\t\'output\':\'output_{}\'.format(idx)\n\t\t\t}\n\t\telif shared_type == \'ffn\':\n\t\t\ttmp = {\n\t\t\t\t""layer"":""layer_shared"",\n\t\t\t\t\'attention\':\'attention_{}\'.format(idx),\n\t\t\t\t\'intermediate\':\'intermediate\',\n\t\t\t\t\'output\':\'output\'\n\t\t\t}\n\t\telse:\n\t\t\ttmp = {\n\t\t\t\t""layer"":""layer_{}"".format(idx),\n\t\t\t\t\'attention\':\'attention\',\n\t\t\t\t\'intermediate\':\'intermediate\',\n\t\t\t\t\'output\':\'output\'\n\t\t\t}\n\n\t\treturn tmp\n\n\tall_layer_outputs = []\n\n\tfor layer_idx in range(num_hidden_layers):\n\n\t\tidx_scope = layer_scope(layer_idx, shared_type)\n\n\t\twith tf.variable_scope(idx_scope[\'layer\'], reuse=tf.AUTO_REUSE):\n\t\t\tlayer_input = prev_output\n\n\t\t\twith tf.variable_scope(idx_scope[\'attention\'], reuse=tf.AUTO_REUSE):\n\t\t\t\tattention_heads = []\n\n\t\t\t\twith tf.variable_scope(""output"", reuse=tf.AUTO_REUSE):\n\t\t\t\t\tlayer_input_pre = layer_norm(layer_input)\n\n\t\t\t\twith tf.variable_scope(""self""):\n\t\t\t\t\tattention_head = attention_layer(\n\t\t\t\t\t\t\tfrom_tensor=layer_input_pre,\n\t\t\t\t\t\t\tto_tensor=layer_input_pre,\n\t\t\t\t\t\t\tattention_mask=attention_mask,\n\t\t\t\t\t\t\tnum_attention_heads=num_attention_heads,\n\t\t\t\t\t\t\tsize_per_head=attention_head_size,\n\t\t\t\t\t\t\tattention_probs_dropout_prob=attention_probs_dropout_prob,\n\t\t\t\t\t\t\tinitializer_range=initializer_range,\n\t\t\t\t\t\t\tdo_return_2d_tensor=True,\n\t\t\t\t\t\t\tbatch_size=batch_size,\n\t\t\t\t\t\t\tfrom_seq_length=seq_length,\n\t\t\t\t\t\t\tto_seq_length=seq_length)\n\t\t\t\t\tattention_heads.append(attention_head)\n\n\t\t\t\tattention_output = None\n\t\t\t\tif len(attention_heads) == 1:\n\t\t\t\t\tattention_output = attention_heads[0]\n\t\t\t\telse:\n\t\t\t\t\t# In the case where we have other sequences, we just concatenate\n\t\t\t\t\t# them to the self-attention head before the projection.\n\t\t\t\t\tattention_output = tf.concat(attention_heads, axis=-1)\n\n\t\t\t\t# Run a linear projection of `hidden_size` then add a residual\n\t\t\t\t# with `layer_input`.\n\t\t\t\twith tf.variable_scope(""output"", reuse=tf.AUTO_REUSE):\n\t\t\t\t\tattention_output = tf.layers.dense(\n\t\t\t\t\t\t\tattention_output,\n\t\t\t\t\t\t\thidden_size,\n\t\t\t\t\t\t\tkernel_initializer=create_initializer(initializer_range))\n\t\t\t\t\tattention_output = dropout(attention_output, hidden_dropout_prob)\n\n\t\t\t\t\t# attention_output = layer_norm(attention_output + layer_input)\n\t\t\t\t\tattention_output = attention_output + layer_input\n\n\t\t\twith tf.variable_scope(idx_scope[\'output\'], reuse=tf.AUTO_REUSE):\n\t\t\t\tattention_output_pre = layer_norm(attention_output)\n\n\t\t\t# The activation is only applied to the ""intermediate"" hidden layer.\n\t\t\twith tf.variable_scope(idx_scope[\'intermediate\'], reuse=tf.AUTO_REUSE):\n\t\t\t\tintermediate_output = tf.layers.dense(\n\t\t\t\t\t\tattention_output_pre,\n\t\t\t\t\t\tintermediate_size,\n\t\t\t\t\t\tactivation=intermediate_act_fn,\n\t\t\t\t\t\tkernel_initializer=create_initializer(initializer_range))\n\n\t\t\t# Down-project back to `hidden_size` then add the residual.\n\t\t\twith tf.variable_scope(idx_scope[\'output\'], reuse=tf.AUTO_REUSE):\n\t\t\t\tlayer_output = tf.layers.dense(\n\t\t\t\t\t\tintermediate_output,\n\t\t\t\t\t\thidden_size,\n\t\t\t\t\t\tkernel_initializer=create_initializer(initializer_range))\n\t\t\t\tlayer_output = dropout(layer_output, hidden_dropout_prob)\n\n\t\t\t\t# layer_output = layer_norm(layer_output + attention_output)\n\t\t\t\tlayer_output = layer_output + attention_output\n\t\t\t\tprev_output = layer_output\n\t\t\t\tall_layer_outputs.append(layer_output)\n\n\tif do_return_all_layers:\n\t\tfinal_outputs = []\n\t\tfor layer_output in all_layer_outputs:\n\t\t\tfinal_output = bert_utils.reshape_from_matrix(layer_output, input_shape)\n\t\t\tfinal_outputs.append(final_output)\n\t\treturn final_outputs\n\telse:\n\t\tfinal_output = bert_utils.reshape_from_matrix(prev_output, input_shape)\n\t\treturn final_output\n'"
baselines/models/albert/optimization.py,41,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n    """"""Creates an optimizer training op.""""""\n    global_step = tf.train.get_or_create_global_step()\n\n    learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n    # Implements linear decay of the learning rate.\n    learning_rate = tf.train.polynomial_decay(\n        learning_rate,\n        global_step,\n        num_train_steps,\n        end_learning_rate=0.0,\n        power=1.0,\n        cycle=False)\n\n    # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n    # learning rate will be `global_step/num_warmup_steps * init_lr`.\n    if num_warmup_steps:\n        global_steps_int = tf.cast(global_step, tf.int32)\n        warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n        global_steps_float = tf.cast(global_steps_int, tf.float32)\n        warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n        warmup_percent_done = global_steps_float / warmup_steps_float\n        warmup_learning_rate = init_lr * warmup_percent_done\n\n        is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n        learning_rate = (\n                (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n    # It is recommended that you use this optimizer for fine tuning, since this\n    # is how the model was trained (note that the Adam m/v variables are NOT\n    # loaded from init_checkpoint.)\n    optimizer = LAMBOptimizer(\n        learning_rate=learning_rate,\n        weight_decay_rate=0.01,\n        beta_1=0.9,\n        beta_2=0.999,\n        epsilon=1e-6,\n        exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n    if use_tpu:\n        optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n    tvars = tf.trainable_variables()\n    grads = tf.gradients(loss, tvars)\n\n    # This is how the model was pre-trained.\n    (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n    train_op = optimizer.apply_gradients(\n        zip(grads, tvars), global_step=global_step)\n\n    # Normally the global step update is done inside of `apply_gradients`.\n    # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n    # a different optimizer, you should probably take this line out.\n    new_global_step = global_step + 1\n    train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n    return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n    """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n    def __init__(self,\n                 learning_rate,\n                 weight_decay_rate=0.0,\n                 beta_1=0.9,\n                 beta_2=0.999,\n                 epsilon=1e-6,\n                 exclude_from_weight_decay=None,\n                 name=""AdamWeightDecayOptimizer""):\n        """"""Constructs a AdamWeightDecayOptimizer.""""""\n        super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n        self.learning_rate = learning_rate\n        self.weight_decay_rate = weight_decay_rate\n        self.beta_1 = beta_1\n        self.beta_2 = beta_2\n        self.epsilon = epsilon\n        self.exclude_from_weight_decay = exclude_from_weight_decay\n\n    def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n        """"""See base class.""""""\n        assignments = []\n        for (grad, param) in grads_and_vars:\n            if grad is None or param is None:\n                continue\n\n            param_name = self._get_variable_name(param.name)\n\n            m = tf.get_variable(\n                name=param_name + ""/adam_m"",\n                shape=param.shape.as_list(),\n                dtype=tf.float32,\n                trainable=False,\n                initializer=tf.zeros_initializer())\n            v = tf.get_variable(\n                name=param_name + ""/adam_v"",\n                shape=param.shape.as_list(),\n                dtype=tf.float32,\n                trainable=False,\n                initializer=tf.zeros_initializer())\n\n            # Standard Adam update.\n            next_m = (\n                    tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n            next_v = (\n                    tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                              tf.square(grad)))\n\n            update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n            # Just adding the square of the weights to the loss function is *not*\n            # the correct way of using L2 regularization/weight decay with Adam,\n            # since that will interact with the m and v parameters in strange ways.\n            #\n            # Instead we want ot decay the weights in a manner that doesn\'t interact\n            # with the m/v parameters. This is equivalent to adding the square\n            # of the weights to the loss with plain (non-momentum) SGD.\n            if self._do_use_weight_decay(param_name):\n                update += self.weight_decay_rate * param\n\n            update_with_lr = self.learning_rate * update\n\n            next_param = param - update_with_lr\n\n            assignments.extend(\n                [param.assign(next_param),\n                 m.assign(next_m),\n                 v.assign(next_v)])\n        return tf.group(*assignments, name=name)\n\n    def _do_use_weight_decay(self, param_name):\n        """"""Whether to use L2 weight decay for `param_name`.""""""\n        if not self.weight_decay_rate:\n            return False\n        if self.exclude_from_weight_decay:\n            for r in self.exclude_from_weight_decay:\n                if re.search(r, param_name) is not None:\n                    return False\n        return True\n\n    def _get_variable_name(self, param_name):\n        """"""Get the variable name from the tensor name.""""""\n        m = re.match(""^(.*):\\\\d+$"", param_name)\n        if m is not None:\n            param_name = m.group(1)\n        return param_name\n\n\n#\nclass LAMBOptimizer(tf.train.Optimizer):\n    """"""\n    LAMBOptimizer optimizer.\n    https://github.com/ymcui/LAMB_Optimizer_TF\n    # IMPORTANT NOTE\n    - This is NOT an official implementation.\n    - LAMB optimizer is changed from arXiv v1 ~ v3.\n    - We implement v3 version (which is the latest version on June, 2019.).\n    - Our implementation is based on `AdamWeightDecayOptimizer` in BERT (provided by Google).\n\n    # References\n    - Large Batch Optimization for Deep Learning: Training BERT in 76 minutes. https://arxiv.org/abs/1904.00962v3\n    - BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. https://arxiv.org/abs/1810.04805\n    # Parameters\n    - There is nothing special, just the same as `AdamWeightDecayOptimizer`.\n    """"""\n\n    def __init__(self,\n                 learning_rate,\n                 weight_decay_rate=0.01,\n                 beta_1=0.9,\n                 beta_2=0.999,\n                 epsilon=1e-6,\n                 exclude_from_weight_decay=None,\n                 name=""LAMBOptimizer""):\n        """"""Constructs a LAMBOptimizer.""""""\n        super(LAMBOptimizer, self).__init__(False, name)\n\n        self.learning_rate = learning_rate\n        self.weight_decay_rate = weight_decay_rate\n        self.beta_1 = beta_1\n        self.beta_2 = beta_2\n        self.epsilon = epsilon\n        self.exclude_from_weight_decay = exclude_from_weight_decay\n\n    def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n        """"""See base class.""""""\n        assignments = []\n        for (grad, param) in grads_and_vars:\n            if grad is None or param is None:\n                continue\n\n            param_name = self._get_variable_name(param.name)\n\n            m = tf.get_variable(\n                name=param_name + ""/lamb_m"",\n                shape=param.shape.as_list(),\n                dtype=tf.float32,\n                trainable=False,\n                initializer=tf.zeros_initializer())\n            v = tf.get_variable(\n                name=param_name + ""/lamb_v"",\n                shape=param.shape.as_list(),\n                dtype=tf.float32,\n                trainable=False,\n                initializer=tf.zeros_initializer())\n\n            # Standard Adam update.\n            next_m = (\n                    tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n            next_v = (\n                    tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                              tf.square(grad)))\n\n            update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n            # Just adding the square of the weights to the loss function is *not*\n            # the correct way of using L2 regularization/weight decay with Adam,\n            # since that will interact with the m and v parameters in strange ways.\n            #\n            # Instead we want ot decay the weights in a manner that doesn\'t interact\n            # with the m/v parameters. This is equivalent to adding the square\n            # of the weights to the loss with plain (non-momentum) SGD.\n            if self._do_use_weight_decay(param_name):\n                update += self.weight_decay_rate * param\n\n            ############## BELOW ARE THE SPECIFIC PARTS FOR LAMB ##############\n\n            # Note: Here are two choices for scaling function \\phi(z)\n            # minmax:   \\phi(z) = min(max(z, \\gamma_l), \\gamma_u)\n            # identity: \\phi(z) = z\n            # The authors does not mention what is \\gamma_l and \\gamma_u\n            # UPDATE: after asking authors, they provide me the code below.\n            # ratio = array_ops.where(math_ops.greater(w_norm, 0), array_ops.where(\n            #      math_ops.greater(g_norm, 0), (w_norm / g_norm), 1.0), 1.0)\n\n            r1 = tf.sqrt(tf.reduce_sum(tf.square(param)))\n            r2 = tf.sqrt(tf.reduce_sum(tf.square(update)))\n\n            r = tf.where(tf.greater(r1, 0.0),\n                         tf.where(tf.greater(r2, 0.0),\n                                  r1 / r2,\n                                  1.0),\n                         1.0)\n\n            eta = self.learning_rate * r\n\n            update_with_lr = eta * update\n\n            next_param = param - update_with_lr\n\n            assignments.extend(\n                [param.assign(next_param),\n                 m.assign(next_m),\n                 v.assign(next_v)])\n        return tf.group(*assignments, name=name)\n\n    def _do_use_weight_decay(self, param_name):\n        """"""Whether to use L2 weight decay for `param_name`.""""""\n        if not self.weight_decay_rate:\n            return False\n        if self.exclude_from_weight_decay:\n            for r in self.exclude_from_weight_decay:\n                if re.search(r, param_name) is not None:\n                    return False\n        return True\n\n    def _get_variable_name(self, param_name):\n        """"""Get the variable name from the tensor name.""""""\n        m = re.match(""^(.*):\\\\d+$"", param_name)\n        if m is not None:\n            param_name = m.group(1)\n        return param_name'"
baselines/models/albert/optimization_finetuning.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.999, # 0.98 ONLY USED FOR PRETRAIN. MUST CHANGE AT FINE-TUNING 0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/albert/run_classifier.py,115,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:29:04\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport modeling\nimport optimization_finetuning as optimization\nimport tokenization\nimport tensorflow as tf\n# from loss import bi_tempered_logistic_loss\nimport sys\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n# Required parameters\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input data dir. Should contain the .tsv files (or other data files) ""\n    ""for the task."")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""task_name"", None, ""The name of the task to train."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n# Other parameters\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(\n    ""do_predict"", False,\n    ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n  return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    features[""label_ids""] = create_int_feature([feature.label_id])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 labels, num_labels, use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use model.get_sequence_output()\n  # instead.\n  output_layer = model.get_pooled_output()\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    ln_type = bert_config.ln_type\n    if ln_type == \'preln\':  # add by brightmart, 10-06. if it is preln, we need to an additonal layer: layer normalization as suggested in paper ""ON LAYER NORMALIZATION IN THE TRANSFORMER ARCHITECTURE""\n      print(""ln_type is preln. add LN layer."")\n      output_layer = layer_norm(output_layer)\n    else:\n      print(""ln_type is postln or other,do nothing."")\n\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs,\n                                      axis=-1)  # todo 08-29 try temp-loss\n    ###############bi_tempered_logistic_loss############################################################################\n    # print(""##cross entropy loss is used....""); tf.logging.info(""##cross entropy loss is used...."")\n    # t1=0.9 #t1=0.90\n    # t2=1.05 #t2=1.05\n    # per_example_loss=bi_tempered_logistic_loss(log_probs,one_hot_labels,t1,t2,label_smoothing=0.1,num_iters=5) # TODO label_smoothing=0.0\n    # tf.logging.info(""per_example_loss:""+str(per_example_loss.shape))\n    ##############bi_tempered_logistic_loss#############################################################################\n\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n    is_real_example = None\n    if ""is_real_example"" in features:\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n    else:\n      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,\n        num_labels, use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n       ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(\n            labels=label_ids, predictions=predictions, weights=is_real_example)\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn,\n                      [per_example_loss, label_ids, logits, is_real_example])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={""probabilities"": probabilities},\n          scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef input_fn_builder(features, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_input_ids = []\n  all_input_mask = []\n  all_segment_ids = []\n  all_label_ids = []\n\n  for feature in features:\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_segment_ids.append(feature.segment_ids)\n    all_label_ids.append(feature.label_id)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""segment_ids"":\n            tf.constant(\n                all_segment_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""label_ids"":\n            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),\n    })\n\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)\n    return d\n\n  return input_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer):\n  """"""Convert a set of `InputExample`s to a list of `InputFeatures`.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    features.append(feature)\n  return features\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval` or `do_predict\' must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  # Cloud TPU: Invalid TPU configuration, ensure ClusterResolver is passed to tpu.\n  print(""###tpu_cluster_resolver:"", tpu_cluster_resolver)\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)  # TODO\n    print(""###length of total train_examples:"", len(train_examples))\n    num_train_steps = int(len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      num_labels=len(label_list),\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n    train_file_exists = os.path.exists(train_file)\n    print(""###train_file_exists:"", train_file_exists, "" ;train_file:"", train_file)\n    if not train_file_exists:  # if tf_record file not exist, convert from raw text file. # TODO\n      if task_name == ""inews"":\n        file_based_convert_examples_to_features_for_inews(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n      else:\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    # dev dataset\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    num_actual_eval_examples = len(eval_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on. These do NOT count towards the metric (all tf.metrics\n      # support a per-instance weight, and these get a weight of 0.0).\n      while len(eval_examples) % FLAGS.eval_batch_size != 0:\n        eval_examples.append(PaddingInputExample())\n\n    eval_file = os.path.join(FLAGS.output_dir, ""dev.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(eval_examples), num_actual_eval_examples,\n                    len(eval_examples) - num_actual_eval_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      assert len(eval_examples) % FLAGS.eval_batch_size == 0\n      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    #######################################################################################################################\n    # evaluate all checkpoints; you can use the checkpoint with the best dev accuarcy\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_albert_zh.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        result = estimator.evaluate(input_fn=eval_input_fn,\n                                    steps=eval_steps, checkpoint_path=filename)\n\n        tf.logging.info(""***** Eval results %s *****"" % (filename))\n        writer.write(""***** Eval results %s *****\\n"" % (filename))\n        for key in sorted(result.keys()):\n          tf.logging.info(""  %s = %s"", key, str(result[key]))\n          writer.write(""%s = %s\\n"" % (key, str(result[key])))\n    #######################################################################################################################\n\n    # result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n    #\n    # output_eval_file = os.path.join(FLAGS.output_dir, ""dev_results_albert_zh.txt"")\n    # with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n    #  tf.logging.info(""***** Eval results *****"")\n    #  for key in sorted(result.keys()):\n    #    tf.logging.info(""  %s = %s"", key, str(result[key]))\n    #    writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    num_actual_predict_examples = len(predict_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on.\n      while len(predict_examples) % FLAGS.predict_batch_size != 0:\n        predict_examples.append(PaddingInputExample())\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(predict_examples, label_list,\n                                                        FLAGS.max_seq_length, tokenizer,\n                                                        predict_file)\n    else:\n      file_based_convert_examples_to_features(predict_examples, label_list,\n                                              FLAGS.max_seq_length, tokenizer,\n                                              predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(predict_examples), num_actual_predict_examples,\n                    len(predict_examples) - num_actual_predict_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_drop_remainder = True if FLAGS.use_tpu else False\n    predict_input_fn = file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=predict_drop_remainder)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/albert/run_pretraining.py,97,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run masked LM/next sentence masked_lm pre-training for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport modeling\nimport optimization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(\n    ""input_file"", None,\n    ""Input TF example files (can be a glob or comma separated)."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded. Must match data generation."")\n\nflags.DEFINE_integer(\n    ""max_predictions_per_seq"", 20,\n    ""Maximum number of masked LM predictions per sequence. ""\n    ""Must match data generation."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_integer(""num_train_steps"", 100000, ""Number of training steps."")\n\nflags.DEFINE_integer(""num_warmup_steps"", 10000, ""Number of warmup steps."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(""max_eval_steps"", 100, ""Maximum number of eval steps."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    masked_lm_positions = features[""masked_lm_positions""]\n    masked_lm_ids = features[""masked_lm_ids""]\n    masked_lm_weights = features[""masked_lm_weights""]\n    next_sentence_labels = features[""next_sentence_labels""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    (masked_lm_loss,\n     masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(\n         bert_config, model.get_sequence_output(), model.get_embedding_table(),model.get_embedding_table_2(),\n         masked_lm_positions, masked_lm_ids, masked_lm_weights)\n\n    (next_sentence_loss, next_sentence_example_loss,\n     next_sentence_log_probs) = get_next_sentence_output(\n         bert_config, model.get_pooled_output(), next_sentence_labels)\n\n    total_loss = masked_lm_loss + next_sentence_loss\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    print(""init_checkpoint:"",init_checkpoint)\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n                    masked_lm_weights, next_sentence_example_loss,\n                    next_sentence_log_probs, next_sentence_labels):\n        """"""Computes the loss and accuracy of the model.""""""\n        masked_lm_log_probs = tf.reshape(masked_lm_log_probs,[-1, masked_lm_log_probs.shape[-1]])\n        masked_lm_predictions = tf.argmax(masked_lm_log_probs, axis=-1, output_type=tf.int32)\n        masked_lm_example_loss = tf.reshape(masked_lm_example_loss, [-1])\n        masked_lm_ids = tf.reshape(masked_lm_ids, [-1])\n        masked_lm_weights = tf.reshape(masked_lm_weights, [-1])\n        masked_lm_accuracy = tf.metrics.accuracy(\n            labels=masked_lm_ids,\n            predictions=masked_lm_predictions,\n            weights=masked_lm_weights)\n        masked_lm_mean_loss = tf.metrics.mean(\n            values=masked_lm_example_loss, weights=masked_lm_weights)\n\n        next_sentence_log_probs = tf.reshape(\n            next_sentence_log_probs, [-1, next_sentence_log_probs.shape[-1]])\n        next_sentence_predictions = tf.argmax(\n            next_sentence_log_probs, axis=-1, output_type=tf.int32)\n        next_sentence_labels = tf.reshape(next_sentence_labels, [-1])\n        next_sentence_accuracy = tf.metrics.accuracy(\n            labels=next_sentence_labels, predictions=next_sentence_predictions)\n        next_sentence_mean_loss = tf.metrics.mean(\n            values=next_sentence_example_loss)\n\n        return {\n            ""masked_lm_accuracy"": masked_lm_accuracy,\n            ""masked_lm_loss"": masked_lm_mean_loss,\n            ""next_sentence_accuracy"": next_sentence_accuracy,\n            ""next_sentence_loss"": next_sentence_mean_loss,\n        }\n\n      # next_sentence_example_loss=0.0 TODO\n      # next_sentence_log_probs=0.0 # TODO\n      eval_metrics = (metric_fn, [\n          masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n          masked_lm_weights, next_sentence_example_loss,\n          next_sentence_log_probs, next_sentence_labels\n      ])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(""Only TRAIN and EVAL modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef get_masked_lm_output(bert_config, input_tensor, output_weights,project_weights, positions,\n                         label_ids, label_weights):\n  """"""Get loss and log probs for the masked LM.""""""\n  input_tensor = gather_indexes(input_tensor, positions)\n\n  with tf.variable_scope(""cls/predictions""):\n    # We apply one more non-linear transformation before the output layer.\n    # This matrix is not used after pre-training.\n    with tf.variable_scope(""transform""):\n      input_tensor = tf.layers.dense(\n          input_tensor,\n          units=bert_config.hidden_size,\n          activation=modeling.get_activation(bert_config.hidden_act),\n          kernel_initializer=modeling.create_initializer(\n              bert_config.initializer_range))\n      input_tensor = modeling.layer_norm(input_tensor)\n\n    # The output weights are the same as the input embeddings, but there is\n    # an output-only bias for each token.\n    output_bias = tf.get_variable(\n        ""output_bias"",\n        shape=[bert_config.vocab_size],\n        initializer=tf.zeros_initializer())\n    # logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    # input_tensor=[-1,hidden_size], project_weights=[embedding_size, hidden_size], project_weights_transpose=[hidden_size, embedding_size]--->[-1, embedding_size]\n    input_project = tf.matmul(input_tensor, project_weights, transpose_b=True)\n    logits = tf.matmul(input_project, output_weights, transpose_b=True)\n    #  # input_project=[-1, embedding_size], output_weights=[vocab_size, embedding_size], output_weights_transpose=[embedding_size, vocab_size] ---> [-1, vocab_size]\n\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    label_ids = tf.reshape(label_ids, [-1])\n    label_weights = tf.reshape(label_weights, [-1])\n\n    one_hot_labels = tf.one_hot(label_ids, depth=bert_config.vocab_size, dtype=tf.float32)\n\n    # The `positions` tensor might be zero-padded (if the sequence is too\n    # short to have the maximum number of predictions). The `label_weights`\n    # tensor has a value of 1.0 for every real prediction and 0.0 for the\n    # padding predictions.\n    per_example_loss = -tf.reduce_sum(log_probs * one_hot_labels, axis=[-1])\n    numerator = tf.reduce_sum(label_weights * per_example_loss)\n    denominator = tf.reduce_sum(label_weights) + 1e-5\n    loss = numerator / denominator\n\n  return (loss, per_example_loss, log_probs)\n\n\ndef get_next_sentence_output(bert_config, input_tensor, labels):\n  """"""Get loss and log probs for the next sentence prediction.""""""\n\n  # Simple binary classification. Note that 0 is ""next sentence"" and 1 is\n  # ""random sentence"". This weight matrix is not used after pre-training.\n  with tf.variable_scope(""cls/seq_relationship""):\n    output_weights = tf.get_variable(\n        ""output_weights"",\n        shape=[2, bert_config.hidden_size],\n        initializer=modeling.create_initializer(bert_config.initializer_range))\n    output_bias = tf.get_variable(\n        ""output_bias"", shape=[2], initializer=tf.zeros_initializer())\n\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n    labels = tf.reshape(labels, [-1])\n    one_hot_labels = tf.one_hot(labels, depth=2, dtype=tf.float32)\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n    return (loss, per_example_loss, log_probs)\n\n\ndef gather_indexes(sequence_tensor, positions):\n  """"""Gathers the vectors at the specific positions over a minibatch.""""""\n  sequence_shape = modeling.get_shape_list(sequence_tensor, expected_rank=3)\n  batch_size = sequence_shape[0]\n  seq_length = sequence_shape[1]\n  width = sequence_shape[2]\n\n  flat_offsets = tf.reshape(\n      tf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n  flat_positions = tf.reshape(positions + flat_offsets, [-1])\n  flat_sequence_tensor = tf.reshape(sequence_tensor,\n                                    [batch_size * seq_length, width])\n  output_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n  return output_tensor\n\n\ndef input_fn_builder(input_files,\n                     max_seq_length,\n                     max_predictions_per_seq,\n                     is_training,\n                     num_cpu_threads=4):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    name_to_features = {\n        ""input_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""input_mask"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""segment_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""masked_lm_positions"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_ids"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_weights"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.float32),\n        ""next_sentence_labels"":\n            tf.FixedLenFeature([1], tf.int64),\n    }\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = tf.data.Dataset.from_tensor_slices(tf.constant(input_files))\n      d = d.repeat()\n      d = d.shuffle(buffer_size=len(input_files))\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_cpu_threads, len(input_files))\n\n      # `sloppy` mode means that the interleaving is not exact. This adds\n      # even more randomness to the training pipeline.\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n      d = d.shuffle(buffer_size=100)\n    else:\n      d = tf.data.TFRecordDataset(input_files)\n      # Since we evaluate for a fixed number of steps we don\'t want to encounter\n      # out-of-range exceptions.\n      d = d.repeat()\n\n    # We must `drop_remainder` on training because the TPU requires fixed\n    # size dimensions. For eval, we assume we are evaluating on the CPU or GPU\n    # and we *don\'t* want to drop the remainder, otherwise we wont cover\n    # every sample.\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_cpu_threads,\n            drop_remainder=True))\n    return d\n\n  return input_fn\n\n\ndef _decode_record(record, name_to_features):\n  """"""Decodes a record to a TensorFlow example.""""""\n  example = tf.parse_single_example(record, name_to_features)\n\n  # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n  # So cast all int64 to int32.\n  for name in list(example.keys()):\n    t = example[name]\n    if t.dtype == tf.int64:\n      t = tf.to_int32(t)\n    example[name] = t\n\n  return example\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not FLAGS.do_train and not FLAGS.do_eval: # \xe5\xbf\x85\xe9\xa1\xbb\xe6\x98\xaf\xe8\xae\xad\xe7\xbb\x83\xe6\x88\x96\xe9\xaa\x8c\xe8\xaf\x81\xe7\x9a\x84\xe7\xb1\xbb\xe5\x9e\x8b\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file) # \xe4\xbb\x8ejson\xe6\x96\x87\xe4\xbb\xb6\xe4\xb8\xad\xe8\x8e\xb7\xe5\xbe\x97\xe9\x85\x8d\xe7\xbd\xae\xe4\xbf\xa1\xe6\x81\xaf\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  input_files = [] # \xe8\xbe\x93\xe5\x85\xa5\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x98\xaf\xe5\xa4\x9a\xe4\xb8\xaa\xe6\x96\x87\xe4\xbb\xb6\xef\xbc\x8c\xe4\xbb\xa5\xe2\x80\x9c\xe9\x80\x97\xe5\x8f\xb7\xe9\x9a\x94\xe5\xbc\x80\xe2\x80\x9d\xef\xbc\x9b\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8c\xb9\xe9\x85\x8d\xe5\xbd\xa2\xe5\xbc\x8f\xe7\x9a\x84\xef\xbc\x8c\xe5\xa6\x82\xe2\x80\x9cinput_x*\xe2\x80\x9d\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Input Files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"" % input_file)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n      tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver( # TODO\n            tpu=FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  print(""###tpu_cluster_resolver:"",tpu_cluster_resolver,"";FLAGS.use_tpu:"",FLAGS.use_tpu,"";FLAGS.tpu_name:"",FLAGS.tpu_name,"";FLAGS.tpu_zone:"",FLAGS.tpu_zone)\n  # ###tpu_cluster_resolver: <tensorflow.python.distribute.cluster_resolver.tpu_cluster_resolver.TPUClusterResolver object at 0x7f4b387b06a0> ;FLAGS.use_tpu: True ;FLAGS.tpu_name: grpc://10.240.1.83:8470\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      keep_checkpoint_max=20, # 10\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=FLAGS.num_train_steps,\n      num_warmup_steps=FLAGS.num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size)\n\n  if FLAGS.do_train:\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    train_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=True)\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.num_train_steps)\n\n  if FLAGS.do_eval:\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    eval_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=False)\n\n    result = estimator.evaluate(input_fn=eval_input_fn, steps=FLAGS.max_eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/albert/test_changes.py,5,"b'# coding=utf-8\nimport tensorflow as tf\nfrom modeling import embedding_lookup_factorized,transformer_model\nimport os\n\n""""""\n\xe6\xb5\x8b\xe8\xaf\x95albert\xe4\xb8\xbb\xe8\xa6\x81\xe7\x9a\x84\xe6\x94\xb9\xe8\xbf\x9b\xe7\x82\xb9\xef\xbc\x9a\xe8\xaf\x8d\xe5\xb5\x8c\xe5\x85\xa5\xe7\x9a\x84\xe5\x9b\xa0\xe5\xbc\x8f\xe5\x88\x86\xe8\xa7\xa3\xe3\x80\x81\xe5\xb1\x82\xe9\x97\xb4\xe5\x8f\x82\xe6\x95\xb0\xe5\x85\xb1\xe4\xba\xab\xe3\x80\x81\xe6\xae\xb5\xe8\x90\xbd\xe9\x97\xb4\xe8\xbf\x9e\xe8\xb4\xaf\xe6\x80\xa7\ntest main change of albert from bert\n""""""\nbatch_size = 2048\nsequence_length = 512\nvocab_size = 30000\nhidden_size = 1024\nnum_attention_heads = int(hidden_size / 64)\n\ndef get_total_parameters():\n    """"""\n    get total parameters of a graph\n    :return:\n    """"""\n    total_parameters = 0\n    for variable in tf.trainable_variables():\n        # shape is an array of tf.Dimension\n        shape = variable.get_shape()\n        # print(shape)\n        # print(len(shape))\n        variable_parameters = 1\n        for dim in shape:\n            # print(dim)\n            variable_parameters *= dim.value\n        # print(variable_parameters)\n        total_parameters += variable_parameters\n    return total_parameters\n\ndef test_factorized_embedding():\n    """"""\n    test of Factorized embedding parameterization\n    :return:\n    """"""\n    input_ids=tf.zeros((batch_size, sequence_length),dtype=tf.int32)\n    output, embedding_table, embedding_table_2=embedding_lookup_factorized(input_ids,vocab_size,hidden_size)\n    print(""output:"",output)\n\ndef test_share_parameters():\n    """"""\n    test of share parameters across all layers: how many parameter after share parameter across layers of transformer.\n    :return:\n    """"""\n    def total_parameters_transformer(share_parameter_across_layers):\n        input_tensor=tf.zeros((batch_size, sequence_length, hidden_size),dtype=tf.float32)\n        print(""transformer_model. input:"",input_tensor)\n        transformer_result=transformer_model(input_tensor,hidden_size=hidden_size,num_attention_heads=num_attention_heads,share_parameter_across_layers=share_parameter_across_layers)\n        print(""transformer_result:"",transformer_result)\n        total_parameters=get_total_parameters()\n        print(\'total_parameters(not share):\',total_parameters)\n\n    share_parameter_across_layers=False\n    total_parameters_transformer(share_parameter_across_layers) # total parameters, not share: 125,976,576 = 125 million\n\n    tf.reset_default_graph() # Clears the default graph stack and resets the global default graph\n    share_parameter_across_layers=True\n    total_parameters_transformer(share_parameter_across_layers) #  total parameters,   share: 10,498,048 = 10.5 million\n\ndef test_sentence_order_prediction():\n    """"""\n    sentence order prediction.\n\n    check method of create_instances_from_document_albert from create_pretrining_data.py\n\n    :return:\n    """"""\n    # \xe6\xb7\xbb\xe5\x8a\xa0\xe8\xbf\x90\xe8\xa1\x8c\xe6\x9d\x83\xe9\x99\x90\n    os.system(""chmod +x create_pretrain_data.sh"")\n\n    os.system(""./create_pretrain_data.sh"")\n\n\n# 1.test of Factorized embedding parameterization\n#test_factorized_embedding()\n\n# 2. test of share parameters across all layers: how many parameter after share parameter across layers of transformer.\n# before share parameter: 125,976,576; after share parameter:\n#test_share_parameters()\n\n# 3. test of sentence order prediction(SOP)\ntest_sentence_order_prediction()\n\n'"
baselines/models/albert/tokenization.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\nimport unicodedata\nimport six\nimport tensorflow as tf\n\n\ndef validate_case_matches_checkpoint(do_lower_case, init_checkpoint):\n  """"""Checks whether the casing config is consistent with the checkpoint name.""""""\n\n  # The casing has to be passed in by the user and there is no explicit check\n  # as to whether it matches the checkpoint. The casing information probably\n  # should have been stored in the bert_config.json file, but it\'s not, so\n  # we have to heuristically detect it to validate.\n\n  if not init_checkpoint:\n    return\n\n  m = re.match(""^.*?([A-Za-z0-9_-]+)/bert_model.ckpt"", init_checkpoint)\n  if m is None:\n    return\n\n  model_name = m.group(1)\n\n  lower_models = [\n      ""uncased_L-24_H-1024_A-16"", ""uncased_L-12_H-768_A-12"",\n      ""multilingual_L-12_H-768_A-12"", ""chinese_L-12_H-768_A-12""\n  ]\n\n  cased_models = [\n      ""cased_L-12_H-768_A-12"", ""cased_L-24_H-1024_A-16"",\n      ""multi_cased_L-12_H-768_A-12""\n  ]\n\n  is_bad_config = False\n  if model_name in lower_models and not do_lower_case:\n    is_bad_config = True\n    actual_flag = ""False""\n    case_name = ""lowercased""\n    opposite_flag = ""True""\n\n  if model_name in cased_models and do_lower_case:\n    is_bad_config = True\n    actual_flag = ""True""\n    case_name = ""cased""\n    opposite_flag = ""False""\n\n  if is_bad_config:\n    raise ValueError(\n        ""You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. ""\n        ""However, `%s` seems to be a %s model, so you ""\n        ""should pass in `--do_lower_case=%s` so that the fine-tuning matches ""\n        ""how the model was pre-training. If this error is wrong, please ""\n        ""just comment out this check."" % (actual_flag, init_checkpoint,\n                                          model_name, case_name, opposite_flag))\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  index = 0\n  with tf.gfile.GFile(vocab_file, ""r"") as reader:\n    while True:\n      token = convert_to_unicode(reader.readline())\n      if not token:\n        break\n      token = token.strip()\n      vocab[token] = index\n      index += 1\n  return vocab\n\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  #print(""items:"",items) #[\'[CLS]\', \'\xe6\x97\xa5\', \'##\xe6\x9c\x9f\', \'\xef\xbc\x8c\', \'\xe4\xbd\x86\', \'\xe8\xa2\xab\', \'##\xe5\x91\x8a\', \'\xe9\x87\x91\', \'##\xe4\xb8\x9c\', \'##\xe7\xa6\x8f\', \'\xe8\xbd\xbd\', \'##\xe6\x98\x8e\', \'[MASK]\', \'U\', \'##N\', \'##K\', \']\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe6\x9c\xac\', \'##\xe6\x9c\x88\', \'1\', \'##4\', \'[MASK]\', \'\xe5\x88\xb0\', \'##\xe4\xbd\x8d\', \'\xef\xbc\x8c\', \'2\', \'##0\', \'##1\', \'##5\', \'\xe5\xb9\xb4\', \'6\', \'[MASK]\', \'1\', \'##1\', \'\xe6\x97\xa5\', \'[\', \'U\', \'##N\', \'##K\', \']\', \'\xef\xbc\x8c\', \'\xe5\x8e\x9f\', \'##\xe5\x91\x8a\', \'[MASK]\', \'\xe8\xae\xa4\', \'##\xe5\x8f\xaf\', \'\xe4\xba\x8e\', \'2\', \'##0\', \'##1\', \'##5\', \'[MASK]\', \'6\', \'\xe6\x9c\x88\', \'[MASK]\', \'[MASK]\', \'\xe6\x97\xa5\', \'##\xe5\x90\x91\', \'\xe8\xa2\xab\', \'##\xe5\x91\x8a\', \'\xe4\xb8\xbb\', \'##\xe5\xbc\xa0\', \'\xe6\x9d\x83\', \'##\xe5\x88\xa9\', \'\xe3\x80\x82\', \'\xe8\x80\x8c\', \'[MASK]\', \'[MASK]\', \'\xe8\x87\xaa\', \'[MASK]\', \'[MASK]\', \'[MASK]\', \'[MASK]\', \'\xe5\xb9\xb4\', \'6\', \'\xe6\x9c\x88\', \'1\', \'##1\', \'\xe6\x97\xa5\', \'[SEP]\', \'\xe5\x8e\x9f\', \'##\xe5\x91\x8a\', \'\xe4\xba\x8e\', \'2\', \'##0\', \'##1\', \'##6\', \'[MASK]\', \'6\', \'[MASK]\', \'2\', \'##4\', \'\xe6\x97\xa5\', \'\xe8\xb5\xb7\', \'##\xe8\xaf\x89\', \'\xef\xbc\x8c\', \'\xe4\xb8\xbb\', \'##\xe5\xbc\xa0\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe8\xb4\xa3\', \'##\xe4\xbb\xbb\', \'\xef\xbc\x8c\', \'\xe5\xb7\xb2\', \'\xe8\xb6\x85\', \'##\xe8\xbf\x87\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe6\x9c\x9f\', \'##\xe9\x99\x90\', \'[MASK]\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe4\xba\xba\', \'\xe4\xbe\x9d\', \'##\xe6\xb3\x95\', \'\xe4\xb8\x8d\', \'##\xe5\x86\x8d\', \'\xe6\x89\xbf\', \'##\xe6\x8b\x85\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'[MASK]\', \'[MASK]\', \'[MASK]\', \'[SEP]\']\n  for i,item in enumerate(items):\n    #print(i,""item:"",item) #  ##\xe6\x9c\x9f\n    output.append(vocab[item])\n  return output\n\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True):\n    self.vocab = load_vocab(vocab_file)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n  def tokenize(self, text):\n    split_tokens = []\n    for token in self.basic_tokenizer.tokenize(text):\n      for sub_token in self.wordpiece_tokenizer.tokenize(token):\n        split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    return convert_by_vocab(self.inv_vocab, ids)\n\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = convert_to_unicode(text)\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n  """"""Runs WordPiece tokenziation.""""""\n\n  def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=200):\n    self.vocab = vocab\n    self.unk_token = unk_token\n    self.max_input_chars_per_word = max_input_chars_per_word\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text into its word pieces.\n\n    This uses a greedy longest-match-first algorithm to perform tokenization\n    using the given vocabulary.\n\n    For example:\n      input = ""unaffable""\n      output = [""un"", ""##aff"", ""##able""]\n\n    Args:\n      text: A single token or whitespace separated tokens. This should have\n        already been passed through `BasicTokenizer.\n\n    Returns:\n      A list of wordpiece tokens.\n    """"""\n\n    text = convert_to_unicode(text)\n\n    output_tokens = []\n    for token in whitespace_tokenize(text):\n      chars = list(token)\n      if len(chars) > self.max_input_chars_per_word:\n        output_tokens.append(self.unk_token)\n        continue\n\n      is_bad = False\n      start = 0\n      sub_tokens = []\n      while start < len(chars):\n        end = len(chars)\n        cur_substr = None\n        while start < end:\n          substr = """".join(chars[start:end])\n          if start > 0:\n            substr = ""##"" + substr\n          if substr in self.vocab:\n            cur_substr = substr\n            break\n          end -= 1\n        if cur_substr is None:\n          is_bad = True\n          break\n        sub_tokens.append(cur_substr)\n        start = end\n\n      if is_bad:\n        output_tokens.append(self.unk_token)\n      else:\n        output_tokens.extend(sub_tokens)\n    return output_tokens\n\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically contorl characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
baselines/models/bert/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n'"
baselines/models/bert/conlleval.py,0,"b'# Python version of the evaluation script from CoNLL\'00-\n# Originates from: https://github.com/spyysalo/conlleval.py\n\n\n# Intentional differences:\n# - accept any space as delimiter by default\n# - optional file argument (default STDIN)\n# - option to set boundary (-b argument)\n# - LaTeX output (-l argument) not supported\n# - raw tags (-r argument) not supported\n\n# add function :evaluate(predicted_label, ori_label): which will not read from file\n\nimport sys\nimport re\nimport codecs\nfrom collections import defaultdict, namedtuple\n\nANY_SPACE = \'<SPACE>\'\n\n\nclass FormatError(Exception):\n    pass\n\nMetrics = namedtuple(\'Metrics\', \'tp fp fn prec rec fscore\')\n\n\nclass EvalCounts(object):\n    def __init__(self):\n        self.correct_chunk = 0    # number of correctly identified chunks\n        self.correct_tags = 0     # number of correct chunk tags\n        self.found_correct = 0    # number of chunks in corpus\n        self.found_guessed = 0    # number of identified chunks\n        self.token_counter = 0    # token counter (ignores sentence breaks)\n\n        # counts by type\n        self.t_correct_chunk = defaultdict(int)\n        self.t_found_correct = defaultdict(int)\n        self.t_found_guessed = defaultdict(int)\n\n\ndef parse_args(argv):\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=\'evaluate tagging results using CoNLL criteria\',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    arg = parser.add_argument\n    arg(\'-b\', \'--boundary\', metavar=\'STR\', default=\'-X-\',\n        help=\'sentence boundary\')\n    arg(\'-d\', \'--delimiter\', metavar=\'CHAR\', default=ANY_SPACE,\n        help=\'character delimiting items in input\')\n    arg(\'-o\', \'--otag\', metavar=\'CHAR\', default=\'O\',\n        help=\'alternative outside tag\')\n    arg(\'file\', nargs=\'?\', default=None)\n    return parser.parse_args(argv)\n\n\ndef parse_tag(t):\n    m = re.match(r\'^([^-]*)-(.*)$\', t)\n    return m.groups() if m else (t, \'\')\n\n\ndef evaluate(iterable, options=None):\n    if options is None:\n        options = parse_args([])    # use defaults\n\n    counts = EvalCounts()\n    num_features = None       # number of features per line\n    in_correct = False        # currently processed chunks is correct until now\n    last_correct = \'O\'        # previous chunk tag in corpus\n    last_correct_type = \'\'    # type of previously identified chunk tag\n    last_guessed = \'O\'        # previously identified chunk tag\n    last_guessed_type = \'\'    # type of previous chunk tag in corpus\n\n    for line in iterable:\n        line = line.rstrip(\'\\r\\n\')\n\n        if options.delimiter == ANY_SPACE:\n            features = line.split()\n        else:\n            features = line.split(options.delimiter)\n\n        if num_features is None:\n            num_features = len(features)\n        elif num_features != len(features) and len(features) != 0:\n            raise FormatError(\'unexpected number of features: %d (%d)\' %\n                              (len(features), num_features))\n\n        if len(features) == 0 or features[0] == options.boundary:\n            features = [options.boundary, \'O\', \'O\']\n        if len(features) < 3:\n            raise FormatError(\'unexpected number of features in line %s\' % line)\n\n        guessed, guessed_type = parse_tag(features.pop())\n        correct, correct_type = parse_tag(features.pop())\n        first_item = features.pop(0)\n\n        if first_item == options.boundary:\n            guessed = \'O\'\n\n        end_correct = end_of_chunk(last_correct, correct,\n                                   last_correct_type, correct_type)\n        end_guessed = end_of_chunk(last_guessed, guessed,\n                                   last_guessed_type, guessed_type)\n        start_correct = start_of_chunk(last_correct, correct,\n                                       last_correct_type, correct_type)\n        start_guessed = start_of_chunk(last_guessed, guessed,\n                                       last_guessed_type, guessed_type)\n\n        if in_correct:\n            if (end_correct and end_guessed and\n                last_guessed_type == last_correct_type):\n                in_correct = False\n                counts.correct_chunk += 1\n                counts.t_correct_chunk[last_correct_type] += 1\n            elif (end_correct != end_guessed or guessed_type != correct_type):\n                in_correct = False\n\n        if start_correct and start_guessed and guessed_type == correct_type:\n            in_correct = True\n\n        if start_correct:\n            counts.found_correct += 1\n            counts.t_found_correct[correct_type] += 1\n        if start_guessed:\n            counts.found_guessed += 1\n            counts.t_found_guessed[guessed_type] += 1\n        if first_item != options.boundary:\n            if correct == guessed and guessed_type == correct_type:\n                counts.correct_tags += 1\n            counts.token_counter += 1\n\n        last_guessed = guessed\n        last_correct = correct\n        last_guessed_type = guessed_type\n        last_correct_type = correct_type\n\n    if in_correct:\n        counts.correct_chunk += 1\n        counts.t_correct_chunk[last_correct_type] += 1\n\n    return counts\n\n\n\ndef uniq(iterable):\n  seen = set()\n  return [i for i in iterable if not (i in seen or seen.add(i))]\n\n\ndef calculate_metrics(correct, guessed, total):\n    tp, fp, fn = correct, guessed-correct, total-correct\n    p = 0 if tp + fp == 0 else 1.*tp / (tp + fp)\n    r = 0 if tp + fn == 0 else 1.*tp / (tp + fn)\n    f = 0 if p + r == 0 else 2 * p * r / (p + r)\n    return Metrics(tp, fp, fn, p, r, f)\n\n\ndef metrics(counts):\n    c = counts\n    overall = calculate_metrics(\n        c.correct_chunk, c.found_guessed, c.found_correct\n    )\n    by_type = {}\n    for t in uniq(list(c.t_found_correct) + list(c.t_found_guessed)):\n        by_type[t] = calculate_metrics(\n            c.t_correct_chunk[t], c.t_found_guessed[t], c.t_found_correct[t]\n        )\n    return overall, by_type\n\n\ndef report(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    out.write(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    out.write(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n\n    if c.token_counter > 0:\n        out.write(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        out.write(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        out.write(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n\n    for i, m in sorted(by_type.items()):\n        out.write(\'%17s: \' % i)\n        out.write(\'precision: %6.2f%%; \' % (100.*m.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*m.rec))\n        out.write(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n\n\ndef report_notprint(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    final_report = []\n    line = []\n    line.append(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    line.append(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n    final_report.append("""".join(line))\n\n    if c.token_counter > 0:\n        line = []\n        line.append(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        line.append(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        line.append(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n        final_report.append("""".join(line))\n\n    for i, m in sorted(by_type.items()):\n        line = []\n        line.append(\'%17s: \' % i)\n        line.append(\'precision: %6.2f%%; \' % (100.*m.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*m.rec))\n        line.append(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n        final_report.append("""".join(line))\n    return final_report\n\n\ndef end_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk ended between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_end = False\n\n    if prev_tag == \'E\': chunk_end = True\n    if prev_tag == \'S\': chunk_end = True\n\n    if prev_tag == \'B\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'O\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'O\': chunk_end = True\n\n    if prev_tag != \'O\' and prev_tag != \'.\' and prev_type != type_:\n        chunk_end = True\n\n    # these chunks are assumed to have length 1\n    if prev_tag == \']\': chunk_end = True\n    if prev_tag == \'[\': chunk_end = True\n\n    return chunk_end\n\n\ndef start_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk started between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_start = False\n\n    if tag == \'B\': chunk_start = True\n    if tag == \'S\': chunk_start = True\n\n    if prev_tag == \'E\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'E\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'I\': chunk_start = True\n\n    if tag != \'O\' and tag != \'.\' and prev_type != type_:\n        chunk_start = True\n\n    # these chunks are assumed to have length 1\n    if tag == \'[\': chunk_start = True\n    if tag == \']\': chunk_start = True\n\n    return chunk_start\n\n\ndef return_report(input_file):\n    with codecs.open(input_file, ""r"", ""utf8"") as f:\n        counts = evaluate(f)\n    return report_notprint(counts)\n\n\ndef main(argv):\n    args = parse_args(argv[1:])\n\n    if args.file is None:\n        counts = evaluate(sys.stdin, args)\n    else:\n        with open(args.file) as f:\n            counts = evaluate(f, args)\n    report(counts)\n\nif __name__ == \'__main__\':\n    sys.exit(main(sys.argv))'"
baselines/models/bert/create_pretraining_data.py,17,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\n\nclass TrainingInstance(object):\n  """"""A single training instance (sentence pair).""""""\n\n  def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n               is_random_next):\n    self.tokens = tokens\n    self.segment_ids = segment_ids\n    self.is_random_next = is_random_next\n    self.masked_lm_positions = masked_lm_positions\n    self.masked_lm_labels = masked_lm_labels\n\n  def __str__(self):\n    s = """"\n    s += ""tokens: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.tokens]))\n    s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n    s += ""is_random_next: %s\\n"" % self.is_random_next\n    s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n        [str(x) for x in self.masked_lm_positions]))\n    s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n    s += ""\\n""\n    return s\n\n  def __repr__(self):\n    return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n  """"""Create TF example files from `TrainingInstance`s.""""""\n  writers = []\n  for output_file in output_files:\n    writers.append(tf.python_io.TFRecordWriter(output_file))\n\n  writer_index = 0\n\n  total_written = 0\n  for (inst_index, instance) in enumerate(instances):\n    input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n    input_mask = [1] * len(input_ids)\n    segment_ids = list(instance.segment_ids)\n    assert len(input_ids) <= max_seq_length\n\n    while len(input_ids) < max_seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      segment_ids.append(0)\n\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n\n    masked_lm_positions = list(instance.masked_lm_positions)\n    masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n    masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n    while len(masked_lm_positions) < max_predictions_per_seq:\n      masked_lm_positions.append(0)\n      masked_lm_ids.append(0)\n      masked_lm_weights.append(0.0)\n\n    next_sentence_label = 1 if instance.is_random_next else 0\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(input_ids)\n    features[""input_mask""] = create_int_feature(input_mask)\n    features[""segment_ids""] = create_int_feature(segment_ids)\n    features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n    features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n    features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n    features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n    writers[writer_index].write(tf_example.SerializeToString())\n    writer_index = (writer_index + 1) % len(writers)\n\n    total_written += 1\n\n    if inst_index < 20:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in instance.tokens]))\n\n      for feature_name in features.keys():\n        feature = features[feature_name]\n        values = []\n        if feature.int64_list.value:\n          values = feature.int64_list.value\n        elif feature.float_list.value:\n          values = feature.float_list.value\n        tf.logging.info(\n            ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n  for writer in writers:\n    writer.close()\n\n  tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n  feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n  return feature\n\n\ndef create_float_feature(values):\n  feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n  return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n  """"""Create `TrainingInstance`s from raw text.""""""\n  all_documents = [[]]\n\n  # Input file format:\n  # (1) One sentence per line. These should ideally be actual sentences, not\n  # entire paragraphs or arbitrary spans of text. (Because we use the\n  # sentence boundaries for the ""next sentence prediction"" task).\n  # (2) Blank lines between documents. Document boundaries are needed so\n  # that the ""next sentence prediction"" task doesn\'t span between documents.\n  for input_file in input_files:\n    with tf.gfile.GFile(input_file, ""r"") as reader:\n      while True:\n        line = tokenization.convert_to_unicode(reader.readline())\n        if not line:\n          break\n        line = line.strip()\n\n        # Empty lines are used as document delimiters\n        if not line:\n          all_documents.append([])\n        tokens = tokenizer.tokenize(line)\n        if tokens:\n          all_documents[-1].append(tokens)\n\n  # Remove empty documents\n  all_documents = [x for x in all_documents if x]\n  rng.shuffle(all_documents)\n\n  vocab_words = list(tokenizer.vocab.keys())\n  instances = []\n  for _ in range(dupe_factor):\n    for document_index in range(len(all_documents)):\n      instances.extend(\n          create_instances_from_document(\n              all_documents, document_index, max_seq_length, short_seq_prob,\n              masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n  rng.shuffle(instances)\n  return instances\n\n\ndef create_instances_from_document(\n    all_documents, document_index, max_seq_length, short_seq_prob,\n    masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n  """"""Creates `TrainingInstance`s for a single document.""""""\n  document = all_documents[document_index]\n\n  # Account for [CLS], [SEP], [SEP]\n  max_num_tokens = max_seq_length - 3\n\n  # We *usually* want to fill up the entire sequence since we are padding\n  # to `max_seq_length` anyways, so short sequences are generally wasted\n  # computation. However, we *sometimes*\n  # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n  # sequences to minimize the mismatch between pre-training and fine-tuning.\n  # The `target_seq_length` is just a rough target however, whereas\n  # `max_seq_length` is a hard limit.\n  target_seq_length = max_num_tokens\n  if rng.random() < short_seq_prob:\n    target_seq_length = rng.randint(2, max_num_tokens)\n\n  # We DON\'T just concatenate all of the tokens from a document into a long\n  # sequence and choose an arbitrary split point because this would make the\n  # next sentence prediction task too easy. Instead, we split the input into\n  # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n  # input.\n  instances = []\n  current_chunk = []\n  current_length = 0\n  i = 0\n  while i < len(document):\n    segment = document[i]\n    current_chunk.append(segment)\n    current_length += len(segment)\n    if i == len(document) - 1 or current_length >= target_seq_length:\n      if current_chunk:\n        # `a_end` is how many segments from `current_chunk` go into the `A`\n        # (first) sentence.\n        a_end = 1\n        if len(current_chunk) >= 2:\n          a_end = rng.randint(1, len(current_chunk) - 1)\n\n        tokens_a = []\n        for j in range(a_end):\n          tokens_a.extend(current_chunk[j])\n\n        tokens_b = []\n        # Random next\n        is_random_next = False\n        if len(current_chunk) == 1 or rng.random() < 0.5:\n          is_random_next = True\n          target_b_length = target_seq_length - len(tokens_a)\n\n          # This should rarely go for more than one iteration for large\n          # corpora. However, just to be careful, we try to make sure that\n          # the random document is not the same as the document\n          # we\'re processing.\n          for _ in range(10):\n            random_document_index = rng.randint(0, len(all_documents) - 1)\n            if random_document_index != document_index:\n              break\n\n          random_document = all_documents[random_document_index]\n          random_start = rng.randint(0, len(random_document) - 1)\n          for j in range(random_start, len(random_document)):\n            tokens_b.extend(random_document[j])\n            if len(tokens_b) >= target_b_length:\n              break\n          # We didn\'t actually use these segments so we ""put them back"" so\n          # they don\'t go to waste.\n          num_unused_segments = len(current_chunk) - a_end\n          i -= num_unused_segments\n        # Actual next\n        else:\n          is_random_next = False\n          for j in range(a_end, len(current_chunk)):\n            tokens_b.extend(current_chunk[j])\n        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n        assert len(tokens_a) >= 1\n        assert len(tokens_b) >= 1\n\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n          tokens.append(token)\n          segment_ids.append(0)\n\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        for token in tokens_b:\n          tokens.append(token)\n          segment_ids.append(1)\n        tokens.append(""[SEP]"")\n        segment_ids.append(1)\n\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance(\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n      current_chunk = []\n      current_length = 0\n    i += 1\n\n  return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n  """"""Creates the predictions for the masked LM objective.""""""\n\n  cand_indexes = []\n  for (i, token) in enumerate(tokens):\n    if token == ""[CLS]"" or token == ""[SEP]"":\n      continue\n    # Whole Word Masking means that if we mask all of the wordpieces\n    # corresponding to an original word. When a word has been split into\n    # WordPieces, the first token does not have any marker and any subsequence\n    # tokens are prefixed with ##. So whenever we see the ## token, we\n    # append it to the previous set of word indexes.\n    #\n    # Note that Whole Word Masking does *not* change the training code\n    # at all -- we still predict each WordPiece independently, softmaxed\n    # over the entire vocabulary.\n    if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n        token.startswith(""##"")):\n      cand_indexes[-1].append(i)\n    else:\n      cand_indexes.append([i])\n\n  rng.shuffle(cand_indexes)\n\n  output_tokens = list(tokens)\n\n  num_to_predict = min(max_predictions_per_seq,\n                       max(1, int(round(len(tokens) * masked_lm_prob))))\n\n  masked_lms = []\n  covered_indexes = set()\n  for index_set in cand_indexes:\n    if len(masked_lms) >= num_to_predict:\n      break\n    # If adding a whole-word mask would exceed the maximum number of\n    # predictions, then just skip this candidate.\n    if len(masked_lms) + len(index_set) > num_to_predict:\n      continue\n    is_any_index_covered = False\n    for index in index_set:\n      if index in covered_indexes:\n        is_any_index_covered = True\n        break\n    if is_any_index_covered:\n      continue\n    for index in index_set:\n      covered_indexes.add(index)\n\n      masked_token = None\n      # 80% of the time, replace with [MASK]\n      if rng.random() < 0.8:\n        masked_token = ""[MASK]""\n      else:\n        # 10% of the time, keep original\n        if rng.random() < 0.5:\n          masked_token = tokens[index]\n        # 10% of the time, replace with random word\n        else:\n          masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n      output_tokens[index] = masked_token\n\n      masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n  assert len(masked_lms) <= num_to_predict\n  masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n  masked_lm_positions = []\n  masked_lm_labels = []\n  for p in masked_lms:\n    masked_lm_positions.append(p.index)\n    masked_lm_labels.append(p.label)\n\n  return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n  """"""Truncates a pair of sequences to a maximum sequence length.""""""\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_num_tokens:\n      break\n\n    trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n    assert len(trunc_tokens) >= 1\n\n    # We want to sometimes truncate from the front and sometimes from the\n    # back to add more randomness and avoid biases.\n    if rng.random() < 0.5:\n      del trunc_tokens[0]\n    else:\n      trunc_tokens.pop()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Reading from input files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"", input_file)\n\n  rng = random.Random(FLAGS.random_seed)\n  instances = create_training_instances(\n      input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n      FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n      rng)\n\n  output_files = FLAGS.output_file.split("","")\n  tf.logging.info(""*** Writing to output files ***"")\n  for output_file in output_files:\n    tf.logging.info(""  %s"", output_file)\n\n  write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                  FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""output_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  tf.app.run()\n'"
baselines/models/bert/extract_features.py,34,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Extract pre-computed feature vectors from BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport codecs\nimport collections\nimport json\nimport re\n\nimport modeling\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None, """")\n\nflags.DEFINE_string(""output_file"", None, """")\n\nflags.DEFINE_string(""layers"", ""-1,-2,-3,-4"", """")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(""batch_size"", 32, ""Batch size for predictions."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_string(""master"", None,\n                    ""If using a TPU, the address of the master."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""use_one_hot_embeddings"", False,\n    ""If True, tf.one_hot will be used for embedding lookups, otherwise ""\n    ""tf.nn.embedding_lookup will be used. On TPUs, this should be True ""\n    ""since it is much faster."")\n\n\nclass InputExample(object):\n\n  def __init__(self, unique_id, text_a, text_b):\n    self.unique_id = unique_id\n    self.text_a = text_a\n    self.text_b = text_b\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self, unique_id, tokens, input_ids, input_mask, input_type_ids):\n    self.unique_id = unique_id\n    self.tokens = tokens\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.input_type_ids = input_type_ids\n\n\ndef input_fn_builder(features, seq_length):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_unique_ids = []\n  all_input_ids = []\n  all_input_mask = []\n  all_input_type_ids = []\n\n  for feature in features:\n    all_unique_ids.append(feature.unique_id)\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_input_type_ids.append(feature.input_type_ids)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""unique_ids"":\n            tf.constant(all_unique_ids, shape=[num_examples], dtype=tf.int32),\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_type_ids"":\n            tf.constant(\n                all_input_type_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n    })\n\n    d = d.batch(batch_size=batch_size, drop_remainder=False)\n    return d\n\n  return input_fn\n\n\ndef model_fn_builder(bert_config, init_checkpoint, layer_indexes, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    input_type_ids = features[""input_type_ids""]\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=False,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=input_type_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    if mode != tf.estimator.ModeKeys.PREDICT:\n      raise ValueError(""Only PREDICT modes are supported: %s"" % (mode))\n\n    tvars = tf.trainable_variables()\n    scaffold_fn = None\n    (assignment_map,\n     initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(\n         tvars, init_checkpoint)\n    if use_tpu:\n\n      def tpu_scaffold():\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        return tf.train.Scaffold()\n\n      scaffold_fn = tpu_scaffold\n    else:\n      tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    all_layers = model.get_all_encoder_layers()\n\n    predictions = {\n        ""unique_id"": unique_ids,\n    }\n\n    for (i, layer_index) in enumerate(layer_indexes):\n      predictions[""layer_output_%d"" % i] = all_layers[layer_index]\n\n    output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n        mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\ndef convert_examples_to_features(examples, seq_length, tokenizer):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    tokens_a = tokenizer.tokenize(example.text_a)\n\n    tokens_b = None\n    if example.text_b:\n      tokens_b = tokenizer.tokenize(example.text_b)\n\n    if tokens_b:\n      # Modifies `tokens_a` and `tokens_b` in place so that the total\n      # length is less than the specified length.\n      # Account for [CLS], [SEP], [SEP] with ""- 3""\n      _truncate_seq_pair(tokens_a, tokens_b, seq_length - 3)\n    else:\n      # Account for [CLS] and [SEP] with ""- 2""\n      if len(tokens_a) > seq_length - 2:\n        tokens_a = tokens_a[0:(seq_length - 2)]\n\n    # The convention in BERT is:\n    # (a) For sequence pairs:\n    #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n    #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n    # (b) For single sequences:\n    #  tokens:   [CLS] the dog is hairy . [SEP]\n    #  type_ids: 0     0   0   0  0     0 0\n    #\n    # Where ""type_ids"" are used to indicate whether this is the first\n    # sequence or the second sequence. The embedding vectors for `type=0` and\n    # `type=1` were learned during pre-training and are added to the wordpiece\n    # embedding vector (and position vector). This is not *strictly* necessary\n    # since the [SEP] token unambiguously separates the sequences, but it makes\n    # it easier for the model to learn the concept of sequences.\n    #\n    # For classification tasks, the first vector (corresponding to [CLS]) is\n    # used as as the ""sentence vector"". Note that this only makes sense because\n    # the entire model is fine-tuned.\n    tokens = []\n    input_type_ids = []\n    tokens.append(""[CLS]"")\n    input_type_ids.append(0)\n    for token in tokens_a:\n      tokens.append(token)\n      input_type_ids.append(0)\n    tokens.append(""[SEP]"")\n    input_type_ids.append(0)\n\n    if tokens_b:\n      for token in tokens_b:\n        tokens.append(token)\n        input_type_ids.append(1)\n      tokens.append(""[SEP]"")\n      input_type_ids.append(1)\n\n    input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n    # The mask has 1 for real tokens and 0 for padding tokens. Only real\n    # tokens are attended to.\n    input_mask = [1] * len(input_ids)\n\n    # Zero-pad up to the sequence length.\n    while len(input_ids) < seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      input_type_ids.append(0)\n\n    assert len(input_ids) == seq_length\n    assert len(input_mask) == seq_length\n    assert len(input_type_ids) == seq_length\n\n    if ex_index < 5:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""unique_id: %s"" % (example.unique_id))\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in tokens]))\n      tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n      tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n      tf.logging.info(\n          ""input_type_ids: %s"" % "" "".join([str(x) for x in input_type_ids]))\n\n    features.append(\n        InputFeatures(\n            unique_id=example.unique_id,\n            tokens=tokens,\n            input_ids=input_ids,\n            input_mask=input_mask,\n            input_type_ids=input_type_ids))\n  return features\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef read_examples(input_file):\n  """"""Read a list of `InputExample`s from an input file.""""""\n  examples = []\n  unique_id = 0\n  with tf.gfile.GFile(input_file, ""r"") as reader:\n    while True:\n      line = tokenization.convert_to_unicode(reader.readline())\n      if not line:\n        break\n      line = line.strip()\n      text_a = None\n      text_b = None\n      m = re.match(r""^(.*) \\|\\|\\| (.*)$"", line)\n      if m is None:\n        text_a = line\n      else:\n        text_a = m.group(1)\n        text_b = m.group(2)\n      examples.append(\n          InputExample(unique_id=unique_id, text_a=text_a, text_b=text_b))\n      unique_id += 1\n  return examples\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  layer_indexes = [int(x) for x in FLAGS.layers.split("","")]\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      master=FLAGS.master,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  examples = read_examples(FLAGS.input_file)\n\n  features = convert_examples_to_features(\n      examples=examples, seq_length=FLAGS.max_seq_length, tokenizer=tokenizer)\n\n  unique_id_to_feature = {}\n  for feature in features:\n    unique_id_to_feature[feature.unique_id] = feature\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      layer_indexes=layer_indexes,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_one_hot_embeddings)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      predict_batch_size=FLAGS.batch_size)\n\n  input_fn = input_fn_builder(\n      features=features, seq_length=FLAGS.max_seq_length)\n\n  with codecs.getwriter(""utf-8"")(tf.gfile.Open(FLAGS.output_file,\n                                               ""w"")) as writer:\n    for result in estimator.predict(input_fn, yield_single_examples=True):\n      unique_id = int(result[""unique_id""])\n      feature = unique_id_to_feature[unique_id]\n      output_json = collections.OrderedDict()\n      output_json[""linex_index""] = unique_id\n      all_features = []\n      for (i, token) in enumerate(feature.tokens):\n        all_layers = []\n        for (j, layer_index) in enumerate(layer_indexes):\n          layer_output = result[""layer_output_%d"" % j]\n          layers = collections.OrderedDict()\n          layers[""index""] = layer_index\n          layers[""values""] = [\n              round(float(x), 6) for x in layer_output[i:(i + 1)].flat\n          ]\n          all_layers.append(layers)\n        features = collections.OrderedDict()\n        features[""token""] = token\n        features[""layers""] = all_layers\n        all_features.append(features)\n      output_json[""features""] = all_features\n      writer.write(json.dumps(output_json) + ""\\n"")\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""init_checkpoint"")\n  flags.mark_flag_as_required(""output_file"")\n  tf.app.run()\n'"
baselines/models/bert/modeling.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The main BERT model and related functions.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport numpy as np\nimport six\nimport tensorflow as tf\n\n\nclass BertConfig(object):\n  """"""Configuration for `BertModel`.""""""\n\n  def __init__(self,\n               vocab_size,\n               hidden_size=768,\n               num_hidden_layers=12,\n               num_attention_heads=12,\n               intermediate_size=3072,\n               hidden_act=""gelu"",\n               hidden_dropout_prob=0.1,\n               attention_probs_dropout_prob=0.1,\n               max_position_embeddings=512,\n               type_vocab_size=16,\n               initializer_range=0.02):\n    """"""Constructs BertConfig.\n\n    Args:\n      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.\n      hidden_size: Size of the encoder layers and the pooler layer.\n      num_hidden_layers: Number of hidden layers in the Transformer encoder.\n      num_attention_heads: Number of attention heads for each attention layer in\n        the Transformer encoder.\n      intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n        layer in the Transformer encoder.\n      hidden_act: The non-linear activation function (function or string) in the\n        encoder and pooler.\n      hidden_dropout_prob: The dropout probability for all fully connected\n        layers in the embeddings, encoder, and pooler.\n      attention_probs_dropout_prob: The dropout ratio for the attention\n        probabilities.\n      max_position_embeddings: The maximum sequence length that this model might\n        ever be used with. Typically set this to something large just in case\n        (e.g., 512 or 1024 or 2048).\n      type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n        `BertModel`.\n      initializer_range: The stdev of the truncated_normal_initializer for\n        initializing all weight matrices.\n    """"""\n    self.vocab_size = vocab_size\n    self.hidden_size = hidden_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.hidden_act = hidden_act\n    self.intermediate_size = intermediate_size\n    self.hidden_dropout_prob = hidden_dropout_prob\n    self.attention_probs_dropout_prob = attention_probs_dropout_prob\n    self.max_position_embeddings = max_position_embeddings\n    self.type_vocab_size = type_vocab_size\n    self.initializer_range = initializer_range\n\n  @classmethod\n  def from_dict(cls, json_object):\n    """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n    config = BertConfig(vocab_size=None)\n    for (key, value) in six.iteritems(json_object):\n      config.__dict__[key] = value\n    return config\n\n  @classmethod\n  def from_json_file(cls, json_file):\n    """"""Constructs a `BertConfig` from a json file of parameters.""""""\n    with tf.gfile.GFile(json_file, ""r"") as reader:\n      text = reader.read()\n    return cls.from_dict(json.loads(text))\n\n  def to_dict(self):\n    """"""Serializes this instance to a Python dictionary.""""""\n    output = copy.deepcopy(self.__dict__)\n    return output\n\n  def to_json_string(self):\n    """"""Serializes this instance to a JSON string.""""""\n    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass BertModel(object):\n  """"""BERT model (""Bidirectional Encoder Representations from Transformers"").\n\n  Example usage:\n\n  ```python\n  # Already been converted into WordPiece token ids\n  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])\n  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])\n  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])\n\n  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,\n    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)\n\n  model = modeling.BertModel(config=config, is_training=True,\n    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)\n\n  label_embeddings = tf.get_variable(...)\n  pooled_output = model.get_pooled_output()\n  logits = tf.matmul(pooled_output, label_embeddings)\n  ...\n  ```\n  """"""\n\n  def __init__(self,\n               config,\n               is_training,\n               input_ids,\n               input_mask=None,\n               token_type_ids=None,\n               use_one_hot_embeddings=False,\n               scope=None):\n    """"""Constructor for BertModel.\n\n    Args:\n      config: `BertConfig` instance.\n      is_training: bool. true for training model, false for eval model. Controls\n        whether dropout will be applied.\n      input_ids: int32 Tensor of shape [batch_size, seq_length].\n      input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].\n      token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      use_one_hot_embeddings: (optional) bool. Whether to use one-hot word\n        embeddings or tf.embedding_lookup() for the word embeddings.\n      scope: (optional) variable scope. Defaults to ""bert"".\n\n    Raises:\n      ValueError: The config is invalid or one of the input tensor shapes\n        is invalid.\n    """"""\n    config = copy.deepcopy(config)\n    if not is_training:\n      config.hidden_dropout_prob = 0.0\n      config.attention_probs_dropout_prob = 0.0\n\n    input_shape = get_shape_list(input_ids, expected_rank=2)\n    batch_size = input_shape[0]\n    seq_length = input_shape[1]\n\n    if input_mask is None:\n      input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    if token_type_ids is None:\n      token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    with tf.variable_scope(scope, default_name=""bert""):\n      with tf.variable_scope(""embeddings""):\n        # Perform embedding lookup on the word ids.\n        (self.embedding_output, self.embedding_table) = embedding_lookup(\n            input_ids=input_ids,\n            vocab_size=config.vocab_size,\n            embedding_size=config.hidden_size,\n            initializer_range=config.initializer_range,\n            word_embedding_name=""word_embeddings"",\n            use_one_hot_embeddings=use_one_hot_embeddings)\n\n        # Add positional embeddings and token type embeddings, then layer\n        # normalize and perform dropout.\n        self.embedding_output = embedding_postprocessor(\n            input_tensor=self.embedding_output,\n            use_token_type=True,\n            token_type_ids=token_type_ids,\n            token_type_vocab_size=config.type_vocab_size,\n            token_type_embedding_name=""token_type_embeddings"",\n            use_position_embeddings=True,\n            position_embedding_name=""position_embeddings"",\n            initializer_range=config.initializer_range,\n            max_position_embeddings=config.max_position_embeddings,\n            dropout_prob=config.hidden_dropout_prob)\n\n      with tf.variable_scope(""encoder""):\n        # This converts a 2D mask of shape [batch_size, seq_length] to a 3D\n        # mask of shape [batch_size, seq_length, seq_length] which is used\n        # for the attention scores.\n        attention_mask = create_attention_mask_from_input_mask(\n            input_ids, input_mask)\n\n        # Run the stacked transformer.\n        # `sequence_output` shape = [batch_size, seq_length, hidden_size].\n        self.all_encoder_layers = transformer_model(\n            input_tensor=self.embedding_output,\n            attention_mask=attention_mask,\n            hidden_size=config.hidden_size,\n            num_hidden_layers=config.num_hidden_layers,\n            num_attention_heads=config.num_attention_heads,\n            intermediate_size=config.intermediate_size,\n            intermediate_act_fn=get_activation(config.hidden_act),\n            hidden_dropout_prob=config.hidden_dropout_prob,\n            attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n            initializer_range=config.initializer_range,\n            do_return_all_layers=True)\n\n      self.sequence_output = self.all_encoder_layers[-1]\n      # The ""pooler"" converts the encoded sequence tensor of shape\n      # [batch_size, seq_length, hidden_size] to a tensor of shape\n      # [batch_size, hidden_size]. This is necessary for segment-level\n      # (or segment-pair-level) classification tasks where we need a fixed\n      # dimensional representation of the segment.\n      with tf.variable_scope(""pooler""):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token. We assume that this has been pre-trained\n        first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)\n        self.pooled_output = tf.layers.dense(\n            first_token_tensor,\n            config.hidden_size,\n            activation=tf.tanh,\n            kernel_initializer=create_initializer(config.initializer_range))\n\n  def get_pooled_output(self):\n    return self.pooled_output\n\n  def get_sequence_output(self):\n    """"""Gets final hidden layer of encoder.\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the final hidden of the transformer encoder.\n    """"""\n    return self.sequence_output\n\n  def get_all_encoder_layers(self):\n    return self.all_encoder_layers\n\n  def get_embedding_output(self):\n    """"""Gets output of the embedding lookup (i.e., input to the transformer).\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the output of the embedding layer, after summing the word\n      embeddings with the positional embeddings and the token type embeddings,\n      then performing layer normalization. This is the input to the transformer.\n    """"""\n    return self.embedding_output\n\n  def get_embedding_table(self):\n    return self.embedding_table\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef get_activation(activation_string):\n  """"""Maps a string to a Python function, e.g., ""relu"" => `tf.nn.relu`.\n\n  Args:\n    activation_string: String name of the activation function.\n\n  Returns:\n    A Python function corresponding to the activation function. If\n    `activation_string` is None, empty, or ""linear"", this will return None.\n    If `activation_string` is not a string, it will return `activation_string`.\n\n  Raises:\n    ValueError: The `activation_string` does not correspond to a known\n      activation.\n  """"""\n\n  # We assume that anything that""s not a string is already an activation\n  # function, so we just return it.\n  if not isinstance(activation_string, six.string_types):\n    return activation_string\n\n  if not activation_string:\n    return None\n\n  act = activation_string.lower()\n  if act == ""linear"":\n    return None\n  elif act == ""relu"":\n    return tf.nn.relu\n  elif act == ""gelu"":\n    return gelu\n  elif act == ""tanh"":\n    return tf.tanh\n  else:\n    raise ValueError(""Unsupported activation: %s"" % act)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    if name not in name_to_variable:\n      continue\n    assignment_map[name] = name\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\ndef dropout(input_tensor, dropout_prob):\n  """"""Perform dropout.\n\n  Args:\n    input_tensor: float Tensor.\n    dropout_prob: Python float. The probability of dropping out a value (NOT of\n      *keeping* a dimension as in `tf.nn.dropout`).\n\n  Returns:\n    A version of `input_tensor` with dropout applied.\n  """"""\n  if dropout_prob is None or dropout_prob == 0.0:\n    return input_tensor\n\n  output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob)\n  return output\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n  """"""Runs layer normalization followed by dropout.""""""\n  output_tensor = layer_norm(input_tensor, name)\n  output_tensor = dropout(output_tensor, dropout_prob)\n  return output_tensor\n\n\ndef create_initializer(initializer_range=0.02):\n  """"""Creates a `truncated_normal_initializer` with the given range.""""""\n  return tf.truncated_normal_initializer(stddev=initializer_range)\n\n\ndef embedding_lookup(input_ids,\n                     vocab_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n  """"""Looks up words embeddings for id tensor.\n\n  Args:\n    input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n      ids.\n    vocab_size: int. Size of the embedding vocabulary.\n    embedding_size: int. Width of the word embeddings.\n    initializer_range: float. Embedding initialization range.\n    word_embedding_name: string. Name of the embedding table.\n    use_one_hot_embeddings: bool. If True, use one-hot method for word\n      embeddings. If False, use `tf.gather()`.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, embedding_size].\n  """"""\n  # This function assumes that the input is of shape [batch_size, seq_length,\n  # num_inputs].\n  #\n  # If the input is a 2D tensor of shape [batch_size, seq_length], we\n  # reshape to [batch_size, seq_length, 1].\n  if input_ids.shape.ndims == 2:\n    input_ids = tf.expand_dims(input_ids, axis=[-1])\n\n  embedding_table = tf.get_variable(\n      name=word_embedding_name,\n      shape=[vocab_size, embedding_size],\n      initializer=create_initializer(initializer_range))\n\n  flat_input_ids = tf.reshape(input_ids, [-1])\n  if use_one_hot_embeddings:\n    one_hot_input_ids = tf.one_hot(flat_input_ids, depth=vocab_size)\n    output = tf.matmul(one_hot_input_ids, embedding_table)\n  else:\n    output = tf.gather(embedding_table, flat_input_ids)\n\n  input_shape = get_shape_list(input_ids)\n\n  output = tf.reshape(output,\n                      input_shape[0:-1] + [input_shape[-1] * embedding_size])\n  return (output, embedding_table)\n\n\ndef embedding_postprocessor(input_tensor,\n                            use_token_type=False,\n                            token_type_ids=None,\n                            token_type_vocab_size=16,\n                            token_type_embedding_name=""token_type_embeddings"",\n                            use_position_embeddings=True,\n                            position_embedding_name=""position_embeddings"",\n                            initializer_range=0.02,\n                            max_position_embeddings=512,\n                            dropout_prob=0.1):\n  """"""Performs various post-processing on a word embedding tensor.\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length,\n      embedding_size].\n    use_token_type: bool. Whether to add embeddings for `token_type_ids`.\n    token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      Must be specified if `use_token_type` is True.\n    token_type_vocab_size: int. The vocabulary size of `token_type_ids`.\n    token_type_embedding_name: string. The name of the embedding table variable\n      for token type ids.\n    use_position_embeddings: bool. Whether to add position embeddings for the\n      position of each token in the sequence.\n    position_embedding_name: string. The name of the embedding table variable\n      for positional embeddings.\n    initializer_range: float. Range of the weight initialization.\n    max_position_embeddings: int. Maximum sequence length that might ever be\n      used with this model. This can be longer than the sequence length of\n      input_tensor, but cannot be shorter.\n    dropout_prob: float. Dropout probability applied to the final output tensor.\n\n  Returns:\n    float tensor with same shape as `input_tensor`.\n\n  Raises:\n    ValueError: One of the tensor shapes or input values is invalid.\n  """"""\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  width = input_shape[2]\n\n  output = input_tensor\n\n  if use_token_type:\n    if token_type_ids is None:\n      raise ValueError(""`token_type_ids` must be specified if""\n                       ""`use_token_type` is True."")\n    token_type_table = tf.get_variable(\n        name=token_type_embedding_name,\n        shape=[token_type_vocab_size, width],\n        initializer=create_initializer(initializer_range))\n    # This vocab will be small so we always do one-hot here, since it is always\n    # faster for a small vocabulary.\n    flat_token_type_ids = tf.reshape(token_type_ids, [-1])\n    one_hot_ids = tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)\n    token_type_embeddings = tf.matmul(one_hot_ids, token_type_table)\n    token_type_embeddings = tf.reshape(token_type_embeddings,\n                                       [batch_size, seq_length, width])\n    output += token_type_embeddings\n\n  if use_position_embeddings:\n    assert_op = tf.assert_less_equal(seq_length, max_position_embeddings)\n    with tf.control_dependencies([assert_op]):\n      full_position_embeddings = tf.get_variable(\n          name=position_embedding_name,\n          shape=[max_position_embeddings, width],\n          initializer=create_initializer(initializer_range))\n      # Since the position embedding table is a learned variable, we create it\n      # using a (long) sequence length `max_position_embeddings`. The actual\n      # sequence length might be shorter than this, for faster training of\n      # tasks that do not have long sequences.\n      #\n      # So `full_position_embeddings` is effectively an embedding table\n      # for position [0, 1, 2, ..., max_position_embeddings-1], and the current\n      # sequence has positions [0, 1, 2, ... seq_length-1], so we can just\n      # perform a slice.\n      position_embeddings = tf.slice(full_position_embeddings, [0, 0],\n                                     [seq_length, -1])\n      num_dims = len(output.shape.as_list())\n\n      # Only the last two dimensions are relevant (`seq_length` and `width`), so\n      # we broadcast among the first dimensions, which is typically just\n      # the batch size.\n      position_broadcast_shape = []\n      for _ in range(num_dims - 2):\n        position_broadcast_shape.append(1)\n      position_broadcast_shape.extend([seq_length, width])\n      position_embeddings = tf.reshape(position_embeddings,\n                                       position_broadcast_shape)\n      output += position_embeddings\n\n  output = layer_norm_and_dropout(output, dropout_prob)\n  return output\n\n\ndef create_attention_mask_from_input_mask(from_tensor, to_mask):\n  """"""Create 3D attention mask from a 2D tensor mask.\n\n  Args:\n    from_tensor: 2D or 3D Tensor of shape [batch_size, from_seq_length, ...].\n    to_mask: int32 Tensor of shape [batch_size, to_seq_length].\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length, to_seq_length].\n  """"""\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  batch_size = from_shape[0]\n  from_seq_length = from_shape[1]\n\n  to_shape = get_shape_list(to_mask, expected_rank=2)\n  to_seq_length = to_shape[1]\n\n  to_mask = tf.cast(\n      tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)\n\n  # We don\'t assume that `from_tensor` is a mask (although it could be). We\n  # don\'t actually care if we attend *from* padding tokens (only *to* padding)\n  # tokens so we create a tensor of all ones.\n  #\n  # `broadcast_ones` = [batch_size, from_seq_length, 1]\n  broadcast_ones = tf.ones(\n      shape=[batch_size, from_seq_length, 1], dtype=tf.float32)\n\n  # Here we broadcast along two dimensions to create the mask.\n  mask = broadcast_ones * to_mask\n\n  return mask\n\n\ndef attention_layer(from_tensor,\n                    to_tensor,\n                    attention_mask=None,\n                    num_attention_heads=1,\n                    size_per_head=512,\n                    query_act=None,\n                    key_act=None,\n                    value_act=None,\n                    attention_probs_dropout_prob=0.0,\n                    initializer_range=0.02,\n                    do_return_2d_tensor=False,\n                    batch_size=None,\n                    from_seq_length=None,\n                    to_seq_length=None):\n  """"""Performs multi-headed attention from `from_tensor` to `to_tensor`.\n\n  This is an implementation of multi-headed attention based on ""Attention\n  is all you Need"". If `from_tensor` and `to_tensor` are the same, then\n  this is self-attention. Each timestep in `from_tensor` attends to the\n  corresponding sequence in `to_tensor`, and returns a fixed-with vector.\n\n  This function first projects `from_tensor` into a ""query"" tensor and\n  `to_tensor` into ""key"" and ""value"" tensors. These are (effectively) a list\n  of tensors of length `num_attention_heads`, where each tensor is of shape\n  [batch_size, seq_length, size_per_head].\n\n  Then, the query and key tensors are dot-producted and scaled. These are\n  softmaxed to obtain attention probabilities. The value tensors are then\n  interpolated by these probabilities, then concatenated back to a single\n  tensor and returned.\n\n  In practice, the multi-headed attention are done with transposes and\n  reshapes rather than actual separate tensors.\n\n  Args:\n    from_tensor: float Tensor of shape [batch_size, from_seq_length,\n      from_width].\n    to_tensor: float Tensor of shape [batch_size, to_seq_length, to_width].\n    attention_mask: (optional) int32 Tensor of shape [batch_size,\n      from_seq_length, to_seq_length]. The values should be 1 or 0. The\n      attention scores will effectively be set to -infinity for any positions in\n      the mask that are 0, and will be unchanged for positions that are 1.\n    num_attention_heads: int. Number of attention heads.\n    size_per_head: int. Size of each attention head.\n    query_act: (optional) Activation function for the query transform.\n    key_act: (optional) Activation function for the key transform.\n    value_act: (optional) Activation function for the value transform.\n    attention_probs_dropout_prob: (optional) float. Dropout probability of the\n      attention probabilities.\n    initializer_range: float. Range of the weight initializer.\n    do_return_2d_tensor: bool. If True, the output will be of shape [batch_size\n      * from_seq_length, num_attention_heads * size_per_head]. If False, the\n      output will be of shape [batch_size, from_seq_length, num_attention_heads\n      * size_per_head].\n    batch_size: (Optional) int. If the input is 2D, this might be the batch size\n      of the 3D version of the `from_tensor` and `to_tensor`.\n    from_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `from_tensor`.\n    to_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `to_tensor`.\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length,\n      num_attention_heads * size_per_head]. (If `do_return_2d_tensor` is\n      true, this will be of shape [batch_size * from_seq_length,\n      num_attention_heads * size_per_head]).\n\n  Raises:\n    ValueError: Any of the arguments or tensor shapes are invalid.\n  """"""\n\n  def transpose_for_scores(input_tensor, batch_size, num_attention_heads,\n                           seq_length, width):\n    output_tensor = tf.reshape(\n        input_tensor, [batch_size, seq_length, num_attention_heads, width])\n\n    output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])\n    return output_tensor\n\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])\n\n  if len(from_shape) != len(to_shape):\n    raise ValueError(\n        ""The rank of `from_tensor` must match the rank of `to_tensor`."")\n\n  if len(from_shape) == 3:\n    batch_size = from_shape[0]\n    from_seq_length = from_shape[1]\n    to_seq_length = to_shape[1]\n  elif len(from_shape) == 2:\n    if (batch_size is None or from_seq_length is None or to_seq_length is None):\n      raise ValueError(\n          ""When passing in rank 2 tensors to attention_layer, the values ""\n          ""for `batch_size`, `from_seq_length`, and `to_seq_length` ""\n          ""must all be specified."")\n\n  # Scalar dimensions referenced here:\n  #   B = batch size (number of sequences)\n  #   F = `from_tensor` sequence length\n  #   T = `to_tensor` sequence length\n  #   N = `num_attention_heads`\n  #   H = `size_per_head`\n\n  from_tensor_2d = reshape_to_matrix(from_tensor)\n  to_tensor_2d = reshape_to_matrix(to_tensor)\n\n  # `query_layer` = [B*F, N*H]\n  query_layer = tf.layers.dense(\n      from_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=query_act,\n      name=""query"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `key_layer` = [B*T, N*H]\n  key_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=key_act,\n      name=""key"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `value_layer` = [B*T, N*H]\n  value_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=value_act,\n      name=""value"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `query_layer` = [B, N, F, H]\n  query_layer = transpose_for_scores(query_layer, batch_size,\n                                     num_attention_heads, from_seq_length,\n                                     size_per_head)\n\n  # `key_layer` = [B, N, T, H]\n  key_layer = transpose_for_scores(key_layer, batch_size, num_attention_heads,\n                                   to_seq_length, size_per_head)\n\n  # Take the dot product between ""query"" and ""key"" to get the raw\n  # attention scores.\n  # `attention_scores` = [B, N, F, T]\n  attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)\n  attention_scores = tf.multiply(attention_scores,\n                                 1.0 / math.sqrt(float(size_per_head)))\n\n  if attention_mask is not None:\n    # `attention_mask` = [B, 1, F, T]\n    attention_mask = tf.expand_dims(attention_mask, axis=[1])\n\n    # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n    # masked positions, this operation will create a tensor which is 0.0 for\n    # positions we want to attend and -10000.0 for masked positions.\n    adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0\n\n    # Since we are adding it to the raw scores before the softmax, this is\n    # effectively the same as removing these entirely.\n    attention_scores += adder\n\n  # Normalize the attention scores to probabilities.\n  # `attention_probs` = [B, N, F, T]\n  attention_probs = tf.nn.softmax(attention_scores)\n\n  # This is actually dropping out entire tokens to attend to, which might\n  # seem a bit unusual, but is taken from the original Transformer paper.\n  attention_probs = dropout(attention_probs, attention_probs_dropout_prob)\n\n  # `value_layer` = [B, T, N, H]\n  value_layer = tf.reshape(\n      value_layer,\n      [batch_size, to_seq_length, num_attention_heads, size_per_head])\n\n  # `value_layer` = [B, N, T, H]\n  value_layer = tf.transpose(value_layer, [0, 2, 1, 3])\n\n  # `context_layer` = [B, N, F, H]\n  context_layer = tf.matmul(attention_probs, value_layer)\n\n  # `context_layer` = [B, F, N, H]\n  context_layer = tf.transpose(context_layer, [0, 2, 1, 3])\n\n  if do_return_2d_tensor:\n    # `context_layer` = [B*F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size * from_seq_length, num_attention_heads * size_per_head])\n  else:\n    # `context_layer` = [B, F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size, from_seq_length, num_attention_heads * size_per_head])\n\n  return context_layer\n\n\ndef transformer_model(input_tensor,\n                      attention_mask=None,\n                      hidden_size=768,\n                      num_hidden_layers=12,\n                      num_attention_heads=12,\n                      intermediate_size=3072,\n                      intermediate_act_fn=gelu,\n                      hidden_dropout_prob=0.1,\n                      attention_probs_dropout_prob=0.1,\n                      initializer_range=0.02,\n                      do_return_all_layers=False):\n  """"""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n  This is almost an exact implementation of the original Transformer encoder.\n\n  See the original paper:\n  https://arxiv.org/abs/1706.03762\n\n  Also see:\n  https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n    attention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n      seq_length], with 1 for positions that can be attended to and 0 in\n      positions that should not be.\n    hidden_size: int. Hidden size of the Transformer.\n    num_hidden_layers: int. Number of layers (blocks) in the Transformer.\n    num_attention_heads: int. Number of attention heads in the Transformer.\n    intermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n      forward) layer.\n    intermediate_act_fn: function. The non-linear activation function to apply\n      to the output of the intermediate/feed-forward layer.\n    hidden_dropout_prob: float. Dropout probability for the hidden layers.\n    attention_probs_dropout_prob: float. Dropout probability of the attention\n      probabilities.\n    initializer_range: float. Range of the initializer (stddev of truncated\n      normal).\n    do_return_all_layers: Whether to also return all layers or just the final\n      layer.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, hidden_size], the final\n    hidden layer of the Transformer.\n\n  Raises:\n    ValueError: A Tensor shape or parameter is invalid.\n  """"""\n  if hidden_size % num_attention_heads != 0:\n    raise ValueError(\n        ""The hidden size (%d) is not a multiple of the number of attention ""\n        ""heads (%d)"" % (hidden_size, num_attention_heads))\n\n  attention_head_size = int(hidden_size / num_attention_heads)\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  input_width = input_shape[2]\n\n  # The Transformer performs sum residuals on all layers so the input needs\n  # to be the same as the hidden size.\n  if input_width != hidden_size:\n    raise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n                     (input_width, hidden_size))\n\n  # We keep the representation as a 2D tensor to avoid re-shaping it back and\n  # forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n  # the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n  # help the optimizer.\n  prev_output = reshape_to_matrix(input_tensor)\n\n  all_layer_outputs = []\n  for layer_idx in range(num_hidden_layers):\n    with tf.variable_scope(""layer_%d"" % layer_idx):\n      layer_input = prev_output\n\n      with tf.variable_scope(""attention""):\n        attention_heads = []\n        with tf.variable_scope(""self""):\n          attention_head = attention_layer(\n              from_tensor=layer_input,\n              to_tensor=layer_input,\n              attention_mask=attention_mask,\n              num_attention_heads=num_attention_heads,\n              size_per_head=attention_head_size,\n              attention_probs_dropout_prob=attention_probs_dropout_prob,\n              initializer_range=initializer_range,\n              do_return_2d_tensor=True,\n              batch_size=batch_size,\n              from_seq_length=seq_length,\n              to_seq_length=seq_length)\n          attention_heads.append(attention_head)\n\n        attention_output = None\n        if len(attention_heads) == 1:\n          attention_output = attention_heads[0]\n        else:\n          # In the case where we have other sequences, we just concatenate\n          # them to the self-attention head before the projection.\n          attention_output = tf.concat(attention_heads, axis=-1)\n\n        # Run a linear projection of `hidden_size` then add a residual\n        # with `layer_input`.\n        with tf.variable_scope(""output""):\n          attention_output = tf.layers.dense(\n              attention_output,\n              hidden_size,\n              kernel_initializer=create_initializer(initializer_range))\n          attention_output = dropout(attention_output, hidden_dropout_prob)\n          attention_output = layer_norm(attention_output + layer_input)\n\n      # The activation is only applied to the ""intermediate"" hidden layer.\n      with tf.variable_scope(""intermediate""):\n        intermediate_output = tf.layers.dense(\n            attention_output,\n            intermediate_size,\n            activation=intermediate_act_fn,\n            kernel_initializer=create_initializer(initializer_range))\n\n      # Down-project back to `hidden_size` then add the residual.\n      with tf.variable_scope(""output""):\n        layer_output = tf.layers.dense(\n            intermediate_output,\n            hidden_size,\n            kernel_initializer=create_initializer(initializer_range))\n        layer_output = dropout(layer_output, hidden_dropout_prob)\n        layer_output = layer_norm(layer_output + attention_output)\n        prev_output = layer_output\n        all_layer_outputs.append(layer_output)\n\n  if do_return_all_layers:\n    final_outputs = []\n    for layer_output in all_layer_outputs:\n      final_output = reshape_from_matrix(layer_output, input_shape)\n      final_outputs.append(final_output)\n    return final_outputs\n  else:\n    final_output = reshape_from_matrix(prev_output, input_shape)\n    return final_output\n\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n  """"""Returns a list of the shape of tensor, preferring static dimensions.\n\n  Args:\n    tensor: A tf.Tensor object to find the shape of.\n    expected_rank: (optional) int. The expected rank of `tensor`. If this is\n      specified and the `tensor` has a different rank, and exception will be\n      thrown.\n    name: Optional name of the tensor for the error message.\n\n  Returns:\n    A list of dimensions of the shape of tensor. All static dimensions will\n    be returned as python integers, and dynamic dimensions will be returned\n    as tf.Tensor scalars.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  if expected_rank is not None:\n    assert_rank(tensor, expected_rank, name)\n\n  shape = tensor.shape.as_list()\n\n  non_static_indexes = []\n  for (index, dim) in enumerate(shape):\n    if dim is None:\n      non_static_indexes.append(index)\n\n  if not non_static_indexes:\n    return shape\n\n  dyn_shape = tf.shape(tensor)\n  for index in non_static_indexes:\n    shape[index] = dyn_shape[index]\n  return shape\n\n\ndef reshape_to_matrix(input_tensor):\n  """"""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n  ndims = input_tensor.shape.ndims\n  if ndims < 2:\n    raise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n                     (input_tensor.shape))\n  if ndims == 2:\n    return input_tensor\n\n  width = input_tensor.shape[-1]\n  output_tensor = tf.reshape(input_tensor, [-1, width])\n  return output_tensor\n\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n  """"""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n  if len(orig_shape_list) == 2:\n    return output_tensor\n\n  output_shape = get_shape_list(output_tensor)\n\n  orig_dims = orig_shape_list[0:-1]\n  width = output_shape[-1]\n\n  return tf.reshape(output_tensor, orig_dims + [width])\n\n\ndef assert_rank(tensor, expected_rank, name=None):\n  """"""Raises an exception if the tensor rank is not of the expected rank.\n\n  Args:\n    tensor: A tf.Tensor to check the rank of.\n    expected_rank: Python integer or list of integers, expected rank.\n    name: Optional name of the tensor for the error message.\n\n  Raises:\n    ValueError: If the expected shape doesn\'t match the actual shape.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  expected_rank_dict = {}\n  if isinstance(expected_rank, six.integer_types):\n    expected_rank_dict[expected_rank] = True\n  else:\n    for x in expected_rank:\n      expected_rank_dict[x] = True\n\n  actual_rank = tensor.shape.ndims\n  if actual_rank not in expected_rank_dict:\n    scope_name = tf.get_variable_scope().name\n    raise ValueError(\n        ""For the tensor `%s` in scope `%s`, the actual rank ""\n        ""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n        (name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n'"
baselines/models/bert/modeling_test.py,5,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport random\nimport re\n\nimport modeling\nimport six\nimport tensorflow as tf\n\n\nclass BertModelTest(tf.test.TestCase):\n\n  class BertModelTester(object):\n\n    def __init__(self,\n                 parent,\n                 batch_size=13,\n                 seq_length=7,\n                 is_training=True,\n                 use_input_mask=True,\n                 use_token_type_ids=True,\n                 vocab_size=99,\n                 hidden_size=32,\n                 num_hidden_layers=5,\n                 num_attention_heads=4,\n                 intermediate_size=37,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=16,\n                 initializer_range=0.02,\n                 scope=None):\n      self.parent = parent\n      self.batch_size = batch_size\n      self.seq_length = seq_length\n      self.is_training = is_training\n      self.use_input_mask = use_input_mask\n      self.use_token_type_ids = use_token_type_ids\n      self.vocab_size = vocab_size\n      self.hidden_size = hidden_size\n      self.num_hidden_layers = num_hidden_layers\n      self.num_attention_heads = num_attention_heads\n      self.intermediate_size = intermediate_size\n      self.hidden_act = hidden_act\n      self.hidden_dropout_prob = hidden_dropout_prob\n      self.attention_probs_dropout_prob = attention_probs_dropout_prob\n      self.max_position_embeddings = max_position_embeddings\n      self.type_vocab_size = type_vocab_size\n      self.initializer_range = initializer_range\n      self.scope = scope\n\n    def create_model(self):\n      input_ids = BertModelTest.ids_tensor([self.batch_size, self.seq_length],\n                                           self.vocab_size)\n\n      input_mask = None\n      if self.use_input_mask:\n        input_mask = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], vocab_size=2)\n\n      token_type_ids = None\n      if self.use_token_type_ids:\n        token_type_ids = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], self.type_vocab_size)\n\n      config = modeling.BertConfig(\n          vocab_size=self.vocab_size,\n          hidden_size=self.hidden_size,\n          num_hidden_layers=self.num_hidden_layers,\n          num_attention_heads=self.num_attention_heads,\n          intermediate_size=self.intermediate_size,\n          hidden_act=self.hidden_act,\n          hidden_dropout_prob=self.hidden_dropout_prob,\n          attention_probs_dropout_prob=self.attention_probs_dropout_prob,\n          max_position_embeddings=self.max_position_embeddings,\n          type_vocab_size=self.type_vocab_size,\n          initializer_range=self.initializer_range)\n\n      model = modeling.BertModel(\n          config=config,\n          is_training=self.is_training,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          token_type_ids=token_type_ids,\n          scope=self.scope)\n\n      outputs = {\n          ""embedding_output"": model.get_embedding_output(),\n          ""sequence_output"": model.get_sequence_output(),\n          ""pooled_output"": model.get_pooled_output(),\n          ""all_encoder_layers"": model.get_all_encoder_layers(),\n      }\n      return outputs\n\n    def check_output(self, result):\n      self.parent.assertAllEqual(\n          result[""embedding_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(\n          result[""sequence_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(result[""pooled_output""].shape,\n                                 [self.batch_size, self.hidden_size])\n\n  def test_default(self):\n    self.run_tester(BertModelTest.BertModelTester(self))\n\n  def test_config_to_json_string(self):\n    config = modeling.BertConfig(vocab_size=99, hidden_size=37)\n    obj = json.loads(config.to_json_string())\n    self.assertEqual(obj[""vocab_size""], 99)\n    self.assertEqual(obj[""hidden_size""], 37)\n\n  def run_tester(self, tester):\n    with self.test_session() as sess:\n      ops = tester.create_model()\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      output_result = sess.run(ops)\n      tester.check_output(output_result)\n\n      self.assert_all_tensors_reachable(sess, [init_op, ops])\n\n  @classmethod\n  def ids_tensor(cls, shape, vocab_size, rng=None, name=None):\n    """"""Creates a random int32 tensor of the shape within the vocab size.""""""\n    if rng is None:\n      rng = random.Random()\n\n    total_dims = 1\n    for dim in shape:\n      total_dims *= dim\n\n    values = []\n    for _ in range(total_dims):\n      values.append(rng.randint(0, vocab_size - 1))\n\n    return tf.constant(value=values, dtype=tf.int32, shape=shape, name=name)\n\n  def assert_all_tensors_reachable(self, sess, outputs):\n    """"""Checks that all the tensors in the graph are reachable from outputs.""""""\n    graph = sess.graph\n\n    ignore_strings = [\n        ""^.*/assert_less_equal/.*$"",\n        ""^.*/dilation_rate$"",\n        ""^.*/Tensordot/concat$"",\n        ""^.*/Tensordot/concat/axis$"",\n        ""^testing/.*$"",\n    ]\n\n    ignore_regexes = [re.compile(x) for x in ignore_strings]\n\n    unreachable = self.get_unreachable_ops(graph, outputs)\n    filtered_unreachable = []\n    for x in unreachable:\n      do_ignore = False\n      for r in ignore_regexes:\n        m = r.match(x.name)\n        if m is not None:\n          do_ignore = True\n      if do_ignore:\n        continue\n      filtered_unreachable.append(x)\n    unreachable = filtered_unreachable\n\n    self.assertEqual(\n        len(unreachable), 0, ""The following ops are unreachable: %s"" %\n        ("" "".join([x.name for x in unreachable])))\n\n  @classmethod\n  def get_unreachable_ops(cls, graph, outputs):\n    """"""Finds all of the tensors in graph that are unreachable from outputs.""""""\n    outputs = cls.flatten_recursive(outputs)\n    output_to_op = collections.defaultdict(list)\n    op_to_all = collections.defaultdict(list)\n    assign_out_to_in = collections.defaultdict(list)\n\n    for op in graph.get_operations():\n      for x in op.inputs:\n        op_to_all[op.name].append(x.name)\n      for y in op.outputs:\n        output_to_op[y.name].append(op.name)\n        op_to_all[op.name].append(y.name)\n      if str(op.type) == ""Assign"":\n        for y in op.outputs:\n          for x in op.inputs:\n            assign_out_to_in[y.name].append(x.name)\n\n    assign_groups = collections.defaultdict(list)\n    for out_name in assign_out_to_in.keys():\n      name_group = assign_out_to_in[out_name]\n      for n1 in name_group:\n        assign_groups[n1].append(out_name)\n        for n2 in name_group:\n          if n1 != n2:\n            assign_groups[n1].append(n2)\n\n    seen_tensors = {}\n    stack = [x.name for x in outputs]\n    while stack:\n      name = stack.pop()\n      if name in seen_tensors:\n        continue\n      seen_tensors[name] = True\n\n      if name in output_to_op:\n        for op_name in output_to_op[name]:\n          if op_name in op_to_all:\n            for input_name in op_to_all[op_name]:\n              if input_name not in stack:\n                stack.append(input_name)\n\n      expanded_names = []\n      if name in assign_groups:\n        for assign_name in assign_groups[name]:\n          expanded_names.append(assign_name)\n\n      for expanded_name in expanded_names:\n        if expanded_name not in stack:\n          stack.append(expanded_name)\n\n    unreachable_ops = []\n    for op in graph.get_operations():\n      is_unreachable = False\n      all_names = [x.name for x in op.inputs] + [x.name for x in op.outputs]\n      for name in all_names:\n        if name not in seen_tensors:\n          is_unreachable = True\n      if is_unreachable:\n        unreachable_ops.append(op)\n    return unreachable_ops\n\n  @classmethod\n  def flatten_recursive(cls, item):\n    """"""Flattens (potentially nested) a tuple/dictionary/list to a list.""""""\n    output = []\n    if isinstance(item, list):\n      output.extend(item)\n    elif isinstance(item, tuple):\n      output.extend(list(item))\n    elif isinstance(item, dict):\n      for (_, v) in six.iteritems(item):\n        output.append(v)\n    else:\n      return [item]\n\n    flat_output = []\n    for x in output:\n      flat_output.extend(cls.flatten_recursive(x))\n    return flat_output\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/bert/optimization.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/bert/optimization_test.py,11,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport optimization\nimport tensorflow as tf\n\n\nclass OptimizationTest(tf.test.TestCase):\n\n  def test_adam(self):\n    with self.test_session() as sess:\n      w = tf.get_variable(\n          ""w"",\n          shape=[3],\n          initializer=tf.constant_initializer([0.1, -0.2, -0.1]))\n      x = tf.constant([0.4, 0.2, -0.5])\n      loss = tf.reduce_mean(tf.square(x - w))\n      tvars = tf.trainable_variables()\n      grads = tf.gradients(loss, tvars)\n      global_step = tf.train.get_or_create_global_step()\n      optimizer = optimization.AdamWeightDecayOptimizer(learning_rate=0.2)\n      train_op = optimizer.apply_gradients(zip(grads, tvars), global_step)\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      for _ in range(100):\n        sess.run(train_op)\n      w_np = sess.run(w)\n      self.assertAllClose(w_np.flat, [0.4, 0.2, -0.5], rtol=1e-2, atol=1e-2)\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/bert/run_classifier.py,112,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:29:38\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nimport sys\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n# Required parameters\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input data dir. Should contain the .tsv files (or other data files) ""\n    ""for the task."")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""task_name"", None, ""The name of the task to train."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n# Other parameters\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(\n    ""do_predict"", False,\n    ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n  return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    features[""label_ids""] = create_int_feature([feature.label_id])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 labels, num_labels, use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use model.get_sequence_output()\n  # instead.\n  output_layer = model.get_pooled_output()\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n    is_real_example = None\n    if ""is_real_example"" in features:\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n    else:\n      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,\n        num_labels, use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n       ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(\n            labels=label_ids, predictions=predictions, weights=is_real_example)\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn,\n                      [per_example_loss, label_ids, logits, is_real_example])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={""probabilities"": probabilities},\n          scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef input_fn_builder(features, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_input_ids = []\n  all_input_mask = []\n  all_segment_ids = []\n  all_label_ids = []\n\n  for feature in features:\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_segment_ids.append(feature.segment_ids)\n    all_label_ids.append(feature.label_id)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""segment_ids"":\n            tf.constant(\n                all_segment_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""label_ids"":\n            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),\n    })\n\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)\n    return d\n\n  return input_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer):\n  """"""Convert a set of `InputExample`s to a list of `InputFeatures`.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    features.append(feature)\n  return features\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval` or `do_predict\' must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    print(""data_dir:"", FLAGS.data_dir)\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      num_labels=len(label_list),\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    else:\n      file_based_convert_examples_to_features(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    # dev dataset\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    num_actual_eval_examples = len(eval_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on. These do NOT count towards the metric (all tf.metrics\n      # support a per-instance weight, and these get a weight of 0.0).\n      while len(eval_examples) % FLAGS.eval_batch_size != 0:\n        eval_examples.append(PaddingInputExample())\n\n    eval_file = os.path.join(FLAGS.output_dir, ""dev.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(eval_examples), num_actual_eval_examples,\n                    len(eval_examples) - num_actual_eval_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      assert len(eval_examples) % FLAGS.eval_batch_size == 0\n      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    #######################################################################################################################\n    # evaluate all checkpoints; you can use the checkpoint with the best dev accuarcy\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_bert.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        result = estimator.evaluate(input_fn=eval_input_fn,\n                                    steps=eval_steps, checkpoint_path=filename)\n\n        tf.logging.info(""***** Eval results %s *****"" % (filename))\n        writer.write(""***** Eval results %s *****\\n"" % (filename))\n        for key in sorted(result.keys()):\n          tf.logging.info(""  %s = %s"", key, str(result[key]))\n          writer.write(""%s = %s\\n"" % (key, str(result[key])))\n    #######################################################################################################################\n\n    # result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n    #\n    # output_eval_file = os.path.join(FLAGS.output_dir, ""dev_results_bert.txt"")\n    # with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n    #  tf.logging.info(""***** Eval results *****"")\n    #  for key in sorted(result.keys()):\n    #    tf.logging.info(""  %s = %s"", key, str(result[key]))\n    #    writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    num_actual_predict_examples = len(predict_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on.\n      while len(predict_examples) % FLAGS.predict_batch_size != 0:\n        predict_examples.append(PaddingInputExample())\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(predict_examples, label_list,\n                                                        FLAGS.max_seq_length, tokenizer,\n                                                        predict_file)\n    else:\n      file_based_convert_examples_to_features(predict_examples, label_list,\n                                              FLAGS.max_seq_length, tokenizer,\n                                              predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(predict_examples), num_actual_predict_examples,\n                    len(predict_examples) - num_actual_predict_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_drop_remainder = True if FLAGS.use_tpu else False\n    predict_input_fn = file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=predict_drop_remainder)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert/run_classifier_with_tfhub.py,51,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner with TF-Hub.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport optimization\nimport run_classifier\nimport tokenization\nimport tensorflow as tf\nimport tensorflow_hub as hub\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""bert_hub_module_handle"", None,\n    ""Handle for the BERT TF-Hub module."")\n\n\ndef create_model(is_training, input_ids, input_mask, segment_ids, labels,\n                 num_labels, bert_hub_module_handle):\n  """"""Creates a classification model.""""""\n  tags = set()\n  if is_training:\n    tags.add(""train"")\n  bert_module = hub.Module(bert_hub_module_handle, tags=tags, trainable=True)\n  bert_inputs = dict(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids)\n  bert_outputs = bert_module(\n      inputs=bert_inputs,\n      signature=""tokens"",\n      as_dict=True)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use\n  # bert_outputs[""sequence_output""] instead.\n  output_layer = bert_outputs[""pooled_output""]\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(num_labels, learning_rate, num_train_steps,\n                     num_warmup_steps, use_tpu, bert_hub_module_handle):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        is_training, input_ids, input_mask, segment_ids, label_ids, num_labels,\n        bert_hub_module_handle)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(label_ids, predictions)\n        loss = tf.metrics.mean(per_example_loss)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions={""probabilities"": probabilities})\n    else:\n      raise ValueError(\n          ""Only TRAIN, EVAL and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef create_tokenizer_from_hub_module(bert_hub_module_handle):\n  """"""Get the vocab file and casing info from the Hub module.""""""\n  with tf.Graph().as_default():\n    bert_module = hub.Module(bert_hub_module_handle)\n    tokenization_info = bert_module(signature=""tokenization_info"", as_dict=True)\n    with tf.Session() as sess:\n      vocab_file, do_lower_case = sess.run([tokenization_info[""vocab_file""],\n                                            tokenization_info[""do_lower_case""]])\n  return tokenization.FullTokenizer(\n      vocab_file=vocab_file, do_lower_case=do_lower_case)\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""cola"": run_classifier.ColaProcessor,\n      ""mnli"": run_classifier.MnliProcessor,\n      ""mrpc"": run_classifier.MrpcProcessor,\n  }\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = create_tokenizer_from_hub_module(FLAGS.bert_hub_module_handle)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      num_labels=len(label_list),\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      bert_hub_module_handle=FLAGS.bert_hub_module_handle)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_features = run_classifier.convert_examples_to_features(\n        train_examples, label_list, FLAGS.max_seq_length, tokenizer)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = run_classifier.input_fn_builder(\n        features=train_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    eval_features = run_classifier.convert_examples_to_features(\n        eval_examples, label_list, FLAGS.max_seq_length, tokenizer)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d"", len(eval_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      # Eval will be slightly WRONG on the TPU because it will truncate\n      # the last batch.\n      eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = run_classifier.input_fn_builder(\n        features=eval_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    if FLAGS.use_tpu:\n      # Discard batch remainder if running on TPU\n      n = len(predict_examples)\n      predict_examples = predict_examples[:(n - n % FLAGS.predict_batch_size)]\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    run_classifier.file_based_convert_examples_to_features(\n        predict_examples, label_list, FLAGS.max_seq_length, tokenizer,\n        predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d"", len(predict_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_input_fn = run_classifier.file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=FLAGS.use_tpu)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n      tf.logging.info(""***** Predict results *****"")\n      for prediction in result:\n        probabilities = prediction[""probabilities""]\n        output_line = ""\\t"".join(\n            str(class_probability)\n            for class_probability in probabilities) + ""\\n""\n        writer.write(output_line)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""bert_hub_module_handle"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert/run_ner.py,81,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-06 17:40:44\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-11-07 10:28:29\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nfrom sklearn.metrics import f1_score, precision_score, recall_score\nfrom tensorflow.python.ops import math_ops\nimport tf_metrics\nimport pickle\nimport codecs\nimport sys\n\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input datadir."",\n)\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model.""\n)\n\nflags.DEFINE_string(\n    ""task_name"", None, ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""token_name"", ""full"", ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written.""\n)\n\n# Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model).""\n)\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text.""\n)\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization.""\n)\n\nflags.DEFINE_bool(\n    ""do_train"", False,\n    ""Whether to run training.""\n)\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(""do_predict"", False,\n                  ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0, ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputExample(object):\n    """"""A single training/test example for simple sequence classification.""""""\n\n    def __init__(self, guid, text, label=None):\n        """"""Constructs a InputExample.\n\n        Args:\n          guid: Unique id for the example.\n          text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n          label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid = guid\n        self.text = text\n        self.label = label\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self, input_ids, input_mask, segment_ids, label_ids, label_mask):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_ids = label_ids\n        self.label_mask = label_mask\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_data(cls, input_file):\n        """"""Reads a BIO data.""""""\n        with open(input_file) as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                word = line.strip().split(\' \')[0]\n                label = line.strip().split(\' \')[-1]\n                if contends.startswith(""-DOCSTART-""):\n                    words.append(\'\')\n                    continue\n                if len(contends) == 0 and words[-1] == \'.\':\n                    l = \' \'.join([label for label in labels if len(label) > 0])\n                    w = \' \'.join([word for word in words if len(word) > 0])\n                    lines.append([l, w])\n                    words = []\n                    labels = []\n                    continue\n                if len(contends) == 0:\n                    continue\n                words.append(word)\n                labels.append(label)\n            return lines\n\n\nclass NerProcessor(DataProcessor):\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""train.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""dev.txt"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""test.txt"")), ""test"")\n\n    def get_labels(self):\n        # return [""I-MISC"", ""I-PER"",  ""I-ORG"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        return [""B-MISC"", ""I-MISC"", ""B-PER"", ""I-PER"", ""B-ORG"", ""I-ORG"", ""B-LOC"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n\nclass WeiboNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.train"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.dev"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.test"")), ""test"")\n\n    def get_labels(self):\n        return [\'I-PER.NOM\', \'I-PER.NAM\', \'I-GPE.NAM\', \'I-ORG.NAM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        # return [\'B-PER.NOM\', \'I-PER.NOM\', \'B-LOC.NAM\', \'B-PER.NAM\', \'I-PER.NAM\', \'B-GPE.NAM\', \'I-GPE.NAM\', \'B-ORG.NAM\', \'I-ORG.NAM\', \'B-ORG.NOM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'B-LOC.NOM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                if len(tokens) == 2:\n                    words.append(tokens[0])\n                    label = tokens[-1]\n                    if label[0] == \'B\':\n                        label = ""I"" + label[1:]\n                    labels.append(label)\n                else:\n                    if len(contends) == 0 and len(words) > 0:\n                        label = []\n                        word = []\n                        for l, w in zip(labels, words):\n                            if len(l) > 0 and len(w) > 0:\n                                label.append(l)\n                                # self.labels.add(l)\n                                word.append(w)\n                        lines.append([\' \'.join(label), \' \'.join(word)])\n                        words = []\n                        labels = []\n                        continue\n                if contends.startswith(""-DOCSTART-""):\n                    continue\n\n            return lines\n\n\nclass MsraNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""train1.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""test"")\n\n    def get_labels(self):\n        return [\'B-PERSON\', \'I-PERSON\', \'B-LOCATION\', \'I-LOCATION\', \'B-ORGANIZATION\', \'I-ORGANIZATION\', ""O"", ""[CLS]"", ""[SEP]"", ""X""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            chars = []\n            labels = []\n            len_count = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                for token in tokens:\n                    word, label = token.split(\'/\')\n\n                    if label == ""nr"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-PERSON\'] + [\'I-PERSON\'] * (len(word) - 1)\n                    elif label == ""ns"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-LOCATION\'] + [\'I-LOCATION\'] * (len(word) - 1)\n                    elif label == ""nt"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-ORGANIZATION\'] + [\'I-ORGANIZATION\'] * (len(word) - 1)\n                    else:\n                        assert label == ""o""\n                        chars = chars + list(word)\n                        labels = labels + [""O""] * len(word)\n                lines.append([\' \'.join(labels), \' \'.join(chars)])\n                len_count.append(len(chars))\n                chars = []\n                labels = []\n            return lines\n\n\ndef write_tokens(tokens, mode):\n    if mode == ""test"":\n        path = os.path.join(FLAGS.output_dir, ""token_"" + mode + "".txt"")\n        wf = open(path, \'a\')\n        for token in tokens:\n            if token != ""**NULL**"":\n                wf.write(token + \'\\n\')\n        wf.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode):\n    label_map = {}\n    for (i, label) in enumerate(label_list, 1):\n        label_map[label] = i\n\n    if not os.path.exists(os.path.join(output_dir, \'label2id.pkl\')):\n        with open(os.path.join(output_dir, \'label2id.pkl\'), \'wb\') as w:\n            pickle.dump(label_map, w)\n    textlist = example.text.split(\' \')\n    labellist = example.label.split(\' \')\n    tokens = []\n    labels = []\n    label_mask = []\n    for i, word in enumerate(textlist):\n        token = tokenizer.tokenize(word)\n        tokens.extend(token)\n        label_1 = labellist[i]\n        for m in range(len(token)):\n            if m == 0:\n                labels.append(label_1)\n            else:\n                labels.append(""X"")\n\n    # tokens = tokenizer.tokenize(example.text)\n    if len(tokens) >= max_seq_length - 1:\n        tokens = tokens[0:(max_seq_length - 2)]\n        labels = labels[0:(max_seq_length - 2)]\n    ntokens = []\n    segment_ids = []\n    label_ids = []\n    ntokens.append(""[CLS]"")\n    segment_ids.append(0)\n    # append(""O"") or append(""[CLS]"") not sure!\n    label_ids.append(label_map[""[CLS]""])\n    label_mask.append(0)  # not to predict and train\n    for i, token in enumerate(tokens):\n        ntokens.append(token)\n        segment_ids.append(0)\n        label_ids.append(label_map[labels[i]])\n        if labels[i] == \'X\':\n            label_mask.append(0)\n        else:\n            label_mask.append(1)\n    ntokens.append(""[SEP]"")\n    segment_ids.append(0)\n    label_mask.append(0)\n    # append(""O"") or append(""[SEP]"") not sure!\n    label_ids.append(label_map[""[SEP]""])\n    input_ids = tokenizer.convert_tokens_to_ids(ntokens)\n    input_mask = [1] * len(input_ids)\n    # label_mask = [1] * len(input_ids)\n    while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n        # we don\'t concerned about it!\n        label_ids.append(0)\n        ntokens.append(""**NULL**"")\n        label_mask.append(0)\n    # print(len(input_ids))\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n    assert len(label_ids) == max_seq_length\n    assert len(label_mask) == max_seq_length\n\n    if ex_index < 5:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""guid: %s"" % (example.guid))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        tf.logging.info(""label_ids: %s"" % "" "".join([str(x) for x in label_ids]))\n        tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n        # tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n\n    feature = InputFeatures(\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        label_ids=label_ids,\n        label_mask=label_mask\n    )\n    write_tokens(ntokens, mode)\n    return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file, output_dir, mode=None):\n    writer = tf.python_io.TFRecordWriter(output_file)\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 5000 == 0:\n            tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n        feature = convert_single_example(\n            ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode)\n\n        def create_int_feature(values):\n            f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n            return f\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(feature.input_ids)\n        features[""input_mask""] = create_int_feature(feature.input_mask)\n        features[""segment_ids""] = create_int_feature(feature.segment_ids)\n        features[""label_ids""] = create_int_feature(feature.label_ids)\n        features[""label_mask""] = create_int_feature(feature.label_mask)\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n        writer.write(tf_example.SerializeToString())\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n    name_to_features = {\n        ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n    }\n\n    def _decode_record(record, name_to_features):\n        example = tf.parse_single_example(record, name_to_features)\n        for name in list(example.keys()):\n            t = example[name]\n            if t.dtype == tf.int64:\n                t = tf.to_int32(t)\n            example[name] = t\n        return example\n\n    def input_fn(params):\n        batch_size = params[""batch_size""]\n        d = tf.data.TFRecordDataset(input_file)\n        if is_training:\n            d = d.repeat()\n            d = d.shuffle(buffer_size=100)\n        d = d.apply(tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder\n        ))\n        return d\n\n    return input_fn\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, label_mask,\n                 segment_ids, labels, num_labels, use_one_hot_embeddings):\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings\n    )\n\n    output_layer = model.get_sequence_output()\n\n    hidden_size = output_layer.shape[-1].value\n\n    output_weight = tf.get_variable(\n        ""output_weights"", [num_labels, hidden_size],\n        initializer=tf.truncated_normal_initializer(stddev=0.02)\n    )\n    output_bias = tf.get_variable(\n        ""output_bias"", [num_labels], initializer=tf.zeros_initializer()\n    )\n    with tf.variable_scope(""loss""):\n        if is_training:\n            output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n        output_layer = tf.reshape(output_layer, [-1, hidden_size])\n        logits = tf.matmul(output_layer, output_weight, transpose_b=True)\n        logits = tf.nn.bias_add(logits, output_bias)\n        logits = tf.reshape(logits, [-1, FLAGS.max_seq_length, num_labels])\n        # mask = tf.cast(input_mask,tf.float32)\n        # loss = tf.contrib.seq2seq.sequence_loss(logits,labels,mask)\n        # return (loss, logits, predict)\n        ##########################################################################\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n        per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n        mask = tf.cast(label_mask, tf.float32)\n        mask_example_loss = per_example_loss * mask\n        loss = tf.reduce_sum(mask_example_loss)\n        probabilities = tf.nn.softmax(logits, axis=-1)\n        predict = tf.argmax(probabilities, axis=-1)\n        return (loss, mask_example_loss, logits, predict)\n        ##########################################################################\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n    def model_fn(features, labels, mode, params):\n        tf.logging.info(""*** Features ***"")\n        for name in sorted(features.keys()):\n            tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n        input_ids = features[""input_ids""]\n        input_mask = features[""input_mask""]\n        segment_ids = features[""segment_ids""]\n        label_ids = features[""label_ids""]\n        label_mask = features[""label_mask""]\n        is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n        (total_loss, per_example_loss, logits, predicts) = create_model(\n            bert_config, is_training, input_ids, input_mask, label_mask, segment_ids, label_ids,\n            num_labels, use_one_hot_embeddings)\n        tvars = tf.trainable_variables()\n        scaffold_fn = None\n        if init_checkpoint:\n            (assignment_map, initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(tvars,\n                                                                                                       init_checkpoint)\n            tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n            if use_tpu:\n                def tpu_scaffold():\n                    tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n                    return tf.train.Scaffold()\n\n                scaffold_fn = tpu_scaffold\n            else:\n                tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        tf.logging.info(""**** Trainable Variables ****"")\n\n        for var in tvars:\n            init_string = """"\n            if var.name in initialized_variable_names:\n                init_string = "", *INIT_FROM_CKPT*""\n            tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                            init_string)\n        output_spec = None\n        if mode == tf.estimator.ModeKeys.TRAIN:\n            train_op = optimization.create_optimizer(\n                total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n            hook_dict = {}\n            hook_dict[\'loss\'] = total_loss\n            hook_dict[\'global_steps\'] = tf.train.get_or_create_global_step()\n            logging_hook = tf.train.LoggingTensorHook(\n                hook_dict, every_n_iter=200)\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                train_op=train_op,\n                scaffold_fn=scaffold_fn,\n                training_hooks=[logging_hook])\n        elif mode == tf.estimator.ModeKeys.EVAL:\n\n            def metric_fn(per_example_loss, label_ids, logits):\n                # def metric_fn(label_ids, logits):\n                predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n                # labels = []\n                # for i, x in enumerate()\n                predict_labels = []\n                # for i in range(1, num_labels - 4):\n                #     predict_labels.append(i)\n                # precision = tf_metrics.precision(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # recall = tf_metrics.recall(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # f = tf_metrics.f1(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n\n                precision = tf_metrics.precision(\n                    label_ids, predictions, num_labels, average=""macro"")\n                recall = tf_metrics.recall(label_ids, predictions, num_labels, average=""macro"")\n                f = tf_metrics.f1(label_ids, predictions, num_labels, average=""macro"")\n\n                #\n                return {\n                    ""eval_precision"": precision,\n                    ""eval_recall"": recall,\n                    ""eval_f"": f,\n                    # ""eval_loss"": loss,\n                }\n\n            eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n            # eval_metrics = (metric_fn, [label_ids, logits])\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                eval_metrics=eval_metrics,\n                scaffold_fn=scaffold_fn)\n        else:\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode, predictions=predicts, scaffold_fn=scaffold_fn\n            )\n        return output_spec\n\n    return model_fn\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    processors = {\n        ""ner"": NerProcessor,\n        ""weiboner"": WeiboNERProcessor,\n        ""msraner"": MsraNERProcessor\n    }\n    # if not FLAGS.do_train and not FLAGS.do_eval:\n    #     raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n    bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n    if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n        raise ValueError(\n            ""Cannot use sequence length %d because the BERT model ""\n            ""was only trained up to sequence length %d"" %\n            (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n    if not os.path.exists(FLAGS.output_dir):\n        os.mkdir(FLAGS.output_dir)\n    task_name = FLAGS.task_name.lower()\n    if task_name not in processors:\n        raise ValueError(""Task not found: %s"" % (task_name))\n    processor = processors[task_name]()\n\n    label_list = processor.get_labels()\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    tpu_cluster_resolver = None\n    if FLAGS.use_tpu and FLAGS.tpu_name:\n        tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n            FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n    is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n\n    run_config = tf.contrib.tpu.RunConfig(\n        cluster=tpu_cluster_resolver,\n        master=FLAGS.master,\n        model_dir=FLAGS.output_dir,\n        save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n        tpu_config=tf.contrib.tpu.TPUConfig(\n            iterations_per_loop=FLAGS.iterations_per_loop,\n            num_shards=FLAGS.num_tpu_cores,\n            per_host_input_for_training=is_per_host))\n\n    train_examples = None\n    num_train_steps = None\n    num_warmup_steps = None\n\n    if FLAGS.do_train:\n        train_examples = processor.get_train_examples(FLAGS.data_dir)\n        num_train_steps = int(\n            len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n        print(num_train_steps)\n        num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    model_fn = model_fn_builder(\n        bert_config=bert_config,\n        num_labels=len(label_list) + 1,\n        init_checkpoint=FLAGS.init_checkpoint,\n        learning_rate=FLAGS.learning_rate,\n        num_train_steps=num_train_steps,\n        num_warmup_steps=num_warmup_steps,\n        use_tpu=FLAGS.use_tpu,\n        use_one_hot_embeddings=FLAGS.use_tpu)\n\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n\n    if FLAGS.do_train:\n        train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file, FLAGS.output_dir)\n        tf.logging.info(""***** Running training *****"")\n        tf.logging.info(""  Num examples = %d"", len(train_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n        tf.logging.info(""  Num steps = %d"", num_train_steps)\n        train_input_fn = file_based_input_fn_builder(\n            input_file=train_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=True,\n            drop_remainder=True)\n        estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n    if FLAGS.do_eval:\n        eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n        eval_file = os.path.join(FLAGS.output_dir, ""eval.tf_record"")\n        file_based_convert_examples_to_features(\n            eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file, FLAGS.output_dir)\n\n        tf.logging.info(""***** Running evaluation *****"")\n        tf.logging.info(""  Num examples = %d"", len(eval_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n        eval_steps = None\n        if FLAGS.use_tpu:\n            eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n        eval_drop_remainder = True if FLAGS.use_tpu else False\n        eval_input_fn = file_based_input_fn_builder(\n            input_file=eval_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=eval_drop_remainder)\n        result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n        output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            tf.logging.info(""***** Eval results *****"")\n            for key in sorted(result.keys()):\n                tf.logging.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n    if FLAGS.do_predict:\n\n        pred_tags = []\n        true_tags = []\n\n        token_path = os.path.join(FLAGS.output_dir, ""token_test.txt"")\n        label_file = os.path.join(FLAGS.output_dir, ""label2id.pkl"")\n        label_masks = []\n        with open(label_file, ""rb"") as rf:\n            label2id = pickle.load(rf)\n            id2label = {value: key for key, value in label2id.items()}\n        if os.path.exists(token_path):\n            os.remove(token_path)\n        predict_examples = processor.get_test_examples(FLAGS.data_dir)\n        ground_truth_file = os.path.join(FLAGS.output_dir, ""ground_truth.txt"")\n        with open(ground_truth_file, \'w\') as writer:\n            for ex_index, example in enumerate(predict_examples):\n                feature = convert_single_example(\n                    ex_index, example, label_list, FLAGS.max_seq_length, tokenizer, FLAGS.output_dir, ""test"")\n                line = []\n                for i, id in enumerate(feature.label_ids):\n                    if feature.label_mask[i] == 1:\n                        line.append(id2label[id])\n                        true_tags.append(id2label[id])\n                # output_line = "" "".join(id2label[id] for id in feature.label_ids if id != 0) + ""\\n""\n                output_line = "" "".join(line) + ""\\n""\n                writer.write(output_line)\n                label_masks.append(feature.label_mask)\n        predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n        file_based_convert_examples_to_features(predict_examples, label_list,\n                                                FLAGS.max_seq_length, tokenizer,\n                                                predict_file, FLAGS.output_dir, mode=""test"")\n\n        tf.logging.info(""***** Running prediction*****"")\n        tf.logging.info(""  Num examples = %d"", len(predict_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n        if FLAGS.use_tpu:\n            # Warning: According to tpu_estimator.py Prediction on TPU is an\n            # experimental feature and hence not supported here\n            raise ValueError(""Prediction in TPU not supported"")\n        predict_drop_remainder = True if FLAGS.use_tpu else False\n        predict_input_fn = file_based_input_fn_builder(\n            input_file=predict_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=predict_drop_remainder)\n\n        result = estimator.predict(input_fn=predict_input_fn)\n        output_predict_file = os.path.join(FLAGS.output_dir, ""label_test.txt"")\n\n        with open(output_predict_file, \'w\') as writer:\n            for i, prediction in enumerate(result):\n                line = []\n                for j, x in enumerate(prediction):\n                    if label_masks[i][j] == 0:\n                        continue\n                    else:\n                        line.append(id2label[x])\n                        # writer.write(id2label[x] + ""\\n"")\n                        pred_tags.append(id2label[x])\n                output_line = "" "".join(line) + ""\\n""\n                # # output_line = "" "".join(id2label[id] for id in prediction if id != 0) + ""\\n""\n                writer.write(output_line)\n        # evaluate(true_tags, pred_tags, verbose=True)\n        # evaluate(true_tags, pred_tags)\n\n        tmp = codecs.open(os.path.join(FLAGS.output_dir, ""tmp""), \'w\', \'utf8\')\n        with codecs.open(ground_truth_file, \'r\', \'utf8\') as ft, codecs.open(output_predict_file, \'r\', \'utf8\') as fg:\n            for lt, lg in zip(ft, fg):\n                for tl, tg in zip(lt.strip().split(), lg.strip().split()):\n                    print(\'\\t\'.join(["" "", tl, tg]), file=tmp)\n        tmp.close()\n        cmd = ""python %s -d \'\\t\' < %s > %s"" % \\\n            (os.path.join(os.getcwd(), ""conlleval.py""),\n             os.path.join(FLAGS.output_dir, ""tmp""),\n             os.path.join(FLAGS.data_dir, ""test_results_bert.txt""))\n        os.system(cmd)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""data_dir"")\n    flags.mark_flag_as_required(""task_name"")\n    flags.mark_flag_as_required(""vocab_file"")\n    flags.mark_flag_as_required(""bert_config_file"")\n    flags.mark_flag_as_required(""output_dir"")\n    tf.app.run()\n'"
baselines/models/bert/run_pretraining.py,97,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run masked LM/next sentence masked_lm pre-training for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport modeling\nimport optimization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(\n    ""input_file"", None,\n    ""Input TF example files (can be a glob or comma separated)."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded. Must match data generation."")\n\nflags.DEFINE_integer(\n    ""max_predictions_per_seq"", 20,\n    ""Maximum number of masked LM predictions per sequence. ""\n    ""Must match data generation."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_integer(""num_train_steps"", 100000, ""Number of training steps."")\n\nflags.DEFINE_integer(""num_warmup_steps"", 10000, ""Number of warmup steps."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(""max_eval_steps"", 100, ""Maximum number of eval steps."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    masked_lm_positions = features[""masked_lm_positions""]\n    masked_lm_ids = features[""masked_lm_ids""]\n    masked_lm_weights = features[""masked_lm_weights""]\n    next_sentence_labels = features[""next_sentence_labels""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    (masked_lm_loss,\n     masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(\n         bert_config, model.get_sequence_output(), model.get_embedding_table(),\n         masked_lm_positions, masked_lm_ids, masked_lm_weights)\n\n    (next_sentence_loss, next_sentence_example_loss,\n     next_sentence_log_probs) = get_next_sentence_output(\n         bert_config, model.get_pooled_output(), next_sentence_labels)\n\n    total_loss = masked_lm_loss + next_sentence_loss\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n                    masked_lm_weights, next_sentence_example_loss,\n                    next_sentence_log_probs, next_sentence_labels):\n        """"""Computes the loss and accuracy of the model.""""""\n        masked_lm_log_probs = tf.reshape(masked_lm_log_probs,\n                                         [-1, masked_lm_log_probs.shape[-1]])\n        masked_lm_predictions = tf.argmax(\n            masked_lm_log_probs, axis=-1, output_type=tf.int32)\n        masked_lm_example_loss = tf.reshape(masked_lm_example_loss, [-1])\n        masked_lm_ids = tf.reshape(masked_lm_ids, [-1])\n        masked_lm_weights = tf.reshape(masked_lm_weights, [-1])\n        masked_lm_accuracy = tf.metrics.accuracy(\n            labels=masked_lm_ids,\n            predictions=masked_lm_predictions,\n            weights=masked_lm_weights)\n        masked_lm_mean_loss = tf.metrics.mean(\n            values=masked_lm_example_loss, weights=masked_lm_weights)\n\n        next_sentence_log_probs = tf.reshape(\n            next_sentence_log_probs, [-1, next_sentence_log_probs.shape[-1]])\n        next_sentence_predictions = tf.argmax(\n            next_sentence_log_probs, axis=-1, output_type=tf.int32)\n        next_sentence_labels = tf.reshape(next_sentence_labels, [-1])\n        next_sentence_accuracy = tf.metrics.accuracy(\n            labels=next_sentence_labels, predictions=next_sentence_predictions)\n        next_sentence_mean_loss = tf.metrics.mean(\n            values=next_sentence_example_loss)\n\n        return {\n            ""masked_lm_accuracy"": masked_lm_accuracy,\n            ""masked_lm_loss"": masked_lm_mean_loss,\n            ""next_sentence_accuracy"": next_sentence_accuracy,\n            ""next_sentence_loss"": next_sentence_mean_loss,\n        }\n\n      eval_metrics = (metric_fn, [\n          masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n          masked_lm_weights, next_sentence_example_loss,\n          next_sentence_log_probs, next_sentence_labels\n      ])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(""Only TRAIN and EVAL modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef get_masked_lm_output(bert_config, input_tensor, output_weights, positions,\n                         label_ids, label_weights):\n  """"""Get loss and log probs for the masked LM.""""""\n  input_tensor = gather_indexes(input_tensor, positions)\n\n  with tf.variable_scope(""cls/predictions""):\n    # We apply one more non-linear transformation before the output layer.\n    # This matrix is not used after pre-training.\n    with tf.variable_scope(""transform""):\n      input_tensor = tf.layers.dense(\n          input_tensor,\n          units=bert_config.hidden_size,\n          activation=modeling.get_activation(bert_config.hidden_act),\n          kernel_initializer=modeling.create_initializer(\n              bert_config.initializer_range))\n      input_tensor = modeling.layer_norm(input_tensor)\n\n    # The output weights are the same as the input embeddings, but there is\n    # an output-only bias for each token.\n    output_bias = tf.get_variable(\n        ""output_bias"",\n        shape=[bert_config.vocab_size],\n        initializer=tf.zeros_initializer())\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    label_ids = tf.reshape(label_ids, [-1])\n    label_weights = tf.reshape(label_weights, [-1])\n\n    one_hot_labels = tf.one_hot(\n        label_ids, depth=bert_config.vocab_size, dtype=tf.float32)\n\n    # The `positions` tensor might be zero-padded (if the sequence is too\n    # short to have the maximum number of predictions). The `label_weights`\n    # tensor has a value of 1.0 for every real prediction and 0.0 for the\n    # padding predictions.\n    per_example_loss = -tf.reduce_sum(log_probs * one_hot_labels, axis=[-1])\n    numerator = tf.reduce_sum(label_weights * per_example_loss)\n    denominator = tf.reduce_sum(label_weights) + 1e-5\n    loss = numerator / denominator\n\n  return (loss, per_example_loss, log_probs)\n\n\ndef get_next_sentence_output(bert_config, input_tensor, labels):\n  """"""Get loss and log probs for the next sentence prediction.""""""\n\n  # Simple binary classification. Note that 0 is ""next sentence"" and 1 is\n  # ""random sentence"". This weight matrix is not used after pre-training.\n  with tf.variable_scope(""cls/seq_relationship""):\n    output_weights = tf.get_variable(\n        ""output_weights"",\n        shape=[2, bert_config.hidden_size],\n        initializer=modeling.create_initializer(bert_config.initializer_range))\n    output_bias = tf.get_variable(\n        ""output_bias"", shape=[2], initializer=tf.zeros_initializer())\n\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n    labels = tf.reshape(labels, [-1])\n    one_hot_labels = tf.one_hot(labels, depth=2, dtype=tf.float32)\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n    return (loss, per_example_loss, log_probs)\n\n\ndef gather_indexes(sequence_tensor, positions):\n  """"""Gathers the vectors at the specific positions over a minibatch.""""""\n  sequence_shape = modeling.get_shape_list(sequence_tensor, expected_rank=3)\n  batch_size = sequence_shape[0]\n  seq_length = sequence_shape[1]\n  width = sequence_shape[2]\n\n  flat_offsets = tf.reshape(\n      tf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n  flat_positions = tf.reshape(positions + flat_offsets, [-1])\n  flat_sequence_tensor = tf.reshape(sequence_tensor,\n                                    [batch_size * seq_length, width])\n  output_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n  return output_tensor\n\n\ndef input_fn_builder(input_files,\n                     max_seq_length,\n                     max_predictions_per_seq,\n                     is_training,\n                     num_cpu_threads=4):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    name_to_features = {\n        ""input_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""input_mask"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""segment_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""masked_lm_positions"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_ids"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_weights"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.float32),\n        ""next_sentence_labels"":\n            tf.FixedLenFeature([1], tf.int64),\n    }\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = tf.data.Dataset.from_tensor_slices(tf.constant(input_files))\n      d = d.repeat()\n      d = d.shuffle(buffer_size=len(input_files))\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_cpu_threads, len(input_files))\n\n      # `sloppy` mode means that the interleaving is not exact. This adds\n      # even more randomness to the training pipeline.\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n      d = d.shuffle(buffer_size=100)\n    else:\n      d = tf.data.TFRecordDataset(input_files)\n      # Since we evaluate for a fixed number of steps we don\'t want to encounter\n      # out-of-range exceptions.\n      d = d.repeat()\n\n    # We must `drop_remainder` on training because the TPU requires fixed\n    # size dimensions. For eval, we assume we are evaluating on the CPU or GPU\n    # and we *don\'t* want to drop the remainder, otherwise we wont cover\n    # every sample.\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_cpu_threads,\n            drop_remainder=True))\n    return d\n\n  return input_fn\n\n\ndef _decode_record(record, name_to_features):\n  """"""Decodes a record to a TensorFlow example.""""""\n  example = tf.parse_single_example(record, name_to_features)\n\n  # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n  # So cast all int64 to int32.\n  for name in list(example.keys()):\n    t = example[name]\n    if t.dtype == tf.int64:\n      t = tf.to_int32(t)\n    example[name] = t\n\n  return example\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Input Files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"" % input_file)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=FLAGS.num_train_steps,\n      num_warmup_steps=FLAGS.num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size)\n\n  if FLAGS.do_train:\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    train_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=True)\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.num_train_steps)\n\n  if FLAGS.do_eval:\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    eval_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=False)\n\n    result = estimator.evaluate(\n        input_fn=eval_input_fn, steps=FLAGS.max_eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert/run_squad.py,93,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run BERT on SQuAD 1.1 and SQuAD 2.0.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport math\nimport os\nimport random\nimport modeling\nimport optimization\nimport tokenization\nimport six\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(""train_file"", None,\n                    ""SQuAD json for training. E.g., train-v1.1.json"")\n\nflags.DEFINE_string(\n    ""predict_file"", None,\n    ""SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json"")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 384,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_integer(\n    ""doc_stride"", 128,\n    ""When splitting up a long document into chunks, how much stride to ""\n    ""take between chunks."")\n\nflags.DEFINE_integer(\n    ""max_query_length"", 64,\n    ""The maximum number of tokens for the question. Questions longer than ""\n    ""this will be truncated to this length."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8,\n                     ""Total batch size for predictions."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(\n    ""n_best_size"", 20,\n    ""The total number of n-best predictions to generate in the ""\n    ""nbest_predictions.json output file."")\n\nflags.DEFINE_integer(\n    ""max_answer_length"", 30,\n    ""The maximum length of an answer that can be generated. This is needed ""\n    ""because the start and end predictions are not conditioned on one another."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""verbose_logging"", False,\n    ""If true, all of the warnings related to data processing will be printed. ""\n    ""A number of warnings are expected for a normal SQuAD evaluation."")\n\nflags.DEFINE_bool(\n    ""version_2_with_negative"", False,\n    ""If true, the SQuAD examples contain some that do not have an answer."")\n\nflags.DEFINE_float(\n    ""null_score_diff_threshold"", 0.0,\n    ""If null_score - best_non_null is greater than the threshold predict null."")\n\n\nclass SquadExample(object):\n  """"""A single training/test example for simple sequence classification.\n\n     For examples without an answer, the start and end position are -1.\n  """"""\n\n  def __init__(self,\n               qas_id,\n               question_text,\n               doc_tokens,\n               orig_answer_text=None,\n               start_position=None,\n               end_position=None,\n               is_impossible=False):\n    self.qas_id = qas_id\n    self.question_text = question_text\n    self.doc_tokens = doc_tokens\n    self.orig_answer_text = orig_answer_text\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n  def __str__(self):\n    return self.__repr__()\n\n  def __repr__(self):\n    s = """"\n    s += ""qas_id: %s"" % (tokenization.printable_text(self.qas_id))\n    s += "", question_text: %s"" % (\n        tokenization.printable_text(self.question_text))\n    s += "", doc_tokens: [%s]"" % ("" "".join(self.doc_tokens))\n    if self.start_position:\n      s += "", start_position: %d"" % (self.start_position)\n    if self.start_position:\n      s += "", end_position: %d"" % (self.end_position)\n    if self.start_position:\n      s += "", is_impossible: %r"" % (self.is_impossible)\n    return s\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tokens,\n               token_to_orig_map,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               segment_ids,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tokens = tokens\n    self.token_to_orig_map = token_to_orig_map\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\ndef read_squad_examples(input_file, is_training):\n  """"""Read a SQuAD json file into a list of SquadExample.""""""\n  with tf.gfile.Open(input_file, ""r"") as reader:\n    input_data = json.load(reader)[""data""]\n\n  def is_whitespace(c):\n    if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F:\n      return True\n    return False\n\n  examples = []\n  for entry in input_data:\n    for paragraph in entry[""paragraphs""]:\n      paragraph_text = paragraph[""context""]\n      doc_tokens = []\n      char_to_word_offset = []\n      prev_is_whitespace = True\n      for c in paragraph_text:\n        if is_whitespace(c):\n          prev_is_whitespace = True\n        else:\n          if prev_is_whitespace:\n            doc_tokens.append(c)\n          else:\n            doc_tokens[-1] += c\n          prev_is_whitespace = False\n        char_to_word_offset.append(len(doc_tokens) - 1)\n\n      for qa in paragraph[""qas""]:\n        qas_id = qa[""id""]\n        question_text = qa[""question""]\n        start_position = None\n        end_position = None\n        orig_answer_text = None\n        is_impossible = False\n        if is_training:\n\n          if FLAGS.version_2_with_negative:\n            is_impossible = qa[""is_impossible""]\n          if (len(qa[""answers""]) != 1) and (not is_impossible):\n            raise ValueError(\n                ""For training, each question should have exactly 1 answer."")\n          if not is_impossible:\n            answer = qa[""answers""][0]\n            orig_answer_text = answer[""text""]\n            answer_offset = answer[""answer_start""]\n            answer_length = len(orig_answer_text)\n            start_position = char_to_word_offset[answer_offset]\n            end_position = char_to_word_offset[answer_offset + answer_length -\n                                               1]\n            # Only add answers where the text can be exactly recovered from the\n            # document. If this CAN\'T happen it\'s likely due to weird Unicode\n            # stuff so we will just skip the example.\n            #\n            # Note that this means for training mode, every example is NOT\n            # guaranteed to be preserved.\n            actual_text = "" "".join(\n                doc_tokens[start_position:(end_position + 1)])\n            cleaned_answer_text = "" "".join(\n                tokenization.whitespace_tokenize(orig_answer_text))\n            if actual_text.find(cleaned_answer_text) == -1:\n              tf.logging.warning(""Could not find answer: \'%s\' vs. \'%s\'"",\n                                 actual_text, cleaned_answer_text)\n              continue\n          else:\n            start_position = -1\n            end_position = -1\n            orig_answer_text = """"\n\n        example = SquadExample(\n            qas_id=qas_id,\n            question_text=question_text,\n            doc_tokens=doc_tokens,\n            orig_answer_text=orig_answer_text,\n            start_position=start_position,\n            end_position=end_position,\n            is_impossible=is_impossible)\n        examples.append(example)\n\n  return examples\n\n\ndef convert_examples_to_features(examples, tokenizer, max_seq_length,\n                                 doc_stride, max_query_length, is_training,\n                                 output_fn):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  unique_id = 1000000000\n\n  for (example_index, example) in enumerate(examples):\n    query_tokens = tokenizer.tokenize(example.question_text)\n\n    if len(query_tokens) > max_query_length:\n      query_tokens = query_tokens[0:max_query_length]\n\n    tok_to_orig_index = []\n    orig_to_tok_index = []\n    all_doc_tokens = []\n    for (i, token) in enumerate(example.doc_tokens):\n      orig_to_tok_index.append(len(all_doc_tokens))\n      sub_tokens = tokenizer.tokenize(token)\n      for sub_token in sub_tokens:\n        tok_to_orig_index.append(i)\n        all_doc_tokens.append(sub_token)\n\n    tok_start_position = None\n    tok_end_position = None\n    if is_training and example.is_impossible:\n      tok_start_position = -1\n      tok_end_position = -1\n    if is_training and not example.is_impossible:\n      tok_start_position = orig_to_tok_index[example.start_position]\n      if example.end_position < len(example.doc_tokens) - 1:\n        tok_end_position = orig_to_tok_index[example.end_position + 1] - 1\n      else:\n        tok_end_position = len(all_doc_tokens) - 1\n      (tok_start_position, tok_end_position) = _improve_answer_span(\n          all_doc_tokens, tok_start_position, tok_end_position, tokenizer,\n          example.orig_answer_text)\n\n    # The -3 accounts for [CLS], [SEP] and [SEP]\n    max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n    # We can have documents that are longer than the maximum sequence length.\n    # To deal with this we do a sliding window approach, where we take chunks\n    # of the up to our max length with a stride of `doc_stride`.\n    _DocSpan = collections.namedtuple(  # pylint: disable=invalid-name\n        ""DocSpan"", [""start"", ""length""])\n    doc_spans = []\n    start_offset = 0\n    while start_offset < len(all_doc_tokens):\n      length = len(all_doc_tokens) - start_offset\n      if length > max_tokens_for_doc:\n        length = max_tokens_for_doc\n      doc_spans.append(_DocSpan(start=start_offset, length=length))\n      if start_offset + length == len(all_doc_tokens):\n        break\n      start_offset += min(length, doc_stride)\n\n    for (doc_span_index, doc_span) in enumerate(doc_spans):\n      tokens = []\n      token_to_orig_map = {}\n      token_is_max_context = {}\n      segment_ids = []\n      tokens.append(""[CLS]"")\n      segment_ids.append(0)\n      for token in query_tokens:\n        tokens.append(token)\n        segment_ids.append(0)\n      tokens.append(""[SEP]"")\n      segment_ids.append(0)\n\n      for i in range(doc_span.length):\n        split_token_index = doc_span.start + i\n        token_to_orig_map[len(tokens)] = tok_to_orig_index[split_token_index]\n\n        is_max_context = _check_is_max_context(doc_spans, doc_span_index,\n                                               split_token_index)\n        token_is_max_context[len(tokens)] = is_max_context\n        tokens.append(all_doc_tokens[split_token_index])\n        segment_ids.append(1)\n      tokens.append(""[SEP]"")\n      segment_ids.append(1)\n\n      input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n      # The mask has 1 for real tokens and 0 for padding tokens. Only real\n      # tokens are attended to.\n      input_mask = [1] * len(input_ids)\n\n      # Zero-pad up to the sequence length.\n      while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n\n      assert len(input_ids) == max_seq_length\n      assert len(input_mask) == max_seq_length\n      assert len(segment_ids) == max_seq_length\n\n      start_position = None\n      end_position = None\n      if is_training and not example.is_impossible:\n        # For training, if our document chunk does not contain an annotation\n        # we throw it out, since there is nothing to predict.\n        doc_start = doc_span.start\n        doc_end = doc_span.start + doc_span.length - 1\n        out_of_span = False\n        if not (tok_start_position >= doc_start and\n                tok_end_position <= doc_end):\n          out_of_span = True\n        if out_of_span:\n          start_position = 0\n          end_position = 0\n        else:\n          doc_offset = len(query_tokens) + 2\n          start_position = tok_start_position - doc_start + doc_offset\n          end_position = tok_end_position - doc_start + doc_offset\n\n      if is_training and example.is_impossible:\n        start_position = 0\n        end_position = 0\n\n      if example_index < 20:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""unique_id: %s"" % (unique_id))\n        tf.logging.info(""example_index: %s"" % (example_index))\n        tf.logging.info(""doc_span_index: %s"" % (doc_span_index))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""token_to_orig_map: %s"" % "" "".join(\n            [""%d:%d"" % (x, y) for (x, y) in six.iteritems(token_to_orig_map)]))\n        tf.logging.info(""token_is_max_context: %s"" % "" "".join([\n            ""%d:%s"" % (x, y) for (x, y) in six.iteritems(token_is_max_context)\n        ]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(\n            ""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(\n            ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        if is_training and example.is_impossible:\n          tf.logging.info(""impossible example"")\n        if is_training and not example.is_impossible:\n          answer_text = "" "".join(tokens[start_position:(end_position + 1)])\n          tf.logging.info(""start_position: %d"" % (start_position))\n          tf.logging.info(""end_position: %d"" % (end_position))\n          tf.logging.info(\n              ""answer: %s"" % (tokenization.printable_text(answer_text)))\n\n      feature = InputFeatures(\n          unique_id=unique_id,\n          example_index=example_index,\n          doc_span_index=doc_span_index,\n          tokens=tokens,\n          token_to_orig_map=token_to_orig_map,\n          token_is_max_context=token_is_max_context,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          segment_ids=segment_ids,\n          start_position=start_position,\n          end_position=end_position,\n          is_impossible=example.is_impossible)\n\n      # Run callback\n      output_fn(feature)\n\n      unique_id += 1\n\n\ndef _improve_answer_span(doc_tokens, input_start, input_end, tokenizer,\n                         orig_answer_text):\n  """"""Returns tokenized answer spans that better match the annotated answer.""""""\n\n  # The SQuAD annotations are character based. We first project them to\n  # whitespace-tokenized words. But then after WordPiece tokenization, we can\n  # often find a ""better match"". For example:\n  #\n  #   Question: What year was John Smith born?\n  #   Context: The leader was John Smith (1895-1943).\n  #   Answer: 1895\n  #\n  # The original whitespace-tokenized answer will be ""(1895-1943)."". However\n  # after tokenization, our tokens will be ""( 1895 - 1943 ) ."". So we can match\n  # the exact answer, 1895.\n  #\n  # However, this is not always possible. Consider the following:\n  #\n  #   Question: What country is the top exporter of electornics?\n  #   Context: The Japanese electronics industry is the lagest in the world.\n  #   Answer: Japan\n  #\n  # In this case, the annotator chose ""Japan"" as a character sub-span of\n  # the word ""Japanese"". Since our WordPiece tokenizer does not split\n  # ""Japanese"", we just use ""Japanese"" as the annotation. This is fairly rare\n  # in SQuAD, but does happen.\n  tok_answer_text = "" "".join(tokenizer.tokenize(orig_answer_text))\n\n  for new_start in range(input_start, input_end + 1):\n    for new_end in range(input_end, new_start - 1, -1):\n      text_span = "" "".join(doc_tokens[new_start:(new_end + 1)])\n      if text_span == tok_answer_text:\n        return (new_start, new_end)\n\n  return (input_start, input_end)\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n  """"""Check if this is the \'max context\' doc span for the token.""""""\n\n  # Because of the sliding window approach taken to scoring documents, a single\n  # token can appear in multiple documents. E.g.\n  #  Doc: the man went to the store and bought a gallon of milk\n  #  Span A: the man went to the\n  #  Span B: to the store and bought\n  #  Span C: and bought a gallon of\n  #  ...\n  #\n  # Now the word \'bought\' will have two scores from spans B and C. We only\n  # want to consider the score with ""maximum context"", which we define as\n  # the *minimum* of its left and right context (the *sum* of left and\n  # right context will always be the same, of course).\n  #\n  # In the example the maximum context for \'bought\' would be span C since\n  # it has 1 left context and 3 right context, while span B has 4 left context\n  # and 0 right context.\n  best_score = None\n  best_span_index = None\n  for (span_index, doc_span) in enumerate(doc_spans):\n    end = doc_span.start + doc_span.length - 1\n    if position < doc_span.start:\n      continue\n    if position > end:\n      continue\n    num_left_context = position - doc_span.start\n    num_right_context = end - position\n    score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n    if best_score is None or score > best_score:\n      best_score = score\n      best_span_index = span_index\n\n  return cur_span_index == best_span_index\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  final_hidden = model.get_sequence_output()\n\n  final_hidden_shape = modeling.get_shape_list(final_hidden, expected_rank=3)\n  batch_size = final_hidden_shape[0]\n  seq_length = final_hidden_shape[1]\n  hidden_size = final_hidden_shape[2]\n\n  output_weights = tf.get_variable(\n      ""cls/squad/output_weights"", [2, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""cls/squad/output_bias"", [2], initializer=tf.zeros_initializer())\n\n  final_hidden_matrix = tf.reshape(final_hidden,\n                                   [batch_size * seq_length, hidden_size])\n  logits = tf.matmul(final_hidden_matrix, output_weights, transpose_b=True)\n  logits = tf.nn.bias_add(logits, output_bias)\n\n  logits = tf.reshape(logits, [batch_size, seq_length, 2])\n  logits = tf.transpose(logits, [2, 0, 1])\n\n  unstacked_logits = tf.unstack(logits, axis=0)\n\n  (start_logits, end_logits) = (unstacked_logits[0], unstacked_logits[1])\n\n  return (start_logits, end_logits)\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (start_logits, end_logits) = create_model(\n        bert_config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      seq_length = modeling.get_shape_list(input_ids)[1]\n\n      def compute_loss(logits, positions):\n        one_hot_positions = tf.one_hot(\n            positions, depth=seq_length, dtype=tf.float32)\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        loss = -tf.reduce_mean(\n            tf.reduce_sum(one_hot_positions * log_probs, axis=-1))\n        return loss\n\n      start_positions = features[""start_positions""]\n      end_positions = features[""end_positions""]\n\n      start_loss = compute_loss(start_logits, start_positions)\n      end_loss = compute_loss(end_logits, end_positions)\n\n      total_loss = (start_loss + end_loss) / 2.0\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      predictions = {\n          ""unique_ids"": unique_ids,\n          ""start_logits"": start_logits,\n          ""end_logits"": end_logits,\n      }\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(\n          ""Only TRAIN and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""unique_ids"": tf.FixedLenFeature([], tf.int64),\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n  }\n\n  if is_training:\n    name_to_features[""start_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""end_positions""] = tf.FixedLenFeature([], tf.int64)\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\nRawResult = collections.namedtuple(""RawResult"",\n                                   [""unique_id"", ""start_logits"", ""end_logits""])\n\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file):\n  """"""Write final predictions to the json file and log-odds of null if needed.""""""\n  tf.logging.info(""Writing predictions to: %s"" % (output_prediction_file))\n  tf.logging.info(""Writing nbest to: %s"" % (output_nbest_file))\n\n  example_index_to_features = collections.defaultdict(list)\n  for feature in all_features:\n    example_index_to_features[feature.example_index].append(feature)\n\n  unique_id_to_result = {}\n  for result in all_results:\n    unique_id_to_result[result.unique_id] = result\n\n  _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n      ""PrelimPrediction"",\n      [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n  all_predictions = collections.OrderedDict()\n  all_nbest_json = collections.OrderedDict()\n  scores_diff_json = collections.OrderedDict()\n\n  for (example_index, example) in enumerate(all_examples):\n    features = example_index_to_features[example_index]\n\n    prelim_predictions = []\n    # keep track of the minimum score of null start+end of position 0\n    score_null = 1000000  # large and positive\n    min_null_feature_index = 0  # the paragraph slice with min mull score\n    null_start_logit = 0  # the start logit at the slice with min null score\n    null_end_logit = 0  # the end logit at the slice with min null score\n    for (feature_index, feature) in enumerate(features):\n      result = unique_id_to_result[feature.unique_id]\n      start_indexes = _get_best_indexes(result.start_logits, n_best_size)\n      end_indexes = _get_best_indexes(result.end_logits, n_best_size)\n      # if we could have irrelevant answers, get the min score of irrelevant\n      if FLAGS.version_2_with_negative:\n        feature_null_score = result.start_logits[0] + result.end_logits[0]\n        if feature_null_score < score_null:\n          score_null = feature_null_score\n          min_null_feature_index = feature_index\n          null_start_logit = result.start_logits[0]\n          null_end_logit = result.end_logits[0]\n      for start_index in start_indexes:\n        for end_index in end_indexes:\n          # We could hypothetically create invalid predictions, e.g., predict\n          # that the start of the span is in the question. We throw out all\n          # invalid predictions.\n          if start_index >= len(feature.tokens):\n            continue\n          if end_index >= len(feature.tokens):\n            continue\n          if start_index not in feature.token_to_orig_map:\n            continue\n          if end_index not in feature.token_to_orig_map:\n            continue\n          if not feature.token_is_max_context.get(start_index, False):\n            continue\n          if end_index < start_index:\n            continue\n          length = end_index - start_index + 1\n          if length > max_answer_length:\n            continue\n          prelim_predictions.append(\n              _PrelimPrediction(\n                  feature_index=feature_index,\n                  start_index=start_index,\n                  end_index=end_index,\n                  start_logit=result.start_logits[start_index],\n                  end_logit=result.end_logits[end_index]))\n\n    if FLAGS.version_2_with_negative:\n      prelim_predictions.append(\n          _PrelimPrediction(\n              feature_index=min_null_feature_index,\n              start_index=0,\n              end_index=0,\n              start_logit=null_start_logit,\n              end_logit=null_end_logit))\n    prelim_predictions = sorted(\n        prelim_predictions,\n        key=lambda x: (x.start_logit + x.end_logit),\n        reverse=True)\n\n    _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n    seen_predictions = {}\n    nbest = []\n    for pred in prelim_predictions:\n      if len(nbest) >= n_best_size:\n        break\n      feature = features[pred.feature_index]\n      if pred.start_index > 0:  # this is a non-null prediction\n        tok_tokens = feature.tokens[pred.start_index:(pred.end_index + 1)]\n        orig_doc_start = feature.token_to_orig_map[pred.start_index]\n        orig_doc_end = feature.token_to_orig_map[pred.end_index]\n        orig_tokens = example.doc_tokens[orig_doc_start:(orig_doc_end + 1)]\n        tok_text = "" "".join(tok_tokens)\n\n        # De-tokenize WordPieces that have been split off.\n        tok_text = tok_text.replace("" ##"", """")\n        tok_text = tok_text.replace(""##"", """")\n\n        # Clean whitespace\n        tok_text = tok_text.strip()\n        tok_text = "" "".join(tok_text.split())\n        orig_text = "" "".join(orig_tokens)\n\n        final_text = get_final_text(tok_text, orig_text, do_lower_case)\n        if final_text in seen_predictions:\n          continue\n\n        seen_predictions[final_text] = True\n      else:\n        final_text = """"\n        seen_predictions[final_text] = True\n\n      nbest.append(\n          _NbestPrediction(\n              text=final_text,\n              start_logit=pred.start_logit,\n              end_logit=pred.end_logit))\n\n    # if we didn\'t inlude the empty option in the n-best, inlcude it\n    if FLAGS.version_2_with_negative:\n      if """" not in seen_predictions:\n        nbest.append(\n            _NbestPrediction(\n                text="""", start_logit=null_start_logit,\n                end_logit=null_end_logit))\n    # In very rare edge cases we could have no valid predictions. So we\n    # just create a nonce prediction in this case to avoid failure.\n    if not nbest:\n      nbest.append(\n          _NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n    assert len(nbest) >= 1\n\n    total_scores = []\n    best_non_null_entry = None\n    for entry in nbest:\n      total_scores.append(entry.start_logit + entry.end_logit)\n      if not best_non_null_entry:\n        if entry.text:\n          best_non_null_entry = entry\n\n    probs = _compute_softmax(total_scores)\n\n    nbest_json = []\n    for (i, entry) in enumerate(nbest):\n      output = collections.OrderedDict()\n      output[""text""] = entry.text\n      output[""probability""] = probs[i]\n      output[""start_logit""] = entry.start_logit\n      output[""end_logit""] = entry.end_logit\n      nbest_json.append(output)\n\n    assert len(nbest_json) >= 1\n\n    if not FLAGS.version_2_with_negative:\n      all_predictions[example.qas_id] = nbest_json[0][""text""]\n    else:\n      # predict """" iff the null score - the score of best non-null > threshold\n      score_diff = score_null - best_non_null_entry.start_logit - (\n          best_non_null_entry.end_logit)\n      scores_diff_json[example.qas_id] = score_diff\n      if score_diff > FLAGS.null_score_diff_threshold:\n        all_predictions[example.qas_id] = """"\n      else:\n        all_predictions[example.qas_id] = best_non_null_entry.text\n\n    all_nbest_json[example.qas_id] = nbest_json\n\n  with tf.gfile.GFile(output_prediction_file, ""w"") as writer:\n    writer.write(json.dumps(all_predictions, indent=4) + ""\\n"")\n\n  with tf.gfile.GFile(output_nbest_file, ""w"") as writer:\n    writer.write(json.dumps(all_nbest_json, indent=4) + ""\\n"")\n\n  if FLAGS.version_2_with_negative:\n    with tf.gfile.GFile(output_null_log_odds_file, ""w"") as writer:\n      writer.write(json.dumps(scores_diff_json, indent=4) + ""\\n"")\n\n\ndef get_final_text(pred_text, orig_text, do_lower_case):\n  """"""Project the tokenized prediction back to the original text.""""""\n\n  # When we created the data, we kept track of the alignment between original\n  # (whitespace tokenized) tokens and our WordPiece tokenized tokens. So\n  # now `orig_text` contains the span of our original text corresponding to the\n  # span that we predicted.\n  #\n  # However, `orig_text` may contain extra characters that we don\'t want in\n  # our prediction.\n  #\n  # For example, let\'s say:\n  #   pred_text = steve smith\n  #   orig_text = Steve Smith\'s\n  #\n  # We don\'t want to return `orig_text` because it contains the extra ""\'s"".\n  #\n  # We don\'t want to return `pred_text` because it\'s already been normalized\n  # (the SQuAD eval script also does punctuation stripping/lower casing but\n  # our tokenizer does additional normalization like stripping accent\n  # characters).\n  #\n  # What we really want to return is ""Steve Smith"".\n  #\n  # Therefore, we have to apply a semi-complicated alignment heruistic between\n  # `pred_text` and `orig_text` to get a character-to-charcter alignment. This\n  # can fail in certain cases in which case we just return `orig_text`.\n\n  def _strip_spaces(text):\n    ns_chars = []\n    ns_to_s_map = collections.OrderedDict()\n    for (i, c) in enumerate(text):\n      if c == "" "":\n        continue\n      ns_to_s_map[len(ns_chars)] = i\n      ns_chars.append(c)\n    ns_text = """".join(ns_chars)\n    return (ns_text, ns_to_s_map)\n\n  # We first tokenize `orig_text`, strip whitespace from the result\n  # and `pred_text`, and check if they are the same length. If they are\n  # NOT the same length, the heuristic has failed. If they are the same\n  # length, we assume the characters are one-to-one aligned.\n  tokenizer = tokenization.BasicTokenizer(do_lower_case=do_lower_case)\n\n  tok_text = "" "".join(tokenizer.tokenize(orig_text))\n\n  start_position = tok_text.find(pred_text)\n  if start_position == -1:\n    if FLAGS.verbose_logging:\n      tf.logging.info(\n          ""Unable to find text: \'%s\' in \'%s\'"" % (pred_text, orig_text))\n    return orig_text\n  end_position = start_position + len(pred_text) - 1\n\n  (orig_ns_text, orig_ns_to_s_map) = _strip_spaces(orig_text)\n  (tok_ns_text, tok_ns_to_s_map) = _strip_spaces(tok_text)\n\n  if len(orig_ns_text) != len(tok_ns_text):\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Length not equal after stripping spaces: \'%s\' vs \'%s\'"",\n                      orig_ns_text, tok_ns_text)\n    return orig_text\n\n  # We then project the characters in `pred_text` back to `orig_text` using\n  # the character-to-character alignment.\n  tok_s_to_ns_map = {}\n  for (i, tok_index) in six.iteritems(tok_ns_to_s_map):\n    tok_s_to_ns_map[tok_index] = i\n\n  orig_start_position = None\n  if start_position in tok_s_to_ns_map:\n    ns_start_position = tok_s_to_ns_map[start_position]\n    if ns_start_position in orig_ns_to_s_map:\n      orig_start_position = orig_ns_to_s_map[ns_start_position]\n\n  if orig_start_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map start position"")\n    return orig_text\n\n  orig_end_position = None\n  if end_position in tok_s_to_ns_map:\n    ns_end_position = tok_s_to_ns_map[end_position]\n    if ns_end_position in orig_ns_to_s_map:\n      orig_end_position = orig_ns_to_s_map[ns_end_position]\n\n  if orig_end_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map end position"")\n    return orig_text\n\n  output_text = orig_text[orig_start_position:(orig_end_position + 1)]\n  return output_text\n\n\ndef _get_best_indexes(logits, n_best_size):\n  """"""Get the n-best logits from a list.""""""\n  index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\n\ndef _compute_softmax(scores):\n  """"""Compute softmax probability over raw logits.""""""\n  if not scores:\n    return []\n\n  max_score = None\n  for score in scores:\n    if max_score is None or score > max_score:\n      max_score = score\n\n  exp_scores = []\n  total_sum = 0.0\n  for score in scores:\n    x = math.exp(score - max_score)\n    exp_scores.append(x)\n    total_sum += x\n\n  probs = []\n  for score in exp_scores:\n    probs.append(score / total_sum)\n  return probs\n\n\nclass FeatureWriter(object):\n  """"""Writes InputFeature to TF example file.""""""\n\n  def __init__(self, filename, is_training):\n    self.filename = filename\n    self.is_training = is_training\n    self.num_features = 0\n    self._writer = tf.python_io.TFRecordWriter(filename)\n\n  def process_feature(self, feature):\n    """"""Write a InputFeature to the TFRecordWriter as a tf.train.Example.""""""\n    self.num_features += 1\n\n    def create_int_feature(values):\n      feature = tf.train.Feature(\n          int64_list=tf.train.Int64List(value=list(values)))\n      return feature\n\n    features = collections.OrderedDict()\n    features[""unique_ids""] = create_int_feature([feature.unique_id])\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n\n    if self.is_training:\n      features[""start_positions""] = create_int_feature([feature.start_position])\n      features[""end_positions""] = create_int_feature([feature.end_position])\n      impossible = 0\n      if feature.is_impossible:\n        impossible = 1\n      features[""is_impossible""] = create_int_feature([impossible])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    self._writer.write(tf_example.SerializeToString())\n\n  def close(self):\n    self._writer.close()\n\n\ndef validate_flags_or_throw(bert_config):\n  """"""Validate the input FLAGS or throw an exception.""""""\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_predict:\n    raise ValueError(""At least one of `do_train` or `do_predict` must be True."")\n\n  if FLAGS.do_train:\n    if not FLAGS.train_file:\n      raise ValueError(\n          ""If `do_train` is True, then `train_file` must be specified."")\n  if FLAGS.do_predict:\n    if not FLAGS.predict_file:\n      raise ValueError(\n          ""If `do_predict` is True, then `predict_file` must be specified."")\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  if FLAGS.max_seq_length <= FLAGS.max_query_length + 3:\n    raise ValueError(\n        ""The max_seq_length (%d) must be greater than max_query_length ""\n        ""(%d) + 3"" % (FLAGS.max_seq_length, FLAGS.max_query_length))\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  validate_flags_or_throw(bert_config)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = read_squad_examples(\n        input_file=FLAGS.train_file, is_training=True)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    # Pre-shuffle the input to avoid having to make a very large shuffle\n    # buffer in in the `input_fn`.\n    rng = random.Random(12345)\n    rng.shuffle(train_examples)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    # We write to a temporary file to avoid storing very large constant tensors\n    # in memory.\n    train_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""train.tf_record""),\n        is_training=True)\n    convert_examples_to_features(\n        examples=train_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=True,\n        output_fn=train_writer.process_feature)\n    train_writer.close()\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(train_examples))\n    tf.logging.info(""  Num split examples = %d"", train_writer.num_features)\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    del train_examples\n\n    train_input_fn = input_fn_builder(\n        input_file=train_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_predict:\n    eval_examples = read_squad_examples(\n        input_file=FLAGS.predict_file, is_training=False)\n\n    eval_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""eval.tf_record""),\n        is_training=False)\n    eval_features = []\n\n    def append_feature(feature):\n      eval_features.append(feature)\n      eval_writer.process_feature(feature)\n\n    convert_examples_to_features(\n        examples=eval_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=False,\n        output_fn=append_feature)\n    eval_writer.close()\n\n    tf.logging.info(""***** Running predictions *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(eval_examples))\n    tf.logging.info(""  Num split examples = %d"", len(eval_features))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    all_results = []\n\n    predict_input_fn = input_fn_builder(\n        input_file=eval_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=False)\n\n    # If running eval on the TPU, you will need to specify the number of\n    # steps.\n    all_results = []\n    for result in estimator.predict(\n        predict_input_fn, yield_single_examples=True):\n      if len(all_results) % 1000 == 0:\n        tf.logging.info(""Processing example: %d"" % (len(all_results)))\n      unique_id = int(result[""unique_ids""])\n      start_logits = [float(x) for x in result[""start_logits""].flat]\n      end_logits = [float(x) for x in result[""end_logits""].flat]\n      all_results.append(\n          RawResult(\n              unique_id=unique_id,\n              start_logits=start_logits,\n              end_logits=end_logits))\n\n    output_prediction_file = os.path.join(FLAGS.output_dir, ""predictions.json"")\n    output_nbest_file = os.path.join(FLAGS.output_dir, ""nbest_predictions.json"")\n    output_null_log_odds_file = os.path.join(FLAGS.output_dir, ""null_odds.json"")\n\n    write_predictions(eval_examples, eval_features, all_results,\n                      FLAGS.n_best_size, FLAGS.max_answer_length,\n                      FLAGS.do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert/tf_metrics.py,22,"b'""""""\r\nMulticlass\r\nfrom: \r\nhttps://github.com/guillaumegenthial/tf_metrics/blob/master/tf_metrics/__init__.py\r\n\r\n""""""\r\n\r\n__author__ = ""Guillaume Genthial""\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops.metrics_impl import _streaming_confusion_matrix\r\n\r\n\r\ndef precision(labels, predictions, num_classes, pos_indices=None,\r\n              weights=None, average=\'micro\'):\r\n    """"""Multi-class precision metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    pr, _, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    op, _, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (pr, op)\r\n\r\n\r\ndef recall(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n           average=\'micro\'):\r\n    """"""Multi-class recall metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, re, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    _, op, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (re, op)\r\n\r\n\r\ndef f1(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n       average=\'micro\'):\r\n    return fbeta(labels, predictions, num_classes, pos_indices, weights,\r\n                 average)\r\n\r\n\r\ndef fbeta(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n          average=\'micro\', beta=1):\r\n    """"""Multi-class fbeta metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, _, fbeta = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average, beta=beta)\r\n    _, _, op = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average, beta=beta)\r\n    return (fbeta, op)\r\n\r\n\r\ndef safe_div(numerator, denominator):\r\n    """"""Safe division, return 0 if denominator is 0""""""\r\n    numerator, denominator = tf.to_float(numerator), tf.to_float(denominator)\r\n    zeros = tf.zeros_like(numerator, dtype=numerator.dtype)\r\n    denominator_is_zero = tf.equal(denominator, zeros)\r\n    return tf.where(denominator_is_zero, zeros, numerator / denominator)\r\n\r\n\r\ndef pr_re_fbeta(cm, pos_indices, beta=1):\r\n    """"""Uses a confusion matrix to compute precision, recall and fbeta""""""\r\n    num_classes = cm.shape[0]\r\n    neg_indices = [i for i in range(num_classes) if i not in pos_indices]\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, neg_indices] = 0\r\n    diag_sum = tf.reduce_sum(tf.diag_part(cm * cm_mask))\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[:, neg_indices] = 0\r\n    tot_pred = tf.reduce_sum(cm * cm_mask)\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, :] = 0\r\n    tot_gold = tf.reduce_sum(cm * cm_mask)\r\n\r\n    pr = safe_div(diag_sum, tot_pred)\r\n    re = safe_div(diag_sum, tot_gold)\r\n    fbeta = safe_div((1. + beta**2) * pr * re, beta**2 * pr + re)\r\n\r\n    return pr, re, fbeta\r\n\r\n\r\ndef metrics_from_confusion_matrix(cm, pos_indices=None, average=\'micro\',\r\n                                  beta=1):\r\n    """"""Precision, Recall and F1 from the confusion matrix\r\n    Parameters\r\n    ----------\r\n    cm : tf.Tensor of type tf.int32, of shape (num_classes, num_classes)\r\n        The streaming confusion matrix.\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    average : str, optional\r\n        \'micro\', \'macro\' or \'weighted\'\r\n    """"""\r\n    num_classes = cm.shape[0]\r\n    if pos_indices is None:\r\n        pos_indices = [i for i in range(num_classes)]\r\n\r\n    if average == \'micro\':\r\n        return pr_re_fbeta(cm, pos_indices, beta)\r\n    elif average in {\'macro\', \'weighted\'}:\r\n        precisions, recalls, fbetas, n_golds = [], [], [], []\r\n        for idx in pos_indices:\r\n            pr, re, fbeta = pr_re_fbeta(cm, [idx], beta)\r\n            precisions.append(pr)\r\n            recalls.append(re)\r\n            fbetas.append(fbeta)\r\n            cm_mask = np.zeros([num_classes, num_classes])\r\n            cm_mask[idx, :] = 1\r\n            n_golds.append(tf.to_float(tf.reduce_sum(cm * cm_mask)))\r\n\r\n        if average == \'macro\':\r\n            pr = tf.reduce_mean(precisions)\r\n            re = tf.reduce_mean(recalls)\r\n            fbeta = tf.reduce_mean(fbetas)\r\n            return pr, re, fbeta\r\n        if average == \'weighted\':\r\n            n_gold = tf.reduce_sum(n_golds)\r\n            pr_sum = sum(p * n for p, n in zip(precisions, n_golds))\r\n            pr = safe_div(pr_sum, n_gold)\r\n            re_sum = sum(r * n for r, n in zip(recalls, n_golds))\r\n            re = safe_div(re_sum, n_gold)\r\n            fbeta_sum = sum(f * n for f, n in zip(fbetas, n_golds))\r\n            fbeta = safe_div(fbeta_sum, n_gold)\r\n            return pr, re, fbeta\r\n\r\n    else:\r\n        raise NotImplementedError()'"
baselines/models/bert/tokenization.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\nimport unicodedata\nimport six\nimport tensorflow as tf\n\n\ndef validate_case_matches_checkpoint(do_lower_case, init_checkpoint):\n  """"""Checks whether the casing config is consistent with the checkpoint name.""""""\n\n  # The casing has to be passed in by the user and there is no explicit check\n  # as to whether it matches the checkpoint. The casing information probably\n  # should have been stored in the bert_config.json file, but it\'s not, so\n  # we have to heuristically detect it to validate.\n\n  if not init_checkpoint:\n    return\n\n  m = re.match(""^.*?([A-Za-z0-9_-]+)/bert_model.ckpt"", init_checkpoint)\n  if m is None:\n    return\n\n  model_name = m.group(1)\n\n  lower_models = [\n      ""uncased_L-24_H-1024_A-16"", ""uncased_L-12_H-768_A-12"",\n      ""multilingual_L-12_H-768_A-12"", ""chinese_L-12_H-768_A-12""\n  ]\n\n  cased_models = [\n      ""cased_L-12_H-768_A-12"", ""cased_L-24_H-1024_A-16"",\n      ""multi_cased_L-12_H-768_A-12""\n  ]\n\n  is_bad_config = False\n  if model_name in lower_models and not do_lower_case:\n    is_bad_config = True\n    actual_flag = ""False""\n    case_name = ""lowercased""\n    opposite_flag = ""True""\n\n  if model_name in cased_models and do_lower_case:\n    is_bad_config = True\n    actual_flag = ""True""\n    case_name = ""cased""\n    opposite_flag = ""False""\n\n  if is_bad_config:\n    raise ValueError(\n        ""You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. ""\n        ""However, `%s` seems to be a %s model, so you ""\n        ""should pass in `--do_lower_case=%s` so that the fine-tuning matches ""\n        ""how the model was pre-training. If this error is wrong, please ""\n        ""just comment out this check."" % (actual_flag, init_checkpoint,\n                                          model_name, case_name, opposite_flag))\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  index = 0\n  with tf.gfile.GFile(vocab_file, ""r"") as reader:\n    while True:\n      token = convert_to_unicode(reader.readline())\n      if not token:\n        break\n      token = token.strip()\n      vocab[token] = index\n      index += 1\n  return vocab\n\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  for item in items:\n    output.append(vocab[item])\n  return output\n\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True):\n    self.vocab = load_vocab(vocab_file)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n  def tokenize(self, text):\n    split_tokens = []\n    for token in self.basic_tokenizer.tokenize(text):\n      for sub_token in self.wordpiece_tokenizer.tokenize(token):\n        split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    return convert_by_vocab(self.inv_vocab, ids)\n\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = convert_to_unicode(text)\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n  """"""Runs WordPiece tokenziation.""""""\n\n  def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=200):\n    self.vocab = vocab\n    self.unk_token = unk_token\n    self.max_input_chars_per_word = max_input_chars_per_word\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text into its word pieces.\n\n    This uses a greedy longest-match-first algorithm to perform tokenization\n    using the given vocabulary.\n\n    For example:\n      input = ""unaffable""\n      output = [""un"", ""##aff"", ""##able""]\n\n    Args:\n      text: A single token or whitespace separated tokens. This should have\n        already been passed through `BasicTokenizer.\n\n    Returns:\n      A list of wordpiece tokens.\n    """"""\n\n    text = convert_to_unicode(text)\n\n    output_tokens = []\n    for token in whitespace_tokenize(text):\n      chars = list(token)\n      if len(chars) > self.max_input_chars_per_word:\n        output_tokens.append(self.unk_token)\n        continue\n\n      is_bad = False\n      start = 0\n      sub_tokens = []\n      while start < len(chars):\n        end = len(chars)\n        cur_substr = None\n        while start < end:\n          substr = """".join(chars[start:end])\n          if start > 0:\n            substr = ""##"" + substr\n          if substr in self.vocab:\n            cur_substr = substr\n            break\n          end -= 1\n        if cur_substr is None:\n          is_bad = True\n          break\n        sub_tokens.append(cur_substr)\n        start = end\n\n      if is_bad:\n        output_tokens.append(self.unk_token)\n      else:\n        output_tokens.extend(sub_tokens)\n    return output_tokens\n\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically contorl characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
baselines/models/bert/tokenization_test.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tempfile\nimport tokenization\nimport six\nimport tensorflow as tf\n\n\nclass TokenizationTest(tf.test.TestCase):\n\n  def test_full_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing"", "",""\n    ]\n    with tempfile.NamedTemporaryFile(delete=False) as vocab_writer:\n      if six.PY2:\n        vocab_writer.write("""".join([x + ""\\n"" for x in vocab_tokens]))\n      else:\n        vocab_writer.write("""".join(\n            [x + ""\\n"" for x in vocab_tokens]).encode(""utf-8""))\n\n      vocab_file = vocab_writer.name\n\n    tokenizer = tokenization.FullTokenizer(vocab_file)\n    os.unlink(vocab_file)\n\n    tokens = tokenizer.tokenize(u""UNwant\\u00E9d,running"")\n    self.assertAllEqual(tokens, [""un"", ""##want"", ""##ed"", "","", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.convert_tokens_to_ids(tokens), [7, 4, 5, 10, 8, 9])\n\n  def test_chinese(self):\n    tokenizer = tokenization.BasicTokenizer()\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u""ah\\u535A\\u63A8zz""),\n        [u""ah"", u""\\u535A"", u""\\u63A8"", u""zz""])\n\n  def test_basic_tokenizer_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=True)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""hello"", ""!"", ""how"", ""are"", ""you"", ""?""])\n    self.assertAllEqual(tokenizer.tokenize(u""H\\u00E9llo""), [""hello""])\n\n  def test_basic_tokenizer_no_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=False)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""HeLLo"", ""!"", ""how"", ""Are"", ""yoU"", ""?""])\n\n  def test_wordpiece_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n    tokenizer = tokenization.WordpieceTokenizer(vocab=vocab)\n\n    self.assertAllEqual(tokenizer.tokenize(""""), [])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwanted running""),\n        [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwantedX running""), [""[UNK]"", ""runn"", ""##ing""])\n\n  def test_convert_tokens_to_ids(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n\n    self.assertAllEqual(\n        tokenization.convert_tokens_to_ids(\n            vocab, [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""]), [7, 4, 5, 8, 9])\n\n  def test_is_whitespace(self):\n    self.assertTrue(tokenization._is_whitespace(u"" ""))\n    self.assertTrue(tokenization._is_whitespace(u""\\t""))\n    self.assertTrue(tokenization._is_whitespace(u""\\r""))\n    self.assertTrue(tokenization._is_whitespace(u""\\n""))\n    self.assertTrue(tokenization._is_whitespace(u""\\u00A0""))\n\n    self.assertFalse(tokenization._is_whitespace(u""A""))\n    self.assertFalse(tokenization._is_whitespace(u""-""))\n\n  def test_is_control(self):\n    self.assertTrue(tokenization._is_control(u""\\u0005""))\n\n    self.assertFalse(tokenization._is_control(u""A""))\n    self.assertFalse(tokenization._is_control(u"" ""))\n    self.assertFalse(tokenization._is_control(u""\\t""))\n    self.assertFalse(tokenization._is_control(u""\\r""))\n    self.assertFalse(tokenization._is_control(u""\\U0001F4A9""))\n\n  def test_is_punctuation(self):\n    self.assertTrue(tokenization._is_punctuation(u""-""))\n    self.assertTrue(tokenization._is_punctuation(u""$""))\n    self.assertTrue(tokenization._is_punctuation(u""`""))\n    self.assertTrue(tokenization._is_punctuation(u"".""))\n\n    self.assertFalse(tokenization._is_punctuation(u""A""))\n    self.assertFalse(tokenization._is_punctuation(u"" ""))\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/bert_wwm_ext/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n'"
baselines/models/bert_wwm_ext/conlleval.py,0,"b'# Python version of the evaluation script from CoNLL\'00-\n# Originates from: https://github.com/spyysalo/conlleval.py\n\n\n# Intentional differences:\n# - accept any space as delimiter by default\n# - optional file argument (default STDIN)\n# - option to set boundary (-b argument)\n# - LaTeX output (-l argument) not supported\n# - raw tags (-r argument) not supported\n\n# add function :evaluate(predicted_label, ori_label): which will not read from file\n\nimport sys\nimport re\nimport codecs\nfrom collections import defaultdict, namedtuple\n\nANY_SPACE = \'<SPACE>\'\n\n\nclass FormatError(Exception):\n    pass\n\nMetrics = namedtuple(\'Metrics\', \'tp fp fn prec rec fscore\')\n\n\nclass EvalCounts(object):\n    def __init__(self):\n        self.correct_chunk = 0    # number of correctly identified chunks\n        self.correct_tags = 0     # number of correct chunk tags\n        self.found_correct = 0    # number of chunks in corpus\n        self.found_guessed = 0    # number of identified chunks\n        self.token_counter = 0    # token counter (ignores sentence breaks)\n\n        # counts by type\n        self.t_correct_chunk = defaultdict(int)\n        self.t_found_correct = defaultdict(int)\n        self.t_found_guessed = defaultdict(int)\n\n\ndef parse_args(argv):\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=\'evaluate tagging results using CoNLL criteria\',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    arg = parser.add_argument\n    arg(\'-b\', \'--boundary\', metavar=\'STR\', default=\'-X-\',\n        help=\'sentence boundary\')\n    arg(\'-d\', \'--delimiter\', metavar=\'CHAR\', default=ANY_SPACE,\n        help=\'character delimiting items in input\')\n    arg(\'-o\', \'--otag\', metavar=\'CHAR\', default=\'O\',\n        help=\'alternative outside tag\')\n    arg(\'file\', nargs=\'?\', default=None)\n    return parser.parse_args(argv)\n\n\ndef parse_tag(t):\n    m = re.match(r\'^([^-]*)-(.*)$\', t)\n    return m.groups() if m else (t, \'\')\n\n\ndef evaluate(iterable, options=None):\n    if options is None:\n        options = parse_args([])    # use defaults\n\n    counts = EvalCounts()\n    num_features = None       # number of features per line\n    in_correct = False        # currently processed chunks is correct until now\n    last_correct = \'O\'        # previous chunk tag in corpus\n    last_correct_type = \'\'    # type of previously identified chunk tag\n    last_guessed = \'O\'        # previously identified chunk tag\n    last_guessed_type = \'\'    # type of previous chunk tag in corpus\n\n    for line in iterable:\n        line = line.rstrip(\'\\r\\n\')\n\n        if options.delimiter == ANY_SPACE:\n            features = line.split()\n        else:\n            features = line.split(options.delimiter)\n\n        if num_features is None:\n            num_features = len(features)\n        elif num_features != len(features) and len(features) != 0:\n            raise FormatError(\'unexpected number of features: %d (%d)\' %\n                              (len(features), num_features))\n\n        if len(features) == 0 or features[0] == options.boundary:\n            features = [options.boundary, \'O\', \'O\']\n        if len(features) < 3:\n            raise FormatError(\'unexpected number of features in line %s\' % line)\n\n        guessed, guessed_type = parse_tag(features.pop())\n        correct, correct_type = parse_tag(features.pop())\n        first_item = features.pop(0)\n\n        if first_item == options.boundary:\n            guessed = \'O\'\n\n        end_correct = end_of_chunk(last_correct, correct,\n                                   last_correct_type, correct_type)\n        end_guessed = end_of_chunk(last_guessed, guessed,\n                                   last_guessed_type, guessed_type)\n        start_correct = start_of_chunk(last_correct, correct,\n                                       last_correct_type, correct_type)\n        start_guessed = start_of_chunk(last_guessed, guessed,\n                                       last_guessed_type, guessed_type)\n\n        if in_correct:\n            if (end_correct and end_guessed and\n                last_guessed_type == last_correct_type):\n                in_correct = False\n                counts.correct_chunk += 1\n                counts.t_correct_chunk[last_correct_type] += 1\n            elif (end_correct != end_guessed or guessed_type != correct_type):\n                in_correct = False\n\n        if start_correct and start_guessed and guessed_type == correct_type:\n            in_correct = True\n\n        if start_correct:\n            counts.found_correct += 1\n            counts.t_found_correct[correct_type] += 1\n        if start_guessed:\n            counts.found_guessed += 1\n            counts.t_found_guessed[guessed_type] += 1\n        if first_item != options.boundary:\n            if correct == guessed and guessed_type == correct_type:\n                counts.correct_tags += 1\n            counts.token_counter += 1\n\n        last_guessed = guessed\n        last_correct = correct\n        last_guessed_type = guessed_type\n        last_correct_type = correct_type\n\n    if in_correct:\n        counts.correct_chunk += 1\n        counts.t_correct_chunk[last_correct_type] += 1\n\n    return counts\n\n\n\ndef uniq(iterable):\n  seen = set()\n  return [i for i in iterable if not (i in seen or seen.add(i))]\n\n\ndef calculate_metrics(correct, guessed, total):\n    tp, fp, fn = correct, guessed-correct, total-correct\n    p = 0 if tp + fp == 0 else 1.*tp / (tp + fp)\n    r = 0 if tp + fn == 0 else 1.*tp / (tp + fn)\n    f = 0 if p + r == 0 else 2 * p * r / (p + r)\n    return Metrics(tp, fp, fn, p, r, f)\n\n\ndef metrics(counts):\n    c = counts\n    overall = calculate_metrics(\n        c.correct_chunk, c.found_guessed, c.found_correct\n    )\n    by_type = {}\n    for t in uniq(list(c.t_found_correct) + list(c.t_found_guessed)):\n        by_type[t] = calculate_metrics(\n            c.t_correct_chunk[t], c.t_found_guessed[t], c.t_found_correct[t]\n        )\n    return overall, by_type\n\n\ndef report(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    out.write(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    out.write(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n\n    if c.token_counter > 0:\n        out.write(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        out.write(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        out.write(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n\n    for i, m in sorted(by_type.items()):\n        out.write(\'%17s: \' % i)\n        out.write(\'precision: %6.2f%%; \' % (100.*m.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*m.rec))\n        out.write(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n\n\ndef report_notprint(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    final_report = []\n    line = []\n    line.append(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    line.append(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n    final_report.append("""".join(line))\n\n    if c.token_counter > 0:\n        line = []\n        line.append(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        line.append(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        line.append(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n        final_report.append("""".join(line))\n\n    for i, m in sorted(by_type.items()):\n        line = []\n        line.append(\'%17s: \' % i)\n        line.append(\'precision: %6.2f%%; \' % (100.*m.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*m.rec))\n        line.append(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n        final_report.append("""".join(line))\n    return final_report\n\n\ndef end_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk ended between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_end = False\n\n    if prev_tag == \'E\': chunk_end = True\n    if prev_tag == \'S\': chunk_end = True\n\n    if prev_tag == \'B\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'O\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'O\': chunk_end = True\n\n    if prev_tag != \'O\' and prev_tag != \'.\' and prev_type != type_:\n        chunk_end = True\n\n    # these chunks are assumed to have length 1\n    if prev_tag == \']\': chunk_end = True\n    if prev_tag == \'[\': chunk_end = True\n\n    return chunk_end\n\n\ndef start_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk started between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_start = False\n\n    if tag == \'B\': chunk_start = True\n    if tag == \'S\': chunk_start = True\n\n    if prev_tag == \'E\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'E\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'I\': chunk_start = True\n\n    if tag != \'O\' and tag != \'.\' and prev_type != type_:\n        chunk_start = True\n\n    # these chunks are assumed to have length 1\n    if tag == \'[\': chunk_start = True\n    if tag == \']\': chunk_start = True\n\n    return chunk_start\n\n\ndef return_report(input_file):\n    with codecs.open(input_file, ""r"", ""utf8"") as f:\n        counts = evaluate(f)\n    return report_notprint(counts)\n\n\ndef main(argv):\n    args = parse_args(argv[1:])\n\n    if args.file is None:\n        counts = evaluate(sys.stdin, args)\n    else:\n        with open(args.file) as f:\n            counts = evaluate(f, args)\n    report(counts)\n\nif __name__ == \'__main__\':\n    sys.exit(main(sys.argv))'"
baselines/models/bert_wwm_ext/create_pretraining_data.py,17,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\n\nclass TrainingInstance(object):\n  """"""A single training instance (sentence pair).""""""\n\n  def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n               is_random_next):\n    self.tokens = tokens\n    self.segment_ids = segment_ids\n    self.is_random_next = is_random_next\n    self.masked_lm_positions = masked_lm_positions\n    self.masked_lm_labels = masked_lm_labels\n\n  def __str__(self):\n    s = """"\n    s += ""tokens: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.tokens]))\n    s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n    s += ""is_random_next: %s\\n"" % self.is_random_next\n    s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n        [str(x) for x in self.masked_lm_positions]))\n    s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n    s += ""\\n""\n    return s\n\n  def __repr__(self):\n    return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n  """"""Create TF example files from `TrainingInstance`s.""""""\n  writers = []\n  for output_file in output_files:\n    writers.append(tf.python_io.TFRecordWriter(output_file))\n\n  writer_index = 0\n\n  total_written = 0\n  for (inst_index, instance) in enumerate(instances):\n    input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n    input_mask = [1] * len(input_ids)\n    segment_ids = list(instance.segment_ids)\n    assert len(input_ids) <= max_seq_length\n\n    while len(input_ids) < max_seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      segment_ids.append(0)\n\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n\n    masked_lm_positions = list(instance.masked_lm_positions)\n    masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n    masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n    while len(masked_lm_positions) < max_predictions_per_seq:\n      masked_lm_positions.append(0)\n      masked_lm_ids.append(0)\n      masked_lm_weights.append(0.0)\n\n    next_sentence_label = 1 if instance.is_random_next else 0\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(input_ids)\n    features[""input_mask""] = create_int_feature(input_mask)\n    features[""segment_ids""] = create_int_feature(segment_ids)\n    features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n    features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n    features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n    features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n    writers[writer_index].write(tf_example.SerializeToString())\n    writer_index = (writer_index + 1) % len(writers)\n\n    total_written += 1\n\n    if inst_index < 20:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in instance.tokens]))\n\n      for feature_name in features.keys():\n        feature = features[feature_name]\n        values = []\n        if feature.int64_list.value:\n          values = feature.int64_list.value\n        elif feature.float_list.value:\n          values = feature.float_list.value\n        tf.logging.info(\n            ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n  for writer in writers:\n    writer.close()\n\n  tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n  feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n  return feature\n\n\ndef create_float_feature(values):\n  feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n  return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n  """"""Create `TrainingInstance`s from raw text.""""""\n  all_documents = [[]]\n\n  # Input file format:\n  # (1) One sentence per line. These should ideally be actual sentences, not\n  # entire paragraphs or arbitrary spans of text. (Because we use the\n  # sentence boundaries for the ""next sentence prediction"" task).\n  # (2) Blank lines between documents. Document boundaries are needed so\n  # that the ""next sentence prediction"" task doesn\'t span between documents.\n  for input_file in input_files:\n    with tf.gfile.GFile(input_file, ""r"") as reader:\n      while True:\n        line = tokenization.convert_to_unicode(reader.readline())\n        if not line:\n          break\n        line = line.strip()\n\n        # Empty lines are used as document delimiters\n        if not line:\n          all_documents.append([])\n        tokens = tokenizer.tokenize(line)\n        if tokens:\n          all_documents[-1].append(tokens)\n\n  # Remove empty documents\n  all_documents = [x for x in all_documents if x]\n  rng.shuffle(all_documents)\n\n  vocab_words = list(tokenizer.vocab.keys())\n  instances = []\n  for _ in range(dupe_factor):\n    for document_index in range(len(all_documents)):\n      instances.extend(\n          create_instances_from_document(\n              all_documents, document_index, max_seq_length, short_seq_prob,\n              masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n  rng.shuffle(instances)\n  return instances\n\n\ndef create_instances_from_document(\n    all_documents, document_index, max_seq_length, short_seq_prob,\n    masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n  """"""Creates `TrainingInstance`s for a single document.""""""\n  document = all_documents[document_index]\n\n  # Account for [CLS], [SEP], [SEP]\n  max_num_tokens = max_seq_length - 3\n\n  # We *usually* want to fill up the entire sequence since we are padding\n  # to `max_seq_length` anyways, so short sequences are generally wasted\n  # computation. However, we *sometimes*\n  # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n  # sequences to minimize the mismatch between pre-training and fine-tuning.\n  # The `target_seq_length` is just a rough target however, whereas\n  # `max_seq_length` is a hard limit.\n  target_seq_length = max_num_tokens\n  if rng.random() < short_seq_prob:\n    target_seq_length = rng.randint(2, max_num_tokens)\n\n  # We DON\'T just concatenate all of the tokens from a document into a long\n  # sequence and choose an arbitrary split point because this would make the\n  # next sentence prediction task too easy. Instead, we split the input into\n  # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n  # input.\n  instances = []\n  current_chunk = []\n  current_length = 0\n  i = 0\n  while i < len(document):\n    segment = document[i]\n    current_chunk.append(segment)\n    current_length += len(segment)\n    if i == len(document) - 1 or current_length >= target_seq_length:\n      if current_chunk:\n        # `a_end` is how many segments from `current_chunk` go into the `A`\n        # (first) sentence.\n        a_end = 1\n        if len(current_chunk) >= 2:\n          a_end = rng.randint(1, len(current_chunk) - 1)\n\n        tokens_a = []\n        for j in range(a_end):\n          tokens_a.extend(current_chunk[j])\n\n        tokens_b = []\n        # Random next\n        is_random_next = False\n        if len(current_chunk) == 1 or rng.random() < 0.5:\n          is_random_next = True\n          target_b_length = target_seq_length - len(tokens_a)\n\n          # This should rarely go for more than one iteration for large\n          # corpora. However, just to be careful, we try to make sure that\n          # the random document is not the same as the document\n          # we\'re processing.\n          for _ in range(10):\n            random_document_index = rng.randint(0, len(all_documents) - 1)\n            if random_document_index != document_index:\n              break\n\n          random_document = all_documents[random_document_index]\n          random_start = rng.randint(0, len(random_document) - 1)\n          for j in range(random_start, len(random_document)):\n            tokens_b.extend(random_document[j])\n            if len(tokens_b) >= target_b_length:\n              break\n          # We didn\'t actually use these segments so we ""put them back"" so\n          # they don\'t go to waste.\n          num_unused_segments = len(current_chunk) - a_end\n          i -= num_unused_segments\n        # Actual next\n        else:\n          is_random_next = False\n          for j in range(a_end, len(current_chunk)):\n            tokens_b.extend(current_chunk[j])\n        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n        assert len(tokens_a) >= 1\n        assert len(tokens_b) >= 1\n\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n          tokens.append(token)\n          segment_ids.append(0)\n\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        for token in tokens_b:\n          tokens.append(token)\n          segment_ids.append(1)\n        tokens.append(""[SEP]"")\n        segment_ids.append(1)\n\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance(\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n      current_chunk = []\n      current_length = 0\n    i += 1\n\n  return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n  """"""Creates the predictions for the masked LM objective.""""""\n\n  cand_indexes = []\n  for (i, token) in enumerate(tokens):\n    if token == ""[CLS]"" or token == ""[SEP]"":\n      continue\n    # Whole Word Masking means that if we mask all of the wordpieces\n    # corresponding to an original word. When a word has been split into\n    # WordPieces, the first token does not have any marker and any subsequence\n    # tokens are prefixed with ##. So whenever we see the ## token, we\n    # append it to the previous set of word indexes.\n    #\n    # Note that Whole Word Masking does *not* change the training code\n    # at all -- we still predict each WordPiece independently, softmaxed\n    # over the entire vocabulary.\n    if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n        token.startswith(""##"")):\n      cand_indexes[-1].append(i)\n    else:\n      cand_indexes.append([i])\n\n  rng.shuffle(cand_indexes)\n\n  output_tokens = list(tokens)\n\n  num_to_predict = min(max_predictions_per_seq,\n                       max(1, int(round(len(tokens) * masked_lm_prob))))\n\n  masked_lms = []\n  covered_indexes = set()\n  for index_set in cand_indexes:\n    if len(masked_lms) >= num_to_predict:\n      break\n    # If adding a whole-word mask would exceed the maximum number of\n    # predictions, then just skip this candidate.\n    if len(masked_lms) + len(index_set) > num_to_predict:\n      continue\n    is_any_index_covered = False\n    for index in index_set:\n      if index in covered_indexes:\n        is_any_index_covered = True\n        break\n    if is_any_index_covered:\n      continue\n    for index in index_set:\n      covered_indexes.add(index)\n\n      masked_token = None\n      # 80% of the time, replace with [MASK]\n      if rng.random() < 0.8:\n        masked_token = ""[MASK]""\n      else:\n        # 10% of the time, keep original\n        if rng.random() < 0.5:\n          masked_token = tokens[index]\n        # 10% of the time, replace with random word\n        else:\n          masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n      output_tokens[index] = masked_token\n\n      masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n  assert len(masked_lms) <= num_to_predict\n  masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n  masked_lm_positions = []\n  masked_lm_labels = []\n  for p in masked_lms:\n    masked_lm_positions.append(p.index)\n    masked_lm_labels.append(p.label)\n\n  return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n  """"""Truncates a pair of sequences to a maximum sequence length.""""""\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_num_tokens:\n      break\n\n    trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n    assert len(trunc_tokens) >= 1\n\n    # We want to sometimes truncate from the front and sometimes from the\n    # back to add more randomness and avoid biases.\n    if rng.random() < 0.5:\n      del trunc_tokens[0]\n    else:\n      trunc_tokens.pop()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Reading from input files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"", input_file)\n\n  rng = random.Random(FLAGS.random_seed)\n  instances = create_training_instances(\n      input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n      FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n      rng)\n\n  output_files = FLAGS.output_file.split("","")\n  tf.logging.info(""*** Writing to output files ***"")\n  for output_file in output_files:\n    tf.logging.info(""  %s"", output_file)\n\n  write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                  FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""output_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  tf.app.run()\n'"
baselines/models/bert_wwm_ext/extract_features.py,34,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Extract pre-computed feature vectors from BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport codecs\nimport collections\nimport json\nimport re\n\nimport modeling\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None, """")\n\nflags.DEFINE_string(""output_file"", None, """")\n\nflags.DEFINE_string(""layers"", ""-1,-2,-3,-4"", """")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(""batch_size"", 32, ""Batch size for predictions."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_string(""master"", None,\n                    ""If using a TPU, the address of the master."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""use_one_hot_embeddings"", False,\n    ""If True, tf.one_hot will be used for embedding lookups, otherwise ""\n    ""tf.nn.embedding_lookup will be used. On TPUs, this should be True ""\n    ""since it is much faster."")\n\n\nclass InputExample(object):\n\n  def __init__(self, unique_id, text_a, text_b):\n    self.unique_id = unique_id\n    self.text_a = text_a\n    self.text_b = text_b\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self, unique_id, tokens, input_ids, input_mask, input_type_ids):\n    self.unique_id = unique_id\n    self.tokens = tokens\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.input_type_ids = input_type_ids\n\n\ndef input_fn_builder(features, seq_length):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_unique_ids = []\n  all_input_ids = []\n  all_input_mask = []\n  all_input_type_ids = []\n\n  for feature in features:\n    all_unique_ids.append(feature.unique_id)\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_input_type_ids.append(feature.input_type_ids)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""unique_ids"":\n            tf.constant(all_unique_ids, shape=[num_examples], dtype=tf.int32),\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_type_ids"":\n            tf.constant(\n                all_input_type_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n    })\n\n    d = d.batch(batch_size=batch_size, drop_remainder=False)\n    return d\n\n  return input_fn\n\n\ndef model_fn_builder(bert_config, init_checkpoint, layer_indexes, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    input_type_ids = features[""input_type_ids""]\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=False,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=input_type_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    if mode != tf.estimator.ModeKeys.PREDICT:\n      raise ValueError(""Only PREDICT modes are supported: %s"" % (mode))\n\n    tvars = tf.trainable_variables()\n    scaffold_fn = None\n    (assignment_map,\n     initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(\n         tvars, init_checkpoint)\n    if use_tpu:\n\n      def tpu_scaffold():\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        return tf.train.Scaffold()\n\n      scaffold_fn = tpu_scaffold\n    else:\n      tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    all_layers = model.get_all_encoder_layers()\n\n    predictions = {\n        ""unique_id"": unique_ids,\n    }\n\n    for (i, layer_index) in enumerate(layer_indexes):\n      predictions[""layer_output_%d"" % i] = all_layers[layer_index]\n\n    output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n        mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\ndef convert_examples_to_features(examples, seq_length, tokenizer):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    tokens_a = tokenizer.tokenize(example.text_a)\n\n    tokens_b = None\n    if example.text_b:\n      tokens_b = tokenizer.tokenize(example.text_b)\n\n    if tokens_b:\n      # Modifies `tokens_a` and `tokens_b` in place so that the total\n      # length is less than the specified length.\n      # Account for [CLS], [SEP], [SEP] with ""- 3""\n      _truncate_seq_pair(tokens_a, tokens_b, seq_length - 3)\n    else:\n      # Account for [CLS] and [SEP] with ""- 2""\n      if len(tokens_a) > seq_length - 2:\n        tokens_a = tokens_a[0:(seq_length - 2)]\n\n    # The convention in BERT is:\n    # (a) For sequence pairs:\n    #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n    #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n    # (b) For single sequences:\n    #  tokens:   [CLS] the dog is hairy . [SEP]\n    #  type_ids: 0     0   0   0  0     0 0\n    #\n    # Where ""type_ids"" are used to indicate whether this is the first\n    # sequence or the second sequence. The embedding vectors for `type=0` and\n    # `type=1` were learned during pre-training and are added to the wordpiece\n    # embedding vector (and position vector). This is not *strictly* necessary\n    # since the [SEP] token unambiguously separates the sequences, but it makes\n    # it easier for the model to learn the concept of sequences.\n    #\n    # For classification tasks, the first vector (corresponding to [CLS]) is\n    # used as as the ""sentence vector"". Note that this only makes sense because\n    # the entire model is fine-tuned.\n    tokens = []\n    input_type_ids = []\n    tokens.append(""[CLS]"")\n    input_type_ids.append(0)\n    for token in tokens_a:\n      tokens.append(token)\n      input_type_ids.append(0)\n    tokens.append(""[SEP]"")\n    input_type_ids.append(0)\n\n    if tokens_b:\n      for token in tokens_b:\n        tokens.append(token)\n        input_type_ids.append(1)\n      tokens.append(""[SEP]"")\n      input_type_ids.append(1)\n\n    input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n    # The mask has 1 for real tokens and 0 for padding tokens. Only real\n    # tokens are attended to.\n    input_mask = [1] * len(input_ids)\n\n    # Zero-pad up to the sequence length.\n    while len(input_ids) < seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      input_type_ids.append(0)\n\n    assert len(input_ids) == seq_length\n    assert len(input_mask) == seq_length\n    assert len(input_type_ids) == seq_length\n\n    if ex_index < 5:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""unique_id: %s"" % (example.unique_id))\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in tokens]))\n      tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n      tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n      tf.logging.info(\n          ""input_type_ids: %s"" % "" "".join([str(x) for x in input_type_ids]))\n\n    features.append(\n        InputFeatures(\n            unique_id=example.unique_id,\n            tokens=tokens,\n            input_ids=input_ids,\n            input_mask=input_mask,\n            input_type_ids=input_type_ids))\n  return features\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef read_examples(input_file):\n  """"""Read a list of `InputExample`s from an input file.""""""\n  examples = []\n  unique_id = 0\n  with tf.gfile.GFile(input_file, ""r"") as reader:\n    while True:\n      line = tokenization.convert_to_unicode(reader.readline())\n      if not line:\n        break\n      line = line.strip()\n      text_a = None\n      text_b = None\n      m = re.match(r""^(.*) \\|\\|\\| (.*)$"", line)\n      if m is None:\n        text_a = line\n      else:\n        text_a = m.group(1)\n        text_b = m.group(2)\n      examples.append(\n          InputExample(unique_id=unique_id, text_a=text_a, text_b=text_b))\n      unique_id += 1\n  return examples\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  layer_indexes = [int(x) for x in FLAGS.layers.split("","")]\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      master=FLAGS.master,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  examples = read_examples(FLAGS.input_file)\n\n  features = convert_examples_to_features(\n      examples=examples, seq_length=FLAGS.max_seq_length, tokenizer=tokenizer)\n\n  unique_id_to_feature = {}\n  for feature in features:\n    unique_id_to_feature[feature.unique_id] = feature\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      layer_indexes=layer_indexes,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_one_hot_embeddings)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      predict_batch_size=FLAGS.batch_size)\n\n  input_fn = input_fn_builder(\n      features=features, seq_length=FLAGS.max_seq_length)\n\n  with codecs.getwriter(""utf-8"")(tf.gfile.Open(FLAGS.output_file,\n                                               ""w"")) as writer:\n    for result in estimator.predict(input_fn, yield_single_examples=True):\n      unique_id = int(result[""unique_id""])\n      feature = unique_id_to_feature[unique_id]\n      output_json = collections.OrderedDict()\n      output_json[""linex_index""] = unique_id\n      all_features = []\n      for (i, token) in enumerate(feature.tokens):\n        all_layers = []\n        for (j, layer_index) in enumerate(layer_indexes):\n          layer_output = result[""layer_output_%d"" % j]\n          layers = collections.OrderedDict()\n          layers[""index""] = layer_index\n          layers[""values""] = [\n              round(float(x), 6) for x in layer_output[i:(i + 1)].flat\n          ]\n          all_layers.append(layers)\n        features = collections.OrderedDict()\n        features[""token""] = token\n        features[""layers""] = all_layers\n        all_features.append(features)\n      output_json[""features""] = all_features\n      writer.write(json.dumps(output_json) + ""\\n"")\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""init_checkpoint"")\n  flags.mark_flag_as_required(""output_file"")\n  tf.app.run()\n'"
baselines/models/bert_wwm_ext/modeling.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The main BERT model and related functions.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport numpy as np\nimport six\nimport tensorflow as tf\n\n\nclass BertConfig(object):\n  """"""Configuration for `BertModel`.""""""\n\n  def __init__(self,\n               vocab_size,\n               hidden_size=768,\n               num_hidden_layers=12,\n               num_attention_heads=12,\n               intermediate_size=3072,\n               hidden_act=""gelu"",\n               hidden_dropout_prob=0.1,\n               attention_probs_dropout_prob=0.1,\n               max_position_embeddings=512,\n               type_vocab_size=16,\n               initializer_range=0.02):\n    """"""Constructs BertConfig.\n\n    Args:\n      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.\n      hidden_size: Size of the encoder layers and the pooler layer.\n      num_hidden_layers: Number of hidden layers in the Transformer encoder.\n      num_attention_heads: Number of attention heads for each attention layer in\n        the Transformer encoder.\n      intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n        layer in the Transformer encoder.\n      hidden_act: The non-linear activation function (function or string) in the\n        encoder and pooler.\n      hidden_dropout_prob: The dropout probability for all fully connected\n        layers in the embeddings, encoder, and pooler.\n      attention_probs_dropout_prob: The dropout ratio for the attention\n        probabilities.\n      max_position_embeddings: The maximum sequence length that this model might\n        ever be used with. Typically set this to something large just in case\n        (e.g., 512 or 1024 or 2048).\n      type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n        `BertModel`.\n      initializer_range: The stdev of the truncated_normal_initializer for\n        initializing all weight matrices.\n    """"""\n    self.vocab_size = vocab_size\n    self.hidden_size = hidden_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.hidden_act = hidden_act\n    self.intermediate_size = intermediate_size\n    self.hidden_dropout_prob = hidden_dropout_prob\n    self.attention_probs_dropout_prob = attention_probs_dropout_prob\n    self.max_position_embeddings = max_position_embeddings\n    self.type_vocab_size = type_vocab_size\n    self.initializer_range = initializer_range\n\n  @classmethod\n  def from_dict(cls, json_object):\n    """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n    config = BertConfig(vocab_size=None)\n    for (key, value) in six.iteritems(json_object):\n      config.__dict__[key] = value\n    return config\n\n  @classmethod\n  def from_json_file(cls, json_file):\n    """"""Constructs a `BertConfig` from a json file of parameters.""""""\n    with tf.gfile.GFile(json_file, ""r"") as reader:\n      text = reader.read()\n    return cls.from_dict(json.loads(text))\n\n  def to_dict(self):\n    """"""Serializes this instance to a Python dictionary.""""""\n    output = copy.deepcopy(self.__dict__)\n    return output\n\n  def to_json_string(self):\n    """"""Serializes this instance to a JSON string.""""""\n    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass BertModel(object):\n  """"""BERT model (""Bidirectional Encoder Representations from Transformers"").\n\n  Example usage:\n\n  ```python\n  # Already been converted into WordPiece token ids\n  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])\n  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])\n  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])\n\n  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,\n    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)\n\n  model = modeling.BertModel(config=config, is_training=True,\n    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)\n\n  label_embeddings = tf.get_variable(...)\n  pooled_output = model.get_pooled_output()\n  logits = tf.matmul(pooled_output, label_embeddings)\n  ...\n  ```\n  """"""\n\n  def __init__(self,\n               config,\n               is_training,\n               input_ids,\n               input_mask=None,\n               token_type_ids=None,\n               use_one_hot_embeddings=False,\n               scope=None):\n    """"""Constructor for BertModel.\n\n    Args:\n      config: `BertConfig` instance.\n      is_training: bool. true for training model, false for eval model. Controls\n        whether dropout will be applied.\n      input_ids: int32 Tensor of shape [batch_size, seq_length].\n      input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].\n      token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      use_one_hot_embeddings: (optional) bool. Whether to use one-hot word\n        embeddings or tf.embedding_lookup() for the word embeddings.\n      scope: (optional) variable scope. Defaults to ""bert"".\n\n    Raises:\n      ValueError: The config is invalid or one of the input tensor shapes\n        is invalid.\n    """"""\n    config = copy.deepcopy(config)\n    if not is_training:\n      config.hidden_dropout_prob = 0.0\n      config.attention_probs_dropout_prob = 0.0\n\n    input_shape = get_shape_list(input_ids, expected_rank=2)\n    batch_size = input_shape[0]\n    seq_length = input_shape[1]\n\n    if input_mask is None:\n      input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    if token_type_ids is None:\n      token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    with tf.variable_scope(scope, default_name=""bert""):\n      with tf.variable_scope(""embeddings""):\n        # Perform embedding lookup on the word ids.\n        (self.embedding_output, self.embedding_table) = embedding_lookup(\n            input_ids=input_ids,\n            vocab_size=config.vocab_size,\n            embedding_size=config.hidden_size,\n            initializer_range=config.initializer_range,\n            word_embedding_name=""word_embeddings"",\n            use_one_hot_embeddings=use_one_hot_embeddings)\n\n        # Add positional embeddings and token type embeddings, then layer\n        # normalize and perform dropout.\n        self.embedding_output = embedding_postprocessor(\n            input_tensor=self.embedding_output,\n            use_token_type=True,\n            token_type_ids=token_type_ids,\n            token_type_vocab_size=config.type_vocab_size,\n            token_type_embedding_name=""token_type_embeddings"",\n            use_position_embeddings=True,\n            position_embedding_name=""position_embeddings"",\n            initializer_range=config.initializer_range,\n            max_position_embeddings=config.max_position_embeddings,\n            dropout_prob=config.hidden_dropout_prob)\n\n      with tf.variable_scope(""encoder""):\n        # This converts a 2D mask of shape [batch_size, seq_length] to a 3D\n        # mask of shape [batch_size, seq_length, seq_length] which is used\n        # for the attention scores.\n        attention_mask = create_attention_mask_from_input_mask(\n            input_ids, input_mask)\n\n        # Run the stacked transformer.\n        # `sequence_output` shape = [batch_size, seq_length, hidden_size].\n        self.all_encoder_layers = transformer_model(\n            input_tensor=self.embedding_output,\n            attention_mask=attention_mask,\n            hidden_size=config.hidden_size,\n            num_hidden_layers=config.num_hidden_layers,\n            num_attention_heads=config.num_attention_heads,\n            intermediate_size=config.intermediate_size,\n            intermediate_act_fn=get_activation(config.hidden_act),\n            hidden_dropout_prob=config.hidden_dropout_prob,\n            attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n            initializer_range=config.initializer_range,\n            do_return_all_layers=True)\n\n      self.sequence_output = self.all_encoder_layers[-1]\n      # The ""pooler"" converts the encoded sequence tensor of shape\n      # [batch_size, seq_length, hidden_size] to a tensor of shape\n      # [batch_size, hidden_size]. This is necessary for segment-level\n      # (or segment-pair-level) classification tasks where we need a fixed\n      # dimensional representation of the segment.\n      with tf.variable_scope(""pooler""):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token. We assume that this has been pre-trained\n        first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)\n        self.pooled_output = tf.layers.dense(\n            first_token_tensor,\n            config.hidden_size,\n            activation=tf.tanh,\n            kernel_initializer=create_initializer(config.initializer_range))\n\n  def get_pooled_output(self):\n    return self.pooled_output\n\n  def get_sequence_output(self):\n    """"""Gets final hidden layer of encoder.\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the final hidden of the transformer encoder.\n    """"""\n    return self.sequence_output\n\n  def get_all_encoder_layers(self):\n    return self.all_encoder_layers\n\n  def get_embedding_output(self):\n    """"""Gets output of the embedding lookup (i.e., input to the transformer).\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the output of the embedding layer, after summing the word\n      embeddings with the positional embeddings and the token type embeddings,\n      then performing layer normalization. This is the input to the transformer.\n    """"""\n    return self.embedding_output\n\n  def get_embedding_table(self):\n    return self.embedding_table\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef get_activation(activation_string):\n  """"""Maps a string to a Python function, e.g., ""relu"" => `tf.nn.relu`.\n\n  Args:\n    activation_string: String name of the activation function.\n\n  Returns:\n    A Python function corresponding to the activation function. If\n    `activation_string` is None, empty, or ""linear"", this will return None.\n    If `activation_string` is not a string, it will return `activation_string`.\n\n  Raises:\n    ValueError: The `activation_string` does not correspond to a known\n      activation.\n  """"""\n\n  # We assume that anything that""s not a string is already an activation\n  # function, so we just return it.\n  if not isinstance(activation_string, six.string_types):\n    return activation_string\n\n  if not activation_string:\n    return None\n\n  act = activation_string.lower()\n  if act == ""linear"":\n    return None\n  elif act == ""relu"":\n    return tf.nn.relu\n  elif act == ""gelu"":\n    return gelu\n  elif act == ""tanh"":\n    return tf.tanh\n  else:\n    raise ValueError(""Unsupported activation: %s"" % act)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    if name not in name_to_variable:\n      continue\n    assignment_map[name] = name\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\ndef dropout(input_tensor, dropout_prob):\n  """"""Perform dropout.\n\n  Args:\n    input_tensor: float Tensor.\n    dropout_prob: Python float. The probability of dropping out a value (NOT of\n      *keeping* a dimension as in `tf.nn.dropout`).\n\n  Returns:\n    A version of `input_tensor` with dropout applied.\n  """"""\n  if dropout_prob is None or dropout_prob == 0.0:\n    return input_tensor\n\n  output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob)\n  return output\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n  """"""Runs layer normalization followed by dropout.""""""\n  output_tensor = layer_norm(input_tensor, name)\n  output_tensor = dropout(output_tensor, dropout_prob)\n  return output_tensor\n\n\ndef create_initializer(initializer_range=0.02):\n  """"""Creates a `truncated_normal_initializer` with the given range.""""""\n  return tf.truncated_normal_initializer(stddev=initializer_range)\n\n\ndef embedding_lookup(input_ids,\n                     vocab_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n  """"""Looks up words embeddings for id tensor.\n\n  Args:\n    input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n      ids.\n    vocab_size: int. Size of the embedding vocabulary.\n    embedding_size: int. Width of the word embeddings.\n    initializer_range: float. Embedding initialization range.\n    word_embedding_name: string. Name of the embedding table.\n    use_one_hot_embeddings: bool. If True, use one-hot method for word\n      embeddings. If False, use `tf.gather()`.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, embedding_size].\n  """"""\n  # This function assumes that the input is of shape [batch_size, seq_length,\n  # num_inputs].\n  #\n  # If the input is a 2D tensor of shape [batch_size, seq_length], we\n  # reshape to [batch_size, seq_length, 1].\n  if input_ids.shape.ndims == 2:\n    input_ids = tf.expand_dims(input_ids, axis=[-1])\n\n  embedding_table = tf.get_variable(\n      name=word_embedding_name,\n      shape=[vocab_size, embedding_size],\n      initializer=create_initializer(initializer_range))\n\n  flat_input_ids = tf.reshape(input_ids, [-1])\n  if use_one_hot_embeddings:\n    one_hot_input_ids = tf.one_hot(flat_input_ids, depth=vocab_size)\n    output = tf.matmul(one_hot_input_ids, embedding_table)\n  else:\n    output = tf.gather(embedding_table, flat_input_ids)\n\n  input_shape = get_shape_list(input_ids)\n\n  output = tf.reshape(output,\n                      input_shape[0:-1] + [input_shape[-1] * embedding_size])\n  return (output, embedding_table)\n\n\ndef embedding_postprocessor(input_tensor,\n                            use_token_type=False,\n                            token_type_ids=None,\n                            token_type_vocab_size=16,\n                            token_type_embedding_name=""token_type_embeddings"",\n                            use_position_embeddings=True,\n                            position_embedding_name=""position_embeddings"",\n                            initializer_range=0.02,\n                            max_position_embeddings=512,\n                            dropout_prob=0.1):\n  """"""Performs various post-processing on a word embedding tensor.\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length,\n      embedding_size].\n    use_token_type: bool. Whether to add embeddings for `token_type_ids`.\n    token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      Must be specified if `use_token_type` is True.\n    token_type_vocab_size: int. The vocabulary size of `token_type_ids`.\n    token_type_embedding_name: string. The name of the embedding table variable\n      for token type ids.\n    use_position_embeddings: bool. Whether to add position embeddings for the\n      position of each token in the sequence.\n    position_embedding_name: string. The name of the embedding table variable\n      for positional embeddings.\n    initializer_range: float. Range of the weight initialization.\n    max_position_embeddings: int. Maximum sequence length that might ever be\n      used with this model. This can be longer than the sequence length of\n      input_tensor, but cannot be shorter.\n    dropout_prob: float. Dropout probability applied to the final output tensor.\n\n  Returns:\n    float tensor with same shape as `input_tensor`.\n\n  Raises:\n    ValueError: One of the tensor shapes or input values is invalid.\n  """"""\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  width = input_shape[2]\n\n  output = input_tensor\n\n  if use_token_type:\n    if token_type_ids is None:\n      raise ValueError(""`token_type_ids` must be specified if""\n                       ""`use_token_type` is True."")\n    token_type_table = tf.get_variable(\n        name=token_type_embedding_name,\n        shape=[token_type_vocab_size, width],\n        initializer=create_initializer(initializer_range))\n    # This vocab will be small so we always do one-hot here, since it is always\n    # faster for a small vocabulary.\n    flat_token_type_ids = tf.reshape(token_type_ids, [-1])\n    one_hot_ids = tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)\n    token_type_embeddings = tf.matmul(one_hot_ids, token_type_table)\n    token_type_embeddings = tf.reshape(token_type_embeddings,\n                                       [batch_size, seq_length, width])\n    output += token_type_embeddings\n\n  if use_position_embeddings:\n    assert_op = tf.assert_less_equal(seq_length, max_position_embeddings)\n    with tf.control_dependencies([assert_op]):\n      full_position_embeddings = tf.get_variable(\n          name=position_embedding_name,\n          shape=[max_position_embeddings, width],\n          initializer=create_initializer(initializer_range))\n      # Since the position embedding table is a learned variable, we create it\n      # using a (long) sequence length `max_position_embeddings`. The actual\n      # sequence length might be shorter than this, for faster training of\n      # tasks that do not have long sequences.\n      #\n      # So `full_position_embeddings` is effectively an embedding table\n      # for position [0, 1, 2, ..., max_position_embeddings-1], and the current\n      # sequence has positions [0, 1, 2, ... seq_length-1], so we can just\n      # perform a slice.\n      position_embeddings = tf.slice(full_position_embeddings, [0, 0],\n                                     [seq_length, -1])\n      num_dims = len(output.shape.as_list())\n\n      # Only the last two dimensions are relevant (`seq_length` and `width`), so\n      # we broadcast among the first dimensions, which is typically just\n      # the batch size.\n      position_broadcast_shape = []\n      for _ in range(num_dims - 2):\n        position_broadcast_shape.append(1)\n      position_broadcast_shape.extend([seq_length, width])\n      position_embeddings = tf.reshape(position_embeddings,\n                                       position_broadcast_shape)\n      output += position_embeddings\n\n  output = layer_norm_and_dropout(output, dropout_prob)\n  return output\n\n\ndef create_attention_mask_from_input_mask(from_tensor, to_mask):\n  """"""Create 3D attention mask from a 2D tensor mask.\n\n  Args:\n    from_tensor: 2D or 3D Tensor of shape [batch_size, from_seq_length, ...].\n    to_mask: int32 Tensor of shape [batch_size, to_seq_length].\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length, to_seq_length].\n  """"""\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  batch_size = from_shape[0]\n  from_seq_length = from_shape[1]\n\n  to_shape = get_shape_list(to_mask, expected_rank=2)\n  to_seq_length = to_shape[1]\n\n  to_mask = tf.cast(\n      tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)\n\n  # We don\'t assume that `from_tensor` is a mask (although it could be). We\n  # don\'t actually care if we attend *from* padding tokens (only *to* padding)\n  # tokens so we create a tensor of all ones.\n  #\n  # `broadcast_ones` = [batch_size, from_seq_length, 1]\n  broadcast_ones = tf.ones(\n      shape=[batch_size, from_seq_length, 1], dtype=tf.float32)\n\n  # Here we broadcast along two dimensions to create the mask.\n  mask = broadcast_ones * to_mask\n\n  return mask\n\n\ndef attention_layer(from_tensor,\n                    to_tensor,\n                    attention_mask=None,\n                    num_attention_heads=1,\n                    size_per_head=512,\n                    query_act=None,\n                    key_act=None,\n                    value_act=None,\n                    attention_probs_dropout_prob=0.0,\n                    initializer_range=0.02,\n                    do_return_2d_tensor=False,\n                    batch_size=None,\n                    from_seq_length=None,\n                    to_seq_length=None):\n  """"""Performs multi-headed attention from `from_tensor` to `to_tensor`.\n\n  This is an implementation of multi-headed attention based on ""Attention\n  is all you Need"". If `from_tensor` and `to_tensor` are the same, then\n  this is self-attention. Each timestep in `from_tensor` attends to the\n  corresponding sequence in `to_tensor`, and returns a fixed-with vector.\n\n  This function first projects `from_tensor` into a ""query"" tensor and\n  `to_tensor` into ""key"" and ""value"" tensors. These are (effectively) a list\n  of tensors of length `num_attention_heads`, where each tensor is of shape\n  [batch_size, seq_length, size_per_head].\n\n  Then, the query and key tensors are dot-producted and scaled. These are\n  softmaxed to obtain attention probabilities. The value tensors are then\n  interpolated by these probabilities, then concatenated back to a single\n  tensor and returned.\n\n  In practice, the multi-headed attention are done with transposes and\n  reshapes rather than actual separate tensors.\n\n  Args:\n    from_tensor: float Tensor of shape [batch_size, from_seq_length,\n      from_width].\n    to_tensor: float Tensor of shape [batch_size, to_seq_length, to_width].\n    attention_mask: (optional) int32 Tensor of shape [batch_size,\n      from_seq_length, to_seq_length]. The values should be 1 or 0. The\n      attention scores will effectively be set to -infinity for any positions in\n      the mask that are 0, and will be unchanged for positions that are 1.\n    num_attention_heads: int. Number of attention heads.\n    size_per_head: int. Size of each attention head.\n    query_act: (optional) Activation function for the query transform.\n    key_act: (optional) Activation function for the key transform.\n    value_act: (optional) Activation function for the value transform.\n    attention_probs_dropout_prob: (optional) float. Dropout probability of the\n      attention probabilities.\n    initializer_range: float. Range of the weight initializer.\n    do_return_2d_tensor: bool. If True, the output will be of shape [batch_size\n      * from_seq_length, num_attention_heads * size_per_head]. If False, the\n      output will be of shape [batch_size, from_seq_length, num_attention_heads\n      * size_per_head].\n    batch_size: (Optional) int. If the input is 2D, this might be the batch size\n      of the 3D version of the `from_tensor` and `to_tensor`.\n    from_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `from_tensor`.\n    to_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `to_tensor`.\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length,\n      num_attention_heads * size_per_head]. (If `do_return_2d_tensor` is\n      true, this will be of shape [batch_size * from_seq_length,\n      num_attention_heads * size_per_head]).\n\n  Raises:\n    ValueError: Any of the arguments or tensor shapes are invalid.\n  """"""\n\n  def transpose_for_scores(input_tensor, batch_size, num_attention_heads,\n                           seq_length, width):\n    output_tensor = tf.reshape(\n        input_tensor, [batch_size, seq_length, num_attention_heads, width])\n\n    output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])\n    return output_tensor\n\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])\n\n  if len(from_shape) != len(to_shape):\n    raise ValueError(\n        ""The rank of `from_tensor` must match the rank of `to_tensor`."")\n\n  if len(from_shape) == 3:\n    batch_size = from_shape[0]\n    from_seq_length = from_shape[1]\n    to_seq_length = to_shape[1]\n  elif len(from_shape) == 2:\n    if (batch_size is None or from_seq_length is None or to_seq_length is None):\n      raise ValueError(\n          ""When passing in rank 2 tensors to attention_layer, the values ""\n          ""for `batch_size`, `from_seq_length`, and `to_seq_length` ""\n          ""must all be specified."")\n\n  # Scalar dimensions referenced here:\n  #   B = batch size (number of sequences)\n  #   F = `from_tensor` sequence length\n  #   T = `to_tensor` sequence length\n  #   N = `num_attention_heads`\n  #   H = `size_per_head`\n\n  from_tensor_2d = reshape_to_matrix(from_tensor)\n  to_tensor_2d = reshape_to_matrix(to_tensor)\n\n  # `query_layer` = [B*F, N*H]\n  query_layer = tf.layers.dense(\n      from_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=query_act,\n      name=""query"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `key_layer` = [B*T, N*H]\n  key_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=key_act,\n      name=""key"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `value_layer` = [B*T, N*H]\n  value_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=value_act,\n      name=""value"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `query_layer` = [B, N, F, H]\n  query_layer = transpose_for_scores(query_layer, batch_size,\n                                     num_attention_heads, from_seq_length,\n                                     size_per_head)\n\n  # `key_layer` = [B, N, T, H]\n  key_layer = transpose_for_scores(key_layer, batch_size, num_attention_heads,\n                                   to_seq_length, size_per_head)\n\n  # Take the dot product between ""query"" and ""key"" to get the raw\n  # attention scores.\n  # `attention_scores` = [B, N, F, T]\n  attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)\n  attention_scores = tf.multiply(attention_scores,\n                                 1.0 / math.sqrt(float(size_per_head)))\n\n  if attention_mask is not None:\n    # `attention_mask` = [B, 1, F, T]\n    attention_mask = tf.expand_dims(attention_mask, axis=[1])\n\n    # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n    # masked positions, this operation will create a tensor which is 0.0 for\n    # positions we want to attend and -10000.0 for masked positions.\n    adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0\n\n    # Since we are adding it to the raw scores before the softmax, this is\n    # effectively the same as removing these entirely.\n    attention_scores += adder\n\n  # Normalize the attention scores to probabilities.\n  # `attention_probs` = [B, N, F, T]\n  attention_probs = tf.nn.softmax(attention_scores)\n\n  # This is actually dropping out entire tokens to attend to, which might\n  # seem a bit unusual, but is taken from the original Transformer paper.\n  attention_probs = dropout(attention_probs, attention_probs_dropout_prob)\n\n  # `value_layer` = [B, T, N, H]\n  value_layer = tf.reshape(\n      value_layer,\n      [batch_size, to_seq_length, num_attention_heads, size_per_head])\n\n  # `value_layer` = [B, N, T, H]\n  value_layer = tf.transpose(value_layer, [0, 2, 1, 3])\n\n  # `context_layer` = [B, N, F, H]\n  context_layer = tf.matmul(attention_probs, value_layer)\n\n  # `context_layer` = [B, F, N, H]\n  context_layer = tf.transpose(context_layer, [0, 2, 1, 3])\n\n  if do_return_2d_tensor:\n    # `context_layer` = [B*F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size * from_seq_length, num_attention_heads * size_per_head])\n  else:\n    # `context_layer` = [B, F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size, from_seq_length, num_attention_heads * size_per_head])\n\n  return context_layer\n\n\ndef transformer_model(input_tensor,\n                      attention_mask=None,\n                      hidden_size=768,\n                      num_hidden_layers=12,\n                      num_attention_heads=12,\n                      intermediate_size=3072,\n                      intermediate_act_fn=gelu,\n                      hidden_dropout_prob=0.1,\n                      attention_probs_dropout_prob=0.1,\n                      initializer_range=0.02,\n                      do_return_all_layers=False):\n  """"""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n  This is almost an exact implementation of the original Transformer encoder.\n\n  See the original paper:\n  https://arxiv.org/abs/1706.03762\n\n  Also see:\n  https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n    attention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n      seq_length], with 1 for positions that can be attended to and 0 in\n      positions that should not be.\n    hidden_size: int. Hidden size of the Transformer.\n    num_hidden_layers: int. Number of layers (blocks) in the Transformer.\n    num_attention_heads: int. Number of attention heads in the Transformer.\n    intermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n      forward) layer.\n    intermediate_act_fn: function. The non-linear activation function to apply\n      to the output of the intermediate/feed-forward layer.\n    hidden_dropout_prob: float. Dropout probability for the hidden layers.\n    attention_probs_dropout_prob: float. Dropout probability of the attention\n      probabilities.\n    initializer_range: float. Range of the initializer (stddev of truncated\n      normal).\n    do_return_all_layers: Whether to also return all layers or just the final\n      layer.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, hidden_size], the final\n    hidden layer of the Transformer.\n\n  Raises:\n    ValueError: A Tensor shape or parameter is invalid.\n  """"""\n  if hidden_size % num_attention_heads != 0:\n    raise ValueError(\n        ""The hidden size (%d) is not a multiple of the number of attention ""\n        ""heads (%d)"" % (hidden_size, num_attention_heads))\n\n  attention_head_size = int(hidden_size / num_attention_heads)\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  input_width = input_shape[2]\n\n  # The Transformer performs sum residuals on all layers so the input needs\n  # to be the same as the hidden size.\n  if input_width != hidden_size:\n    raise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n                     (input_width, hidden_size))\n\n  # We keep the representation as a 2D tensor to avoid re-shaping it back and\n  # forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n  # the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n  # help the optimizer.\n  prev_output = reshape_to_matrix(input_tensor)\n\n  all_layer_outputs = []\n  for layer_idx in range(num_hidden_layers):\n    with tf.variable_scope(""layer_%d"" % layer_idx):\n      layer_input = prev_output\n\n      with tf.variable_scope(""attention""):\n        attention_heads = []\n        with tf.variable_scope(""self""):\n          attention_head = attention_layer(\n              from_tensor=layer_input,\n              to_tensor=layer_input,\n              attention_mask=attention_mask,\n              num_attention_heads=num_attention_heads,\n              size_per_head=attention_head_size,\n              attention_probs_dropout_prob=attention_probs_dropout_prob,\n              initializer_range=initializer_range,\n              do_return_2d_tensor=True,\n              batch_size=batch_size,\n              from_seq_length=seq_length,\n              to_seq_length=seq_length)\n          attention_heads.append(attention_head)\n\n        attention_output = None\n        if len(attention_heads) == 1:\n          attention_output = attention_heads[0]\n        else:\n          # In the case where we have other sequences, we just concatenate\n          # them to the self-attention head before the projection.\n          attention_output = tf.concat(attention_heads, axis=-1)\n\n        # Run a linear projection of `hidden_size` then add a residual\n        # with `layer_input`.\n        with tf.variable_scope(""output""):\n          attention_output = tf.layers.dense(\n              attention_output,\n              hidden_size,\n              kernel_initializer=create_initializer(initializer_range))\n          attention_output = dropout(attention_output, hidden_dropout_prob)\n          attention_output = layer_norm(attention_output + layer_input)\n\n      # The activation is only applied to the ""intermediate"" hidden layer.\n      with tf.variable_scope(""intermediate""):\n        intermediate_output = tf.layers.dense(\n            attention_output,\n            intermediate_size,\n            activation=intermediate_act_fn,\n            kernel_initializer=create_initializer(initializer_range))\n\n      # Down-project back to `hidden_size` then add the residual.\n      with tf.variable_scope(""output""):\n        layer_output = tf.layers.dense(\n            intermediate_output,\n            hidden_size,\n            kernel_initializer=create_initializer(initializer_range))\n        layer_output = dropout(layer_output, hidden_dropout_prob)\n        layer_output = layer_norm(layer_output + attention_output)\n        prev_output = layer_output\n        all_layer_outputs.append(layer_output)\n\n  if do_return_all_layers:\n    final_outputs = []\n    for layer_output in all_layer_outputs:\n      final_output = reshape_from_matrix(layer_output, input_shape)\n      final_outputs.append(final_output)\n    return final_outputs\n  else:\n    final_output = reshape_from_matrix(prev_output, input_shape)\n    return final_output\n\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n  """"""Returns a list of the shape of tensor, preferring static dimensions.\n\n  Args:\n    tensor: A tf.Tensor object to find the shape of.\n    expected_rank: (optional) int. The expected rank of `tensor`. If this is\n      specified and the `tensor` has a different rank, and exception will be\n      thrown.\n    name: Optional name of the tensor for the error message.\n\n  Returns:\n    A list of dimensions of the shape of tensor. All static dimensions will\n    be returned as python integers, and dynamic dimensions will be returned\n    as tf.Tensor scalars.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  if expected_rank is not None:\n    assert_rank(tensor, expected_rank, name)\n\n  shape = tensor.shape.as_list()\n\n  non_static_indexes = []\n  for (index, dim) in enumerate(shape):\n    if dim is None:\n      non_static_indexes.append(index)\n\n  if not non_static_indexes:\n    return shape\n\n  dyn_shape = tf.shape(tensor)\n  for index in non_static_indexes:\n    shape[index] = dyn_shape[index]\n  return shape\n\n\ndef reshape_to_matrix(input_tensor):\n  """"""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n  ndims = input_tensor.shape.ndims\n  if ndims < 2:\n    raise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n                     (input_tensor.shape))\n  if ndims == 2:\n    return input_tensor\n\n  width = input_tensor.shape[-1]\n  output_tensor = tf.reshape(input_tensor, [-1, width])\n  return output_tensor\n\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n  """"""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n  if len(orig_shape_list) == 2:\n    return output_tensor\n\n  output_shape = get_shape_list(output_tensor)\n\n  orig_dims = orig_shape_list[0:-1]\n  width = output_shape[-1]\n\n  return tf.reshape(output_tensor, orig_dims + [width])\n\n\ndef assert_rank(tensor, expected_rank, name=None):\n  """"""Raises an exception if the tensor rank is not of the expected rank.\n\n  Args:\n    tensor: A tf.Tensor to check the rank of.\n    expected_rank: Python integer or list of integers, expected rank.\n    name: Optional name of the tensor for the error message.\n\n  Raises:\n    ValueError: If the expected shape doesn\'t match the actual shape.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  expected_rank_dict = {}\n  if isinstance(expected_rank, six.integer_types):\n    expected_rank_dict[expected_rank] = True\n  else:\n    for x in expected_rank:\n      expected_rank_dict[x] = True\n\n  actual_rank = tensor.shape.ndims\n  if actual_rank not in expected_rank_dict:\n    scope_name = tf.get_variable_scope().name\n    raise ValueError(\n        ""For the tensor `%s` in scope `%s`, the actual rank ""\n        ""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n        (name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n'"
baselines/models/bert_wwm_ext/modeling_test.py,5,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport random\nimport re\n\nimport modeling\nimport six\nimport tensorflow as tf\n\n\nclass BertModelTest(tf.test.TestCase):\n\n  class BertModelTester(object):\n\n    def __init__(self,\n                 parent,\n                 batch_size=13,\n                 seq_length=7,\n                 is_training=True,\n                 use_input_mask=True,\n                 use_token_type_ids=True,\n                 vocab_size=99,\n                 hidden_size=32,\n                 num_hidden_layers=5,\n                 num_attention_heads=4,\n                 intermediate_size=37,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=16,\n                 initializer_range=0.02,\n                 scope=None):\n      self.parent = parent\n      self.batch_size = batch_size\n      self.seq_length = seq_length\n      self.is_training = is_training\n      self.use_input_mask = use_input_mask\n      self.use_token_type_ids = use_token_type_ids\n      self.vocab_size = vocab_size\n      self.hidden_size = hidden_size\n      self.num_hidden_layers = num_hidden_layers\n      self.num_attention_heads = num_attention_heads\n      self.intermediate_size = intermediate_size\n      self.hidden_act = hidden_act\n      self.hidden_dropout_prob = hidden_dropout_prob\n      self.attention_probs_dropout_prob = attention_probs_dropout_prob\n      self.max_position_embeddings = max_position_embeddings\n      self.type_vocab_size = type_vocab_size\n      self.initializer_range = initializer_range\n      self.scope = scope\n\n    def create_model(self):\n      input_ids = BertModelTest.ids_tensor([self.batch_size, self.seq_length],\n                                           self.vocab_size)\n\n      input_mask = None\n      if self.use_input_mask:\n        input_mask = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], vocab_size=2)\n\n      token_type_ids = None\n      if self.use_token_type_ids:\n        token_type_ids = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], self.type_vocab_size)\n\n      config = modeling.BertConfig(\n          vocab_size=self.vocab_size,\n          hidden_size=self.hidden_size,\n          num_hidden_layers=self.num_hidden_layers,\n          num_attention_heads=self.num_attention_heads,\n          intermediate_size=self.intermediate_size,\n          hidden_act=self.hidden_act,\n          hidden_dropout_prob=self.hidden_dropout_prob,\n          attention_probs_dropout_prob=self.attention_probs_dropout_prob,\n          max_position_embeddings=self.max_position_embeddings,\n          type_vocab_size=self.type_vocab_size,\n          initializer_range=self.initializer_range)\n\n      model = modeling.BertModel(\n          config=config,\n          is_training=self.is_training,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          token_type_ids=token_type_ids,\n          scope=self.scope)\n\n      outputs = {\n          ""embedding_output"": model.get_embedding_output(),\n          ""sequence_output"": model.get_sequence_output(),\n          ""pooled_output"": model.get_pooled_output(),\n          ""all_encoder_layers"": model.get_all_encoder_layers(),\n      }\n      return outputs\n\n    def check_output(self, result):\n      self.parent.assertAllEqual(\n          result[""embedding_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(\n          result[""sequence_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(result[""pooled_output""].shape,\n                                 [self.batch_size, self.hidden_size])\n\n  def test_default(self):\n    self.run_tester(BertModelTest.BertModelTester(self))\n\n  def test_config_to_json_string(self):\n    config = modeling.BertConfig(vocab_size=99, hidden_size=37)\n    obj = json.loads(config.to_json_string())\n    self.assertEqual(obj[""vocab_size""], 99)\n    self.assertEqual(obj[""hidden_size""], 37)\n\n  def run_tester(self, tester):\n    with self.test_session() as sess:\n      ops = tester.create_model()\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      output_result = sess.run(ops)\n      tester.check_output(output_result)\n\n      self.assert_all_tensors_reachable(sess, [init_op, ops])\n\n  @classmethod\n  def ids_tensor(cls, shape, vocab_size, rng=None, name=None):\n    """"""Creates a random int32 tensor of the shape within the vocab size.""""""\n    if rng is None:\n      rng = random.Random()\n\n    total_dims = 1\n    for dim in shape:\n      total_dims *= dim\n\n    values = []\n    for _ in range(total_dims):\n      values.append(rng.randint(0, vocab_size - 1))\n\n    return tf.constant(value=values, dtype=tf.int32, shape=shape, name=name)\n\n  def assert_all_tensors_reachable(self, sess, outputs):\n    """"""Checks that all the tensors in the graph are reachable from outputs.""""""\n    graph = sess.graph\n\n    ignore_strings = [\n        ""^.*/assert_less_equal/.*$"",\n        ""^.*/dilation_rate$"",\n        ""^.*/Tensordot/concat$"",\n        ""^.*/Tensordot/concat/axis$"",\n        ""^testing/.*$"",\n    ]\n\n    ignore_regexes = [re.compile(x) for x in ignore_strings]\n\n    unreachable = self.get_unreachable_ops(graph, outputs)\n    filtered_unreachable = []\n    for x in unreachable:\n      do_ignore = False\n      for r in ignore_regexes:\n        m = r.match(x.name)\n        if m is not None:\n          do_ignore = True\n      if do_ignore:\n        continue\n      filtered_unreachable.append(x)\n    unreachable = filtered_unreachable\n\n    self.assertEqual(\n        len(unreachable), 0, ""The following ops are unreachable: %s"" %\n        ("" "".join([x.name for x in unreachable])))\n\n  @classmethod\n  def get_unreachable_ops(cls, graph, outputs):\n    """"""Finds all of the tensors in graph that are unreachable from outputs.""""""\n    outputs = cls.flatten_recursive(outputs)\n    output_to_op = collections.defaultdict(list)\n    op_to_all = collections.defaultdict(list)\n    assign_out_to_in = collections.defaultdict(list)\n\n    for op in graph.get_operations():\n      for x in op.inputs:\n        op_to_all[op.name].append(x.name)\n      for y in op.outputs:\n        output_to_op[y.name].append(op.name)\n        op_to_all[op.name].append(y.name)\n      if str(op.type) == ""Assign"":\n        for y in op.outputs:\n          for x in op.inputs:\n            assign_out_to_in[y.name].append(x.name)\n\n    assign_groups = collections.defaultdict(list)\n    for out_name in assign_out_to_in.keys():\n      name_group = assign_out_to_in[out_name]\n      for n1 in name_group:\n        assign_groups[n1].append(out_name)\n        for n2 in name_group:\n          if n1 != n2:\n            assign_groups[n1].append(n2)\n\n    seen_tensors = {}\n    stack = [x.name for x in outputs]\n    while stack:\n      name = stack.pop()\n      if name in seen_tensors:\n        continue\n      seen_tensors[name] = True\n\n      if name in output_to_op:\n        for op_name in output_to_op[name]:\n          if op_name in op_to_all:\n            for input_name in op_to_all[op_name]:\n              if input_name not in stack:\n                stack.append(input_name)\n\n      expanded_names = []\n      if name in assign_groups:\n        for assign_name in assign_groups[name]:\n          expanded_names.append(assign_name)\n\n      for expanded_name in expanded_names:\n        if expanded_name not in stack:\n          stack.append(expanded_name)\n\n    unreachable_ops = []\n    for op in graph.get_operations():\n      is_unreachable = False\n      all_names = [x.name for x in op.inputs] + [x.name for x in op.outputs]\n      for name in all_names:\n        if name not in seen_tensors:\n          is_unreachable = True\n      if is_unreachable:\n        unreachable_ops.append(op)\n    return unreachable_ops\n\n  @classmethod\n  def flatten_recursive(cls, item):\n    """"""Flattens (potentially nested) a tuple/dictionary/list to a list.""""""\n    output = []\n    if isinstance(item, list):\n      output.extend(item)\n    elif isinstance(item, tuple):\n      output.extend(list(item))\n    elif isinstance(item, dict):\n      for (_, v) in six.iteritems(item):\n        output.append(v)\n    else:\n      return [item]\n\n    flat_output = []\n    for x in output:\n      flat_output.extend(cls.flatten_recursive(x))\n    return flat_output\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/bert_wwm_ext/optimization.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/bert_wwm_ext/optimization_test.py,11,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport optimization\nimport tensorflow as tf\n\n\nclass OptimizationTest(tf.test.TestCase):\n\n  def test_adam(self):\n    with self.test_session() as sess:\n      w = tf.get_variable(\n          ""w"",\n          shape=[3],\n          initializer=tf.constant_initializer([0.1, -0.2, -0.1]))\n      x = tf.constant([0.4, 0.2, -0.5])\n      loss = tf.reduce_mean(tf.square(x - w))\n      tvars = tf.trainable_variables()\n      grads = tf.gradients(loss, tvars)\n      global_step = tf.train.get_or_create_global_step()\n      optimizer = optimization.AdamWeightDecayOptimizer(learning_rate=0.2)\n      train_op = optimizer.apply_gradients(zip(grads, tvars), global_step)\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      for _ in range(100):\n        sess.run(train_op)\n      w_np = sess.run(w)\n      self.assertAllClose(w_np.flat, [0.4, 0.2, -0.5], rtol=1e-2, atol=1e-2)\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/bert_wwm_ext/run_classifier.py,112,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:30:10\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nimport sys\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n# Required parameters\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input data dir. Should contain the .tsv files (or other data files) ""\n    ""for the task."")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""task_name"", None, ""The name of the task to train."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n# Other parameters\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(\n    ""do_predict"", False,\n    ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n  return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    features[""label_ids""] = create_int_feature([feature.label_id])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 labels, num_labels, use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use model.get_sequence_output()\n  # instead.\n  output_layer = model.get_pooled_output()\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n    is_real_example = None\n    if ""is_real_example"" in features:\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n    else:\n      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,\n        num_labels, use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n       ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(\n            labels=label_ids, predictions=predictions, weights=is_real_example)\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn,\n                      [per_example_loss, label_ids, logits, is_real_example])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={""probabilities"": probabilities},\n          scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef input_fn_builder(features, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_input_ids = []\n  all_input_mask = []\n  all_segment_ids = []\n  all_label_ids = []\n\n  for feature in features:\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_segment_ids.append(feature.segment_ids)\n    all_label_ids.append(feature.label_id)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""segment_ids"":\n            tf.constant(\n                all_segment_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""label_ids"":\n            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),\n    })\n\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)\n    return d\n\n  return input_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer):\n  """"""Convert a set of `InputExample`s to a list of `InputFeatures`.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    features.append(feature)\n  return features\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval` or `do_predict\' must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      num_labels=len(label_list),\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    else:\n      file_based_convert_examples_to_features(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    # dev dataset\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    num_actual_eval_examples = len(eval_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on. These do NOT count towards the metric (all tf.metrics\n      # support a per-instance weight, and these get a weight of 0.0).\n      while len(eval_examples) % FLAGS.eval_batch_size != 0:\n        eval_examples.append(PaddingInputExample())\n\n    eval_file = os.path.join(FLAGS.output_dir, ""dev.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(eval_examples), num_actual_eval_examples,\n                    len(eval_examples) - num_actual_eval_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      assert len(eval_examples) % FLAGS.eval_batch_size == 0\n      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    #######################################################################################################################\n    # evaluate all checkpoints; you can use the checkpoint with the best dev accuarcy\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_bert_wwm_ext.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        result = estimator.evaluate(input_fn=eval_input_fn,\n                                    steps=eval_steps, checkpoint_path=filename)\n\n        tf.logging.info(""***** Eval results %s *****"" % (filename))\n        writer.write(""***** Eval results %s *****\\n"" % (filename))\n        for key in sorted(result.keys()):\n          tf.logging.info(""  %s = %s"", key, str(result[key]))\n          writer.write(""%s = %s\\n"" % (key, str(result[key])))\n    #######################################################################################################################\n\n    # result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n    #\n    # output_eval_file = os.path.join(FLAGS.output_dir, ""dev_results_bert_wwm_ext.txt"")\n    # with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n    #  tf.logging.info(""***** Eval results *****"")\n    #  for key in sorted(result.keys()):\n    #    tf.logging.info(""  %s = %s"", key, str(result[key]))\n    #    writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    num_actual_predict_examples = len(predict_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on.\n      while len(predict_examples) % FLAGS.predict_batch_size != 0:\n        predict_examples.append(PaddingInputExample())\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(predict_examples, label_list,\n                                                        FLAGS.max_seq_length, tokenizer,\n                                                        predict_file)\n    else:\n      file_based_convert_examples_to_features(predict_examples, label_list,\n                                              FLAGS.max_seq_length, tokenizer,\n                                              predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(predict_examples), num_actual_predict_examples,\n                    len(predict_examples) - num_actual_predict_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_drop_remainder = True if FLAGS.use_tpu else False\n    predict_input_fn = file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=predict_drop_remainder)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert_wwm_ext/run_classifier_with_tfhub.py,51,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner with TF-Hub.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport optimization\nimport run_classifier\nimport tokenization\nimport tensorflow as tf\nimport tensorflow_hub as hub\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""bert_hub_module_handle"", None,\n    ""Handle for the BERT TF-Hub module."")\n\n\ndef create_model(is_training, input_ids, input_mask, segment_ids, labels,\n                 num_labels, bert_hub_module_handle):\n  """"""Creates a classification model.""""""\n  tags = set()\n  if is_training:\n    tags.add(""train"")\n  bert_module = hub.Module(bert_hub_module_handle, tags=tags, trainable=True)\n  bert_inputs = dict(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids)\n  bert_outputs = bert_module(\n      inputs=bert_inputs,\n      signature=""tokens"",\n      as_dict=True)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use\n  # bert_outputs[""sequence_output""] instead.\n  output_layer = bert_outputs[""pooled_output""]\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(num_labels, learning_rate, num_train_steps,\n                     num_warmup_steps, use_tpu, bert_hub_module_handle):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        is_training, input_ids, input_mask, segment_ids, label_ids, num_labels,\n        bert_hub_module_handle)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(label_ids, predictions)\n        loss = tf.metrics.mean(per_example_loss)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions={""probabilities"": probabilities})\n    else:\n      raise ValueError(\n          ""Only TRAIN, EVAL and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef create_tokenizer_from_hub_module(bert_hub_module_handle):\n  """"""Get the vocab file and casing info from the Hub module.""""""\n  with tf.Graph().as_default():\n    bert_module = hub.Module(bert_hub_module_handle)\n    tokenization_info = bert_module(signature=""tokenization_info"", as_dict=True)\n    with tf.Session() as sess:\n      vocab_file, do_lower_case = sess.run([tokenization_info[""vocab_file""],\n                                            tokenization_info[""do_lower_case""]])\n  return tokenization.FullTokenizer(\n      vocab_file=vocab_file, do_lower_case=do_lower_case)\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""cola"": run_classifier.ColaProcessor,\n      ""mnli"": run_classifier.MnliProcessor,\n      ""mrpc"": run_classifier.MrpcProcessor,\n  }\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = create_tokenizer_from_hub_module(FLAGS.bert_hub_module_handle)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      num_labels=len(label_list),\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      bert_hub_module_handle=FLAGS.bert_hub_module_handle)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_features = run_classifier.convert_examples_to_features(\n        train_examples, label_list, FLAGS.max_seq_length, tokenizer)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = run_classifier.input_fn_builder(\n        features=train_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    eval_features = run_classifier.convert_examples_to_features(\n        eval_examples, label_list, FLAGS.max_seq_length, tokenizer)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d"", len(eval_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      # Eval will be slightly WRONG on the TPU because it will truncate\n      # the last batch.\n      eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = run_classifier.input_fn_builder(\n        features=eval_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    if FLAGS.use_tpu:\n      # Discard batch remainder if running on TPU\n      n = len(predict_examples)\n      predict_examples = predict_examples[:(n - n % FLAGS.predict_batch_size)]\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    run_classifier.file_based_convert_examples_to_features(\n        predict_examples, label_list, FLAGS.max_seq_length, tokenizer,\n        predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d"", len(predict_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_input_fn = run_classifier.file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=FLAGS.use_tpu)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n      tf.logging.info(""***** Predict results *****"")\n      for prediction in result:\n        probabilities = prediction[""probabilities""]\n        output_line = ""\\t"".join(\n            str(class_probability)\n            for class_probability in probabilities) + ""\\n""\n        writer.write(output_line)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""bert_hub_module_handle"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert_wwm_ext/run_ner.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nfrom sklearn.metrics import f1_score, precision_score, recall_score\nfrom tensorflow.python.ops import math_ops\nimport tf_metrics\nimport pickle\nimport codecs\nimport sys\n\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input datadir."",\n)\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model.""\n)\n\nflags.DEFINE_string(\n    ""task_name"", None, ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""token_name"", ""full"", ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written.""\n)\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model).""\n)\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text.""\n)\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization.""\n)\n\nflags.DEFINE_bool(\n    ""do_train"", False,\n    ""Whether to run training.""\n)\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0, ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputExample(object):\n    """"""A single training/test example for simple sequence classification.""""""\n\n    def __init__(self, guid, text, label=None):\n        """"""Constructs a InputExample.\n\n        Args:\n          guid: Unique id for the example.\n          text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n          label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid = guid\n        self.text = text\n        self.label = label\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self, input_ids, input_mask, segment_ids, label_ids, label_mask):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_ids = label_ids\n        self.label_mask = label_mask\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_data(cls, input_file):\n        """"""Reads a BIO data.""""""\n        with open(input_file) as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                word = line.strip().split(\' \')[0]\n                label = line.strip().split(\' \')[-1]\n                if contends.startswith(""-DOCSTART-""):\n                    words.append(\'\')\n                    continue\n                if len(contends) == 0 and words[-1] == \'.\':\n                    l = \' \'.join([label for label in labels if len(label) > 0])\n                    w = \' \'.join([word for word in words if len(word) > 0])\n                    lines.append([l, w])\n                    words = []\n                    labels = []\n                    continue\n                if len(contends) == 0:\n                    continue\n                words.append(word)\n                labels.append(label)\n            return lines\n\n\nclass NerProcessor(DataProcessor):\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""train.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""dev.txt"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""test.txt"")), ""test"")\n\n    def get_labels(self):\n        # return [""I-MISC"", ""I-PER"",  ""I-ORG"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        return [""B-MISC"", ""I-MISC"", ""B-PER"", ""I-PER"", ""B-ORG"", ""I-ORG"", ""B-LOC"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\nclass WeiboNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.train"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.dev"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.test"")), ""test"")\n\n\n    def get_labels(self):\n        return [\'I-PER.NOM\', \'I-PER.NAM\', \'I-GPE.NAM\', \'I-ORG.NAM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        # return [\'B-PER.NOM\', \'I-PER.NOM\', \'B-LOC.NAM\', \'B-PER.NAM\', \'I-PER.NAM\', \'B-GPE.NAM\', \'I-GPE.NAM\', \'B-ORG.NAM\', \'I-ORG.NAM\', \'B-ORG.NOM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'B-LOC.NOM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                if len(tokens) == 2:\n                    words.append(tokens[0])\n                    label = tokens[-1]\n                    if label[0] == \'B\':\n                        label = ""I"" + label[1:]\n                    labels.append(label)\n                else:\n                    if len(contends) == 0 and len(words) > 0:\n                        label = []\n                        word = []\n                        for l, w in zip(labels, words):\n                            if len(l) > 0 and len(w) > 0:\n                                label.append(l)\n                                # self.labels.add(l)\n                                word.append(w)\n                        lines.append([\' \'.join(label), \' \'.join(word)])\n                        words = []\n                        labels = []\n                        continue\n                if contends.startswith(""-DOCSTART-""):\n                    continue\n\n            return lines\n\nclass MsraNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""train1.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""test"")\n\n    def get_labels(self):\n        return [\'B-PERSON\', \'I-PERSON\', \'B-LOCATION\', \'I-LOCATION\', \'B-ORGANIZATION\', \'I-ORGANIZATION\', ""O"", ""[CLS]"", ""[SEP]"", ""X""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            chars = []\n            labels = []\n            len_count = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                for token in tokens:\n                    word, label = token.split(\'/\')\n\n                    if label == ""nr"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-PERSON\'] + [\'I-PERSON\']*(len(word)-1)\n                    elif label == ""ns"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-LOCATION\'] + [\'I-LOCATION\']*(len(word)-1)\n                    elif label == ""nt"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-ORGANIZATION\'] + [\'I-ORGANIZATION\']*(len(word)-1)\n                    else:\n                        assert label == ""o""\n                        chars = chars + list(word)\n                        labels = labels + [""O""] * len(word)\n                lines.append([\' \'.join(labels), \' \'.join(chars)])\n                len_count.append(len(chars))\n                chars = []\n                labels = []\n            return lines\n\n\ndef write_tokens(tokens, mode):\n    if mode == ""test"":\n        path = os.path.join(FLAGS.output_dir, ""token_"" + mode + "".txt"")\n        wf = open(path, \'a\')\n        for token in tokens:\n            if token != ""**NULL**"":\n                wf.write(token + \'\\n\')\n        wf.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode):\n    label_map = {}\n    for (i, label) in enumerate(label_list, 1):\n        label_map[label] = i\n\n    if not os.path.exists(os.path.join(output_dir, \'label2id.pkl\')):\n        with open(os.path.join(output_dir, \'label2id.pkl\'), \'wb\') as w:\n            pickle.dump(label_map, w)\n    textlist = example.text.split(\' \')\n    labellist = example.label.split(\' \')\n    tokens = []\n    labels = []\n    label_mask = []\n    for i, word in enumerate(textlist):\n        token = tokenizer.tokenize(word)\n        tokens.extend(token)\n        label_1 = labellist[i]\n        for m in range(len(token)):\n            if m == 0:\n                labels.append(label_1)\n            else:\n                labels.append(""X"")\n    \n    # tokens = tokenizer.tokenize(example.text)\n    if len(tokens) >= max_seq_length - 1:\n        tokens = tokens[0:(max_seq_length - 2)]\n        labels = labels[0:(max_seq_length - 2)]\n    ntokens = []\n    segment_ids = []\n    label_ids = []\n    ntokens.append(""[CLS]"")\n    segment_ids.append(0)\n    # append(""O"") or append(""[CLS]"") not sure!\n    label_ids.append(label_map[""[CLS]""])\n    label_mask.append(0) # not to predict and train\n    for i, token in enumerate(tokens):\n        ntokens.append(token)\n        segment_ids.append(0)\n        label_ids.append(label_map[labels[i]])\n        if labels[i] == \'X\':\n            label_mask.append(0)\n        else:\n            label_mask.append(1)\n    ntokens.append(""[SEP]"")\n    segment_ids.append(0)\n    label_mask.append(0)\n    # append(""O"") or append(""[SEP]"") not sure!\n    label_ids.append(label_map[""[SEP]""])\n    input_ids = tokenizer.convert_tokens_to_ids(ntokens)\n    input_mask = [1] * len(input_ids)\n    # label_mask = [1] * len(input_ids)\n    while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n        # we don\'t concerned about it!\n        label_ids.append(0)\n        ntokens.append(""**NULL**"")\n        label_mask.append(0)\n    # print(len(input_ids))\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n    assert len(label_ids) == max_seq_length\n    assert len(label_mask) == max_seq_length\n\n    if ex_index < 5:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""guid: %s"" % (example.guid))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        tf.logging.info(""label_ids: %s"" % "" "".join([str(x) for x in label_ids]))\n        tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n        # tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n\n    feature = InputFeatures(\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        label_ids=label_ids,\n        label_mask = label_mask\n    )\n    write_tokens(ntokens, mode)\n    return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file, output_dir, mode=None\n):\n    writer = tf.python_io.TFRecordWriter(output_file)\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 5000 == 0:\n            tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n        feature = convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode)\n\n        def create_int_feature(values):\n            f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n            return f\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(feature.input_ids)\n        features[""input_mask""] = create_int_feature(feature.input_mask)\n        features[""segment_ids""] = create_int_feature(feature.segment_ids)\n        features[""label_ids""] = create_int_feature(feature.label_ids)\n        features[""label_mask""] = create_int_feature(feature.label_mask)\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n        writer.write(tf_example.SerializeToString())\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n    name_to_features = {\n        ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n    }\n\n    def _decode_record(record, name_to_features):\n        example = tf.parse_single_example(record, name_to_features)\n        for name in list(example.keys()):\n            t = example[name]\n            if t.dtype == tf.int64:\n                t = tf.to_int32(t)\n            example[name] = t\n        return example\n\n    def input_fn(params):\n        batch_size = params[""batch_size""]\n        d = tf.data.TFRecordDataset(input_file)\n        if is_training:\n            d = d.repeat()\n            d = d.shuffle(buffer_size=100)\n        d = d.apply(tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder\n        ))\n        return d\n\n    return input_fn\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, label_mask,\n                 segment_ids, labels, num_labels, use_one_hot_embeddings):\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings\n    )\n\n    output_layer = model.get_sequence_output()\n\n    hidden_size = output_layer.shape[-1].value\n\n    output_weight = tf.get_variable(\n        ""output_weights"", [num_labels, hidden_size],\n        initializer=tf.truncated_normal_initializer(stddev=0.02)\n    )\n    output_bias = tf.get_variable(\n        ""output_bias"", [num_labels], initializer=tf.zeros_initializer()\n    )\n    with tf.variable_scope(""loss""):\n        if is_training:\n            output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n        output_layer = tf.reshape(output_layer, [-1, hidden_size])\n        logits = tf.matmul(output_layer, output_weight, transpose_b=True)\n        logits = tf.nn.bias_add(logits, output_bias)\n        logits = tf.reshape(logits, [-1, FLAGS.max_seq_length, num_labels])\n        # mask = tf.cast(input_mask,tf.float32)\n        # loss = tf.contrib.seq2seq.sequence_loss(logits,labels,mask)\n        # return (loss, logits, predict)\n        ##########################################################################\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n        per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n        mask = tf.cast(label_mask, tf.float32)\n        mask_example_loss = per_example_loss * mask\n        loss = tf.reduce_sum(mask_example_loss)\n        probabilities = tf.nn.softmax(logits, axis=-1)\n        predict = tf.argmax(probabilities, axis=-1)\n        return (loss, mask_example_loss, logits, predict)\n        ##########################################################################\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n    def model_fn(features, labels, mode, params):\n        tf.logging.info(""*** Features ***"")\n        for name in sorted(features.keys()):\n            tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n        input_ids = features[""input_ids""]\n        input_mask = features[""input_mask""]\n        segment_ids = features[""segment_ids""]\n        label_ids = features[""label_ids""]\n        label_mask = features[""label_mask""]\n        is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n        (total_loss, per_example_loss, logits, predicts) = create_model(\n            bert_config, is_training, input_ids, input_mask, label_mask, segment_ids, label_ids,\n            num_labels, use_one_hot_embeddings)\n        tvars = tf.trainable_variables()\n        scaffold_fn = None\n        if init_checkpoint:\n            (assignment_map, initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(tvars,\n                                                                                                       init_checkpoint)\n            tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n            if use_tpu:\n                def tpu_scaffold():\n                    tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n                    return tf.train.Scaffold()\n\n                scaffold_fn = tpu_scaffold\n            else:\n                tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        tf.logging.info(""**** Trainable Variables ****"")\n\n        for var in tvars:\n            init_string = """"\n            if var.name in initialized_variable_names:\n                init_string = "", *INIT_FROM_CKPT*""\n            tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                            init_string)\n        output_spec = None\n        if mode == tf.estimator.ModeKeys.TRAIN:\n            train_op = optimization.create_optimizer(\n                total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n            hook_dict = {}\n            hook_dict[\'loss\'] = total_loss\n            hook_dict[\'global_steps\'] = tf.train.get_or_create_global_step()\n            logging_hook = tf.train.LoggingTensorHook(\n                hook_dict, every_n_iter=200)\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                train_op=train_op,\n                scaffold_fn=scaffold_fn,\n                training_hooks=[logging_hook])\n        elif mode == tf.estimator.ModeKeys.EVAL:\n\n            def metric_fn(per_example_loss, label_ids, logits):\n                # def metric_fn(label_ids, logits):\n                predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n                # labels = []\n                # for i, x in enumerate()\n                predict_labels = []\n                # for i in range(1, num_labels - 4):\n                #     predict_labels.append(i)\n                # precision = tf_metrics.precision(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # recall = tf_metrics.recall(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # f = tf_metrics.f1(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n\n                precision = tf_metrics.precision(label_ids, predictions, num_labels, average=""macro"")\n                recall = tf_metrics.recall(label_ids, predictions, num_labels, average=""macro"")\n                f = tf_metrics.f1(label_ids, predictions, num_labels, average=""macro"")\n\n                #\n                return {\n                    ""eval_precision"": precision,\n                    ""eval_recall"": recall,\n                    ""eval_f"": f,\n                    # ""eval_loss"": loss,\n                }\n\n            eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n            # eval_metrics = (metric_fn, [label_ids, logits])\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                eval_metrics=eval_metrics,\n                scaffold_fn=scaffold_fn)\n        else:\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode, predictions=predicts, scaffold_fn=scaffold_fn\n            )\n        return output_spec\n\n    return model_fn\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    processors = {\n        ""ner"": NerProcessor,\n        ""weiboner"": WeiboNERProcessor,\n        ""msraner"": MsraNERProcessor\n    }\n    # if not FLAGS.do_train and not FLAGS.do_eval:\n    #     raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n    bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n    if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n        raise ValueError(\n            ""Cannot use sequence length %d because the BERT model ""\n            ""was only trained up to sequence length %d"" %\n            (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n    if not os.path.exists(FLAGS.output_dir):\n        os.mkdir(FLAGS.output_dir)\n    task_name = FLAGS.task_name.lower()\n    if task_name not in processors:\n        raise ValueError(""Task not found: %s"" % (task_name))\n    processor = processors[task_name]()\n\n    label_list = processor.get_labels()\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    tpu_cluster_resolver = None\n    if FLAGS.use_tpu and FLAGS.tpu_name:\n        tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n            FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n    is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n\n    run_config = tf.contrib.tpu.RunConfig(\n        cluster=tpu_cluster_resolver,\n        master=FLAGS.master,\n        model_dir=FLAGS.output_dir,\n        save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n        tpu_config=tf.contrib.tpu.TPUConfig(\n            iterations_per_loop=FLAGS.iterations_per_loop,\n            num_shards=FLAGS.num_tpu_cores,\n            per_host_input_for_training=is_per_host))\n\n    train_examples = None\n    num_train_steps = None\n    num_warmup_steps = None\n\n    if FLAGS.do_train:\n        train_examples = processor.get_train_examples(FLAGS.data_dir)\n        num_train_steps = int(\n            len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n        print(num_train_steps)\n        num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    model_fn = model_fn_builder(\n        bert_config=bert_config,\n        num_labels=len(label_list) + 1,\n        init_checkpoint=FLAGS.init_checkpoint,\n        learning_rate=FLAGS.learning_rate,\n        num_train_steps=num_train_steps,\n        num_warmup_steps=num_warmup_steps,\n        use_tpu=FLAGS.use_tpu,\n        use_one_hot_embeddings=FLAGS.use_tpu)\n\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n\n    if FLAGS.do_train:\n        train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file, FLAGS.output_dir)\n        tf.logging.info(""***** Running training *****"")\n        tf.logging.info(""  Num examples = %d"", len(train_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n        tf.logging.info(""  Num steps = %d"", num_train_steps)\n        train_input_fn = file_based_input_fn_builder(\n            input_file=train_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=True,\n            drop_remainder=True)\n        estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n    if FLAGS.do_eval:\n        eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n        eval_file = os.path.join(FLAGS.output_dir, ""eval.tf_record"")\n        file_based_convert_examples_to_features(\n            eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file, FLAGS.output_dir)\n\n        tf.logging.info(""***** Running evaluation *****"")\n        tf.logging.info(""  Num examples = %d"", len(eval_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n        eval_steps = None\n        if FLAGS.use_tpu:\n            eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n        eval_drop_remainder = True if FLAGS.use_tpu else False\n        eval_input_fn = file_based_input_fn_builder(\n            input_file=eval_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=eval_drop_remainder)\n        result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n        output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            tf.logging.info(""***** Eval results *****"")\n            for key in sorted(result.keys()):\n                tf.logging.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\n    if FLAGS.do_predict:\n\n        pred_tags = []\n        true_tags = []\n\n        token_path = os.path.join(FLAGS.output_dir, ""token_test.txt"")\n        label_file = os.path.join(FLAGS.output_dir, ""label2id.pkl"")\n        label_masks = []\n        with open(label_file, ""rb"") as rf:\n            label2id = pickle.load(rf)\n            id2label = {value: key for key, value in label2id.items()}\n        if os.path.exists(token_path):\n            os.remove(token_path)\n        predict_examples = processor.get_test_examples(FLAGS.data_dir)\n        ground_truth_file = os.path.join(FLAGS.output_dir, ""ground_truth.txt"")\n        with open(ground_truth_file, \'w\') as writer:\n            for ex_index, example in enumerate(predict_examples):\n                feature = convert_single_example(ex_index, example, label_list, FLAGS.max_seq_length, tokenizer, FLAGS.output_dir, ""test"")\n                line = []\n                for i, id in enumerate(feature.label_ids):\n                    if feature.label_mask[i] == 1:\n                        line.append(id2label[id])\n                        true_tags.append(id2label[id])\n                # output_line = "" "".join(id2label[id] for id in feature.label_ids if id != 0) + ""\\n""\n                output_line = "" "".join(line) + ""\\n""\n                writer.write(output_line)\n                label_masks.append(feature.label_mask)\n        predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n        file_based_convert_examples_to_features(predict_examples, label_list,\n                                                 FLAGS.max_seq_length, tokenizer,\n                                                 predict_file, FLAGS.output_dir, mode=""test"")\n\n        tf.logging.info(""***** Running prediction*****"")\n        tf.logging.info(""  Num examples = %d"", len(predict_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n        if FLAGS.use_tpu:\n            # Warning: According to tpu_estimator.py Prediction on TPU is an\n            # experimental feature and hence not supported here\n            raise ValueError(""Prediction in TPU not supported"")\n        predict_drop_remainder = True if FLAGS.use_tpu else False\n        predict_input_fn = file_based_input_fn_builder(\n            input_file=predict_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=predict_drop_remainder)\n\n        result = estimator.predict(input_fn=predict_input_fn)\n        output_predict_file = os.path.join(FLAGS.output_dir, ""label_test.txt"")\n\n        with open(output_predict_file, \'w\') as writer:\n            for i, prediction in enumerate(result):\n                line = []\n                for j, x in enumerate(prediction):\n                    if label_masks[i][j] == 0:\n                        continue\n                    else:\n                        line.append(id2label[x])\n                        # writer.write(id2label[x] + ""\\n"")\n                        pred_tags.append(id2label[x])\n                output_line = "" "".join(line) + ""\\n""\n                # # output_line = "" "".join(id2label[id] for id in prediction if id != 0) + ""\\n""\n                writer.write(output_line)\n        # evaluate(true_tags, pred_tags, verbose=True)\n        # evaluate(true_tags, pred_tags)\n\n        tmp = codecs.open(os.path.join(FLAGS.output_dir, ""tmp""), \'w\', \'utf8\')\n        with codecs.open(ground_truth_file, \'r\', \'utf8\') as ft, codecs.open(output_predict_file, \'r\', \'utf8\') as fg:\n            for lt, lg in zip(ft, fg):\n                for tl, tg in zip(lt.strip().split(), lg.strip().split()):\n                    print(\'\\t\'.join(["" "", tl, tg]), file=tmp)\n        tmp.close()\n        cmd = ""python %s -d \'\\t\' < %s > %s"" % \\\n                (os.path.join(os.getcwd(), ""conlleval.py""), \\\n                os.path.join(FLAGS.output_dir, ""tmp""), \\\n                os.path.join(FLAGS.data_dir, ""test_results_bert_wwm_ext.txt""))\n        os.system(cmd)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""data_dir"")\n    flags.mark_flag_as_required(""task_name"")\n    flags.mark_flag_as_required(""vocab_file"")\n    flags.mark_flag_as_required(""bert_config_file"")\n    flags.mark_flag_as_required(""output_dir"")\n    tf.app.run()\n'"
baselines/models/bert_wwm_ext/run_pretraining.py,97,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run masked LM/next sentence masked_lm pre-training for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport modeling\nimport optimization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(\n    ""input_file"", None,\n    ""Input TF example files (can be a glob or comma separated)."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded. Must match data generation."")\n\nflags.DEFINE_integer(\n    ""max_predictions_per_seq"", 20,\n    ""Maximum number of masked LM predictions per sequence. ""\n    ""Must match data generation."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_integer(""num_train_steps"", 100000, ""Number of training steps."")\n\nflags.DEFINE_integer(""num_warmup_steps"", 10000, ""Number of warmup steps."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(""max_eval_steps"", 100, ""Maximum number of eval steps."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    masked_lm_positions = features[""masked_lm_positions""]\n    masked_lm_ids = features[""masked_lm_ids""]\n    masked_lm_weights = features[""masked_lm_weights""]\n    next_sentence_labels = features[""next_sentence_labels""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    (masked_lm_loss,\n     masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(\n         bert_config, model.get_sequence_output(), model.get_embedding_table(),\n         masked_lm_positions, masked_lm_ids, masked_lm_weights)\n\n    (next_sentence_loss, next_sentence_example_loss,\n     next_sentence_log_probs) = get_next_sentence_output(\n         bert_config, model.get_pooled_output(), next_sentence_labels)\n\n    total_loss = masked_lm_loss + next_sentence_loss\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n                    masked_lm_weights, next_sentence_example_loss,\n                    next_sentence_log_probs, next_sentence_labels):\n        """"""Computes the loss and accuracy of the model.""""""\n        masked_lm_log_probs = tf.reshape(masked_lm_log_probs,\n                                         [-1, masked_lm_log_probs.shape[-1]])\n        masked_lm_predictions = tf.argmax(\n            masked_lm_log_probs, axis=-1, output_type=tf.int32)\n        masked_lm_example_loss = tf.reshape(masked_lm_example_loss, [-1])\n        masked_lm_ids = tf.reshape(masked_lm_ids, [-1])\n        masked_lm_weights = tf.reshape(masked_lm_weights, [-1])\n        masked_lm_accuracy = tf.metrics.accuracy(\n            labels=masked_lm_ids,\n            predictions=masked_lm_predictions,\n            weights=masked_lm_weights)\n        masked_lm_mean_loss = tf.metrics.mean(\n            values=masked_lm_example_loss, weights=masked_lm_weights)\n\n        next_sentence_log_probs = tf.reshape(\n            next_sentence_log_probs, [-1, next_sentence_log_probs.shape[-1]])\n        next_sentence_predictions = tf.argmax(\n            next_sentence_log_probs, axis=-1, output_type=tf.int32)\n        next_sentence_labels = tf.reshape(next_sentence_labels, [-1])\n        next_sentence_accuracy = tf.metrics.accuracy(\n            labels=next_sentence_labels, predictions=next_sentence_predictions)\n        next_sentence_mean_loss = tf.metrics.mean(\n            values=next_sentence_example_loss)\n\n        return {\n            ""masked_lm_accuracy"": masked_lm_accuracy,\n            ""masked_lm_loss"": masked_lm_mean_loss,\n            ""next_sentence_accuracy"": next_sentence_accuracy,\n            ""next_sentence_loss"": next_sentence_mean_loss,\n        }\n\n      eval_metrics = (metric_fn, [\n          masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n          masked_lm_weights, next_sentence_example_loss,\n          next_sentence_log_probs, next_sentence_labels\n      ])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(""Only TRAIN and EVAL modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef get_masked_lm_output(bert_config, input_tensor, output_weights, positions,\n                         label_ids, label_weights):\n  """"""Get loss and log probs for the masked LM.""""""\n  input_tensor = gather_indexes(input_tensor, positions)\n\n  with tf.variable_scope(""cls/predictions""):\n    # We apply one more non-linear transformation before the output layer.\n    # This matrix is not used after pre-training.\n    with tf.variable_scope(""transform""):\n      input_tensor = tf.layers.dense(\n          input_tensor,\n          units=bert_config.hidden_size,\n          activation=modeling.get_activation(bert_config.hidden_act),\n          kernel_initializer=modeling.create_initializer(\n              bert_config.initializer_range))\n      input_tensor = modeling.layer_norm(input_tensor)\n\n    # The output weights are the same as the input embeddings, but there is\n    # an output-only bias for each token.\n    output_bias = tf.get_variable(\n        ""output_bias"",\n        shape=[bert_config.vocab_size],\n        initializer=tf.zeros_initializer())\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    label_ids = tf.reshape(label_ids, [-1])\n    label_weights = tf.reshape(label_weights, [-1])\n\n    one_hot_labels = tf.one_hot(\n        label_ids, depth=bert_config.vocab_size, dtype=tf.float32)\n\n    # The `positions` tensor might be zero-padded (if the sequence is too\n    # short to have the maximum number of predictions). The `label_weights`\n    # tensor has a value of 1.0 for every real prediction and 0.0 for the\n    # padding predictions.\n    per_example_loss = -tf.reduce_sum(log_probs * one_hot_labels, axis=[-1])\n    numerator = tf.reduce_sum(label_weights * per_example_loss)\n    denominator = tf.reduce_sum(label_weights) + 1e-5\n    loss = numerator / denominator\n\n  return (loss, per_example_loss, log_probs)\n\n\ndef get_next_sentence_output(bert_config, input_tensor, labels):\n  """"""Get loss and log probs for the next sentence prediction.""""""\n\n  # Simple binary classification. Note that 0 is ""next sentence"" and 1 is\n  # ""random sentence"". This weight matrix is not used after pre-training.\n  with tf.variable_scope(""cls/seq_relationship""):\n    output_weights = tf.get_variable(\n        ""output_weights"",\n        shape=[2, bert_config.hidden_size],\n        initializer=modeling.create_initializer(bert_config.initializer_range))\n    output_bias = tf.get_variable(\n        ""output_bias"", shape=[2], initializer=tf.zeros_initializer())\n\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n    labels = tf.reshape(labels, [-1])\n    one_hot_labels = tf.one_hot(labels, depth=2, dtype=tf.float32)\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n    return (loss, per_example_loss, log_probs)\n\n\ndef gather_indexes(sequence_tensor, positions):\n  """"""Gathers the vectors at the specific positions over a minibatch.""""""\n  sequence_shape = modeling.get_shape_list(sequence_tensor, expected_rank=3)\n  batch_size = sequence_shape[0]\n  seq_length = sequence_shape[1]\n  width = sequence_shape[2]\n\n  flat_offsets = tf.reshape(\n      tf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n  flat_positions = tf.reshape(positions + flat_offsets, [-1])\n  flat_sequence_tensor = tf.reshape(sequence_tensor,\n                                    [batch_size * seq_length, width])\n  output_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n  return output_tensor\n\n\ndef input_fn_builder(input_files,\n                     max_seq_length,\n                     max_predictions_per_seq,\n                     is_training,\n                     num_cpu_threads=4):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    name_to_features = {\n        ""input_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""input_mask"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""segment_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""masked_lm_positions"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_ids"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_weights"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.float32),\n        ""next_sentence_labels"":\n            tf.FixedLenFeature([1], tf.int64),\n    }\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = tf.data.Dataset.from_tensor_slices(tf.constant(input_files))\n      d = d.repeat()\n      d = d.shuffle(buffer_size=len(input_files))\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_cpu_threads, len(input_files))\n\n      # `sloppy` mode means that the interleaving is not exact. This adds\n      # even more randomness to the training pipeline.\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n      d = d.shuffle(buffer_size=100)\n    else:\n      d = tf.data.TFRecordDataset(input_files)\n      # Since we evaluate for a fixed number of steps we don\'t want to encounter\n      # out-of-range exceptions.\n      d = d.repeat()\n\n    # We must `drop_remainder` on training because the TPU requires fixed\n    # size dimensions. For eval, we assume we are evaluating on the CPU or GPU\n    # and we *don\'t* want to drop the remainder, otherwise we wont cover\n    # every sample.\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_cpu_threads,\n            drop_remainder=True))\n    return d\n\n  return input_fn\n\n\ndef _decode_record(record, name_to_features):\n  """"""Decodes a record to a TensorFlow example.""""""\n  example = tf.parse_single_example(record, name_to_features)\n\n  # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n  # So cast all int64 to int32.\n  for name in list(example.keys()):\n    t = example[name]\n    if t.dtype == tf.int64:\n      t = tf.to_int32(t)\n    example[name] = t\n\n  return example\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Input Files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"" % input_file)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=FLAGS.num_train_steps,\n      num_warmup_steps=FLAGS.num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size)\n\n  if FLAGS.do_train:\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    train_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=True)\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.num_train_steps)\n\n  if FLAGS.do_eval:\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    eval_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=False)\n\n    result = estimator.evaluate(\n        input_fn=eval_input_fn, steps=FLAGS.max_eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert_wwm_ext/run_squad.py,93,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run BERT on SQuAD 1.1 and SQuAD 2.0.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport math\nimport os\nimport random\nimport modeling\nimport optimization\nimport tokenization\nimport six\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(""train_file"", None,\n                    ""SQuAD json for training. E.g., train-v1.1.json"")\n\nflags.DEFINE_string(\n    ""predict_file"", None,\n    ""SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json"")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 384,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_integer(\n    ""doc_stride"", 128,\n    ""When splitting up a long document into chunks, how much stride to ""\n    ""take between chunks."")\n\nflags.DEFINE_integer(\n    ""max_query_length"", 64,\n    ""The maximum number of tokens for the question. Questions longer than ""\n    ""this will be truncated to this length."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8,\n                     ""Total batch size for predictions."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(\n    ""n_best_size"", 20,\n    ""The total number of n-best predictions to generate in the ""\n    ""nbest_predictions.json output file."")\n\nflags.DEFINE_integer(\n    ""max_answer_length"", 30,\n    ""The maximum length of an answer that can be generated. This is needed ""\n    ""because the start and end predictions are not conditioned on one another."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""verbose_logging"", False,\n    ""If true, all of the warnings related to data processing will be printed. ""\n    ""A number of warnings are expected for a normal SQuAD evaluation."")\n\nflags.DEFINE_bool(\n    ""version_2_with_negative"", False,\n    ""If true, the SQuAD examples contain some that do not have an answer."")\n\nflags.DEFINE_float(\n    ""null_score_diff_threshold"", 0.0,\n    ""If null_score - best_non_null is greater than the threshold predict null."")\n\n\nclass SquadExample(object):\n  """"""A single training/test example for simple sequence classification.\n\n     For examples without an answer, the start and end position are -1.\n  """"""\n\n  def __init__(self,\n               qas_id,\n               question_text,\n               doc_tokens,\n               orig_answer_text=None,\n               start_position=None,\n               end_position=None,\n               is_impossible=False):\n    self.qas_id = qas_id\n    self.question_text = question_text\n    self.doc_tokens = doc_tokens\n    self.orig_answer_text = orig_answer_text\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n  def __str__(self):\n    return self.__repr__()\n\n  def __repr__(self):\n    s = """"\n    s += ""qas_id: %s"" % (tokenization.printable_text(self.qas_id))\n    s += "", question_text: %s"" % (\n        tokenization.printable_text(self.question_text))\n    s += "", doc_tokens: [%s]"" % ("" "".join(self.doc_tokens))\n    if self.start_position:\n      s += "", start_position: %d"" % (self.start_position)\n    if self.start_position:\n      s += "", end_position: %d"" % (self.end_position)\n    if self.start_position:\n      s += "", is_impossible: %r"" % (self.is_impossible)\n    return s\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tokens,\n               token_to_orig_map,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               segment_ids,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tokens = tokens\n    self.token_to_orig_map = token_to_orig_map\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\ndef read_squad_examples(input_file, is_training):\n  """"""Read a SQuAD json file into a list of SquadExample.""""""\n  with tf.gfile.Open(input_file, ""r"") as reader:\n    input_data = json.load(reader)[""data""]\n\n  def is_whitespace(c):\n    if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F:\n      return True\n    return False\n\n  examples = []\n  for entry in input_data:\n    for paragraph in entry[""paragraphs""]:\n      paragraph_text = paragraph[""context""]\n      doc_tokens = []\n      char_to_word_offset = []\n      prev_is_whitespace = True\n      for c in paragraph_text:\n        if is_whitespace(c):\n          prev_is_whitespace = True\n        else:\n          if prev_is_whitespace:\n            doc_tokens.append(c)\n          else:\n            doc_tokens[-1] += c\n          prev_is_whitespace = False\n        char_to_word_offset.append(len(doc_tokens) - 1)\n\n      for qa in paragraph[""qas""]:\n        qas_id = qa[""id""]\n        question_text = qa[""question""]\n        start_position = None\n        end_position = None\n        orig_answer_text = None\n        is_impossible = False\n        if is_training:\n\n          if FLAGS.version_2_with_negative:\n            is_impossible = qa[""is_impossible""]\n          if (len(qa[""answers""]) != 1) and (not is_impossible):\n            raise ValueError(\n                ""For training, each question should have exactly 1 answer."")\n          if not is_impossible:\n            answer = qa[""answers""][0]\n            orig_answer_text = answer[""text""]\n            answer_offset = answer[""answer_start""]\n            answer_length = len(orig_answer_text)\n            start_position = char_to_word_offset[answer_offset]\n            end_position = char_to_word_offset[answer_offset + answer_length -\n                                               1]\n            # Only add answers where the text can be exactly recovered from the\n            # document. If this CAN\'T happen it\'s likely due to weird Unicode\n            # stuff so we will just skip the example.\n            #\n            # Note that this means for training mode, every example is NOT\n            # guaranteed to be preserved.\n            actual_text = "" "".join(\n                doc_tokens[start_position:(end_position + 1)])\n            cleaned_answer_text = "" "".join(\n                tokenization.whitespace_tokenize(orig_answer_text))\n            if actual_text.find(cleaned_answer_text) == -1:\n              tf.logging.warning(""Could not find answer: \'%s\' vs. \'%s\'"",\n                                 actual_text, cleaned_answer_text)\n              continue\n          else:\n            start_position = -1\n            end_position = -1\n            orig_answer_text = """"\n\n        example = SquadExample(\n            qas_id=qas_id,\n            question_text=question_text,\n            doc_tokens=doc_tokens,\n            orig_answer_text=orig_answer_text,\n            start_position=start_position,\n            end_position=end_position,\n            is_impossible=is_impossible)\n        examples.append(example)\n\n  return examples\n\n\ndef convert_examples_to_features(examples, tokenizer, max_seq_length,\n                                 doc_stride, max_query_length, is_training,\n                                 output_fn):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  unique_id = 1000000000\n\n  for (example_index, example) in enumerate(examples):\n    query_tokens = tokenizer.tokenize(example.question_text)\n\n    if len(query_tokens) > max_query_length:\n      query_tokens = query_tokens[0:max_query_length]\n\n    tok_to_orig_index = []\n    orig_to_tok_index = []\n    all_doc_tokens = []\n    for (i, token) in enumerate(example.doc_tokens):\n      orig_to_tok_index.append(len(all_doc_tokens))\n      sub_tokens = tokenizer.tokenize(token)\n      for sub_token in sub_tokens:\n        tok_to_orig_index.append(i)\n        all_doc_tokens.append(sub_token)\n\n    tok_start_position = None\n    tok_end_position = None\n    if is_training and example.is_impossible:\n      tok_start_position = -1\n      tok_end_position = -1\n    if is_training and not example.is_impossible:\n      tok_start_position = orig_to_tok_index[example.start_position]\n      if example.end_position < len(example.doc_tokens) - 1:\n        tok_end_position = orig_to_tok_index[example.end_position + 1] - 1\n      else:\n        tok_end_position = len(all_doc_tokens) - 1\n      (tok_start_position, tok_end_position) = _improve_answer_span(\n          all_doc_tokens, tok_start_position, tok_end_position, tokenizer,\n          example.orig_answer_text)\n\n    # The -3 accounts for [CLS], [SEP] and [SEP]\n    max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n    # We can have documents that are longer than the maximum sequence length.\n    # To deal with this we do a sliding window approach, where we take chunks\n    # of the up to our max length with a stride of `doc_stride`.\n    _DocSpan = collections.namedtuple(  # pylint: disable=invalid-name\n        ""DocSpan"", [""start"", ""length""])\n    doc_spans = []\n    start_offset = 0\n    while start_offset < len(all_doc_tokens):\n      length = len(all_doc_tokens) - start_offset\n      if length > max_tokens_for_doc:\n        length = max_tokens_for_doc\n      doc_spans.append(_DocSpan(start=start_offset, length=length))\n      if start_offset + length == len(all_doc_tokens):\n        break\n      start_offset += min(length, doc_stride)\n\n    for (doc_span_index, doc_span) in enumerate(doc_spans):\n      tokens = []\n      token_to_orig_map = {}\n      token_is_max_context = {}\n      segment_ids = []\n      tokens.append(""[CLS]"")\n      segment_ids.append(0)\n      for token in query_tokens:\n        tokens.append(token)\n        segment_ids.append(0)\n      tokens.append(""[SEP]"")\n      segment_ids.append(0)\n\n      for i in range(doc_span.length):\n        split_token_index = doc_span.start + i\n        token_to_orig_map[len(tokens)] = tok_to_orig_index[split_token_index]\n\n        is_max_context = _check_is_max_context(doc_spans, doc_span_index,\n                                               split_token_index)\n        token_is_max_context[len(tokens)] = is_max_context\n        tokens.append(all_doc_tokens[split_token_index])\n        segment_ids.append(1)\n      tokens.append(""[SEP]"")\n      segment_ids.append(1)\n\n      input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n      # The mask has 1 for real tokens and 0 for padding tokens. Only real\n      # tokens are attended to.\n      input_mask = [1] * len(input_ids)\n\n      # Zero-pad up to the sequence length.\n      while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n\n      assert len(input_ids) == max_seq_length\n      assert len(input_mask) == max_seq_length\n      assert len(segment_ids) == max_seq_length\n\n      start_position = None\n      end_position = None\n      if is_training and not example.is_impossible:\n        # For training, if our document chunk does not contain an annotation\n        # we throw it out, since there is nothing to predict.\n        doc_start = doc_span.start\n        doc_end = doc_span.start + doc_span.length - 1\n        out_of_span = False\n        if not (tok_start_position >= doc_start and\n                tok_end_position <= doc_end):\n          out_of_span = True\n        if out_of_span:\n          start_position = 0\n          end_position = 0\n        else:\n          doc_offset = len(query_tokens) + 2\n          start_position = tok_start_position - doc_start + doc_offset\n          end_position = tok_end_position - doc_start + doc_offset\n\n      if is_training and example.is_impossible:\n        start_position = 0\n        end_position = 0\n\n      if example_index < 20:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""unique_id: %s"" % (unique_id))\n        tf.logging.info(""example_index: %s"" % (example_index))\n        tf.logging.info(""doc_span_index: %s"" % (doc_span_index))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""token_to_orig_map: %s"" % "" "".join(\n            [""%d:%d"" % (x, y) for (x, y) in six.iteritems(token_to_orig_map)]))\n        tf.logging.info(""token_is_max_context: %s"" % "" "".join([\n            ""%d:%s"" % (x, y) for (x, y) in six.iteritems(token_is_max_context)\n        ]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(\n            ""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(\n            ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        if is_training and example.is_impossible:\n          tf.logging.info(""impossible example"")\n        if is_training and not example.is_impossible:\n          answer_text = "" "".join(tokens[start_position:(end_position + 1)])\n          tf.logging.info(""start_position: %d"" % (start_position))\n          tf.logging.info(""end_position: %d"" % (end_position))\n          tf.logging.info(\n              ""answer: %s"" % (tokenization.printable_text(answer_text)))\n\n      feature = InputFeatures(\n          unique_id=unique_id,\n          example_index=example_index,\n          doc_span_index=doc_span_index,\n          tokens=tokens,\n          token_to_orig_map=token_to_orig_map,\n          token_is_max_context=token_is_max_context,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          segment_ids=segment_ids,\n          start_position=start_position,\n          end_position=end_position,\n          is_impossible=example.is_impossible)\n\n      # Run callback\n      output_fn(feature)\n\n      unique_id += 1\n\n\ndef _improve_answer_span(doc_tokens, input_start, input_end, tokenizer,\n                         orig_answer_text):\n  """"""Returns tokenized answer spans that better match the annotated answer.""""""\n\n  # The SQuAD annotations are character based. We first project them to\n  # whitespace-tokenized words. But then after WordPiece tokenization, we can\n  # often find a ""better match"". For example:\n  #\n  #   Question: What year was John Smith born?\n  #   Context: The leader was John Smith (1895-1943).\n  #   Answer: 1895\n  #\n  # The original whitespace-tokenized answer will be ""(1895-1943)."". However\n  # after tokenization, our tokens will be ""( 1895 - 1943 ) ."". So we can match\n  # the exact answer, 1895.\n  #\n  # However, this is not always possible. Consider the following:\n  #\n  #   Question: What country is the top exporter of electornics?\n  #   Context: The Japanese electronics industry is the lagest in the world.\n  #   Answer: Japan\n  #\n  # In this case, the annotator chose ""Japan"" as a character sub-span of\n  # the word ""Japanese"". Since our WordPiece tokenizer does not split\n  # ""Japanese"", we just use ""Japanese"" as the annotation. This is fairly rare\n  # in SQuAD, but does happen.\n  tok_answer_text = "" "".join(tokenizer.tokenize(orig_answer_text))\n\n  for new_start in range(input_start, input_end + 1):\n    for new_end in range(input_end, new_start - 1, -1):\n      text_span = "" "".join(doc_tokens[new_start:(new_end + 1)])\n      if text_span == tok_answer_text:\n        return (new_start, new_end)\n\n  return (input_start, input_end)\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n  """"""Check if this is the \'max context\' doc span for the token.""""""\n\n  # Because of the sliding window approach taken to scoring documents, a single\n  # token can appear in multiple documents. E.g.\n  #  Doc: the man went to the store and bought a gallon of milk\n  #  Span A: the man went to the\n  #  Span B: to the store and bought\n  #  Span C: and bought a gallon of\n  #  ...\n  #\n  # Now the word \'bought\' will have two scores from spans B and C. We only\n  # want to consider the score with ""maximum context"", which we define as\n  # the *minimum* of its left and right context (the *sum* of left and\n  # right context will always be the same, of course).\n  #\n  # In the example the maximum context for \'bought\' would be span C since\n  # it has 1 left context and 3 right context, while span B has 4 left context\n  # and 0 right context.\n  best_score = None\n  best_span_index = None\n  for (span_index, doc_span) in enumerate(doc_spans):\n    end = doc_span.start + doc_span.length - 1\n    if position < doc_span.start:\n      continue\n    if position > end:\n      continue\n    num_left_context = position - doc_span.start\n    num_right_context = end - position\n    score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n    if best_score is None or score > best_score:\n      best_score = score\n      best_span_index = span_index\n\n  return cur_span_index == best_span_index\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  final_hidden = model.get_sequence_output()\n\n  final_hidden_shape = modeling.get_shape_list(final_hidden, expected_rank=3)\n  batch_size = final_hidden_shape[0]\n  seq_length = final_hidden_shape[1]\n  hidden_size = final_hidden_shape[2]\n\n  output_weights = tf.get_variable(\n      ""cls/squad/output_weights"", [2, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""cls/squad/output_bias"", [2], initializer=tf.zeros_initializer())\n\n  final_hidden_matrix = tf.reshape(final_hidden,\n                                   [batch_size * seq_length, hidden_size])\n  logits = tf.matmul(final_hidden_matrix, output_weights, transpose_b=True)\n  logits = tf.nn.bias_add(logits, output_bias)\n\n  logits = tf.reshape(logits, [batch_size, seq_length, 2])\n  logits = tf.transpose(logits, [2, 0, 1])\n\n  unstacked_logits = tf.unstack(logits, axis=0)\n\n  (start_logits, end_logits) = (unstacked_logits[0], unstacked_logits[1])\n\n  return (start_logits, end_logits)\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (start_logits, end_logits) = create_model(\n        bert_config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      seq_length = modeling.get_shape_list(input_ids)[1]\n\n      def compute_loss(logits, positions):\n        one_hot_positions = tf.one_hot(\n            positions, depth=seq_length, dtype=tf.float32)\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        loss = -tf.reduce_mean(\n            tf.reduce_sum(one_hot_positions * log_probs, axis=-1))\n        return loss\n\n      start_positions = features[""start_positions""]\n      end_positions = features[""end_positions""]\n\n      start_loss = compute_loss(start_logits, start_positions)\n      end_loss = compute_loss(end_logits, end_positions)\n\n      total_loss = (start_loss + end_loss) / 2.0\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      predictions = {\n          ""unique_ids"": unique_ids,\n          ""start_logits"": start_logits,\n          ""end_logits"": end_logits,\n      }\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(\n          ""Only TRAIN and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""unique_ids"": tf.FixedLenFeature([], tf.int64),\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n  }\n\n  if is_training:\n    name_to_features[""start_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""end_positions""] = tf.FixedLenFeature([], tf.int64)\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\nRawResult = collections.namedtuple(""RawResult"",\n                                   [""unique_id"", ""start_logits"", ""end_logits""])\n\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file):\n  """"""Write final predictions to the json file and log-odds of null if needed.""""""\n  tf.logging.info(""Writing predictions to: %s"" % (output_prediction_file))\n  tf.logging.info(""Writing nbest to: %s"" % (output_nbest_file))\n\n  example_index_to_features = collections.defaultdict(list)\n  for feature in all_features:\n    example_index_to_features[feature.example_index].append(feature)\n\n  unique_id_to_result = {}\n  for result in all_results:\n    unique_id_to_result[result.unique_id] = result\n\n  _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n      ""PrelimPrediction"",\n      [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n  all_predictions = collections.OrderedDict()\n  all_nbest_json = collections.OrderedDict()\n  scores_diff_json = collections.OrderedDict()\n\n  for (example_index, example) in enumerate(all_examples):\n    features = example_index_to_features[example_index]\n\n    prelim_predictions = []\n    # keep track of the minimum score of null start+end of position 0\n    score_null = 1000000  # large and positive\n    min_null_feature_index = 0  # the paragraph slice with min mull score\n    null_start_logit = 0  # the start logit at the slice with min null score\n    null_end_logit = 0  # the end logit at the slice with min null score\n    for (feature_index, feature) in enumerate(features):\n      result = unique_id_to_result[feature.unique_id]\n      start_indexes = _get_best_indexes(result.start_logits, n_best_size)\n      end_indexes = _get_best_indexes(result.end_logits, n_best_size)\n      # if we could have irrelevant answers, get the min score of irrelevant\n      if FLAGS.version_2_with_negative:\n        feature_null_score = result.start_logits[0] + result.end_logits[0]\n        if feature_null_score < score_null:\n          score_null = feature_null_score\n          min_null_feature_index = feature_index\n          null_start_logit = result.start_logits[0]\n          null_end_logit = result.end_logits[0]\n      for start_index in start_indexes:\n        for end_index in end_indexes:\n          # We could hypothetically create invalid predictions, e.g., predict\n          # that the start of the span is in the question. We throw out all\n          # invalid predictions.\n          if start_index >= len(feature.tokens):\n            continue\n          if end_index >= len(feature.tokens):\n            continue\n          if start_index not in feature.token_to_orig_map:\n            continue\n          if end_index not in feature.token_to_orig_map:\n            continue\n          if not feature.token_is_max_context.get(start_index, False):\n            continue\n          if end_index < start_index:\n            continue\n          length = end_index - start_index + 1\n          if length > max_answer_length:\n            continue\n          prelim_predictions.append(\n              _PrelimPrediction(\n                  feature_index=feature_index,\n                  start_index=start_index,\n                  end_index=end_index,\n                  start_logit=result.start_logits[start_index],\n                  end_logit=result.end_logits[end_index]))\n\n    if FLAGS.version_2_with_negative:\n      prelim_predictions.append(\n          _PrelimPrediction(\n              feature_index=min_null_feature_index,\n              start_index=0,\n              end_index=0,\n              start_logit=null_start_logit,\n              end_logit=null_end_logit))\n    prelim_predictions = sorted(\n        prelim_predictions,\n        key=lambda x: (x.start_logit + x.end_logit),\n        reverse=True)\n\n    _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n    seen_predictions = {}\n    nbest = []\n    for pred in prelim_predictions:\n      if len(nbest) >= n_best_size:\n        break\n      feature = features[pred.feature_index]\n      if pred.start_index > 0:  # this is a non-null prediction\n        tok_tokens = feature.tokens[pred.start_index:(pred.end_index + 1)]\n        orig_doc_start = feature.token_to_orig_map[pred.start_index]\n        orig_doc_end = feature.token_to_orig_map[pred.end_index]\n        orig_tokens = example.doc_tokens[orig_doc_start:(orig_doc_end + 1)]\n        tok_text = "" "".join(tok_tokens)\n\n        # De-tokenize WordPieces that have been split off.\n        tok_text = tok_text.replace("" ##"", """")\n        tok_text = tok_text.replace(""##"", """")\n\n        # Clean whitespace\n        tok_text = tok_text.strip()\n        tok_text = "" "".join(tok_text.split())\n        orig_text = "" "".join(orig_tokens)\n\n        final_text = get_final_text(tok_text, orig_text, do_lower_case)\n        if final_text in seen_predictions:\n          continue\n\n        seen_predictions[final_text] = True\n      else:\n        final_text = """"\n        seen_predictions[final_text] = True\n\n      nbest.append(\n          _NbestPrediction(\n              text=final_text,\n              start_logit=pred.start_logit,\n              end_logit=pred.end_logit))\n\n    # if we didn\'t inlude the empty option in the n-best, inlcude it\n    if FLAGS.version_2_with_negative:\n      if """" not in seen_predictions:\n        nbest.append(\n            _NbestPrediction(\n                text="""", start_logit=null_start_logit,\n                end_logit=null_end_logit))\n    # In very rare edge cases we could have no valid predictions. So we\n    # just create a nonce prediction in this case to avoid failure.\n    if not nbest:\n      nbest.append(\n          _NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n    assert len(nbest) >= 1\n\n    total_scores = []\n    best_non_null_entry = None\n    for entry in nbest:\n      total_scores.append(entry.start_logit + entry.end_logit)\n      if not best_non_null_entry:\n        if entry.text:\n          best_non_null_entry = entry\n\n    probs = _compute_softmax(total_scores)\n\n    nbest_json = []\n    for (i, entry) in enumerate(nbest):\n      output = collections.OrderedDict()\n      output[""text""] = entry.text\n      output[""probability""] = probs[i]\n      output[""start_logit""] = entry.start_logit\n      output[""end_logit""] = entry.end_logit\n      nbest_json.append(output)\n\n    assert len(nbest_json) >= 1\n\n    if not FLAGS.version_2_with_negative:\n      all_predictions[example.qas_id] = nbest_json[0][""text""]\n    else:\n      # predict """" iff the null score - the score of best non-null > threshold\n      score_diff = score_null - best_non_null_entry.start_logit - (\n          best_non_null_entry.end_logit)\n      scores_diff_json[example.qas_id] = score_diff\n      if score_diff > FLAGS.null_score_diff_threshold:\n        all_predictions[example.qas_id] = """"\n      else:\n        all_predictions[example.qas_id] = best_non_null_entry.text\n\n    all_nbest_json[example.qas_id] = nbest_json\n\n  with tf.gfile.GFile(output_prediction_file, ""w"") as writer:\n    writer.write(json.dumps(all_predictions, indent=4) + ""\\n"")\n\n  with tf.gfile.GFile(output_nbest_file, ""w"") as writer:\n    writer.write(json.dumps(all_nbest_json, indent=4) + ""\\n"")\n\n  if FLAGS.version_2_with_negative:\n    with tf.gfile.GFile(output_null_log_odds_file, ""w"") as writer:\n      writer.write(json.dumps(scores_diff_json, indent=4) + ""\\n"")\n\n\ndef get_final_text(pred_text, orig_text, do_lower_case):\n  """"""Project the tokenized prediction back to the original text.""""""\n\n  # When we created the data, we kept track of the alignment between original\n  # (whitespace tokenized) tokens and our WordPiece tokenized tokens. So\n  # now `orig_text` contains the span of our original text corresponding to the\n  # span that we predicted.\n  #\n  # However, `orig_text` may contain extra characters that we don\'t want in\n  # our prediction.\n  #\n  # For example, let\'s say:\n  #   pred_text = steve smith\n  #   orig_text = Steve Smith\'s\n  #\n  # We don\'t want to return `orig_text` because it contains the extra ""\'s"".\n  #\n  # We don\'t want to return `pred_text` because it\'s already been normalized\n  # (the SQuAD eval script also does punctuation stripping/lower casing but\n  # our tokenizer does additional normalization like stripping accent\n  # characters).\n  #\n  # What we really want to return is ""Steve Smith"".\n  #\n  # Therefore, we have to apply a semi-complicated alignment heruistic between\n  # `pred_text` and `orig_text` to get a character-to-charcter alignment. This\n  # can fail in certain cases in which case we just return `orig_text`.\n\n  def _strip_spaces(text):\n    ns_chars = []\n    ns_to_s_map = collections.OrderedDict()\n    for (i, c) in enumerate(text):\n      if c == "" "":\n        continue\n      ns_to_s_map[len(ns_chars)] = i\n      ns_chars.append(c)\n    ns_text = """".join(ns_chars)\n    return (ns_text, ns_to_s_map)\n\n  # We first tokenize `orig_text`, strip whitespace from the result\n  # and `pred_text`, and check if they are the same length. If they are\n  # NOT the same length, the heuristic has failed. If they are the same\n  # length, we assume the characters are one-to-one aligned.\n  tokenizer = tokenization.BasicTokenizer(do_lower_case=do_lower_case)\n\n  tok_text = "" "".join(tokenizer.tokenize(orig_text))\n\n  start_position = tok_text.find(pred_text)\n  if start_position == -1:\n    if FLAGS.verbose_logging:\n      tf.logging.info(\n          ""Unable to find text: \'%s\' in \'%s\'"" % (pred_text, orig_text))\n    return orig_text\n  end_position = start_position + len(pred_text) - 1\n\n  (orig_ns_text, orig_ns_to_s_map) = _strip_spaces(orig_text)\n  (tok_ns_text, tok_ns_to_s_map) = _strip_spaces(tok_text)\n\n  if len(orig_ns_text) != len(tok_ns_text):\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Length not equal after stripping spaces: \'%s\' vs \'%s\'"",\n                      orig_ns_text, tok_ns_text)\n    return orig_text\n\n  # We then project the characters in `pred_text` back to `orig_text` using\n  # the character-to-character alignment.\n  tok_s_to_ns_map = {}\n  for (i, tok_index) in six.iteritems(tok_ns_to_s_map):\n    tok_s_to_ns_map[tok_index] = i\n\n  orig_start_position = None\n  if start_position in tok_s_to_ns_map:\n    ns_start_position = tok_s_to_ns_map[start_position]\n    if ns_start_position in orig_ns_to_s_map:\n      orig_start_position = orig_ns_to_s_map[ns_start_position]\n\n  if orig_start_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map start position"")\n    return orig_text\n\n  orig_end_position = None\n  if end_position in tok_s_to_ns_map:\n    ns_end_position = tok_s_to_ns_map[end_position]\n    if ns_end_position in orig_ns_to_s_map:\n      orig_end_position = orig_ns_to_s_map[ns_end_position]\n\n  if orig_end_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map end position"")\n    return orig_text\n\n  output_text = orig_text[orig_start_position:(orig_end_position + 1)]\n  return output_text\n\n\ndef _get_best_indexes(logits, n_best_size):\n  """"""Get the n-best logits from a list.""""""\n  index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\n\ndef _compute_softmax(scores):\n  """"""Compute softmax probability over raw logits.""""""\n  if not scores:\n    return []\n\n  max_score = None\n  for score in scores:\n    if max_score is None or score > max_score:\n      max_score = score\n\n  exp_scores = []\n  total_sum = 0.0\n  for score in scores:\n    x = math.exp(score - max_score)\n    exp_scores.append(x)\n    total_sum += x\n\n  probs = []\n  for score in exp_scores:\n    probs.append(score / total_sum)\n  return probs\n\n\nclass FeatureWriter(object):\n  """"""Writes InputFeature to TF example file.""""""\n\n  def __init__(self, filename, is_training):\n    self.filename = filename\n    self.is_training = is_training\n    self.num_features = 0\n    self._writer = tf.python_io.TFRecordWriter(filename)\n\n  def process_feature(self, feature):\n    """"""Write a InputFeature to the TFRecordWriter as a tf.train.Example.""""""\n    self.num_features += 1\n\n    def create_int_feature(values):\n      feature = tf.train.Feature(\n          int64_list=tf.train.Int64List(value=list(values)))\n      return feature\n\n    features = collections.OrderedDict()\n    features[""unique_ids""] = create_int_feature([feature.unique_id])\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n\n    if self.is_training:\n      features[""start_positions""] = create_int_feature([feature.start_position])\n      features[""end_positions""] = create_int_feature([feature.end_position])\n      impossible = 0\n      if feature.is_impossible:\n        impossible = 1\n      features[""is_impossible""] = create_int_feature([impossible])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    self._writer.write(tf_example.SerializeToString())\n\n  def close(self):\n    self._writer.close()\n\n\ndef validate_flags_or_throw(bert_config):\n  """"""Validate the input FLAGS or throw an exception.""""""\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_predict:\n    raise ValueError(""At least one of `do_train` or `do_predict` must be True."")\n\n  if FLAGS.do_train:\n    if not FLAGS.train_file:\n      raise ValueError(\n          ""If `do_train` is True, then `train_file` must be specified."")\n  if FLAGS.do_predict:\n    if not FLAGS.predict_file:\n      raise ValueError(\n          ""If `do_predict` is True, then `predict_file` must be specified."")\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  if FLAGS.max_seq_length <= FLAGS.max_query_length + 3:\n    raise ValueError(\n        ""The max_seq_length (%d) must be greater than max_query_length ""\n        ""(%d) + 3"" % (FLAGS.max_seq_length, FLAGS.max_query_length))\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  validate_flags_or_throw(bert_config)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = read_squad_examples(\n        input_file=FLAGS.train_file, is_training=True)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    # Pre-shuffle the input to avoid having to make a very large shuffle\n    # buffer in in the `input_fn`.\n    rng = random.Random(12345)\n    rng.shuffle(train_examples)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    # We write to a temporary file to avoid storing very large constant tensors\n    # in memory.\n    train_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""train.tf_record""),\n        is_training=True)\n    convert_examples_to_features(\n        examples=train_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=True,\n        output_fn=train_writer.process_feature)\n    train_writer.close()\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(train_examples))\n    tf.logging.info(""  Num split examples = %d"", train_writer.num_features)\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    del train_examples\n\n    train_input_fn = input_fn_builder(\n        input_file=train_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_predict:\n    eval_examples = read_squad_examples(\n        input_file=FLAGS.predict_file, is_training=False)\n\n    eval_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""eval.tf_record""),\n        is_training=False)\n    eval_features = []\n\n    def append_feature(feature):\n      eval_features.append(feature)\n      eval_writer.process_feature(feature)\n\n    convert_examples_to_features(\n        examples=eval_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=False,\n        output_fn=append_feature)\n    eval_writer.close()\n\n    tf.logging.info(""***** Running predictions *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(eval_examples))\n    tf.logging.info(""  Num split examples = %d"", len(eval_features))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    all_results = []\n\n    predict_input_fn = input_fn_builder(\n        input_file=eval_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=False)\n\n    # If running eval on the TPU, you will need to specify the number of\n    # steps.\n    all_results = []\n    for result in estimator.predict(\n        predict_input_fn, yield_single_examples=True):\n      if len(all_results) % 1000 == 0:\n        tf.logging.info(""Processing example: %d"" % (len(all_results)))\n      unique_id = int(result[""unique_ids""])\n      start_logits = [float(x) for x in result[""start_logits""].flat]\n      end_logits = [float(x) for x in result[""end_logits""].flat]\n      all_results.append(\n          RawResult(\n              unique_id=unique_id,\n              start_logits=start_logits,\n              end_logits=end_logits))\n\n    output_prediction_file = os.path.join(FLAGS.output_dir, ""predictions.json"")\n    output_nbest_file = os.path.join(FLAGS.output_dir, ""nbest_predictions.json"")\n    output_null_log_odds_file = os.path.join(FLAGS.output_dir, ""null_odds.json"")\n\n    write_predictions(eval_examples, eval_features, all_results,\n                      FLAGS.n_best_size, FLAGS.max_answer_length,\n                      FLAGS.do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/bert_wwm_ext/tf_metrics.py,22,"b'""""""\r\nMulticlass\r\nfrom: \r\nhttps://github.com/guillaumegenthial/tf_metrics/blob/master/tf_metrics/__init__.py\r\n\r\n""""""\r\n\r\n__author__ = ""Guillaume Genthial""\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops.metrics_impl import _streaming_confusion_matrix\r\n\r\n\r\ndef precision(labels, predictions, num_classes, pos_indices=None,\r\n              weights=None, average=\'micro\'):\r\n    """"""Multi-class precision metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    pr, _, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    op, _, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (pr, op)\r\n\r\n\r\ndef recall(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n           average=\'micro\'):\r\n    """"""Multi-class recall metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, re, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    _, op, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (re, op)\r\n\r\n\r\ndef f1(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n       average=\'micro\'):\r\n    return fbeta(labels, predictions, num_classes, pos_indices, weights,\r\n                 average)\r\n\r\n\r\ndef fbeta(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n          average=\'micro\', beta=1):\r\n    """"""Multi-class fbeta metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, _, fbeta = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average, beta=beta)\r\n    _, _, op = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average, beta=beta)\r\n    return (fbeta, op)\r\n\r\n\r\ndef safe_div(numerator, denominator):\r\n    """"""Safe division, return 0 if denominator is 0""""""\r\n    numerator, denominator = tf.to_float(numerator), tf.to_float(denominator)\r\n    zeros = tf.zeros_like(numerator, dtype=numerator.dtype)\r\n    denominator_is_zero = tf.equal(denominator, zeros)\r\n    return tf.where(denominator_is_zero, zeros, numerator / denominator)\r\n\r\n\r\ndef pr_re_fbeta(cm, pos_indices, beta=1):\r\n    """"""Uses a confusion matrix to compute precision, recall and fbeta""""""\r\n    num_classes = cm.shape[0]\r\n    neg_indices = [i for i in range(num_classes) if i not in pos_indices]\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, neg_indices] = 0\r\n    diag_sum = tf.reduce_sum(tf.diag_part(cm * cm_mask))\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[:, neg_indices] = 0\r\n    tot_pred = tf.reduce_sum(cm * cm_mask)\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, :] = 0\r\n    tot_gold = tf.reduce_sum(cm * cm_mask)\r\n\r\n    pr = safe_div(diag_sum, tot_pred)\r\n    re = safe_div(diag_sum, tot_gold)\r\n    fbeta = safe_div((1. + beta**2) * pr * re, beta**2 * pr + re)\r\n\r\n    return pr, re, fbeta\r\n\r\n\r\ndef metrics_from_confusion_matrix(cm, pos_indices=None, average=\'micro\',\r\n                                  beta=1):\r\n    """"""Precision, Recall and F1 from the confusion matrix\r\n    Parameters\r\n    ----------\r\n    cm : tf.Tensor of type tf.int32, of shape (num_classes, num_classes)\r\n        The streaming confusion matrix.\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    average : str, optional\r\n        \'micro\', \'macro\' or \'weighted\'\r\n    """"""\r\n    num_classes = cm.shape[0]\r\n    if pos_indices is None:\r\n        pos_indices = [i for i in range(num_classes)]\r\n\r\n    if average == \'micro\':\r\n        return pr_re_fbeta(cm, pos_indices, beta)\r\n    elif average in {\'macro\', \'weighted\'}:\r\n        precisions, recalls, fbetas, n_golds = [], [], [], []\r\n        for idx in pos_indices:\r\n            pr, re, fbeta = pr_re_fbeta(cm, [idx], beta)\r\n            precisions.append(pr)\r\n            recalls.append(re)\r\n            fbetas.append(fbeta)\r\n            cm_mask = np.zeros([num_classes, num_classes])\r\n            cm_mask[idx, :] = 1\r\n            n_golds.append(tf.to_float(tf.reduce_sum(cm * cm_mask)))\r\n\r\n        if average == \'macro\':\r\n            pr = tf.reduce_mean(precisions)\r\n            re = tf.reduce_mean(recalls)\r\n            fbeta = tf.reduce_mean(fbetas)\r\n            return pr, re, fbeta\r\n        if average == \'weighted\':\r\n            n_gold = tf.reduce_sum(n_golds)\r\n            pr_sum = sum(p * n for p, n in zip(precisions, n_golds))\r\n            pr = safe_div(pr_sum, n_gold)\r\n            re_sum = sum(r * n for r, n in zip(recalls, n_golds))\r\n            re = safe_div(re_sum, n_gold)\r\n            fbeta_sum = sum(f * n for f, n in zip(fbetas, n_golds))\r\n            fbeta = safe_div(fbeta_sum, n_gold)\r\n            return pr, re, fbeta\r\n\r\n    else:\r\n        raise NotImplementedError()'"
baselines/models/bert_wwm_ext/tokenization.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\nimport unicodedata\nimport six\nimport tensorflow as tf\n\n\ndef validate_case_matches_checkpoint(do_lower_case, init_checkpoint):\n  """"""Checks whether the casing config is consistent with the checkpoint name.""""""\n\n  # The casing has to be passed in by the user and there is no explicit check\n  # as to whether it matches the checkpoint. The casing information probably\n  # should have been stored in the bert_config.json file, but it\'s not, so\n  # we have to heuristically detect it to validate.\n\n  if not init_checkpoint:\n    return\n\n  m = re.match(""^.*?([A-Za-z0-9_-]+)/bert_model.ckpt"", init_checkpoint)\n  if m is None:\n    return\n\n  model_name = m.group(1)\n\n  lower_models = [\n      ""uncased_L-24_H-1024_A-16"", ""uncased_L-12_H-768_A-12"",\n      ""multilingual_L-12_H-768_A-12"", ""chinese_L-12_H-768_A-12""\n  ]\n\n  cased_models = [\n      ""cased_L-12_H-768_A-12"", ""cased_L-24_H-1024_A-16"",\n      ""multi_cased_L-12_H-768_A-12""\n  ]\n\n  is_bad_config = False\n  if model_name in lower_models and not do_lower_case:\n    is_bad_config = True\n    actual_flag = ""False""\n    case_name = ""lowercased""\n    opposite_flag = ""True""\n\n  if model_name in cased_models and do_lower_case:\n    is_bad_config = True\n    actual_flag = ""True""\n    case_name = ""cased""\n    opposite_flag = ""False""\n\n  if is_bad_config:\n    raise ValueError(\n        ""You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. ""\n        ""However, `%s` seems to be a %s model, so you ""\n        ""should pass in `--do_lower_case=%s` so that the fine-tuning matches ""\n        ""how the model was pre-training. If this error is wrong, please ""\n        ""just comment out this check."" % (actual_flag, init_checkpoint,\n                                          model_name, case_name, opposite_flag))\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  index = 0\n  with tf.gfile.GFile(vocab_file, ""r"") as reader:\n    while True:\n      token = convert_to_unicode(reader.readline())\n      if not token:\n        break\n      token = token.strip()\n      vocab[token] = index\n      index += 1\n  return vocab\n\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  for item in items:\n    output.append(vocab[item])\n  return output\n\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True):\n    self.vocab = load_vocab(vocab_file)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n  def tokenize(self, text):\n    split_tokens = []\n    for token in self.basic_tokenizer.tokenize(text):\n      for sub_token in self.wordpiece_tokenizer.tokenize(token):\n        split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    return convert_by_vocab(self.inv_vocab, ids)\n\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = convert_to_unicode(text)\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n  """"""Runs WordPiece tokenziation.""""""\n\n  def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=200):\n    self.vocab = vocab\n    self.unk_token = unk_token\n    self.max_input_chars_per_word = max_input_chars_per_word\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text into its word pieces.\n\n    This uses a greedy longest-match-first algorithm to perform tokenization\n    using the given vocabulary.\n\n    For example:\n      input = ""unaffable""\n      output = [""un"", ""##aff"", ""##able""]\n\n    Args:\n      text: A single token or whitespace separated tokens. This should have\n        already been passed through `BasicTokenizer.\n\n    Returns:\n      A list of wordpiece tokens.\n    """"""\n\n    text = convert_to_unicode(text)\n\n    output_tokens = []\n    for token in whitespace_tokenize(text):\n      chars = list(token)\n      if len(chars) > self.max_input_chars_per_word:\n        output_tokens.append(self.unk_token)\n        continue\n\n      is_bad = False\n      start = 0\n      sub_tokens = []\n      while start < len(chars):\n        end = len(chars)\n        cur_substr = None\n        while start < end:\n          substr = """".join(chars[start:end])\n          if start > 0:\n            substr = ""##"" + substr\n          if substr in self.vocab:\n            cur_substr = substr\n            break\n          end -= 1\n        if cur_substr is None:\n          is_bad = True\n          break\n        sub_tokens.append(cur_substr)\n        start = end\n\n      if is_bad:\n        output_tokens.append(self.unk_token)\n      else:\n        output_tokens.extend(sub_tokens)\n    return output_tokens\n\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically contorl characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
baselines/models/bert_wwm_ext/tokenization_test.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tempfile\nimport tokenization\nimport six\nimport tensorflow as tf\n\n\nclass TokenizationTest(tf.test.TestCase):\n\n  def test_full_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing"", "",""\n    ]\n    with tempfile.NamedTemporaryFile(delete=False) as vocab_writer:\n      if six.PY2:\n        vocab_writer.write("""".join([x + ""\\n"" for x in vocab_tokens]))\n      else:\n        vocab_writer.write("""".join(\n            [x + ""\\n"" for x in vocab_tokens]).encode(""utf-8""))\n\n      vocab_file = vocab_writer.name\n\n    tokenizer = tokenization.FullTokenizer(vocab_file)\n    os.unlink(vocab_file)\n\n    tokens = tokenizer.tokenize(u""UNwant\\u00E9d,running"")\n    self.assertAllEqual(tokens, [""un"", ""##want"", ""##ed"", "","", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.convert_tokens_to_ids(tokens), [7, 4, 5, 10, 8, 9])\n\n  def test_chinese(self):\n    tokenizer = tokenization.BasicTokenizer()\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u""ah\\u535A\\u63A8zz""),\n        [u""ah"", u""\\u535A"", u""\\u63A8"", u""zz""])\n\n  def test_basic_tokenizer_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=True)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""hello"", ""!"", ""how"", ""are"", ""you"", ""?""])\n    self.assertAllEqual(tokenizer.tokenize(u""H\\u00E9llo""), [""hello""])\n\n  def test_basic_tokenizer_no_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=False)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""HeLLo"", ""!"", ""how"", ""Are"", ""yoU"", ""?""])\n\n  def test_wordpiece_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n    tokenizer = tokenization.WordpieceTokenizer(vocab=vocab)\n\n    self.assertAllEqual(tokenizer.tokenize(""""), [])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwanted running""),\n        [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwantedX running""), [""[UNK]"", ""runn"", ""##ing""])\n\n  def test_convert_tokens_to_ids(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n\n    self.assertAllEqual(\n        tokenization.convert_tokens_to_ids(\n            vocab, [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""]), [7, 4, 5, 8, 9])\n\n  def test_is_whitespace(self):\n    self.assertTrue(tokenization._is_whitespace(u"" ""))\n    self.assertTrue(tokenization._is_whitespace(u""\\t""))\n    self.assertTrue(tokenization._is_whitespace(u""\\r""))\n    self.assertTrue(tokenization._is_whitespace(u""\\n""))\n    self.assertTrue(tokenization._is_whitespace(u""\\u00A0""))\n\n    self.assertFalse(tokenization._is_whitespace(u""A""))\n    self.assertFalse(tokenization._is_whitespace(u""-""))\n\n  def test_is_control(self):\n    self.assertTrue(tokenization._is_control(u""\\u0005""))\n\n    self.assertFalse(tokenization._is_control(u""A""))\n    self.assertFalse(tokenization._is_control(u"" ""))\n    self.assertFalse(tokenization._is_control(u""\\t""))\n    self.assertFalse(tokenization._is_control(u""\\r""))\n    self.assertFalse(tokenization._is_control(u""\\U0001F4A9""))\n\n  def test_is_punctuation(self):\n    self.assertTrue(tokenization._is_punctuation(u""-""))\n    self.assertTrue(tokenization._is_punctuation(u""$""))\n    self.assertTrue(tokenization._is_punctuation(u""`""))\n    self.assertTrue(tokenization._is_punctuation(u"".""))\n\n    self.assertFalse(tokenization._is_punctuation(u""A""))\n    self.assertFalse(tokenization._is_punctuation(u"" ""))\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/copa_sh/convert_test.py,0,"b'#coding:utf-8\nimport sys\nimport json\n\ntest_file=sys.argv[1]\npredict_label = []\ntmp = []\nfor line in open(test_file, \'r\').readlines():\n    ss = line.strip().split(\'\\t\')\n    if len(ss) == 2:\n        tmp.append(ss[1])\n    else:\n        print (\'wrong format!!!: \' + line.strip())\n\ni = 0\nwhile(i < len(tmp)-1):\n    if tmp[i] >= tmp[i+1]:\n        predict_label.append(str(0))\n    else:\n        predict_label.append(str(1))\n    i += 2\nprint (""predict_label size: "" + str(len(predict_label)))\n\nres = {}\nfor idx, label in enumerate(predict_label):\n    res[\'id\'] = idx\n    res[\'label\'] = label\n    print(json.dumps(res, ensure_ascii=False))\n\n\n'"
baselines/models/copa_sh/eval_copa.py,0,"b'#coding:utf-8\nimport sys\n\ntest_file=sys.argv[1]\npredict_label = []\ntmp = []\nfor line in open(test_file, \'r\').readlines():\n    ss = line.strip().split(\'\\t\')\n    if len(ss) == 2:\n        tmp.append(ss[1])\n    else:\n        print (\'wrong format!!!: \' + line.strip())\n\ni = 0\nwhile(i < len(tmp)-1):\n    if tmp[i] >= tmp[i+1]:\n        predict_label.append(str(0))\n    else:\n        predict_label.append(str(1))\n    i += 2\nprint (""predict_label size: "" + str(len(predict_label)))\n\n\ngolden_file = \'dev_label.txt\'\ngolden_label=[]\nfor line in open(golden_file, \'r\').readlines():\n    ss = line.strip().split(\'\\t\')\n    if len(ss) == 2:\n        golden_label.append(ss[1])\n    else:\n        print (\'wrong format!!!: \' + line.strip())\n\nprint (\'golden_label size: \' + str(len(golden_label)))\ncorrect_count = 0\nwrong_count = 0\nfor i in range(0, len(golden_label)):\n    if golden_label[i] == predict_label[i]:\n        correct_count += 1\n    else:\n        wrong_count += 1\nprint (""correct_count: "" + str(correct_count))\nprint (""wrong_count: "" + str(wrong_count))\nprint (""precision: "" + str( correct_count * 1.0 / len(golden_label)))\n\n\n\n'"
baselines/models/ernie/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n'"
baselines/models/ernie/conlleval.py,0,"b'# Python version of the evaluation script from CoNLL\'00-\n# Originates from: https://github.com/spyysalo/conlleval.py\n\n\n# Intentional differences:\n# - accept any space as delimiter by default\n# - optional file argument (default STDIN)\n# - option to set boundary (-b argument)\n# - LaTeX output (-l argument) not supported\n# - raw tags (-r argument) not supported\n\n# add function :evaluate(predicted_label, ori_label): which will not read from file\n\nimport sys\nimport re\nimport codecs\nfrom collections import defaultdict, namedtuple\n\nANY_SPACE = \'<SPACE>\'\n\n\nclass FormatError(Exception):\n    pass\n\nMetrics = namedtuple(\'Metrics\', \'tp fp fn prec rec fscore\')\n\n\nclass EvalCounts(object):\n    def __init__(self):\n        self.correct_chunk = 0    # number of correctly identified chunks\n        self.correct_tags = 0     # number of correct chunk tags\n        self.found_correct = 0    # number of chunks in corpus\n        self.found_guessed = 0    # number of identified chunks\n        self.token_counter = 0    # token counter (ignores sentence breaks)\n\n        # counts by type\n        self.t_correct_chunk = defaultdict(int)\n        self.t_found_correct = defaultdict(int)\n        self.t_found_guessed = defaultdict(int)\n\n\ndef parse_args(argv):\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=\'evaluate tagging results using CoNLL criteria\',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    arg = parser.add_argument\n    arg(\'-b\', \'--boundary\', metavar=\'STR\', default=\'-X-\',\n        help=\'sentence boundary\')\n    arg(\'-d\', \'--delimiter\', metavar=\'CHAR\', default=ANY_SPACE,\n        help=\'character delimiting items in input\')\n    arg(\'-o\', \'--otag\', metavar=\'CHAR\', default=\'O\',\n        help=\'alternative outside tag\')\n    arg(\'file\', nargs=\'?\', default=None)\n    return parser.parse_args(argv)\n\n\ndef parse_tag(t):\n    m = re.match(r\'^([^-]*)-(.*)$\', t)\n    return m.groups() if m else (t, \'\')\n\n\ndef evaluate(iterable, options=None):\n    if options is None:\n        options = parse_args([])    # use defaults\n\n    counts = EvalCounts()\n    num_features = None       # number of features per line\n    in_correct = False        # currently processed chunks is correct until now\n    last_correct = \'O\'        # previous chunk tag in corpus\n    last_correct_type = \'\'    # type of previously identified chunk tag\n    last_guessed = \'O\'        # previously identified chunk tag\n    last_guessed_type = \'\'    # type of previous chunk tag in corpus\n\n    for line in iterable:\n        line = line.rstrip(\'\\r\\n\')\n\n        if options.delimiter == ANY_SPACE:\n            features = line.split()\n        else:\n            features = line.split(options.delimiter)\n\n        if num_features is None:\n            num_features = len(features)\n        elif num_features != len(features) and len(features) != 0:\n            raise FormatError(\'unexpected number of features: %d (%d)\' %\n                              (len(features), num_features))\n\n        if len(features) == 0 or features[0] == options.boundary:\n            features = [options.boundary, \'O\', \'O\']\n        if len(features) < 3:\n            raise FormatError(\'unexpected number of features in line %s\' % line)\n\n        guessed, guessed_type = parse_tag(features.pop())\n        correct, correct_type = parse_tag(features.pop())\n        first_item = features.pop(0)\n\n        if first_item == options.boundary:\n            guessed = \'O\'\n\n        end_correct = end_of_chunk(last_correct, correct,\n                                   last_correct_type, correct_type)\n        end_guessed = end_of_chunk(last_guessed, guessed,\n                                   last_guessed_type, guessed_type)\n        start_correct = start_of_chunk(last_correct, correct,\n                                       last_correct_type, correct_type)\n        start_guessed = start_of_chunk(last_guessed, guessed,\n                                       last_guessed_type, guessed_type)\n\n        if in_correct:\n            if (end_correct and end_guessed and\n                last_guessed_type == last_correct_type):\n                in_correct = False\n                counts.correct_chunk += 1\n                counts.t_correct_chunk[last_correct_type] += 1\n            elif (end_correct != end_guessed or guessed_type != correct_type):\n                in_correct = False\n\n        if start_correct and start_guessed and guessed_type == correct_type:\n            in_correct = True\n\n        if start_correct:\n            counts.found_correct += 1\n            counts.t_found_correct[correct_type] += 1\n        if start_guessed:\n            counts.found_guessed += 1\n            counts.t_found_guessed[guessed_type] += 1\n        if first_item != options.boundary:\n            if correct == guessed and guessed_type == correct_type:\n                counts.correct_tags += 1\n            counts.token_counter += 1\n\n        last_guessed = guessed\n        last_correct = correct\n        last_guessed_type = guessed_type\n        last_correct_type = correct_type\n\n    if in_correct:\n        counts.correct_chunk += 1\n        counts.t_correct_chunk[last_correct_type] += 1\n\n    return counts\n\n\n\ndef uniq(iterable):\n  seen = set()\n  return [i for i in iterable if not (i in seen or seen.add(i))]\n\n\ndef calculate_metrics(correct, guessed, total):\n    tp, fp, fn = correct, guessed-correct, total-correct\n    p = 0 if tp + fp == 0 else 1.*tp / (tp + fp)\n    r = 0 if tp + fn == 0 else 1.*tp / (tp + fn)\n    f = 0 if p + r == 0 else 2 * p * r / (p + r)\n    return Metrics(tp, fp, fn, p, r, f)\n\n\ndef metrics(counts):\n    c = counts\n    overall = calculate_metrics(\n        c.correct_chunk, c.found_guessed, c.found_correct\n    )\n    by_type = {}\n    for t in uniq(list(c.t_found_correct) + list(c.t_found_guessed)):\n        by_type[t] = calculate_metrics(\n            c.t_correct_chunk[t], c.t_found_guessed[t], c.t_found_correct[t]\n        )\n    return overall, by_type\n\n\ndef report(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    out.write(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    out.write(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n\n    if c.token_counter > 0:\n        out.write(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        out.write(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        out.write(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n\n    for i, m in sorted(by_type.items()):\n        out.write(\'%17s: \' % i)\n        out.write(\'precision: %6.2f%%; \' % (100.*m.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*m.rec))\n        out.write(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n\n\ndef report_notprint(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    final_report = []\n    line = []\n    line.append(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    line.append(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n    final_report.append("""".join(line))\n\n    if c.token_counter > 0:\n        line = []\n        line.append(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        line.append(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        line.append(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n        final_report.append("""".join(line))\n\n    for i, m in sorted(by_type.items()):\n        line = []\n        line.append(\'%17s: \' % i)\n        line.append(\'precision: %6.2f%%; \' % (100.*m.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*m.rec))\n        line.append(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n        final_report.append("""".join(line))\n    return final_report\n\n\ndef end_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk ended between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_end = False\n\n    if prev_tag == \'E\': chunk_end = True\n    if prev_tag == \'S\': chunk_end = True\n\n    if prev_tag == \'B\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'O\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'O\': chunk_end = True\n\n    if prev_tag != \'O\' and prev_tag != \'.\' and prev_type != type_:\n        chunk_end = True\n\n    # these chunks are assumed to have length 1\n    if prev_tag == \']\': chunk_end = True\n    if prev_tag == \'[\': chunk_end = True\n\n    return chunk_end\n\n\ndef start_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk started between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_start = False\n\n    if tag == \'B\': chunk_start = True\n    if tag == \'S\': chunk_start = True\n\n    if prev_tag == \'E\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'E\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'I\': chunk_start = True\n\n    if tag != \'O\' and tag != \'.\' and prev_type != type_:\n        chunk_start = True\n\n    # these chunks are assumed to have length 1\n    if tag == \'[\': chunk_start = True\n    if tag == \']\': chunk_start = True\n\n    return chunk_start\n\n\ndef return_report(input_file):\n    with codecs.open(input_file, ""r"", ""utf8"") as f:\n        counts = evaluate(f)\n    return report_notprint(counts)\n\n\ndef main(argv):\n    args = parse_args(argv[1:])\n\n    if args.file is None:\n        counts = evaluate(sys.stdin, args)\n    else:\n        with open(args.file) as f:\n            counts = evaluate(f, args)\n    report(counts)\n\nif __name__ == \'__main__\':\n    sys.exit(main(sys.argv))'"
baselines/models/ernie/create_pretraining_data.py,17,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\n\nclass TrainingInstance(object):\n  """"""A single training instance (sentence pair).""""""\n\n  def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n               is_random_next):\n    self.tokens = tokens\n    self.segment_ids = segment_ids\n    self.is_random_next = is_random_next\n    self.masked_lm_positions = masked_lm_positions\n    self.masked_lm_labels = masked_lm_labels\n\n  def __str__(self):\n    s = """"\n    s += ""tokens: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.tokens]))\n    s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n    s += ""is_random_next: %s\\n"" % self.is_random_next\n    s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n        [str(x) for x in self.masked_lm_positions]))\n    s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n    s += ""\\n""\n    return s\n\n  def __repr__(self):\n    return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n  """"""Create TF example files from `TrainingInstance`s.""""""\n  writers = []\n  for output_file in output_files:\n    writers.append(tf.python_io.TFRecordWriter(output_file))\n\n  writer_index = 0\n\n  total_written = 0\n  for (inst_index, instance) in enumerate(instances):\n    input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n    input_mask = [1] * len(input_ids)\n    segment_ids = list(instance.segment_ids)\n    assert len(input_ids) <= max_seq_length\n\n    while len(input_ids) < max_seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      segment_ids.append(0)\n\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n\n    masked_lm_positions = list(instance.masked_lm_positions)\n    masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n    masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n    while len(masked_lm_positions) < max_predictions_per_seq:\n      masked_lm_positions.append(0)\n      masked_lm_ids.append(0)\n      masked_lm_weights.append(0.0)\n\n    next_sentence_label = 1 if instance.is_random_next else 0\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(input_ids)\n    features[""input_mask""] = create_int_feature(input_mask)\n    features[""segment_ids""] = create_int_feature(segment_ids)\n    features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n    features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n    features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n    features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n    writers[writer_index].write(tf_example.SerializeToString())\n    writer_index = (writer_index + 1) % len(writers)\n\n    total_written += 1\n\n    if inst_index < 20:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in instance.tokens]))\n\n      for feature_name in features.keys():\n        feature = features[feature_name]\n        values = []\n        if feature.int64_list.value:\n          values = feature.int64_list.value\n        elif feature.float_list.value:\n          values = feature.float_list.value\n        tf.logging.info(\n            ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n  for writer in writers:\n    writer.close()\n\n  tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n  feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n  return feature\n\n\ndef create_float_feature(values):\n  feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n  return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n  """"""Create `TrainingInstance`s from raw text.""""""\n  all_documents = [[]]\n\n  # Input file format:\n  # (1) One sentence per line. These should ideally be actual sentences, not\n  # entire paragraphs or arbitrary spans of text. (Because we use the\n  # sentence boundaries for the ""next sentence prediction"" task).\n  # (2) Blank lines between documents. Document boundaries are needed so\n  # that the ""next sentence prediction"" task doesn\'t span between documents.\n  for input_file in input_files:\n    with tf.gfile.GFile(input_file, ""r"") as reader:\n      while True:\n        line = tokenization.convert_to_unicode(reader.readline())\n        if not line:\n          break\n        line = line.strip()\n\n        # Empty lines are used as document delimiters\n        if not line:\n          all_documents.append([])\n        tokens = tokenizer.tokenize(line)\n        if tokens:\n          all_documents[-1].append(tokens)\n\n  # Remove empty documents\n  all_documents = [x for x in all_documents if x]\n  rng.shuffle(all_documents)\n\n  vocab_words = list(tokenizer.vocab.keys())\n  instances = []\n  for _ in range(dupe_factor):\n    for document_index in range(len(all_documents)):\n      instances.extend(\n          create_instances_from_document(\n              all_documents, document_index, max_seq_length, short_seq_prob,\n              masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n  rng.shuffle(instances)\n  return instances\n\n\ndef create_instances_from_document(\n    all_documents, document_index, max_seq_length, short_seq_prob,\n    masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n  """"""Creates `TrainingInstance`s for a single document.""""""\n  document = all_documents[document_index]\n\n  # Account for [CLS], [SEP], [SEP]\n  max_num_tokens = max_seq_length - 3\n\n  # We *usually* want to fill up the entire sequence since we are padding\n  # to `max_seq_length` anyways, so short sequences are generally wasted\n  # computation. However, we *sometimes*\n  # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n  # sequences to minimize the mismatch between pre-training and fine-tuning.\n  # The `target_seq_length` is just a rough target however, whereas\n  # `max_seq_length` is a hard limit.\n  target_seq_length = max_num_tokens\n  if rng.random() < short_seq_prob:\n    target_seq_length = rng.randint(2, max_num_tokens)\n\n  # We DON\'T just concatenate all of the tokens from a document into a long\n  # sequence and choose an arbitrary split point because this would make the\n  # next sentence prediction task too easy. Instead, we split the input into\n  # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n  # input.\n  instances = []\n  current_chunk = []\n  current_length = 0\n  i = 0\n  while i < len(document):\n    segment = document[i]\n    current_chunk.append(segment)\n    current_length += len(segment)\n    if i == len(document) - 1 or current_length >= target_seq_length:\n      if current_chunk:\n        # `a_end` is how many segments from `current_chunk` go into the `A`\n        # (first) sentence.\n        a_end = 1\n        if len(current_chunk) >= 2:\n          a_end = rng.randint(1, len(current_chunk) - 1)\n\n        tokens_a = []\n        for j in range(a_end):\n          tokens_a.extend(current_chunk[j])\n\n        tokens_b = []\n        # Random next\n        is_random_next = False\n        if len(current_chunk) == 1 or rng.random() < 0.5:\n          is_random_next = True\n          target_b_length = target_seq_length - len(tokens_a)\n\n          # This should rarely go for more than one iteration for large\n          # corpora. However, just to be careful, we try to make sure that\n          # the random document is not the same as the document\n          # we\'re processing.\n          for _ in range(10):\n            random_document_index = rng.randint(0, len(all_documents) - 1)\n            if random_document_index != document_index:\n              break\n\n          random_document = all_documents[random_document_index]\n          random_start = rng.randint(0, len(random_document) - 1)\n          for j in range(random_start, len(random_document)):\n            tokens_b.extend(random_document[j])\n            if len(tokens_b) >= target_b_length:\n              break\n          # We didn\'t actually use these segments so we ""put them back"" so\n          # they don\'t go to waste.\n          num_unused_segments = len(current_chunk) - a_end\n          i -= num_unused_segments\n        # Actual next\n        else:\n          is_random_next = False\n          for j in range(a_end, len(current_chunk)):\n            tokens_b.extend(current_chunk[j])\n        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n        assert len(tokens_a) >= 1\n        assert len(tokens_b) >= 1\n\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n          tokens.append(token)\n          segment_ids.append(0)\n\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        for token in tokens_b:\n          tokens.append(token)\n          segment_ids.append(1)\n        tokens.append(""[SEP]"")\n        segment_ids.append(1)\n\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance(\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n      current_chunk = []\n      current_length = 0\n    i += 1\n\n  return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n  """"""Creates the predictions for the masked LM objective.""""""\n\n  cand_indexes = []\n  for (i, token) in enumerate(tokens):\n    if token == ""[CLS]"" or token == ""[SEP]"":\n      continue\n    # Whole Word Masking means that if we mask all of the wordpieces\n    # corresponding to an original word. When a word has been split into\n    # WordPieces, the first token does not have any marker and any subsequence\n    # tokens are prefixed with ##. So whenever we see the ## token, we\n    # append it to the previous set of word indexes.\n    #\n    # Note that Whole Word Masking does *not* change the training code\n    # at all -- we still predict each WordPiece independently, softmaxed\n    # over the entire vocabulary.\n    if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n        token.startswith(""##"")):\n      cand_indexes[-1].append(i)\n    else:\n      cand_indexes.append([i])\n\n  rng.shuffle(cand_indexes)\n\n  output_tokens = list(tokens)\n\n  num_to_predict = min(max_predictions_per_seq,\n                       max(1, int(round(len(tokens) * masked_lm_prob))))\n\n  masked_lms = []\n  covered_indexes = set()\n  for index_set in cand_indexes:\n    if len(masked_lms) >= num_to_predict:\n      break\n    # If adding a whole-word mask would exceed the maximum number of\n    # predictions, then just skip this candidate.\n    if len(masked_lms) + len(index_set) > num_to_predict:\n      continue\n    is_any_index_covered = False\n    for index in index_set:\n      if index in covered_indexes:\n        is_any_index_covered = True\n        break\n    if is_any_index_covered:\n      continue\n    for index in index_set:\n      covered_indexes.add(index)\n\n      masked_token = None\n      # 80% of the time, replace with [MASK]\n      if rng.random() < 0.8:\n        masked_token = ""[MASK]""\n      else:\n        # 10% of the time, keep original\n        if rng.random() < 0.5:\n          masked_token = tokens[index]\n        # 10% of the time, replace with random word\n        else:\n          masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n      output_tokens[index] = masked_token\n\n      masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n  assert len(masked_lms) <= num_to_predict\n  masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n  masked_lm_positions = []\n  masked_lm_labels = []\n  for p in masked_lms:\n    masked_lm_positions.append(p.index)\n    masked_lm_labels.append(p.label)\n\n  return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n  """"""Truncates a pair of sequences to a maximum sequence length.""""""\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_num_tokens:\n      break\n\n    trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n    assert len(trunc_tokens) >= 1\n\n    # We want to sometimes truncate from the front and sometimes from the\n    # back to add more randomness and avoid biases.\n    if rng.random() < 0.5:\n      del trunc_tokens[0]\n    else:\n      trunc_tokens.pop()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Reading from input files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"", input_file)\n\n  rng = random.Random(FLAGS.random_seed)\n  instances = create_training_instances(\n      input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n      FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n      rng)\n\n  output_files = FLAGS.output_file.split("","")\n  tf.logging.info(""*** Writing to output files ***"")\n  for output_file in output_files:\n    tf.logging.info(""  %s"", output_file)\n\n  write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                  FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""output_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  tf.app.run()\n'"
baselines/models/ernie/extract_features.py,34,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Extract pre-computed feature vectors from BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport codecs\nimport collections\nimport json\nimport re\n\nimport modeling\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None, """")\n\nflags.DEFINE_string(""output_file"", None, """")\n\nflags.DEFINE_string(""layers"", ""-1,-2,-3,-4"", """")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(""batch_size"", 32, ""Batch size for predictions."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_string(""master"", None,\n                    ""If using a TPU, the address of the master."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""use_one_hot_embeddings"", False,\n    ""If True, tf.one_hot will be used for embedding lookups, otherwise ""\n    ""tf.nn.embedding_lookup will be used. On TPUs, this should be True ""\n    ""since it is much faster."")\n\n\nclass InputExample(object):\n\n  def __init__(self, unique_id, text_a, text_b):\n    self.unique_id = unique_id\n    self.text_a = text_a\n    self.text_b = text_b\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self, unique_id, tokens, input_ids, input_mask, input_type_ids):\n    self.unique_id = unique_id\n    self.tokens = tokens\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.input_type_ids = input_type_ids\n\n\ndef input_fn_builder(features, seq_length):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_unique_ids = []\n  all_input_ids = []\n  all_input_mask = []\n  all_input_type_ids = []\n\n  for feature in features:\n    all_unique_ids.append(feature.unique_id)\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_input_type_ids.append(feature.input_type_ids)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""unique_ids"":\n            tf.constant(all_unique_ids, shape=[num_examples], dtype=tf.int32),\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_type_ids"":\n            tf.constant(\n                all_input_type_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n    })\n\n    d = d.batch(batch_size=batch_size, drop_remainder=False)\n    return d\n\n  return input_fn\n\n\ndef model_fn_builder(bert_config, init_checkpoint, layer_indexes, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    input_type_ids = features[""input_type_ids""]\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=False,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=input_type_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    if mode != tf.estimator.ModeKeys.PREDICT:\n      raise ValueError(""Only PREDICT modes are supported: %s"" % (mode))\n\n    tvars = tf.trainable_variables()\n    scaffold_fn = None\n    (assignment_map,\n     initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(\n         tvars, init_checkpoint)\n    if use_tpu:\n\n      def tpu_scaffold():\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        return tf.train.Scaffold()\n\n      scaffold_fn = tpu_scaffold\n    else:\n      tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    all_layers = model.get_all_encoder_layers()\n\n    predictions = {\n        ""unique_id"": unique_ids,\n    }\n\n    for (i, layer_index) in enumerate(layer_indexes):\n      predictions[""layer_output_%d"" % i] = all_layers[layer_index]\n\n    output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n        mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\ndef convert_examples_to_features(examples, seq_length, tokenizer):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    tokens_a = tokenizer.tokenize(example.text_a)\n\n    tokens_b = None\n    if example.text_b:\n      tokens_b = tokenizer.tokenize(example.text_b)\n\n    if tokens_b:\n      # Modifies `tokens_a` and `tokens_b` in place so that the total\n      # length is less than the specified length.\n      # Account for [CLS], [SEP], [SEP] with ""- 3""\n      _truncate_seq_pair(tokens_a, tokens_b, seq_length - 3)\n    else:\n      # Account for [CLS] and [SEP] with ""- 2""\n      if len(tokens_a) > seq_length - 2:\n        tokens_a = tokens_a[0:(seq_length - 2)]\n\n    # The convention in BERT is:\n    # (a) For sequence pairs:\n    #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n    #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n    # (b) For single sequences:\n    #  tokens:   [CLS] the dog is hairy . [SEP]\n    #  type_ids: 0     0   0   0  0     0 0\n    #\n    # Where ""type_ids"" are used to indicate whether this is the first\n    # sequence or the second sequence. The embedding vectors for `type=0` and\n    # `type=1` were learned during pre-training and are added to the wordpiece\n    # embedding vector (and position vector). This is not *strictly* necessary\n    # since the [SEP] token unambiguously separates the sequences, but it makes\n    # it easier for the model to learn the concept of sequences.\n    #\n    # For classification tasks, the first vector (corresponding to [CLS]) is\n    # used as as the ""sentence vector"". Note that this only makes sense because\n    # the entire model is fine-tuned.\n    tokens = []\n    input_type_ids = []\n    tokens.append(""[CLS]"")\n    input_type_ids.append(0)\n    for token in tokens_a:\n      tokens.append(token)\n      input_type_ids.append(0)\n    tokens.append(""[SEP]"")\n    input_type_ids.append(0)\n\n    if tokens_b:\n      for token in tokens_b:\n        tokens.append(token)\n        input_type_ids.append(1)\n      tokens.append(""[SEP]"")\n      input_type_ids.append(1)\n\n    input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n    # The mask has 1 for real tokens and 0 for padding tokens. Only real\n    # tokens are attended to.\n    input_mask = [1] * len(input_ids)\n\n    # Zero-pad up to the sequence length.\n    while len(input_ids) < seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      input_type_ids.append(0)\n\n    assert len(input_ids) == seq_length\n    assert len(input_mask) == seq_length\n    assert len(input_type_ids) == seq_length\n\n    if ex_index < 5:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""unique_id: %s"" % (example.unique_id))\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in tokens]))\n      tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n      tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n      tf.logging.info(\n          ""input_type_ids: %s"" % "" "".join([str(x) for x in input_type_ids]))\n\n    features.append(\n        InputFeatures(\n            unique_id=example.unique_id,\n            tokens=tokens,\n            input_ids=input_ids,\n            input_mask=input_mask,\n            input_type_ids=input_type_ids))\n  return features\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef read_examples(input_file):\n  """"""Read a list of `InputExample`s from an input file.""""""\n  examples = []\n  unique_id = 0\n  with tf.gfile.GFile(input_file, ""r"") as reader:\n    while True:\n      line = tokenization.convert_to_unicode(reader.readline())\n      if not line:\n        break\n      line = line.strip()\n      text_a = None\n      text_b = None\n      m = re.match(r""^(.*) \\|\\|\\| (.*)$"", line)\n      if m is None:\n        text_a = line\n      else:\n        text_a = m.group(1)\n        text_b = m.group(2)\n      examples.append(\n          InputExample(unique_id=unique_id, text_a=text_a, text_b=text_b))\n      unique_id += 1\n  return examples\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  layer_indexes = [int(x) for x in FLAGS.layers.split("","")]\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      master=FLAGS.master,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  examples = read_examples(FLAGS.input_file)\n\n  features = convert_examples_to_features(\n      examples=examples, seq_length=FLAGS.max_seq_length, tokenizer=tokenizer)\n\n  unique_id_to_feature = {}\n  for feature in features:\n    unique_id_to_feature[feature.unique_id] = feature\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      layer_indexes=layer_indexes,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_one_hot_embeddings)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      predict_batch_size=FLAGS.batch_size)\n\n  input_fn = input_fn_builder(\n      features=features, seq_length=FLAGS.max_seq_length)\n\n  with codecs.getwriter(""utf-8"")(tf.gfile.Open(FLAGS.output_file,\n                                               ""w"")) as writer:\n    for result in estimator.predict(input_fn, yield_single_examples=True):\n      unique_id = int(result[""unique_id""])\n      feature = unique_id_to_feature[unique_id]\n      output_json = collections.OrderedDict()\n      output_json[""linex_index""] = unique_id\n      all_features = []\n      for (i, token) in enumerate(feature.tokens):\n        all_layers = []\n        for (j, layer_index) in enumerate(layer_indexes):\n          layer_output = result[""layer_output_%d"" % j]\n          layers = collections.OrderedDict()\n          layers[""index""] = layer_index\n          layers[""values""] = [\n              round(float(x), 6) for x in layer_output[i:(i + 1)].flat\n          ]\n          all_layers.append(layers)\n        features = collections.OrderedDict()\n        features[""token""] = token\n        features[""layers""] = all_layers\n        all_features.append(features)\n      output_json[""features""] = all_features\n      writer.write(json.dumps(output_json) + ""\\n"")\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""init_checkpoint"")\n  flags.mark_flag_as_required(""output_file"")\n  tf.app.run()\n'"
baselines/models/ernie/modeling.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The main BERT model and related functions.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport numpy as np\nimport six\nimport tensorflow as tf\n\n\nclass BertConfig(object):\n  """"""Configuration for `BertModel`.""""""\n\n  def __init__(self,\n               vocab_size,\n               hidden_size=768,\n               num_hidden_layers=12,\n               num_attention_heads=12,\n               intermediate_size=3072,\n               hidden_act=""gelu"",\n               hidden_dropout_prob=0.1,\n               attention_probs_dropout_prob=0.1,\n               max_position_embeddings=512,\n               type_vocab_size=16,\n               initializer_range=0.02):\n    """"""Constructs BertConfig.\n\n    Args:\n      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.\n      hidden_size: Size of the encoder layers and the pooler layer.\n      num_hidden_layers: Number of hidden layers in the Transformer encoder.\n      num_attention_heads: Number of attention heads for each attention layer in\n        the Transformer encoder.\n      intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n        layer in the Transformer encoder.\n      hidden_act: The non-linear activation function (function or string) in the\n        encoder and pooler.\n      hidden_dropout_prob: The dropout probability for all fully connected\n        layers in the embeddings, encoder, and pooler.\n      attention_probs_dropout_prob: The dropout ratio for the attention\n        probabilities.\n      max_position_embeddings: The maximum sequence length that this model might\n        ever be used with. Typically set this to something large just in case\n        (e.g., 512 or 1024 or 2048).\n      type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n        `BertModel`.\n      initializer_range: The stdev of the truncated_normal_initializer for\n        initializing all weight matrices.\n    """"""\n    self.vocab_size = vocab_size\n    self.hidden_size = hidden_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.hidden_act = hidden_act\n    self.intermediate_size = intermediate_size\n    self.hidden_dropout_prob = hidden_dropout_prob\n    self.attention_probs_dropout_prob = attention_probs_dropout_prob\n    self.max_position_embeddings = max_position_embeddings\n    self.type_vocab_size = type_vocab_size\n    self.initializer_range = initializer_range\n\n  @classmethod\n  def from_dict(cls, json_object):\n    """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n    config = BertConfig(vocab_size=None)\n    for (key, value) in six.iteritems(json_object):\n      config.__dict__[key] = value\n    return config\n\n  @classmethod\n  def from_json_file(cls, json_file):\n    """"""Constructs a `BertConfig` from a json file of parameters.""""""\n    with tf.gfile.GFile(json_file, ""r"") as reader:\n      text = reader.read()\n    return cls.from_dict(json.loads(text))\n\n  def to_dict(self):\n    """"""Serializes this instance to a Python dictionary.""""""\n    output = copy.deepcopy(self.__dict__)\n    return output\n\n  def to_json_string(self):\n    """"""Serializes this instance to a JSON string.""""""\n    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass BertModel(object):\n  """"""BERT model (""Bidirectional Encoder Representations from Transformers"").\n\n  Example usage:\n\n  ```python\n  # Already been converted into WordPiece token ids\n  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])\n  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])\n  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])\n\n  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,\n    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)\n\n  model = modeling.BertModel(config=config, is_training=True,\n    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)\n\n  label_embeddings = tf.get_variable(...)\n  pooled_output = model.get_pooled_output()\n  logits = tf.matmul(pooled_output, label_embeddings)\n  ...\n  ```\n  """"""\n\n  def __init__(self,\n               config,\n               is_training,\n               input_ids,\n               input_mask=None,\n               token_type_ids=None,\n               use_one_hot_embeddings=False,\n               scope=None):\n    """"""Constructor for BertModel.\n\n    Args:\n      config: `BertConfig` instance.\n      is_training: bool. true for training model, false for eval model. Controls\n        whether dropout will be applied.\n      input_ids: int32 Tensor of shape [batch_size, seq_length].\n      input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].\n      token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      use_one_hot_embeddings: (optional) bool. Whether to use one-hot word\n        embeddings or tf.embedding_lookup() for the word embeddings.\n      scope: (optional) variable scope. Defaults to ""bert"".\n\n    Raises:\n      ValueError: The config is invalid or one of the input tensor shapes\n        is invalid.\n    """"""\n    config = copy.deepcopy(config)\n    if not is_training:\n      config.hidden_dropout_prob = 0.0\n      config.attention_probs_dropout_prob = 0.0\n\n    input_shape = get_shape_list(input_ids, expected_rank=2)\n    batch_size = input_shape[0]\n    seq_length = input_shape[1]\n\n    if input_mask is None:\n      input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    if token_type_ids is None:\n      token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    with tf.variable_scope(scope, default_name=""bert""):\n      with tf.variable_scope(""embeddings""):\n        # Perform embedding lookup on the word ids.\n        (self.embedding_output, self.embedding_table) = embedding_lookup(\n            input_ids=input_ids,\n            vocab_size=config.vocab_size,\n            embedding_size=config.hidden_size,\n            initializer_range=config.initializer_range,\n            word_embedding_name=""word_embeddings"",\n            use_one_hot_embeddings=use_one_hot_embeddings)\n\n        # Add positional embeddings and token type embeddings, then layer\n        # normalize and perform dropout.\n        self.embedding_output = embedding_postprocessor(\n            input_tensor=self.embedding_output,\n            use_token_type=True,\n            token_type_ids=token_type_ids,\n            token_type_vocab_size=config.type_vocab_size,\n            token_type_embedding_name=""token_type_embeddings"",\n            use_position_embeddings=True,\n            position_embedding_name=""position_embeddings"",\n            initializer_range=config.initializer_range,\n            max_position_embeddings=config.max_position_embeddings,\n            dropout_prob=config.hidden_dropout_prob)\n\n      with tf.variable_scope(""encoder""):\n        # This converts a 2D mask of shape [batch_size, seq_length] to a 3D\n        # mask of shape [batch_size, seq_length, seq_length] which is used\n        # for the attention scores.\n        attention_mask = create_attention_mask_from_input_mask(\n            input_ids, input_mask)\n\n        # Run the stacked transformer.\n        # `sequence_output` shape = [batch_size, seq_length, hidden_size].\n        self.all_encoder_layers = transformer_model(\n            input_tensor=self.embedding_output,\n            attention_mask=attention_mask,\n            hidden_size=config.hidden_size,\n            num_hidden_layers=config.num_hidden_layers,\n            num_attention_heads=config.num_attention_heads,\n            intermediate_size=config.intermediate_size,\n            intermediate_act_fn=get_activation(config.hidden_act),\n            hidden_dropout_prob=config.hidden_dropout_prob,\n            attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n            initializer_range=config.initializer_range,\n            do_return_all_layers=True)\n\n      self.sequence_output = self.all_encoder_layers[-1]\n      # The ""pooler"" converts the encoded sequence tensor of shape\n      # [batch_size, seq_length, hidden_size] to a tensor of shape\n      # [batch_size, hidden_size]. This is necessary for segment-level\n      # (or segment-pair-level) classification tasks where we need a fixed\n      # dimensional representation of the segment.\n      with tf.variable_scope(""pooler""):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token. We assume that this has been pre-trained\n        first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)\n        self.pooled_output = tf.layers.dense(\n            first_token_tensor,\n            config.hidden_size,\n            activation=tf.tanh,\n            kernel_initializer=create_initializer(config.initializer_range))\n\n  def get_pooled_output(self):\n    return self.pooled_output\n\n  def get_sequence_output(self):\n    """"""Gets final hidden layer of encoder.\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the final hidden of the transformer encoder.\n    """"""\n    return self.sequence_output\n\n  def get_all_encoder_layers(self):\n    return self.all_encoder_layers\n\n  def get_embedding_output(self):\n    """"""Gets output of the embedding lookup (i.e., input to the transformer).\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the output of the embedding layer, after summing the word\n      embeddings with the positional embeddings and the token type embeddings,\n      then performing layer normalization. This is the input to the transformer.\n    """"""\n    return self.embedding_output\n\n  def get_embedding_table(self):\n    return self.embedding_table\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef get_activation(activation_string):\n  """"""Maps a string to a Python function, e.g., ""relu"" => `tf.nn.relu`.\n\n  Args:\n    activation_string: String name of the activation function.\n\n  Returns:\n    A Python function corresponding to the activation function. If\n    `activation_string` is None, empty, or ""linear"", this will return None.\n    If `activation_string` is not a string, it will return `activation_string`.\n\n  Raises:\n    ValueError: The `activation_string` does not correspond to a known\n      activation.\n  """"""\n\n  # We assume that anything that""s not a string is already an activation\n  # function, so we just return it.\n  if not isinstance(activation_string, six.string_types):\n    return activation_string\n\n  if not activation_string:\n    return None\n\n  act = activation_string.lower()\n  if act == ""linear"":\n    return None\n  elif act == ""relu"":\n    return tf.nn.relu\n  elif act == ""gelu"":\n    return gelu\n  elif act == ""tanh"":\n    return tf.tanh\n  else:\n    raise ValueError(""Unsupported activation: %s"" % act)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    if name not in name_to_variable:\n      continue\n    assignment_map[name] = name\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\ndef dropout(input_tensor, dropout_prob):\n  """"""Perform dropout.\n\n  Args:\n    input_tensor: float Tensor.\n    dropout_prob: Python float. The probability of dropping out a value (NOT of\n      *keeping* a dimension as in `tf.nn.dropout`).\n\n  Returns:\n    A version of `input_tensor` with dropout applied.\n  """"""\n  if dropout_prob is None or dropout_prob == 0.0:\n    return input_tensor\n\n  output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob)\n  return output\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n  """"""Runs layer normalization followed by dropout.""""""\n  output_tensor = layer_norm(input_tensor, name)\n  output_tensor = dropout(output_tensor, dropout_prob)\n  return output_tensor\n\n\ndef create_initializer(initializer_range=0.02):\n  """"""Creates a `truncated_normal_initializer` with the given range.""""""\n  return tf.truncated_normal_initializer(stddev=initializer_range)\n\n\ndef embedding_lookup(input_ids,\n                     vocab_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n  """"""Looks up words embeddings for id tensor.\n\n  Args:\n    input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n      ids.\n    vocab_size: int. Size of the embedding vocabulary.\n    embedding_size: int. Width of the word embeddings.\n    initializer_range: float. Embedding initialization range.\n    word_embedding_name: string. Name of the embedding table.\n    use_one_hot_embeddings: bool. If True, use one-hot method for word\n      embeddings. If False, use `tf.gather()`.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, embedding_size].\n  """"""\n  # This function assumes that the input is of shape [batch_size, seq_length,\n  # num_inputs].\n  #\n  # If the input is a 2D tensor of shape [batch_size, seq_length], we\n  # reshape to [batch_size, seq_length, 1].\n  if input_ids.shape.ndims == 2:\n    input_ids = tf.expand_dims(input_ids, axis=[-1])\n\n  embedding_table = tf.get_variable(\n      name=word_embedding_name,\n      shape=[vocab_size, embedding_size],\n      initializer=create_initializer(initializer_range))\n\n  flat_input_ids = tf.reshape(input_ids, [-1])\n  if use_one_hot_embeddings:\n    one_hot_input_ids = tf.one_hot(flat_input_ids, depth=vocab_size)\n    output = tf.matmul(one_hot_input_ids, embedding_table)\n  else:\n    output = tf.gather(embedding_table, flat_input_ids)\n\n  input_shape = get_shape_list(input_ids)\n\n  output = tf.reshape(output,\n                      input_shape[0:-1] + [input_shape[-1] * embedding_size])\n  return (output, embedding_table)\n\n\ndef embedding_postprocessor(input_tensor,\n                            use_token_type=False,\n                            token_type_ids=None,\n                            token_type_vocab_size=16,\n                            token_type_embedding_name=""token_type_embeddings"",\n                            use_position_embeddings=True,\n                            position_embedding_name=""position_embeddings"",\n                            initializer_range=0.02,\n                            max_position_embeddings=512,\n                            dropout_prob=0.1):\n  """"""Performs various post-processing on a word embedding tensor.\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length,\n      embedding_size].\n    use_token_type: bool. Whether to add embeddings for `token_type_ids`.\n    token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      Must be specified if `use_token_type` is True.\n    token_type_vocab_size: int. The vocabulary size of `token_type_ids`.\n    token_type_embedding_name: string. The name of the embedding table variable\n      for token type ids.\n    use_position_embeddings: bool. Whether to add position embeddings for the\n      position of each token in the sequence.\n    position_embedding_name: string. The name of the embedding table variable\n      for positional embeddings.\n    initializer_range: float. Range of the weight initialization.\n    max_position_embeddings: int. Maximum sequence length that might ever be\n      used with this model. This can be longer than the sequence length of\n      input_tensor, but cannot be shorter.\n    dropout_prob: float. Dropout probability applied to the final output tensor.\n\n  Returns:\n    float tensor with same shape as `input_tensor`.\n\n  Raises:\n    ValueError: One of the tensor shapes or input values is invalid.\n  """"""\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  width = input_shape[2]\n\n  output = input_tensor\n\n  if use_token_type:\n    if token_type_ids is None:\n      raise ValueError(""`token_type_ids` must be specified if""\n                       ""`use_token_type` is True."")\n    token_type_table = tf.get_variable(\n        name=token_type_embedding_name,\n        shape=[token_type_vocab_size, width],\n        initializer=create_initializer(initializer_range))\n    # This vocab will be small so we always do one-hot here, since it is always\n    # faster for a small vocabulary.\n    flat_token_type_ids = tf.reshape(token_type_ids, [-1])\n    one_hot_ids = tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)\n    token_type_embeddings = tf.matmul(one_hot_ids, token_type_table)\n    token_type_embeddings = tf.reshape(token_type_embeddings,\n                                       [batch_size, seq_length, width])\n    output += token_type_embeddings\n\n  if use_position_embeddings:\n    assert_op = tf.assert_less_equal(seq_length, max_position_embeddings)\n    with tf.control_dependencies([assert_op]):\n      full_position_embeddings = tf.get_variable(\n          name=position_embedding_name,\n          shape=[max_position_embeddings, width],\n          initializer=create_initializer(initializer_range))\n      # Since the position embedding table is a learned variable, we create it\n      # using a (long) sequence length `max_position_embeddings`. The actual\n      # sequence length might be shorter than this, for faster training of\n      # tasks that do not have long sequences.\n      #\n      # So `full_position_embeddings` is effectively an embedding table\n      # for position [0, 1, 2, ..., max_position_embeddings-1], and the current\n      # sequence has positions [0, 1, 2, ... seq_length-1], so we can just\n      # perform a slice.\n      position_embeddings = tf.slice(full_position_embeddings, [0, 0],\n                                     [seq_length, -1])\n      num_dims = len(output.shape.as_list())\n\n      # Only the last two dimensions are relevant (`seq_length` and `width`), so\n      # we broadcast among the first dimensions, which is typically just\n      # the batch size.\n      position_broadcast_shape = []\n      for _ in range(num_dims - 2):\n        position_broadcast_shape.append(1)\n      position_broadcast_shape.extend([seq_length, width])\n      position_embeddings = tf.reshape(position_embeddings,\n                                       position_broadcast_shape)\n      output += position_embeddings\n\n  output = layer_norm_and_dropout(output, dropout_prob)\n  return output\n\n\ndef create_attention_mask_from_input_mask(from_tensor, to_mask):\n  """"""Create 3D attention mask from a 2D tensor mask.\n\n  Args:\n    from_tensor: 2D or 3D Tensor of shape [batch_size, from_seq_length, ...].\n    to_mask: int32 Tensor of shape [batch_size, to_seq_length].\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length, to_seq_length].\n  """"""\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  batch_size = from_shape[0]\n  from_seq_length = from_shape[1]\n\n  to_shape = get_shape_list(to_mask, expected_rank=2)\n  to_seq_length = to_shape[1]\n\n  to_mask = tf.cast(\n      tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)\n\n  # We don\'t assume that `from_tensor` is a mask (although it could be). We\n  # don\'t actually care if we attend *from* padding tokens (only *to* padding)\n  # tokens so we create a tensor of all ones.\n  #\n  # `broadcast_ones` = [batch_size, from_seq_length, 1]\n  broadcast_ones = tf.ones(\n      shape=[batch_size, from_seq_length, 1], dtype=tf.float32)\n\n  # Here we broadcast along two dimensions to create the mask.\n  mask = broadcast_ones * to_mask\n\n  return mask\n\n\ndef attention_layer(from_tensor,\n                    to_tensor,\n                    attention_mask=None,\n                    num_attention_heads=1,\n                    size_per_head=512,\n                    query_act=None,\n                    key_act=None,\n                    value_act=None,\n                    attention_probs_dropout_prob=0.0,\n                    initializer_range=0.02,\n                    do_return_2d_tensor=False,\n                    batch_size=None,\n                    from_seq_length=None,\n                    to_seq_length=None):\n  """"""Performs multi-headed attention from `from_tensor` to `to_tensor`.\n\n  This is an implementation of multi-headed attention based on ""Attention\n  is all you Need"". If `from_tensor` and `to_tensor` are the same, then\n  this is self-attention. Each timestep in `from_tensor` attends to the\n  corresponding sequence in `to_tensor`, and returns a fixed-with vector.\n\n  This function first projects `from_tensor` into a ""query"" tensor and\n  `to_tensor` into ""key"" and ""value"" tensors. These are (effectively) a list\n  of tensors of length `num_attention_heads`, where each tensor is of shape\n  [batch_size, seq_length, size_per_head].\n\n  Then, the query and key tensors are dot-producted and scaled. These are\n  softmaxed to obtain attention probabilities. The value tensors are then\n  interpolated by these probabilities, then concatenated back to a single\n  tensor and returned.\n\n  In practice, the multi-headed attention are done with transposes and\n  reshapes rather than actual separate tensors.\n\n  Args:\n    from_tensor: float Tensor of shape [batch_size, from_seq_length,\n      from_width].\n    to_tensor: float Tensor of shape [batch_size, to_seq_length, to_width].\n    attention_mask: (optional) int32 Tensor of shape [batch_size,\n      from_seq_length, to_seq_length]. The values should be 1 or 0. The\n      attention scores will effectively be set to -infinity for any positions in\n      the mask that are 0, and will be unchanged for positions that are 1.\n    num_attention_heads: int. Number of attention heads.\n    size_per_head: int. Size of each attention head.\n    query_act: (optional) Activation function for the query transform.\n    key_act: (optional) Activation function for the key transform.\n    value_act: (optional) Activation function for the value transform.\n    attention_probs_dropout_prob: (optional) float. Dropout probability of the\n      attention probabilities.\n    initializer_range: float. Range of the weight initializer.\n    do_return_2d_tensor: bool. If True, the output will be of shape [batch_size\n      * from_seq_length, num_attention_heads * size_per_head]. If False, the\n      output will be of shape [batch_size, from_seq_length, num_attention_heads\n      * size_per_head].\n    batch_size: (Optional) int. If the input is 2D, this might be the batch size\n      of the 3D version of the `from_tensor` and `to_tensor`.\n    from_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `from_tensor`.\n    to_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `to_tensor`.\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length,\n      num_attention_heads * size_per_head]. (If `do_return_2d_tensor` is\n      true, this will be of shape [batch_size * from_seq_length,\n      num_attention_heads * size_per_head]).\n\n  Raises:\n    ValueError: Any of the arguments or tensor shapes are invalid.\n  """"""\n\n  def transpose_for_scores(input_tensor, batch_size, num_attention_heads,\n                           seq_length, width):\n    output_tensor = tf.reshape(\n        input_tensor, [batch_size, seq_length, num_attention_heads, width])\n\n    output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])\n    return output_tensor\n\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])\n\n  if len(from_shape) != len(to_shape):\n    raise ValueError(\n        ""The rank of `from_tensor` must match the rank of `to_tensor`."")\n\n  if len(from_shape) == 3:\n    batch_size = from_shape[0]\n    from_seq_length = from_shape[1]\n    to_seq_length = to_shape[1]\n  elif len(from_shape) == 2:\n    if (batch_size is None or from_seq_length is None or to_seq_length is None):\n      raise ValueError(\n          ""When passing in rank 2 tensors to attention_layer, the values ""\n          ""for `batch_size`, `from_seq_length`, and `to_seq_length` ""\n          ""must all be specified."")\n\n  # Scalar dimensions referenced here:\n  #   B = batch size (number of sequences)\n  #   F = `from_tensor` sequence length\n  #   T = `to_tensor` sequence length\n  #   N = `num_attention_heads`\n  #   H = `size_per_head`\n\n  from_tensor_2d = reshape_to_matrix(from_tensor)\n  to_tensor_2d = reshape_to_matrix(to_tensor)\n\n  # `query_layer` = [B*F, N*H]\n  query_layer = tf.layers.dense(\n      from_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=query_act,\n      name=""query"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `key_layer` = [B*T, N*H]\n  key_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=key_act,\n      name=""key"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `value_layer` = [B*T, N*H]\n  value_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=value_act,\n      name=""value"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `query_layer` = [B, N, F, H]\n  query_layer = transpose_for_scores(query_layer, batch_size,\n                                     num_attention_heads, from_seq_length,\n                                     size_per_head)\n\n  # `key_layer` = [B, N, T, H]\n  key_layer = transpose_for_scores(key_layer, batch_size, num_attention_heads,\n                                   to_seq_length, size_per_head)\n\n  # Take the dot product between ""query"" and ""key"" to get the raw\n  # attention scores.\n  # `attention_scores` = [B, N, F, T]\n  attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)\n  attention_scores = tf.multiply(attention_scores,\n                                 1.0 / math.sqrt(float(size_per_head)))\n\n  if attention_mask is not None:\n    # `attention_mask` = [B, 1, F, T]\n    attention_mask = tf.expand_dims(attention_mask, axis=[1])\n\n    # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n    # masked positions, this operation will create a tensor which is 0.0 for\n    # positions we want to attend and -10000.0 for masked positions.\n    adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0\n\n    # Since we are adding it to the raw scores before the softmax, this is\n    # effectively the same as removing these entirely.\n    attention_scores += adder\n\n  # Normalize the attention scores to probabilities.\n  # `attention_probs` = [B, N, F, T]\n  attention_probs = tf.nn.softmax(attention_scores)\n\n  # This is actually dropping out entire tokens to attend to, which might\n  # seem a bit unusual, but is taken from the original Transformer paper.\n  attention_probs = dropout(attention_probs, attention_probs_dropout_prob)\n\n  # `value_layer` = [B, T, N, H]\n  value_layer = tf.reshape(\n      value_layer,\n      [batch_size, to_seq_length, num_attention_heads, size_per_head])\n\n  # `value_layer` = [B, N, T, H]\n  value_layer = tf.transpose(value_layer, [0, 2, 1, 3])\n\n  # `context_layer` = [B, N, F, H]\n  context_layer = tf.matmul(attention_probs, value_layer)\n\n  # `context_layer` = [B, F, N, H]\n  context_layer = tf.transpose(context_layer, [0, 2, 1, 3])\n\n  if do_return_2d_tensor:\n    # `context_layer` = [B*F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size * from_seq_length, num_attention_heads * size_per_head])\n  else:\n    # `context_layer` = [B, F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size, from_seq_length, num_attention_heads * size_per_head])\n\n  return context_layer\n\n\ndef transformer_model(input_tensor,\n                      attention_mask=None,\n                      hidden_size=768,\n                      num_hidden_layers=12,\n                      num_attention_heads=12,\n                      intermediate_size=3072,\n                      intermediate_act_fn=gelu,\n                      hidden_dropout_prob=0.1,\n                      attention_probs_dropout_prob=0.1,\n                      initializer_range=0.02,\n                      do_return_all_layers=False):\n  """"""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n  This is almost an exact implementation of the original Transformer encoder.\n\n  See the original paper:\n  https://arxiv.org/abs/1706.03762\n\n  Also see:\n  https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n    attention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n      seq_length], with 1 for positions that can be attended to and 0 in\n      positions that should not be.\n    hidden_size: int. Hidden size of the Transformer.\n    num_hidden_layers: int. Number of layers (blocks) in the Transformer.\n    num_attention_heads: int. Number of attention heads in the Transformer.\n    intermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n      forward) layer.\n    intermediate_act_fn: function. The non-linear activation function to apply\n      to the output of the intermediate/feed-forward layer.\n    hidden_dropout_prob: float. Dropout probability for the hidden layers.\n    attention_probs_dropout_prob: float. Dropout probability of the attention\n      probabilities.\n    initializer_range: float. Range of the initializer (stddev of truncated\n      normal).\n    do_return_all_layers: Whether to also return all layers or just the final\n      layer.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, hidden_size], the final\n    hidden layer of the Transformer.\n\n  Raises:\n    ValueError: A Tensor shape or parameter is invalid.\n  """"""\n  if hidden_size % num_attention_heads != 0:\n    raise ValueError(\n        ""The hidden size (%d) is not a multiple of the number of attention ""\n        ""heads (%d)"" % (hidden_size, num_attention_heads))\n\n  attention_head_size = int(hidden_size / num_attention_heads)\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  input_width = input_shape[2]\n\n  # The Transformer performs sum residuals on all layers so the input needs\n  # to be the same as the hidden size.\n  if input_width != hidden_size:\n    raise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n                     (input_width, hidden_size))\n\n  # We keep the representation as a 2D tensor to avoid re-shaping it back and\n  # forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n  # the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n  # help the optimizer.\n  prev_output = reshape_to_matrix(input_tensor)\n\n  all_layer_outputs = []\n  for layer_idx in range(num_hidden_layers):\n    with tf.variable_scope(""layer_%d"" % layer_idx):\n      layer_input = prev_output\n\n      with tf.variable_scope(""attention""):\n        attention_heads = []\n        with tf.variable_scope(""self""):\n          attention_head = attention_layer(\n              from_tensor=layer_input,\n              to_tensor=layer_input,\n              attention_mask=attention_mask,\n              num_attention_heads=num_attention_heads,\n              size_per_head=attention_head_size,\n              attention_probs_dropout_prob=attention_probs_dropout_prob,\n              initializer_range=initializer_range,\n              do_return_2d_tensor=True,\n              batch_size=batch_size,\n              from_seq_length=seq_length,\n              to_seq_length=seq_length)\n          attention_heads.append(attention_head)\n\n        attention_output = None\n        if len(attention_heads) == 1:\n          attention_output = attention_heads[0]\n        else:\n          # In the case where we have other sequences, we just concatenate\n          # them to the self-attention head before the projection.\n          attention_output = tf.concat(attention_heads, axis=-1)\n\n        # Run a linear projection of `hidden_size` then add a residual\n        # with `layer_input`.\n        with tf.variable_scope(""output""):\n          attention_output = tf.layers.dense(\n              attention_output,\n              hidden_size,\n              kernel_initializer=create_initializer(initializer_range))\n          attention_output = dropout(attention_output, hidden_dropout_prob)\n          attention_output = layer_norm(attention_output + layer_input)\n\n      # The activation is only applied to the ""intermediate"" hidden layer.\n      with tf.variable_scope(""intermediate""):\n        intermediate_output = tf.layers.dense(\n            attention_output,\n            intermediate_size,\n            activation=intermediate_act_fn,\n            kernel_initializer=create_initializer(initializer_range))\n\n      # Down-project back to `hidden_size` then add the residual.\n      with tf.variable_scope(""output""):\n        layer_output = tf.layers.dense(\n            intermediate_output,\n            hidden_size,\n            kernel_initializer=create_initializer(initializer_range))\n        layer_output = dropout(layer_output, hidden_dropout_prob)\n        layer_output = layer_norm(layer_output + attention_output)\n        prev_output = layer_output\n        all_layer_outputs.append(layer_output)\n\n  if do_return_all_layers:\n    final_outputs = []\n    for layer_output in all_layer_outputs:\n      final_output = reshape_from_matrix(layer_output, input_shape)\n      final_outputs.append(final_output)\n    return final_outputs\n  else:\n    final_output = reshape_from_matrix(prev_output, input_shape)\n    return final_output\n\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n  """"""Returns a list of the shape of tensor, preferring static dimensions.\n\n  Args:\n    tensor: A tf.Tensor object to find the shape of.\n    expected_rank: (optional) int. The expected rank of `tensor`. If this is\n      specified and the `tensor` has a different rank, and exception will be\n      thrown.\n    name: Optional name of the tensor for the error message.\n\n  Returns:\n    A list of dimensions of the shape of tensor. All static dimensions will\n    be returned as python integers, and dynamic dimensions will be returned\n    as tf.Tensor scalars.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  if expected_rank is not None:\n    assert_rank(tensor, expected_rank, name)\n\n  shape = tensor.shape.as_list()\n\n  non_static_indexes = []\n  for (index, dim) in enumerate(shape):\n    if dim is None:\n      non_static_indexes.append(index)\n\n  if not non_static_indexes:\n    return shape\n\n  dyn_shape = tf.shape(tensor)\n  for index in non_static_indexes:\n    shape[index] = dyn_shape[index]\n  return shape\n\n\ndef reshape_to_matrix(input_tensor):\n  """"""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n  ndims = input_tensor.shape.ndims\n  if ndims < 2:\n    raise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n                     (input_tensor.shape))\n  if ndims == 2:\n    return input_tensor\n\n  width = input_tensor.shape[-1]\n  output_tensor = tf.reshape(input_tensor, [-1, width])\n  return output_tensor\n\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n  """"""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n  if len(orig_shape_list) == 2:\n    return output_tensor\n\n  output_shape = get_shape_list(output_tensor)\n\n  orig_dims = orig_shape_list[0:-1]\n  width = output_shape[-1]\n\n  return tf.reshape(output_tensor, orig_dims + [width])\n\n\ndef assert_rank(tensor, expected_rank, name=None):\n  """"""Raises an exception if the tensor rank is not of the expected rank.\n\n  Args:\n    tensor: A tf.Tensor to check the rank of.\n    expected_rank: Python integer or list of integers, expected rank.\n    name: Optional name of the tensor for the error message.\n\n  Raises:\n    ValueError: If the expected shape doesn\'t match the actual shape.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  expected_rank_dict = {}\n  if isinstance(expected_rank, six.integer_types):\n    expected_rank_dict[expected_rank] = True\n  else:\n    for x in expected_rank:\n      expected_rank_dict[x] = True\n\n  actual_rank = tensor.shape.ndims\n  if actual_rank not in expected_rank_dict:\n    scope_name = tf.get_variable_scope().name\n    raise ValueError(\n        ""For the tensor `%s` in scope `%s`, the actual rank ""\n        ""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n        (name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n'"
baselines/models/ernie/modeling_test.py,5,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport random\nimport re\n\nimport modeling\nimport six\nimport tensorflow as tf\n\n\nclass BertModelTest(tf.test.TestCase):\n\n  class BertModelTester(object):\n\n    def __init__(self,\n                 parent,\n                 batch_size=13,\n                 seq_length=7,\n                 is_training=True,\n                 use_input_mask=True,\n                 use_token_type_ids=True,\n                 vocab_size=99,\n                 hidden_size=32,\n                 num_hidden_layers=5,\n                 num_attention_heads=4,\n                 intermediate_size=37,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=16,\n                 initializer_range=0.02,\n                 scope=None):\n      self.parent = parent\n      self.batch_size = batch_size\n      self.seq_length = seq_length\n      self.is_training = is_training\n      self.use_input_mask = use_input_mask\n      self.use_token_type_ids = use_token_type_ids\n      self.vocab_size = vocab_size\n      self.hidden_size = hidden_size\n      self.num_hidden_layers = num_hidden_layers\n      self.num_attention_heads = num_attention_heads\n      self.intermediate_size = intermediate_size\n      self.hidden_act = hidden_act\n      self.hidden_dropout_prob = hidden_dropout_prob\n      self.attention_probs_dropout_prob = attention_probs_dropout_prob\n      self.max_position_embeddings = max_position_embeddings\n      self.type_vocab_size = type_vocab_size\n      self.initializer_range = initializer_range\n      self.scope = scope\n\n    def create_model(self):\n      input_ids = BertModelTest.ids_tensor([self.batch_size, self.seq_length],\n                                           self.vocab_size)\n\n      input_mask = None\n      if self.use_input_mask:\n        input_mask = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], vocab_size=2)\n\n      token_type_ids = None\n      if self.use_token_type_ids:\n        token_type_ids = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], self.type_vocab_size)\n\n      config = modeling.BertConfig(\n          vocab_size=self.vocab_size,\n          hidden_size=self.hidden_size,\n          num_hidden_layers=self.num_hidden_layers,\n          num_attention_heads=self.num_attention_heads,\n          intermediate_size=self.intermediate_size,\n          hidden_act=self.hidden_act,\n          hidden_dropout_prob=self.hidden_dropout_prob,\n          attention_probs_dropout_prob=self.attention_probs_dropout_prob,\n          max_position_embeddings=self.max_position_embeddings,\n          type_vocab_size=self.type_vocab_size,\n          initializer_range=self.initializer_range)\n\n      model = modeling.BertModel(\n          config=config,\n          is_training=self.is_training,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          token_type_ids=token_type_ids,\n          scope=self.scope)\n\n      outputs = {\n          ""embedding_output"": model.get_embedding_output(),\n          ""sequence_output"": model.get_sequence_output(),\n          ""pooled_output"": model.get_pooled_output(),\n          ""all_encoder_layers"": model.get_all_encoder_layers(),\n      }\n      return outputs\n\n    def check_output(self, result):\n      self.parent.assertAllEqual(\n          result[""embedding_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(\n          result[""sequence_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(result[""pooled_output""].shape,\n                                 [self.batch_size, self.hidden_size])\n\n  def test_default(self):\n    self.run_tester(BertModelTest.BertModelTester(self))\n\n  def test_config_to_json_string(self):\n    config = modeling.BertConfig(vocab_size=99, hidden_size=37)\n    obj = json.loads(config.to_json_string())\n    self.assertEqual(obj[""vocab_size""], 99)\n    self.assertEqual(obj[""hidden_size""], 37)\n\n  def run_tester(self, tester):\n    with self.test_session() as sess:\n      ops = tester.create_model()\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      output_result = sess.run(ops)\n      tester.check_output(output_result)\n\n      self.assert_all_tensors_reachable(sess, [init_op, ops])\n\n  @classmethod\n  def ids_tensor(cls, shape, vocab_size, rng=None, name=None):\n    """"""Creates a random int32 tensor of the shape within the vocab size.""""""\n    if rng is None:\n      rng = random.Random()\n\n    total_dims = 1\n    for dim in shape:\n      total_dims *= dim\n\n    values = []\n    for _ in range(total_dims):\n      values.append(rng.randint(0, vocab_size - 1))\n\n    return tf.constant(value=values, dtype=tf.int32, shape=shape, name=name)\n\n  def assert_all_tensors_reachable(self, sess, outputs):\n    """"""Checks that all the tensors in the graph are reachable from outputs.""""""\n    graph = sess.graph\n\n    ignore_strings = [\n        ""^.*/assert_less_equal/.*$"",\n        ""^.*/dilation_rate$"",\n        ""^.*/Tensordot/concat$"",\n        ""^.*/Tensordot/concat/axis$"",\n        ""^testing/.*$"",\n    ]\n\n    ignore_regexes = [re.compile(x) for x in ignore_strings]\n\n    unreachable = self.get_unreachable_ops(graph, outputs)\n    filtered_unreachable = []\n    for x in unreachable:\n      do_ignore = False\n      for r in ignore_regexes:\n        m = r.match(x.name)\n        if m is not None:\n          do_ignore = True\n      if do_ignore:\n        continue\n      filtered_unreachable.append(x)\n    unreachable = filtered_unreachable\n\n    self.assertEqual(\n        len(unreachable), 0, ""The following ops are unreachable: %s"" %\n        ("" "".join([x.name for x in unreachable])))\n\n  @classmethod\n  def get_unreachable_ops(cls, graph, outputs):\n    """"""Finds all of the tensors in graph that are unreachable from outputs.""""""\n    outputs = cls.flatten_recursive(outputs)\n    output_to_op = collections.defaultdict(list)\n    op_to_all = collections.defaultdict(list)\n    assign_out_to_in = collections.defaultdict(list)\n\n    for op in graph.get_operations():\n      for x in op.inputs:\n        op_to_all[op.name].append(x.name)\n      for y in op.outputs:\n        output_to_op[y.name].append(op.name)\n        op_to_all[op.name].append(y.name)\n      if str(op.type) == ""Assign"":\n        for y in op.outputs:\n          for x in op.inputs:\n            assign_out_to_in[y.name].append(x.name)\n\n    assign_groups = collections.defaultdict(list)\n    for out_name in assign_out_to_in.keys():\n      name_group = assign_out_to_in[out_name]\n      for n1 in name_group:\n        assign_groups[n1].append(out_name)\n        for n2 in name_group:\n          if n1 != n2:\n            assign_groups[n1].append(n2)\n\n    seen_tensors = {}\n    stack = [x.name for x in outputs]\n    while stack:\n      name = stack.pop()\n      if name in seen_tensors:\n        continue\n      seen_tensors[name] = True\n\n      if name in output_to_op:\n        for op_name in output_to_op[name]:\n          if op_name in op_to_all:\n            for input_name in op_to_all[op_name]:\n              if input_name not in stack:\n                stack.append(input_name)\n\n      expanded_names = []\n      if name in assign_groups:\n        for assign_name in assign_groups[name]:\n          expanded_names.append(assign_name)\n\n      for expanded_name in expanded_names:\n        if expanded_name not in stack:\n          stack.append(expanded_name)\n\n    unreachable_ops = []\n    for op in graph.get_operations():\n      is_unreachable = False\n      all_names = [x.name for x in op.inputs] + [x.name for x in op.outputs]\n      for name in all_names:\n        if name not in seen_tensors:\n          is_unreachable = True\n      if is_unreachable:\n        unreachable_ops.append(op)\n    return unreachable_ops\n\n  @classmethod\n  def flatten_recursive(cls, item):\n    """"""Flattens (potentially nested) a tuple/dictionary/list to a list.""""""\n    output = []\n    if isinstance(item, list):\n      output.extend(item)\n    elif isinstance(item, tuple):\n      output.extend(list(item))\n    elif isinstance(item, dict):\n      for (_, v) in six.iteritems(item):\n        output.append(v)\n    else:\n      return [item]\n\n    flat_output = []\n    for x in output:\n      flat_output.extend(cls.flatten_recursive(x))\n    return flat_output\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/ernie/optimization.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/ernie/optimization_test.py,11,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport optimization\nimport tensorflow as tf\n\n\nclass OptimizationTest(tf.test.TestCase):\n\n  def test_adam(self):\n    with self.test_session() as sess:\n      w = tf.get_variable(\n          ""w"",\n          shape=[3],\n          initializer=tf.constant_initializer([0.1, -0.2, -0.1]))\n      x = tf.constant([0.4, 0.2, -0.5])\n      loss = tf.reduce_mean(tf.square(x - w))\n      tvars = tf.trainable_variables()\n      grads = tf.gradients(loss, tvars)\n      global_step = tf.train.get_or_create_global_step()\n      optimizer = optimization.AdamWeightDecayOptimizer(learning_rate=0.2)\n      train_op = optimizer.apply_gradients(zip(grads, tvars), global_step)\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      for _ in range(100):\n        sess.run(train_op)\n      w_np = sess.run(w)\n      self.assertAllClose(w_np.flat, [0.4, 0.2, -0.5], rtol=1e-2, atol=1e-2)\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/ernie/run_classifier.py,112,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:30:20\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nimport sys\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n# Required parameters\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input data dir. Should contain the .tsv files (or other data files) ""\n    ""for the task."")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""task_name"", None, ""The name of the task to train."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n# Other parameters\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(\n    ""do_predict"", False,\n    ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n  return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    features[""label_ids""] = create_int_feature([feature.label_id])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 labels, num_labels, use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use model.get_sequence_output()\n  # instead.\n  output_layer = model.get_pooled_output()\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n    is_real_example = None\n    if ""is_real_example"" in features:\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n    else:\n      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,\n        num_labels, use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n       ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(\n            labels=label_ids, predictions=predictions, weights=is_real_example)\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn,\n                      [per_example_loss, label_ids, logits, is_real_example])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={""probabilities"": probabilities},\n          scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef input_fn_builder(features, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_input_ids = []\n  all_input_mask = []\n  all_segment_ids = []\n  all_label_ids = []\n\n  for feature in features:\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_segment_ids.append(feature.segment_ids)\n    all_label_ids.append(feature.label_id)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""segment_ids"":\n            tf.constant(\n                all_segment_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""label_ids"":\n            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),\n    })\n\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)\n    return d\n\n  return input_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer):\n  """"""Convert a set of `InputExample`s to a list of `InputFeatures`.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    features.append(feature)\n  return features\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval` or `do_predict\' must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      num_labels=len(label_list),\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    else:\n      file_based_convert_examples_to_features(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    # dev dataset\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    num_actual_eval_examples = len(eval_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on. These do NOT count towards the metric (all tf.metrics\n      # support a per-instance weight, and these get a weight of 0.0).\n      while len(eval_examples) % FLAGS.eval_batch_size != 0:\n        eval_examples.append(PaddingInputExample())\n\n    eval_file = os.path.join(FLAGS.output_dir, ""dev.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(eval_examples), num_actual_eval_examples,\n                    len(eval_examples) - num_actual_eval_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      assert len(eval_examples) % FLAGS.eval_batch_size == 0\n      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    #######################################################################################################################\n    # evaluate all checkpoints; you can use the checkpoint with the best dev accuarcy\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_ernie.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        result = estimator.evaluate(input_fn=eval_input_fn,\n                                    steps=eval_steps, checkpoint_path=filename)\n\n        tf.logging.info(""***** Eval results %s *****"" % (filename))\n        writer.write(""***** Eval results %s *****\\n"" % (filename))\n        for key in sorted(result.keys()):\n          tf.logging.info(""  %s = %s"", key, str(result[key]))\n          writer.write(""%s = %s\\n"" % (key, str(result[key])))\n    #######################################################################################################################\n\n    # result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n    #\n    # output_eval_file = os.path.join(FLAGS.output_dir, ""dev_results_ernie.txt"")\n    # with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n    #  tf.logging.info(""***** Eval results *****"")\n    #  for key in sorted(result.keys()):\n    #    tf.logging.info(""  %s = %s"", key, str(result[key]))\n    #    writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    num_actual_predict_examples = len(predict_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on.\n      while len(predict_examples) % FLAGS.predict_batch_size != 0:\n        predict_examples.append(PaddingInputExample())\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(predict_examples, label_list,\n                                                        FLAGS.max_seq_length, tokenizer,\n                                                        predict_file)\n    else:\n      file_based_convert_examples_to_features(predict_examples, label_list,\n                                              FLAGS.max_seq_length, tokenizer,\n                                              predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(predict_examples), num_actual_predict_examples,\n                    len(predict_examples) - num_actual_predict_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_drop_remainder = True if FLAGS.use_tpu else False\n    predict_input_fn = file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=predict_drop_remainder)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/ernie/run_classifier_with_tfhub.py,51,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner with TF-Hub.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport optimization\nimport run_classifier\nimport tokenization\nimport tensorflow as tf\nimport tensorflow_hub as hub\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""bert_hub_module_handle"", None,\n    ""Handle for the BERT TF-Hub module."")\n\n\ndef create_model(is_training, input_ids, input_mask, segment_ids, labels,\n                 num_labels, bert_hub_module_handle):\n  """"""Creates a classification model.""""""\n  tags = set()\n  if is_training:\n    tags.add(""train"")\n  bert_module = hub.Module(bert_hub_module_handle, tags=tags, trainable=True)\n  bert_inputs = dict(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids)\n  bert_outputs = bert_module(\n      inputs=bert_inputs,\n      signature=""tokens"",\n      as_dict=True)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use\n  # bert_outputs[""sequence_output""] instead.\n  output_layer = bert_outputs[""pooled_output""]\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(num_labels, learning_rate, num_train_steps,\n                     num_warmup_steps, use_tpu, bert_hub_module_handle):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        is_training, input_ids, input_mask, segment_ids, label_ids, num_labels,\n        bert_hub_module_handle)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(label_ids, predictions)\n        loss = tf.metrics.mean(per_example_loss)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions={""probabilities"": probabilities})\n    else:\n      raise ValueError(\n          ""Only TRAIN, EVAL and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef create_tokenizer_from_hub_module(bert_hub_module_handle):\n  """"""Get the vocab file and casing info from the Hub module.""""""\n  with tf.Graph().as_default():\n    bert_module = hub.Module(bert_hub_module_handle)\n    tokenization_info = bert_module(signature=""tokenization_info"", as_dict=True)\n    with tf.Session() as sess:\n      vocab_file, do_lower_case = sess.run([tokenization_info[""vocab_file""],\n                                            tokenization_info[""do_lower_case""]])\n  return tokenization.FullTokenizer(\n      vocab_file=vocab_file, do_lower_case=do_lower_case)\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""cola"": run_classifier.ColaProcessor,\n      ""mnli"": run_classifier.MnliProcessor,\n      ""mrpc"": run_classifier.MrpcProcessor,\n  }\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = create_tokenizer_from_hub_module(FLAGS.bert_hub_module_handle)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      num_labels=len(label_list),\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      bert_hub_module_handle=FLAGS.bert_hub_module_handle)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_features = run_classifier.convert_examples_to_features(\n        train_examples, label_list, FLAGS.max_seq_length, tokenizer)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = run_classifier.input_fn_builder(\n        features=train_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    eval_features = run_classifier.convert_examples_to_features(\n        eval_examples, label_list, FLAGS.max_seq_length, tokenizer)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d"", len(eval_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      # Eval will be slightly WRONG on the TPU because it will truncate\n      # the last batch.\n      eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = run_classifier.input_fn_builder(\n        features=eval_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    if FLAGS.use_tpu:\n      # Discard batch remainder if running on TPU\n      n = len(predict_examples)\n      predict_examples = predict_examples[:(n - n % FLAGS.predict_batch_size)]\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    run_classifier.file_based_convert_examples_to_features(\n        predict_examples, label_list, FLAGS.max_seq_length, tokenizer,\n        predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d"", len(predict_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_input_fn = run_classifier.file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=FLAGS.use_tpu)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n      tf.logging.info(""***** Predict results *****"")\n      for prediction in result:\n        probabilities = prediction[""probabilities""]\n        output_line = ""\\t"".join(\n            str(class_probability)\n            for class_probability in probabilities) + ""\\n""\n        writer.write(output_line)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""bert_hub_module_handle"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/ernie/run_ner.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nfrom sklearn.metrics import f1_score, precision_score, recall_score\nfrom tensorflow.python.ops import math_ops\nimport tf_metrics\nimport pickle\nimport codecs\nimport sys\n\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input datadir."",\n)\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model.""\n)\n\nflags.DEFINE_string(\n    ""task_name"", None, ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""token_name"", ""full"", ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written.""\n)\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model).""\n)\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text.""\n)\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization.""\n)\n\nflags.DEFINE_bool(\n    ""do_train"", False,\n    ""Whether to run training.""\n)\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0, ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputExample(object):\n    """"""A single training/test example for simple sequence classification.""""""\n\n    def __init__(self, guid, text, label=None):\n        """"""Constructs a InputExample.\n\n        Args:\n          guid: Unique id for the example.\n          text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n          label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid = guid\n        self.text = text\n        self.label = label\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self, input_ids, input_mask, segment_ids, label_ids, label_mask):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_ids = label_ids\n        self.label_mask = label_mask\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_data(cls, input_file):\n        """"""Reads a BIO data.""""""\n        with open(input_file) as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                word = line.strip().split(\' \')[0]\n                label = line.strip().split(\' \')[-1]\n                if contends.startswith(""-DOCSTART-""):\n                    words.append(\'\')\n                    continue\n                if len(contends) == 0 and words[-1] == \'.\':\n                    l = \' \'.join([label for label in labels if len(label) > 0])\n                    w = \' \'.join([word for word in words if len(word) > 0])\n                    lines.append([l, w])\n                    words = []\n                    labels = []\n                    continue\n                if len(contends) == 0:\n                    continue\n                words.append(word)\n                labels.append(label)\n            return lines\n\n\nclass NerProcessor(DataProcessor):\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""train.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""dev.txt"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""test.txt"")), ""test"")\n\n    def get_labels(self):\n        # return [""I-MISC"", ""I-PER"",  ""I-ORG"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        return [""B-MISC"", ""I-MISC"", ""B-PER"", ""I-PER"", ""B-ORG"", ""I-ORG"", ""B-LOC"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\nclass WeiboNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.train"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.dev"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.test"")), ""test"")\n\n\n    def get_labels(self):\n        return [\'I-PER.NOM\', \'I-PER.NAM\', \'I-GPE.NAM\', \'I-ORG.NAM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        # return [\'B-PER.NOM\', \'I-PER.NOM\', \'B-LOC.NAM\', \'B-PER.NAM\', \'I-PER.NAM\', \'B-GPE.NAM\', \'I-GPE.NAM\', \'B-ORG.NAM\', \'I-ORG.NAM\', \'B-ORG.NOM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'B-LOC.NOM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                if len(tokens) == 2:\n                    words.append(tokens[0])\n                    label = tokens[-1]\n                    if label[0] == \'B\':\n                        label = ""I"" + label[1:]\n                    labels.append(label)\n                else:\n                    if len(contends) == 0 and len(words) > 0:\n                        label = []\n                        word = []\n                        for l, w in zip(labels, words):\n                            if len(l) > 0 and len(w) > 0:\n                                label.append(l)\n                                # self.labels.add(l)\n                                word.append(w)\n                        lines.append([\' \'.join(label), \' \'.join(word)])\n                        words = []\n                        labels = []\n                        continue\n                if contends.startswith(""-DOCSTART-""):\n                    continue\n\n            return lines\n\nclass MsraNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""train1.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""test"")\n\n    def get_labels(self):\n        return [\'B-PERSON\', \'I-PERSON\', \'B-LOCATION\', \'I-LOCATION\', \'B-ORGANIZATION\', \'I-ORGANIZATION\', ""O"", ""[CLS]"", ""[SEP]"", ""X""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            chars = []\n            labels = []\n            len_count = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                for token in tokens:\n                    word, label = token.split(\'/\')\n\n                    if label == ""nr"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-PERSON\'] + [\'I-PERSON\']*(len(word)-1)\n                    elif label == ""ns"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-LOCATION\'] + [\'I-LOCATION\']*(len(word)-1)\n                    elif label == ""nt"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-ORGANIZATION\'] + [\'I-ORGANIZATION\']*(len(word)-1)\n                    else:\n                        assert label == ""o""\n                        chars = chars + list(word)\n                        labels = labels + [""O""] * len(word)\n                lines.append([\' \'.join(labels), \' \'.join(chars)])\n                len_count.append(len(chars))\n                chars = []\n                labels = []\n            return lines\n\n\ndef write_tokens(tokens, mode):\n    if mode == ""test"":\n        path = os.path.join(FLAGS.output_dir, ""token_"" + mode + "".txt"")\n        wf = open(path, \'a\')\n        for token in tokens:\n            if token != ""**NULL**"":\n                wf.write(token + \'\\n\')\n        wf.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode):\n    label_map = {}\n    for (i, label) in enumerate(label_list, 1):\n        label_map[label] = i\n\n    if not os.path.exists(os.path.join(output_dir, \'label2id.pkl\')):\n        with open(os.path.join(output_dir, \'label2id.pkl\'), \'wb\') as w:\n            pickle.dump(label_map, w)\n    textlist = example.text.split(\' \')\n    labellist = example.label.split(\' \')\n    tokens = []\n    labels = []\n    label_mask = []\n    for i, word in enumerate(textlist):\n        token = tokenizer.tokenize(word)\n        tokens.extend(token)\n        label_1 = labellist[i]\n        for m in range(len(token)):\n            if m == 0:\n                labels.append(label_1)\n            else:\n                labels.append(""X"")\n    \n    # tokens = tokenizer.tokenize(example.text)\n    if len(tokens) >= max_seq_length - 1:\n        tokens = tokens[0:(max_seq_length - 2)]\n        labels = labels[0:(max_seq_length - 2)]\n    ntokens = []\n    segment_ids = []\n    label_ids = []\n    ntokens.append(""[CLS]"")\n    segment_ids.append(0)\n    # append(""O"") or append(""[CLS]"") not sure!\n    label_ids.append(label_map[""[CLS]""])\n    label_mask.append(0) # not to predict and train\n    for i, token in enumerate(tokens):\n        ntokens.append(token)\n        segment_ids.append(0)\n        label_ids.append(label_map[labels[i]])\n        if labels[i] == \'X\':\n            label_mask.append(0)\n        else:\n            label_mask.append(1)\n    ntokens.append(""[SEP]"")\n    segment_ids.append(0)\n    label_mask.append(0)\n    # append(""O"") or append(""[SEP]"") not sure!\n    label_ids.append(label_map[""[SEP]""])\n    input_ids = tokenizer.convert_tokens_to_ids(ntokens)\n    input_mask = [1] * len(input_ids)\n    # label_mask = [1] * len(input_ids)\n    while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n        # we don\'t concerned about it!\n        label_ids.append(0)\n        ntokens.append(""**NULL**"")\n        label_mask.append(0)\n    # print(len(input_ids))\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n    assert len(label_ids) == max_seq_length\n    assert len(label_mask) == max_seq_length\n\n    if ex_index < 5:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""guid: %s"" % (example.guid))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        tf.logging.info(""label_ids: %s"" % "" "".join([str(x) for x in label_ids]))\n        tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n        # tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n\n    feature = InputFeatures(\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        label_ids=label_ids,\n        label_mask = label_mask\n    )\n    write_tokens(ntokens, mode)\n    return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file, output_dir, mode=None\n):\n    writer = tf.python_io.TFRecordWriter(output_file)\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 5000 == 0:\n            tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n        feature = convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode)\n\n        def create_int_feature(values):\n            f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n            return f\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(feature.input_ids)\n        features[""input_mask""] = create_int_feature(feature.input_mask)\n        features[""segment_ids""] = create_int_feature(feature.segment_ids)\n        features[""label_ids""] = create_int_feature(feature.label_ids)\n        features[""label_mask""] = create_int_feature(feature.label_mask)\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n        writer.write(tf_example.SerializeToString())\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n    name_to_features = {\n        ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n    }\n\n    def _decode_record(record, name_to_features):\n        example = tf.parse_single_example(record, name_to_features)\n        for name in list(example.keys()):\n            t = example[name]\n            if t.dtype == tf.int64:\n                t = tf.to_int32(t)\n            example[name] = t\n        return example\n\n    def input_fn(params):\n        batch_size = params[""batch_size""]\n        d = tf.data.TFRecordDataset(input_file)\n        if is_training:\n            d = d.repeat()\n            d = d.shuffle(buffer_size=100)\n        d = d.apply(tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder\n        ))\n        return d\n\n    return input_fn\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, label_mask,\n                 segment_ids, labels, num_labels, use_one_hot_embeddings):\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings\n    )\n\n    output_layer = model.get_sequence_output()\n\n    hidden_size = output_layer.shape[-1].value\n\n    output_weight = tf.get_variable(\n        ""output_weights"", [num_labels, hidden_size],\n        initializer=tf.truncated_normal_initializer(stddev=0.02)\n    )\n    output_bias = tf.get_variable(\n        ""output_bias"", [num_labels], initializer=tf.zeros_initializer()\n    )\n    with tf.variable_scope(""loss""):\n        if is_training:\n            output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n        output_layer = tf.reshape(output_layer, [-1, hidden_size])\n        logits = tf.matmul(output_layer, output_weight, transpose_b=True)\n        logits = tf.nn.bias_add(logits, output_bias)\n        logits = tf.reshape(logits, [-1, FLAGS.max_seq_length, num_labels])\n        # mask = tf.cast(input_mask,tf.float32)\n        # loss = tf.contrib.seq2seq.sequence_loss(logits,labels,mask)\n        # return (loss, logits, predict)\n        ##########################################################################\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n        per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n        mask = tf.cast(label_mask, tf.float32)\n        mask_example_loss = per_example_loss * mask\n        loss = tf.reduce_sum(mask_example_loss)\n        probabilities = tf.nn.softmax(logits, axis=-1)\n        predict = tf.argmax(probabilities, axis=-1)\n        return (loss, mask_example_loss, logits, predict)\n        ##########################################################################\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n    def model_fn(features, labels, mode, params):\n        tf.logging.info(""*** Features ***"")\n        for name in sorted(features.keys()):\n            tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n        input_ids = features[""input_ids""]\n        input_mask = features[""input_mask""]\n        segment_ids = features[""segment_ids""]\n        label_ids = features[""label_ids""]\n        label_mask = features[""label_mask""]\n        is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n        (total_loss, per_example_loss, logits, predicts) = create_model(\n            bert_config, is_training, input_ids, input_mask, label_mask, segment_ids, label_ids,\n            num_labels, use_one_hot_embeddings)\n        tvars = tf.trainable_variables()\n        scaffold_fn = None\n        if init_checkpoint:\n            (assignment_map, initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(tvars,\n                                                                                                       init_checkpoint)\n            tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n            if use_tpu:\n                def tpu_scaffold():\n                    tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n                    return tf.train.Scaffold()\n\n                scaffold_fn = tpu_scaffold\n            else:\n                tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        tf.logging.info(""**** Trainable Variables ****"")\n\n        for var in tvars:\n            init_string = """"\n            if var.name in initialized_variable_names:\n                init_string = "", *INIT_FROM_CKPT*""\n            tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                            init_string)\n        output_spec = None\n        if mode == tf.estimator.ModeKeys.TRAIN:\n            train_op = optimization.create_optimizer(\n                total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n            hook_dict = {}\n            hook_dict[\'loss\'] = total_loss\n            hook_dict[\'global_steps\'] = tf.train.get_or_create_global_step()\n            logging_hook = tf.train.LoggingTensorHook(\n                hook_dict, every_n_iter=200)\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                train_op=train_op,\n                scaffold_fn=scaffold_fn,\n                training_hooks=[logging_hook])\n        elif mode == tf.estimator.ModeKeys.EVAL:\n\n            def metric_fn(per_example_loss, label_ids, logits):\n                # def metric_fn(label_ids, logits):\n                predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n                # labels = []\n                # for i, x in enumerate()\n                predict_labels = []\n                # for i in range(1, num_labels - 4):\n                #     predict_labels.append(i)\n                # precision = tf_metrics.precision(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # recall = tf_metrics.recall(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # f = tf_metrics.f1(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n\n                precision = tf_metrics.precision(label_ids, predictions, num_labels, average=""macro"")\n                recall = tf_metrics.recall(label_ids, predictions, num_labels, average=""macro"")\n                f = tf_metrics.f1(label_ids, predictions, num_labels, average=""macro"")\n\n                #\n                return {\n                    ""eval_precision"": precision,\n                    ""eval_recall"": recall,\n                    ""eval_f"": f,\n                    # ""eval_loss"": loss,\n                }\n\n            eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n            # eval_metrics = (metric_fn, [label_ids, logits])\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                eval_metrics=eval_metrics,\n                scaffold_fn=scaffold_fn)\n        else:\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode, predictions=predicts, scaffold_fn=scaffold_fn\n            )\n        return output_spec\n\n    return model_fn\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    processors = {\n        ""ner"": NerProcessor,\n        ""weiboner"": WeiboNERProcessor,\n        ""msraner"": MsraNERProcessor\n    }\n    # if not FLAGS.do_train and not FLAGS.do_eval:\n    #     raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n    bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n    if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n        raise ValueError(\n            ""Cannot use sequence length %d because the BERT model ""\n            ""was only trained up to sequence length %d"" %\n            (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n    if not os.path.exists(FLAGS.output_dir):\n        os.mkdir(FLAGS.output_dir)\n    task_name = FLAGS.task_name.lower()\n    if task_name not in processors:\n        raise ValueError(""Task not found: %s"" % (task_name))\n    processor = processors[task_name]()\n\n    label_list = processor.get_labels()\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    tpu_cluster_resolver = None\n    if FLAGS.use_tpu and FLAGS.tpu_name:\n        tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n            FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n    is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n\n    run_config = tf.contrib.tpu.RunConfig(\n        cluster=tpu_cluster_resolver,\n        master=FLAGS.master,\n        model_dir=FLAGS.output_dir,\n        save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n        tpu_config=tf.contrib.tpu.TPUConfig(\n            iterations_per_loop=FLAGS.iterations_per_loop,\n            num_shards=FLAGS.num_tpu_cores,\n            per_host_input_for_training=is_per_host))\n\n    train_examples = None\n    num_train_steps = None\n    num_warmup_steps = None\n\n    if FLAGS.do_train:\n        train_examples = processor.get_train_examples(FLAGS.data_dir)\n        num_train_steps = int(\n            len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n        print(num_train_steps)\n        num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    model_fn = model_fn_builder(\n        bert_config=bert_config,\n        num_labels=len(label_list) + 1,\n        init_checkpoint=FLAGS.init_checkpoint,\n        learning_rate=FLAGS.learning_rate,\n        num_train_steps=num_train_steps,\n        num_warmup_steps=num_warmup_steps,\n        use_tpu=FLAGS.use_tpu,\n        use_one_hot_embeddings=FLAGS.use_tpu)\n\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n\n    if FLAGS.do_train:\n        train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file, FLAGS.output_dir)\n        tf.logging.info(""***** Running training *****"")\n        tf.logging.info(""  Num examples = %d"", len(train_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n        tf.logging.info(""  Num steps = %d"", num_train_steps)\n        train_input_fn = file_based_input_fn_builder(\n            input_file=train_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=True,\n            drop_remainder=True)\n        estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n    if FLAGS.do_eval:\n        eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n        eval_file = os.path.join(FLAGS.output_dir, ""eval.tf_record"")\n        file_based_convert_examples_to_features(\n            eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file, FLAGS.output_dir)\n\n        tf.logging.info(""***** Running evaluation *****"")\n        tf.logging.info(""  Num examples = %d"", len(eval_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n        eval_steps = None\n        if FLAGS.use_tpu:\n            eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n        eval_drop_remainder = True if FLAGS.use_tpu else False\n        eval_input_fn = file_based_input_fn_builder(\n            input_file=eval_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=eval_drop_remainder)\n        result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n        output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            tf.logging.info(""***** Eval results *****"")\n            for key in sorted(result.keys()):\n                tf.logging.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\n    if FLAGS.do_predict:\n\n        pred_tags = []\n        true_tags = []\n\n        token_path = os.path.join(FLAGS.output_dir, ""token_test.txt"")\n        label_file = os.path.join(FLAGS.output_dir, ""label2id.pkl"")\n        label_masks = []\n        with open(label_file, ""rb"") as rf:\n            label2id = pickle.load(rf)\n            id2label = {value: key for key, value in label2id.items()}\n        if os.path.exists(token_path):\n            os.remove(token_path)\n        predict_examples = processor.get_test_examples(FLAGS.data_dir)\n        ground_truth_file = os.path.join(FLAGS.output_dir, ""ground_truth.txt"")\n        with open(ground_truth_file, \'w\') as writer:\n            for ex_index, example in enumerate(predict_examples):\n                feature = convert_single_example(ex_index, example, label_list, FLAGS.max_seq_length, tokenizer, FLAGS.output_dir, ""test"")\n                line = []\n                for i, id in enumerate(feature.label_ids):\n                    if feature.label_mask[i] == 1:\n                        line.append(id2label[id])\n                        true_tags.append(id2label[id])\n                # output_line = "" "".join(id2label[id] for id in feature.label_ids if id != 0) + ""\\n""\n                output_line = "" "".join(line) + ""\\n""\n                writer.write(output_line)\n                label_masks.append(feature.label_mask)\n        predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n        file_based_convert_examples_to_features(predict_examples, label_list,\n                                                 FLAGS.max_seq_length, tokenizer,\n                                                 predict_file, FLAGS.output_dir, mode=""test"")\n\n        tf.logging.info(""***** Running prediction*****"")\n        tf.logging.info(""  Num examples = %d"", len(predict_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n        if FLAGS.use_tpu:\n            # Warning: According to tpu_estimator.py Prediction on TPU is an\n            # experimental feature and hence not supported here\n            raise ValueError(""Prediction in TPU not supported"")\n        predict_drop_remainder = True if FLAGS.use_tpu else False\n        predict_input_fn = file_based_input_fn_builder(\n            input_file=predict_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=predict_drop_remainder)\n\n        result = estimator.predict(input_fn=predict_input_fn)\n        output_predict_file = os.path.join(FLAGS.output_dir, ""label_test.txt"")\n\n        with open(output_predict_file, \'w\') as writer:\n            for i, prediction in enumerate(result):\n                line = []\n                for j, x in enumerate(prediction):\n                    if label_masks[i][j] == 0:\n                        continue\n                    else:\n                        line.append(id2label[x])\n                        # writer.write(id2label[x] + ""\\n"")\n                        pred_tags.append(id2label[x])\n                output_line = "" "".join(line) + ""\\n""\n                # # output_line = "" "".join(id2label[id] for id in prediction if id != 0) + ""\\n""\n                writer.write(output_line)\n        # evaluate(true_tags, pred_tags, verbose=True)\n        # evaluate(true_tags, pred_tags)\n\n        tmp = codecs.open(os.path.join(FLAGS.output_dir, ""tmp""), \'w\', \'utf8\')\n        with codecs.open(ground_truth_file, \'r\', \'utf8\') as ft, codecs.open(output_predict_file, \'r\', \'utf8\') as fg:\n            for lt, lg in zip(ft, fg):\n                for tl, tg in zip(lt.strip().split(), lg.strip().split()):\n                    print(\'\\t\'.join(["" "", tl, tg]), file=tmp)\n        tmp.close()\n        cmd = ""python %s -d \'\\t\' < %s > %s"" % \\\n                (os.path.join(os.getcwd(), ""conlleval.py""), \\\n                os.path.join(FLAGS.output_dir, ""tmp""), \\\n                os.path.join(FLAGS.data_dir, ""test_results_ernie_base.txt""))\n        os.system(cmd)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""data_dir"")\n    flags.mark_flag_as_required(""task_name"")\n    flags.mark_flag_as_required(""vocab_file"")\n    flags.mark_flag_as_required(""bert_config_file"")\n    flags.mark_flag_as_required(""output_dir"")\n    tf.app.run()\n'"
baselines/models/ernie/run_pretraining.py,97,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run masked LM/next sentence masked_lm pre-training for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport modeling\nimport optimization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(\n    ""input_file"", None,\n    ""Input TF example files (can be a glob or comma separated)."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded. Must match data generation."")\n\nflags.DEFINE_integer(\n    ""max_predictions_per_seq"", 20,\n    ""Maximum number of masked LM predictions per sequence. ""\n    ""Must match data generation."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_integer(""num_train_steps"", 100000, ""Number of training steps."")\n\nflags.DEFINE_integer(""num_warmup_steps"", 10000, ""Number of warmup steps."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(""max_eval_steps"", 100, ""Maximum number of eval steps."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    masked_lm_positions = features[""masked_lm_positions""]\n    masked_lm_ids = features[""masked_lm_ids""]\n    masked_lm_weights = features[""masked_lm_weights""]\n    next_sentence_labels = features[""next_sentence_labels""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    (masked_lm_loss,\n     masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(\n         bert_config, model.get_sequence_output(), model.get_embedding_table(),\n         masked_lm_positions, masked_lm_ids, masked_lm_weights)\n\n    (next_sentence_loss, next_sentence_example_loss,\n     next_sentence_log_probs) = get_next_sentence_output(\n         bert_config, model.get_pooled_output(), next_sentence_labels)\n\n    total_loss = masked_lm_loss + next_sentence_loss\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n                    masked_lm_weights, next_sentence_example_loss,\n                    next_sentence_log_probs, next_sentence_labels):\n        """"""Computes the loss and accuracy of the model.""""""\n        masked_lm_log_probs = tf.reshape(masked_lm_log_probs,\n                                         [-1, masked_lm_log_probs.shape[-1]])\n        masked_lm_predictions = tf.argmax(\n            masked_lm_log_probs, axis=-1, output_type=tf.int32)\n        masked_lm_example_loss = tf.reshape(masked_lm_example_loss, [-1])\n        masked_lm_ids = tf.reshape(masked_lm_ids, [-1])\n        masked_lm_weights = tf.reshape(masked_lm_weights, [-1])\n        masked_lm_accuracy = tf.metrics.accuracy(\n            labels=masked_lm_ids,\n            predictions=masked_lm_predictions,\n            weights=masked_lm_weights)\n        masked_lm_mean_loss = tf.metrics.mean(\n            values=masked_lm_example_loss, weights=masked_lm_weights)\n\n        next_sentence_log_probs = tf.reshape(\n            next_sentence_log_probs, [-1, next_sentence_log_probs.shape[-1]])\n        next_sentence_predictions = tf.argmax(\n            next_sentence_log_probs, axis=-1, output_type=tf.int32)\n        next_sentence_labels = tf.reshape(next_sentence_labels, [-1])\n        next_sentence_accuracy = tf.metrics.accuracy(\n            labels=next_sentence_labels, predictions=next_sentence_predictions)\n        next_sentence_mean_loss = tf.metrics.mean(\n            values=next_sentence_example_loss)\n\n        return {\n            ""masked_lm_accuracy"": masked_lm_accuracy,\n            ""masked_lm_loss"": masked_lm_mean_loss,\n            ""next_sentence_accuracy"": next_sentence_accuracy,\n            ""next_sentence_loss"": next_sentence_mean_loss,\n        }\n\n      eval_metrics = (metric_fn, [\n          masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n          masked_lm_weights, next_sentence_example_loss,\n          next_sentence_log_probs, next_sentence_labels\n      ])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(""Only TRAIN and EVAL modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef get_masked_lm_output(bert_config, input_tensor, output_weights, positions,\n                         label_ids, label_weights):\n  """"""Get loss and log probs for the masked LM.""""""\n  input_tensor = gather_indexes(input_tensor, positions)\n\n  with tf.variable_scope(""cls/predictions""):\n    # We apply one more non-linear transformation before the output layer.\n    # This matrix is not used after pre-training.\n    with tf.variable_scope(""transform""):\n      input_tensor = tf.layers.dense(\n          input_tensor,\n          units=bert_config.hidden_size,\n          activation=modeling.get_activation(bert_config.hidden_act),\n          kernel_initializer=modeling.create_initializer(\n              bert_config.initializer_range))\n      input_tensor = modeling.layer_norm(input_tensor)\n\n    # The output weights are the same as the input embeddings, but there is\n    # an output-only bias for each token.\n    output_bias = tf.get_variable(\n        ""output_bias"",\n        shape=[bert_config.vocab_size],\n        initializer=tf.zeros_initializer())\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    label_ids = tf.reshape(label_ids, [-1])\n    label_weights = tf.reshape(label_weights, [-1])\n\n    one_hot_labels = tf.one_hot(\n        label_ids, depth=bert_config.vocab_size, dtype=tf.float32)\n\n    # The `positions` tensor might be zero-padded (if the sequence is too\n    # short to have the maximum number of predictions). The `label_weights`\n    # tensor has a value of 1.0 for every real prediction and 0.0 for the\n    # padding predictions.\n    per_example_loss = -tf.reduce_sum(log_probs * one_hot_labels, axis=[-1])\n    numerator = tf.reduce_sum(label_weights * per_example_loss)\n    denominator = tf.reduce_sum(label_weights) + 1e-5\n    loss = numerator / denominator\n\n  return (loss, per_example_loss, log_probs)\n\n\ndef get_next_sentence_output(bert_config, input_tensor, labels):\n  """"""Get loss and log probs for the next sentence prediction.""""""\n\n  # Simple binary classification. Note that 0 is ""next sentence"" and 1 is\n  # ""random sentence"". This weight matrix is not used after pre-training.\n  with tf.variable_scope(""cls/seq_relationship""):\n    output_weights = tf.get_variable(\n        ""output_weights"",\n        shape=[2, bert_config.hidden_size],\n        initializer=modeling.create_initializer(bert_config.initializer_range))\n    output_bias = tf.get_variable(\n        ""output_bias"", shape=[2], initializer=tf.zeros_initializer())\n\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n    labels = tf.reshape(labels, [-1])\n    one_hot_labels = tf.one_hot(labels, depth=2, dtype=tf.float32)\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n    return (loss, per_example_loss, log_probs)\n\n\ndef gather_indexes(sequence_tensor, positions):\n  """"""Gathers the vectors at the specific positions over a minibatch.""""""\n  sequence_shape = modeling.get_shape_list(sequence_tensor, expected_rank=3)\n  batch_size = sequence_shape[0]\n  seq_length = sequence_shape[1]\n  width = sequence_shape[2]\n\n  flat_offsets = tf.reshape(\n      tf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n  flat_positions = tf.reshape(positions + flat_offsets, [-1])\n  flat_sequence_tensor = tf.reshape(sequence_tensor,\n                                    [batch_size * seq_length, width])\n  output_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n  return output_tensor\n\n\ndef input_fn_builder(input_files,\n                     max_seq_length,\n                     max_predictions_per_seq,\n                     is_training,\n                     num_cpu_threads=4):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    name_to_features = {\n        ""input_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""input_mask"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""segment_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""masked_lm_positions"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_ids"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_weights"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.float32),\n        ""next_sentence_labels"":\n            tf.FixedLenFeature([1], tf.int64),\n    }\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = tf.data.Dataset.from_tensor_slices(tf.constant(input_files))\n      d = d.repeat()\n      d = d.shuffle(buffer_size=len(input_files))\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_cpu_threads, len(input_files))\n\n      # `sloppy` mode means that the interleaving is not exact. This adds\n      # even more randomness to the training pipeline.\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n      d = d.shuffle(buffer_size=100)\n    else:\n      d = tf.data.TFRecordDataset(input_files)\n      # Since we evaluate for a fixed number of steps we don\'t want to encounter\n      # out-of-range exceptions.\n      d = d.repeat()\n\n    # We must `drop_remainder` on training because the TPU requires fixed\n    # size dimensions. For eval, we assume we are evaluating on the CPU or GPU\n    # and we *don\'t* want to drop the remainder, otherwise we wont cover\n    # every sample.\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_cpu_threads,\n            drop_remainder=True))\n    return d\n\n  return input_fn\n\n\ndef _decode_record(record, name_to_features):\n  """"""Decodes a record to a TensorFlow example.""""""\n  example = tf.parse_single_example(record, name_to_features)\n\n  # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n  # So cast all int64 to int32.\n  for name in list(example.keys()):\n    t = example[name]\n    if t.dtype == tf.int64:\n      t = tf.to_int32(t)\n    example[name] = t\n\n  return example\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Input Files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"" % input_file)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=FLAGS.num_train_steps,\n      num_warmup_steps=FLAGS.num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size)\n\n  if FLAGS.do_train:\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    train_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=True)\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.num_train_steps)\n\n  if FLAGS.do_eval:\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    eval_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=False)\n\n    result = estimator.evaluate(\n        input_fn=eval_input_fn, steps=FLAGS.max_eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/ernie/run_squad.py,93,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run BERT on SQuAD 1.1 and SQuAD 2.0.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport math\nimport os\nimport random\nimport modeling\nimport optimization\nimport tokenization\nimport six\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(""train_file"", None,\n                    ""SQuAD json for training. E.g., train-v1.1.json"")\n\nflags.DEFINE_string(\n    ""predict_file"", None,\n    ""SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json"")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 384,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_integer(\n    ""doc_stride"", 128,\n    ""When splitting up a long document into chunks, how much stride to ""\n    ""take between chunks."")\n\nflags.DEFINE_integer(\n    ""max_query_length"", 64,\n    ""The maximum number of tokens for the question. Questions longer than ""\n    ""this will be truncated to this length."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8,\n                     ""Total batch size for predictions."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(\n    ""n_best_size"", 20,\n    ""The total number of n-best predictions to generate in the ""\n    ""nbest_predictions.json output file."")\n\nflags.DEFINE_integer(\n    ""max_answer_length"", 30,\n    ""The maximum length of an answer that can be generated. This is needed ""\n    ""because the start and end predictions are not conditioned on one another."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""verbose_logging"", False,\n    ""If true, all of the warnings related to data processing will be printed. ""\n    ""A number of warnings are expected for a normal SQuAD evaluation."")\n\nflags.DEFINE_bool(\n    ""version_2_with_negative"", False,\n    ""If true, the SQuAD examples contain some that do not have an answer."")\n\nflags.DEFINE_float(\n    ""null_score_diff_threshold"", 0.0,\n    ""If null_score - best_non_null is greater than the threshold predict null."")\n\n\nclass SquadExample(object):\n  """"""A single training/test example for simple sequence classification.\n\n     For examples without an answer, the start and end position are -1.\n  """"""\n\n  def __init__(self,\n               qas_id,\n               question_text,\n               doc_tokens,\n               orig_answer_text=None,\n               start_position=None,\n               end_position=None,\n               is_impossible=False):\n    self.qas_id = qas_id\n    self.question_text = question_text\n    self.doc_tokens = doc_tokens\n    self.orig_answer_text = orig_answer_text\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n  def __str__(self):\n    return self.__repr__()\n\n  def __repr__(self):\n    s = """"\n    s += ""qas_id: %s"" % (tokenization.printable_text(self.qas_id))\n    s += "", question_text: %s"" % (\n        tokenization.printable_text(self.question_text))\n    s += "", doc_tokens: [%s]"" % ("" "".join(self.doc_tokens))\n    if self.start_position:\n      s += "", start_position: %d"" % (self.start_position)\n    if self.start_position:\n      s += "", end_position: %d"" % (self.end_position)\n    if self.start_position:\n      s += "", is_impossible: %r"" % (self.is_impossible)\n    return s\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tokens,\n               token_to_orig_map,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               segment_ids,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tokens = tokens\n    self.token_to_orig_map = token_to_orig_map\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\ndef read_squad_examples(input_file, is_training):\n  """"""Read a SQuAD json file into a list of SquadExample.""""""\n  with tf.gfile.Open(input_file, ""r"") as reader:\n    input_data = json.load(reader)[""data""]\n\n  def is_whitespace(c):\n    if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F:\n      return True\n    return False\n\n  examples = []\n  for entry in input_data:\n    for paragraph in entry[""paragraphs""]:\n      paragraph_text = paragraph[""context""]\n      doc_tokens = []\n      char_to_word_offset = []\n      prev_is_whitespace = True\n      for c in paragraph_text:\n        if is_whitespace(c):\n          prev_is_whitespace = True\n        else:\n          if prev_is_whitespace:\n            doc_tokens.append(c)\n          else:\n            doc_tokens[-1] += c\n          prev_is_whitespace = False\n        char_to_word_offset.append(len(doc_tokens) - 1)\n\n      for qa in paragraph[""qas""]:\n        qas_id = qa[""id""]\n        question_text = qa[""question""]\n        start_position = None\n        end_position = None\n        orig_answer_text = None\n        is_impossible = False\n        if is_training:\n\n          if FLAGS.version_2_with_negative:\n            is_impossible = qa[""is_impossible""]\n          if (len(qa[""answers""]) != 1) and (not is_impossible):\n            raise ValueError(\n                ""For training, each question should have exactly 1 answer."")\n          if not is_impossible:\n            answer = qa[""answers""][0]\n            orig_answer_text = answer[""text""]\n            answer_offset = answer[""answer_start""]\n            answer_length = len(orig_answer_text)\n            start_position = char_to_word_offset[answer_offset]\n            end_position = char_to_word_offset[answer_offset + answer_length -\n                                               1]\n            # Only add answers where the text can be exactly recovered from the\n            # document. If this CAN\'T happen it\'s likely due to weird Unicode\n            # stuff so we will just skip the example.\n            #\n            # Note that this means for training mode, every example is NOT\n            # guaranteed to be preserved.\n            actual_text = "" "".join(\n                doc_tokens[start_position:(end_position + 1)])\n            cleaned_answer_text = "" "".join(\n                tokenization.whitespace_tokenize(orig_answer_text))\n            if actual_text.find(cleaned_answer_text) == -1:\n              tf.logging.warning(""Could not find answer: \'%s\' vs. \'%s\'"",\n                                 actual_text, cleaned_answer_text)\n              continue\n          else:\n            start_position = -1\n            end_position = -1\n            orig_answer_text = """"\n\n        example = SquadExample(\n            qas_id=qas_id,\n            question_text=question_text,\n            doc_tokens=doc_tokens,\n            orig_answer_text=orig_answer_text,\n            start_position=start_position,\n            end_position=end_position,\n            is_impossible=is_impossible)\n        examples.append(example)\n\n  return examples\n\n\ndef convert_examples_to_features(examples, tokenizer, max_seq_length,\n                                 doc_stride, max_query_length, is_training,\n                                 output_fn):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  unique_id = 1000000000\n\n  for (example_index, example) in enumerate(examples):\n    query_tokens = tokenizer.tokenize(example.question_text)\n\n    if len(query_tokens) > max_query_length:\n      query_tokens = query_tokens[0:max_query_length]\n\n    tok_to_orig_index = []\n    orig_to_tok_index = []\n    all_doc_tokens = []\n    for (i, token) in enumerate(example.doc_tokens):\n      orig_to_tok_index.append(len(all_doc_tokens))\n      sub_tokens = tokenizer.tokenize(token)\n      for sub_token in sub_tokens:\n        tok_to_orig_index.append(i)\n        all_doc_tokens.append(sub_token)\n\n    tok_start_position = None\n    tok_end_position = None\n    if is_training and example.is_impossible:\n      tok_start_position = -1\n      tok_end_position = -1\n    if is_training and not example.is_impossible:\n      tok_start_position = orig_to_tok_index[example.start_position]\n      if example.end_position < len(example.doc_tokens) - 1:\n        tok_end_position = orig_to_tok_index[example.end_position + 1] - 1\n      else:\n        tok_end_position = len(all_doc_tokens) - 1\n      (tok_start_position, tok_end_position) = _improve_answer_span(\n          all_doc_tokens, tok_start_position, tok_end_position, tokenizer,\n          example.orig_answer_text)\n\n    # The -3 accounts for [CLS], [SEP] and [SEP]\n    max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n    # We can have documents that are longer than the maximum sequence length.\n    # To deal with this we do a sliding window approach, where we take chunks\n    # of the up to our max length with a stride of `doc_stride`.\n    _DocSpan = collections.namedtuple(  # pylint: disable=invalid-name\n        ""DocSpan"", [""start"", ""length""])\n    doc_spans = []\n    start_offset = 0\n    while start_offset < len(all_doc_tokens):\n      length = len(all_doc_tokens) - start_offset\n      if length > max_tokens_for_doc:\n        length = max_tokens_for_doc\n      doc_spans.append(_DocSpan(start=start_offset, length=length))\n      if start_offset + length == len(all_doc_tokens):\n        break\n      start_offset += min(length, doc_stride)\n\n    for (doc_span_index, doc_span) in enumerate(doc_spans):\n      tokens = []\n      token_to_orig_map = {}\n      token_is_max_context = {}\n      segment_ids = []\n      tokens.append(""[CLS]"")\n      segment_ids.append(0)\n      for token in query_tokens:\n        tokens.append(token)\n        segment_ids.append(0)\n      tokens.append(""[SEP]"")\n      segment_ids.append(0)\n\n      for i in range(doc_span.length):\n        split_token_index = doc_span.start + i\n        token_to_orig_map[len(tokens)] = tok_to_orig_index[split_token_index]\n\n        is_max_context = _check_is_max_context(doc_spans, doc_span_index,\n                                               split_token_index)\n        token_is_max_context[len(tokens)] = is_max_context\n        tokens.append(all_doc_tokens[split_token_index])\n        segment_ids.append(1)\n      tokens.append(""[SEP]"")\n      segment_ids.append(1)\n\n      input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n      # The mask has 1 for real tokens and 0 for padding tokens. Only real\n      # tokens are attended to.\n      input_mask = [1] * len(input_ids)\n\n      # Zero-pad up to the sequence length.\n      while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n\n      assert len(input_ids) == max_seq_length\n      assert len(input_mask) == max_seq_length\n      assert len(segment_ids) == max_seq_length\n\n      start_position = None\n      end_position = None\n      if is_training and not example.is_impossible:\n        # For training, if our document chunk does not contain an annotation\n        # we throw it out, since there is nothing to predict.\n        doc_start = doc_span.start\n        doc_end = doc_span.start + doc_span.length - 1\n        out_of_span = False\n        if not (tok_start_position >= doc_start and\n                tok_end_position <= doc_end):\n          out_of_span = True\n        if out_of_span:\n          start_position = 0\n          end_position = 0\n        else:\n          doc_offset = len(query_tokens) + 2\n          start_position = tok_start_position - doc_start + doc_offset\n          end_position = tok_end_position - doc_start + doc_offset\n\n      if is_training and example.is_impossible:\n        start_position = 0\n        end_position = 0\n\n      if example_index < 20:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""unique_id: %s"" % (unique_id))\n        tf.logging.info(""example_index: %s"" % (example_index))\n        tf.logging.info(""doc_span_index: %s"" % (doc_span_index))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""token_to_orig_map: %s"" % "" "".join(\n            [""%d:%d"" % (x, y) for (x, y) in six.iteritems(token_to_orig_map)]))\n        tf.logging.info(""token_is_max_context: %s"" % "" "".join([\n            ""%d:%s"" % (x, y) for (x, y) in six.iteritems(token_is_max_context)\n        ]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(\n            ""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(\n            ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        if is_training and example.is_impossible:\n          tf.logging.info(""impossible example"")\n        if is_training and not example.is_impossible:\n          answer_text = "" "".join(tokens[start_position:(end_position + 1)])\n          tf.logging.info(""start_position: %d"" % (start_position))\n          tf.logging.info(""end_position: %d"" % (end_position))\n          tf.logging.info(\n              ""answer: %s"" % (tokenization.printable_text(answer_text)))\n\n      feature = InputFeatures(\n          unique_id=unique_id,\n          example_index=example_index,\n          doc_span_index=doc_span_index,\n          tokens=tokens,\n          token_to_orig_map=token_to_orig_map,\n          token_is_max_context=token_is_max_context,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          segment_ids=segment_ids,\n          start_position=start_position,\n          end_position=end_position,\n          is_impossible=example.is_impossible)\n\n      # Run callback\n      output_fn(feature)\n\n      unique_id += 1\n\n\ndef _improve_answer_span(doc_tokens, input_start, input_end, tokenizer,\n                         orig_answer_text):\n  """"""Returns tokenized answer spans that better match the annotated answer.""""""\n\n  # The SQuAD annotations are character based. We first project them to\n  # whitespace-tokenized words. But then after WordPiece tokenization, we can\n  # often find a ""better match"". For example:\n  #\n  #   Question: What year was John Smith born?\n  #   Context: The leader was John Smith (1895-1943).\n  #   Answer: 1895\n  #\n  # The original whitespace-tokenized answer will be ""(1895-1943)."". However\n  # after tokenization, our tokens will be ""( 1895 - 1943 ) ."". So we can match\n  # the exact answer, 1895.\n  #\n  # However, this is not always possible. Consider the following:\n  #\n  #   Question: What country is the top exporter of electornics?\n  #   Context: The Japanese electronics industry is the lagest in the world.\n  #   Answer: Japan\n  #\n  # In this case, the annotator chose ""Japan"" as a character sub-span of\n  # the word ""Japanese"". Since our WordPiece tokenizer does not split\n  # ""Japanese"", we just use ""Japanese"" as the annotation. This is fairly rare\n  # in SQuAD, but does happen.\n  tok_answer_text = "" "".join(tokenizer.tokenize(orig_answer_text))\n\n  for new_start in range(input_start, input_end + 1):\n    for new_end in range(input_end, new_start - 1, -1):\n      text_span = "" "".join(doc_tokens[new_start:(new_end + 1)])\n      if text_span == tok_answer_text:\n        return (new_start, new_end)\n\n  return (input_start, input_end)\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n  """"""Check if this is the \'max context\' doc span for the token.""""""\n\n  # Because of the sliding window approach taken to scoring documents, a single\n  # token can appear in multiple documents. E.g.\n  #  Doc: the man went to the store and bought a gallon of milk\n  #  Span A: the man went to the\n  #  Span B: to the store and bought\n  #  Span C: and bought a gallon of\n  #  ...\n  #\n  # Now the word \'bought\' will have two scores from spans B and C. We only\n  # want to consider the score with ""maximum context"", which we define as\n  # the *minimum* of its left and right context (the *sum* of left and\n  # right context will always be the same, of course).\n  #\n  # In the example the maximum context for \'bought\' would be span C since\n  # it has 1 left context and 3 right context, while span B has 4 left context\n  # and 0 right context.\n  best_score = None\n  best_span_index = None\n  for (span_index, doc_span) in enumerate(doc_spans):\n    end = doc_span.start + doc_span.length - 1\n    if position < doc_span.start:\n      continue\n    if position > end:\n      continue\n    num_left_context = position - doc_span.start\n    num_right_context = end - position\n    score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n    if best_score is None or score > best_score:\n      best_score = score\n      best_span_index = span_index\n\n  return cur_span_index == best_span_index\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  final_hidden = model.get_sequence_output()\n\n  final_hidden_shape = modeling.get_shape_list(final_hidden, expected_rank=3)\n  batch_size = final_hidden_shape[0]\n  seq_length = final_hidden_shape[1]\n  hidden_size = final_hidden_shape[2]\n\n  output_weights = tf.get_variable(\n      ""cls/squad/output_weights"", [2, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""cls/squad/output_bias"", [2], initializer=tf.zeros_initializer())\n\n  final_hidden_matrix = tf.reshape(final_hidden,\n                                   [batch_size * seq_length, hidden_size])\n  logits = tf.matmul(final_hidden_matrix, output_weights, transpose_b=True)\n  logits = tf.nn.bias_add(logits, output_bias)\n\n  logits = tf.reshape(logits, [batch_size, seq_length, 2])\n  logits = tf.transpose(logits, [2, 0, 1])\n\n  unstacked_logits = tf.unstack(logits, axis=0)\n\n  (start_logits, end_logits) = (unstacked_logits[0], unstacked_logits[1])\n\n  return (start_logits, end_logits)\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (start_logits, end_logits) = create_model(\n        bert_config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      seq_length = modeling.get_shape_list(input_ids)[1]\n\n      def compute_loss(logits, positions):\n        one_hot_positions = tf.one_hot(\n            positions, depth=seq_length, dtype=tf.float32)\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        loss = -tf.reduce_mean(\n            tf.reduce_sum(one_hot_positions * log_probs, axis=-1))\n        return loss\n\n      start_positions = features[""start_positions""]\n      end_positions = features[""end_positions""]\n\n      start_loss = compute_loss(start_logits, start_positions)\n      end_loss = compute_loss(end_logits, end_positions)\n\n      total_loss = (start_loss + end_loss) / 2.0\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      predictions = {\n          ""unique_ids"": unique_ids,\n          ""start_logits"": start_logits,\n          ""end_logits"": end_logits,\n      }\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(\n          ""Only TRAIN and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""unique_ids"": tf.FixedLenFeature([], tf.int64),\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n  }\n\n  if is_training:\n    name_to_features[""start_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""end_positions""] = tf.FixedLenFeature([], tf.int64)\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\nRawResult = collections.namedtuple(""RawResult"",\n                                   [""unique_id"", ""start_logits"", ""end_logits""])\n\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file):\n  """"""Write final predictions to the json file and log-odds of null if needed.""""""\n  tf.logging.info(""Writing predictions to: %s"" % (output_prediction_file))\n  tf.logging.info(""Writing nbest to: %s"" % (output_nbest_file))\n\n  example_index_to_features = collections.defaultdict(list)\n  for feature in all_features:\n    example_index_to_features[feature.example_index].append(feature)\n\n  unique_id_to_result = {}\n  for result in all_results:\n    unique_id_to_result[result.unique_id] = result\n\n  _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n      ""PrelimPrediction"",\n      [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n  all_predictions = collections.OrderedDict()\n  all_nbest_json = collections.OrderedDict()\n  scores_diff_json = collections.OrderedDict()\n\n  for (example_index, example) in enumerate(all_examples):\n    features = example_index_to_features[example_index]\n\n    prelim_predictions = []\n    # keep track of the minimum score of null start+end of position 0\n    score_null = 1000000  # large and positive\n    min_null_feature_index = 0  # the paragraph slice with min mull score\n    null_start_logit = 0  # the start logit at the slice with min null score\n    null_end_logit = 0  # the end logit at the slice with min null score\n    for (feature_index, feature) in enumerate(features):\n      result = unique_id_to_result[feature.unique_id]\n      start_indexes = _get_best_indexes(result.start_logits, n_best_size)\n      end_indexes = _get_best_indexes(result.end_logits, n_best_size)\n      # if we could have irrelevant answers, get the min score of irrelevant\n      if FLAGS.version_2_with_negative:\n        feature_null_score = result.start_logits[0] + result.end_logits[0]\n        if feature_null_score < score_null:\n          score_null = feature_null_score\n          min_null_feature_index = feature_index\n          null_start_logit = result.start_logits[0]\n          null_end_logit = result.end_logits[0]\n      for start_index in start_indexes:\n        for end_index in end_indexes:\n          # We could hypothetically create invalid predictions, e.g., predict\n          # that the start of the span is in the question. We throw out all\n          # invalid predictions.\n          if start_index >= len(feature.tokens):\n            continue\n          if end_index >= len(feature.tokens):\n            continue\n          if start_index not in feature.token_to_orig_map:\n            continue\n          if end_index not in feature.token_to_orig_map:\n            continue\n          if not feature.token_is_max_context.get(start_index, False):\n            continue\n          if end_index < start_index:\n            continue\n          length = end_index - start_index + 1\n          if length > max_answer_length:\n            continue\n          prelim_predictions.append(\n              _PrelimPrediction(\n                  feature_index=feature_index,\n                  start_index=start_index,\n                  end_index=end_index,\n                  start_logit=result.start_logits[start_index],\n                  end_logit=result.end_logits[end_index]))\n\n    if FLAGS.version_2_with_negative:\n      prelim_predictions.append(\n          _PrelimPrediction(\n              feature_index=min_null_feature_index,\n              start_index=0,\n              end_index=0,\n              start_logit=null_start_logit,\n              end_logit=null_end_logit))\n    prelim_predictions = sorted(\n        prelim_predictions,\n        key=lambda x: (x.start_logit + x.end_logit),\n        reverse=True)\n\n    _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n    seen_predictions = {}\n    nbest = []\n    for pred in prelim_predictions:\n      if len(nbest) >= n_best_size:\n        break\n      feature = features[pred.feature_index]\n      if pred.start_index > 0:  # this is a non-null prediction\n        tok_tokens = feature.tokens[pred.start_index:(pred.end_index + 1)]\n        orig_doc_start = feature.token_to_orig_map[pred.start_index]\n        orig_doc_end = feature.token_to_orig_map[pred.end_index]\n        orig_tokens = example.doc_tokens[orig_doc_start:(orig_doc_end + 1)]\n        tok_text = "" "".join(tok_tokens)\n\n        # De-tokenize WordPieces that have been split off.\n        tok_text = tok_text.replace("" ##"", """")\n        tok_text = tok_text.replace(""##"", """")\n\n        # Clean whitespace\n        tok_text = tok_text.strip()\n        tok_text = "" "".join(tok_text.split())\n        orig_text = "" "".join(orig_tokens)\n\n        final_text = get_final_text(tok_text, orig_text, do_lower_case)\n        if final_text in seen_predictions:\n          continue\n\n        seen_predictions[final_text] = True\n      else:\n        final_text = """"\n        seen_predictions[final_text] = True\n\n      nbest.append(\n          _NbestPrediction(\n              text=final_text,\n              start_logit=pred.start_logit,\n              end_logit=pred.end_logit))\n\n    # if we didn\'t inlude the empty option in the n-best, inlcude it\n    if FLAGS.version_2_with_negative:\n      if """" not in seen_predictions:\n        nbest.append(\n            _NbestPrediction(\n                text="""", start_logit=null_start_logit,\n                end_logit=null_end_logit))\n    # In very rare edge cases we could have no valid predictions. So we\n    # just create a nonce prediction in this case to avoid failure.\n    if not nbest:\n      nbest.append(\n          _NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n    assert len(nbest) >= 1\n\n    total_scores = []\n    best_non_null_entry = None\n    for entry in nbest:\n      total_scores.append(entry.start_logit + entry.end_logit)\n      if not best_non_null_entry:\n        if entry.text:\n          best_non_null_entry = entry\n\n    probs = _compute_softmax(total_scores)\n\n    nbest_json = []\n    for (i, entry) in enumerate(nbest):\n      output = collections.OrderedDict()\n      output[""text""] = entry.text\n      output[""probability""] = probs[i]\n      output[""start_logit""] = entry.start_logit\n      output[""end_logit""] = entry.end_logit\n      nbest_json.append(output)\n\n    assert len(nbest_json) >= 1\n\n    if not FLAGS.version_2_with_negative:\n      all_predictions[example.qas_id] = nbest_json[0][""text""]\n    else:\n      # predict """" iff the null score - the score of best non-null > threshold\n      score_diff = score_null - best_non_null_entry.start_logit - (\n          best_non_null_entry.end_logit)\n      scores_diff_json[example.qas_id] = score_diff\n      if score_diff > FLAGS.null_score_diff_threshold:\n        all_predictions[example.qas_id] = """"\n      else:\n        all_predictions[example.qas_id] = best_non_null_entry.text\n\n    all_nbest_json[example.qas_id] = nbest_json\n\n  with tf.gfile.GFile(output_prediction_file, ""w"") as writer:\n    writer.write(json.dumps(all_predictions, indent=4) + ""\\n"")\n\n  with tf.gfile.GFile(output_nbest_file, ""w"") as writer:\n    writer.write(json.dumps(all_nbest_json, indent=4) + ""\\n"")\n\n  if FLAGS.version_2_with_negative:\n    with tf.gfile.GFile(output_null_log_odds_file, ""w"") as writer:\n      writer.write(json.dumps(scores_diff_json, indent=4) + ""\\n"")\n\n\ndef get_final_text(pred_text, orig_text, do_lower_case):\n  """"""Project the tokenized prediction back to the original text.""""""\n\n  # When we created the data, we kept track of the alignment between original\n  # (whitespace tokenized) tokens and our WordPiece tokenized tokens. So\n  # now `orig_text` contains the span of our original text corresponding to the\n  # span that we predicted.\n  #\n  # However, `orig_text` may contain extra characters that we don\'t want in\n  # our prediction.\n  #\n  # For example, let\'s say:\n  #   pred_text = steve smith\n  #   orig_text = Steve Smith\'s\n  #\n  # We don\'t want to return `orig_text` because it contains the extra ""\'s"".\n  #\n  # We don\'t want to return `pred_text` because it\'s already been normalized\n  # (the SQuAD eval script also does punctuation stripping/lower casing but\n  # our tokenizer does additional normalization like stripping accent\n  # characters).\n  #\n  # What we really want to return is ""Steve Smith"".\n  #\n  # Therefore, we have to apply a semi-complicated alignment heruistic between\n  # `pred_text` and `orig_text` to get a character-to-charcter alignment. This\n  # can fail in certain cases in which case we just return `orig_text`.\n\n  def _strip_spaces(text):\n    ns_chars = []\n    ns_to_s_map = collections.OrderedDict()\n    for (i, c) in enumerate(text):\n      if c == "" "":\n        continue\n      ns_to_s_map[len(ns_chars)] = i\n      ns_chars.append(c)\n    ns_text = """".join(ns_chars)\n    return (ns_text, ns_to_s_map)\n\n  # We first tokenize `orig_text`, strip whitespace from the result\n  # and `pred_text`, and check if they are the same length. If they are\n  # NOT the same length, the heuristic has failed. If they are the same\n  # length, we assume the characters are one-to-one aligned.\n  tokenizer = tokenization.BasicTokenizer(do_lower_case=do_lower_case)\n\n  tok_text = "" "".join(tokenizer.tokenize(orig_text))\n\n  start_position = tok_text.find(pred_text)\n  if start_position == -1:\n    if FLAGS.verbose_logging:\n      tf.logging.info(\n          ""Unable to find text: \'%s\' in \'%s\'"" % (pred_text, orig_text))\n    return orig_text\n  end_position = start_position + len(pred_text) - 1\n\n  (orig_ns_text, orig_ns_to_s_map) = _strip_spaces(orig_text)\n  (tok_ns_text, tok_ns_to_s_map) = _strip_spaces(tok_text)\n\n  if len(orig_ns_text) != len(tok_ns_text):\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Length not equal after stripping spaces: \'%s\' vs \'%s\'"",\n                      orig_ns_text, tok_ns_text)\n    return orig_text\n\n  # We then project the characters in `pred_text` back to `orig_text` using\n  # the character-to-character alignment.\n  tok_s_to_ns_map = {}\n  for (i, tok_index) in six.iteritems(tok_ns_to_s_map):\n    tok_s_to_ns_map[tok_index] = i\n\n  orig_start_position = None\n  if start_position in tok_s_to_ns_map:\n    ns_start_position = tok_s_to_ns_map[start_position]\n    if ns_start_position in orig_ns_to_s_map:\n      orig_start_position = orig_ns_to_s_map[ns_start_position]\n\n  if orig_start_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map start position"")\n    return orig_text\n\n  orig_end_position = None\n  if end_position in tok_s_to_ns_map:\n    ns_end_position = tok_s_to_ns_map[end_position]\n    if ns_end_position in orig_ns_to_s_map:\n      orig_end_position = orig_ns_to_s_map[ns_end_position]\n\n  if orig_end_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map end position"")\n    return orig_text\n\n  output_text = orig_text[orig_start_position:(orig_end_position + 1)]\n  return output_text\n\n\ndef _get_best_indexes(logits, n_best_size):\n  """"""Get the n-best logits from a list.""""""\n  index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\n\ndef _compute_softmax(scores):\n  """"""Compute softmax probability over raw logits.""""""\n  if not scores:\n    return []\n\n  max_score = None\n  for score in scores:\n    if max_score is None or score > max_score:\n      max_score = score\n\n  exp_scores = []\n  total_sum = 0.0\n  for score in scores:\n    x = math.exp(score - max_score)\n    exp_scores.append(x)\n    total_sum += x\n\n  probs = []\n  for score in exp_scores:\n    probs.append(score / total_sum)\n  return probs\n\n\nclass FeatureWriter(object):\n  """"""Writes InputFeature to TF example file.""""""\n\n  def __init__(self, filename, is_training):\n    self.filename = filename\n    self.is_training = is_training\n    self.num_features = 0\n    self._writer = tf.python_io.TFRecordWriter(filename)\n\n  def process_feature(self, feature):\n    """"""Write a InputFeature to the TFRecordWriter as a tf.train.Example.""""""\n    self.num_features += 1\n\n    def create_int_feature(values):\n      feature = tf.train.Feature(\n          int64_list=tf.train.Int64List(value=list(values)))\n      return feature\n\n    features = collections.OrderedDict()\n    features[""unique_ids""] = create_int_feature([feature.unique_id])\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n\n    if self.is_training:\n      features[""start_positions""] = create_int_feature([feature.start_position])\n      features[""end_positions""] = create_int_feature([feature.end_position])\n      impossible = 0\n      if feature.is_impossible:\n        impossible = 1\n      features[""is_impossible""] = create_int_feature([impossible])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    self._writer.write(tf_example.SerializeToString())\n\n  def close(self):\n    self._writer.close()\n\n\ndef validate_flags_or_throw(bert_config):\n  """"""Validate the input FLAGS or throw an exception.""""""\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_predict:\n    raise ValueError(""At least one of `do_train` or `do_predict` must be True."")\n\n  if FLAGS.do_train:\n    if not FLAGS.train_file:\n      raise ValueError(\n          ""If `do_train` is True, then `train_file` must be specified."")\n  if FLAGS.do_predict:\n    if not FLAGS.predict_file:\n      raise ValueError(\n          ""If `do_predict` is True, then `predict_file` must be specified."")\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  if FLAGS.max_seq_length <= FLAGS.max_query_length + 3:\n    raise ValueError(\n        ""The max_seq_length (%d) must be greater than max_query_length ""\n        ""(%d) + 3"" % (FLAGS.max_seq_length, FLAGS.max_query_length))\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  validate_flags_or_throw(bert_config)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = read_squad_examples(\n        input_file=FLAGS.train_file, is_training=True)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    # Pre-shuffle the input to avoid having to make a very large shuffle\n    # buffer in in the `input_fn`.\n    rng = random.Random(12345)\n    rng.shuffle(train_examples)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    # We write to a temporary file to avoid storing very large constant tensors\n    # in memory.\n    train_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""train.tf_record""),\n        is_training=True)\n    convert_examples_to_features(\n        examples=train_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=True,\n        output_fn=train_writer.process_feature)\n    train_writer.close()\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(train_examples))\n    tf.logging.info(""  Num split examples = %d"", train_writer.num_features)\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    del train_examples\n\n    train_input_fn = input_fn_builder(\n        input_file=train_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_predict:\n    eval_examples = read_squad_examples(\n        input_file=FLAGS.predict_file, is_training=False)\n\n    eval_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""eval.tf_record""),\n        is_training=False)\n    eval_features = []\n\n    def append_feature(feature):\n      eval_features.append(feature)\n      eval_writer.process_feature(feature)\n\n    convert_examples_to_features(\n        examples=eval_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=False,\n        output_fn=append_feature)\n    eval_writer.close()\n\n    tf.logging.info(""***** Running predictions *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(eval_examples))\n    tf.logging.info(""  Num split examples = %d"", len(eval_features))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    all_results = []\n\n    predict_input_fn = input_fn_builder(\n        input_file=eval_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=False)\n\n    # If running eval on the TPU, you will need to specify the number of\n    # steps.\n    all_results = []\n    for result in estimator.predict(\n        predict_input_fn, yield_single_examples=True):\n      if len(all_results) % 1000 == 0:\n        tf.logging.info(""Processing example: %d"" % (len(all_results)))\n      unique_id = int(result[""unique_ids""])\n      start_logits = [float(x) for x in result[""start_logits""].flat]\n      end_logits = [float(x) for x in result[""end_logits""].flat]\n      all_results.append(\n          RawResult(\n              unique_id=unique_id,\n              start_logits=start_logits,\n              end_logits=end_logits))\n\n    output_prediction_file = os.path.join(FLAGS.output_dir, ""predictions.json"")\n    output_nbest_file = os.path.join(FLAGS.output_dir, ""nbest_predictions.json"")\n    output_null_log_odds_file = os.path.join(FLAGS.output_dir, ""null_odds.json"")\n\n    write_predictions(eval_examples, eval_features, all_results,\n                      FLAGS.n_best_size, FLAGS.max_answer_length,\n                      FLAGS.do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/ernie/tf_metrics.py,22,"b'""""""\r\nMulticlass\r\nfrom: \r\nhttps://github.com/guillaumegenthial/tf_metrics/blob/master/tf_metrics/__init__.py\r\n\r\n""""""\r\n\r\n__author__ = ""Guillaume Genthial""\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops.metrics_impl import _streaming_confusion_matrix\r\n\r\n\r\ndef precision(labels, predictions, num_classes, pos_indices=None,\r\n              weights=None, average=\'micro\'):\r\n    """"""Multi-class precision metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    pr, _, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    op, _, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (pr, op)\r\n\r\n\r\ndef recall(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n           average=\'micro\'):\r\n    """"""Multi-class recall metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, re, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    _, op, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (re, op)\r\n\r\n\r\ndef f1(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n       average=\'micro\'):\r\n    return fbeta(labels, predictions, num_classes, pos_indices, weights,\r\n                 average)\r\n\r\n\r\ndef fbeta(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n          average=\'micro\', beta=1):\r\n    """"""Multi-class fbeta metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, _, fbeta = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average, beta=beta)\r\n    _, _, op = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average, beta=beta)\r\n    return (fbeta, op)\r\n\r\n\r\ndef safe_div(numerator, denominator):\r\n    """"""Safe division, return 0 if denominator is 0""""""\r\n    numerator, denominator = tf.to_float(numerator), tf.to_float(denominator)\r\n    zeros = tf.zeros_like(numerator, dtype=numerator.dtype)\r\n    denominator_is_zero = tf.equal(denominator, zeros)\r\n    return tf.where(denominator_is_zero, zeros, numerator / denominator)\r\n\r\n\r\ndef pr_re_fbeta(cm, pos_indices, beta=1):\r\n    """"""Uses a confusion matrix to compute precision, recall and fbeta""""""\r\n    num_classes = cm.shape[0]\r\n    neg_indices = [i for i in range(num_classes) if i not in pos_indices]\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, neg_indices] = 0\r\n    diag_sum = tf.reduce_sum(tf.diag_part(cm * cm_mask))\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[:, neg_indices] = 0\r\n    tot_pred = tf.reduce_sum(cm * cm_mask)\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, :] = 0\r\n    tot_gold = tf.reduce_sum(cm * cm_mask)\r\n\r\n    pr = safe_div(diag_sum, tot_pred)\r\n    re = safe_div(diag_sum, tot_gold)\r\n    fbeta = safe_div((1. + beta**2) * pr * re, beta**2 * pr + re)\r\n\r\n    return pr, re, fbeta\r\n\r\n\r\ndef metrics_from_confusion_matrix(cm, pos_indices=None, average=\'micro\',\r\n                                  beta=1):\r\n    """"""Precision, Recall and F1 from the confusion matrix\r\n    Parameters\r\n    ----------\r\n    cm : tf.Tensor of type tf.int32, of shape (num_classes, num_classes)\r\n        The streaming confusion matrix.\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    average : str, optional\r\n        \'micro\', \'macro\' or \'weighted\'\r\n    """"""\r\n    num_classes = cm.shape[0]\r\n    if pos_indices is None:\r\n        pos_indices = [i for i in range(num_classes)]\r\n\r\n    if average == \'micro\':\r\n        return pr_re_fbeta(cm, pos_indices, beta)\r\n    elif average in {\'macro\', \'weighted\'}:\r\n        precisions, recalls, fbetas, n_golds = [], [], [], []\r\n        for idx in pos_indices:\r\n            pr, re, fbeta = pr_re_fbeta(cm, [idx], beta)\r\n            precisions.append(pr)\r\n            recalls.append(re)\r\n            fbetas.append(fbeta)\r\n            cm_mask = np.zeros([num_classes, num_classes])\r\n            cm_mask[idx, :] = 1\r\n            n_golds.append(tf.to_float(tf.reduce_sum(cm * cm_mask)))\r\n\r\n        if average == \'macro\':\r\n            pr = tf.reduce_mean(precisions)\r\n            re = tf.reduce_mean(recalls)\r\n            fbeta = tf.reduce_mean(fbetas)\r\n            return pr, re, fbeta\r\n        if average == \'weighted\':\r\n            n_gold = tf.reduce_sum(n_golds)\r\n            pr_sum = sum(p * n for p, n in zip(precisions, n_golds))\r\n            pr = safe_div(pr_sum, n_gold)\r\n            re_sum = sum(r * n for r, n in zip(recalls, n_golds))\r\n            re = safe_div(re_sum, n_gold)\r\n            fbeta_sum = sum(f * n for f, n in zip(fbetas, n_golds))\r\n            fbeta = safe_div(fbeta_sum, n_gold)\r\n            return pr, re, fbeta\r\n\r\n    else:\r\n        raise NotImplementedError()'"
baselines/models/ernie/tokenization.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\nimport unicodedata\nimport six\nimport tensorflow as tf\n\n\ndef validate_case_matches_checkpoint(do_lower_case, init_checkpoint):\n  """"""Checks whether the casing config is consistent with the checkpoint name.""""""\n\n  # The casing has to be passed in by the user and there is no explicit check\n  # as to whether it matches the checkpoint. The casing information probably\n  # should have been stored in the bert_config.json file, but it\'s not, so\n  # we have to heuristically detect it to validate.\n\n  if not init_checkpoint:\n    return\n\n  m = re.match(""^.*?([A-Za-z0-9_-]+)/bert_model.ckpt"", init_checkpoint)\n  if m is None:\n    return\n\n  model_name = m.group(1)\n\n  lower_models = [\n      ""uncased_L-24_H-1024_A-16"", ""uncased_L-12_H-768_A-12"",\n      ""multilingual_L-12_H-768_A-12"", ""chinese_L-12_H-768_A-12""\n  ]\n\n  cased_models = [\n      ""cased_L-12_H-768_A-12"", ""cased_L-24_H-1024_A-16"",\n      ""multi_cased_L-12_H-768_A-12""\n  ]\n\n  is_bad_config = False\n  if model_name in lower_models and not do_lower_case:\n    is_bad_config = True\n    actual_flag = ""False""\n    case_name = ""lowercased""\n    opposite_flag = ""True""\n\n  if model_name in cased_models and do_lower_case:\n    is_bad_config = True\n    actual_flag = ""True""\n    case_name = ""cased""\n    opposite_flag = ""False""\n\n  if is_bad_config:\n    raise ValueError(\n        ""You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. ""\n        ""However, `%s` seems to be a %s model, so you ""\n        ""should pass in `--do_lower_case=%s` so that the fine-tuning matches ""\n        ""how the model was pre-training. If this error is wrong, please ""\n        ""just comment out this check."" % (actual_flag, init_checkpoint,\n                                          model_name, case_name, opposite_flag))\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  index = 0\n  with tf.gfile.GFile(vocab_file, ""r"") as reader:\n    while True:\n      token = convert_to_unicode(reader.readline())\n      if not token:\n        break\n      token = token.strip()\n      vocab[token] = index\n      index += 1\n  return vocab\n\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  for item in items:\n    output.append(vocab[item])\n  return output\n\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True):\n    self.vocab = load_vocab(vocab_file)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n  def tokenize(self, text):\n    split_tokens = []\n    for token in self.basic_tokenizer.tokenize(text):\n      for sub_token in self.wordpiece_tokenizer.tokenize(token):\n        split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    return convert_by_vocab(self.inv_vocab, ids)\n\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = convert_to_unicode(text)\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n  """"""Runs WordPiece tokenziation.""""""\n\n  def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=200):\n    self.vocab = vocab\n    self.unk_token = unk_token\n    self.max_input_chars_per_word = max_input_chars_per_word\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text into its word pieces.\n\n    This uses a greedy longest-match-first algorithm to perform tokenization\n    using the given vocabulary.\n\n    For example:\n      input = ""unaffable""\n      output = [""un"", ""##aff"", ""##able""]\n\n    Args:\n      text: A single token or whitespace separated tokens. This should have\n        already been passed through `BasicTokenizer.\n\n    Returns:\n      A list of wordpiece tokens.\n    """"""\n\n    text = convert_to_unicode(text)\n\n    output_tokens = []\n    for token in whitespace_tokenize(text):\n      chars = list(token)\n      if len(chars) > self.max_input_chars_per_word:\n        output_tokens.append(self.unk_token)\n        continue\n\n      is_bad = False\n      start = 0\n      sub_tokens = []\n      while start < len(chars):\n        end = len(chars)\n        cur_substr = None\n        while start < end:\n          substr = """".join(chars[start:end])\n          if start > 0:\n            substr = ""##"" + substr\n          if substr in self.vocab:\n            cur_substr = substr\n            break\n          end -= 1\n        if cur_substr is None:\n          is_bad = True\n          break\n        sub_tokens.append(cur_substr)\n        start = end\n\n      if is_bad:\n        output_tokens.append(self.unk_token)\n      else:\n        output_tokens.extend(sub_tokens)\n    return output_tokens\n\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically contorl characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
baselines/models/ernie/tokenization_test.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tempfile\nimport tokenization\nimport six\nimport tensorflow as tf\n\n\nclass TokenizationTest(tf.test.TestCase):\n\n  def test_full_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing"", "",""\n    ]\n    with tempfile.NamedTemporaryFile(delete=False) as vocab_writer:\n      if six.PY2:\n        vocab_writer.write("""".join([x + ""\\n"" for x in vocab_tokens]))\n      else:\n        vocab_writer.write("""".join(\n            [x + ""\\n"" for x in vocab_tokens]).encode(""utf-8""))\n\n      vocab_file = vocab_writer.name\n\n    tokenizer = tokenization.FullTokenizer(vocab_file)\n    os.unlink(vocab_file)\n\n    tokens = tokenizer.tokenize(u""UNwant\\u00E9d,running"")\n    self.assertAllEqual(tokens, [""un"", ""##want"", ""##ed"", "","", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.convert_tokens_to_ids(tokens), [7, 4, 5, 10, 8, 9])\n\n  def test_chinese(self):\n    tokenizer = tokenization.BasicTokenizer()\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u""ah\\u535A\\u63A8zz""),\n        [u""ah"", u""\\u535A"", u""\\u63A8"", u""zz""])\n\n  def test_basic_tokenizer_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=True)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""hello"", ""!"", ""how"", ""are"", ""you"", ""?""])\n    self.assertAllEqual(tokenizer.tokenize(u""H\\u00E9llo""), [""hello""])\n\n  def test_basic_tokenizer_no_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=False)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""HeLLo"", ""!"", ""how"", ""Are"", ""yoU"", ""?""])\n\n  def test_wordpiece_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n    tokenizer = tokenization.WordpieceTokenizer(vocab=vocab)\n\n    self.assertAllEqual(tokenizer.tokenize(""""), [])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwanted running""),\n        [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwantedX running""), [""[UNK]"", ""runn"", ""##ing""])\n\n  def test_convert_tokens_to_ids(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n\n    self.assertAllEqual(\n        tokenization.convert_tokens_to_ids(\n            vocab, [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""]), [7, 4, 5, 8, 9])\n\n  def test_is_whitespace(self):\n    self.assertTrue(tokenization._is_whitespace(u"" ""))\n    self.assertTrue(tokenization._is_whitespace(u""\\t""))\n    self.assertTrue(tokenization._is_whitespace(u""\\r""))\n    self.assertTrue(tokenization._is_whitespace(u""\\n""))\n    self.assertTrue(tokenization._is_whitespace(u""\\u00A0""))\n\n    self.assertFalse(tokenization._is_whitespace(u""A""))\n    self.assertFalse(tokenization._is_whitespace(u""-""))\n\n  def test_is_control(self):\n    self.assertTrue(tokenization._is_control(u""\\u0005""))\n\n    self.assertFalse(tokenization._is_control(u""A""))\n    self.assertFalse(tokenization._is_control(u"" ""))\n    self.assertFalse(tokenization._is_control(u""\\t""))\n    self.assertFalse(tokenization._is_control(u""\\r""))\n    self.assertFalse(tokenization._is_control(u""\\U0001F4A9""))\n\n  def test_is_punctuation(self):\n    self.assertTrue(tokenization._is_punctuation(u""-""))\n    self.assertTrue(tokenization._is_punctuation(u""$""))\n    self.assertTrue(tokenization._is_punctuation(u""`""))\n    self.assertTrue(tokenization._is_punctuation(u"".""))\n\n    self.assertFalse(tokenization._is_punctuation(u""A""))\n    self.assertFalse(tokenization._is_punctuation(u"" ""))\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/roberta/conlleval.py,0,"b'# Python version of the evaluation script from CoNLL\'00-\n# Originates from: https://github.com/spyysalo/conlleval.py\n\n\n# Intentional differences:\n# - accept any space as delimiter by default\n# - optional file argument (default STDIN)\n# - option to set boundary (-b argument)\n# - LaTeX output (-l argument) not supported\n# - raw tags (-r argument) not supported\n\n# add function :evaluate(predicted_label, ori_label): which will not read from file\n\nimport sys\nimport re\nimport codecs\nfrom collections import defaultdict, namedtuple\n\nANY_SPACE = \'<SPACE>\'\n\n\nclass FormatError(Exception):\n    pass\n\nMetrics = namedtuple(\'Metrics\', \'tp fp fn prec rec fscore\')\n\n\nclass EvalCounts(object):\n    def __init__(self):\n        self.correct_chunk = 0    # number of correctly identified chunks\n        self.correct_tags = 0     # number of correct chunk tags\n        self.found_correct = 0    # number of chunks in corpus\n        self.found_guessed = 0    # number of identified chunks\n        self.token_counter = 0    # token counter (ignores sentence breaks)\n\n        # counts by type\n        self.t_correct_chunk = defaultdict(int)\n        self.t_found_correct = defaultdict(int)\n        self.t_found_guessed = defaultdict(int)\n\n\ndef parse_args(argv):\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=\'evaluate tagging results using CoNLL criteria\',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    arg = parser.add_argument\n    arg(\'-b\', \'--boundary\', metavar=\'STR\', default=\'-X-\',\n        help=\'sentence boundary\')\n    arg(\'-d\', \'--delimiter\', metavar=\'CHAR\', default=ANY_SPACE,\n        help=\'character delimiting items in input\')\n    arg(\'-o\', \'--otag\', metavar=\'CHAR\', default=\'O\',\n        help=\'alternative outside tag\')\n    arg(\'file\', nargs=\'?\', default=None)\n    return parser.parse_args(argv)\n\n\ndef parse_tag(t):\n    m = re.match(r\'^([^-]*)-(.*)$\', t)\n    return m.groups() if m else (t, \'\')\n\n\ndef evaluate(iterable, options=None):\n    if options is None:\n        options = parse_args([])    # use defaults\n\n    counts = EvalCounts()\n    num_features = None       # number of features per line\n    in_correct = False        # currently processed chunks is correct until now\n    last_correct = \'O\'        # previous chunk tag in corpus\n    last_correct_type = \'\'    # type of previously identified chunk tag\n    last_guessed = \'O\'        # previously identified chunk tag\n    last_guessed_type = \'\'    # type of previous chunk tag in corpus\n\n    for line in iterable:\n        line = line.rstrip(\'\\r\\n\')\n\n        if options.delimiter == ANY_SPACE:\n            features = line.split()\n        else:\n            features = line.split(options.delimiter)\n\n        if num_features is None:\n            num_features = len(features)\n        elif num_features != len(features) and len(features) != 0:\n            raise FormatError(\'unexpected number of features: %d (%d)\' %\n                              (len(features), num_features))\n\n        if len(features) == 0 or features[0] == options.boundary:\n            features = [options.boundary, \'O\', \'O\']\n        if len(features) < 3:\n            raise FormatError(\'unexpected number of features in line %s\' % line)\n\n        guessed, guessed_type = parse_tag(features.pop())\n        correct, correct_type = parse_tag(features.pop())\n        first_item = features.pop(0)\n\n        if first_item == options.boundary:\n            guessed = \'O\'\n\n        end_correct = end_of_chunk(last_correct, correct,\n                                   last_correct_type, correct_type)\n        end_guessed = end_of_chunk(last_guessed, guessed,\n                                   last_guessed_type, guessed_type)\n        start_correct = start_of_chunk(last_correct, correct,\n                                       last_correct_type, correct_type)\n        start_guessed = start_of_chunk(last_guessed, guessed,\n                                       last_guessed_type, guessed_type)\n\n        if in_correct:\n            if (end_correct and end_guessed and\n                last_guessed_type == last_correct_type):\n                in_correct = False\n                counts.correct_chunk += 1\n                counts.t_correct_chunk[last_correct_type] += 1\n            elif (end_correct != end_guessed or guessed_type != correct_type):\n                in_correct = False\n\n        if start_correct and start_guessed and guessed_type == correct_type:\n            in_correct = True\n\n        if start_correct:\n            counts.found_correct += 1\n            counts.t_found_correct[correct_type] += 1\n        if start_guessed:\n            counts.found_guessed += 1\n            counts.t_found_guessed[guessed_type] += 1\n        if first_item != options.boundary:\n            if correct == guessed and guessed_type == correct_type:\n                counts.correct_tags += 1\n            counts.token_counter += 1\n\n        last_guessed = guessed\n        last_correct = correct\n        last_guessed_type = guessed_type\n        last_correct_type = correct_type\n\n    if in_correct:\n        counts.correct_chunk += 1\n        counts.t_correct_chunk[last_correct_type] += 1\n\n    return counts\n\n\n\ndef uniq(iterable):\n  seen = set()\n  return [i for i in iterable if not (i in seen or seen.add(i))]\n\n\ndef calculate_metrics(correct, guessed, total):\n    tp, fp, fn = correct, guessed-correct, total-correct\n    p = 0 if tp + fp == 0 else 1.*tp / (tp + fp)\n    r = 0 if tp + fn == 0 else 1.*tp / (tp + fn)\n    f = 0 if p + r == 0 else 2 * p * r / (p + r)\n    return Metrics(tp, fp, fn, p, r, f)\n\n\ndef metrics(counts):\n    c = counts\n    overall = calculate_metrics(\n        c.correct_chunk, c.found_guessed, c.found_correct\n    )\n    by_type = {}\n    for t in uniq(list(c.t_found_correct) + list(c.t_found_guessed)):\n        by_type[t] = calculate_metrics(\n            c.t_correct_chunk[t], c.t_found_guessed[t], c.t_found_correct[t]\n        )\n    return overall, by_type\n\n\ndef report(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    out.write(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    out.write(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n\n    if c.token_counter > 0:\n        out.write(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        out.write(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        out.write(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n\n    for i, m in sorted(by_type.items()):\n        out.write(\'%17s: \' % i)\n        out.write(\'precision: %6.2f%%; \' % (100.*m.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*m.rec))\n        out.write(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n\n\ndef report_notprint(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    final_report = []\n    line = []\n    line.append(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    line.append(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n    final_report.append("""".join(line))\n\n    if c.token_counter > 0:\n        line = []\n        line.append(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        line.append(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        line.append(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n        final_report.append("""".join(line))\n\n    for i, m in sorted(by_type.items()):\n        line = []\n        line.append(\'%17s: \' % i)\n        line.append(\'precision: %6.2f%%; \' % (100.*m.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*m.rec))\n        line.append(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n        final_report.append("""".join(line))\n    return final_report\n\n\ndef end_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk ended between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_end = False\n\n    if prev_tag == \'E\': chunk_end = True\n    if prev_tag == \'S\': chunk_end = True\n\n    if prev_tag == \'B\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'O\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'O\': chunk_end = True\n\n    if prev_tag != \'O\' and prev_tag != \'.\' and prev_type != type_:\n        chunk_end = True\n\n    # these chunks are assumed to have length 1\n    if prev_tag == \']\': chunk_end = True\n    if prev_tag == \'[\': chunk_end = True\n\n    return chunk_end\n\n\ndef start_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk started between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_start = False\n\n    if tag == \'B\': chunk_start = True\n    if tag == \'S\': chunk_start = True\n\n    if prev_tag == \'E\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'E\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'I\': chunk_start = True\n\n    if tag != \'O\' and tag != \'.\' and prev_type != type_:\n        chunk_start = True\n\n    # these chunks are assumed to have length 1\n    if tag == \'[\': chunk_start = True\n    if tag == \']\': chunk_start = True\n\n    return chunk_start\n\n\ndef return_report(input_file):\n    with codecs.open(input_file, ""r"", ""utf8"") as f:\n        counts = evaluate(f)\n    return report_notprint(counts)\n\n\ndef main(argv):\n    args = parse_args(argv[1:])\n\n    if args.file is None:\n        counts = evaluate(sys.stdin, args)\n    else:\n        with open(args.file) as f:\n            counts = evaluate(f, args)\n    report(counts)\n\nif __name__ == \'__main__\':\n    sys.exit(main(sys.argv))'"
baselines/models/roberta/create_pretraining_data.py,19,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport re\nimport tokenization\nimport tensorflow as tf\nimport jieba\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\n\nclass TrainingInstance(object):\n    """"""A single training instance (sentence pair).""""""\n\n    def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n                 is_random_next):\n        self.tokens = tokens\n        self.segment_ids = segment_ids\n        self.is_random_next = is_random_next\n        self.masked_lm_positions = masked_lm_positions\n        self.masked_lm_labels = masked_lm_labels\n\n    def __str__(self):\n        s = """"\n        s += ""tokens: %s\\n"" % ("" "".join(\n            [tokenization.printable_text(x) for x in self.tokens]))\n        s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n        s += ""is_random_next: %s\\n"" % self.is_random_next\n        s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n            [str(x) for x in self.masked_lm_positions]))\n        s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n            [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n        s += ""\\n""\n        return s\n\n    def __repr__(self):\n        return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n    """"""Create TF example files from `TrainingInstance`s.""""""\n    writers = []\n    for output_file in output_files:\n        writers.append(tf.python_io.TFRecordWriter(output_file))\n\n    writer_index = 0\n\n    total_written = 0\n    for (inst_index, instance) in enumerate(instances):\n        input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n        input_mask = [1] * len(input_ids)\n        segment_ids = list(instance.segment_ids)\n        assert len(input_ids) <= max_seq_length\n\n        while len(input_ids) < max_seq_length:\n            input_ids.append(0)\n            input_mask.append(0)\n            segment_ids.append(0)\n\n        assert len(input_ids) == max_seq_length\n        assert len(input_mask) == max_seq_length\n        # print(""length of segment_ids:"",len(segment_ids),""max_seq_length:"", max_seq_length)\n        assert len(segment_ids) == max_seq_length\n\n        masked_lm_positions = list(instance.masked_lm_positions)\n        masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n        masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n        while len(masked_lm_positions) < max_predictions_per_seq:\n            masked_lm_positions.append(0)\n            masked_lm_ids.append(0)\n            masked_lm_weights.append(0.0)\n\n        next_sentence_label = 1 if instance.is_random_next else 0\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(input_ids)\n        features[""input_mask""] = create_int_feature(input_mask)\n        features[""segment_ids""] = create_int_feature(segment_ids)\n        features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n        features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n        features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n        features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n        writers[writer_index].write(tf_example.SerializeToString())\n        writer_index = (writer_index + 1) % len(writers)\n\n        total_written += 1\n\n        if inst_index < 20:\n            tf.logging.info(""*** Example ***"")\n            tf.logging.info(""tokens: %s"" % "" "".join(\n                [tokenization.printable_text(x) for x in instance.tokens]))\n\n            for feature_name in features.keys():\n                feature = features[feature_name]\n                values = []\n                if feature.int64_list.value:\n                    values = feature.int64_list.value\n                elif feature.float_list.value:\n                    values = feature.float_list.value\n                tf.logging.info(\n                    ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n    for writer in writers:\n        writer.close()\n\n    tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n    feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n    return feature\n\n\ndef create_float_feature(values):\n    feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n    return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n    """"""Create `TrainingInstance`s from raw text.""""""\n    all_documents = [[]]\n\n    # Input file format:\n    # (1) One sentence per line. These should ideally be actual sentences, not\n    # entire paragraphs or arbitrary spans of text. (Because we use the\n    # sentence boundaries for the ""next sentence prediction"" task).\n    # (2) Blank lines between documents. Document boundaries are needed so\n    # that the ""next sentence prediction"" task doesn\'t span between documents.\n    print(""create_training_instances.started..."")\n    for input_file in input_files:\n        with tf.gfile.GFile(input_file, ""r"") as reader:\n            while True:\n                line = tokenization.convert_to_unicode(reader.readline().replace(""<eop>"",""""))# .replace(""\xe2\x80\x9d"","""")) # \xe5\xb0\x86<eop>\xe3\x80\x81\xe2\x80\x9d\xe6\x9b\xbf\xe6\x8d\xa2\xe6\x8e\x89\xe3\x80\x82\n                if not line:\n                    break\n                line = line.strip()\n\n                # Empty lines are used as document delimiters\n                if not line:\n                    all_documents.append([])\n                tokens = tokenizer.tokenize(line)\n                if tokens:\n                    all_documents[-1].append(tokens)\n\n    # Remove empty documents\n    all_documents = [x for x in all_documents if x]\n    rng.shuffle(all_documents)\n\n    vocab_words = list(tokenizer.vocab.keys())\n    instances = []\n    for _ in range(dupe_factor):\n        for document_index in range(len(all_documents)):\n            instances.extend(\n                create_instances_from_document(\n                    all_documents, document_index, max_seq_length, short_seq_prob,\n                    masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n    rng.shuffle(instances)\n    print(""create_training_instances.ended..."")\n\n    return instances\n\n\ndef _is_chinese_char(cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n            (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n        return True\n\n\ndef get_new_segment(segment): #  \xe6\x96\xb0\xe5\xa2\x9e\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95 ####\n    """"""\n    \xe8\xbe\x93\xe5\x85\xa5\xe4\xb8\x80\xe5\x8f\xa5\xe8\xaf\x9d\xef\xbc\x8c\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe5\x8f\xa5\xe7\xbb\x8f\xe8\xbf\x87\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe8\xaf\x9d: \xe4\xb8\xba\xe4\xba\x86\xe6\x94\xaf\xe6\x8c\x81\xe4\xb8\xad\xe6\x96\x87\xe5\x85\xa8\xe7\xa7\xb0mask\xef\xbc\x8c\xe5\xb0\x86\xe8\xa2\xab\xe5\x88\x86\xe5\xbc\x80\xe7\x9a\x84\xe8\xaf\x8d\xef\xbc\x8c\xe5\xb0\x86\xe4\xb8\x8a\xe7\x89\xb9\xe6\xae\x8a\xe6\xa0\x87\xe8\xae\xb0(""#"")\xef\xbc\x8c\xe4\xbd\xbf\xe5\xbe\x97\xe5\x90\x8e\xe7\xbb\xad\xe5\xa4\x84\xe7\x90\x86\xe6\xa8\xa1\xe5\x9d\x97\xef\xbc\x8c\xe8\x83\xbd\xe5\xa4\x9f\xe7\x9f\xa5\xe9\x81\x93\xe5\x93\xaa\xe4\xba\x9b\xe5\xad\x97\xe6\x98\xaf\xe5\xb1\x9e\xe4\xba\x8e\xe5\x90\x8c\xe4\xb8\x80\xe4\xb8\xaa\xe8\xaf\x8d\xe7\x9a\x84\xe3\x80\x82\n    :param segment: \xe4\xb8\x80\xe5\x8f\xa5\xe8\xaf\x9d\n    :return: \xe4\xb8\x80\xe5\x8f\xa5\xe5\xa4\x84\xe7\x90\x86\xe8\xbf\x87\xe7\x9a\x84\xe8\xaf\x9d\n    """"""\n    seq_cws = jieba.lcut("""".join(segment))\n    seq_cws_dict = {x: 1 for x in seq_cws}\n    new_segment = []\n    i = 0\n    while i < len(segment):\n        if len(re.findall(\'[\\u4E00-\\u9FA5]\', segment[i]))==0: # \xe4\xb8\x8d\xe6\x98\xaf\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84\xef\xbc\x8c\xe5\x8e\x9f\xe6\x96\x87\xe5\x8a\xa0\xe8\xbf\x9b\xe5\x8e\xbb\xe3\x80\x82\n            new_segment.append(segment[i])\n            i += 1\n            continue\n\n        has_add = False\n        for length in range(3,0,-1):\n            if i+length>len(segment):\n                continue\n            if \'\'.join(segment[i:i+length]) in seq_cws_dict:\n                new_segment.append(segment[i])\n                for l in range(1, length):\n                    new_segment.append(\'##\' + segment[i+l])\n                i += length\n                has_add = True\n                break\n        if not has_add:\n            new_segment.append(segment[i])\n            i += 1\n    return new_segment\n\ndef get_raw_instance(document,max_sequence_length): # \xe6\x96\xb0\xe5\xa2\x9e\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95\n    """"""\n    \xe8\x8e\xb7\xe5\x8f\x96\xe5\x88\x9d\xe6\xad\xa5\xe7\x9a\x84\xe8\xae\xad\xe7\xbb\x83\xe5\xae\x9e\xe4\xbe\x8b\xef\xbc\x8c\xe5\xb0\x86\xe6\x95\xb4\xe6\xae\xb5\xe6\x8c\x89\xe7\x85\xa7max_sequence_length\xe5\x88\x87\xe5\x88\x86\xe6\x88\x90\xe5\xa4\x9a\xe4\xb8\xaa\xe9\x83\xa8\xe5\x88\x86,\xe5\xb9\xb6\xe4\xbb\xa5\xe5\xa4\x9a\xe4\xb8\xaa\xe5\xa4\x84\xe7\x90\x86\xe5\xa5\xbd\xe7\x9a\x84\xe5\xae\x9e\xe4\xbe\x8b\xe7\x9a\x84\xe5\xbd\xa2\xe5\xbc\x8f\xe8\xbf\x94\xe5\x9b\x9e\xe3\x80\x82\n    :param document: \xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\n    :param max_sequence_length:\n    :return: a list. each element is a sequence of text\n    """"""\n    max_sequence_length_allowed=max_sequence_length-2\n    document = [seq for seq in document if len(seq)<max_sequence_length_allowed]\n    sizes = [len(seq) for seq in document]\n\n    result_list = []\n    curr_seq = [] # \xe5\xbd\x93\xe5\x89\x8d\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\n    sz_idx = 0\n    while sz_idx < len(sizes):\n        # \xe5\xbd\x93\xe5\x89\x8d\xe5\x8f\xa5\xe5\xad\x90\xe5\x8a\xa0\xe4\xb8\x8a\xe6\x96\xb0\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe9\x95\xbf\xe5\xba\xa6\xe5\xb0\x8f\xe4\xba\x8e\xe6\x9c\x80\xe5\xa4\xa7\xe9\x99\x90\xe5\x88\xb6\xef\xbc\x8c\xe5\x88\x99\xe5\x90\x88\xe5\xb9\xb6\xe5\xbd\x93\xe5\x89\x8d\xe5\x8f\xa5\xe5\xad\x90\xe5\x92\x8c\xe6\x96\xb0\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x9b\xe5\x90\xa6\xe5\x88\x99\xe5\x8d\xb3\xe8\xb6\x85\xe8\xbf\x87\xe4\xba\x86\xe6\x9c\x80\xe5\xa4\xa7\xe9\x99\x90\xe5\x88\xb6\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe5\x81\x9a\xe4\xb8\xba\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\xb0\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\xe5\x8a\xa0\xe5\x88\xb0\xe7\x9b\xae\xe6\xa0\x87\xe5\x88\x97\xe8\xa1\xa8\xe4\xb8\xad\n        if len(curr_seq) + sizes[sz_idx] <= max_sequence_length_allowed: # or len(curr_seq)==0:\n            curr_seq += document[sz_idx]\n            sz_idx += 1\n        else:\n            result_list.append(curr_seq)\n            curr_seq = []\n    # \xe5\xaf\xb9\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe4\xb8\xaa\xe5\xba\x8f\xe5\x88\x97\xe8\xbf\x9b\xe8\xa1\x8c\xe5\xa4\x84\xe7\x90\x86\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe5\xa4\xaa\xe7\x9f\xad\xe7\x9a\x84\xe8\xaf\x9d\xef\xbc\x8c\xe4\xb8\xa2\xe5\xbc\x83\xe6\x8e\x89\xe3\x80\x82\n    if len(curr_seq)>max_sequence_length_allowed/2: # /2\n        result_list.append(curr_seq)\n\n    # # \xe8\xae\xa1\xe7\xae\x97\xe6\x80\xbb\xe5\x85\xb1\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xbe\x97\xe5\x88\xb0\xe5\xa4\x9a\xe5\xb0\x91\xe4\xbb\xbd\n    # num_instance=int(len(big_list)/max_sequence_length_allowed)+1\n    # print(""num_instance:"",num_instance)\n    # # \xe5\x88\x87\xe5\x88\x86\xe6\x88\x90\xe5\xa4\x9a\xe4\xbb\xbd\xef\xbc\x8c\xe6\xb7\xbb\xe5\x8a\xa0\xe5\x88\xb0\xe5\x88\x97\xe8\xa1\xa8\xe4\xb8\xad\n    # result_list=[]\n    # for j in range(num_instance):\n    #     index=j*max_sequence_length_allowed\n    #     end_index=index+max_sequence_length_allowed if j!=num_instance-1 else -1\n    #     result_list.append(big_list[index:end_index])\n    return result_list\n\ndef create_instances_from_document( # \xe6\x96\xb0\xe5\xa2\x9e\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95\n    # \xe7\x9b\xae\xe6\xa0\x87\xe6\x8c\x89\xe7\x85\xa7RoBERTa\xe7\x9a\x84\xe6\x80\x9d\xe8\xb7\xaf\xef\xbc\x8c\xe4\xbd\xbf\xe7\x94\xa8DOC-SENTENCES\xef\xbc\x8c\xe5\xb9\xb6\xe4\xbc\x9a\xe5\x8e\xbb\xe6\x8e\x89NSP\xe4\xbb\xbb\xe5\x8a\xa1: \xe4\xbb\x8e\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe8\xbf\x9e\xe7\xbb\xad\xe7\x9a\x84\xe8\x8e\xb7\xe5\xbe\x97\xe6\x96\x87\xe6\x9c\xac\xef\xbc\x8c\xe7\x9b\xb4\xe5\x88\xb0\xe8\xbe\xbe\xe5\x88\xb0\xe6\x9c\x80\xe5\xa4\xa7\xe9\x95\xbf\xe5\xba\xa6\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c\xe6\x98\xaf\xe4\xbb\x8e\xe4\xb8\x8b\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe8\x8e\xb7\xe5\xbe\x97\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe5\x8a\xa0\xe4\xb8\x8a\xe4\xb8\x80\xe4\xb8\xaa\xe5\x88\x86\xe9\x9a\x94\xe7\xac\xa6\n    #  document\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe3\x80\x82\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe5\x8f\xab\xe5\x81\x9asegment.\n    # \xe7\xbb\x99\xe5\xae\x9a\xe4\xb8\x80\xe4\xb8\xaadocument\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe7\x94\x9f\xe6\x88\x90\xe4\xb8\x80\xe4\xba\x9binstance.\n        all_documents, document_index, max_seq_length, short_seq_prob,\n        masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n    """"""Creates `TrainingInstance`s for a single document.""""""\n    document = all_documents[document_index]\n\n    # Account for [CLS], [SEP], [SEP]\n    max_num_tokens = max_seq_length - 3\n\n    # We *usually* want to fill up the entire sequence since we are padding\n    # to `max_seq_length` anyways, so short sequences are generally wasted\n    # computation. However, we *sometimes*\n    # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n    # sequences to minimize the mismatch between pre-training and fine-tuning.\n    # The `target_seq_length` is just a rough target however, whereas\n    # `max_seq_length` is a hard limit.\n\n    #target_seq_length = max_num_tokens\n    #if rng.random() < short_seq_prob:\n    #    target_seq_length = rng.randint(2, max_num_tokens)\n\n    instances = []\n    raw_text_list_list=get_raw_instance(document, max_seq_length) # document\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe3\x80\x82\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe5\x8f\xab\xe5\x81\x9asegment.\n    for j, raw_text_list in enumerate(raw_text_list_list):\n        ####################################################################################################################\n        raw_text_list = get_new_segment(raw_text_list) # \xe7\xbb\x93\xe5\x90\x88\xe5\x88\x86\xe8\xaf\x8d\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84whole mask\xe8\xae\xbe\xe7\xbd\xae\xe5\x8d\xb3\xe5\x9c\xa8\xe9\x9c\x80\xe8\xa6\x81\xe7\x9a\x84\xe5\x9c\xb0\xe6\x96\xb9\xe5\x8a\xa0\xe4\xb8\x8a\xe2\x80\x9c##\xe2\x80\x9d\n        # 1\xe3\x80\x81\xe8\xae\xbe\xe7\xbd\xaetoken, segment_ids\n        is_random_next=True # this will not be used, so it\'s value doesn\'t matter\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in raw_text_list:\n            tokens.append(token)\n            segment_ids.append(0)\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n        ################################################################################################################\n        # 2\xe3\x80\x81\xe8\xb0\x83\xe7\x94\xa8\xe5\x8e\x9f\xe6\x9c\x89\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n            tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance(\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n\n    return instances\n\n\n\ndef create_instances_from_document_original(\n        all_documents, document_index, max_seq_length, short_seq_prob,\n        masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n    """"""Creates `TrainingInstance`s for a single document.""""""\n    document = all_documents[document_index]\n\n    # Account for [CLS], [SEP], [SEP]\n    max_num_tokens = max_seq_length - 3\n\n    # We *usually* want to fill up the entire sequence since we are padding\n    # to `max_seq_length` anyways, so short sequences are generally wasted\n    # computation. However, we *sometimes*\n    # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n    # sequences to minimize the mismatch between pre-training and fine-tuning.\n    # The `target_seq_length` is just a rough target however, whereas\n    # `max_seq_length` is a hard limit.\n    target_seq_length = max_num_tokens\n    if rng.random() < short_seq_prob:\n        target_seq_length = rng.randint(2, max_num_tokens)\n\n    # We DON\'T just concatenate all of the tokens from a document into a long\n    # sequence and choose an arbitrary split point because this would make the\n    # next sentence prediction task too easy. Instead, we split the input into\n    # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n    # input.\n    instances = []\n    current_chunk = []\n    current_length = 0\n    i = 0\n    print(""document_index:"",document_index,""document:"",type(document),"" ;document:"",document) # document\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe3\x80\x82\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe5\x8f\xab\xe5\x81\x9asegment.\n    while i < len(document):\n        segment = document[i] # \xe5\x8f\x96\xe5\x88\xb0\xe4\xb8\x80\xe4\xb8\xaa\xe9\x83\xa8\xe5\x88\x86\xef\xbc\x88\xe5\x8f\xaf\xe8\x83\xbd\xe6\x98\xaf\xe4\xb8\x80\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x89\n        print(""i:"",i,"" ;segment:"",segment)\n        ####################################################################################################################\n        segment = get_new_segment(segment) # \xe7\xbb\x93\xe5\x90\x88\xe5\x88\x86\xe8\xaf\x8d\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84whole mask\xe8\xae\xbe\xe7\xbd\xae\xe5\x8d\xb3\xe5\x9c\xa8\xe9\x9c\x80\xe8\xa6\x81\xe7\x9a\x84\xe5\x9c\xb0\xe6\x96\xb9\xe5\x8a\xa0\xe4\xb8\x8a\xe2\x80\x9c##\xe2\x80\x9d\n        ###################################################################################################################\n        current_chunk.append(segment)\n        current_length += len(segment)\n        print(""#####condition:"",i == len(document) - 1 or current_length >= target_seq_length)\n        if i == len(document) - 1 or current_length >= target_seq_length:\n            if current_chunk:\n                # `a_end` is how many segments from `current_chunk` go into the `A`\n                # (first) sentence.\n                a_end = 1\n                if len(current_chunk) >= 2:\n                    a_end = rng.randint(1, len(current_chunk) - 1)\n\n                tokens_a = []\n                for j in range(a_end):\n                    tokens_a.extend(current_chunk[j])\n\n                tokens_b = []\n                # Random next\n                is_random_next = False\n                if len(current_chunk) == 1 or rng.random() < 0.5:\n                    is_random_next = True\n                    target_b_length = target_seq_length - len(tokens_a)\n\n                    # This should rarely go for more than one iteration for large\n                    # corpora. However, just to be careful, we try to make sure that\n                    # the random document is not the same as the document\n                    # we\'re processing.\n                    for _ in range(10):\n                        random_document_index = rng.randint(0, len(all_documents) - 1)\n                        if random_document_index != document_index:\n                            break\n\n                    random_document = all_documents[random_document_index]\n                    random_start = rng.randint(0, len(random_document) - 1)\n                    for j in range(random_start, len(random_document)):\n                        tokens_b.extend(random_document[j])\n                        if len(tokens_b) >= target_b_length:\n                            break\n                    # We didn\'t actually use these segments so we ""put them back"" so\n                    # they don\'t go to waste.\n                    num_unused_segments = len(current_chunk) - a_end\n                    i -= num_unused_segments\n                # Actual next\n                else:\n                    is_random_next = False\n                    for j in range(a_end, len(current_chunk)):\n                        tokens_b.extend(current_chunk[j])\n                truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n                assert len(tokens_a) >= 1\n                assert len(tokens_b) >= 1\n\n                tokens = []\n                segment_ids = []\n                tokens.append(""[CLS]"")\n                segment_ids.append(0)\n                for token in tokens_a:\n                    tokens.append(token)\n                    segment_ids.append(0)\n\n                tokens.append(""[SEP]"")\n                segment_ids.append(0)\n\n                for token in tokens_b:\n                    tokens.append(token)\n                    segment_ids.append(1)\n                tokens.append(""[SEP]"")\n                segment_ids.append(1)\n\n                (tokens, masked_lm_positions,\n                 masked_lm_labels) = create_masked_lm_predictions(\n                     tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n                instance = TrainingInstance(\n                    tokens=tokens,\n                    segment_ids=segment_ids,\n                    is_random_next=is_random_next,\n                    masked_lm_positions=masked_lm_positions,\n                    masked_lm_labels=masked_lm_labels)\n                instances.append(instance)\n            current_chunk = []\n            current_length = 0\n        i += 1\n\n    return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n    """"""Creates the predictions for the masked LM objective.""""""\n\n    cand_indexes = []\n    for (i, token) in enumerate(tokens):\n        if token == ""[CLS]"" or token == ""[SEP]"":\n            continue\n        # Whole Word Masking means that if we mask all of the wordpieces\n        # corresponding to an original word. When a word has been split into\n        # WordPieces, the first token does not have any marker and any subsequence\n        # tokens are prefixed with ##. So whenever we see the ## token, we\n        # append it to the previous set of word indexes.\n        #\n        # Note that Whole Word Masking does *not* change the training code\n        # at all -- we still predict each WordPiece independently, softmaxed\n        # over the entire vocabulary.\n        if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n                token.startswith(""##"")):\n            cand_indexes[-1].append(i)\n        else:\n            cand_indexes.append([i])\n\n    rng.shuffle(cand_indexes)\n\n    output_tokens = [t[2:] if len(re.findall(\'##[\\u4E00-\\u9FA5]\', t))>0 else t for t in tokens]\n\n    num_to_predict = min(max_predictions_per_seq,\n                         max(1, int(round(len(tokens) * masked_lm_prob))))\n\n    masked_lms = []\n    covered_indexes = set()\n    for index_set in cand_indexes:\n        if len(masked_lms) >= num_to_predict:\n            break\n        # If adding a whole-word mask would exceed the maximum number of\n        # predictions, then just skip this candidate.\n        if len(masked_lms) + len(index_set) > num_to_predict:\n            continue\n        is_any_index_covered = False\n        for index in index_set:\n            if index in covered_indexes:\n                is_any_index_covered = True\n                break\n        if is_any_index_covered:\n            continue\n        for index in index_set:\n            covered_indexes.add(index)\n\n            masked_token = None\n            # 80% of the time, replace with [MASK]\n            if rng.random() < 0.8:\n                masked_token = ""[MASK]""\n            else:\n                # 10% of the time, keep original\n                if rng.random() < 0.5:\n                    masked_token = tokens[index][2:] if len(re.findall(\'##[\\u4E00-\\u9FA5]\', tokens[index]))>0 else tokens[index]\n                # 10% of the time, replace with random word\n                else:\n                    masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n            output_tokens[index] = masked_token\n\n            masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n    assert len(masked_lms) <= num_to_predict\n    masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n    masked_lm_positions = []\n    masked_lm_labels = []\n    for p in masked_lms:\n        masked_lm_positions.append(p.index)\n        masked_lm_labels.append(p.label)\n\n    # tf.logging.info(\'%s\' % (tokens))\n    # tf.logging.info(\'%s\' % (output_tokens))\n    return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n    """"""Truncates a pair of sequences to a maximum sequence length.""""""\n    while True:\n        total_length = len(tokens_a) + len(tokens_b)\n        if total_length <= max_num_tokens:\n            break\n\n        trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n        assert len(trunc_tokens) >= 1\n\n        # We want to sometimes truncate from the front and sometimes from the\n        # back to add more randomness and avoid biases.\n        if rng.random() < 0.5:\n            del trunc_tokens[0]\n        else:\n            trunc_tokens.pop()\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    input_files = []\n    for input_pattern in FLAGS.input_file.split("",""):\n        input_files.extend(tf.gfile.Glob(input_pattern))\n\n    tf.logging.info(""*** Reading from input files ***"")\n    for input_file in input_files:\n        tf.logging.info(""  %s"", input_file)\n\n    rng = random.Random(FLAGS.random_seed)\n    instances = create_training_instances(\n        input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n        FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n        rng)\n\n    output_files = FLAGS.output_file.split("","")\n    tf.logging.info(""*** Writing to output files ***"")\n    for output_file in output_files:\n        tf.logging.info(""  %s"", output_file)\n\n    write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                    FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""input_file"")\n    flags.mark_flag_as_required(""output_file"")\n    flags.mark_flag_as_required(""vocab_file"")\n    tf.app.run()'"
baselines/models/roberta/modeling.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The main BERT model and related functions.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport numpy as np\nimport six\nimport tensorflow as tf\n\n\nclass BertConfig(object):\n  """"""Configuration for `BertModel`.""""""\n\n  def __init__(self,\n               vocab_size,\n               hidden_size=768,\n               num_hidden_layers=12,\n               num_attention_heads=12,\n               intermediate_size=3072,\n               hidden_act=""gelu"",\n               hidden_dropout_prob=0.1,\n               attention_probs_dropout_prob=0.1,\n               max_position_embeddings=512,\n               type_vocab_size=16,\n               initializer_range=0.02):\n    """"""Constructs BertConfig.\n\n    Args:\n      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.\n      hidden_size: Size of the encoder layers and the pooler layer.\n      num_hidden_layers: Number of hidden layers in the Transformer encoder.\n      num_attention_heads: Number of attention heads for each attention layer in\n        the Transformer encoder.\n      intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n        layer in the Transformer encoder.\n      hidden_act: The non-linear activation function (function or string) in the\n        encoder and pooler.\n      hidden_dropout_prob: The dropout probability for all fully connected\n        layers in the embeddings, encoder, and pooler.\n      attention_probs_dropout_prob: The dropout ratio for the attention\n        probabilities.\n      max_position_embeddings: The maximum sequence length that this model might\n        ever be used with. Typically set this to something large just in case\n        (e.g., 512 or 1024 or 2048).\n      type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n        `BertModel`.\n      initializer_range: The stdev of the truncated_normal_initializer for\n        initializing all weight matrices.\n    """"""\n    self.vocab_size = vocab_size\n    self.hidden_size = hidden_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.hidden_act = hidden_act\n    self.intermediate_size = intermediate_size\n    self.hidden_dropout_prob = hidden_dropout_prob\n    self.attention_probs_dropout_prob = attention_probs_dropout_prob\n    self.max_position_embeddings = max_position_embeddings\n    self.type_vocab_size = type_vocab_size\n    self.initializer_range = initializer_range\n\n  @classmethod\n  def from_dict(cls, json_object):\n    """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n    config = BertConfig(vocab_size=None)\n    for (key, value) in six.iteritems(json_object):\n      config.__dict__[key] = value\n    return config\n\n  @classmethod\n  def from_json_file(cls, json_file):\n    """"""Constructs a `BertConfig` from a json file of parameters.""""""\n    with tf.gfile.GFile(json_file, ""r"") as reader:\n      text = reader.read()\n    return cls.from_dict(json.loads(text))\n\n  def to_dict(self):\n    """"""Serializes this instance to a Python dictionary.""""""\n    output = copy.deepcopy(self.__dict__)\n    return output\n\n  def to_json_string(self):\n    """"""Serializes this instance to a JSON string.""""""\n    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass BertModel(object):\n  """"""BERT model (""Bidirectional Encoder Representations from Transformers"").\n\n  Example usage:\n\n  ```python\n  # Already been converted into WordPiece token ids\n  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])\n  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])\n  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])\n\n  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,\n    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)\n\n  model = modeling.BertModel(config=config, is_training=True,\n    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)\n\n  label_embeddings = tf.get_variable(...)\n  pooled_output = model.get_pooled_output()\n  logits = tf.matmul(pooled_output, label_embeddings)\n  ...\n  ```\n  """"""\n\n  def __init__(self,\n               config,\n               is_training,\n               input_ids,\n               input_mask=None,\n               token_type_ids=None,\n               use_one_hot_embeddings=False,\n               scope=None):\n    """"""Constructor for BertModel.\n\n    Args:\n      config: `BertConfig` instance.\n      is_training: bool. true for training model, false for eval model. Controls\n        whether dropout will be applied.\n      input_ids: int32 Tensor of shape [batch_size, seq_length].\n      input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].\n      token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      use_one_hot_embeddings: (optional) bool. Whether to use one-hot word\n        embeddings or tf.embedding_lookup() for the word embeddings.\n      scope: (optional) variable scope. Defaults to ""bert"".\n\n    Raises:\n      ValueError: The config is invalid or one of the input tensor shapes\n        is invalid.\n    """"""\n    config = copy.deepcopy(config)\n    if not is_training:\n      config.hidden_dropout_prob = 0.0\n      config.attention_probs_dropout_prob = 0.0\n\n    input_shape = get_shape_list(input_ids, expected_rank=2)\n    batch_size = input_shape[0]\n    seq_length = input_shape[1]\n\n    if input_mask is None:\n      input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    if token_type_ids is None:\n      token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    with tf.variable_scope(scope, default_name=""bert""):\n      with tf.variable_scope(""embeddings""):\n        # Perform embedding lookup on the word ids.\n        (self.embedding_output, self.embedding_table) = embedding_lookup(\n            input_ids=input_ids,\n            vocab_size=config.vocab_size,\n            embedding_size=config.hidden_size,\n            initializer_range=config.initializer_range,\n            word_embedding_name=""word_embeddings"",\n            use_one_hot_embeddings=use_one_hot_embeddings)\n\n        # Add positional embeddings and token type embeddings, then layer\n        # normalize and perform dropout.\n        self.embedding_output = embedding_postprocessor(\n            input_tensor=self.embedding_output,\n            use_token_type=True,\n            token_type_ids=token_type_ids,\n            token_type_vocab_size=config.type_vocab_size,\n            token_type_embedding_name=""token_type_embeddings"",\n            use_position_embeddings=True,\n            position_embedding_name=""position_embeddings"",\n            initializer_range=config.initializer_range,\n            max_position_embeddings=config.max_position_embeddings,\n            dropout_prob=config.hidden_dropout_prob)\n\n      with tf.variable_scope(""encoder""):\n        # This converts a 2D mask of shape [batch_size, seq_length] to a 3D\n        # mask of shape [batch_size, seq_length, seq_length] which is used\n        # for the attention scores.\n        attention_mask = create_attention_mask_from_input_mask(\n            input_ids, input_mask)\n\n        # Run the stacked transformer.\n        # `sequence_output` shape = [batch_size, seq_length, hidden_size].\n        self.all_encoder_layers = transformer_model(\n            input_tensor=self.embedding_output,\n            attention_mask=attention_mask,\n            hidden_size=config.hidden_size,\n            num_hidden_layers=config.num_hidden_layers,\n            num_attention_heads=config.num_attention_heads,\n            intermediate_size=config.intermediate_size,\n            intermediate_act_fn=get_activation(config.hidden_act),\n            hidden_dropout_prob=config.hidden_dropout_prob,\n            attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n            initializer_range=config.initializer_range,\n            do_return_all_layers=True)\n\n      self.sequence_output = self.all_encoder_layers[-1] # [batch_size, seq_length, hidden_size]\n      # The ""pooler"" converts the encoded sequence tensor of shape\n      # [batch_size, seq_length, hidden_size] to a tensor of shape\n      # [batch_size, hidden_size]. This is necessary for segment-level\n      # (or segment-pair-level) classification tasks where we need a fixed\n      # dimensional representation of the segment.\n      with tf.variable_scope(""pooler""):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token. We assume that this has been pre-trained\n        first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)\n        self.pooled_output = tf.layers.dense(\n            first_token_tensor,\n            config.hidden_size,\n            activation=tf.tanh,\n            kernel_initializer=create_initializer(config.initializer_range))\n\n  def get_pooled_output(self):\n    return self.pooled_output\n\n  def get_sequence_output(self):\n    """"""Gets final hidden layer of encoder.\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the final hidden of the transformer encoder.\n    """"""\n    return self.sequence_output\n\n  def get_all_encoder_layers(self):\n    return self.all_encoder_layers\n\n  def get_embedding_output(self):\n    """"""Gets output of the embedding lookup (i.e., input to the transformer).\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the output of the embedding layer, after summing the word\n      embeddings with the positional embeddings and the token type embeddings,\n      then performing layer normalization. This is the input to the transformer.\n    """"""\n    return self.embedding_output\n\n  def get_embedding_table(self):\n    return self.embedding_table\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef get_activation(activation_string):\n  """"""Maps a string to a Python function, e.g., ""relu"" => `tf.nn.relu`.\n\n  Args:\n    activation_string: String name of the activation function.\n\n  Returns:\n    A Python function corresponding to the activation function. If\n    `activation_string` is None, empty, or ""linear"", this will return None.\n    If `activation_string` is not a string, it will return `activation_string`.\n\n  Raises:\n    ValueError: The `activation_string` does not correspond to a known\n      activation.\n  """"""\n\n  # We assume that anything that""s not a string is already an activation\n  # function, so we just return it.\n  if not isinstance(activation_string, six.string_types):\n    return activation_string\n\n  if not activation_string:\n    return None\n\n  act = activation_string.lower()\n  if act == ""linear"":\n    return None\n  elif act == ""relu"":\n    return tf.nn.relu\n  elif act == ""gelu"":\n    return gelu\n  elif act == ""tanh"":\n    return tf.tanh\n  else:\n    raise ValueError(""Unsupported activation: %s"" % act)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    if name not in name_to_variable:\n      continue\n    assignment_map[name] = name\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\ndef dropout(input_tensor, dropout_prob):\n  """"""Perform dropout.\n\n  Args:\n    input_tensor: float Tensor.\n    dropout_prob: Python float. The probability of dropping out a value (NOT of\n      *keeping* a dimension as in `tf.nn.dropout`).\n\n  Returns:\n    A version of `input_tensor` with dropout applied.\n  """"""\n  if dropout_prob is None or dropout_prob == 0.0:\n    return input_tensor\n\n  output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob)\n  return output\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n  """"""Runs layer normalization followed by dropout.""""""\n  output_tensor = layer_norm(input_tensor, name)\n  output_tensor = dropout(output_tensor, dropout_prob)\n  return output_tensor\n\n\ndef create_initializer(initializer_range=0.02):\n  """"""Creates a `truncated_normal_initializer` with the given range.""""""\n  return tf.truncated_normal_initializer(stddev=initializer_range)\n\n\ndef embedding_lookup(input_ids,\n                     vocab_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n  """"""Looks up words embeddings for id tensor.\n\n  Args:\n    input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n      ids.\n    vocab_size: int. Size of the embedding vocabulary.\n    embedding_size: int. Width of the word embeddings.\n    initializer_range: float. Embedding initialization range.\n    word_embedding_name: string. Name of the embedding table.\n    use_one_hot_embeddings: bool. If True, use one-hot method for word\n      embeddings. If False, use `tf.gather()`.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, embedding_size].\n  """"""\n  # This function assumes that the input is of shape [batch_size, seq_length,\n  # num_inputs].\n  #\n  # If the input is a 2D tensor of shape [batch_size, seq_length], we\n  # reshape to [batch_size, seq_length, 1].\n  if input_ids.shape.ndims == 2:\n    input_ids = tf.expand_dims(input_ids, axis=[-1])\n\n  embedding_table = tf.get_variable(\n      name=word_embedding_name,\n      shape=[vocab_size, embedding_size],\n      initializer=create_initializer(initializer_range))\n\n  flat_input_ids = tf.reshape(input_ids, [-1])\n  if use_one_hot_embeddings:\n    one_hot_input_ids = tf.one_hot(flat_input_ids, depth=vocab_size)\n    output = tf.matmul(one_hot_input_ids, embedding_table)\n  else:\n    output = tf.gather(embedding_table, flat_input_ids)\n\n  input_shape = get_shape_list(input_ids)\n\n  output = tf.reshape(output,\n                      input_shape[0:-1] + [input_shape[-1] * embedding_size])\n  return (output, embedding_table)\n\n\ndef embedding_postprocessor(input_tensor,\n                            use_token_type=False,\n                            token_type_ids=None,\n                            token_type_vocab_size=16,\n                            token_type_embedding_name=""token_type_embeddings"",\n                            use_position_embeddings=True,\n                            position_embedding_name=""position_embeddings"",\n                            initializer_range=0.02,\n                            max_position_embeddings=512,\n                            dropout_prob=0.1):\n  """"""Performs various post-processing on a word embedding tensor.\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length,\n      embedding_size].\n    use_token_type: bool. Whether to add embeddings for `token_type_ids`.\n    token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      Must be specified if `use_token_type` is True.\n    token_type_vocab_size: int. The vocabulary size of `token_type_ids`.\n    token_type_embedding_name: string. The name of the embedding table variable\n      for token type ids.\n    use_position_embeddings: bool. Whether to add position embeddings for the\n      position of each token in the sequence.\n    position_embedding_name: string. The name of the embedding table variable\n      for positional embeddings.\n    initializer_range: float. Range of the weight initialization.\n    max_position_embeddings: int. Maximum sequence length that might ever be\n      used with this model. This can be longer than the sequence length of\n      input_tensor, but cannot be shorter.\n    dropout_prob: float. Dropout probability applied to the final output tensor.\n\n  Returns:\n    float tensor with same shape as `input_tensor`.\n\n  Raises:\n    ValueError: One of the tensor shapes or input values is invalid.\n  """"""\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  width = input_shape[2]\n\n  output = input_tensor\n\n  if use_token_type:\n    if token_type_ids is None:\n      raise ValueError(""`token_type_ids` must be specified if""\n                       ""`use_token_type` is True."")\n    token_type_table = tf.get_variable(\n        name=token_type_embedding_name,\n        shape=[token_type_vocab_size, width],\n        initializer=create_initializer(initializer_range))\n    # This vocab will be small so we always do one-hot here, since it is always\n    # faster for a small vocabulary.\n    flat_token_type_ids = tf.reshape(token_type_ids, [-1])\n    one_hot_ids = tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)\n    token_type_embeddings = tf.matmul(one_hot_ids, token_type_table)\n    token_type_embeddings = tf.reshape(token_type_embeddings,\n                                       [batch_size, seq_length, width])\n    output += token_type_embeddings\n\n  if use_position_embeddings:\n    assert_op = tf.assert_less_equal(seq_length, max_position_embeddings)\n    with tf.control_dependencies([assert_op]):\n      full_position_embeddings = tf.get_variable(\n          name=position_embedding_name,\n          shape=[max_position_embeddings, width],\n          initializer=create_initializer(initializer_range))\n      # Since the position embedding table is a learned variable, we create it\n      # using a (long) sequence length `max_position_embeddings`. The actual\n      # sequence length might be shorter than this, for faster training of\n      # tasks that do not have long sequences.\n      #\n      # So `full_position_embeddings` is effectively an embedding table\n      # for position [0, 1, 2, ..., max_position_embeddings-1], and the current\n      # sequence has positions [0, 1, 2, ... seq_length-1], so we can just\n      # perform a slice.\n      position_embeddings = tf.slice(full_position_embeddings, [0, 0],\n                                     [seq_length, -1])\n      num_dims = len(output.shape.as_list())\n\n      # Only the last two dimensions are relevant (`seq_length` and `width`), so\n      # we broadcast among the first dimensions, which is typically just\n      # the batch size.\n      position_broadcast_shape = []\n      for _ in range(num_dims - 2):\n        position_broadcast_shape.append(1)\n      position_broadcast_shape.extend([seq_length, width])\n      position_embeddings = tf.reshape(position_embeddings,\n                                       position_broadcast_shape)\n      output += position_embeddings\n\n  output = layer_norm_and_dropout(output, dropout_prob)\n  return output\n\n\ndef create_attention_mask_from_input_mask(from_tensor, to_mask):\n  """"""Create 3D attention mask from a 2D tensor mask.\n\n  Args:\n    from_tensor: 2D or 3D Tensor of shape [batch_size, from_seq_length, ...].\n    to_mask: int32 Tensor of shape [batch_size, to_seq_length].\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length, to_seq_length].\n  """"""\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  batch_size = from_shape[0]\n  from_seq_length = from_shape[1]\n\n  to_shape = get_shape_list(to_mask, expected_rank=2)\n  to_seq_length = to_shape[1]\n\n  to_mask = tf.cast(\n      tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)\n\n  # We don\'t assume that `from_tensor` is a mask (although it could be). We\n  # don\'t actually care if we attend *from* padding tokens (only *to* padding)\n  # tokens so we create a tensor of all ones.\n  #\n  # `broadcast_ones` = [batch_size, from_seq_length, 1]\n  broadcast_ones = tf.ones(\n      shape=[batch_size, from_seq_length, 1], dtype=tf.float32)\n\n  # Here we broadcast along two dimensions to create the mask.\n  mask = broadcast_ones * to_mask\n\n  return mask\n\n\ndef attention_layer(from_tensor,\n                    to_tensor,\n                    attention_mask=None,\n                    num_attention_heads=1,\n                    size_per_head=512,\n                    query_act=None,\n                    key_act=None,\n                    value_act=None,\n                    attention_probs_dropout_prob=0.0,\n                    initializer_range=0.02,\n                    do_return_2d_tensor=False,\n                    batch_size=None,\n                    from_seq_length=None,\n                    to_seq_length=None):\n  """"""Performs multi-headed attention from `from_tensor` to `to_tensor`.\n\n  This is an implementation of multi-headed attention based on ""Attention\n  is all you Need"". If `from_tensor` and `to_tensor` are the same, then\n  this is self-attention. Each timestep in `from_tensor` attends to the\n  corresponding sequence in `to_tensor`, and returns a fixed-with vector.\n\n  This function first projects `from_tensor` into a ""query"" tensor and\n  `to_tensor` into ""key"" and ""value"" tensors. These are (effectively) a list\n  of tensors of length `num_attention_heads`, where each tensor is of shape\n  [batch_size, seq_length, size_per_head].\n\n  Then, the query and key tensors are dot-producted and scaled. These are\n  softmaxed to obtain attention probabilities. The value tensors are then\n  interpolated by these probabilities, then concatenated back to a single\n  tensor and returned.\n\n  In practice, the multi-headed attention are done with transposes and\n  reshapes rather than actual separate tensors.\n\n  Args:\n    from_tensor: float Tensor of shape [batch_size, from_seq_length,\n      from_width].\n    to_tensor: float Tensor of shape [batch_size, to_seq_length, to_width].\n    attention_mask: (optional) int32 Tensor of shape [batch_size,\n      from_seq_length, to_seq_length]. The values should be 1 or 0. The\n      attention scores will effectively be set to -infinity for any positions in\n      the mask that are 0, and will be unchanged for positions that are 1.\n    num_attention_heads: int. Number of attention heads.\n    size_per_head: int. Size of each attention head.\n    query_act: (optional) Activation function for the query transform.\n    key_act: (optional) Activation function for the key transform.\n    value_act: (optional) Activation function for the value transform.\n    attention_probs_dropout_prob: (optional) float. Dropout probability of the\n      attention probabilities.\n    initializer_range: float. Range of the weight initializer.\n    do_return_2d_tensor: bool. If True, the output will be of shape [batch_size\n      * from_seq_length, num_attention_heads * size_per_head]. If False, the\n      output will be of shape [batch_size, from_seq_length, num_attention_heads\n      * size_per_head].\n    batch_size: (Optional) int. If the input is 2D, this might be the batch size\n      of the 3D version of the `from_tensor` and `to_tensor`.\n    from_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `from_tensor`.\n    to_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `to_tensor`.\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length,\n      num_attention_heads * size_per_head]. (If `do_return_2d_tensor` is\n      true, this will be of shape [batch_size * from_seq_length,\n      num_attention_heads * size_per_head]).\n\n  Raises:\n    ValueError: Any of the arguments or tensor shapes are invalid.\n  """"""\n\n  def transpose_for_scores(input_tensor, batch_size, num_attention_heads,\n                           seq_length, width):\n    output_tensor = tf.reshape(\n        input_tensor, [batch_size, seq_length, num_attention_heads, width])\n\n    output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])\n    return output_tensor\n\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])\n\n  if len(from_shape) != len(to_shape):\n    raise ValueError(\n        ""The rank of `from_tensor` must match the rank of `to_tensor`."")\n\n  if len(from_shape) == 3:\n    batch_size = from_shape[0]\n    from_seq_length = from_shape[1]\n    to_seq_length = to_shape[1]\n  elif len(from_shape) == 2:\n    if (batch_size is None or from_seq_length is None or to_seq_length is None):\n      raise ValueError(\n          ""When passing in rank 2 tensors to attention_layer, the values ""\n          ""for `batch_size`, `from_seq_length`, and `to_seq_length` ""\n          ""must all be specified."")\n\n  # Scalar dimensions referenced here:\n  #   B = batch size (number of sequences)\n  #   F = `from_tensor` sequence length\n  #   T = `to_tensor` sequence length\n  #   N = `num_attention_heads`\n  #   H = `size_per_head`\n\n  from_tensor_2d = reshape_to_matrix(from_tensor)\n  to_tensor_2d = reshape_to_matrix(to_tensor)\n\n  # `query_layer` = [B*F, N*H]\n  query_layer = tf.layers.dense(\n      from_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=query_act,\n      name=""query"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `key_layer` = [B*T, N*H]\n  key_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=key_act,\n      name=""key"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `value_layer` = [B*T, N*H]\n  value_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=value_act,\n      name=""value"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `query_layer` = [B, N, F, H]\n  query_layer = transpose_for_scores(query_layer, batch_size,\n                                     num_attention_heads, from_seq_length,\n                                     size_per_head)\n\n  # `key_layer` = [B, N, T, H]\n  key_layer = transpose_for_scores(key_layer, batch_size, num_attention_heads,\n                                   to_seq_length, size_per_head)\n\n  # Take the dot product between ""query"" and ""key"" to get the raw\n  # attention scores.\n  # `attention_scores` = [B, N, F, T]\n  attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)\n  attention_scores = tf.multiply(attention_scores,\n                                 1.0 / math.sqrt(float(size_per_head)))\n\n  if attention_mask is not None:\n    # `attention_mask` = [B, 1, F, T]\n    attention_mask = tf.expand_dims(attention_mask, axis=[1])\n\n    # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n    # masked positions, this operation will create a tensor which is 0.0 for\n    # positions we want to attend and -10000.0 for masked positions.\n    adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0\n\n    # Since we are adding it to the raw scores before the softmax, this is\n    # effectively the same as removing these entirely.\n    attention_scores += adder\n\n  # Normalize the attention scores to probabilities.\n  # `attention_probs` = [B, N, F, T]\n  attention_probs = tf.nn.softmax(attention_scores)\n\n  # This is actually dropping out entire tokens to attend to, which might\n  # seem a bit unusual, but is taken from the original Transformer paper.\n  attention_probs = dropout(attention_probs, attention_probs_dropout_prob)\n\n  # `value_layer` = [B, T, N, H]\n  value_layer = tf.reshape(\n      value_layer,\n      [batch_size, to_seq_length, num_attention_heads, size_per_head])\n\n  # `value_layer` = [B, N, T, H]\n  value_layer = tf.transpose(value_layer, [0, 2, 1, 3])\n\n  # `context_layer` = [B, N, F, H]\n  context_layer = tf.matmul(attention_probs, value_layer)\n\n  # `context_layer` = [B, F, N, H]\n  context_layer = tf.transpose(context_layer, [0, 2, 1, 3])\n\n  if do_return_2d_tensor:\n    # `context_layer` = [B*F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size * from_seq_length, num_attention_heads * size_per_head])\n  else:\n    # `context_layer` = [B, F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size, from_seq_length, num_attention_heads * size_per_head])\n\n  return context_layer\n\n\ndef transformer_model(input_tensor,\n                      attention_mask=None,\n                      hidden_size=768,\n                      num_hidden_layers=12,\n                      num_attention_heads=12,\n                      intermediate_size=3072,\n                      intermediate_act_fn=gelu,\n                      hidden_dropout_prob=0.1,\n                      attention_probs_dropout_prob=0.1,\n                      initializer_range=0.02,\n                      do_return_all_layers=False):\n  """"""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n  This is almost an exact implementation of the original Transformer encoder.\n\n  See the original paper:\n  https://arxiv.org/abs/1706.03762\n\n  Also see:\n  https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n    attention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n      seq_length], with 1 for positions that can be attended to and 0 in\n      positions that should not be.\n    hidden_size: int. Hidden size of the Transformer.\n    num_hidden_layers: int. Number of layers (blocks) in the Transformer.\n    num_attention_heads: int. Number of attention heads in the Transformer.\n    intermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n      forward) layer.\n    intermediate_act_fn: function. The non-linear activation function to apply\n      to the output of the intermediate/feed-forward layer.\n    hidden_dropout_prob: float. Dropout probability for the hidden layers.\n    attention_probs_dropout_prob: float. Dropout probability of the attention\n      probabilities.\n    initializer_range: float. Range of the initializer (stddev of truncated\n      normal).\n    do_return_all_layers: Whether to also return all layers or just the final\n      layer.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, hidden_size], the final\n    hidden layer of the Transformer.\n\n  Raises:\n    ValueError: A Tensor shape or parameter is invalid.\n  """"""\n  if hidden_size % num_attention_heads != 0:\n    raise ValueError(\n        ""The hidden size (%d) is not a multiple of the number of attention ""\n        ""heads (%d)"" % (hidden_size, num_attention_heads))\n\n  attention_head_size = int(hidden_size / num_attention_heads)\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  input_width = input_shape[2]\n\n  # The Transformer performs sum residuals on all layers so the input needs\n  # to be the same as the hidden size.\n  if input_width != hidden_size:\n    raise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n                     (input_width, hidden_size))\n\n  # We keep the representation as a 2D tensor to avoid re-shaping it back and\n  # forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n  # the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n  # help the optimizer.\n  prev_output = reshape_to_matrix(input_tensor)\n\n  all_layer_outputs = []\n  for layer_idx in range(num_hidden_layers):\n    with tf.variable_scope(""layer_%d"" % layer_idx):\n      layer_input = prev_output\n\n      with tf.variable_scope(""attention""):\n        attention_heads = []\n        with tf.variable_scope(""self""):\n          attention_head = attention_layer(\n              from_tensor=layer_input,\n              to_tensor=layer_input,\n              attention_mask=attention_mask,\n              num_attention_heads=num_attention_heads,\n              size_per_head=attention_head_size,\n              attention_probs_dropout_prob=attention_probs_dropout_prob,\n              initializer_range=initializer_range,\n              do_return_2d_tensor=True,\n              batch_size=batch_size,\n              from_seq_length=seq_length,\n              to_seq_length=seq_length)\n          attention_heads.append(attention_head)\n\n        attention_output = None\n        if len(attention_heads) == 1:\n          attention_output = attention_heads[0]\n        else:\n          # In the case where we have other sequences, we just concatenate\n          # them to the self-attention head before the projection.\n          attention_output = tf.concat(attention_heads, axis=-1)\n\n        # Run a linear projection of `hidden_size` then add a residual\n        # with `layer_input`.\n        with tf.variable_scope(""output""):\n          attention_output = tf.layers.dense(\n              attention_output,\n              hidden_size,\n              kernel_initializer=create_initializer(initializer_range))\n          attention_output = dropout(attention_output, hidden_dropout_prob)\n          attention_output = layer_norm(attention_output + layer_input)\n\n      # The activation is only applied to the ""intermediate"" hidden layer.\n      with tf.variable_scope(""intermediate""):\n        intermediate_output = tf.layers.dense(\n            attention_output,\n            intermediate_size,\n            activation=intermediate_act_fn,\n            kernel_initializer=create_initializer(initializer_range))\n\n      # Down-project back to `hidden_size` then add the residual.\n      with tf.variable_scope(""output""):\n        layer_output = tf.layers.dense(\n            intermediate_output,\n            hidden_size,\n            kernel_initializer=create_initializer(initializer_range))\n        layer_output = dropout(layer_output, hidden_dropout_prob)\n        layer_output = layer_norm(layer_output + attention_output)\n        prev_output = layer_output\n        all_layer_outputs.append(layer_output)\n\n  if do_return_all_layers:\n    final_outputs = []\n    for layer_output in all_layer_outputs:\n      final_output = reshape_from_matrix(layer_output, input_shape)\n      final_outputs.append(final_output)\n    return final_outputs\n  else:\n    final_output = reshape_from_matrix(prev_output, input_shape)\n    return final_output\n\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n  """"""Returns a list of the shape of tensor, preferring static dimensions.\n\n  Args:\n    tensor: A tf.Tensor object to find the shape of.\n    expected_rank: (optional) int. The expected rank of `tensor`. If this is\n      specified and the `tensor` has a different rank, and exception will be\n      thrown.\n    name: Optional name of the tensor for the error message.\n\n  Returns:\n    A list of dimensions of the shape of tensor. All static dimensions will\n    be returned as python integers, and dynamic dimensions will be returned\n    as tf.Tensor scalars.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  if expected_rank is not None:\n    assert_rank(tensor, expected_rank, name)\n\n  shape = tensor.shape.as_list()\n\n  non_static_indexes = []\n  for (index, dim) in enumerate(shape):\n    if dim is None:\n      non_static_indexes.append(index)\n\n  if not non_static_indexes:\n    return shape\n\n  dyn_shape = tf.shape(tensor)\n  for index in non_static_indexes:\n    shape[index] = dyn_shape[index]\n  return shape\n\n\ndef reshape_to_matrix(input_tensor):\n  """"""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n  ndims = input_tensor.shape.ndims\n  if ndims < 2:\n    raise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n                     (input_tensor.shape))\n  if ndims == 2:\n    return input_tensor\n\n  width = input_tensor.shape[-1]\n  output_tensor = tf.reshape(input_tensor, [-1, width])\n  return output_tensor\n\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n  """"""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n  if len(orig_shape_list) == 2:\n    return output_tensor\n\n  output_shape = get_shape_list(output_tensor)\n\n  orig_dims = orig_shape_list[0:-1]\n  width = output_shape[-1]\n\n  return tf.reshape(output_tensor, orig_dims + [width])\n\n\ndef assert_rank(tensor, expected_rank, name=None):\n  """"""Raises an exception if the tensor rank is not of the expected rank.\n\n  Args:\n    tensor: A tf.Tensor to check the rank of.\n    expected_rank: Python integer or list of integers, expected rank.\n    name: Optional name of the tensor for the error message.\n\n  Raises:\n    ValueError: If the expected shape doesn\'t match the actual shape.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  expected_rank_dict = {}\n  if isinstance(expected_rank, six.integer_types):\n    expected_rank_dict[expected_rank] = True\n  else:\n    for x in expected_rank:\n      expected_rank_dict[x] = True\n\n  actual_rank = tensor.shape.ndims\n  if actual_rank not in expected_rank_dict:\n    scope_name = tf.get_variable_scope().name\n    raise ValueError(\n        ""For the tensor `%s` in scope `%s`, the actual rank ""\n        ""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n        (name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n'"
baselines/models/roberta/optimization.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.98, # 0.98 ONLY USED FOR PRETRAIN. MUST CHANGE AT FINE-TUNING 0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n\n  # tvars=find_train_variables(tvars) # fix parameters from layer 0 to layer9.\n\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\ndef find_train_variables(tvars):\n    """"""\n    get trainable variables only to train from layer 9 to last layer\n    :param tvars: a list\n    :return: a new tvars, which is list\n    """"""\n    # bert/encoder/layer_21, bert/encoder/layer_9, bert/encoder/layer_20/attention/output/dense/bias:0, bert/encoder/layer_20/attention/output/dense/kernel:\n    tvars_result_list=[]\n\n    for var in tvars:\n        if \'cls/predictions\' in var.name or \'bert/pooler/dense\' in  var.name: # \xe6\x9c\x80\xe5\x90\x8e\xe5\x87\xa0\xe5\xb1\x82\n            tvars_result_list.append(var)\n        else: # \xe5\x90\x8e\xe5\x8d\x8a\xe4\xb8\xaa\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\n            layer_number_list=re.findall(""layer_(.+?)/"", var.name)\n            if len(layer_number_list)>0 and isinstance(layer_number_list[0],int): # \xe5\x8c\xb9\xe9\x85\x8d\xe5\x88\xb0\xe4\xba\x86\xe4\xb8\x80\xe4\xb8\xaa\xe6\x95\xb0\xe5\xad\x97\n                layer_number=int(layer_number_list[0])\n                if layer_number>=9:\n                    tvars_result_list.append(var)\n\n    # print train variables\n    for i,var_ in enumerate(tvars_result_list):\n        print(""####find_train_variables.i:"",i, ""variable name:"",var_.name)\n\n    print(""####find_train_variables:length of tvars_result_list:"",tvars_result_list)\n    return tvars_result_list\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/roberta/optimization_finetuning.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.999, # 0.98 ONLY USED FOR PRETRAIN. MUST CHANGE AT FINE-TUNING 0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/roberta/run_classifier.py,130,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:30:31\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport modeling\nimport optimization_finetuning as optimization\nimport tokenization\nimport tensorflow as tf\n# from loss import bi_tempered_logistic_loss\nimport sys\nimport time\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n# Required parameters\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input data dir. Should contain the .tsv files (or other data files) ""\n    ""for the task."")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""task_name"", None, ""The name of the task to train."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n# Other parameters\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(\n    ""do_predict"", False,\n    ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_integer(""keep_checkpoint_max"", 1,\n                   ""Total number of training keep checkpoint."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 100,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n  return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    features[""label_ids""] = create_int_feature([feature.label_id])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 labels, num_labels, use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use model.get_sequence_output()\n  # instead.\n  output_layer = model.get_pooled_output()\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs,\n                                      axis=-1)  # todo 08-29 try temp-loss\n    ###############bi_tempered_logistic_loss############################################################################\n    # print(""##cross entropy loss is used....""); tf.logging.info(""##cross entropy loss is used...."")\n    # t1=0.9 #t1=0.90\n    # t2=1.05 #t2=1.05\n    # per_example_loss=bi_tempered_logistic_loss(log_probs,one_hot_labels,t1,t2,label_smoothing=0.1,num_iters=5) # TODO label_smoothing=0.0\n    # tf.logging.info(""per_example_loss:""+str(per_example_loss.shape))\n    ##############bi_tempered_logistic_loss#############################################################################\n\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n    is_real_example = None\n    if ""is_real_example"" in features:\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n    else:\n      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,\n        num_labels, use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n       ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(\n            labels=label_ids, predictions=predictions, weights=is_real_example)\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn,\n                      [per_example_loss, label_ids, logits, is_real_example])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={""probabilities"": probabilities},\n          scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef input_fn_builder(features, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_input_ids = []\n  all_input_mask = []\n  all_segment_ids = []\n  all_label_ids = []\n\n  for feature in features:\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_segment_ids.append(feature.segment_ids)\n    all_label_ids.append(feature.label_id)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""segment_ids"":\n            tf.constant(\n                all_segment_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""label_ids"":\n            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),\n    })\n\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)\n    return d\n\n  return input_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer):\n  """"""Convert a set of `InputExample`s to a list of `InputFeatures`.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    features.append(feature)\n  return features\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval` or `do_predict\' must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  # Cloud TPU: Invalid TPU configuration, ensure ClusterResolver is passed to tpu.\n  print(""###tpu_cluster_resolver:"", tpu_cluster_resolver)\n  print(""###save_checkpoints_steps:"", FLAGS.save_checkpoints_steps)\n  print(""###keep_checkpoint_max:"", FLAGS.keep_checkpoint_max)\n  if FLAGS.do_train:\n    iterations_per_loop = int(min(FLAGS.iterations_per_loop,              \n                                  FLAGS.save_checkpoints_steps))          \n  else:\n    iterations_per_loop = FLAGS.iterations_per_loop \n\n  run_config = tf.contrib.tpu.RunConfig(\n      keep_checkpoint_max=FLAGS.keep_checkpoint_max,\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train or FLAGS.do_eval:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)  # TODO\n    print(""###length of total train_examples:"", len(train_examples))\n    num_train_steps = int(len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n    print(""###num_train_steps :"", num_train_steps)\n    print(""###num_warmup_steps :"", num_warmup_steps)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      num_labels=len(label_list),\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n    train_file_exists = os.path.exists(train_file)\n    print(""###train_file_exists:"", train_file_exists, "" ;train_file:"", train_file)\n    if not train_file_exists:  # if tf_record file not exist, convert from raw text file. # TODO\n      if task_name == ""inews"":\n        file_based_convert_examples_to_features_for_inews(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n      else:\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    # dev dataset\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    num_actual_eval_examples = len(eval_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on. These do NOT count towards the metric (all tf.metrics\n      # support a per-instance weight, and these get a weight of 0.0).\n      while len(eval_examples) % FLAGS.eval_batch_size != 0:\n        eval_examples.append(PaddingInputExample())\n\n    eval_file = os.path.join(FLAGS.output_dir, ""dev.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(eval_examples), num_actual_eval_examples,\n                    len(eval_examples) - num_actual_eval_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      assert len(eval_examples) % FLAGS.eval_batch_size == 0\n      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    ### select best model ###\n\n    best_trial_info_file = os.path.join(FLAGS.output_dir, ""best_trial.txt"")\n\n    def _best_trial_info():\n      """"""Returns information about which checkpoints have been evaled so far.""""""\n      if tf.gfile.Exists(best_trial_info_file):\n        with tf.gfile.GFile(best_trial_info_file, ""r"") as best_info:\n          global_step, best_metric_global_step, metric_value = (\n              best_info.read().split("":""))\n          global_step = int(global_step)\n          best_metric_global_step = int(best_metric_global_step)\n          metric_value = float(metric_value)\n      else:\n        metric_value = -1\n        best_metric_global_step = -1\n        global_step = -1\n      tf.logging.info(\n          ""Best trial info: Step: %s, Best Value Step: %s, ""\n          ""Best Value: %s"", global_step, best_metric_global_step, metric_value)\n      return global_step, best_metric_global_step, metric_value\n\n    def _remove_checkpoint(checkpoint_path):\n      for ext in [""meta"", ""data-00000-of-00001"", ""index""]:\n        src_ckpt = checkpoint_path + "".{}"".format(ext)\n        tf.logging.info(""removing {}"".format(src_ckpt))\n        tf.gfile.Remove(src_ckpt)\n\n    def _find_valid_cands(curr_step):\n      filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n      candidates = []\n      for filename in filenames:\n        if filename.endswith("".index""):\n          ckpt_name = filename[:-6]\n          idx = ckpt_name.split(""-"")[-1]\n          if int(idx) > curr_step:\n            candidates.append(filename)\n      return candidates\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n\n    if task_name == ""sts-b"":\n      key_name = ""pearson""\n    elif task_name == ""cola"":\n      key_name = ""matthew_corr""\n    else:\n      key_name = ""eval_accuracy""\n\n    global_step, best_perf_global_step, best_perf = _best_trial_info()\n    writer = tf.gfile.GFile(output_eval_file, ""w"")\n    while global_step < num_train_steps:\n    #while global_step < FLAGS.train_step:\n      steps_and_files = {}\n      filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n      for filename in filenames:\n        if filename.endswith("".index""):\n          ckpt_name = filename[:-6]\n          cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n          gstep = int(cur_filename.split(""-"")[-1])\n          if gstep not in steps_and_files:\n            tf.logging.info(""Add {} to eval list."".format(cur_filename))\n            steps_and_files[gstep] = cur_filename\n      tf.logging.info(""found {} files."".format(len(steps_and_files)))\n      if not steps_and_files:\n        tf.logging.info(""found 0 file, global step: {}. Sleeping.""\n                        .format(global_step))\n        time.sleep(60)\n      else:\n        for checkpoint in sorted(steps_and_files.items()):\n          step, checkpoint_path = checkpoint\n          if global_step >= step:\n            if (best_perf_global_step != step and\n                len(_find_valid_cands(step)) > 1):\n              _remove_checkpoint(checkpoint_path)\n            continue\n          result = estimator.evaluate(\n              input_fn=eval_input_fn,\n              steps=eval_steps,\n              checkpoint_path=checkpoint_path)\n          global_step = result[""global_step""]\n          tf.logging.info(""***** Eval results *****"")\n          for key in sorted(result.keys()):\n            tf.logging.info(""  %s = %s"", key, str(result[key]))\n            writer.write(""%s = %s\\n"" % (key, str(result[key])))\n          writer.write(""best = {}\\n"".format(best_perf))\n          if result[key_name] > best_perf:\n            best_perf = result[key_name]\n            best_perf_global_step = global_step\n          elif len(_find_valid_cands(global_step)) > 1:\n            _remove_checkpoint(checkpoint_path)\n          writer.write(""="" * 50 + ""\\n"")\n          writer.flush()\n          with tf.gfile.GFile(best_trial_info_file, ""w"") as best_info:\n            best_info.write(""{}:{}:{}"".format(\n                global_step, best_perf_global_step, best_perf))\n    writer.close()\n\n    for ext in [""meta"", ""data-00000-of-00001"", ""index""]:\n      src_ckpt = ""model.ckpt-{}.{}"".format(best_perf_global_step, ext)\n      tgt_ckpt = ""model.ckpt-best.{}"".format(ext)\n      tf.logging.info(""saving {} to {}"".format(src_ckpt, tgt_ckpt))\n      tf.io.gfile.rename(\n          os.path.join(FLAGS.output_dir, src_ckpt),\n          os.path.join(FLAGS.output_dir, tgt_ckpt),\n          overwrite=True)\n    #######################################################################################################################\n    # evaluate all checkpoints; you can use the checkpoint with the best dev accuarcy\n    \'\'\'steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_roberta.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        result = estimator.evaluate(input_fn=eval_input_fn,\n                                    steps=eval_steps, checkpoint_path=filename)\n\n        tf.logging.info(""***** Eval results %s *****"" % (filename))\n        writer.write(""***** Eval results %s *****\\n"" % (filename))\n        for key in sorted(result.keys()):\n          tf.logging.info(""  %s = %s"", key, str(result[key]))\n          writer.write(""%s = %s\\n"" % (key, str(result[key])))\'\'\'\n    #######################################################################################################################\n\n    # result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n    #\n    # output_eval_file = os.path.join(FLAGS.output_dir, ""dev_results_roberta.txt"")\n    # with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n    #  tf.logging.info(""***** Eval results *****"")\n    #  for key in sorted(result.keys()):\n    #    tf.logging.info(""  %s = %s"", key, str(result[key]))\n    #    writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    num_actual_predict_examples = len(predict_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on.\n      while len(predict_examples) % FLAGS.predict_batch_size != 0:\n        predict_examples.append(PaddingInputExample())\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(predict_examples, label_list,\n                                                        FLAGS.max_seq_length, tokenizer,\n                                                        predict_file)\n    else:\n      file_based_convert_examples_to_features(predict_examples, label_list,\n                                              FLAGS.max_seq_length, tokenizer,\n                                              predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(predict_examples), num_actual_predict_examples,\n                    len(predict_examples) - num_actual_predict_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_drop_remainder = True if FLAGS.use_tpu else False\n    predict_input_fn = file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=predict_drop_remainder)\n\n    checkpoint_path = os.path.join(FLAGS.output_dir, ""model.ckpt-best"")\n    result = estimator.predict(input_fn=predict_input_fn, checkpoint_path=checkpoint_path)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta/run_ner.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nfrom sklearn.metrics import f1_score, precision_score, recall_score\nfrom tensorflow.python.ops import math_ops\nimport tf_metrics\nimport pickle\nimport codecs\nimport sys\n\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input datadir."",\n)\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model.""\n)\n\nflags.DEFINE_string(\n    ""task_name"", None, ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""token_name"", ""full"", ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written.""\n)\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model).""\n)\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text.""\n)\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization.""\n)\n\nflags.DEFINE_bool(\n    ""do_train"", False,\n    ""Whether to run training.""\n)\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0, ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputExample(object):\n    """"""A single training/test example for simple sequence classification.""""""\n\n    def __init__(self, guid, text, label=None):\n        """"""Constructs a InputExample.\n\n        Args:\n          guid: Unique id for the example.\n          text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n          label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid = guid\n        self.text = text\n        self.label = label\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self, input_ids, input_mask, segment_ids, label_ids, label_mask):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_ids = label_ids\n        self.label_mask = label_mask\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_data(cls, input_file):\n        """"""Reads a BIO data.""""""\n        with open(input_file) as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                word = line.strip().split(\' \')[0]\n                label = line.strip().split(\' \')[-1]\n                if contends.startswith(""-DOCSTART-""):\n                    words.append(\'\')\n                    continue\n                if len(contends) == 0 and words[-1] == \'.\':\n                    l = \' \'.join([label for label in labels if len(label) > 0])\n                    w = \' \'.join([word for word in words if len(word) > 0])\n                    lines.append([l, w])\n                    words = []\n                    labels = []\n                    continue\n                if len(contends) == 0:\n                    continue\n                words.append(word)\n                labels.append(label)\n            return lines\n\n\nclass NerProcessor(DataProcessor):\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""train.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""dev.txt"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""test.txt"")), ""test"")\n\n    def get_labels(self):\n        # return [""I-MISC"", ""I-PER"",  ""I-ORG"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        return [""B-MISC"", ""I-MISC"", ""B-PER"", ""I-PER"", ""B-ORG"", ""I-ORG"", ""B-LOC"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\nclass WeiboNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.train"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.dev"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.test"")), ""test"")\n\n\n    def get_labels(self):\n        return [\'I-PER.NOM\', \'I-PER.NAM\', \'I-GPE.NAM\', \'I-ORG.NAM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        # return [\'B-PER.NOM\', \'I-PER.NOM\', \'B-LOC.NAM\', \'B-PER.NAM\', \'I-PER.NAM\', \'B-GPE.NAM\', \'I-GPE.NAM\', \'B-ORG.NAM\', \'I-ORG.NAM\', \'B-ORG.NOM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'B-LOC.NOM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                if len(tokens) == 2:\n                    words.append(tokens[0])\n                    label = tokens[-1]\n                    if label[0] == \'B\':\n                        label = ""I"" + label[1:]\n                    labels.append(label)\n                else:\n                    if len(contends) == 0 and len(words) > 0:\n                        label = []\n                        word = []\n                        for l, w in zip(labels, words):\n                            if len(l) > 0 and len(w) > 0:\n                                label.append(l)\n                                # self.labels.add(l)\n                                word.append(w)\n                        lines.append([\' \'.join(label), \' \'.join(word)])\n                        words = []\n                        labels = []\n                        continue\n                if contends.startswith(""-DOCSTART-""):\n                    continue\n\n            return lines\n\nclass MsraNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""train1.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""test"")\n\n    def get_labels(self):\n        return [\'B-PERSON\', \'I-PERSON\', \'B-LOCATION\', \'I-LOCATION\', \'B-ORGANIZATION\', \'I-ORGANIZATION\', ""O"", ""[CLS]"", ""[SEP]"", ""X""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            chars = []\n            labels = []\n            len_count = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                for token in tokens:\n                    word, label = token.split(\'/\')\n\n                    if label == ""nr"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-PERSON\'] + [\'I-PERSON\']*(len(word)-1)\n                    elif label == ""ns"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-LOCATION\'] + [\'I-LOCATION\']*(len(word)-1)\n                    elif label == ""nt"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-ORGANIZATION\'] + [\'I-ORGANIZATION\']*(len(word)-1)\n                    else:\n                        assert label == ""o""\n                        chars = chars + list(word)\n                        labels = labels + [""O""] * len(word)\n                lines.append([\' \'.join(labels), \' \'.join(chars)])\n                len_count.append(len(chars))\n                chars = []\n                labels = []\n            return lines\n\n\ndef write_tokens(tokens, mode):\n    if mode == ""test"":\n        path = os.path.join(FLAGS.output_dir, ""token_"" + mode + "".txt"")\n        wf = open(path, \'a\')\n        for token in tokens:\n            if token != ""**NULL**"":\n                wf.write(token + \'\\n\')\n        wf.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode):\n    label_map = {}\n    for (i, label) in enumerate(label_list, 1):\n        label_map[label] = i\n\n    if not os.path.exists(os.path.join(output_dir, \'label2id.pkl\')):\n        with open(os.path.join(output_dir, \'label2id.pkl\'), \'wb\') as w:\n            pickle.dump(label_map, w)\n    textlist = example.text.split(\' \')\n    labellist = example.label.split(\' \')\n    tokens = []\n    labels = []\n    label_mask = []\n    for i, word in enumerate(textlist):\n        token = tokenizer.tokenize(word)\n        tokens.extend(token)\n        label_1 = labellist[i]\n        for m in range(len(token)):\n            if m == 0:\n                labels.append(label_1)\n            else:\n                labels.append(""X"")\n    \n    # tokens = tokenizer.tokenize(example.text)\n    if len(tokens) >= max_seq_length - 1:\n        tokens = tokens[0:(max_seq_length - 2)]\n        labels = labels[0:(max_seq_length - 2)]\n    ntokens = []\n    segment_ids = []\n    label_ids = []\n    ntokens.append(""[CLS]"")\n    segment_ids.append(0)\n    # append(""O"") or append(""[CLS]"") not sure!\n    label_ids.append(label_map[""[CLS]""])\n    label_mask.append(0) # not to predict and train\n    for i, token in enumerate(tokens):\n        ntokens.append(token)\n        segment_ids.append(0)\n        label_ids.append(label_map[labels[i]])\n        if labels[i] == \'X\':\n            label_mask.append(0)\n        else:\n            label_mask.append(1)\n    ntokens.append(""[SEP]"")\n    segment_ids.append(0)\n    label_mask.append(0)\n    # append(""O"") or append(""[SEP]"") not sure!\n    label_ids.append(label_map[""[SEP]""])\n    input_ids = tokenizer.convert_tokens_to_ids(ntokens)\n    input_mask = [1] * len(input_ids)\n    # label_mask = [1] * len(input_ids)\n    while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n        # we don\'t concerned about it!\n        label_ids.append(0)\n        ntokens.append(""**NULL**"")\n        label_mask.append(0)\n    # print(len(input_ids))\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n    assert len(label_ids) == max_seq_length\n    assert len(label_mask) == max_seq_length\n\n    if ex_index < 5:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""guid: %s"" % (example.guid))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        tf.logging.info(""label_ids: %s"" % "" "".join([str(x) for x in label_ids]))\n        tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n        # tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n\n    feature = InputFeatures(\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        label_ids=label_ids,\n        label_mask = label_mask\n    )\n    write_tokens(ntokens, mode)\n    return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file, output_dir, mode=None\n):\n    writer = tf.python_io.TFRecordWriter(output_file)\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 5000 == 0:\n            tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n        feature = convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode)\n\n        def create_int_feature(values):\n            f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n            return f\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(feature.input_ids)\n        features[""input_mask""] = create_int_feature(feature.input_mask)\n        features[""segment_ids""] = create_int_feature(feature.segment_ids)\n        features[""label_ids""] = create_int_feature(feature.label_ids)\n        features[""label_mask""] = create_int_feature(feature.label_mask)\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n        writer.write(tf_example.SerializeToString())\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n    name_to_features = {\n        ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n    }\n\n    def _decode_record(record, name_to_features):\n        example = tf.parse_single_example(record, name_to_features)\n        for name in list(example.keys()):\n            t = example[name]\n            if t.dtype == tf.int64:\n                t = tf.to_int32(t)\n            example[name] = t\n        return example\n\n    def input_fn(params):\n        batch_size = params[""batch_size""]\n        d = tf.data.TFRecordDataset(input_file)\n        if is_training:\n            d = d.repeat()\n            d = d.shuffle(buffer_size=100)\n        d = d.apply(tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder\n        ))\n        return d\n\n    return input_fn\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, label_mask,\n                 segment_ids, labels, num_labels, use_one_hot_embeddings):\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings\n    )\n\n    output_layer = model.get_sequence_output()\n\n    hidden_size = output_layer.shape[-1].value\n\n    output_weight = tf.get_variable(\n        ""output_weights"", [num_labels, hidden_size],\n        initializer=tf.truncated_normal_initializer(stddev=0.02)\n    )\n    output_bias = tf.get_variable(\n        ""output_bias"", [num_labels], initializer=tf.zeros_initializer()\n    )\n    with tf.variable_scope(""loss""):\n        if is_training:\n            output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n        output_layer = tf.reshape(output_layer, [-1, hidden_size])\n        logits = tf.matmul(output_layer, output_weight, transpose_b=True)\n        logits = tf.nn.bias_add(logits, output_bias)\n        logits = tf.reshape(logits, [-1, FLAGS.max_seq_length, num_labels])\n        # mask = tf.cast(input_mask,tf.float32)\n        # loss = tf.contrib.seq2seq.sequence_loss(logits,labels,mask)\n        # return (loss, logits, predict)\n        ##########################################################################\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n        per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n        mask = tf.cast(label_mask, tf.float32)\n        mask_example_loss = per_example_loss * mask\n        loss = tf.reduce_sum(mask_example_loss)\n        probabilities = tf.nn.softmax(logits, axis=-1)\n        predict = tf.argmax(probabilities, axis=-1)\n        return (loss, mask_example_loss, logits, predict)\n        ##########################################################################\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n    def model_fn(features, labels, mode, params):\n        tf.logging.info(""*** Features ***"")\n        for name in sorted(features.keys()):\n            tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n        input_ids = features[""input_ids""]\n        input_mask = features[""input_mask""]\n        segment_ids = features[""segment_ids""]\n        label_ids = features[""label_ids""]\n        label_mask = features[""label_mask""]\n        is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n        (total_loss, per_example_loss, logits, predicts) = create_model(\n            bert_config, is_training, input_ids, input_mask, label_mask, segment_ids, label_ids,\n            num_labels, use_one_hot_embeddings)\n        tvars = tf.trainable_variables()\n        scaffold_fn = None\n        if init_checkpoint:\n            (assignment_map, initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(tvars,\n                                                                                                       init_checkpoint)\n            tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n            if use_tpu:\n                def tpu_scaffold():\n                    tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n                    return tf.train.Scaffold()\n\n                scaffold_fn = tpu_scaffold\n            else:\n                tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        tf.logging.info(""**** Trainable Variables ****"")\n\n        for var in tvars:\n            init_string = """"\n            if var.name in initialized_variable_names:\n                init_string = "", *INIT_FROM_CKPT*""\n            tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                            init_string)\n        output_spec = None\n        if mode == tf.estimator.ModeKeys.TRAIN:\n            train_op = optimization.create_optimizer(\n                total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n            hook_dict = {}\n            hook_dict[\'loss\'] = total_loss\n            hook_dict[\'global_steps\'] = tf.train.get_or_create_global_step()\n            logging_hook = tf.train.LoggingTensorHook(\n                hook_dict, every_n_iter=200)\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                train_op=train_op,\n                scaffold_fn=scaffold_fn,\n                training_hooks=[logging_hook])\n        elif mode == tf.estimator.ModeKeys.EVAL:\n\n            def metric_fn(per_example_loss, label_ids, logits):\n                # def metric_fn(label_ids, logits):\n                predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n                # labels = []\n                # for i, x in enumerate()\n                predict_labels = []\n                # for i in range(1, num_labels - 4):\n                #     predict_labels.append(i)\n                # precision = tf_metrics.precision(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # recall = tf_metrics.recall(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # f = tf_metrics.f1(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n\n                precision = tf_metrics.precision(label_ids, predictions, num_labels, average=""macro"")\n                recall = tf_metrics.recall(label_ids, predictions, num_labels, average=""macro"")\n                f = tf_metrics.f1(label_ids, predictions, num_labels, average=""macro"")\n\n                #\n                return {\n                    ""eval_precision"": precision,\n                    ""eval_recall"": recall,\n                    ""eval_f"": f,\n                    # ""eval_loss"": loss,\n                }\n\n            eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n            # eval_metrics = (metric_fn, [label_ids, logits])\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                eval_metrics=eval_metrics,\n                scaffold_fn=scaffold_fn)\n        else:\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode, predictions=predicts, scaffold_fn=scaffold_fn\n            )\n        return output_spec\n\n    return model_fn\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    processors = {\n        ""ner"": NerProcessor,\n        ""weiboner"": WeiboNERProcessor,\n        ""msraner"": MsraNERProcessor\n    }\n    # if not FLAGS.do_train and not FLAGS.do_eval:\n    #     raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n    bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n    if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n        raise ValueError(\n            ""Cannot use sequence length %d because the BERT model ""\n            ""was only trained up to sequence length %d"" %\n            (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n    if not os.path.exists(FLAGS.output_dir):\n        os.mkdir(FLAGS.output_dir)\n    task_name = FLAGS.task_name.lower()\n    if task_name not in processors:\n        raise ValueError(""Task not found: %s"" % (task_name))\n    processor = processors[task_name]()\n\n    label_list = processor.get_labels()\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    tpu_cluster_resolver = None\n    if FLAGS.use_tpu and FLAGS.tpu_name:\n        tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n            FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n    is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n\n    run_config = tf.contrib.tpu.RunConfig(\n        cluster=tpu_cluster_resolver,\n        master=FLAGS.master,\n        model_dir=FLAGS.output_dir,\n        save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n        tpu_config=tf.contrib.tpu.TPUConfig(\n            iterations_per_loop=FLAGS.iterations_per_loop,\n            num_shards=FLAGS.num_tpu_cores,\n            per_host_input_for_training=is_per_host))\n\n    train_examples = None\n    num_train_steps = None\n    num_warmup_steps = None\n\n    if FLAGS.do_train:\n        train_examples = processor.get_train_examples(FLAGS.data_dir)\n        num_train_steps = int(\n            len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n        print(num_train_steps)\n        num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    model_fn = model_fn_builder(\n        bert_config=bert_config,\n        num_labels=len(label_list) + 1,\n        init_checkpoint=FLAGS.init_checkpoint,\n        learning_rate=FLAGS.learning_rate,\n        num_train_steps=num_train_steps,\n        num_warmup_steps=num_warmup_steps,\n        use_tpu=FLAGS.use_tpu,\n        use_one_hot_embeddings=FLAGS.use_tpu)\n\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n\n    if FLAGS.do_train:\n        train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file, FLAGS.output_dir)\n        tf.logging.info(""***** Running training *****"")\n        tf.logging.info(""  Num examples = %d"", len(train_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n        tf.logging.info(""  Num steps = %d"", num_train_steps)\n        train_input_fn = file_based_input_fn_builder(\n            input_file=train_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=True,\n            drop_remainder=True)\n        estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n    if FLAGS.do_eval:\n        eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n        eval_file = os.path.join(FLAGS.output_dir, ""eval.tf_record"")\n        file_based_convert_examples_to_features(\n            eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file, FLAGS.output_dir)\n\n        tf.logging.info(""***** Running evaluation *****"")\n        tf.logging.info(""  Num examples = %d"", len(eval_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n        eval_steps = None\n        if FLAGS.use_tpu:\n            eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n        eval_drop_remainder = True if FLAGS.use_tpu else False\n        eval_input_fn = file_based_input_fn_builder(\n            input_file=eval_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=eval_drop_remainder)\n        result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n        output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            tf.logging.info(""***** Eval results *****"")\n            for key in sorted(result.keys()):\n                tf.logging.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\n    if FLAGS.do_predict:\n\n        pred_tags = []\n        true_tags = []\n\n        token_path = os.path.join(FLAGS.output_dir, ""token_test.txt"")\n        label_file = os.path.join(FLAGS.output_dir, ""label2id.pkl"")\n        label_masks = []\n        with open(label_file, ""rb"") as rf:\n            label2id = pickle.load(rf)\n            id2label = {value: key for key, value in label2id.items()}\n        if os.path.exists(token_path):\n            os.remove(token_path)\n        predict_examples = processor.get_test_examples(FLAGS.data_dir)\n        ground_truth_file = os.path.join(FLAGS.output_dir, ""ground_truth.txt"")\n        with open(ground_truth_file, \'w\') as writer:\n            for ex_index, example in enumerate(predict_examples):\n                feature = convert_single_example(ex_index, example, label_list, FLAGS.max_seq_length, tokenizer, FLAGS.output_dir, ""test"")\n                line = []\n                for i, id in enumerate(feature.label_ids):\n                    if feature.label_mask[i] == 1:\n                        line.append(id2label[id])\n                        true_tags.append(id2label[id])\n                # output_line = "" "".join(id2label[id] for id in feature.label_ids if id != 0) + ""\\n""\n                output_line = "" "".join(line) + ""\\n""\n                writer.write(output_line)\n                label_masks.append(feature.label_mask)\n        predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n        file_based_convert_examples_to_features(predict_examples, label_list,\n                                                 FLAGS.max_seq_length, tokenizer,\n                                                 predict_file, FLAGS.output_dir, mode=""test"")\n\n        tf.logging.info(""***** Running prediction*****"")\n        tf.logging.info(""  Num examples = %d"", len(predict_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n        if FLAGS.use_tpu:\n            # Warning: According to tpu_estimator.py Prediction on TPU is an\n            # experimental feature and hence not supported here\n            raise ValueError(""Prediction in TPU not supported"")\n        predict_drop_remainder = True if FLAGS.use_tpu else False\n        predict_input_fn = file_based_input_fn_builder(\n            input_file=predict_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=predict_drop_remainder)\n\n        result = estimator.predict(input_fn=predict_input_fn)\n        output_predict_file = os.path.join(FLAGS.output_dir, ""label_test.txt"")\n\n        with open(output_predict_file, \'w\') as writer:\n            for i, prediction in enumerate(result):\n                line = []\n                for j, x in enumerate(prediction):\n                    if label_masks[i][j] == 0:\n                        continue\n                    else:\n                        line.append(id2label[x])\n                        # writer.write(id2label[x] + ""\\n"")\n                        pred_tags.append(id2label[x])\n                output_line = "" "".join(line) + ""\\n""\n                # # output_line = "" "".join(id2label[id] for id in prediction if id != 0) + ""\\n""\n                writer.write(output_line)\n        # evaluate(true_tags, pred_tags, verbose=True)\n        # evaluate(true_tags, pred_tags)\n\n        tmp = codecs.open(os.path.join(FLAGS.output_dir, ""tmp""), \'w\', \'utf8\')\n        with codecs.open(ground_truth_file, \'r\', \'utf8\') as ft, codecs.open(output_predict_file, \'r\', \'utf8\') as fg:\n            for lt, lg in zip(ft, fg):\n                for tl, tg in zip(lt.strip().split(), lg.strip().split()):\n                    print(\'\\t\'.join(["" "", tl, tg]), file=tmp)\n        tmp.close()\n        cmd = ""python %s -d \'\\t\' < %s > %s"" % \\\n                (os.path.join(os.getcwd(), ""conlleval.py""), \\\n                os.path.join(FLAGS.output_dir, ""tmp""), \\\n                os.path.join(FLAGS.data_dir, ""test_results_roberta_large.txt""))\n        os.system(cmd)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""data_dir"")\n    flags.mark_flag_as_required(""task_name"")\n    flags.mark_flag_as_required(""vocab_file"")\n    flags.mark_flag_as_required(""bert_config_file"")\n    flags.mark_flag_as_required(""output_dir"")\n    tf.app.run()\n'"
baselines/models/roberta/run_pretraining.py,97,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run masked LM/next sentence masked_lm pre-training for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport modeling\nimport optimization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(\n    ""input_file"", None,\n    ""Input TF example files (can be a glob or comma separated)."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded. Must match data generation."")\n\nflags.DEFINE_integer(\n    ""max_predictions_per_seq"", 20,\n    ""Maximum number of masked LM predictions per sequence. ""\n    ""Must match data generation."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_integer(""num_train_steps"", 100000, ""Number of training steps."")\n\nflags.DEFINE_integer(""num_warmup_steps"", 10000, ""Number of warmup steps."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(""max_eval_steps"", 100, ""Maximum number of eval steps."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    masked_lm_positions = features[""masked_lm_positions""]\n    masked_lm_ids = features[""masked_lm_ids""]\n    masked_lm_weights = features[""masked_lm_weights""]\n    next_sentence_labels = features[""next_sentence_labels""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    (masked_lm_loss,\n     masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(\n         bert_config, model.get_sequence_output(), model.get_embedding_table(),\n         masked_lm_positions, masked_lm_ids, masked_lm_weights)\n\n    (next_sentence_loss, next_sentence_example_loss, # TODO TODO TODO \xe5\x8f\xaf\xe4\xbb\xa5\xe8\xae\xa1\xe7\xae\x97\xe5\x8d\x95\xe4\xb8\x8d\xe7\xae\x97\xe6\x88\x90\xe7\xbb\xa9\n     next_sentence_log_probs) = get_next_sentence_output(\n         bert_config, model.get_pooled_output(), next_sentence_labels)\n    # batch_size=masked_lm_log_probs.shape[0]\n    # next_sentence_example_loss=tf.zeros((batch_size)) #tf.constant(0.0,dtype=tf.float32)\n    # next_sentence_log_probs=tf.zeros((batch_size,2))\n    total_loss = masked_lm_loss # TODO remove next sentence loss 2019-08-08, + next_sentence_loss\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    print(""init_checkpoint:"",init_checkpoint)\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n                    masked_lm_weights, next_sentence_example_loss,\n                    next_sentence_log_probs, next_sentence_labels):\n        """"""Computes the loss and accuracy of the model.""""""\n        masked_lm_log_probs = tf.reshape(masked_lm_log_probs,[-1, masked_lm_log_probs.shape[-1]])\n        masked_lm_predictions = tf.argmax(masked_lm_log_probs, axis=-1, output_type=tf.int32)\n        masked_lm_example_loss = tf.reshape(masked_lm_example_loss, [-1])\n        masked_lm_ids = tf.reshape(masked_lm_ids, [-1])\n        masked_lm_weights = tf.reshape(masked_lm_weights, [-1])\n        masked_lm_accuracy = tf.metrics.accuracy(\n            labels=masked_lm_ids,\n            predictions=masked_lm_predictions,\n            weights=masked_lm_weights)\n        masked_lm_mean_loss = tf.metrics.mean(\n            values=masked_lm_example_loss, weights=masked_lm_weights)\n\n        next_sentence_log_probs = tf.reshape(\n            next_sentence_log_probs, [-1, next_sentence_log_probs.shape[-1]])\n        next_sentence_predictions = tf.argmax(\n            next_sentence_log_probs, axis=-1, output_type=tf.int32)\n        next_sentence_labels = tf.reshape(next_sentence_labels, [-1])\n        next_sentence_accuracy = tf.metrics.accuracy(\n            labels=next_sentence_labels, predictions=next_sentence_predictions)\n        next_sentence_mean_loss = tf.metrics.mean(\n            values=next_sentence_example_loss)\n\n        return {\n            ""masked_lm_accuracy"": masked_lm_accuracy,\n            ""masked_lm_loss"": masked_lm_mean_loss,\n            ""next_sentence_accuracy"": next_sentence_accuracy,\n            ""next_sentence_loss"": next_sentence_mean_loss,\n        }\n\n      # next_sentence_example_loss=0.0 TODO\n      # next_sentence_log_probs=0.0 # TODO\n      eval_metrics = (metric_fn, [\n          masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n          masked_lm_weights, next_sentence_example_loss,\n          next_sentence_log_probs, next_sentence_labels\n      ])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(""Only TRAIN and EVAL modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef get_masked_lm_output(bert_config, input_tensor, output_weights, positions,\n                         label_ids, label_weights):\n  """"""Get loss and log probs for the masked LM.""""""\n  input_tensor = gather_indexes(input_tensor, positions)\n\n  with tf.variable_scope(""cls/predictions""):\n    # We apply one more non-linear transformation before the output layer.\n    # This matrix is not used after pre-training.\n    with tf.variable_scope(""transform""):\n      input_tensor = tf.layers.dense(\n          input_tensor,\n          units=bert_config.hidden_size,\n          activation=modeling.get_activation(bert_config.hidden_act),\n          kernel_initializer=modeling.create_initializer(\n              bert_config.initializer_range))\n      input_tensor = modeling.layer_norm(input_tensor)\n\n    # The output weights are the same as the input embeddings, but there is\n    # an output-only bias for each token.\n    output_bias = tf.get_variable(\n        ""output_bias"",\n        shape=[bert_config.vocab_size],\n        initializer=tf.zeros_initializer())\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    label_ids = tf.reshape(label_ids, [-1])\n    label_weights = tf.reshape(label_weights, [-1])\n\n    one_hot_labels = tf.one_hot(label_ids, depth=bert_config.vocab_size, dtype=tf.float32)\n\n    # The `positions` tensor might be zero-padded (if the sequence is too\n    # short to have the maximum number of predictions). The `label_weights`\n    # tensor has a value of 1.0 for every real prediction and 0.0 for the\n    # padding predictions.\n    per_example_loss = -tf.reduce_sum(log_probs * one_hot_labels, axis=[-1])\n    numerator = tf.reduce_sum(label_weights * per_example_loss)\n    denominator = tf.reduce_sum(label_weights) + 1e-5\n    loss = numerator / denominator\n\n  return (loss, per_example_loss, log_probs)\n\n\ndef get_next_sentence_output(bert_config, input_tensor, labels):\n  """"""Get loss and log probs for the next sentence prediction.""""""\n\n  # Simple binary classification. Note that 0 is ""next sentence"" and 1 is\n  # ""random sentence"". This weight matrix is not used after pre-training.\n  with tf.variable_scope(""cls/seq_relationship""):\n    output_weights = tf.get_variable(\n        ""output_weights"",\n        shape=[2, bert_config.hidden_size],\n        initializer=modeling.create_initializer(bert_config.initializer_range))\n    output_bias = tf.get_variable(\n        ""output_bias"", shape=[2], initializer=tf.zeros_initializer())\n\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n    labels = tf.reshape(labels, [-1])\n    one_hot_labels = tf.one_hot(labels, depth=2, dtype=tf.float32)\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n    return (loss, per_example_loss, log_probs)\n\n\ndef gather_indexes(sequence_tensor, positions):\n  """"""Gathers the vectors at the specific positions over a minibatch.""""""\n  sequence_shape = modeling.get_shape_list(sequence_tensor, expected_rank=3)\n  batch_size = sequence_shape[0]\n  seq_length = sequence_shape[1]\n  width = sequence_shape[2]\n\n  flat_offsets = tf.reshape(\n      tf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n  flat_positions = tf.reshape(positions + flat_offsets, [-1])\n  flat_sequence_tensor = tf.reshape(sequence_tensor,\n                                    [batch_size * seq_length, width])\n  output_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n  return output_tensor\n\n\ndef input_fn_builder(input_files,\n                     max_seq_length,\n                     max_predictions_per_seq,\n                     is_training,\n                     num_cpu_threads=4):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    name_to_features = {\n        ""input_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""input_mask"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""segment_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""masked_lm_positions"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_ids"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_weights"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.float32),\n        ""next_sentence_labels"":\n            tf.FixedLenFeature([1], tf.int64),\n    }\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = tf.data.Dataset.from_tensor_slices(tf.constant(input_files))\n      d = d.repeat()\n      d = d.shuffle(buffer_size=len(input_files))\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_cpu_threads, len(input_files))\n\n      # `sloppy` mode means that the interleaving is not exact. This adds\n      # even more randomness to the training pipeline.\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n      d = d.shuffle(buffer_size=100)\n    else:\n      d = tf.data.TFRecordDataset(input_files)\n      # Since we evaluate for a fixed number of steps we don\'t want to encounter\n      # out-of-range exceptions.\n      d = d.repeat()\n\n    # We must `drop_remainder` on training because the TPU requires fixed\n    # size dimensions. For eval, we assume we are evaluating on the CPU or GPU\n    # and we *don\'t* want to drop the remainder, otherwise we wont cover\n    # every sample.\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_cpu_threads,\n            drop_remainder=True))\n    return d\n\n  return input_fn\n\n\ndef _decode_record(record, name_to_features):\n  """"""Decodes a record to a TensorFlow example.""""""\n  example = tf.parse_single_example(record, name_to_features)\n\n  # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n  # So cast all int64 to int32.\n  for name in list(example.keys()):\n    t = example[name]\n    if t.dtype == tf.int64:\n      t = tf.to_int32(t)\n    example[name] = t\n\n  return example\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not FLAGS.do_train and not FLAGS.do_eval: # \xe5\xbf\x85\xe9\xa1\xbb\xe6\x98\xaf\xe8\xae\xad\xe7\xbb\x83\xe6\x88\x96\xe9\xaa\x8c\xe8\xaf\x81\xe7\x9a\x84\xe7\xb1\xbb\xe5\x9e\x8b\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file) # \xe4\xbb\x8ejson\xe6\x96\x87\xe4\xbb\xb6\xe4\xb8\xad\xe8\x8e\xb7\xe5\xbe\x97\xe9\x85\x8d\xe7\xbd\xae\xe4\xbf\xa1\xe6\x81\xaf\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  input_files = [] # \xe8\xbe\x93\xe5\x85\xa5\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x98\xaf\xe5\xa4\x9a\xe4\xb8\xaa\xe6\x96\x87\xe4\xbb\xb6\xef\xbc\x8c\xe4\xbb\xa5\xe2\x80\x9c\xe9\x80\x97\xe5\x8f\xb7\xe9\x9a\x94\xe5\xbc\x80\xe2\x80\x9d\xef\xbc\x9b\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8c\xb9\xe9\x85\x8d\xe5\xbd\xa2\xe5\xbc\x8f\xe7\x9a\x84\xef\xbc\x8c\xe5\xa6\x82\xe2\x80\x9cinput_x*\xe2\x80\x9d\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Input Files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"" % input_file)\n\n  tpu_cluster_resolver = None\n  #if FLAGS.use_tpu and FLAGS.tpu_name:\n  tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver( # TODO\n        tpu=FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  print(""###tpu_cluster_resolver:"",tpu_cluster_resolver,"";FLAGS.use_tpu:"",FLAGS.use_tpu,"";FLAGS.tpu_name:"",FLAGS.tpu_name,"";FLAGS.tpu_zone:"",FLAGS.tpu_zone)\n  # ###tpu_cluster_resolver: <tensorflow.python.distribute.cluster_resolver.tpu_cluster_resolver.TPUClusterResolver object at 0x7f4b387b06a0> ;FLAGS.use_tpu: True ;FLAGS.tpu_name: grpc://10.240.1.83:8470\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      keep_checkpoint_max=20, # 10\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=FLAGS.num_train_steps,\n      num_warmup_steps=FLAGS.num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size)\n\n  if FLAGS.do_train:\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    train_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=True)\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.num_train_steps)\n\n  if FLAGS.do_eval:\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    eval_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=False)\n\n    result = estimator.evaluate(input_fn=eval_input_fn, steps=FLAGS.max_eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta/tf_metrics.py,22,"b'""""""\r\nMulticlass\r\nfrom: \r\nhttps://github.com/guillaumegenthial/tf_metrics/blob/master/tf_metrics/__init__.py\r\n\r\n""""""\r\n\r\n__author__ = ""Guillaume Genthial""\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops.metrics_impl import _streaming_confusion_matrix\r\n\r\n\r\ndef precision(labels, predictions, num_classes, pos_indices=None,\r\n              weights=None, average=\'micro\'):\r\n    """"""Multi-class precision metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    pr, _, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    op, _, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (pr, op)\r\n\r\n\r\ndef recall(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n           average=\'micro\'):\r\n    """"""Multi-class recall metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, re, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    _, op, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (re, op)\r\n\r\n\r\ndef f1(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n       average=\'micro\'):\r\n    return fbeta(labels, predictions, num_classes, pos_indices, weights,\r\n                 average)\r\n\r\n\r\ndef fbeta(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n          average=\'micro\', beta=1):\r\n    """"""Multi-class fbeta metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, _, fbeta = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average, beta=beta)\r\n    _, _, op = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average, beta=beta)\r\n    return (fbeta, op)\r\n\r\n\r\ndef safe_div(numerator, denominator):\r\n    """"""Safe division, return 0 if denominator is 0""""""\r\n    numerator, denominator = tf.to_float(numerator), tf.to_float(denominator)\r\n    zeros = tf.zeros_like(numerator, dtype=numerator.dtype)\r\n    denominator_is_zero = tf.equal(denominator, zeros)\r\n    return tf.where(denominator_is_zero, zeros, numerator / denominator)\r\n\r\n\r\ndef pr_re_fbeta(cm, pos_indices, beta=1):\r\n    """"""Uses a confusion matrix to compute precision, recall and fbeta""""""\r\n    num_classes = cm.shape[0]\r\n    neg_indices = [i for i in range(num_classes) if i not in pos_indices]\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, neg_indices] = 0\r\n    diag_sum = tf.reduce_sum(tf.diag_part(cm * cm_mask))\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[:, neg_indices] = 0\r\n    tot_pred = tf.reduce_sum(cm * cm_mask)\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, :] = 0\r\n    tot_gold = tf.reduce_sum(cm * cm_mask)\r\n\r\n    pr = safe_div(diag_sum, tot_pred)\r\n    re = safe_div(diag_sum, tot_gold)\r\n    fbeta = safe_div((1. + beta**2) * pr * re, beta**2 * pr + re)\r\n\r\n    return pr, re, fbeta\r\n\r\n\r\ndef metrics_from_confusion_matrix(cm, pos_indices=None, average=\'micro\',\r\n                                  beta=1):\r\n    """"""Precision, Recall and F1 from the confusion matrix\r\n    Parameters\r\n    ----------\r\n    cm : tf.Tensor of type tf.int32, of shape (num_classes, num_classes)\r\n        The streaming confusion matrix.\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    average : str, optional\r\n        \'micro\', \'macro\' or \'weighted\'\r\n    """"""\r\n    num_classes = cm.shape[0]\r\n    if pos_indices is None:\r\n        pos_indices = [i for i in range(num_classes)]\r\n\r\n    if average == \'micro\':\r\n        return pr_re_fbeta(cm, pos_indices, beta)\r\n    elif average in {\'macro\', \'weighted\'}:\r\n        precisions, recalls, fbetas, n_golds = [], [], [], []\r\n        for idx in pos_indices:\r\n            pr, re, fbeta = pr_re_fbeta(cm, [idx], beta)\r\n            precisions.append(pr)\r\n            recalls.append(re)\r\n            fbetas.append(fbeta)\r\n            cm_mask = np.zeros([num_classes, num_classes])\r\n            cm_mask[idx, :] = 1\r\n            n_golds.append(tf.to_float(tf.reduce_sum(cm * cm_mask)))\r\n\r\n        if average == \'macro\':\r\n            pr = tf.reduce_mean(precisions)\r\n            re = tf.reduce_mean(recalls)\r\n            fbeta = tf.reduce_mean(fbetas)\r\n            return pr, re, fbeta\r\n        if average == \'weighted\':\r\n            n_gold = tf.reduce_sum(n_golds)\r\n            pr_sum = sum(p * n for p, n in zip(precisions, n_golds))\r\n            pr = safe_div(pr_sum, n_gold)\r\n            re_sum = sum(r * n for r, n in zip(recalls, n_golds))\r\n            re = safe_div(re_sum, n_gold)\r\n            fbeta_sum = sum(f * n for f, n in zip(fbetas, n_golds))\r\n            fbeta = safe_div(fbeta_sum, n_gold)\r\n            return pr, re, fbeta\r\n\r\n    else:\r\n        raise NotImplementedError()'"
baselines/models/roberta/tokenization.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\nimport unicodedata\nimport six\nimport tensorflow as tf\n\n\ndef validate_case_matches_checkpoint(do_lower_case, init_checkpoint):\n  """"""Checks whether the casing config is consistent with the checkpoint name.""""""\n\n  # The casing has to be passed in by the user and there is no explicit check\n  # as to whether it matches the checkpoint. The casing information probably\n  # should have been stored in the bert_config.json file, but it\'s not, so\n  # we have to heuristically detect it to validate.\n\n  if not init_checkpoint:\n    return\n\n  m = re.match(""^.*?([A-Za-z0-9_-]+)/bert_model.ckpt"", init_checkpoint)\n  if m is None:\n    return\n\n  model_name = m.group(1)\n\n  lower_models = [\n      ""uncased_L-24_H-1024_A-16"", ""uncased_L-12_H-768_A-12"",\n      ""multilingual_L-12_H-768_A-12"", ""chinese_L-12_H-768_A-12""\n  ]\n\n  cased_models = [\n      ""cased_L-12_H-768_A-12"", ""cased_L-24_H-1024_A-16"",\n      ""multi_cased_L-12_H-768_A-12""\n  ]\n\n  is_bad_config = False\n  if model_name in lower_models and not do_lower_case:\n    is_bad_config = True\n    actual_flag = ""False""\n    case_name = ""lowercased""\n    opposite_flag = ""True""\n\n  if model_name in cased_models and do_lower_case:\n    is_bad_config = True\n    actual_flag = ""True""\n    case_name = ""cased""\n    opposite_flag = ""False""\n\n  if is_bad_config:\n    raise ValueError(\n        ""You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. ""\n        ""However, `%s` seems to be a %s model, so you ""\n        ""should pass in `--do_lower_case=%s` so that the fine-tuning matches ""\n        ""how the model was pre-training. If this error is wrong, please ""\n        ""just comment out this check."" % (actual_flag, init_checkpoint,\n                                          model_name, case_name, opposite_flag))\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  index = 0\n  with tf.gfile.GFile(vocab_file, ""r"") as reader:\n    while True:\n      token = convert_to_unicode(reader.readline())\n      if not token:\n        break\n      token = token.strip()\n      vocab[token] = index\n      index += 1\n  return vocab\n\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  #print(""items:"",items) #[\'[CLS]\', \'\xe6\x97\xa5\', \'##\xe6\x9c\x9f\', \'\xef\xbc\x8c\', \'\xe4\xbd\x86\', \'\xe8\xa2\xab\', \'##\xe5\x91\x8a\', \'\xe9\x87\x91\', \'##\xe4\xb8\x9c\', \'##\xe7\xa6\x8f\', \'\xe8\xbd\xbd\', \'##\xe6\x98\x8e\', \'[MASK]\', \'U\', \'##N\', \'##K\', \']\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe6\x9c\xac\', \'##\xe6\x9c\x88\', \'1\', \'##4\', \'[MASK]\', \'\xe5\x88\xb0\', \'##\xe4\xbd\x8d\', \'\xef\xbc\x8c\', \'2\', \'##0\', \'##1\', \'##5\', \'\xe5\xb9\xb4\', \'6\', \'[MASK]\', \'1\', \'##1\', \'\xe6\x97\xa5\', \'[\', \'U\', \'##N\', \'##K\', \']\', \'\xef\xbc\x8c\', \'\xe5\x8e\x9f\', \'##\xe5\x91\x8a\', \'[MASK]\', \'\xe8\xae\xa4\', \'##\xe5\x8f\xaf\', \'\xe4\xba\x8e\', \'2\', \'##0\', \'##1\', \'##5\', \'[MASK]\', \'6\', \'\xe6\x9c\x88\', \'[MASK]\', \'[MASK]\', \'\xe6\x97\xa5\', \'##\xe5\x90\x91\', \'\xe8\xa2\xab\', \'##\xe5\x91\x8a\', \'\xe4\xb8\xbb\', \'##\xe5\xbc\xa0\', \'\xe6\x9d\x83\', \'##\xe5\x88\xa9\', \'\xe3\x80\x82\', \'\xe8\x80\x8c\', \'[MASK]\', \'[MASK]\', \'\xe8\x87\xaa\', \'[MASK]\', \'[MASK]\', \'[MASK]\', \'[MASK]\', \'\xe5\xb9\xb4\', \'6\', \'\xe6\x9c\x88\', \'1\', \'##1\', \'\xe6\x97\xa5\', \'[SEP]\', \'\xe5\x8e\x9f\', \'##\xe5\x91\x8a\', \'\xe4\xba\x8e\', \'2\', \'##0\', \'##1\', \'##6\', \'[MASK]\', \'6\', \'[MASK]\', \'2\', \'##4\', \'\xe6\x97\xa5\', \'\xe8\xb5\xb7\', \'##\xe8\xaf\x89\', \'\xef\xbc\x8c\', \'\xe4\xb8\xbb\', \'##\xe5\xbc\xa0\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe8\xb4\xa3\', \'##\xe4\xbb\xbb\', \'\xef\xbc\x8c\', \'\xe5\xb7\xb2\', \'\xe8\xb6\x85\', \'##\xe8\xbf\x87\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe6\x9c\x9f\', \'##\xe9\x99\x90\', \'[MASK]\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'\xe4\xba\xba\', \'\xe4\xbe\x9d\', \'##\xe6\xb3\x95\', \'\xe4\xb8\x8d\', \'##\xe5\x86\x8d\', \'\xe6\x89\xbf\', \'##\xe6\x8b\x85\', \'\xe4\xbf\x9d\', \'##\xe8\xaf\x81\', \'[MASK]\', \'[MASK]\', \'[MASK]\', \'[SEP]\']\n  for i,item in enumerate(items):\n    #print(i,""item:"",item) #  ##\xe6\x9c\x9f\n    output.append(vocab[item])\n  return output\n\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True):\n    self.vocab = load_vocab(vocab_file)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n  def tokenize(self, text):\n    split_tokens = []\n    for token in self.basic_tokenizer.tokenize(text):\n      for sub_token in self.wordpiece_tokenizer.tokenize(token):\n        split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    return convert_by_vocab(self.inv_vocab, ids)\n\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = convert_to_unicode(text)\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n  """"""Runs WordPiece tokenziation.""""""\n\n  def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=200):\n    self.vocab = vocab\n    self.unk_token = unk_token\n    self.max_input_chars_per_word = max_input_chars_per_word\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text into its word pieces.\n\n    This uses a greedy longest-match-first algorithm to perform tokenization\n    using the given vocabulary.\n\n    For example:\n      input = ""unaffable""\n      output = [""un"", ""##aff"", ""##able""]\n\n    Args:\n      text: A single token or whitespace separated tokens. This should have\n        already been passed through `BasicTokenizer.\n\n    Returns:\n      A list of wordpiece tokens.\n    """"""\n\n    text = convert_to_unicode(text)\n\n    output_tokens = []\n    for token in whitespace_tokenize(text):\n      chars = list(token)\n      if len(chars) > self.max_input_chars_per_word:\n        output_tokens.append(self.unk_token)\n        continue\n\n      is_bad = False\n      start = 0\n      sub_tokens = []\n      while start < len(chars):\n        end = len(chars)\n        cur_substr = None\n        while start < end:\n          substr = """".join(chars[start:end])\n          if start > 0:\n            substr = ""##"" + substr\n          if substr in self.vocab:\n            cur_substr = substr\n            break\n          end -= 1\n        if cur_substr is None:\n          is_bad = True\n          break\n        sub_tokens.append(cur_substr)\n        start = end\n\n      if is_bad:\n        output_tokens.append(self.unk_token)\n      else:\n        output_tokens.extend(sub_tokens)\n    return output_tokens\n\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically contorl characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
baselines/models/roberta_wwm_ext/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n'"
baselines/models/roberta_wwm_ext/conlleval.py,0,"b'# Python version of the evaluation script from CoNLL\'00-\n# Originates from: https://github.com/spyysalo/conlleval.py\n\n\n# Intentional differences:\n# - accept any space as delimiter by default\n# - optional file argument (default STDIN)\n# - option to set boundary (-b argument)\n# - LaTeX output (-l argument) not supported\n# - raw tags (-r argument) not supported\n\n# add function :evaluate(predicted_label, ori_label): which will not read from file\n\nimport sys\nimport re\nimport codecs\nfrom collections import defaultdict, namedtuple\n\nANY_SPACE = \'<SPACE>\'\n\n\nclass FormatError(Exception):\n    pass\n\nMetrics = namedtuple(\'Metrics\', \'tp fp fn prec rec fscore\')\n\n\nclass EvalCounts(object):\n    def __init__(self):\n        self.correct_chunk = 0    # number of correctly identified chunks\n        self.correct_tags = 0     # number of correct chunk tags\n        self.found_correct = 0    # number of chunks in corpus\n        self.found_guessed = 0    # number of identified chunks\n        self.token_counter = 0    # token counter (ignores sentence breaks)\n\n        # counts by type\n        self.t_correct_chunk = defaultdict(int)\n        self.t_found_correct = defaultdict(int)\n        self.t_found_guessed = defaultdict(int)\n\n\ndef parse_args(argv):\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=\'evaluate tagging results using CoNLL criteria\',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    arg = parser.add_argument\n    arg(\'-b\', \'--boundary\', metavar=\'STR\', default=\'-X-\',\n        help=\'sentence boundary\')\n    arg(\'-d\', \'--delimiter\', metavar=\'CHAR\', default=ANY_SPACE,\n        help=\'character delimiting items in input\')\n    arg(\'-o\', \'--otag\', metavar=\'CHAR\', default=\'O\',\n        help=\'alternative outside tag\')\n    arg(\'file\', nargs=\'?\', default=None)\n    return parser.parse_args(argv)\n\n\ndef parse_tag(t):\n    m = re.match(r\'^([^-]*)-(.*)$\', t)\n    return m.groups() if m else (t, \'\')\n\n\ndef evaluate(iterable, options=None):\n    if options is None:\n        options = parse_args([])    # use defaults\n\n    counts = EvalCounts()\n    num_features = None       # number of features per line\n    in_correct = False        # currently processed chunks is correct until now\n    last_correct = \'O\'        # previous chunk tag in corpus\n    last_correct_type = \'\'    # type of previously identified chunk tag\n    last_guessed = \'O\'        # previously identified chunk tag\n    last_guessed_type = \'\'    # type of previous chunk tag in corpus\n\n    for line in iterable:\n        line = line.rstrip(\'\\r\\n\')\n\n        if options.delimiter == ANY_SPACE:\n            features = line.split()\n        else:\n            features = line.split(options.delimiter)\n\n        if num_features is None:\n            num_features = len(features)\n        elif num_features != len(features) and len(features) != 0:\n            raise FormatError(\'unexpected number of features: %d (%d)\' %\n                              (len(features), num_features))\n\n        if len(features) == 0 or features[0] == options.boundary:\n            features = [options.boundary, \'O\', \'O\']\n        if len(features) < 3:\n            raise FormatError(\'unexpected number of features in line %s\' % line)\n\n        guessed, guessed_type = parse_tag(features.pop())\n        correct, correct_type = parse_tag(features.pop())\n        first_item = features.pop(0)\n\n        if first_item == options.boundary:\n            guessed = \'O\'\n\n        end_correct = end_of_chunk(last_correct, correct,\n                                   last_correct_type, correct_type)\n        end_guessed = end_of_chunk(last_guessed, guessed,\n                                   last_guessed_type, guessed_type)\n        start_correct = start_of_chunk(last_correct, correct,\n                                       last_correct_type, correct_type)\n        start_guessed = start_of_chunk(last_guessed, guessed,\n                                       last_guessed_type, guessed_type)\n\n        if in_correct:\n            if (end_correct and end_guessed and\n                last_guessed_type == last_correct_type):\n                in_correct = False\n                counts.correct_chunk += 1\n                counts.t_correct_chunk[last_correct_type] += 1\n            elif (end_correct != end_guessed or guessed_type != correct_type):\n                in_correct = False\n\n        if start_correct and start_guessed and guessed_type == correct_type:\n            in_correct = True\n\n        if start_correct:\n            counts.found_correct += 1\n            counts.t_found_correct[correct_type] += 1\n        if start_guessed:\n            counts.found_guessed += 1\n            counts.t_found_guessed[guessed_type] += 1\n        if first_item != options.boundary:\n            if correct == guessed and guessed_type == correct_type:\n                counts.correct_tags += 1\n            counts.token_counter += 1\n\n        last_guessed = guessed\n        last_correct = correct\n        last_guessed_type = guessed_type\n        last_correct_type = correct_type\n\n    if in_correct:\n        counts.correct_chunk += 1\n        counts.t_correct_chunk[last_correct_type] += 1\n\n    return counts\n\n\n\ndef uniq(iterable):\n  seen = set()\n  return [i for i in iterable if not (i in seen or seen.add(i))]\n\n\ndef calculate_metrics(correct, guessed, total):\n    tp, fp, fn = correct, guessed-correct, total-correct\n    p = 0 if tp + fp == 0 else 1.*tp / (tp + fp)\n    r = 0 if tp + fn == 0 else 1.*tp / (tp + fn)\n    f = 0 if p + r == 0 else 2 * p * r / (p + r)\n    return Metrics(tp, fp, fn, p, r, f)\n\n\ndef metrics(counts):\n    c = counts\n    overall = calculate_metrics(\n        c.correct_chunk, c.found_guessed, c.found_correct\n    )\n    by_type = {}\n    for t in uniq(list(c.t_found_correct) + list(c.t_found_guessed)):\n        by_type[t] = calculate_metrics(\n            c.t_correct_chunk[t], c.t_found_guessed[t], c.t_found_correct[t]\n        )\n    return overall, by_type\n\n\ndef report(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    out.write(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    out.write(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n\n    if c.token_counter > 0:\n        out.write(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        out.write(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        out.write(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n\n    for i, m in sorted(by_type.items()):\n        out.write(\'%17s: \' % i)\n        out.write(\'precision: %6.2f%%; \' % (100.*m.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*m.rec))\n        out.write(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n\n\ndef report_notprint(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    final_report = []\n    line = []\n    line.append(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    line.append(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n    final_report.append("""".join(line))\n\n    if c.token_counter > 0:\n        line = []\n        line.append(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        line.append(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        line.append(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n        final_report.append("""".join(line))\n\n    for i, m in sorted(by_type.items()):\n        line = []\n        line.append(\'%17s: \' % i)\n        line.append(\'precision: %6.2f%%; \' % (100.*m.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*m.rec))\n        line.append(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n        final_report.append("""".join(line))\n    return final_report\n\n\ndef end_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk ended between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_end = False\n\n    if prev_tag == \'E\': chunk_end = True\n    if prev_tag == \'S\': chunk_end = True\n\n    if prev_tag == \'B\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'O\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'O\': chunk_end = True\n\n    if prev_tag != \'O\' and prev_tag != \'.\' and prev_type != type_:\n        chunk_end = True\n\n    # these chunks are assumed to have length 1\n    if prev_tag == \']\': chunk_end = True\n    if prev_tag == \'[\': chunk_end = True\n\n    return chunk_end\n\n\ndef start_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk started between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_start = False\n\n    if tag == \'B\': chunk_start = True\n    if tag == \'S\': chunk_start = True\n\n    if prev_tag == \'E\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'E\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'I\': chunk_start = True\n\n    if tag != \'O\' and tag != \'.\' and prev_type != type_:\n        chunk_start = True\n\n    # these chunks are assumed to have length 1\n    if tag == \'[\': chunk_start = True\n    if tag == \']\': chunk_start = True\n\n    return chunk_start\n\n\ndef return_report(input_file):\n    with codecs.open(input_file, ""r"", ""utf8"") as f:\n        counts = evaluate(f)\n    return report_notprint(counts)\n\n\ndef main(argv):\n    args = parse_args(argv[1:])\n\n    if args.file is None:\n        counts = evaluate(sys.stdin, args)\n    else:\n        with open(args.file) as f:\n            counts = evaluate(f, args)\n    report(counts)\n\nif __name__ == \'__main__\':\n    sys.exit(main(sys.argv))'"
baselines/models/roberta_wwm_ext/create_pretraining_data.py,17,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\n\nclass TrainingInstance(object):\n  """"""A single training instance (sentence pair).""""""\n\n  def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n               is_random_next):\n    self.tokens = tokens\n    self.segment_ids = segment_ids\n    self.is_random_next = is_random_next\n    self.masked_lm_positions = masked_lm_positions\n    self.masked_lm_labels = masked_lm_labels\n\n  def __str__(self):\n    s = """"\n    s += ""tokens: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.tokens]))\n    s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n    s += ""is_random_next: %s\\n"" % self.is_random_next\n    s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n        [str(x) for x in self.masked_lm_positions]))\n    s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n    s += ""\\n""\n    return s\n\n  def __repr__(self):\n    return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n  """"""Create TF example files from `TrainingInstance`s.""""""\n  writers = []\n  for output_file in output_files:\n    writers.append(tf.python_io.TFRecordWriter(output_file))\n\n  writer_index = 0\n\n  total_written = 0\n  for (inst_index, instance) in enumerate(instances):\n    input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n    input_mask = [1] * len(input_ids)\n    segment_ids = list(instance.segment_ids)\n    assert len(input_ids) <= max_seq_length\n\n    while len(input_ids) < max_seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      segment_ids.append(0)\n\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n\n    masked_lm_positions = list(instance.masked_lm_positions)\n    masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n    masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n    while len(masked_lm_positions) < max_predictions_per_seq:\n      masked_lm_positions.append(0)\n      masked_lm_ids.append(0)\n      masked_lm_weights.append(0.0)\n\n    next_sentence_label = 1 if instance.is_random_next else 0\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(input_ids)\n    features[""input_mask""] = create_int_feature(input_mask)\n    features[""segment_ids""] = create_int_feature(segment_ids)\n    features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n    features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n    features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n    features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n    writers[writer_index].write(tf_example.SerializeToString())\n    writer_index = (writer_index + 1) % len(writers)\n\n    total_written += 1\n\n    if inst_index < 20:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in instance.tokens]))\n\n      for feature_name in features.keys():\n        feature = features[feature_name]\n        values = []\n        if feature.int64_list.value:\n          values = feature.int64_list.value\n        elif feature.float_list.value:\n          values = feature.float_list.value\n        tf.logging.info(\n            ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n  for writer in writers:\n    writer.close()\n\n  tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n  feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n  return feature\n\n\ndef create_float_feature(values):\n  feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n  return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n  """"""Create `TrainingInstance`s from raw text.""""""\n  all_documents = [[]]\n\n  # Input file format:\n  # (1) One sentence per line. These should ideally be actual sentences, not\n  # entire paragraphs or arbitrary spans of text. (Because we use the\n  # sentence boundaries for the ""next sentence prediction"" task).\n  # (2) Blank lines between documents. Document boundaries are needed so\n  # that the ""next sentence prediction"" task doesn\'t span between documents.\n  for input_file in input_files:\n    with tf.gfile.GFile(input_file, ""r"") as reader:\n      while True:\n        line = tokenization.convert_to_unicode(reader.readline())\n        if not line:\n          break\n        line = line.strip()\n\n        # Empty lines are used as document delimiters\n        if not line:\n          all_documents.append([])\n        tokens = tokenizer.tokenize(line)\n        if tokens:\n          all_documents[-1].append(tokens)\n\n  # Remove empty documents\n  all_documents = [x for x in all_documents if x]\n  rng.shuffle(all_documents)\n\n  vocab_words = list(tokenizer.vocab.keys())\n  instances = []\n  for _ in range(dupe_factor):\n    for document_index in range(len(all_documents)):\n      instances.extend(\n          create_instances_from_document(\n              all_documents, document_index, max_seq_length, short_seq_prob,\n              masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n  rng.shuffle(instances)\n  return instances\n\n\ndef create_instances_from_document(\n    all_documents, document_index, max_seq_length, short_seq_prob,\n    masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n  """"""Creates `TrainingInstance`s for a single document.""""""\n  document = all_documents[document_index]\n\n  # Account for [CLS], [SEP], [SEP]\n  max_num_tokens = max_seq_length - 3\n\n  # We *usually* want to fill up the entire sequence since we are padding\n  # to `max_seq_length` anyways, so short sequences are generally wasted\n  # computation. However, we *sometimes*\n  # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n  # sequences to minimize the mismatch between pre-training and fine-tuning.\n  # The `target_seq_length` is just a rough target however, whereas\n  # `max_seq_length` is a hard limit.\n  target_seq_length = max_num_tokens\n  if rng.random() < short_seq_prob:\n    target_seq_length = rng.randint(2, max_num_tokens)\n\n  # We DON\'T just concatenate all of the tokens from a document into a long\n  # sequence and choose an arbitrary split point because this would make the\n  # next sentence prediction task too easy. Instead, we split the input into\n  # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n  # input.\n  instances = []\n  current_chunk = []\n  current_length = 0\n  i = 0\n  while i < len(document):\n    segment = document[i]\n    current_chunk.append(segment)\n    current_length += len(segment)\n    if i == len(document) - 1 or current_length >= target_seq_length:\n      if current_chunk:\n        # `a_end` is how many segments from `current_chunk` go into the `A`\n        # (first) sentence.\n        a_end = 1\n        if len(current_chunk) >= 2:\n          a_end = rng.randint(1, len(current_chunk) - 1)\n\n        tokens_a = []\n        for j in range(a_end):\n          tokens_a.extend(current_chunk[j])\n\n        tokens_b = []\n        # Random next\n        is_random_next = False\n        if len(current_chunk) == 1 or rng.random() < 0.5:\n          is_random_next = True\n          target_b_length = target_seq_length - len(tokens_a)\n\n          # This should rarely go for more than one iteration for large\n          # corpora. However, just to be careful, we try to make sure that\n          # the random document is not the same as the document\n          # we\'re processing.\n          for _ in range(10):\n            random_document_index = rng.randint(0, len(all_documents) - 1)\n            if random_document_index != document_index:\n              break\n\n          random_document = all_documents[random_document_index]\n          random_start = rng.randint(0, len(random_document) - 1)\n          for j in range(random_start, len(random_document)):\n            tokens_b.extend(random_document[j])\n            if len(tokens_b) >= target_b_length:\n              break\n          # We didn\'t actually use these segments so we ""put them back"" so\n          # they don\'t go to waste.\n          num_unused_segments = len(current_chunk) - a_end\n          i -= num_unused_segments\n        # Actual next\n        else:\n          is_random_next = False\n          for j in range(a_end, len(current_chunk)):\n            tokens_b.extend(current_chunk[j])\n        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n        assert len(tokens_a) >= 1\n        assert len(tokens_b) >= 1\n\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n          tokens.append(token)\n          segment_ids.append(0)\n\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        for token in tokens_b:\n          tokens.append(token)\n          segment_ids.append(1)\n        tokens.append(""[SEP]"")\n        segment_ids.append(1)\n\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance(\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n      current_chunk = []\n      current_length = 0\n    i += 1\n\n  return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n  """"""Creates the predictions for the masked LM objective.""""""\n\n  cand_indexes = []\n  for (i, token) in enumerate(tokens):\n    if token == ""[CLS]"" or token == ""[SEP]"":\n      continue\n    # Whole Word Masking means that if we mask all of the wordpieces\n    # corresponding to an original word. When a word has been split into\n    # WordPieces, the first token does not have any marker and any subsequence\n    # tokens are prefixed with ##. So whenever we see the ## token, we\n    # append it to the previous set of word indexes.\n    #\n    # Note that Whole Word Masking does *not* change the training code\n    # at all -- we still predict each WordPiece independently, softmaxed\n    # over the entire vocabulary.\n    if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n        token.startswith(""##"")):\n      cand_indexes[-1].append(i)\n    else:\n      cand_indexes.append([i])\n\n  rng.shuffle(cand_indexes)\n\n  output_tokens = list(tokens)\n\n  num_to_predict = min(max_predictions_per_seq,\n                       max(1, int(round(len(tokens) * masked_lm_prob))))\n\n  masked_lms = []\n  covered_indexes = set()\n  for index_set in cand_indexes:\n    if len(masked_lms) >= num_to_predict:\n      break\n    # If adding a whole-word mask would exceed the maximum number of\n    # predictions, then just skip this candidate.\n    if len(masked_lms) + len(index_set) > num_to_predict:\n      continue\n    is_any_index_covered = False\n    for index in index_set:\n      if index in covered_indexes:\n        is_any_index_covered = True\n        break\n    if is_any_index_covered:\n      continue\n    for index in index_set:\n      covered_indexes.add(index)\n\n      masked_token = None\n      # 80% of the time, replace with [MASK]\n      if rng.random() < 0.8:\n        masked_token = ""[MASK]""\n      else:\n        # 10% of the time, keep original\n        if rng.random() < 0.5:\n          masked_token = tokens[index]\n        # 10% of the time, replace with random word\n        else:\n          masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n      output_tokens[index] = masked_token\n\n      masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n  assert len(masked_lms) <= num_to_predict\n  masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n  masked_lm_positions = []\n  masked_lm_labels = []\n  for p in masked_lms:\n    masked_lm_positions.append(p.index)\n    masked_lm_labels.append(p.label)\n\n  return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n  """"""Truncates a pair of sequences to a maximum sequence length.""""""\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_num_tokens:\n      break\n\n    trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n    assert len(trunc_tokens) >= 1\n\n    # We want to sometimes truncate from the front and sometimes from the\n    # back to add more randomness and avoid biases.\n    if rng.random() < 0.5:\n      del trunc_tokens[0]\n    else:\n      trunc_tokens.pop()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Reading from input files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"", input_file)\n\n  rng = random.Random(FLAGS.random_seed)\n  instances = create_training_instances(\n      input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n      FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n      rng)\n\n  output_files = FLAGS.output_file.split("","")\n  tf.logging.info(""*** Writing to output files ***"")\n  for output_file in output_files:\n    tf.logging.info(""  %s"", output_file)\n\n  write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                  FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""output_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_ext/extract_features.py,34,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Extract pre-computed feature vectors from BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport codecs\nimport collections\nimport json\nimport re\n\nimport modeling\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None, """")\n\nflags.DEFINE_string(""output_file"", None, """")\n\nflags.DEFINE_string(""layers"", ""-1,-2,-3,-4"", """")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(""batch_size"", 32, ""Batch size for predictions."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_string(""master"", None,\n                    ""If using a TPU, the address of the master."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""use_one_hot_embeddings"", False,\n    ""If True, tf.one_hot will be used for embedding lookups, otherwise ""\n    ""tf.nn.embedding_lookup will be used. On TPUs, this should be True ""\n    ""since it is much faster."")\n\n\nclass InputExample(object):\n\n  def __init__(self, unique_id, text_a, text_b):\n    self.unique_id = unique_id\n    self.text_a = text_a\n    self.text_b = text_b\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self, unique_id, tokens, input_ids, input_mask, input_type_ids):\n    self.unique_id = unique_id\n    self.tokens = tokens\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.input_type_ids = input_type_ids\n\n\ndef input_fn_builder(features, seq_length):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_unique_ids = []\n  all_input_ids = []\n  all_input_mask = []\n  all_input_type_ids = []\n\n  for feature in features:\n    all_unique_ids.append(feature.unique_id)\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_input_type_ids.append(feature.input_type_ids)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""unique_ids"":\n            tf.constant(all_unique_ids, shape=[num_examples], dtype=tf.int32),\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_type_ids"":\n            tf.constant(\n                all_input_type_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n    })\n\n    d = d.batch(batch_size=batch_size, drop_remainder=False)\n    return d\n\n  return input_fn\n\n\ndef model_fn_builder(bert_config, init_checkpoint, layer_indexes, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    input_type_ids = features[""input_type_ids""]\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=False,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=input_type_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    if mode != tf.estimator.ModeKeys.PREDICT:\n      raise ValueError(""Only PREDICT modes are supported: %s"" % (mode))\n\n    tvars = tf.trainable_variables()\n    scaffold_fn = None\n    (assignment_map,\n     initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(\n         tvars, init_checkpoint)\n    if use_tpu:\n\n      def tpu_scaffold():\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        return tf.train.Scaffold()\n\n      scaffold_fn = tpu_scaffold\n    else:\n      tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    all_layers = model.get_all_encoder_layers()\n\n    predictions = {\n        ""unique_id"": unique_ids,\n    }\n\n    for (i, layer_index) in enumerate(layer_indexes):\n      predictions[""layer_output_%d"" % i] = all_layers[layer_index]\n\n    output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n        mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\ndef convert_examples_to_features(examples, seq_length, tokenizer):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    tokens_a = tokenizer.tokenize(example.text_a)\n\n    tokens_b = None\n    if example.text_b:\n      tokens_b = tokenizer.tokenize(example.text_b)\n\n    if tokens_b:\n      # Modifies `tokens_a` and `tokens_b` in place so that the total\n      # length is less than the specified length.\n      # Account for [CLS], [SEP], [SEP] with ""- 3""\n      _truncate_seq_pair(tokens_a, tokens_b, seq_length - 3)\n    else:\n      # Account for [CLS] and [SEP] with ""- 2""\n      if len(tokens_a) > seq_length - 2:\n        tokens_a = tokens_a[0:(seq_length - 2)]\n\n    # The convention in BERT is:\n    # (a) For sequence pairs:\n    #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n    #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n    # (b) For single sequences:\n    #  tokens:   [CLS] the dog is hairy . [SEP]\n    #  type_ids: 0     0   0   0  0     0 0\n    #\n    # Where ""type_ids"" are used to indicate whether this is the first\n    # sequence or the second sequence. The embedding vectors for `type=0` and\n    # `type=1` were learned during pre-training and are added to the wordpiece\n    # embedding vector (and position vector). This is not *strictly* necessary\n    # since the [SEP] token unambiguously separates the sequences, but it makes\n    # it easier for the model to learn the concept of sequences.\n    #\n    # For classification tasks, the first vector (corresponding to [CLS]) is\n    # used as as the ""sentence vector"". Note that this only makes sense because\n    # the entire model is fine-tuned.\n    tokens = []\n    input_type_ids = []\n    tokens.append(""[CLS]"")\n    input_type_ids.append(0)\n    for token in tokens_a:\n      tokens.append(token)\n      input_type_ids.append(0)\n    tokens.append(""[SEP]"")\n    input_type_ids.append(0)\n\n    if tokens_b:\n      for token in tokens_b:\n        tokens.append(token)\n        input_type_ids.append(1)\n      tokens.append(""[SEP]"")\n      input_type_ids.append(1)\n\n    input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n    # The mask has 1 for real tokens and 0 for padding tokens. Only real\n    # tokens are attended to.\n    input_mask = [1] * len(input_ids)\n\n    # Zero-pad up to the sequence length.\n    while len(input_ids) < seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      input_type_ids.append(0)\n\n    assert len(input_ids) == seq_length\n    assert len(input_mask) == seq_length\n    assert len(input_type_ids) == seq_length\n\n    if ex_index < 5:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""unique_id: %s"" % (example.unique_id))\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in tokens]))\n      tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n      tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n      tf.logging.info(\n          ""input_type_ids: %s"" % "" "".join([str(x) for x in input_type_ids]))\n\n    features.append(\n        InputFeatures(\n            unique_id=example.unique_id,\n            tokens=tokens,\n            input_ids=input_ids,\n            input_mask=input_mask,\n            input_type_ids=input_type_ids))\n  return features\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef read_examples(input_file):\n  """"""Read a list of `InputExample`s from an input file.""""""\n  examples = []\n  unique_id = 0\n  with tf.gfile.GFile(input_file, ""r"") as reader:\n    while True:\n      line = tokenization.convert_to_unicode(reader.readline())\n      if not line:\n        break\n      line = line.strip()\n      text_a = None\n      text_b = None\n      m = re.match(r""^(.*) \\|\\|\\| (.*)$"", line)\n      if m is None:\n        text_a = line\n      else:\n        text_a = m.group(1)\n        text_b = m.group(2)\n      examples.append(\n          InputExample(unique_id=unique_id, text_a=text_a, text_b=text_b))\n      unique_id += 1\n  return examples\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  layer_indexes = [int(x) for x in FLAGS.layers.split("","")]\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      master=FLAGS.master,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  examples = read_examples(FLAGS.input_file)\n\n  features = convert_examples_to_features(\n      examples=examples, seq_length=FLAGS.max_seq_length, tokenizer=tokenizer)\n\n  unique_id_to_feature = {}\n  for feature in features:\n    unique_id_to_feature[feature.unique_id] = feature\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      layer_indexes=layer_indexes,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_one_hot_embeddings)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      predict_batch_size=FLAGS.batch_size)\n\n  input_fn = input_fn_builder(\n      features=features, seq_length=FLAGS.max_seq_length)\n\n  with codecs.getwriter(""utf-8"")(tf.gfile.Open(FLAGS.output_file,\n                                               ""w"")) as writer:\n    for result in estimator.predict(input_fn, yield_single_examples=True):\n      unique_id = int(result[""unique_id""])\n      feature = unique_id_to_feature[unique_id]\n      output_json = collections.OrderedDict()\n      output_json[""linex_index""] = unique_id\n      all_features = []\n      for (i, token) in enumerate(feature.tokens):\n        all_layers = []\n        for (j, layer_index) in enumerate(layer_indexes):\n          layer_output = result[""layer_output_%d"" % j]\n          layers = collections.OrderedDict()\n          layers[""index""] = layer_index\n          layers[""values""] = [\n              round(float(x), 6) for x in layer_output[i:(i + 1)].flat\n          ]\n          all_layers.append(layers)\n        features = collections.OrderedDict()\n        features[""token""] = token\n        features[""layers""] = all_layers\n        all_features.append(features)\n      output_json[""features""] = all_features\n      writer.write(json.dumps(output_json) + ""\\n"")\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""init_checkpoint"")\n  flags.mark_flag_as_required(""output_file"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_ext/modeling.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The main BERT model and related functions.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport numpy as np\nimport six\nimport tensorflow as tf\n\n\nclass BertConfig(object):\n  """"""Configuration for `BertModel`.""""""\n\n  def __init__(self,\n               vocab_size,\n               hidden_size=768,\n               num_hidden_layers=12,\n               num_attention_heads=12,\n               intermediate_size=3072,\n               hidden_act=""gelu"",\n               hidden_dropout_prob=0.1,\n               attention_probs_dropout_prob=0.1,\n               max_position_embeddings=512,\n               type_vocab_size=16,\n               initializer_range=0.02):\n    """"""Constructs BertConfig.\n\n    Args:\n      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.\n      hidden_size: Size of the encoder layers and the pooler layer.\n      num_hidden_layers: Number of hidden layers in the Transformer encoder.\n      num_attention_heads: Number of attention heads for each attention layer in\n        the Transformer encoder.\n      intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n        layer in the Transformer encoder.\n      hidden_act: The non-linear activation function (function or string) in the\n        encoder and pooler.\n      hidden_dropout_prob: The dropout probability for all fully connected\n        layers in the embeddings, encoder, and pooler.\n      attention_probs_dropout_prob: The dropout ratio for the attention\n        probabilities.\n      max_position_embeddings: The maximum sequence length that this model might\n        ever be used with. Typically set this to something large just in case\n        (e.g., 512 or 1024 or 2048).\n      type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n        `BertModel`.\n      initializer_range: The stdev of the truncated_normal_initializer for\n        initializing all weight matrices.\n    """"""\n    self.vocab_size = vocab_size\n    self.hidden_size = hidden_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.hidden_act = hidden_act\n    self.intermediate_size = intermediate_size\n    self.hidden_dropout_prob = hidden_dropout_prob\n    self.attention_probs_dropout_prob = attention_probs_dropout_prob\n    self.max_position_embeddings = max_position_embeddings\n    self.type_vocab_size = type_vocab_size\n    self.initializer_range = initializer_range\n\n  @classmethod\n  def from_dict(cls, json_object):\n    """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n    config = BertConfig(vocab_size=None)\n    for (key, value) in six.iteritems(json_object):\n      config.__dict__[key] = value\n    return config\n\n  @classmethod\n  def from_json_file(cls, json_file):\n    """"""Constructs a `BertConfig` from a json file of parameters.""""""\n    with tf.gfile.GFile(json_file, ""r"") as reader:\n      text = reader.read()\n    return cls.from_dict(json.loads(text))\n\n  def to_dict(self):\n    """"""Serializes this instance to a Python dictionary.""""""\n    output = copy.deepcopy(self.__dict__)\n    return output\n\n  def to_json_string(self):\n    """"""Serializes this instance to a JSON string.""""""\n    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass BertModel(object):\n  """"""BERT model (""Bidirectional Encoder Representations from Transformers"").\n\n  Example usage:\n\n  ```python\n  # Already been converted into WordPiece token ids\n  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])\n  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])\n  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])\n\n  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,\n    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)\n\n  model = modeling.BertModel(config=config, is_training=True,\n    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)\n\n  label_embeddings = tf.get_variable(...)\n  pooled_output = model.get_pooled_output()\n  logits = tf.matmul(pooled_output, label_embeddings)\n  ...\n  ```\n  """"""\n\n  def __init__(self,\n               config,\n               is_training,\n               input_ids,\n               input_mask=None,\n               token_type_ids=None,\n               use_one_hot_embeddings=False,\n               scope=None):\n    """"""Constructor for BertModel.\n\n    Args:\n      config: `BertConfig` instance.\n      is_training: bool. true for training model, false for eval model. Controls\n        whether dropout will be applied.\n      input_ids: int32 Tensor of shape [batch_size, seq_length].\n      input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].\n      token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      use_one_hot_embeddings: (optional) bool. Whether to use one-hot word\n        embeddings or tf.embedding_lookup() for the word embeddings.\n      scope: (optional) variable scope. Defaults to ""bert"".\n\n    Raises:\n      ValueError: The config is invalid or one of the input tensor shapes\n        is invalid.\n    """"""\n    config = copy.deepcopy(config)\n    if not is_training:\n      config.hidden_dropout_prob = 0.0\n      config.attention_probs_dropout_prob = 0.0\n\n    input_shape = get_shape_list(input_ids, expected_rank=2)\n    batch_size = input_shape[0]\n    seq_length = input_shape[1]\n\n    if input_mask is None:\n      input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    if token_type_ids is None:\n      token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    with tf.variable_scope(scope, default_name=""bert""):\n      with tf.variable_scope(""embeddings""):\n        # Perform embedding lookup on the word ids.\n        (self.embedding_output, self.embedding_table) = embedding_lookup(\n            input_ids=input_ids,\n            vocab_size=config.vocab_size,\n            embedding_size=config.hidden_size,\n            initializer_range=config.initializer_range,\n            word_embedding_name=""word_embeddings"",\n            use_one_hot_embeddings=use_one_hot_embeddings)\n\n        # Add positional embeddings and token type embeddings, then layer\n        # normalize and perform dropout.\n        self.embedding_output = embedding_postprocessor(\n            input_tensor=self.embedding_output,\n            use_token_type=True,\n            token_type_ids=token_type_ids,\n            token_type_vocab_size=config.type_vocab_size,\n            token_type_embedding_name=""token_type_embeddings"",\n            use_position_embeddings=True,\n            position_embedding_name=""position_embeddings"",\n            initializer_range=config.initializer_range,\n            max_position_embeddings=config.max_position_embeddings,\n            dropout_prob=config.hidden_dropout_prob)\n\n      with tf.variable_scope(""encoder""):\n        # This converts a 2D mask of shape [batch_size, seq_length] to a 3D\n        # mask of shape [batch_size, seq_length, seq_length] which is used\n        # for the attention scores.\n        attention_mask = create_attention_mask_from_input_mask(\n            input_ids, input_mask)\n\n        # Run the stacked transformer.\n        # `sequence_output` shape = [batch_size, seq_length, hidden_size].\n        self.all_encoder_layers = transformer_model(\n            input_tensor=self.embedding_output,\n            attention_mask=attention_mask,\n            hidden_size=config.hidden_size,\n            num_hidden_layers=config.num_hidden_layers,\n            num_attention_heads=config.num_attention_heads,\n            intermediate_size=config.intermediate_size,\n            intermediate_act_fn=get_activation(config.hidden_act),\n            hidden_dropout_prob=config.hidden_dropout_prob,\n            attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n            initializer_range=config.initializer_range,\n            do_return_all_layers=True)\n\n      self.sequence_output = self.all_encoder_layers[-1]\n      # The ""pooler"" converts the encoded sequence tensor of shape\n      # [batch_size, seq_length, hidden_size] to a tensor of shape\n      # [batch_size, hidden_size]. This is necessary for segment-level\n      # (or segment-pair-level) classification tasks where we need a fixed\n      # dimensional representation of the segment.\n      with tf.variable_scope(""pooler""):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token. We assume that this has been pre-trained\n        first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)\n        self.pooled_output = tf.layers.dense(\n            first_token_tensor,\n            config.hidden_size,\n            activation=tf.tanh,\n            kernel_initializer=create_initializer(config.initializer_range))\n\n  def get_pooled_output(self):\n    return self.pooled_output\n\n  def get_sequence_output(self):\n    """"""Gets final hidden layer of encoder.\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the final hidden of the transformer encoder.\n    """"""\n    return self.sequence_output\n\n  def get_all_encoder_layers(self):\n    return self.all_encoder_layers\n\n  def get_embedding_output(self):\n    """"""Gets output of the embedding lookup (i.e., input to the transformer).\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the output of the embedding layer, after summing the word\n      embeddings with the positional embeddings and the token type embeddings,\n      then performing layer normalization. This is the input to the transformer.\n    """"""\n    return self.embedding_output\n\n  def get_embedding_table(self):\n    return self.embedding_table\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef get_activation(activation_string):\n  """"""Maps a string to a Python function, e.g., ""relu"" => `tf.nn.relu`.\n\n  Args:\n    activation_string: String name of the activation function.\n\n  Returns:\n    A Python function corresponding to the activation function. If\n    `activation_string` is None, empty, or ""linear"", this will return None.\n    If `activation_string` is not a string, it will return `activation_string`.\n\n  Raises:\n    ValueError: The `activation_string` does not correspond to a known\n      activation.\n  """"""\n\n  # We assume that anything that""s not a string is already an activation\n  # function, so we just return it.\n  if not isinstance(activation_string, six.string_types):\n    return activation_string\n\n  if not activation_string:\n    return None\n\n  act = activation_string.lower()\n  if act == ""linear"":\n    return None\n  elif act == ""relu"":\n    return tf.nn.relu\n  elif act == ""gelu"":\n    return gelu\n  elif act == ""tanh"":\n    return tf.tanh\n  else:\n    raise ValueError(""Unsupported activation: %s"" % act)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    if name not in name_to_variable:\n      continue\n    assignment_map[name] = name\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\ndef dropout(input_tensor, dropout_prob):\n  """"""Perform dropout.\n\n  Args:\n    input_tensor: float Tensor.\n    dropout_prob: Python float. The probability of dropping out a value (NOT of\n      *keeping* a dimension as in `tf.nn.dropout`).\n\n  Returns:\n    A version of `input_tensor` with dropout applied.\n  """"""\n  if dropout_prob is None or dropout_prob == 0.0:\n    return input_tensor\n\n  output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob)\n  return output\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n  """"""Runs layer normalization followed by dropout.""""""\n  output_tensor = layer_norm(input_tensor, name)\n  output_tensor = dropout(output_tensor, dropout_prob)\n  return output_tensor\n\n\ndef create_initializer(initializer_range=0.02):\n  """"""Creates a `truncated_normal_initializer` with the given range.""""""\n  return tf.truncated_normal_initializer(stddev=initializer_range)\n\n\ndef embedding_lookup(input_ids,\n                     vocab_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n  """"""Looks up words embeddings for id tensor.\n\n  Args:\n    input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n      ids.\n    vocab_size: int. Size of the embedding vocabulary.\n    embedding_size: int. Width of the word embeddings.\n    initializer_range: float. Embedding initialization range.\n    word_embedding_name: string. Name of the embedding table.\n    use_one_hot_embeddings: bool. If True, use one-hot method for word\n      embeddings. If False, use `tf.gather()`.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, embedding_size].\n  """"""\n  # This function assumes that the input is of shape [batch_size, seq_length,\n  # num_inputs].\n  #\n  # If the input is a 2D tensor of shape [batch_size, seq_length], we\n  # reshape to [batch_size, seq_length, 1].\n  if input_ids.shape.ndims == 2:\n    input_ids = tf.expand_dims(input_ids, axis=[-1])\n\n  embedding_table = tf.get_variable(\n      name=word_embedding_name,\n      shape=[vocab_size, embedding_size],\n      initializer=create_initializer(initializer_range))\n\n  flat_input_ids = tf.reshape(input_ids, [-1])\n  if use_one_hot_embeddings:\n    one_hot_input_ids = tf.one_hot(flat_input_ids, depth=vocab_size)\n    output = tf.matmul(one_hot_input_ids, embedding_table)\n  else:\n    output = tf.gather(embedding_table, flat_input_ids)\n\n  input_shape = get_shape_list(input_ids)\n\n  output = tf.reshape(output,\n                      input_shape[0:-1] + [input_shape[-1] * embedding_size])\n  return (output, embedding_table)\n\n\ndef embedding_postprocessor(input_tensor,\n                            use_token_type=False,\n                            token_type_ids=None,\n                            token_type_vocab_size=16,\n                            token_type_embedding_name=""token_type_embeddings"",\n                            use_position_embeddings=True,\n                            position_embedding_name=""position_embeddings"",\n                            initializer_range=0.02,\n                            max_position_embeddings=512,\n                            dropout_prob=0.1):\n  """"""Performs various post-processing on a word embedding tensor.\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length,\n      embedding_size].\n    use_token_type: bool. Whether to add embeddings for `token_type_ids`.\n    token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      Must be specified if `use_token_type` is True.\n    token_type_vocab_size: int. The vocabulary size of `token_type_ids`.\n    token_type_embedding_name: string. The name of the embedding table variable\n      for token type ids.\n    use_position_embeddings: bool. Whether to add position embeddings for the\n      position of each token in the sequence.\n    position_embedding_name: string. The name of the embedding table variable\n      for positional embeddings.\n    initializer_range: float. Range of the weight initialization.\n    max_position_embeddings: int. Maximum sequence length that might ever be\n      used with this model. This can be longer than the sequence length of\n      input_tensor, but cannot be shorter.\n    dropout_prob: float. Dropout probability applied to the final output tensor.\n\n  Returns:\n    float tensor with same shape as `input_tensor`.\n\n  Raises:\n    ValueError: One of the tensor shapes or input values is invalid.\n  """"""\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  width = input_shape[2]\n\n  output = input_tensor\n\n  if use_token_type:\n    if token_type_ids is None:\n      raise ValueError(""`token_type_ids` must be specified if""\n                       ""`use_token_type` is True."")\n    token_type_table = tf.get_variable(\n        name=token_type_embedding_name,\n        shape=[token_type_vocab_size, width],\n        initializer=create_initializer(initializer_range))\n    # This vocab will be small so we always do one-hot here, since it is always\n    # faster for a small vocabulary.\n    flat_token_type_ids = tf.reshape(token_type_ids, [-1])\n    one_hot_ids = tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)\n    token_type_embeddings = tf.matmul(one_hot_ids, token_type_table)\n    token_type_embeddings = tf.reshape(token_type_embeddings,\n                                       [batch_size, seq_length, width])\n    output += token_type_embeddings\n\n  if use_position_embeddings:\n    assert_op = tf.assert_less_equal(seq_length, max_position_embeddings)\n    with tf.control_dependencies([assert_op]):\n      full_position_embeddings = tf.get_variable(\n          name=position_embedding_name,\n          shape=[max_position_embeddings, width],\n          initializer=create_initializer(initializer_range))\n      # Since the position embedding table is a learned variable, we create it\n      # using a (long) sequence length `max_position_embeddings`. The actual\n      # sequence length might be shorter than this, for faster training of\n      # tasks that do not have long sequences.\n      #\n      # So `full_position_embeddings` is effectively an embedding table\n      # for position [0, 1, 2, ..., max_position_embeddings-1], and the current\n      # sequence has positions [0, 1, 2, ... seq_length-1], so we can just\n      # perform a slice.\n      position_embeddings = tf.slice(full_position_embeddings, [0, 0],\n                                     [seq_length, -1])\n      num_dims = len(output.shape.as_list())\n\n      # Only the last two dimensions are relevant (`seq_length` and `width`), so\n      # we broadcast among the first dimensions, which is typically just\n      # the batch size.\n      position_broadcast_shape = []\n      for _ in range(num_dims - 2):\n        position_broadcast_shape.append(1)\n      position_broadcast_shape.extend([seq_length, width])\n      position_embeddings = tf.reshape(position_embeddings,\n                                       position_broadcast_shape)\n      output += position_embeddings\n\n  output = layer_norm_and_dropout(output, dropout_prob)\n  return output\n\n\ndef create_attention_mask_from_input_mask(from_tensor, to_mask):\n  """"""Create 3D attention mask from a 2D tensor mask.\n\n  Args:\n    from_tensor: 2D or 3D Tensor of shape [batch_size, from_seq_length, ...].\n    to_mask: int32 Tensor of shape [batch_size, to_seq_length].\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length, to_seq_length].\n  """"""\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  batch_size = from_shape[0]\n  from_seq_length = from_shape[1]\n\n  to_shape = get_shape_list(to_mask, expected_rank=2)\n  to_seq_length = to_shape[1]\n\n  to_mask = tf.cast(\n      tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)\n\n  # We don\'t assume that `from_tensor` is a mask (although it could be). We\n  # don\'t actually care if we attend *from* padding tokens (only *to* padding)\n  # tokens so we create a tensor of all ones.\n  #\n  # `broadcast_ones` = [batch_size, from_seq_length, 1]\n  broadcast_ones = tf.ones(\n      shape=[batch_size, from_seq_length, 1], dtype=tf.float32)\n\n  # Here we broadcast along two dimensions to create the mask.\n  mask = broadcast_ones * to_mask\n\n  return mask\n\n\ndef attention_layer(from_tensor,\n                    to_tensor,\n                    attention_mask=None,\n                    num_attention_heads=1,\n                    size_per_head=512,\n                    query_act=None,\n                    key_act=None,\n                    value_act=None,\n                    attention_probs_dropout_prob=0.0,\n                    initializer_range=0.02,\n                    do_return_2d_tensor=False,\n                    batch_size=None,\n                    from_seq_length=None,\n                    to_seq_length=None):\n  """"""Performs multi-headed attention from `from_tensor` to `to_tensor`.\n\n  This is an implementation of multi-headed attention based on ""Attention\n  is all you Need"". If `from_tensor` and `to_tensor` are the same, then\n  this is self-attention. Each timestep in `from_tensor` attends to the\n  corresponding sequence in `to_tensor`, and returns a fixed-with vector.\n\n  This function first projects `from_tensor` into a ""query"" tensor and\n  `to_tensor` into ""key"" and ""value"" tensors. These are (effectively) a list\n  of tensors of length `num_attention_heads`, where each tensor is of shape\n  [batch_size, seq_length, size_per_head].\n\n  Then, the query and key tensors are dot-producted and scaled. These are\n  softmaxed to obtain attention probabilities. The value tensors are then\n  interpolated by these probabilities, then concatenated back to a single\n  tensor and returned.\n\n  In practice, the multi-headed attention are done with transposes and\n  reshapes rather than actual separate tensors.\n\n  Args:\n    from_tensor: float Tensor of shape [batch_size, from_seq_length,\n      from_width].\n    to_tensor: float Tensor of shape [batch_size, to_seq_length, to_width].\n    attention_mask: (optional) int32 Tensor of shape [batch_size,\n      from_seq_length, to_seq_length]. The values should be 1 or 0. The\n      attention scores will effectively be set to -infinity for any positions in\n      the mask that are 0, and will be unchanged for positions that are 1.\n    num_attention_heads: int. Number of attention heads.\n    size_per_head: int. Size of each attention head.\n    query_act: (optional) Activation function for the query transform.\n    key_act: (optional) Activation function for the key transform.\n    value_act: (optional) Activation function for the value transform.\n    attention_probs_dropout_prob: (optional) float. Dropout probability of the\n      attention probabilities.\n    initializer_range: float. Range of the weight initializer.\n    do_return_2d_tensor: bool. If True, the output will be of shape [batch_size\n      * from_seq_length, num_attention_heads * size_per_head]. If False, the\n      output will be of shape [batch_size, from_seq_length, num_attention_heads\n      * size_per_head].\n    batch_size: (Optional) int. If the input is 2D, this might be the batch size\n      of the 3D version of the `from_tensor` and `to_tensor`.\n    from_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `from_tensor`.\n    to_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `to_tensor`.\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length,\n      num_attention_heads * size_per_head]. (If `do_return_2d_tensor` is\n      true, this will be of shape [batch_size * from_seq_length,\n      num_attention_heads * size_per_head]).\n\n  Raises:\n    ValueError: Any of the arguments or tensor shapes are invalid.\n  """"""\n\n  def transpose_for_scores(input_tensor, batch_size, num_attention_heads,\n                           seq_length, width):\n    output_tensor = tf.reshape(\n        input_tensor, [batch_size, seq_length, num_attention_heads, width])\n\n    output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])\n    return output_tensor\n\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])\n\n  if len(from_shape) != len(to_shape):\n    raise ValueError(\n        ""The rank of `from_tensor` must match the rank of `to_tensor`."")\n\n  if len(from_shape) == 3:\n    batch_size = from_shape[0]\n    from_seq_length = from_shape[1]\n    to_seq_length = to_shape[1]\n  elif len(from_shape) == 2:\n    if (batch_size is None or from_seq_length is None or to_seq_length is None):\n      raise ValueError(\n          ""When passing in rank 2 tensors to attention_layer, the values ""\n          ""for `batch_size`, `from_seq_length`, and `to_seq_length` ""\n          ""must all be specified."")\n\n  # Scalar dimensions referenced here:\n  #   B = batch size (number of sequences)\n  #   F = `from_tensor` sequence length\n  #   T = `to_tensor` sequence length\n  #   N = `num_attention_heads`\n  #   H = `size_per_head`\n\n  from_tensor_2d = reshape_to_matrix(from_tensor)\n  to_tensor_2d = reshape_to_matrix(to_tensor)\n\n  # `query_layer` = [B*F, N*H]\n  query_layer = tf.layers.dense(\n      from_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=query_act,\n      name=""query"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `key_layer` = [B*T, N*H]\n  key_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=key_act,\n      name=""key"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `value_layer` = [B*T, N*H]\n  value_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=value_act,\n      name=""value"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `query_layer` = [B, N, F, H]\n  query_layer = transpose_for_scores(query_layer, batch_size,\n                                     num_attention_heads, from_seq_length,\n                                     size_per_head)\n\n  # `key_layer` = [B, N, T, H]\n  key_layer = transpose_for_scores(key_layer, batch_size, num_attention_heads,\n                                   to_seq_length, size_per_head)\n\n  # Take the dot product between ""query"" and ""key"" to get the raw\n  # attention scores.\n  # `attention_scores` = [B, N, F, T]\n  attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)\n  attention_scores = tf.multiply(attention_scores,\n                                 1.0 / math.sqrt(float(size_per_head)))\n\n  if attention_mask is not None:\n    # `attention_mask` = [B, 1, F, T]\n    attention_mask = tf.expand_dims(attention_mask, axis=[1])\n\n    # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n    # masked positions, this operation will create a tensor which is 0.0 for\n    # positions we want to attend and -10000.0 for masked positions.\n    adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0\n\n    # Since we are adding it to the raw scores before the softmax, this is\n    # effectively the same as removing these entirely.\n    attention_scores += adder\n\n  # Normalize the attention scores to probabilities.\n  # `attention_probs` = [B, N, F, T]\n  attention_probs = tf.nn.softmax(attention_scores)\n\n  # This is actually dropping out entire tokens to attend to, which might\n  # seem a bit unusual, but is taken from the original Transformer paper.\n  attention_probs = dropout(attention_probs, attention_probs_dropout_prob)\n\n  # `value_layer` = [B, T, N, H]\n  value_layer = tf.reshape(\n      value_layer,\n      [batch_size, to_seq_length, num_attention_heads, size_per_head])\n\n  # `value_layer` = [B, N, T, H]\n  value_layer = tf.transpose(value_layer, [0, 2, 1, 3])\n\n  # `context_layer` = [B, N, F, H]\n  context_layer = tf.matmul(attention_probs, value_layer)\n\n  # `context_layer` = [B, F, N, H]\n  context_layer = tf.transpose(context_layer, [0, 2, 1, 3])\n\n  if do_return_2d_tensor:\n    # `context_layer` = [B*F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size * from_seq_length, num_attention_heads * size_per_head])\n  else:\n    # `context_layer` = [B, F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size, from_seq_length, num_attention_heads * size_per_head])\n\n  return context_layer\n\n\ndef transformer_model(input_tensor,\n                      attention_mask=None,\n                      hidden_size=768,\n                      num_hidden_layers=12,\n                      num_attention_heads=12,\n                      intermediate_size=3072,\n                      intermediate_act_fn=gelu,\n                      hidden_dropout_prob=0.1,\n                      attention_probs_dropout_prob=0.1,\n                      initializer_range=0.02,\n                      do_return_all_layers=False):\n  """"""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n  This is almost an exact implementation of the original Transformer encoder.\n\n  See the original paper:\n  https://arxiv.org/abs/1706.03762\n\n  Also see:\n  https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n    attention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n      seq_length], with 1 for positions that can be attended to and 0 in\n      positions that should not be.\n    hidden_size: int. Hidden size of the Transformer.\n    num_hidden_layers: int. Number of layers (blocks) in the Transformer.\n    num_attention_heads: int. Number of attention heads in the Transformer.\n    intermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n      forward) layer.\n    intermediate_act_fn: function. The non-linear activation function to apply\n      to the output of the intermediate/feed-forward layer.\n    hidden_dropout_prob: float. Dropout probability for the hidden layers.\n    attention_probs_dropout_prob: float. Dropout probability of the attention\n      probabilities.\n    initializer_range: float. Range of the initializer (stddev of truncated\n      normal).\n    do_return_all_layers: Whether to also return all layers or just the final\n      layer.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, hidden_size], the final\n    hidden layer of the Transformer.\n\n  Raises:\n    ValueError: A Tensor shape or parameter is invalid.\n  """"""\n  if hidden_size % num_attention_heads != 0:\n    raise ValueError(\n        ""The hidden size (%d) is not a multiple of the number of attention ""\n        ""heads (%d)"" % (hidden_size, num_attention_heads))\n\n  attention_head_size = int(hidden_size / num_attention_heads)\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  input_width = input_shape[2]\n\n  # The Transformer performs sum residuals on all layers so the input needs\n  # to be the same as the hidden size.\n  if input_width != hidden_size:\n    raise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n                     (input_width, hidden_size))\n\n  # We keep the representation as a 2D tensor to avoid re-shaping it back and\n  # forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n  # the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n  # help the optimizer.\n  prev_output = reshape_to_matrix(input_tensor)\n\n  all_layer_outputs = []\n  for layer_idx in range(num_hidden_layers):\n    with tf.variable_scope(""layer_%d"" % layer_idx):\n      layer_input = prev_output\n\n      with tf.variable_scope(""attention""):\n        attention_heads = []\n        with tf.variable_scope(""self""):\n          attention_head = attention_layer(\n              from_tensor=layer_input,\n              to_tensor=layer_input,\n              attention_mask=attention_mask,\n              num_attention_heads=num_attention_heads,\n              size_per_head=attention_head_size,\n              attention_probs_dropout_prob=attention_probs_dropout_prob,\n              initializer_range=initializer_range,\n              do_return_2d_tensor=True,\n              batch_size=batch_size,\n              from_seq_length=seq_length,\n              to_seq_length=seq_length)\n          attention_heads.append(attention_head)\n\n        attention_output = None\n        if len(attention_heads) == 1:\n          attention_output = attention_heads[0]\n        else:\n          # In the case where we have other sequences, we just concatenate\n          # them to the self-attention head before the projection.\n          attention_output = tf.concat(attention_heads, axis=-1)\n\n        # Run a linear projection of `hidden_size` then add a residual\n        # with `layer_input`.\n        with tf.variable_scope(""output""):\n          attention_output = tf.layers.dense(\n              attention_output,\n              hidden_size,\n              kernel_initializer=create_initializer(initializer_range))\n          attention_output = dropout(attention_output, hidden_dropout_prob)\n          attention_output = layer_norm(attention_output + layer_input)\n\n      # The activation is only applied to the ""intermediate"" hidden layer.\n      with tf.variable_scope(""intermediate""):\n        intermediate_output = tf.layers.dense(\n            attention_output,\n            intermediate_size,\n            activation=intermediate_act_fn,\n            kernel_initializer=create_initializer(initializer_range))\n\n      # Down-project back to `hidden_size` then add the residual.\n      with tf.variable_scope(""output""):\n        layer_output = tf.layers.dense(\n            intermediate_output,\n            hidden_size,\n            kernel_initializer=create_initializer(initializer_range))\n        layer_output = dropout(layer_output, hidden_dropout_prob)\n        layer_output = layer_norm(layer_output + attention_output)\n        prev_output = layer_output\n        all_layer_outputs.append(layer_output)\n\n  if do_return_all_layers:\n    final_outputs = []\n    for layer_output in all_layer_outputs:\n      final_output = reshape_from_matrix(layer_output, input_shape)\n      final_outputs.append(final_output)\n    return final_outputs\n  else:\n    final_output = reshape_from_matrix(prev_output, input_shape)\n    return final_output\n\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n  """"""Returns a list of the shape of tensor, preferring static dimensions.\n\n  Args:\n    tensor: A tf.Tensor object to find the shape of.\n    expected_rank: (optional) int. The expected rank of `tensor`. If this is\n      specified and the `tensor` has a different rank, and exception will be\n      thrown.\n    name: Optional name of the tensor for the error message.\n\n  Returns:\n    A list of dimensions of the shape of tensor. All static dimensions will\n    be returned as python integers, and dynamic dimensions will be returned\n    as tf.Tensor scalars.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  if expected_rank is not None:\n    assert_rank(tensor, expected_rank, name)\n\n  shape = tensor.shape.as_list()\n\n  non_static_indexes = []\n  for (index, dim) in enumerate(shape):\n    if dim is None:\n      non_static_indexes.append(index)\n\n  if not non_static_indexes:\n    return shape\n\n  dyn_shape = tf.shape(tensor)\n  for index in non_static_indexes:\n    shape[index] = dyn_shape[index]\n  return shape\n\n\ndef reshape_to_matrix(input_tensor):\n  """"""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n  ndims = input_tensor.shape.ndims\n  if ndims < 2:\n    raise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n                     (input_tensor.shape))\n  if ndims == 2:\n    return input_tensor\n\n  width = input_tensor.shape[-1]\n  output_tensor = tf.reshape(input_tensor, [-1, width])\n  return output_tensor\n\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n  """"""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n  if len(orig_shape_list) == 2:\n    return output_tensor\n\n  output_shape = get_shape_list(output_tensor)\n\n  orig_dims = orig_shape_list[0:-1]\n  width = output_shape[-1]\n\n  return tf.reshape(output_tensor, orig_dims + [width])\n\n\ndef assert_rank(tensor, expected_rank, name=None):\n  """"""Raises an exception if the tensor rank is not of the expected rank.\n\n  Args:\n    tensor: A tf.Tensor to check the rank of.\n    expected_rank: Python integer or list of integers, expected rank.\n    name: Optional name of the tensor for the error message.\n\n  Raises:\n    ValueError: If the expected shape doesn\'t match the actual shape.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  expected_rank_dict = {}\n  if isinstance(expected_rank, six.integer_types):\n    expected_rank_dict[expected_rank] = True\n  else:\n    for x in expected_rank:\n      expected_rank_dict[x] = True\n\n  actual_rank = tensor.shape.ndims\n  if actual_rank not in expected_rank_dict:\n    scope_name = tf.get_variable_scope().name\n    raise ValueError(\n        ""For the tensor `%s` in scope `%s`, the actual rank ""\n        ""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n        (name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n'"
baselines/models/roberta_wwm_ext/modeling_test.py,5,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport random\nimport re\n\nimport modeling\nimport six\nimport tensorflow as tf\n\n\nclass BertModelTest(tf.test.TestCase):\n\n  class BertModelTester(object):\n\n    def __init__(self,\n                 parent,\n                 batch_size=13,\n                 seq_length=7,\n                 is_training=True,\n                 use_input_mask=True,\n                 use_token_type_ids=True,\n                 vocab_size=99,\n                 hidden_size=32,\n                 num_hidden_layers=5,\n                 num_attention_heads=4,\n                 intermediate_size=37,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=16,\n                 initializer_range=0.02,\n                 scope=None):\n      self.parent = parent\n      self.batch_size = batch_size\n      self.seq_length = seq_length\n      self.is_training = is_training\n      self.use_input_mask = use_input_mask\n      self.use_token_type_ids = use_token_type_ids\n      self.vocab_size = vocab_size\n      self.hidden_size = hidden_size\n      self.num_hidden_layers = num_hidden_layers\n      self.num_attention_heads = num_attention_heads\n      self.intermediate_size = intermediate_size\n      self.hidden_act = hidden_act\n      self.hidden_dropout_prob = hidden_dropout_prob\n      self.attention_probs_dropout_prob = attention_probs_dropout_prob\n      self.max_position_embeddings = max_position_embeddings\n      self.type_vocab_size = type_vocab_size\n      self.initializer_range = initializer_range\n      self.scope = scope\n\n    def create_model(self):\n      input_ids = BertModelTest.ids_tensor([self.batch_size, self.seq_length],\n                                           self.vocab_size)\n\n      input_mask = None\n      if self.use_input_mask:\n        input_mask = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], vocab_size=2)\n\n      token_type_ids = None\n      if self.use_token_type_ids:\n        token_type_ids = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], self.type_vocab_size)\n\n      config = modeling.BertConfig(\n          vocab_size=self.vocab_size,\n          hidden_size=self.hidden_size,\n          num_hidden_layers=self.num_hidden_layers,\n          num_attention_heads=self.num_attention_heads,\n          intermediate_size=self.intermediate_size,\n          hidden_act=self.hidden_act,\n          hidden_dropout_prob=self.hidden_dropout_prob,\n          attention_probs_dropout_prob=self.attention_probs_dropout_prob,\n          max_position_embeddings=self.max_position_embeddings,\n          type_vocab_size=self.type_vocab_size,\n          initializer_range=self.initializer_range)\n\n      model = modeling.BertModel(\n          config=config,\n          is_training=self.is_training,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          token_type_ids=token_type_ids,\n          scope=self.scope)\n\n      outputs = {\n          ""embedding_output"": model.get_embedding_output(),\n          ""sequence_output"": model.get_sequence_output(),\n          ""pooled_output"": model.get_pooled_output(),\n          ""all_encoder_layers"": model.get_all_encoder_layers(),\n      }\n      return outputs\n\n    def check_output(self, result):\n      self.parent.assertAllEqual(\n          result[""embedding_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(\n          result[""sequence_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(result[""pooled_output""].shape,\n                                 [self.batch_size, self.hidden_size])\n\n  def test_default(self):\n    self.run_tester(BertModelTest.BertModelTester(self))\n\n  def test_config_to_json_string(self):\n    config = modeling.BertConfig(vocab_size=99, hidden_size=37)\n    obj = json.loads(config.to_json_string())\n    self.assertEqual(obj[""vocab_size""], 99)\n    self.assertEqual(obj[""hidden_size""], 37)\n\n  def run_tester(self, tester):\n    with self.test_session() as sess:\n      ops = tester.create_model()\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      output_result = sess.run(ops)\n      tester.check_output(output_result)\n\n      self.assert_all_tensors_reachable(sess, [init_op, ops])\n\n  @classmethod\n  def ids_tensor(cls, shape, vocab_size, rng=None, name=None):\n    """"""Creates a random int32 tensor of the shape within the vocab size.""""""\n    if rng is None:\n      rng = random.Random()\n\n    total_dims = 1\n    for dim in shape:\n      total_dims *= dim\n\n    values = []\n    for _ in range(total_dims):\n      values.append(rng.randint(0, vocab_size - 1))\n\n    return tf.constant(value=values, dtype=tf.int32, shape=shape, name=name)\n\n  def assert_all_tensors_reachable(self, sess, outputs):\n    """"""Checks that all the tensors in the graph are reachable from outputs.""""""\n    graph = sess.graph\n\n    ignore_strings = [\n        ""^.*/assert_less_equal/.*$"",\n        ""^.*/dilation_rate$"",\n        ""^.*/Tensordot/concat$"",\n        ""^.*/Tensordot/concat/axis$"",\n        ""^testing/.*$"",\n    ]\n\n    ignore_regexes = [re.compile(x) for x in ignore_strings]\n\n    unreachable = self.get_unreachable_ops(graph, outputs)\n    filtered_unreachable = []\n    for x in unreachable:\n      do_ignore = False\n      for r in ignore_regexes:\n        m = r.match(x.name)\n        if m is not None:\n          do_ignore = True\n      if do_ignore:\n        continue\n      filtered_unreachable.append(x)\n    unreachable = filtered_unreachable\n\n    self.assertEqual(\n        len(unreachable), 0, ""The following ops are unreachable: %s"" %\n        ("" "".join([x.name for x in unreachable])))\n\n  @classmethod\n  def get_unreachable_ops(cls, graph, outputs):\n    """"""Finds all of the tensors in graph that are unreachable from outputs.""""""\n    outputs = cls.flatten_recursive(outputs)\n    output_to_op = collections.defaultdict(list)\n    op_to_all = collections.defaultdict(list)\n    assign_out_to_in = collections.defaultdict(list)\n\n    for op in graph.get_operations():\n      for x in op.inputs:\n        op_to_all[op.name].append(x.name)\n      for y in op.outputs:\n        output_to_op[y.name].append(op.name)\n        op_to_all[op.name].append(y.name)\n      if str(op.type) == ""Assign"":\n        for y in op.outputs:\n          for x in op.inputs:\n            assign_out_to_in[y.name].append(x.name)\n\n    assign_groups = collections.defaultdict(list)\n    for out_name in assign_out_to_in.keys():\n      name_group = assign_out_to_in[out_name]\n      for n1 in name_group:\n        assign_groups[n1].append(out_name)\n        for n2 in name_group:\n          if n1 != n2:\n            assign_groups[n1].append(n2)\n\n    seen_tensors = {}\n    stack = [x.name for x in outputs]\n    while stack:\n      name = stack.pop()\n      if name in seen_tensors:\n        continue\n      seen_tensors[name] = True\n\n      if name in output_to_op:\n        for op_name in output_to_op[name]:\n          if op_name in op_to_all:\n            for input_name in op_to_all[op_name]:\n              if input_name not in stack:\n                stack.append(input_name)\n\n      expanded_names = []\n      if name in assign_groups:\n        for assign_name in assign_groups[name]:\n          expanded_names.append(assign_name)\n\n      for expanded_name in expanded_names:\n        if expanded_name not in stack:\n          stack.append(expanded_name)\n\n    unreachable_ops = []\n    for op in graph.get_operations():\n      is_unreachable = False\n      all_names = [x.name for x in op.inputs] + [x.name for x in op.outputs]\n      for name in all_names:\n        if name not in seen_tensors:\n          is_unreachable = True\n      if is_unreachable:\n        unreachable_ops.append(op)\n    return unreachable_ops\n\n  @classmethod\n  def flatten_recursive(cls, item):\n    """"""Flattens (potentially nested) a tuple/dictionary/list to a list.""""""\n    output = []\n    if isinstance(item, list):\n      output.extend(item)\n    elif isinstance(item, tuple):\n      output.extend(list(item))\n    elif isinstance(item, dict):\n      for (_, v) in six.iteritems(item):\n        output.append(v)\n    else:\n      return [item]\n\n    flat_output = []\n    for x in output:\n      flat_output.extend(cls.flatten_recursive(x))\n    return flat_output\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/roberta_wwm_ext/optimization.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/roberta_wwm_ext/optimization_test.py,11,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport optimization\nimport tensorflow as tf\n\n\nclass OptimizationTest(tf.test.TestCase):\n\n  def test_adam(self):\n    with self.test_session() as sess:\n      w = tf.get_variable(\n          ""w"",\n          shape=[3],\n          initializer=tf.constant_initializer([0.1, -0.2, -0.1]))\n      x = tf.constant([0.4, 0.2, -0.5])\n      loss = tf.reduce_mean(tf.square(x - w))\n      tvars = tf.trainable_variables()\n      grads = tf.gradients(loss, tvars)\n      global_step = tf.train.get_or_create_global_step()\n      optimizer = optimization.AdamWeightDecayOptimizer(learning_rate=0.2)\n      train_op = optimizer.apply_gradients(zip(grads, tvars), global_step)\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      for _ in range(100):\n        sess.run(train_op)\n      w_np = sess.run(w)\n      self.assertAllClose(w_np.flat, [0.4, 0.2, -0.5], rtol=1e-2, atol=1e-2)\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/roberta_wwm_ext/run_classifier.py,112,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:30:38\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nimport sys\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n# Required parameters\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input data dir. Should contain the .tsv files (or other data files) ""\n    ""for the task."")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""task_name"", None, ""The name of the task to train."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n# Other parameters\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(\n    ""do_predict"", False,\n    ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n  return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    features[""label_ids""] = create_int_feature([feature.label_id])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 labels, num_labels, use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use model.get_sequence_output()\n  # instead.\n  output_layer = model.get_pooled_output()\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n    is_real_example = None\n    if ""is_real_example"" in features:\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n    else:\n      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,\n        num_labels, use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n       ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(\n            labels=label_ids, predictions=predictions, weights=is_real_example)\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn,\n                      [per_example_loss, label_ids, logits, is_real_example])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={""probabilities"": probabilities},\n          scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef input_fn_builder(features, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_input_ids = []\n  all_input_mask = []\n  all_segment_ids = []\n  all_label_ids = []\n\n  for feature in features:\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_segment_ids.append(feature.segment_ids)\n    all_label_ids.append(feature.label_id)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""segment_ids"":\n            tf.constant(\n                all_segment_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""label_ids"":\n            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),\n    })\n\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)\n    return d\n\n  return input_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer):\n  """"""Convert a set of `InputExample`s to a list of `InputFeatures`.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    features.append(feature)\n  return features\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval` or `do_predict\' must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      num_labels=len(label_list),\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    else:\n      file_based_convert_examples_to_features(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    # dev dataset\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    num_actual_eval_examples = len(eval_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on. These do NOT count towards the metric (all tf.metrics\n      # support a per-instance weight, and these get a weight of 0.0).\n      while len(eval_examples) % FLAGS.eval_batch_size != 0:\n        eval_examples.append(PaddingInputExample())\n\n    eval_file = os.path.join(FLAGS.output_dir, ""dev.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(eval_examples), num_actual_eval_examples,\n                    len(eval_examples) - num_actual_eval_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      assert len(eval_examples) % FLAGS.eval_batch_size == 0\n      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    #######################################################################################################################\n    # evaluate all checkpoints; you can use the checkpoint with the best dev accuarcy\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_roberta_wwm_ext.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        result = estimator.evaluate(input_fn=eval_input_fn,\n                                    steps=eval_steps, checkpoint_path=filename)\n\n        tf.logging.info(""***** Eval results %s *****"" % (filename))\n        writer.write(""***** Eval results %s *****\\n"" % (filename))\n        for key in sorted(result.keys()):\n          tf.logging.info(""  %s = %s"", key, str(result[key]))\n          writer.write(""%s = %s\\n"" % (key, str(result[key])))\n    #######################################################################################################################\n\n    # result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n    #\n    # output_eval_file = os.path.join(FLAGS.output_dir, ""dev_results_roberta_wwm_ext.txt"")\n    # with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n    #  tf.logging.info(""***** Eval results *****"")\n    #  for key in sorted(result.keys()):\n    #    tf.logging.info(""  %s = %s"", key, str(result[key]))\n    #    writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    num_actual_predict_examples = len(predict_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on.\n      while len(predict_examples) % FLAGS.predict_batch_size != 0:\n        predict_examples.append(PaddingInputExample())\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(predict_examples, label_list,\n                                                        FLAGS.max_seq_length, tokenizer,\n                                                        predict_file)\n    else:\n      file_based_convert_examples_to_features(predict_examples, label_list,\n                                              FLAGS.max_seq_length, tokenizer,\n                                              predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(predict_examples), num_actual_predict_examples,\n                    len(predict_examples) - num_actual_predict_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_drop_remainder = True if FLAGS.use_tpu else False\n    predict_input_fn = file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=predict_drop_remainder)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_ext/run_classifier_with_tfhub.py,51,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner with TF-Hub.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport optimization\nimport run_classifier\nimport tokenization\nimport tensorflow as tf\nimport tensorflow_hub as hub\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""bert_hub_module_handle"", None,\n    ""Handle for the BERT TF-Hub module."")\n\n\ndef create_model(is_training, input_ids, input_mask, segment_ids, labels,\n                 num_labels, bert_hub_module_handle):\n  """"""Creates a classification model.""""""\n  tags = set()\n  if is_training:\n    tags.add(""train"")\n  bert_module = hub.Module(bert_hub_module_handle, tags=tags, trainable=True)\n  bert_inputs = dict(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids)\n  bert_outputs = bert_module(\n      inputs=bert_inputs,\n      signature=""tokens"",\n      as_dict=True)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use\n  # bert_outputs[""sequence_output""] instead.\n  output_layer = bert_outputs[""pooled_output""]\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(num_labels, learning_rate, num_train_steps,\n                     num_warmup_steps, use_tpu, bert_hub_module_handle):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        is_training, input_ids, input_mask, segment_ids, label_ids, num_labels,\n        bert_hub_module_handle)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(label_ids, predictions)\n        loss = tf.metrics.mean(per_example_loss)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions={""probabilities"": probabilities})\n    else:\n      raise ValueError(\n          ""Only TRAIN, EVAL and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef create_tokenizer_from_hub_module(bert_hub_module_handle):\n  """"""Get the vocab file and casing info from the Hub module.""""""\n  with tf.Graph().as_default():\n    bert_module = hub.Module(bert_hub_module_handle)\n    tokenization_info = bert_module(signature=""tokenization_info"", as_dict=True)\n    with tf.Session() as sess:\n      vocab_file, do_lower_case = sess.run([tokenization_info[""vocab_file""],\n                                            tokenization_info[""do_lower_case""]])\n  return tokenization.FullTokenizer(\n      vocab_file=vocab_file, do_lower_case=do_lower_case)\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""cola"": run_classifier.ColaProcessor,\n      ""mnli"": run_classifier.MnliProcessor,\n      ""mrpc"": run_classifier.MrpcProcessor,\n  }\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = create_tokenizer_from_hub_module(FLAGS.bert_hub_module_handle)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      num_labels=len(label_list),\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      bert_hub_module_handle=FLAGS.bert_hub_module_handle)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_features = run_classifier.convert_examples_to_features(\n        train_examples, label_list, FLAGS.max_seq_length, tokenizer)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = run_classifier.input_fn_builder(\n        features=train_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    eval_features = run_classifier.convert_examples_to_features(\n        eval_examples, label_list, FLAGS.max_seq_length, tokenizer)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d"", len(eval_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      # Eval will be slightly WRONG on the TPU because it will truncate\n      # the last batch.\n      eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = run_classifier.input_fn_builder(\n        features=eval_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    if FLAGS.use_tpu:\n      # Discard batch remainder if running on TPU\n      n = len(predict_examples)\n      predict_examples = predict_examples[:(n - n % FLAGS.predict_batch_size)]\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    run_classifier.file_based_convert_examples_to_features(\n        predict_examples, label_list, FLAGS.max_seq_length, tokenizer,\n        predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d"", len(predict_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_input_fn = run_classifier.file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=FLAGS.use_tpu)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n      tf.logging.info(""***** Predict results *****"")\n      for prediction in result:\n        probabilities = prediction[""probabilities""]\n        output_line = ""\\t"".join(\n            str(class_probability)\n            for class_probability in probabilities) + ""\\n""\n        writer.write(output_line)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""bert_hub_module_handle"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_ext/run_ner.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nfrom sklearn.metrics import f1_score, precision_score, recall_score\nfrom tensorflow.python.ops import math_ops\nimport tf_metrics\nimport pickle\nimport codecs\nimport sys\n\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input datadir."",\n)\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model.""\n)\n\nflags.DEFINE_string(\n    ""task_name"", None, ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""token_name"", ""full"", ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written.""\n)\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model).""\n)\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text.""\n)\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization.""\n)\n\nflags.DEFINE_bool(\n    ""do_train"", False,\n    ""Whether to run training.""\n)\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0, ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputExample(object):\n    """"""A single training/test example for simple sequence classification.""""""\n\n    def __init__(self, guid, text, label=None):\n        """"""Constructs a InputExample.\n\n        Args:\n          guid: Unique id for the example.\n          text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n          label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid = guid\n        self.text = text\n        self.label = label\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self, input_ids, input_mask, segment_ids, label_ids, label_mask):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_ids = label_ids\n        self.label_mask = label_mask\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_data(cls, input_file):\n        """"""Reads a BIO data.""""""\n        with open(input_file) as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                word = line.strip().split(\' \')[0]\n                label = line.strip().split(\' \')[-1]\n                if contends.startswith(""-DOCSTART-""):\n                    words.append(\'\')\n                    continue\n                if len(contends) == 0 and words[-1] == \'.\':\n                    l = \' \'.join([label for label in labels if len(label) > 0])\n                    w = \' \'.join([word for word in words if len(word) > 0])\n                    lines.append([l, w])\n                    words = []\n                    labels = []\n                    continue\n                if len(contends) == 0:\n                    continue\n                words.append(word)\n                labels.append(label)\n            return lines\n\n\nclass NerProcessor(DataProcessor):\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""train.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""dev.txt"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""test.txt"")), ""test"")\n\n    def get_labels(self):\n        # return [""I-MISC"", ""I-PER"",  ""I-ORG"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        return [""B-MISC"", ""I-MISC"", ""B-PER"", ""I-PER"", ""B-ORG"", ""I-ORG"", ""B-LOC"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\nclass WeiboNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.train"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.dev"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.test"")), ""test"")\n\n\n    def get_labels(self):\n        return [\'I-PER.NOM\', \'I-PER.NAM\', \'I-GPE.NAM\', \'I-ORG.NAM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        # return [\'B-PER.NOM\', \'I-PER.NOM\', \'B-LOC.NAM\', \'B-PER.NAM\', \'I-PER.NAM\', \'B-GPE.NAM\', \'I-GPE.NAM\', \'B-ORG.NAM\', \'I-ORG.NAM\', \'B-ORG.NOM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'B-LOC.NOM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                if len(tokens) == 2:\n                    words.append(tokens[0])\n                    label = tokens[-1]\n                    if label[0] == \'B\':\n                        label = ""I"" + label[1:]\n                    labels.append(label)\n                else:\n                    if len(contends) == 0 and len(words) > 0:\n                        label = []\n                        word = []\n                        for l, w in zip(labels, words):\n                            if len(l) > 0 and len(w) > 0:\n                                label.append(l)\n                                # self.labels.add(l)\n                                word.append(w)\n                        lines.append([\' \'.join(label), \' \'.join(word)])\n                        words = []\n                        labels = []\n                        continue\n                if contends.startswith(""-DOCSTART-""):\n                    continue\n\n            return lines\n\nclass MsraNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""train1.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""test"")\n\n    def get_labels(self):\n        return [\'B-PERSON\', \'I-PERSON\', \'B-LOCATION\', \'I-LOCATION\', \'B-ORGANIZATION\', \'I-ORGANIZATION\', ""O"", ""[CLS]"", ""[SEP]"", ""X""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            chars = []\n            labels = []\n            len_count = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                for token in tokens:\n                    word, label = token.split(\'/\')\n\n                    if label == ""nr"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-PERSON\'] + [\'I-PERSON\']*(len(word)-1)\n                    elif label == ""ns"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-LOCATION\'] + [\'I-LOCATION\']*(len(word)-1)\n                    elif label == ""nt"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-ORGANIZATION\'] + [\'I-ORGANIZATION\']*(len(word)-1)\n                    else:\n                        assert label == ""o""\n                        chars = chars + list(word)\n                        labels = labels + [""O""] * len(word)\n                lines.append([\' \'.join(labels), \' \'.join(chars)])\n                len_count.append(len(chars))\n                chars = []\n                labels = []\n            return lines\n\n\ndef write_tokens(tokens, mode):\n    if mode == ""test"":\n        path = os.path.join(FLAGS.output_dir, ""token_"" + mode + "".txt"")\n        wf = open(path, \'a\')\n        for token in tokens:\n            if token != ""**NULL**"":\n                wf.write(token + \'\\n\')\n        wf.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode):\n    label_map = {}\n    for (i, label) in enumerate(label_list, 1):\n        label_map[label] = i\n\n    if not os.path.exists(os.path.join(output_dir, \'label2id.pkl\')):\n        with open(os.path.join(output_dir, \'label2id.pkl\'), \'wb\') as w:\n            pickle.dump(label_map, w)\n    textlist = example.text.split(\' \')\n    labellist = example.label.split(\' \')\n    tokens = []\n    labels = []\n    label_mask = []\n    for i, word in enumerate(textlist):\n        token = tokenizer.tokenize(word)\n        tokens.extend(token)\n        label_1 = labellist[i]\n        for m in range(len(token)):\n            if m == 0:\n                labels.append(label_1)\n            else:\n                labels.append(""X"")\n    \n    # tokens = tokenizer.tokenize(example.text)\n    if len(tokens) >= max_seq_length - 1:\n        tokens = tokens[0:(max_seq_length - 2)]\n        labels = labels[0:(max_seq_length - 2)]\n    ntokens = []\n    segment_ids = []\n    label_ids = []\n    ntokens.append(""[CLS]"")\n    segment_ids.append(0)\n    # append(""O"") or append(""[CLS]"") not sure!\n    label_ids.append(label_map[""[CLS]""])\n    label_mask.append(0) # not to predict and train\n    for i, token in enumerate(tokens):\n        ntokens.append(token)\n        segment_ids.append(0)\n        label_ids.append(label_map[labels[i]])\n        if labels[i] == \'X\':\n            label_mask.append(0)\n        else:\n            label_mask.append(1)\n    ntokens.append(""[SEP]"")\n    segment_ids.append(0)\n    label_mask.append(0)\n    # append(""O"") or append(""[SEP]"") not sure!\n    label_ids.append(label_map[""[SEP]""])\n    input_ids = tokenizer.convert_tokens_to_ids(ntokens)\n    input_mask = [1] * len(input_ids)\n    # label_mask = [1] * len(input_ids)\n    while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n        # we don\'t concerned about it!\n        label_ids.append(0)\n        ntokens.append(""**NULL**"")\n        label_mask.append(0)\n    # print(len(input_ids))\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n    assert len(label_ids) == max_seq_length\n    assert len(label_mask) == max_seq_length\n\n    if ex_index < 5:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""guid: %s"" % (example.guid))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        tf.logging.info(""label_ids: %s"" % "" "".join([str(x) for x in label_ids]))\n        tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n        # tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n\n    feature = InputFeatures(\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        label_ids=label_ids,\n        label_mask = label_mask\n    )\n    write_tokens(ntokens, mode)\n    return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file, output_dir, mode=None\n):\n    writer = tf.python_io.TFRecordWriter(output_file)\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 5000 == 0:\n            tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n        feature = convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode)\n\n        def create_int_feature(values):\n            f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n            return f\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(feature.input_ids)\n        features[""input_mask""] = create_int_feature(feature.input_mask)\n        features[""segment_ids""] = create_int_feature(feature.segment_ids)\n        features[""label_ids""] = create_int_feature(feature.label_ids)\n        features[""label_mask""] = create_int_feature(feature.label_mask)\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n        writer.write(tf_example.SerializeToString())\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n    name_to_features = {\n        ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n    }\n\n    def _decode_record(record, name_to_features):\n        example = tf.parse_single_example(record, name_to_features)\n        for name in list(example.keys()):\n            t = example[name]\n            if t.dtype == tf.int64:\n                t = tf.to_int32(t)\n            example[name] = t\n        return example\n\n    def input_fn(params):\n        batch_size = params[""batch_size""]\n        d = tf.data.TFRecordDataset(input_file)\n        if is_training:\n            d = d.repeat()\n            d = d.shuffle(buffer_size=100)\n        d = d.apply(tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder\n        ))\n        return d\n\n    return input_fn\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, label_mask,\n                 segment_ids, labels, num_labels, use_one_hot_embeddings):\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings\n    )\n\n    output_layer = model.get_sequence_output()\n\n    hidden_size = output_layer.shape[-1].value\n\n    output_weight = tf.get_variable(\n        ""output_weights"", [num_labels, hidden_size],\n        initializer=tf.truncated_normal_initializer(stddev=0.02)\n    )\n    output_bias = tf.get_variable(\n        ""output_bias"", [num_labels], initializer=tf.zeros_initializer()\n    )\n    with tf.variable_scope(""loss""):\n        if is_training:\n            output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n        output_layer = tf.reshape(output_layer, [-1, hidden_size])\n        logits = tf.matmul(output_layer, output_weight, transpose_b=True)\n        logits = tf.nn.bias_add(logits, output_bias)\n        logits = tf.reshape(logits, [-1, FLAGS.max_seq_length, num_labels])\n        # mask = tf.cast(input_mask,tf.float32)\n        # loss = tf.contrib.seq2seq.sequence_loss(logits,labels,mask)\n        # return (loss, logits, predict)\n        ##########################################################################\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n        per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n        mask = tf.cast(label_mask, tf.float32)\n        mask_example_loss = per_example_loss * mask\n        loss = tf.reduce_sum(mask_example_loss)\n        probabilities = tf.nn.softmax(logits, axis=-1)\n        predict = tf.argmax(probabilities, axis=-1)\n        return (loss, mask_example_loss, logits, predict)\n        ##########################################################################\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n    def model_fn(features, labels, mode, params):\n        tf.logging.info(""*** Features ***"")\n        for name in sorted(features.keys()):\n            tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n        input_ids = features[""input_ids""]\n        input_mask = features[""input_mask""]\n        segment_ids = features[""segment_ids""]\n        label_ids = features[""label_ids""]\n        label_mask = features[""label_mask""]\n        is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n        (total_loss, per_example_loss, logits, predicts) = create_model(\n            bert_config, is_training, input_ids, input_mask, label_mask, segment_ids, label_ids,\n            num_labels, use_one_hot_embeddings)\n        tvars = tf.trainable_variables()\n        scaffold_fn = None\n        if init_checkpoint:\n            (assignment_map, initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(tvars,\n                                                                                                       init_checkpoint)\n            tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n            if use_tpu:\n                def tpu_scaffold():\n                    tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n                    return tf.train.Scaffold()\n\n                scaffold_fn = tpu_scaffold\n            else:\n                tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        tf.logging.info(""**** Trainable Variables ****"")\n\n        for var in tvars:\n            init_string = """"\n            if var.name in initialized_variable_names:\n                init_string = "", *INIT_FROM_CKPT*""\n            tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                            init_string)\n        output_spec = None\n        if mode == tf.estimator.ModeKeys.TRAIN:\n            train_op = optimization.create_optimizer(\n                total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n            hook_dict = {}\n            hook_dict[\'loss\'] = total_loss\n            hook_dict[\'global_steps\'] = tf.train.get_or_create_global_step()\n            logging_hook = tf.train.LoggingTensorHook(\n                hook_dict, every_n_iter=200)\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                train_op=train_op,\n                scaffold_fn=scaffold_fn,\n                training_hooks=[logging_hook])\n        elif mode == tf.estimator.ModeKeys.EVAL:\n\n            def metric_fn(per_example_loss, label_ids, logits):\n                # def metric_fn(label_ids, logits):\n                predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n                # labels = []\n                # for i, x in enumerate()\n                predict_labels = []\n                # for i in range(1, num_labels - 4):\n                #     predict_labels.append(i)\n                # precision = tf_metrics.precision(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # recall = tf_metrics.recall(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # f = tf_metrics.f1(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n\n                precision = tf_metrics.precision(label_ids, predictions, num_labels, average=""macro"")\n                recall = tf_metrics.recall(label_ids, predictions, num_labels, average=""macro"")\n                f = tf_metrics.f1(label_ids, predictions, num_labels, average=""macro"")\n\n                #\n                return {\n                    ""eval_precision"": precision,\n                    ""eval_recall"": recall,\n                    ""eval_f"": f,\n                    # ""eval_loss"": loss,\n                }\n\n            eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n            # eval_metrics = (metric_fn, [label_ids, logits])\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                eval_metrics=eval_metrics,\n                scaffold_fn=scaffold_fn)\n        else:\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode, predictions=predicts, scaffold_fn=scaffold_fn\n            )\n        return output_spec\n\n    return model_fn\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    processors = {\n        ""ner"": NerProcessor,\n        ""weiboner"": WeiboNERProcessor,\n        ""msraner"": MsraNERProcessor\n    }\n    # if not FLAGS.do_train and not FLAGS.do_eval:\n    #     raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n    bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n    if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n        raise ValueError(\n            ""Cannot use sequence length %d because the BERT model ""\n            ""was only trained up to sequence length %d"" %\n            (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n    if not os.path.exists(FLAGS.output_dir):\n        os.mkdir(FLAGS.output_dir)\n    task_name = FLAGS.task_name.lower()\n    if task_name not in processors:\n        raise ValueError(""Task not found: %s"" % (task_name))\n    processor = processors[task_name]()\n\n    label_list = processor.get_labels()\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    tpu_cluster_resolver = None\n    if FLAGS.use_tpu and FLAGS.tpu_name:\n        tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n            FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n    is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n\n    run_config = tf.contrib.tpu.RunConfig(\n        cluster=tpu_cluster_resolver,\n        master=FLAGS.master,\n        model_dir=FLAGS.output_dir,\n        save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n        tpu_config=tf.contrib.tpu.TPUConfig(\n            iterations_per_loop=FLAGS.iterations_per_loop,\n            num_shards=FLAGS.num_tpu_cores,\n            per_host_input_for_training=is_per_host))\n\n    train_examples = None\n    num_train_steps = None\n    num_warmup_steps = None\n\n    if FLAGS.do_train:\n        train_examples = processor.get_train_examples(FLAGS.data_dir)\n        num_train_steps = int(\n            len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n        print(num_train_steps)\n        num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    model_fn = model_fn_builder(\n        bert_config=bert_config,\n        num_labels=len(label_list) + 1,\n        init_checkpoint=FLAGS.init_checkpoint,\n        learning_rate=FLAGS.learning_rate,\n        num_train_steps=num_train_steps,\n        num_warmup_steps=num_warmup_steps,\n        use_tpu=FLAGS.use_tpu,\n        use_one_hot_embeddings=FLAGS.use_tpu)\n\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n\n    if FLAGS.do_train:\n        train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file, FLAGS.output_dir)\n        tf.logging.info(""***** Running training *****"")\n        tf.logging.info(""  Num examples = %d"", len(train_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n        tf.logging.info(""  Num steps = %d"", num_train_steps)\n        train_input_fn = file_based_input_fn_builder(\n            input_file=train_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=True,\n            drop_remainder=True)\n        estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n    if FLAGS.do_eval:\n        eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n        eval_file = os.path.join(FLAGS.output_dir, ""eval.tf_record"")\n        file_based_convert_examples_to_features(\n            eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file, FLAGS.output_dir)\n\n        tf.logging.info(""***** Running evaluation *****"")\n        tf.logging.info(""  Num examples = %d"", len(eval_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n        eval_steps = None\n        if FLAGS.use_tpu:\n            eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n        eval_drop_remainder = True if FLAGS.use_tpu else False\n        eval_input_fn = file_based_input_fn_builder(\n            input_file=eval_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=eval_drop_remainder)\n        result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n        output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            tf.logging.info(""***** Eval results *****"")\n            for key in sorted(result.keys()):\n                tf.logging.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\n    if FLAGS.do_predict:\n\n        pred_tags = []\n        true_tags = []\n\n        token_path = os.path.join(FLAGS.output_dir, ""token_test.txt"")\n        label_file = os.path.join(FLAGS.output_dir, ""label2id.pkl"")\n        label_masks = []\n        with open(label_file, ""rb"") as rf:\n            label2id = pickle.load(rf)\n            id2label = {value: key for key, value in label2id.items()}\n        if os.path.exists(token_path):\n            os.remove(token_path)\n        predict_examples = processor.get_test_examples(FLAGS.data_dir)\n        ground_truth_file = os.path.join(FLAGS.output_dir, ""ground_truth.txt"")\n        with open(ground_truth_file, \'w\') as writer:\n            for ex_index, example in enumerate(predict_examples):\n                feature = convert_single_example(ex_index, example, label_list, FLAGS.max_seq_length, tokenizer, FLAGS.output_dir, ""test"")\n                line = []\n                for i, id in enumerate(feature.label_ids):\n                    if feature.label_mask[i] == 1:\n                        line.append(id2label[id])\n                        true_tags.append(id2label[id])\n                # output_line = "" "".join(id2label[id] for id in feature.label_ids if id != 0) + ""\\n""\n                output_line = "" "".join(line) + ""\\n""\n                writer.write(output_line)\n                label_masks.append(feature.label_mask)\n        predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n        file_based_convert_examples_to_features(predict_examples, label_list,\n                                                 FLAGS.max_seq_length, tokenizer,\n                                                 predict_file, FLAGS.output_dir, mode=""test"")\n\n        tf.logging.info(""***** Running prediction*****"")\n        tf.logging.info(""  Num examples = %d"", len(predict_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n        if FLAGS.use_tpu:\n            # Warning: According to tpu_estimator.py Prediction on TPU is an\n            # experimental feature and hence not supported here\n            raise ValueError(""Prediction in TPU not supported"")\n        predict_drop_remainder = True if FLAGS.use_tpu else False\n        predict_input_fn = file_based_input_fn_builder(\n            input_file=predict_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=predict_drop_remainder)\n\n        result = estimator.predict(input_fn=predict_input_fn)\n        output_predict_file = os.path.join(FLAGS.output_dir, ""label_test.txt"")\n\n        with open(output_predict_file, \'w\') as writer:\n            for i, prediction in enumerate(result):\n                line = []\n                for j, x in enumerate(prediction):\n                    if label_masks[i][j] == 0:\n                        continue\n                    else:\n                        line.append(id2label[x])\n                        # writer.write(id2label[x] + ""\\n"")\n                        pred_tags.append(id2label[x])\n                output_line = "" "".join(line) + ""\\n""\n                # # output_line = "" "".join(id2label[id] for id in prediction if id != 0) + ""\\n""\n                writer.write(output_line)\n        # evaluate(true_tags, pred_tags, verbose=True)\n        # evaluate(true_tags, pred_tags)\n\n        tmp = codecs.open(os.path.join(FLAGS.output_dir, ""tmp""), \'w\', \'utf8\')\n        with codecs.open(ground_truth_file, \'r\', \'utf8\') as ft, codecs.open(output_predict_file, \'r\', \'utf8\') as fg:\n            for lt, lg in zip(ft, fg):\n                for tl, tg in zip(lt.strip().split(), lg.strip().split()):\n                    print(\'\\t\'.join(["" "", tl, tg]), file=tmp)\n        tmp.close()\n        cmd = ""python %s -d \'\\t\' < %s > %s"" % \\\n                (os.path.join(os.getcwd(), ""conlleval.py""), \\\n                os.path.join(FLAGS.output_dir, ""tmp""), \\\n                os.path.join(FLAGS.data_dir, ""test_results_roberta_wwm_ext.txt""))\n        os.system(cmd)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""data_dir"")\n    flags.mark_flag_as_required(""task_name"")\n    flags.mark_flag_as_required(""vocab_file"")\n    flags.mark_flag_as_required(""bert_config_file"")\n    flags.mark_flag_as_required(""output_dir"")\n    tf.app.run()\n'"
baselines/models/roberta_wwm_ext/run_pretraining.py,97,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run masked LM/next sentence masked_lm pre-training for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport modeling\nimport optimization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(\n    ""input_file"", None,\n    ""Input TF example files (can be a glob or comma separated)."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded. Must match data generation."")\n\nflags.DEFINE_integer(\n    ""max_predictions_per_seq"", 20,\n    ""Maximum number of masked LM predictions per sequence. ""\n    ""Must match data generation."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_integer(""num_train_steps"", 100000, ""Number of training steps."")\n\nflags.DEFINE_integer(""num_warmup_steps"", 10000, ""Number of warmup steps."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(""max_eval_steps"", 100, ""Maximum number of eval steps."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    masked_lm_positions = features[""masked_lm_positions""]\n    masked_lm_ids = features[""masked_lm_ids""]\n    masked_lm_weights = features[""masked_lm_weights""]\n    next_sentence_labels = features[""next_sentence_labels""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    (masked_lm_loss,\n     masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(\n         bert_config, model.get_sequence_output(), model.get_embedding_table(),\n         masked_lm_positions, masked_lm_ids, masked_lm_weights)\n\n    (next_sentence_loss, next_sentence_example_loss,\n     next_sentence_log_probs) = get_next_sentence_output(\n         bert_config, model.get_pooled_output(), next_sentence_labels)\n\n    total_loss = masked_lm_loss + next_sentence_loss\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n                    masked_lm_weights, next_sentence_example_loss,\n                    next_sentence_log_probs, next_sentence_labels):\n        """"""Computes the loss and accuracy of the model.""""""\n        masked_lm_log_probs = tf.reshape(masked_lm_log_probs,\n                                         [-1, masked_lm_log_probs.shape[-1]])\n        masked_lm_predictions = tf.argmax(\n            masked_lm_log_probs, axis=-1, output_type=tf.int32)\n        masked_lm_example_loss = tf.reshape(masked_lm_example_loss, [-1])\n        masked_lm_ids = tf.reshape(masked_lm_ids, [-1])\n        masked_lm_weights = tf.reshape(masked_lm_weights, [-1])\n        masked_lm_accuracy = tf.metrics.accuracy(\n            labels=masked_lm_ids,\n            predictions=masked_lm_predictions,\n            weights=masked_lm_weights)\n        masked_lm_mean_loss = tf.metrics.mean(\n            values=masked_lm_example_loss, weights=masked_lm_weights)\n\n        next_sentence_log_probs = tf.reshape(\n            next_sentence_log_probs, [-1, next_sentence_log_probs.shape[-1]])\n        next_sentence_predictions = tf.argmax(\n            next_sentence_log_probs, axis=-1, output_type=tf.int32)\n        next_sentence_labels = tf.reshape(next_sentence_labels, [-1])\n        next_sentence_accuracy = tf.metrics.accuracy(\n            labels=next_sentence_labels, predictions=next_sentence_predictions)\n        next_sentence_mean_loss = tf.metrics.mean(\n            values=next_sentence_example_loss)\n\n        return {\n            ""masked_lm_accuracy"": masked_lm_accuracy,\n            ""masked_lm_loss"": masked_lm_mean_loss,\n            ""next_sentence_accuracy"": next_sentence_accuracy,\n            ""next_sentence_loss"": next_sentence_mean_loss,\n        }\n\n      eval_metrics = (metric_fn, [\n          masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n          masked_lm_weights, next_sentence_example_loss,\n          next_sentence_log_probs, next_sentence_labels\n      ])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(""Only TRAIN and EVAL modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef get_masked_lm_output(bert_config, input_tensor, output_weights, positions,\n                         label_ids, label_weights):\n  """"""Get loss and log probs for the masked LM.""""""\n  input_tensor = gather_indexes(input_tensor, positions)\n\n  with tf.variable_scope(""cls/predictions""):\n    # We apply one more non-linear transformation before the output layer.\n    # This matrix is not used after pre-training.\n    with tf.variable_scope(""transform""):\n      input_tensor = tf.layers.dense(\n          input_tensor,\n          units=bert_config.hidden_size,\n          activation=modeling.get_activation(bert_config.hidden_act),\n          kernel_initializer=modeling.create_initializer(\n              bert_config.initializer_range))\n      input_tensor = modeling.layer_norm(input_tensor)\n\n    # The output weights are the same as the input embeddings, but there is\n    # an output-only bias for each token.\n    output_bias = tf.get_variable(\n        ""output_bias"",\n        shape=[bert_config.vocab_size],\n        initializer=tf.zeros_initializer())\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    label_ids = tf.reshape(label_ids, [-1])\n    label_weights = tf.reshape(label_weights, [-1])\n\n    one_hot_labels = tf.one_hot(\n        label_ids, depth=bert_config.vocab_size, dtype=tf.float32)\n\n    # The `positions` tensor might be zero-padded (if the sequence is too\n    # short to have the maximum number of predictions). The `label_weights`\n    # tensor has a value of 1.0 for every real prediction and 0.0 for the\n    # padding predictions.\n    per_example_loss = -tf.reduce_sum(log_probs * one_hot_labels, axis=[-1])\n    numerator = tf.reduce_sum(label_weights * per_example_loss)\n    denominator = tf.reduce_sum(label_weights) + 1e-5\n    loss = numerator / denominator\n\n  return (loss, per_example_loss, log_probs)\n\n\ndef get_next_sentence_output(bert_config, input_tensor, labels):\n  """"""Get loss and log probs for the next sentence prediction.""""""\n\n  # Simple binary classification. Note that 0 is ""next sentence"" and 1 is\n  # ""random sentence"". This weight matrix is not used after pre-training.\n  with tf.variable_scope(""cls/seq_relationship""):\n    output_weights = tf.get_variable(\n        ""output_weights"",\n        shape=[2, bert_config.hidden_size],\n        initializer=modeling.create_initializer(bert_config.initializer_range))\n    output_bias = tf.get_variable(\n        ""output_bias"", shape=[2], initializer=tf.zeros_initializer())\n\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n    labels = tf.reshape(labels, [-1])\n    one_hot_labels = tf.one_hot(labels, depth=2, dtype=tf.float32)\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n    return (loss, per_example_loss, log_probs)\n\n\ndef gather_indexes(sequence_tensor, positions):\n  """"""Gathers the vectors at the specific positions over a minibatch.""""""\n  sequence_shape = modeling.get_shape_list(sequence_tensor, expected_rank=3)\n  batch_size = sequence_shape[0]\n  seq_length = sequence_shape[1]\n  width = sequence_shape[2]\n\n  flat_offsets = tf.reshape(\n      tf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n  flat_positions = tf.reshape(positions + flat_offsets, [-1])\n  flat_sequence_tensor = tf.reshape(sequence_tensor,\n                                    [batch_size * seq_length, width])\n  output_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n  return output_tensor\n\n\ndef input_fn_builder(input_files,\n                     max_seq_length,\n                     max_predictions_per_seq,\n                     is_training,\n                     num_cpu_threads=4):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    name_to_features = {\n        ""input_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""input_mask"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""segment_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""masked_lm_positions"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_ids"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_weights"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.float32),\n        ""next_sentence_labels"":\n            tf.FixedLenFeature([1], tf.int64),\n    }\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = tf.data.Dataset.from_tensor_slices(tf.constant(input_files))\n      d = d.repeat()\n      d = d.shuffle(buffer_size=len(input_files))\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_cpu_threads, len(input_files))\n\n      # `sloppy` mode means that the interleaving is not exact. This adds\n      # even more randomness to the training pipeline.\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n      d = d.shuffle(buffer_size=100)\n    else:\n      d = tf.data.TFRecordDataset(input_files)\n      # Since we evaluate for a fixed number of steps we don\'t want to encounter\n      # out-of-range exceptions.\n      d = d.repeat()\n\n    # We must `drop_remainder` on training because the TPU requires fixed\n    # size dimensions. For eval, we assume we are evaluating on the CPU or GPU\n    # and we *don\'t* want to drop the remainder, otherwise we wont cover\n    # every sample.\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_cpu_threads,\n            drop_remainder=True))\n    return d\n\n  return input_fn\n\n\ndef _decode_record(record, name_to_features):\n  """"""Decodes a record to a TensorFlow example.""""""\n  example = tf.parse_single_example(record, name_to_features)\n\n  # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n  # So cast all int64 to int32.\n  for name in list(example.keys()):\n    t = example[name]\n    if t.dtype == tf.int64:\n      t = tf.to_int32(t)\n    example[name] = t\n\n  return example\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Input Files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"" % input_file)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=FLAGS.num_train_steps,\n      num_warmup_steps=FLAGS.num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size)\n\n  if FLAGS.do_train:\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    train_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=True)\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.num_train_steps)\n\n  if FLAGS.do_eval:\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    eval_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=False)\n\n    result = estimator.evaluate(\n        input_fn=eval_input_fn, steps=FLAGS.max_eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_ext/run_squad.py,93,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run BERT on SQuAD 1.1 and SQuAD 2.0.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport math\nimport os\nimport random\nimport modeling\nimport optimization\nimport tokenization\nimport six\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(""train_file"", None,\n                    ""SQuAD json for training. E.g., train-v1.1.json"")\n\nflags.DEFINE_string(\n    ""predict_file"", None,\n    ""SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json"")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 384,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_integer(\n    ""doc_stride"", 128,\n    ""When splitting up a long document into chunks, how much stride to ""\n    ""take between chunks."")\n\nflags.DEFINE_integer(\n    ""max_query_length"", 64,\n    ""The maximum number of tokens for the question. Questions longer than ""\n    ""this will be truncated to this length."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8,\n                     ""Total batch size for predictions."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(\n    ""n_best_size"", 20,\n    ""The total number of n-best predictions to generate in the ""\n    ""nbest_predictions.json output file."")\n\nflags.DEFINE_integer(\n    ""max_answer_length"", 30,\n    ""The maximum length of an answer that can be generated. This is needed ""\n    ""because the start and end predictions are not conditioned on one another."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""verbose_logging"", False,\n    ""If true, all of the warnings related to data processing will be printed. ""\n    ""A number of warnings are expected for a normal SQuAD evaluation."")\n\nflags.DEFINE_bool(\n    ""version_2_with_negative"", False,\n    ""If true, the SQuAD examples contain some that do not have an answer."")\n\nflags.DEFINE_float(\n    ""null_score_diff_threshold"", 0.0,\n    ""If null_score - best_non_null is greater than the threshold predict null."")\n\n\nclass SquadExample(object):\n  """"""A single training/test example for simple sequence classification.\n\n     For examples without an answer, the start and end position are -1.\n  """"""\n\n  def __init__(self,\n               qas_id,\n               question_text,\n               doc_tokens,\n               orig_answer_text=None,\n               start_position=None,\n               end_position=None,\n               is_impossible=False):\n    self.qas_id = qas_id\n    self.question_text = question_text\n    self.doc_tokens = doc_tokens\n    self.orig_answer_text = orig_answer_text\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n  def __str__(self):\n    return self.__repr__()\n\n  def __repr__(self):\n    s = """"\n    s += ""qas_id: %s"" % (tokenization.printable_text(self.qas_id))\n    s += "", question_text: %s"" % (\n        tokenization.printable_text(self.question_text))\n    s += "", doc_tokens: [%s]"" % ("" "".join(self.doc_tokens))\n    if self.start_position:\n      s += "", start_position: %d"" % (self.start_position)\n    if self.start_position:\n      s += "", end_position: %d"" % (self.end_position)\n    if self.start_position:\n      s += "", is_impossible: %r"" % (self.is_impossible)\n    return s\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tokens,\n               token_to_orig_map,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               segment_ids,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tokens = tokens\n    self.token_to_orig_map = token_to_orig_map\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\ndef read_squad_examples(input_file, is_training):\n  """"""Read a SQuAD json file into a list of SquadExample.""""""\n  with tf.gfile.Open(input_file, ""r"") as reader:\n    input_data = json.load(reader)[""data""]\n\n  def is_whitespace(c):\n    if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F:\n      return True\n    return False\n\n  examples = []\n  for entry in input_data:\n    for paragraph in entry[""paragraphs""]:\n      paragraph_text = paragraph[""context""]\n      doc_tokens = []\n      char_to_word_offset = []\n      prev_is_whitespace = True\n      for c in paragraph_text:\n        if is_whitespace(c):\n          prev_is_whitespace = True\n        else:\n          if prev_is_whitespace:\n            doc_tokens.append(c)\n          else:\n            doc_tokens[-1] += c\n          prev_is_whitespace = False\n        char_to_word_offset.append(len(doc_tokens) - 1)\n\n      for qa in paragraph[""qas""]:\n        qas_id = qa[""id""]\n        question_text = qa[""question""]\n        start_position = None\n        end_position = None\n        orig_answer_text = None\n        is_impossible = False\n        if is_training:\n\n          if FLAGS.version_2_with_negative:\n            is_impossible = qa[""is_impossible""]\n          if (len(qa[""answers""]) != 1) and (not is_impossible):\n            raise ValueError(\n                ""For training, each question should have exactly 1 answer."")\n          if not is_impossible:\n            answer = qa[""answers""][0]\n            orig_answer_text = answer[""text""]\n            answer_offset = answer[""answer_start""]\n            answer_length = len(orig_answer_text)\n            start_position = char_to_word_offset[answer_offset]\n            end_position = char_to_word_offset[answer_offset + answer_length -\n                                               1]\n            # Only add answers where the text can be exactly recovered from the\n            # document. If this CAN\'T happen it\'s likely due to weird Unicode\n            # stuff so we will just skip the example.\n            #\n            # Note that this means for training mode, every example is NOT\n            # guaranteed to be preserved.\n            actual_text = "" "".join(\n                doc_tokens[start_position:(end_position + 1)])\n            cleaned_answer_text = "" "".join(\n                tokenization.whitespace_tokenize(orig_answer_text))\n            if actual_text.find(cleaned_answer_text) == -1:\n              tf.logging.warning(""Could not find answer: \'%s\' vs. \'%s\'"",\n                                 actual_text, cleaned_answer_text)\n              continue\n          else:\n            start_position = -1\n            end_position = -1\n            orig_answer_text = """"\n\n        example = SquadExample(\n            qas_id=qas_id,\n            question_text=question_text,\n            doc_tokens=doc_tokens,\n            orig_answer_text=orig_answer_text,\n            start_position=start_position,\n            end_position=end_position,\n            is_impossible=is_impossible)\n        examples.append(example)\n\n  return examples\n\n\ndef convert_examples_to_features(examples, tokenizer, max_seq_length,\n                                 doc_stride, max_query_length, is_training,\n                                 output_fn):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  unique_id = 1000000000\n\n  for (example_index, example) in enumerate(examples):\n    query_tokens = tokenizer.tokenize(example.question_text)\n\n    if len(query_tokens) > max_query_length:\n      query_tokens = query_tokens[0:max_query_length]\n\n    tok_to_orig_index = []\n    orig_to_tok_index = []\n    all_doc_tokens = []\n    for (i, token) in enumerate(example.doc_tokens):\n      orig_to_tok_index.append(len(all_doc_tokens))\n      sub_tokens = tokenizer.tokenize(token)\n      for sub_token in sub_tokens:\n        tok_to_orig_index.append(i)\n        all_doc_tokens.append(sub_token)\n\n    tok_start_position = None\n    tok_end_position = None\n    if is_training and example.is_impossible:\n      tok_start_position = -1\n      tok_end_position = -1\n    if is_training and not example.is_impossible:\n      tok_start_position = orig_to_tok_index[example.start_position]\n      if example.end_position < len(example.doc_tokens) - 1:\n        tok_end_position = orig_to_tok_index[example.end_position + 1] - 1\n      else:\n        tok_end_position = len(all_doc_tokens) - 1\n      (tok_start_position, tok_end_position) = _improve_answer_span(\n          all_doc_tokens, tok_start_position, tok_end_position, tokenizer,\n          example.orig_answer_text)\n\n    # The -3 accounts for [CLS], [SEP] and [SEP]\n    max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n    # We can have documents that are longer than the maximum sequence length.\n    # To deal with this we do a sliding window approach, where we take chunks\n    # of the up to our max length with a stride of `doc_stride`.\n    _DocSpan = collections.namedtuple(  # pylint: disable=invalid-name\n        ""DocSpan"", [""start"", ""length""])\n    doc_spans = []\n    start_offset = 0\n    while start_offset < len(all_doc_tokens):\n      length = len(all_doc_tokens) - start_offset\n      if length > max_tokens_for_doc:\n        length = max_tokens_for_doc\n      doc_spans.append(_DocSpan(start=start_offset, length=length))\n      if start_offset + length == len(all_doc_tokens):\n        break\n      start_offset += min(length, doc_stride)\n\n    for (doc_span_index, doc_span) in enumerate(doc_spans):\n      tokens = []\n      token_to_orig_map = {}\n      token_is_max_context = {}\n      segment_ids = []\n      tokens.append(""[CLS]"")\n      segment_ids.append(0)\n      for token in query_tokens:\n        tokens.append(token)\n        segment_ids.append(0)\n      tokens.append(""[SEP]"")\n      segment_ids.append(0)\n\n      for i in range(doc_span.length):\n        split_token_index = doc_span.start + i\n        token_to_orig_map[len(tokens)] = tok_to_orig_index[split_token_index]\n\n        is_max_context = _check_is_max_context(doc_spans, doc_span_index,\n                                               split_token_index)\n        token_is_max_context[len(tokens)] = is_max_context\n        tokens.append(all_doc_tokens[split_token_index])\n        segment_ids.append(1)\n      tokens.append(""[SEP]"")\n      segment_ids.append(1)\n\n      input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n      # The mask has 1 for real tokens and 0 for padding tokens. Only real\n      # tokens are attended to.\n      input_mask = [1] * len(input_ids)\n\n      # Zero-pad up to the sequence length.\n      while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n\n      assert len(input_ids) == max_seq_length\n      assert len(input_mask) == max_seq_length\n      assert len(segment_ids) == max_seq_length\n\n      start_position = None\n      end_position = None\n      if is_training and not example.is_impossible:\n        # For training, if our document chunk does not contain an annotation\n        # we throw it out, since there is nothing to predict.\n        doc_start = doc_span.start\n        doc_end = doc_span.start + doc_span.length - 1\n        out_of_span = False\n        if not (tok_start_position >= doc_start and\n                tok_end_position <= doc_end):\n          out_of_span = True\n        if out_of_span:\n          start_position = 0\n          end_position = 0\n        else:\n          doc_offset = len(query_tokens) + 2\n          start_position = tok_start_position - doc_start + doc_offset\n          end_position = tok_end_position - doc_start + doc_offset\n\n      if is_training and example.is_impossible:\n        start_position = 0\n        end_position = 0\n\n      if example_index < 20:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""unique_id: %s"" % (unique_id))\n        tf.logging.info(""example_index: %s"" % (example_index))\n        tf.logging.info(""doc_span_index: %s"" % (doc_span_index))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""token_to_orig_map: %s"" % "" "".join(\n            [""%d:%d"" % (x, y) for (x, y) in six.iteritems(token_to_orig_map)]))\n        tf.logging.info(""token_is_max_context: %s"" % "" "".join([\n            ""%d:%s"" % (x, y) for (x, y) in six.iteritems(token_is_max_context)\n        ]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(\n            ""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(\n            ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        if is_training and example.is_impossible:\n          tf.logging.info(""impossible example"")\n        if is_training and not example.is_impossible:\n          answer_text = "" "".join(tokens[start_position:(end_position + 1)])\n          tf.logging.info(""start_position: %d"" % (start_position))\n          tf.logging.info(""end_position: %d"" % (end_position))\n          tf.logging.info(\n              ""answer: %s"" % (tokenization.printable_text(answer_text)))\n\n      feature = InputFeatures(\n          unique_id=unique_id,\n          example_index=example_index,\n          doc_span_index=doc_span_index,\n          tokens=tokens,\n          token_to_orig_map=token_to_orig_map,\n          token_is_max_context=token_is_max_context,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          segment_ids=segment_ids,\n          start_position=start_position,\n          end_position=end_position,\n          is_impossible=example.is_impossible)\n\n      # Run callback\n      output_fn(feature)\n\n      unique_id += 1\n\n\ndef _improve_answer_span(doc_tokens, input_start, input_end, tokenizer,\n                         orig_answer_text):\n  """"""Returns tokenized answer spans that better match the annotated answer.""""""\n\n  # The SQuAD annotations are character based. We first project them to\n  # whitespace-tokenized words. But then after WordPiece tokenization, we can\n  # often find a ""better match"". For example:\n  #\n  #   Question: What year was John Smith born?\n  #   Context: The leader was John Smith (1895-1943).\n  #   Answer: 1895\n  #\n  # The original whitespace-tokenized answer will be ""(1895-1943)."". However\n  # after tokenization, our tokens will be ""( 1895 - 1943 ) ."". So we can match\n  # the exact answer, 1895.\n  #\n  # However, this is not always possible. Consider the following:\n  #\n  #   Question: What country is the top exporter of electornics?\n  #   Context: The Japanese electronics industry is the lagest in the world.\n  #   Answer: Japan\n  #\n  # In this case, the annotator chose ""Japan"" as a character sub-span of\n  # the word ""Japanese"". Since our WordPiece tokenizer does not split\n  # ""Japanese"", we just use ""Japanese"" as the annotation. This is fairly rare\n  # in SQuAD, but does happen.\n  tok_answer_text = "" "".join(tokenizer.tokenize(orig_answer_text))\n\n  for new_start in range(input_start, input_end + 1):\n    for new_end in range(input_end, new_start - 1, -1):\n      text_span = "" "".join(doc_tokens[new_start:(new_end + 1)])\n      if text_span == tok_answer_text:\n        return (new_start, new_end)\n\n  return (input_start, input_end)\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n  """"""Check if this is the \'max context\' doc span for the token.""""""\n\n  # Because of the sliding window approach taken to scoring documents, a single\n  # token can appear in multiple documents. E.g.\n  #  Doc: the man went to the store and bought a gallon of milk\n  #  Span A: the man went to the\n  #  Span B: to the store and bought\n  #  Span C: and bought a gallon of\n  #  ...\n  #\n  # Now the word \'bought\' will have two scores from spans B and C. We only\n  # want to consider the score with ""maximum context"", which we define as\n  # the *minimum* of its left and right context (the *sum* of left and\n  # right context will always be the same, of course).\n  #\n  # In the example the maximum context for \'bought\' would be span C since\n  # it has 1 left context and 3 right context, while span B has 4 left context\n  # and 0 right context.\n  best_score = None\n  best_span_index = None\n  for (span_index, doc_span) in enumerate(doc_spans):\n    end = doc_span.start + doc_span.length - 1\n    if position < doc_span.start:\n      continue\n    if position > end:\n      continue\n    num_left_context = position - doc_span.start\n    num_right_context = end - position\n    score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n    if best_score is None or score > best_score:\n      best_score = score\n      best_span_index = span_index\n\n  return cur_span_index == best_span_index\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  final_hidden = model.get_sequence_output()\n\n  final_hidden_shape = modeling.get_shape_list(final_hidden, expected_rank=3)\n  batch_size = final_hidden_shape[0]\n  seq_length = final_hidden_shape[1]\n  hidden_size = final_hidden_shape[2]\n\n  output_weights = tf.get_variable(\n      ""cls/squad/output_weights"", [2, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""cls/squad/output_bias"", [2], initializer=tf.zeros_initializer())\n\n  final_hidden_matrix = tf.reshape(final_hidden,\n                                   [batch_size * seq_length, hidden_size])\n  logits = tf.matmul(final_hidden_matrix, output_weights, transpose_b=True)\n  logits = tf.nn.bias_add(logits, output_bias)\n\n  logits = tf.reshape(logits, [batch_size, seq_length, 2])\n  logits = tf.transpose(logits, [2, 0, 1])\n\n  unstacked_logits = tf.unstack(logits, axis=0)\n\n  (start_logits, end_logits) = (unstacked_logits[0], unstacked_logits[1])\n\n  return (start_logits, end_logits)\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (start_logits, end_logits) = create_model(\n        bert_config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      seq_length = modeling.get_shape_list(input_ids)[1]\n\n      def compute_loss(logits, positions):\n        one_hot_positions = tf.one_hot(\n            positions, depth=seq_length, dtype=tf.float32)\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        loss = -tf.reduce_mean(\n            tf.reduce_sum(one_hot_positions * log_probs, axis=-1))\n        return loss\n\n      start_positions = features[""start_positions""]\n      end_positions = features[""end_positions""]\n\n      start_loss = compute_loss(start_logits, start_positions)\n      end_loss = compute_loss(end_logits, end_positions)\n\n      total_loss = (start_loss + end_loss) / 2.0\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      predictions = {\n          ""unique_ids"": unique_ids,\n          ""start_logits"": start_logits,\n          ""end_logits"": end_logits,\n      }\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(\n          ""Only TRAIN and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""unique_ids"": tf.FixedLenFeature([], tf.int64),\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n  }\n\n  if is_training:\n    name_to_features[""start_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""end_positions""] = tf.FixedLenFeature([], tf.int64)\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\nRawResult = collections.namedtuple(""RawResult"",\n                                   [""unique_id"", ""start_logits"", ""end_logits""])\n\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file):\n  """"""Write final predictions to the json file and log-odds of null if needed.""""""\n  tf.logging.info(""Writing predictions to: %s"" % (output_prediction_file))\n  tf.logging.info(""Writing nbest to: %s"" % (output_nbest_file))\n\n  example_index_to_features = collections.defaultdict(list)\n  for feature in all_features:\n    example_index_to_features[feature.example_index].append(feature)\n\n  unique_id_to_result = {}\n  for result in all_results:\n    unique_id_to_result[result.unique_id] = result\n\n  _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n      ""PrelimPrediction"",\n      [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n  all_predictions = collections.OrderedDict()\n  all_nbest_json = collections.OrderedDict()\n  scores_diff_json = collections.OrderedDict()\n\n  for (example_index, example) in enumerate(all_examples):\n    features = example_index_to_features[example_index]\n\n    prelim_predictions = []\n    # keep track of the minimum score of null start+end of position 0\n    score_null = 1000000  # large and positive\n    min_null_feature_index = 0  # the paragraph slice with min mull score\n    null_start_logit = 0  # the start logit at the slice with min null score\n    null_end_logit = 0  # the end logit at the slice with min null score\n    for (feature_index, feature) in enumerate(features):\n      result = unique_id_to_result[feature.unique_id]\n      start_indexes = _get_best_indexes(result.start_logits, n_best_size)\n      end_indexes = _get_best_indexes(result.end_logits, n_best_size)\n      # if we could have irrelevant answers, get the min score of irrelevant\n      if FLAGS.version_2_with_negative:\n        feature_null_score = result.start_logits[0] + result.end_logits[0]\n        if feature_null_score < score_null:\n          score_null = feature_null_score\n          min_null_feature_index = feature_index\n          null_start_logit = result.start_logits[0]\n          null_end_logit = result.end_logits[0]\n      for start_index in start_indexes:\n        for end_index in end_indexes:\n          # We could hypothetically create invalid predictions, e.g., predict\n          # that the start of the span is in the question. We throw out all\n          # invalid predictions.\n          if start_index >= len(feature.tokens):\n            continue\n          if end_index >= len(feature.tokens):\n            continue\n          if start_index not in feature.token_to_orig_map:\n            continue\n          if end_index not in feature.token_to_orig_map:\n            continue\n          if not feature.token_is_max_context.get(start_index, False):\n            continue\n          if end_index < start_index:\n            continue\n          length = end_index - start_index + 1\n          if length > max_answer_length:\n            continue\n          prelim_predictions.append(\n              _PrelimPrediction(\n                  feature_index=feature_index,\n                  start_index=start_index,\n                  end_index=end_index,\n                  start_logit=result.start_logits[start_index],\n                  end_logit=result.end_logits[end_index]))\n\n    if FLAGS.version_2_with_negative:\n      prelim_predictions.append(\n          _PrelimPrediction(\n              feature_index=min_null_feature_index,\n              start_index=0,\n              end_index=0,\n              start_logit=null_start_logit,\n              end_logit=null_end_logit))\n    prelim_predictions = sorted(\n        prelim_predictions,\n        key=lambda x: (x.start_logit + x.end_logit),\n        reverse=True)\n\n    _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n    seen_predictions = {}\n    nbest = []\n    for pred in prelim_predictions:\n      if len(nbest) >= n_best_size:\n        break\n      feature = features[pred.feature_index]\n      if pred.start_index > 0:  # this is a non-null prediction\n        tok_tokens = feature.tokens[pred.start_index:(pred.end_index + 1)]\n        orig_doc_start = feature.token_to_orig_map[pred.start_index]\n        orig_doc_end = feature.token_to_orig_map[pred.end_index]\n        orig_tokens = example.doc_tokens[orig_doc_start:(orig_doc_end + 1)]\n        tok_text = "" "".join(tok_tokens)\n\n        # De-tokenize WordPieces that have been split off.\n        tok_text = tok_text.replace("" ##"", """")\n        tok_text = tok_text.replace(""##"", """")\n\n        # Clean whitespace\n        tok_text = tok_text.strip()\n        tok_text = "" "".join(tok_text.split())\n        orig_text = "" "".join(orig_tokens)\n\n        final_text = get_final_text(tok_text, orig_text, do_lower_case)\n        if final_text in seen_predictions:\n          continue\n\n        seen_predictions[final_text] = True\n      else:\n        final_text = """"\n        seen_predictions[final_text] = True\n\n      nbest.append(\n          _NbestPrediction(\n              text=final_text,\n              start_logit=pred.start_logit,\n              end_logit=pred.end_logit))\n\n    # if we didn\'t inlude the empty option in the n-best, inlcude it\n    if FLAGS.version_2_with_negative:\n      if """" not in seen_predictions:\n        nbest.append(\n            _NbestPrediction(\n                text="""", start_logit=null_start_logit,\n                end_logit=null_end_logit))\n    # In very rare edge cases we could have no valid predictions. So we\n    # just create a nonce prediction in this case to avoid failure.\n    if not nbest:\n      nbest.append(\n          _NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n    assert len(nbest) >= 1\n\n    total_scores = []\n    best_non_null_entry = None\n    for entry in nbest:\n      total_scores.append(entry.start_logit + entry.end_logit)\n      if not best_non_null_entry:\n        if entry.text:\n          best_non_null_entry = entry\n\n    probs = _compute_softmax(total_scores)\n\n    nbest_json = []\n    for (i, entry) in enumerate(nbest):\n      output = collections.OrderedDict()\n      output[""text""] = entry.text\n      output[""probability""] = probs[i]\n      output[""start_logit""] = entry.start_logit\n      output[""end_logit""] = entry.end_logit\n      nbest_json.append(output)\n\n    assert len(nbest_json) >= 1\n\n    if not FLAGS.version_2_with_negative:\n      all_predictions[example.qas_id] = nbest_json[0][""text""]\n    else:\n      # predict """" iff the null score - the score of best non-null > threshold\n      score_diff = score_null - best_non_null_entry.start_logit - (\n          best_non_null_entry.end_logit)\n      scores_diff_json[example.qas_id] = score_diff\n      if score_diff > FLAGS.null_score_diff_threshold:\n        all_predictions[example.qas_id] = """"\n      else:\n        all_predictions[example.qas_id] = best_non_null_entry.text\n\n    all_nbest_json[example.qas_id] = nbest_json\n\n  with tf.gfile.GFile(output_prediction_file, ""w"") as writer:\n    writer.write(json.dumps(all_predictions, indent=4) + ""\\n"")\n\n  with tf.gfile.GFile(output_nbest_file, ""w"") as writer:\n    writer.write(json.dumps(all_nbest_json, indent=4) + ""\\n"")\n\n  if FLAGS.version_2_with_negative:\n    with tf.gfile.GFile(output_null_log_odds_file, ""w"") as writer:\n      writer.write(json.dumps(scores_diff_json, indent=4) + ""\\n"")\n\n\ndef get_final_text(pred_text, orig_text, do_lower_case):\n  """"""Project the tokenized prediction back to the original text.""""""\n\n  # When we created the data, we kept track of the alignment between original\n  # (whitespace tokenized) tokens and our WordPiece tokenized tokens. So\n  # now `orig_text` contains the span of our original text corresponding to the\n  # span that we predicted.\n  #\n  # However, `orig_text` may contain extra characters that we don\'t want in\n  # our prediction.\n  #\n  # For example, let\'s say:\n  #   pred_text = steve smith\n  #   orig_text = Steve Smith\'s\n  #\n  # We don\'t want to return `orig_text` because it contains the extra ""\'s"".\n  #\n  # We don\'t want to return `pred_text` because it\'s already been normalized\n  # (the SQuAD eval script also does punctuation stripping/lower casing but\n  # our tokenizer does additional normalization like stripping accent\n  # characters).\n  #\n  # What we really want to return is ""Steve Smith"".\n  #\n  # Therefore, we have to apply a semi-complicated alignment heruistic between\n  # `pred_text` and `orig_text` to get a character-to-charcter alignment. This\n  # can fail in certain cases in which case we just return `orig_text`.\n\n  def _strip_spaces(text):\n    ns_chars = []\n    ns_to_s_map = collections.OrderedDict()\n    for (i, c) in enumerate(text):\n      if c == "" "":\n        continue\n      ns_to_s_map[len(ns_chars)] = i\n      ns_chars.append(c)\n    ns_text = """".join(ns_chars)\n    return (ns_text, ns_to_s_map)\n\n  # We first tokenize `orig_text`, strip whitespace from the result\n  # and `pred_text`, and check if they are the same length. If they are\n  # NOT the same length, the heuristic has failed. If they are the same\n  # length, we assume the characters are one-to-one aligned.\n  tokenizer = tokenization.BasicTokenizer(do_lower_case=do_lower_case)\n\n  tok_text = "" "".join(tokenizer.tokenize(orig_text))\n\n  start_position = tok_text.find(pred_text)\n  if start_position == -1:\n    if FLAGS.verbose_logging:\n      tf.logging.info(\n          ""Unable to find text: \'%s\' in \'%s\'"" % (pred_text, orig_text))\n    return orig_text\n  end_position = start_position + len(pred_text) - 1\n\n  (orig_ns_text, orig_ns_to_s_map) = _strip_spaces(orig_text)\n  (tok_ns_text, tok_ns_to_s_map) = _strip_spaces(tok_text)\n\n  if len(orig_ns_text) != len(tok_ns_text):\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Length not equal after stripping spaces: \'%s\' vs \'%s\'"",\n                      orig_ns_text, tok_ns_text)\n    return orig_text\n\n  # We then project the characters in `pred_text` back to `orig_text` using\n  # the character-to-character alignment.\n  tok_s_to_ns_map = {}\n  for (i, tok_index) in six.iteritems(tok_ns_to_s_map):\n    tok_s_to_ns_map[tok_index] = i\n\n  orig_start_position = None\n  if start_position in tok_s_to_ns_map:\n    ns_start_position = tok_s_to_ns_map[start_position]\n    if ns_start_position in orig_ns_to_s_map:\n      orig_start_position = orig_ns_to_s_map[ns_start_position]\n\n  if orig_start_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map start position"")\n    return orig_text\n\n  orig_end_position = None\n  if end_position in tok_s_to_ns_map:\n    ns_end_position = tok_s_to_ns_map[end_position]\n    if ns_end_position in orig_ns_to_s_map:\n      orig_end_position = orig_ns_to_s_map[ns_end_position]\n\n  if orig_end_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map end position"")\n    return orig_text\n\n  output_text = orig_text[orig_start_position:(orig_end_position + 1)]\n  return output_text\n\n\ndef _get_best_indexes(logits, n_best_size):\n  """"""Get the n-best logits from a list.""""""\n  index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\n\ndef _compute_softmax(scores):\n  """"""Compute softmax probability over raw logits.""""""\n  if not scores:\n    return []\n\n  max_score = None\n  for score in scores:\n    if max_score is None or score > max_score:\n      max_score = score\n\n  exp_scores = []\n  total_sum = 0.0\n  for score in scores:\n    x = math.exp(score - max_score)\n    exp_scores.append(x)\n    total_sum += x\n\n  probs = []\n  for score in exp_scores:\n    probs.append(score / total_sum)\n  return probs\n\n\nclass FeatureWriter(object):\n  """"""Writes InputFeature to TF example file.""""""\n\n  def __init__(self, filename, is_training):\n    self.filename = filename\n    self.is_training = is_training\n    self.num_features = 0\n    self._writer = tf.python_io.TFRecordWriter(filename)\n\n  def process_feature(self, feature):\n    """"""Write a InputFeature to the TFRecordWriter as a tf.train.Example.""""""\n    self.num_features += 1\n\n    def create_int_feature(values):\n      feature = tf.train.Feature(\n          int64_list=tf.train.Int64List(value=list(values)))\n      return feature\n\n    features = collections.OrderedDict()\n    features[""unique_ids""] = create_int_feature([feature.unique_id])\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n\n    if self.is_training:\n      features[""start_positions""] = create_int_feature([feature.start_position])\n      features[""end_positions""] = create_int_feature([feature.end_position])\n      impossible = 0\n      if feature.is_impossible:\n        impossible = 1\n      features[""is_impossible""] = create_int_feature([impossible])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    self._writer.write(tf_example.SerializeToString())\n\n  def close(self):\n    self._writer.close()\n\n\ndef validate_flags_or_throw(bert_config):\n  """"""Validate the input FLAGS or throw an exception.""""""\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_predict:\n    raise ValueError(""At least one of `do_train` or `do_predict` must be True."")\n\n  if FLAGS.do_train:\n    if not FLAGS.train_file:\n      raise ValueError(\n          ""If `do_train` is True, then `train_file` must be specified."")\n  if FLAGS.do_predict:\n    if not FLAGS.predict_file:\n      raise ValueError(\n          ""If `do_predict` is True, then `predict_file` must be specified."")\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  if FLAGS.max_seq_length <= FLAGS.max_query_length + 3:\n    raise ValueError(\n        ""The max_seq_length (%d) must be greater than max_query_length ""\n        ""(%d) + 3"" % (FLAGS.max_seq_length, FLAGS.max_query_length))\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  validate_flags_or_throw(bert_config)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = read_squad_examples(\n        input_file=FLAGS.train_file, is_training=True)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    # Pre-shuffle the input to avoid having to make a very large shuffle\n    # buffer in in the `input_fn`.\n    rng = random.Random(12345)\n    rng.shuffle(train_examples)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    # We write to a temporary file to avoid storing very large constant tensors\n    # in memory.\n    train_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""train.tf_record""),\n        is_training=True)\n    convert_examples_to_features(\n        examples=train_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=True,\n        output_fn=train_writer.process_feature)\n    train_writer.close()\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(train_examples))\n    tf.logging.info(""  Num split examples = %d"", train_writer.num_features)\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    del train_examples\n\n    train_input_fn = input_fn_builder(\n        input_file=train_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_predict:\n    eval_examples = read_squad_examples(\n        input_file=FLAGS.predict_file, is_training=False)\n\n    eval_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""eval.tf_record""),\n        is_training=False)\n    eval_features = []\n\n    def append_feature(feature):\n      eval_features.append(feature)\n      eval_writer.process_feature(feature)\n\n    convert_examples_to_features(\n        examples=eval_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=False,\n        output_fn=append_feature)\n    eval_writer.close()\n\n    tf.logging.info(""***** Running predictions *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(eval_examples))\n    tf.logging.info(""  Num split examples = %d"", len(eval_features))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    all_results = []\n\n    predict_input_fn = input_fn_builder(\n        input_file=eval_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=False)\n\n    # If running eval on the TPU, you will need to specify the number of\n    # steps.\n    all_results = []\n    for result in estimator.predict(\n        predict_input_fn, yield_single_examples=True):\n      if len(all_results) % 1000 == 0:\n        tf.logging.info(""Processing example: %d"" % (len(all_results)))\n      unique_id = int(result[""unique_ids""])\n      start_logits = [float(x) for x in result[""start_logits""].flat]\n      end_logits = [float(x) for x in result[""end_logits""].flat]\n      all_results.append(\n          RawResult(\n              unique_id=unique_id,\n              start_logits=start_logits,\n              end_logits=end_logits))\n\n    output_prediction_file = os.path.join(FLAGS.output_dir, ""predictions.json"")\n    output_nbest_file = os.path.join(FLAGS.output_dir, ""nbest_predictions.json"")\n    output_null_log_odds_file = os.path.join(FLAGS.output_dir, ""null_odds.json"")\n\n    write_predictions(eval_examples, eval_features, all_results,\n                      FLAGS.n_best_size, FLAGS.max_answer_length,\n                      FLAGS.do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_ext/tf_metrics.py,22,"b'""""""\r\nMulticlass\r\nfrom: \r\nhttps://github.com/guillaumegenthial/tf_metrics/blob/master/tf_metrics/__init__.py\r\n\r\n""""""\r\n\r\n__author__ = ""Guillaume Genthial""\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops.metrics_impl import _streaming_confusion_matrix\r\n\r\n\r\ndef precision(labels, predictions, num_classes, pos_indices=None,\r\n              weights=None, average=\'micro\'):\r\n    """"""Multi-class precision metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    pr, _, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    op, _, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (pr, op)\r\n\r\n\r\ndef recall(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n           average=\'micro\'):\r\n    """"""Multi-class recall metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, re, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    _, op, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (re, op)\r\n\r\n\r\ndef f1(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n       average=\'micro\'):\r\n    return fbeta(labels, predictions, num_classes, pos_indices, weights,\r\n                 average)\r\n\r\n\r\ndef fbeta(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n          average=\'micro\', beta=1):\r\n    """"""Multi-class fbeta metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, _, fbeta = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average, beta=beta)\r\n    _, _, op = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average, beta=beta)\r\n    return (fbeta, op)\r\n\r\n\r\ndef safe_div(numerator, denominator):\r\n    """"""Safe division, return 0 if denominator is 0""""""\r\n    numerator, denominator = tf.to_float(numerator), tf.to_float(denominator)\r\n    zeros = tf.zeros_like(numerator, dtype=numerator.dtype)\r\n    denominator_is_zero = tf.equal(denominator, zeros)\r\n    return tf.where(denominator_is_zero, zeros, numerator / denominator)\r\n\r\n\r\ndef pr_re_fbeta(cm, pos_indices, beta=1):\r\n    """"""Uses a confusion matrix to compute precision, recall and fbeta""""""\r\n    num_classes = cm.shape[0]\r\n    neg_indices = [i for i in range(num_classes) if i not in pos_indices]\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, neg_indices] = 0\r\n    diag_sum = tf.reduce_sum(tf.diag_part(cm * cm_mask))\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[:, neg_indices] = 0\r\n    tot_pred = tf.reduce_sum(cm * cm_mask)\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, :] = 0\r\n    tot_gold = tf.reduce_sum(cm * cm_mask)\r\n\r\n    pr = safe_div(diag_sum, tot_pred)\r\n    re = safe_div(diag_sum, tot_gold)\r\n    fbeta = safe_div((1. + beta**2) * pr * re, beta**2 * pr + re)\r\n\r\n    return pr, re, fbeta\r\n\r\n\r\ndef metrics_from_confusion_matrix(cm, pos_indices=None, average=\'micro\',\r\n                                  beta=1):\r\n    """"""Precision, Recall and F1 from the confusion matrix\r\n    Parameters\r\n    ----------\r\n    cm : tf.Tensor of type tf.int32, of shape (num_classes, num_classes)\r\n        The streaming confusion matrix.\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    average : str, optional\r\n        \'micro\', \'macro\' or \'weighted\'\r\n    """"""\r\n    num_classes = cm.shape[0]\r\n    if pos_indices is None:\r\n        pos_indices = [i for i in range(num_classes)]\r\n\r\n    if average == \'micro\':\r\n        return pr_re_fbeta(cm, pos_indices, beta)\r\n    elif average in {\'macro\', \'weighted\'}:\r\n        precisions, recalls, fbetas, n_golds = [], [], [], []\r\n        for idx in pos_indices:\r\n            pr, re, fbeta = pr_re_fbeta(cm, [idx], beta)\r\n            precisions.append(pr)\r\n            recalls.append(re)\r\n            fbetas.append(fbeta)\r\n            cm_mask = np.zeros([num_classes, num_classes])\r\n            cm_mask[idx, :] = 1\r\n            n_golds.append(tf.to_float(tf.reduce_sum(cm * cm_mask)))\r\n\r\n        if average == \'macro\':\r\n            pr = tf.reduce_mean(precisions)\r\n            re = tf.reduce_mean(recalls)\r\n            fbeta = tf.reduce_mean(fbetas)\r\n            return pr, re, fbeta\r\n        if average == \'weighted\':\r\n            n_gold = tf.reduce_sum(n_golds)\r\n            pr_sum = sum(p * n for p, n in zip(precisions, n_golds))\r\n            pr = safe_div(pr_sum, n_gold)\r\n            re_sum = sum(r * n for r, n in zip(recalls, n_golds))\r\n            re = safe_div(re_sum, n_gold)\r\n            fbeta_sum = sum(f * n for f, n in zip(fbetas, n_golds))\r\n            fbeta = safe_div(fbeta_sum, n_gold)\r\n            return pr, re, fbeta\r\n\r\n    else:\r\n        raise NotImplementedError()'"
baselines/models/roberta_wwm_ext/tokenization.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\nimport unicodedata\nimport six\nimport tensorflow as tf\n\n\ndef validate_case_matches_checkpoint(do_lower_case, init_checkpoint):\n  """"""Checks whether the casing config is consistent with the checkpoint name.""""""\n\n  # The casing has to be passed in by the user and there is no explicit check\n  # as to whether it matches the checkpoint. The casing information probably\n  # should have been stored in the bert_config.json file, but it\'s not, so\n  # we have to heuristically detect it to validate.\n\n  if not init_checkpoint:\n    return\n\n  m = re.match(""^.*?([A-Za-z0-9_-]+)/bert_model.ckpt"", init_checkpoint)\n  if m is None:\n    return\n\n  model_name = m.group(1)\n\n  lower_models = [\n      ""uncased_L-24_H-1024_A-16"", ""uncased_L-12_H-768_A-12"",\n      ""multilingual_L-12_H-768_A-12"", ""chinese_L-12_H-768_A-12""\n  ]\n\n  cased_models = [\n      ""cased_L-12_H-768_A-12"", ""cased_L-24_H-1024_A-16"",\n      ""multi_cased_L-12_H-768_A-12""\n  ]\n\n  is_bad_config = False\n  if model_name in lower_models and not do_lower_case:\n    is_bad_config = True\n    actual_flag = ""False""\n    case_name = ""lowercased""\n    opposite_flag = ""True""\n\n  if model_name in cased_models and do_lower_case:\n    is_bad_config = True\n    actual_flag = ""True""\n    case_name = ""cased""\n    opposite_flag = ""False""\n\n  if is_bad_config:\n    raise ValueError(\n        ""You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. ""\n        ""However, `%s` seems to be a %s model, so you ""\n        ""should pass in `--do_lower_case=%s` so that the fine-tuning matches ""\n        ""how the model was pre-training. If this error is wrong, please ""\n        ""just comment out this check."" % (actual_flag, init_checkpoint,\n                                          model_name, case_name, opposite_flag))\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  index = 0\n  with tf.gfile.GFile(vocab_file, ""r"") as reader:\n    while True:\n      token = convert_to_unicode(reader.readline())\n      if not token:\n        break\n      token = token.strip()\n      vocab[token] = index\n      index += 1\n  return vocab\n\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  for item in items:\n    output.append(vocab[item])\n  return output\n\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True):\n    self.vocab = load_vocab(vocab_file)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n  def tokenize(self, text):\n    split_tokens = []\n    for token in self.basic_tokenizer.tokenize(text):\n      for sub_token in self.wordpiece_tokenizer.tokenize(token):\n        split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    return convert_by_vocab(self.inv_vocab, ids)\n\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = convert_to_unicode(text)\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n  """"""Runs WordPiece tokenziation.""""""\n\n  def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=200):\n    self.vocab = vocab\n    self.unk_token = unk_token\n    self.max_input_chars_per_word = max_input_chars_per_word\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text into its word pieces.\n\n    This uses a greedy longest-match-first algorithm to perform tokenization\n    using the given vocabulary.\n\n    For example:\n      input = ""unaffable""\n      output = [""un"", ""##aff"", ""##able""]\n\n    Args:\n      text: A single token or whitespace separated tokens. This should have\n        already been passed through `BasicTokenizer.\n\n    Returns:\n      A list of wordpiece tokens.\n    """"""\n\n    text = convert_to_unicode(text)\n\n    output_tokens = []\n    for token in whitespace_tokenize(text):\n      chars = list(token)\n      if len(chars) > self.max_input_chars_per_word:\n        output_tokens.append(self.unk_token)\n        continue\n\n      is_bad = False\n      start = 0\n      sub_tokens = []\n      while start < len(chars):\n        end = len(chars)\n        cur_substr = None\n        while start < end:\n          substr = """".join(chars[start:end])\n          if start > 0:\n            substr = ""##"" + substr\n          if substr in self.vocab:\n            cur_substr = substr\n            break\n          end -= 1\n        if cur_substr is None:\n          is_bad = True\n          break\n        sub_tokens.append(cur_substr)\n        start = end\n\n      if is_bad:\n        output_tokens.append(self.unk_token)\n      else:\n        output_tokens.extend(sub_tokens)\n    return output_tokens\n\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically contorl characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
baselines/models/roberta_wwm_ext/tokenization_test.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tempfile\nimport tokenization\nimport six\nimport tensorflow as tf\n\n\nclass TokenizationTest(tf.test.TestCase):\n\n  def test_full_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing"", "",""\n    ]\n    with tempfile.NamedTemporaryFile(delete=False) as vocab_writer:\n      if six.PY2:\n        vocab_writer.write("""".join([x + ""\\n"" for x in vocab_tokens]))\n      else:\n        vocab_writer.write("""".join(\n            [x + ""\\n"" for x in vocab_tokens]).encode(""utf-8""))\n\n      vocab_file = vocab_writer.name\n\n    tokenizer = tokenization.FullTokenizer(vocab_file)\n    os.unlink(vocab_file)\n\n    tokens = tokenizer.tokenize(u""UNwant\\u00E9d,running"")\n    self.assertAllEqual(tokens, [""un"", ""##want"", ""##ed"", "","", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.convert_tokens_to_ids(tokens), [7, 4, 5, 10, 8, 9])\n\n  def test_chinese(self):\n    tokenizer = tokenization.BasicTokenizer()\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u""ah\\u535A\\u63A8zz""),\n        [u""ah"", u""\\u535A"", u""\\u63A8"", u""zz""])\n\n  def test_basic_tokenizer_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=True)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""hello"", ""!"", ""how"", ""are"", ""you"", ""?""])\n    self.assertAllEqual(tokenizer.tokenize(u""H\\u00E9llo""), [""hello""])\n\n  def test_basic_tokenizer_no_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=False)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""HeLLo"", ""!"", ""how"", ""Are"", ""yoU"", ""?""])\n\n  def test_wordpiece_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n    tokenizer = tokenization.WordpieceTokenizer(vocab=vocab)\n\n    self.assertAllEqual(tokenizer.tokenize(""""), [])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwanted running""),\n        [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwantedX running""), [""[UNK]"", ""runn"", ""##ing""])\n\n  def test_convert_tokens_to_ids(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n\n    self.assertAllEqual(\n        tokenization.convert_tokens_to_ids(\n            vocab, [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""]), [7, 4, 5, 8, 9])\n\n  def test_is_whitespace(self):\n    self.assertTrue(tokenization._is_whitespace(u"" ""))\n    self.assertTrue(tokenization._is_whitespace(u""\\t""))\n    self.assertTrue(tokenization._is_whitespace(u""\\r""))\n    self.assertTrue(tokenization._is_whitespace(u""\\n""))\n    self.assertTrue(tokenization._is_whitespace(u""\\u00A0""))\n\n    self.assertFalse(tokenization._is_whitespace(u""A""))\n    self.assertFalse(tokenization._is_whitespace(u""-""))\n\n  def test_is_control(self):\n    self.assertTrue(tokenization._is_control(u""\\u0005""))\n\n    self.assertFalse(tokenization._is_control(u""A""))\n    self.assertFalse(tokenization._is_control(u"" ""))\n    self.assertFalse(tokenization._is_control(u""\\t""))\n    self.assertFalse(tokenization._is_control(u""\\r""))\n    self.assertFalse(tokenization._is_control(u""\\U0001F4A9""))\n\n  def test_is_punctuation(self):\n    self.assertTrue(tokenization._is_punctuation(u""-""))\n    self.assertTrue(tokenization._is_punctuation(u""$""))\n    self.assertTrue(tokenization._is_punctuation(u""`""))\n    self.assertTrue(tokenization._is_punctuation(u"".""))\n\n    self.assertFalse(tokenization._is_punctuation(u""A""))\n    self.assertFalse(tokenization._is_punctuation(u"" ""))\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/roberta_wwm_large_ext/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n'"
baselines/models/roberta_wwm_large_ext/conlleval.py,0,"b'# Python version of the evaluation script from CoNLL\'00-\n# Originates from: https://github.com/spyysalo/conlleval.py\n\n\n# Intentional differences:\n# - accept any space as delimiter by default\n# - optional file argument (default STDIN)\n# - option to set boundary (-b argument)\n# - LaTeX output (-l argument) not supported\n# - raw tags (-r argument) not supported\n\n# add function :evaluate(predicted_label, ori_label): which will not read from file\n\nimport sys\nimport re\nimport codecs\nfrom collections import defaultdict, namedtuple\n\nANY_SPACE = \'<SPACE>\'\n\n\nclass FormatError(Exception):\n    pass\n\nMetrics = namedtuple(\'Metrics\', \'tp fp fn prec rec fscore\')\n\n\nclass EvalCounts(object):\n    def __init__(self):\n        self.correct_chunk = 0    # number of correctly identified chunks\n        self.correct_tags = 0     # number of correct chunk tags\n        self.found_correct = 0    # number of chunks in corpus\n        self.found_guessed = 0    # number of identified chunks\n        self.token_counter = 0    # token counter (ignores sentence breaks)\n\n        # counts by type\n        self.t_correct_chunk = defaultdict(int)\n        self.t_found_correct = defaultdict(int)\n        self.t_found_guessed = defaultdict(int)\n\n\ndef parse_args(argv):\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=\'evaluate tagging results using CoNLL criteria\',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    arg = parser.add_argument\n    arg(\'-b\', \'--boundary\', metavar=\'STR\', default=\'-X-\',\n        help=\'sentence boundary\')\n    arg(\'-d\', \'--delimiter\', metavar=\'CHAR\', default=ANY_SPACE,\n        help=\'character delimiting items in input\')\n    arg(\'-o\', \'--otag\', metavar=\'CHAR\', default=\'O\',\n        help=\'alternative outside tag\')\n    arg(\'file\', nargs=\'?\', default=None)\n    return parser.parse_args(argv)\n\n\ndef parse_tag(t):\n    m = re.match(r\'^([^-]*)-(.*)$\', t)\n    return m.groups() if m else (t, \'\')\n\n\ndef evaluate(iterable, options=None):\n    if options is None:\n        options = parse_args([])    # use defaults\n\n    counts = EvalCounts()\n    num_features = None       # number of features per line\n    in_correct = False        # currently processed chunks is correct until now\n    last_correct = \'O\'        # previous chunk tag in corpus\n    last_correct_type = \'\'    # type of previously identified chunk tag\n    last_guessed = \'O\'        # previously identified chunk tag\n    last_guessed_type = \'\'    # type of previous chunk tag in corpus\n\n    for line in iterable:\n        line = line.rstrip(\'\\r\\n\')\n\n        if options.delimiter == ANY_SPACE:\n            features = line.split()\n        else:\n            features = line.split(options.delimiter)\n\n        if num_features is None:\n            num_features = len(features)\n        elif num_features != len(features) and len(features) != 0:\n            raise FormatError(\'unexpected number of features: %d (%d)\' %\n                              (len(features), num_features))\n\n        if len(features) == 0 or features[0] == options.boundary:\n            features = [options.boundary, \'O\', \'O\']\n        if len(features) < 3:\n            raise FormatError(\'unexpected number of features in line %s\' % line)\n\n        guessed, guessed_type = parse_tag(features.pop())\n        correct, correct_type = parse_tag(features.pop())\n        first_item = features.pop(0)\n\n        if first_item == options.boundary:\n            guessed = \'O\'\n\n        end_correct = end_of_chunk(last_correct, correct,\n                                   last_correct_type, correct_type)\n        end_guessed = end_of_chunk(last_guessed, guessed,\n                                   last_guessed_type, guessed_type)\n        start_correct = start_of_chunk(last_correct, correct,\n                                       last_correct_type, correct_type)\n        start_guessed = start_of_chunk(last_guessed, guessed,\n                                       last_guessed_type, guessed_type)\n\n        if in_correct:\n            if (end_correct and end_guessed and\n                last_guessed_type == last_correct_type):\n                in_correct = False\n                counts.correct_chunk += 1\n                counts.t_correct_chunk[last_correct_type] += 1\n            elif (end_correct != end_guessed or guessed_type != correct_type):\n                in_correct = False\n\n        if start_correct and start_guessed and guessed_type == correct_type:\n            in_correct = True\n\n        if start_correct:\n            counts.found_correct += 1\n            counts.t_found_correct[correct_type] += 1\n        if start_guessed:\n            counts.found_guessed += 1\n            counts.t_found_guessed[guessed_type] += 1\n        if first_item != options.boundary:\n            if correct == guessed and guessed_type == correct_type:\n                counts.correct_tags += 1\n            counts.token_counter += 1\n\n        last_guessed = guessed\n        last_correct = correct\n        last_guessed_type = guessed_type\n        last_correct_type = correct_type\n\n    if in_correct:\n        counts.correct_chunk += 1\n        counts.t_correct_chunk[last_correct_type] += 1\n\n    return counts\n\n\n\ndef uniq(iterable):\n  seen = set()\n  return [i for i in iterable if not (i in seen or seen.add(i))]\n\n\ndef calculate_metrics(correct, guessed, total):\n    tp, fp, fn = correct, guessed-correct, total-correct\n    p = 0 if tp + fp == 0 else 1.*tp / (tp + fp)\n    r = 0 if tp + fn == 0 else 1.*tp / (tp + fn)\n    f = 0 if p + r == 0 else 2 * p * r / (p + r)\n    return Metrics(tp, fp, fn, p, r, f)\n\n\ndef metrics(counts):\n    c = counts\n    overall = calculate_metrics(\n        c.correct_chunk, c.found_guessed, c.found_correct\n    )\n    by_type = {}\n    for t in uniq(list(c.t_found_correct) + list(c.t_found_guessed)):\n        by_type[t] = calculate_metrics(\n            c.t_correct_chunk[t], c.t_found_guessed[t], c.t_found_correct[t]\n        )\n    return overall, by_type\n\n\ndef report(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    out.write(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    out.write(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n\n    if c.token_counter > 0:\n        out.write(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        out.write(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        out.write(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n\n    for i, m in sorted(by_type.items()):\n        out.write(\'%17s: \' % i)\n        out.write(\'precision: %6.2f%%; \' % (100.*m.prec))\n        out.write(\'recall: %6.2f%%; \' % (100.*m.rec))\n        out.write(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n\n\ndef report_notprint(counts, out=None):\n    if out is None:\n        out = sys.stdout\n\n    overall, by_type = metrics(counts)\n\n    c = counts\n    final_report = []\n    line = []\n    line.append(\'processed %d tokens with %d phrases; \' %\n              (c.token_counter, c.found_correct))\n    line.append(\'found: %d phrases; correct: %d.\\n\' %\n              (c.found_guessed, c.correct_chunk))\n    final_report.append("""".join(line))\n\n    if c.token_counter > 0:\n        line = []\n        line.append(\'accuracy: %6.2f%%; \' %\n                  (100.*c.correct_tags/c.token_counter))\n        line.append(\'precision: %6.2f%%; \' % (100.*overall.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*overall.rec))\n        line.append(\'FB1: %6.2f\\n\' % (100.*overall.fscore))\n        final_report.append("""".join(line))\n\n    for i, m in sorted(by_type.items()):\n        line = []\n        line.append(\'%17s: \' % i)\n        line.append(\'precision: %6.2f%%; \' % (100.*m.prec))\n        line.append(\'recall: %6.2f%%; \' % (100.*m.rec))\n        line.append(\'FB1: %6.2f  %d\\n\' % (100.*m.fscore, c.t_found_guessed[i]))\n        final_report.append("""".join(line))\n    return final_report\n\n\ndef end_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk ended between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_end = False\n\n    if prev_tag == \'E\': chunk_end = True\n    if prev_tag == \'S\': chunk_end = True\n\n    if prev_tag == \'B\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'B\' and tag == \'O\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'B\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'S\': chunk_end = True\n    if prev_tag == \'I\' and tag == \'O\': chunk_end = True\n\n    if prev_tag != \'O\' and prev_tag != \'.\' and prev_type != type_:\n        chunk_end = True\n\n    # these chunks are assumed to have length 1\n    if prev_tag == \']\': chunk_end = True\n    if prev_tag == \'[\': chunk_end = True\n\n    return chunk_end\n\n\ndef start_of_chunk(prev_tag, tag, prev_type, type_):\n    # check if a chunk started between the previous and current word\n    # arguments: previous and current chunk tags, previous and current types\n    chunk_start = False\n\n    if tag == \'B\': chunk_start = True\n    if tag == \'S\': chunk_start = True\n\n    if prev_tag == \'E\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'E\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'S\' and tag == \'I\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'E\': chunk_start = True\n    if prev_tag == \'O\' and tag == \'I\': chunk_start = True\n\n    if tag != \'O\' and tag != \'.\' and prev_type != type_:\n        chunk_start = True\n\n    # these chunks are assumed to have length 1\n    if tag == \'[\': chunk_start = True\n    if tag == \']\': chunk_start = True\n\n    return chunk_start\n\n\ndef return_report(input_file):\n    with codecs.open(input_file, ""r"", ""utf8"") as f:\n        counts = evaluate(f)\n    return report_notprint(counts)\n\n\ndef main(argv):\n    args = parse_args(argv[1:])\n\n    if args.file is None:\n        counts = evaluate(sys.stdin, args)\n    else:\n        with open(args.file) as f:\n            counts = evaluate(f, args)\n    report(counts)\n\nif __name__ == \'__main__\':\n    sys.exit(main(sys.argv))'"
baselines/models/roberta_wwm_large_ext/create_pretraining_data.py,17,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\n\nclass TrainingInstance(object):\n  """"""A single training instance (sentence pair).""""""\n\n  def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n               is_random_next):\n    self.tokens = tokens\n    self.segment_ids = segment_ids\n    self.is_random_next = is_random_next\n    self.masked_lm_positions = masked_lm_positions\n    self.masked_lm_labels = masked_lm_labels\n\n  def __str__(self):\n    s = """"\n    s += ""tokens: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.tokens]))\n    s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n    s += ""is_random_next: %s\\n"" % self.is_random_next\n    s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n        [str(x) for x in self.masked_lm_positions]))\n    s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n        [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n    s += ""\\n""\n    return s\n\n  def __repr__(self):\n    return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n  """"""Create TF example files from `TrainingInstance`s.""""""\n  writers = []\n  for output_file in output_files:\n    writers.append(tf.python_io.TFRecordWriter(output_file))\n\n  writer_index = 0\n\n  total_written = 0\n  for (inst_index, instance) in enumerate(instances):\n    input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n    input_mask = [1] * len(input_ids)\n    segment_ids = list(instance.segment_ids)\n    assert len(input_ids) <= max_seq_length\n\n    while len(input_ids) < max_seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      segment_ids.append(0)\n\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n\n    masked_lm_positions = list(instance.masked_lm_positions)\n    masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n    masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n    while len(masked_lm_positions) < max_predictions_per_seq:\n      masked_lm_positions.append(0)\n      masked_lm_ids.append(0)\n      masked_lm_weights.append(0.0)\n\n    next_sentence_label = 1 if instance.is_random_next else 0\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(input_ids)\n    features[""input_mask""] = create_int_feature(input_mask)\n    features[""segment_ids""] = create_int_feature(segment_ids)\n    features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n    features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n    features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n    features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n    writers[writer_index].write(tf_example.SerializeToString())\n    writer_index = (writer_index + 1) % len(writers)\n\n    total_written += 1\n\n    if inst_index < 20:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in instance.tokens]))\n\n      for feature_name in features.keys():\n        feature = features[feature_name]\n        values = []\n        if feature.int64_list.value:\n          values = feature.int64_list.value\n        elif feature.float_list.value:\n          values = feature.float_list.value\n        tf.logging.info(\n            ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n  for writer in writers:\n    writer.close()\n\n  tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n  feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n  return feature\n\n\ndef create_float_feature(values):\n  feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n  return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n  """"""Create `TrainingInstance`s from raw text.""""""\n  all_documents = [[]]\n\n  # Input file format:\n  # (1) One sentence per line. These should ideally be actual sentences, not\n  # entire paragraphs or arbitrary spans of text. (Because we use the\n  # sentence boundaries for the ""next sentence prediction"" task).\n  # (2) Blank lines between documents. Document boundaries are needed so\n  # that the ""next sentence prediction"" task doesn\'t span between documents.\n  for input_file in input_files:\n    with tf.gfile.GFile(input_file, ""r"") as reader:\n      while True:\n        line = tokenization.convert_to_unicode(reader.readline())\n        if not line:\n          break\n        line = line.strip()\n\n        # Empty lines are used as document delimiters\n        if not line:\n          all_documents.append([])\n        tokens = tokenizer.tokenize(line)\n        if tokens:\n          all_documents[-1].append(tokens)\n\n  # Remove empty documents\n  all_documents = [x for x in all_documents if x]\n  rng.shuffle(all_documents)\n\n  vocab_words = list(tokenizer.vocab.keys())\n  instances = []\n  for _ in range(dupe_factor):\n    for document_index in range(len(all_documents)):\n      instances.extend(\n          create_instances_from_document(\n              all_documents, document_index, max_seq_length, short_seq_prob,\n              masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n  rng.shuffle(instances)\n  return instances\n\n\ndef create_instances_from_document(\n    all_documents, document_index, max_seq_length, short_seq_prob,\n    masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n  """"""Creates `TrainingInstance`s for a single document.""""""\n  document = all_documents[document_index]\n\n  # Account for [CLS], [SEP], [SEP]\n  max_num_tokens = max_seq_length - 3\n\n  # We *usually* want to fill up the entire sequence since we are padding\n  # to `max_seq_length` anyways, so short sequences are generally wasted\n  # computation. However, we *sometimes*\n  # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n  # sequences to minimize the mismatch between pre-training and fine-tuning.\n  # The `target_seq_length` is just a rough target however, whereas\n  # `max_seq_length` is a hard limit.\n  target_seq_length = max_num_tokens\n  if rng.random() < short_seq_prob:\n    target_seq_length = rng.randint(2, max_num_tokens)\n\n  # We DON\'T just concatenate all of the tokens from a document into a long\n  # sequence and choose an arbitrary split point because this would make the\n  # next sentence prediction task too easy. Instead, we split the input into\n  # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n  # input.\n  instances = []\n  current_chunk = []\n  current_length = 0\n  i = 0\n  while i < len(document):\n    segment = document[i]\n    current_chunk.append(segment)\n    current_length += len(segment)\n    if i == len(document) - 1 or current_length >= target_seq_length:\n      if current_chunk:\n        # `a_end` is how many segments from `current_chunk` go into the `A`\n        # (first) sentence.\n        a_end = 1\n        if len(current_chunk) >= 2:\n          a_end = rng.randint(1, len(current_chunk) - 1)\n\n        tokens_a = []\n        for j in range(a_end):\n          tokens_a.extend(current_chunk[j])\n\n        tokens_b = []\n        # Random next\n        is_random_next = False\n        if len(current_chunk) == 1 or rng.random() < 0.5:\n          is_random_next = True\n          target_b_length = target_seq_length - len(tokens_a)\n\n          # This should rarely go for more than one iteration for large\n          # corpora. However, just to be careful, we try to make sure that\n          # the random document is not the same as the document\n          # we\'re processing.\n          for _ in range(10):\n            random_document_index = rng.randint(0, len(all_documents) - 1)\n            if random_document_index != document_index:\n              break\n\n          random_document = all_documents[random_document_index]\n          random_start = rng.randint(0, len(random_document) - 1)\n          for j in range(random_start, len(random_document)):\n            tokens_b.extend(random_document[j])\n            if len(tokens_b) >= target_b_length:\n              break\n          # We didn\'t actually use these segments so we ""put them back"" so\n          # they don\'t go to waste.\n          num_unused_segments = len(current_chunk) - a_end\n          i -= num_unused_segments\n        # Actual next\n        else:\n          is_random_next = False\n          for j in range(a_end, len(current_chunk)):\n            tokens_b.extend(current_chunk[j])\n        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n        assert len(tokens_a) >= 1\n        assert len(tokens_b) >= 1\n\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n          tokens.append(token)\n          segment_ids.append(0)\n\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        for token in tokens_b:\n          tokens.append(token)\n          segment_ids.append(1)\n        tokens.append(""[SEP]"")\n        segment_ids.append(1)\n\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance(\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n      current_chunk = []\n      current_length = 0\n    i += 1\n\n  return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n  """"""Creates the predictions for the masked LM objective.""""""\n\n  cand_indexes = []\n  for (i, token) in enumerate(tokens):\n    if token == ""[CLS]"" or token == ""[SEP]"":\n      continue\n    # Whole Word Masking means that if we mask all of the wordpieces\n    # corresponding to an original word. When a word has been split into\n    # WordPieces, the first token does not have any marker and any subsequence\n    # tokens are prefixed with ##. So whenever we see the ## token, we\n    # append it to the previous set of word indexes.\n    #\n    # Note that Whole Word Masking does *not* change the training code\n    # at all -- we still predict each WordPiece independently, softmaxed\n    # over the entire vocabulary.\n    if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n        token.startswith(""##"")):\n      cand_indexes[-1].append(i)\n    else:\n      cand_indexes.append([i])\n\n  rng.shuffle(cand_indexes)\n\n  output_tokens = list(tokens)\n\n  num_to_predict = min(max_predictions_per_seq,\n                       max(1, int(round(len(tokens) * masked_lm_prob))))\n\n  masked_lms = []\n  covered_indexes = set()\n  for index_set in cand_indexes:\n    if len(masked_lms) >= num_to_predict:\n      break\n    # If adding a whole-word mask would exceed the maximum number of\n    # predictions, then just skip this candidate.\n    if len(masked_lms) + len(index_set) > num_to_predict:\n      continue\n    is_any_index_covered = False\n    for index in index_set:\n      if index in covered_indexes:\n        is_any_index_covered = True\n        break\n    if is_any_index_covered:\n      continue\n    for index in index_set:\n      covered_indexes.add(index)\n\n      masked_token = None\n      # 80% of the time, replace with [MASK]\n      if rng.random() < 0.8:\n        masked_token = ""[MASK]""\n      else:\n        # 10% of the time, keep original\n        if rng.random() < 0.5:\n          masked_token = tokens[index]\n        # 10% of the time, replace with random word\n        else:\n          masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n      output_tokens[index] = masked_token\n\n      masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n  assert len(masked_lms) <= num_to_predict\n  masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n  masked_lm_positions = []\n  masked_lm_labels = []\n  for p in masked_lms:\n    masked_lm_positions.append(p.index)\n    masked_lm_labels.append(p.label)\n\n  return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n  """"""Truncates a pair of sequences to a maximum sequence length.""""""\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_num_tokens:\n      break\n\n    trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n    assert len(trunc_tokens) >= 1\n\n    # We want to sometimes truncate from the front and sometimes from the\n    # back to add more randomness and avoid biases.\n    if rng.random() < 0.5:\n      del trunc_tokens[0]\n    else:\n      trunc_tokens.pop()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Reading from input files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"", input_file)\n\n  rng = random.Random(FLAGS.random_seed)\n  instances = create_training_instances(\n      input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n      FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n      rng)\n\n  output_files = FLAGS.output_file.split("","")\n  tf.logging.info(""*** Writing to output files ***"")\n  for output_file in output_files:\n    tf.logging.info(""  %s"", output_file)\n\n  write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                  FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""output_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_large_ext/extract_features.py,34,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Extract pre-computed feature vectors from BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport codecs\nimport collections\nimport json\nimport re\n\nimport modeling\nimport tokenization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None, """")\n\nflags.DEFINE_string(""output_file"", None, """")\n\nflags.DEFINE_string(""layers"", ""-1,-2,-3,-4"", """")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(""batch_size"", 32, ""Batch size for predictions."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_string(""master"", None,\n                    ""If using a TPU, the address of the master."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""use_one_hot_embeddings"", False,\n    ""If True, tf.one_hot will be used for embedding lookups, otherwise ""\n    ""tf.nn.embedding_lookup will be used. On TPUs, this should be True ""\n    ""since it is much faster."")\n\n\nclass InputExample(object):\n\n  def __init__(self, unique_id, text_a, text_b):\n    self.unique_id = unique_id\n    self.text_a = text_a\n    self.text_b = text_b\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self, unique_id, tokens, input_ids, input_mask, input_type_ids):\n    self.unique_id = unique_id\n    self.tokens = tokens\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.input_type_ids = input_type_ids\n\n\ndef input_fn_builder(features, seq_length):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_unique_ids = []\n  all_input_ids = []\n  all_input_mask = []\n  all_input_type_ids = []\n\n  for feature in features:\n    all_unique_ids.append(feature.unique_id)\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_input_type_ids.append(feature.input_type_ids)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""unique_ids"":\n            tf.constant(all_unique_ids, shape=[num_examples], dtype=tf.int32),\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_type_ids"":\n            tf.constant(\n                all_input_type_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n    })\n\n    d = d.batch(batch_size=batch_size, drop_remainder=False)\n    return d\n\n  return input_fn\n\n\ndef model_fn_builder(bert_config, init_checkpoint, layer_indexes, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    input_type_ids = features[""input_type_ids""]\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=False,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=input_type_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    if mode != tf.estimator.ModeKeys.PREDICT:\n      raise ValueError(""Only PREDICT modes are supported: %s"" % (mode))\n\n    tvars = tf.trainable_variables()\n    scaffold_fn = None\n    (assignment_map,\n     initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(\n         tvars, init_checkpoint)\n    if use_tpu:\n\n      def tpu_scaffold():\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        return tf.train.Scaffold()\n\n      scaffold_fn = tpu_scaffold\n    else:\n      tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    all_layers = model.get_all_encoder_layers()\n\n    predictions = {\n        ""unique_id"": unique_ids,\n    }\n\n    for (i, layer_index) in enumerate(layer_indexes):\n      predictions[""layer_output_%d"" % i] = all_layers[layer_index]\n\n    output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n        mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\ndef convert_examples_to_features(examples, seq_length, tokenizer):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    tokens_a = tokenizer.tokenize(example.text_a)\n\n    tokens_b = None\n    if example.text_b:\n      tokens_b = tokenizer.tokenize(example.text_b)\n\n    if tokens_b:\n      # Modifies `tokens_a` and `tokens_b` in place so that the total\n      # length is less than the specified length.\n      # Account for [CLS], [SEP], [SEP] with ""- 3""\n      _truncate_seq_pair(tokens_a, tokens_b, seq_length - 3)\n    else:\n      # Account for [CLS] and [SEP] with ""- 2""\n      if len(tokens_a) > seq_length - 2:\n        tokens_a = tokens_a[0:(seq_length - 2)]\n\n    # The convention in BERT is:\n    # (a) For sequence pairs:\n    #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n    #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n    # (b) For single sequences:\n    #  tokens:   [CLS] the dog is hairy . [SEP]\n    #  type_ids: 0     0   0   0  0     0 0\n    #\n    # Where ""type_ids"" are used to indicate whether this is the first\n    # sequence or the second sequence. The embedding vectors for `type=0` and\n    # `type=1` were learned during pre-training and are added to the wordpiece\n    # embedding vector (and position vector). This is not *strictly* necessary\n    # since the [SEP] token unambiguously separates the sequences, but it makes\n    # it easier for the model to learn the concept of sequences.\n    #\n    # For classification tasks, the first vector (corresponding to [CLS]) is\n    # used as as the ""sentence vector"". Note that this only makes sense because\n    # the entire model is fine-tuned.\n    tokens = []\n    input_type_ids = []\n    tokens.append(""[CLS]"")\n    input_type_ids.append(0)\n    for token in tokens_a:\n      tokens.append(token)\n      input_type_ids.append(0)\n    tokens.append(""[SEP]"")\n    input_type_ids.append(0)\n\n    if tokens_b:\n      for token in tokens_b:\n        tokens.append(token)\n        input_type_ids.append(1)\n      tokens.append(""[SEP]"")\n      input_type_ids.append(1)\n\n    input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n    # The mask has 1 for real tokens and 0 for padding tokens. Only real\n    # tokens are attended to.\n    input_mask = [1] * len(input_ids)\n\n    # Zero-pad up to the sequence length.\n    while len(input_ids) < seq_length:\n      input_ids.append(0)\n      input_mask.append(0)\n      input_type_ids.append(0)\n\n    assert len(input_ids) == seq_length\n    assert len(input_mask) == seq_length\n    assert len(input_type_ids) == seq_length\n\n    if ex_index < 5:\n      tf.logging.info(""*** Example ***"")\n      tf.logging.info(""unique_id: %s"" % (example.unique_id))\n      tf.logging.info(""tokens: %s"" % "" "".join(\n          [tokenization.printable_text(x) for x in tokens]))\n      tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n      tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n      tf.logging.info(\n          ""input_type_ids: %s"" % "" "".join([str(x) for x in input_type_ids]))\n\n    features.append(\n        InputFeatures(\n            unique_id=example.unique_id,\n            tokens=tokens,\n            input_ids=input_ids,\n            input_mask=input_mask,\n            input_type_ids=input_type_ids))\n  return features\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef read_examples(input_file):\n  """"""Read a list of `InputExample`s from an input file.""""""\n  examples = []\n  unique_id = 0\n  with tf.gfile.GFile(input_file, ""r"") as reader:\n    while True:\n      line = tokenization.convert_to_unicode(reader.readline())\n      if not line:\n        break\n      line = line.strip()\n      text_a = None\n      text_b = None\n      m = re.match(r""^(.*) \\|\\|\\| (.*)$"", line)\n      if m is None:\n        text_a = line\n      else:\n        text_a = m.group(1)\n        text_b = m.group(2)\n      examples.append(\n          InputExample(unique_id=unique_id, text_a=text_a, text_b=text_b))\n      unique_id += 1\n  return examples\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  layer_indexes = [int(x) for x in FLAGS.layers.split("","")]\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      master=FLAGS.master,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  examples = read_examples(FLAGS.input_file)\n\n  features = convert_examples_to_features(\n      examples=examples, seq_length=FLAGS.max_seq_length, tokenizer=tokenizer)\n\n  unique_id_to_feature = {}\n  for feature in features:\n    unique_id_to_feature[feature.unique_id] = feature\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      layer_indexes=layer_indexes,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_one_hot_embeddings)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      predict_batch_size=FLAGS.batch_size)\n\n  input_fn = input_fn_builder(\n      features=features, seq_length=FLAGS.max_seq_length)\n\n  with codecs.getwriter(""utf-8"")(tf.gfile.Open(FLAGS.output_file,\n                                               ""w"")) as writer:\n    for result in estimator.predict(input_fn, yield_single_examples=True):\n      unique_id = int(result[""unique_id""])\n      feature = unique_id_to_feature[unique_id]\n      output_json = collections.OrderedDict()\n      output_json[""linex_index""] = unique_id\n      all_features = []\n      for (i, token) in enumerate(feature.tokens):\n        all_layers = []\n        for (j, layer_index) in enumerate(layer_indexes):\n          layer_output = result[""layer_output_%d"" % j]\n          layers = collections.OrderedDict()\n          layers[""index""] = layer_index\n          layers[""values""] = [\n              round(float(x), 6) for x in layer_output[i:(i + 1)].flat\n          ]\n          all_layers.append(layers)\n        features = collections.OrderedDict()\n        features[""token""] = token\n        features[""layers""] = all_layers\n        all_features.append(features)\n      output_json[""features""] = all_features\n      writer.write(json.dumps(output_json) + ""\\n"")\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""init_checkpoint"")\n  flags.mark_flag_as_required(""output_file"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_large_ext/modeling.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The main BERT model and related functions.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport json\nimport math\nimport re\nimport numpy as np\nimport six\nimport tensorflow as tf\n\n\nclass BertConfig(object):\n  """"""Configuration for `BertModel`.""""""\n\n  def __init__(self,\n               vocab_size,\n               hidden_size=768,\n               num_hidden_layers=12,\n               num_attention_heads=12,\n               intermediate_size=3072,\n               hidden_act=""gelu"",\n               hidden_dropout_prob=0.1,\n               attention_probs_dropout_prob=0.1,\n               max_position_embeddings=512,\n               type_vocab_size=16,\n               initializer_range=0.02):\n    """"""Constructs BertConfig.\n\n    Args:\n      vocab_size: Vocabulary size of `inputs_ids` in `BertModel`.\n      hidden_size: Size of the encoder layers and the pooler layer.\n      num_hidden_layers: Number of hidden layers in the Transformer encoder.\n      num_attention_heads: Number of attention heads for each attention layer in\n        the Transformer encoder.\n      intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n        layer in the Transformer encoder.\n      hidden_act: The non-linear activation function (function or string) in the\n        encoder and pooler.\n      hidden_dropout_prob: The dropout probability for all fully connected\n        layers in the embeddings, encoder, and pooler.\n      attention_probs_dropout_prob: The dropout ratio for the attention\n        probabilities.\n      max_position_embeddings: The maximum sequence length that this model might\n        ever be used with. Typically set this to something large just in case\n        (e.g., 512 or 1024 or 2048).\n      type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n        `BertModel`.\n      initializer_range: The stdev of the truncated_normal_initializer for\n        initializing all weight matrices.\n    """"""\n    self.vocab_size = vocab_size\n    self.hidden_size = hidden_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.hidden_act = hidden_act\n    self.intermediate_size = intermediate_size\n    self.hidden_dropout_prob = hidden_dropout_prob\n    self.attention_probs_dropout_prob = attention_probs_dropout_prob\n    self.max_position_embeddings = max_position_embeddings\n    self.type_vocab_size = type_vocab_size\n    self.initializer_range = initializer_range\n\n  @classmethod\n  def from_dict(cls, json_object):\n    """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n    config = BertConfig(vocab_size=None)\n    for (key, value) in six.iteritems(json_object):\n      config.__dict__[key] = value\n    return config\n\n  @classmethod\n  def from_json_file(cls, json_file):\n    """"""Constructs a `BertConfig` from a json file of parameters.""""""\n    with tf.gfile.GFile(json_file, ""r"") as reader:\n      text = reader.read()\n    return cls.from_dict(json.loads(text))\n\n  def to_dict(self):\n    """"""Serializes this instance to a Python dictionary.""""""\n    output = copy.deepcopy(self.__dict__)\n    return output\n\n  def to_json_string(self):\n    """"""Serializes this instance to a JSON string.""""""\n    return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass BertModel(object):\n  """"""BERT model (""Bidirectional Encoder Representations from Transformers"").\n\n  Example usage:\n\n  ```python\n  # Already been converted into WordPiece token ids\n  input_ids = tf.constant([[31, 51, 99], [15, 5, 0]])\n  input_mask = tf.constant([[1, 1, 1], [1, 1, 0]])\n  token_type_ids = tf.constant([[0, 0, 1], [0, 2, 0]])\n\n  config = modeling.BertConfig(vocab_size=32000, hidden_size=512,\n    num_hidden_layers=8, num_attention_heads=6, intermediate_size=1024)\n\n  model = modeling.BertModel(config=config, is_training=True,\n    input_ids=input_ids, input_mask=input_mask, token_type_ids=token_type_ids)\n\n  label_embeddings = tf.get_variable(...)\n  pooled_output = model.get_pooled_output()\n  logits = tf.matmul(pooled_output, label_embeddings)\n  ...\n  ```\n  """"""\n\n  def __init__(self,\n               config,\n               is_training,\n               input_ids,\n               input_mask=None,\n               token_type_ids=None,\n               use_one_hot_embeddings=False,\n               scope=None):\n    """"""Constructor for BertModel.\n\n    Args:\n      config: `BertConfig` instance.\n      is_training: bool. true for training model, false for eval model. Controls\n        whether dropout will be applied.\n      input_ids: int32 Tensor of shape [batch_size, seq_length].\n      input_mask: (optional) int32 Tensor of shape [batch_size, seq_length].\n      token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      use_one_hot_embeddings: (optional) bool. Whether to use one-hot word\n        embeddings or tf.embedding_lookup() for the word embeddings.\n      scope: (optional) variable scope. Defaults to ""bert"".\n\n    Raises:\n      ValueError: The config is invalid or one of the input tensor shapes\n        is invalid.\n    """"""\n    config = copy.deepcopy(config)\n    if not is_training:\n      config.hidden_dropout_prob = 0.0\n      config.attention_probs_dropout_prob = 0.0\n\n    input_shape = get_shape_list(input_ids, expected_rank=2)\n    batch_size = input_shape[0]\n    seq_length = input_shape[1]\n\n    if input_mask is None:\n      input_mask = tf.ones(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    if token_type_ids is None:\n      token_type_ids = tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)\n\n    with tf.variable_scope(scope, default_name=""bert""):\n      with tf.variable_scope(""embeddings""):\n        # Perform embedding lookup on the word ids.\n        (self.embedding_output, self.embedding_table) = embedding_lookup(\n            input_ids=input_ids,\n            vocab_size=config.vocab_size,\n            embedding_size=config.hidden_size,\n            initializer_range=config.initializer_range,\n            word_embedding_name=""word_embeddings"",\n            use_one_hot_embeddings=use_one_hot_embeddings)\n\n        # Add positional embeddings and token type embeddings, then layer\n        # normalize and perform dropout.\n        self.embedding_output = embedding_postprocessor(\n            input_tensor=self.embedding_output,\n            use_token_type=True,\n            token_type_ids=token_type_ids,\n            token_type_vocab_size=config.type_vocab_size,\n            token_type_embedding_name=""token_type_embeddings"",\n            use_position_embeddings=True,\n            position_embedding_name=""position_embeddings"",\n            initializer_range=config.initializer_range,\n            max_position_embeddings=config.max_position_embeddings,\n            dropout_prob=config.hidden_dropout_prob)\n\n      with tf.variable_scope(""encoder""):\n        # This converts a 2D mask of shape [batch_size, seq_length] to a 3D\n        # mask of shape [batch_size, seq_length, seq_length] which is used\n        # for the attention scores.\n        attention_mask = create_attention_mask_from_input_mask(\n            input_ids, input_mask)\n\n        # Run the stacked transformer.\n        # `sequence_output` shape = [batch_size, seq_length, hidden_size].\n        self.all_encoder_layers = transformer_model(\n            input_tensor=self.embedding_output,\n            attention_mask=attention_mask,\n            hidden_size=config.hidden_size,\n            num_hidden_layers=config.num_hidden_layers,\n            num_attention_heads=config.num_attention_heads,\n            intermediate_size=config.intermediate_size,\n            intermediate_act_fn=get_activation(config.hidden_act),\n            hidden_dropout_prob=config.hidden_dropout_prob,\n            attention_probs_dropout_prob=config.attention_probs_dropout_prob,\n            initializer_range=config.initializer_range,\n            do_return_all_layers=True)\n\n      self.sequence_output = self.all_encoder_layers[-1]\n      # The ""pooler"" converts the encoded sequence tensor of shape\n      # [batch_size, seq_length, hidden_size] to a tensor of shape\n      # [batch_size, hidden_size]. This is necessary for segment-level\n      # (or segment-pair-level) classification tasks where we need a fixed\n      # dimensional representation of the segment.\n      with tf.variable_scope(""pooler""):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token. We assume that this has been pre-trained\n        first_token_tensor = tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)\n        self.pooled_output = tf.layers.dense(\n            first_token_tensor,\n            config.hidden_size,\n            activation=tf.tanh,\n            kernel_initializer=create_initializer(config.initializer_range))\n\n  def get_pooled_output(self):\n    return self.pooled_output\n\n  def get_sequence_output(self):\n    """"""Gets final hidden layer of encoder.\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the final hidden of the transformer encoder.\n    """"""\n    return self.sequence_output\n\n  def get_all_encoder_layers(self):\n    return self.all_encoder_layers\n\n  def get_embedding_output(self):\n    """"""Gets output of the embedding lookup (i.e., input to the transformer).\n\n    Returns:\n      float Tensor of shape [batch_size, seq_length, hidden_size] corresponding\n      to the output of the embedding layer, after summing the word\n      embeddings with the positional embeddings and the token type embeddings,\n      then performing layer normalization. This is the input to the transformer.\n    """"""\n    return self.embedding_output\n\n  def get_embedding_table(self):\n    return self.embedding_table\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef get_activation(activation_string):\n  """"""Maps a string to a Python function, e.g., ""relu"" => `tf.nn.relu`.\n\n  Args:\n    activation_string: String name of the activation function.\n\n  Returns:\n    A Python function corresponding to the activation function. If\n    `activation_string` is None, empty, or ""linear"", this will return None.\n    If `activation_string` is not a string, it will return `activation_string`.\n\n  Raises:\n    ValueError: The `activation_string` does not correspond to a known\n      activation.\n  """"""\n\n  # We assume that anything that""s not a string is already an activation\n  # function, so we just return it.\n  if not isinstance(activation_string, six.string_types):\n    return activation_string\n\n  if not activation_string:\n    return None\n\n  act = activation_string.lower()\n  if act == ""linear"":\n    return None\n  elif act == ""relu"":\n    return tf.nn.relu\n  elif act == ""gelu"":\n    return gelu\n  elif act == ""tanh"":\n    return tf.tanh\n  else:\n    raise ValueError(""Unsupported activation: %s"" % act)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    if name not in name_to_variable:\n      continue\n    assignment_map[name] = name\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\ndef dropout(input_tensor, dropout_prob):\n  """"""Perform dropout.\n\n  Args:\n    input_tensor: float Tensor.\n    dropout_prob: Python float. The probability of dropping out a value (NOT of\n      *keeping* a dimension as in `tf.nn.dropout`).\n\n  Returns:\n    A version of `input_tensor` with dropout applied.\n  """"""\n  if dropout_prob is None or dropout_prob == 0.0:\n    return input_tensor\n\n  output = tf.nn.dropout(input_tensor, 1.0 - dropout_prob)\n  return output\n\n\ndef layer_norm(input_tensor, name=None):\n  """"""Run layer normalization on the last dimension of the tensor.""""""\n  return tf.contrib.layers.layer_norm(\n      inputs=input_tensor, begin_norm_axis=-1, begin_params_axis=-1, scope=name)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n  """"""Runs layer normalization followed by dropout.""""""\n  output_tensor = layer_norm(input_tensor, name)\n  output_tensor = dropout(output_tensor, dropout_prob)\n  return output_tensor\n\n\ndef create_initializer(initializer_range=0.02):\n  """"""Creates a `truncated_normal_initializer` with the given range.""""""\n  return tf.truncated_normal_initializer(stddev=initializer_range)\n\n\ndef embedding_lookup(input_ids,\n                     vocab_size,\n                     embedding_size=128,\n                     initializer_range=0.02,\n                     word_embedding_name=""word_embeddings"",\n                     use_one_hot_embeddings=False):\n  """"""Looks up words embeddings for id tensor.\n\n  Args:\n    input_ids: int32 Tensor of shape [batch_size, seq_length] containing word\n      ids.\n    vocab_size: int. Size of the embedding vocabulary.\n    embedding_size: int. Width of the word embeddings.\n    initializer_range: float. Embedding initialization range.\n    word_embedding_name: string. Name of the embedding table.\n    use_one_hot_embeddings: bool. If True, use one-hot method for word\n      embeddings. If False, use `tf.gather()`.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, embedding_size].\n  """"""\n  # This function assumes that the input is of shape [batch_size, seq_length,\n  # num_inputs].\n  #\n  # If the input is a 2D tensor of shape [batch_size, seq_length], we\n  # reshape to [batch_size, seq_length, 1].\n  if input_ids.shape.ndims == 2:\n    input_ids = tf.expand_dims(input_ids, axis=[-1])\n\n  embedding_table = tf.get_variable(\n      name=word_embedding_name,\n      shape=[vocab_size, embedding_size],\n      initializer=create_initializer(initializer_range))\n\n  flat_input_ids = tf.reshape(input_ids, [-1])\n  if use_one_hot_embeddings:\n    one_hot_input_ids = tf.one_hot(flat_input_ids, depth=vocab_size)\n    output = tf.matmul(one_hot_input_ids, embedding_table)\n  else:\n    output = tf.gather(embedding_table, flat_input_ids)\n\n  input_shape = get_shape_list(input_ids)\n\n  output = tf.reshape(output,\n                      input_shape[0:-1] + [input_shape[-1] * embedding_size])\n  return (output, embedding_table)\n\n\ndef embedding_postprocessor(input_tensor,\n                            use_token_type=False,\n                            token_type_ids=None,\n                            token_type_vocab_size=16,\n                            token_type_embedding_name=""token_type_embeddings"",\n                            use_position_embeddings=True,\n                            position_embedding_name=""position_embeddings"",\n                            initializer_range=0.02,\n                            max_position_embeddings=512,\n                            dropout_prob=0.1):\n  """"""Performs various post-processing on a word embedding tensor.\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length,\n      embedding_size].\n    use_token_type: bool. Whether to add embeddings for `token_type_ids`.\n    token_type_ids: (optional) int32 Tensor of shape [batch_size, seq_length].\n      Must be specified if `use_token_type` is True.\n    token_type_vocab_size: int. The vocabulary size of `token_type_ids`.\n    token_type_embedding_name: string. The name of the embedding table variable\n      for token type ids.\n    use_position_embeddings: bool. Whether to add position embeddings for the\n      position of each token in the sequence.\n    position_embedding_name: string. The name of the embedding table variable\n      for positional embeddings.\n    initializer_range: float. Range of the weight initialization.\n    max_position_embeddings: int. Maximum sequence length that might ever be\n      used with this model. This can be longer than the sequence length of\n      input_tensor, but cannot be shorter.\n    dropout_prob: float. Dropout probability applied to the final output tensor.\n\n  Returns:\n    float tensor with same shape as `input_tensor`.\n\n  Raises:\n    ValueError: One of the tensor shapes or input values is invalid.\n  """"""\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  width = input_shape[2]\n\n  output = input_tensor\n\n  if use_token_type:\n    if token_type_ids is None:\n      raise ValueError(""`token_type_ids` must be specified if""\n                       ""`use_token_type` is True."")\n    token_type_table = tf.get_variable(\n        name=token_type_embedding_name,\n        shape=[token_type_vocab_size, width],\n        initializer=create_initializer(initializer_range))\n    # This vocab will be small so we always do one-hot here, since it is always\n    # faster for a small vocabulary.\n    flat_token_type_ids = tf.reshape(token_type_ids, [-1])\n    one_hot_ids = tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)\n    token_type_embeddings = tf.matmul(one_hot_ids, token_type_table)\n    token_type_embeddings = tf.reshape(token_type_embeddings,\n                                       [batch_size, seq_length, width])\n    output += token_type_embeddings\n\n  if use_position_embeddings:\n    assert_op = tf.assert_less_equal(seq_length, max_position_embeddings)\n    with tf.control_dependencies([assert_op]):\n      full_position_embeddings = tf.get_variable(\n          name=position_embedding_name,\n          shape=[max_position_embeddings, width],\n          initializer=create_initializer(initializer_range))\n      # Since the position embedding table is a learned variable, we create it\n      # using a (long) sequence length `max_position_embeddings`. The actual\n      # sequence length might be shorter than this, for faster training of\n      # tasks that do not have long sequences.\n      #\n      # So `full_position_embeddings` is effectively an embedding table\n      # for position [0, 1, 2, ..., max_position_embeddings-1], and the current\n      # sequence has positions [0, 1, 2, ... seq_length-1], so we can just\n      # perform a slice.\n      position_embeddings = tf.slice(full_position_embeddings, [0, 0],\n                                     [seq_length, -1])\n      num_dims = len(output.shape.as_list())\n\n      # Only the last two dimensions are relevant (`seq_length` and `width`), so\n      # we broadcast among the first dimensions, which is typically just\n      # the batch size.\n      position_broadcast_shape = []\n      for _ in range(num_dims - 2):\n        position_broadcast_shape.append(1)\n      position_broadcast_shape.extend([seq_length, width])\n      position_embeddings = tf.reshape(position_embeddings,\n                                       position_broadcast_shape)\n      output += position_embeddings\n\n  output = layer_norm_and_dropout(output, dropout_prob)\n  return output\n\n\ndef create_attention_mask_from_input_mask(from_tensor, to_mask):\n  """"""Create 3D attention mask from a 2D tensor mask.\n\n  Args:\n    from_tensor: 2D or 3D Tensor of shape [batch_size, from_seq_length, ...].\n    to_mask: int32 Tensor of shape [batch_size, to_seq_length].\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length, to_seq_length].\n  """"""\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  batch_size = from_shape[0]\n  from_seq_length = from_shape[1]\n\n  to_shape = get_shape_list(to_mask, expected_rank=2)\n  to_seq_length = to_shape[1]\n\n  to_mask = tf.cast(\n      tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)\n\n  # We don\'t assume that `from_tensor` is a mask (although it could be). We\n  # don\'t actually care if we attend *from* padding tokens (only *to* padding)\n  # tokens so we create a tensor of all ones.\n  #\n  # `broadcast_ones` = [batch_size, from_seq_length, 1]\n  broadcast_ones = tf.ones(\n      shape=[batch_size, from_seq_length, 1], dtype=tf.float32)\n\n  # Here we broadcast along two dimensions to create the mask.\n  mask = broadcast_ones * to_mask\n\n  return mask\n\n\ndef attention_layer(from_tensor,\n                    to_tensor,\n                    attention_mask=None,\n                    num_attention_heads=1,\n                    size_per_head=512,\n                    query_act=None,\n                    key_act=None,\n                    value_act=None,\n                    attention_probs_dropout_prob=0.0,\n                    initializer_range=0.02,\n                    do_return_2d_tensor=False,\n                    batch_size=None,\n                    from_seq_length=None,\n                    to_seq_length=None):\n  """"""Performs multi-headed attention from `from_tensor` to `to_tensor`.\n\n  This is an implementation of multi-headed attention based on ""Attention\n  is all you Need"". If `from_tensor` and `to_tensor` are the same, then\n  this is self-attention. Each timestep in `from_tensor` attends to the\n  corresponding sequence in `to_tensor`, and returns a fixed-with vector.\n\n  This function first projects `from_tensor` into a ""query"" tensor and\n  `to_tensor` into ""key"" and ""value"" tensors. These are (effectively) a list\n  of tensors of length `num_attention_heads`, where each tensor is of shape\n  [batch_size, seq_length, size_per_head].\n\n  Then, the query and key tensors are dot-producted and scaled. These are\n  softmaxed to obtain attention probabilities. The value tensors are then\n  interpolated by these probabilities, then concatenated back to a single\n  tensor and returned.\n\n  In practice, the multi-headed attention are done with transposes and\n  reshapes rather than actual separate tensors.\n\n  Args:\n    from_tensor: float Tensor of shape [batch_size, from_seq_length,\n      from_width].\n    to_tensor: float Tensor of shape [batch_size, to_seq_length, to_width].\n    attention_mask: (optional) int32 Tensor of shape [batch_size,\n      from_seq_length, to_seq_length]. The values should be 1 or 0. The\n      attention scores will effectively be set to -infinity for any positions in\n      the mask that are 0, and will be unchanged for positions that are 1.\n    num_attention_heads: int. Number of attention heads.\n    size_per_head: int. Size of each attention head.\n    query_act: (optional) Activation function for the query transform.\n    key_act: (optional) Activation function for the key transform.\n    value_act: (optional) Activation function for the value transform.\n    attention_probs_dropout_prob: (optional) float. Dropout probability of the\n      attention probabilities.\n    initializer_range: float. Range of the weight initializer.\n    do_return_2d_tensor: bool. If True, the output will be of shape [batch_size\n      * from_seq_length, num_attention_heads * size_per_head]. If False, the\n      output will be of shape [batch_size, from_seq_length, num_attention_heads\n      * size_per_head].\n    batch_size: (Optional) int. If the input is 2D, this might be the batch size\n      of the 3D version of the `from_tensor` and `to_tensor`.\n    from_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `from_tensor`.\n    to_seq_length: (Optional) If the input is 2D, this might be the seq length\n      of the 3D version of the `to_tensor`.\n\n  Returns:\n    float Tensor of shape [batch_size, from_seq_length,\n      num_attention_heads * size_per_head]. (If `do_return_2d_tensor` is\n      true, this will be of shape [batch_size * from_seq_length,\n      num_attention_heads * size_per_head]).\n\n  Raises:\n    ValueError: Any of the arguments or tensor shapes are invalid.\n  """"""\n\n  def transpose_for_scores(input_tensor, batch_size, num_attention_heads,\n                           seq_length, width):\n    output_tensor = tf.reshape(\n        input_tensor, [batch_size, seq_length, num_attention_heads, width])\n\n    output_tensor = tf.transpose(output_tensor, [0, 2, 1, 3])\n    return output_tensor\n\n  from_shape = get_shape_list(from_tensor, expected_rank=[2, 3])\n  to_shape = get_shape_list(to_tensor, expected_rank=[2, 3])\n\n  if len(from_shape) != len(to_shape):\n    raise ValueError(\n        ""The rank of `from_tensor` must match the rank of `to_tensor`."")\n\n  if len(from_shape) == 3:\n    batch_size = from_shape[0]\n    from_seq_length = from_shape[1]\n    to_seq_length = to_shape[1]\n  elif len(from_shape) == 2:\n    if (batch_size is None or from_seq_length is None or to_seq_length is None):\n      raise ValueError(\n          ""When passing in rank 2 tensors to attention_layer, the values ""\n          ""for `batch_size`, `from_seq_length`, and `to_seq_length` ""\n          ""must all be specified."")\n\n  # Scalar dimensions referenced here:\n  #   B = batch size (number of sequences)\n  #   F = `from_tensor` sequence length\n  #   T = `to_tensor` sequence length\n  #   N = `num_attention_heads`\n  #   H = `size_per_head`\n\n  from_tensor_2d = reshape_to_matrix(from_tensor)\n  to_tensor_2d = reshape_to_matrix(to_tensor)\n\n  # `query_layer` = [B*F, N*H]\n  query_layer = tf.layers.dense(\n      from_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=query_act,\n      name=""query"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `key_layer` = [B*T, N*H]\n  key_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=key_act,\n      name=""key"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `value_layer` = [B*T, N*H]\n  value_layer = tf.layers.dense(\n      to_tensor_2d,\n      num_attention_heads * size_per_head,\n      activation=value_act,\n      name=""value"",\n      kernel_initializer=create_initializer(initializer_range))\n\n  # `query_layer` = [B, N, F, H]\n  query_layer = transpose_for_scores(query_layer, batch_size,\n                                     num_attention_heads, from_seq_length,\n                                     size_per_head)\n\n  # `key_layer` = [B, N, T, H]\n  key_layer = transpose_for_scores(key_layer, batch_size, num_attention_heads,\n                                   to_seq_length, size_per_head)\n\n  # Take the dot product between ""query"" and ""key"" to get the raw\n  # attention scores.\n  # `attention_scores` = [B, N, F, T]\n  attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)\n  attention_scores = tf.multiply(attention_scores,\n                                 1.0 / math.sqrt(float(size_per_head)))\n\n  if attention_mask is not None:\n    # `attention_mask` = [B, 1, F, T]\n    attention_mask = tf.expand_dims(attention_mask, axis=[1])\n\n    # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n    # masked positions, this operation will create a tensor which is 0.0 for\n    # positions we want to attend and -10000.0 for masked positions.\n    adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0\n\n    # Since we are adding it to the raw scores before the softmax, this is\n    # effectively the same as removing these entirely.\n    attention_scores += adder\n\n  # Normalize the attention scores to probabilities.\n  # `attention_probs` = [B, N, F, T]\n  attention_probs = tf.nn.softmax(attention_scores)\n\n  # This is actually dropping out entire tokens to attend to, which might\n  # seem a bit unusual, but is taken from the original Transformer paper.\n  attention_probs = dropout(attention_probs, attention_probs_dropout_prob)\n\n  # `value_layer` = [B, T, N, H]\n  value_layer = tf.reshape(\n      value_layer,\n      [batch_size, to_seq_length, num_attention_heads, size_per_head])\n\n  # `value_layer` = [B, N, T, H]\n  value_layer = tf.transpose(value_layer, [0, 2, 1, 3])\n\n  # `context_layer` = [B, N, F, H]\n  context_layer = tf.matmul(attention_probs, value_layer)\n\n  # `context_layer` = [B, F, N, H]\n  context_layer = tf.transpose(context_layer, [0, 2, 1, 3])\n\n  if do_return_2d_tensor:\n    # `context_layer` = [B*F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size * from_seq_length, num_attention_heads * size_per_head])\n  else:\n    # `context_layer` = [B, F, N*H]\n    context_layer = tf.reshape(\n        context_layer,\n        [batch_size, from_seq_length, num_attention_heads * size_per_head])\n\n  return context_layer\n\n\ndef transformer_model(input_tensor,\n                      attention_mask=None,\n                      hidden_size=768,\n                      num_hidden_layers=12,\n                      num_attention_heads=12,\n                      intermediate_size=3072,\n                      intermediate_act_fn=gelu,\n                      hidden_dropout_prob=0.1,\n                      attention_probs_dropout_prob=0.1,\n                      initializer_range=0.02,\n                      do_return_all_layers=False):\n  """"""Multi-headed, multi-layer Transformer from ""Attention is All You Need"".\n\n  This is almost an exact implementation of the original Transformer encoder.\n\n  See the original paper:\n  https://arxiv.org/abs/1706.03762\n\n  Also see:\n  https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py\n\n  Args:\n    input_tensor: float Tensor of shape [batch_size, seq_length, hidden_size].\n    attention_mask: (optional) int32 Tensor of shape [batch_size, seq_length,\n      seq_length], with 1 for positions that can be attended to and 0 in\n      positions that should not be.\n    hidden_size: int. Hidden size of the Transformer.\n    num_hidden_layers: int. Number of layers (blocks) in the Transformer.\n    num_attention_heads: int. Number of attention heads in the Transformer.\n    intermediate_size: int. The size of the ""intermediate"" (a.k.a., feed\n      forward) layer.\n    intermediate_act_fn: function. The non-linear activation function to apply\n      to the output of the intermediate/feed-forward layer.\n    hidden_dropout_prob: float. Dropout probability for the hidden layers.\n    attention_probs_dropout_prob: float. Dropout probability of the attention\n      probabilities.\n    initializer_range: float. Range of the initializer (stddev of truncated\n      normal).\n    do_return_all_layers: Whether to also return all layers or just the final\n      layer.\n\n  Returns:\n    float Tensor of shape [batch_size, seq_length, hidden_size], the final\n    hidden layer of the Transformer.\n\n  Raises:\n    ValueError: A Tensor shape or parameter is invalid.\n  """"""\n  if hidden_size % num_attention_heads != 0:\n    raise ValueError(\n        ""The hidden size (%d) is not a multiple of the number of attention ""\n        ""heads (%d)"" % (hidden_size, num_attention_heads))\n\n  attention_head_size = int(hidden_size / num_attention_heads)\n  input_shape = get_shape_list(input_tensor, expected_rank=3)\n  batch_size = input_shape[0]\n  seq_length = input_shape[1]\n  input_width = input_shape[2]\n\n  # The Transformer performs sum residuals on all layers so the input needs\n  # to be the same as the hidden size.\n  if input_width != hidden_size:\n    raise ValueError(""The width of the input tensor (%d) != hidden size (%d)"" %\n                     (input_width, hidden_size))\n\n  # We keep the representation as a 2D tensor to avoid re-shaping it back and\n  # forth from a 3D tensor to a 2D tensor. Re-shapes are normally free on\n  # the GPU/CPU but may not be free on the TPU, so we want to minimize them to\n  # help the optimizer.\n  prev_output = reshape_to_matrix(input_tensor)\n\n  all_layer_outputs = []\n  for layer_idx in range(num_hidden_layers):\n    with tf.variable_scope(""layer_%d"" % layer_idx):\n      layer_input = prev_output\n\n      with tf.variable_scope(""attention""):\n        attention_heads = []\n        with tf.variable_scope(""self""):\n          attention_head = attention_layer(\n              from_tensor=layer_input,\n              to_tensor=layer_input,\n              attention_mask=attention_mask,\n              num_attention_heads=num_attention_heads,\n              size_per_head=attention_head_size,\n              attention_probs_dropout_prob=attention_probs_dropout_prob,\n              initializer_range=initializer_range,\n              do_return_2d_tensor=True,\n              batch_size=batch_size,\n              from_seq_length=seq_length,\n              to_seq_length=seq_length)\n          attention_heads.append(attention_head)\n\n        attention_output = None\n        if len(attention_heads) == 1:\n          attention_output = attention_heads[0]\n        else:\n          # In the case where we have other sequences, we just concatenate\n          # them to the self-attention head before the projection.\n          attention_output = tf.concat(attention_heads, axis=-1)\n\n        # Run a linear projection of `hidden_size` then add a residual\n        # with `layer_input`.\n        with tf.variable_scope(""output""):\n          attention_output = tf.layers.dense(\n              attention_output,\n              hidden_size,\n              kernel_initializer=create_initializer(initializer_range))\n          attention_output = dropout(attention_output, hidden_dropout_prob)\n          attention_output = layer_norm(attention_output + layer_input)\n\n      # The activation is only applied to the ""intermediate"" hidden layer.\n      with tf.variable_scope(""intermediate""):\n        intermediate_output = tf.layers.dense(\n            attention_output,\n            intermediate_size,\n            activation=intermediate_act_fn,\n            kernel_initializer=create_initializer(initializer_range))\n\n      # Down-project back to `hidden_size` then add the residual.\n      with tf.variable_scope(""output""):\n        layer_output = tf.layers.dense(\n            intermediate_output,\n            hidden_size,\n            kernel_initializer=create_initializer(initializer_range))\n        layer_output = dropout(layer_output, hidden_dropout_prob)\n        layer_output = layer_norm(layer_output + attention_output)\n        prev_output = layer_output\n        all_layer_outputs.append(layer_output)\n\n  if do_return_all_layers:\n    final_outputs = []\n    for layer_output in all_layer_outputs:\n      final_output = reshape_from_matrix(layer_output, input_shape)\n      final_outputs.append(final_output)\n    return final_outputs\n  else:\n    final_output = reshape_from_matrix(prev_output, input_shape)\n    return final_output\n\n\ndef get_shape_list(tensor, expected_rank=None, name=None):\n  """"""Returns a list of the shape of tensor, preferring static dimensions.\n\n  Args:\n    tensor: A tf.Tensor object to find the shape of.\n    expected_rank: (optional) int. The expected rank of `tensor`. If this is\n      specified and the `tensor` has a different rank, and exception will be\n      thrown.\n    name: Optional name of the tensor for the error message.\n\n  Returns:\n    A list of dimensions of the shape of tensor. All static dimensions will\n    be returned as python integers, and dynamic dimensions will be returned\n    as tf.Tensor scalars.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  if expected_rank is not None:\n    assert_rank(tensor, expected_rank, name)\n\n  shape = tensor.shape.as_list()\n\n  non_static_indexes = []\n  for (index, dim) in enumerate(shape):\n    if dim is None:\n      non_static_indexes.append(index)\n\n  if not non_static_indexes:\n    return shape\n\n  dyn_shape = tf.shape(tensor)\n  for index in non_static_indexes:\n    shape[index] = dyn_shape[index]\n  return shape\n\n\ndef reshape_to_matrix(input_tensor):\n  """"""Reshapes a >= rank 2 tensor to a rank 2 tensor (i.e., a matrix).""""""\n  ndims = input_tensor.shape.ndims\n  if ndims < 2:\n    raise ValueError(""Input tensor must have at least rank 2. Shape = %s"" %\n                     (input_tensor.shape))\n  if ndims == 2:\n    return input_tensor\n\n  width = input_tensor.shape[-1]\n  output_tensor = tf.reshape(input_tensor, [-1, width])\n  return output_tensor\n\n\ndef reshape_from_matrix(output_tensor, orig_shape_list):\n  """"""Reshapes a rank 2 tensor back to its original rank >= 2 tensor.""""""\n  if len(orig_shape_list) == 2:\n    return output_tensor\n\n  output_shape = get_shape_list(output_tensor)\n\n  orig_dims = orig_shape_list[0:-1]\n  width = output_shape[-1]\n\n  return tf.reshape(output_tensor, orig_dims + [width])\n\n\ndef assert_rank(tensor, expected_rank, name=None):\n  """"""Raises an exception if the tensor rank is not of the expected rank.\n\n  Args:\n    tensor: A tf.Tensor to check the rank of.\n    expected_rank: Python integer or list of integers, expected rank.\n    name: Optional name of the tensor for the error message.\n\n  Raises:\n    ValueError: If the expected shape doesn\'t match the actual shape.\n  """"""\n  if name is None:\n    name = tensor.name\n\n  expected_rank_dict = {}\n  if isinstance(expected_rank, six.integer_types):\n    expected_rank_dict[expected_rank] = True\n  else:\n    for x in expected_rank:\n      expected_rank_dict[x] = True\n\n  actual_rank = tensor.shape.ndims\n  if actual_rank not in expected_rank_dict:\n    scope_name = tf.get_variable_scope().name\n    raise ValueError(\n        ""For the tensor `%s` in scope `%s`, the actual rank ""\n        ""`%d` (shape = %s) is not equal to the expected rank `%s`"" %\n        (name, scope_name, actual_rank, str(tensor.shape), str(expected_rank)))\n'"
baselines/models/roberta_wwm_large_ext/modeling_test.py,5,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport random\nimport re\n\nimport modeling\nimport six\nimport tensorflow as tf\n\n\nclass BertModelTest(tf.test.TestCase):\n\n  class BertModelTester(object):\n\n    def __init__(self,\n                 parent,\n                 batch_size=13,\n                 seq_length=7,\n                 is_training=True,\n                 use_input_mask=True,\n                 use_token_type_ids=True,\n                 vocab_size=99,\n                 hidden_size=32,\n                 num_hidden_layers=5,\n                 num_attention_heads=4,\n                 intermediate_size=37,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=16,\n                 initializer_range=0.02,\n                 scope=None):\n      self.parent = parent\n      self.batch_size = batch_size\n      self.seq_length = seq_length\n      self.is_training = is_training\n      self.use_input_mask = use_input_mask\n      self.use_token_type_ids = use_token_type_ids\n      self.vocab_size = vocab_size\n      self.hidden_size = hidden_size\n      self.num_hidden_layers = num_hidden_layers\n      self.num_attention_heads = num_attention_heads\n      self.intermediate_size = intermediate_size\n      self.hidden_act = hidden_act\n      self.hidden_dropout_prob = hidden_dropout_prob\n      self.attention_probs_dropout_prob = attention_probs_dropout_prob\n      self.max_position_embeddings = max_position_embeddings\n      self.type_vocab_size = type_vocab_size\n      self.initializer_range = initializer_range\n      self.scope = scope\n\n    def create_model(self):\n      input_ids = BertModelTest.ids_tensor([self.batch_size, self.seq_length],\n                                           self.vocab_size)\n\n      input_mask = None\n      if self.use_input_mask:\n        input_mask = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], vocab_size=2)\n\n      token_type_ids = None\n      if self.use_token_type_ids:\n        token_type_ids = BertModelTest.ids_tensor(\n            [self.batch_size, self.seq_length], self.type_vocab_size)\n\n      config = modeling.BertConfig(\n          vocab_size=self.vocab_size,\n          hidden_size=self.hidden_size,\n          num_hidden_layers=self.num_hidden_layers,\n          num_attention_heads=self.num_attention_heads,\n          intermediate_size=self.intermediate_size,\n          hidden_act=self.hidden_act,\n          hidden_dropout_prob=self.hidden_dropout_prob,\n          attention_probs_dropout_prob=self.attention_probs_dropout_prob,\n          max_position_embeddings=self.max_position_embeddings,\n          type_vocab_size=self.type_vocab_size,\n          initializer_range=self.initializer_range)\n\n      model = modeling.BertModel(\n          config=config,\n          is_training=self.is_training,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          token_type_ids=token_type_ids,\n          scope=self.scope)\n\n      outputs = {\n          ""embedding_output"": model.get_embedding_output(),\n          ""sequence_output"": model.get_sequence_output(),\n          ""pooled_output"": model.get_pooled_output(),\n          ""all_encoder_layers"": model.get_all_encoder_layers(),\n      }\n      return outputs\n\n    def check_output(self, result):\n      self.parent.assertAllEqual(\n          result[""embedding_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(\n          result[""sequence_output""].shape,\n          [self.batch_size, self.seq_length, self.hidden_size])\n\n      self.parent.assertAllEqual(result[""pooled_output""].shape,\n                                 [self.batch_size, self.hidden_size])\n\n  def test_default(self):\n    self.run_tester(BertModelTest.BertModelTester(self))\n\n  def test_config_to_json_string(self):\n    config = modeling.BertConfig(vocab_size=99, hidden_size=37)\n    obj = json.loads(config.to_json_string())\n    self.assertEqual(obj[""vocab_size""], 99)\n    self.assertEqual(obj[""hidden_size""], 37)\n\n  def run_tester(self, tester):\n    with self.test_session() as sess:\n      ops = tester.create_model()\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      output_result = sess.run(ops)\n      tester.check_output(output_result)\n\n      self.assert_all_tensors_reachable(sess, [init_op, ops])\n\n  @classmethod\n  def ids_tensor(cls, shape, vocab_size, rng=None, name=None):\n    """"""Creates a random int32 tensor of the shape within the vocab size.""""""\n    if rng is None:\n      rng = random.Random()\n\n    total_dims = 1\n    for dim in shape:\n      total_dims *= dim\n\n    values = []\n    for _ in range(total_dims):\n      values.append(rng.randint(0, vocab_size - 1))\n\n    return tf.constant(value=values, dtype=tf.int32, shape=shape, name=name)\n\n  def assert_all_tensors_reachable(self, sess, outputs):\n    """"""Checks that all the tensors in the graph are reachable from outputs.""""""\n    graph = sess.graph\n\n    ignore_strings = [\n        ""^.*/assert_less_equal/.*$"",\n        ""^.*/dilation_rate$"",\n        ""^.*/Tensordot/concat$"",\n        ""^.*/Tensordot/concat/axis$"",\n        ""^testing/.*$"",\n    ]\n\n    ignore_regexes = [re.compile(x) for x in ignore_strings]\n\n    unreachable = self.get_unreachable_ops(graph, outputs)\n    filtered_unreachable = []\n    for x in unreachable:\n      do_ignore = False\n      for r in ignore_regexes:\n        m = r.match(x.name)\n        if m is not None:\n          do_ignore = True\n      if do_ignore:\n        continue\n      filtered_unreachable.append(x)\n    unreachable = filtered_unreachable\n\n    self.assertEqual(\n        len(unreachable), 0, ""The following ops are unreachable: %s"" %\n        ("" "".join([x.name for x in unreachable])))\n\n  @classmethod\n  def get_unreachable_ops(cls, graph, outputs):\n    """"""Finds all of the tensors in graph that are unreachable from outputs.""""""\n    outputs = cls.flatten_recursive(outputs)\n    output_to_op = collections.defaultdict(list)\n    op_to_all = collections.defaultdict(list)\n    assign_out_to_in = collections.defaultdict(list)\n\n    for op in graph.get_operations():\n      for x in op.inputs:\n        op_to_all[op.name].append(x.name)\n      for y in op.outputs:\n        output_to_op[y.name].append(op.name)\n        op_to_all[op.name].append(y.name)\n      if str(op.type) == ""Assign"":\n        for y in op.outputs:\n          for x in op.inputs:\n            assign_out_to_in[y.name].append(x.name)\n\n    assign_groups = collections.defaultdict(list)\n    for out_name in assign_out_to_in.keys():\n      name_group = assign_out_to_in[out_name]\n      for n1 in name_group:\n        assign_groups[n1].append(out_name)\n        for n2 in name_group:\n          if n1 != n2:\n            assign_groups[n1].append(n2)\n\n    seen_tensors = {}\n    stack = [x.name for x in outputs]\n    while stack:\n      name = stack.pop()\n      if name in seen_tensors:\n        continue\n      seen_tensors[name] = True\n\n      if name in output_to_op:\n        for op_name in output_to_op[name]:\n          if op_name in op_to_all:\n            for input_name in op_to_all[op_name]:\n              if input_name not in stack:\n                stack.append(input_name)\n\n      expanded_names = []\n      if name in assign_groups:\n        for assign_name in assign_groups[name]:\n          expanded_names.append(assign_name)\n\n      for expanded_name in expanded_names:\n        if expanded_name not in stack:\n          stack.append(expanded_name)\n\n    unreachable_ops = []\n    for op in graph.get_operations():\n      is_unreachable = False\n      all_names = [x.name for x in op.inputs] + [x.name for x in op.outputs]\n      for name in all_names:\n        if name not in seen_tensors:\n          is_unreachable = True\n      if is_unreachable:\n        unreachable_ops.append(op)\n    return unreachable_ops\n\n  @classmethod\n  def flatten_recursive(cls, item):\n    """"""Flattens (potentially nested) a tuple/dictionary/list to a list.""""""\n    output = []\n    if isinstance(item, list):\n      output.extend(item)\n    elif isinstance(item, tuple):\n      output.extend(list(item))\n    elif isinstance(item, dict):\n      for (_, v) in six.iteritems(item):\n        output.append(v)\n    else:\n      return [item]\n\n    flat_output = []\n    for x in output:\n      flat_output.extend(cls.flatten_recursive(x))\n    return flat_output\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/roberta_wwm_large_ext/optimization.py,25,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Functions and classes related to optimization (weight updates).""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport tensorflow as tf\n\n\ndef create_optimizer(loss, init_lr, num_train_steps, num_warmup_steps, use_tpu):\n  """"""Creates an optimizer training op.""""""\n  global_step = tf.train.get_or_create_global_step()\n\n  learning_rate = tf.constant(value=init_lr, shape=[], dtype=tf.float32)\n\n  # Implements linear decay of the learning rate.\n  learning_rate = tf.train.polynomial_decay(\n      learning_rate,\n      global_step,\n      num_train_steps,\n      end_learning_rate=0.0,\n      power=1.0,\n      cycle=False)\n\n  # Implements linear warmup. I.e., if global_step < num_warmup_steps, the\n  # learning rate will be `global_step/num_warmup_steps * init_lr`.\n  if num_warmup_steps:\n    global_steps_int = tf.cast(global_step, tf.int32)\n    warmup_steps_int = tf.constant(num_warmup_steps, dtype=tf.int32)\n\n    global_steps_float = tf.cast(global_steps_int, tf.float32)\n    warmup_steps_float = tf.cast(warmup_steps_int, tf.float32)\n\n    warmup_percent_done = global_steps_float / warmup_steps_float\n    warmup_learning_rate = init_lr * warmup_percent_done\n\n    is_warmup = tf.cast(global_steps_int < warmup_steps_int, tf.float32)\n    learning_rate = (\n        (1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate)\n\n  # It is recommended that you use this optimizer for fine tuning, since this\n  # is how the model was trained (note that the Adam m/v variables are NOT\n  # loaded from init_checkpoint.)\n  optimizer = AdamWeightDecayOptimizer(\n      learning_rate=learning_rate,\n      weight_decay_rate=0.01,\n      beta_1=0.9,\n      beta_2=0.999,\n      epsilon=1e-6,\n      exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""])\n\n  if use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  tvars = tf.trainable_variables()\n  grads = tf.gradients(loss, tvars)\n\n  # This is how the model was pre-trained.\n  (grads, _) = tf.clip_by_global_norm(grads, clip_norm=1.0)\n\n  train_op = optimizer.apply_gradients(\n      zip(grads, tvars), global_step=global_step)\n\n  # Normally the global step update is done inside of `apply_gradients`.\n  # However, `AdamWeightDecayOptimizer` doesn\'t do this. But if you use\n  # a different optimizer, you should probably take this line out.\n  new_global_step = global_step + 1\n  train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n  return train_op\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n'"
baselines/models/roberta_wwm_large_ext/optimization_test.py,11,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport optimization\nimport tensorflow as tf\n\n\nclass OptimizationTest(tf.test.TestCase):\n\n  def test_adam(self):\n    with self.test_session() as sess:\n      w = tf.get_variable(\n          ""w"",\n          shape=[3],\n          initializer=tf.constant_initializer([0.1, -0.2, -0.1]))\n      x = tf.constant([0.4, 0.2, -0.5])\n      loss = tf.reduce_mean(tf.square(x - w))\n      tvars = tf.trainable_variables()\n      grads = tf.gradients(loss, tvars)\n      global_step = tf.train.get_or_create_global_step()\n      optimizer = optimization.AdamWeightDecayOptimizer(learning_rate=0.2)\n      train_op = optimizer.apply_gradients(zip(grads, tvars), global_step)\n      init_op = tf.group(tf.global_variables_initializer(),\n                         tf.local_variables_initializer())\n      sess.run(init_op)\n      for _ in range(100):\n        sess.run(train_op)\n      w_np = sess.run(w)\n      self.assertAllClose(w_np.flat, [0.4, 0.2, -0.5], rtol=1e-2, atol=1e-2)\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/roberta_wwm_large_ext/run_classifier.py,112,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:30:45\n# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport csv\nimport os\nimport json\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nimport sys\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n# Required parameters\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input data dir. Should contain the .tsv files (or other data files) ""\n    ""for the task."")\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""task_name"", None, ""The name of the task to train."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n# Other parameters\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(\n    ""do_predict"", False,\n    ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer.tokenize(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer.tokenize(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for [CLS], [SEP], [SEP] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for [CLS] and [SEP] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[0:(max_seq_length - 2)]\n\n  # The convention in BERT is:\n  # (a) For sequence pairs:\n  #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n  #  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1\n  # (b) For single sequences:\n  #  tokens:   [CLS] the dog is hairy . [SEP]\n  #  type_ids: 0     0   0   0  0     0 0\n  #\n  # Where ""type_ids"" are used to indicate whether this is the first\n  # sequence or the second sequence. The embedding vectors for `type=0` and\n  # `type=1` were learned during pre-training and are added to the wordpiece\n  # embedding vector (and position vector). This is not *strictly* necessary\n  # since the [SEP] token unambiguously separates the sequences, but it makes\n  # it easier for the model to learn the concept of sequences.\n  #\n  # For classification tasks, the first vector (corresponding to [CLS]) is\n  # used as the ""sentence vector"". Note that this only makes sense because\n  # the entire model is fine-tuned.\n  tokens = []\n  segment_ids = []\n  tokens.append(""[CLS]"")\n  segment_ids.append(0)\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(0)\n  tokens.append(""[SEP]"")\n  segment_ids.append(0)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(1)\n    tokens.append(""[SEP]"")\n    segment_ids.append(1)\n\n  input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n  # The mask has 1 for real tokens and 0 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [1] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  while len(input_ids) < max_seq_length:\n    input_ids.append(0)\n    input_mask.append(0)\n    segment_ids.append(0)\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  label_id = label_map[example.label]\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""tokens: %s"" % "" "".join(\n        [tokenization.printable_text(x) for x in tokens]))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id,\n      is_real_example=True)\n  return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    features[""label_ids""] = create_int_feature([feature.label_id])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 labels, num_labels, use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use model.get_sequence_output()\n  # instead.\n  output_layer = model.get_pooled_output()\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n    is_real_example = None\n    if ""is_real_example"" in features:\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n    else:\n      is_real_example = tf.ones(tf.shape(label_ids), dtype=tf.float32)\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        bert_config, is_training, input_ids, input_mask, segment_ids, label_ids,\n        num_labels, use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n       ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(\n            labels=label_ids, predictions=predictions, weights=is_real_example)\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn,\n                      [per_example_loss, label_ids, logits, is_real_example])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={""probabilities"": probabilities},\n          scaffold_fn=scaffold_fn)\n    return output_spec\n\n  return model_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef input_fn_builder(features, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  all_input_ids = []\n  all_input_mask = []\n  all_segment_ids = []\n  all_label_ids = []\n\n  for feature in features:\n    all_input_ids.append(feature.input_ids)\n    all_input_mask.append(feature.input_mask)\n    all_segment_ids.append(feature.segment_ids)\n    all_label_ids.append(feature.label_id)\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    num_examples = len(features)\n\n    # This is for demo purposes and does NOT scale to large data sets. We do\n    # not use Dataset.from_generator() because that uses tf.py_func which is\n    # not TPU compatible. The right way to load data is with TFRecordReader.\n    d = tf.data.Dataset.from_tensor_slices({\n        ""input_ids"":\n            tf.constant(\n                all_input_ids, shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""input_mask"":\n            tf.constant(\n                all_input_mask,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""segment_ids"":\n            tf.constant(\n                all_segment_ids,\n                shape=[num_examples, seq_length],\n                dtype=tf.int32),\n        ""label_ids"":\n            tf.constant(all_label_ids, shape=[num_examples], dtype=tf.int32),\n    })\n\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.batch(batch_size=batch_size, drop_remainder=drop_remainder)\n    return d\n\n  return input_fn\n\n\n# This function is not used by this file but is still used by the Colab and\n# people who depend on it.\ndef convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer):\n  """"""Convert a set of `InputExample`s to a list of `InputFeatures`.""""""\n\n  features = []\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenizer)\n\n    features.append(feature)\n  return features\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval` or `do_predict\' must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      num_labels=len(label_list),\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n    else:\n      file_based_convert_examples_to_features(\n          train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file)\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    # dev dataset\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    num_actual_eval_examples = len(eval_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on. These do NOT count towards the metric (all tf.metrics\n      # support a per-instance weight, and these get a weight of 0.0).\n      while len(eval_examples) % FLAGS.eval_batch_size != 0:\n        eval_examples.append(PaddingInputExample())\n\n    eval_file = os.path.join(FLAGS.output_dir, ""dev.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(eval_examples), num_actual_eval_examples,\n                    len(eval_examples) - num_actual_eval_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      assert len(eval_examples) % FLAGS.eval_batch_size == 0\n      eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    #######################################################################################################################\n    # evaluate all checkpoints; you can use the checkpoint with the best dev accuarcy\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.output_dir)\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = os.path.join(FLAGS.output_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_roberta_wwm_large_ext.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        result = estimator.evaluate(input_fn=eval_input_fn,\n                                    steps=eval_steps, checkpoint_path=filename)\n\n        tf.logging.info(""***** Eval results %s *****"" % (filename))\n        writer.write(""***** Eval results %s *****\\n"" % (filename))\n        for key in sorted(result.keys()):\n          tf.logging.info(""  %s = %s"", key, str(result[key]))\n          writer.write(""%s = %s\\n"" % (key, str(result[key])))\n    #######################################################################################################################\n\n    # result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n    #\n    # output_eval_file = os.path.join(FLAGS.output_dir, ""dev_results_roberta_wwm_large_ext.txt"")\n    # with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n    #  tf.logging.info(""***** Eval results *****"")\n    #  for key in sorted(result.keys()):\n    #    tf.logging.info(""  %s = %s"", key, str(result[key]))\n    #    writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    num_actual_predict_examples = len(predict_examples)\n    if FLAGS.use_tpu:\n      # TPU requires a fixed batch size for all batches, therefore the number\n      # of examples must be a multiple of the batch size, or else examples\n      # will get dropped. So we pad with fake examples which are ignored\n      # later on.\n      while len(predict_examples) % FLAGS.predict_batch_size != 0:\n        predict_examples.append(PaddingInputExample())\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(predict_examples, label_list,\n                                                        FLAGS.max_seq_length, tokenizer,\n                                                        predict_file)\n    else:\n      file_based_convert_examples_to_features(predict_examples, label_list,\n                                              FLAGS.max_seq_length, tokenizer,\n                                              predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d (%d actual, %d padding)"",\n                    len(predict_examples), num_actual_predict_examples,\n                    len(predict_examples) - num_actual_predict_examples)\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_drop_remainder = True if FLAGS.use_tpu else False\n    predict_input_fn = file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=predict_drop_remainder)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_large_ext/run_classifier_with_tfhub.py,51,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner with TF-Hub.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport optimization\nimport run_classifier\nimport tokenization\nimport tensorflow as tf\nimport tensorflow_hub as hub\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""bert_hub_module_handle"", None,\n    ""Handle for the BERT TF-Hub module."")\n\n\ndef create_model(is_training, input_ids, input_mask, segment_ids, labels,\n                 num_labels, bert_hub_module_handle):\n  """"""Creates a classification model.""""""\n  tags = set()\n  if is_training:\n    tags.add(""train"")\n  bert_module = hub.Module(bert_hub_module_handle, tags=tags, trainable=True)\n  bert_inputs = dict(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids)\n  bert_outputs = bert_module(\n      inputs=bert_inputs,\n      signature=""tokens"",\n      as_dict=True)\n\n  # In the demo, we are doing a simple classification task on the entire\n  # segment.\n  #\n  # If you want to use the token-level output, use\n  # bert_outputs[""sequence_output""] instead.\n  output_layer = bert_outputs[""pooled_output""]\n\n  hidden_size = output_layer.shape[-1].value\n\n  output_weights = tf.get_variable(\n      ""output_weights"", [num_labels, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""output_bias"", [num_labels], initializer=tf.zeros_initializer())\n\n  with tf.variable_scope(""loss""):\n    if is_training:\n      # I.e., 0.1 dropout\n      output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n\n    logits = tf.matmul(output_layer, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    probabilities = tf.nn.softmax(logits, axis=-1)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n\n    return (loss, per_example_loss, logits, probabilities)\n\n\ndef model_fn_builder(num_labels, learning_rate, num_train_steps,\n                     num_warmup_steps, use_tpu, bert_hub_module_handle):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    label_ids = features[""label_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (total_loss, per_example_loss, logits, probabilities) = create_model(\n        is_training, input_ids, input_mask, segment_ids, label_ids, num_labels,\n        bert_hub_module_handle)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(per_example_loss, label_ids, logits):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        accuracy = tf.metrics.accuracy(label_ids, predictions)\n        loss = tf.metrics.mean(per_example_loss)\n        return {\n            ""eval_accuracy"": accuracy,\n            ""eval_loss"": loss,\n        }\n\n      eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions={""probabilities"": probabilities})\n    else:\n      raise ValueError(\n          ""Only TRAIN, EVAL and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef create_tokenizer_from_hub_module(bert_hub_module_handle):\n  """"""Get the vocab file and casing info from the Hub module.""""""\n  with tf.Graph().as_default():\n    bert_module = hub.Module(bert_hub_module_handle)\n    tokenization_info = bert_module(signature=""tokenization_info"", as_dict=True)\n    with tf.Session() as sess:\n      vocab_file, do_lower_case = sess.run([tokenization_info[""vocab_file""],\n                                            tokenization_info[""do_lower_case""]])\n  return tokenization.FullTokenizer(\n      vocab_file=vocab_file, do_lower_case=do_lower_case)\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  processors = {\n      ""cola"": run_classifier.ColaProcessor,\n      ""mnli"": run_classifier.MnliProcessor,\n      ""mrpc"": run_classifier.MrpcProcessor,\n  }\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n\n  label_list = processor.get_labels()\n\n  tokenizer = create_tokenizer_from_hub_module(FLAGS.bert_hub_module_handle)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n  model_fn = model_fn_builder(\n      num_labels=len(label_list),\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      bert_hub_module_handle=FLAGS.bert_hub_module_handle)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    train_features = run_classifier.convert_examples_to_features(\n        train_examples, label_list, FLAGS.max_seq_length, tokenizer)\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num examples = %d"", len(train_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    train_input_fn = run_classifier.input_fn_builder(\n        features=train_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_eval:\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    eval_features = run_classifier.convert_examples_to_features(\n        eval_examples, label_list, FLAGS.max_seq_length, tokenizer)\n\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Num examples = %d"", len(eval_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    # This tells the estimator to run through the entire set.\n    eval_steps = None\n    # However, if running eval on the TPU, you will need to specify the\n    # number of steps.\n    if FLAGS.use_tpu:\n      # Eval will be slightly WRONG on the TPU because it will truncate\n      # the last batch.\n      eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n\n    eval_drop_remainder = True if FLAGS.use_tpu else False\n    eval_input_fn = run_classifier.input_fn_builder(\n        features=eval_features,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=eval_drop_remainder)\n\n    result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n  if FLAGS.do_predict:\n    predict_examples = processor.get_test_examples(FLAGS.data_dir)\n    if FLAGS.use_tpu:\n      # Discard batch remainder if running on TPU\n      n = len(predict_examples)\n      predict_examples = predict_examples[:(n - n % FLAGS.predict_batch_size)]\n\n    predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n    run_classifier.file_based_convert_examples_to_features(\n        predict_examples, label_list, FLAGS.max_seq_length, tokenizer,\n        predict_file)\n\n    tf.logging.info(""***** Running prediction*****"")\n    tf.logging.info(""  Num examples = %d"", len(predict_examples))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    predict_input_fn = run_classifier.file_based_input_fn_builder(\n        input_file=predict_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=FLAGS.use_tpu)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n      tf.logging.info(""***** Predict results *****"")\n      for prediction in result:\n        probabilities = prediction[""probabilities""]\n        output_line = ""\\t"".join(\n            str(class_probability)\n            for class_probability in probabilities) + ""\\n""\n        writer.write(output_line)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""data_dir"")\n  flags.mark_flag_as_required(""task_name"")\n  flags.mark_flag_as_required(""bert_hub_module_handle"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_large_ext/run_ner.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport modeling\nimport optimization\nimport tokenization\nimport tensorflow as tf\nfrom sklearn.metrics import f1_score, precision_score, recall_score\nfrom tensorflow.python.ops import math_ops\nimport tf_metrics\nimport pickle\nimport codecs\nimport sys\n\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(\n    ""data_dir"", None,\n    ""The input datadir."",\n)\n\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model.""\n)\n\nflags.DEFINE_string(\n    ""task_name"", None, ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""token_name"", ""full"", ""The name of the task to train.""\n)\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written.""\n)\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model).""\n)\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text.""\n)\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization.""\n)\n\nflags.DEFINE_bool(\n    ""do_train"", False,\n    ""Whether to run training.""\n)\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run the model in inference mode on the test set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8, ""Total batch size for predict."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0, ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\nclass InputExample(object):\n    """"""A single training/test example for simple sequence classification.""""""\n\n    def __init__(self, guid, text, label=None):\n        """"""Constructs a InputExample.\n\n        Args:\n          guid: Unique id for the example.\n          text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n          label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid = guid\n        self.text = text\n        self.label = label\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self, input_ids, input_mask, segment_ids, label_ids, label_mask):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_ids = label_ids\n        self.label_mask = label_mask\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_data(cls, input_file):\n        """"""Reads a BIO data.""""""\n        with open(input_file) as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                word = line.strip().split(\' \')[0]\n                label = line.strip().split(\' \')[-1]\n                if contends.startswith(""-DOCSTART-""):\n                    words.append(\'\')\n                    continue\n                if len(contends) == 0 and words[-1] == \'.\':\n                    l = \' \'.join([label for label in labels if len(label) > 0])\n                    w = \' \'.join([word for word in words if len(word) > 0])\n                    lines.append([l, w])\n                    words = []\n                    labels = []\n                    continue\n                if len(contends) == 0:\n                    continue\n                words.append(word)\n                labels.append(label)\n            return lines\n\n\nclass NerProcessor(DataProcessor):\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""train.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""dev.txt"")), ""dev""\n        )\n\n    def get_test_examples(self, data_dir):\n        return self._create_example(\n            self._read_data(os.path.join(data_dir, ""test.txt"")), ""test"")\n\n    def get_labels(self):\n        # return [""I-MISC"", ""I-PER"",  ""I-ORG"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        return [""B-MISC"", ""I-MISC"", ""B-PER"", ""I-PER"", ""B-ORG"", ""I-ORG"", ""B-LOC"", ""I-LOC"", ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\nclass WeiboNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.train"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.dev"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""weiboNER.conll.test"")), ""test"")\n\n\n    def get_labels(self):\n        return [\'I-PER.NOM\', \'I-PER.NAM\', \'I-GPE.NAM\', \'I-ORG.NAM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n        # return [\'B-PER.NOM\', \'I-PER.NOM\', \'B-LOC.NAM\', \'B-PER.NAM\', \'I-PER.NAM\', \'B-GPE.NAM\', \'I-GPE.NAM\', \'B-ORG.NAM\', \'I-ORG.NAM\', \'B-ORG.NOM\', \'I-ORG.NOM\', \'I-LOC.NAM\', \'B-LOC.NOM\', \'I-LOC.NOM\', ""O"", ""X"", ""[CLS]"", ""[SEP]""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            words = []\n            labels = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                if len(tokens) == 2:\n                    words.append(tokens[0])\n                    label = tokens[-1]\n                    if label[0] == \'B\':\n                        label = ""I"" + label[1:]\n                    labels.append(label)\n                else:\n                    if len(contends) == 0 and len(words) > 0:\n                        label = []\n                        word = []\n                        for l, w in zip(labels, words):\n                            if len(l) > 0 and len(w) > 0:\n                                label.append(l)\n                                # self.labels.add(l)\n                                word.append(w)\n                        lines.append([\' \'.join(label), \' \'.join(word)])\n                        words = []\n                        labels = []\n                        continue\n                if contends.startswith(""-DOCSTART-""):\n                    continue\n\n            return lines\n\nclass MsraNERProcessor(DataProcessor):\n    def __init_(self):\n        self.labels = set()\n\n    def get_train_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""train1.txt"")), ""train""\n        )\n\n    def get_dev_examples(self, data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""dev""\n        )\n\n    def get_test_examples(self,data_dir):\n        return self._create_example(\n            self._read_raw(os.path.join(data_dir, ""testright1.txt"")), ""test"")\n\n    def get_labels(self):\n        return [\'B-PERSON\', \'I-PERSON\', \'B-LOCATION\', \'I-LOCATION\', \'B-ORGANIZATION\', \'I-ORGANIZATION\', ""O"", ""[CLS]"", ""[SEP]"", ""X""]\n\n    def _create_example(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text = tokenization.convert_to_unicode(line[1])\n            label = tokenization.convert_to_unicode(line[0])\n            examples.append(InputExample(guid=guid, text=text, label=label))\n        return examples\n\n    def _read_raw(self, input_file):\n        with codecs.open(input_file, \'r\', encoding=\'utf-8\') as f:\n            lines = []\n            chars = []\n            labels = []\n            len_count = []\n            for line in f:\n                contends = line.strip()\n                tokens = contends.split()\n                for token in tokens:\n                    word, label = token.split(\'/\')\n\n                    if label == ""nr"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-PERSON\'] + [\'I-PERSON\']*(len(word)-1)\n                    elif label == ""ns"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-LOCATION\'] + [\'I-LOCATION\']*(len(word)-1)\n                    elif label == ""nt"":\n                        chars = chars + list(word)\n                        labels = labels + [\'B-ORGANIZATION\'] + [\'I-ORGANIZATION\']*(len(word)-1)\n                    else:\n                        assert label == ""o""\n                        chars = chars + list(word)\n                        labels = labels + [""O""] * len(word)\n                lines.append([\' \'.join(labels), \' \'.join(chars)])\n                len_count.append(len(chars))\n                chars = []\n                labels = []\n            return lines\n\n\ndef write_tokens(tokens, mode):\n    if mode == ""test"":\n        path = os.path.join(FLAGS.output_dir, ""token_"" + mode + "".txt"")\n        wf = open(path, \'a\')\n        for token in tokens:\n            if token != ""**NULL**"":\n                wf.write(token + \'\\n\')\n        wf.close()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode):\n    label_map = {}\n    for (i, label) in enumerate(label_list, 1):\n        label_map[label] = i\n\n    if not os.path.exists(os.path.join(output_dir, \'label2id.pkl\')):\n        with open(os.path.join(output_dir, \'label2id.pkl\'), \'wb\') as w:\n            pickle.dump(label_map, w)\n    textlist = example.text.split(\' \')\n    labellist = example.label.split(\' \')\n    tokens = []\n    labels = []\n    label_mask = []\n    for i, word in enumerate(textlist):\n        token = tokenizer.tokenize(word)\n        tokens.extend(token)\n        label_1 = labellist[i]\n        for m in range(len(token)):\n            if m == 0:\n                labels.append(label_1)\n            else:\n                labels.append(""X"")\n    \n    # tokens = tokenizer.tokenize(example.text)\n    if len(tokens) >= max_seq_length - 1:\n        tokens = tokens[0:(max_seq_length - 2)]\n        labels = labels[0:(max_seq_length - 2)]\n    ntokens = []\n    segment_ids = []\n    label_ids = []\n    ntokens.append(""[CLS]"")\n    segment_ids.append(0)\n    # append(""O"") or append(""[CLS]"") not sure!\n    label_ids.append(label_map[""[CLS]""])\n    label_mask.append(0) # not to predict and train\n    for i, token in enumerate(tokens):\n        ntokens.append(token)\n        segment_ids.append(0)\n        label_ids.append(label_map[labels[i]])\n        if labels[i] == \'X\':\n            label_mask.append(0)\n        else:\n            label_mask.append(1)\n    ntokens.append(""[SEP]"")\n    segment_ids.append(0)\n    label_mask.append(0)\n    # append(""O"") or append(""[SEP]"") not sure!\n    label_ids.append(label_map[""[SEP]""])\n    input_ids = tokenizer.convert_tokens_to_ids(ntokens)\n    input_mask = [1] * len(input_ids)\n    # label_mask = [1] * len(input_ids)\n    while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n        # we don\'t concerned about it!\n        label_ids.append(0)\n        ntokens.append(""**NULL**"")\n        label_mask.append(0)\n    # print(len(input_ids))\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n    assert len(label_ids) == max_seq_length\n    assert len(label_mask) == max_seq_length\n\n    if ex_index < 5:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""guid: %s"" % (example.guid))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        tf.logging.info(""label_ids: %s"" % "" "".join([str(x) for x in label_ids]))\n        tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n        # tf.logging.info(""label_mask: %s"" % "" "".join([str(x) for x in label_mask]))\n\n    feature = InputFeatures(\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        label_ids=label_ids,\n        label_mask = label_mask\n    )\n    write_tokens(ntokens, mode)\n    return feature\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenizer, output_file, output_dir, mode=None\n):\n    writer = tf.python_io.TFRecordWriter(output_file)\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 5000 == 0:\n            tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n        feature = convert_single_example(ex_index, example, label_list, max_seq_length, tokenizer, output_dir, mode)\n\n        def create_int_feature(values):\n            f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n            return f\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(feature.input_ids)\n        features[""input_mask""] = create_int_feature(feature.input_mask)\n        features[""segment_ids""] = create_int_feature(feature.segment_ids)\n        features[""label_ids""] = create_int_feature(feature.label_ids)\n        features[""label_mask""] = create_int_feature(feature.label_mask)\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n        writer.write(tf_example.SerializeToString())\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n    name_to_features = {\n        ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n        ""label_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n    }\n\n    def _decode_record(record, name_to_features):\n        example = tf.parse_single_example(record, name_to_features)\n        for name in list(example.keys()):\n            t = example[name]\n            if t.dtype == tf.int64:\n                t = tf.to_int32(t)\n            example[name] = t\n        return example\n\n    def input_fn(params):\n        batch_size = params[""batch_size""]\n        d = tf.data.TFRecordDataset(input_file)\n        if is_training:\n            d = d.repeat()\n            d = d.shuffle(buffer_size=100)\n        d = d.apply(tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder\n        ))\n        return d\n\n    return input_fn\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, label_mask,\n                 segment_ids, labels, num_labels, use_one_hot_embeddings):\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings\n    )\n\n    output_layer = model.get_sequence_output()\n\n    hidden_size = output_layer.shape[-1].value\n\n    output_weight = tf.get_variable(\n        ""output_weights"", [num_labels, hidden_size],\n        initializer=tf.truncated_normal_initializer(stddev=0.02)\n    )\n    output_bias = tf.get_variable(\n        ""output_bias"", [num_labels], initializer=tf.zeros_initializer()\n    )\n    with tf.variable_scope(""loss""):\n        if is_training:\n            output_layer = tf.nn.dropout(output_layer, keep_prob=0.9)\n        output_layer = tf.reshape(output_layer, [-1, hidden_size])\n        logits = tf.matmul(output_layer, output_weight, transpose_b=True)\n        logits = tf.nn.bias_add(logits, output_bias)\n        logits = tf.reshape(logits, [-1, FLAGS.max_seq_length, num_labels])\n        # mask = tf.cast(input_mask,tf.float32)\n        # loss = tf.contrib.seq2seq.sequence_loss(logits,labels,mask)\n        # return (loss, logits, predict)\n        ##########################################################################\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)\n\n        per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n        mask = tf.cast(label_mask, tf.float32)\n        mask_example_loss = per_example_loss * mask\n        loss = tf.reduce_sum(mask_example_loss)\n        probabilities = tf.nn.softmax(logits, axis=-1)\n        predict = tf.argmax(probabilities, axis=-1)\n        return (loss, mask_example_loss, logits, predict)\n        ##########################################################################\n\n\ndef model_fn_builder(bert_config, num_labels, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n    def model_fn(features, labels, mode, params):\n        tf.logging.info(""*** Features ***"")\n        for name in sorted(features.keys()):\n            tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n        input_ids = features[""input_ids""]\n        input_mask = features[""input_mask""]\n        segment_ids = features[""segment_ids""]\n        label_ids = features[""label_ids""]\n        label_mask = features[""label_mask""]\n        is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n        (total_loss, per_example_loss, logits, predicts) = create_model(\n            bert_config, is_training, input_ids, input_mask, label_mask, segment_ids, label_ids,\n            num_labels, use_one_hot_embeddings)\n        tvars = tf.trainable_variables()\n        scaffold_fn = None\n        if init_checkpoint:\n            (assignment_map, initialized_variable_names) = modeling.get_assignment_map_from_checkpoint(tvars,\n                                                                                                       init_checkpoint)\n            tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n            if use_tpu:\n                def tpu_scaffold():\n                    tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n                    return tf.train.Scaffold()\n\n                scaffold_fn = tpu_scaffold\n            else:\n                tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        tf.logging.info(""**** Trainable Variables ****"")\n\n        for var in tvars:\n            init_string = """"\n            if var.name in initialized_variable_names:\n                init_string = "", *INIT_FROM_CKPT*""\n            tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                            init_string)\n        output_spec = None\n        if mode == tf.estimator.ModeKeys.TRAIN:\n            train_op = optimization.create_optimizer(\n                total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n            hook_dict = {}\n            hook_dict[\'loss\'] = total_loss\n            hook_dict[\'global_steps\'] = tf.train.get_or_create_global_step()\n            logging_hook = tf.train.LoggingTensorHook(\n                hook_dict, every_n_iter=200)\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                train_op=train_op,\n                scaffold_fn=scaffold_fn,\n                training_hooks=[logging_hook])\n        elif mode == tf.estimator.ModeKeys.EVAL:\n\n            def metric_fn(per_example_loss, label_ids, logits):\n                # def metric_fn(label_ids, logits):\n                predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n                # labels = []\n                # for i, x in enumerate()\n                predict_labels = []\n                # for i in range(1, num_labels - 4):\n                #     predict_labels.append(i)\n                # precision = tf_metrics.precision(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # recall = tf_metrics.recall(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n                # f = tf_metrics.f1(label_ids, predictions, num_labels, predict_labels, average=""macro"")\n\n                precision = tf_metrics.precision(label_ids, predictions, num_labels, average=""macro"")\n                recall = tf_metrics.recall(label_ids, predictions, num_labels, average=""macro"")\n                f = tf_metrics.f1(label_ids, predictions, num_labels, average=""macro"")\n\n                #\n                return {\n                    ""eval_precision"": precision,\n                    ""eval_recall"": recall,\n                    ""eval_f"": f,\n                    # ""eval_loss"": loss,\n                }\n\n            eval_metrics = (metric_fn, [per_example_loss, label_ids, logits])\n            # eval_metrics = (metric_fn, [label_ids, logits])\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode,\n                loss=total_loss,\n                eval_metrics=eval_metrics,\n                scaffold_fn=scaffold_fn)\n        else:\n            output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n                mode=mode, predictions=predicts, scaffold_fn=scaffold_fn\n            )\n        return output_spec\n\n    return model_fn\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    processors = {\n        ""ner"": NerProcessor,\n        ""weiboner"": WeiboNERProcessor,\n        ""msraner"": MsraNERProcessor\n    }\n    # if not FLAGS.do_train and not FLAGS.do_eval:\n    #     raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n    bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n    if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n        raise ValueError(\n            ""Cannot use sequence length %d because the BERT model ""\n            ""was only trained up to sequence length %d"" %\n            (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n    if not os.path.exists(FLAGS.output_dir):\n        os.mkdir(FLAGS.output_dir)\n    task_name = FLAGS.task_name.lower()\n    if task_name not in processors:\n        raise ValueError(""Task not found: %s"" % (task_name))\n    processor = processors[task_name]()\n\n    label_list = processor.get_labels()\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    tpu_cluster_resolver = None\n    if FLAGS.use_tpu and FLAGS.tpu_name:\n        tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n            FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n    is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n\n    run_config = tf.contrib.tpu.RunConfig(\n        cluster=tpu_cluster_resolver,\n        master=FLAGS.master,\n        model_dir=FLAGS.output_dir,\n        save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n        tpu_config=tf.contrib.tpu.TPUConfig(\n            iterations_per_loop=FLAGS.iterations_per_loop,\n            num_shards=FLAGS.num_tpu_cores,\n            per_host_input_for_training=is_per_host))\n\n    train_examples = None\n    num_train_steps = None\n    num_warmup_steps = None\n\n    if FLAGS.do_train:\n        train_examples = processor.get_train_examples(FLAGS.data_dir)\n        num_train_steps = int(\n            len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n        print(num_train_steps)\n        num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    model_fn = model_fn_builder(\n        bert_config=bert_config,\n        num_labels=len(label_list) + 1,\n        init_checkpoint=FLAGS.init_checkpoint,\n        learning_rate=FLAGS.learning_rate,\n        num_train_steps=num_train_steps,\n        num_warmup_steps=num_warmup_steps,\n        use_tpu=FLAGS.use_tpu,\n        use_one_hot_embeddings=FLAGS.use_tpu)\n\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n\n    if FLAGS.do_train:\n        train_file = os.path.join(FLAGS.output_dir, ""train.tf_record"")\n        file_based_convert_examples_to_features(\n            train_examples, label_list, FLAGS.max_seq_length, tokenizer, train_file, FLAGS.output_dir)\n        tf.logging.info(""***** Running training *****"")\n        tf.logging.info(""  Num examples = %d"", len(train_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n        tf.logging.info(""  Num steps = %d"", num_train_steps)\n        train_input_fn = file_based_input_fn_builder(\n            input_file=train_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=True,\n            drop_remainder=True)\n        estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n    if FLAGS.do_eval:\n        eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n        eval_file = os.path.join(FLAGS.output_dir, ""eval.tf_record"")\n        file_based_convert_examples_to_features(\n            eval_examples, label_list, FLAGS.max_seq_length, tokenizer, eval_file, FLAGS.output_dir)\n\n        tf.logging.info(""***** Running evaluation *****"")\n        tf.logging.info(""  Num examples = %d"", len(eval_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n        eval_steps = None\n        if FLAGS.use_tpu:\n            eval_steps = int(len(eval_examples) / FLAGS.eval_batch_size)\n        eval_drop_remainder = True if FLAGS.use_tpu else False\n        eval_input_fn = file_based_input_fn_builder(\n            input_file=eval_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=eval_drop_remainder)\n        result = estimator.evaluate(input_fn=eval_input_fn, steps=eval_steps)\n        output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            tf.logging.info(""***** Eval results *****"")\n            for key in sorted(result.keys()):\n                tf.logging.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\n    if FLAGS.do_predict:\n\n        pred_tags = []\n        true_tags = []\n\n        token_path = os.path.join(FLAGS.output_dir, ""token_test.txt"")\n        label_file = os.path.join(FLAGS.output_dir, ""label2id.pkl"")\n        label_masks = []\n        with open(label_file, ""rb"") as rf:\n            label2id = pickle.load(rf)\n            id2label = {value: key for key, value in label2id.items()}\n        if os.path.exists(token_path):\n            os.remove(token_path)\n        predict_examples = processor.get_test_examples(FLAGS.data_dir)\n        ground_truth_file = os.path.join(FLAGS.output_dir, ""ground_truth.txt"")\n        with open(ground_truth_file, \'w\') as writer:\n            for ex_index, example in enumerate(predict_examples):\n                feature = convert_single_example(ex_index, example, label_list, FLAGS.max_seq_length, tokenizer, FLAGS.output_dir, ""test"")\n                line = []\n                for i, id in enumerate(feature.label_ids):\n                    if feature.label_mask[i] == 1:\n                        line.append(id2label[id])\n                        true_tags.append(id2label[id])\n                # output_line = "" "".join(id2label[id] for id in feature.label_ids if id != 0) + ""\\n""\n                output_line = "" "".join(line) + ""\\n""\n                writer.write(output_line)\n                label_masks.append(feature.label_mask)\n        predict_file = os.path.join(FLAGS.output_dir, ""predict.tf_record"")\n        file_based_convert_examples_to_features(predict_examples, label_list,\n                                                 FLAGS.max_seq_length, tokenizer,\n                                                 predict_file, FLAGS.output_dir, mode=""test"")\n\n        tf.logging.info(""***** Running prediction*****"")\n        tf.logging.info(""  Num examples = %d"", len(predict_examples))\n        tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n        if FLAGS.use_tpu:\n            # Warning: According to tpu_estimator.py Prediction on TPU is an\n            # experimental feature and hence not supported here\n            raise ValueError(""Prediction in TPU not supported"")\n        predict_drop_remainder = True if FLAGS.use_tpu else False\n        predict_input_fn = file_based_input_fn_builder(\n            input_file=predict_file,\n            seq_length=FLAGS.max_seq_length,\n            is_training=False,\n            drop_remainder=predict_drop_remainder)\n\n        result = estimator.predict(input_fn=predict_input_fn)\n        output_predict_file = os.path.join(FLAGS.output_dir, ""label_test.txt"")\n\n        with open(output_predict_file, \'w\') as writer:\n            for i, prediction in enumerate(result):\n                line = []\n                for j, x in enumerate(prediction):\n                    if label_masks[i][j] == 0:\n                        continue\n                    else:\n                        line.append(id2label[x])\n                        # writer.write(id2label[x] + ""\\n"")\n                        pred_tags.append(id2label[x])\n                output_line = "" "".join(line) + ""\\n""\n                # # output_line = "" "".join(id2label[id] for id in prediction if id != 0) + ""\\n""\n                writer.write(output_line)\n        # evaluate(true_tags, pred_tags, verbose=True)\n        # evaluate(true_tags, pred_tags)\n\n        tmp = codecs.open(os.path.join(FLAGS.output_dir, ""tmp""), \'w\', \'utf8\')\n        with codecs.open(ground_truth_file, \'r\', \'utf8\') as ft, codecs.open(output_predict_file, \'r\', \'utf8\') as fg:\n            for lt, lg in zip(ft, fg):\n                for tl, tg in zip(lt.strip().split(), lg.strip().split()):\n                    print(\'\\t\'.join(["" "", tl, tg]), file=tmp)\n        tmp.close()\n        cmd = ""python %s -d \'\\t\' < %s > %s"" % \\\n                (os.path.join(os.getcwd(), ""conlleval.py""), \\\n                os.path.join(FLAGS.output_dir, ""tmp""), \\\n                os.path.join(FLAGS.data_dir, ""test_results_roberta_wwm_large_ext.txt""))\n        os.system(cmd)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""data_dir"")\n    flags.mark_flag_as_required(""task_name"")\n    flags.mark_flag_as_required(""vocab_file"")\n    flags.mark_flag_as_required(""bert_config_file"")\n    flags.mark_flag_as_required(""output_dir"")\n    tf.app.run()\n'"
baselines/models/roberta_wwm_large_ext/run_pretraining.py,97,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run masked LM/next sentence masked_lm pre-training for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport modeling\nimport optimization\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(\n    ""input_file"", None,\n    ""Input TF example files (can be a glob or comma separated)."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 128,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded. Must match data generation."")\n\nflags.DEFINE_integer(\n    ""max_predictions_per_seq"", 20,\n    ""Maximum number of masked LM predictions per sequence. ""\n    ""Must match data generation."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_eval"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""eval_batch_size"", 8, ""Total batch size for eval."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_integer(""num_train_steps"", 100000, ""Number of training steps."")\n\nflags.DEFINE_integer(""num_warmup_steps"", 10000, ""Number of warmup steps."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(""max_eval_steps"", 100, ""Maximum number of eval steps."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n    masked_lm_positions = features[""masked_lm_positions""]\n    masked_lm_ids = features[""masked_lm_ids""]\n    masked_lm_weights = features[""masked_lm_weights""]\n    next_sentence_labels = features[""next_sentence_labels""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    model = modeling.BertModel(\n        config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        token_type_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    (masked_lm_loss,\n     masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(\n         bert_config, model.get_sequence_output(), model.get_embedding_table(),\n         masked_lm_positions, masked_lm_ids, masked_lm_weights)\n\n    (next_sentence_loss, next_sentence_example_loss,\n     next_sentence_log_probs) = get_next_sentence_output(\n         bert_config, model.get_pooled_output(), next_sentence_labels)\n\n    total_loss = masked_lm_loss + next_sentence_loss\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.EVAL:\n\n      def metric_fn(masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n                    masked_lm_weights, next_sentence_example_loss,\n                    next_sentence_log_probs, next_sentence_labels):\n        """"""Computes the loss and accuracy of the model.""""""\n        masked_lm_log_probs = tf.reshape(masked_lm_log_probs,\n                                         [-1, masked_lm_log_probs.shape[-1]])\n        masked_lm_predictions = tf.argmax(\n            masked_lm_log_probs, axis=-1, output_type=tf.int32)\n        masked_lm_example_loss = tf.reshape(masked_lm_example_loss, [-1])\n        masked_lm_ids = tf.reshape(masked_lm_ids, [-1])\n        masked_lm_weights = tf.reshape(masked_lm_weights, [-1])\n        masked_lm_accuracy = tf.metrics.accuracy(\n            labels=masked_lm_ids,\n            predictions=masked_lm_predictions,\n            weights=masked_lm_weights)\n        masked_lm_mean_loss = tf.metrics.mean(\n            values=masked_lm_example_loss, weights=masked_lm_weights)\n\n        next_sentence_log_probs = tf.reshape(\n            next_sentence_log_probs, [-1, next_sentence_log_probs.shape[-1]])\n        next_sentence_predictions = tf.argmax(\n            next_sentence_log_probs, axis=-1, output_type=tf.int32)\n        next_sentence_labels = tf.reshape(next_sentence_labels, [-1])\n        next_sentence_accuracy = tf.metrics.accuracy(\n            labels=next_sentence_labels, predictions=next_sentence_predictions)\n        next_sentence_mean_loss = tf.metrics.mean(\n            values=next_sentence_example_loss)\n\n        return {\n            ""masked_lm_accuracy"": masked_lm_accuracy,\n            ""masked_lm_loss"": masked_lm_mean_loss,\n            ""next_sentence_accuracy"": next_sentence_accuracy,\n            ""next_sentence_loss"": next_sentence_mean_loss,\n        }\n\n      eval_metrics = (metric_fn, [\n          masked_lm_example_loss, masked_lm_log_probs, masked_lm_ids,\n          masked_lm_weights, next_sentence_example_loss,\n          next_sentence_log_probs, next_sentence_labels\n      ])\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          eval_metrics=eval_metrics,\n          scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(""Only TRAIN and EVAL modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef get_masked_lm_output(bert_config, input_tensor, output_weights, positions,\n                         label_ids, label_weights):\n  """"""Get loss and log probs for the masked LM.""""""\n  input_tensor = gather_indexes(input_tensor, positions)\n\n  with tf.variable_scope(""cls/predictions""):\n    # We apply one more non-linear transformation before the output layer.\n    # This matrix is not used after pre-training.\n    with tf.variable_scope(""transform""):\n      input_tensor = tf.layers.dense(\n          input_tensor,\n          units=bert_config.hidden_size,\n          activation=modeling.get_activation(bert_config.hidden_act),\n          kernel_initializer=modeling.create_initializer(\n              bert_config.initializer_range))\n      input_tensor = modeling.layer_norm(input_tensor)\n\n    # The output weights are the same as the input embeddings, but there is\n    # an output-only bias for each token.\n    output_bias = tf.get_variable(\n        ""output_bias"",\n        shape=[bert_config.vocab_size],\n        initializer=tf.zeros_initializer())\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n\n    label_ids = tf.reshape(label_ids, [-1])\n    label_weights = tf.reshape(label_weights, [-1])\n\n    one_hot_labels = tf.one_hot(\n        label_ids, depth=bert_config.vocab_size, dtype=tf.float32)\n\n    # The `positions` tensor might be zero-padded (if the sequence is too\n    # short to have the maximum number of predictions). The `label_weights`\n    # tensor has a value of 1.0 for every real prediction and 0.0 for the\n    # padding predictions.\n    per_example_loss = -tf.reduce_sum(log_probs * one_hot_labels, axis=[-1])\n    numerator = tf.reduce_sum(label_weights * per_example_loss)\n    denominator = tf.reduce_sum(label_weights) + 1e-5\n    loss = numerator / denominator\n\n  return (loss, per_example_loss, log_probs)\n\n\ndef get_next_sentence_output(bert_config, input_tensor, labels):\n  """"""Get loss and log probs for the next sentence prediction.""""""\n\n  # Simple binary classification. Note that 0 is ""next sentence"" and 1 is\n  # ""random sentence"". This weight matrix is not used after pre-training.\n  with tf.variable_scope(""cls/seq_relationship""):\n    output_weights = tf.get_variable(\n        ""output_weights"",\n        shape=[2, bert_config.hidden_size],\n        initializer=modeling.create_initializer(bert_config.initializer_range))\n    output_bias = tf.get_variable(\n        ""output_bias"", shape=[2], initializer=tf.zeros_initializer())\n\n    logits = tf.matmul(input_tensor, output_weights, transpose_b=True)\n    logits = tf.nn.bias_add(logits, output_bias)\n    log_probs = tf.nn.log_softmax(logits, axis=-1)\n    labels = tf.reshape(labels, [-1])\n    one_hot_labels = tf.one_hot(labels, depth=2, dtype=tf.float32)\n    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=-1)\n    loss = tf.reduce_mean(per_example_loss)\n    return (loss, per_example_loss, log_probs)\n\n\ndef gather_indexes(sequence_tensor, positions):\n  """"""Gathers the vectors at the specific positions over a minibatch.""""""\n  sequence_shape = modeling.get_shape_list(sequence_tensor, expected_rank=3)\n  batch_size = sequence_shape[0]\n  seq_length = sequence_shape[1]\n  width = sequence_shape[2]\n\n  flat_offsets = tf.reshape(\n      tf.range(0, batch_size, dtype=tf.int32) * seq_length, [-1, 1])\n  flat_positions = tf.reshape(positions + flat_offsets, [-1])\n  flat_sequence_tensor = tf.reshape(sequence_tensor,\n                                    [batch_size * seq_length, width])\n  output_tensor = tf.gather(flat_sequence_tensor, flat_positions)\n  return output_tensor\n\n\ndef input_fn_builder(input_files,\n                     max_seq_length,\n                     max_predictions_per_seq,\n                     is_training,\n                     num_cpu_threads=4):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    name_to_features = {\n        ""input_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""input_mask"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""segment_ids"":\n            tf.FixedLenFeature([max_seq_length], tf.int64),\n        ""masked_lm_positions"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_ids"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.int64),\n        ""masked_lm_weights"":\n            tf.FixedLenFeature([max_predictions_per_seq], tf.float32),\n        ""next_sentence_labels"":\n            tf.FixedLenFeature([1], tf.int64),\n    }\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = tf.data.Dataset.from_tensor_slices(tf.constant(input_files))\n      d = d.repeat()\n      d = d.shuffle(buffer_size=len(input_files))\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_cpu_threads, len(input_files))\n\n      # `sloppy` mode means that the interleaving is not exact. This adds\n      # even more randomness to the training pipeline.\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n      d = d.shuffle(buffer_size=100)\n    else:\n      d = tf.data.TFRecordDataset(input_files)\n      # Since we evaluate for a fixed number of steps we don\'t want to encounter\n      # out-of-range exceptions.\n      d = d.repeat()\n\n    # We must `drop_remainder` on training because the TPU requires fixed\n    # size dimensions. For eval, we assume we are evaluating on the CPU or GPU\n    # and we *don\'t* want to drop the remainder, otherwise we wont cover\n    # every sample.\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_cpu_threads,\n            drop_remainder=True))\n    return d\n\n  return input_fn\n\n\ndef _decode_record(record, name_to_features):\n  """"""Decodes a record to a TensorFlow example.""""""\n  example = tf.parse_single_example(record, name_to_features)\n\n  # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n  # So cast all int64 to int32.\n  for name in list(example.keys()):\n    t = example[name]\n    if t.dtype == tf.int64:\n      t = tf.to_int32(t)\n    example[name] = t\n\n  return example\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not FLAGS.do_train and not FLAGS.do_eval:\n    raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  input_files = []\n  for input_pattern in FLAGS.input_file.split("",""):\n    input_files.extend(tf.gfile.Glob(input_pattern))\n\n  tf.logging.info(""*** Input Files ***"")\n  for input_file in input_files:\n    tf.logging.info(""  %s"" % input_file)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=FLAGS.num_train_steps,\n      num_warmup_steps=FLAGS.num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      eval_batch_size=FLAGS.eval_batch_size)\n\n  if FLAGS.do_train:\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    train_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=True)\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.num_train_steps)\n\n  if FLAGS.do_eval:\n    tf.logging.info(""***** Running evaluation *****"")\n    tf.logging.info(""  Batch size = %d"", FLAGS.eval_batch_size)\n\n    eval_input_fn = input_fn_builder(\n        input_files=input_files,\n        max_seq_length=FLAGS.max_seq_length,\n        max_predictions_per_seq=FLAGS.max_predictions_per_seq,\n        is_training=False)\n\n    result = estimator.evaluate(\n        input_fn=eval_input_fn, steps=FLAGS.max_eval_steps)\n\n    output_eval_file = os.path.join(FLAGS.output_dir, ""eval_results.txt"")\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      tf.logging.info(""***** Eval results *****"")\n      for key in sorted(result.keys()):\n        tf.logging.info(""  %s = %s"", key, str(result[key]))\n        writer.write(""%s = %s\\n"" % (key, str(result[key])))\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""input_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_large_ext/run_squad.py,93,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Run BERT on SQuAD 1.1 and SQuAD 2.0.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport json\nimport math\nimport os\nimport random\nimport modeling\nimport optimization\nimport tokenization\nimport six\nimport tensorflow as tf\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\n## Required parameters\nflags.DEFINE_string(\n    ""bert_config_file"", None,\n    ""The config json file corresponding to the pre-trained BERT model. ""\n    ""This specifies the model architecture."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_string(\n    ""output_dir"", None,\n    ""The output directory where the model checkpoints will be written."")\n\n## Other parameters\nflags.DEFINE_string(""train_file"", None,\n                    ""SQuAD json for training. E.g., train-v1.1.json"")\n\nflags.DEFINE_string(\n    ""predict_file"", None,\n    ""SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json"")\n\nflags.DEFINE_string(\n    ""init_checkpoint"", None,\n    ""Initial checkpoint (usually from a pre-trained BERT model)."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_integer(\n    ""max_seq_length"", 384,\n    ""The maximum total input sequence length after WordPiece tokenization. ""\n    ""Sequences longer than this will be truncated, and sequences shorter ""\n    ""than this will be padded."")\n\nflags.DEFINE_integer(\n    ""doc_stride"", 128,\n    ""When splitting up a long document into chunks, how much stride to ""\n    ""take between chunks."")\n\nflags.DEFINE_integer(\n    ""max_query_length"", 64,\n    ""The maximum number of tokens for the question. Questions longer than ""\n    ""this will be truncated to this length."")\n\nflags.DEFINE_bool(""do_train"", False, ""Whether to run training."")\n\nflags.DEFINE_bool(""do_predict"", False, ""Whether to run eval on the dev set."")\n\nflags.DEFINE_integer(""train_batch_size"", 32, ""Total batch size for training."")\n\nflags.DEFINE_integer(""predict_batch_size"", 8,\n                     ""Total batch size for predictions."")\n\nflags.DEFINE_float(""learning_rate"", 5e-5, ""The initial learning rate for Adam."")\n\nflags.DEFINE_float(""num_train_epochs"", 3.0,\n                   ""Total number of training epochs to perform."")\n\nflags.DEFINE_float(\n    ""warmup_proportion"", 0.1,\n    ""Proportion of training to perform linear learning rate warmup for. ""\n    ""E.g., 0.1 = 10% of training."")\n\nflags.DEFINE_integer(""save_checkpoints_steps"", 1000,\n                     ""How often to save the model checkpoint."")\n\nflags.DEFINE_integer(""iterations_per_loop"", 1000,\n                     ""How many steps to make in each estimator call."")\n\nflags.DEFINE_integer(\n    ""n_best_size"", 20,\n    ""The total number of n-best predictions to generate in the ""\n    ""nbest_predictions.json output file."")\n\nflags.DEFINE_integer(\n    ""max_answer_length"", 30,\n    ""The maximum length of an answer that can be generated. This is needed ""\n    ""because the start and end predictions are not conditioned on one another."")\n\nflags.DEFINE_bool(""use_tpu"", False, ""Whether to use TPU or GPU/CPU."")\n\ntf.flags.DEFINE_string(\n    ""tpu_name"", None,\n    ""The Cloud TPU to use for training. This should be either the name ""\n    ""used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 ""\n    ""url."")\n\ntf.flags.DEFINE_string(\n    ""tpu_zone"", None,\n    ""[Optional] GCE zone where the Cloud TPU is located in. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(\n    ""gcp_project"", None,\n    ""[Optional] Project name for the Cloud TPU-enabled project. If not ""\n    ""specified, we will attempt to automatically detect the GCE project from ""\n    ""metadata."")\n\ntf.flags.DEFINE_string(""master"", None, ""[Optional] TensorFlow master URL."")\n\nflags.DEFINE_integer(\n    ""num_tpu_cores"", 8,\n    ""Only used if `use_tpu` is True. Total number of TPU cores to use."")\n\nflags.DEFINE_bool(\n    ""verbose_logging"", False,\n    ""If true, all of the warnings related to data processing will be printed. ""\n    ""A number of warnings are expected for a normal SQuAD evaluation."")\n\nflags.DEFINE_bool(\n    ""version_2_with_negative"", False,\n    ""If true, the SQuAD examples contain some that do not have an answer."")\n\nflags.DEFINE_float(\n    ""null_score_diff_threshold"", 0.0,\n    ""If null_score - best_non_null is greater than the threshold predict null."")\n\n\nclass SquadExample(object):\n  """"""A single training/test example for simple sequence classification.\n\n     For examples without an answer, the start and end position are -1.\n  """"""\n\n  def __init__(self,\n               qas_id,\n               question_text,\n               doc_tokens,\n               orig_answer_text=None,\n               start_position=None,\n               end_position=None,\n               is_impossible=False):\n    self.qas_id = qas_id\n    self.question_text = question_text\n    self.doc_tokens = doc_tokens\n    self.orig_answer_text = orig_answer_text\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n  def __str__(self):\n    return self.__repr__()\n\n  def __repr__(self):\n    s = """"\n    s += ""qas_id: %s"" % (tokenization.printable_text(self.qas_id))\n    s += "", question_text: %s"" % (\n        tokenization.printable_text(self.question_text))\n    s += "", doc_tokens: [%s]"" % ("" "".join(self.doc_tokens))\n    if self.start_position:\n      s += "", start_position: %d"" % (self.start_position)\n    if self.start_position:\n      s += "", end_position: %d"" % (self.end_position)\n    if self.start_position:\n      s += "", is_impossible: %r"" % (self.is_impossible)\n    return s\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tokens,\n               token_to_orig_map,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               segment_ids,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tokens = tokens\n    self.token_to_orig_map = token_to_orig_map\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\ndef read_squad_examples(input_file, is_training):\n  """"""Read a SQuAD json file into a list of SquadExample.""""""\n  with tf.gfile.Open(input_file, ""r"") as reader:\n    input_data = json.load(reader)[""data""]\n\n  def is_whitespace(c):\n    if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F:\n      return True\n    return False\n\n  examples = []\n  for entry in input_data:\n    for paragraph in entry[""paragraphs""]:\n      paragraph_text = paragraph[""context""]\n      doc_tokens = []\n      char_to_word_offset = []\n      prev_is_whitespace = True\n      for c in paragraph_text:\n        if is_whitespace(c):\n          prev_is_whitespace = True\n        else:\n          if prev_is_whitespace:\n            doc_tokens.append(c)\n          else:\n            doc_tokens[-1] += c\n          prev_is_whitespace = False\n        char_to_word_offset.append(len(doc_tokens) - 1)\n\n      for qa in paragraph[""qas""]:\n        qas_id = qa[""id""]\n        question_text = qa[""question""]\n        start_position = None\n        end_position = None\n        orig_answer_text = None\n        is_impossible = False\n        if is_training:\n\n          if FLAGS.version_2_with_negative:\n            is_impossible = qa[""is_impossible""]\n          if (len(qa[""answers""]) != 1) and (not is_impossible):\n            raise ValueError(\n                ""For training, each question should have exactly 1 answer."")\n          if not is_impossible:\n            answer = qa[""answers""][0]\n            orig_answer_text = answer[""text""]\n            answer_offset = answer[""answer_start""]\n            answer_length = len(orig_answer_text)\n            start_position = char_to_word_offset[answer_offset]\n            end_position = char_to_word_offset[answer_offset + answer_length -\n                                               1]\n            # Only add answers where the text can be exactly recovered from the\n            # document. If this CAN\'T happen it\'s likely due to weird Unicode\n            # stuff so we will just skip the example.\n            #\n            # Note that this means for training mode, every example is NOT\n            # guaranteed to be preserved.\n            actual_text = "" "".join(\n                doc_tokens[start_position:(end_position + 1)])\n            cleaned_answer_text = "" "".join(\n                tokenization.whitespace_tokenize(orig_answer_text))\n            if actual_text.find(cleaned_answer_text) == -1:\n              tf.logging.warning(""Could not find answer: \'%s\' vs. \'%s\'"",\n                                 actual_text, cleaned_answer_text)\n              continue\n          else:\n            start_position = -1\n            end_position = -1\n            orig_answer_text = """"\n\n        example = SquadExample(\n            qas_id=qas_id,\n            question_text=question_text,\n            doc_tokens=doc_tokens,\n            orig_answer_text=orig_answer_text,\n            start_position=start_position,\n            end_position=end_position,\n            is_impossible=is_impossible)\n        examples.append(example)\n\n  return examples\n\n\ndef convert_examples_to_features(examples, tokenizer, max_seq_length,\n                                 doc_stride, max_query_length, is_training,\n                                 output_fn):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  unique_id = 1000000000\n\n  for (example_index, example) in enumerate(examples):\n    query_tokens = tokenizer.tokenize(example.question_text)\n\n    if len(query_tokens) > max_query_length:\n      query_tokens = query_tokens[0:max_query_length]\n\n    tok_to_orig_index = []\n    orig_to_tok_index = []\n    all_doc_tokens = []\n    for (i, token) in enumerate(example.doc_tokens):\n      orig_to_tok_index.append(len(all_doc_tokens))\n      sub_tokens = tokenizer.tokenize(token)\n      for sub_token in sub_tokens:\n        tok_to_orig_index.append(i)\n        all_doc_tokens.append(sub_token)\n\n    tok_start_position = None\n    tok_end_position = None\n    if is_training and example.is_impossible:\n      tok_start_position = -1\n      tok_end_position = -1\n    if is_training and not example.is_impossible:\n      tok_start_position = orig_to_tok_index[example.start_position]\n      if example.end_position < len(example.doc_tokens) - 1:\n        tok_end_position = orig_to_tok_index[example.end_position + 1] - 1\n      else:\n        tok_end_position = len(all_doc_tokens) - 1\n      (tok_start_position, tok_end_position) = _improve_answer_span(\n          all_doc_tokens, tok_start_position, tok_end_position, tokenizer,\n          example.orig_answer_text)\n\n    # The -3 accounts for [CLS], [SEP] and [SEP]\n    max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n    # We can have documents that are longer than the maximum sequence length.\n    # To deal with this we do a sliding window approach, where we take chunks\n    # of the up to our max length with a stride of `doc_stride`.\n    _DocSpan = collections.namedtuple(  # pylint: disable=invalid-name\n        ""DocSpan"", [""start"", ""length""])\n    doc_spans = []\n    start_offset = 0\n    while start_offset < len(all_doc_tokens):\n      length = len(all_doc_tokens) - start_offset\n      if length > max_tokens_for_doc:\n        length = max_tokens_for_doc\n      doc_spans.append(_DocSpan(start=start_offset, length=length))\n      if start_offset + length == len(all_doc_tokens):\n        break\n      start_offset += min(length, doc_stride)\n\n    for (doc_span_index, doc_span) in enumerate(doc_spans):\n      tokens = []\n      token_to_orig_map = {}\n      token_is_max_context = {}\n      segment_ids = []\n      tokens.append(""[CLS]"")\n      segment_ids.append(0)\n      for token in query_tokens:\n        tokens.append(token)\n        segment_ids.append(0)\n      tokens.append(""[SEP]"")\n      segment_ids.append(0)\n\n      for i in range(doc_span.length):\n        split_token_index = doc_span.start + i\n        token_to_orig_map[len(tokens)] = tok_to_orig_index[split_token_index]\n\n        is_max_context = _check_is_max_context(doc_spans, doc_span_index,\n                                               split_token_index)\n        token_is_max_context[len(tokens)] = is_max_context\n        tokens.append(all_doc_tokens[split_token_index])\n        segment_ids.append(1)\n      tokens.append(""[SEP]"")\n      segment_ids.append(1)\n\n      input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n      # The mask has 1 for real tokens and 0 for padding tokens. Only real\n      # tokens are attended to.\n      input_mask = [1] * len(input_ids)\n\n      # Zero-pad up to the sequence length.\n      while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n\n      assert len(input_ids) == max_seq_length\n      assert len(input_mask) == max_seq_length\n      assert len(segment_ids) == max_seq_length\n\n      start_position = None\n      end_position = None\n      if is_training and not example.is_impossible:\n        # For training, if our document chunk does not contain an annotation\n        # we throw it out, since there is nothing to predict.\n        doc_start = doc_span.start\n        doc_end = doc_span.start + doc_span.length - 1\n        out_of_span = False\n        if not (tok_start_position >= doc_start and\n                tok_end_position <= doc_end):\n          out_of_span = True\n        if out_of_span:\n          start_position = 0\n          end_position = 0\n        else:\n          doc_offset = len(query_tokens) + 2\n          start_position = tok_start_position - doc_start + doc_offset\n          end_position = tok_end_position - doc_start + doc_offset\n\n      if is_training and example.is_impossible:\n        start_position = 0\n        end_position = 0\n\n      if example_index < 20:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""unique_id: %s"" % (unique_id))\n        tf.logging.info(""example_index: %s"" % (example_index))\n        tf.logging.info(""doc_span_index: %s"" % (doc_span_index))\n        tf.logging.info(""tokens: %s"" % "" "".join(\n            [tokenization.printable_text(x) for x in tokens]))\n        tf.logging.info(""token_to_orig_map: %s"" % "" "".join(\n            [""%d:%d"" % (x, y) for (x, y) in six.iteritems(token_to_orig_map)]))\n        tf.logging.info(""token_is_max_context: %s"" % "" "".join([\n            ""%d:%s"" % (x, y) for (x, y) in six.iteritems(token_is_max_context)\n        ]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(\n            ""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(\n            ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n        if is_training and example.is_impossible:\n          tf.logging.info(""impossible example"")\n        if is_training and not example.is_impossible:\n          answer_text = "" "".join(tokens[start_position:(end_position + 1)])\n          tf.logging.info(""start_position: %d"" % (start_position))\n          tf.logging.info(""end_position: %d"" % (end_position))\n          tf.logging.info(\n              ""answer: %s"" % (tokenization.printable_text(answer_text)))\n\n      feature = InputFeatures(\n          unique_id=unique_id,\n          example_index=example_index,\n          doc_span_index=doc_span_index,\n          tokens=tokens,\n          token_to_orig_map=token_to_orig_map,\n          token_is_max_context=token_is_max_context,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          segment_ids=segment_ids,\n          start_position=start_position,\n          end_position=end_position,\n          is_impossible=example.is_impossible)\n\n      # Run callback\n      output_fn(feature)\n\n      unique_id += 1\n\n\ndef _improve_answer_span(doc_tokens, input_start, input_end, tokenizer,\n                         orig_answer_text):\n  """"""Returns tokenized answer spans that better match the annotated answer.""""""\n\n  # The SQuAD annotations are character based. We first project them to\n  # whitespace-tokenized words. But then after WordPiece tokenization, we can\n  # often find a ""better match"". For example:\n  #\n  #   Question: What year was John Smith born?\n  #   Context: The leader was John Smith (1895-1943).\n  #   Answer: 1895\n  #\n  # The original whitespace-tokenized answer will be ""(1895-1943)."". However\n  # after tokenization, our tokens will be ""( 1895 - 1943 ) ."". So we can match\n  # the exact answer, 1895.\n  #\n  # However, this is not always possible. Consider the following:\n  #\n  #   Question: What country is the top exporter of electornics?\n  #   Context: The Japanese electronics industry is the lagest in the world.\n  #   Answer: Japan\n  #\n  # In this case, the annotator chose ""Japan"" as a character sub-span of\n  # the word ""Japanese"". Since our WordPiece tokenizer does not split\n  # ""Japanese"", we just use ""Japanese"" as the annotation. This is fairly rare\n  # in SQuAD, but does happen.\n  tok_answer_text = "" "".join(tokenizer.tokenize(orig_answer_text))\n\n  for new_start in range(input_start, input_end + 1):\n    for new_end in range(input_end, new_start - 1, -1):\n      text_span = "" "".join(doc_tokens[new_start:(new_end + 1)])\n      if text_span == tok_answer_text:\n        return (new_start, new_end)\n\n  return (input_start, input_end)\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n  """"""Check if this is the \'max context\' doc span for the token.""""""\n\n  # Because of the sliding window approach taken to scoring documents, a single\n  # token can appear in multiple documents. E.g.\n  #  Doc: the man went to the store and bought a gallon of milk\n  #  Span A: the man went to the\n  #  Span B: to the store and bought\n  #  Span C: and bought a gallon of\n  #  ...\n  #\n  # Now the word \'bought\' will have two scores from spans B and C. We only\n  # want to consider the score with ""maximum context"", which we define as\n  # the *minimum* of its left and right context (the *sum* of left and\n  # right context will always be the same, of course).\n  #\n  # In the example the maximum context for \'bought\' would be span C since\n  # it has 1 left context and 3 right context, while span B has 4 left context\n  # and 0 right context.\n  best_score = None\n  best_span_index = None\n  for (span_index, doc_span) in enumerate(doc_spans):\n    end = doc_span.start + doc_span.length - 1\n    if position < doc_span.start:\n      continue\n    if position > end:\n      continue\n    num_left_context = position - doc_span.start\n    num_right_context = end - position\n    score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n    if best_score is None or score > best_score:\n      best_score = score\n      best_span_index = span_index\n\n  return cur_span_index == best_span_index\n\n\ndef create_model(bert_config, is_training, input_ids, input_mask, segment_ids,\n                 use_one_hot_embeddings):\n  """"""Creates a classification model.""""""\n  model = modeling.BertModel(\n      config=bert_config,\n      is_training=is_training,\n      input_ids=input_ids,\n      input_mask=input_mask,\n      token_type_ids=segment_ids,\n      use_one_hot_embeddings=use_one_hot_embeddings)\n\n  final_hidden = model.get_sequence_output()\n\n  final_hidden_shape = modeling.get_shape_list(final_hidden, expected_rank=3)\n  batch_size = final_hidden_shape[0]\n  seq_length = final_hidden_shape[1]\n  hidden_size = final_hidden_shape[2]\n\n  output_weights = tf.get_variable(\n      ""cls/squad/output_weights"", [2, hidden_size],\n      initializer=tf.truncated_normal_initializer(stddev=0.02))\n\n  output_bias = tf.get_variable(\n      ""cls/squad/output_bias"", [2], initializer=tf.zeros_initializer())\n\n  final_hidden_matrix = tf.reshape(final_hidden,\n                                   [batch_size * seq_length, hidden_size])\n  logits = tf.matmul(final_hidden_matrix, output_weights, transpose_b=True)\n  logits = tf.nn.bias_add(logits, output_bias)\n\n  logits = tf.reshape(logits, [batch_size, seq_length, 2])\n  logits = tf.transpose(logits, [2, 0, 1])\n\n  unstacked_logits = tf.unstack(logits, axis=0)\n\n  (start_logits, end_logits) = (unstacked_logits[0], unstacked_logits[1])\n\n  return (start_logits, end_logits)\n\n\ndef model_fn_builder(bert_config, init_checkpoint, learning_rate,\n                     num_train_steps, num_warmup_steps, use_tpu,\n                     use_one_hot_embeddings):\n  """"""Returns `model_fn` closure for TPUEstimator.""""""\n\n  def model_fn(features, labels, mode, params):  # pylint: disable=unused-argument\n    """"""The `model_fn` for TPUEstimator.""""""\n\n    tf.logging.info(""*** Features ***"")\n    for name in sorted(features.keys()):\n      tf.logging.info(""  name = %s, shape = %s"" % (name, features[name].shape))\n\n    unique_ids = features[""unique_ids""]\n    input_ids = features[""input_ids""]\n    input_mask = features[""input_mask""]\n    segment_ids = features[""segment_ids""]\n\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    (start_logits, end_logits) = create_model(\n        bert_config=bert_config,\n        is_training=is_training,\n        input_ids=input_ids,\n        input_mask=input_mask,\n        segment_ids=segment_ids,\n        use_one_hot_embeddings=use_one_hot_embeddings)\n\n    tvars = tf.trainable_variables()\n\n    initialized_variable_names = {}\n    scaffold_fn = None\n    if init_checkpoint:\n      (assignment_map, initialized_variable_names\n      ) = modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n      if use_tpu:\n\n        def tpu_scaffold():\n          tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n          return tf.train.Scaffold()\n\n        scaffold_fn = tpu_scaffold\n      else:\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    tf.logging.info(""**** Trainable Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n\n    output_spec = None\n    if mode == tf.estimator.ModeKeys.TRAIN:\n      seq_length = modeling.get_shape_list(input_ids)[1]\n\n      def compute_loss(logits, positions):\n        one_hot_positions = tf.one_hot(\n            positions, depth=seq_length, dtype=tf.float32)\n        log_probs = tf.nn.log_softmax(logits, axis=-1)\n        loss = -tf.reduce_mean(\n            tf.reduce_sum(one_hot_positions * log_probs, axis=-1))\n        return loss\n\n      start_positions = features[""start_positions""]\n      end_positions = features[""end_positions""]\n\n      start_loss = compute_loss(start_logits, start_positions)\n      end_loss = compute_loss(end_logits, end_positions)\n\n      total_loss = (start_loss + end_loss) / 2.0\n\n      train_op = optimization.create_optimizer(\n          total_loss, learning_rate, num_train_steps, num_warmup_steps, use_tpu)\n\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          loss=total_loss,\n          train_op=train_op,\n          scaffold_fn=scaffold_fn)\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      predictions = {\n          ""unique_ids"": unique_ids,\n          ""start_logits"": start_logits,\n          ""end_logits"": end_logits,\n      }\n      output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n    else:\n      raise ValueError(\n          ""Only TRAIN and PREDICT modes are supported: %s"" % (mode))\n\n    return output_spec\n\n  return model_fn\n\n\ndef input_fn_builder(input_file, seq_length, is_training, drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""unique_ids"": tf.FixedLenFeature([], tf.int64),\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n  }\n\n  if is_training:\n    name_to_features[""start_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""end_positions""] = tf.FixedLenFeature([], tf.int64)\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.to_int32(t)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    batch_size = params[""batch_size""]\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    d = tf.data.TFRecordDataset(input_file)\n    if is_training:\n      d = d.repeat()\n      d = d.shuffle(buffer_size=100)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\nRawResult = collections.namedtuple(""RawResult"",\n                                   [""unique_id"", ""start_logits"", ""end_logits""])\n\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file):\n  """"""Write final predictions to the json file and log-odds of null if needed.""""""\n  tf.logging.info(""Writing predictions to: %s"" % (output_prediction_file))\n  tf.logging.info(""Writing nbest to: %s"" % (output_nbest_file))\n\n  example_index_to_features = collections.defaultdict(list)\n  for feature in all_features:\n    example_index_to_features[feature.example_index].append(feature)\n\n  unique_id_to_result = {}\n  for result in all_results:\n    unique_id_to_result[result.unique_id] = result\n\n  _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n      ""PrelimPrediction"",\n      [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n  all_predictions = collections.OrderedDict()\n  all_nbest_json = collections.OrderedDict()\n  scores_diff_json = collections.OrderedDict()\n\n  for (example_index, example) in enumerate(all_examples):\n    features = example_index_to_features[example_index]\n\n    prelim_predictions = []\n    # keep track of the minimum score of null start+end of position 0\n    score_null = 1000000  # large and positive\n    min_null_feature_index = 0  # the paragraph slice with min mull score\n    null_start_logit = 0  # the start logit at the slice with min null score\n    null_end_logit = 0  # the end logit at the slice with min null score\n    for (feature_index, feature) in enumerate(features):\n      result = unique_id_to_result[feature.unique_id]\n      start_indexes = _get_best_indexes(result.start_logits, n_best_size)\n      end_indexes = _get_best_indexes(result.end_logits, n_best_size)\n      # if we could have irrelevant answers, get the min score of irrelevant\n      if FLAGS.version_2_with_negative:\n        feature_null_score = result.start_logits[0] + result.end_logits[0]\n        if feature_null_score < score_null:\n          score_null = feature_null_score\n          min_null_feature_index = feature_index\n          null_start_logit = result.start_logits[0]\n          null_end_logit = result.end_logits[0]\n      for start_index in start_indexes:\n        for end_index in end_indexes:\n          # We could hypothetically create invalid predictions, e.g., predict\n          # that the start of the span is in the question. We throw out all\n          # invalid predictions.\n          if start_index >= len(feature.tokens):\n            continue\n          if end_index >= len(feature.tokens):\n            continue\n          if start_index not in feature.token_to_orig_map:\n            continue\n          if end_index not in feature.token_to_orig_map:\n            continue\n          if not feature.token_is_max_context.get(start_index, False):\n            continue\n          if end_index < start_index:\n            continue\n          length = end_index - start_index + 1\n          if length > max_answer_length:\n            continue\n          prelim_predictions.append(\n              _PrelimPrediction(\n                  feature_index=feature_index,\n                  start_index=start_index,\n                  end_index=end_index,\n                  start_logit=result.start_logits[start_index],\n                  end_logit=result.end_logits[end_index]))\n\n    if FLAGS.version_2_with_negative:\n      prelim_predictions.append(\n          _PrelimPrediction(\n              feature_index=min_null_feature_index,\n              start_index=0,\n              end_index=0,\n              start_logit=null_start_logit,\n              end_logit=null_end_logit))\n    prelim_predictions = sorted(\n        prelim_predictions,\n        key=lambda x: (x.start_logit + x.end_logit),\n        reverse=True)\n\n    _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n    seen_predictions = {}\n    nbest = []\n    for pred in prelim_predictions:\n      if len(nbest) >= n_best_size:\n        break\n      feature = features[pred.feature_index]\n      if pred.start_index > 0:  # this is a non-null prediction\n        tok_tokens = feature.tokens[pred.start_index:(pred.end_index + 1)]\n        orig_doc_start = feature.token_to_orig_map[pred.start_index]\n        orig_doc_end = feature.token_to_orig_map[pred.end_index]\n        orig_tokens = example.doc_tokens[orig_doc_start:(orig_doc_end + 1)]\n        tok_text = "" "".join(tok_tokens)\n\n        # De-tokenize WordPieces that have been split off.\n        tok_text = tok_text.replace("" ##"", """")\n        tok_text = tok_text.replace(""##"", """")\n\n        # Clean whitespace\n        tok_text = tok_text.strip()\n        tok_text = "" "".join(tok_text.split())\n        orig_text = "" "".join(orig_tokens)\n\n        final_text = get_final_text(tok_text, orig_text, do_lower_case)\n        if final_text in seen_predictions:\n          continue\n\n        seen_predictions[final_text] = True\n      else:\n        final_text = """"\n        seen_predictions[final_text] = True\n\n      nbest.append(\n          _NbestPrediction(\n              text=final_text,\n              start_logit=pred.start_logit,\n              end_logit=pred.end_logit))\n\n    # if we didn\'t inlude the empty option in the n-best, inlcude it\n    if FLAGS.version_2_with_negative:\n      if """" not in seen_predictions:\n        nbest.append(\n            _NbestPrediction(\n                text="""", start_logit=null_start_logit,\n                end_logit=null_end_logit))\n    # In very rare edge cases we could have no valid predictions. So we\n    # just create a nonce prediction in this case to avoid failure.\n    if not nbest:\n      nbest.append(\n          _NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n    assert len(nbest) >= 1\n\n    total_scores = []\n    best_non_null_entry = None\n    for entry in nbest:\n      total_scores.append(entry.start_logit + entry.end_logit)\n      if not best_non_null_entry:\n        if entry.text:\n          best_non_null_entry = entry\n\n    probs = _compute_softmax(total_scores)\n\n    nbest_json = []\n    for (i, entry) in enumerate(nbest):\n      output = collections.OrderedDict()\n      output[""text""] = entry.text\n      output[""probability""] = probs[i]\n      output[""start_logit""] = entry.start_logit\n      output[""end_logit""] = entry.end_logit\n      nbest_json.append(output)\n\n    assert len(nbest_json) >= 1\n\n    if not FLAGS.version_2_with_negative:\n      all_predictions[example.qas_id] = nbest_json[0][""text""]\n    else:\n      # predict """" iff the null score - the score of best non-null > threshold\n      score_diff = score_null - best_non_null_entry.start_logit - (\n          best_non_null_entry.end_logit)\n      scores_diff_json[example.qas_id] = score_diff\n      if score_diff > FLAGS.null_score_diff_threshold:\n        all_predictions[example.qas_id] = """"\n      else:\n        all_predictions[example.qas_id] = best_non_null_entry.text\n\n    all_nbest_json[example.qas_id] = nbest_json\n\n  with tf.gfile.GFile(output_prediction_file, ""w"") as writer:\n    writer.write(json.dumps(all_predictions, indent=4) + ""\\n"")\n\n  with tf.gfile.GFile(output_nbest_file, ""w"") as writer:\n    writer.write(json.dumps(all_nbest_json, indent=4) + ""\\n"")\n\n  if FLAGS.version_2_with_negative:\n    with tf.gfile.GFile(output_null_log_odds_file, ""w"") as writer:\n      writer.write(json.dumps(scores_diff_json, indent=4) + ""\\n"")\n\n\ndef get_final_text(pred_text, orig_text, do_lower_case):\n  """"""Project the tokenized prediction back to the original text.""""""\n\n  # When we created the data, we kept track of the alignment between original\n  # (whitespace tokenized) tokens and our WordPiece tokenized tokens. So\n  # now `orig_text` contains the span of our original text corresponding to the\n  # span that we predicted.\n  #\n  # However, `orig_text` may contain extra characters that we don\'t want in\n  # our prediction.\n  #\n  # For example, let\'s say:\n  #   pred_text = steve smith\n  #   orig_text = Steve Smith\'s\n  #\n  # We don\'t want to return `orig_text` because it contains the extra ""\'s"".\n  #\n  # We don\'t want to return `pred_text` because it\'s already been normalized\n  # (the SQuAD eval script also does punctuation stripping/lower casing but\n  # our tokenizer does additional normalization like stripping accent\n  # characters).\n  #\n  # What we really want to return is ""Steve Smith"".\n  #\n  # Therefore, we have to apply a semi-complicated alignment heruistic between\n  # `pred_text` and `orig_text` to get a character-to-charcter alignment. This\n  # can fail in certain cases in which case we just return `orig_text`.\n\n  def _strip_spaces(text):\n    ns_chars = []\n    ns_to_s_map = collections.OrderedDict()\n    for (i, c) in enumerate(text):\n      if c == "" "":\n        continue\n      ns_to_s_map[len(ns_chars)] = i\n      ns_chars.append(c)\n    ns_text = """".join(ns_chars)\n    return (ns_text, ns_to_s_map)\n\n  # We first tokenize `orig_text`, strip whitespace from the result\n  # and `pred_text`, and check if they are the same length. If they are\n  # NOT the same length, the heuristic has failed. If they are the same\n  # length, we assume the characters are one-to-one aligned.\n  tokenizer = tokenization.BasicTokenizer(do_lower_case=do_lower_case)\n\n  tok_text = "" "".join(tokenizer.tokenize(orig_text))\n\n  start_position = tok_text.find(pred_text)\n  if start_position == -1:\n    if FLAGS.verbose_logging:\n      tf.logging.info(\n          ""Unable to find text: \'%s\' in \'%s\'"" % (pred_text, orig_text))\n    return orig_text\n  end_position = start_position + len(pred_text) - 1\n\n  (orig_ns_text, orig_ns_to_s_map) = _strip_spaces(orig_text)\n  (tok_ns_text, tok_ns_to_s_map) = _strip_spaces(tok_text)\n\n  if len(orig_ns_text) != len(tok_ns_text):\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Length not equal after stripping spaces: \'%s\' vs \'%s\'"",\n                      orig_ns_text, tok_ns_text)\n    return orig_text\n\n  # We then project the characters in `pred_text` back to `orig_text` using\n  # the character-to-character alignment.\n  tok_s_to_ns_map = {}\n  for (i, tok_index) in six.iteritems(tok_ns_to_s_map):\n    tok_s_to_ns_map[tok_index] = i\n\n  orig_start_position = None\n  if start_position in tok_s_to_ns_map:\n    ns_start_position = tok_s_to_ns_map[start_position]\n    if ns_start_position in orig_ns_to_s_map:\n      orig_start_position = orig_ns_to_s_map[ns_start_position]\n\n  if orig_start_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map start position"")\n    return orig_text\n\n  orig_end_position = None\n  if end_position in tok_s_to_ns_map:\n    ns_end_position = tok_s_to_ns_map[end_position]\n    if ns_end_position in orig_ns_to_s_map:\n      orig_end_position = orig_ns_to_s_map[ns_end_position]\n\n  if orig_end_position is None:\n    if FLAGS.verbose_logging:\n      tf.logging.info(""Couldn\'t map end position"")\n    return orig_text\n\n  output_text = orig_text[orig_start_position:(orig_end_position + 1)]\n  return output_text\n\n\ndef _get_best_indexes(logits, n_best_size):\n  """"""Get the n-best logits from a list.""""""\n  index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\n\ndef _compute_softmax(scores):\n  """"""Compute softmax probability over raw logits.""""""\n  if not scores:\n    return []\n\n  max_score = None\n  for score in scores:\n    if max_score is None or score > max_score:\n      max_score = score\n\n  exp_scores = []\n  total_sum = 0.0\n  for score in scores:\n    x = math.exp(score - max_score)\n    exp_scores.append(x)\n    total_sum += x\n\n  probs = []\n  for score in exp_scores:\n    probs.append(score / total_sum)\n  return probs\n\n\nclass FeatureWriter(object):\n  """"""Writes InputFeature to TF example file.""""""\n\n  def __init__(self, filename, is_training):\n    self.filename = filename\n    self.is_training = is_training\n    self.num_features = 0\n    self._writer = tf.python_io.TFRecordWriter(filename)\n\n  def process_feature(self, feature):\n    """"""Write a InputFeature to the TFRecordWriter as a tf.train.Example.""""""\n    self.num_features += 1\n\n    def create_int_feature(values):\n      feature = tf.train.Feature(\n          int64_list=tf.train.Int64List(value=list(values)))\n      return feature\n\n    features = collections.OrderedDict()\n    features[""unique_ids""] = create_int_feature([feature.unique_id])\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_int_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n\n    if self.is_training:\n      features[""start_positions""] = create_int_feature([feature.start_position])\n      features[""end_positions""] = create_int_feature([feature.end_position])\n      impossible = 0\n      if feature.is_impossible:\n        impossible = 1\n      features[""is_impossible""] = create_int_feature([impossible])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    self._writer.write(tf_example.SerializeToString())\n\n  def close(self):\n    self._writer.close()\n\n\ndef validate_flags_or_throw(bert_config):\n  """"""Validate the input FLAGS or throw an exception.""""""\n  tokenization.validate_case_matches_checkpoint(FLAGS.do_lower_case,\n                                                FLAGS.init_checkpoint)\n\n  if not FLAGS.do_train and not FLAGS.do_predict:\n    raise ValueError(""At least one of `do_train` or `do_predict` must be True."")\n\n  if FLAGS.do_train:\n    if not FLAGS.train_file:\n      raise ValueError(\n          ""If `do_train` is True, then `train_file` must be specified."")\n  if FLAGS.do_predict:\n    if not FLAGS.predict_file:\n      raise ValueError(\n          ""If `do_predict` is True, then `predict_file` must be specified."")\n\n  if FLAGS.max_seq_length > bert_config.max_position_embeddings:\n    raise ValueError(\n        ""Cannot use sequence length %d because the BERT model ""\n        ""was only trained up to sequence length %d"" %\n        (FLAGS.max_seq_length, bert_config.max_position_embeddings))\n\n  if FLAGS.max_seq_length <= FLAGS.max_query_length + 3:\n    raise ValueError(\n        ""The max_seq_length (%d) must be greater than max_query_length ""\n        ""(%d) + 3"" % (FLAGS.max_seq_length, FLAGS.max_query_length))\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  bert_config = modeling.BertConfig.from_json_file(FLAGS.bert_config_file)\n\n  validate_flags_or_throw(bert_config)\n\n  tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  tokenizer = tokenization.FullTokenizer(\n      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n  tpu_cluster_resolver = None\n  if FLAGS.use_tpu and FLAGS.tpu_name:\n    tpu_cluster_resolver = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n\n  is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      cluster=tpu_cluster_resolver,\n      master=FLAGS.master,\n      model_dir=FLAGS.output_dir,\n      save_checkpoints_steps=FLAGS.save_checkpoints_steps,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations_per_loop,\n          num_shards=FLAGS.num_tpu_cores,\n          per_host_input_for_training=is_per_host))\n\n  train_examples = None\n  num_train_steps = None\n  num_warmup_steps = None\n  if FLAGS.do_train:\n    train_examples = read_squad_examples(\n        input_file=FLAGS.train_file, is_training=True)\n    num_train_steps = int(\n        len(train_examples) / FLAGS.train_batch_size * FLAGS.num_train_epochs)\n    num_warmup_steps = int(num_train_steps * FLAGS.warmup_proportion)\n\n    # Pre-shuffle the input to avoid having to make a very large shuffle\n    # buffer in in the `input_fn`.\n    rng = random.Random(12345)\n    rng.shuffle(train_examples)\n\n  model_fn = model_fn_builder(\n      bert_config=bert_config,\n      init_checkpoint=FLAGS.init_checkpoint,\n      learning_rate=FLAGS.learning_rate,\n      num_train_steps=num_train_steps,\n      num_warmup_steps=num_warmup_steps,\n      use_tpu=FLAGS.use_tpu,\n      use_one_hot_embeddings=FLAGS.use_tpu)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  estimator = tf.contrib.tpu.TPUEstimator(\n      use_tpu=FLAGS.use_tpu,\n      model_fn=model_fn,\n      config=run_config,\n      train_batch_size=FLAGS.train_batch_size,\n      predict_batch_size=FLAGS.predict_batch_size)\n\n  if FLAGS.do_train:\n    # We write to a temporary file to avoid storing very large constant tensors\n    # in memory.\n    train_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""train.tf_record""),\n        is_training=True)\n    convert_examples_to_features(\n        examples=train_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=True,\n        output_fn=train_writer.process_feature)\n    train_writer.close()\n\n    tf.logging.info(""***** Running training *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(train_examples))\n    tf.logging.info(""  Num split examples = %d"", train_writer.num_features)\n    tf.logging.info(""  Batch size = %d"", FLAGS.train_batch_size)\n    tf.logging.info(""  Num steps = %d"", num_train_steps)\n    del train_examples\n\n    train_input_fn = input_fn_builder(\n        input_file=train_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n    estimator.train(input_fn=train_input_fn, max_steps=num_train_steps)\n\n  if FLAGS.do_predict:\n    eval_examples = read_squad_examples(\n        input_file=FLAGS.predict_file, is_training=False)\n\n    eval_writer = FeatureWriter(\n        filename=os.path.join(FLAGS.output_dir, ""eval.tf_record""),\n        is_training=False)\n    eval_features = []\n\n    def append_feature(feature):\n      eval_features.append(feature)\n      eval_writer.process_feature(feature)\n\n    convert_examples_to_features(\n        examples=eval_examples,\n        tokenizer=tokenizer,\n        max_seq_length=FLAGS.max_seq_length,\n        doc_stride=FLAGS.doc_stride,\n        max_query_length=FLAGS.max_query_length,\n        is_training=False,\n        output_fn=append_feature)\n    eval_writer.close()\n\n    tf.logging.info(""***** Running predictions *****"")\n    tf.logging.info(""  Num orig examples = %d"", len(eval_examples))\n    tf.logging.info(""  Num split examples = %d"", len(eval_features))\n    tf.logging.info(""  Batch size = %d"", FLAGS.predict_batch_size)\n\n    all_results = []\n\n    predict_input_fn = input_fn_builder(\n        input_file=eval_writer.filename,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=False)\n\n    # If running eval on the TPU, you will need to specify the number of\n    # steps.\n    all_results = []\n    for result in estimator.predict(\n        predict_input_fn, yield_single_examples=True):\n      if len(all_results) % 1000 == 0:\n        tf.logging.info(""Processing example: %d"" % (len(all_results)))\n      unique_id = int(result[""unique_ids""])\n      start_logits = [float(x) for x in result[""start_logits""].flat]\n      end_logits = [float(x) for x in result[""end_logits""].flat]\n      all_results.append(\n          RawResult(\n              unique_id=unique_id,\n              start_logits=start_logits,\n              end_logits=end_logits))\n\n    output_prediction_file = os.path.join(FLAGS.output_dir, ""predictions.json"")\n    output_nbest_file = os.path.join(FLAGS.output_dir, ""nbest_predictions.json"")\n    output_null_log_odds_file = os.path.join(FLAGS.output_dir, ""null_odds.json"")\n\n    write_predictions(eval_examples, eval_features, all_results,\n                      FLAGS.n_best_size, FLAGS.max_answer_length,\n                      FLAGS.do_lower_case, output_prediction_file,\n                      output_nbest_file, output_null_log_odds_file)\n\n\nif __name__ == ""__main__"":\n  flags.mark_flag_as_required(""vocab_file"")\n  flags.mark_flag_as_required(""bert_config_file"")\n  flags.mark_flag_as_required(""output_dir"")\n  tf.app.run()\n'"
baselines/models/roberta_wwm_large_ext/tf_metrics.py,22,"b'""""""\r\nMulticlass\r\nfrom: \r\nhttps://github.com/guillaumegenthial/tf_metrics/blob/master/tf_metrics/__init__.py\r\n\r\n""""""\r\n\r\n__author__ = ""Guillaume Genthial""\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops.metrics_impl import _streaming_confusion_matrix\r\n\r\n\r\ndef precision(labels, predictions, num_classes, pos_indices=None,\r\n              weights=None, average=\'micro\'):\r\n    """"""Multi-class precision metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    pr, _, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    op, _, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (pr, op)\r\n\r\n\r\ndef recall(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n           average=\'micro\'):\r\n    """"""Multi-class recall metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, re, _ = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average)\r\n    _, op, _ = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average)\r\n    return (re, op)\r\n\r\n\r\ndef f1(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n       average=\'micro\'):\r\n    return fbeta(labels, predictions, num_classes, pos_indices, weights,\r\n                 average)\r\n\r\n\r\ndef fbeta(labels, predictions, num_classes, pos_indices=None, weights=None,\r\n          average=\'micro\', beta=1):\r\n    """"""Multi-class fbeta metric for Tensorflow\r\n    Parameters\r\n    ----------\r\n    labels : Tensor of tf.int32 or tf.int64\r\n        The true labels\r\n    predictions : Tensor of tf.int32 or tf.int64\r\n        The predictions, same shape as labels\r\n    num_classes : int\r\n        The number of classes\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes, default is all\r\n    weights : Tensor of tf.int32, optional\r\n        Mask, must be of compatible shape with labels\r\n    average : str, optional\r\n        \'micro\': counts the total number of true positives, false\r\n            positives, and false negatives for the classes in\r\n            `pos_indices` and infer the metric from it.\r\n        \'macro\': will compute the metric separately for each class in\r\n            `pos_indices` and average. Will not account for class\r\n            imbalance.\r\n        \'weighted\': will compute the metric separately for each class in\r\n            `pos_indices` and perform a weighted average by the total\r\n            number of true labels for each class.\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    Returns\r\n    -------\r\n    tuple of (scalar float Tensor, update_op)\r\n    """"""\r\n    cm, op = _streaming_confusion_matrix(\r\n        labels, predictions, num_classes, weights)\r\n    _, _, fbeta = metrics_from_confusion_matrix(\r\n        cm, pos_indices, average=average, beta=beta)\r\n    _, _, op = metrics_from_confusion_matrix(\r\n        op, pos_indices, average=average, beta=beta)\r\n    return (fbeta, op)\r\n\r\n\r\ndef safe_div(numerator, denominator):\r\n    """"""Safe division, return 0 if denominator is 0""""""\r\n    numerator, denominator = tf.to_float(numerator), tf.to_float(denominator)\r\n    zeros = tf.zeros_like(numerator, dtype=numerator.dtype)\r\n    denominator_is_zero = tf.equal(denominator, zeros)\r\n    return tf.where(denominator_is_zero, zeros, numerator / denominator)\r\n\r\n\r\ndef pr_re_fbeta(cm, pos_indices, beta=1):\r\n    """"""Uses a confusion matrix to compute precision, recall and fbeta""""""\r\n    num_classes = cm.shape[0]\r\n    neg_indices = [i for i in range(num_classes) if i not in pos_indices]\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, neg_indices] = 0\r\n    diag_sum = tf.reduce_sum(tf.diag_part(cm * cm_mask))\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[:, neg_indices] = 0\r\n    tot_pred = tf.reduce_sum(cm * cm_mask)\r\n\r\n    cm_mask = np.ones([num_classes, num_classes])\r\n    cm_mask[neg_indices, :] = 0\r\n    tot_gold = tf.reduce_sum(cm * cm_mask)\r\n\r\n    pr = safe_div(diag_sum, tot_pred)\r\n    re = safe_div(diag_sum, tot_gold)\r\n    fbeta = safe_div((1. + beta**2) * pr * re, beta**2 * pr + re)\r\n\r\n    return pr, re, fbeta\r\n\r\n\r\ndef metrics_from_confusion_matrix(cm, pos_indices=None, average=\'micro\',\r\n                                  beta=1):\r\n    """"""Precision, Recall and F1 from the confusion matrix\r\n    Parameters\r\n    ----------\r\n    cm : tf.Tensor of type tf.int32, of shape (num_classes, num_classes)\r\n        The streaming confusion matrix.\r\n    pos_indices : list of int, optional\r\n        The indices of the positive classes\r\n    beta : int, optional\r\n        Weight of precision in harmonic mean\r\n    average : str, optional\r\n        \'micro\', \'macro\' or \'weighted\'\r\n    """"""\r\n    num_classes = cm.shape[0]\r\n    if pos_indices is None:\r\n        pos_indices = [i for i in range(num_classes)]\r\n\r\n    if average == \'micro\':\r\n        return pr_re_fbeta(cm, pos_indices, beta)\r\n    elif average in {\'macro\', \'weighted\'}:\r\n        precisions, recalls, fbetas, n_golds = [], [], [], []\r\n        for idx in pos_indices:\r\n            pr, re, fbeta = pr_re_fbeta(cm, [idx], beta)\r\n            precisions.append(pr)\r\n            recalls.append(re)\r\n            fbetas.append(fbeta)\r\n            cm_mask = np.zeros([num_classes, num_classes])\r\n            cm_mask[idx, :] = 1\r\n            n_golds.append(tf.to_float(tf.reduce_sum(cm * cm_mask)))\r\n\r\n        if average == \'macro\':\r\n            pr = tf.reduce_mean(precisions)\r\n            re = tf.reduce_mean(recalls)\r\n            fbeta = tf.reduce_mean(fbetas)\r\n            return pr, re, fbeta\r\n        if average == \'weighted\':\r\n            n_gold = tf.reduce_sum(n_golds)\r\n            pr_sum = sum(p * n for p, n in zip(precisions, n_golds))\r\n            pr = safe_div(pr_sum, n_gold)\r\n            re_sum = sum(r * n for r, n in zip(recalls, n_golds))\r\n            re = safe_div(re_sum, n_gold)\r\n            fbeta_sum = sum(f * n for f, n in zip(fbetas, n_golds))\r\n            fbeta = safe_div(fbeta_sum, n_gold)\r\n            return pr, re, fbeta\r\n\r\n    else:\r\n        raise NotImplementedError()'"
baselines/models/roberta_wwm_large_ext/tokenization.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\nimport unicodedata\nimport six\nimport tensorflow as tf\n\n\ndef validate_case_matches_checkpoint(do_lower_case, init_checkpoint):\n  """"""Checks whether the casing config is consistent with the checkpoint name.""""""\n\n  # The casing has to be passed in by the user and there is no explicit check\n  # as to whether it matches the checkpoint. The casing information probably\n  # should have been stored in the bert_config.json file, but it\'s not, so\n  # we have to heuristically detect it to validate.\n\n  if not init_checkpoint:\n    return\n\n  m = re.match(""^.*?([A-Za-z0-9_-]+)/bert_model.ckpt"", init_checkpoint)\n  if m is None:\n    return\n\n  model_name = m.group(1)\n\n  lower_models = [\n      ""uncased_L-24_H-1024_A-16"", ""uncased_L-12_H-768_A-12"",\n      ""multilingual_L-12_H-768_A-12"", ""chinese_L-12_H-768_A-12""\n  ]\n\n  cased_models = [\n      ""cased_L-12_H-768_A-12"", ""cased_L-24_H-1024_A-16"",\n      ""multi_cased_L-12_H-768_A-12""\n  ]\n\n  is_bad_config = False\n  if model_name in lower_models and not do_lower_case:\n    is_bad_config = True\n    actual_flag = ""False""\n    case_name = ""lowercased""\n    opposite_flag = ""True""\n\n  if model_name in cased_models and do_lower_case:\n    is_bad_config = True\n    actual_flag = ""True""\n    case_name = ""cased""\n    opposite_flag = ""False""\n\n  if is_bad_config:\n    raise ValueError(\n        ""You passed in `--do_lower_case=%s` with `--init_checkpoint=%s`. ""\n        ""However, `%s` seems to be a %s model, so you ""\n        ""should pass in `--do_lower_case=%s` so that the fine-tuning matches ""\n        ""how the model was pre-training. If this error is wrong, please ""\n        ""just comment out this check."" % (actual_flag, init_checkpoint,\n                                          model_name, case_name, opposite_flag))\n\n\ndef convert_to_unicode(text):\n  """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text.decode(""utf-8"", ""ignore"")\n    elif isinstance(text, unicode):\n      return text\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  index = 0\n  with tf.gfile.GFile(vocab_file, ""r"") as reader:\n    while True:\n      token = convert_to_unicode(reader.readline())\n      if not token:\n        break\n      token = token.strip()\n      vocab[token] = index\n      index += 1\n  return vocab\n\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  for item in items:\n    output.append(vocab[item])\n  return output\n\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True):\n    self.vocab = load_vocab(vocab_file)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n  def tokenize(self, text):\n    split_tokens = []\n    for token in self.basic_tokenizer.tokenize(text):\n      for sub_token in self.wordpiece_tokenizer.tokenize(token):\n        split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    return convert_by_vocab(self.inv_vocab, ids)\n\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = convert_to_unicode(text)\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n  """"""Runs WordPiece tokenziation.""""""\n\n  def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=200):\n    self.vocab = vocab\n    self.unk_token = unk_token\n    self.max_input_chars_per_word = max_input_chars_per_word\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text into its word pieces.\n\n    This uses a greedy longest-match-first algorithm to perform tokenization\n    using the given vocabulary.\n\n    For example:\n      input = ""unaffable""\n      output = [""un"", ""##aff"", ""##able""]\n\n    Args:\n      text: A single token or whitespace separated tokens. This should have\n        already been passed through `BasicTokenizer.\n\n    Returns:\n      A list of wordpiece tokens.\n    """"""\n\n    text = convert_to_unicode(text)\n\n    output_tokens = []\n    for token in whitespace_tokenize(text):\n      chars = list(token)\n      if len(chars) > self.max_input_chars_per_word:\n        output_tokens.append(self.unk_token)\n        continue\n\n      is_bad = False\n      start = 0\n      sub_tokens = []\n      while start < len(chars):\n        end = len(chars)\n        cur_substr = None\n        while start < end:\n          substr = """".join(chars[start:end])\n          if start > 0:\n            substr = ""##"" + substr\n          if substr in self.vocab:\n            cur_substr = substr\n            break\n          end -= 1\n        if cur_substr is None:\n          is_bad = True\n          break\n        sub_tokens.append(cur_substr)\n        start = end\n\n      if is_bad:\n        output_tokens.append(self.unk_token)\n      else:\n        output_tokens.extend(sub_tokens)\n    return output_tokens\n\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically contorl characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
baselines/models/roberta_wwm_large_ext/tokenization_test.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tempfile\nimport tokenization\nimport six\nimport tensorflow as tf\n\n\nclass TokenizationTest(tf.test.TestCase):\n\n  def test_full_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing"", "",""\n    ]\n    with tempfile.NamedTemporaryFile(delete=False) as vocab_writer:\n      if six.PY2:\n        vocab_writer.write("""".join([x + ""\\n"" for x in vocab_tokens]))\n      else:\n        vocab_writer.write("""".join(\n            [x + ""\\n"" for x in vocab_tokens]).encode(""utf-8""))\n\n      vocab_file = vocab_writer.name\n\n    tokenizer = tokenization.FullTokenizer(vocab_file)\n    os.unlink(vocab_file)\n\n    tokens = tokenizer.tokenize(u""UNwant\\u00E9d,running"")\n    self.assertAllEqual(tokens, [""un"", ""##want"", ""##ed"", "","", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.convert_tokens_to_ids(tokens), [7, 4, 5, 10, 8, 9])\n\n  def test_chinese(self):\n    tokenizer = tokenization.BasicTokenizer()\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u""ah\\u535A\\u63A8zz""),\n        [u""ah"", u""\\u535A"", u""\\u63A8"", u""zz""])\n\n  def test_basic_tokenizer_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=True)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""hello"", ""!"", ""how"", ""are"", ""you"", ""?""])\n    self.assertAllEqual(tokenizer.tokenize(u""H\\u00E9llo""), [""hello""])\n\n  def test_basic_tokenizer_no_lower(self):\n    tokenizer = tokenization.BasicTokenizer(do_lower_case=False)\n\n    self.assertAllEqual(\n        tokenizer.tokenize(u"" \\tHeLLo!how  \\n Are yoU?  ""),\n        [""HeLLo"", ""!"", ""how"", ""Are"", ""yoU"", ""?""])\n\n  def test_wordpiece_tokenizer(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n    tokenizer = tokenization.WordpieceTokenizer(vocab=vocab)\n\n    self.assertAllEqual(tokenizer.tokenize(""""), [])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwanted running""),\n        [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""])\n\n    self.assertAllEqual(\n        tokenizer.tokenize(""unwantedX running""), [""[UNK]"", ""runn"", ""##ing""])\n\n  def test_convert_tokens_to_ids(self):\n    vocab_tokens = [\n        ""[UNK]"", ""[CLS]"", ""[SEP]"", ""want"", ""##want"", ""##ed"", ""wa"", ""un"", ""runn"",\n        ""##ing""\n    ]\n\n    vocab = {}\n    for (i, token) in enumerate(vocab_tokens):\n      vocab[token] = i\n\n    self.assertAllEqual(\n        tokenization.convert_tokens_to_ids(\n            vocab, [""un"", ""##want"", ""##ed"", ""runn"", ""##ing""]), [7, 4, 5, 8, 9])\n\n  def test_is_whitespace(self):\n    self.assertTrue(tokenization._is_whitespace(u"" ""))\n    self.assertTrue(tokenization._is_whitespace(u""\\t""))\n    self.assertTrue(tokenization._is_whitespace(u""\\r""))\n    self.assertTrue(tokenization._is_whitespace(u""\\n""))\n    self.assertTrue(tokenization._is_whitespace(u""\\u00A0""))\n\n    self.assertFalse(tokenization._is_whitespace(u""A""))\n    self.assertFalse(tokenization._is_whitespace(u""-""))\n\n  def test_is_control(self):\n    self.assertTrue(tokenization._is_control(u""\\u0005""))\n\n    self.assertFalse(tokenization._is_control(u""A""))\n    self.assertFalse(tokenization._is_control(u"" ""))\n    self.assertFalse(tokenization._is_control(u""\\t""))\n    self.assertFalse(tokenization._is_control(u""\\r""))\n    self.assertFalse(tokenization._is_control(u""\\U0001F4A9""))\n\n  def test_is_punctuation(self):\n    self.assertTrue(tokenization._is_punctuation(u""-""))\n    self.assertTrue(tokenization._is_punctuation(u""$""))\n    self.assertTrue(tokenization._is_punctuation(u""`""))\n    self.assertTrue(tokenization._is_punctuation(u"".""))\n\n    self.assertFalse(tokenization._is_punctuation(u""A""))\n    self.assertFalse(tokenization._is_punctuation(u"" ""))\n\n\nif __name__ == ""__main__"":\n  tf.test.main()\n'"
baselines/models/xlnet/__init__.py,0,b''
baselines/models/xlnet/cmrc2018_evaluate_drcd.py,0,"b'# -*- coding: utf-8 -*-\n\'\'\'\nEvaluation script for CMRC 2018\nversion: v5\nNote: \nv5 formatted output, add usage description\nv4 fixed segmentation issues\n\'\'\'\nfrom __future__ import print_function\nfrom collections import Counter, OrderedDict\nimport string\nimport re\nimport argparse\nimport json\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\nimport nltk\nimport pdb\n\n# split Chinese with English\ndef mixed_segmentation(in_str, rm_punc=False):\n\tin_str = str(in_str).decode(\'utf-8\').lower().strip()\n\tsegs_out = []\n\ttemp_str = """"\n\tsp_char = [\'-\',\':\',\'_\',\'*\',\'^\',\'/\',\'\\\\\',\'~\',\'`\',\'+\',\'=\',\n\t\t\t   \'\xef\xbc\x8c\',\'\xe3\x80\x82\',\'\xef\xbc\x9a\',\'\xef\xbc\x9f\',\'\xef\xbc\x81\',\'\xe2\x80\x9c\',\'\xe2\x80\x9d\',\'\xef\xbc\x9b\',\'\xe2\x80\x99\',\'\xe3\x80\x8a\',\'\xe3\x80\x8b\',\'\xe2\x80\xa6\xe2\x80\xa6\',\'\xc2\xb7\',\'\xe3\x80\x81\',\n\t\t\t   \'\xe3\x80\x8c\',\'\xe3\x80\x8d\',\'\xef\xbc\x88\',\'\xef\xbc\x89\',\'\xef\xbc\x8d\',\'\xef\xbd\x9e\',\'\xe3\x80\x8e\',\'\xe3\x80\x8f\']\n\tfor char in in_str:\n\t\tif rm_punc and char in sp_char:\n\t\t\tcontinue\n\t\tif re.search(ur\'[\\u4e00-\\u9fa5]\', char) or char in sp_char:\n\t\t\tif temp_str != """":\n\t\t\t\tss = nltk.word_tokenize(temp_str)\n\t\t\t\tsegs_out.extend(ss)\n\t\t\t\ttemp_str = """"\n\t\t\tsegs_out.append(char)\n\t\telse:\n\t\t\ttemp_str += char\n\n\t#handling last part\n\tif temp_str != """":\n\t\tss = nltk.word_tokenize(temp_str)\n\t\tsegs_out.extend(ss)\n\n\treturn segs_out\n\n\n# remove punctuation\ndef remove_punctuation(in_str):\n\tin_str = str(in_str).decode(\'utf-8\').lower().strip()\n\tsp_char = [\'-\',\':\',\'_\',\'*\',\'^\',\'/\',\'\\\\\',\'~\',\'`\',\'+\',\'=\',\n\t\t\t   \'\xef\xbc\x8c\',\'\xe3\x80\x82\',\'\xef\xbc\x9a\',\'\xef\xbc\x9f\',\'\xef\xbc\x81\',\'\xe2\x80\x9c\',\'\xe2\x80\x9d\',\'\xef\xbc\x9b\',\'\xe2\x80\x99\',\'\xe3\x80\x8a\',\'\xe3\x80\x8b\',\'\xe2\x80\xa6\xe2\x80\xa6\',\'\xc2\xb7\',\'\xe3\x80\x81\',\n\t\t\t   \'\xe3\x80\x8c\',\'\xe3\x80\x8d\',\'\xef\xbc\x88\',\'\xef\xbc\x89\',\'\xef\xbc\x8d\',\'\xef\xbd\x9e\',\'\xe3\x80\x8e\',\'\xe3\x80\x8f\']\n\tout_segs = []\n\tfor char in in_str:\n\t\tif char in sp_char:\n\t\t\tcontinue\n\t\telse:\n\t\t\tout_segs.append(char)\n\treturn \'\'.join(out_segs)\n\n\n# find longest common string\ndef find_lcs(s1, s2):\n\tm = [[0 for i in range(len(s2)+1)] for j in range(len(s1)+1)]\n\tmmax = 0\n\tp = 0\n\tfor i in range(len(s1)):\n\t\tfor j in range(len(s2)):\n\t\t\tif s1[i] == s2[j]:\n\t\t\t\tm[i+1][j+1] = m[i][j]+1\n\t\t\t\tif m[i+1][j+1] > mmax:\n\t\t\t\t\tmmax=m[i+1][j+1]\n\t\t\t\t\tp=i+1\n\treturn s1[p-mmax:p], mmax\n\n#\ndef evaluate(ground_truth_file, prediction_file):\n\tf1 = 0\n\tem = 0\n\ttotal_count = 0\n\tskip_count = 0\n\tfor instance in ground_truth_file[""data""]:\n\t\t#context_id   = instance[\'context_id\'].strip()\n\t\t#context_text = instance[\'context_text\'].strip()\n\t\tfor para in instance[""paragraphs""]:\n\t\t\tfor qas in para[\'qas\']:\n\t\t\t\ttotal_count += 1\n\t\t\t\tquery_id    = qas[\'id\'].strip()\n\t\t\t\tquery_text  = qas[\'question\'].strip()\n\t\t\t\tanswers \t= [x[""text""] for x in qas[\'answers\']]\n\n\t\t\t\tif query_id not in prediction_file:\n\t\t\t\t\tsys.stderr.write(\'Unanswered question: {}\\n\'.format(query_id))\n\t\t\t\t\tskip_count += 1\n\t\t\t\t\tcontinue\n\n\t\t\t\tprediction \t= str(prediction_file[query_id]).decode(\'utf-8\')\n\t\t\t\tf1 += calc_f1_score(answers, prediction)\n\t\t\t\tem += calc_em_score(answers, prediction)\n\n\tf1_score = 100.0 * f1 / total_count\n\tem_score = 100.0 * em / total_count\n\treturn f1_score, em_score, total_count, skip_count\n\n\ndef calc_f1_score(answers, prediction):\n\tf1_scores = []\n\tfor ans in answers:\n\t\tans_segs = mixed_segmentation(ans, rm_punc=True)\n\t\tprediction_segs = mixed_segmentation(prediction, rm_punc=True)\n\t\tlcs, lcs_len = find_lcs(ans_segs, prediction_segs)\n\t\tif lcs_len == 0:\n\t\t\tf1_scores.append(0)\n\t\t\tcontinue\n\t\tprecision \t= 1.0*lcs_len/len(prediction_segs)\n\t\trecall \t\t= 1.0*lcs_len/len(ans_segs)\n\t\tf1 \t\t\t= (2*precision*recall)/(precision+recall)\n\t\tf1_scores.append(f1)\n\treturn max(f1_scores)\n\n\ndef calc_em_score(answers, prediction):\n\tem = 0\n\tfor ans in answers:\n\t\tans_ = remove_punctuation(ans)\n\t\tprediction_ = remove_punctuation(prediction)\n\t\tif ans_ == prediction_:\n\t\t\tem = 1\n\t\t\tbreak\n\treturn em\n\nif __name__ == \'__main__\':\n\tparser = argparse.ArgumentParser(description=\'Evaluation Script for CMRC 2018\')\n\tparser.add_argument(\'dataset_file\', help=\'Official dataset file\')\n\tparser.add_argument(\'prediction_file\', help=\'Your prediction File\')\n\targs = parser.parse_args()\n\tground_truth_file   = json.load(open(args.dataset_file, \'rb\'))\n\tprediction_file     = json.load(open(args.prediction_file, \'rb\'))\n\tF1, EM, TOTAL, SKIP = evaluate(ground_truth_file, prediction_file)\n\tAVG = (EM+F1)*0.5\n\toutput_result = OrderedDict()\n\toutput_result[\'AVERAGE\'] = \'%.3f\' % AVG\n\toutput_result[\'F1\'] = \'%.3f\' % F1\n\toutput_result[\'EM\'] = \'%.3f\' % EM\n\toutput_result[\'TOTAL\'] = TOTAL\n\toutput_result[\'SKIP\'] = SKIP\n\toutput_result[\'FILE\'] = args.prediction_file\n\tprint(json.dumps(output_result))\n\n'"
baselines/models/xlnet/data_utils.py,104,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport json\nimport os\nimport random\n\nfrom absl import flags\nimport absl.logging as _logging  # pylint: disable=unused-import\n\nimport numpy as np\n\n\nimport tensorflow as tf\n\nfrom prepro_utils import preprocess_text, encode_ids\nimport sentencepiece as spm\n\n\nspecial_symbols = {\n    ""<unk>""  : 0,\n    ""<s>""    : 1,\n    ""</s>""   : 2,\n    ""<cls>""  : 3,\n    ""<sep>""  : 4,\n    ""<pad>""  : 5,\n    ""<mask>"" : 6,\n    ""<eod>""  : 7,\n    ""<eop>""  : 8,\n}\n\nVOCAB_SIZE = 32000\nUNK_ID = special_symbols[""<unk>""]\nCLS_ID = special_symbols[""<cls>""]\nSEP_ID = special_symbols[""<sep>""]\nMASK_ID = special_symbols[""<mask>""]\nEOD_ID = special_symbols[""<eod>""]\n\n\ndef _int64_feature(values):\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=values))\n\n\ndef _float_feature(values):\n  return tf.train.Feature(float_list=tf.train.FloatList(value=values))\n\n\ndef format_filename(prefix, bsz_per_host, seq_len, bi_data, suffix,\n                    mask_alpha=5, mask_beta=1, reuse_len=None, uncased=False,\n                    fixed_num_predict=None):\n  """"""docs.""""""\n  if reuse_len is None:\n    reuse_len_str = """"\n  else:\n    reuse_len_str = ""reuse-{}."".format(reuse_len)\n  if not uncased:\n    uncased_str = """"\n  else:\n    uncased_str = ""uncased.""\n  if bi_data:\n    bi_data_str = ""bi""\n  else:\n    bi_data_str = ""uni""\n  if fixed_num_predict is not None:\n    fnp_str = ""fnp-{}."".format(fixed_num_predict)\n  else:\n    fnp_str = """"\n\n  file_name = ""{}.bsz-{}.seqlen-{}.{}{}{}.alpha-{}.beta-{}.{}{}"".format(\n      prefix, bsz_per_host, seq_len, reuse_len_str, uncased_str, bi_data_str,\n      mask_alpha, mask_beta, fnp_str, suffix)\n\n  return file_name\n\n\ndef _create_data(idx, input_paths):\n  # Load sentence-piece model\n  sp = spm.SentencePieceProcessor()\n  sp.Load(FLAGS.sp_path)\n\n  input_shards = []\n  total_line_cnt = 0\n  for input_path in input_paths:\n    input_data, sent_ids = [], []\n    sent_id, line_cnt = True, 0\n    tf.logging.info(""Processing %s"", input_path)\n    for line in tf.gfile.Open(input_path):\n      if line_cnt % 100000 == 0:\n        tf.logging.info(""Loading line %d"", line_cnt)\n      line_cnt += 1\n\n      if not line.strip():\n        if FLAGS.use_eod:\n          sent_id = not sent_id\n          cur_sent = [EOD_ID]\n        else:\n          continue\n      else:\n        if FLAGS.from_raw_text:\n          cur_sent = preprocess_text(line.strip(), lower=FLAGS.uncased)\n          cur_sent = encode_ids(sp, cur_sent)\n        else:\n          cur_sent = list(map(int, line.strip().split()))\n\n      input_data.extend(cur_sent)\n      sent_ids.extend([sent_id] * len(cur_sent))\n      sent_id = not sent_id\n\n    tf.logging.info(""Finish with line %d"", line_cnt)\n    if line_cnt == 0:\n      continue\n\n    input_data = np.array(input_data, dtype=np.int64)\n    sent_ids = np.array(sent_ids, dtype=np.bool)\n\n    total_line_cnt += line_cnt\n    input_shards.append((input_data, sent_ids))\n\n  tf.logging.info(""[Task %d] Total number line: %d"", idx, total_line_cnt)\n\n  tfrecord_dir = os.path.join(FLAGS.save_dir, ""tfrecords"")\n\n  filenames, num_batch = [], 0\n\n  # Randomly shuffle input shards (with a fixed but distinct random seed)\n  np.random.seed(100 * FLAGS.task + FLAGS.pass_id)\n\n  perm_indices = np.random.permutation(len(input_shards))\n  tf.logging.info(""Using perm indices %s for pass %d"",\n                  perm_indices.tolist(), FLAGS.pass_id)\n\n  input_data_list, sent_ids_list = [], []\n  prev_sent_id = None\n  for perm_idx in perm_indices:\n    input_data, sent_ids = input_shards[perm_idx]\n    # make sure the `send_ids[0] == not prev_sent_id`\n    if prev_sent_id is not None and sent_ids[0] == prev_sent_id:\n      sent_ids = np.logical_not(sent_ids)\n\n    # append to temporary list\n    input_data_list.append(input_data)\n    sent_ids_list.append(sent_ids)\n\n    # update `prev_sent_id`\n    prev_sent_id = sent_ids[-1]\n\n  input_data = np.concatenate(input_data_list)\n  sent_ids = np.concatenate(sent_ids_list)\n\n  file_name, cur_num_batch = create_tfrecords(\n      save_dir=tfrecord_dir,\n      basename=""{}-{}-{}"".format(FLAGS.split, idx, FLAGS.pass_id),\n      data=[input_data, sent_ids],\n      bsz_per_host=FLAGS.bsz_per_host,\n      seq_len=FLAGS.seq_len,\n      bi_data=FLAGS.bi_data,\n      sp=sp,\n  )\n\n  filenames.append(file_name)\n  num_batch += cur_num_batch\n\n  record_info = {\n      ""filenames"": filenames,\n      ""num_batch"": num_batch\n  }\n\n  return record_info\n\n\ndef create_data(_):\n  # Validate FLAGS\n  assert FLAGS.bsz_per_host % FLAGS.num_core_per_host == 0\n  if not FLAGS.use_tpu:\n    FLAGS.num_core_per_host = 1  # forced to be one\n\n  # Make workdirs\n  if not tf.gfile.Exists(FLAGS.save_dir):\n    tf.gfile.MakeDirs(FLAGS.save_dir)\n\n  tfrecord_dir = os.path.join(FLAGS.save_dir, ""tfrecords"")\n  if not tf.gfile.Exists(tfrecord_dir):\n    tf.gfile.MakeDirs(tfrecord_dir)\n\n  # Create and dump corpus_info from task 0\n  if FLAGS.task == 0:\n    corpus_info = {\n        ""vocab_size"": VOCAB_SIZE,\n        ""bsz_per_host"": FLAGS.bsz_per_host,\n        ""num_core_per_host"": FLAGS.num_core_per_host,\n        ""seq_len"": FLAGS.seq_len,\n        ""reuse_len"": FLAGS.reuse_len,\n        ""uncased"": FLAGS.uncased,\n        ""bi_data"": FLAGS.bi_data,\n        ""mask_alpha"": FLAGS.mask_alpha,\n        ""mask_beta"": FLAGS.mask_beta,\n        ""num_predict"": FLAGS.num_predict,\n        ""use_eod"": FLAGS.use_eod,\n        ""sp_path"": FLAGS.sp_path,\n        ""input_glob"": FLAGS.input_glob,\n    }\n    corpus_info_path = os.path.join(FLAGS.save_dir, ""corpus_info.json"")\n    with tf.gfile.Open(corpus_info_path, ""w"") as fp:\n      json.dump(corpus_info, fp)\n\n  # Interleavely split the work into FLAGS.num_task splits\n  file_paths = sorted(tf.gfile.Glob(FLAGS.input_glob))\n  tf.logging.info(""Use glob: %s"", FLAGS.input_glob)\n  tf.logging.info(""Find %d files: %s"", len(file_paths), file_paths)\n\n  task_file_paths = file_paths[FLAGS.task::FLAGS.num_task]\n  if not task_file_paths:\n    tf.logging.info(""Exit: task %d has no file to process."", FLAGS.task)\n    return\n\n  tf.logging.info(""Task %d process %d files: %s"",\n                  FLAGS.task, len(task_file_paths), task_file_paths)\n  record_info = _create_data(FLAGS.task, task_file_paths)\n\n  record_prefix = ""record_info-{}-{}-{}"".format(\n      FLAGS.split, FLAGS.task, FLAGS.pass_id)\n  record_name = format_filename(\n      prefix=record_prefix,\n      bsz_per_host=FLAGS.bsz_per_host,\n      seq_len=FLAGS.seq_len,\n      mask_alpha=FLAGS.mask_alpha,\n      mask_beta=FLAGS.mask_beta,\n      reuse_len=FLAGS.reuse_len,\n      bi_data=FLAGS.bi_data,\n      suffix=""json"",\n      uncased=FLAGS.uncased,\n      fixed_num_predict=FLAGS.num_predict)\n  record_info_path = os.path.join(tfrecord_dir, record_name)\n\n  with tf.gfile.Open(record_info_path, ""w"") as fp:\n    json.dump(record_info, fp)\n\n\ndef batchify(data, bsz_per_host, sent_ids=None):\n  num_step = len(data) // bsz_per_host\n  data = data[:bsz_per_host * num_step]\n  data = data.reshape(bsz_per_host, num_step)\n  if sent_ids is not None:\n    sent_ids = sent_ids[:bsz_per_host * num_step]\n    sent_ids = sent_ids.reshape(bsz_per_host, num_step)\n\n  if sent_ids is not None:\n    return data, sent_ids\n  return data\n\n\ndef _split_a_and_b(data, sent_ids, begin_idx, tot_len, extend_target=False):\n  """"""Split two segments from `data` starting from the index `begin_idx`.""""""\n\n  data_len = data.shape[0]\n  if begin_idx + tot_len >= data_len:\n    tf.logging.info(""[_split_a_and_b] returns None: ""\n                    ""begin_idx %d + tot_len %d >= data_len %d"",\n                    begin_idx, tot_len, data_len)\n    return None\n\n  end_idx = begin_idx + 1\n  cut_points = []\n  while end_idx < data_len:\n    if sent_ids[end_idx] != sent_ids[end_idx - 1]:\n      if end_idx - begin_idx >= tot_len: break\n      cut_points.append(end_idx)\n    end_idx += 1\n\n  a_begin = begin_idx\n  if len(cut_points) == 0 or random.random() < 0.5:\n    label = 0\n    if len(cut_points) == 0:\n      a_end = end_idx\n    else:\n      a_end = random.choice(cut_points)\n\n    b_len = max(1, tot_len - (a_end - a_begin))\n    # (zihang): `data_len - 1` to account for extend_target\n    b_begin = random.randint(0, data_len - 1 - b_len)\n    b_end = b_begin + b_len\n    while b_begin > 0 and sent_ids[b_begin - 1] == sent_ids[b_begin]:\n      b_begin -= 1\n    # (zihang): `data_len - 1` to account for extend_target\n    while b_end < data_len - 1 and sent_ids[b_end - 1] == sent_ids[b_end]:\n      b_end += 1\n\n    new_begin = a_end\n  else:\n    label = 1\n    a_end = random.choice(cut_points)\n    b_begin = a_end\n    b_end = end_idx\n\n    new_begin = b_end\n\n  while a_end - a_begin + b_end - b_begin > tot_len:\n    if a_end - a_begin > b_end - b_begin:\n      # delete the right side only for the LM objective\n      a_end -= 1\n    else:\n      b_end -= 1\n\n  ret = [data[a_begin: a_end], data[b_begin: b_end], label, new_begin]\n\n  if extend_target:\n    if a_end >= data_len or b_end >= data_len:\n      tf.logging.info(""[_split_a_and_b] returns None: ""\n                      ""a_end %d or b_end %d >= data_len %d"",\n                      a_end, b_end, data_len)\n      return None\n    a_target = data[a_begin + 1: a_end + 1]\n    b_target = data[b_begin: b_end + 1]\n    ret.extend([a_target, b_target])\n\n  return ret\n\n\ndef _is_start_piece(piece):\n  special_pieces = set(list(\'!""#$%&\\""()*+,-./:;?@[\\\\]^_`{|}~\'))\n  if (piece.startswith(""\xe2\x96\x81"") or piece.startswith(""<"")\n      or piece in special_pieces):\n    return True\n  else:\n    return False\n\n\ndef _sample_mask(sp, seg, reverse=False, max_gram=5, goal_num_predict=None):\n  """"""Sample `goal_num_predict` tokens for partial prediction.\n  About `mask_beta` tokens are chosen in a context of `mask_alpha` tokens.""""""\n\n  seg_len = len(seg)\n  mask = np.array([False] * seg_len, dtype=np.bool)\n\n  num_predict = 0\n\n  ngrams = np.arange(1, max_gram + 1, dtype=np.int64)\n  pvals = 1. / np.arange(1, max_gram + 1)\n  pvals /= pvals.sum(keepdims=True)\n\n  if reverse:\n    seg = np.flip(seg, 0)\n\n  cur_len = 0\n  while cur_len < seg_len:\n    if goal_num_predict is not None and num_predict >= goal_num_predict: break\n\n    n = np.random.choice(ngrams, p=pvals)\n    if goal_num_predict is not None:\n      n = min(n, goal_num_predict - num_predict)\n    ctx_size = (n * FLAGS.mask_alpha) // FLAGS.mask_beta\n    l_ctx = np.random.choice(ctx_size)\n    r_ctx = ctx_size - l_ctx\n\n    # Find the start position of a complete token\n    beg = cur_len + l_ctx\n    while beg < seg_len and not _is_start_piece(sp.IdToPiece(seg[beg].item())):\n      beg += 1\n    if beg >= seg_len:\n      break\n\n    # Find the end position of the n-gram (start pos of the n+1-th gram)\n    end = beg + 1\n    cnt_ngram = 1\n    while end < seg_len:\n      if _is_start_piece(sp.IdToPiece(seg[beg].item())):\n        cnt_ngram += 1\n        if cnt_ngram > n:\n          break\n      end += 1\n    if end >= seg_len:\n      break\n\n    # Update\n    mask[beg:end] = True\n    num_predict += end - beg\n\n    cur_len = end + r_ctx\n\n  while goal_num_predict is not None and num_predict < goal_num_predict:\n    i = np.random.randint(seg_len)\n    if not mask[i]:\n      mask[i] = True\n      num_predict += 1\n\n  if reverse:\n    mask = np.flip(mask, 0)\n\n  return mask\n\n\ndef create_tfrecords(save_dir, basename, data, bsz_per_host, seq_len,\n                     bi_data, sp):\n  data, sent_ids = data[0], data[1]\n\n  num_core = FLAGS.num_core_per_host\n  bsz_per_core = bsz_per_host // num_core\n\n  if bi_data:\n    assert bsz_per_host % (2 * FLAGS.num_core_per_host) == 0\n    fwd_data, fwd_sent_ids = batchify(data, bsz_per_host // 2, sent_ids)\n\n    fwd_data = fwd_data.reshape(num_core, 1, bsz_per_core // 2, -1)\n    fwd_sent_ids = fwd_sent_ids.reshape(num_core, 1, bsz_per_core // 2, -1)\n\n    bwd_data = fwd_data[:, :, :, ::-1]\n    bwd_sent_ids = fwd_sent_ids[:, :, :, ::-1]\n\n    data = np.concatenate(\n        [fwd_data, bwd_data], 1).reshape(bsz_per_host, -1)\n    sent_ids = np.concatenate(\n        [fwd_sent_ids, bwd_sent_ids], 1).reshape(bsz_per_host, -1)\n  else:\n    data, sent_ids = batchify(data, bsz_per_host, sent_ids)\n\n  tf.logging.info(""Raw data shape %s."", data.shape)\n\n  file_name = format_filename(\n      prefix=basename,\n      bsz_per_host=bsz_per_host,\n      seq_len=seq_len,\n      bi_data=bi_data,\n      suffix=""tfrecords"",\n      mask_alpha=FLAGS.mask_alpha,\n      mask_beta=FLAGS.mask_beta,\n      reuse_len=FLAGS.reuse_len,\n      uncased=FLAGS.uncased,\n      fixed_num_predict=FLAGS.num_predict\n  )\n  save_path = os.path.join(save_dir, file_name)\n  record_writer = tf.python_io.TFRecordWriter(save_path)\n  tf.logging.info(""Start writing %s."", save_path)\n\n  num_batch = 0\n  reuse_len = FLAGS.reuse_len\n\n  # [sep] x 2 + [cls]\n  assert reuse_len < seq_len - 3\n\n  data_len = data.shape[1]\n  sep_array = np.array([SEP_ID], dtype=np.int64)\n  cls_array = np.array([CLS_ID], dtype=np.int64)\n\n  i = 0\n  while i + seq_len <= data_len:\n    if num_batch % 500 == 0:\n      tf.logging.info(""Processing batch %d"", num_batch)\n\n    all_ok = True\n    features = []\n    for idx in range(bsz_per_host):\n      inp = data[idx, i: i + reuse_len]\n      tgt = data[idx, i + 1: i + reuse_len + 1]\n\n      results = _split_a_and_b(\n          data[idx],\n          sent_ids[idx],\n          begin_idx=i + reuse_len,\n          tot_len=seq_len - reuse_len - 3,\n          extend_target=True)\n      if results is None:\n        tf.logging.info(""Break out with seq idx %d"", i)\n        all_ok = False\n        break\n\n      # unpack the results\n      (a_data, b_data, label, _, a_target, b_target) = tuple(results)\n\n      # sample ngram spans to predict\n      reverse = bi_data and (idx // (bsz_per_core // 2)) % 2 == 1\n      if FLAGS.num_predict is None:\n        num_predict_0 = num_predict_1 = None\n      else:\n        num_predict_1 = FLAGS.num_predict // 2\n        num_predict_0 = FLAGS.num_predict - num_predict_1\n      mask_0 = _sample_mask(sp, inp, reverse=reverse,\n                            goal_num_predict=num_predict_0)\n      mask_1 = _sample_mask(sp, np.concatenate([a_data, sep_array, b_data,\n                                                sep_array, cls_array]),\n                            reverse=reverse, goal_num_predict=num_predict_1)\n\n      # concatenate data\n      cat_data = np.concatenate([inp, a_data, sep_array, b_data,\n                                 sep_array, cls_array])\n      seg_id = ([0] * (reuse_len + a_data.shape[0]) + [0] +\n                [1] * b_data.shape[0] + [1] + [2])\n      assert cat_data.shape[0] == seq_len\n      assert mask_0.shape[0] == seq_len // 2\n      assert mask_1.shape[0] == seq_len // 2\n\n      # the last two CLS\'s are not used, just for padding purposes\n      tgt = np.concatenate([tgt, a_target, b_target, cls_array, cls_array])\n      assert tgt.shape[0] == seq_len\n\n      is_masked = np.concatenate([mask_0, mask_1], 0)\n      if FLAGS.num_predict is not None:\n        assert np.sum(is_masked) == FLAGS.num_predict\n\n      feature = {\n          ""input"": _int64_feature(cat_data),\n          ""is_masked"": _int64_feature(is_masked),\n          ""target"": _int64_feature(tgt),\n          ""seg_id"": _int64_feature(seg_id),\n          ""label"": _int64_feature([label]),\n      }\n      features.append(feature)\n\n    if all_ok:\n      assert len(features) == bsz_per_host\n      for feature in features:\n        example = tf.train.Example(features=tf.train.Features(feature=feature))\n        record_writer.write(example.SerializeToString())\n      num_batch += 1\n    else:\n      break\n\n    i += reuse_len\n\n  record_writer.close()\n  tf.logging.info(""Done writing %s. Num of batches: %d"", save_path, num_batch)\n\n  return save_path, num_batch\n\n\n################\n# get_input_fn #\n################\ndef _convert_example(example, use_bfloat16):\n  """"""Cast int64 into int32 and float32 to bfloat16 if use_bfloat16.""""""\n  for key in list(example.keys()):\n    val = example[key]\n    if tf.keras.backend.is_sparse(val):\n      val = tf.sparse.to_dense(val)\n    if val.dtype == tf.int64:\n      val = tf.cast(val, tf.int32)\n    if use_bfloat16 and val.dtype == tf.float32:\n      val = tf.cast(val, tf.bfloat16)\n\n    example[key] = val\n\n\ndef parse_files_to_dataset(parser, file_names, split, num_batch, num_hosts,\n                           host_id, num_core_per_host, bsz_per_core):\n  # list of file pathes\n  num_files = len(file_names)\n  num_files_per_host = num_files // num_hosts\n  my_start_file_id = host_id * num_files_per_host\n  my_end_file_id = (host_id + 1) * num_files_per_host\n  if host_id == num_hosts - 1:\n    my_end_file_id = num_files\n  file_paths = file_names[my_start_file_id: my_end_file_id]\n  tf.logging.info(""Host %d handles %d files"", host_id, len(file_paths))\n\n  assert split == ""train""\n  dataset = tf.data.Dataset.from_tensor_slices(file_paths)\n\n  # file-level shuffle\n  if len(file_paths) > 1:\n    dataset = dataset.shuffle(len(file_paths))\n\n  # Note: we cannot perform sample-level shuffle here because this will violate\n  # the consecutive requirement of data stream.\n  dataset = tf.data.TFRecordDataset(dataset)\n\n  # (zihang): since we are doing online preprocessing, the parsed result of\n  # the same input at each time will be different. Thus, cache processed data\n  # is not helpful. It will use a lot of memory and lead to contrainer OOM.\n  # So, change to cache non-parsed raw data instead.\n  dataset = dataset.cache().map(parser).repeat()\n  dataset = dataset.batch(bsz_per_core, drop_remainder=True)\n  dataset = dataset.prefetch(num_core_per_host * bsz_per_core)\n\n  return dataset\n\n\ndef _local_perm(inputs, targets, is_masked, perm_size, seq_len):\n  """"""\n  Sample a permutation of the factorization order, and create an\n  attention mask accordingly.\n\n  Args:\n    inputs: int64 Tensor in shape [seq_len], input ids.\n    targets: int64 Tensor in shape [seq_len], target ids.\n    is_masked: bool Tensor in shape [seq_len]. True means being selected\n      for partial prediction.\n    perm_size: the length of longest permutation. Could be set to be reuse_len.\n      Should not be larger than reuse_len or there will be data leaks.\n    seq_len: int, sequence length.\n  """"""\n\n  # Generate permutation indices\n  index = tf.range(seq_len, dtype=tf.int64)\n  index = tf.transpose(tf.reshape(index, [-1, perm_size]))\n  index = tf.random_shuffle(index)\n  index = tf.reshape(tf.transpose(index), [-1])\n\n  # `perm_mask` and `target_mask`\n  # non-functional tokens\n  non_func_tokens = tf.logical_not(tf.logical_or(\n      tf.equal(inputs, SEP_ID),\n      tf.equal(inputs, CLS_ID)))\n\n  non_mask_tokens = tf.logical_and(tf.logical_not(is_masked), non_func_tokens)\n  masked_or_func_tokens = tf.logical_not(non_mask_tokens)\n\n  # Set the permutation indices of non-masked (& non-funcional) tokens to the\n  # smallest index (-1):\n  # (1) they can be seen by all other positions\n  # (2) they cannot see masked positions, so there won""t be information leak\n  smallest_index = -tf.ones([seq_len], dtype=tf.int64)\n  rev_index = tf.where(non_mask_tokens, smallest_index, index)\n\n  # Create `target_mask`: non-funcional and maksed tokens\n  # 1: use mask as input and have loss\n  # 0: use token (or [SEP], [CLS]) as input and do not have loss\n  target_tokens = tf.logical_and(masked_or_func_tokens, non_func_tokens)\n  target_mask = tf.cast(target_tokens, tf.float32)\n\n  # Create `perm_mask`\n  # `target_tokens` cannot see themselves\n  self_rev_index = tf.where(target_tokens, rev_index, rev_index + 1)\n\n  # 1: cannot attend if i <= j and j is not non-masked (masked_or_func_tokens)\n  # 0: can attend if i > j or j is non-masked\n  perm_mask = tf.logical_and(\n      self_rev_index[:, None] <= rev_index[None, :],\n      masked_or_func_tokens)\n  perm_mask = tf.cast(perm_mask, tf.float32)\n\n  # new target: [next token] for LM and [curr token] (self) for PLM\n  new_targets = tf.concat([inputs[0: 1], targets[: -1]],\n                          axis=0)\n\n  # construct inputs_k\n  inputs_k = inputs\n\n  # construct inputs_q\n  inputs_q = target_mask\n\n  return perm_mask, new_targets, target_mask, inputs_k, inputs_q\n\n\ndef get_dataset(params, num_hosts, num_core_per_host, split, file_names,\n                num_batch, seq_len, reuse_len, perm_size, mask_alpha,\n                mask_beta, use_bfloat16=False, num_predict=None):\n\n  bsz_per_core = params[""batch_size""]\n  if num_hosts > 1:\n    host_id = params[""context""].current_host\n  else:\n    host_id = 0\n\n    #### Function used to parse tfrecord\n  def parser(record):\n    """"""function used to parse tfrecord.""""""\n\n    record_spec = {\n        ""input"": tf.FixedLenFeature([seq_len], tf.int64),\n        ""target"": tf.FixedLenFeature([seq_len], tf.int64),\n        ""seg_id"": tf.FixedLenFeature([seq_len], tf.int64),\n        ""label"": tf.FixedLenFeature([1], tf.int64),\n        ""is_masked"": tf.FixedLenFeature([seq_len], tf.int64),\n    }\n\n    # retrieve serialized example\n    example = tf.parse_single_example(\n        serialized=record,\n        features=record_spec)\n\n    inputs = example.pop(""input"")\n    target = example.pop(""target"")\n    is_masked = tf.cast(example.pop(""is_masked""), tf.bool)\n\n    non_reuse_len = seq_len - reuse_len\n    assert perm_size <= reuse_len and perm_size <= non_reuse_len\n\n    perm_mask_0, target_0, target_mask_0, input_k_0, input_q_0 = _local_perm(\n        inputs[:reuse_len],\n        target[:reuse_len],\n        is_masked[:reuse_len],\n        perm_size,\n        reuse_len)\n\n    perm_mask_1, target_1, target_mask_1, input_k_1, input_q_1 = _local_perm(\n        inputs[reuse_len:],\n        target[reuse_len:],\n        is_masked[reuse_len:],\n        perm_size,\n        non_reuse_len)\n\n    perm_mask_0 = tf.concat([perm_mask_0, tf.ones([reuse_len, non_reuse_len])],\n                            axis=1)\n    perm_mask_1 = tf.concat([tf.zeros([non_reuse_len, reuse_len]), perm_mask_1],\n                            axis=1)\n    perm_mask = tf.concat([perm_mask_0, perm_mask_1], axis=0)\n    target = tf.concat([target_0, target_1], axis=0)\n    target_mask = tf.concat([target_mask_0, target_mask_1], axis=0)\n    input_k = tf.concat([input_k_0, input_k_1], axis=0)\n    input_q = tf.concat([input_q_0, input_q_1], axis=0)\n\n    if num_predict is not None:\n      indices = tf.range(seq_len, dtype=tf.int64)\n      bool_target_mask = tf.cast(target_mask, tf.bool)\n      indices = tf.boolean_mask(indices, bool_target_mask)\n\n      ##### extra padding due to CLS/SEP introduced after prepro\n      actual_num_predict = tf.shape(indices)[0]\n      pad_len = num_predict - actual_num_predict\n\n      ##### target_mapping\n      target_mapping = tf.one_hot(indices, seq_len, dtype=tf.float32)\n      paddings = tf.zeros([pad_len, seq_len], dtype=target_mapping.dtype)\n      target_mapping = tf.concat([target_mapping, paddings], axis=0)\n      example[""target_mapping""] = tf.reshape(target_mapping,\n                                             [num_predict, seq_len])\n\n      ##### target\n      target = tf.boolean_mask(target, bool_target_mask)\n      paddings = tf.zeros([pad_len], dtype=target.dtype)\n      target = tf.concat([target, paddings], axis=0)\n      example[""target""] = tf.reshape(target, [num_predict])\n\n      ##### target mask\n      target_mask = tf.concat(\n          [tf.ones([actual_num_predict], dtype=tf.float32),\n           tf.zeros([pad_len], dtype=tf.float32)],\n          axis=0)\n      example[""target_mask""] = tf.reshape(target_mask, [num_predict])\n    else:\n      example[""target""] = tf.reshape(target, [seq_len])\n      example[""target_mask""] = tf.reshape(target_mask, [seq_len])\n\n    # reshape back to fixed shape\n    example[""perm_mask""] = tf.reshape(perm_mask, [seq_len, seq_len])\n    example[""input_k""] = tf.reshape(input_k, [seq_len])\n    example[""input_q""] = tf.reshape(input_q, [seq_len])\n\n    _convert_example(example, use_bfloat16)\n\n    for k, v in example.items():\n      tf.logging.info(""%s: %s"", k, v)\n\n    return example\n\n  # Get dataset\n  dataset = parse_files_to_dataset(\n      parser=parser,\n      file_names=file_names,\n      split=split,\n      num_batch=num_batch,\n      num_hosts=num_hosts,\n      host_id=host_id,\n      num_core_per_host=num_core_per_host,\n      bsz_per_core=bsz_per_core)\n\n  return dataset\n\n\ndef get_input_fn(\n    tfrecord_dir,\n    split,\n    bsz_per_host,\n    seq_len,\n    reuse_len,\n    bi_data,\n    num_hosts=1,\n    num_core_per_host=1,\n    perm_size=None,\n    mask_alpha=None,\n    mask_beta=None,\n    uncased=False,\n    num_passes=None,\n    use_bfloat16=False,\n    num_predict=None):\n\n  # Merge all record infos into a single one\n  record_glob_base = format_filename(\n      prefix=""record_info-{}-*"".format(split),\n      bsz_per_host=bsz_per_host,\n      seq_len=seq_len,\n      bi_data=bi_data,\n      suffix=""json"",\n      mask_alpha=mask_alpha,\n      mask_beta=mask_beta,\n      reuse_len=reuse_len,\n      uncased=uncased,\n      fixed_num_predict=num_predict)\n\n  record_info = {""num_batch"": 0, ""filenames"": []}\n\n  tfrecord_dirs = tfrecord_dir.split("","")\n  tf.logging.info(""Use the following tfrecord dirs: %s"", tfrecord_dirs)\n\n  for idx, record_dir in enumerate(tfrecord_dirs):\n    record_glob = os.path.join(record_dir, record_glob_base)\n    tf.logging.info(""[%d] Record glob: %s"", idx, record_glob)\n\n    record_paths = sorted(tf.gfile.Glob(record_glob))\n    tf.logging.info(""[%d] Num of record info path: %d"",\n                    idx, len(record_paths))\n\n    cur_record_info = {""num_batch"": 0, ""filenames"": []}\n\n    for record_info_path in record_paths:\n      if num_passes is not None:\n        record_info_name = os.path.basename(record_info_path)\n        fields = record_info_name.split(""."")[0].split(""-"")\n        pass_id = int(fields[-1])\n        if len(fields) == 5 and pass_id >= num_passes:\n          tf.logging.info(""Skip pass %d: %s"", pass_id, record_info_name)\n          continue\n\n      with tf.gfile.Open(record_info_path, ""r"") as fp:\n        info = json.load(fp)\n        if num_passes is not None:\n          eff_num_passes = min(num_passes, len(info[""filenames""]))\n          ratio = eff_num_passes / len(info[""filenames""])\n          cur_record_info[""num_batch""] += int(info[""num_batch""] * ratio)\n          cur_record_info[""filenames""] += info[""filenames""][:eff_num_passes]\n        else:\n          cur_record_info[""num_batch""] += info[""num_batch""]\n          cur_record_info[""filenames""] += info[""filenames""]\n\n    # overwrite directory for `cur_record_info`\n    new_filenames = []\n    for filename in cur_record_info[""filenames""]:\n      basename = os.path.basename(filename)\n      new_filename = os.path.join(record_dir, basename)\n      new_filenames.append(new_filename)\n    cur_record_info[""filenames""] = new_filenames\n\n    tf.logging.info(""[Dir %d] Number of chosen batches: %s"",\n                    idx, cur_record_info[""num_batch""])\n    tf.logging.info(""[Dir %d] Number of chosen files: %s"",\n                    idx, len(cur_record_info[""filenames""]))\n    tf.logging.info(cur_record_info[""filenames""])\n\n    # add `cur_record_info` to global `record_info`\n    record_info[""num_batch""] += cur_record_info[""num_batch""]\n    record_info[""filenames""] += cur_record_info[""filenames""]\n\n  tf.logging.info(""Total number of batches: %d"",\n                  record_info[""num_batch""])\n  tf.logging.info(""Total number of files: %d"",\n                  len(record_info[""filenames""]))\n  tf.logging.info(record_info[""filenames""])\n\n  def input_fn(params):\n    """"""docs.""""""\n    assert params[""batch_size""] * num_core_per_host == bsz_per_host\n\n    dataset = get_dataset(\n        params=params,\n        num_hosts=num_hosts,\n        num_core_per_host=num_core_per_host,\n        split=split,\n        file_names=record_info[""filenames""],\n        num_batch=record_info[""num_batch""],\n        seq_len=seq_len,\n        reuse_len=reuse_len,\n        perm_size=perm_size,\n        mask_alpha=mask_alpha,\n        mask_beta=mask_beta,\n        use_bfloat16=use_bfloat16,\n        num_predict=num_predict)\n\n    return dataset\n\n  return input_fn, record_info\n\n\nif __name__ == ""__main__"":\n  FLAGS = flags.FLAGS\n  flags.DEFINE_bool(""use_tpu"", True, help=""whether to use TPUs"")\n  flags.DEFINE_integer(""bsz_per_host"", 32, help=""batch size per host."")\n  flags.DEFINE_integer(""num_core_per_host"", 8, help=""num TPU cores per host."")\n\n  flags.DEFINE_integer(""seq_len"", 512,\n                       help=""Sequence length."")\n  flags.DEFINE_integer(""reuse_len"", 256,\n                       help=""Number of token that can be reused as memory. ""\n                       ""Could be half of `seq_len`."")\n  flags.DEFINE_bool(""uncased"", True, help=""Use uncased inputs or not."")\n  flags.DEFINE_bool(""bi_data"", True,\n                    help=""whether to create bidirectional data"")\n  flags.DEFINE_integer(""mask_alpha"", default=6,\n                       help=""How many tokens to form a group."")\n  flags.DEFINE_integer(""mask_beta"", default=1,\n                       help=""How many tokens to mask within each group."")\n  flags.DEFINE_bool(""use_eod"", True,\n                    help=""whether to append EOD at the end of a doc."")\n  flags.DEFINE_bool(""from_raw_text"", True,\n                    help=""Whether the input is raw text or encoded ids."")\n  flags.DEFINE_integer(""num_predict"", default=85,\n                       help=""Num of tokens to predict."")\n\n  flags.DEFINE_string(""input_glob"", ""data/example/*.txt"",\n                      help=""Input file glob."")\n  flags.DEFINE_string(""sp_path"", """", help=""Path to the sentence piece model."")\n  flags.DEFINE_string(""save_dir"", ""proc_data/example"",\n                      help=""Directory for saving the processed data."")\n  flags.DEFINE_enum(""split"", ""train"", [""train"", ""dev"", ""test""],\n                    help=""Save the data as which split."")\n\n  flags.DEFINE_integer(""pass_id"", 0, help=""ID of the current pass.""\n                       ""Different passes sample different negative segment."")\n  flags.DEFINE_integer(""num_task"", 1, help=""Number of total tasks."")\n  flags.DEFINE_integer(""task"", 0, help=""The Task ID. This value is used when ""\n                       ""using multiple workers to identify each worker."")\n\n  tf.logging.set_verbosity(tf.logging.INFO)\n  tf.app.run(create_data)\n'"
baselines/models/xlnet/function_builder.py,83,"b'""""""doc.""""""\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\nimport os\nimport tensorflow as tf\nimport modeling\nimport xlnet\n\n\ndef construct_scalar_host_call(\n    monitor_dict,\n    model_dir,\n    prefix="""",\n    reduce_fn=None):\n  """"""\n  Construct host calls to monitor training progress on TPUs.\n  """"""\n\n  metric_names = list(monitor_dict.keys())\n\n  def host_call_fn(global_step, *args):\n    """"""actual host call function.""""""\n    step = global_step[0]\n    with tf.contrib.summary.create_file_writer(\n        logdir=model_dir, filename_suffix="".host_call"").as_default():\n      with tf.contrib.summary.always_record_summaries():\n        for i, name in enumerate(metric_names):\n          if reduce_fn is None:\n            scalar = args[i][0]\n          else:\n            scalar = reduce_fn(args[i])\n          with tf.contrib.summary.record_summaries_every_n_global_steps(\n              100, global_step=step):\n            tf.contrib.summary.scalar(prefix + name, scalar, step=step)\n\n        return tf.contrib.summary.all_summary_ops()\n\n  global_step_tensor = tf.reshape(tf.train.get_or_create_global_step(), [1])\n  other_tensors = [tf.reshape(monitor_dict[key], [1]) for key in metric_names]\n\n  return host_call_fn, [global_step_tensor] + other_tensors\n\n\ndef two_stream_loss(FLAGS, features, labels, mems, is_training):\n  """"""Pretraining loss with two-stream attention Transformer-XL.""""""\n\n  #### Unpack input\n  mem_name = ""mems""\n  mems = mems.get(mem_name, None)\n\n  inp_k = tf.transpose(features[""input_k""], [1, 0])\n  inp_q = tf.transpose(features[""input_q""], [1, 0])\n\n  seg_id = tf.transpose(features[""seg_id""], [1, 0])\n\n  inp_mask = None\n  perm_mask = tf.transpose(features[""perm_mask""], [1, 2, 0])\n\n  if FLAGS.num_predict is not None:\n    # [num_predict x tgt_len x bsz]\n    target_mapping = tf.transpose(features[""target_mapping""], [1, 2, 0])\n  else:\n    target_mapping = None\n\n  # target for LM loss\n  tgt = tf.transpose(features[""target""], [1, 0])\n\n  # target mask for LM loss\n  tgt_mask = tf.transpose(features[""target_mask""], [1, 0])\n\n  # construct xlnet config and save to model_dir\n  xlnet_config = xlnet.XLNetConfig(FLAGS=FLAGS)\n  xlnet_config.to_json(os.path.join(FLAGS.model_dir, ""config.json""))\n\n  # construct run config from FLAGS\n  run_config = xlnet.create_run_config(is_training, False, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp_k,\n      seg_ids=seg_id,\n      input_mask=inp_mask,\n      mems=mems,\n      perm_mask=perm_mask,\n      target_mapping=target_mapping,\n      inp_q=inp_q)\n\n  output = xlnet_model.get_sequence_output()\n  new_mems = {mem_name: xlnet_model.get_new_memory()}\n  lookup_table = xlnet_model.get_embedding_table()\n\n  initializer = xlnet_model.get_initializer()\n\n  with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n    # LM loss\n    lm_loss = modeling.lm_loss(\n        hidden=output,\n        target=tgt,\n        n_token=xlnet_config.n_token,\n        d_model=xlnet_config.d_model,\n        initializer=initializer,\n        lookup_table=lookup_table,\n        tie_weight=True,\n        bi_data=run_config.bi_data,\n        use_tpu=run_config.use_tpu)\n\n  #### Quantity to monitor\n  monitor_dict = {}\n\n  if FLAGS.use_bfloat16:\n    tgt_mask = tf.cast(tgt_mask, tf.float32)\n    lm_loss = tf.cast(lm_loss, tf.float32)\n\n  total_loss = tf.reduce_sum(lm_loss * tgt_mask) / tf.reduce_sum(tgt_mask)\n  monitor_dict[""total_loss""] = total_loss\n\n  return total_loss, new_mems, monitor_dict\n\n\ndef get_loss(FLAGS, features, labels, mems, is_training):\n  """"""Pretraining loss with two-stream attention Transformer-XL.""""""\n  if FLAGS.use_bfloat16:\n    with tf.tpu.bfloat16_scope():\n      return two_stream_loss(FLAGS, features, labels, mems, is_training)\n  else:\n    return two_stream_loss(FLAGS, features, labels, mems, is_training)\n\n\ndef get_classification_loss(\n    FLAGS, features, n_class, is_training):\n  """"""Loss for downstream classification tasks.""""""\n\n  bsz_per_core = tf.shape(features[""input_ids""])[0]\n\n  inp = tf.transpose(features[""input_ids""], [1, 0])\n  seg_id = tf.transpose(features[""segment_ids""], [1, 0])\n  inp_mask = tf.transpose(features[""input_mask""], [1, 0])\n  label = tf.reshape(features[""label_ids""], [bsz_per_core])\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n\n  summary = xlnet_model.get_pooled_out(FLAGS.summary_type, FLAGS.use_summ_proj)\n\n  with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n\n    if FLAGS.cls_scope is not None and FLAGS.cls_scope:\n      cls_scope = ""classification_{}"".format(FLAGS.cls_scope)\n    else:\n      cls_scope = ""classification_{}"".format(FLAGS.task_name.lower())\n\n    per_example_loss, logits = modeling.classification_loss(\n        hidden=summary,\n        labels=label,\n        n_class=n_class,\n        initializer=xlnet_model.get_initializer(),\n        scope=cls_scope,\n        return_logits=True)\n\n    total_loss = tf.reduce_mean(per_example_loss)\n\n    return total_loss, per_example_loss, logits\n\n\ndef get_regression_loss(\n    FLAGS, features, is_training):\n  """"""Loss for downstream regression tasks.""""""\n\n  bsz_per_core = tf.shape(features[""input_ids""])[0]\n\n  inp = tf.transpose(features[""input_ids""], [1, 0])\n  seg_id = tf.transpose(features[""segment_ids""], [1, 0])\n  inp_mask = tf.transpose(features[""input_mask""], [1, 0])\n  label = tf.reshape(features[""label_ids""], [bsz_per_core])\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n\n  summary = xlnet_model.get_pooled_out(FLAGS.summary_type, FLAGS.use_summ_proj)\n\n  with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n    per_example_loss, logits = modeling.regression_loss(\n        hidden=summary,\n        labels=label,\n        initializer=xlnet_model.get_initializer(),\n        scope=""regression_{}"".format(FLAGS.task_name.lower()),\n        return_logits=True)\n\n    total_loss = tf.reduce_mean(per_example_loss)\n\n    return total_loss, per_example_loss, logits\n\n\ndef get_qa_outputs(FLAGS, features, is_training):\n  """"""Loss for downstream span-extraction QA tasks such as SQuAD.""""""\n\n  inp = tf.transpose(features[""input_ids""], [1, 0])\n  seg_id = tf.transpose(features[""segment_ids""], [1, 0])\n  inp_mask = tf.transpose(features[""input_mask""], [1, 0])\n\n  seq_len = tf.shape(inp)[0]\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n  output = xlnet_model.get_sequence_output()\n  initializer = xlnet_model.get_initializer()\n\n  return_dict = {}\n\n  # invalid position mask such as query and special symbols (PAD, SEP, CLS)\n  p_mask = features[""p_mask""]\n\n  # logit of the start position\n  with tf.variable_scope(""start_logits""):\n    start_logits = tf.layers.dense(\n        output,\n        1,\n        kernel_initializer=initializer)\n    start_logits = tf.transpose(tf.squeeze(start_logits, -1), [1, 0])\n    start_logits_masked = start_logits * (1 - p_mask) - 1e30 * p_mask\n    start_log_probs = tf.nn.log_softmax(start_logits_masked, -1)\n\n  # logit of the end position\n  with tf.variable_scope(""end_logits""):\n    if is_training:\n      # during training, compute the end logits based on the\n      # ground truth of the start position\n\n      start_positions = tf.reshape(features[""start_positions""], [-1])\n      start_index = tf.one_hot(start_positions, depth=seq_len, axis=-1,\n                               dtype=tf.float32)\n      start_features = tf.einsum(""lbh,bl->bh"", output, start_index)\n      start_features = tf.tile(start_features[None], [seq_len, 1, 1])\n      end_logits = tf.layers.dense(\n          tf.concat([output, start_features], axis=-1), xlnet_config.d_model,\n          kernel_initializer=initializer, activation=tf.tanh, name=""dense_0"")\n      end_logits = tf.contrib.layers.layer_norm(\n          end_logits, begin_norm_axis=-1)\n\n      end_logits = tf.layers.dense(\n          end_logits, 1,\n          kernel_initializer=initializer,\n          name=""dense_1"")\n      end_logits = tf.transpose(tf.squeeze(end_logits, -1), [1, 0])\n      end_logits_masked = end_logits * (1 - p_mask) - 1e30 * p_mask\n      end_log_probs = tf.nn.log_softmax(end_logits_masked, -1)\n    else:\n      # during inference, compute the end logits based on beam search\n\n      start_top_log_probs, start_top_index = tf.nn.top_k(\n          start_log_probs, k=FLAGS.start_n_top)\n      start_index = tf.one_hot(start_top_index,\n                               depth=seq_len, axis=-1, dtype=tf.float32)\n      start_features = tf.einsum(""lbh,bkl->bkh"", output, start_index)\n      end_input = tf.tile(output[:, :, None],\n                          [1, 1, FLAGS.start_n_top, 1])\n      start_features = tf.tile(start_features[None],\n                               [seq_len, 1, 1, 1])\n      end_input = tf.concat([end_input, start_features], axis=-1)\n      end_logits = tf.layers.dense(\n          end_input,\n          xlnet_config.d_model,\n          kernel_initializer=initializer,\n          activation=tf.tanh,\n          name=""dense_0"")\n      end_logits = tf.contrib.layers.layer_norm(end_logits,\n                                                begin_norm_axis=-1)\n      end_logits = tf.layers.dense(\n          end_logits,\n          1,\n          kernel_initializer=initializer,\n          name=""dense_1"")\n      end_logits = tf.reshape(end_logits, [seq_len, -1, FLAGS.start_n_top])\n      end_logits = tf.transpose(end_logits, [1, 2, 0])\n      end_logits_masked = end_logits * (\n          1 - p_mask[:, None]) - 1e30 * p_mask[:, None]\n      end_log_probs = tf.nn.log_softmax(end_logits_masked, -1)\n      end_top_log_probs, end_top_index = tf.nn.top_k(\n          end_log_probs, k=FLAGS.end_n_top)\n      end_top_log_probs = tf.reshape(\n          end_top_log_probs,\n          [-1, FLAGS.start_n_top * FLAGS.end_n_top])\n      end_top_index = tf.reshape(\n          end_top_index,\n          [-1, FLAGS.start_n_top * FLAGS.end_n_top])\n\n  if is_training:\n    return_dict[""start_log_probs""] = start_log_probs\n    return_dict[""end_log_probs""] = end_log_probs\n  else:\n    return_dict[""start_top_log_probs""] = start_top_log_probs\n    return_dict[""start_top_index""] = start_top_index\n    return_dict[""end_top_log_probs""] = end_top_log_probs\n    return_dict[""end_top_index""] = end_top_index\n\n  return return_dict\n\n\ndef get_race_loss(FLAGS, features, is_training):\n  """"""Loss for downstream multi-choice QA tasks such as RACE.""""""\n\n  bsz_per_core = tf.shape(features[""input_ids""])[0]\n\n  def _transform_features(feature):\n    out = tf.reshape(feature, [bsz_per_core, 4, -1])\n    out = tf.transpose(out, [2, 0, 1])\n    out = tf.reshape(out, [-1, bsz_per_core * 4])\n    return out\n\n  inp = _transform_features(features[""input_ids""])\n  seg_id = _transform_features(features[""segment_ids""])\n  inp_mask = _transform_features(features[""input_mask""])\n  label = tf.reshape(features[""label_ids""], [bsz_per_core])\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n  summary = xlnet_model.get_pooled_out(FLAGS.summary_type, FLAGS.use_summ_proj)\n\n  with tf.variable_scope(""logits""):\n    logits = tf.layers.dense(summary, 1,\n        kernel_initializer=xlnet_model.get_initializer())\n    logits = tf.reshape(logits, [bsz_per_core, 4])\n\n    one_hot_target = tf.one_hot(label, 4)\n    per_example_loss = -tf.reduce_sum(\n        tf.nn.log_softmax(logits) * one_hot_target, -1)\n    total_loss = tf.reduce_mean(per_example_loss)\n\n  return total_loss, per_example_loss, logits\n\n'"
baselines/models/xlnet/gpu_utils.py,7,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tensorflow as tf\n\ndef assign_to_gpu(gpu=0, ps_dev=""/device:CPU:0""):\n    def _assign(op):\n        node_def = op if isinstance(op, tf.NodeDef) else op.node_def\n        if node_def.op == ""Variable"":\n            return ps_dev\n        else:\n            return ""/gpu:%d"" % gpu\n    return _assign\n\n\ndef average_grads_and_vars(tower_grads_and_vars):\n    def average_dense(grad_and_vars):\n        if len(grad_and_vars) == 1:\n            return grad_and_vars[0][0]\n\n        grad = grad_and_vars[0][0]\n        for g, _ in grad_and_vars[1:]:\n            grad += g\n        return grad / len(grad_and_vars)\n\n    def average_sparse(grad_and_vars):\n        if len(grad_and_vars) == 1:\n            return grad_and_vars[0][0]\n\n        indices = []\n        values = []\n        for g, _ in grad_and_vars:\n            indices += [g.indices]\n            values += [g.values]\n        indices = tf.concat(indices, 0)\n        values = tf.concat(values, 0) / len(grad_and_vars)\n        return tf.IndexedSlices(values, indices, grad_and_vars[0][0].dense_shape)\n\n    average_grads_and_vars = []\n    for grad_and_vars in zip(*tower_grads_and_vars):\n        if grad_and_vars[0][0] is None:\n            grad = None\n        elif isinstance(grad_and_vars[0][0], tf.IndexedSlices):\n            grad = average_sparse(grad_and_vars)\n        else:\n            grad = average_dense(grad_and_vars)\n        # Keep in mind that the Variables are redundant because they are shared\n        # across towers. So .. we will just return the first tower\'s pointer to\n        # the Variable.\n        v = grad_and_vars[0][1]\n        grad_and_var = (grad, v)\n        average_grads_and_vars.append(grad_and_var)\n    return average_grads_and_vars\n\n\ndef load_from_checkpoint(saver, logdir):\n    sess = tf.get_default_session()\n    ckpt = tf.train.get_checkpoint_state(logdir)\n    if ckpt and ckpt.model_checkpoint_path:\n        if os.path.isabs(ckpt.model_checkpoint_path):\n            # Restores from checkpoint with absolute path.\n            saver.restore(sess, ckpt.model_checkpoint_path)\n        else:\n            # Restores from checkpoint with relative path.\n            saver.restore(sess, os.path.join(logdir, ckpt.model_checkpoint_path))\n        return True\n    return False\n'"
baselines/models/xlnet/model_utils.py,75,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport re\nimport numpy as np\nimport six\nfrom os.path import join\nfrom six.moves import zip\n\nfrom absl import flags\n\nimport tensorflow as tf\n\n\ndef configure_tpu(FLAGS):\n  if FLAGS.use_tpu:\n    tpu_cluster = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n    master = tpu_cluster.get_master()\n  else:\n    tpu_cluster = None\n    master = FLAGS.master\n\n  session_config = tf.ConfigProto(allow_soft_placement=True)\n  # Uncomment the following line if you hope to monitor GPU RAM growth\n  # session_config.gpu_options.allow_growth = True\n\n  if FLAGS.use_tpu:\n    strategy = None\n    tf.logging.info(\'Use TPU without distribute strategy.\')\n  elif FLAGS.num_core_per_host == 1:\n    strategy = None\n    tf.logging.info(\'Single device mode.\')\n  else:\n    strategy = tf.contrib.distribute.MirroredStrategy(\n        num_gpus=FLAGS.num_core_per_host)\n    tf.logging.info(\'Use MirroredStrategy with %d devices.\',\n                    strategy.num_replicas_in_sync)\n\n  per_host_input = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      master=master,\n      model_dir=FLAGS.model_dir,\n      session_config=session_config,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations,\n          num_shards=FLAGS.num_hosts * FLAGS.num_core_per_host,\n          per_host_input_for_training=per_host_input),\n      keep_checkpoint_max=FLAGS.max_save,\n      save_checkpoints_secs=None,\n      save_checkpoints_steps=FLAGS.save_steps,\n      train_distribute=strategy\n  )\n  return run_config\n\n\ndef init_from_checkpoint(FLAGS, global_vars=False):\n  tvars = tf.global_variables() if global_vars else tf.trainable_variables()\n  initialized_variable_names = {}\n  scaffold_fn = None\n  if FLAGS.init_checkpoint is not None:\n    if FLAGS.init_checkpoint.endswith(""latest""):\n      ckpt_dir = os.path.dirname(FLAGS.init_checkpoint)\n      init_checkpoint = tf.train.latest_checkpoint(ckpt_dir)\n    else:\n      init_checkpoint = FLAGS.init_checkpoint\n\n    tf.logging.info(""Initialize from the ckpt {}"".format(init_checkpoint))\n\n    (assignment_map, initialized_variable_names\n    ) = get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n    if FLAGS.use_tpu:\n      def tpu_scaffold():\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        return tf.train.Scaffold()\n\n      scaffold_fn = tpu_scaffold\n    else:\n      tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    # Log customized initialization\n    tf.logging.info(""**** Global Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n  return scaffold_fn\n\n\ndef get_train_op(FLAGS, total_loss, grads_and_vars=None):\n  global_step = tf.train.get_or_create_global_step()\n\n  # increase the learning rate linearly\n  if FLAGS.warmup_steps > 0:\n    warmup_lr = (tf.cast(global_step, tf.float32)\n                 / tf.cast(FLAGS.warmup_steps, tf.float32)\n                 * FLAGS.learning_rate)\n  else:\n    warmup_lr = 0.0\n\n  # decay the learning rate\n  if FLAGS.decay_method == ""poly"":\n    decay_lr = tf.train.polynomial_decay(\n        FLAGS.learning_rate,\n        global_step=global_step - FLAGS.warmup_steps,\n        decay_steps=FLAGS.train_steps - FLAGS.warmup_steps,\n        end_learning_rate=FLAGS.learning_rate * FLAGS.min_lr_ratio)\n  elif FLAGS.decay_method == ""cos"":\n    decay_lr = tf.train.cosine_decay(\n        FLAGS.learning_rate,\n        global_step=global_step - FLAGS.warmup_steps,\n        decay_steps=FLAGS.train_steps - FLAGS.warmup_steps,\n        alpha=FLAGS.min_lr_ratio)\n  else:\n    raise ValueError(FLAGS.decay_method)\n\n  learning_rate = tf.where(global_step < FLAGS.warmup_steps,\n                           warmup_lr, decay_lr)\n\n  if (FLAGS.weight_decay > 0 and not FLAGS.use_tpu and\n      FLAGS.num_core_per_host > 1):\n    raise ValueError(""Do not support `weight_decay > 0` with multi-gpu ""\n                     ""training so far."")\n\n  if FLAGS.weight_decay == 0:\n    optimizer = tf.train.AdamOptimizer(\n        learning_rate=learning_rate,\n        epsilon=FLAGS.adam_epsilon)\n  else:\n    optimizer = AdamWeightDecayOptimizer(\n        learning_rate=learning_rate,\n        epsilon=FLAGS.adam_epsilon,\n        exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""],\n        weight_decay_rate=FLAGS.weight_decay)\n\n  if FLAGS.use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  if grads_and_vars is None:\n    grads_and_vars = optimizer.compute_gradients(total_loss)\n  gradients, variables = zip(*grads_and_vars)\n  clipped, gnorm = tf.clip_by_global_norm(gradients, FLAGS.clip)\n\n  if getattr(FLAGS, ""lr_layer_decay_rate"", 1.0) != 1.0:\n    n_layer = 0\n    for i in range(len(clipped)):\n      m = re.search(r""model/transformer/layer_(\\d+?)/"", variables[i].name)\n      if not m: continue\n      n_layer = max(n_layer, int(m.group(1)) + 1)\n\n    for i in range(len(clipped)):\n      for l in range(n_layer):\n        if ""model/transformer/layer_{}/"".format(l) in variables[i].name:\n          abs_rate = FLAGS.lr_layer_decay_rate ** (n_layer - 1 - l)\n          clipped[i] *= abs_rate\n          tf.logging.info(""Apply mult {:.4f} to layer-{} grad of {}"".format(\n              abs_rate, l, variables[i].name))\n          break\n\n  train_op = optimizer.apply_gradients(\n      zip(clipped, variables), global_step=global_step)\n\n  # Manually increment `global_step` for AdamWeightDecayOptimizer\n  if FLAGS.weight_decay > 0:\n    new_global_step = global_step + 1\n    train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n\n  return train_op, learning_rate, gnorm\n\n\ndef clean_ckpt(_):\n  input_ckpt = FLAGS.clean_input_ckpt\n  output_model_dir = FLAGS.clean_output_model_dir\n\n  tf.reset_default_graph()\n\n  var_list = tf.contrib.framework.list_variables(input_ckpt)\n  var_values, var_dtypes = {}, {}\n  for (name, shape) in var_list:\n    if not name.startswith(""global_step"") and ""adam"" not in name.lower():\n      var_values[name] = None\n      tf.logging.info(""Include {}"".format(name))\n    else:\n      tf.logging.info(""Exclude {}"".format(name))\n\n  tf.logging.info(""Loading from {}"".format(input_ckpt))\n  reader = tf.contrib.framework.load_checkpoint(input_ckpt)\n  for name in var_values:\n    tensor = reader.get_tensor(name)\n    var_dtypes[name] = tensor.dtype\n    var_values[name] = tensor\n\n  with tf.variable_scope(tf.get_variable_scope(), reuse=tf.AUTO_REUSE):\n    tf_vars = [\n        tf.get_variable(v, shape=var_values[v].shape, dtype=var_dtypes[v])\n        for v in var_values\n    ]\n  placeholders = [tf.placeholder(v.dtype, shape=v.shape) for v in tf_vars]\n  assign_ops = [tf.assign(v, p) for (v, p) in zip(tf_vars, placeholders)]\n  global_step = tf.Variable(\n      0, name=""global_step"", trainable=False, dtype=tf.int64)\n  saver = tf.train.Saver(tf.all_variables())\n\n  if not tf.gfile.Exists(output_model_dir):\n    tf.gfile.MakeDirs(output_model_dir)\n\n  # Build a model consisting only of variables, set them to the average values.\n  with tf.Session() as sess:\n    sess.run(tf.initialize_all_variables())\n    for p, assign_op, (name, value) in zip(placeholders, assign_ops,\n                                           six.iteritems(var_values)):\n      sess.run(assign_op, {p: value})\n\n    # Use the built saver to save the averaged checkpoint.\n    saver.save(sess, join(output_model_dir, ""model.ckpt""),\n               global_step=global_step)\n\n\ndef avg_checkpoints(model_dir, output_model_dir, last_k):\n  tf.reset_default_graph()\n\n  checkpoint_state = tf.train.get_checkpoint_state(model_dir)\n  checkpoints = checkpoint_state.all_model_checkpoint_paths[- last_k:]\n  var_list = tf.contrib.framework.list_variables(checkpoints[0])\n  var_values, var_dtypes = {}, {}\n  for (name, shape) in var_list:\n    if not name.startswith(""global_step""):\n      var_values[name] = np.zeros(shape)\n  for checkpoint in checkpoints:\n    reader = tf.contrib.framework.load_checkpoint(checkpoint)\n    for name in var_values:\n      tensor = reader.get_tensor(name)\n      var_dtypes[name] = tensor.dtype\n      var_values[name] += tensor\n    tf.logging.info(""Read from checkpoint %s"", checkpoint)\n  for name in var_values:  # Average.\n    var_values[name] /= len(checkpoints)\n\n  with tf.variable_scope(tf.get_variable_scope(), reuse=tf.AUTO_REUSE):\n    tf_vars = [\n        tf.get_variable(v, shape=var_values[v].shape, dtype=var_dtypes[v])\n        for v in var_values\n    ]\n  placeholders = [tf.placeholder(v.dtype, shape=v.shape) for v in tf_vars]\n  assign_ops = [tf.assign(v, p) for (v, p) in zip(tf_vars, placeholders)]\n  global_step = tf.Variable(\n      0, name=""global_step"", trainable=False, dtype=tf.int64)\n  saver = tf.train.Saver(tf.all_variables())\n\n  # Build a model consisting only of variables, set them to the average values.\n  with tf.Session() as sess:\n    sess.run(tf.initialize_all_variables())\n    for p, assign_op, (name, value) in zip(placeholders, assign_ops,\n                                           six.iteritems(var_values)):\n      sess.run(assign_op, {p: value})\n    # Use the built saver to save the averaged checkpoint.\n    saver.save(sess, join(output_model_dir, ""model.ckpt""),\n        global_step=global_step)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    # tf.logging.info(\'original name: %s\', name)\n    if name not in name_to_variable:\n      continue\n    # assignment_map[name] = name\n    assignment_map[name] = name_to_variable[name]\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               include_in_weight_decay=[""r_s_bias"", ""r_r_bias"", ""r_w_bias""],\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n    self.include_in_weight_decay = include_in_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    for r in self.include_in_weight_decay:\n      if re.search(r, param_name) is not None:\n        return True\n\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          tf.logging.info(\'Adam WD excludes {}\'.format(param_name))\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n\n\nif __name__ == ""__main__"":\n  flags.DEFINE_string(""clean_input_ckpt"", """", ""input ckpt for cleaning"")\n  flags.DEFINE_string(""clean_output_model_dir"", """", ""output dir for cleaned ckpt"")\n\n  FLAGS = flags.FLAGS\n\n  tf.app.run(clean_ckpt)\n'"
baselines/models/xlnet/modeling.py,135,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport tensorflow as tf\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef embedding_lookup(x, n_token, d_embed, initializer, use_tpu=True,\n                     scope=\'embedding\', reuse=None, dtype=tf.float32):\n  """"""TPU and GPU embedding_lookup function.""""""\n  with tf.variable_scope(scope, reuse=reuse):\n    lookup_table = tf.get_variable(\'lookup_table\', [n_token, d_embed],\n                                   dtype=dtype, initializer=initializer)\n    if use_tpu:\n      one_hot_idx = tf.one_hot(x, n_token, dtype=dtype)\n      if one_hot_idx.shape.ndims == 2:\n        return tf.einsum(\'in,nd->id\', one_hot_idx, lookup_table), lookup_table\n      else:\n        return tf.einsum(\'ibn,nd->ibd\', one_hot_idx, lookup_table), lookup_table\n    else:\n      return tf.nn.embedding_lookup(lookup_table, x), lookup_table\n\n\ndef positional_embedding(pos_seq, inv_freq, bsz=None):\n  sinusoid_inp = tf.einsum(\'i,d->id\', pos_seq, inv_freq)\n  pos_emb = tf.concat([tf.sin(sinusoid_inp), tf.cos(sinusoid_inp)], -1)\n  pos_emb = pos_emb[:, None, :]\n\n  if bsz is not None:\n    pos_emb = tf.tile(pos_emb, [1, bsz, 1])\n\n  return pos_emb\n\n\ndef positionwise_ffn(inp, d_model, d_inner, dropout, kernel_initializer,\n                     activation_type=\'relu\', scope=\'ff\', is_training=True,\n                     reuse=None):\n  """"""Position-wise Feed-forward Network.""""""\n  if activation_type == \'relu\':\n    activation = tf.nn.relu\n  elif activation_type == \'gelu\':\n    activation = gelu\n  else:\n    raise ValueError(\'Unsupported activation type {}\'.format(activation_type))\n\n  output = inp\n  with tf.variable_scope(scope, reuse=reuse):\n    output = tf.layers.dense(output, d_inner, activation=activation,\n                             kernel_initializer=kernel_initializer,\n                             name=\'layer_1\')\n    output = tf.layers.dropout(output, dropout, training=is_training,\n                               name=\'drop_1\')\n    output = tf.layers.dense(output, d_model,\n                             kernel_initializer=kernel_initializer,\n                             name=\'layer_2\')\n    output = tf.layers.dropout(output, dropout, training=is_training,\n                               name=\'drop_2\')\n    output = tf.contrib.layers.layer_norm(output + inp, begin_norm_axis=-1,\n                                          scope=\'LayerNorm\')\n  return output\n\n\ndef head_projection(h, d_model, n_head, d_head, kernel_initializer, name):\n  """"""Project hidden states to a specific head with a 4D-shape.""""""\n  proj_weight = tf.get_variable(\'{}/kernel\'.format(name),\n                                [d_model, n_head, d_head], dtype=h.dtype,\n                                initializer=kernel_initializer)\n  head = tf.einsum(\'ibh,hnd->ibnd\', h, proj_weight)\n\n  return head\n\n\ndef post_attention(h, attn_vec, d_model, n_head, d_head, dropout, is_training,\n                   kernel_initializer, residual=True):\n  """"""Post-attention processing.""""""\n  # post-attention projection (back to `d_model`)\n  proj_o = tf.get_variable(\'o/kernel\', [d_model, n_head, d_head],\n                           dtype=h.dtype, initializer=kernel_initializer)\n  attn_out = tf.einsum(\'ibnd,hnd->ibh\', attn_vec, proj_o)\n\n  attn_out = tf.layers.dropout(attn_out, dropout, training=is_training)\n  if residual:\n    output = tf.contrib.layers.layer_norm(attn_out + h, begin_norm_axis=-1,\n                                          scope=\'LayerNorm\')\n  else:\n    output = tf.contrib.layers.layer_norm(attn_out, begin_norm_axis=-1,\n                                          scope=\'LayerNorm\')\n\n  return output\n\n\ndef abs_attn_core(q_head, k_head, v_head, attn_mask, dropatt, is_training,\n                  scale):\n  """"""Core absolute positional attention operations.""""""\n\n  attn_score = tf.einsum(\'ibnd,jbnd->ijbn\', q_head, k_head)\n  attn_score *= scale\n  if attn_mask is not None:\n    attn_score = attn_score - 1e30 * attn_mask\n\n  # attention probability\n  attn_prob = tf.nn.softmax(attn_score, 1)\n  attn_prob = tf.layers.dropout(attn_prob, dropatt, training=is_training)\n\n  # attention output\n  attn_vec = tf.einsum(\'ijbn,jbnd->ibnd\', attn_prob, v_head)\n\n  return attn_vec\n\n\ndef rel_attn_core(q_head, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat,\n                  r_w_bias, r_r_bias, r_s_bias, attn_mask, dropatt, is_training,\n                  scale):\n  """"""Core relative positional attention operations.""""""\n\n  # content based attention score\n  ac = tf.einsum(\'ibnd,jbnd->ijbn\', q_head + r_w_bias, k_head_h)\n\n  # position based attention score\n  bd = tf.einsum(\'ibnd,jbnd->ijbn\', q_head + r_r_bias, k_head_r)\n  bd = rel_shift(bd, klen=tf.shape(ac)[1])\n\n  # segment based attention score\n  if seg_mat is None:\n    ef = 0\n  else:\n    ef = tf.einsum(\'ibnd,snd->ibns\', q_head + r_s_bias, seg_embed)\n    ef = tf.einsum(\'ijbs,ibns->ijbn\', seg_mat, ef)\n\n  # merge attention scores and perform masking\n  attn_score = (ac + bd + ef) * scale\n  if attn_mask is not None:\n    # attn_score = attn_score * (1 - attn_mask) - 1e30 * attn_mask\n    attn_score = attn_score - 1e30 * attn_mask\n\n  # attention probability\n  attn_prob = tf.nn.softmax(attn_score, 1)\n  attn_prob = tf.layers.dropout(attn_prob, dropatt, training=is_training)\n\n  # attention output\n  attn_vec = tf.einsum(\'ijbn,jbnd->ibnd\', attn_prob, v_head_h)\n\n  return attn_vec\n\n\ndef rel_shift(x, klen=-1):\n  """"""perform relative shift to form the relative attention score.""""""\n  x_size = tf.shape(x)\n\n  x = tf.reshape(x, [x_size[1], x_size[0], x_size[2], x_size[3]])\n  x = tf.slice(x, [1, 0, 0, 0], [-1, -1, -1, -1])\n  x = tf.reshape(x, [x_size[0], x_size[1] - 1, x_size[2], x_size[3]])\n  x = tf.slice(x, [0, 0, 0, 0], [-1, klen, -1, -1])\n\n  return x\n\n\ndef _create_mask(qlen, mlen, dtype=tf.float32, same_length=False):\n  """"""create causal attention mask.""""""\n  attn_mask = tf.ones([qlen, qlen], dtype=dtype)\n  mask_u = tf.matrix_band_part(attn_mask, 0, -1)\n  mask_dia = tf.matrix_band_part(attn_mask, 0, 0)\n  attn_mask_pad = tf.zeros([qlen, mlen], dtype=dtype)\n  ret = tf.concat([attn_mask_pad, mask_u - mask_dia], 1)\n  if same_length:\n    mask_l = tf.matrix_band_part(attn_mask, -1, 0)\n    ret = tf.concat([ret[:, :qlen] + mask_l - mask_dia, ret[:, qlen:]], 1)\n\n  return ret\n\n\ndef _cache_mem(curr_out, prev_mem, mem_len, reuse_len=None):\n  """"""cache hidden states into memory.""""""\n  if mem_len is None or mem_len == 0:\n    return None\n  else:\n    if reuse_len is not None and reuse_len > 0:\n      curr_out = curr_out[:reuse_len]\n\n    if prev_mem is None:\n      new_mem = curr_out[-mem_len:]\n    else:\n      new_mem = tf.concat([prev_mem, curr_out], 0)[-mem_len:]\n\n  return tf.stop_gradient(new_mem)\n\n\ndef relative_positional_encoding(qlen, klen, d_model, clamp_len, attn_type,\n                                 bi_data, bsz=None, dtype=None):\n  """"""create relative positional encoding.""""""\n  freq_seq = tf.range(0, d_model, 2.0)\n  if dtype is not None and dtype != tf.float32:\n    freq_seq = tf.cast(freq_seq, dtype=dtype)\n  inv_freq = 1 / (10000 ** (freq_seq / d_model))\n\n  if attn_type == \'bi\':\n    # beg, end = klen - 1, -qlen\n    beg, end = klen, -qlen\n  elif attn_type == \'uni\':\n    # beg, end = klen - 1, -1\n    beg, end = klen, -1\n  else:\n    raise ValueError(\'Unknown `attn_type` {}.\'.format(attn_type))\n\n  if bi_data:\n    fwd_pos_seq = tf.range(beg, end, -1.0)\n    bwd_pos_seq = tf.range(-beg, -end, 1.0)\n\n    if dtype is not None and dtype != tf.float32:\n      fwd_pos_seq = tf.cast(fwd_pos_seq, dtype=dtype)\n      bwd_pos_seq = tf.cast(bwd_pos_seq, dtype=dtype)\n\n    if clamp_len > 0:\n      fwd_pos_seq = tf.clip_by_value(fwd_pos_seq, -clamp_len, clamp_len)\n      bwd_pos_seq = tf.clip_by_value(bwd_pos_seq, -clamp_len, clamp_len)\n\n    if bsz is not None:\n      # With bi_data, the batch size should be divisible by 2.\n      assert bsz%2 == 0\n      fwd_pos_emb = positional_embedding(fwd_pos_seq, inv_freq, bsz//2)\n      bwd_pos_emb = positional_embedding(bwd_pos_seq, inv_freq, bsz//2)\n    else:\n      fwd_pos_emb = positional_embedding(fwd_pos_seq, inv_freq)\n      bwd_pos_emb = positional_embedding(bwd_pos_seq, inv_freq)\n\n    pos_emb = tf.concat([fwd_pos_emb, bwd_pos_emb], axis=1)\n  else:\n    fwd_pos_seq = tf.range(beg, end, -1.0)\n    if dtype is not None and dtype != tf.float32:\n      fwd_pos_seq = tf.cast(fwd_pos_seq, dtype=dtype)\n    if clamp_len > 0:\n      fwd_pos_seq = tf.clip_by_value(fwd_pos_seq, -clamp_len, clamp_len)\n    pos_emb = positional_embedding(fwd_pos_seq, inv_freq, bsz)\n\n  return pos_emb\n\n\ndef multihead_attn(q, k, v, attn_mask, d_model, n_head, d_head, dropout,\n                   dropatt, is_training, kernel_initializer, residual=True,\n                   scope=\'abs_attn\', reuse=None):\n  """"""Standard multi-head attention with absolute positional embedding.""""""\n\n  scale = 1 / (d_head ** 0.5)\n  with tf.variable_scope(scope, reuse=reuse):\n    # attention heads\n    q_head = head_projection(\n        q, d_model, n_head, d_head, kernel_initializer, \'q\')\n    k_head = head_projection(\n        k, d_model, n_head, d_head, kernel_initializer, \'k\')\n    v_head = head_projection(\n        v, d_model, n_head, d_head, kernel_initializer, \'v\')\n\n    # attention vector\n    attn_vec = abs_attn_core(q_head, k_head, v_head, attn_mask, dropatt,\n                             is_training, scale)\n\n    # post processing\n    output = post_attention(v, attn_vec, d_model, n_head, d_head, dropout,\n                            is_training, kernel_initializer, residual)\n\n  return output\n\n\n\ndef rel_multihead_attn(h, r, r_w_bias, r_r_bias, seg_mat, r_s_bias, seg_embed,\n                       attn_mask, mems, d_model, n_head, d_head, dropout,\n                       dropatt, is_training, kernel_initializer,\n                       scope=\'rel_attn\', reuse=None):\n  """"""Multi-head attention with relative positional encoding.""""""\n\n  scale = 1 / (d_head ** 0.5)\n  with tf.variable_scope(scope, reuse=reuse):\n    if mems is not None and mems.shape.ndims > 1:\n      cat = tf.concat([mems, h], 0)\n    else:\n      cat = h\n\n    # content heads\n    q_head_h = head_projection(\n        h, d_model, n_head, d_head, kernel_initializer, \'q\')\n    k_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'k\')\n    v_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'v\')\n\n    # positional heads\n    k_head_r = head_projection(\n        r, d_model, n_head, d_head, kernel_initializer, \'r\')\n\n    # core attention ops\n    attn_vec = rel_attn_core(\n        q_head_h, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n        r_r_bias, r_s_bias, attn_mask, dropatt, is_training, scale)\n\n    # post processing\n    output = post_attention(h, attn_vec, d_model, n_head, d_head, dropout,\n                            is_training, kernel_initializer)\n\n  return output\n\n\ndef two_stream_rel_attn(h, g, r, mems, r_w_bias, r_r_bias, seg_mat, r_s_bias,\n                        seg_embed, attn_mask_h, attn_mask_g, target_mapping,\n                        d_model, n_head, d_head, dropout, dropatt, is_training,\n                        kernel_initializer, scope=\'rel_attn\'):\n  """"""Two-stream attention with relative positional encoding.""""""\n\n  scale = 1 / (d_head ** 0.5)\n  with tf.variable_scope(scope, reuse=False):\n\n    # content based attention score\n    if mems is not None and mems.shape.ndims > 1:\n      cat = tf.concat([mems, h], 0)\n    else:\n      cat = h\n\n    # content-based key head\n    k_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'k\')\n\n    # content-based value head\n    v_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'v\')\n\n    # position-based key head\n    k_head_r = head_projection(\n        r, d_model, n_head, d_head, kernel_initializer, \'r\')\n\n    ##### h-stream\n    # content-stream query head\n    q_head_h = head_projection(\n        h, d_model, n_head, d_head, kernel_initializer, \'q\')\n\n    # core attention ops\n    attn_vec_h = rel_attn_core(\n        q_head_h, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n        r_r_bias, r_s_bias, attn_mask_h, dropatt, is_training, scale)\n\n    # post processing\n    output_h = post_attention(h, attn_vec_h, d_model, n_head, d_head, dropout,\n                              is_training, kernel_initializer)\n\n  with tf.variable_scope(scope, reuse=True):\n    ##### g-stream\n    # query-stream query head\n    q_head_g = head_projection(\n        g, d_model, n_head, d_head, kernel_initializer, \'q\')\n\n    # core attention ops\n    if target_mapping is not None:\n      q_head_g = tf.einsum(\'mbnd,mlb->lbnd\', q_head_g, target_mapping)\n      attn_vec_g = rel_attn_core(\n          q_head_g, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n          r_r_bias, r_s_bias, attn_mask_g, dropatt, is_training, scale)\n      attn_vec_g = tf.einsum(\'lbnd,mlb->mbnd\', attn_vec_g, target_mapping)\n    else:\n      attn_vec_g = rel_attn_core(\n          q_head_g, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n          r_r_bias, r_s_bias, attn_mask_g, dropatt, is_training, scale)\n\n    # post processing\n    output_g = post_attention(g, attn_vec_g, d_model, n_head, d_head, dropout,\n                              is_training, kernel_initializer)\n\n    return output_h, output_g\n\n\ndef transformer_xl(inp_k, n_token, n_layer, d_model, n_head,\n                d_head, d_inner, dropout, dropatt, attn_type,\n                bi_data, initializer, is_training, mem_len=None,\n                inp_q=None, mems=None,\n                same_length=False, clamp_len=-1, untie_r=False,\n                use_tpu=True, input_mask=None,\n                perm_mask=None, seg_id=None, reuse_len=None,\n                ff_activation=\'relu\', target_mapping=None,\n                use_bfloat16=False, scope=\'transformer\', **kwargs):\n  """"""\n    Defines a Transformer-XL computation graph with additional\n    support for XLNet.\n\n    Args:\n\n    inp_k: int32 Tensor in shape [len, bsz], the input token IDs.\n    seg_id: int32 Tensor in shape [len, bsz], the input segment IDs.\n    input_mask: float32 Tensor in shape [len, bsz], the input mask.\n      0 for real tokens and 1 for padding.\n    mems: a list of float32 Tensors in shape [mem_len, bsz, d_model], memory\n      from previous batches. The length of the list equals n_layer.\n      If None, no memory is used.\n    perm_mask: float32 Tensor in shape [len, len, bsz].\n      If perm_mask[i, j, k] = 0, i attend to j in batch k;\n      if perm_mask[i, j, k] = 1, i does not attend to j in batch k.\n      If None, each position attends to all the others.\n    target_mapping: float32 Tensor in shape [num_predict, len, bsz].\n      If target_mapping[i, j, k] = 1, the i-th predict in batch k is\n      on the j-th token.\n      Only used during pretraining for partial prediction.\n      Set to None during finetuning.\n    inp_q: float32 Tensor in shape [len, bsz].\n      1 for tokens with losses and 0 for tokens without losses.\n      Only used during pretraining for two-stream attention.\n      Set to None during finetuning.\n\n    n_layer: int, the number of layers.\n    d_model: int, the hidden size.\n    n_head: int, the number of attention heads.\n    d_head: int, the dimension size of each attention head.\n    d_inner: int, the hidden size in feed-forward layers.\n    ff_activation: str, ""relu"" or ""gelu"".\n    untie_r: bool, whether to untie the biases in attention.\n    n_token: int, the vocab size.\n\n    is_training: bool, whether in training mode.\n    use_tpu: bool, whether TPUs are used.\n    use_bfloat16: bool, use bfloat16 instead of float32.\n    dropout: float, dropout rate.\n    dropatt: float, dropout rate on attention probabilities.\n    init: str, the initialization scheme, either ""normal"" or ""uniform"".\n    init_range: float, initialize the parameters with a uniform distribution\n      in [-init_range, init_range]. Only effective when init=""uniform"".\n    init_std: float, initialize the parameters with a normal distribution\n      with mean 0 and stddev init_std. Only effective when init=""normal"".\n    mem_len: int, the number of tokens to cache.\n    reuse_len: int, the number of tokens in the currect batch to be cached\n      and reused in the future.\n    bi_data: bool, whether to use bidirectional input pipeline.\n      Usually set to True during pretraining and False during finetuning.\n    clamp_len: int, clamp all relative distances larger than clamp_len.\n      -1 means no clamping.\n    same_length: bool, whether to use the same attention length for each token.\n    summary_type: str, ""last"", ""first"", ""mean"", or ""attn"". The method\n      to pool the input to get a vector representation.\n    initializer: A tf initializer.\n    scope: scope name for the computation graph.\n  """"""\n  tf.logging.info(\'memory input {}\'.format(mems))\n  tf_float = tf.bfloat16 if use_bfloat16 else tf.float32\n  tf.logging.info(\'Use float type {}\'.format(tf_float))\n\n  new_mems = []\n  with tf.variable_scope(scope):\n    if untie_r:\n      r_w_bias = tf.get_variable(\'r_w_bias\', [n_layer, n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n      r_r_bias = tf.get_variable(\'r_r_bias\', [n_layer, n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n    else:\n      r_w_bias = tf.get_variable(\'r_w_bias\', [n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n      r_r_bias = tf.get_variable(\'r_r_bias\', [n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n\n    bsz = tf.shape(inp_k)[1]\n    qlen = tf.shape(inp_k)[0]\n    mlen = tf.shape(mems[0])[0] if mems is not None else 0\n    klen = mlen + qlen\n\n    ##### Attention mask\n    # causal attention mask\n    if attn_type == \'uni\':\n      attn_mask = _create_mask(qlen, mlen, tf_float, same_length)\n      attn_mask = attn_mask[:, :, None, None]\n    elif attn_type == \'bi\':\n      attn_mask = None\n    else:\n      raise ValueError(\'Unsupported attention type: {}\'.format(attn_type))\n\n    # data mask: input mask & perm mask\n    if input_mask is not None and perm_mask is not None:\n      data_mask = input_mask[None] + perm_mask\n    elif input_mask is not None and perm_mask is None:\n      data_mask = input_mask[None]\n    elif input_mask is None and perm_mask is not None:\n      data_mask = perm_mask\n    else:\n      data_mask = None\n\n    if data_mask is not None:\n      # all mems can be attended to\n      mems_mask = tf.zeros([tf.shape(data_mask)[0], mlen, bsz],\n                           dtype=tf_float)\n      data_mask = tf.concat([mems_mask, data_mask], 1)\n      if attn_mask is None:\n        attn_mask = data_mask[:, :, :, None]\n      else:\n        attn_mask += data_mask[:, :, :, None]\n\n    if attn_mask is not None:\n      attn_mask = tf.cast(attn_mask > 0, dtype=tf_float)\n\n    if attn_mask is not None:\n      non_tgt_mask = -tf.eye(qlen, dtype=tf_float)\n      non_tgt_mask = tf.concat([tf.zeros([qlen, mlen], dtype=tf_float),\n                                non_tgt_mask], axis=-1)\n      non_tgt_mask = tf.cast((attn_mask + non_tgt_mask[:, :, None, None]) > 0,\n                             dtype=tf_float)\n    else:\n      non_tgt_mask = None\n\n    ##### Word embedding\n    word_emb_k, lookup_table = embedding_lookup(\n        x=inp_k,\n        n_token=n_token,\n        d_embed=d_model,\n        initializer=initializer,\n        use_tpu=use_tpu,\n        dtype=tf_float,\n        scope=\'word_embedding\')\n\n    if inp_q is not None:\n      with tf.variable_scope(\'mask_emb\'):\n        mask_emb = tf.get_variable(\'mask_emb\', [1, 1, d_model], dtype=tf_float)\n        if target_mapping is not None:\n          word_emb_q = tf.tile(mask_emb, [tf.shape(target_mapping)[0], bsz, 1])\n        else:\n          inp_q_ext = inp_q[:, :, None]\n          word_emb_q = inp_q_ext * mask_emb + (1 - inp_q_ext) * word_emb_k\n    output_h = tf.layers.dropout(word_emb_k, dropout, training=is_training)\n    if inp_q is not None:\n      output_g = tf.layers.dropout(word_emb_q, dropout, training=is_training)\n\n    ##### Segment embedding\n    if seg_id is not None:\n      if untie_r:\n        r_s_bias = tf.get_variable(\'r_s_bias\', [n_layer, n_head, d_head],\n                                   dtype=tf_float, initializer=initializer)\n      else:\n        # default case (tie)\n        r_s_bias = tf.get_variable(\'r_s_bias\', [n_head, d_head],\n                                   dtype=tf_float, initializer=initializer)\n\n      seg_embed = tf.get_variable(\'seg_embed\', [n_layer, 2, n_head, d_head],\n                                  dtype=tf_float, initializer=initializer)\n\n      # Convert `seg_id` to one-hot `seg_mat`\n      mem_pad = tf.zeros([mlen, bsz], dtype=tf.int32)\n      cat_ids = tf.concat([mem_pad, seg_id], 0)\n\n      # `1` indicates not in the same segment [qlen x klen x bsz]\n      seg_mat = tf.cast(\n          tf.logical_not(tf.equal(seg_id[:, None], cat_ids[None, :])),\n          tf.int32)\n      seg_mat = tf.one_hot(seg_mat, 2, dtype=tf_float)\n    else:\n      seg_mat = None\n\n    ##### Positional encoding\n    pos_emb = relative_positional_encoding(\n        qlen, klen, d_model, clamp_len, attn_type, bi_data,\n        bsz=bsz, dtype=tf_float)\n    pos_emb = tf.layers.dropout(pos_emb, dropout, training=is_training)\n\n    ##### Attention layers\n    if mems is None:\n      mems = [None] * n_layer\n\n    for i in range(n_layer):\n      # cache new mems\n      new_mems.append(_cache_mem(output_h, mems[i], mem_len, reuse_len))\n\n      # segment bias\n      if seg_id is None:\n        r_s_bias_i = None\n        seg_embed_i = None\n      else:\n        r_s_bias_i = r_s_bias if not untie_r else r_s_bias[i]\n        seg_embed_i = seg_embed[i]\n\n      with tf.variable_scope(\'layer_{}\'.format(i)):\n        if inp_q is not None:\n          output_h, output_g = two_stream_rel_attn(\n              h=output_h,\n              g=output_g,\n              r=pos_emb,\n              r_w_bias=r_w_bias if not untie_r else r_w_bias[i],\n              r_r_bias=r_r_bias if not untie_r else r_r_bias[i],\n              seg_mat=seg_mat,\n              r_s_bias=r_s_bias_i,\n              seg_embed=seg_embed_i,\n              attn_mask_h=non_tgt_mask,\n              attn_mask_g=attn_mask,\n              mems=mems[i],\n              target_mapping=target_mapping,\n              d_model=d_model,\n              n_head=n_head,\n              d_head=d_head,\n              dropout=dropout,\n              dropatt=dropatt,\n              is_training=is_training,\n              kernel_initializer=initializer)\n          reuse = True\n        else:\n          reuse = False\n\n          output_h = rel_multihead_attn(\n              h=output_h,\n              r=pos_emb,\n              r_w_bias=r_w_bias if not untie_r else r_w_bias[i],\n              r_r_bias=r_r_bias if not untie_r else r_r_bias[i],\n              seg_mat=seg_mat,\n              r_s_bias=r_s_bias_i,\n              seg_embed=seg_embed_i,\n              attn_mask=non_tgt_mask,\n              mems=mems[i],\n              d_model=d_model,\n              n_head=n_head,\n              d_head=d_head,\n              dropout=dropout,\n              dropatt=dropatt,\n              is_training=is_training,\n              kernel_initializer=initializer,\n              reuse=reuse)\n\n        if inp_q is not None:\n          output_g = positionwise_ffn(\n              inp=output_g,\n              d_model=d_model,\n              d_inner=d_inner,\n              dropout=dropout,\n              kernel_initializer=initializer,\n              activation_type=ff_activation,\n              is_training=is_training)\n\n        output_h = positionwise_ffn(\n            inp=output_h,\n            d_model=d_model,\n            d_inner=d_inner,\n            dropout=dropout,\n            kernel_initializer=initializer,\n            activation_type=ff_activation,\n            is_training=is_training,\n            reuse=reuse)\n\n    if inp_q is not None:\n      output = tf.layers.dropout(output_g, dropout, training=is_training)\n    else:\n      output = tf.layers.dropout(output_h, dropout, training=is_training)\n\n    return output, new_mems, lookup_table\n\n\ndef lm_loss(hidden, target, n_token, d_model, initializer, lookup_table=None,\n            tie_weight=False, bi_data=True, use_tpu=False):\n  """"""doc.""""""\n\n  with tf.variable_scope(\'lm_loss\'):\n    if tie_weight:\n      assert lookup_table is not None, \\\n          \'lookup_table cannot be None for tie_weight\'\n      softmax_w = lookup_table\n    else:\n      softmax_w = tf.get_variable(\'weight\', [n_token, d_model],\n                                  dtype=hidden.dtype, initializer=initializer)\n\n    softmax_b = tf.get_variable(\'bias\', [n_token], dtype=hidden.dtype,\n                                initializer=tf.zeros_initializer())\n\n    logits = tf.einsum(\'ibd,nd->ibn\', hidden, softmax_w) + softmax_b\n\n    if use_tpu:\n      one_hot_target = tf.one_hot(target, n_token, dtype=logits.dtype)\n      loss = -tf.reduce_sum(tf.nn.log_softmax(logits) * one_hot_target, -1)\n    else:\n      loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target,\n                                                            logits=logits)\n\n    return loss\n\n\ndef summarize_sequence(summary_type, hidden, d_model, n_head, d_head, dropout,\n                       dropatt, input_mask, is_training, initializer,\n                       scope=None, reuse=None, use_proj=True):\n\n  """"""\n      Different classification tasks may not may not share the same parameters\n      to summarize the sequence features.\n\n      If shared, one can keep the `scope` to the default value `None`.\n      Otherwise, one should specify a different `scope` for each task.\n  """"""\n\n  with tf.variable_scope(scope, \'sequnece_summary\', reuse=reuse):\n    if summary_type == \'last\':\n      summary = hidden[-1]\n    elif summary_type == \'first\':\n      summary = hidden[0]\n    elif summary_type == \'mean\':\n      summary = tf.reduce_mean(hidden, axis=0)\n    elif summary_type == \'attn\':\n      bsz = tf.shape(hidden)[1]\n\n      summary_bias = tf.get_variable(\'summary_bias\', [d_model],\n                                     dtype=hidden.dtype,\n                                     initializer=initializer)\n      summary_bias = tf.tile(summary_bias[None, None], [1, bsz, 1])\n\n      if input_mask is not None:\n        input_mask = input_mask[None, :, :, None]\n\n      summary = multihead_attn(summary_bias, hidden, hidden, input_mask,\n                               d_model, n_head, d_head, dropout, dropatt,\n                               is_training, initializer, residual=False)\n      summary = summary[0]\n    else:\n      raise ValueError(\'Unsupported summary type {}\'.format(summary_type))\n\n    # use another projection as in BERT\n    if use_proj:\n      summary = tf.layers.dense(\n          summary,\n          d_model,\n          activation=tf.tanh,\n          kernel_initializer=initializer,\n          name=\'summary\')\n\n    # dropout\n    summary = tf.layers.dropout(\n        summary, dropout, training=is_training,\n        name=\'dropout\')\n\n  return summary\n\n\ndef classification_loss(hidden, labels, n_class, initializer, scope, reuse=None,\n                        return_logits=False):\n  """"""\n      Different classification tasks should use different scope names to ensure\n      different dense layers (parameters) are used to produce the logits.\n\n      An exception will be in transfer learning, where one hopes to transfer\n      the classification weights.\n  """"""\n\n  with tf.variable_scope(scope, reuse=reuse):\n    logits = tf.layers.dense(\n        hidden,\n        n_class,\n        kernel_initializer=initializer,\n        name=\'logit\')\n\n    one_hot_target = tf.one_hot(labels, n_class, dtype=hidden.dtype)\n    loss = -tf.reduce_sum(tf.nn.log_softmax(logits) * one_hot_target, -1)\n\n    if return_logits:\n      return loss, logits\n\n    return loss\n\n\ndef regression_loss(hidden, labels, initializer, scope, reuse=None,\n                    return_logits=False):\n  with tf.variable_scope(scope, reuse=reuse):\n    logits = tf.layers.dense(\n        hidden,\n        1,\n        kernel_initializer=initializer,\n        name=\'logit\')\n\n    logits = tf.squeeze(logits, axis=-1)\n    loss = tf.square(logits - labels)\n\n    if return_logits:\n      return loss, logits\n\n    return loss\n\n'"
baselines/models/xlnet/prepro_utils.py,1,"b'# coding=utf-8\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport unicodedata\nimport six\nfrom functools import partial\n\n\nSPIECE_UNDERLINE = \'\xe2\x96\x81\'\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef print_(*args):\n  new_args = []\n  for arg in args:\n    if isinstance(arg, list):\n      s = [printable_text(i) for i in arg]\n      s = \' \'.join(s)\n      new_args.append(s)\n    else:\n      new_args.append(printable_text(arg))\n  print(*new_args)\n\n\ndef preprocess_text(inputs, lower=False, remove_space=True, keep_accents=False):\n  if remove_space:\n    outputs = \' \'.join(inputs.strip().split())\n  else:\n    outputs = inputs\n  outputs = outputs.replace(""``"", \'""\').replace(""\'\'"", \'""\')\n\n  if six.PY2 and isinstance(outputs, str):\n    outputs = outputs.decode(\'utf-8\')\n\n  if not keep_accents:\n    outputs = unicodedata.normalize(\'NFKD\', outputs)\n    outputs = \'\'.join([c for c in outputs if not unicodedata.combining(c)])\n  if lower:\n    outputs = outputs.lower()\n\n  return outputs\n\n\ndef encode_pieces(sp_model, text, return_unicode=True, sample=False):\n  # return_unicode is used only for py2\n\n  # note(zhiliny): in some systems, sentencepiece only accepts str for py2\n  if six.PY2 and isinstance(text, unicode):\n    text = text.encode(\'utf-8\')\n\n  if not sample:\n    pieces = sp_model.EncodeAsPieces(text)\n  else:\n    pieces = sp_model.SampleEncodeAsPieces(text, 64, 0.1)\n  new_pieces = []\n  for piece in pieces:\n    if len(piece) > 1 and piece[-1] == \',\' and piece[-2].isdigit():\n      cur_pieces = sp_model.EncodeAsPieces(\n          piece[:-1].replace(SPIECE_UNDERLINE, \'\'))\n      if piece[0] != SPIECE_UNDERLINE and cur_pieces[0][0] == SPIECE_UNDERLINE:\n        if len(cur_pieces[0]) == 1:\n          cur_pieces = cur_pieces[1:]\n        else:\n          cur_pieces[0] = cur_pieces[0][1:]\n      cur_pieces.append(piece[-1])\n      new_pieces.extend(cur_pieces)\n    else:\n      new_pieces.append(piece)\n\n  # note(zhiliny): convert back to unicode for py2\n  if six.PY2 and return_unicode:\n    ret_pieces = []\n    for piece in new_pieces:\n      if isinstance(piece, str):\n        piece = piece.decode(\'utf-8\')\n      ret_pieces.append(piece)\n    new_pieces = ret_pieces\n\n  return new_pieces\n\n\ndef encode_ids(sp_model, text, sample=False):\n  pieces = encode_pieces(sp_model, text, return_unicode=False, sample=sample)\n  ids = [sp_model.PieceToId(piece) for piece in pieces]\n  return ids\n\n\nif __name__ == \'__main__\':\n  import sentencepiece as spm\n\n  sp = spm.SentencePieceProcessor()\n  sp.load(\'sp10m.uncased.v3.model\')\n\n  print_(u\'I was born in 2000, and this is fals\xc3\xa9.\')\n  print_(u\'ORIGINAL\', sp.EncodeAsPieces(u\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(u\'OURS\', encode_pieces(sp, u\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print(encode_ids(sp, u\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'\')\n  prepro_func = partial(preprocess_text, lower=True)\n  print_(prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'ORIGINAL\', sp.EncodeAsPieces(prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\')))\n  print_(\'OURS\', encode_pieces(sp, prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\')))\n  print(encode_ids(sp, prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\')))\n  print_(\'\')\n  print_(\'I was born in 2000, and this is fals\xc3\xa9.\')\n  print_(\'ORIGINAL\', sp.EncodeAsPieces(\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'OURS\', encode_pieces(sp, \'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print(encode_ids(sp, \'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'\')\n  print_(\'I was born in 92000, and this is fals\xc3\xa9.\')\n  print_(\'ORIGINAL\', sp.EncodeAsPieces(\'I was born in 92000, and this is fals\xc3\xa9.\'))\n  print_(\'OURS\', encode_pieces(sp, \'I was born in 92000, and this is fals\xc3\xa9.\'))\n  print(encode_ids(sp, \'I was born in 92000, and this is fals\xc3\xa9.\'))\n\n'"
baselines/models/xlnet/run_classifier.py,90,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-11-04 09:56:36\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-04 14:39:31\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom os.path import join\nfrom absl import flags\nimport os\nimport sys\nimport csv\nimport collections\nimport numpy as np\nimport time\nimport math\nimport json\nimport random\nfrom copy import copy\nfrom collections import defaultdict as dd\n\nimport absl.logging as _logging  # pylint: disable=unused-import\nimport tensorflow as tf\n\nimport sentencepiece as spm\n\nfrom data_utils import SEP_ID, CLS_ID\nimport model_utils\nimport function_builder\nfrom prepro_utils import preprocess_text, encode_ids\nsys.path.append(\'..\')\nfrom classifier_utils import *\n\n\n# Model\nflags.DEFINE_string(""model_config_path"", default=None,\n                    help=""Model config path."")\nflags.DEFINE_float(""dropout"", default=0.1,\n                   help=""Dropout rate."")\nflags.DEFINE_float(""dropatt"", default=0.1,\n                   help=""Attention dropout rate."")\nflags.DEFINE_integer(""clamp_len"", default=-1,\n                     help=""Clamp length"")\nflags.DEFINE_string(""summary_type"", default=""last"",\n                    help=""Method used to summarize a sequence into a compact vector."")\nflags.DEFINE_bool(""use_summ_proj"", default=True,\n                  help=""Whether to use projection for summarizing sequences."")\nflags.DEFINE_bool(""use_bfloat16"", False,\n                  help=""Whether to use bfloat16."")\n\n# Parameter initialization\nflags.DEFINE_enum(""init"", default=""normal"",\n                  enum_values=[""normal"", ""uniform""],\n                  help=""Initialization method."")\nflags.DEFINE_float(""init_std"", default=0.02,\n                   help=""Initialization std when init is normal."")\nflags.DEFINE_float(""init_range"", default=0.1,\n                   help=""Initialization std when init is uniform."")\n\n# I/O paths\nflags.DEFINE_bool(""overwrite_data"", default=False,\n                  help=""If False, will use cached data if available."")\nflags.DEFINE_string(""init_checkpoint"", default=None,\n                    help=""checkpoint path for initializing the model. ""\n                    ""Could be a pretrained model or a finetuned model."")\nflags.DEFINE_string(""output_dir"", default="""",\n                    help=""Output dir for TF records."")\nflags.DEFINE_string(""spiece_model_file"", default="""",\n                    help=""Sentence Piece model path."")\nflags.DEFINE_string(""model_dir"", default="""",\n                    help=""Directory for saving the finetuned model."")\nflags.DEFINE_string(""data_dir"", default="""",\n                    help=""Directory for input data."")\n\n# TPUs and machines\nflags.DEFINE_bool(""use_tpu"", default=False, help=""whether to use TPU."")\nflags.DEFINE_integer(""num_hosts"", default=1, help=""How many TPU hosts."")\nflags.DEFINE_integer(""num_core_per_host"", default=8,\n                     help=""8 for TPU v2 and v3-8, 16 for larger TPU v3 pod. In the context ""\n                     ""of GPU training, it refers to the number of GPUs used."")\nflags.DEFINE_string(""tpu_job_name"", default=None, help=""TPU worker job name."")\nflags.DEFINE_string(""tpu"", default=None, help=""TPU name."")\nflags.DEFINE_string(""tpu_zone"", default=None, help=""TPU zone."")\nflags.DEFINE_string(""gcp_project"", default=None, help=""gcp project."")\nflags.DEFINE_string(""master"", default=None, help=""master"")\nflags.DEFINE_integer(""iterations"", default=1000,\n                     help=""number of iterations per TPU training loop."")\n\n# training\nflags.DEFINE_bool(""do_train"", default=False, help=""whether to do training"")\nflags.DEFINE_integer(""train_steps"", default=1000,\n                     help=""Number of training steps"")\nflags.DEFINE_integer(""num_train_epochs"", default=0,\n                     help=""Number of training steps"")\nflags.DEFINE_integer(""warmup_steps"", default=0, help=""number of warmup steps"")\nflags.DEFINE_float(""learning_rate"", default=1e-5, help=""initial learning rate"")\nflags.DEFINE_float(""lr_layer_decay_rate"", 1.0,\n                   ""Top layer: lr[L] = FLAGS.learning_rate.""\n                   ""Low layer: lr[l-1] = lr[l] * lr_layer_decay_rate."")\nflags.DEFINE_float(""min_lr_ratio"", default=0.0,\n                   help=""min lr ratio for cos decay."")\nflags.DEFINE_float(""clip"", default=1.0, help=""Gradient clipping"")\nflags.DEFINE_integer(""max_save"", default=0,\n                     help=""Max number of checkpoints to save. Use 0 to save all."")\nflags.DEFINE_integer(""save_steps"", default=None,\n                     help=""Save the model for every save_steps. ""\n                     ""If None, not to save any model."")\nflags.DEFINE_integer(""train_batch_size"", default=8,\n                     help=""Batch size for training"")\nflags.DEFINE_float(""weight_decay"", default=0.00, help=""Weight decay rate"")\nflags.DEFINE_float(""adam_epsilon"", default=1e-8, help=""Adam epsilon"")\nflags.DEFINE_string(""decay_method"", default=""poly"", help=""poly or cos"")\n\n# evaluation\nflags.DEFINE_bool(""do_eval"", default=False, help=""whether to do eval"")\nflags.DEFINE_bool(""do_predict"", default=False, help=""whether to do prediction"")\nflags.DEFINE_float(""predict_threshold"", default=0,\n                   help=""Threshold for binary prediction."")\nflags.DEFINE_string(""eval_split"", default=""dev"", help=""could be dev or test"")\nflags.DEFINE_integer(""eval_batch_size"", default=128,\n                     help=""batch size for evaluation"")\nflags.DEFINE_integer(""predict_batch_size"", default=128,\n                     help=""batch size for prediction."")\nflags.DEFINE_string(""predict_dir"", default=None,\n                    help=""Dir for saving prediction files."")\nflags.DEFINE_bool(""eval_all_ckpt"", default=False,\n                  help=""Eval all ckpts. If False, only evaluate the last one."")\nflags.DEFINE_string(""predict_ckpt"", default=None,\n                    help=""Ckpt path for do_predict. If None, use the last one."")\n\n# task specific\nflags.DEFINE_string(""task_name"", default=None, help=""Task name"")\nflags.DEFINE_integer(""max_seq_length"", default=128, help=""Max sequence length"")\nflags.DEFINE_integer(""shuffle_buffer"", default=2048,\n                     help=""Buffer size used for shuffle."")\nflags.DEFINE_integer(""num_passes"", default=1,\n                     help=""Num passes for processing training data. ""\n                     ""This is use to batch data without loss for TPUs."")\nflags.DEFINE_bool(""uncased"", default=False,\n                  help=""Use uncased."")\nflags.DEFINE_string(""cls_scope"", default=None,\n                    help=""Classifier layer scope."")\nflags.DEFINE_bool(""is_regression"", default=False,\n                  help=""Whether it\'s a regression task."")\n\nFLAGS = flags.FLAGS\n\n\nSEG_ID_A = 0\nSEG_ID_B = 1\nSEG_ID_CLS = 2\nSEG_ID_SEP = 3\nSEG_ID_PAD = 4\n\n\nclass PaddingInputExample(object):\n  """"""Fake example so the num input examples is a multiple of the batch size.\n  When running eval/predict on the TPU, we need to pad the number of examples\n  to be a multiple of the batch size, because the TPU requires a fixed batch\n  size. The alternative is to drop the last batch, which is bad because it means\n  the entire output data won\'t be generated.\n  We use this class instead of `None` because treating `None` as padding\n  battches could cause silent errors.\n  """"""\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                           tokenize_fn):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[1] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  if label_list is not None:\n    label_map = {}\n    for (i, label) in enumerate(label_list):\n      label_map[label] = i\n\n  tokens_a = tokenize_fn(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenize_fn(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for two [SEP] & one [CLS] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for one [SEP] & one [CLS] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[:max_seq_length - 2]\n\n  tokens = []\n  segment_ids = []\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(SEG_ID_A)\n  tokens.append(SEP_ID)\n  segment_ids.append(SEG_ID_A)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(SEG_ID_B)\n    tokens.append(SEP_ID)\n    segment_ids.append(SEG_ID_B)\n\n  tokens.append(CLS_ID)\n  segment_ids.append(SEG_ID_CLS)\n\n  input_ids = tokens\n\n  # The mask has 0 for real tokens and 1 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [0] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  if len(input_ids) < max_seq_length:\n    delta_len = max_seq_length - len(input_ids)\n    input_ids = [0] * delta_len + input_ids\n    input_mask = [1] * delta_len + input_mask\n    segment_ids = [SEG_ID_PAD] * delta_len + segment_ids\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  if label_list is not None:\n    label_id = label_map[example.label]\n  else:\n    label_id = example.label\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: {} (id = {})"".format(example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id)\n  return feature\n\n\ndef convert_single_example_for_inews(ex_index, tokens_a, tokens_b, label_map, max_seq_length,\n                                     tokenizer, example):\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for two [SEP] & one [CLS] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for one [SEP] & one [CLS] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[:max_seq_length - 2]\n\n  tokens = []\n  segment_ids = []\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(SEG_ID_A)\n  tokens.append(SEP_ID)\n  segment_ids.append(SEG_ID_A)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(SEG_ID_B)\n    tokens.append(SEP_ID)\n    segment_ids.append(SEG_ID_B)\n\n  tokens.append(CLS_ID)\n  segment_ids.append(SEG_ID_CLS)\n\n  input_ids = tokens\n\n  # The mask has 0 for real tokens and 1 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [0] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  if len(input_ids) < max_seq_length:\n    delta_len = max_seq_length - len(input_ids)\n    input_ids = [0] * delta_len + input_ids\n    input_mask = [1] * delta_len + input_mask\n    segment_ids = [SEG_ID_PAD] * delta_len + segment_ids\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  if label_map is not None:\n    label_id = label_map[example.label]\n  else:\n    label_id = example.label\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: {} (id = {})"".format(example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id)\n  return feature\n\n\ndef convert_example_list_for_inews(ex_index, example, label_list, max_seq_length,\n                                   tokenizer):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return [InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[0] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)]\n\n  label_map = {}\n  for (i, label) in enumerate(label_list):\n    label_map[label] = i\n\n  tokens_a = tokenizer(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenizer(example.text_b)\n    must_len = len(tokens_a) + 3\n    extra_len = max_seq_length - must_len\n  feature_list = []\n  if example.text_b and extra_len > 0:\n    extra_num = int((len(tokens_b) - 1) / extra_len) + 1\n    for num in range(extra_num):\n      max_len = min((num + 1) * extra_len, len(tokens_b))\n      tokens_b_sub = tokens_b[num * extra_len: max_len]\n      feature = convert_single_example_for_inews(\n          ex_index, tokens_a, tokens_b_sub, label_map, max_seq_length, tokenizer, example)\n      feature_list.append(feature)\n  else:\n    feature = convert_single_example_for_inews(\n        ex_index, tokens_a, tokens_b, label_map, max_seq_length, tokenizer, example)\n    feature_list.append(feature)\n  return feature_list\n\n\ndef file_based_convert_examples_to_features_for_inews(\n        examples, label_list, max_seq_length, tokenizer, output_file, num_passes=1):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n  num_example = 0\n  if num_passes > 1:\n    examples *= num_passes\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 1000 == 0:\n      tf.logging.info(""Writing example %d of %d"" % (ex_index, len(examples)))\n\n    feature_list = convert_example_list_for_inews(ex_index, example, label_list,\n                                                  max_seq_length, tokenizer)\n    num_example += len(feature_list)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    for feature in feature_list:\n      features[""input_ids""] = create_int_feature(feature.input_ids)\n      features[""input_mask""] = create_int_feature(feature.input_mask)\n      features[""segment_ids""] = create_int_feature(feature.segment_ids)\n      features[""label_ids""] = create_int_feature([feature.label_id])\n      features[""is_real_example""] = create_int_feature(\n          [int(feature.is_real_example)])\n\n      tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n      writer.write(tf_example.SerializeToString())\n  tf.logging.info(""feature num: %s"", num_example)\n  writer.close()\n\n\ndef file_based_convert_examples_to_features(\n        examples, label_list, max_seq_length, tokenize_fn, output_file,\n        num_passes=1):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n  print(len(examples))\n  sys.stdout.flush()\n  # do not create duplicated records\n  if tf.gfile.Exists(output_file) and not FLAGS.overwrite_data:\n    tf.logging.info(""Do not overwrite tfrecord {} exists."".format(output_file))\n    return\n\n  tf.logging.info(""Create new tfrecord {}."".format(output_file))\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  if num_passes > 1:\n    examples *= num_passes\n\n  print(len(examples))\n  sys.stdout.flush()\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example {} of {}"".format(ex_index,\n                                                        len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenize_fn)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    def create_float_feature(values):\n      f = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_float_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    if label_list is not None:\n      features[""label_ids""] = create_int_feature([feature.label_id])\n    else:\n      features[""label_ids""] = create_float_feature([float(feature.label_id)])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.float32),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n  if FLAGS.is_regression:\n    name_to_features[""label_ids""] = tf.FixedLenFeature([], tf.float32)\n\n  tf.logging.info(""Input tfrecord file {}"".format(input_file))\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.cast(t, tf.int32)\n      example[name] = t\n\n    return example\n\n  def input_fn(params, input_context=None):\n    """"""The actual input function.""""""\n    if FLAGS.use_tpu:\n      batch_size = params[""batch_size""]\n    elif is_training:\n      batch_size = FLAGS.train_batch_size\n    elif FLAGS.do_eval:\n      batch_size = FLAGS.eval_batch_size\n    else:\n      batch_size = FLAGS.predict_batch_size\n\n    d = tf.data.TFRecordDataset(input_file)\n    # Shard the dataset to difference devices\n    if input_context is not None:\n      tf.logging.info(""Input pipeline id %d out of %d"",\n                      input_context.input_pipeline_id, input_context.num_replicas_in_sync)\n      d = d.shard(input_context.num_input_pipelines,\n                  input_context.input_pipeline_id)\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = d.shuffle(buffer_size=FLAGS.shuffle_buffer)\n      d = d.repeat()\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef get_model_fn(n_class):\n  def model_fn(features, labels, mode, params):\n    #### Training or Evaluation\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    # Get loss from inputs\n    if FLAGS.is_regression:\n      (total_loss, per_example_loss, logits\n       ) = function_builder.get_regression_loss(FLAGS, features, is_training)\n    else:\n      (total_loss, per_example_loss, logits\n       ) = function_builder.get_classification_loss(\n          FLAGS, features, n_class, is_training)\n\n    # Check model parameters\n    num_params = sum([np.prod(v.shape) for v in tf.trainable_variables()])\n    tf.logging.info(\'#params: {}\'.format(num_params))\n\n    # load pretrained models\n    scaffold_fn = model_utils.init_from_checkpoint(FLAGS)\n\n    # Evaluation mode\n    if mode == tf.estimator.ModeKeys.EVAL:\n      assert FLAGS.num_hosts == 1\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        eval_input_dict = {\n            \'labels\': label_ids,\n            \'predictions\': predictions,\n            \'weights\': is_real_example\n        }\n        accuracy = tf.metrics.accuracy(**eval_input_dict)\n\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            \'eval_accuracy\': accuracy,\n            \'eval_loss\': loss}\n\n      def regression_metric_fn(\n              per_example_loss, label_ids, logits, is_real_example):\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        pearsonr = tf.contrib.metrics.streaming_pearson_correlation(\n            logits, label_ids, weights=is_real_example)\n        return {\'eval_loss\': loss, \'eval_pearsonr\': pearsonr}\n\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n\n      # Constucting evaluation TPUEstimatorSpec with new cache.\n      label_ids = tf.reshape(features[\'label_ids\'], [-1])\n\n      if FLAGS.is_regression:\n        metric_fn = regression_metric_fn\n      else:\n        metric_fn = metric_fn\n      metric_args = [per_example_loss, label_ids, logits, is_real_example]\n\n      if FLAGS.use_tpu:\n        eval_spec = tf.contrib.tpu.TPUEstimatorSpec(\n            mode=mode,\n            loss=total_loss,\n            eval_metrics=(metric_fn, metric_args),\n            scaffold_fn=scaffold_fn)\n      else:\n        eval_spec = tf.estimator.EstimatorSpec(\n            mode=mode,\n            loss=total_loss,\n            eval_metric_ops=metric_fn(*metric_args))\n\n      return eval_spec\n\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      label_ids = tf.reshape(features[""label_ids""], [-1])\n\n      predictions = {\n          ""logits"": logits,\n          ""labels"": label_ids,\n          ""is_real"": features[""is_real_example""]\n      }\n\n      if FLAGS.use_tpu:\n        output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n            mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n      else:\n        output_spec = tf.estimator.EstimatorSpec(\n            mode=mode, predictions=predictions)\n      return output_spec\n\n    # Configuring the optimizer\n    train_op, learning_rate, _ = model_utils.get_train_op(FLAGS, total_loss)\n\n    monitor_dict = {}\n    monitor_dict[""lr""] = learning_rate\n\n    # Constucting training TPUEstimatorSpec with new cache.\n    if FLAGS.use_tpu:\n      # Creating host calls\n      if not FLAGS.is_regression:\n        label_ids = tf.reshape(features[\'label_ids\'], [-1])\n        predictions = tf.argmax(logits, axis=-1, output_type=label_ids.dtype)\n        is_correct = tf.equal(predictions, label_ids)\n        accuracy = tf.reduce_mean(tf.cast(is_correct, tf.float32))\n\n        monitor_dict[""accuracy""] = accuracy\n\n        host_call = function_builder.construct_scalar_host_call(\n            monitor_dict=monitor_dict,\n            model_dir=FLAGS.model_dir,\n            prefix=""train/"",\n            reduce_fn=tf.reduce_mean)\n      else:\n        host_call = None\n\n      train_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op, host_call=host_call,\n          scaffold_fn=scaffold_fn)\n    else:\n      train_spec = tf.estimator.EstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op)\n\n    return train_spec\n\n  return model_fn\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  # Validate flags\n  if FLAGS.save_steps is not None:\n    FLAGS.iterations = min(FLAGS.iterations, FLAGS.save_steps)\n\n  if FLAGS.do_predict:\n    predict_dir = FLAGS.predict_dir\n    if not tf.gfile.Exists(predict_dir):\n      tf.gfile.MakeDirs(predict_dir)\n\n  processors = {\n      ""xnli"": XnliProcessor,\n      ""tnews"": TnewsProcessor,\n      ""afqmc"": AFQMCProcessor,\n      ""iflytek"": iFLYTEKDataProcessor,\n      ""copa"": COPAProcessor,\n      ""cmnli"": CMNLIProcessor,\n      ""wsc"": WSCProcessor,\n      ""csl"": CslProcessor,\n      ""copa"": COPAProcessor,\n  }\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval, `do_predict` or ""\n        ""`do_submit` must be True."")\n\n  if not tf.gfile.Exists(FLAGS.output_dir):\n    tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n  label_list = processor.get_labels() if not FLAGS.is_regression else None\n\n  sp = spm.SentencePieceProcessor()\n  sp.Load(FLAGS.spiece_model_file)\n\n  def tokenize_fn(text):\n    text = preprocess_text(text, lower=FLAGS.uncased)\n    return encode_ids(sp, text)\n\n  run_config = model_utils.configure_tpu(FLAGS)\n\n  model_fn = get_model_fn(len(label_list) if label_list is not None else None)\n\n  spm_basename = os.path.basename(FLAGS.spiece_model_file)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  if FLAGS.use_tpu:\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size)\n  else:\n    estimator = tf.estimator.Estimator(\n        model_fn=model_fn,\n        config=run_config)\n\n  if FLAGS.do_train:\n    train_file_base = ""{}.len-{}.train.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length)\n    train_file = os.path.join(FLAGS.output_dir, train_file_base)\n    tf.logging.info(""Use tfrecord file {}"".format(train_file))\n\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    np.random.shuffle(train_examples)\n    tf.logging.info(""Num of train samples: {}"".format(len(train_examples)))\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          train_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n          train_file, FLAGS.num_passes)\n    else:\n      file_based_convert_examples_to_features(\n          train_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n          train_file, FLAGS.num_passes)\n\n    # here we use epoch number to calculate total train_steps\n    train_steps = int(len(train_examples) * FLAGS.num_train_epochs / FLAGS.train_batch_size)\n    FLAGS.warmup_steps = int(0.1 * train_steps)\n\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n\n    estimator.train(input_fn=train_input_fn, max_steps=train_steps)\n\n  if FLAGS.do_eval or FLAGS.do_predict:\n    eval_examples = processor.get_dev_examples(FLAGS.data_dir)\n    tf.logging.info(""Num of eval samples: {}"".format(len(eval_examples)))\n\n  if FLAGS.do_eval:\n    # TPU requires a fixed batch size for all batches, therefore the number\n    # of examples must be a multiple of the batch size, or else examples\n    # will get dropped. So we pad with fake examples which are ignored\n    # later on. These do NOT count towards the metric (all tf.metrics\n    # support a per-instance weight, and these get a weight of 0.0).\n    #\n    # Modified in XL: We also adopt the same mechanism for GPUs.\n    while len(eval_examples) % FLAGS.eval_batch_size != 0:\n      eval_examples.append(PaddingInputExample())\n\n    eval_file_base = ""{}.len-{}.{}.eval.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length, FLAGS.eval_split)\n    eval_file = os.path.join(FLAGS.output_dir, eval_file_base)\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n          eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n          eval_file)\n\n    assert len(eval_examples) % FLAGS.eval_batch_size == 0\n    eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=True)\n\n    # Filter out all checkpoints in the directory\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.model_dir)\n\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        cur_filename = join(FLAGS.model_dir, ckpt_name)\n        global_step = int(cur_filename.split(""-"")[-1])\n        tf.logging.info(""Add {} to eval list."".format(cur_filename))\n        steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    # Decide whether to evaluate all ckpts\n    if not FLAGS.eval_all_ckpt:\n      steps_and_files = steps_and_files[-1:]\n\n    eval_results = []\n    output_eval_file = os.path.join(FLAGS.data_dir, ""dev_results_bert.txt"")\n    print(""output_eval_file:"", output_eval_file)\n    tf.logging.info(""output_eval_file:"" + output_eval_file)\n    with tf.gfile.GFile(output_eval_file, ""w"") as writer:\n      for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n        ret = estimator.evaluate(\n            input_fn=eval_input_fn,\n            steps=eval_steps,\n            checkpoint_path=filename)\n\n        ret[""step""] = global_step\n        ret[""path""] = filename\n\n        eval_results.append(ret)\n\n        tf.logging.info(""="" * 80)\n        log_str = ""Eval result | ""\n        for key, val in sorted(ret.items(), key=lambda x: x[0]):\n          log_str += ""{} {} | "".format(key, val)\n          writer.write(""%s = %s\\n"" % (key, val))\n        tf.logging.info(log_str)\n\n    key_name = ""eval_pearsonr"" if FLAGS.is_regression else ""eval_accuracy""\n    eval_results.sort(key=lambda x: x[key_name], reverse=True)\n\n    tf.logging.info(""="" * 80)\n    log_str = ""Best result | ""\n    for key, val in sorted(eval_results[0].items(), key=lambda x: x[0]):\n      log_str += ""{} {} | "".format(key, val)\n    tf.logging.info(log_str)\n\n  if FLAGS.do_predict:\n    eval_examples = processor.get_test_examples(FLAGS.data_dir)\n    eval_file_base = ""{}.len-{}.{}.predict.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length, FLAGS.eval_split)\n    eval_file = os.path.join(FLAGS.output_dir, eval_file_base)\n    if task_name == ""inews"":\n      file_based_convert_examples_to_features_for_inews(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n          eval_file)\n    else:\n      file_based_convert_examples_to_features(\n          eval_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n          eval_file)\n\n    pred_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=False)\n\n    result = estimator.predict(input_fn=predict_input_fn)\n    index2label_map = {}\n    for (i, label) in enumerate(label_list):\n      index2label_map[i] = label\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    output_predict_file = os.path.join(FLAGS.output_dir, ""test_results.tsv"")\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.GFile(output_predict_file, ""w"") as writer:\n        num_written_lines = 0\n        tf.logging.info(""***** Predict results *****"")\n        for (i, prediction) in enumerate(result):\n          probabilities = prediction[""probabilities""]\n          label_index = probabilities.argmax(0)\n          if i >= num_actual_predict_examples:\n            break\n          output_line = ""\\t"".join(\n              str(class_probability)\n              for class_probability in probabilities) + ""\\n""\n          test_label_dict = {}\n          test_label_dict[""id""] = i\n          test_label_dict[""label""] = str(index2label_map[label_index])\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n          num_written_lines += 1\n    assert num_written_lines == num_actual_predict_examples\n\n    output_predict_file_label_name = task_name + ""_predict.json""\n    output_predict_file_label = os.path.join(FLAGS.output_dir, output_predict_file_label_name)\n    predict_results = []\n    with tf.gfile.GFile(output_predict_file_label, ""w"") as writer_label:\n      with tf.gfile.Open(os.path.join(predict_dir, ""{}.tsv"".format(\n              task_name)), ""w"") as fout:\n        fout.write(""index\\tprediction\\n"")\n\n        for pred_cnt, result in enumerate(estimator.predict(\n                input_fn=pred_input_fn,\n                yield_single_examples=True,\n                checkpoint_path=FLAGS.predict_ckpt)):\n          if pred_cnt % 1000 == 0:\n            tf.logging.info(""Predicting submission for example: {}"".format(\n                pred_cnt))\n\n          logits = [float(x) for x in result[""logits""].flat]\n          predict_results.append(logits)\n\n          if len(logits) == 1:\n            label_out = logits[0]\n          elif len(logits) == 2:\n            if logits[1] - logits[0] > FLAGS.predict_threshold:\n              label_out = label_list[1]\n            else:\n              label_out = label_list[0]\n          elif len(logits) > 2:\n            max_index = np.argmax(np.array(logits, dtype=np.float32))\n            label_out = label_list[max_index]\n          else:\n            raise NotImplementedError\n\n          fout.write(""{}\\t{}\\n"".format(pred_cnt, label_out))\n\n          test_label_dict = {}\n          test_label_dict[""id""] = pred_cnt\n          test_label_dict[""label""] = str(label_out)\n          if task_name == ""tnews"":\n            test_label_dict[""label_desc""] = """"\n          writer.write(output_line)\n          json.dump(test_label_dict, writer_label)\n          writer_label.write(""\\n"")\n\n    predict_json_path = os.path.join(predict_dir, ""{}.logits.json"".format(\n        task_name))\n\n    with tf.gfile.Open(predict_json_path, ""w"") as fp:\n      json.dump(predict_results, fp, indent=4)\n\n\nif __name__ == ""__main__"":\n  tf.app.run()\n'"
baselines/models/xlnet/run_cmrc_drcd.py,83,"b'# coding=utf-8\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl import flags\nimport absl.logging as _logging  # pylint: disable=unused-import\n\nimport collections\nimport os\nimport time\nimport math\nimport json\nimport six\nimport random\nimport gc\n\nimport numpy as np\n\nif six.PY2:\n  import cPickle as pickle\nelse:\n  import pickle\n\nimport tensorflow as tf\nimport sentencepiece as spm\nfrom prepro_utils import preprocess_text, encode_ids, encode_pieces, printable_text\nimport function_builder\nimport model_utils\nimport squad_utils\nfrom data_utils import SEP_ID, CLS_ID, VOCAB_SIZE\n\nSPIECE_UNDERLINE = u\'\xe2\x96\x81\'\n\nSEG_ID_P   = 0\nSEG_ID_Q   = 1\nSEG_ID_CLS = 2\nSEG_ID_PAD = 3\n\n# Preprocessing\nflags.DEFINE_bool(""do_prepro"", default=False,\n      help=""Perform preprocessing only."")\nflags.DEFINE_integer(""num_proc"", default=1,\n      help=""Number of preprocessing processes."")\nflags.DEFINE_integer(""proc_id"", default=0,\n      help=""Process id for preprocessing."")\n\n# Model\nflags.DEFINE_string(""model_config_path"", default=None,\n      help=""Model config path."")\nflags.DEFINE_float(""dropout"", default=0.1,\n      help=""Dropout rate."")\nflags.DEFINE_float(""dropatt"", default=0.1,\n      help=""Attention dropout rate."")\nflags.DEFINE_integer(""clamp_len"", default=-1,\n      help=""Clamp length."")\nflags.DEFINE_string(""summary_type"", default=""last"",\n      help=""Method used to summarize a sequence into a vector."")\nflags.DEFINE_bool(""use_bfloat16"", default=False,\n      help=""Whether to use bfloat16."")\n\n# Parameter initialization\nflags.DEFINE_enum(""init"", default=""normal"",\n                  enum_values=[""normal"", ""uniform""],\n                  help=""Initialization method."")\nflags.DEFINE_float(""init_std"", default=0.02,\n                   help=""Initialization std when init is normal."")\nflags.DEFINE_float(""init_range"", default=0.1,\n                   help=""Initialization std when init is uniform."")\n\n# I/O paths\nflags.DEFINE_bool(""overwrite_data"", default=False,\n                  help=""If False, will use cached data if available."")\nflags.DEFINE_string(""init_checkpoint"", default=None,\n                    help=""checkpoint path for initializing the model. ""\n                    ""Could be a pretrained model or a finetuned model."")\nflags.DEFINE_bool(""init_global_vars"", default=False,\n                  help=""If true, init all global vars. If false, init ""\n                  ""trainable vars only."")\nflags.DEFINE_string(""output_dir"", default="""",\n                    help=""Output dir for TF records."")\nflags.DEFINE_string(""predict_dir"", default="""",\n                    help=""Dir for predictions."")\nflags.DEFINE_string(""spiece_model_file"", default="""",\n                    help=""Sentence Piece model path."")\nflags.DEFINE_string(""model_dir"", default="""",\n                    help=""Directory for saving the finetuned model."")\nflags.DEFINE_string(""train_file"", default="""",\n                    help=""Path of train file."")\nflags.DEFINE_string(""predict_file"", default="""",\n                    help=""Path of prediction file."")\n\n# Data preprocessing config\nflags.DEFINE_integer(""max_seq_length"",\n                     default=512, help=""Max sequence length"")\nflags.DEFINE_integer(""max_query_length"",\n                     default=64, help=""Max query length"")\nflags.DEFINE_integer(""doc_stride"",\n                     default=128, help=""Doc stride"")\nflags.DEFINE_integer(""max_answer_length"",\n                     default=64, help=""Max answer length"")\nflags.DEFINE_bool(""uncased"", default=False, help=""Use uncased data."")\n\n# TPUs and machines\nflags.DEFINE_bool(""use_tpu"", default=False, help=""whether to use TPU."")\nflags.DEFINE_integer(""num_hosts"", default=1, help=""How many TPU hosts."")\nflags.DEFINE_integer(""num_core_per_host"", default=8,\n      help=""8 for TPU v2 and v3-8, 16 for larger TPU v3 pod. In the context ""\n      ""of GPU training, it refers to the number of GPUs used."")\nflags.DEFINE_string(""tpu_job_name"", default=None, help=""TPU worker job name."")\nflags.DEFINE_string(""tpu"", default=None, help=""TPU name."")\nflags.DEFINE_string(""tpu_zone"", default=None, help=""TPU zone."")\nflags.DEFINE_string(""gcp_project"", default=None, help=""gcp project."")\nflags.DEFINE_string(""master"", default=None, help=""master"")\nflags.DEFINE_integer(""iterations"", default=1000,\n                     help=""number of iterations per TPU training loop."")\n\n# Training\nflags.DEFINE_bool(""do_train"", default=True, help=""whether to do training"")\nflags.DEFINE_integer(""train_batch_size"", default=48,\n                     help=""batch size for training"")\nflags.DEFINE_integer(""train_steps"", default=8000,\n                     help=""Number of training steps"")\nflags.DEFINE_integer(""warmup_steps"", default=0, help=""number of warmup steps"")\nflags.DEFINE_integer(""save_steps"", default=None,\n                     help=""Save the model for every save_steps. ""\n                     ""If None, not to save any model."")\nflags.DEFINE_integer(""max_save"", default=5,\n                     help=""Max number of checkpoints to save. ""\n                     ""Use 0 to save all."")\nflags.DEFINE_integer(""shuffle_buffer"", default=2048,\n                     help=""Buffer size used for shuffle."")\n\n# Optimization\nflags.DEFINE_float(""learning_rate"", default=3e-5, help=""initial learning rate"")\nflags.DEFINE_float(""min_lr_ratio"", default=0.0,\n                   help=""min lr ratio for cos decay."")\nflags.DEFINE_float(""clip"", default=1.0, help=""Gradient clipping"")\nflags.DEFINE_float(""weight_decay"", default=0.00, help=""Weight decay rate"")\nflags.DEFINE_float(""adam_epsilon"", default=1e-6, help=""Adam epsilon"")\nflags.DEFINE_string(""decay_method"", default=""poly"", help=""poly or cos"")\nflags.DEFINE_float(""lr_layer_decay_rate"", default=0.75,\n                   help=""Top layer: lr[L] = FLAGS.learning_rate.""\n                   ""Lower layers: lr[l-1] = lr[l] * lr_layer_decay_rate."")\n\n# Eval / Prediction\nflags.DEFINE_bool(""do_predict"", default=False, help=""whether to do predict"")\nflags.DEFINE_integer(""predict_batch_size"", default=32,\n                     help=""batch size for prediction"")\nflags.DEFINE_integer(""n_best_size"", default=5,\n                     help=""n best size for predictions"")\nflags.DEFINE_integer(""start_n_top"", default=5, help=""Beam size for span start."")\nflags.DEFINE_integer(""end_n_top"", default=5, help=""Beam size for span end."")\nflags.DEFINE_string(""target_eval_key"", default=""best_f1"",\n                    help=""Use has_ans_f1 for Model I."")\n\n\nFLAGS = flags.FLAGS\n\n\nclass SquadExample(object):\n  """"""A single training/test example for simple sequence classification.\n\n     For examples without an answer, the start and end position are -1.\n  """"""\n\n  def __init__(self,\n               qas_id,\n               question_text,\n               paragraph_text,\n               orig_answer_text=None,\n               start_position=None,\n               is_impossible=False):\n    self.qas_id = qas_id\n    self.question_text = question_text\n    self.paragraph_text = paragraph_text\n    self.orig_answer_text = orig_answer_text\n    self.start_position = start_position\n    self.is_impossible = is_impossible\n\n  def __str__(self):\n    return self.__repr__()\n\n  def __repr__(self):\n    s = """"\n    s += ""qas_id: %s"" % (printable_text(self.qas_id))\n    s += "", question_text: %s"" % (\n        printable_text(self.question_text))\n    s += "", paragraph_text: [%s]"" % ("" "".join(self.paragraph_text))\n    if self.start_position:\n      s += "", start_position: %d"" % (self.start_position)\n    if self.start_position:\n      s += "", is_impossible: %r"" % (self.is_impossible)\n    return s\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tok_start_to_orig_index,\n               tok_end_to_orig_index,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               p_mask,\n               segment_ids,\n               paragraph_len,\n               cls_index,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tok_start_to_orig_index = tok_start_to_orig_index\n    self.tok_end_to_orig_index = tok_end_to_orig_index\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.p_mask = p_mask\n    self.segment_ids = segment_ids\n    self.paragraph_len = paragraph_len\n    self.cls_index = cls_index\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\ndef read_squad_examples(input_file, is_training):\n  """"""Read a SQuAD json file into a list of SquadExample.""""""\n  with tf.gfile.Open(input_file, ""r"") as reader:\n    input_data = json.load(reader)[""data""]\n\n  examples = []\n  for entry in input_data:\n    for paragraph in entry[""paragraphs""]:\n      paragraph_text = paragraph[""context""]\n\n      for qa in paragraph[""qas""]:\n        qas_id = qa[""id""]\n        question_text = qa[""question""]\n        start_position = None\n        orig_answer_text = None\n        is_impossible = False\n\n        if is_training:\n          if ""is_impossible"" in qa:\n            is_impossible = qa[""is_impossible""]\n          else:\n            is_impossible = False\n          if (len(qa[""answers""]) != 1) and (not is_impossible):\n            raise ValueError(\n                ""For training, each question should have exactly 1 answer."")\n          if not is_impossible:\n            answer = qa[""answers""][0]\n            orig_answer_text = answer[""text""]\n            start_position = answer[""answer_start""]\n          else:\n            start_position = -1\n            orig_answer_text = """"\n\n        example = SquadExample(\n            qas_id=qas_id,\n            question_text=question_text,\n            paragraph_text=paragraph_text,\n            orig_answer_text=orig_answer_text,\n            start_position=start_position,\n            is_impossible=is_impossible)\n        examples.append(example)\n\n  return examples\n\n\ndef _convert_index(index, pos, M=None, is_start=True):\n  if pos >= len(index):\n    pos = len(index) - 1\n  if index[pos] is not None:\n    return index[pos]\n  N = len(index)\n  rear = pos\n  while rear < N - 1 and index[rear] is None:\n    rear += 1\n  front = pos\n  while front > 0 and index[front] is None:\n    front -= 1\n  assert index[front] is not None or index[rear] is not None\n  if index[front] is None:\n    if index[rear] >= 1:\n      if is_start:\n        return 0\n      else:\n        return index[rear] - 1\n    return index[rear]\n  if index[rear] is None:\n    if M is not None and index[front] < M - 1:\n      if is_start:\n        return index[front] + 1\n      else:\n        return M - 1\n    return index[front]\n  if is_start:\n    if index[rear] > index[front] + 1:\n      return index[front] + 1\n    else:\n      return index[rear]\n  else:\n    if index[rear] > index[front] + 1:\n      return index[rear] - 1\n    else:\n      return index[front]\n\n\ndef convert_examples_to_features(examples, sp_model, max_seq_length,\n                                 doc_stride, max_query_length, is_training,\n                                 output_fn):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  cnt_pos, cnt_neg = 0, 0\n  unique_id = 1000000000\n  max_N, max_M = 1024, 1024\n  f = np.zeros((max_N, max_M), dtype=np.float32)\n\n  for (example_index, example) in enumerate(examples):\n\n    if example_index % 100 == 0:\n      tf.logging.info(\'Converting {}/{} pos {} neg {}\'.format(\n          example_index, len(examples), cnt_pos, cnt_neg))\n\n    query_tokens = encode_ids(\n        sp_model,\n        preprocess_text(example.question_text, lower=FLAGS.uncased))\n\n    if len(query_tokens) > max_query_length:\n      query_tokens = query_tokens[0:max_query_length]\n\n    paragraph_text = example.paragraph_text\n    para_tokens = encode_pieces(\n        sp_model,\n        preprocess_text(example.paragraph_text, lower=FLAGS.uncased))\n\n    chartok_to_tok_index = []\n    tok_start_to_chartok_index = []\n    tok_end_to_chartok_index = []\n    char_cnt = 0\n    for i, token in enumerate(para_tokens):\n      chartok_to_tok_index.extend([i] * len(token))\n      tok_start_to_chartok_index.append(char_cnt)\n      char_cnt += len(token)\n      tok_end_to_chartok_index.append(char_cnt - 1)\n\n    tok_cat_text = \'\'.join(para_tokens).replace(SPIECE_UNDERLINE, \' \')\n    N, M = len(paragraph_text), len(tok_cat_text)\n\n    if N > max_N or M > max_M:\n      max_N = max(N, max_N)\n      max_M = max(M, max_M)\n      f = np.zeros((max_N, max_M), dtype=np.float32)\n      gc.collect()\n\n    g = {}\n\n    def _lcs_match(max_dist):\n      f.fill(0)\n      g.clear()\n\n      ### longest common sub sequence\n      # f[i, j] = max(f[i - 1, j], f[i, j - 1], f[i - 1, j - 1] + match(i, j))\n      for i in range(N):\n\n        # note(zhiliny):\n        # unlike standard LCS, this is specifically optimized for the setting\n        # because the mismatch between sentence pieces and original text will\n        # be small\n        for j in range(i - max_dist, i + max_dist):\n          if j >= M or j < 0: continue\n\n          if i > 0:\n            g[(i, j)] = 0\n            f[i, j] = f[i - 1, j]\n\n          if j > 0 and f[i, j - 1] > f[i, j]:\n            g[(i, j)] = 1\n            f[i, j] = f[i, j - 1]\n\n          f_prev = f[i - 1, j - 1] if i > 0 and j > 0 else 0\n          if (preprocess_text(paragraph_text[i], lower=FLAGS.uncased,\n              remove_space=False)\n              == tok_cat_text[j]\n              and f_prev + 1 > f[i, j]):\n            g[(i, j)] = 2\n            f[i, j] = f_prev + 1\n\n    max_dist = abs(N - M) + 5\n    for _ in range(2):\n      _lcs_match(max_dist)\n      if f[N - 1, M - 1] > 0.8 * N: break\n      max_dist *= 2\n\n    orig_to_chartok_index = [None] * N\n    chartok_to_orig_index = [None] * M\n    i, j = N - 1, M - 1\n    while i >= 0 and j >= 0:\n      if (i, j) not in g: break\n      if g[(i, j)] == 2:\n        orig_to_chartok_index[i] = j\n        chartok_to_orig_index[j] = i\n        i, j = i - 1, j - 1\n      elif g[(i, j)] == 1:\n        j = j - 1\n      else:\n        i = i - 1\n\n    if all(v is None for v in orig_to_chartok_index) or f[N - 1, M - 1] < 0.8 * N:\n      print(\'MISMATCH DETECTED!\')\n      continue\n\n    tok_start_to_orig_index = []\n    tok_end_to_orig_index = []\n    for i in range(len(para_tokens)):\n      start_chartok_pos = tok_start_to_chartok_index[i]\n      end_chartok_pos = tok_end_to_chartok_index[i]\n      start_orig_pos = _convert_index(chartok_to_orig_index, start_chartok_pos,\n                                      N, is_start=True)\n      end_orig_pos = _convert_index(chartok_to_orig_index, end_chartok_pos,\n                                    N, is_start=False)\n\n      tok_start_to_orig_index.append(start_orig_pos)\n      tok_end_to_orig_index.append(end_orig_pos)\n\n    if not is_training:\n      tok_start_position = tok_end_position = None\n\n    if is_training and example.is_impossible:\n      tok_start_position = -1\n      tok_end_position = -1\n\n    if is_training and not example.is_impossible:\n      start_position = example.start_position\n      end_position = start_position + len(example.orig_answer_text) - 1\n\n      start_chartok_pos = _convert_index(orig_to_chartok_index, start_position,\n                                         is_start=True)\n      tok_start_position = chartok_to_tok_index[start_chartok_pos]\n\n      end_chartok_pos = _convert_index(orig_to_chartok_index, end_position,\n                                       is_start=False)\n      tok_end_position = chartok_to_tok_index[end_chartok_pos]\n      assert tok_start_position <= tok_end_position\n\n    def _piece_to_id(x):\n      if six.PY2 and isinstance(x, unicode):\n        x = x.encode(\'utf-8\')\n      return sp_model.PieceToId(x)\n\n    all_doc_tokens = list(map(_piece_to_id, para_tokens))\n\n    # The -3 accounts for [CLS], [SEP] and [SEP]\n    max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n    # We can have documents that are longer than the maximum sequence length.\n    # To deal with this we do a sliding window approach, where we take chunks\n    # of the up to our max length with a stride of `doc_stride`.\n    _DocSpan = collections.namedtuple(  # pylint: disable=invalid-name\n        ""DocSpan"", [""start"", ""length""])\n    doc_spans = []\n    start_offset = 0\n    while start_offset < len(all_doc_tokens):\n      length = len(all_doc_tokens) - start_offset\n      if length > max_tokens_for_doc:\n        length = max_tokens_for_doc\n      doc_spans.append(_DocSpan(start=start_offset, length=length))\n      if start_offset + length == len(all_doc_tokens):\n        break\n      start_offset += min(length, doc_stride)\n\n    for (doc_span_index, doc_span) in enumerate(doc_spans):\n      tokens = []\n      token_is_max_context = {}\n      segment_ids = []\n      p_mask = []\n\n      cur_tok_start_to_orig_index = []\n      cur_tok_end_to_orig_index = []\n\n      for i in range(doc_span.length):\n        split_token_index = doc_span.start + i\n\n        cur_tok_start_to_orig_index.append(\n            tok_start_to_orig_index[split_token_index])\n        cur_tok_end_to_orig_index.append(\n            tok_end_to_orig_index[split_token_index])\n\n        is_max_context = _check_is_max_context(doc_spans, doc_span_index,\n                                               split_token_index)\n        token_is_max_context[len(tokens)] = is_max_context\n        tokens.append(all_doc_tokens[split_token_index])\n        segment_ids.append(SEG_ID_P)\n        p_mask.append(0)\n\n      paragraph_len = len(tokens)\n\n      tokens.append(SEP_ID)\n      segment_ids.append(SEG_ID_P)\n      p_mask.append(1)\n\n      # note(zhiliny): we put P before Q\n      # because during pretraining, B is always shorter than A\n      for token in query_tokens:\n        tokens.append(token)\n        segment_ids.append(SEG_ID_Q)\n        p_mask.append(1)\n      tokens.append(SEP_ID)\n      segment_ids.append(SEG_ID_Q)\n      p_mask.append(1)\n\n      cls_index = len(segment_ids)\n      tokens.append(CLS_ID)\n      segment_ids.append(SEG_ID_CLS)\n      p_mask.append(0)\n\n      input_ids = tokens\n\n      # The mask has 0 for real tokens and 1 for padding tokens. Only real\n      # tokens are attended to.\n      input_mask = [0] * len(input_ids)\n\n      # Zero-pad up to the sequence length.\n      while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(1)\n        segment_ids.append(SEG_ID_PAD)\n        p_mask.append(1)\n\n      assert len(input_ids) == max_seq_length\n      assert len(input_mask) == max_seq_length\n      assert len(segment_ids) == max_seq_length\n      assert len(p_mask) == max_seq_length\n\n      span_is_impossible = example.is_impossible\n      start_position = None\n      end_position = None\n      if is_training and not span_is_impossible:\n        # For training, if our document chunk does not contain an annotation\n        # we throw it out, since there is nothing to predict.\n        doc_start = doc_span.start\n        doc_end = doc_span.start + doc_span.length - 1\n        out_of_span = False\n        if not (tok_start_position >= doc_start and\n                tok_end_position <= doc_end):\n          out_of_span = True\n        if out_of_span:\n          # continue\n          start_position = 0\n          end_position = 0\n          span_is_impossible = True\n        else:\n          # note(zhiliny): we put P before Q, so doc_offset should be zero.\n          # doc_offset = len(query_tokens) + 2\n          doc_offset = 0\n          start_position = tok_start_position - doc_start + doc_offset\n          end_position = tok_end_position - doc_start + doc_offset\n\n      if is_training and span_is_impossible:\n        start_position = cls_index\n        end_position = cls_index\n\n      if example_index < 20:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""unique_id: %s"" % (unique_id))\n        tf.logging.info(""example_index: %s"" % (example_index))\n        tf.logging.info(""doc_span_index: %s"" % (doc_span_index))\n        tf.logging.info(""tok_start_to_orig_index: %s"" % "" "".join(\n            [str(x) for x in cur_tok_start_to_orig_index]))\n        tf.logging.info(""tok_end_to_orig_index: %s"" % "" "".join(\n            [str(x) for x in cur_tok_end_to_orig_index]))\n        tf.logging.info(""token_is_max_context: %s"" % "" "".join([\n            ""%d:%s"" % (x, y) for (x, y) in six.iteritems(token_is_max_context)\n        ]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(\n            ""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(\n            ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n\n        if is_training and span_is_impossible:\n          tf.logging.info(""impossible example span"")\n\n        if is_training and not span_is_impossible:\n          pieces = [sp_model.IdToPiece(token) for token in\n                    tokens[start_position: (end_position + 1)]]\n          answer_text = sp_model.DecodePieces(pieces)\n          tf.logging.info(""start_position: %d"" % (start_position))\n          tf.logging.info(""end_position: %d"" % (end_position))\n          tf.logging.info(\n              ""answer: %s"" % (printable_text(answer_text)))\n\n          # note(zhiliny): With multi processing,\n          # the example_index is actually the index within the current process\n          # therefore we use example_index=None to avoid being used in the future.\n          # The current code does not use example_index of training data.\n      if is_training:\n        feat_example_index = None\n      else:\n        feat_example_index = example_index\n\n      feature = InputFeatures(\n          unique_id=unique_id,\n          example_index=feat_example_index,\n          doc_span_index=doc_span_index,\n          tok_start_to_orig_index=cur_tok_start_to_orig_index,\n          tok_end_to_orig_index=cur_tok_end_to_orig_index,\n          token_is_max_context=token_is_max_context,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          p_mask=p_mask,\n          segment_ids=segment_ids,\n          paragraph_len=paragraph_len,\n          cls_index=cls_index,\n          start_position=start_position,\n          end_position=end_position,\n          is_impossible=span_is_impossible)\n\n      # Run callback\n      output_fn(feature)\n\n      unique_id += 1\n      if span_is_impossible:\n        cnt_neg += 1\n      else:\n        cnt_pos += 1\n\n  tf.logging.info(""Total number of instances: {} = pos {} neg {}"".format(\n      cnt_pos + cnt_neg, cnt_pos, cnt_neg))\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n  """"""Check if this is the \'max context\' doc span for the token.""""""\n\n  # Because of the sliding window approach taken to scoring documents, a single\n  # token can appear in multiple documents. E.g.\n  #  Doc: the man went to the store and bought a gallon of milk\n  #  Span A: the man went to the\n  #  Span B: to the store and bought\n  #  Span C: and bought a gallon of\n  #  ...\n  #\n  # Now the word \'bought\' will have two scores from spans B and C. We only\n  # want to consider the score with ""maximum context"", which we define as\n  # the *minimum* of its left and right context (the *sum* of left and\n  # right context will always be the same, of course).\n  #\n  # In the example the maximum context for \'bought\' would be span C since\n  # it has 1 left context and 3 right context, while span B has 4 left context\n  # and 0 right context.\n  best_score = None\n  best_span_index = None\n  for (span_index, doc_span) in enumerate(doc_spans):\n    end = doc_span.start + doc_span.length - 1\n    if position < doc_span.start:\n      continue\n    if position > end:\n      continue\n    num_left_context = position - doc_span.start\n    num_right_context = end - position\n    score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n    if best_score is None or score > best_score:\n      best_score = score\n      best_span_index = span_index\n\n  return cur_span_index == best_span_index\n\n\nclass FeatureWriter(object):\n  """"""Writes InputFeature to TF example file.""""""\n\n  def __init__(self, filename, is_training):\n    self.filename = filename\n    self.is_training = is_training\n    self.num_features = 0\n    self._writer = tf.python_io.TFRecordWriter(filename)\n\n  def process_feature(self, feature):\n    """"""Write a InputFeature to the TFRecordWriter as a tf.train.Example.""""""\n    self.num_features += 1\n\n    def create_int_feature(values):\n      feature = tf.train.Feature(\n          int64_list=tf.train.Int64List(value=list(values)))\n      return feature\n\n    def create_float_feature(values):\n      f = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""unique_ids""] = create_int_feature([feature.unique_id])\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_float_feature(feature.input_mask)\n    features[""p_mask""] = create_float_feature(feature.p_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n\n    features[""cls_index""] = create_int_feature([feature.cls_index])\n\n    if self.is_training:\n      features[""start_positions""] = create_int_feature([feature.start_position])\n      features[""end_positions""] = create_int_feature([feature.end_position])\n      impossible = 0\n      if feature.is_impossible:\n        impossible = 1\n      features[""is_impossible""] = create_float_feature([impossible])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    self._writer.write(tf_example.SerializeToString())\n\n  def close(self):\n    self._writer.close()\n\n\nRawResult = collections.namedtuple(""RawResult"",\n    [""unique_id"", ""start_top_log_probs"", ""start_top_index"",\n    ""end_top_log_probs"", ""end_top_index""])\n\n_PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n    ""PrelimPrediction"",\n    [""feature_index"", ""start_index"", ""end_index"",\n    ""start_log_prob"", ""end_log_prob""])\n\n_NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n    ""NbestPrediction"", [""text"", ""start_log_prob"", ""end_log_prob""])\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, output_prediction_file,\n                      output_nbest_file,\n                      orig_data):\n  """"""Write final predictions to the json file and log-odds of null if needed.""""""\n  tf.logging.info(""Writing predictions to: %s"" % (output_prediction_file))\n  # tf.logging.info(""Writing nbest to: %s"" % (output_nbest_file))\n\n  example_index_to_features = collections.defaultdict(list)\n  for feature in all_features:\n    example_index_to_features[feature.example_index].append(feature)\n\n  unique_id_to_result = {}\n  for result in all_results:\n    unique_id_to_result[result.unique_id] = result\n\n  all_predictions = collections.OrderedDict()\n  all_nbest_json = collections.OrderedDict()\n  scores_diff_json = collections.OrderedDict()\n\n  for (example_index, example) in enumerate(all_examples):\n    features = example_index_to_features[example_index]\n\n    prelim_predictions = []\n    # keep track of the minimum score of null start+end of position 0\n    for (feature_index, feature) in enumerate(features):\n      result = unique_id_to_result[feature.unique_id]\n\n      for i in range(FLAGS.start_n_top):\n        for j in range(FLAGS.end_n_top):\n          start_log_prob = result.start_top_log_probs[i]\n          start_index = result.start_top_index[i]\n\n          j_index = i * FLAGS.end_n_top + j\n\n          end_log_prob = result.end_top_log_probs[j_index]\n          end_index = result.end_top_index[j_index]\n\n          # We could hypothetically create invalid predictions, e.g., predict\n          # that the start of the span is in the question. We throw out all\n          # invalid predictions.\n          if start_index >= feature.paragraph_len - 1:\n            continue\n          if end_index >= feature.paragraph_len - 1:\n            continue\n\n          if not feature.token_is_max_context.get(start_index, False):\n            continue\n          if end_index < start_index:\n            continue\n          length = end_index - start_index + 1\n          if length > max_answer_length:\n            continue\n\n          prelim_predictions.append(\n              _PrelimPrediction(\n                  feature_index=feature_index,\n                  start_index=start_index,\n                  end_index=end_index,\n                  start_log_prob=start_log_prob,\n                  end_log_prob=end_log_prob))\n\n    prelim_predictions = sorted(\n        prelim_predictions,\n        key=lambda x: (x.start_log_prob + x.end_log_prob),\n        reverse=True)\n\n    seen_predictions = {}\n    nbest = []\n    for pred in prelim_predictions:\n      if len(nbest) >= n_best_size:\n        break\n      feature = features[pred.feature_index]\n\n      tok_start_to_orig_index = feature.tok_start_to_orig_index\n      tok_end_to_orig_index = feature.tok_end_to_orig_index\n      start_orig_pos = tok_start_to_orig_index[pred.start_index]\n      end_orig_pos = tok_end_to_orig_index[pred.end_index]\n\n      paragraph_text = example.paragraph_text\n      final_text = paragraph_text[start_orig_pos: end_orig_pos + 1].strip()\n\n      if final_text in seen_predictions:\n        continue\n\n      seen_predictions[final_text] = True\n\n      nbest.append(\n          _NbestPrediction(\n              text=final_text,\n              start_log_prob=pred.start_log_prob,\n              end_log_prob=pred.end_log_prob))\n\n    # In very rare edge cases we could have no valid predictions. So we\n    # just create a nonce prediction in this case to avoid failure.\n    if not nbest:\n      nbest.append(\n          _NbestPrediction(text="""", start_log_prob=-1e6,\n          end_log_prob=-1e6))\n\n    total_scores = []\n    best_non_null_entry = None\n    for entry in nbest:\n      total_scores.append(entry.start_log_prob + entry.end_log_prob)\n      if not best_non_null_entry:\n        best_non_null_entry = entry\n\n    probs = _compute_softmax(total_scores)\n\n    nbest_json = []\n    for (i, entry) in enumerate(nbest):\n      output = collections.OrderedDict()\n      output[""text""] = entry.text\n      output[""probability""] = probs[i]\n      output[""start_log_prob""] = entry.start_log_prob\n      output[""end_log_prob""] = entry.end_log_prob\n      nbest_json.append(output)\n\n    assert len(nbest_json) >= 1\n    assert best_non_null_entry is not None\n\n    score_diff = 0 #score_null\n    scores_diff_json[example.qas_id] = score_diff\n    # note(zhiliny): always predict best_non_null_entry\n    # and the evaluation script will search for the best threshold\n    all_predictions[example.qas_id] = best_non_null_entry.text\n\n    all_nbest_json[example.qas_id] = nbest_json\n\n  with tf.gfile.GFile(output_prediction_file, ""w"") as writer:\n    writer.write(json.dumps(all_predictions, indent=4) + ""\\n"")\n\n  with tf.gfile.GFile(output_nbest_file, ""w"") as writer:\n    writer.write(json.dumps(all_nbest_json, indent=4) + ""\\n"")\n\n  qid_to_has_ans = squad_utils.make_qid_to_has_ans(orig_data)\n  has_ans_qids = [k for k, v in qid_to_has_ans.items() if v]\n  no_ans_qids = [k for k, v in qid_to_has_ans.items() if not v]\n  exact_raw, f1_raw = squad_utils.get_raw_scores(orig_data, all_predictions)\n  out_eval = {}\n\n  squad_utils.find_all_best_thresh_v2(out_eval, all_predictions, exact_raw, f1_raw,\n                                   scores_diff_json, qid_to_has_ans)\n\n  return out_eval\n\n\ndef _get_best_indexes(logits, n_best_size):\n  """"""Get the n-best logits from a list.""""""\n  index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\n\ndef _compute_softmax(scores):\n  """"""Compute softmax probability over raw logits.""""""\n  if not scores:\n    return []\n\n  max_score = None\n  for score in scores:\n    if max_score is None or score > max_score:\n      max_score = score\n\n  exp_scores = []\n  total_sum = 0.0\n  for score in scores:\n    x = math.exp(score - max_score)\n    exp_scores.append(x)\n    total_sum += x\n\n  probs = []\n  for score in exp_scores:\n    probs.append(score / total_sum)\n  return probs\n\n\ndef input_fn_builder(input_glob, seq_length, is_training, drop_remainder,\n                     num_hosts, num_threads=8):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""unique_ids"": tf.FixedLenFeature([], tf.int64),\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.float32),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""cls_index"": tf.FixedLenFeature([], tf.int64),\n      ""p_mask"": tf.FixedLenFeature([seq_length], tf.float32)\n  }\n\n  if is_training:\n    name_to_features[""start_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""end_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""is_impossible""] = tf.FixedLenFeature([], tf.float32)\n\n  tf.logging.info(""Input tfrecord file glob {}"".format(input_glob))\n  global_input_paths = tf.gfile.Glob(input_glob)\n  tf.logging.info(""Find {} input paths {}"".format(\n      len(global_input_paths), global_input_paths))\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.cast(t, tf.int32)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    if FLAGS.use_tpu:\n      batch_size = params[""batch_size""]\n    elif is_training:\n      batch_size = FLAGS.train_batch_size\n    else:\n      batch_size = FLAGS.predict_batch_size\n\n    # Split tfrecords across hosts\n    if num_hosts > 1:\n      host_id = params[""context""].current_host\n      num_files = len(global_input_paths)\n      if num_files >= num_hosts:\n        num_files_per_host = (num_files + num_hosts - 1) // num_hosts\n        my_start_file_id = host_id * num_files_per_host\n        my_end_file_id = min((host_id + 1) * num_files_per_host, num_files)\n        input_paths = global_input_paths[my_start_file_id: my_end_file_id]\n      tf.logging.info(""Host {} handles {} files"".format(host_id,\n                                                        len(input_paths)))\n    else:\n      input_paths = global_input_paths\n\n    if len(input_paths) == 1:\n      d = tf.data.TFRecordDataset(input_paths[0])\n      # For training, we want a lot of parallel reading and shuffling.\n      # For eval, we want no shuffling and parallel reading doesn\'t matter.\n      if is_training:\n        d = d.shuffle(buffer_size=FLAGS.shuffle_buffer)\n        d = d.repeat()\n    else:\n      d = tf.data.Dataset.from_tensor_slices(input_paths)\n      # file level shuffle\n      d = d.shuffle(len(input_paths)).repeat()\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_threads, len(input_paths))\n\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n\n      if is_training:\n        # sample level shuffle\n        d = d.shuffle(buffer_size=FLAGS.shuffle_buffer)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_threads,\n            drop_remainder=drop_remainder))\n    d = d.prefetch(1024)\n\n    return d\n\n  return input_fn\n\n\ndef get_model_fn():\n  def model_fn(features, labels, mode, params):\n    #### Training or Evaluation\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    #### Get loss from inputs\n    outputs = function_builder.get_qa_outputs(FLAGS, features, is_training)\n\n    #### Check model parameters\n    num_params = sum([np.prod(v.shape) for v in tf.trainable_variables()])\n    tf.logging.info(\'#params: {}\'.format(num_params))\n\n    scaffold_fn = None\n\n    #### Evaluation mode\n    if mode == tf.estimator.ModeKeys.PREDICT:\n      if FLAGS.init_checkpoint:\n        tf.logging.info(""init_checkpoint not being used in predict mode."")\n\n      predictions = {\n          ""unique_ids"": features[""unique_ids""],\n          ""start_top_index"": outputs[""start_top_index""],\n          ""start_top_log_probs"": outputs[""start_top_log_probs""],\n          ""end_top_index"": outputs[""end_top_index""],\n          ""end_top_log_probs"": outputs[""end_top_log_probs""]\n      }\n\n      if FLAGS.use_tpu:\n        output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n            mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n      else:\n        output_spec = tf.estimator.EstimatorSpec(\n            mode=mode, predictions=predictions)\n      return output_spec\n\n    ### Compute loss\n    seq_length = tf.shape(features[""input_ids""])[1]\n    def compute_loss(log_probs, positions):\n      one_hot_positions = tf.one_hot(\n          positions, depth=seq_length, dtype=tf.float32)\n\n      loss = - tf.reduce_sum(one_hot_positions * log_probs, axis=-1)\n      loss = tf.reduce_mean(loss)\n      return loss\n\n    start_loss = compute_loss(\n        outputs[""start_log_probs""], features[""start_positions""])\n    end_loss = compute_loss(\n        outputs[""end_log_probs""], features[""end_positions""])\n\n    total_loss = (start_loss + end_loss) * 0.5\n\n    #### Configuring the optimizer\n    train_op, learning_rate, _ = model_utils.get_train_op(FLAGS, total_loss)\n\n    monitor_dict = {}\n    monitor_dict[""lr""] = learning_rate\n\n    #### load pretrained models\n    scaffold_fn = model_utils.init_from_checkpoint(FLAGS)\n\n    #### Constucting training TPUEstimatorSpec with new cache.\n    if FLAGS.use_tpu:\n      host_call = function_builder.construct_scalar_host_call(\n          monitor_dict=monitor_dict,\n          model_dir=FLAGS.model_dir,\n          prefix=""train/"",\n          reduce_fn=tf.reduce_mean)\n\n      train_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op, host_call=host_call,\n          scaffold_fn=scaffold_fn)\n    else:\n      train_spec = tf.estimator.EstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op)\n\n    return train_spec\n\n  return model_fn\n\n\ndef _get_spm_basename():\n  spm_basename = os.path.basename(FLAGS.spiece_model_file)\n  return spm_basename\n\n\ndef preprocess():\n  sp_model = spm.SentencePieceProcessor()\n  sp_model.Load(FLAGS.spiece_model_file)\n  spm_basename = _get_spm_basename()\n\n  train_rec_file = os.path.join(\n      FLAGS.output_dir,\n      ""{}.{}.slen-{}.qlen-{}.train.tf_record"".format(\n          spm_basename, FLAGS.proc_id, FLAGS.max_seq_length,\n          FLAGS.max_query_length))\n\n  tf.logging.info(""Read examples from {}"".format(FLAGS.train_file))\n  train_examples = read_squad_examples(FLAGS.train_file, is_training=True)\n  train_examples = train_examples[FLAGS.proc_id::FLAGS.num_proc]\n\n  # Pre-shuffle the input to avoid having to make a very large shuffle\n  # buffer in the `input_fn`.\n  random.shuffle(train_examples)\n\n  tf.logging.info(""Write to {}"".format(train_rec_file))\n  train_writer = FeatureWriter(\n      filename=train_rec_file,\n      is_training=True)\n  convert_examples_to_features(\n      examples=train_examples,\n      sp_model=sp_model,\n      max_seq_length=FLAGS.max_seq_length,\n      doc_stride=FLAGS.doc_stride,\n      max_query_length=FLAGS.max_query_length,\n      is_training=True,\n      output_fn=train_writer.process_feature)\n  train_writer.close()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not tf.gfile.Exists(FLAGS.output_dir):\n    tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  if FLAGS.do_prepro:\n    preprocess()\n    return\n\n  #### Validate flags\n  if FLAGS.save_steps is not None:\n    FLAGS.iterations = min(FLAGS.iterations, FLAGS.save_steps)\n\n  if not FLAGS.do_train and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train` and `do_predict` must be True."")\n\n  if FLAGS.do_predict and not tf.gfile.Exists(FLAGS.predict_dir):\n    tf.gfile.MakeDirs(FLAGS.predict_dir)\n\n  sp_model = spm.SentencePieceProcessor()\n  sp_model.Load(FLAGS.spiece_model_file)\n\n  ### TPU Configuration\n  run_config = model_utils.configure_tpu(FLAGS)\n\n  model_fn = get_model_fn()\n  spm_basename = _get_spm_basename()\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  if FLAGS.use_tpu:\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n  else:\n    estimator = tf.estimator.Estimator(\n        model_fn=model_fn,\n        config=run_config)\n\n  if FLAGS.do_train:\n    train_rec_glob = os.path.join(\n        FLAGS.output_dir,\n        ""{}.*.slen-{}.qlen-{}.train.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length,\n        FLAGS.max_query_length))\n\n    train_input_fn = input_fn_builder(\n        input_glob=train_rec_glob,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True,\n        num_hosts=FLAGS.num_hosts)\n\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.train_steps)\n\n  if FLAGS.do_predict:\n    for eval_set in [\'dev\',\'test\',\'challenge\']:\n      new_predict_file = FLAGS.predict_file + ""_"" + eval_set + "".json""\n\n      eval_examples = read_squad_examples(new_predict_file, is_training=False)\n\n      with tf.gfile.Open(new_predict_file) as f:\n        orig_data = json.load(f)[""data""]\n\n      eval_rec_file = os.path.join(\n          FLAGS.output_dir,\n          ""{}.slen-{}.qlen-{}.{}.tf_record"".format(\n              spm_basename, FLAGS.max_seq_length, FLAGS.max_query_length, eval_set))\n      eval_feature_file = os.path.join(\n          FLAGS.output_dir,\n          ""{}.slen-{}.qlen-{}.{}.features.pkl"".format(\n              spm_basename, FLAGS.max_seq_length, FLAGS.max_query_length, eval_set))\n\n      if tf.gfile.Exists(eval_rec_file) and tf.gfile.Exists(\n          eval_feature_file) and not FLAGS.overwrite_data:\n        tf.logging.info(""Loading eval features from {}"".format(eval_feature_file))\n        with tf.gfile.Open(eval_feature_file, \'rb\') as fin:\n          eval_features = pickle.load(fin)\n      else:\n        eval_writer = FeatureWriter(filename=eval_rec_file, is_training=False)\n        eval_features = []\n\n        def append_feature(feature):\n          eval_features.append(feature)\n          eval_writer.process_feature(feature)\n\n        convert_examples_to_features(\n            examples=eval_examples,\n            sp_model=sp_model,\n            max_seq_length=FLAGS.max_seq_length,\n            doc_stride=FLAGS.doc_stride,\n            max_query_length=FLAGS.max_query_length,\n            is_training=False,\n            output_fn=append_feature)\n        eval_writer.close()\n\n        with tf.gfile.Open(eval_feature_file, \'wb\') as fout:\n          pickle.dump(eval_features, fout)\n\n      eval_input_fn = input_fn_builder(\n          input_glob=eval_rec_file,\n          seq_length=FLAGS.max_seq_length,\n          is_training=False,\n          drop_remainder=False,\n          num_hosts=1)\n\n      cur_results = []\n      for result in estimator.predict(\n          input_fn=eval_input_fn,\n          yield_single_examples=True):\n\n        if len(cur_results) % 1000 == 0:\n          tf.logging.info(""Processing example: %d"" % (len(cur_results)))\n\n        unique_id = int(result[""unique_ids""])\n        start_top_log_probs = (\n            [float(x) for x in result[""start_top_log_probs""].flat])\n        start_top_index = [int(x) for x in result[""start_top_index""].flat]\n        end_top_log_probs = (\n            [float(x) for x in result[""end_top_log_probs""].flat])\n        end_top_index = [int(x) for x in result[""end_top_index""].flat]\n\n\n        cur_results.append(\n            RawResult(\n                unique_id=unique_id,\n                start_top_log_probs=start_top_log_probs,\n                start_top_index=start_top_index,\n                end_top_log_probs=end_top_log_probs,\n                end_top_index=end_top_index))\n\n      output_prediction_file = os.path.join(\n          FLAGS.predict_dir, eval_set+""_predictions.json"")\n      output_nbest_file = os.path.join(\n          FLAGS.predict_dir, eval_set+""_nbest_predictions.json"")\n\n      ret = write_predictions(eval_examples, eval_features, cur_results,\n                              FLAGS.n_best_size, FLAGS.max_answer_length,\n                              output_prediction_file,\n                              output_nbest_file,\n                              orig_data)\n\n      # Log current result\n      tf.logging.info(""="" * 80)\n      log_str = ""Result | ""\n      for key, val in ret.items():\n        log_str += ""{} {} | "".format(key, val)\n      tf.logging.info(log_str)\n      tf.logging.info(""="" * 80)\n\n\nif __name__ == ""__main__"":\n  tf.app.run()\n\n'"
baselines/models/xlnet/squad_utils.py,0,"b'""""""Official evaluation script for SQuAD version 2.0.\n\nIn addition to basic functionality, we also compute additional statistics and\nplot precision-recall curves if an additional na_prob.json file is provided.\nThis file is expected to map question ID\'s to the model\'s predicted probability\nthat a question is unanswerable.\n""""""\nimport argparse\nimport collections\nimport json\nimport numpy as np\nimport os\nimport re\nimport string\nimport sys\n\nOPTS = None\n\ndef parse_args():\n  parser = argparse.ArgumentParser(\'Official evaluation script for SQuAD version 2.0.\')\n  parser.add_argument(\'data_file\', metavar=\'data.json\', help=\'Input data JSON file.\')\n  parser.add_argument(\'pred_file\', metavar=\'pred.json\', help=\'Model predictions.\')\n  parser.add_argument(\'--out-file\', \'-o\', metavar=\'eval.json\',\n                      help=\'Write accuracy metrics to file (default is stdout).\')\n  parser.add_argument(\'--na-prob-file\', \'-n\', metavar=\'na_prob.json\',\n                      help=\'Model estimates of probability of no answer.\')\n  parser.add_argument(\'--na-prob-thresh\', \'-t\', type=float, default=1.0,\n                      help=\'Predict """" if no-answer probability exceeds this (default = 1.0).\')\n  parser.add_argument(\'--out-image-dir\', \'-p\', metavar=\'out_images\', default=None,\n                      help=\'Save precision-recall curves to directory.\')\n  parser.add_argument(\'--verbose\', \'-v\', action=\'store_true\')\n  if len(sys.argv) == 1:\n    parser.print_help()\n    sys.exit(1)\n  return parser.parse_args()\n\ndef make_qid_to_has_ans(dataset):\n  qid_to_has_ans = {}\n  for article in dataset:\n    for p in article[\'paragraphs\']:\n      for qa in p[\'qas\']:\n        qid_to_has_ans[qa[\'id\']] = bool(qa[\'answers\'])\n  return qid_to_has_ans\n\ndef normalize_answer(s):\n  """"""Lower text and remove punctuation, articles and extra whitespace.""""""\n  def remove_articles(text):\n    regex = re.compile(r\'\\b(a|an|the)\\b\', re.UNICODE)\n    return re.sub(regex, \' \', text)\n  def white_space_fix(text):\n    return \' \'.join(text.split())\n  def remove_punc(text):\n    exclude = set(string.punctuation)\n    return \'\'.join(ch for ch in text if ch not in exclude)\n  def lower(text):\n    return text.lower()\n  return white_space_fix(remove_articles(remove_punc(lower(s))))\n\ndef get_tokens(s):\n  if not s: return []\n  return normalize_answer(s).split()\n\ndef compute_exact(a_gold, a_pred):\n  return int(normalize_answer(a_gold) == normalize_answer(a_pred))\n\ndef compute_f1(a_gold, a_pred):\n  gold_toks = get_tokens(a_gold)\n  pred_toks = get_tokens(a_pred)\n  common = collections.Counter(gold_toks) & collections.Counter(pred_toks)\n  num_same = sum(common.values())\n  if len(gold_toks) == 0 or len(pred_toks) == 0:\n    # If either is no-answer, then F1 is 1 if they agree, 0 otherwise\n    return int(gold_toks == pred_toks)\n  if num_same == 0:\n    return 0\n  precision = 1.0 * num_same / len(pred_toks)\n  recall = 1.0 * num_same / len(gold_toks)\n  f1 = (2 * precision * recall) / (precision + recall)\n  return f1\n\ndef get_raw_scores(dataset, preds):\n  exact_scores = {}\n  f1_scores = {}\n  for article in dataset:\n    for p in article[\'paragraphs\']:\n      for qa in p[\'qas\']:\n        qid = qa[\'id\']\n        gold_answers = [a[\'text\'] for a in qa[\'answers\']\n                        if normalize_answer(a[\'text\'])]\n        if not gold_answers:\n          # For unanswerable questions, only correct answer is empty string\n          gold_answers = [\'\']\n        if qid not in preds:\n          print(\'Missing prediction for %s\' % qid)\n          continue\n        a_pred = preds[qid]\n        # Take max over all gold answers\n        exact_scores[qid] = max(compute_exact(a, a_pred) for a in gold_answers)\n        f1_scores[qid] = max(compute_f1(a, a_pred) for a in gold_answers)\n  return exact_scores, f1_scores\n\ndef apply_no_ans_threshold(scores, na_probs, qid_to_has_ans, na_prob_thresh):\n  new_scores = {}\n  for qid, s in scores.items():\n    pred_na = na_probs[qid] > na_prob_thresh\n    if pred_na:\n      new_scores[qid] = float(not qid_to_has_ans[qid])\n    else:\n      new_scores[qid] = s\n  return new_scores\n\ndef make_eval_dict(exact_scores, f1_scores, qid_list=None):\n  if not qid_list:\n    total = len(exact_scores)\n    return collections.OrderedDict([\n        (\'exact\', 100.0 * sum(exact_scores.values()) / total),\n        (\'f1\', 100.0 * sum(f1_scores.values()) / total),\n        (\'total\', total),\n    ])\n  else:\n    total = len(qid_list)\n    return collections.OrderedDict([\n        (\'exact\', 100.0 * sum(exact_scores[k] for k in qid_list) / total),\n        (\'f1\', 100.0 * sum(f1_scores[k] for k in qid_list) / total),\n        (\'total\', total),\n    ])\n\ndef merge_eval(main_eval, new_eval, prefix):\n  for k in new_eval:\n    main_eval[\'%s_%s\' % (prefix, k)] = new_eval[k]\n\ndef plot_pr_curve(precisions, recalls, out_image, title):\n  plt.step(recalls, precisions, color=\'b\', alpha=0.2, where=\'post\')\n  plt.fill_between(recalls, precisions, step=\'post\', alpha=0.2, color=\'b\')\n  plt.xlabel(\'Recall\')\n  plt.ylabel(\'Precision\')\n  plt.xlim([0.0, 1.05])\n  plt.ylim([0.0, 1.05])\n  plt.title(title)\n  plt.savefig(out_image)\n  plt.clf()\n\ndef make_precision_recall_eval(scores, na_probs, num_true_pos, qid_to_has_ans,\n                               out_image=None, title=None):\n  qid_list = sorted(na_probs, key=lambda k: na_probs[k])\n  true_pos = 0.0\n  cur_p = 1.0\n  cur_r = 0.0\n  precisions = [1.0]\n  recalls = [0.0]\n  avg_prec = 0.0\n  for i, qid in enumerate(qid_list):\n    if qid_to_has_ans[qid]:\n      true_pos += scores[qid]\n    cur_p = true_pos / float(i+1)\n    cur_r = true_pos / float(num_true_pos)\n    if i == len(qid_list) - 1 or na_probs[qid] != na_probs[qid_list[i+1]]:\n      # i.e., if we can put a threshold after this point\n      avg_prec += cur_p * (cur_r - recalls[-1])\n      precisions.append(cur_p)\n      recalls.append(cur_r)\n  if out_image:\n    plot_pr_curve(precisions, recalls, out_image, title)\n  return {\'ap\': 100.0 * avg_prec}\n\ndef run_precision_recall_analysis(main_eval, exact_raw, f1_raw, na_probs, \n                                  qid_to_has_ans, out_image_dir):\n  if out_image_dir and not os.path.exists(out_image_dir):\n    os.makedirs(out_image_dir)\n  num_true_pos = sum(1 for v in qid_to_has_ans.values() if v)\n  if num_true_pos == 0:\n    return\n  pr_exact = make_precision_recall_eval(\n      exact_raw, na_probs, num_true_pos, qid_to_has_ans,\n      out_image=os.path.join(out_image_dir, \'pr_exact.png\'),\n      title=\'Precision-Recall curve for Exact Match score\')\n  pr_f1 = make_precision_recall_eval(\n      f1_raw, na_probs, num_true_pos, qid_to_has_ans,\n      out_image=os.path.join(out_image_dir, \'pr_f1.png\'),\n      title=\'Precision-Recall curve for F1 score\')\n  oracle_scores = {k: float(v) for k, v in qid_to_has_ans.items()}\n  pr_oracle = make_precision_recall_eval(\n      oracle_scores, na_probs, num_true_pos, qid_to_has_ans,\n      out_image=os.path.join(out_image_dir, \'pr_oracle.png\'),\n      title=\'Oracle Precision-Recall curve (binary task of HasAns vs. NoAns)\')\n  merge_eval(main_eval, pr_exact, \'pr_exact\')\n  merge_eval(main_eval, pr_f1, \'pr_f1\')\n  merge_eval(main_eval, pr_oracle, \'pr_oracle\')\n\ndef histogram_na_prob(na_probs, qid_list, image_dir, name):\n  if not qid_list:\n    return\n  x = [na_probs[k] for k in qid_list]\n  weights = np.ones_like(x) / float(len(x))\n  plt.hist(x, weights=weights, bins=20, range=(0.0, 1.0))\n  plt.xlabel(\'Model probability of no-answer\')\n  plt.ylabel(\'Proportion of dataset\')\n  plt.title(\'Histogram of no-answer probability: %s\' % name)\n  plt.savefig(os.path.join(image_dir, \'na_prob_hist_%s.png\' % name))\n  plt.clf()\n\ndef find_best_thresh(preds, scores, na_probs, qid_to_has_ans):\n  num_no_ans = sum(1 for k in qid_to_has_ans if not qid_to_has_ans[k])\n  cur_score = num_no_ans\n  best_score = cur_score\n  best_thresh = 0.0\n  qid_list = sorted(na_probs, key=lambda k: na_probs[k])\n  for i, qid in enumerate(qid_list):\n    if qid not in scores: continue\n    if qid_to_has_ans[qid]:\n      diff = scores[qid]\n    else:\n      if preds[qid]:\n        diff = -1\n      else:\n        diff = 0\n    cur_score += diff\n    if cur_score > best_score:\n      best_score = cur_score\n      best_thresh = na_probs[qid]\n  return 100.0 * best_score / len(scores), best_thresh\n\ndef find_best_thresh_v2(preds, scores, na_probs, qid_to_has_ans):\n  num_no_ans = sum(1 for k in qid_to_has_ans if not qid_to_has_ans[k])\n  cur_score = num_no_ans\n  best_score = cur_score\n  best_thresh = 0.0\n  qid_list = sorted(na_probs, key=lambda k: na_probs[k])\n  for i, qid in enumerate(qid_list):\n    if qid not in scores: continue\n    if qid_to_has_ans[qid]:\n      diff = scores[qid]\n    else:\n      if preds[qid]:\n        diff = -1\n      else:\n        diff = 0\n    cur_score += diff\n    if cur_score > best_score:\n      best_score = cur_score\n      best_thresh = na_probs[qid]\n\n  has_ans_score, has_ans_cnt = 0, 0\n  for qid in qid_list:\n    if not qid_to_has_ans[qid]: continue\n    has_ans_cnt += 1\n\n    if qid not in scores: continue\n    has_ans_score += scores[qid]\n\n  return 100.0 * best_score / len(scores), best_thresh, 1.0 * has_ans_score / has_ans_cnt\n\ndef find_all_best_thresh(main_eval, preds, exact_raw, f1_raw, na_probs, qid_to_has_ans):\n  best_exact, exact_thresh = find_best_thresh(preds, exact_raw, na_probs, qid_to_has_ans)\n  best_f1, f1_thresh = find_best_thresh(preds, f1_raw, na_probs, qid_to_has_ans)\n  main_eval[\'best_exact\'] = best_exact\n  main_eval[\'best_exact_thresh\'] = exact_thresh\n  main_eval[\'best_f1\'] = best_f1\n  main_eval[\'best_f1_thresh\'] = f1_thresh\n\ndef find_all_best_thresh_v2(main_eval, preds, exact_raw, f1_raw, na_probs, qid_to_has_ans):\n  best_exact, exact_thresh, has_ans_exact = find_best_thresh_v2(preds, exact_raw, na_probs, qid_to_has_ans)\n  best_f1, f1_thresh, has_ans_f1 = find_best_thresh_v2(preds, f1_raw, na_probs, qid_to_has_ans)\n  main_eval[\'best_exact\'] = best_exact\n  main_eval[\'best_exact_thresh\'] = exact_thresh\n  main_eval[\'best_f1\'] = best_f1\n  main_eval[\'best_f1_thresh\'] = f1_thresh\n  main_eval[\'has_ans_exact\'] = has_ans_exact\n  main_eval[\'has_ans_f1\'] = has_ans_f1\n\ndef main():\n  with open(OPTS.data_file) as f:\n    dataset_json = json.load(f)\n    dataset = dataset_json[\'data\']\n  with open(OPTS.pred_file) as f:\n    preds = json.load(f)\n\n  new_orig_data = []\n  for article in dataset:\n    for p in article[\'paragraphs\']:\n      for qa in p[\'qas\']:\n        if qa[\'id\'] in preds:\n          new_para = {\'qas\': [qa]}\n          new_article = {\'paragraphs\': [new_para]}\n          new_orig_data.append(new_article)\n  dataset = new_orig_data\n\n  if OPTS.na_prob_file:\n    with open(OPTS.na_prob_file) as f:\n      na_probs = json.load(f)\n  else:\n    na_probs = {k: 0.0 for k in preds}\n  qid_to_has_ans = make_qid_to_has_ans(dataset)  # maps qid to True/False\n  has_ans_qids = [k for k, v in qid_to_has_ans.items() if v]\n  no_ans_qids = [k for k, v in qid_to_has_ans.items() if not v]\n  exact_raw, f1_raw = get_raw_scores(dataset, preds)\n  exact_thresh = apply_no_ans_threshold(exact_raw, na_probs, qid_to_has_ans,\n                                        OPTS.na_prob_thresh)\n  f1_thresh = apply_no_ans_threshold(f1_raw, na_probs, qid_to_has_ans,\n                                     OPTS.na_prob_thresh)\n  out_eval = make_eval_dict(exact_thresh, f1_thresh)\n  if has_ans_qids:\n    has_ans_eval = make_eval_dict(exact_thresh, f1_thresh, qid_list=has_ans_qids)\n    merge_eval(out_eval, has_ans_eval, \'HasAns\')\n  if no_ans_qids:\n    no_ans_eval = make_eval_dict(exact_thresh, f1_thresh, qid_list=no_ans_qids)\n    merge_eval(out_eval, no_ans_eval, \'NoAns\')\n  if OPTS.na_prob_file:\n    find_all_best_thresh(out_eval, preds, exact_raw, f1_raw, na_probs, qid_to_has_ans)\n  if OPTS.na_prob_file and OPTS.out_image_dir:\n    run_precision_recall_analysis(out_eval, exact_raw, f1_raw, na_probs, \n                                  qid_to_has_ans, OPTS.out_image_dir)\n    histogram_na_prob(na_probs, has_ans_qids, OPTS.out_image_dir, \'hasAns\')\n    histogram_na_prob(na_probs, no_ans_qids, OPTS.out_image_dir, \'noAns\')\n  if OPTS.out_file:\n    with open(OPTS.out_file, \'w\') as f:\n      json.dump(out_eval, f)\n  else:\n    print(json.dumps(out_eval, indent=2))\n\nif __name__ == \'__main__\':\n  OPTS = parse_args()\n  if OPTS.out_image_dir:\n    import matplotlib\n    matplotlib.use(\'Agg\')\n    import matplotlib.pyplot as plt \n  main()\n'"
baselines/models/xlnet/summary.py,0,"b'# -*- coding: utf-8 -*-\n\'\'\'\nprint summary\n\'\'\'\nfrom __future__ import print_function\nfrom collections import Counter, OrderedDict\nimport string\nimport re\nimport argparse\nimport json\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf-8\')\nimport pdb\nimport os\nimport math\nimport numpy as np\nimport collections\nfrom prettytable import PrettyTable\n\ndef print_summary():\n\tlscmd = os.popen(\'ls \'+sys.argv[1]+\'/result.*\').read()\n\tresult_list = lscmd.split()\n\tnum_args = len(result_list)\n\tassert num_args==2 or num_args==3\n\n\tdev_input_file = open(sys.argv[1]+\'/result.dev\', \'rb\')\n\ttest_input_file = open(sys.argv[1]+\'/result.test\', \'rb\')\n\tif num_args==2:\n\t\tprint_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'FILE\'])\n\telif num_args==3:\n\t\tchl_input_file = open(sys.argv[1]+\'/result.challenge\', \'rb\')\n\t\tprint_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'CHL-AVG\',\'CHL-EM\',\'CHL-F1\',\'FILE\'])\n\n\t# style set\n\tprint_table.align[\'FILE\'] = \'l\'\n\tprint_table.float_format = \'2.3\'\n\n\t# data fill\n\tdev_avg = []\n\tdev_em = []\n\tdev_f1 = []\n\tdev_file = []\n\tfor dline in dev_input_file.readlines():\n\t\tdline = dline.strip()\n\t\tif re.search(\'^{\', dline):\n\t\t\tddict = json.loads(dline)\n\t\t\tdev_avg.append(float(ddict[\'AVERAGE\']))\n\t\t\tdev_em.append(float(ddict[\'EM\']))\n\t\t\tdev_f1.append(float(ddict[\'F1\']))\n\t\t\tdev_file.append(ddict[\'FILE\'])\n\n\ttest_avg = []\n\ttest_em = []\n\ttest_f1 = []\n\ttest_file = []\n\tfor dline in test_input_file.readlines():\n\t\tdline = dline.strip()\n\t\tif re.search(\'^{\', dline):\n\t\t\tddict = json.loads(dline)\n\t\t\ttest_avg.append(float(ddict[\'AVERAGE\']))\n\t\t\ttest_em.append(float(ddict[\'EM\']))\n\t\t\ttest_f1.append(float(ddict[\'F1\']))\n\t\t\ttest_file.append(ddict[\'FILE\'])\n\n\tif num_args==3:\n\t\tchl_avg = []\n\t\tchl_em = []\n\t\tchl_f1 = []\n\t\tchl_file = []\n\t\tfor dline in chl_input_file.readlines():\n\t\t\tdline = dline.strip()\n\t\t\tif re.search(\'^{\', dline):\n\t\t\t\tddict = json.loads(dline)\n\t\t\t\tchl_avg.append(float(ddict[\'AVERAGE\']))\n\t\t\t\tchl_em.append(float(ddict[\'EM\']))\n\t\t\t\tchl_f1.append(float(ddict[\'F1\']))\n\t\t\t\tchl_file.append(ddict[\'FILE\'])\n\n\t# print\n\tif num_args == 2:\n\t\tmin_len = min(len(dev_avg),len(test_avg))\n\t\tfor k in range(min_len):\n\t\t\tprint_table.add_row([k+1, dev_avg[k], dev_em[k], dev_f1[k], test_avg[k], test_em[k], test_f1[k], dev_file[k]])\n\telif num_args == 3:\n\t\tmin_len = min(len(dev_avg),len(test_avg),len(chl_avg))\n\t\tfor k in range(min_len):\n\t\t\tprint_table.add_row([k+1, dev_avg[k], dev_em[k], dev_f1[k], test_avg[k], test_em[k], test_f1[k], chl_avg[k], chl_em[k], chl_f1[k], dev_file[k]])\n\n\tif len(sys.argv)==3:\n\t\tsk = sys.argv[2].upper()\n\t\tprint(\'sort key detected: {}\'.format(sk))\n\t\tprint(print_table.get_string(sortby=sk, reversesort=True))\n\telse:\n\t\tprint(print_table)\n\t\n\n\tif num_args == 2:\n\t\tsummary_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'FILE\'])\n\t\tsummary_table.add_row([""M"", np.max(dev_avg), np.max(dev_em), np.max(dev_f1), \n\t\t\t\t\t\t\t\t  np.max(test_avg), np.max(test_em), np.max(test_f1),""-""])\n\t\tsummary_table.add_row([""A"", np.mean(dev_avg), np.mean(dev_em), np.mean(dev_f1), \n\t\t\t\t\t\t\t\t  np.mean(test_avg), np.mean(test_em), np.mean(test_f1),""-""])\n\t\tsummary_table.add_row([""D"", np.std(dev_avg), np.std(dev_em), np.std(dev_f1), \n\t\t\t\t\t\t\t\t  np.std(test_avg), np.std(test_em), np.std(test_f1),""-""])\n\telif num_args == 3:\n\t\tsummary_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'CHL-AVG\',\'CHL-EM\',\'CHL-F1\',\'FILE\'])\n\t\tsummary_table.add_row([""M"", np.max(dev_avg), np.max(dev_em), np.max(dev_f1), \n\t\t\t\t\t\t\t\t  np.max(test_avg), np.max(test_em), np.max(test_f1),\n\t\t\t\t\t\t\t\t  np.max(chl_avg), np.max(chl_em), np.max(chl_f1), ""-""])\n\t\tsummary_table.add_row([""A"", np.mean(dev_avg), np.mean(dev_em), np.mean(dev_f1), \n\t\t\t\t\t\t\t\t  np.mean(test_avg), np.mean(test_em), np.mean(test_f1),\n\t\t\t\t\t\t\t\t  np.mean(chl_avg), np.mean(chl_em), np.mean(chl_f1), ""-""])\n\t\tsummary_table.add_row([""D"", np.std(dev_avg), np.std(dev_em), np.std(dev_f1), \n\t\t\t\t\t\t\t\t  np.std(test_avg), np.std(test_em), np.std(test_f1),\n\t\t\t\t\t\t\t\t  np.std(chl_avg), np.std(chl_em), np.std(chl_f1), ""-""])\n\t# style set\n\tsummary_table.align[\'FILE\'] = \'l\'\n\tsummary_table.float_format = \'2.3\'\n\tprint(summary_table)\n\treturn 0\n\n\n\n\nif __name__ == \'__main__\':\n\tprint_summary()\n\n'"
baselines/models/xlnet/tpu_estimator.py,28,"b'# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ===================================================================\n""""""TPUEstimator class.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport os\nimport signal\nimport sys\nimport threading\nimport time\n\nimport numpy as np\nimport six\nfrom six.moves import queue as Queue  # pylint: disable=redefined-builtin\nfrom six.moves import xrange  # pylint: disable=redefined-builtin\n\nfrom tensorflow.contrib.tpu.proto import compilation_result_pb2 as tpu_compilation_result\nfrom tensorflow.contrib.tpu.python.tpu import tensor_tracer\nfrom tensorflow.contrib.tpu.python.ops import tpu_ops\nfrom tensorflow.contrib.tpu.python.tpu import error_handling\nfrom tensorflow.contrib.tpu.python.tpu import session_support\nfrom tensorflow.contrib.tpu.python.tpu import tpu\nfrom tensorflow.contrib.tpu.python.tpu import tpu_config\nfrom tensorflow.contrib.tpu.python.tpu import tpu_context\nfrom tensorflow.contrib.tpu.python.tpu import tpu_feed\nfrom tensorflow.contrib.tpu.python.tpu import training_loop\nfrom tensorflow.contrib.tpu.python.tpu import util as util_lib\nfrom tensorflow.contrib.training.python.training import hparam\nfrom tensorflow.core.framework import variable_pb2\nfrom tensorflow.core.framework.summary_pb2 import Summary\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.client import session as tf_session\nfrom tensorflow.python.data.ops import dataset_ops\nfrom tensorflow.python.data.util import nest as data_nest\nfrom tensorflow.python.estimator import estimator as estimator_lib\nfrom tensorflow.python.estimator import model_fn as model_fn_lib\nfrom tensorflow.python.estimator.export import export_output as export_output_lib\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import check_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import init_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.ops import state_ops\nfrom tensorflow.python.ops import summary_ops_v2 as contrib_summary\nfrom tensorflow.python.ops import variable_scope\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.saved_model import tag_constants\nfrom tensorflow.python.summary import summary\nfrom tensorflow.python.training import basic_session_run_hooks\nfrom tensorflow.python.training import evaluation\nfrom tensorflow.python.training import session_run_hook\nfrom tensorflow.python.training import training\nfrom tensorflow.python.training import training_util\nfrom tensorflow.python.util import function_utils\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import tf_inspect\n\n_INITIAL_LOSS = 1e7\n_ZERO_LOSS = 0.\n_TPU_ESTIMATOR = \'custom_tpu_estimator\'\n_ITERATIONS_PER_LOOP_VAR = \'iterations_per_loop\'\n_BATCH_SIZE_KEY = \'batch_size\'\n_CTX_KEY = \'context\'\n_USE_TPU_KEY = \'use_tpu\'\n_CROSS_REPLICA_SUM_OP = \'CrossReplicaSum\'\n_ONE_GIGABYTE = 1024 * 1024 * 1024\n_TPU_ENQUEUE_OPS = \'_tpu_enqueue_ops\'\n_TPU_TRAIN_OP = \'_tpu_train_op\'\n_REWRITE_FOR_INFERENCE_MODE = \'_rewrite_for_inference\'\n\n# Ideally _USE_TPU_KEY should be reserved as well. However there are already\n# models that make use of this key, thus it can not be reserved now to prevent\n# breakage. In the long run, we would like to mitigate this by migrating models\n# off of using _USE_TPU_KEY.\n_RESERVED_PARAMS_KEYS = [_BATCH_SIZE_KEY, _CTX_KEY]\n\n# TODO(b/65703635): Flip the value and remove all dead code. Currently, this is\n# only used for per-core based deployments. For per-host based pipelines, if a\n# user returns a Dataset instance it will be automatically wrapped in a\n# tf.while_loop (This can be disabled by returning features and labels\n# explicitly).\n_WRAP_INPUT_FN_INTO_WHILE_LOOP = False\n\nops.register_proto_function(\n    \'{}_{}\'.format(_TPU_ESTIMATOR, _ITERATIONS_PER_LOOP_VAR),\n    proto_type=variable_pb2.VariableDef,\n    to_proto=resource_variable_ops._to_proto_fn,  # pylint: disable=protected-access\n    from_proto=resource_variable_ops._from_proto_fn)  # pylint: disable=protected-access\n\n\ndef _is_iterable(obj):\n  """"""A Python 2 and 3 compatible util to check whether `obj` is iterable.""""""\n  try:\n    iter(obj)\n    return True\n  except TypeError:\n    return False\n\n\ndef _create_global_step(graph):\n  graph = graph or ops.get_default_graph()\n  if training.get_global_step(graph) is not None:\n    raise ValueError(\'""global_step"" already exists.\')\n  # Create in proper graph and base name_scope.\n  with graph.as_default() as g, g.name_scope(None):\n    return variable_scope.get_variable(\n        ops.GraphKeys.GLOBAL_STEP,\n        shape=[],\n        dtype=dtypes.int64,\n        initializer=init_ops.zeros_initializer(),\n        trainable=False,\n        use_resource=True,\n        collections=[ops.GraphKeys.GLOBAL_VARIABLES, ops.GraphKeys.GLOBAL_STEP])\n\n\ndef _create_or_get_iterations_per_loop():\n  """"""Creates or gets the iterations_per_loop variable.\n\n  In TPUEstimator, the user provided computation, the model_fn, is wrapped\n  inside a tf.while_loop for peak performance. The iterations of the loop are\n  specified by this variable, which adjusts its value on the CPU after each TPU\n  program execution and before the next TPU execution.\n\n  The purpose of using a variable, rather then a constant, is to allow\n  TPUEstimator adapt the TPU training iterations according to the final steps\n  specified by users. For example, if the user sets the iterations_per_loop as 4\n  in TPUConfig and steps as 10 in TPUEstimator.train(), the iterations_per_loop\n  variable will have the following value before each TPU training.\n\n      - 1-th TPU execution: iterations_per_loop = 4\n      - 2-th TPU execution: iterations_per_loop = 4\n      - 3-th TPU execution: iterations_per_loop = 2\n\n  As model_fn increases the global step once per train_op invocation, the global\n  step is 10 after all TPU executions, matching the steps=10 inputs passed in by\n  users.\n\n  Returns:\n    A TF non-trainable resource variable.\n\n  Raises:\n    RuntimeError: If multi iterations_per_loop variables were found.\n  """"""\n  graph = ops.get_default_graph()\n  collection_name = \'{}_{}\'.format(_TPU_ESTIMATOR, _ITERATIONS_PER_LOOP_VAR)\n  iter_vars = graph.get_collection(collection_name)\n  if len(iter_vars) == 1:\n    return iter_vars[0]\n  elif len(iter_vars) > 1:\n    raise RuntimeError(\'Multiple iterations_per_loop_var in collection.\')\n\n  with ops.colocate_with(training_util.get_global_step()):\n    with variable_scope.variable_scope(\n        _TPU_ESTIMATOR, reuse=variable_scope.AUTO_REUSE):\n      return variable_scope.get_variable(\n          _ITERATIONS_PER_LOOP_VAR,\n          initializer=init_ops.zeros_initializer(),\n          shape=[],\n          dtype=dtypes.int32,\n          trainable=False,\n          collections=[collection_name, ops.GraphKeys.LOCAL_VARIABLES],\n          use_resource=True)\n\n\ndef _sync_variables_ops(ctx):\n  """"""Create varriables synchronization ops.\n\n  Gets the variables back from TPU nodes. This means the variables updated\n  by TPU will now be *synced* to host memory.\n  In BROADCAST mode, we skip this sync since the variables are ususally too\n  big to transmit via RPC.\n\n  Args:\n    ctx: A `_InternalTPUContext` instance with mode.\n\n  Returns:\n    A list of sync ops.\n  """"""\n\n  if not ctx.is_input_broadcast_with_iterators():\n    return [\n        array_ops.check_numerics(v.read_value(),\n                                 \'Gradient for %s is NaN\' % v.name).op\n        for v in variables.trainable_variables()\n    ]\n  else:\n    return [control_flow_ops.no_op()]\n\n\ndef _increase_eval_step_op(iterations_per_loop):\n  """"""Returns an op to increase the eval step for TPU evaluation.\n\n  Args:\n    iterations_per_loop: Tensor. The number of eval steps running in TPU system\n      before returning to CPU host for each `Session.run`.\n\n  Returns:\n    An operation\n  """"""\n  eval_step = evaluation._get_or_create_eval_step()  # pylint: disable=protected-access\n  # Estimator evaluate increases 1 by default. So, we increase the difference.\n  return state_ops.assign_add(\n      eval_step,\n      math_ops.cast(iterations_per_loop - 1, dtype=eval_step.dtype),\n      use_locking=True)\n\n\ndef _extract_key_names(tensor_or_dict):\n  if isinstance(tensor_or_dict, dict):\n    return sorted(tensor_or_dict.keys())\n  return []\n\n\nclass _SIGNAL(object):\n  """"""Signal used to control the thread of infeed/outfeed.\n\n  All preserved signals must be negative numbers. Positive numbers are used to\n  indicate the number of iterations for next training/evaluation loop.\n  """"""\n  NEXT_BATCH = -1\n  STOP = -2\n\n\nclass TPUEstimatorSpec(model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n  """"""Ops and objects returned from a `model_fn` and passed to `TPUEstimator`.\n\n  See `EstimatorSpec` for `mode`, `predictions`, `loss`, `train_op`, and\n  `export_outputs`.\n\n  For evaluation, `eval_metrics `is a tuple of `metric_fn` and `tensors`, where\n  `metric_fn` runs on CPU to generate metrics and `tensors` represents the\n  `Tensor`s transferred from TPU system to CPU host and passed to `metric_fn`.\n  To be precise, TPU evaluation expects a slightly different signature from the\n  `tf.estimator.Estimator`. While `EstimatorSpec.eval_metric_ops` expects a\n  dict, `TPUEstimatorSpec.eval_metrics` is a tuple of `metric_fn` and `tensors`.\n  The `tensors` could be a list of `Tensor`s or dict of names to `Tensor`s. The\n  `tensors` usually specify the model logits, which are transferred back from\n  TPU system to CPU host. All tensors must have be batch-major, i.e., the batch\n  size is the first dimension. Once all tensors are available at CPU host from\n  all shards, they are concatenated (on CPU) and passed as positional arguments\n  to the `metric_fn` if `tensors` is list or keyword arguments if `tensors` is\n  a dict. `metric_fn` takes the `tensors` and returns a dict from metric string\n  name to the result of calling a metric function, namely a `(metric_tensor,\n  update_op)` tuple. See `TPUEstimator` for MNIST example how to specify the\n  `eval_metrics`.\n\n  `scaffold_fn` is a function running on CPU to generate the `Scaffold`. This\n  function should not capture any Tensors in `model_fn`.\n\n  `host_call` is a tuple of a `function` and a list or dictionary of `tensors`\n  to pass to that function and returns a list of Tensors. `host_call` currently\n  works for train() and evaluate(). The Tensors returned by the function is\n  executed on the CPU on every step, so there is communication overhead when\n  sending tensors from TPU to CPU. To reduce the overhead, try reducing the\n  size of the tensors. The `tensors` are concatenated along their major (batch)\n  dimension, and so must be >= rank 1. The `host_call` is useful for writing\n  summaries with `tf.contrib.summary.create_file_writer`.\n  """"""\n\n  def __new__(cls,\n              mode,\n              predictions=None,\n              loss=None,\n              train_op=None,\n              eval_metrics=None,\n              export_outputs=None,\n              scaffold_fn=None,\n              host_call=None,\n              training_hooks=None,\n              evaluation_hooks=None,\n              prediction_hooks=None):\n    """"""Creates a validated `TPUEstimatorSpec` instance.""""""\n    host_calls = {}\n    if eval_metrics is not None:\n      host_calls[\'eval_metrics\'] = eval_metrics\n    if host_call is not None:\n      host_calls[\'host_call\'] = host_call\n    _OutfeedHostCall.validate(host_calls)\n\n    training_hooks = tuple(training_hooks or [])\n    evaluation_hooks = tuple(evaluation_hooks or [])\n    prediction_hooks = tuple(prediction_hooks or [])\n\n    for hook in training_hooks + evaluation_hooks + prediction_hooks:\n      if not isinstance(hook, session_run_hook.SessionRunHook):\n        raise TypeError(\'All hooks must be SessionRunHook instances, given: {}\'\n                        .format(hook))\n\n    return super(TPUEstimatorSpec, cls).__new__(\n        cls,\n        mode=mode,\n        predictions=predictions,\n        loss=loss,\n        train_op=train_op,\n        eval_metrics=eval_metrics,\n        export_outputs=export_outputs,\n        scaffold_fn=scaffold_fn,\n        host_call=host_call,\n        training_hooks=training_hooks,\n        evaluation_hooks=evaluation_hooks,\n        prediction_hooks=prediction_hooks)\n\n  def as_estimator_spec(self):\n    """"""Creates an equivalent `EstimatorSpec` used by CPU train/eval.""""""\n    host_calls = {}\n    if self.eval_metrics is not None:\n      host_calls[\'eval_metrics\'] = self.eval_metrics\n    if self.host_call is not None:\n      host_calls[\'host_call\'] = self.host_call\n    host_call_ret = _OutfeedHostCall.create_cpu_hostcall(host_calls)\n    eval_metric_ops = None\n    if self.eval_metrics is not None:\n      eval_metric_ops = host_call_ret[\'eval_metrics\']\n    hooks = None\n    if self.host_call is not None:\n      hooks = [_OutfeedHostCallHook(host_call_ret[\'host_call\'])]\n    if tensor_tracer.TensorTracer.is_enabled():\n      tt = tensor_tracer.TensorTracer()\n      tracing_calls = tt.trace_cpu(ops.get_default_graph())\n      tracing_call_ret = _OutfeedHostCall.create_cpu_hostcall(tracing_calls)\n      tracing_functions = tracing_call_ret.values()\n      if tracing_functions:\n        if hooks:\n          hooks.extend([_OutfeedHostCallHook(tracing_functions)])\n        else:\n          hooks = [_OutfeedHostCallHook(tracing_functions)]\n    hooks = tuple(hooks or [])\n    scaffold = self.scaffold_fn() if self.scaffold_fn else None\n    return model_fn_lib.EstimatorSpec(\n        mode=self.mode,\n        predictions=self.predictions,\n        loss=self.loss,\n        train_op=self.train_op,\n        eval_metric_ops=eval_metric_ops,\n        export_outputs=self.export_outputs,\n        scaffold=scaffold,\n        training_hooks=self.training_hooks + hooks,\n        evaluation_hooks=self.evaluation_hooks + hooks,\n        prediction_hooks=self.prediction_hooks + hooks)\n\n\nclass _OpQueueContext(object):\n  """"""Manages work queue and thread for a infeed/outfeed thread.""""""\n\n  def __init__(self, name, target, args):\n    self._name = name\n    self._queue = Queue.Queue()\n    args = (self,) + args\n    self._thread = threading.Thread(name=name, target=target, args=args)\n    self._thread.daemon = True\n    self._thread.start()\n\n  def stop(self):\n    self._queue.put(_SIGNAL.STOP)\n\n  def send_next_batch_signal(self, iterations):\n    self._queue.put(iterations)\n\n  def read_iteration_counts(self):\n    while True:\n      iterations = self._queue.get(block=True)\n      logging.debug(\'%s read iterations %s\', self._name, iterations)\n      if iterations == _SIGNAL.STOP:\n        logging.info(\'%s received shutdown signal, stopping.\', self._name)\n        return\n      yield iterations\n\n  def join(self):\n    logging.info(\'Shutting down %s thread.\', self._name)\n    self.stop()\n    self._thread.join()\n\n\nclass _OpSignalOnceQueueContext(_OpQueueContext):\n  """"""Manages work queue and thread for a infeed/outfeed thread.\n\n  This subclass only signals once.\n  """"""\n\n  def __init__(self, name, target, args):\n    super(_OpSignalOnceQueueContext, self).__init__(name, target, args)\n    self._has_signaled = False\n\n  def send_next_batch_signal(self, iterations):\n    if not self._has_signaled:\n      self._queue.put(iterations)\n      self._has_signaled = True\n\n\nclass TPUInfeedOutfeedSessionHook(session_run_hook.SessionRunHook):\n  """"""A Session hook setting up the TPU initialization, infeed, and outfeed.\n\n  This hook does two major things:\n  1. initialize and shutdown TPU system.\n  2. launch and join the threads for infeed enqueue and (optional) outfeed\n     dequeue.\n  """"""\n\n  def __init__(self,\n               ctx,\n               enqueue_ops,\n               dequeue_ops,\n               tpu_compile_op,\n               run_infeed_loop_on_coordinator=True,\n               rendezvous=None,\n               master=None,\n               session_config=None):\n    self._master_job = ctx.master_job\n    self._enqueue_ops = enqueue_ops\n    self._dequeue_ops = dequeue_ops\n    self._rendezvous = rendezvous\n    self._master = master\n    self._session_config = session_config\n    self._run_infeed_loop_on_coordinator = run_infeed_loop_on_coordinator\n    self._initial_infeed_sleep_secs = (\n        ctx.config.tpu_config.initial_infeed_sleep_secs)\n\n    self._feed_error = None\n    self._finished = False\n    self._should_initialize_tpu = True\n    self._tpu_compile_op = tpu_compile_op\n\n  def begin(self):\n    logging.info(\'TPU job name %s\', self._master_job)\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n    self._init_ops = []\n    if self._should_initialize_tpu:\n      self._finalize_ops = [tpu.shutdown_system(job=self._master_job)]\n    else:\n      self._finalize_ops = []\n\n    summary_writer_init_ops = contrib_summary.summary_writer_initializer_op()\n    self._init_ops.extend(summary_writer_init_ops)\n    # Get all the writer resources from the initializer, so we know what to\n    # flush.\n    for op in summary_writer_init_ops:\n      self._finalize_ops.append(contrib_summary.flush(writer=op.inputs[0]))\n\n  def _run_infeed(self, queue_ctx, session):\n    logging.info(\'Starting infeed thread controller.\')\n    if self._initial_infeed_sleep_secs:\n      logging.info(\'Infeed thread sleeping for %d seconds.\',\n                   self._initial_infeed_sleep_secs)\n      time.sleep(self._initial_infeed_sleep_secs)\n      logging.info(\'Infeed thread starting after sleep\')\n\n    with self._rendezvous.catch_errors(source=\'infeed\', session=session):\n      if self._run_infeed_loop_on_coordinator:\n        for count, steps in enumerate(queue_ctx.read_iteration_counts()):\n          for i in xrange(steps):\n            logging.debug(\'Infeed enqueue for iteration (%d, %d)\', count, i)\n            session.run(self._enqueue_ops)\n      else:\n        for _ in queue_ctx.read_iteration_counts():\n          session.run(self._enqueue_ops)\n      logging.info(\'Infeed thread finished, shutting down.\')\n\n  def _run_outfeed(self, queue_ctx, session):\n    logging.info(\'Starting outfeed thread controller.\')\n    with self._rendezvous.catch_errors(source=\'outfeed\', session=session):\n      for count, steps in enumerate(queue_ctx.read_iteration_counts()):\n        for i in xrange(steps):\n          logging.debug(\'Outfeed dequeue for iteration (%d, %d)\', count, i)\n          session.run(self._dequeue_ops)\n      logging.info(\'Outfeed thread finished, shutting down.\')\n\n  def _create_infeed_controller(self, name, target, args):\n    return _OpQueueContext(name=name, target=target, args=args)\n\n  def _assertCompilationSucceeded(self, result, coord):\n    proto = tpu_compilation_result.CompilationResultProto()\n    proto.ParseFromString(result)\n    if proto.status_error_message:\n      logging.error(\'Compilation failed: {}\'.format(proto.status_error_message))\n      coord.request_stop()\n    else:\n      logging.info(\'Compilation succeeded\')\n\n  def after_create_session(self, session, coord):\n    if self._should_initialize_tpu:\n      logging.info(\'Init TPU system\')\n      start = time.time()\n      with ops.Graph().as_default():\n        with tf_session.Session(\n            self._master, config=self._session_config) as sess:\n          sess.run(tpu.initialize_system(job=self._master_job))\n      logging.info(\'Initialized TPU in %d seconds\', time.time() - start)\n\n    session.run(self._init_ops,\n                options=config_pb2.RunOptions(timeout_in_ms=5 * 60 * 1000))\n\n    if os.environ.get(\'TPU_SPLIT_COMPILE_AND_EXECUTE\', \'\') == \'1\':\n      logging.info(\'Compiling user program: this may take a while...\')\n      self._assertCompilationSucceeded(session.run(self._tpu_compile_op), coord)\n\n    self._infeed_controller = self._create_infeed_controller(\n        name=\'InfeedController\', target=self._run_infeed, args=(session,))\n\n    self._outfeed_controller = _OpQueueContext(\n        name=\'OutfeedController\', target=self._run_outfeed, args=(session,))\n\n    # Enable the worker watchdog to terminate workers on coordinator exit.\n    watchdog_timeout = int(os.environ.get(\'TF_TPU_WATCHDOG_TIMEOUT\', \'0\'))\n    if watchdog_timeout > 0:\n      session_support.start_worker_watchdog(session,\n                                            shutdown_timeout=watchdog_timeout)\n\n  def before_run(self, run_context):\n    self._feed_error = None\n\n    iterations = run_context.session.run(self._iterations_per_loop_var)\n\n    logging.info(\'Enqueue next (%d) batch(es) of data to infeed.\', iterations)\n    self._infeed_controller.send_next_batch_signal(iterations)\n\n    logging.info(\'Dequeue next (%d) batch(es) of data from outfeed.\',\n                 iterations)\n    self._outfeed_controller.send_next_batch_signal(iterations)\n\n  def end(self, session):\n    self._finished = True\n    logging.info(\'Stop infeed thread controller\')\n    self._infeed_controller.join()\n    self._rendezvous.record_done(\'infeed\')\n\n    logging.info(\'Stop output thread controller\')\n    self._outfeed_controller.join()\n    self._rendezvous.record_done(\'outfeed\')\n\n    logging.info(\'Shutdown TPU system.\')\n    session.run(self._finalize_ops)\n\n\nclass TPUInfeedOutfeedSessionHookForPrediction(TPUInfeedOutfeedSessionHook):\n\n  def __init__(self, ctx, enqueue_ops, dequeue_ops, tpu_compile_op,\n               rendezvous=None, master=None, session_config=None):\n    super(TPUInfeedOutfeedSessionHookForPrediction, self).__init__(\n        ctx,\n        enqueue_ops,\n        dequeue_ops,\n        tpu_compile_op=tpu_compile_op,\n        run_infeed_loop_on_coordinator=False,\n        rendezvous=rendezvous,\n        master=master,\n        session_config=session_config)\n\n  def _create_infeed_controller(self, name, target, args):\n    return _OpSignalOnceQueueContext(name=name, target=target, args=args)\n\n\nclass _TPUStopAtStepHook(session_run_hook.SessionRunHook):\n  """"""Hook that requests stop at a specified step.\n\n  This hook is similar to the `session_run_hook._StopAfterNEvalsHook` with\n  following differences for TPU training:\n\n  1. This hook sets the variable for iterations_per_loop, which is used by\n     `TPUInfeedOutfeedSessionHook` to control the iterations for infeed/outfeed.\n     As the hook execution order is not guaranteed, the variable update is\n     handled in `after_create_session` and `after_run` as\n     `TPUInfeedOutfeedSessionHook` reads the variable value in `before_run`.\n\n  2. For each training loop (session.run), the global step could be increased\n     multiple times on TPU. The global step tensor value will be explicitly read\n     again in `after_run` to ensure the latest value is retrieved to avoid race\n     condition.\n  """"""\n\n  def __init__(self, iterations, num_steps=None, last_step=None):\n    """"""Initializes a `StopAtStepHook`.\n\n    Args:\n      iterations: The number of iterations to run optimizer per training loop.\n      num_steps: Number of steps to execute.\n      last_step: Step after which to stop.\n\n    Raises:\n      ValueError: If one of the arguments is invalid.\n    """"""\n    if num_steps is None and last_step is None:\n      raise ValueError(\'One of num_steps or last_step must be specified.\')\n    if num_steps is not None and last_step is not None:\n      raise ValueError(\'Only one of num_steps or last_step can be specified.\')\n    self._num_steps = num_steps\n    self._last_step = last_step\n    self._iterations = iterations\n\n  def _next_iterations(self, global_step, last_step):\n    gap = last_step - global_step\n    return min(gap, self._iterations)\n\n  def begin(self):\n    self._global_step_tensor = training_util.get_global_step()\n    if self._global_step_tensor is None:\n      raise RuntimeError(\'Global step should be created.\')\n\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  def after_create_session(self, session, coord):\n    global_step = session.run(self._global_step_tensor)\n    if self._last_step is None:\n      self._last_step = global_step + self._num_steps\n\n    iterations = self._next_iterations(global_step, self._last_step)\n\n    self._iterations_per_loop_var.load(iterations, session=session)\n\n  def after_run(self, run_context, run_values):\n    # Global step cannot be retrieved via SessionRunArgs and before_run due to\n    # race condition.\n    global_step = run_context.session.run(self._global_step_tensor)\n    if global_step >= self._last_step:\n      run_context.request_stop()\n    else:\n      iterations = self._next_iterations(global_step, self._last_step)\n      self._iterations_per_loop_var.load(\n          iterations, session=run_context.session)\n\n\nclass _SetEvalIterationsHook(session_run_hook.SessionRunHook):\n  """"""Hook that requests stop at a specified step.""""""\n\n  def __init__(self, num_steps):\n    """"""Initializes a `_SetEvalIterationsHook`.\n\n    Args:\n      num_steps: Number of steps to execute.\n    """"""\n    self._num_steps = num_steps\n\n  def begin(self):\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  def after_create_session(self, session, coord):\n    self._iterations_per_loop_var.load(self._num_steps, session=session)\n\n\nclass _StoppingPredictHook(session_run_hook.SessionRunHook):\n  """"""Hook that requests stop according to the stopping signal in prediction.""""""\n\n  def __init__(self, scalar_stopping_signal):\n    self._scalar_stopping_signal = scalar_stopping_signal\n\n  def begin(self):\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  def after_create_session(self, session, coord):\n    # This is not necessary as we do not run infeed enqueue and outfeed dequeue\n    # in side threads for prediction model. But it makes the\n    # TPUInfeedOutfeedSessionHook prints nice message.\n    self._iterations_per_loop_var.load(1, session=session)\n\n  def before_run(self, run_context):\n    return session_run_hook.SessionRunArgs(self._scalar_stopping_signal)\n\n  def after_run(self, run_context, run_values):\n    _ = run_context\n    scalar_stopping_signal = run_values.results\n    if _StopSignals.should_stop(scalar_stopping_signal):\n      # NOTE(xiejw): In prediction, stopping signals are inserted for each\n      # batch. And we append one more batch to signal the system it should stop.\n      # The data flow might look like\n      #\n      #  batch   0: images, labels, stop = 0  (user provided)\n      #  batch   1: images, labels, stop = 0  (user provided)\n      #  ...\n      #  batch  99: images, labels, stop = 0  (user provided)\n      #  batch 100: images, labels, stop = 1  (TPUEstimator appended)\n      #\n      # where the final batch (id = 100) is appended by TPUEstimator, so we\n      # should drop it before returning the predictions to user.\n      # To achieve that, we throw the OutOfRangeError in after_run. Once\n      # Monitored Session sees this error in SessionRunHook.after_run, the\n      # ""current"" prediction, i.e., batch with id=100, will be discarded\n      # immediately\n      raise errors.OutOfRangeError(None, None, \'Stopped by stopping signal.\')\n\n\ndef generate_per_core_enqueue_ops_fn_for_host(\n    ctx, input_fn, inputs_structure_recorder, host_device, host_id):\n  """"""Generates infeed enqueue ops for per-core input_fn on a single host.""""""\n  captured_infeed_queue = _CapturedObject()\n  tpu_ordinal_function_impl = ctx.tpu_ordinal_function(host_id)\n\n  def enqueue_ops_fn():\n    """"""A fn returns enqueue_ops.""""""\n    num_cores_per_host = ctx.num_of_cores_per_host\n    per_host_sharded_inputs = []\n    for core_ordinal in range(num_cores_per_host):\n      with ops.name_scope(\'ordinal_%d\' % (core_ordinal)):\n        user_context = tpu_context.TPUContext(\n            internal_ctx=ctx,\n            input_device=host_device,\n            invocation_index=host_id * ctx.num_of_cores_per_host + core_ordinal)\n        inputs = _Inputs.from_input_fn(input_fn(user_context))\n        if inputs.is_dataset:\n          raise TypeError(\n              \'`input_fn` returning `Dataset`  is not yet supported in \'\n              \'per-Core input pipeline deployment yet. Please set \'\n              \'TPUConfig.per_host_input_for_training to True or return \'\n              \'`features` and `labels` from `input_fn`\')\n        features, labels = inputs.features_and_labels()\n\n        inputs_structure_recorder.validate_and_record_structure(\n            features, labels)\n        flattened_inputs = (\n            inputs_structure_recorder.flatten_features_and_labels(\n                features, labels))\n        per_host_sharded_inputs.append(flattened_inputs)\n\n    infeed_queue = tpu_feed.InfeedQueue(\n        number_of_tuple_elements=len(per_host_sharded_inputs[0]))\n    captured_infeed_queue.capture(infeed_queue)\n\n    per_host_enqueue_ops = infeed_queue.generate_enqueue_ops(\n        per_host_sharded_inputs, tpu_ordinal_function=tpu_ordinal_function_impl)\n    return per_host_enqueue_ops\n\n  return enqueue_ops_fn, captured_infeed_queue\n\n\ndef generate_per_host_enqueue_ops_fn_for_host(\n    ctx, input_fn, inputs_structure_recorder, batch_axis, device, host_id):\n  """"""Generates infeed enqueue ops for per-host input_fn on a single host.""""""\n  captured_infeed_queue = _CapturedObject()\n\n  dataset_initializer = None\n\n  with ops.device(device):\n    user_context = tpu_context.TPUContext(\n        internal_ctx=ctx, input_device=device, invocation_index=host_id)\n    inputs = _Inputs.from_input_fn(input_fn(user_context))\n\n    is_dataset = inputs.is_dataset\n    if ctx.mode == model_fn_lib.ModeKeys.PREDICT:\n      if not is_dataset:\n        raise TypeError(\n            \'For mode PREDICT, `input_fn` must return `Dataset` instead of \'\n            \'`features` and `labels`.\')\n      if batch_axis is not None:\n        raise TypeError(\'For mode PREDICT, batch_axis is not supported yet.\')\n      inputs = _InputsWithStoppingSignals(\n          dataset=inputs.dataset,\n          batch_size=ctx.batch_size_for_input_fn,\n          add_padding=True)\n\n    if is_dataset:\n      dataset_initializer = inputs.dataset_initializer()\n\n    tpu_ordinal_function_impl = ctx.tpu_ordinal_function(host_id)\n\n  def enqueue_ops_fn():\n    """"""A Fn returning the TPU infeed enqueue ops.\n\n    By providing as a Fn, it can be invoked inside the tf.while_loop such that\n    the input pipeline for multiple iterations can be executed by one\n    Session.run call.\n\n    Returns:\n      list of dict of ops.\n    """"""\n    with ops.device(device):\n      num_of_replicas_per_host = ctx.num_of_replicas_per_host\n      # Convert user input to features and labels.  If the user returns a\n      # dataset, it is initialized and the features and labels extracted via\n      # `dataset.iterator.get_next()`\n      features, labels = inputs.features_and_labels()\n      signals = inputs.signals()\n\n      inputs_structure_recorder.validate_and_record_structure(features, labels)\n      unsharded_tensor_list = (\n          inputs_structure_recorder.flatten_features_and_labels(\n              features, labels, signals))\n\n      infeed_queue = tpu_feed.InfeedQueue(\n          tuple_types=[t.dtype for t in unsharded_tensor_list],\n          tuple_shapes=[t.shape for t in unsharded_tensor_list],\n          shard_dimensions=batch_axis)\n      captured_infeed_queue.capture(infeed_queue)\n      infeed_queue.set_number_of_shards(num_of_replicas_per_host)\n      per_host_enqueue_ops = (\n          infeed_queue.split_inputs_and_generate_enqueue_ops(\n              unsharded_tensor_list,\n              placement_function=lambda x: device,\n              tpu_ordinal_function=tpu_ordinal_function_impl))\n      if signals is None:\n        return per_host_enqueue_ops\n      else:\n        return {\n            \'ops\': per_host_enqueue_ops,\n            \'signals\': signals,\n        }\n\n  return enqueue_ops_fn, captured_infeed_queue, dataset_initializer\n\n\ndef generate_per_host_v2_enqueue_ops_fn_for_host(\n    ctx, input_fn, inputs_structure_recorder, device, host_id):\n  """"""Generates infeed enqueue ops for per-host input_fn on a single host.""""""\n  captured_infeed_queue = _CapturedObject()\n  dataset_initializer = None\n\n  with ops.device(device):\n    user_context = tpu_context.TPUContext(\n        internal_ctx=ctx, input_device=device, invocation_index=host_id)\n    inputs = _Inputs.from_input_fn(input_fn(user_context))\n\n    is_dataset = inputs.is_dataset\n    if not is_dataset:\n      raise TypeError(\'`input_fn` must return a `Dataset` for the PER_HOST_V2 \'\n                      \'input pipeline configuration.\')\n\n    if ctx.mode == model_fn_lib.ModeKeys.PREDICT:\n      inputs = _InputsWithStoppingSignals(\n          dataset=inputs.dataset,\n          batch_size=ctx.batch_size_for_input_fn,\n          add_padding=True,\n          num_invocations_per_step=ctx.num_of_replicas_per_host)\n\n    dataset_initializer = inputs.dataset_initializer()\n    tpu_ordinal_function_impl = ctx.tpu_ordinal_function(host_id)\n\n  def enqueue_ops_fn():\n    """"""Generates the per_host enqueue ops.""""""\n    control_deps = []\n    per_host_sharded_inputs = []\n    num_replicas_per_host = ctx.num_of_replicas_per_host\n    cached_signals = None\n    with ops.device(device):\n      if not inputs.is_dataset:\n        raise TypeError(\'`input_fn` must return a `Dataset` for this mode.\')\n      for _ in range(num_replicas_per_host):\n        # Use control dependencies to ensure a deterministic ordering.\n        with ops.control_dependencies(control_deps):\n          features, labels = inputs.features_and_labels()  # Calls get_next()\n          signals = inputs.signals()\n\n          # All the replicas share the replica 0\'s stopping singal.\n          # This avoids inconsistent state among different model replcias.\n          if cached_signals:\n            signals[\'stopping\'] = cached_signals[\'stopping\']\n          else:\n            cached_signals = signals\n\n        inputs_structure_recorder.validate_and_record_structure(\n            features, labels)\n        flattened_inputs = (\n            inputs_structure_recorder.flatten_features_and_labels(\n                features, labels, signals))\n        control_deps.extend(flattened_inputs)\n        per_host_sharded_inputs.append(flattened_inputs)\n\n      if inputs_structure_recorder.flattened_input_dims:\n        input_partition_dims = inputs_structure_recorder.flattened_input_dims\n        if signals:\n          input_partition_dims += [None] * len(signals)\n        # pylint: disable=protected-access\n        infeed_queue = tpu_feed._PartitionedInfeedQueue(\n            number_of_tuple_elements=len(per_host_sharded_inputs[0]),\n            host_id=host_id,\n            input_partition_dims=input_partition_dims,\n            device_assignment=ctx.device_assignment)\n        per_host_enqueue_ops = infeed_queue.generate_enqueue_ops(\n            per_host_sharded_inputs)\n      else:\n        infeed_queue = tpu_feed.InfeedQueue(\n            number_of_tuple_elements=len(per_host_sharded_inputs[0]))\n        per_host_enqueue_ops = infeed_queue.generate_enqueue_ops(\n            per_host_sharded_inputs,\n            tpu_ordinal_function=tpu_ordinal_function_impl)\n      captured_infeed_queue.capture(infeed_queue)\n\n    if signals is None:\n      return per_host_enqueue_ops\n    else:\n      return {\n          \'ops\': per_host_enqueue_ops,\n          \'signals\': signals,\n      }\n\n  return enqueue_ops_fn, captured_infeed_queue, dataset_initializer\n\n\ndef generate_broadcast_enqueue_ops_fn(ctx, input_fn, inputs_structure_recorder,\n                                      num_hosts):\n  """"""Generates infeed enqueue ops for one input_fn on all the hosts.""""""\n  captured_infeed_queue = _CapturedObject()\n  dataset_initializer = None\n  device_0 = ctx.tpu_host_placement_function(host_id=0)\n  with ops.device(device_0):\n    user_context = tpu_context.TPUContext(\n        internal_ctx=ctx, input_device=device_0, invocation_index=0)\n    inputs = _Inputs.from_input_fn(input_fn(user_context))\n\n    is_dataset = inputs.is_dataset\n    if ctx.mode == model_fn_lib.ModeKeys.PREDICT:\n      if not is_dataset:\n        raise TypeError(\n            \'For mode PREDICT, `input_fn` must return `Dataset` instead of \'\n            \'`features` and `labels`.\')\n\n      inputs = _InputsWithStoppingSignals(\n          dataset=inputs.dataset,\n          batch_size=ctx.batch_size_for_input_fn,\n          add_padding=True)\n\n    if is_dataset:\n      dataset_initializer = inputs.dataset_initializer()\n    num_replicas_per_host = ctx.num_of_replicas_per_host\n\n  def tpu_ordinal_function_impl(replica_id):\n    if ctx.device_assignment:\n      return ctx.device_assignment.tpu_ordinal(replica=replica_id)\n    else:\n      return replica_id % num_replicas_per_host\n\n  def device_function_impl(replica_id):\n    return ctx.tpu_host_placement_function(replica_id=replica_id)\n\n  def enqueue_ops_fn():\n    """"""Generates enqueue ops for all the hosts.""""""\n    broadcasted_inputs = []\n    flattened_inputs = None  # Cache result from input_fn.\n    signals = None\n    for host_id in xrange(num_hosts):\n      with ops.device(ctx.tpu_host_placement_function(host_id=host_id)):\n        for _ in xrange(ctx.num_of_replicas_per_host):\n          # Note: input_fn is only called once at host 0 for the first replica.\n          # The features and labels returned from that invocation are\n          # broadcasted to other replicas(including the replicas on other\n          # hosts).\n          if flattened_inputs is None:\n            features, labels = inputs.features_and_labels()  # Calls get_next()\n            signals = inputs.signals()\n\n            inputs_structure_recorder.validate_and_record_structure(\n                features, labels)\n            flattened_inputs = (\n                inputs_structure_recorder.flatten_features_and_labels(\n                    features, labels, signals))\n          broadcasted_inputs.append(flattened_inputs)\n\n    infeed_queue = tpu_feed.InfeedQueue(\n        number_of_tuple_elements=len(broadcasted_inputs[0]))\n    captured_infeed_queue.capture(infeed_queue)\n    enqueue_ops = infeed_queue.generate_enqueue_ops(\n        broadcasted_inputs,\n        tpu_ordinal_function=tpu_ordinal_function_impl,\n        placement_function=device_function_impl)\n\n    if signals is None:\n      return enqueue_ops\n    else:\n      return {\n          \'ops\': enqueue_ops,\n          \'signals\': signals,\n      }\n\n  return enqueue_ops_fn, captured_infeed_queue, dataset_initializer\n\n\nclass _InputPipeline(object):\n  """"""`_InputPipeline` handles invoking `input_fn` and piping to infeed queue.\n\n  `_InputPipeline` abstracts the per-core/per-host `input_fn` invocation from\n  call site.  To be precise, based on the configuration in\n  `_InternalTPUContext`,  it invokes `input_fn` for all cores (usually\n  multi-host TPU training) or for one host (usually for single-host TPU\n  evaluation), and sends all `features` and `labels` returned by `input_fn` to\n  TPU infeed. For per-core invocation, `features` and `labels` are piped to\n  infeed directly, one tuple for each core. For per-host invocation,  `features`\n  and `labels` are split at host (with respect to `batch_axis`) and piped to all\n  cores accordingly.\n\n  In addition, flatten/unflatten are handled by `_InputPipeline` also.  Model\n  inputs returned by the `input_fn` can have one of the following forms:\n  1. features\n  2. (features, labels)\n  3. ((arbitrarily nested structure of features), labels)\n\n  Internally, form 1 is reformed to `(features, None)` as features and labels\n  are passed separately to underlying methods. For TPU training, TPUEstimator\n  may expect multiple `features` and `labels` tuples one for each core.\n\n  TPUEstimator allows various different structures for inputs (namely `features`\n  and `labels`).  Both `features` and `labels` can be any nested sturcture\n  supported by TF nest (namely, dict, tuples, namedtuples or any nested\n  structure of such of Tensors).  `labels` could be `None` as well.\n\n  These are flattened before they are passed to the infeed/outfeed library\n  as that expectes flattend lists.\n  """"""\n\n  class InputsStructureRecorder(object):\n    """"""The recorder to record inputs structure.""""""\n\n    def __init__(self, input_partition_dims=None):\n      # Holds the structure of inputs\n      self._feature_structure = {}\n      self._flattened_input_dims = None\n\n      if input_partition_dims:\n        # This should have been validated in TPUConfig.\n        assert len(input_partition_dims) <= 2, \'must have 1 or 2 elements.\'\n        if len(input_partition_dims) == 2:\n          self._feature_dims, self._label_dims = input_partition_dims\n        else:\n          self._feature_dims = input_partition_dims[0]\n          self._label_dims = None\n\n        assert self._feature_dims is not None, (\'input_partition_dims[0] must \'\n                                                \'not be None\')\n      else:\n        self._feature_dims = None\n        self._label_dims = None\n\n      # Internal state.\n      self._initialized = False\n\n    @property\n    def flattened_input_dims(self):\n      assert self._initialized, \'InputsStructureRecorder is not initialized.\'\n      return self._flattened_input_dims\n\n    def has_labels(self):\n      return \'labels\' in self._feature_structure\n\n    def _flatten_input_dims(self, feature_dims, feature_dims_names, label_dims,\n                            label_dims_names, label_names, has_labels):\n      """"""Flatten input dims with the same order as flattened input tensors.""""""\n      flattened_input_dims = []\n      if feature_dims_names:\n        # We need a fixed ordering for matching the tensors in features.\n        flattened_input_dims.extend(\n            [feature_dims[name] for name in feature_dims_names])\n      else:\n        flattened_input_dims.append(feature_dims)\n\n      if label_dims_names:\n        # We need a fixed ordering for matching the tensors in labels.\n        flattened_input_dims.extend(\n            [label_dims[name] for name in label_dims_names])\n      else:\n        if label_names:\n          num_tensors_in_label = len(label_names)\n        else:\n          num_tensors_in_label = int(has_labels)\n        # Setting `None` in input_partition_dims[1] will apply `None` to\n        # all the tensors in labels, regardless of internal structure.\n        flattened_input_dims.extend([label_dims] * num_tensors_in_label)\n\n      return flattened_input_dims\n\n    def validate_and_record_structure(self, features, labels):\n      """"""Validates and records the structure of `features` and `labels`.""""""\n      # Extract structure.\n      has_labels = labels is not None\n      feature_names = _extract_key_names(features)\n      label_names = _extract_key_names(labels)\n\n      if not self._initialized:\n        # Record structure.\n        self._initialized = True\n        if self._feature_dims is not None:\n          feature_dims_names = _extract_key_names(self._feature_dims)\n          if feature_dims_names != feature_names:\n            raise ValueError(\n                \'TPUConfig.input_partition_dims[0] mismatched feature\'\n                \' keys. Expected {}, got {}\'.format(feature_names,\n                                                    feature_dims_names))\n\n          label_dims_names = _extract_key_names(self._label_dims)\n          if self._label_dims is not None and label_dims_names != label_names:\n            raise ValueError(\n                \'TPUConfig.input_partition_dims[1] mismatched label\'\n                \' keys. Expected {}, got {}\'.format(label_names,\n                                                    label_dims_names))\n\n          self._flattened_input_dims = self._flatten_input_dims(\n              self._feature_dims, feature_dims_names, self._label_dims,\n              label_dims_names, label_names, has_labels)\n\n    def flatten_features_and_labels(self, features, labels, signals=None):\n      """"""Flattens the `features` and `labels` to a single tensor list.""""""\n      self._feature_structure[\'features\'] = features\n      if labels is not None:\n        self._feature_structure[\'labels\'] = labels\n      if signals is not None:\n        self._feature_structure[\'signals\'] = signals\n      return data_nest.flatten(self._feature_structure)\n\n    def unflatten_features_and_labels(self, flattened_inputs):\n      """"""Restores the flattened inputs to original features and labels form.\n\n      Args:\n        flattened_inputs: Flattened inputs for each shard.\n\n      Returns:\n        A tuple of (`features`, `labels`), where `labels` could be None.\n        Each one, if present, should have identical structure (single tensor vs\n        dict) as the one returned by input_fn.\n\n      Raises:\n        ValueError: If the number of expected tensors from `flattened_inputs`\n          mismatches the recorded structure.\n      """"""\n\n      unflattened_inputs = data_nest.pack_sequence_as(self._feature_structure,\n                                                      flattened_inputs)\n      return _Inputs(\n          unflattened_inputs[\'features\'],\n          unflattened_inputs.get(\'labels\'),\n          signals=unflattened_inputs.get(\'signals\'))\n\n  def __init__(self, input_fn, batch_axis, ctx):\n    """"""Constructor.\n\n    Args:\n      input_fn: input fn for train or eval.\n      batch_axis: A python tuple of int values describing how each tensor\n        produced by the Estimator `input_fn` should be split across the TPU\n        compute shards.\n      ctx: A `_InternalTPUContext` instance with mode.\n\n    Raises:\n      ValueError: If both `sharded_features` and `num_cores` are `None`.\n    """"""\n    self._inputs_structure_recorder = _InputPipeline.InputsStructureRecorder(\n        ctx.input_partition_dims)\n\n    self._sharded_per_core = ctx.is_input_sharded_per_core()\n    self._input_fn = input_fn\n    self._infeed_queue = None\n    self._ctx = ctx\n    self._batch_axis = batch_axis\n\n  def generate_infeed_enqueue_ops_and_dequeue_fn(self):\n    """"""Generates infeed enqueue ops and dequeue_fn.""""""\n    # While tf.while_loop is called, the body function, which invokes\n    # `enqueue_fn` passed in, is called to construct the graph. So, input_fn\n    # structure is recorded.\n    enqueue_ops, all_hooks, run_infeed_loop_on_coordinator = (\n        self._invoke_input_fn_and_record_structure())\n\n    self._validate_input_pipeline()\n\n    def dequeue_fn():\n      """"""dequeue_fn is used by TPU to retrieve the tensors.""""""\n      # In the model-parallel case, both the host-side and device-side\n      # computations must agree on the core on which infeed takes place. We\n      # choose to perform infeed on logical core 0 of each replica.\n      values = self._infeed_queue.generate_dequeue_op(tpu_device=0)\n      # The unflatten process uses the structure information recorded above.\n      return self._inputs_structure_recorder.unflatten_features_and_labels(\n          values)\n\n    return (enqueue_ops, dequeue_fn, all_hooks, run_infeed_loop_on_coordinator)\n\n  def _invoke_input_fn_and_record_structure(self):\n    """"""Deploys the input pipeline and record input structure.""""""\n    enqueue_ops = []\n    infeed_queues = []\n    all_dataset_initializers = []\n    num_hosts = self._ctx.num_hosts\n    tpu_host_placement_fn = self._ctx.tpu_host_placement_function\n\n    run_infeed_loop_on_coordinator = True\n\n    if self._sharded_per_core:\n      # Per-Core input pipeline deployment.\n      # Invoke input pipeline for each core and placed on the corresponding\n      # host.\n      for host_id in range(num_hosts):\n        host_device = tpu_host_placement_fn(host_id=host_id)\n        with ops.device(host_device):\n          with ops.name_scope(\'input_pipeline_task%d\' % (host_id)):\n            enqueue_ops_fn, captured_infeed_queue = (\n                generate_per_core_enqueue_ops_fn_for_host(\n                    self._ctx, self._input_fn, self._inputs_structure_recorder,\n                    host_device, host_id))\n\n            if _WRAP_INPUT_FN_INTO_WHILE_LOOP:\n              run_infeed_loop_on_coordinator = False\n              enqueue_ops.append(\n                  _wrap_computation_in_while_loop(\n                      device=host_device, op_fn=enqueue_ops_fn))\n            else:\n              enqueue_ops.append(enqueue_ops_fn())\n            # Infeed_queue_getter must be called after enqueue_ops_fn is called.\n            infeed_queues.append(captured_infeed_queue.get())\n\n    elif self._ctx.is_input_broadcast_with_iterators():\n      # Only calls input_fn in host 0.\n      host_device = tpu_host_placement_fn(host_id=0)\n      enqueue_ops_fn, captured_infeed_queue, dataset_initializer = (\n          generate_broadcast_enqueue_ops_fn(self._ctx, self._input_fn,\n                                            self._inputs_structure_recorder,\n                                            num_hosts))\n      if dataset_initializer:\n        all_dataset_initializers.append(dataset_initializer)\n        run_infeed_loop_on_coordinator = False\n        wrap_fn = (\n            _wrap_computation_in_while_loop\n            if self._ctx.mode != model_fn_lib.ModeKeys.PREDICT else\n            _wrap_computation_in_while_loop_with_stopping_signals)\n        enqueue_ops.append(wrap_fn(device=host_device, op_fn=enqueue_ops_fn))\n      else:\n        enqueue_ops.append(enqueue_ops_fn())\n      infeed_queues.append(captured_infeed_queue.get())\n    else:\n      for host_id in range(num_hosts):\n        host_device = tpu_host_placement_fn(host_id=host_id)\n        with ops.device(host_device):\n          with ops.name_scope(\'input_pipeline_task%d\' % (host_id)):\n            if self._ctx.is_input_per_host_with_iterators():\n              enqueue_ops_fn, captured_infeed_queue, dataset_initializer = (\n                  generate_per_host_v2_enqueue_ops_fn_for_host(\n                      self._ctx, self._input_fn,\n                      self._inputs_structure_recorder, host_device, host_id))\n            else:\n              enqueue_ops_fn, captured_infeed_queue, dataset_initializer = (\n                  generate_per_host_enqueue_ops_fn_for_host(\n                      self._ctx, self._input_fn,\n                      self._inputs_structure_recorder, self._batch_axis,\n                      host_device, host_id))\n\n            # NOTE(xiejw): We dispatch here based on the return type of the\n            # users `input_fn`.\n            #\n            # 1. If input_fn returns a Dataset instance, we initialize the\n            # iterator outside of tf.while_loop, and call the iterator.get_next\n            # inside tf.while_loop.  This should be always safe.\n            #\n            # 2. If input_fn returns (features, labels), it is too late to wrap\n            # them inside tf.while_loop, as resource initialization cannot be\n            # handled in TF control flow properly. In this case, we will use\n            # python loop to enqueue the data into TPU system.  This may be\n            # slow compared to the previous case.\n            if dataset_initializer:\n              all_dataset_initializers.append(dataset_initializer)\n              run_infeed_loop_on_coordinator = False\n              wrap_fn = (\n                  _wrap_computation_in_while_loop\n                  if self._ctx.mode != model_fn_lib.ModeKeys.PREDICT else\n                  _wrap_computation_in_while_loop_with_stopping_signals)\n              enqueue_ops.append(\n                  wrap_fn(device=host_device, op_fn=enqueue_ops_fn))\n            else:\n              enqueue_ops.append(enqueue_ops_fn())\n            infeed_queues.append(captured_infeed_queue.get())\n    # infeed_queue is used to generate dequeue ops. The only thing it uses for\n    # dequeue is dtypes and types. So, any one can be used. Here, grab the\n    # first one.\n    self._infeed_queue = infeed_queues[0]\n    return enqueue_ops, [\n        util_lib.MultiHostDatasetInitializerHook(all_dataset_initializers)\n    ], run_infeed_loop_on_coordinator\n\n  def _validate_input_pipeline(self):\n    """"""Validates the input pipeline.\n\n    Perform some sanity checks to log user friendly information. We should\n    error out to give users better error message. But, if\n    _WRAP_INPUT_FN_INTO_WHILE_LOOP is False (legacy behavior), we cannot break\n    user code, so, log a warning.\n\n    Raises:\n      RuntimeError: If the validation failed.\n    """"""\n    if ops.get_default_graph().get_collection(ops.GraphKeys.QUEUE_RUNNERS):\n      err_msg = (\'Input pipeline contains one or more QueueRunners. \'\n                 \'It could be slow and not scalable. Please consider \'\n                 \'converting your input pipeline to use `tf.data` instead (see \'\n                 \'https://www.tensorflow.org/guide/datasets for \'\n                 \'instructions.\')\n      if _WRAP_INPUT_FN_INTO_WHILE_LOOP:\n        raise RuntimeError(err_msg)\n      else:\n        logging.warn(err_msg)\n\n\nclass _ModelFnWrapper(object):\n  """"""A `model_fn` wrapper.\n\n  This makes calling model_fn on CPU and TPU easier and more consistent and\n  performs necessary check and mutation required by TPU training and evaluation.\n\n  In addition, this wrapper manages converting the `model_fn` to a single TPU\n  train and eval step.\n  """"""\n\n  def __init__(self, model_fn, train_cache_fn, eval_cache_fn, config, params, ctx):\n    self._model_fn = model_fn\n    self._train_cache_fn = train_cache_fn\n    self._eval_cache_fn = eval_cache_fn\n    self._config = config\n    self._params = params\n    self._ctx = ctx\n\n  def call_without_tpu(self, features, labels, is_export_mode):\n    return self._call_model_fn(features, labels, is_export_mode=is_export_mode)\n\n  def convert_to_single_tpu_train_step(self, dequeue_fn):\n    """"""Converts user provided model_fn` as a single train step on TPU.\n\n    The user provided `model_fn` takes input tuple\n    (features, labels) and produces the EstimatorSpec with train_op and loss for\n    train `mode`. This usually represents a single train computation on CPU.\n\n    For TPU training, a train (computation) step is first wrapped in a\n    tf.while_loop control flow to repeat for many times and then replicated to\n    all TPU shards. Besides the input should be taken from TPU infeed rather\n    than input pipeline (input_fn) directly. To fit TPU loop and replicate\n    pattern, the original train computation should be reformed, which is the\n    returned `train_step`.\n\n    Args:\n      dequeue_fn: The function to retrieve inputs, features and labels, from TPU\n        infeed dequeue channel.\n\n    Returns:\n      A tuple of train_fn, host_calls, and captured scaffold_fn. The train_fn\n      representing the train step for TPU.\n    """"""\n\n    host_call = _OutfeedHostCall(self._ctx)\n    captured_scaffold_fn = _CapturedObject()\n    captured_training_hooks = _CapturedObject()\n\n    def train_step(loss, *cache):\n      """"""Training step function for use inside a while loop.""""""\n      del loss  # unused; required in function signature.\n      inputs = dequeue_fn()\n      features, labels = inputs.features_and_labels()\n\n      # Consume the current cache\n      estimator_spec = self._verify_estimator_spec(\n          self._call_model_fn(features, labels, cache=cache))\n\n      # Retrieve the new returned cache\n      """"""\n        `cache` consists of a list of tensors, potentially empty (of length 0)\n      """"""\n      cache = estimator_spec.cache\n      loss, train_op = estimator_spec.loss, estimator_spec.train_op\n\n      if isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n        captured_scaffold_fn.capture(estimator_spec.scaffold_fn)\n      else:\n        captured_scaffold_fn.capture(None)\n\n      captured_training_hooks.capture(estimator_spec.training_hooks)\n\n      tracing_ops = []\n      if tensor_tracer.TensorTracer.is_enabled():\n        tt = tensor_tracer.TensorTracer()\n        loss, tracing_ops = tt.trace_tpu(ops.get_default_graph(), loss,\n                                         self._ctx.num_replicas)\n\n      # We must run train_op to update the variables prior to running the\n      # outfeed.\n      with ops.control_dependencies([train_op]+tracing_ops):\n        host_call_outfeed_ops = []\n        if (isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec)  # pylint: disable=protected-access\n            and estimator_spec.host_call is not None):\n          host_call.record({\'host_call\': estimator_spec.host_call})\n          host_call_outfeed_ops = host_call.create_enqueue_op()\n        with ops.control_dependencies(host_call_outfeed_ops):\n          return [array_ops.identity(loss)] + cache\n\n    return (train_step, host_call, captured_scaffold_fn,\n            captured_training_hooks)\n\n  def convert_to_single_tpu_eval_step(self, dequeue_fn):\n    """"""Converts user provided model_fn` as a single eval step on TPU.\n\n    Similar to training, the user provided `model_fn` takes input tuple\n    (features, labels) and produces the TPUEstimatorSpec with eval_metrics for\n    eval `mode`. This usually represents a single evaluation computation on CPU.\n\n    For TPU evaluation, a eval (computation) step is first wrapped in a\n    tf.while_loop control flow to repeat for many times and then replicated to\n    all TPU shards. Besides the input and output are slightly different. Input,\n    features and labels, should be taken from TPU infeed rather than input\n    pipeline (input_fn) directly. Output is managed in two stages.  First, the\n    model outputs as the result of evaluation computation, usually model logits,\n    should be transferred from TPU system to CPU. Then, all model outputs are\n    concatenated first on CPU and sent to the metric_fn for metrics computation.\n    To fit TPU evaluation pattern, the original eval computation should be\n    reformed, which is the returned `eval_step`.\n\n    Args:\n      dequeue_fn: The function to retrieve inputs, features and labels, from TPU\n        infeed dequeue channel.\n\n    Returns:\n      A tuple of eval_fn, host_calls, and captured scaffold_fn. The eval_fn\n      representing the eval step for TPU.\n    """"""\n    host_calls = _OutfeedHostCall(self._ctx)\n    captured_scaffold_fn = _CapturedObject()\n    captured_eval_hooks = _CapturedObject()\n\n    def eval_step(total_loss, *cache):\n      """"""Evaluation step function for use inside a while loop.""""""\n      inputs = dequeue_fn()\n      features, labels = inputs.features_and_labels()\n\n      # Consume the current cache\n      tpu_estimator_spec = self._call_model_fn(features, labels, cache=cache)\n      if not isinstance(tpu_estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n        raise RuntimeError(\n            \'estimator_spec used by TPU evaluation must have type\'\n            \'`TPUEstimatorSpec`. Got {}\'.format(type(tpu_estimator_spec)))\n\n      # Retrieve the new returned cache\n      cache = tpu_estimator_spec.cache\n      loss = tpu_estimator_spec.loss\n\n      captured_scaffold_fn.capture(tpu_estimator_spec.scaffold_fn)\n      captured_eval_hooks.capture(tpu_estimator_spec.evaluation_hooks)\n\n      to_record = {}\n      if tpu_estimator_spec.eval_metrics:\n        to_record[\'eval_metrics\'] = tpu_estimator_spec.eval_metrics\n      if tpu_estimator_spec.host_call is not None:\n        # We assume that evaluate won\'t update global step, so we don\'t wrap\n        # this host_call.\n        to_record[\'host_call\'] = tpu_estimator_spec.host_call\n      host_calls.record(to_record)\n\n      with ops.control_dependencies(host_calls.create_enqueue_op()):\n        return [math_ops.add(total_loss, loss)] + cache\n\n    return eval_step, host_calls, captured_scaffold_fn, captured_eval_hooks\n\n  def convert_to_single_tpu_predict_step(self, dequeue_fn):\n    """"""Converts user provided model_fn` as a single predict step on TPU.\n\n    Args:\n      dequeue_fn: The function to retrieve inputs, features and labels, from TPU\n        infeed dequeue channel.\n\n    Returns:\n      A tuple of predict_fn, host_calls, and captured scaffold_fn. The\n      predict_fn representing the predict step for TPU.\n    """"""\n    host_calls = _OutfeedHostCall(self._ctx)\n    captured_scaffold_fn = _CapturedObject()\n    captured_predict_hooks = _CapturedObject()\n\n    def predict_step(unused_scalar_stopping_signal):\n      """"""Evaluation step function for use inside a while loop.""""""\n      inputs = dequeue_fn()\n      features, labels = inputs.features_and_labels()\n      stopping_signals = inputs.signals()\n\n      assert stopping_signals is not None, (\n          \'Internal Error: `signals` is missing.\')\n\n      tpu_estimator_spec = self._call_model_fn(\n          features, labels, is_export_mode=False)\n      if not isinstance(tpu_estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n        raise RuntimeError(\n            \'estimator_spec used by TPU prediction must have type\'\n            \'`TPUEstimatorSpec`. Got {}\'.format(type(tpu_estimator_spec)))\n\n      self._verify_tpu_spec_predictions(tpu_estimator_spec.predictions)\n\n      captured_scaffold_fn.capture(tpu_estimator_spec.scaffold_fn)\n      captured_predict_hooks.capture(tpu_estimator_spec.prediction_hooks)\n      to_record = {}\n      identity_fn = lambda **kwargs: kwargs\n      to_record[\'predictions\'] = [identity_fn, tpu_estimator_spec.predictions]\n      to_record[\'signals\'] = [identity_fn, stopping_signals]\n      if tpu_estimator_spec.host_call is not None:\n        to_record[\'host_call\'] = tpu_estimator_spec.host_call\n      host_calls.record(to_record)\n\n      with ops.control_dependencies(host_calls.create_enqueue_op()):\n        return _StopSignals.as_scalar_stopping_signal(stopping_signals)\n\n    return (predict_step, host_calls, captured_scaffold_fn,\n            captured_predict_hooks)\n\n  def _verify_tpu_spec_predictions(self, predictions):\n    """"""Validates TPUEstimatorSpec.predictions dict.""""""\n    # TODO(xiejw): Adds validation for prediction dictionrary.\n    # TODO(xiejw): Adds support for single tensor as predictions.\n    if not isinstance(predictions, dict):\n      raise TypeError(\'TPUEstimatorSpec.predictions must be dict of Tensors.\')\n\n    for (key, tensor) in predictions.items():\n      if tensor.shape.dims[0].value is None:\n        raise ValueError(\n            \'The tensor with key ({}) in TPUEstimatorSpec.predictions has \'\n            \'dynamic shape (should be static). Tensor: {}\'.format(key, tensor))\n    return predictions\n\n  def _validate_model_features_and_labels(self, features, labels,\n                                          is_export_mode):\n    """"""Validates that the features and labels for the model function are valid.\n\n    A valid features/labels object is the one with:\n    - Type: A tensor or any nested structure of tensors supported by TF nest,\n        namely nested dictionary, tuple, namedtuple, or sequence of tensors.\n    - Static shape if is_export_mode is False.\n\n    Args:\n      features: the features that would be input to the model function.\n      labels: the labels that would be input to the model function.\n      is_export_mode: boolean value specifying if in export mode.\n\n    Raises:\n      TypeError: If features/labels are not of the correct type.\n      ValueError: If features/labels have dynamic shape.\n    """"""\n\n    def validate(obj, obj_name):\n      """"""Helper validate function.""""""\n      if is_export_mode or self._ctx.is_running_on_cpu(is_export_mode):\n        return\n      if isinstance(obj, ops.Tensor):\n        if not obj.get_shape().is_fully_defined():\n          raise ValueError(\n              \'The {} to the model returned by input_fn must have static shape.\'\n              \' Tensor: {}\'.format(obj_name, obj))\n      else:\n        for tensor in data_nest.flatten(obj):\n          if not tensor.get_shape().is_fully_defined():\n            raise ValueError(\n                (\'The {} to the model returned by input_fn must have static \'\n                 \'shape. Tensor: {}\').format(obj_name, tensor))\n\n    validate(features, \'features\')\n    if labels is not None:\n      validate(labels, \'labels\')\n\n  def _call_model_fn(self, features, labels, cache=None, is_export_mode=False):\n    """"""Calls the model_fn with required parameters.""""""\n    self._validate_model_features_and_labels(features, labels, is_export_mode)\n    model_fn_args = function_utils.fn_args(self._model_fn)\n    kwargs = {}\n\n    # Makes deep copy with `config` and params` in case user mutates them.\n    config = copy.deepcopy(self._config)\n    params = copy.deepcopy(self._params)\n\n    if \'labels\' in model_fn_args:\n      kwargs[\'labels\'] = labels\n    elif labels is not None:\n      raise ValueError(\n          \'model_fn does not take labels, but input_fn returns labels.\')\n    if \'mode\' in model_fn_args:\n      kwargs[\'mode\'] = self._ctx.mode\n    if \'config\' in model_fn_args:\n      kwargs[\'config\'] = config\n    if \'params\' in model_fn_args:\n      kwargs[\'params\'] = params\n\n    if cache is not None:\n      params[\'cache\'] = cache\n\n    if \'params\' not in model_fn_args:\n      raise ValueError(\'model_fn ({}) does not include params argument, \'\n                       \'required by TPUEstimator to pass batch size as \'\n                       \'params[\\\'batch_size\\\']\'.format(self._model_fn))\n\n    if is_export_mode:\n      batch_size_for_model_fn = None\n    else:\n      batch_size_for_model_fn = self._ctx.batch_size_for_model_fn\n\n    if batch_size_for_model_fn is not None:\n      _add_item_to_params(params, _BATCH_SIZE_KEY, batch_size_for_model_fn)\n\n    running_on_cpu = self._ctx.is_running_on_cpu(is_export_mode)\n    _add_item_to_params(params, _USE_TPU_KEY, not running_on_cpu)\n\n    if not running_on_cpu:\n      user_context = tpu_context.TPUContext(\n          internal_ctx=self._ctx, call_from_input_fn=False)\n      _add_item_to_params(params, _CTX_KEY, user_context)\n\n    estimator_spec = self._model_fn(features=features, **kwargs)\n    if (running_on_cpu and\n        isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec)):  # pylint: disable=protected-access\n      # The estimator_spec will be passed to `Estimator` directly, which expects\n      # type `EstimatorSpec`.\n      return estimator_spec.as_estimator_spec()\n    else:\n      return estimator_spec\n\n  def _verify_estimator_spec(self, estimator_spec):\n    """"""Validates the estimator_spec.""""""\n    if isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n      return estimator_spec\n\n    err_msg = \'{} returned by EstimatorSpec is not supported in TPUEstimator.\'\n    if estimator_spec.training_chief_hooks:\n      raise ValueError(\n          err_msg.format(\'training_chief_hooks\') + \'If you want\' +\n          \' to pass training hooks, please pass via training_hooks.\')\n\n    if estimator_spec.scaffold:\n      logging.warning(\'EstimatorSpec.Scaffold is ignored by TPU train/eval. \'\n                      \'Please use TPUEstimatorSpec.\')\n    return estimator_spec\n\n\nclass _OutfeedHostCall(object):\n  """"""Support for `eval_metrics` and `host_call` in TPUEstimatorSpec.""""""\n\n  def __init__(self, ctx):\n    self._ctx = ctx\n    self._names = []\n    # All of these are dictionaries of lists keyed on the name.\n    self._host_fns = {}\n    self._tensor_keys = collections.defaultdict(list)\n    self._tensors = collections.defaultdict(list)\n    self._tensor_dtypes = collections.defaultdict(list)\n    self._tensor_shapes = collections.defaultdict(list)\n\n  @staticmethod\n  def validate(host_calls):\n    """"""Validates the `eval_metrics` and `host_call` in `TPUEstimatorSpec`.""""""\n\n    for name, host_call in host_calls.items():\n      if not isinstance(host_call, (tuple, list)):\n        raise ValueError(\'{} should be tuple or list\'.format(name))\n      if len(host_call) != 2:\n        raise ValueError(\'{} should have two elements.\'.format(name))\n      if not callable(host_call[0]):\n        raise TypeError(\'{}[0] should be callable.\'.format(name))\n      if not isinstance(host_call[1], (tuple, list, dict)):\n        raise ValueError(\'{}[1] should be tuple or list, or dict.\'.format(name))\n\n      if isinstance(host_call[1], (tuple, list)):\n        fullargspec = tf_inspect.getfullargspec(host_call[0])\n        fn_args = function_utils.fn_args(host_call[0])\n        # wrapped_hostcall_with_global_step uses varargs, so we allow that.\n        if fullargspec.varargs is None and len(host_call[1]) != len(fn_args):\n          raise RuntimeError(\n              \'In TPUEstimatorSpec.{}, length of tensors {} does not match \'\n              \'method args of the function, which takes {}.\'.format(\n                  name, len(host_call[1]), len(fn_args)))\n\n  @staticmethod\n  def create_cpu_hostcall(host_calls):\n    """"""Runs on the host_call on CPU instead of TPU when use_tpu=False.""""""\n\n    _OutfeedHostCall.validate(host_calls)\n    ret = {}\n    for name, host_call in host_calls.items():\n      host_fn, tensors = host_call\n      if isinstance(tensors, (tuple, list)):\n        ret[name] = host_fn(*tensors)\n      else:\n        # Must be dict.\n        try:\n          ret[name] = host_fn(**tensors)\n        except TypeError as e:\n          logging.warning(\n              \'Exception while calling %s: %s. It is likely the tensors \'\n              \'(%s[1]) do not match the \'\n              \'function\\\'s arguments\', name, e, name)\n          raise e\n    return ret\n\n  def record(self, host_calls):\n    """"""Records the host_call structure.""""""\n\n    for name, host_call in host_calls.items():\n      host_fn, tensor_list_or_dict = host_call\n      self._names.append(name)\n      self._host_fns[name] = host_fn\n\n      if isinstance(tensor_list_or_dict, dict):\n        for (key, tensor) in six.iteritems(tensor_list_or_dict):\n          self._tensor_keys[name].append(key)\n          self._tensors[name].append(tensor)\n          self._tensor_dtypes[name].append(tensor.dtype)\n          self._tensor_shapes[name].append(tensor.shape)\n      else:\n        # List or tuple.\n        self._tensor_keys[name] = None\n        for tensor in tensor_list_or_dict:\n          self._tensors[name].append(tensor)\n          self._tensor_dtypes[name].append(tensor.dtype)\n          self._tensor_shapes[name].append(tensor.shape)\n\n  def create_enqueue_op(self):\n    """"""Create the op to enqueue the recorded host_calls.\n\n    Returns:\n      A list of enqueue ops, which is empty if there are no host calls.\n    """"""\n    if not self._names:\n      return []\n\n    tensors = []\n    # TODO(jhseu): Consider deduping tensors.\n    for name in self._names:\n      tensors.extend(self._tensors[name])\n\n    with ops.device(tpu.core(0)):\n      return [tpu_ops.outfeed_enqueue_tuple(tensors)]\n\n  def create_tpu_hostcall(self):\n    """"""Sends the tensors through outfeed and runs the host_fn on CPU.\n\n    The tensors are concatenated along dimension 0 to form a global tensor\n    across all shards. The concatenated function is passed to the host_fn and\n    executed on the first host.\n\n    Returns:\n      A dictionary mapping name to the return type of the host_call by that\n      name.\n\n    Raises:\n      RuntimeError: If outfeed tensor is scalar.\n    """"""\n    if not self._names:\n      return {}\n\n    ret = {}\n    # For each i, dequeue_ops[i] is a list containing the tensors from all\n    # shards. This list is concatenated later.\n    dequeue_ops = []\n    tensor_dtypes = []\n    tensor_shapes = []\n    for name in self._names:\n      for _ in self._tensors[name]:\n        dequeue_ops.append([])\n      for dtype in self._tensor_dtypes[name]:\n        tensor_dtypes.append(dtype)\n      for shape in self._tensor_shapes[name]:\n        tensor_shapes.append(shape)\n\n    # Outfeed ops execute on each replica\'s first logical core. Note: we must\n    # constraint it such that we have at most one outfeed dequeue and enqueue\n    # per replica.\n    for i in xrange(self._ctx.num_replicas):\n      host_device, ordinal_id = self._ctx.device_for_replica(i)\n      with ops.device(host_device):\n        outfeed_tensors = tpu_ops.outfeed_dequeue_tuple(\n            dtypes=tensor_dtypes,\n            shapes=tensor_shapes,\n            device_ordinal=ordinal_id)\n        for j, item in enumerate(outfeed_tensors):\n          dequeue_ops[j].append(item)\n\n    # Deconstruct dequeue ops.\n    dequeue_ops_by_name = {}\n    pos = 0\n    for name in self._names:\n      dequeue_ops_by_name[name] = dequeue_ops[pos:pos +\n                                              len(self._tensors[name])]\n      pos += len(self._tensors[name])\n\n    # It is assumed evaluation always happens on single host TPU system. So,\n    # place all ops on tpu host if possible.\n    #\n    # TODO(jhseu): Evaluate whether this is right for summaries.\n    with ops.device(self._ctx.tpu_host_placement_function(replica_id=0)):\n      for name in self._names:\n        dequeue_ops = dequeue_ops_by_name[name]\n        for i, item in enumerate(dequeue_ops):\n          if dequeue_ops[i][0].shape.ndims == 0:\n            raise RuntimeError(\n                \'All tensors outfed from TPU should preserve batch size \'\n                \'dimension, but got scalar {}\'.format(dequeue_ops[i][0]))\n          # TODO(xiejw): Allow users to specify the axis for batch size\n          # dimension.\n          dequeue_ops[i] = array_ops.concat(dequeue_ops[i], axis=0)\n\n        if self._tensor_keys[name] is not None:\n          # The user-provided eval_metrics[1] is a dict.\n          dequeue_ops = dict(zip(self._tensor_keys[name], dequeue_ops))\n          try:\n            ret[name] = self._host_fns[name](**dequeue_ops)\n          except TypeError as e:\n            logging.warning(\n                \'Exception while calling %s: %s. It is likely the tensors \'\n                \'(%s[1]) do not match the \'\n                \'function\\\'s arguments\', name, e, name)\n            raise e\n        else:\n          ret[name] = self._host_fns[name](*dequeue_ops)\n\n    return ret\n\n\nclass _OutfeedHostCallHook(session_run_hook.SessionRunHook):\n  """"""Hook to run host calls when use_tpu=False.""""""\n\n  def __init__(self, tensors):\n    self._tensors = tensors\n\n  def begin(self):\n    # We duplicate this code from the TPUInfeedOutfeedSessionHook rather than\n    # create a separate hook to guarantee execution order, because summaries\n    # need to be initialized before the outfeed thread starts.\n    # TODO(jhseu): Make a wrapper hook instead?\n    self._init_ops = contrib_summary.summary_writer_initializer_op()\n    # Get all the writer resources from the initializer, so we know what to\n    # flush.\n    self._finalize_ops = []\n    for op in self._init_ops:\n      self._finalize_ops.append(contrib_summary.flush(writer=op.inputs[0]))\n\n  def after_create_session(self, session, coord):\n    session.run(self._init_ops)\n\n  def before_run(self, run_context):\n    return basic_session_run_hooks.SessionRunArgs(self._tensors)\n\n  def end(self, session):\n    session.run(self._finalize_ops)\n\n\nclass ExamplesPerSecondHook(basic_session_run_hooks.StepCounterHook):\n  """"""Calculate and report global_step/sec and examples/sec during runtime.""""""\n\n  def __init__(self,\n               batch_size,\n               every_n_steps=100,\n               every_n_secs=None,\n               output_dir=None,\n               summary_writer=None):\n    self._batch_size = batch_size\n    super(ExamplesPerSecondHook, self).__init__(\n        every_n_steps=every_n_steps,\n        every_n_secs=every_n_secs,\n        output_dir=output_dir,\n        summary_writer=summary_writer)\n\n  def _log_and_record(self, elapsed_steps, elapsed_time, global_step):\n    global_step_per_sec = elapsed_steps / elapsed_time\n    examples_per_sec = self._batch_size * global_step_per_sec\n    if self._summary_writer is not None:\n      global_step_summary = Summary(value=[\n          Summary.Value(tag=\'global_step/sec\', simple_value=global_step_per_sec)\n      ])\n      example_summary = Summary(value=[\n          Summary.Value(tag=\'examples/sec\', simple_value=examples_per_sec)\n      ])\n      self._summary_writer.add_summary(global_step_summary, global_step)\n      self._summary_writer.add_summary(example_summary, global_step)\n    logging.info(\'global_step/sec: %g\', global_step_per_sec)\n    logging.info(\'examples/sec: %g\', examples_per_sec)\n\n\nclass InstallSignalHandlerHook(session_run_hook.SessionRunHook):\n  """"""Change SIGINT (CTRL^C) handler to force quit the process.\n\n  The default behavior often results in hanging processes.\n  The original handler is restored after training/evaluation.\n  """"""\n\n  def __init__(self):\n    self._signal_fn = signal.getsignal(signal.SIGINT)\n\n  def before_run(self, run_context):\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n  def end(self, session):\n    signal.signal(signal.SIGINT, self._signal_fn)\n\n\nclass TPUEstimator(estimator_lib.Estimator):\n  """"""Estimator with TPU support.\n\n  TPUEstimator also supports training on CPU and GPU. You don\'t need to define\n  a separate `tf.estimator.Estimator`.\n\n  TPUEstimator handles many of the details of running on TPU devices, such as\n  replicating inputs and models for each core, and returning to host\n  periodically to run hooks.\n\n  TPUEstimator transforms a global batch size in params to a per-shard batch\n  size when calling the `input_fn` and `model_fn`. Users should specify\n  global batch size in constructor, and then get the batch size for each shard\n  in `input_fn` and `model_fn` by `params[\'batch_size\']`.\n\n  - For training, `model_fn` gets per-core batch size; `input_fn` may get\n    per-core or per-host batch size depending on `per_host_input_for_training`\n    in `TPUConfig` (See docstring for TPUConfig for details).\n\n  - For evaluation and prediction, `model_fn` gets per-core batch size and\n    `input_fn` get per-host batch size.\n\n  Evaluation\n  ==========\n\n  `model_fn` should return `TPUEstimatorSpec`, which expects the `eval_metrics`\n  for TPU evaluation. However, if eval_on_tpu is False, `model_fn` must return\n  `EstimatorSpec` and the evaluation will execute on CPU or GPU; in this case\n  the following discussion on TPU evaluation does not apply.\n\n  `TPUEstimatorSpec.eval_metrics` is a tuple of `metric_fn` and `tensors`, where\n  `tensors` could be a list of any nested structure of `Tensor`s (See\n  `TPUEstimatorSpec` for details).  `metric_fn` takes the `tensors` and returns\n  a dict from metric string name to the result of calling a metric function,\n  namely a `(metric_tensor, update_op)` tuple.\n\n  One can set `use_tpu` to `False` for testing. All training, evaluation, and\n  predict will be executed on CPU. `input_fn` and `model_fn` will receive\n  `train_batch_size` or `eval_batch_size` unmodified as `params[\'batch_size\']`.\n\n  Current limitations:\n  --------------------\n\n  1. TPU evaluation only works on a single host (one TPU worker) except\n     BROADCAST mode.\n\n  2. `input_fn` for evaluation should **NOT** raise an end-of-input exception\n     (`OutOfRangeError` or `StopIteration`). And all evaluation steps and all\n     batches should have the same size.\n\n  Example (MNIST):\n  ----------------\n\n  ```\n  # The metric Fn which runs on CPU.\n  def metric_fn(labels, logits):\n    predictions = tf.argmax(logits, 1)\n    return {\n      \'accuracy\': tf.metrics.precision(\n          labels=labels, predictions=predictions),\n    }\n\n  # Your model Fn which runs on TPU (eval_metrics is list in this example)\n  def model_fn(features, labels, mode, config, params):\n    ...\n    logits = ...\n\n    if mode = tf.estimator.ModeKeys.EVAL:\n      return tpu_estimator.TPUEstimatorSpec(\n          mode=mode,\n          loss=loss,\n          eval_metrics=(metric_fn, [labels, logits]))\n\n  # or specify the eval_metrics tensors as dict.\n  def model_fn(features, labels, mode, config, params):\n    ...\n    final_layer_output = ...\n\n    if mode = tf.estimator.ModeKeys.EVAL:\n      return tpu_estimator.TPUEstimatorSpec(\n          mode=mode,\n          loss=loss,\n          eval_metrics=(metric_fn, {\n              \'labels\': labels,\n              \'logits\': final_layer_output,\n          }))\n  ```\n\n  Prediction\n  ==========\n\n  Prediction on TPU is an experimental feature to support large batch inference.\n  It is not designed for latency-critical system. In addition, due to some\n  usability issues, for prediction with small dataset, CPU `.predict`, i.e.,\n  creating a new `TPUEstimator` instance with `use_tpu=False`, might be more\n  convenient.\n\n  Note: In contrast to TPU training/evaluation, the `input_fn` for prediction\n  *should* raise an end-of-input exception (`OutOfRangeError` or\n  `StopIteration`), which serves as the stopping signal to `TPUEstimator`. To be\n  precise, the ops created by `input_fn` produce one batch of the data.\n  The `predict()` API processes one batch at a time. When reaching the end of\n  the data source, an end-of-input exception should be raised by one of these\n  operations. The user usually does not need to do this manually. As long as the\n  dataset is not repeated forever, the `tf.data` API will raise an end-of-input\n  exception automatically after the last batch has been produced.\n\n  Note: Estimator.predict returns a Python generator. Please consume all the\n  data from the generator so that TPUEstimator can shutdown the TPU system\n  properly for user.\n\n  Current limitations:\n  --------------------\n  1. TPU prediction only works on a single host (one TPU worker).\n\n  2. `input_fn` must return a `Dataset` instance rather than `features`. In\n  fact, .train() and .evaluate() also support Dataset as return value.\n\n  Example (MNIST):\n  ----------------\n  ```\n  height = 32\n  width = 32\n  total_examples = 100\n\n  def predict_input_fn(params):\n    batch_size = params[\'batch_size\']\n\n    images = tf.random_uniform(\n        [total_examples, height, width, 3], minval=-1, maxval=1)\n\n    dataset = tf.data.Dataset.from_tensor_slices(images)\n    dataset = dataset.map(lambda images: {\'image\': images})\n\n    dataset = dataset.batch(batch_size)\n    return dataset\n\n  def model_fn(features, labels, params, mode):\n     # Generate predictions, called \'output\', from features[\'image\']\n\n    if mode == tf.estimator.ModeKeys.PREDICT:\n      return tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={\n              \'predictions\': output,\n              \'is_padding\': features[\'is_padding\']\n          })\n\n  tpu_est = TPUEstimator(\n      model_fn=model_fn,\n      ...,\n      predict_batch_size=16)\n\n  # Fully consume the generator so that TPUEstimator can shutdown the TPU\n  # system.\n  for item in tpu_est.predict(input_fn=input_fn):\n    # Filter out item if the `is_padding` is 1.\n    # Process the \'predictions\'\n  ```\n\n  Exporting\n  =========\n\n  `export_savedmodel` exports 2 metagraphs, one with `tag_constants.SERVING`,\n  and another with `tag_constants.SERVING` and `tag_constants.TPU`.\n  At serving time, these tags are used to select metagraph to load.\n\n  Before running the graph on TPU, TPU system needs to be initialized. If\n  TensorFlow Serving model-server is used, this is done automatically. If\n  not, please call `session.run(tpu.initialize_system())`.\n\n  `tpu.outside_compilation` can be used to wrap TPU incompatible ops in\n  `model_fn`.\n\n  Example:\n  ----------------\n\n  ```\n  def model_fn(features, labels, mode, config, params):\n    ...\n    logits = ...\n    export_outputs = {\n      \'logits\': export_output_lib.PredictOutput(\n        {\'logits\': logits})\n    }\n\n    def host_call(logits):\n      class_ids = math_ops.argmax(logits)\n      classes = string_ops.as_string(class_ids)\n      export_outputs[\'classes\'] =\n        export_output_lib.ClassificationOutput(classes=classes)\n\n    tpu.outside_compilation(host_call, logits)\n\n    ...\n  ```\n\n  """"""\n\n  def __init__(self,\n               model_fn=None,\n               train_cache_fn=None,\n               eval_cache_fn=None,\n               model_dir=None,\n               config=None,\n               params=None,\n               use_tpu=True,\n               train_batch_size=None,\n               eval_batch_size=None,\n               predict_batch_size=None,\n               batch_axis=None,\n               eval_on_tpu=True,\n               export_to_tpu=True,\n               warm_start_from=None):\n    """"""Constructs an `TPUEstimator` instance.\n\n    Args:\n      model_fn: Model function as required by `Estimator` which returns\n        EstimatorSpec or TPUEstimatorSpec. `training_hooks`, \'evaluation_hooks\',\n        and `prediction_hooks` must not capure any TPU Tensor inside the\n        model_fn.\n      model_dir: Directory to save model parameters, graph and etc. This can\n        also be used to load checkpoints from the directory into a estimator to\n        continue training a previously saved model. If `None`, the model_dir in\n        `config` will be used if set. If both are set, they must be same. If\n        both are `None`, a temporary directory will be used.\n      config: An `tpu_config.RunConfig` configuration object. Cannot be `None`.\n      params: An optional `dict` of hyper parameters that will be passed into\n        `input_fn` and `model_fn`.  Keys are names of parameters, values are\n        basic python types. There are reserved keys for `TPUEstimator`,\n        including \'batch_size\'.\n      use_tpu: A bool indicating whether TPU support is enabled. Currently, -\n        TPU training and evaluation respect this bit, but eval_on_tpu can\n        override execution of eval. See below. - Predict still happens on CPU.\n      train_batch_size: An int representing the global training batch size.\n        TPUEstimator transforms this global batch size to a per-shard batch\n        size, as params[\'batch_size\'], when calling `input_fn` and `model_fn`.\n        Cannot be `None` if `use_tpu` is `True`. Must be divisible by total\n        number of replicas.\n      eval_batch_size: An int representing evaluation batch size. Must be\n        divisible by total number of replicas.\n      predict_batch_size: An int representing the prediction batch size. Must be\n        divisible by total number of replicas.\n      batch_axis: A python tuple of int values describing how each tensor\n        produced by the Estimator `input_fn` should be split across the TPU\n        compute shards. For example, if your input_fn produced (images, labels)\n        where the images tensor is in `HWCN` format, your shard dimensions would\n        be [3, 0], where 3 corresponds to the `N` dimension of your images\n        Tensor, and 0 corresponds to the dimension along which to split the\n        labels to match up with the corresponding images. If None is supplied,\n        and per_host_input_for_training is True, batches will be sharded based\n        on the major dimension. If tpu_config.per_host_input_for_training is\n        False or `PER_HOST_V2`, batch_axis is ignored.\n      eval_on_tpu: If False, evaluation runs on CPU or GPU. In this case, the\n        model_fn must return `EstimatorSpec` when called with `mode` as `EVAL`.\n      export_to_tpu: If True, `export_savedmodel()` exports a metagraph for\n        serving on TPU besides the one on CPU.\n      warm_start_from: Optional string filepath to a checkpoint or SavedModel to\n        warm-start from, or a `tf.estimator.WarmStartSettings` object to fully\n        configure warm-starting.  If the string filepath is provided instead of\n        a `WarmStartSettings`, then all variables are warm-started, and it is\n        assumed that vocabularies and Tensor names are unchanged.\n\n    Raises:\n      ValueError: `params` has reserved keys already.\n    """"""\n    if config is None or not isinstance(config, tpu_config.RunConfig):\n      raise ValueError(\n          \'`config` must be provided with type `tpu_config.RunConfig`\')\n\n    if params is not None and any(k in params for k in _RESERVED_PARAMS_KEYS):\n      raise ValueError(\'{} are reserved keys but existed in params {}.\'.format(\n          _RESERVED_PARAMS_KEYS, params))\n\n    if use_tpu:\n      # Perform some very basic validations. More validations will be found in\n      # _InternalTPUContext.\n      if train_batch_size is None:\n        raise ValueError(\'`train_batch_size` cannot be `None`\')\n      util_lib.check_positive_integer(train_batch_size, \'train_batch_size\')\n\n      if (config.tpu_config.per_host_input_for_training is\n          tpu_config.InputPipelineConfig.PER_SHARD_V1 and\n          config.tpu_config.num_cores_per_replica):\n        raise ValueError(\n            \'Model parallelism only supports per host input for training. \'\n            \'Please adjust TPURunconfig.per_host_input_for_training.\')\n\n      if eval_batch_size is not None:\n        util_lib.check_positive_integer(eval_batch_size, \'eval_batch_size\')\n\n      if predict_batch_size is not None:\n        util_lib.check_positive_integer(predict_batch_size,\n                                        \'predict_batch_size\')\n\n    # Verifies the model_fn signature according to Estimator framework.\n    estimator_lib._verify_model_fn_args(model_fn, params)  # pylint: disable=protected-access\n    # We cannot store config and params in this constructor as parent\n    # constructor might change them, such as assigning a temp dir for\n    # config.model_dir.\n    model_function = self._augment_model_fn(\n        model_fn,\n        train_cache_fn,\n        eval_cache_fn,\n        batch_axis)\n\n    # Overwrite log_step_count_steps to disable TensorLoggingHook and\n    # StepCounterHook from being created in Estimator. TPUEstimator already\n    # added equivalent hooks in _augment_model_fn above.\n    self._log_every_n_steps = config.log_step_count_steps\n    config = config.replace(log_step_count_steps=None)\n\n    # Passing non-None params as wrapped model_fn has it.\n    params = params or {}\n    super(TPUEstimator, self).__init__(\n        model_fn=model_function,\n        model_dir=model_dir,\n        config=config,\n        params=params,\n        warm_start_from=warm_start_from)\n    self._iterations_per_training_loop = (\n        self._config.tpu_config.iterations_per_loop)\n\n    # All properties passed to _InternalTPUContext are immutable.\n    # pylint: disable=protected-access\n    self._ctx = tpu_context._get_tpu_context(\n        self._config, train_batch_size, eval_batch_size, predict_batch_size,\n        use_tpu, eval_on_tpu)\n\n    self._export_to_tpu = export_to_tpu\n\n    self._is_input_fn_invoked = None\n    self._rendezvous = {}\n\n  def _add_meta_graph_for_mode(self,\n                               builder,\n                               input_receiver_fn_map,\n                               checkpoint_path,\n                               save_variables=True,\n                               mode=model_fn_lib.ModeKeys.PREDICT,\n                               export_tags=None,\n                               check_variables=True):\n    if self._export_to_tpu and mode != model_fn_lib.ModeKeys.PREDICT:\n      raise NotImplementedError(\n          \'TPUEstimator only handles mode PREDICT for exporting \'\n          \'when `export_to_tpu` is `True`; \'\n          \'got {}.\'.format(mode))\n\n    (super(TPUEstimator, self)._add_meta_graph_for_mode(\n        builder,\n        input_receiver_fn_map,\n        checkpoint_path,\n        save_variables,\n        mode=mode,\n        export_tags=export_tags,\n        check_variables=check_variables))\n\n    if self._export_to_tpu:\n      input_receiver_fn_map = {\n          _REWRITE_FOR_INFERENCE_MODE: input_receiver_fn_map[mode]\n      }\n      export_tags = [tag_constants.SERVING, tag_constants.TPU]\n      mode = _REWRITE_FOR_INFERENCE_MODE\n      # See b/110052256 for why `check_variables` is `False`.\n      (super(TPUEstimator, self)._add_meta_graph_for_mode(\n          builder,\n          input_receiver_fn_map,\n          checkpoint_path,\n          save_variables=False,\n          mode=mode,\n          export_tags=export_tags,\n          check_variables=False))\n\n  def _call_model_fn(self, features, labels, mode, config):\n    if mode == _REWRITE_FOR_INFERENCE_MODE:\n      return self._call_model_fn_for_inference(features, labels, mode, config)\n    else:\n      return super(TPUEstimator, self)._call_model_fn(features, labels, mode,\n                                                      config)\n\n  def _call_model_fn_for_inference(self, features, labels, mode, config):\n    """"""Wraps `_call_model_fn` for `export_savedmodel`.""""""\n    if mode != _REWRITE_FOR_INFERENCE_MODE:\n      raise ValueError(\'mode must be {}; \'\n                       \'got {}.\'.format(_REWRITE_FOR_INFERENCE_MODE, mode))\n\n    capture = _CapturedObject()\n\n    def computation():\n      """"""Compute tpu tensors used in export_outputs.\n\n      Passed to rewrite_for_inference so that model_fn will be called under\n      the rewriting contexts. Only tpu tensors are returned, but export_outputs\n      and scaffold are captured.\n\n      Returns:\n         A list of Tensors used in export_outputs and not marked for\n         outside_compilation.\n      """"""\n      # We should only call model fn once and it should be inside `computation`\n      # so that building the graph will happen under `rewrite_for_inference`.\n      mode = model_fn_lib.ModeKeys.PREDICT\n      estimator_spec = self._call_model_fn(features, labels, mode, config)\n\n      # We pick the TPU tensors out from `export_output` and later return them\n      # from `computation` for rewriting.\n      tensors_dict = collections.OrderedDict(\n          (k, _export_output_to_tensors(v))\n          for k, v in six.iteritems(estimator_spec.export_outputs))\n      tensors = nest.flatten(tensors_dict)\n      tpu_tensors = [t for t in tensors if t is not None]\n\n      # We cannot return anything other than `tpu_tensors` here so we capture\n      # the rest for later use.\n      capture.capture((estimator_spec, tensors_dict, tensors))\n      return tpu_tensors\n\n    tpu_tensors_on_cpu = tpu.rewrite_for_inference(computation)\n    estimator_spec, tensors_dict, tensors = capture.get()\n\n    # Reconstruct `tensors`, but with `tpu_tensors` replaced with\n    # `tpu_tensors_on_cpu`.\n    new_tensors = []\n    for t in tensors:\n      if t is None:\n        new_tensors.append(None)\n      else:\n        new_tensors.append(tpu_tensors_on_cpu.pop(0))\n\n    # Reconstruct `tensors_dict`.\n    new_tensors_dict = nest.pack_sequence_as(tensors_dict, new_tensors)\n    # Reconstruct `export_outputs`.\n    export_outputs = estimator_spec.export_outputs\n    new_export_outputs = collections.OrderedDict(\n        (k, _clone_export_output_with_tensors(export_outputs[k], v))\n        for k, v in six.iteritems(new_tensors_dict))\n\n    return estimator_spec._replace(export_outputs=new_export_outputs)\n\n  def _create_global_step(self, graph):\n    """"""Creates a global step suitable for TPUs.\n\n    Args:\n      graph: The graph in which to create the global step.\n\n    Returns:\n      A global step `Tensor`.\n\n    Raises:\n      ValueError: if the global step tensor is already defined.\n    """"""\n    return _create_global_step(graph)\n\n  def _convert_train_steps_to_hooks(self, steps, max_steps):\n    with self._ctx.with_mode(model_fn_lib.ModeKeys.TRAIN) as ctx:\n      if ctx.is_running_on_cpu():\n        return super(TPUEstimator, self)._convert_train_steps_to_hooks(\n            steps, max_steps)\n\n    # On TPU.\n    if steps is None and max_steps is None:\n      raise ValueError(\n          \'For TPU training, one of `steps` or `max_steps` must be set. \'\n          \'Cannot be both `None`.\')\n\n    # Estimator.train has explicit positiveness check.\n    if steps is not None:\n      util_lib.check_positive_integer(steps, \'Train steps\')\n    if max_steps is not None:\n      util_lib.check_positive_integer(max_steps, \'Train max_steps\')\n\n    return [\n        _TPUStopAtStepHook(self._iterations_per_training_loop, steps, max_steps)\n    ]\n\n  def _convert_eval_steps_to_hooks(self, steps):\n    with self._ctx.with_mode(model_fn_lib.ModeKeys.EVAL) as ctx:\n      if ctx.is_running_on_cpu():\n        return super(TPUEstimator, self)._convert_eval_steps_to_hooks(steps)\n\n    if steps is None:\n      raise ValueError(\'Evaluate `steps` must be set on TPU. Cannot be `None`.\')\n\n    util_lib.check_positive_integer(steps, \'Eval steps\')\n\n    return [\n        evaluation._StopAfterNEvalsHook(  # pylint: disable=protected-access\n            num_evals=steps),\n        _SetEvalIterationsHook(steps)\n    ]\n\n  def _call_input_fn(self, input_fn, mode):\n    """"""Calls the input function.\n\n    Args:\n      input_fn: The input function.\n      mode: ModeKeys\n\n    Returns:\n      In TPU mode, returns an input_fn to be called later in model_fn.\n      Otherwise, calls the input_fn and returns either fatures or\n        (features, labels).\n\n    Raises:\n      ValueError: if input_fn takes invalid arguments or does not have `params`.\n    """"""\n    input_fn_args = function_utils.fn_args(input_fn)\n    config = self.config  # a deep copy.\n    kwargs = {}\n    if \'params\' in input_fn_args:\n      kwargs[\'params\'] = self.params  # a deep copy.\n    else:\n      raise ValueError(\'input_fn ({}) does not include params argument, \'\n                       \'required by TPUEstimator to pass batch size as \'\n                       \'params[""batch_size""]\'.format(input_fn))\n    if \'config\' in input_fn_args:\n      kwargs[\'config\'] = config\n\n    if \'mode\' in input_fn_args:\n      kwargs[\'mode\'] = mode\n\n    # Records the fact input_fn has been invoked.\n    self._is_input_fn_invoked = True\n\n    with self._ctx.with_mode(mode) as ctx:\n      # Setting the batch size in params first. This helps user to have same\n      # input_fn for use_tpu=True/False.\n      batch_size_for_input_fn = ctx.batch_size_for_input_fn\n      if batch_size_for_input_fn is not None:\n        _add_item_to_params(kwargs[\'params\'], _BATCH_SIZE_KEY,\n                            batch_size_for_input_fn)\n\n      # For export_savedmodel, input_fn is never passed to Estimator. So,\n      # `is_export_mode` must be False.\n      if ctx.is_running_on_cpu(is_export_mode=False):\n        with ops.device(\'/device:CPU:0\'):\n          return input_fn(**kwargs)\n\n      # For TPU computation, input_fn should be invoked in a tf.while_loop for\n      # performance. While constructing the tf.while_loop, the structure of\n      # inputs returned by the `input_fn` needs to be recorded. The structure\n      # includes whether features or labels is dict or single Tensor, dict keys,\n      # tensor shapes, and dtypes. The recorded structure is used to create the\n      # infeed dequeue ops, which must be wrapped and passed as a Fn, called\n      # inside the TPU computation, as the TPU computation is wrapped inside a\n      # tf.while_loop also. So, we either pass input_fn to model_fn or pass\n      # dequeue_fn to model_fn. Here, `input_fn` is passed directly as\n      # `features` in `model_fn` signature.\n      def _input_fn(ctx):\n        _add_item_to_params(kwargs[\'params\'], _CTX_KEY, ctx)\n        return input_fn(**kwargs)\n\n      return _input_fn\n\n  def _validate_features_in_predict_input(self, result):\n    """"""Skip the validation.\n\n    For TPUEstimator, we do not need to check the result type. `_InputPipeline`\n    has stronger check. Parent class\'s check generates confusing warning msg.\n\n    Args:\n      result: `features` returned by input_fn.\n    """"""\n    pass\n\n  def train(self,\n            input_fn,\n            hooks=None,\n            steps=None,\n            max_steps=None,\n            saving_listeners=None):\n    rendezvous = error_handling.ErrorRendezvous(num_sources=3)\n    self._rendezvous[model_fn_lib.ModeKeys.TRAIN] = rendezvous\n    try:\n      return super(TPUEstimator, self).train(\n          input_fn=input_fn,\n          hooks=hooks,\n          steps=steps,\n          max_steps=max_steps,\n          saving_listeners=saving_listeners)\n    except Exception:  # pylint: disable=broad-except\n      rendezvous.record_error(\'training_loop\', sys.exc_info())\n    finally:\n      rendezvous.record_done(\'training_loop\')\n      rendezvous.raise_errors()\n\n  def evaluate(self,\n               input_fn,\n               steps=None,\n               hooks=None,\n               checkpoint_path=None,\n               name=None):\n    rendezvous = error_handling.ErrorRendezvous(num_sources=3)\n    self._rendezvous[model_fn_lib.ModeKeys.EVAL] = rendezvous\n    try:\n      return super(TPUEstimator, self).evaluate(\n          input_fn,\n          steps=steps,\n          hooks=hooks,\n          checkpoint_path=checkpoint_path,\n          name=name)\n    except Exception:  # pylint: disable=broad-except\n      rendezvous.record_error(\'evaluation_loop\', sys.exc_info())\n    finally:\n      rendezvous.record_done(\'evaluation_loop\')\n      rendezvous.raise_errors()\n\n  def predict(self,\n              input_fn,\n              predict_keys=None,\n              hooks=None,\n              checkpoint_path=None,\n              yield_single_examples=True):\n    rendezvous = error_handling.ErrorRendezvous(num_sources=3)\n    self._rendezvous[model_fn_lib.ModeKeys.PREDICT] = rendezvous\n    try:\n      for result in super(TPUEstimator, self).predict(\n          input_fn=input_fn,\n          predict_keys=predict_keys,\n          hooks=hooks,\n          checkpoint_path=checkpoint_path,\n          yield_single_examples=yield_single_examples):\n        yield result\n    except Exception:  # pylint: disable=broad-except\n      rendezvous.record_error(\'prediction_loop\', sys.exc_info())\n    finally:\n      rendezvous.record_done(\'prediction_loop\')\n      rendezvous.raise_errors()\n\n    rendezvous.record_done(\'prediction_loop\')\n    rendezvous.raise_errors()\n\n  def _augment_model_fn(self, model_fn, train_cache_fn, eval_cache_fn, batch_axis):\n    """"""Returns a new model_fn, which wraps the TPU support.""""""\n\n    def _model_fn(features, labels, mode, config, params):\n      """"""A Estimator `model_fn` for TPUEstimator.""""""\n      with self._ctx.with_mode(mode) as ctx:\n        model_fn_wrapper = _ModelFnWrapper(model_fn, train_cache_fn,\n            eval_cache_fn, config, params, ctx)\n\n        # `input_fn` is called in `train()`, `evaluate()`, and `predict()`,\n        # but not in `export_savedmodel()`.\n        if self._is_input_fn_invoked:\n          is_export_mode = False\n        else:\n          is_export_mode = True\n\n        # Clear the bit.\n        self._is_input_fn_invoked = None\n\n        # examples_hook is added to training_hooks for both CPU and TPU\n        # execution.\n        if self._log_every_n_steps is not None:\n          examples_hook = ExamplesPerSecondHook(\n              ctx.global_batch_size,\n              output_dir=self.model_dir,\n              every_n_steps=self._log_every_n_steps)\n\n        if ctx.is_running_on_cpu(is_export_mode=is_export_mode):\n          logging.info(\'Running %s on CPU\', mode)\n          estimator_spec = model_fn_wrapper.call_without_tpu(\n              features, labels, is_export_mode=is_export_mode)\n          if self._log_every_n_steps is not None:\n            estimator_spec = estimator_spec._replace(\n                training_hooks=estimator_spec.training_hooks + (examples_hook,))\n          return estimator_spec\n\n        assert labels is None, \'`labels` passed to `model_fn` must be `None`.\'\n        # TPUEstimator._call_input_fn passes `input_fn` as features to here.\n        assert callable(features), \'`input_fn` is not callable.\'\n        input_fn = features\n\n        input_holders = _InputPipeline(input_fn, batch_axis, ctx)\n        enqueue_ops, dequeue_fn, input_hooks, run_infeed_loop_on_coordinator = (\n            input_holders.generate_infeed_enqueue_ops_and_dequeue_fn())\n\n        graph = ops.get_default_graph()\n        for enqueue_op in enqueue_ops:\n          if isinstance(enqueue_op, list):\n            graph.get_collection_ref(_TPU_ENQUEUE_OPS).extend(enqueue_op)\n          else:\n            graph.add_to_collection(_TPU_ENQUEUE_OPS, enqueue_op)\n\n        if mode == model_fn_lib.ModeKeys.TRAIN:\n          compile_op, loss, host_call, scaffold, training_hooks = (\n              _train_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn))\n          host_ops = host_call.create_tpu_hostcall()\n          if host_ops is None:\n            host_ops = []\n\n          shutdown_hooks = []\n          shutdown_mode = os.environ.get(\'TF_TPU_GRACEFUL_SHUTDOWN_MODE\',\n                                         \'shutdown_worker\')\n          if shutdown_mode:\n            if shutdown_mode == \'shutdown_worker\':\n              finalizer_hooks = [\n                  session_support.ShutdownLameWorkers(timeout_ms=60 * 1000),\n              ]\n            elif shutdown_mode == \'shutdown_computation\':\n              finalizer_hooks = [\n                  session_support.RestartComputation(timeout_ms=60 * 1000),\n              ]\n            else:\n              raise ValueError(\n                  \'Unknown TF_TPU_GRACEFUL_SHUTDOWN_MODE ""%s""\' % shutdown_mode)\n\n            shutdown_hooks.append(\n                session_support.GracefulShutdownHook(\n                    checkpoint_prefix=self.model_dir + \'/model.ckpt\',\n                    on_shutdown_hooks=finalizer_hooks))\n\n          with ops.control_dependencies([loss]):\n            global_step = array_ops.identity(training.get_global_step())\n          hooks = input_hooks + shutdown_hooks\n          hooks.extend([\n              TPUInfeedOutfeedSessionHook(\n                  ctx,\n                  enqueue_ops,\n                  host_ops,\n                  tpu_compile_op=compile_op,\n                  run_infeed_loop_on_coordinator=(\n                      run_infeed_loop_on_coordinator),\n                  rendezvous=self._rendezvous[mode],\n                  master=self._config.master,\n                  session_config=self._session_config,\n              ),\n              InstallSignalHandlerHook()\n          ])\n          if self._log_every_n_steps is not None:\n            logging_hook_frequency = (  # Divide and round up\n                (self._log_every_n_steps +\n                 self._config.tpu_config.iterations_per_loop - 1) //\n                self._config.tpu_config.iterations_per_loop)\n            hooks.append(\n                training.LoggingTensorHook({\n                    \'loss\': array_ops.identity(loss),\n                    \'step\': global_step,\n                },\n                                           every_n_iter=logging_hook_frequency))\n            examples_hook._set_steps_per_run(  # pylint: disable=protected-access\n                self._config.tpu_config.iterations_per_loop)\n            hooks.append(examples_hook)\n\n          if training_hooks:\n            hooks.extend(training_hooks)\n\n          chief_hooks = []\n          if (self._config.save_checkpoints_secs or\n              self._config.save_checkpoints_steps):\n            checkpoint_hook = training.CheckpointSaverHook(\n                self.model_dir,\n                save_secs=self._config.save_checkpoints_secs,\n                save_steps=self._config.save_checkpoints_steps,\n                scaffold=scaffold)\n            checkpoint_hook._set_steps_per_run(  # pylint: disable=protected-access\n                self._config.tpu_config.iterations_per_loop)\n            chief_hooks.append(checkpoint_hook)\n\n          summary.scalar(model_fn_lib.LOSS_METRIC_KEY, loss)\n          with ops.control_dependencies([loss]):\n            update_ops = _sync_variables_ops(ctx)\n\n          # Validate the TPU training graph to catch basic errors\n          _validate_tpu_training_graph()\n\n          train_op = control_flow_ops.group(*update_ops)\n          graph.add_to_collection(_TPU_TRAIN_OP, train_op)\n\n          return model_fn_lib.EstimatorSpec(\n              mode,\n              loss=loss,\n              training_chief_hooks=chief_hooks,\n              training_hooks=hooks,\n              train_op=train_op,\n              scaffold=scaffold)\n\n        if mode == model_fn_lib.ModeKeys.EVAL:\n          compile_op, total_loss, host_calls, scaffold, eval_hooks = (\n              _eval_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn))\n          iterations_per_loop_var = _create_or_get_iterations_per_loop()\n          mean_loss = math_ops.div(\n              total_loss,\n              math_ops.cast(iterations_per_loop_var, dtype=total_loss.dtype))\n\n          with ops.control_dependencies([mean_loss]):\n            # After TPU evaluation computation is done (the mean_loss tensor),\n            # reads all variables back from TPU and updates the eval step\n            # counter properly\n            internal_ops_to_run = _sync_variables_ops(ctx)\n            internal_ops_to_run.append(\n                _increase_eval_step_op(iterations_per_loop_var))\n\n          host_call_ret = host_calls.create_tpu_hostcall()\n          eval_metric_ops = {}\n          eval_update_ops = []\n\n          eval_metrics = host_call_ret.get(\'eval_metrics\', {})\n          if eval_metrics:\n            # Creates a dummy metric update_op for all metrics. Estimator\n            # expects all metrics in `eval_metric_ops` have update_op and calls\n            # them one by one. The real metric update_ops are invoked in a\n            # separated thread. So, here give Estimator the dummy op for all\n            # metrics.\n            with ops.control_dependencies(internal_ops_to_run):\n              dummy_update_op = control_flow_ops.no_op()\n\n            for k, v in eval_metrics.items():\n              eval_metric_ops[k] = (v[0], dummy_update_op)\n              eval_update_ops.append(v[1])\n          else:\n            # If no eval metrics are passed, create an identity node for the\n            # loss and add `internal_ops_to_run` to its dependencies. So\n            # `internal_ops_to_run` can be executed.\n            with ops.control_dependencies(internal_ops_to_run):\n              mean_loss = array_ops.identity(mean_loss)\n\n          if \'host_call\' not in host_call_ret:\n            host_ops = []\n          else:\n            host_ops = host_call_ret[\'host_call\']\n          hooks = [\n              TPUInfeedOutfeedSessionHook(\n                  ctx,\n                  enqueue_ops,\n                  eval_update_ops + host_ops,\n                  tpu_compile_op=compile_op,\n                  run_infeed_loop_on_coordinator=(\n                      run_infeed_loop_on_coordinator),\n                  rendezvous=self._rendezvous[mode],\n                  master=self._config.evaluation_master,\n                  session_config=self._session_config,\n              )] + input_hooks\n\n          if eval_hooks:\n            hooks.extend(eval_hooks)\n\n          return model_fn_lib.EstimatorSpec(\n              mode,\n              loss=mean_loss,\n              evaluation_hooks=hooks,\n              eval_metric_ops=eval_metric_ops,\n              scaffold=scaffold)\n\n        # Predict\n        assert mode == model_fn_lib.ModeKeys.PREDICT\n\n        (compile_op, dummy_predict_op, host_calls,\n         scaffold, prediction_hooks) = _predict_on_tpu_system(\n             ctx, model_fn_wrapper, dequeue_fn)\n        with ops.control_dependencies([dummy_predict_op]):\n          internal_ops_to_run = _sync_variables_ops(ctx)\n          with ops.control_dependencies(internal_ops_to_run):\n            dummy_predict_op = control_flow_ops.no_op()\n\n        # In train and evaluation, the main TPU program is passed to monitored\n        # training session to run. Infeed enqueue and outfeed dequeue are\n        # executed in side threads. This is not the configuration for\n        # prediction mode.\n        #\n        # For prediction, the Estimator executes the EstimatorSpec.predictions\n        # directly and yield the element (via generator) to call site. So, the\n        # outfeed based prediction must be passed to MonitoredSession directly.\n        # Other parts of the TPU execution are organized as follows.\n        #\n        # 1. All outfeed based Tensors must be grouped with predictions Tensors\n        #    to form a single invocation. This avoid the issue we might trigger\n        #    multiple outfeeds incorrectly. To achieve this, `host_call` is\n        #    placed in control_dependencies of `stopping_signals`, and\n        #    `stopping_signals` is passed into _StoppingPredictHook, which sets\n        #    the `stopping_signals` as SessionRunArgs. MonitoredSession merges\n        #    all SessionRunArgs with the fetch in session.run together.\n        #\n        # 2. The TPU program (dummy_predict_op) and enqueue_ops (infeed Enqueue)\n        #    are grouped together. They will be launched once and only once in\n        #    side threads and they quit naturally according to the SAME stopping\n        #    condition.\n        enqueue_ops.append(dummy_predict_op)\n\n        host_call_ret = host_calls.create_tpu_hostcall()\n        if \'host_call\' not in host_call_ret:\n          host_ops = []\n        else:\n          host_ops = host_call_ret[\'host_call\']\n\n        predictions = host_call_ret[\'predictions\']\n        _verify_cross_hosts_transfer_size(\n            predictions,\n            message=(\n                \'The estimated size for TPUEstimatorSpec.predictions is too \'\n                \'large.\'))\n        signals = host_call_ret[\'signals\']\n\n        with ops.control_dependencies(host_ops):\n          host_ops = []  # Empty, we do do not need it anymore.\n          scalar_stopping_signal = _StopSignals.as_scalar_stopping_signal(\n              signals)\n          predictions = _PaddingSignals.slice_tensor_or_dict(\n              predictions, signals)\n\n        hooks = [\n            _StoppingPredictHook(scalar_stopping_signal),\n            TPUInfeedOutfeedSessionHookForPrediction(\n                ctx, enqueue_ops, host_ops, rendezvous=self._rendezvous[mode],\n                tpu_compile_op=compile_op,\n                master=self._config.master,\n                session_config=self._session_config),\n        ] + input_hooks\n\n        if prediction_hooks:\n          hooks.extend(prediction_hooks)\n\n        return model_fn_lib.EstimatorSpec(\n            mode,\n            prediction_hooks=hooks,\n            predictions=predictions,\n            scaffold=scaffold)\n\n    return _model_fn\n\n\ndef _export_output_to_tensors(export_output):\n  """"""Get a list of `Tensors` used in `export_output`.\n\n  Args:\n    export_output: an `ExportOutput` object such as `ClassificationOutput`,\n      `RegressionOutput`, or `PredictOutput`.\n\n  Returns:\n    a list of tensors used in export_output.\n\n  Raises:\n    ValueError: if `export_output` is not one of `ClassificationOutput`,\n        `RegressionOutput`, or `PredictOutput`.\n  """"""\n  if isinstance(export_output, export_output_lib.ClassificationOutput):\n    return [export_output.scores, export_output.classes]\n  elif isinstance(export_output, export_output_lib.RegressionOutput):\n    return [export_output.value]\n  elif isinstance(export_output, export_output_lib.PredictOutput):\n    return list(export_output.outputs.values())\n  else:\n    raise ValueError(\n        \'`export_output` must be have type `ClassificationOutput`, \'\n        \'`RegressionOutput`, or `PredictOutput`; got {}.\'.format(export_output))\n\n\ndef _clone_export_output_with_tensors(export_output, tensors):\n  """"""Clones `export_output` but with new `tensors`.\n\n  Args:\n    export_output: an `ExportOutput` object such as `ClassificationOutput`,\n      `RegressionOutput`, or `PredictOutput`.\n    tensors: a list of `Tensors` used to construct a new `export_output`.\n\n  Returns:\n    A dict similar to `export_output` but with `tensors`.\n\n  Raises:\n    ValueError: if `export_output` is not one of `ClassificationOutput`,\n        `RegressionOutput`, or `PredictOutput`.\n  """"""\n  if isinstance(export_output, export_output_lib.ClassificationOutput):\n    if len(tensors) != 2:\n      raise ValueError(\'tensors must be of length 2; \'\n                       \'got {}.\'.format(len(tensors)))\n    return export_output_lib.ClassificationOutput(*tensors)\n  elif isinstance(export_output, export_output_lib.RegressionOutput):\n    if len(tensors) != 1:\n      raise ValueError(\'tensors must be of length 1; \'\n                       \'got {}\'.format(len(tensors)))\n    return export_output_lib.RegressionOutput(*tensors)\n  elif isinstance(export_output, export_output_lib.PredictOutput):\n    return export_output_lib.PredictOutput(\n        dict(zip(export_output.outputs.keys(), tensors)))\n  else:\n    raise ValueError(\n        \'`export_output` must be have type `ClassificationOutput`, \'\n        \'`RegressionOutput`, or `PredictOutput`; got {}.\'.format(export_output))\n\n\ndef _eval_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn):\n  """"""Executes `model_fn_wrapper` multiple times on all TPU shards.""""""\n  iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  (single_tpu_eval_step, host_calls, captured_scaffold_fn, captured_eval_hooks\n  ) = model_fn_wrapper.convert_to_single_tpu_eval_step(dequeue_fn)\n\n  def multi_tpu_eval_steps_on_single_shard():\n    loop_vars = [_ZERO_LOSS]\n    if model_fn_wrapper._eval_cache_fn is not None:\n      batch_size = ctx.global_batch_size\n      num_shards = ctx._config._tpu_config.num_shards\n      loop_vars += model_fn_wrapper._eval_cache_fn(batch_size // num_shards)\n\n    return training_loop.repeat(\n        iterations_per_loop_var,\n        single_tpu_eval_step,\n        loop_vars)\n\n  compile_op, ret = tpu.split_compile_and_shard(\n      multi_tpu_eval_steps_on_single_shard,\n      inputs=[],\n      num_shards=ctx.num_replicas,\n      outputs_from_all_shards=False,\n      device_assignment=ctx.device_assignment)\n\n  loss = ret[0]\n  scaffold = _get_scaffold(captured_scaffold_fn)\n  return compile_op, loss, host_calls, scaffold, captured_eval_hooks.get()\n\n\ndef _train_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn):\n  """"""Executes `model_fn_wrapper` multiple times on all TPU shards.""""""\n  iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  (single_tpu_train_step, host_call, captured_scaffold_fn,\n   captured_training_hooks) = (\n       model_fn_wrapper.convert_to_single_tpu_train_step(dequeue_fn))\n\n  def multi_tpu_train_steps_on_single_shard():\n    loop_vars = [_INITIAL_LOSS]\n    if model_fn_wrapper._train_cache_fn is not None:\n      batch_size = ctx.global_batch_size\n      num_shards = ctx._config._tpu_config.num_shards\n      loop_vars += model_fn_wrapper._train_cache_fn(batch_size // num_shards)\n\n    return training_loop.repeat(\n        iterations_per_loop_var,\n        single_tpu_train_step,\n        loop_vars)\n\n  compile_op, ret = tpu.split_compile_and_shard(\n      multi_tpu_train_steps_on_single_shard,\n      inputs=[],\n      num_shards=ctx.num_replicas,\n      outputs_from_all_shards=False,\n      device_assignment=ctx.device_assignment)\n\n  loss = ret[0]\n  scaffold = _get_scaffold(captured_scaffold_fn)\n  return compile_op, loss, host_call, scaffold, captured_training_hooks.get()\n\n\ndef _predict_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn):\n  """"""Executes `model_fn_wrapper` multiple times on all TPU shards.""""""\n  (single_tpu_predict_step, host_calls, captured_scaffold_fn,\n   captured_predict_hooks\n  ) = model_fn_wrapper.convert_to_single_tpu_predict_step(dequeue_fn)\n\n  def multi_tpu_predict_steps_on_single_shard():\n\n    def cond(scalar_stopping_signal):\n      return math_ops.logical_not(\n          _StopSignals.should_stop(scalar_stopping_signal))\n\n    inputs = [_StopSignals.NON_STOPPING_SIGNAL]\n    outputs = training_loop.while_loop(\n        cond, single_tpu_predict_step, inputs=inputs, name=b\'loop\')\n    return outputs\n\n  (compile_op, dummy_predict_op,) = tpu.split_compile_and_shard(\n      multi_tpu_predict_steps_on_single_shard,\n      inputs=[],\n      num_shards=ctx.num_replicas,\n      outputs_from_all_shards=False,\n      device_assignment=ctx.device_assignment)\n\n  dummy_predict_op = dummy_predict_op[0]\n  scaffold = _get_scaffold(captured_scaffold_fn)\n  return (compile_op, dummy_predict_op, host_calls, scaffold,\n          captured_predict_hooks.get())\n\n\ndef _wrap_computation_in_while_loop(device, op_fn):\n  """"""Wraps the ops generated by `op_fn` in tf.while_loop.""""""\n\n  def computation(i):\n    with ops.control_dependencies(op_fn()):\n      return i + 1\n\n  iterations_per_loop_var = _create_or_get_iterations_per_loop()\n  # By setting parallel_iterations=1, the parallel execution in while_loop is\n  # basically turned off.\n  with ops.device(device):\n    iterations = array_ops.identity(iterations_per_loop_var)\n    return control_flow_ops.while_loop(\n        lambda i: i < iterations,\n        computation, [constant_op.constant(0)],\n        parallel_iterations=1)\n\n\ndef _wrap_computation_in_while_loop_with_stopping_signals(device, op_fn):\n  """"""Wraps the ops generated by `op_fn` in tf.while_loop.""""""\n\n  def cond(scalar_stopping_signal):\n    return math_ops.logical_not(\n        _StopSignals.should_stop(scalar_stopping_signal))\n\n  def computation(unused_scalar_stopping_signal):\n    return_value = op_fn()\n    execute_ops = return_value[\'ops\']\n    signals = return_value[\'signals\']\n    with ops.control_dependencies(execute_ops):\n      return _StopSignals.as_scalar_stopping_signal(signals)\n\n  # By setting parallel_iterations=1, the parallel execution in while_loop is\n  # basically turned off.\n  with ops.device(device):\n    return control_flow_ops.while_loop(\n        cond,\n        computation, [_StopSignals.NON_STOPPING_SIGNAL],\n        parallel_iterations=1)\n\n\ndef _validate_tpu_training_graph():\n  """"""Validate graph before running distributed training.\n\n  Raises:\n    ValueError: If the graph seems invalid for running on device\n  """"""\n  operations = ops.get_default_graph().get_operations()\n\n  # Check if there is atleast one CrossReplicaSum operation in the graph\n  # This should be introduced by using the CrossShardOptimizer wrapper\n  cross_replica_sum_ops = [\n      o for o in operations if o.type == _CROSS_REPLICA_SUM_OP\n  ]\n  if not cross_replica_sum_ops:\n    raise ValueError(\n        \'CrossShardOptimizer must be used for model training on TPUs.\')\n\n\nclass _CapturedObject(object):\n  """"""A placeholder to capture an object.\n\n  This is useful when we need to capture a Python object in the Tensorflow\n  control flow body function and use it outside the control flow.\n  """"""\n\n  def __init__(self):\n    self._object = None\n    self._captured = False\n\n  def capture(self, o):\n    if self._captured:\n      raise RuntimeError(\n          \'InternalError: Object can capture only once. Please file bug.\')\n\n    self._captured = True\n    self._object = o\n\n  def get(self):\n    if not self._captured:\n      raise RuntimeError(\n          \'InternalError: Object is not captured properly before `get`. \'\n          \'Please file bug.\')\n    return self._object\n\n\ndef _get_scaffold(captured_scaffold_fn):\n  """"""Retrieves the Scaffold from `captured_scaffold_fn`.""""""\n  with _CapturingContext(message=\'Inside scaffold_fn\'):\n    scaffold_fn = captured_scaffold_fn.get()\n    if scaffold_fn:\n      scaffold = scaffold_fn()\n      if scaffold is None:\n        raise ValueError(\n            \'TPUEstimatorSpec.scaffold_fn returns None, which is not allowed\')\n    else:\n      scaffold = None\n\n  if scaffold:\n    wrapped_finalize = scaffold.finalize\n\n    def _finalize():\n      with _CapturingContext(\'Inside Scaffold.finalize\'):\n        wrapped_finalize()\n\n    scaffold.finalize = _finalize\n  return scaffold\n\n\nclass _CapturingContext(control_flow_ops.ControlFlowContext):\n  """"""Tracks references to Tensors defined in TPU replication.""""""\n\n  def __init__(self, message):\n    control_flow_ops.ControlFlowContext.__init__(self)\n    self._message = message\n\n  def to_control_flow_context_def(self, context_def, export_scope=None):\n    # pylint: disable=useless-super-delegation\n    # NOTE(slebedev): the method is required by `ControlFlowContext`.\n    super(_CapturingContext, self).to_control_flow_context_def(\n        context_def, export_scope)\n\n  def AddOp(self, op):  # pylint: disable=invalid-name\n    for c in op.inputs:\n      if tpu._TPU_REPLICATE_ATTR in c.op.node_def.attr:  # pylint: disable=protected-access\n        raise ValueError(\'{}: Op {} depends on TPU computation {}, \'\n                         \'which is not allowed.\'.format(self._message, op, c))\n\n  def __enter__(self):\n    # pylint: disable=protected-access\n    self._g = ops.get_default_graph()\n    self._old = self._g._get_control_flow_context()\n    self._g._set_control_flow_context(self)\n    # pylint: enable=protected-access\n\n  def __exit__(self, _, __, ___):  # pylint: disable=invalid-name\n    self._g._set_control_flow_context(self._old)  # pylint: disable=protected-access\n\n\nclass _Inputs(object):\n  """"""A data structure representing the input_fn returned values.\n\n  This also supports the returned value from input_fn as `Dataset`.\n  """"""\n\n  def __init__(self, features=None, labels=None, dataset=None, signals=None):\n    if dataset is not None and (features is not None or labels is not None or\n                                signals is not None):\n      raise RuntimeError(\'Internal Error: Either (features and labels) or \'\n                         \'dataset should be provided, not both. Please file \'\n                         \'bug\')\n\n    self._features = features\n    self._labels = labels\n    self._signals = signals\n\n    self._dataset = dataset\n    self._iterator = None\n\n  @staticmethod\n  def from_input_fn(return_values):\n    """"""Returns an `_Inputs` instance according to `input_fn` return value.""""""\n    if isinstance(return_values, dataset_ops.DatasetV2):\n      dataset = return_values\n      return _Inputs(dataset=dataset)\n\n    features, labels = _Inputs._parse_inputs(return_values)\n    return _Inputs(features, labels)\n\n  @staticmethod\n  def _parse_inputs(return_values):\n    if isinstance(return_values, tuple):\n      features, labels = return_values\n    else:\n      features, labels = return_values, None\n    return features, labels\n\n  @property\n  def is_dataset(self):\n    """"""Returns True if the return value from input_fn is Dataset.""""""\n    return self._dataset is not None\n\n  def dataset_initializer(self):\n    """"""Returns the dataset\'s initializer.\n\n    The initializer must be run before calling `features_and_labels`.\n    """"""\n    self._iterator = dataset_ops.make_initializable_iterator(self._dataset)\n    return self._iterator.initializer\n\n  def features_and_labels(self):\n    """"""Gets `features` and `labels`.""""""\n    if self.is_dataset:\n      if self._iterator is None:\n        raise RuntimeError(\'Internal error: Must run dataset_initializer \'\n                           \'before calling features_and_labels(). Please file \'\n                           \'a bug!\')\n      return _Inputs._parse_inputs(self._iterator.get_next())\n\n    return (self._features, self._labels)\n\n  def signals(self):\n    return self._signals\n\n  @property\n  def dataset(self):\n    return self._dataset\n\n\nclass _InputsWithStoppingSignals(_Inputs):\n  """"""Inputs with `_StopSignals` inserted into the dataset.""""""\n\n  def __init__(self,\n               dataset,\n               batch_size,\n               add_padding=False,\n               num_invocations_per_step=1):\n\n    assert dataset is not None\n    user_provided_dataset = dataset.map(\n        _InputsWithStoppingSignals.insert_stopping_signal(\n            stop=False, batch_size=batch_size, add_padding=add_padding))\n    if num_invocations_per_step == 1:\n      final_batch_dataset = dataset.take(1).map(\n          _InputsWithStoppingSignals.insert_stopping_signal(\n              stop=True, batch_size=batch_size, add_padding=add_padding))\n    else:\n      # We append (2 * num_invocations_per_step - 1) batches for exhausting the\n      # user_provided_dataset and stop properly.\n      # For example, if num_invocations_per_step is 2, we append 3 additional\n      # padding batches: b1, b2, b3.\n      # If user_provided_dataset contains two batches: a1, a2\n      # Step 1: [a1, a2]\n      # Step 2: [b1, b2] -> STOP\n      # If user_provided_dataset contains three batches: a1, a2, a3.\n      # The training loops:\n      # Step 1: [a1, a2]\n      # Step 2: [a3, b1]\n      # Step 3: [b2, b3] -> STOP.\n      final_batch_dataset = dataset.take(1).map(\n          _InputsWithStoppingSignals.insert_stopping_signal(\n              stop=True, batch_size=batch_size, add_padding=add_padding))\n      final_batch_dataset = final_batch_dataset.repeat(\n          2 * num_invocations_per_step - 1)\n\n      def _set_mask(data_dict):\n        signals = data_dict[\'signals\']\n        signals[\'padding_mask\'] = array_ops.ones_like(signals[\'padding_mask\'])\n        data_dict[\'signals\'] = signals\n        return data_dict\n\n      # Mask out the extra batch.\n      final_batch_dataset = final_batch_dataset.map(_set_mask)\n\n    dataset = user_provided_dataset.concatenate(final_batch_dataset).prefetch(2)\n\n    super(_InputsWithStoppingSignals, self).__init__(dataset=dataset)\n    self._current_inputs = None\n\n  def features_and_labels(self):\n    if self._current_inputs is not None:\n      raise RuntimeError(\n          \'Internal Error: The previous inputs have not been properly \'\n          \'consumed. First call features_and_labels, then call signals.\')\n\n    inputs_with_signals = self._iterator.get_next()\n    features = inputs_with_signals[\'features\']\n    labels = inputs_with_signals.get(\'labels\')\n\n    self._current_inputs = inputs_with_signals\n    return features, labels\n\n  def signals(self):\n    """"""Returns the `Signals` from `_Inputs`.""""""\n    if self._current_inputs is None:\n      raise RuntimeError(\n          \'Internal Error: The current inputs have not been properly \'\n          \'generated. First call features_and_labels, then call signals.\')\n    signals = self._current_inputs[\'signals\']\n    self._current_inputs = None\n    return signals\n\n  @staticmethod\n  def insert_stopping_signal(stop, batch_size, add_padding=False):\n    """"""Inserts stopping_signal into dataset via _map_fn.\n\n    Here we change the data structure in the dataset, such that the return value\n    is a dictionary now and `features`, `labels`, and `signals` are three\n    distinguished keys in that dict. This provides a better structure, which\n    eases the process to decompose the inputs (see `features_and_labels`).\n\n    Args:\n      stop: bool, state of current stopping signals.\n      batch_size: int, batch size.\n      add_padding: bool, whether to pad the tensor to full batch size.\n\n    Returns:\n      A map_fn passed to dataset.map API.\n    """"""\n\n    def _map_fn(*args):\n      """"""The map fn to insert signals.""""""\n      if len(args) == 1:\n        # Unpack the single Tensor/dict argument as features. This is required\n        # for the input_fn returns no labels.\n        args = args[0]\n      features, labels = _Inputs._parse_inputs(args)\n      new_input_dict = {}\n\n      if add_padding:\n        padding_mask, features, labels = (\n            _PaddingSignals.pad_features_and_labels(features, labels,\n                                                    batch_size))\n\n        new_input_dict[\'features\'] = features\n        if labels is not None:\n          new_input_dict[\'labels\'] = labels\n\n      else:\n        new_input_dict[\'features\'] = features\n        if labels is not None:\n          new_input_dict[\'labels\'] = labels\n        padding_mask = None\n\n      new_input_dict[\'signals\'] = _StopSignals(\n          stop=stop, batch_size=batch_size,\n          padding_mask=padding_mask).as_dict()\n\n      return new_input_dict\n\n    return _map_fn\n\n\nclass _StopSignals(object):\n  """"""Signals class holding all logic to handle TPU stopping condition.""""""\n\n  NON_STOPPING_SIGNAL = False\n  STOPPING_SIGNAL = True\n\n  def __init__(self, stop, batch_size, padding_mask=None):\n    self._stop = stop\n    self._batch_size = batch_size\n    self._padding_mask = padding_mask\n\n  def as_dict(self):\n    """"""Returns the signals as Python dict.""""""\n    shape = [self._batch_size, 1]\n    dtype = dtypes.bool\n\n    if self._stop:\n      stopping = array_ops.ones(shape=shape, dtype=dtype)\n    else:\n      stopping = array_ops.zeros(shape=shape, dtype=dtype)\n\n    signals = {\'stopping\': stopping}\n    if self._padding_mask is not None:\n      signals[\'padding_mask\'] = self._padding_mask\n    return signals\n\n  @staticmethod\n  def as_scalar_stopping_signal(signals):\n    return array_ops.identity(signals[\'stopping\'][0][0])\n\n  @staticmethod\n  def should_stop(scalar_stopping_signal):\n    """"""Detects whether scalar_stopping_signal indicates stopping.""""""\n    if isinstance(scalar_stopping_signal, ops.Tensor):\n      # STOPPING_SIGNAL is a constant True. Here, the logical_and is just the TF\n      # way to express the bool check whether scalar_stopping_signal is True.\n      return math_ops.logical_and(scalar_stopping_signal,\n                                  _StopSignals.STOPPING_SIGNAL)\n    else:\n      # For non Tensor case, it is used in SessionRunHook. So, we cannot modify\n      # the graph anymore. Here, we use pure Python.\n      return bool(scalar_stopping_signal)\n\n\nclass _PaddingSignals(object):\n  """"""Signals class holding all logic to handle padding.""""""\n\n  @staticmethod\n  def pad_features_and_labels(features, labels, batch_size):\n    """"""Pads out the batch dimension of features and labels.""""""\n    real_batch_size = array_ops.shape(\n        _PaddingSignals._find_any_tensor(features))[0]\n\n    batch_size_tensor = constant_op.constant(batch_size, dtypes.int32)\n\n    check_greater = check_ops.assert_greater_equal(\n        batch_size_tensor,\n        real_batch_size,\n        data=(batch_size_tensor, real_batch_size),\n        message=\'The real batch size should not be greater than batch_size.\')\n\n    with ops.control_dependencies([check_greater]):\n      missing_count = batch_size_tensor - real_batch_size\n\n    def pad_single_tensor(tensor):\n      """"""Pads out the batch dimension of a tensor to the complete batch_size.""""""\n      rank = len(tensor.shape)\n      assert rank > 0\n      padding = array_ops.stack([[0, missing_count]] + [[0, 0]] * (rank - 1))\n      padded_shape = (batch_size,) + tuple(tensor.shape[1:])\n      padded_tensor = array_ops.pad(tensor, padding)\n      padded_tensor.set_shape(padded_shape)\n      return padded_tensor\n\n    def nest_pad(tensor_or_dict):\n      return nest.map_structure(pad_single_tensor, tensor_or_dict)\n\n    features = nest_pad(features)\n    if labels is not None:\n      labels = nest_pad(labels)\n\n    padding_mask = _PaddingSignals._padding_mask(real_batch_size, missing_count,\n                                                 batch_size)\n\n    return padding_mask, features, labels\n\n  @staticmethod\n  def slice_tensor_or_dict(tensor_or_dict, signals):\n    """"""Slice the real Tensors according to padding mask in signals.""""""\n\n    padding_mask = signals[\'padding_mask\']\n    batch_size = array_ops.shape(padding_mask)[0]\n\n    def verify_batch_size(tensor):\n      check_batch_size = math_ops.equal(batch_size, tensor.shape[0])\n      with ops.control_dependencies([check_batch_size]):\n        return array_ops.identity(tensor)\n\n    def slice_single_tensor(tensor):\n      rank = len(tensor.shape)\n      assert rank > 0\n      real_batch_size = batch_size - math_ops.reduce_sum(padding_mask)\n      return verify_batch_size(tensor)[0:real_batch_size]\n\n    # As we split the Tensors to all TPU cores and concat them back, it is\n    # important to ensure the real data is placed before padded ones, i.e.,\n    # order is preserved. By that, the sliced padding mask should have all 0\'s.\n    # If this assertion failed, # the slice logic here would not hold.\n    sliced_padding_mask = slice_single_tensor(padding_mask)\n    assert_padding_mask = math_ops.equal(\n        math_ops.reduce_sum(sliced_padding_mask), 0)\n\n    with ops.control_dependencies([assert_padding_mask]):\n      should_stop = _StopSignals.should_stop(\n          _StopSignals.as_scalar_stopping_signal(signals))\n\n    is_full_batch = math_ops.equal(math_ops.reduce_sum(padding_mask), 0)\n\n    def slice_fn(tensor):\n      # If the current batch is full batch or part of stopping signals, we do\n      # not need to slice to save performance.\n      return control_flow_ops.cond(\n          math_ops.logical_or(should_stop, is_full_batch),\n          (lambda: verify_batch_size(tensor)),\n          (lambda: slice_single_tensor(tensor)))\n\n    return nest.map_structure(slice_fn, tensor_or_dict)\n\n  @staticmethod\n  def _find_any_tensor(batch_features):\n    tensors = [\n        x for x in nest.flatten(batch_features) if isinstance(x, ops.Tensor)\n    ]\n    if not tensors:\n      raise ValueError(\'Cannot find any Tensor in features dict.\')\n    return tensors[0]\n\n  @staticmethod\n  def _padding_mask(real_batch_size, missing_count, batch_size):\n    padding_mask = array_ops.concat([\n        array_ops.zeros((real_batch_size,), dtype=dtypes.int32),\n        array_ops.ones((missing_count,), dtype=dtypes.int32)\n    ],\n                                    axis=0)\n    padding_mask.set_shape((batch_size,))\n    return padding_mask\n\n\ndef _verify_cross_hosts_transfer_size(tensor_dict, message):\n  total_size = 0\n  tensor_structure = {}\n  for key, tensor in tensor_dict.items():\n    shape = tensor.shape\n    size = np.product(shape) * tensor.dtype.size\n    tensor_structure[key] = shape\n    total_size += size\n  if total_size >= _ONE_GIGABYTE:\n    raise ValueError(\n        \'{} The transfer size is larger than the protobuf limit. Please \'\n        \'consider to use Tensors with smaller shapes or reduce batch \'\n        \'size. Given:\\n\'\n        \'{}\'.format(\n            message, \'\\n\'.join([\n                \' -- Key: {}, Shape: {}\'.format(k, v)\n                for k, v in tensor_structure.items()\n            ])))\n\n\ndef _add_item_to_params(params, key, value):\n  """"""Adds a new item into `params`.""""""\n  if isinstance(params, hparam.HParams):\n    # For HParams, we need to use special API.\n    if key in params:\n      params.set_hparam(key, value)\n    else:\n      params.add_hparam(key, value)\n  else:\n    # Now params is Python dict.\n    params[key] = value\n\n\ndef export_estimator_savedmodel(estimator,\n                                export_dir_base,\n                                serving_input_receiver_fn,\n                                assets_extra=None,\n                                as_text=False,\n                                checkpoint_path=None,\n                                strip_default_attrs=False):\n  """"""Export `Estimator` trained model for TPU inference.\n\n  Args:\n    estimator: `Estimator` with which model has been trained.\n    export_dir_base: A string containing a directory in which to create\n      timestamped subdirectories containing exported SavedModels.\n    serving_input_receiver_fn: A function that takes no argument and returns a\n      `ServingInputReceiver` or `TensorServingInputReceiver`.\n    assets_extra: A dict specifying how to populate the assets.extra directory\n      within the exported SavedModel, or `None` if no extra assets are needed.\n    as_text: whether to write the SavedModel proto in text format.\n    checkpoint_path: The checkpoint path to export.  If `None` (the default),\n      the most recent checkpoint found within the model directory is chosen.\n    strip_default_attrs: Boolean. If `True`, default-valued attributes will be\n      removed from the NodeDefs.\n\n  Returns:\n    The string path to the exported directory.\n  """"""\n  # `TPUEstimator` requires `tpu_config.RunConfig`, so we cannot use\n  # `estimator.config`.\n  config = tpu_config.RunConfig(model_dir=estimator.model_dir)\n  est = TPUEstimator(\n      estimator._model_fn,  # pylint: disable=protected-access\n      config=config,\n      params=estimator.params,\n      use_tpu=True,\n      train_batch_size=2048,  # Does not matter.\n      eval_batch_size=2048,  # Does not matter.\n  )\n  return est.export_savedmodel(export_dir_base, serving_input_receiver_fn,\n                               assets_extra, as_text, checkpoint_path,\n                               strip_default_attrs)\n'"
baselines/models/xlnet/xlnet.py,8,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport json\nimport os\nimport tensorflow as tf\nimport modeling\n\n\ndef _get_initializer(FLAGS):\n  """"""Get variable intializer.""""""\n  if FLAGS.init == ""uniform"":\n    initializer = tf.initializers.random_uniform(\n        minval=-FLAGS.init_range,\n        maxval=FLAGS.init_range,\n        seed=None)\n  elif FLAGS.init == ""normal"":\n    initializer = tf.initializers.random_normal(\n        stddev=FLAGS.init_std,\n        seed=None)\n  else:\n    raise ValueError(""Initializer {} not supported"".format(FLAGS.init))\n  return initializer\n\n\nclass XLNetConfig(object):\n  """"""XLNetConfig contains hyperparameters that are specific to a model checkpoint;\n  i.e., these hyperparameters should be the same between\n  pretraining and finetuning.\n\n  The following hyperparameters are defined:\n    n_layer: int, the number of layers.\n    d_model: int, the hidden size.\n    n_head: int, the number of attention heads.\n    d_head: int, the dimension size of each attention head.\n    d_inner: int, the hidden size in feed-forward layers.\n    ff_activation: str, ""relu"" or ""gelu"".\n    untie_r: bool, whether to untie the biases in attention.\n    n_token: int, the vocab size.\n  """"""\n\n  def __init__(self, FLAGS=None, json_path=None):\n    """"""Constructing an XLNetConfig.\n    One of FLAGS or json_path should be provided.""""""\n\n    assert FLAGS is not None or json_path is not None\n\n    self.keys = [""n_layer"", ""d_model"", ""n_head"", ""d_head"", ""d_inner"",\n                 ""ff_activation"", ""untie_r"", ""n_token""]\n\n    if FLAGS is not None:\n      self.init_from_flags(FLAGS)\n\n    if json_path is not None:\n      self.init_from_json(json_path)\n\n  def init_from_flags(self, FLAGS):\n    for key in self.keys:\n      setattr(self, key, getattr(FLAGS, key))\n\n  def init_from_json(self, json_path):\n    with tf.gfile.Open(json_path) as f:\n      json_data = json.load(f)\n      for key in self.keys:\n        setattr(self, key, json_data[key])\n\n  def to_json(self, json_path):\n    """"""Save XLNetConfig to a json file.""""""\n    json_data = {}\n    for key in self.keys:\n      json_data[key] = getattr(self, key)\n\n    json_dir = os.path.dirname(json_path)\n    if not tf.gfile.Exists(json_dir):\n      tf.gfile.MakeDirs(json_dir)\n    with tf.gfile.Open(json_path, ""w"") as f:\n      json.dump(json_data, f, indent=4, sort_keys=True)\n\n\ndef create_run_config(is_training, is_finetune, FLAGS):\n  kwargs = dict(\n      is_training=is_training,\n      use_tpu=FLAGS.use_tpu,\n      use_bfloat16=FLAGS.use_bfloat16,\n      dropout=FLAGS.dropout,\n      dropatt=FLAGS.dropatt,\n      init=FLAGS.init,\n      init_range=FLAGS.init_range,\n      init_std=FLAGS.init_std,\n      clamp_len=FLAGS.clamp_len)\n\n  if not is_finetune:\n    kwargs.update(dict(\n        mem_len=FLAGS.mem_len,\n        reuse_len=FLAGS.reuse_len,\n        bi_data=FLAGS.bi_data,\n        clamp_len=FLAGS.clamp_len,\n        same_length=FLAGS.same_length))\n\n  return RunConfig(**kwargs)\n\n\nclass RunConfig(object):\n  """"""RunConfig contains hyperparameters that could be different\n  between pretraining and finetuning.\n  These hyperparameters can also be changed from run to run.\n  We store them separately from XLNetConfig for flexibility.\n  """"""\n\n  def __init__(self, is_training, use_tpu, use_bfloat16, dropout, dropatt,\n               init=""normal"", init_range=0.1, init_std=0.02, mem_len=None,\n               reuse_len=None, bi_data=False, clamp_len=-1, same_length=False):\n    """"""\n    Args:\n      is_training: bool, whether in training mode.\n      use_tpu: bool, whether TPUs are used.\n      use_bfloat16: bool, use bfloat16 instead of float32.\n      dropout: float, dropout rate.\n      dropatt: float, dropout rate on attention probabilities.\n      init: str, the initialization scheme, either ""normal"" or ""uniform"".\n      init_range: float, initialize the parameters with a uniform distribution\n        in [-init_range, init_range]. Only effective when init=""uniform"".\n      init_std: float, initialize the parameters with a normal distribution\n        with mean 0 and stddev init_std. Only effective when init=""normal"".\n      mem_len: int, the number of tokens to cache.\n      reuse_len: int, the number of tokens in the currect batch to be cached\n        and reused in the future.\n      bi_data: bool, whether to use bidirectional input pipeline.\n        Usually set to True during pretraining and False during finetuning.\n      clamp_len: int, clamp all relative distances larger than clamp_len.\n        -1 means no clamping.\n      same_length: bool, whether to use the same attention length for each token.\n    """"""\n\n    self.init = init\n    self.init_range = init_range\n    self.init_std = init_std\n    self.is_training = is_training\n    self.dropout = dropout\n    self.dropatt = dropatt\n    self.use_tpu = use_tpu\n    self.use_bfloat16 = use_bfloat16\n    self.mem_len = mem_len\n    self.reuse_len = reuse_len\n    self.bi_data = bi_data\n    self.clamp_len = clamp_len\n    self.same_length = same_length\n\n\nclass XLNetModel(object):\n  """"""A wrapper of the XLNet model used during both pretraining and finetuning.""""""\n\n  def __init__(self, xlnet_config, run_config, input_ids, seg_ids, input_mask,\n               mems=None, perm_mask=None, target_mapping=None, inp_q=None,\n               **kwargs):\n    """"""\n    Args:\n      xlnet_config: XLNetConfig,\n      run_config: RunConfig,\n      input_ids: int32 Tensor in shape [len, bsz], the input token IDs.\n      seg_ids: int32 Tensor in shape [len, bsz], the input segment IDs.\n      input_mask: float32 Tensor in shape [len, bsz], the input mask.\n        0 for real tokens and 1 for padding.\n      mems: a list of float32 Tensors in shape [mem_len, bsz, d_model], memory\n        from previous batches. The length of the list equals n_layer.\n        If None, no memory is used.\n      perm_mask: float32 Tensor in shape [len, len, bsz].\n        If perm_mask[i, j, k] = 0, i attend to j in batch k;\n        if perm_mask[i, j, k] = 1, i does not attend to j in batch k.\n        If None, each position attends to all the others.\n      target_mapping: float32 Tensor in shape [num_predict, len, bsz].\n        If target_mapping[i, j, k] = 1, the i-th predict in batch k is\n        on the j-th token.\n        Only used during pretraining for partial prediction.\n        Set to None during finetuning.\n      inp_q: float32 Tensor in shape [len, bsz].\n        1 for tokens with losses and 0 for tokens without losses.\n        Only used during pretraining for two-stream attention.\n        Set to None during finetuning.\n    """"""\n\n    initializer = _get_initializer(run_config)\n\n    tfm_args = dict(\n        n_token=xlnet_config.n_token,\n        initializer=initializer,\n        attn_type=""bi"",\n        n_layer=xlnet_config.n_layer,\n        d_model=xlnet_config.d_model,\n        n_head=xlnet_config.n_head,\n        d_head=xlnet_config.d_head,\n        d_inner=xlnet_config.d_inner,\n        ff_activation=xlnet_config.ff_activation,\n        untie_r=xlnet_config.untie_r,\n\n        is_training=run_config.is_training,\n        use_bfloat16=run_config.use_bfloat16,\n        use_tpu=run_config.use_tpu,\n        dropout=run_config.dropout,\n        dropatt=run_config.dropatt,\n\n        mem_len=run_config.mem_len,\n        reuse_len=run_config.reuse_len,\n        bi_data=run_config.bi_data,\n        clamp_len=run_config.clamp_len,\n        same_length=run_config.same_length\n    )\n\n    input_args = dict(\n        inp_k=input_ids,\n        seg_id=seg_ids,\n        input_mask=input_mask,\n        mems=mems,\n        perm_mask=perm_mask,\n        target_mapping=target_mapping,\n        inp_q=inp_q)\n    tfm_args.update(input_args)\n\n    with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n      (self.output, self.new_mems, self.lookup_table\n          ) = modeling.transformer_xl(**tfm_args)\n\n    self.input_mask = input_mask\n    self.initializer = initializer\n    self.xlnet_config = xlnet_config\n    self.run_config = run_config\n\n  def get_pooled_out(self, summary_type, use_summ_proj=True):\n    """"""\n    Args:\n      summary_type: str, ""last"", ""first"", ""mean"", or ""attn"". The method\n        to pool the input to get a vector representation.\n      use_summ_proj: bool, whether to use a linear projection during pooling.\n\n    Returns:\n      float32 Tensor in shape [bsz, d_model], the pooled representation.\n    """"""\n\n    xlnet_config = self.xlnet_config\n    run_config = self.run_config\n\n    with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n      summary = modeling.summarize_sequence(\n          summary_type=summary_type,\n          hidden=self.output,\n          d_model=xlnet_config.d_model,\n          n_head=xlnet_config.n_head,\n          d_head=xlnet_config.d_head,\n          dropout=run_config.dropout,\n          dropatt=run_config.dropatt,\n          is_training=run_config.is_training,\n          input_mask=self.input_mask,\n          initializer=self.initializer,\n          use_proj=use_summ_proj)\n\n    return summary\n\n  def get_sequence_output(self):\n    """"""\n    Returns:\n      float32 Tensor in shape [len, bsz, d_model]. The last layer hidden\n      representation of XLNet.\n    """"""\n\n    return self.output\n\n  def get_new_memory(self):\n    """"""\n    Returns:\n      list of float32 Tensors in shape [mem_len, bsz, d_model], the new\n      memory that concatenates the previous memory with the current input\n      representations.\n      The length of the list equals n_layer.\n    """"""\n    return self.new_mems\n\n  def get_embedding_table(self):\n    """"""\n    Returns:\n      float32 Tensor in shape [n_token, d_model]. The embedding lookup table.\n      Used for tying embeddings between input and output layers.\n    """"""\n    return self.lookup_table\n\n  def get_initializer(self):\n    """"""\n    Returns:\n      A tf initializer. Used to initialize variables in layers on top of XLNet.\n    """"""\n    return self.initializer\n\n'"
baselines/models_pytorch/classifier_pytorch/convert_albert_original_tf_checkpoint_to_pytorch.py,0,"b'""""""Convert ALBERT checkpoint.""""""\r\n\r\nfrom __future__ import absolute_import\r\nfrom __future__ import division\r\nfrom __future__ import print_function\r\n\r\nimport argparse\r\nimport torch\r\n\r\nfrom transformers.modeling_albert import BertConfig, AlbertForPreTraining, load_tf_weights_in_albert\r\n\r\nimport logging\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\ndef convert_tf_checkpoint_to_pytorch(tf_checkpoint_path, bert_config_file, pytorch_dump_path):\r\n    # Initialise PyTorch model\r\n    config = BertConfig.from_json_file(bert_config_file)\r\n    print(""Building PyTorch model from configuration: {}"".format(str(config)))\r\n    model = AlbertForPreTraining(config)\r\n\r\n    # Load weights from tf checkpoint\r\n    load_tf_weights_in_albert(model, config, tf_checkpoint_path)\r\n\r\n    # Save pytorch-model\r\n    print(""Save PyTorch model to {}"".format(pytorch_dump_path))\r\n    torch.save(model.state_dict(), pytorch_dump_path)\r\n\r\n\r\nif __name__ == ""__main__"":\r\n    parser = argparse.ArgumentParser()\r\n    ## Required parameters\r\n    parser.add_argument(""--tf_checkpoint_path"",\r\n                        default = None,\r\n                        type = str,\r\n                        required = True,\r\n                        help = ""Path to the TensorFlow checkpoint path."")\r\n    parser.add_argument(""--bert_config_file"",\r\n                        default = None,\r\n                        type = str,\r\n                        required = True,\r\n                        help = ""The config json file corresponding to the pre-trained ALBERT model. \\n""\r\n                            ""This specifies the model architecture."")\r\n    parser.add_argument(""--pytorch_dump_path"",\r\n                        default = None,\r\n                        type = str,\r\n                        required = True,\r\n                        help = ""Path to the output PyTorch model."")\r\n    args = parser.parse_args()\r\n    convert_tf_checkpoint_to_pytorch(args.tf_checkpoint_path,\r\n                                     args.bert_config_file,\r\n                                     args.pytorch_dump_path)\r\n\r\n\'\'\'\r\npython convert_albert_original_tf_checkpoint_to_pytorch.py \\\r\n    --tf_checkpoint_path=/home/lwt/NewDisk/chineseGLUE_pytorch/prev_trained_model/albert_tiny_tf \\\r\n    --bert_config_file=/home/lwt/NewDisk/chineseGLUE_pytorch/prev_trained_model/albert_tiny_tf/config.json \\\r\n    --pytorch_dump_path=/home/lwt/NewDisk/chineseGLUE_pytorch/prev_trained_model/albert_tiny/pytorch_model.bin\r\n\'\'\''"
baselines/models_pytorch/classifier_pytorch/convert_bert_original_tf_checkpoint_to_pytorch.py,0,"b'""""""Convert BERT checkpoint.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport argparse\nimport torch\n\nfrom transformers import BertConfig, BertForPreTraining, load_tf_weights_in_bert\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\ndef convert_tf_checkpoint_to_pytorch(tf_checkpoint_path, bert_config_file, pytorch_dump_path):\n    # Initialise PyTorch model\n    config = BertConfig.from_json_file(bert_config_file)\n    print(""Building PyTorch model from configuration: {}"".format(str(config)))\n    model = BertForPreTraining(config)\n\n    # Load weights from tf checkpoint\n    load_tf_weights_in_bert(model, config, tf_checkpoint_path)\n\n    # Save pytorch-model\n    print(""Save PyTorch model to {}"".format(pytorch_dump_path))\n    torch.save(model.state_dict(), pytorch_dump_path)\n\n\nif __name__ == ""__main__"":\n    parser = argparse.ArgumentParser()\n    ## Required parameters\n    parser.add_argument(""--tf_checkpoint_path"",\n                        default = None,\n                        type = str,\n                        required = True,\n                        help = ""Path to the TensorFlow checkpoint path."")\n    parser.add_argument(""--bert_config_file"",\n                        default = None,\n                        type = str,\n                        required = True,\n                        help = ""The config json file corresponding to the pre-trained BERT model. \\n""\n                            ""This specifies the model architecture."")\n    parser.add_argument(""--pytorch_dump_path"",\n                        default = None,\n                        type = str,\n                        required = True,\n                        help = ""Path to the output PyTorch model."")\n    args = parser.parse_args()\n    convert_tf_checkpoint_to_pytorch(args.tf_checkpoint_path,\n                                     args.bert_config_file,\n                                     args.pytorch_dump_path)\n'"
baselines/models_pytorch/classifier_pytorch/convert_ernie_original_pad_checkpoint_to_pytorch.py,0,"b'""""""Convert ERNIE checkpoint.""""""\n\nimport collections\nimport os\nimport sys\nimport numpy as np\nimport argparse\nimport paddle.fluid as fluid\nimport torch\nimport json\n\nif not os.path.exists(\'ERNIE\'):\n    os.system(\'git clone https://github.com/PaddlePaddle/ERNIE.git\')\nsys.path = [\'./ERNIE\'] + sys.path\ntry:\n    from model.ernie_v1 import ErnieConfig, ErnieModel\nexcept:\n    raise Exception(\'Place clone ERNIE first\')\n\n\ndef create_model(args, pyreader_name, ernie_config, is_prediction=False):\n    pyreader = fluid.layers.py_reader(\n        capacity=50,\n        shapes=[[-1, args.max_seq_len, 1], [-1, args.max_seq_len, 1],\n                [-1, args.max_seq_len, 1], [-1, args.max_seq_len, 1], [-1, 1],\n                [-1, 1],\n                [3, 1], [3]],\n        dtypes=[\'int64\', \'int64\', \'int64\', \'float32\', \'int64\', \'int64\', \'int64\', \'int64\'],\n        lod_levels=[0, 0, 0, 0, 0, 0, 0, 0],\n        name=pyreader_name,\n        use_double_buffer=True)\n\n    (src_ids, sent_ids, pos_ids, input_mask, labels, qids,\n     mlm_mask_label, mlm_mask_pos) = fluid.layers.read_file(pyreader)\n    ernie = ErnieModel(\n        src_ids=src_ids,\n        position_ids=pos_ids,\n        sentence_ids=sent_ids,\n        input_mask=input_mask,\n        config=ernie_config,\n        use_fp16=args.use_fp16\n    )\n    cls_feats = ernie.get_pooled_output()\n    cls_feats = fluid.layers.dropout(\n        x=cls_feats,\n        dropout_prob=0.1,\n        dropout_implementation=""upscale_in_train"")\n    logits = fluid.layers.fc(\n        input=cls_feats,\n        size=args.num_labels,\n        param_attr=fluid.ParamAttr(\n            name=""cls_out_w"",\n            initializer=fluid.initializer.TruncatedNormal(scale=0.02)),\n        bias_attr=fluid.ParamAttr(\n            name=""cls_out_b"", initializer=fluid.initializer.Constant(0.)))\n\n    ernie.get_pretraining_output(\n        mask_label=mlm_mask_label,\n        mask_pos=mlm_mask_pos,\n        labels=labels\n    )\n\n    if is_prediction:\n        probs = fluid.layers.softmax(logits)\n        feed_targets_name = [\n            src_ids.name, pos_ids.name, sent_ids.name, input_mask.name\n        ]\n        return pyreader, probs, feed_targets_name\n\n    ce_loss, probs = fluid.layers.softmax_with_cross_entropy(\n        logits=logits, label=labels, return_softmax=True)\n    loss = fluid.layers.mean(x=ce_loss)\n\n    if args.use_fp16 and args.loss_scaling > 1.0:\n        loss *= args.loss_scaling\n\n    num_seqs = fluid.layers.create_tensor(dtype=\'int64\')\n    accuracy = fluid.layers.accuracy(input=probs, label=labels, total=num_seqs)\n\n    graph_vars = {\n        ""loss"": loss,\n        ""probs"": probs,\n        ""accuracy"": accuracy,\n        ""labels"": labels,\n        ""num_seqs"": num_seqs,\n        ""qids"": qids\n    }\n\n    for k, v in graph_vars.items():\n        v.persistable = True\n\n    return pyreader, graph_vars\n\n\ndef if_exist(var):\n    return os.path.exists(os.path.join(args.init_pretraining_params, var.name))\n\n\ndef build_weight_map():\n    weight_map = collections.OrderedDict({\n        \'word_embedding\': \'bert.embeddings.word_embeddings.weight\',\n        \'pos_embedding\': \'bert.embeddings.position_embeddings.weight\',\n        \'sent_embedding\': \'bert.embeddings.token_type_embeddings.weight\',\n        \'pre_encoder_layer_norm_scale\': \'bert.embeddings.LayerNorm.gamma\',\n        \'pre_encoder_layer_norm_bias\': \'bert.embeddings.LayerNorm.beta\',\n    })\n\n    def add_w_and_b(ernie_pre, pytroch_pre):\n        weight_map[ernie_pre + "".w_0""] = pytroch_pre + "".weight""\n        weight_map[ernie_pre + "".b_0""] = pytroch_pre + "".bias""\n\n    def add_one_encoder_layer(layer_number):\n        # attention\n        add_w_and_b(f""encoder_layer_{layer_number}_multi_head_att_query_fc"",\n                    f""bert.encoder.layer.{layer_number}.attention.self.query"")\n        add_w_and_b(f""encoder_layer_{layer_number}_multi_head_att_key_fc"",\n                    f""bert.encoder.layer.{layer_number}.attention.self.key"")\n        add_w_and_b(f""encoder_layer_{layer_number}_multi_head_att_value_fc"",\n                    f""bert.encoder.layer.{layer_number}.attention.self.value"")\n        add_w_and_b(f""encoder_layer_{layer_number}_multi_head_att_output_fc"",\n                    f""bert.encoder.layer.{layer_number}.attention.output.dense"")\n        weight_map[f""encoder_layer_{layer_number}_post_att_layer_norm_bias""] = \\\n            f""bert.encoder.layer.{layer_number}.attention.output.LayerNorm.bias""\n        weight_map[f""encoder_layer_{layer_number}_post_att_layer_norm_scale""] = \\\n            f""bert.encoder.layer.{layer_number}.attention.output.LayerNorm.weight""\n        # intermediate\n        add_w_and_b(f""encoder_layer_{layer_number}_ffn_fc_0"", f""bert.encoder.layer.{layer_number}.intermediate.dense"")\n        # output\n        add_w_and_b(f""encoder_layer_{layer_number}_ffn_fc_1"", f""bert.encoder.layer.{layer_number}.output.dense"")\n        weight_map[f""encoder_layer_{layer_number}_post_ffn_layer_norm_bias""] = \\\n            f""bert.encoder.layer.{layer_number}.output.LayerNorm.bias""\n        weight_map[f""encoder_layer_{layer_number}_post_ffn_layer_norm_scale""] = \\\n            f""bert.encoder.layer.{layer_number}.output.LayerNorm.weight""\n\n    for i in range(12):\n        add_one_encoder_layer(i)\n    add_w_and_b(\'pooled_fc\', \'bert.pooler.dense\')\n\n    weight_map.update({\n        \'mask_lm_trans_fc.b_0\': \'cls.predictions.transform.dense.bias\',\n        \'mask_lm_trans_fc.w_0\': \'cls.predictions.transform.dense.weight\',\n        \'mask_lm_trans_layer_norm_scale\': \'cls.predictions.transform.LayerNorm.weight\',\n        \'mask_lm_trans_layer_norm_bias\': \'cls.predictions.transform.LayerNorm.bias\',\n        \'mask_lm_out_fc.b_0\': \'cls.predictions.bias\'\n    })\n\n    return weight_map\n\ndef extract_weights(args):\n    # add ERNIR to environment\n    print(\'extract weights start\'.center(60, \'=\'))\n    startup_prog = fluid.Program()\n    test_prog = fluid.Program()\n    place = fluid.CPUPlace()\n    exe = fluid.Executor(place)\n    exe.run(startup_prog)\n    args.max_seq_len = 512\n    args.use_fp16 = False\n    args.num_labels = 2\n    args.loss_scaling = 1.0\n    ernie_config = ErnieConfig(args.ernie_config_path)\n    ernie_config.print_config()\n    with fluid.program_guard(test_prog, startup_prog):\n        with fluid.unique_name.guard():\n            create_model(\n                args,\n                pyreader_name=\'train\',\n                ernie_config=ernie_config)\n    fluid.io.load_vars(exe, args.init_pretraining_params, main_program=test_prog, predicate=if_exist)\n    state_dict = collections.OrderedDict()\n    weight_map = build_weight_map()\n    for ernie_name, pytorch_name in weight_map.items():\n        fluid_tensor = fluid.global_scope().find_var(ernie_name).get_tensor()\n        fluid_array = np.array(fluid_tensor, dtype=np.float32)\n        if \'w_0\' in ernie_name:\n            fluid_array = fluid_array.transpose()\n        state_dict[pytorch_name] = fluid_array\n        print(f\'{ernie_name} -> {pytorch_name} {fluid_array.shape}\')\n    print(\'extract weights done!\'.center(60, \'=\'))\n    return state_dict\n\n\ndef save_model(state_dict, dump_path):\n    print(\'save model start\'.center(60, \'=\'))\n    if not os.path.exists(dump_path):\n        os.makedirs(dump_path)\n    # save model\n    for key in state_dict:\n        state_dict[key] = torch.FloatTensor(state_dict[key])\n    torch.save(state_dict, os.path.join(dump_path, ""pytorch_model.bin""))\n    print(\'finish save model\')\n    # save config\n    ernie_config = ErnieConfig(args.ernie_config_path)._config_dict\n    # set layer_norm_eps, more detail see: https://github.com/PaddlePaddle/LARK/issues/75\n    ernie_config[\'layer_norm_eps\'] = 1e-5\n    with open(os.path.join(dump_path, ""config.json""), \'wt\', encoding=\'utf-8\') as f:\n        json.dump(ernie_config, f, indent=4)\n    print(\'finish save config\')\n    # save vocab.txt\n    vocab_f = open(os.path.join(dump_path, ""vocab.txt""), ""wt"", encoding=\'utf-8\')\n    with open(""./ERNIE/config/vocab.txt"", ""rt"", encoding=\'utf-8\') as f:\n        for line in f:\n            data = line.strip().split(""\\t"")\n            vocab_f.writelines(data[0] + ""\\n"")\n    vocab_f.close()\n    print(\'finish save vocab\')\n    print(\'save model done!\'.center(60, \'=\'))\n\n\nif __name__ == ""__main__"":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(""--init_pretraining_params"", default=\'./ERNIE_1.0_max-len-512/params\', type=str, help=""."")\n    parser.add_argument(""--ernie_config_path"", default=\'./ERNIE_1.0_max-len-512/ernie_config.json\', type=str, help=""."")\n    parser.add_argument(""--output_dir"", default=\'./ERNIE-converted\', type=str, help=""."")\n    args = parser.parse_args()\n    state_dict = extract_weights(args)\n    save_model(state_dict, args.output_dir)'"
baselines/models_pytorch/classifier_pytorch/convert_xlnet_original_tf_checkpoint_to_pytorch.py,0,"b'""""""Convert XLNET checkpoint.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport argparse\nimport torch\n\nfrom transformers import (CONFIG_NAME, WEIGHTS_NAME,\n                        XLNetConfig,\n                        XLNetLMHeadModel,\n                        load_tf_weights_in_xlnet)\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\ndef convert_xlnet_checkpoint_to_pytorch(tf_checkpoint_path, bert_config_file, pytorch_dump_folder_path):\n    # Initialise PyTorch model\n    config = XLNetConfig.from_json_file(bert_config_file)\n\n    model = XLNetLMHeadModel(config)\n\n    # Load weights from tf checkpoint\n    load_tf_weights_in_xlnet(model, config, tf_checkpoint_path)\n\n    # Save pytorch-model\n    pytorch_weights_dump_path = os.path.join(pytorch_dump_folder_path, WEIGHTS_NAME)\n    pytorch_config_dump_path = os.path.join(pytorch_dump_folder_path, CONFIG_NAME)\n    print(""Save PyTorch model to {}"".format(os.path.abspath(pytorch_weights_dump_path)))\n    torch.save(model.state_dict(), pytorch_weights_dump_path)\n    print(""Save configuration file to {}"".format(os.path.abspath(pytorch_config_dump_path)))\n    with open(pytorch_config_dump_path, ""w"", encoding=""utf-8"") as f:\n        f.write(config.to_json_string())\n\n\nif __name__ == ""__main__"":\n    parser = argparse.ArgumentParser()\n    ## Required parameters\n    parser.add_argument(""--tf_checkpoint_path"",\n                        default = None,\n                        type = str,\n                        required = True,\n                        help = ""Path to the TensorFlow checkpoint path."")\n    parser.add_argument(""--xlnet_config_file"",\n                        default = None,\n                        type = str,\n                        required = True,\n                        help = ""The config json file corresponding to the pre-trained XLNet model. \\n""\n                               ""This specifies the model architecture."")\n    parser.add_argument(""--pytorch_dump_folder_path"",\n                        default = None,\n                        type = str,\n                        required = True,\n                        help = ""Path to the folder to store the PyTorch model or dataset/vocab."")\n    args = parser.parse_args()\n\n    convert_xlnet_checkpoint_to_pytorch(args.tf_checkpoint_path,\n                                        args.xlnet_config_file,\n                                        args.pytorch_dump_folder_path)\n'"
baselines/models_pytorch/classifier_pytorch/download_clue_data.py,0,"b'"""""" Script for downloading all CLUE data.\r\nFor licence information, see the original dataset information links\r\navailable from: https://www.cluebenchmarks.com/\r\nExample usage:\r\n  python download_clue_data.py --data_dir data --tasks all\r\n""""""\r\n\r\nimport os\r\nimport sys\r\nimport argparse\r\nimport urllib.request\r\nimport zipfile\r\n\r\nTASKS = [""afqmc"", ""cmnli"", ""copa"", ""csl"", ""iflytek"", ""tnews"", ""wsc"",""cmrc"",""chid"",""drcd""]\r\n\r\nTASK2PATH = {\r\n    ""afqmc"": ""https://storage.googleapis.com/cluebenchmark/tasks/afqmc_public.zip"",\r\n    ""cmnli"": ""https://storage.googleapis.com/cluebenchmark/tasks/cmnli_public.zip"",\r\n    ""copa"": ""https://storage.googleapis.com/cluebenchmark/tasks/copa_public.zip"",\r\n    ""csl"": ""https://storage.googleapis.com/cluebenchmark/tasks/csl_public.zip"",\r\n    ""iflytek"": ""https://storage.googleapis.com/cluebenchmark/tasks/iflytek_public.zip"",\r\n    ""tnews"": ""https://storage.googleapis.com/cluebenchmark/tasks/tnews_public.zip"",\r\n    ""wsc"": ""https://storage.googleapis.com/cluebenchmark/tasks/wsc_public.zip"",\r\n    \'cmrc\': ""https://storage.googleapis.com/cluebenchmark/tasks/cmrc2018_public.zip"",\r\n    ""chid"": ""https://storage.googleapis.com/cluebenchmark/tasks/chid_public.zip"",\r\n    ""drcd"": ""https://storage.googleapis.com/cluebenchmark/tasks/drcd_public.zip"",\r\n}\r\n\r\ndef download_and_extract(task, data_dir):\r\n    print(""Downloading and extracting %s..."" % task)\r\n    if not os.path.isdir(data_dir):\r\n        os.mkdir(data_dir)\r\n    data_file = os.path.join(data_dir, ""%s_public.zip"" % task)\r\n    save_dir = os.path.join(data_dir,task)\r\n    if not os.path.isdir(save_dir):\r\n        os.mkdir(save_dir)\r\n    urllib.request.urlretrieve(TASK2PATH[task], data_file)\r\n    with zipfile.ZipFile(data_file) as zip_ref:\r\n        zip_ref.extractall(save_dir)\r\n    os.remove(data_file)\r\n    print(f""\\tCompleted! Downloaded {task} data to directory {save_dir}"")\r\n\r\ndef get_tasks(task_names):\r\n    task_names = task_names.split("","")\r\n    if ""all"" in task_names:\r\n        tasks = TASKS\r\n    else:\r\n        tasks = []\r\n        for task_name in task_names:\r\n            assert task_name in TASKS, ""Task %s not found!"" % task_name\r\n            tasks.append(task_name)\r\n    return tasks\r\n\r\ndef main(arguments):\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument(\r\n        ""-d"", ""--data_dir"", help=""directory to save data to"", type=str, default=""./CLUEdatasets""\r\n    )\r\n    parser.add_argument(\r\n        ""-t"",\r\n        ""--tasks"",\r\n        help=""tasks to download data for as a comma separated string"",\r\n        type=str,\r\n        default=""all"",\r\n    )\r\n    args = parser.parse_args(arguments)\r\n\r\n    if not os.path.exists(args.data_dir):\r\n        os.mkdir(args.data_dir)\r\n    tasks = get_tasks(args.tasks)\r\n\r\n    for task in tasks:\r\n        download_and_extract(task, args.data_dir)\r\n\r\nif __name__ == ""__main__"":\r\n    sys.exit(main(sys.argv[1:]))'"
baselines/models_pytorch/classifier_pytorch/run_classifier.py,0,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-12-30 19:26:53\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2019-12-31 19:49:36\n"""""" Finetuning the library models for sequence classification on CLUE (Bert, ERNIE, XLNet, RoBERTa).""""""\n\nfrom __future__ import absolute_import, division, print_function\n\nimport argparse\nimport glob\nimport logging\nimport os\nimport json\nimport numpy as np\nimport torch\nfrom torch.utils.data import DataLoader, RandomSampler, SequentialSampler, TensorDataset\nfrom torch.utils.data.distributed import DistributedSampler\n\nfrom transformers import (WEIGHTS_NAME, BertConfig,\n                          BertForSequenceClassification, BertTokenizer,\n                          RobertaConfig, XLNetConfig,\n                          XLNetForSequenceClassification,\n                          XLNetTokenizer,\n                          AlbertForSequenceClassification)\n\nfrom transformers import AdamW, WarmupLinearSchedule\nfrom metrics.clue_compute_metrics import compute_metrics\nfrom processors import clue_output_modes as output_modes\nfrom processors import clue_processors as processors\nfrom processors import clue_convert_examples_to_features as convert_examples_to_features\nfrom processors import collate_fn, xlnet_collate_fn\nfrom tools.common import seed_everything, save_numpy\nfrom tools.common import init_logger, logger\nfrom tools.progressbar import ProgressBar\n\nALL_MODELS = sum((tuple(conf.pretrained_config_archive_map.keys()) for conf in (BertConfig, XLNetConfig,\n                                                                                RobertaConfig)), ())\nMODEL_CLASSES = {\n    ## bert ernie bert_wwm bert_wwwm_ext\n    \'bert\': (BertConfig, BertForSequenceClassification, BertTokenizer),\n    \'xlnet\': (XLNetConfig, XLNetForSequenceClassification, XLNetTokenizer),\n    \'roberta\': (BertConfig, BertForSequenceClassification, BertTokenizer),\n    \'albert\': (BertConfig, AlbertForSequenceClassification, BertTokenizer)\n}\n\n\ndef train(args, train_dataset, model, tokenizer):\n    """""" Train the model """"""\n    args.train_batch_size = args.per_gpu_train_batch_size * max(1, args.n_gpu)\n    train_sampler = RandomSampler(train_dataset) if args.local_rank == -1 else DistributedSampler(train_dataset)\n    train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size,\n                                  collate_fn=xlnet_collate_fn if args.model_type in [\'xlnet\'] else collate_fn)\n\n    if args.max_steps > 0:\n        t_total = args.max_steps\n        args.num_train_epochs = args.max_steps // (len(train_dataloader) // args.gradient_accumulation_steps) + 1\n    else:\n        t_total = len(train_dataloader) // args.gradient_accumulation_steps * args.num_train_epochs\n    args.warmup_steps = int(t_total * args.warmup_proportion)\n    # Prepare optimizer and schedule (linear warmup and decay)\n    no_decay = [\'bias\', \'LayerNorm.weight\']\n    optimizer_grouped_parameters = [\n        {\'params\': [p for n, p in model.named_parameters() if not any(nd in n for nd in no_decay)],\n         \'weight_decay\': args.weight_decay},\n        {\'params\': [p for n, p in model.named_parameters() if any(nd in n for nd in no_decay)], \'weight_decay\': 0.0}\n    ]\n    optimizer = AdamW(optimizer_grouped_parameters, lr=args.learning_rate, eps=args.adam_epsilon)\n    scheduler = WarmupLinearSchedule(optimizer, warmup_steps=args.warmup_steps, t_total=t_total)\n    if args.fp16:\n        try:\n            from apex import amp\n        except ImportError:\n            raise ImportError(""Please install apex from https://www.github.com/nvidia/apex to use fp16 training."")\n        model, optimizer = amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)\n\n    # multi-gpu training (should be after apex fp16 initialization)\n    if args.n_gpu > 1:\n        model = torch.nn.DataParallel(model)\n\n    # Distributed training (should be after apex fp16 initialization)\n    if args.local_rank != -1:\n        model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank],\n                                                          output_device=args.local_rank,\n                                                          find_unused_parameters=True)\n\n    # Train!\n    logger.info(""***** Running training *****"")\n    logger.info(""  Num examples = %d"", len(train_dataset))\n    logger.info(""  Num Epochs = %d"", args.num_train_epochs)\n    logger.info(""  Instantaneous batch size per GPU = %d"", args.per_gpu_train_batch_size)\n    logger.info(""  Total train batch size (w. parallel, distributed & accumulation) = %d"",\n                args.train_batch_size * args.gradient_accumulation_steps * (\n                    torch.distributed.get_world_size() if args.local_rank != -1 else 1))\n    logger.info(""  Gradient Accumulation steps = %d"", args.gradient_accumulation_steps)\n    logger.info(""  Total optimization steps = %d"", t_total)\n\n    global_step = 0\n    tr_loss, logging_loss = 0.0, 0.0\n    model.zero_grad()\n    seed_everything(args.seed)  # Added here for reproductibility (even between python 2 and 3)\n    for _ in range(int(args.num_train_epochs)):\n        pbar = ProgressBar(n_total=len(train_dataloader), desc=\'Training\')\n        for step, batch in enumerate(train_dataloader):\n            model.train()\n            batch = tuple(t.to(args.device) for t in batch)\n            inputs = {\'input_ids\': batch[0],\n                      \'attention_mask\': batch[1],\n                      \'labels\': batch[3]}\n            if args.model_type != \'distilbert\':\n                inputs[\'token_type_ids\'] = batch[2] if args.model_type in [\'bert\', \'xlnet\', \'albert\',\n                                                                           \'roberta\'] else None  # XLM, DistilBERT don\'t use segment_ids\n            outputs = model(**inputs)\n            loss = outputs[0]  # model outputs are always tuple in transformers (see doc)\n\n            if args.n_gpu > 1:\n                loss = loss.mean()  # mean() to average on multi-gpu parallel training\n            if args.gradient_accumulation_steps > 1:\n                loss = loss / args.gradient_accumulation_steps\n\n            if args.fp16:\n                with amp.scale_loss(loss, optimizer) as scaled_loss:\n                    scaled_loss.backward()\n                torch.nn.utils.clip_grad_norm_(amp.master_params(optimizer), args.max_grad_norm)\n            else:\n                loss.backward()\n                torch.nn.utils.clip_grad_norm_(model.parameters(), args.max_grad_norm)\n\n            pbar(step, {\'loss\': loss.item()})\n            tr_loss += loss.item()\n            if (step + 1) % args.gradient_accumulation_steps == 0:\n                optimizer.step()\n                scheduler.step()  # Update learning rate schedule\n                model.zero_grad()\n                global_step += 1\n\n                if args.local_rank in [-1, 0] and args.logging_steps > 0 and global_step % args.logging_steps == 0:\n                    print("" "")\n                    # Log metrics\n                    if args.local_rank == -1:  # Only evaluate when single GPU otherwise metrics may not average well\n                        evaluate(args, model, tokenizer)\n\n                if args.local_rank in [-1, 0] and args.save_steps > 0 and global_step % args.save_steps == 0:\n                    # Save model checkpoint\n                    output_dir = os.path.join(args.output_dir, \'checkpoint-{}\'.format(global_step))\n                    if not os.path.exists(output_dir):\n                        os.makedirs(output_dir)\n                    model_to_save = model.module if hasattr(model,\n                                                            \'module\') else model  # Take care of distributed/parallel training\n                    model_to_save.save_pretrained(output_dir)\n                    torch.save(args, os.path.join(output_dir, \'training_args.bin\'))\n                    logger.info(""Saving model checkpoint to %s"", output_dir)\n                    tokenizer.save_vocabulary(vocab_path=output_dir)\n        print("" "")\n        if \'cuda\' in str(args.device):\n            torch.cuda.empty_cache()\n    return global_step, tr_loss / global_step\n\n\ndef evaluate(args, model, tokenizer, prefix=""""):\n    eval_task_names = (args.task_name,)\n    eval_outputs_dirs = (args.output_dir,)\n    results = {}\n    for eval_task, eval_output_dir in zip(eval_task_names, eval_outputs_dirs):\n        eval_dataset = load_and_cache_examples(args, eval_task, tokenizer, data_type=\'dev\')\n        if not os.path.exists(eval_output_dir) and args.local_rank in [-1, 0]:\n            os.makedirs(eval_output_dir)\n\n        args.eval_batch_size = args.per_gpu_eval_batch_size * max(1, args.n_gpu)\n        # Note that DistributedSampler samples randomly\n        eval_sampler = SequentialSampler(eval_dataset) if args.local_rank == -1 else DistributedSampler(eval_dataset)\n        eval_dataloader = DataLoader(eval_dataset, sampler=eval_sampler, batch_size=args.eval_batch_size,\n                                     collate_fn=xlnet_collate_fn if args.model_type in [\'xlnet\'] else collate_fn)\n\n        # Eval!\n        logger.info(""********* Running evaluation {} ********"".format(prefix))\n        eval_loss = 0.0\n        nb_eval_steps = 0\n        preds = None\n        out_label_ids = None\n        pbar = ProgressBar(n_total=len(eval_dataloader), desc=""Evaluating"")\n        for step, batch in enumerate(eval_dataloader):\n            model.eval()\n            batch = tuple(t.to(args.device) for t in batch)\n            with torch.no_grad():\n                inputs = {\'input_ids\': batch[0],\n                          \'attention_mask\': batch[1],\n                          \'labels\': batch[3]}\n                if args.model_type != \'distilbert\':\n                    inputs[\'token_type_ids\'] = batch[2] if args.model_type in [\'bert\', \'xlnet\', \'albert\',\n                                                                               \'roberta\'] else None  # XLM, DistilBERT and RoBERTa don\'t use segment_ids\n                outputs = model(**inputs)\n                tmp_eval_loss, logits = outputs[:2]\n                eval_loss += tmp_eval_loss.mean().item()\n            nb_eval_steps += 1\n            if preds is None:\n                preds = logits.detach().cpu().numpy()\n                out_label_ids = inputs[\'labels\'].detach().cpu().numpy()\n            else:\n                preds = np.append(preds, logits.detach().cpu().numpy(), axis=0)\n                out_label_ids = np.append(out_label_ids, inputs[\'labels\'].detach().cpu().numpy(), axis=0)\n            pbar(step)\n        print(\' \')\n        if \'cuda\' in str(args.device):\n            torch.cuda.empty_cache()\n        eval_loss = eval_loss / nb_eval_steps\n        if args.output_mode == ""classification"":\n            preds = np.argmax(preds, axis=1)\n        elif args.output_mode == ""regression"":\n            preds = np.squeeze(preds)\n        result = compute_metrics(eval_task, preds, out_label_ids)\n        results.update(result)\n        logger.info(""  Num examples = %d"", len(eval_dataset))\n        logger.info(""  Batch size = %d"", args.eval_batch_size)\n        logger.info(""******** Eval results {} ********"".format(prefix))\n        for key in sorted(result.keys()):\n            logger.info("" dev: %s = %s"", key, str(result[key]))\n    return results\n\n\ndef predict(args, model, tokenizer, label_list, prefix=""""):\n    pred_task_names = (args.task_name,)\n    pred_outputs_dirs = (args.output_dir,)\n    label_map = {i: label for i, label in enumerate(label_list)}\n\n    for pred_task, pred_output_dir in zip(pred_task_names, pred_outputs_dirs):\n        pred_dataset = load_and_cache_examples(args, pred_task, tokenizer, data_type=\'test\')\n        if not os.path.exists(pred_output_dir) and args.local_rank in [-1, 0]:\n            os.makedirs(pred_output_dir)\n\n        args.pred_batch_size = args.per_gpu_eval_batch_size * max(1, args.n_gpu)\n        # Note that DistributedSampler samples randomly\n        pred_sampler = SequentialSampler(pred_dataset) if args.local_rank == -1 else DistributedSampler(pred_dataset)\n        pred_dataloader = DataLoader(pred_dataset, sampler=pred_sampler, batch_size=args.pred_batch_size,\n                                     collate_fn=xlnet_collate_fn\n                                     if args.model_type in [\'xlnet\'] else collate_fn)\n\n        logger.info(""******** Running prediction {} ********"".format(prefix))\n        logger.info(""  Num examples = %d"", len(pred_dataset))\n        logger.info(""  Batch size = %d"", args.pred_batch_size)\n        nb_pred_steps = 0\n        preds = None\n        pbar = ProgressBar(n_total=len(pred_dataloader), desc=""Predicting"")\n        for step, batch in enumerate(pred_dataloader):\n            model.eval()\n            batch = tuple(t.to(args.device) for t in batch)\n            with torch.no_grad():\n                inputs = {\'input_ids\': batch[0],\n                          \'attention_mask\': batch[1],\n                          \'labels\': batch[3]}\n                if args.model_type != \'distilbert\':\n                    inputs[\'token_type_ids\'] = batch[2] if (\n                            \'bert\' in args.model_type or \'xlnet\' in args.model_type) else None  # XLM, DistilBERT and RoBERTa don\'t use segment_ids\n                outputs = model(**inputs)\n                _, logits = outputs[:2]\n            nb_pred_steps += 1\n            if preds is None:\n                if pred_task == \'copa\':\n                    preds = logits.softmax(-1).detach().cpu().numpy()\n                else:\n                    preds = logits.detach().cpu().numpy()\n            else:\n                if pred_task == \'copa\':\n                    preds = np.append(preds, logits.softmax(-1).detach().cpu().numpy(), axis=0)\n                else:\n                    preds = np.append(preds, logits.detach().cpu().numpy(), axis=0)\n            pbar(step)\n        print(\' \')\n        if args.output_mode == ""classification"":\n            predict_label = np.argmax(preds, axis=1)\n        elif args.output_mode == ""regression"":\n            predict_label = np.squeeze(preds)\n        if pred_task == \'copa\':\n            predict_label = []\n            pred_logits = preds[:, 1]\n            i = 0\n            while (i < len(pred_logits) - 1):\n                if pred_logits[i] >= pred_logits[i + 1]:\n                    predict_label.append(0)\n                else:\n                    predict_label.append(1)\n                i += 2\n        output_submit_file = os.path.join(pred_output_dir, prefix, ""test_prediction.json"")\n        output_logits_file = os.path.join(pred_output_dir, prefix, ""test_logits"")\n        # \xe4\xbf\x9d\xe5\xad\x98\xe6\xa0\x87\xe7\xad\xbe\xe7\xbb\x93\xe6\x9e\x9c\n        with open(output_submit_file, ""w"") as writer:\n            for i, pred in enumerate(predict_label):\n                json_d = {}\n                json_d[\'id\'] = i\n                json_d[\'label\'] = str(label_map[pred])\n                writer.write(json.dumps(json_d) + \'\\n\')\n        # \xe4\xbf\x9d\xe5\xad\x98\xe4\xb8\xad\xe9\x97\xb4\xe9\xa2\x84\xe6\xb5\x8b\xe7\xbb\x93\xe6\x9e\x9c\n        save_numpy(file_path=output_logits_file, data=preds)\n\n\ndef load_and_cache_examples(args, task, tokenizer, data_type=\'train\'):\n    if args.local_rank not in [-1, 0] and not evaluate:\n        torch.distributed.barrier()  # Make sure only the first process in distributed training process the dataset, and the others will use the cache\n\n    processor = processors[task]()\n    output_mode = output_modes[task]\n    # Load data features from cache or dataset file\n    cached_features_file = os.path.join(args.data_dir, \'cached_{}_{}_{}_{}\'.format(\n        data_type,\n        list(filter(None, args.model_name_or_path.split(\'/\'))).pop(),\n        str(args.max_seq_length),\n        str(task)))\n    if os.path.exists(cached_features_file):\n        logger.info(""Loading features from cached file %s"", cached_features_file)\n        features = torch.load(cached_features_file)\n    else:\n        logger.info(""Creating features from dataset file at %s"", args.data_dir)\n        label_list = processor.get_labels()\n        if task in [\'mnli\', \'mnli-mm\'] and \'roberta\' in args.model_type:\n            # HACK(label indices are swapped in RoBERTa pretrained model)\n            label_list[1], label_list[2] = label_list[2], label_list[1]\n\n        if data_type == \'train\':\n            examples = processor.get_train_examples(args.data_dir)\n        elif data_type == \'dev\':\n            examples = processor.get_dev_examples(args.data_dir)\n        else:\n            examples = processor.get_test_examples(args.data_dir)\n\n        features = convert_examples_to_features(examples,\n                                                tokenizer,\n                                                label_list=label_list,\n                                                max_length=args.max_seq_length,\n                                                output_mode=output_mode,\n                                                pad_on_left=bool(args.model_type in [\'xlnet\']),\n                                                # pad on the left for xlnet\n                                                pad_token=tokenizer.convert_tokens_to_ids([tokenizer.pad_token])[0],\n                                                pad_token_segment_id=4 if args.model_type in [\'xlnet\'] else 0,\n                                                )\n        if args.local_rank in [-1, 0]:\n            logger.info(""Saving features into cached file %s"", cached_features_file)\n            torch.save(features, cached_features_file)\n\n    if args.local_rank == 0 and not evaluate:\n        torch.distributed.barrier()  # Make sure only the first process in distributed training process the dataset, and the others will use the cache\n    # Convert to Tensors and build dataset\n    all_input_ids = torch.tensor([f.input_ids for f in features], dtype=torch.long)\n    all_attention_mask = torch.tensor([f.attention_mask for f in features], dtype=torch.long)\n    all_token_type_ids = torch.tensor([f.token_type_ids for f in features], dtype=torch.long)\n    all_lens = torch.tensor([f.input_len for f in features], dtype=torch.long)\n    if output_mode == ""classification"":\n        all_labels = torch.tensor([f.label for f in features], dtype=torch.long)\n    elif output_mode == ""regression"":\n        all_labels = torch.tensor([f.label for f in features], dtype=torch.float)\n    dataset = TensorDataset(all_input_ids, all_attention_mask, all_token_type_ids, all_lens, all_labels)\n    return dataset\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n\n    ## Required parameters\n    parser.add_argument(""--data_dir"", default=None, type=str, required=True,\n                        help=""The input data dir. Should contain the .tsv files (or other data files) for the task."")\n    parser.add_argument(""--model_type"", default=None, type=str, required=True,\n                        help=""Model type selected in the list: "" + "", "".join(MODEL_CLASSES.keys()))\n    parser.add_argument(""--model_name_or_path"", default=None, type=str, required=True,\n                        help=""Path to pre-trained model or shortcut name selected in the list: "" + "", "".join(\n                            ALL_MODELS))\n    parser.add_argument(""--task_name"", default=None, type=str, required=True,\n                        help=""The name of the task to train selected in the list: "" + "", "".join(processors.keys()))\n    parser.add_argument(""--output_dir"", default=None, type=str, required=True,\n                        help=""The output directory where the model predictions and checkpoints will be written."")\n\n    ## Other parameters\n    parser.add_argument(""--config_name"", default="""", type=str,\n                        help=""Pretrained config name or path if not the same as model_name"")\n    parser.add_argument(""--tokenizer_name"", default="""", type=str,\n                        help=""Pretrained tokenizer name or path if not the same as model_name"")\n    parser.add_argument(""--cache_dir"", default="""", type=str,\n                        help=""Where do you want to store the pre-trained models downloaded from s3"")\n    parser.add_argument(""--max_seq_length"", default=128, type=int,\n                        help=""The maximum total input sequence length after tokenization. Sequences longer ""\n                             ""than this will be truncated, sequences shorter will be padded."")\n    parser.add_argument(""--do_train"", action=\'store_true\',\n                        help=""Whether to run training."")\n    parser.add_argument(""--do_eval"", action=\'store_true\',\n                        help=""Whether to run eval on the dev set."")\n    parser.add_argument(""--do_predict"", action=\'store_true\',\n                        help=""Whether to run the model in inference mode on the test set."")\n    parser.add_argument(""--do_lower_case"", action=\'store_true\',\n                        help=""Set this flag if you are using an uncased model."")\n\n    parser.add_argument(""--per_gpu_train_batch_size"", default=8, type=int,\n                        help=""Batch size per GPU/CPU for training."")\n    parser.add_argument(""--per_gpu_eval_batch_size"", default=8, type=int,\n                        help=""Batch size per GPU/CPU for evaluation."")\n    parser.add_argument(\'--gradient_accumulation_steps\', type=int, default=1,\n                        help=""Number of updates steps to accumulate before performing a backward/update pass."")\n    parser.add_argument(""--learning_rate"", default=5e-5, type=float,\n                        help=""The initial learning rate for Adam."")\n    parser.add_argument(""--weight_decay"", default=0.01, type=float,\n                        help=""Weight deay if we apply some."")\n    parser.add_argument(""--adam_epsilon"", default=1e-8, type=float,\n                        help=""Epsilon for Adam optimizer."")\n    parser.add_argument(""--max_grad_norm"", default=1.0, type=float,\n                        help=""Max gradient norm."")\n    parser.add_argument(""--num_train_epochs"", default=3.0, type=float,\n                        help=""Total number of training epochs to perform."")\n    parser.add_argument(""--max_steps"", default=-1, type=int,\n                        help=""If > 0: set total number of training steps to perform. Override num_train_epochs."")\n    parser.add_argument(""--warmup_proportion"", default=0.1, type=float,\n                        help=""Proportion of training to perform linear learning rate warmup for,E.g., 0.1 = 10% of training."")\n\n    parser.add_argument(\'--logging_steps\', type=int, default=10,\n                        help=""Log every X updates steps."")\n    parser.add_argument(\'--save_steps\', type=int, default=1000,\n                        help=""Save checkpoint every X updates steps."")\n    parser.add_argument(""--eval_all_checkpoints"", action=\'store_true\',\n                        help=""Evaluate all checkpoints starting with the same prefix as model_name ending and ending with step number"")\n    parser.add_argument(""--predict_checkpoints"", type=int, default=0,\n                        help=""predict checkpoints starting with the same prefix as model_name ending and ending with step number"")\n    parser.add_argument(""--no_cuda"", action=\'store_true\',\n                        help=""Avoid using CUDA when available"")\n    parser.add_argument(\'--overwrite_output_dir\', action=\'store_true\',\n                        help=""Overwrite the content of the output directory"")\n    parser.add_argument(\'--overwrite_cache\', action=\'store_true\',\n                        help=""Overwrite the cached training and evaluation sets"")\n    parser.add_argument(\'--seed\', type=int, default=42,\n                        help=""random seed for initialization"")\n\n    parser.add_argument(\'--fp16\', action=\'store_true\',\n                        help=""Whether to use 16-bit (mixed) precision (through NVIDIA apex) instead of 32-bit"")\n    parser.add_argument(\'--fp16_opt_level\', type=str, default=\'O1\',\n                        help=""For fp16: Apex AMP optimization level selected in [\'O0\', \'O1\', \'O2\', and \'O3\'].""\n                             ""See details at https://nvidia.github.io/apex/amp.html"")\n    parser.add_argument(""--local_rank"", type=int, default=-1,\n                        help=""For distributed training: local_rank"")\n    parser.add_argument(\'--server_ip\', type=str, default=\'\', help=""For distant debugging."")\n    parser.add_argument(\'--server_port\', type=str, default=\'\', help=""For distant debugging."")\n    args = parser.parse_args()\n\n    if not os.path.exists(args.output_dir):\n        os.mkdir(args.output_dir)\n    args.output_dir = args.output_dir + \'{}\'.format(args.model_type)\n    if not os.path.exists(args.output_dir):\n        os.mkdir(args.output_dir)\n    init_logger(log_file=args.output_dir + \'/{}-{}.log\'.format(args.model_type, args.task_name))\n    if os.path.exists(args.output_dir) and os.listdir(\n            args.output_dir) and args.do_train and not args.overwrite_output_dir:\n        raise ValueError(\n            ""Output directory ({}) already exists and is not empty. Use --overwrite_output_dir to overcome."".format(\n                args.output_dir))\n\n    # Setup distant debugging if needed\n    if args.server_ip and args.server_port:\n        # Distant debugging - see https://code.visualstudio.com/docs/python/debugging#_attach-to-a-local-script\n        import ptvsd\n        print(""Waiting for debugger attach"")\n        ptvsd.enable_attach(address=(args.server_ip, args.server_port), redirect_output=True)\n        ptvsd.wait_for_attach()\n\n    # Setup CUDA, GPU & distributed training\n    if args.local_rank == -1 or args.no_cuda:\n        device = torch.device(""cuda"" if torch.cuda.is_available() and not args.no_cuda else ""cpu"")\n        args.n_gpu = torch.cuda.device_count()\n    else:  # Initializes the distributed backend which will take care of sychronizing nodes/GPUs\n        torch.cuda.set_device(args.local_rank)\n        device = torch.device(""cuda"", args.local_rank)\n        torch.distributed.init_process_group(backend=\'nccl\')\n        args.n_gpu = 1\n    args.device = device\n\n    # Setup logging\n    logger.warning(""Process rank: %s, device: %s, n_gpu: %s, distributed training: %s, 16-bits training: %s"",\n                   args.local_rank, device, args.n_gpu, bool(args.local_rank != -1), args.fp16)\n\n    # Set seed\n    seed_everything(args.seed)\n    # Prepare CLUE task\n    args.task_name = args.task_name.lower()\n    if args.task_name not in processors:\n        raise ValueError(""Task not found: %s"" % (args.task_name))\n    processor = processors[args.task_name]()\n    args.output_mode = output_modes[args.task_name]\n    label_list = processor.get_labels()\n    num_labels = len(label_list)\n\n    # Load pretrained model and tokenizer\n    if args.local_rank not in [-1, 0]:\n        torch.distributed.barrier()  # Make sure only the first process in distributed training will download model & vocab\n\n    args.model_type = args.model_type.lower()\n    config_class, model_class, tokenizer_class = MODEL_CLASSES[args.model_type]\n    config = config_class.from_pretrained(args.config_name if args.config_name else args.model_name_or_path,\n                                          num_labels=num_labels, finetuning_task=args.task_name)\n    tokenizer = tokenizer_class.from_pretrained(args.tokenizer_name if args.tokenizer_name else args.model_name_or_path,\n                                                do_lower_case=args.do_lower_case)\n    model = model_class.from_pretrained(args.model_name_or_path, from_tf=bool(\'.ckpt\' in args.model_name_or_path),\n                                        config=config)\n\n    if args.local_rank == 0:\n        torch.distributed.barrier()  # Make sure only the first process in distributed training will download model & vocab\n    model.to(args.device)\n    logger.info(""Training/evaluation parameters %s"", args)\n    # Training\n    if args.do_train:\n        train_dataset = load_and_cache_examples(args, args.task_name, tokenizer, data_type=\'train\')\n        global_step, tr_loss = train(args, train_dataset, model, tokenizer)\n        logger.info("" global_step = %s, average loss = %s"", global_step, tr_loss)\n\n    # Saving best-practices: if you use defaults names for the model, you can reload it using from_pretrained()\n    if args.do_train and (args.local_rank == -1 or torch.distributed.get_rank() == 0):\n        # Create output directory if needed\n        if not os.path.exists(args.output_dir) and args.local_rank in [-1, 0]:\n            os.makedirs(args.output_dir)\n\n        logger.info(""Saving model checkpoint to %s"", args.output_dir)\n        # Save a trained model, configuration and tokenizer using `save_pretrained()`.\n        # They can then be reloaded using `from_pretrained()`\n        model_to_save = model.module if hasattr(model,\n                                                \'module\') else model  # Take care of distributed/parallel training\n        model_to_save.save_pretrained(args.output_dir)\n        tokenizer.save_pretrained(args.output_dir)\n\n        # Good practice: save your training arguments together with the trained model\n        torch.save(args, os.path.join(args.output_dir, \'training_args.bin\'))\n\n        # Load a trained model and vocabulary that you have fine-tuned\n        model = model_class.from_pretrained(args.output_dir)\n        tokenizer = tokenizer_class.from_pretrained(args.output_dir, do_lower_case=args.do_lower_case)\n        model.to(args.device)\n\n    # Evaluation\n    results = {}\n    if args.do_eval and args.local_rank in [-1, 0]:\n        tokenizer = tokenizer_class.from_pretrained(args.output_dir, do_lower_case=args.do_lower_case)\n        checkpoints = [args.output_dir]\n        if args.eval_all_checkpoints:\n            checkpoints = list(\n                os.path.dirname(c) for c in sorted(glob.glob(args.output_dir + \'/**/\' + WEIGHTS_NAME, recursive=True)))\n            logging.getLogger(""transformers.modeling_utils"").setLevel(logging.WARN)  # Reduce logging\n        logger.info(""Evaluate the following checkpoints: %s"", checkpoints)\n        for checkpoint in checkpoints:\n            global_step = checkpoint.split(\'-\')[-1] if len(checkpoints) > 1 else """"\n            prefix = checkpoint.split(\'/\')[-1] if checkpoint.find(\'checkpoint\') != -1 else """"\n            model = model_class.from_pretrained(checkpoint)\n            model.to(args.device)\n            result = evaluate(args, model, tokenizer, prefix=prefix)\n            result = dict((k + \'_{}\'.format(global_step), v) for k, v in result.items())\n            results.update(result)\n        output_eval_file = os.path.join(args.output_dir, ""checkpoint_eval_results.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            for key in sorted(results.keys()):\n                writer.write(""%s = %s\\n"" % (key, str(results[key])))\n\n    if args.do_predict and args.local_rank in [-1, 0]:\n        tokenizer = tokenizer_class.from_pretrained(args.output_dir, do_lower_case=args.do_lower_case)\n        checkpoints = [args.output_dir]\n        if args.predict_checkpoints > 0:\n            checkpoints = list(\n                os.path.dirname(c) for c in sorted(glob.glob(args.output_dir + \'/**/\' + WEIGHTS_NAME, recursive=True)))\n            logging.getLogger(""transformers.modeling_utils"").setLevel(logging.WARN)  # Reduce logging\n            checkpoints = [x for x in checkpoints if x.split(\'-\')[-1] == str(args.predict_checkpoints)]\n        logger.info(""Predict the following checkpoints: %s"", checkpoints)\n        for checkpoint in checkpoints:\n            prefix = checkpoint.split(\'/\')[-1] if checkpoint.find(\'checkpoint\') != -1 else """"\n            model = model_class.from_pretrained(checkpoint)\n            model.to(args.device)\n            predict(args, model, tokenizer, label_list, prefix=prefix)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
baselines/models_pytorch/mrc_pytorch/convert_tf_checkpoint_to_pytorch.py,2,"b'# coding=utf-8\n# Copyright 2018 The HugginFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Convert BERT checkpoint.""""""\n\nfrom __future__ import print_function\n\nimport argparse\nimport os\nimport re\n\nimport numpy as np\nimport tensorflow as tf\nimport torch\n\nfrom pytorch_modeling import BertConfig, BertForPreTraining, ALBertConfig, ALBertForPreTraining\n\n\ndef convert_tf_checkpoint_to_pytorch(tf_checkpoint_path, bert_config_file, pytorch_dump_path, is_albert):\n    config_path = os.path.abspath(bert_config_file)\n    tf_path = os.path.abspath(tf_checkpoint_path)\n    print(""Converting TensorFlow checkpoint from {} with config at {}"".format(tf_path, config_path))\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        print(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array)\n\n    # Initialise PyTorch model\n    if is_albert:\n        config = ALBertConfig.from_json_file(bert_config_file)\n        print(""Building PyTorch model from configuration: {}"".format(str(config)))\n        model = ALBertForPreTraining(config)\n    else:\n        config = BertConfig.from_json_file(bert_config_file)\n        print(""Building PyTorch model from configuration: {}"".format(str(config)))\n        model = BertForPreTraining(config)\n\n    for name, array in zip(names, arrays):\n        name = name.split(\'/\')\n        if name[0] == \'global_step\':\n            continue\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if any(n in [""adam_v"", ""adam_m""] for n in name):\n            print(""Skipping {}"".format(""/"".join(name)))\n            continue\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+_\\d+\', m_name):\n                l = re.split(r\'_(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'kernel\' or l[0] == \'gamma\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'output_bias\' or l[0] == \'beta\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'output_weights\':\n                pointer = getattr(pointer, \'weight\')\n            else:\n                pointer = getattr(pointer, l[0])\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        if m_name[-11:] == \'_embeddings\':\n            pointer = getattr(pointer, \'weight\')\n        elif m_name[-13:] == \'_embeddings_2\':\n            pointer = getattr(pointer, \'weight\')\n            array = np.transpose(array)\n        elif m_name == \'kernel\':\n            array = np.transpose(array)\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        print(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n\n    # Save pytorch-model\n    print(""Save PyTorch model to {}"".format(pytorch_dump_path))\n    torch.save(model.state_dict(), pytorch_dump_path)\n\n\nif __name__ == ""__main__"":\n    parser = argparse.ArgumentParser()\n    ## Required parameters\n    parser.add_argument(""--tf_checkpoint_path"",\n                        default=\'check_points/pretrain_models/albert_large_zh/albert_model.ckpt\',\n                        type=str,\n                        help=""Path the TensorFlow checkpoint path."")\n    parser.add_argument(""--bert_config_file"",\n                        default=\'check_points/pretrain_models/albert_large_zh/albert_config_large.json\',\n                        type=str,\n                        help=""The config json file corresponding to the pre-trained BERT model. \\n""\n                             ""This specifies the model architecture."")\n    parser.add_argument(""--pytorch_dump_path"",\n                        default=\'check_points/pretrain_models/albert_large_zh/pytorch_albert_model.pth\',\n                        type=str,\n                        help=""Path to the output PyTorch model."")\n    parser.add_argument(""--is_albert"",\n                        default=False,\n                        action=\'store_true\',\n                        type=bool,\n                        help=""whether is albert?"")\n    args = parser.parse_args()\n    convert_tf_checkpoint_to_pytorch(args.tf_checkpoint_path,\n                                     args.bert_config_file,\n                                     args.pytorch_dump_path,\n                                     args.is_albert)\n'"
baselines/models_pytorch/mrc_pytorch/google_albert_pytorch_modeling.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HugginFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch BERT model.""""""\nfrom __future__ import print_function\n\nimport copy\nimport json\nimport math\nimport logging\nimport six\n\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss\n\nlogger = logging.getLogger(__name__)\n\n\ndef gelu(x):\n    """"""Implementation of the gelu activation function.\n        For information: OpenAI GPT\'s gelu is slightly different (and gives slightly different results):\n        0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n    """"""\n    return x * 0.5 * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\n\ndef fast_gelu(x):\n    return x * torch.sigmoid(1.702 * x)\n\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT2FN = {""gelu"": fast_gelu, ""relu"": torch.relu, ""swish"": swish}\n\n\nclass AlbertConfig(object):\n    """"""Configuration for `AlbertModel`.\n    The default settings match the configuration of model `albert_xxlarge`.\n    """"""\n\n    def __init__(self,\n                 vocab_size,\n                 embedding_size=128,\n                 hidden_size=4096,\n                 num_hidden_layers=12,\n                 num_hidden_groups=1,\n                 num_attention_heads=64,\n                 intermediate_size=16384,\n                 inner_group_num=1,\n                 down_scale_factor=1,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0,\n                 attention_probs_dropout_prob=0,\n                 max_position_embeddings=512,\n                 type_vocab_size=2,\n                 initializer_range=0.02):\n        """"""Constructs AlbertConfig.\n        Args:\n          vocab_size: Vocabulary size of `inputs_ids` in `AlbertModel`.\n          embedding_size: size of voc embeddings.\n          hidden_size: Size of the encoder layers and the pooler layer.\n          num_hidden_layers: Number of hidden layers in the Transformer encoder.\n          num_hidden_groups: Number of group for the hidden layers, parameters in\n            the same group are shared.\n          num_attention_heads: Number of attention heads for each attention layer in\n            the Transformer encoder.\n          intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n            layer in the Transformer encoder.\n          inner_group_num: int, number of inner repetition of attention and ffn.\n          down_scale_factor: float, the scale to apply\n          hidden_act: The non-linear activation function (function or string) in the\n            encoder and pooler.\n          hidden_dropout_prob: The dropout probability for all fully connected\n            layers in the embeddings, encoder, and pooler.\n          attention_probs_dropout_prob: The dropout ratio for the attention\n            probabilities.\n          max_position_embeddings: The maximum sequence length that this model might\n            ever be used with. Typically set this to something large just in case\n            (e.g., 512 or 1024 or 2048).\n          type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n            `AlbertModel`.\n          initializer_range: The stdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n        """"""\n        self.vocab_size = vocab_size\n        self.embedding_size = embedding_size\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_hidden_groups = num_hidden_groups\n        self.num_attention_heads = num_attention_heads\n        self.inner_group_num = inner_group_num\n        self.down_scale_factor = down_scale_factor\n        self.hidden_act = hidden_act\n        self.intermediate_size = intermediate_size\n        self.hidden_dropout_prob = hidden_dropout_prob\n        self.attention_probs_dropout_prob = attention_probs_dropout_prob\n        self.max_position_embeddings = max_position_embeddings\n        self.type_vocab_size = type_vocab_size\n        self.initializer_range = initializer_range\n\n    @classmethod\n    def from_dict(cls, json_object):\n        """"""Constructs a `AlbertConfig` from a Python dictionary of parameters.""""""\n        config = AlbertConfig(vocab_size=None)\n        for (key, value) in six.iteritems(json_object):\n            config.__dict__[key] = value\n        return config\n\n    @classmethod\n    def from_json_file(cls, json_file):\n        """"""Constructs a `AlbertConfig` from a json file of parameters.""""""\n        with open(json_file, ""r"") as reader:\n            text = reader.read()\n        return cls.from_dict(json.loads(text))\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\ntry:\n    from apex.normalization.fused_layer_norm import FusedLayerNorm as BertLayerNorm\nexcept ImportError:\n    print(""Better speed can be achieved with apex installed from https://www.github.com/nvidia/apex."")\n\n\n    class BertLayerNorm(nn.Module):\n        def __init__(self, hidden_size, eps=1e-5):\n            """"""Construct a layernorm module in the TF style (epsilon inside the square root).\n            """"""\n            super(BertLayerNorm, self).__init__()\n            self.weight = nn.Parameter(torch.ones(hidden_size))\n            self.bias = nn.Parameter(torch.zeros(hidden_size))\n            self.variance_epsilon = eps\n\n        def forward(self, x):\n            u = x.mean(-1, keepdim=True)\n            s = (x - u).pow(2).mean(-1, keepdim=True)\n            x = (x - u) / torch.sqrt(s + self.variance_epsilon)\n            return self.weight * x + self.bias\n\n\nclass AlbertEmbeddings(nn.Module):\n    """""" Albert embeddings. """"""\n\n    def __init__(self, config):\n        super(AlbertEmbeddings, self).__init__()\n\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.embedding_size, padding_idx=0)\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.embedding_size)\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.embedding_size)\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\n        # any TensorFlow checkpoint file\n        self.LayerNorm = BertLayerNorm(config.embedding_size, eps=1e-5)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n        words_embeddings = self.word_embeddings(input_ids)\n        position_embeddings = self.position_embeddings(position_ids)\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\n\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\n        embeddings = self.LayerNorm(embeddings)\n        embeddings = self.dropout(embeddings)\n        return embeddings\n\n\nclass BertSelfAttention(nn.Module):\n    def __init__(self, config):\n        super(BertSelfAttention, self).__init__()\n        if config.hidden_size % config.num_attention_heads != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.hidden_size, config.num_attention_heads))\n        self.num_attention_heads = config.num_attention_heads\n        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)\n        self.all_head_size = self.num_attention_heads * self.attention_head_size\n\n        self.query = nn.Linear(config.hidden_size, self.all_head_size)\n        self.key = nn.Linear(config.hidden_size, self.all_head_size)\n        self.value = nn.Linear(config.hidden_size, self.all_head_size)\n\n    def transpose_for_scores(self, x):\n        new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size)\n        x = x.view(*new_x_shape)\n        return x.permute(0, 2, 1, 3)\n\n    def forward(self, hidden_states, attention_mask):\n        mixed_query_layer = self.query(hidden_states)\n        mixed_key_layer = self.key(hidden_states)\n        mixed_value_layer = self.value(hidden_states)\n\n        query_layer = self.transpose_for_scores(mixed_query_layer)\n        key_layer = self.transpose_for_scores(mixed_key_layer)\n        value_layer = self.transpose_for_scores(mixed_value_layer)\n\n        # Take the dot product between ""query"" and ""key"" to get the raw attention scores.\n        attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))\n        attention_scores = attention_scores / math.sqrt(self.attention_head_size)\n        # Apply the attention mask is (precomputed for all layers in BertModel forward() function)\n        attention_scores = attention_scores + attention_mask\n\n        # Normalize the attention scores to probabilities.\n        attention_probs = nn.Softmax(dim=-1)(attention_scores)\n\n        context_layer = torch.matmul(attention_probs, value_layer)\n        context_layer = context_layer.permute(0, 2, 1, 3).contiguous()\n        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)\n        context_layer = context_layer.view(*new_context_layer_shape)\n        return context_layer\n\n\nclass BertSelfOutput(nn.Module):\n    def __init__(self, config):\n        super(BertSelfOutput, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = hidden_states + input_tensor\n\n        return hidden_states\n\n\nclass BertAttention(nn.Module):\n    def __init__(self, config):\n        super(BertAttention, self).__init__()\n        self.self = BertSelfAttention(config)\n        self.output = BertSelfOutput(config)\n\n    def forward(self, input_tensor, attention_mask):\n        self_output = self.self(input_tensor, attention_mask)\n        attention_output = self.output(self_output, input_tensor)\n        return attention_output\n\n\nclass BertOutput(nn.Module):\n    def __init__(self, config):\n        super(BertOutput, self).__init__()\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = hidden_states + input_tensor\n        return hidden_states\n\n\nclass BertIntermediate(nn.Module):\n    def __init__(self, config):\n        super(BertIntermediate, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)\n        # if isinstance(config.hidden_act, str) else config.hidden_act\n        self.intermediate_act_fn = ACT2FN[config.hidden_act]\n        self.output = BertOutput(config)\n\n    def forward(self, input_tensor):\n        hidden_states = self.dense(input_tensor)\n        hidden_states = self.intermediate_act_fn(hidden_states)\n        hidden_output = self.output(hidden_states, input_tensor)\n        return hidden_output\n\n\nclass BertFF(nn.Module):\n    def __init__(self, config):\n        super(BertFF, self).__init__()\n        self.intermediate = BertIntermediate(config)\n\n    def forward(self, hidden_states):\n        hidden_states = self.intermediate(hidden_states)\n        return hidden_states\n\n\nclass AlbertLayer(nn.Module):\n    def __init__(self, config):\n        super(AlbertLayer, self).__init__()\n        self.attention_1 = BertAttention(config)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=1e-5)\n        self.ffn_1 = BertFF(config)\n        self.LayerNorm_1 = BertLayerNorm(config.hidden_size, eps=1e-5)\n\n    def forward(self, hidden_states, attention_mask):\n        attention_output = self.attention_1(hidden_states, attention_mask)\n        attention_output = self.LayerNorm(attention_output)\n        attention_output = self.ffn_1(attention_output)\n        attention_output = self.LayerNorm_1(attention_output)\n        return attention_output\n\n\nclass AlbertEncoder(nn.Module):\n    def __init__(self, config):\n        super(AlbertEncoder, self).__init__()\n        self.embedding_hidden_mapping_in = nn.Linear(config.embedding_size, config.hidden_size)\n        self.num_hidden_layers = config.num_hidden_layers\n        self.transformer = AlbertLayer(config)\n\n    def forward(self, hidden_states, attention_mask, output_all_encoded_layers=True):\n        hidden_states = self.embedding_hidden_mapping_in(hidden_states)\n        all_encoder_layers = []\n        for i in range(self.num_hidden_layers):\n            hidden_states = self.transformer(hidden_states, attention_mask)\n            if output_all_encoded_layers:\n                all_encoder_layers.append(hidden_states)\n        if not output_all_encoded_layers:\n            all_encoder_layers.append(hidden_states)\n        return all_encoder_layers\n\n\nclass BertPooler(nn.Module):\n    def __init__(self, config):\n        super(BertPooler, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.activation = nn.Tanh()\n\n    def forward(self, hidden_states):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token.\n        first_token_tensor = hidden_states[:, 0]\n        pooled_output = self.dense(first_token_tensor)\n        pooled_output = self.activation(pooled_output)\n        return pooled_output\n\n\nclass AlbertModel(nn.Module):\n    def __init__(self, config):\n        super(AlbertModel, self).__init__()\n        self.embeddings = AlbertEmbeddings(config)\n        self.encoder = AlbertEncoder(config)\n        self.pooler = BertPooler(config)\n        self.config = config\n        self.apply(self.init_bert_weights)\n\n    def init_bert_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, BertLayerNorm):\n            module.bias.data.normal_(mean=0.0, std=self.config.initializer_range)\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, output_all_encoded_layers=True):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        # We create a 3D attention mask from a 2D tensor mask.\n        # Sizes are [batch_size, 1, 1, to_seq_length]\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n        # this attention mask is more simple than the triangular masking of causal attention\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n        # masked positions, this operation will create a tensor which is 0.0 for\n        # positions we want to attend and -10000.0 for masked positions.\n        # Since we are adding it to the raw scores before the softmax, this is\n        # effectively the same as removing these entirely.\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype)  # fp16 compatibility\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\n\n        embedding_output = self.embeddings(input_ids, token_type_ids)\n        encoded_layers = self.encoder(embedding_output,\n                                      extended_attention_mask,\n                                      output_all_encoded_layers=output_all_encoded_layers)\n        sequence_output = encoded_layers[-1]\n        pooled_output = self.pooler(sequence_output)\n        if not output_all_encoded_layers:\n            encoded_layers = encoded_layers[-1]\n        return encoded_layers, pooled_output\n\n\nclass AlbertForPreTraining(nn.Module):\n    def __init__(self, config):\n        super(AlbertForPreTraining, self).__init__()\n        self.bert = AlbertModel(config)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, output_all_encoded_layers=True):\n        return self.bert(input_ids, token_type_ids, attention_mask, output_all_encoded_layers)\n\n\nclass MRC_finetune(nn.Module):\n    def __init__(self, config):\n        super(MRC_finetune, self).__init__()\n        self.start_dense = nn.Linear(config.hidden_size, 1)\n        self.end_dense = nn.Linear(config.hidden_size, 1)\n\n    def forward(self, input_tensor):\n        return self.start_dense(input_tensor), self.end_dense(input_tensor)\n\n\nclass AlbertForMRC(nn.Module):\n    def __init__(self, config):\n        super(AlbertForMRC, self).__init__()\n        self.bert = AlbertModel(config)\n        self.finetune_mrc = MRC_finetune(config)\n        self.config = config\n        self.apply(self.init_bert_weights)\n\n    def init_bert_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, BertLayerNorm):\n            module.bias.data.normal_(mean=0.0, std=self.config.initializer_range)\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None,\n                start_positions=None, end_positions=None):\n        sequence_output, _ = self.bert(input_ids, token_type_ids, attention_mask, output_all_encoded_layers=False)\n        start_logits, end_logits = self.finetune_mrc(sequence_output)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            return total_loss\n        else:\n            return start_logits, end_logits\n\nclass AlbertForMultipleChoice(nn.Module):\n    def __init__(self, config, num_choices=2):\n        super(AlbertForMultipleChoice, self).__init__()\n        self.config = config\n        self.num_choices = num_choices\n        self.bert = AlbertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n        self.apply(self.init_bert_weights)\n\n    def init_bert_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, BertLayerNorm):\n            module.bias.data.normal_(mean=0.0, std=self.config.initializer_range)\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None, return_logits=False):\n        flat_input_ids = input_ids.view(-1, input_ids.size(-1))\n        flat_token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1))\n        flat_attention_mask = attention_mask.view(-1, attention_mask.size(-1))\n        _, pooled_output = self.bert(flat_input_ids, flat_token_type_ids, flat_attention_mask,\n                                     output_all_encoded_layers=False)\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, self.num_choices)\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            if return_logits:\n                return loss, reshaped_logits\n            else:\n                return loss\n        else:\n            return reshaped_logits\n'"
baselines/models_pytorch/mrc_pytorch/pytorch_modeling.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HugginFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch BERT model.""""""\nfrom __future__ import print_function\n\nimport os\nimport copy\nimport json\nimport math\nimport logging\nimport tarfile\nimport tempfile\nimport shutil\n\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss\n\nfrom tools.file_utils import cached_path\n\nlogger = logging.getLogger(__name__)\n\nPRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased.tar.gz"",\n    \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased.tar.gz"",\n    \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased.tar.gz"",\n    \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased.tar.gz"",\n    \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased.tar.gz"",\n    \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased.tar.gz"",\n    \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese.tar.gz"",\n}\nCONFIG_NAME = \'bert_config.json\'\nWEIGHTS_NAME = \'pytorch_model.bin\'\n\n\ndef gelu(x):\n    """"""Implementation of the gelu activation function.\n        For information: OpenAI GPT\'s gelu is slightly different (and gives slightly different results):\n        0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n    """"""\n    return x * 0.5 * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT2FN = {""gelu"": gelu, ""relu"": torch.nn.functional.relu, ""swish"": swish}\n\n\nclass BertConfig(object):\n    """"""Configuration class to store the configuration of a `BertModel`.\n    """"""\n\n    def __init__(self,\n                 vocab_size_or_config_json_file,\n                 hidden_size=768,\n                 num_hidden_layers=12,\n                 num_attention_heads=12,\n                 intermediate_size=3072,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=2,\n                 initializer_range=0.02):\n        """"""Constructs BertConfig.\n\n        Args:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `BertModel`.\n            hidden_size: Size of the encoder layers and the pooler layer.\n            num_hidden_layers: Number of hidden layers in the Transformer encoder.\n            num_attention_heads: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n                layer in the Transformer encoder.\n            hidden_act: The non-linear activation function (function or string) in the\n                encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n            hidden_dropout_prob: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attention_probs_dropout_prob: The dropout ratio for the attention\n                probabilities.\n            max_position_embeddings: The maximum sequence length that this model might\n                ever be used with. Typically set this to something large just in case\n                (e.g., 512 or 1024 or 2048).\n            type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n                `BertModel`.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n        """"""\n        if isinstance(vocab_size_or_config_json_file, str):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.hidden_size = hidden_size\n            self.num_hidden_layers = num_hidden_layers\n            self.num_attention_heads = num_attention_heads\n            self.hidden_act = hidden_act\n            self.intermediate_size = intermediate_size\n            self.hidden_dropout_prob = hidden_dropout_prob\n            self.attention_probs_dropout_prob = attention_probs_dropout_prob\n            self.max_position_embeddings = max_position_embeddings\n            self.type_vocab_size = type_vocab_size\n            self.initializer_range = initializer_range\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             ""or the path to a pretrained model config file (str)"")\n\n    @classmethod\n    def from_dict(cls, json_object):\n        """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n        config = BertConfig(vocab_size_or_config_json_file=-1)\n        for key, value in json_object.items():\n            config.__dict__[key] = value\n        return config\n\n    @classmethod\n    def from_json_file(cls, json_file):\n        """"""Constructs a `BertConfig` from a json file of parameters.""""""\n        with open(json_file, ""r"", encoding=\'utf-8\') as reader:\n            text = reader.read()\n        return cls.from_dict(json.loads(text))\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass ALBertConfig(object):\n    """"""Configuration class to store the configuration of a `BertModel`.\n    """"""\n\n    def __init__(self,\n                 vocab_size_or_config_json_file,\n                 hidden_size=768,\n                 num_hidden_layers=12,\n                 num_attention_heads=12,\n                 intermediate_size=3072,\n                 embedding_size=128,\n                 ln_type=""postln"",\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=2,\n                 initializer_range=0.02):\n        """"""Constructs BertConfig.\n\n        Args:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `BertModel`.\n            hidden_size: Size of the encoder layers and the pooler layer.\n            num_hidden_layers: Number of hidden layers in the Transformer encoder.\n            num_attention_heads: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n                layer in the Transformer encoder.\n            hidden_act: The non-linear activation function (function or string) in the\n                encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n            hidden_dropout_prob: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attention_probs_dropout_prob: The dropout ratio for the attention\n                probabilities.\n            max_position_embeddings: The maximum sequence length that this model might\n                ever be used with. Typically set this to something large just in case\n                (e.g., 512 or 1024 or 2048).\n            type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n                `BertModel`.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n        """"""\n        if isinstance(vocab_size_or_config_json_file, str):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.hidden_size = hidden_size\n            self.num_hidden_layers = num_hidden_layers\n            self.num_attention_heads = num_attention_heads\n            self.embedding_size = embedding_size\n            self.ln_type = ln_type\n            self.hidden_act = hidden_act\n            self.intermediate_size = intermediate_size\n            self.hidden_dropout_prob = hidden_dropout_prob\n            self.attention_probs_dropout_prob = attention_probs_dropout_prob\n            self.max_position_embeddings = max_position_embeddings\n            self.type_vocab_size = type_vocab_size\n            self.initializer_range = initializer_range\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             ""or the path to a pretrained model config file (str)"")\n\n    @classmethod\n    def from_dict(cls, json_object):\n        """"""Constructs a `BertConfig` from a Python dictionary of parameters.""""""\n        config = BertConfig(vocab_size_or_config_json_file=-1)\n        for key, value in json_object.items():\n            config.__dict__[key] = value\n        return config\n\n    @classmethod\n    def from_json_file(cls, json_file):\n        """"""Constructs a `BertConfig` from a json file of parameters.""""""\n        with open(json_file, ""r"", encoding=\'utf-8\') as reader:\n            text = reader.read()\n        return cls.from_dict(json.loads(text))\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\ntry:\n    from apex.normalization.fused_layer_norm import FusedLayerNorm as BertLayerNorm\nexcept ImportError:\n    print(""Better speed can be achieved with apex installed from https://www.github.com/nvidia/apex."")\n\n    class BertLayerNorm(nn.Module):\n        def __init__(self, hidden_size, eps=1e-5):\n            """"""Construct a layernorm module in the TF style (epsilon inside the square root).\n            """"""\n            super(BertLayerNorm, self).__init__()\n            self.weight = nn.Parameter(torch.ones(hidden_size))\n            self.bias = nn.Parameter(torch.zeros(hidden_size))\n            self.variance_epsilon = eps\n\n        def forward(self, x):\n            u = x.mean(-1, keepdim=True)\n            s = (x - u).pow(2).mean(-1, keepdim=True)\n            x = (x - u) / torch.sqrt(s + self.variance_epsilon)\n            return self.weight * x + self.bias\n\n\nclass BertEmbeddings(nn.Module):\n    """"""Construct the embeddings from word, position and token_type embeddings.\n    """"""\n\n    def __init__(self, config):\n        super(BertEmbeddings, self).__init__()\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=0)\n        # TODO:ROBERTA\xe6\x9a\x82\xe6\x97\xb6\xe5\xad\x98\xe5\x9c\xa8\xe4\xb8\x80\xe4\xba\x9b\xe9\x97\xae\xe9\xa2\x98\xef\xbc\x8c\xe5\xbf\x85\xe9\xa1\xbb512\xe6\x89\x8d\xe8\x83\xbd\xe5\x8a\xa0\xe8\xbd\xbd\xe4\xb8\x80\xe4\xba\x9b\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x8c\xe4\xbd\x86\xe6\x98\xaf\xe9\x83\xa8\xe5\x88\x86\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x8d\xb4\xe4\xb8\x8d\xe6\x98\xaf\xe7\x94\xa8512\xe9\x95\xbf\xe5\xba\xa6\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xef\xbc\x8c\xe8\xa6\x81\xe6\xb3\xa8\xe6\x84\x8f\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)\n\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\n        # any TensorFlow checkpoint file\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=1e-5)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, input_ids, token_type_ids=None):\n        seq_length = input_ids.size(1)\n        position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\n        position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        words_embeddings = self.word_embeddings(input_ids)\n        position_embeddings = self.position_embeddings(position_ids)\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\n\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\n        embeddings = self.LayerNorm(embeddings)\n        embeddings = self.dropout(embeddings)\n        return embeddings\n\n\nclass ALBertEmbeddings(nn.Module):\n    """""" ALBert embeddings. """"""\n\n    def __init__(self, config):\n        super(ALBertEmbeddings, self).__init__()\n\n        # word_embeddings_2: project vector(output_middle) to the hidden space\n        if config.embedding_size == config.hidden_size:\n            self.word_embeddings = nn.Embedding(config.vocab_size, config.embedding_size, padding_idx=0)\n            self.word_embeddings_2 = None\n        else:\n            self.word_embeddings = nn.Embedding(config.vocab_size, config.embedding_size, padding_idx=0)\n            self.word_embeddings_2 = nn.Linear(config.embedding_size, config.hidden_size, bias=False)\n\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\n        # any TensorFlow checkpoint file\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=1e-5)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n        words_embeddings = self.word_embeddings(input_ids)\n        if self.word_embeddings_2:\n            words_embeddings = self.word_embeddings_2(words_embeddings)\n        position_embeddings = self.position_embeddings(position_ids)\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\n\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\n        embeddings = self.LayerNorm(embeddings)\n        embeddings = self.dropout(embeddings)\n        return embeddings\n\n\nclass BertSelfAttention(nn.Module):\n    def __init__(self, config):\n        super(BertSelfAttention, self).__init__()\n        if config.hidden_size % config.num_attention_heads != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.hidden_size, config.num_attention_heads))\n        self.num_attention_heads = config.num_attention_heads\n        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)\n        self.all_head_size = self.num_attention_heads * self.attention_head_size\n\n        self.query = nn.Linear(config.hidden_size, self.all_head_size)\n        self.key = nn.Linear(config.hidden_size, self.all_head_size)\n        self.value = nn.Linear(config.hidden_size, self.all_head_size)\n\n        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)\n\n    def transpose_for_scores(self, x):\n        new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size)\n        x = x.view(*new_x_shape)\n        return x.permute(0, 2, 1, 3)\n\n    def forward(self, hidden_states, attention_mask):\n        mixed_query_layer = self.query(hidden_states)\n        mixed_key_layer = self.key(hidden_states)\n        mixed_value_layer = self.value(hidden_states)\n\n        query_layer = self.transpose_for_scores(mixed_query_layer)\n        key_layer = self.transpose_for_scores(mixed_key_layer)\n        value_layer = self.transpose_for_scores(mixed_value_layer)\n\n        # Take the dot product between ""query"" and ""key"" to get the raw attention scores.\n        attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))\n        attention_scores = attention_scores / math.sqrt(self.attention_head_size)\n        # Apply the attention mask is (precomputed for all layers in BertModel forward() function)\n        attention_scores = attention_scores + attention_mask\n\n        # Normalize the attention scores to probabilities.\n        attention_probs = nn.Softmax(dim=-1)(attention_scores)\n\n        # This is actually dropping out entire tokens to attend to, which might\n        # seem a bit unusual, but is taken from the original Transformer paper.\n        attention_probs = self.dropout(attention_probs)\n\n        context_layer = torch.matmul(attention_probs, value_layer)\n        context_layer = context_layer.permute(0, 2, 1, 3).contiguous()\n        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)\n        context_layer = context_layer.view(*new_context_layer_shape)\n        return context_layer\n\n\nclass BertSelfOutput(nn.Module):\n    def __init__(self, config):\n        super(BertSelfOutput, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=1e-5)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.ln_type = \'postln\'\n        if \'ln_type\' in config.__dict__:\n            self.ln_type = config.ln_type\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        if self.ln_type == \'preln\':\n            hidden_states = hidden_states + input_tensor\n        else:\n            hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertAttention(nn.Module):\n    def __init__(self, config):\n        super(BertAttention, self).__init__()\n        self.self = BertSelfAttention(config)\n        self.output = BertSelfOutput(config)\n        self.ln_type = \'postln\'\n        if \'ln_type\' in config.__dict__:\n            self.ln_type = config.ln_type\n\n    def forward(self, input_tensor, attention_mask):\n        if self.ln_type == \'preln\':\n            hidden_state = self.output.LayerNorm(input_tensor)  # pre_ln\n            self_output = self.self(hidden_state, attention_mask)\n        else:\n            self_output = self.self(input_tensor, attention_mask)\n        attention_output = self.output(self_output, input_tensor)\n        return attention_output\n\n\nclass BertIntermediate(nn.Module):\n    def __init__(self, config):\n        super(BertIntermediate, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)\n        self.intermediate_act_fn = ACT2FN[config.hidden_act] \\\n            if isinstance(config.hidden_act, str) else config.hidden_act\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.intermediate_act_fn(hidden_states)\n        return hidden_states\n\n\nclass BertOutput(nn.Module):\n    def __init__(self, config):\n        super(BertOutput, self).__init__()\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=1e-5)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.ln_type = \'postln\'\n        if \'ln_type\' in config.__dict__:\n            self.ln_type = config.ln_type\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        if self.ln_type == \'preln\':\n            hidden_states = hidden_states + input_tensor\n        else:\n            hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertLayer(nn.Module):\n    def __init__(self, config):\n        super(BertLayer, self).__init__()\n        self.ln_type = \'postln\'\n        if \'ln_type\' in config.__dict__:\n            self.ln_type = config.ln_type\n        self.attention = BertAttention(config)\n        self.intermediate = BertIntermediate(config)\n        self.output = BertOutput(config)\n\n    def forward(self, hidden_states, attention_mask):\n        attention_output = self.attention(hidden_states, attention_mask)\n        if self.ln_type == \'preln\':\n            attention_output_pre = self.output.LayerNorm(attention_output)\n        else:\n            attention_output_pre = attention_output\n        intermediate_output = self.intermediate(attention_output_pre)\n        layer_output = self.output(intermediate_output, attention_output)\n        return layer_output\n\n\nclass BertEncoder(nn.Module):\n    def __init__(self, config):\n        super(BertEncoder, self).__init__()\n        layer = BertLayer(config)\n        self.layer = nn.ModuleList([copy.deepcopy(layer) for _ in range(config.num_hidden_layers)])\n\n    def forward(self, hidden_states, attention_mask, output_all_encoded_layers=True):\n        all_encoder_layers = []\n        for layer_module in self.layer:\n            hidden_states = layer_module(hidden_states, attention_mask)\n            if output_all_encoded_layers:\n                all_encoder_layers.append(hidden_states)\n        if not output_all_encoded_layers:\n            all_encoder_layers.append(hidden_states)\n        return all_encoder_layers\n\n\nclass ALBertEncoder(nn.Module):\n    def __init__(self, config):\n        super(ALBertEncoder, self).__init__()\n        self.num_hidden_layers = config.num_hidden_layers\n        self.layer_shared = BertLayer(config)\n\n    def forward(self, hidden_states, attention_mask, output_all_encoded_layers=True):\n        all_encoder_layers = []\n        for i in range(self.num_hidden_layers):\n            hidden_states = self.layer_shared(hidden_states, attention_mask)\n            if output_all_encoded_layers:\n                all_encoder_layers.append(hidden_states)\n        if not output_all_encoded_layers:\n            all_encoder_layers.append(hidden_states)\n        return all_encoder_layers\n\n\nclass BertPooler(nn.Module):\n    def __init__(self, config):\n        super(BertPooler, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.activation = nn.Tanh()\n\n    def forward(self, hidden_states):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token.\n        first_token_tensor = hidden_states[:, 0]\n        pooled_output = self.dense(first_token_tensor)\n        pooled_output = self.activation(pooled_output)\n        return pooled_output\n\n\nclass BertPredictionHeadTransform(nn.Module):\n    def __init__(self, config):\n        super(BertPredictionHeadTransform, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.transform_act_fn = ACT2FN[config.hidden_act] \\\n            if isinstance(config.hidden_act, str) else config.hidden_act\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=1e-5)\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.transform_act_fn(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states)\n        return hidden_states\n\n\nclass BertLMPredictionHead(nn.Module):\n    def __init__(self, config, bert_model_embedding_weights):\n        super(BertLMPredictionHead, self).__init__()\n        self.transform = BertPredictionHeadTransform(config)\n\n        # The output weights are the same as the input embeddings, but there is\n        # an output-only bias for each token.\n        self.decoder = nn.Linear(bert_model_embedding_weights.size(1),\n                                 bert_model_embedding_weights.size(0),\n                                 bias=False)\n        self.decoder.weight = bert_model_embedding_weights\n        self.bias = nn.Parameter(torch.zeros(bert_model_embedding_weights.size(0)))\n\n    def forward(self, hidden_states):\n        hidden_states = self.transform(hidden_states)\n        hidden_states = self.decoder(hidden_states) + self.bias\n        return hidden_states\n\n\nclass BertOnlyMLMHead(nn.Module):\n    def __init__(self, config, bert_model_embedding_weights):\n        super(BertOnlyMLMHead, self).__init__()\n        self.predictions = BertLMPredictionHead(config, bert_model_embedding_weights)\n\n    def forward(self, sequence_output):\n        prediction_scores = self.predictions(sequence_output)\n        return prediction_scores\n\n\nclass BertOnlyNSPHead(nn.Module):\n    def __init__(self, config):\n        super(BertOnlyNSPHead, self).__init__()\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, pooled_output):\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return seq_relationship_score\n\n\nclass BertPreTrainingHeads(nn.Module):\n    def __init__(self, config, bert_model_embedding_weights):\n        super(BertPreTrainingHeads, self).__init__()\n        self.predictions = BertLMPredictionHead(config, bert_model_embedding_weights)\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, sequence_output, pooled_output):\n        prediction_scores = self.predictions(sequence_output)\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return prediction_scores, seq_relationship_score\n\n\nclass PreTrainedBertModel(nn.Module):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n\n    def __init__(self, config, *inputs, **kwargs):\n        super(PreTrainedBertModel, self).__init__()\n        if not isinstance(config, BertConfig):\n            raise ValueError(\n                ""Parameter config in `{}(config)` should be an instance of class `BertConfig`. ""\n                ""To create a model from a Google pretrained model use ""\n                ""`model = {}.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(\n                    self.__class__.__name__, self.__class__.__name__\n                ))\n        self.config = config\n\n    def init_bert_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, BertLayerNorm):\n            module.bias.data.normal_(mean=0.0, std=self.config.initializer_range)\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name, state_dict=None, cache_dir=None, *inputs, **kwargs):\n        """"""\n        Instantiate a PreTrainedBertModel from a pre-trained model file or a pytorch state dict.\n        Download and cache the pre-trained model file if needed.\n\n        Params:\n            pretrained_model_name: either:\n                - a str with the name of a pre-trained model to load selected in the list of:\n                    . `bert-base-uncased`\n                    . `bert-large-uncased`\n                    . `bert-base-cased`\n                    . `bert-base-multilingual`\n                    . `bert-base-chinese`\n                - a path or url to a pretrained model archive containing:\n                    . `bert_config.json` a configuration file for the model\n                    . `pytorch_model.bin` a PyTorch dump of a BertForPreTraining instance\n            cache_dir: an optional path to a folder in which the pre-trained models will be cached.\n            state_dict: an optional state dictionnary (collections.OrderedDict object) to use instead of Google pre-trained models\n            *inputs, **kwargs: additional input for the specific Bert class\n                (ex: num_labels for BertForSequenceClassification)\n        """"""\n        if pretrained_model_name in PRETRAINED_MODEL_ARCHIVE_MAP:\n            archive_file = PRETRAINED_MODEL_ARCHIVE_MAP[pretrained_model_name]\n        else:\n            archive_file = pretrained_model_name\n        # redirect to the cache, if necessary\n        try:\n            resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)\n        except FileNotFoundError:\n            logger.error(\n                ""Model name \'{}\' was not found in model name list ({}). ""\n                ""We assumed \'{}\' was a path or url but couldn\'t find any file ""\n                ""associated to this path or url."".format(\n                    pretrained_model_name,\n                    \', \'.join(PRETRAINED_MODEL_ARCHIVE_MAP.keys()),\n                    archive_file))\n            return None\n        if resolved_archive_file == archive_file:\n            logger.info(""loading archive file {}"".format(archive_file))\n        else:\n            logger.info(""loading archive file {} from cache at {}"".format(\n                archive_file, resolved_archive_file))\n        tempdir = None\n        if os.path.isdir(resolved_archive_file):\n            serialization_dir = resolved_archive_file\n        else:\n            # Extract archive to temp dir\n            tempdir = tempfile.mkdtemp()\n            logger.info(""extracting archive file {} to temp dir {}"".format(\n                resolved_archive_file, tempdir))\n            with tarfile.open(resolved_archive_file, \'r:gz\') as archive:\n                archive.extractall(tempdir)\n            serialization_dir = tempdir\n        # Load config\n        config_file = os.path.join(serialization_dir, CONFIG_NAME)\n        config = BertConfig.from_json_file(config_file)\n        logger.info(""Model config {}"".format(config))\n        # Instantiate model.\n        model = cls(config, *inputs, **kwargs)\n        if state_dict is None:\n            weights_path = os.path.join(serialization_dir, WEIGHTS_NAME)\n            state_dict = torch.load(weights_path)\n\n        old_keys = []\n        new_keys = []\n        for key in state_dict.keys():\n            new_key = None\n            if \'gamma\' in key:\n                new_key = key.replace(\'gamma\', \'weight\')\n            if \'beta\' in key:\n                new_key = key.replace(\'beta\', \'bias\')\n            if new_key:\n                old_keys.append(key)\n                new_keys.append(new_key)\n        for old_key, new_key in zip(old_keys, new_keys):\n            state_dict[new_key] = state_dict.pop(old_key)\n\n        missing_keys = []\n        unexpected_keys = []\n        error_msgs = []\n        # copy state_dict so _load_from_state_dict can modify it\n        metadata = getattr(state_dict, \'_metadata\', None)\n        state_dict = state_dict.copy()\n        if metadata is not None:\n            state_dict._metadata = metadata\n\n        def load(module, prefix=\'\'):\n            local_metadata = {} if metadata is None else metadata.get(prefix[:-1], {})\n            module._load_from_state_dict(\n                state_dict, prefix, local_metadata, True, missing_keys, unexpected_keys, error_msgs)\n            for name, child in module._modules.items():\n                if child is not None:\n                    load(child, prefix + name + \'.\')\n\n        load(model, prefix=\'\' if hasattr(model, \'bert\') else \'bert.\')\n        if len(missing_keys) > 0:\n            logger.info(""Weights of {} not initialized from pretrained model: {}"".format(\n                model.__class__.__name__, missing_keys))\n        if len(unexpected_keys) > 0:\n            logger.info(""Weights from pretrained model not used in {}: {}"".format(\n                model.__class__.__name__, unexpected_keys))\n        if tempdir:\n            # Clean up temp dir\n            shutil.rmtree(tempdir)\n        return model\n\n\nclass BertModel(PreTrainedBertModel):\n    def __init__(self, config):\n        super(BertModel, self).__init__(config)\n        self.embeddings = BertEmbeddings(config)\n        self.encoder = BertEncoder(config)\n        self.pooler = BertPooler(config)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, output_all_encoded_layers=True):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        # We create a 3D attention mask from a 2D tensor mask.\n        # Sizes are [batch_size, 1, 1, to_seq_length]\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n        # this attention mask is more simple than the triangular masking of causal attention\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n        # masked positions, this operation will create a tensor which is 0.0 for\n        # positions we want to attend and -10000.0 for masked positions.\n        # Since we are adding it to the raw scores before the softmax, this is\n        # effectively the same as removing these entirely.\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype)  # fp16 compatibility\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\n\n        embedding_output = self.embeddings(input_ids, token_type_ids)\n        encoded_layers = self.encoder(embedding_output,\n                                      extended_attention_mask,\n                                      output_all_encoded_layers=output_all_encoded_layers)\n        sequence_output = encoded_layers[-1]\n        pooled_output = self.pooler(sequence_output)\n        if not output_all_encoded_layers:\n            encoded_layers = encoded_layers[-1]\n        return encoded_layers, pooled_output\n\n\nclass ALBertModel(PreTrainedBertModel):\n    def __init__(self, config):\n        super(ALBertModel, self).__init__(config)\n        self.embeddings = ALBertEmbeddings(config)\n        self.encoder = ALBertEncoder(config)\n        self.pooler = BertPooler(config)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, output_all_encoded_layers=True):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        # We create a 3D attention mask from a 2D tensor mask.\n        # Sizes are [batch_size, 1, 1, to_seq_length]\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n        # this attention mask is more simple than the triangular masking of causal attention\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n        # masked positions, this operation will create a tensor which is 0.0 for\n        # positions we want to attend and -10000.0 for masked positions.\n        # Since we are adding it to the raw scores before the softmax, this is\n        # effectively the same as removing these entirely.\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype)  # fp16 compatibility\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\n\n        embedding_output = self.embeddings(input_ids, token_type_ids)\n        encoded_layers = self.encoder(embedding_output,\n                                      extended_attention_mask,\n                                      output_all_encoded_layers=output_all_encoded_layers)\n        sequence_output = encoded_layers[-1]\n        pooled_output = self.pooler(sequence_output)\n        if not output_all_encoded_layers:\n            encoded_layers = encoded_layers[-1]\n        return encoded_layers, pooled_output\n\n\nclass BertForPreTraining(PreTrainedBertModel):\n    """"""BERT model with pre-training heads.\n    This module comprises the BERT model followed by the two pre-training heads:\n        - the masked language modeling head, and\n        - the next sentence classification head.\n\n    Params:\n        config: a BertConfig class instance with the configuration to build a new model.\n\n    Inputs:\n        `input_ids`: a torch.LongTensor of shape [batch_size, sequence_length]\n            with the word token indices in the vocabulary(see the tokens preprocessing logic in the scripts\n            `extract_features.py`, `run_classifier.py` and `run_squad.py`)\n        `token_type_ids`: an optional torch.LongTensor of shape [batch_size, sequence_length] with the token\n            types indices selected in [0, 1]. Type 0 corresponds to a `sentence A` and type 1 corresponds to\n            a `sentence B` token (see BERT paper for more details).\n        `attention_mask`: an optional torch.LongTensor of shape [batch_size, sequence_length] with indices\n            selected in [0, 1]. It\'s a mask to be used if the input sequence length is smaller than the max\n            input sequence length in the current batch. It\'s the mask that we typically use for attention when\n            a batch has varying length sentences.\n        `masked_lm_labels`: masked language modeling labels: torch.LongTensor of shape [batch_size, sequence_length]\n            with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss\n            is only computed for the labels set in [0, ..., vocab_size]\n        `next_sentence_label`: next sentence classification loss: torch.LongTensor of shape [batch_size]\n            with indices selected in [0, 1].\n            0 => next sentence is the continuation, 1 => next sentence is a random sentence.\n\n    Outputs:\n        if `masked_lm_labels` and `next_sentence_label` are not `None`:\n            Outputs the total_loss which is the sum of the masked language modeling loss and the next\n            sentence classification loss.\n        if `masked_lm_labels` or `next_sentence_label` is `None`:\n            Outputs a tuple comprising\n            - the masked language modeling logits of shape [batch_size, sequence_length, vocab_size], and\n            - the next sentence classification logits of shape [batch_size, 2].\n\n    Example usage:\n    ```python\n    # Already been converted into WordPiece token ids\n    input_ids = torch.LongTensor([[31, 51, 99], [15, 5, 0]])\n    input_mask = torch.LongTensor([[1, 1, 1], [1, 1, 0]])\n    token_type_ids = torch.LongTensor([[0, 0, 1], [0, 1, 0]])\n\n    config = BertConfig(vocab_size_or_config_json_file=32000, hidden_size=768,\n        num_hidden_layers=12, num_attention_heads=12, intermediate_size=3072)\n\n    model = BertForPreTraining(config)\n    masked_lm_logits_scores, seq_relationship_logits = model(input_ids, token_type_ids, input_mask)\n    ```\n    """"""\n\n    def __init__(self, config):\n        super(BertForPreTraining, self).__init__(config)\n        self.bert = BertModel(config)\n        self.cls = BertPreTrainingHeads(config, self.bert.embeddings.word_embeddings.weight)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, masked_lm_labels=None,\n                next_sentence_label=None):\n        sequence_output, pooled_output = self.bert(input_ids, token_type_ids, attention_mask,\n                                                   output_all_encoded_layers=False)\n        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\n\n        if masked_lm_labels is not None and next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            total_loss = masked_lm_loss + next_sentence_loss\n            return total_loss\n        else:\n            return prediction_scores, seq_relationship_score\n\n\nclass ALBertForPreTraining(PreTrainedBertModel):\n    def __init__(self, config):\n        super(ALBertForPreTraining, self).__init__(config)\n        self.bert = ALBertModel(config)\n        self.cls = BertPreTrainingHeads(config, self.bert.embeddings.word_embeddings.weight)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, masked_lm_labels=None,\n                next_sentence_label=None):\n        sequence_output, pooled_output = self.bert(input_ids, token_type_ids, attention_mask,\n                                                   output_all_encoded_layers=False)\n        return sequence_output, pooled_output\n        # \xe4\xb8\x8d\xe5\x81\x9a\xe9\xa2\x84\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe8\xaf\x9d\xef\xbc\x8c\xe8\xbf\x99\xe4\xba\x9b\xe4\xb8\x8d\xe5\x81\x9a\xe4\xb9\x9f\xe6\xb2\xa1\xe4\xba\x8b\n        # prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\n        #\n        # if masked_lm_labels is not None and next_sentence_label is not None:\n        #     loss_fct = CrossEntropyLoss(ignore_index=-1)\n        #     masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n        #     next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n        #     total_loss = masked_lm_loss + next_sentence_loss\n        #     return total_loss\n        # else:\n        #     return prediction_scores, seq_relationship_score\n\n\nclass BertForMaskedLM(PreTrainedBertModel):\n    def __init__(self, config):\n        super(BertForMaskedLM, self).__init__(config)\n        self.bert = BertModel(config)\n        self.cls = BertOnlyMLMHead(config, self.bert.embeddings.word_embeddings.weight)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, masked_lm_labels=None):\n        sequence_output, _ = self.bert(input_ids, token_type_ids, attention_mask,\n                                       output_all_encoded_layers=False)\n        prediction_scores = self.cls(sequence_output)\n\n        if masked_lm_labels is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            return masked_lm_loss\n        else:\n            return prediction_scores\n\n\nclass BertForNextSentencePrediction(PreTrainedBertModel):\n    def __init__(self, config):\n        super(BertForNextSentencePrediction, self).__init__(config)\n        self.bert = BertModel(config)\n        self.cls = BertOnlyNSPHead(config)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, next_sentence_label=None):\n        _, pooled_output = self.bert(input_ids, token_type_ids, attention_mask,\n                                     output_all_encoded_layers=False)\n        seq_relationship_score = self.cls(pooled_output)\n\n        if next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            return next_sentence_loss\n        else:\n            return seq_relationship_score\n\n\nclass BertForSequenceClassification(PreTrainedBertModel):\n\n    def __init__(self, config, num_labels=2):\n        super(BertForSequenceClassification, self).__init__(config)\n        self.num_labels = num_labels\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, num_labels)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None):\n        _, pooled_output = self.bert(input_ids, token_type_ids, attention_mask, output_all_encoded_layers=False)\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            return loss\n        else:\n            return logits\n\n\nclass BertForMultipleChoice(PreTrainedBertModel):\n\n    def __init__(self, config, num_choices=2):\n        super(BertForMultipleChoice, self).__init__(config)\n        self.num_choices = num_choices\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None, return_logits=False):\n        flat_input_ids = input_ids.view(-1, input_ids.size(-1))\n        flat_token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1))\n        flat_attention_mask = attention_mask.view(-1, attention_mask.size(-1))\n        _, pooled_output = self.bert(flat_input_ids, flat_token_type_ids, flat_attention_mask,\n                                     output_all_encoded_layers=False)\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, self.num_choices)\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            if return_logits:\n                return loss, reshaped_logits\n            else:\n                return loss\n        else:\n            return reshaped_logits\n\n\nclass BertForTokenClassification(PreTrainedBertModel):\n    def __init__(self, config, num_labels=2):\n        super(BertForTokenClassification, self).__init__(config)\n        self.num_labels = num_labels\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, num_labels)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None):\n        sequence_output, _ = self.bert(input_ids, token_type_ids, attention_mask, output_all_encoded_layers=False)\n        sequence_output = self.dropout(sequence_output)\n        logits = self.classifier(sequence_output)\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            return loss\n        else:\n            return logits\n\n\nclass BertForQuestionAnswering(PreTrainedBertModel):\n    def __init__(self, config):\n        super(BertForQuestionAnswering, self).__init__(config)\n        self.bert = BertModel(config)\n        # TODO check with Google if it\'s normal there is no dropout on the token classifier of SQuAD in the TF version\n        # self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.qa_outputs = nn.Linear(config.hidden_size, 2)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, start_positions=None, end_positions=None):\n        sequence_output, _ = self.bert(input_ids, token_type_ids, attention_mask, output_all_encoded_layers=False)\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            return total_loss\n        else:\n            return start_logits, end_logits\n\n\nclass BertForQA_CLS(PreTrainedBertModel):\n    def __init__(self, config):\n        super(BertForQA_CLS, self).__init__(config)\n        self.bert = BertModel(config)\n        # TODO check with Google if it\'s normal there is no dropout on the token classifier of SQuAD in the TF version\n        # self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.qa_outputs = nn.Linear(config.hidden_size, 2)\n        self.cls_outputs = nn.Linear(config.hidden_size, 3)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None,\n                start_positions=None, end_positions=None, target_labels=None):\n        sequence_output, pooled_output = self.bert(input_ids, token_type_ids, attention_mask,\n                                                   output_all_encoded_layers=False)\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n        target_logits = self.cls_outputs(pooled_output)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n\n            # classifier loss\n            loss_fct_cls = CrossEntropyLoss(ignore_index=-1)  # no loss for has answer\n            cls_loss = loss_fct_cls(target_logits, target_labels)\n\n            total_loss = ((start_loss + end_loss) / 2) + cls_loss\n            return total_loss\n        else:\n            return start_logits, end_logits, target_logits\n\n\nclass ALBertForQA(PreTrainedBertModel):\n    def __init__(self, config, dropout_rate):\n        super(ALBertForQA, self).__init__(config)\n        self.bert = ALBertModel(config)\n        self.ln_type = config.ln_type\n        if self.ln_type == \'ln_pre\':\n            self.LayerNorm = BertLayerNorm(config.hidden_size, eps=1e-5)\n        else:\n            self.LayerNorm = None\n        self.dropout = nn.Dropout(dropout_rate)\n        self.qa_outputs = nn.Linear(config.hidden_size, 2)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, start_positions=None, end_positions=None):\n        sequence_output, _ = self.bert(input_ids, token_type_ids, attention_mask, output_all_encoded_layers=False)\n        if self.ln_type == \'ln_pre\':\n            sequence_output = self.LayerNorm(sequence_output)\n        sequence_output = self.dropout(sequence_output)\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            return total_loss\n        else:\n            return start_logits, end_logits\n\n\nclass ALBertForQA_CLS(PreTrainedBertModel):\n    def __init__(self, config, dropout_rate):\n        super(ALBertForQA_CLS, self).__init__(config)\n        self.bert = ALBertModel(config)\n        self.ln_type = config.ln_type\n        if self.ln_type == \'ln_pre\':\n            self.LayerNorm_qa = BertLayerNorm(config.hidden_size, eps=1e-5)\n            self.LayerNorm_cls = BertLayerNorm(config.hidden_size, eps=1e-5)\n        else:\n            self.LayerNorm_qa = None\n            self.LayerNorm_cls = None\n        self.dropout_qa = nn.Dropout(dropout_rate)\n        self.dropout_cls = nn.Dropout(dropout_rate)\n        self.qa_outputs = nn.Linear(config.hidden_size, 2)\n        self.cls_outputs = nn.Linear(config.hidden_size, 3)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None,\n                start_positions=None, end_positions=None, target_labels=None):\n        sequence_output, pooled_output = self.bert(input_ids, token_type_ids, attention_mask,\n                                                   output_all_encoded_layers=False)\n        if self.ln_type == \'ln_pre\':\n            sequence_output = self.LayerNorm_qa(sequence_output)\n            pooled_output = self.LayerNorm_cls(pooled_output)\n        sequence_output = self.dropout_qa(sequence_output)\n        pooled_output = self.dropout_cls(pooled_output)\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n        target_logits = self.cls_outputs(pooled_output)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n\n            # classifier loss\n            loss_fct_cls = CrossEntropyLoss(ignore_index=-1)  # no loss for has answer\n            cls_loss = loss_fct_cls(target_logits, target_labels)\n\n            total_loss = ((start_loss + end_loss) / 2) + cls_loss\n            return total_loss\n        else:\n            return start_logits, end_logits, target_logits\n\nclass ALBertForMultipleChoice(PreTrainedBertModel):\n\n    def __init__(self, config, num_choices=2):\n        super(ALBertForMultipleChoice, self).__init__(config)\n        self.num_choices = num_choices\n        self.bert = ALBertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n        self.apply(self.init_bert_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None, return_logits=False):\n        flat_input_ids = input_ids.view(-1, input_ids.size(-1))\n        flat_token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1))\n        flat_attention_mask = attention_mask.view(-1, attention_mask.size(-1))\n        _, pooled_output = self.bert(flat_input_ids, flat_token_type_ids, flat_attention_mask,\n                                     output_all_encoded_layers=False)\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, self.num_choices)\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            if return_logits:\n                return loss, reshaped_logits\n            else:\n                return loss\n        else:\n            return reshaped_logits\n'"
baselines/models_pytorch/mrc_pytorch/run_c3.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HugginFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""BERT finetuning runner.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport argparse\nimport csv\nimport json\nimport logging\nimport os\nimport pickle\nimport random\n\nimport numpy as np\nimport torch\nfrom google_albert_pytorch_modeling import AlbertConfig, AlbertForMultipleChoice\nfrom pytorch_modeling import BertConfig, BertForMultipleChoice, ALBertConfig, ALBertForMultipleChoice\nfrom tools import official_tokenization as tokenization\nfrom tools import utils\nfrom tools.pytorch_optimization import get_optimization, warmup_linear\nfrom torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler\nfrom torch.utils.data.distributed import DistributedSampler\nfrom tqdm import tqdm\n\nn_class = 4\nreverse_order = False\nsa_step = False\n\nlogging.basicConfig(format=\'%(asctime)s - %(levelname)s - %(name)s -   %(message)s\',\n                    datefmt=\'%m/%d/%Y %H:%M:%S\',\n                    level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass InputExample(object):\n    """"""A single training/test example for simple sequence classification.""""""\n\n    def __init__(self, guid, text_a, text_b=None, label=None, text_c=None):\n        """"""Constructs a InputExample.\n        Args:\n            guid: Unique id for the example.\n            text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n            text_b: (Optional) string. The untokenized text of the second sequence.\n            Only must be specified for sequence pair tasks.\n            label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid = guid\n        self.text_a = text_a\n        self.text_b = text_b\n        self.text_c = text_c\n        self.label = label\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self, input_ids, input_mask, segment_ids, label_id):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_id = label_id\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_tsv(cls, input_file, quotechar=None):\n        """"""Reads a tab separated value file.""""""\n        with open(input_file, ""r"") as f:\n            reader = csv.reader(f, delimiter=""\\t"", quotechar=quotechar)\n            lines = []\n            for line in reader:\n                lines.append(line)\n            return lines\n\n\nclass c3Processor(DataProcessor):\n    def __init__(self, data_dir):\n        self.D = [[], [], []]\n        self.data_dir = data_dir\n\n        for sid in range(3):\n            data = []\n            for subtask in [""d"", ""m""]:\n                with open(self.data_dir + ""/c3-"" + subtask + ""-"" + [""train.json"", ""dev.json"", ""test.json""][sid],\n                          ""r"", encoding=""utf8"") as f:\n                    data += json.load(f)\n            if sid == 0:\n                random.shuffle(data)\n            for i in range(len(data)):\n                for j in range(len(data[i][1])):\n                    d = [\'\\n\'.join(data[i][0]).lower(), data[i][1][j][""question""].lower()]\n                    for k in range(len(data[i][1][j][""choice""])):\n                        d += [data[i][1][j][""choice""][k].lower()]\n                    for k in range(len(data[i][1][j][""choice""]), 4):\n                        d += [\'\xe6\x97\xa0\xe6\x95\x88\xe7\xad\x94\xe6\xa1\x88\']  # \xe6\x9c\x89\xe4\xba\x9bC3\xe6\x95\xb0\xe6\x8d\xae\xe9\x80\x89\xe9\xa1\xb9\xe4\xb8\x8d\xe8\xb6\xb34\xe4\xb8\xaa\xef\xbc\x8c\xe6\xb7\xbb\xe5\x8a\xa0[\xe6\x97\xa0\xe6\x95\x88\xe7\xad\x94\xe6\xa1\x88]\xe8\x83\xbd\xe5\xa4\x9f\xe6\x9c\x89\xe6\x95\x88\xe5\xa2\x9e\xe5\xbc\xba\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x94\xb6\xe6\x95\x9b\xe7\xa8\xb3\xe5\xae\x9a\xe6\x80\xa7\n                    d += [data[i][1][j][""answer""].lower()]\n                    self.D[sid] += [d]\n\n    def get_train_examples(self):\n        """"""See base class.""""""\n        return self._create_examples(self.D[0], ""train"")\n\n    def get_test_examples(self):\n        """"""See base class.""""""\n        return self._create_examples(self.D[2], ""test"")\n\n    def get_dev_examples(self):\n        """"""See base class.""""""\n        return self._create_examples(self.D[1], ""dev"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        return [""0"", ""1"", ""2"", ""3""]\n\n    def _create_examples(self, data, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        cache_dir = os.path.join(self.data_dir, set_type + \'_examples.pkl\')\n        if os.path.exists(cache_dir):\n            examples = pickle.load(open(cache_dir, \'rb\'))\n        else:\n            examples = []\n            for (i, d) in enumerate(data):\n                answer = -1\n                # \xe8\xbf\x99\xe9\x87\x8cdata[i]\xe6\x9c\x896\xe4\xb8\xaa\xe5\x85\x83\xe7\xb4\xa0\xef\xbc\x8c0\xe6\x98\xafcontext\xef\xbc\x8c1\xe6\x98\xaf\xe9\x97\xae\xe9\xa2\x98\xef\xbc\x8c2~5\xe6\x98\xafchoice\xef\xbc\x8c6\xe6\x98\xaf\xe7\xad\x94\xe6\xa1\x88\n                for k in range(4):\n                    if data[i][2 + k] == data[i][6]:\n                        answer = str(k)\n\n                label = tokenization.convert_to_unicode(answer)\n\n                for k in range(4):\n                    guid = ""%s-%s-%s"" % (set_type, i, k)\n                    text_a = tokenization.convert_to_unicode(data[i][0])\n                    text_b = tokenization.convert_to_unicode(data[i][k + 2])\n                    text_c = tokenization.convert_to_unicode(data[i][1])\n                    examples.append(InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label, text_c=text_c))\n\n            with open(cache_dir, \'wb\') as w:\n                pickle.dump(examples, w)\n\n        return examples\n\n\ndef convert_examples_to_features(examples, label_list, max_seq_length, tokenizer):\n    """"""Loads a data file into a list of `InputBatch`s.""""""\n\n    print(""#examples"", len(examples))\n\n    label_map = {}\n    for (i, label) in enumerate(label_list):\n        label_map[label] = i\n\n    features = [[]]\n    for (ex_index, example) in enumerate(tqdm(examples)):\n        tokens_a = tokenizer.tokenize(example.text_a)\n\n        tokens_b = tokenizer.tokenize(example.text_b)\n\n        tokens_c = tokenizer.tokenize(example.text_c)\n\n        _truncate_seq_tuple(tokens_a, tokens_b, tokens_c, max_seq_length - 4)\n        tokens_b = tokens_c + [""[SEP]""] + tokens_b\n\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in tokens_a:\n            tokens.append(token)\n            segment_ids.append(0)\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n\n        if tokens_b:\n            for token in tokens_b:\n                tokens.append(token)\n                segment_ids.append(1)\n            tokens.append(""[SEP]"")\n            segment_ids.append(1)\n\n        input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n        # The mask has 1 for real tokens and 0 for padding tokens. Only real\n        # tokens are attended to.\n        input_mask = [1] * len(input_ids)\n\n        # Zero-pad up to the sequence length.\n        while len(input_ids) < max_seq_length:\n            input_ids.append(0)\n            input_mask.append(0)\n            segment_ids.append(0)\n\n        assert len(input_ids) == max_seq_length\n        assert len(input_mask) == max_seq_length\n        assert len(segment_ids) == max_seq_length\n\n        label_id = label_map[example.label]\n        if ex_index < 5:\n            logger.info(""*** Example ***"")\n            logger.info(""guid: %s"" % (example.guid))\n            logger.info(""tokens: %s"" % "" "".join(\n                [tokenization.printable_text(x) for x in tokens]))\n            logger.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n            logger.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n            logger.info(\n                ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n            logger.info(""label: %s (id = %d)"" % (example.label, label_id))\n\n        features[-1].append(\n            InputFeatures(\n                input_ids=input_ids,\n                input_mask=input_mask,\n                segment_ids=segment_ids,\n                label_id=label_id))\n        if len(features[-1]) == n_class:\n            features.append([])\n\n    if len(features[-1]) == 0:\n        features = features[:-1]\n    print(\'#features\', len(features))\n    return features\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n    """"""Truncates a sequence pair in place to the maximum length.""""""\n\n    # This is a simple heuristic which will always truncate the longer sequence\n    # one token at a time. This makes more sense than truncating an equal percent\n    # of tokens from each, since if one sequence is very short then each token\n    # that\'s truncated likely contains more information than a longer sequence.\n    while True:\n        total_length = len(tokens_a) + len(tokens_b)\n        if total_length <= max_length:\n            break\n        if len(tokens_a) > len(tokens_b):\n            tokens_a.pop()\n        else:\n            tokens_b.pop()\n\n\ndef _truncate_seq_tuple(tokens_a, tokens_b, tokens_c, max_length):\n    """"""Truncates a sequence tuple in place to the maximum length.""""""\n\n    # This is a simple heuristic which will always truncate the longer sequence\n    # one token at a time. This makes more sense than truncating an equal percent\n    # of tokens from each, since if one sequence is very short then each token\n    # that\'s truncated likely contains more information than a longer sequence.\n    while True:\n        total_length = len(tokens_a) + len(tokens_b) + len(tokens_c)\n        if total_length <= max_length:\n            break\n        if len(tokens_a) >= len(tokens_b) and len(tokens_a) >= len(tokens_c):\n            tokens_a.pop()\n        elif len(tokens_b) >= len(tokens_a) and len(tokens_b) >= len(tokens_c):\n            tokens_b.pop()\n        else:\n            tokens_c.pop()\n\n\ndef accuracy(out, labels):\n    outputs = np.argmax(out, axis=1)\n    return np.sum(outputs == labels)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n\n    ## Required parameters\n    parser.add_argument(""--gpu_ids"",\n                        default=\'0\',\n                        type=str,\n                        required=True)\n    parser.add_argument(""--data_dir"",\n                        default=None,\n                        type=str,\n                        required=True,\n                        help=""The input data dir. Should contain the .tsv files (or other data files) for the task."")\n    parser.add_argument(""--task_name"",\n                        default=\'c3\',\n                        type=str,\n                        required=True)\n    parser.add_argument(""--bert_config_file"",\n                        default=None,\n                        type=str,\n                        required=True,\n                        help=""The config json file corresponding to the pre-trained BERT model. \\n""\n                             ""This specifies the model architecture."")\n    parser.add_argument(""--vocab_file"",\n                        default=None,\n                        type=str,\n                        required=True,\n                        help=""The vocabulary file that the BERT model was trained on."")\n    parser.add_argument(""--output_dir"",\n                        default=None,\n                        type=str,\n                        required=True,\n                        help=""The output directory where the model checkpoints will be written."")\n\n    ## Other parameters\n    parser.add_argument(""--init_checkpoint"",\n                        default=\'check_points/pretrain_models/albert_xxlarge_google_zh_v1121/pytorch_model.pth\',\n                        type=str,\n                        help=""Initial checkpoint (usually from a pre-trained BERT model)."")\n    parser.add_argument(""--do_lower_case"",\n                        default=True,\n                        action=\'store_true\',\n                        help=""Whether to lower case the input text. True for uncased models, False for cased models."")\n    parser.add_argument(""--max_seq_length"",\n                        default=512,\n                        type=int,\n                        help=""The maximum total input sequence length after WordPiece tokenization. \\n""\n                             ""Sequences longer than this will be truncated, and sequences shorter \\n""\n                             ""than this will be padded."")\n    parser.add_argument(""--do_train"",\n                        default=False,\n                        action=\'store_true\',\n                        help=""Whether to run training."")\n    parser.add_argument(""--do_eval"",\n                        default=False,\n                        action=\'store_true\',\n                        help=""Whether to run eval on the dev set."")\n    parser.add_argument(""--train_batch_size"",\n                        default=16,\n                        type=int,\n                        help=""Total batch size for training."")\n    parser.add_argument(""--eval_batch_size"",\n                        default=16,\n                        type=int,\n                        help=""Total batch size for eval."")\n    parser.add_argument(""--learning_rate"",\n                        default=2e-5,\n                        type=float,\n                        help=""The initial learning rate for Adam."")\n    parser.add_argument(""--schedule"",\n                        default=\'warmup_linear\',\n                        type=str,\n                        help=\'schedule\')\n    parser.add_argument(""--weight_decay_rate"",\n                        default=0.01,\n                        type=float,\n                        help=\'weight_decay_rate\')\n    parser.add_argument(\'--clip_norm\',\n                        type=float,\n                        default=1.0)\n    parser.add_argument(""--num_train_epochs"",\n                        default=8.0,\n                        type=float,\n                        help=""Total number of training epochs to perform."")\n    parser.add_argument(""--warmup_proportion"",\n                        default=0.1,\n                        type=float,\n                        help=""Proportion of training to perform linear learning rate warmup for. ""\n                             ""E.g., 0.1 = 10%% of training."")\n    parser.add_argument(""--no_cuda"",\n                        default=False,\n                        action=\'store_true\',\n                        help=""Whether not to use CUDA when available"")\n    parser.add_argument(\'--float16\',\n                        action=\'store_true\',\n                        default=False)\n    parser.add_argument(""--local_rank"",\n                        type=int,\n                        default=-1,\n                        help=""local_rank for distributed training on gpus"")\n    parser.add_argument(\'--seed\',\n                        type=int,\n                        default=422,\n                        help=""random seed for initialization"")\n    parser.add_argument(\'--gradient_accumulation_steps\',\n                        type=int,\n                        default=1,\n                        help=""Number of updates steps to accumualte before performing a backward/update pass."")\n    parser.add_argument(\'--setting_file\', type=str, default=\'setting.txt\')\n    parser.add_argument(\'--log_file\', type=str, default=\'log.txt\')\n\n    args = parser.parse_args()\n    args.setting_file = os.path.join(args.output_dir, args.setting_file)\n    args.log_file = os.path.join(args.output_dir, args.log_file)\n    os.makedirs(args.output_dir, exist_ok=True)\n    with open(args.setting_file, \'wt\') as opt_file:\n        opt_file.write(\'------------ Options -------------\\n\')\n        print(\'------------ Options -------------\')\n        for k in args.__dict__:\n            v = args.__dict__[k]\n            opt_file.write(\'%s: %s\\n\' % (str(k), str(v)))\n            print(\'%s: %s\' % (str(k), str(v)))\n        opt_file.write(\'-------------- End ----------------\\n\')\n        print(\'------------ End -------------\')\n    os.environ[""CUDA_VISIBLE_DEVICES""] = args.gpu_ids\n\n    if os.path.exists(args.log_file):\n        os.remove(args.log_file)\n\n    if args.local_rank == -1 or args.no_cuda:\n        device = torch.device(""cuda"" if torch.cuda.is_available() and not args.no_cuda else ""cpu"")\n        n_gpu = torch.cuda.device_count()\n    else:\n        device = torch.device(""cuda"", args.local_rank)\n        n_gpu = 1\n        # Initializes the distributed backend which will take care of sychronizing nodes/GPUs\n        torch.distributed.init_process_group(backend=\'nccl\')\n    logger.info(""device %s n_gpu %d distributed training %r"", device, n_gpu, bool(args.local_rank != -1))\n\n    if args.gradient_accumulation_steps < 1:\n        raise ValueError(""Invalid gradient_accumulation_steps parameter: {}, should be >= 1"".format(\n            args.gradient_accumulation_steps))\n\n    args.train_batch_size = int(args.train_batch_size / args.gradient_accumulation_steps)\n\n    random.seed(args.seed)\n    np.random.seed(args.seed)\n    torch.manual_seed(args.seed)\n    if n_gpu > 0:\n        torch.cuda.manual_seed_all(args.seed)\n\n    if not args.do_train and not args.do_eval:\n        raise ValueError(""At least one of `do_train` or `do_eval` must be True."")\n\n    processor = c3Processor(args.data_dir)\n    label_list = processor.get_labels()\n\n    tokenizer = tokenization.BertTokenizer(vocab_file=args.vocab_file, do_lower_case=args.do_lower_case)\n\n    train_examples = None\n    num_train_steps = None\n    if args.do_train:\n        train_examples = processor.get_train_examples()\n        num_train_steps = int(len(train_examples) / n_class / args.train_batch_size /\n                              args.gradient_accumulation_steps * args.num_train_epochs)\n\n    if \'albert\' in args.bert_config_file:\n        if \'google\' in args.bert_config_file:\n            bert_config = AlbertConfig.from_json_file(args.bert_config_file)\n            model = AlbertForMultipleChoice(bert_config, num_choices=n_class)\n        else:\n            bert_config = ALBertConfig.from_json_file(args.bert_config_file)\n            model = ALBertForMultipleChoice(bert_config, num_choices=n_class)\n    else:\n        bert_config = BertConfig.from_json_file(args.bert_config_file)\n        model = BertForMultipleChoice(bert_config, num_choices=n_class)\n\n    if args.max_seq_length > bert_config.max_position_embeddings:\n        raise ValueError(\n            ""Cannot use sequence length {} because the BERT model was only trained up to sequence length {}"".format(\n                args.max_seq_length, bert_config.max_position_embeddings))\n\n    if args.init_checkpoint is not None:\n        utils.torch_show_all_params(model)\n        utils.torch_init_model(model, args.init_checkpoint)\n    if args.float16:\n        model.half()\n    model.to(device)\n\n    if args.local_rank != -1:\n        model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank],\n                                                          output_device=args.local_rank)\n    elif n_gpu > 1:\n        model = torch.nn.DataParallel(model)\n\n    optimizer = get_optimization(model=model,\n                                 float16=args.float16,\n                                 learning_rate=args.learning_rate,\n                                 total_steps=num_train_steps,\n                                 schedule=args.schedule,\n                                 warmup_rate=args.warmup_proportion,\n                                 max_grad_norm=args.clip_norm,\n                                 weight_decay_rate=args.weight_decay_rate,\n                                 opt_pooler=True)  # multi_choice must update pooler\n\n    global_step = 0\n    eval_dataloader = None\n    if args.do_eval:\n        eval_examples = processor.get_dev_examples()\n        feature_dir = os.path.join(args.data_dir, \'dev_features{}.pkl\'.format(args.max_seq_length))\n        if os.path.exists(feature_dir):\n            eval_features = pickle.load(open(feature_dir, \'rb\'))\n        else:\n            eval_features = convert_examples_to_features(eval_examples, label_list, args.max_seq_length, tokenizer)\n            with open(feature_dir, \'wb\') as w:\n                pickle.dump(eval_features, w)\n\n        input_ids = []\n        input_mask = []\n        segment_ids = []\n        label_id = []\n\n        for f in eval_features:\n            input_ids.append([])\n            input_mask.append([])\n            segment_ids.append([])\n            for i in range(n_class):\n                input_ids[-1].append(f[i].input_ids)\n                input_mask[-1].append(f[i].input_mask)\n                segment_ids[-1].append(f[i].segment_ids)\n            label_id.append(f[0].label_id)\n\n        all_input_ids = torch.tensor(input_ids, dtype=torch.long)\n        all_input_mask = torch.tensor(input_mask, dtype=torch.long)\n        all_segment_ids = torch.tensor(segment_ids, dtype=torch.long)\n        all_label_ids = torch.tensor(label_id, dtype=torch.long)\n\n        eval_data = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids)\n        if args.local_rank == -1:\n            eval_sampler = SequentialSampler(eval_data)\n        else:\n            eval_sampler = DistributedSampler(eval_data)\n        eval_dataloader = DataLoader(eval_data, sampler=eval_sampler, batch_size=args.eval_batch_size)\n\n    if args.do_train:\n        best_accuracy = 0\n\n        feature_dir = os.path.join(args.data_dir, \'train_features{}.pkl\'.format(args.max_seq_length))\n        if os.path.exists(feature_dir):\n            train_features = pickle.load(open(feature_dir, \'rb\'))\n        else:\n            train_features = convert_examples_to_features(train_examples, label_list, args.max_seq_length, tokenizer)\n            with open(feature_dir, \'wb\') as w:\n                pickle.dump(train_features, w)\n\n        logger.info(""***** Running training *****"")\n        logger.info(""  Num examples = %d"", len(train_examples))\n        logger.info(""  Batch size = %d"", args.train_batch_size)\n        logger.info(""  Num steps = %d"", num_train_steps)\n\n        input_ids = []\n        input_mask = []\n        segment_ids = []\n        label_id = []\n        for f in train_features:\n            input_ids.append([])\n            input_mask.append([])\n            segment_ids.append([])\n            for i in range(n_class):\n                input_ids[-1].append(f[i].input_ids)\n                input_mask[-1].append(f[i].input_mask)\n                segment_ids[-1].append(f[i].segment_ids)\n            label_id.append(f[0].label_id)\n\n        all_input_ids = torch.tensor(input_ids, dtype=torch.long)\n        all_input_mask = torch.tensor(input_mask, dtype=torch.long)\n        all_segment_ids = torch.tensor(segment_ids, dtype=torch.long)\n        all_label_ids = torch.tensor(label_id, dtype=torch.long)\n\n        train_data = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids)\n        if args.local_rank == -1:\n            train_sampler = RandomSampler(train_data)\n        else:\n            train_sampler = DistributedSampler(train_data)\n        train_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=args.train_batch_size,\n                                      drop_last=True)\n        steps_per_epoch = int(num_train_steps / args.num_train_epochs)\n\n        for ie in range(int(args.num_train_epochs)):\n            model.train()\n            tr_loss = 0\n            nb_tr_examples, nb_tr_steps = 0, 0\n            with tqdm(total=int(steps_per_epoch), desc=\'Epoch %d\' % (ie + 1)) as pbar:\n                for step, batch in enumerate(train_dataloader):\n                    batch = tuple(t.to(device) for t in batch)\n                    input_ids, input_mask, segment_ids, label_ids = batch\n                    loss = model(input_ids, segment_ids, input_mask, label_ids)\n                    if n_gpu > 1:\n                        loss = loss.mean()  # mean() to average on multi-gpu.\n                    if args.gradient_accumulation_steps > 1:\n                        loss = loss / args.gradient_accumulation_steps\n                    tr_loss += loss.item()\n\n                    if args.float16:\n                        optimizer.backward(loss)\n                        # modify learning rate with special warm up BERT uses\n                        # if args.fp16 is False, BertAdam is used and handles this automatically\n                        lr_this_step = args.learning_rate * warmup_linear(global_step / num_train_steps,\n                                                                          args.warmup_proportion)\n                        for param_group in optimizer.param_groups:\n                            param_group[\'lr\'] = lr_this_step\n                    else:\n                        loss.backward()\n\n                    nb_tr_examples += input_ids.size(0)\n                    if (step + 1) % args.gradient_accumulation_steps == 0:\n                        optimizer.step()  # We have accumulated enought gradients\n                        model.zero_grad()\n                        global_step += 1\n                        nb_tr_steps += 1\n                        pbar.set_postfix({\'loss\': \'{0:1.5f}\'.format(tr_loss / (nb_tr_steps + 1e-5))})\n                        pbar.update(1)\n\n            if args.do_eval:\n                model.eval()\n                eval_loss, eval_accuracy = 0, 0\n                nb_eval_steps, nb_eval_examples = 0, 0\n                logits_all = []\n                for input_ids, input_mask, segment_ids, label_ids in tqdm(eval_dataloader):\n                    input_ids = input_ids.to(device)\n                    input_mask = input_mask.to(device)\n                    segment_ids = segment_ids.to(device)\n                    label_ids = label_ids.to(device)\n\n                    with torch.no_grad():\n                        tmp_eval_loss, logits = model(input_ids, segment_ids, input_mask, label_ids, return_logits=True)\n\n                    logits = logits.detach().cpu().numpy()\n                    label_ids = label_ids.cpu().numpy()\n                    for i in range(len(logits)):\n                        logits_all += [logits[i]]\n\n                    tmp_eval_accuracy = accuracy(logits, label_ids.reshape(-1))\n\n                    eval_loss += tmp_eval_loss.mean().item()\n                    eval_accuracy += tmp_eval_accuracy\n\n                    nb_eval_examples += input_ids.size(0)\n                    nb_eval_steps += 1\n\n                eval_loss = eval_loss / nb_eval_steps\n                eval_accuracy = eval_accuracy / nb_eval_examples\n\n                if args.do_train:\n                    result = {\'eval_loss\': eval_loss,\n                              \'eval_accuracy\': eval_accuracy,\n                              \'global_step\': global_step,\n                              \'loss\': tr_loss / nb_tr_steps}\n                else:\n                    result = {\'eval_loss\': eval_loss,\n                              \'eval_accuracy\': eval_accuracy}\n\n                logger.info(""***** Eval results *****"")\n                for key in sorted(result.keys()):\n                    logger.info(""  %s = %s"", key, str(result[key]))\n\n                with open(args.log_file, \'a\') as aw:\n                    aw.write(""-------------------global steps:{}-------------------\\n"".format(global_step))\n                    aw.write(str(json.dumps(result, indent=2)) + \'\\n\')\n\n                if eval_accuracy >= best_accuracy:\n                    torch.save(model.state_dict(), os.path.join(args.output_dir, ""model_best.pt""))\n                    best_accuracy = eval_accuracy\n\n        model.load_state_dict(torch.load(os.path.join(args.output_dir, ""model_best.pt"")))\n        torch.save(model.state_dict(), os.path.join(args.output_dir, ""model.pt""))\n\n    model.load_state_dict(torch.load(os.path.join(args.output_dir, ""model.pt"")))\n\n    if args.do_eval:\n        logger.info(""***** Running evaluation *****"")\n        logger.info(""  Num examples = %d"", len(eval_examples))\n        logger.info(""  Batch size = %d"", args.eval_batch_size)\n\n        model.eval()\n        eval_loss, eval_accuracy = 0, 0\n        nb_eval_steps, nb_eval_examples = 0, 0\n        logits_all = []\n        for input_ids, input_mask, segment_ids, label_ids in tqdm(eval_dataloader):\n            input_ids = input_ids.to(device)\n            input_mask = input_mask.to(device)\n            segment_ids = segment_ids.to(device)\n            label_ids = label_ids.to(device)\n\n            with torch.no_grad():\n                tmp_eval_loss, logits = model(input_ids, segment_ids, input_mask, label_ids, return_logits=True)\n\n            logits = logits.detach().cpu().numpy()\n            label_ids = label_ids.cpu().numpy()\n            for i in range(len(logits)):\n                logits_all += [logits[i]]\n\n            tmp_eval_accuracy = accuracy(logits, label_ids.reshape(-1))\n\n            eval_loss += tmp_eval_loss.mean().item()\n            eval_accuracy += tmp_eval_accuracy\n\n            nb_eval_examples += input_ids.size(0)\n            nb_eval_steps += 1\n\n        eval_loss = eval_loss / nb_eval_steps\n        eval_accuracy = eval_accuracy / nb_eval_examples\n\n        result = {\'eval_loss\': eval_loss,\n                  \'eval_accuracy\': eval_accuracy}\n\n        output_eval_file = os.path.join(args.output_dir, ""results_dev.txt"")\n        with open(output_eval_file, ""w"") as writer:\n            logger.info(""***** Eval results *****"")\n            for key in sorted(result.keys()):\n                logger.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n        output_eval_file = os.path.join(args.output_dir, ""logits_dev.txt"")\n        with open(output_eval_file, ""w"") as f:\n            for i in range(len(logits_all)):\n                for j in range(len(logits_all[i])):\n                    f.write(str(logits_all[i][j]))\n                    if j == len(logits_all[i]) - 1:\n                        f.write(""\\n"")\n                    else:\n                        f.write("" "")\n\n        test_examples = processor.get_test_examples()\n        feature_dir = os.path.join(args.data_dir, \'test_features{}.pkl\'.format(args.max_seq_length))\n        if os.path.exists(feature_dir):\n            test_features = pickle.load(open(feature_dir, \'rb\'))\n        else:\n            test_features = convert_examples_to_features(test_examples, label_list, args.max_seq_length, tokenizer)\n            with open(feature_dir, \'wb\') as w:\n                pickle.dump(test_features, w)\n\n        logger.info(""***** Running testing *****"")\n        logger.info(""  Num examples = %d"", len(test_examples))\n        logger.info(""  Batch size = %d"", args.eval_batch_size)\n\n        input_ids = []\n        input_mask = []\n        segment_ids = []\n        label_id = []\n\n        for f in test_features:\n            input_ids.append([])\n            input_mask.append([])\n            segment_ids.append([])\n            for i in range(n_class):\n                input_ids[-1].append(f[i].input_ids)\n                input_mask[-1].append(f[i].input_mask)\n                segment_ids[-1].append(f[i].segment_ids)\n            label_id.append(f[0].label_id)\n\n        all_input_ids = torch.tensor(input_ids, dtype=torch.long)\n        all_input_mask = torch.tensor(input_mask, dtype=torch.long)\n        all_segment_ids = torch.tensor(segment_ids, dtype=torch.long)\n        all_label_ids = torch.tensor(label_id, dtype=torch.long)\n\n        test_data = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids)\n        if args.local_rank == -1:\n            test_sampler = SequentialSampler(test_data)\n        else:\n            test_sampler = DistributedSampler(test_data)\n        test_dataloader = DataLoader(test_data, sampler=test_sampler, batch_size=args.eval_batch_size)\n\n        model.eval()\n        test_loss, test_accuracy = 0, 0\n        nb_test_steps, nb_test_examples = 0, 0\n        logits_all = []\n        for input_ids, input_mask, segment_ids, label_ids in tqdm(test_dataloader):\n            input_ids = input_ids.to(device)\n            input_mask = input_mask.to(device)\n            segment_ids = segment_ids.to(device)\n            label_ids = label_ids.to(device)\n\n            with torch.no_grad():\n                tmp_test_loss, logits = model(input_ids, segment_ids, input_mask, label_ids, return_logits=True)\n\n            logits = logits.detach().cpu().numpy()\n            label_ids = label_ids.to(\'cpu\').numpy()\n            for i in range(len(logits)):\n                logits_all += [logits[i]]\n\n            tmp_test_accuracy = accuracy(logits, label_ids.reshape(-1))\n\n            test_loss += tmp_test_loss.mean().item()\n            test_accuracy += tmp_test_accuracy\n\n            nb_test_examples += input_ids.size(0)\n            nb_test_steps += 1\n\n        test_loss = test_loss / nb_test_steps\n        test_accuracy = test_accuracy / nb_test_examples\n\n        result = {\'test_loss\': test_loss,\n                  \'test_accuracy\': test_accuracy}\n\n        output_test_file = os.path.join(args.output_dir, ""results_test.txt"")\n        with open(output_test_file, ""w"") as writer:\n            logger.info(""***** Test results *****"")\n            for key in sorted(result.keys()):\n                logger.info(""  %s = %s"", key, str(result[key]))\n                writer.write(""%s = %s\\n"" % (key, str(result[key])))\n        output_test_file = os.path.join(args.output_dir, ""logits_test.txt"")\n        with open(output_test_file, ""w"") as f:\n            for i in range(len(logits_all)):\n                for j in range(len(logits_all[i])):\n                    f.write(str(logits_all[i][j]))\n                    if j == len(logits_all[i]) - 1:\n                        f.write(""\\n"")\n                    else:\n                        f.write("" "")\n\n        # the test submission order can\'t be changed\n        submission_test = os.path.join(args.output_dir, ""submission_test.json"")\n        test_preds = [int(np.argmax(logits_)) for logits_ in logits_all]\n        with open(submission_test, ""w"") as f:\n            json.dump(test_preds, f)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
baselines/models_pytorch/mrc_pytorch/run_mrc.py,0,"b'import argparse\nimport collections\nimport json\nimport os\nimport random\n\nimport numpy as np\nimport torch\nfrom google_albert_pytorch_modeling import AlbertConfig, AlbertForMRC\nfrom preprocess.cmrc2018_evaluate import get_eval\nfrom pytorch_modeling import BertConfig, BertForQuestionAnswering, ALBertConfig, ALBertForQA\nfrom tools import official_tokenization as tokenization, utils\nfrom tools.pytorch_optimization import get_optimization, warmup_linear\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom tqdm import tqdm\n\n\ndef evaluate(model, args, eval_examples, eval_features, device, global_steps, best_f1, best_em, best_f1_em):\n    print(""***** Eval *****"")\n    RawResult = collections.namedtuple(""RawResult"",\n                                       [""unique_id"", ""start_logits"", ""end_logits""])\n    output_prediction_file = os.path.join(args.checkpoint_dir,\n                                          ""predictions_steps"" + str(global_steps) + "".json"")\n    output_nbest_file = output_prediction_file.replace(\'predictions\', \'nbest\')\n\n    all_input_ids = torch.tensor([f[\'input_ids\'] for f in eval_features], dtype=torch.long)\n    all_input_mask = torch.tensor([f[\'input_mask\'] for f in eval_features], dtype=torch.long)\n    all_segment_ids = torch.tensor([f[\'segment_ids\'] for f in eval_features], dtype=torch.long)\n    all_example_index = torch.arange(all_input_ids.size(0), dtype=torch.long)\n\n    eval_data = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_example_index)\n    eval_dataloader = DataLoader(eval_data, batch_size=args.n_batch, shuffle=False)\n\n    model.eval()\n    all_results = []\n    print(""Start evaluating"")\n    for input_ids, input_mask, segment_ids, example_indices in tqdm(eval_dataloader, desc=""Evaluating""):\n        input_ids = input_ids.to(device)\n        input_mask = input_mask.to(device)\n        segment_ids = segment_ids.to(device)\n        with torch.no_grad():\n            batch_start_logits, batch_end_logits = model(input_ids, segment_ids, input_mask)\n\n        for i, example_index in enumerate(example_indices):\n            start_logits = batch_start_logits[i].detach().cpu().tolist()\n            end_logits = batch_end_logits[i].detach().cpu().tolist()\n            eval_feature = eval_features[example_index.item()]\n            unique_id = int(eval_feature[\'unique_id\'])\n            all_results.append(RawResult(unique_id=unique_id,\n                                         start_logits=start_logits,\n                                         end_logits=end_logits))\n\n    write_predictions(eval_examples, eval_features, all_results,\n                      n_best_size=args.n_best, max_answer_length=args.max_ans_length,\n                      do_lower_case=True, output_prediction_file=output_prediction_file,\n                      output_nbest_file=output_nbest_file)\n\n    tmp_result = get_eval(args.dev_file, output_prediction_file)\n    tmp_result[\'STEP\'] = global_steps\n    with open(args.log_file, \'a\') as aw:\n        aw.write(json.dumps(tmp_result) + \'\\n\')\n    print(tmp_result)\n\n    if float(tmp_result[\'F1\']) > best_f1:\n        best_f1 = float(tmp_result[\'F1\'])\n\n    if float(tmp_result[\'EM\']) > best_em:\n        best_em = float(tmp_result[\'EM\'])\n\n    if float(tmp_result[\'F1\']) + float(tmp_result[\'EM\']) > best_f1_em:\n        best_f1_em = float(tmp_result[\'F1\']) + float(tmp_result[\'EM\'])\n        utils.torch_save_model(model, args.checkpoint_dir,\n                               {\'f1\': float(tmp_result[\'F1\']), \'em\': float(tmp_result[\'EM\'])}, max_save_num=1)\n\n    model.train()\n\n    return best_f1, best_em, best_f1_em\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'--gpu_ids\', type=str, default=\'0,1,2,3\')\n\n    # training parameter\n    parser.add_argument(\'--train_epochs\', type=int, default=2)\n    parser.add_argument(\'--n_batch\', type=int, default=32)\n    parser.add_argument(\'--lr\', type=float, default=3e-5)\n    parser.add_argument(\'--dropout\', type=float, default=0.1)\n    parser.add_argument(\'--clip_norm\', type=float, default=1.0)\n    parser.add_argument(\'--warmup_rate\', type=float, default=0.05)\n    parser.add_argument(""--schedule"", default=\'warmup_linear\', type=str, help=\'schedule\')\n    parser.add_argument(""--weight_decay_rate"", default=0.01, type=float, help=\'weight_decay_rate\')\n    parser.add_argument(\'--seed\', type=list, default=[123])\n    parser.add_argument(\'--float16\', action=\'store_true\', default=False)  # only sm >= 7.0 (tensorcores)\n    parser.add_argument(\'--max_ans_length\', type=int, default=50)\n    parser.add_argument(\'--n_best\', type=int, default=20)\n    parser.add_argument(\'--eval_epochs\', type=float, default=0.5)\n    parser.add_argument(\'--save_best\', type=bool, default=True)\n    parser.add_argument(\'--vocab_size\', type=int, default=21128)\n    parser.add_argument(\'--max_seq_length\', type=int, default=256)\n\n    # data dir\n    parser.add_argument(\'--train_dir\', type=str, required=True)\n    parser.add_argument(\'--dev_dir1\', type=str, required=True)\n    parser.add_argument(\'--dev_dir2\', type=str, required=True)\n    parser.add_argument(\'--train_file\', type=str, required=True)\n    parser.add_argument(\'--dev_file\', type=str, required=True)\n    parser.add_argument(\'--bert_config_file\', type=str, required=True)\n    parser.add_argument(\'--vocab_file\', type=str, required=True)\n    parser.add_argument(\'--init_restore_dir\', type=str, required=True)\n    parser.add_argument(\'--checkpoint_dir\', type=str, required=True)\n    parser.add_argument(\'--task_name\', type=str, required=True)\n    parser.add_argument(\'--setting_file\', type=str, default=\'setting.txt\')\n    parser.add_argument(\'--log_file\', type=str, default=\'log.txt\')\n\n    # use some global vars for convenience\n    args = parser.parse_args()\n\n    if args.task_name.lower() == \'drcd\':\n        from preprocess.DRCD_output import write_predictions\n        from preprocess.DRCD_preprocess import json2features\n    elif args.task_name.lower() == \'cmrc2018\':\n        from preprocess.cmrc2018_output import write_predictions\n        from preprocess.cmrc2018_preprocess import json2features\n    else:\n        raise NotImplementedError\n\n    args.train_dir = args.train_dir.replace(\'features.json\', \'features_\' + str(args.max_seq_length) + \'.json\')\n    args.dev_dir1 = args.dev_dir1.replace(\'examples.json\', \'examples_\' + str(args.max_seq_length) + \'.json\')\n    args.dev_dir2 = args.dev_dir2.replace(\'features.json\', \'features_\' + str(args.max_seq_length) + \'.json\')\n    args = utils.check_args(args)\n    os.environ[""CUDA_VISIBLE_DEVICES""] = args.gpu_ids\n    device = torch.device(""cuda"")\n    n_gpu = torch.cuda.device_count()\n    print(""device %s n_gpu %d"" % (device, n_gpu))\n    print(""device: {} n_gpu: {} 16-bits training: {}"".format(device, n_gpu, args.float16))\n\n    # load the bert setting\n    if \'albert\' not in args.bert_config_file:\n        bert_config = BertConfig.from_json_file(args.bert_config_file)\n    else:\n        if \'google\' in args.bert_config_file:\n            bert_config = AlbertConfig.from_json_file(args.bert_config_file)\n        else:\n            bert_config = ALBertConfig.from_json_file(args.bert_config_file)\n\n    # load data\n    print(\'loading data...\')\n    tokenizer = tokenization.BertTokenizer(vocab_file=args.vocab_file, do_lower_case=True)\n    assert args.vocab_size == len(tokenizer.vocab)\n    if not os.path.exists(args.train_dir):\n        json2features(args.train_file, [args.train_dir.replace(\'_features_\', \'_examples_\'), args.train_dir],\n                      tokenizer, is_training=True,\n                      max_seq_length=args.max_seq_length)\n\n    if not os.path.exists(args.dev_dir1) or not os.path.exists(args.dev_dir2):\n        json2features(args.dev_file, [args.dev_dir1, args.dev_dir2], tokenizer, is_training=False,\n                      max_seq_length=args.max_seq_length)\n\n    train_features = json.load(open(args.train_dir, \'r\'))\n    dev_examples = json.load(open(args.dev_dir1, \'r\'))\n    dev_features = json.load(open(args.dev_dir2, \'r\'))\n    if os.path.exists(args.log_file):\n        os.remove(args.log_file)\n\n    steps_per_epoch = len(train_features) // args.n_batch\n    eval_steps = int(steps_per_epoch * args.eval_epochs)\n    dev_steps_per_epoch = len(dev_features) // args.n_batch\n    if len(train_features) % args.n_batch != 0:\n        steps_per_epoch += 1\n    if len(dev_features) % args.n_batch != 0:\n        dev_steps_per_epoch += 1\n    total_steps = steps_per_epoch * args.train_epochs\n\n    print(\'steps per epoch:\', steps_per_epoch)\n    print(\'total steps:\', total_steps)\n    print(\'warmup steps:\', int(args.warmup_rate * total_steps))\n\n    F1s = []\n    EMs = []\n    # \xe5\xad\x98\xe4\xb8\x80\xe4\xb8\xaa\xe5\x85\xa8\xe5\xb1\x80\xe6\x9c\x80\xe4\xbc\x98\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\n    best_f1_em = 0\n\n    for seed_ in args.seed:\n        best_f1, best_em = 0, 0\n        with open(args.log_file, \'a\') as aw:\n            aw.write(\'===================================\' +\n                     \'SEED:\' + str(seed_)\n                     + \'===================================\' + \'\\n\')\n        print(\'SEED:\', seed_)\n\n        random.seed(seed_)\n        np.random.seed(seed_)\n        torch.manual_seed(seed_)\n        if n_gpu > 0:\n            torch.cuda.manual_seed_all(seed_)\n\n        # init model\n        print(\'init model...\')\n        if \'albert\' not in args.init_restore_dir:\n            model = BertForQuestionAnswering(bert_config)\n        else:\n            if \'google\' in args.init_restore_dir:\n                model = AlbertForMRC(bert_config)\n            else:\n                model = ALBertForQA(bert_config, dropout_rate=args.dropout)\n        utils.torch_show_all_params(model)\n        utils.torch_init_model(model, args.init_restore_dir)\n        if args.float16:\n            model.half()\n        model.to(device)\n        if n_gpu > 1:\n            model = torch.nn.DataParallel(model)\n        optimizer = get_optimization(model=model,\n                                     float16=args.float16,\n                                     learning_rate=args.lr,\n                                     total_steps=total_steps,\n                                     schedule=args.schedule,\n                                     warmup_rate=args.warmup_rate,\n                                     max_grad_norm=args.clip_norm,\n                                     weight_decay_rate=args.weight_decay_rate)\n\n        all_input_ids = torch.tensor([f[\'input_ids\'] for f in train_features], dtype=torch.long)\n        all_input_mask = torch.tensor([f[\'input_mask\'] for f in train_features], dtype=torch.long)\n        all_segment_ids = torch.tensor([f[\'segment_ids\'] for f in train_features], dtype=torch.long)\n\n        seq_len = all_input_ids.shape[1]\n        # \xe6\xa0\xb7\xe6\x9c\xac\xe9\x95\xbf\xe5\xba\xa6\xe4\xb8\x8d\xe8\x83\xbd\xe8\xb6\x85\xe8\xbf\x87bert\xe7\x9a\x84\xe9\x95\xbf\xe5\xba\xa6\xe9\x99\x90\xe5\x88\xb6\n        assert seq_len <= bert_config.max_position_embeddings\n\n        # true label\n        all_start_positions = torch.tensor([f[\'start_position\'] for f in train_features], dtype=torch.long)\n        all_end_positions = torch.tensor([f[\'end_position\'] for f in train_features], dtype=torch.long)\n\n        train_data = TensorDataset(all_input_ids, all_input_mask, all_segment_ids,\n                                   all_start_positions, all_end_positions)\n        train_dataloader = DataLoader(train_data, batch_size=args.n_batch, shuffle=True)\n\n        print(\'***** Training *****\')\n        model.train()\n        global_steps = 1\n        best_em = 0\n        best_f1 = 0\n        for i in range(int(args.train_epochs)):\n            print(\'Starting epoch %d\' % (i + 1))\n            total_loss = 0\n            iteration = 1\n            with tqdm(total=steps_per_epoch, desc=\'Epoch %d\' % (i + 1)) as pbar:\n                for step, batch in enumerate(train_dataloader):\n                    batch = tuple(t.to(device) for t in batch)\n                    input_ids, input_mask, segment_ids, start_positions, end_positions = batch\n                    loss = model(input_ids, segment_ids, input_mask, start_positions, end_positions)\n                    if n_gpu > 1:\n                        loss = loss.mean()  # mean() to average on multi-gpu.\n                    total_loss += loss.item()\n                    pbar.set_postfix({\'loss\': \'{0:1.5f}\'.format(total_loss / (iteration + 1e-5))})\n                    pbar.update(1)\n\n                    if args.float16:\n                        optimizer.backward(loss)\n                        # modify learning rate with special warm up BERT uses\n                        # if args.fp16 is False, BertAdam is used and handles this automatically\n                        lr_this_step = args.lr * warmup_linear(global_steps / total_steps, args.warmup_rate)\n                        for param_group in optimizer.param_groups:\n                            param_group[\'lr\'] = lr_this_step\n                    else:\n                        loss.backward()\n\n                    optimizer.step()\n                    model.zero_grad()\n                    global_steps += 1\n                    iteration += 1\n\n                    if global_steps % eval_steps == 0:\n                        best_f1, best_em, best_f1_em = evaluate(model, args, dev_examples, dev_features, device,\n                                                                global_steps, best_f1, best_em, best_f1_em)\n\n        F1s.append(best_f1)\n        EMs.append(best_em)\n\n        # release the memory\n        del model\n        del optimizer\n        torch.cuda.empty_cache()\n\n    print(\'Mean F1:\', np.mean(F1s), \'Mean EM:\', np.mean(EMs))\n    print(\'Best F1:\', np.max(F1s), \'Best EM:\', np.max(EMs))\n    with open(args.log_file, \'a\') as aw:\n        aw.write(\'Mean(Best) F1:{}({})\\n\'.format(np.mean(F1s), np.max(F1s)))\n        aw.write(\'Mean(Best) EM:{}({})\\n\'.format(np.mean(EMs), np.max(EMs)))\n'"
baselines/models_pytorch/mrc_pytorch/run_multichoice_mrc.py,0,"b'""""""\n@name = \'roberta_wwm_ext_large\'\n@author = \'zhangxinrui\'\n@time = \'2019/11/15\'\nroberta_wwm_ext_large \xe7\x9a\x84baseline\xe7\x89\x88\xe6\x9c\xac\n\ncoding=utf-8\nCopyright 2018 The Google AI Language Team Authors and The HugginFace Inc. team.\nCopyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the ""License"");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an ""AS IS"" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n""""""\n\nfrom __future__ import print_function\n\nimport argparse\nimport os\nimport random\n\nimport numpy as np\nimport torch\nfrom google_albert_pytorch_modeling import AlbertConfig, AlbertForMultipleChoice\nfrom preprocess.CHID_preprocess import RawResult, get_final_predictions, write_predictions, generate_input, evaluate\nfrom pytorch_modeling import ALBertConfig, ALBertForMultipleChoice\nfrom pytorch_modeling import BertConfig, BertForMultipleChoice\nfrom tools.official_tokenization import BertTokenizer\nfrom tools.pytorch_optimization import get_optimization, warmup_linear\nfrom torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler\nfrom tqdm import tqdm\n\n\ndef reset_model(args, bert_config, model_cls):\n    # Prepare model\n    model = model_cls(bert_config, num_choices=args.max_num_choices)\n    if args.init_restore_dir is not None:\n        print(\'load bert weight\')\n        state_dict = torch.load(args.init_restore_dir, map_location=\'cpu\')\n        missing_keys = []\n        unexpected_keys = []\n        error_msgs = []\n        # copy state_dict so _load_from_state_dict can modify it\n        metadata = getattr(state_dict, \'_metadata\', None)\n        state_dict = state_dict.copy()\n        if metadata is not None:\n            state_dict._metadata = metadata\n\n        def load(module, prefix=\'\'):\n            local_metadata = {} if metadata is None else metadata.get(prefix[:-1], {})\n\n            module._load_from_state_dict(\n                state_dict, prefix, local_metadata, True, missing_keys, unexpected_keys, error_msgs)\n            for name, child in module._modules.items():\n                if child is not None:\n                    load(child, prefix + name + \'.\')\n\n        load(model, prefix=\'\' if hasattr(model, \'bert\') else \'bert.\')\n        print(""missing keys:{}"".format(missing_keys))\n        print(\'unexpected keys:{}\'.format(unexpected_keys))\n        print(\'error msgs:{}\'.format(error_msgs))\n\n    if args.fp16:\n        model.half()\n\n    return model\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(""--gpu_ids"", default=\'\', required=True, type=str)\n    parser.add_argument(""--bert_config_file"", required=True,\n                        default=\'check_points/pretrain_models/roberta_wwm_ext_large/bert_config.json\')\n    parser.add_argument(""--vocab_file"", required=True,\n                        default=\'check_points/pretrain_models/roberta_wwm_ext_large/vocab.txt\')\n    parser.add_argument(""--init_restore_dir"", required=True,\n                        default=\'check_points/pretrain_models/roberta_wwm_ext_large/pytorch_model.pth\')\n    parser.add_argument(""--input_dir"", required=True, default=\'dataset/CHID\')\n    parser.add_argument(""--output_dir"", required=True, default=\'check_points/CHID\')\n\n    ## Other parameters\n    parser.add_argument(""--train_file"", default=\'./origin_data/CHID/train.json\', type=str,\n                        help=""SQuAD json for training. E.g., train-v1.1.json"")\n    parser.add_argument(""--train_ans_file"", default=\'./origin_data/CHID/train_answer.json\', type=str,\n                        help=""SQuAD answer for training. E.g., train-v1.1.json"")\n    parser.add_argument(""--predict_file"", default=\'./origin_data/CHID/dev.json\', type=str,\n                        help=""SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json"")\n    parser.add_argument(""--predict_ans_file"", default=\'origin_data/CHID/dev_answer.json\', type=str,\n                        help=""SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json"")\n    parser.add_argument(""--max_seq_length"", default=64, type=int,\n                        help=""The maximum total input sequence length after WordPiece tokenization. Sequences ""\n                             ""longer than this will be truncated, and sequences shorter than this will be padded."")\n    parser.add_argument(""--max_num_choices"", default=10, type=int,\n                        help=""The maximum number of cadicate answer,  shorter than this will be padded."")\n    parser.add_argument(""--train_batch_size"", default=20, type=int, help=""Total batch size for training."")\n    parser.add_argument(""--predict_batch_size"", default=16, type=int, help=""Total batch size for predictions."")\n    parser.add_argument(""--learning_rate"", default=2e-5, type=float, help=""The initial learning rate for Adam."")\n    parser.add_argument(""--num_train_epochs"", default=3.0, type=float,\n                        help=""Total number of training epochs to perform."")\n    parser.add_argument(""--warmup_proportion"", default=0.06, type=float,\n                        help=""Proportion of training to perform linear learning rate warmup for. E.g., 0.1 = 10% ""\n                             ""of training."")\n    parser.add_argument(\'--seed\', type=int, default=42, help=""random seed for initialization"")\n    parser.add_argument(\'--gradient_accumulation_steps\', type=int, default=1,\n                        help=""Number of updates steps to accumulate before performing a backward/update pass."")\n    parser.add_argument(""--do_lower_case"", default=True,\n                        help=""Whether to lower case the input text. True for uncased models, False for cased models."")\n    parser.add_argument(\'--fp16\', default=False, action=\'store_true\',\n                        help=""Whether to use 16-bit float precision instead of 32-bit"")\n\n    args = parser.parse_args()\n    print(args)\n    os.environ[""CUDA_VISIBLE_DEVICES""] = args.gpu_ids\n\n    device = torch.device(""cuda"" if torch.cuda.is_available() else ""cpu"")\n    n_gpu = torch.cuda.device_count()\n    print(""device: {} n_gpu: {}, 16-bits training: {}"".format(device, n_gpu, args.fp16))\n\n    if args.gradient_accumulation_steps < 1:\n        raise ValueError(""Invalid gradient_accumulation_steps parameter: {}, should be >= 1"".format(\n            args.gradient_accumulation_steps))\n\n    args.train_batch_size = int(args.train_batch_size / args.gradient_accumulation_steps)\n\n    random.seed(args.seed)\n    np.random.seed(args.seed)\n    torch.manual_seed(args.seed)\n    if n_gpu > 0:\n        torch.cuda.manual_seed_all(args.seed)\n\n    if os.path.exists(args.input_dir) == False:\n        os.makedirs(args.input_dir, exist_ok=True)\n    if os.path.exists(args.output_dir) == False:\n        os.makedirs(args.output_dir, exist_ok=True)\n\n    tokenizer = BertTokenizer(vocab_file=args.vocab_file, do_lower_case=args.do_lower_case)\n\n    print(\'ready for train dataset\')\n\n    train_example_file = os.path.join(args.input_dir, \'train_examples_{}.pkl\'.format(str(args.max_seq_length)))\n    train_feature_file = os.path.join(args.input_dir, \'train_features_{}.pkl\'.format(str(args.max_seq_length)))\n\n    train_features = generate_input(args.train_file, args.train_ans_file, train_example_file, train_feature_file,\n                                    tokenizer, max_seq_length=args.max_seq_length,\n                                    max_num_choices=args.max_num_choices,\n                                    is_training=True)\n\n    dev_example_file = os.path.join(args.input_dir, \'dev_examples_{}.pkl\'.format(str(args.max_seq_length)))\n    dev_feature_file = os.path.join(args.input_dir, \'dev_features_{}.pkl\'.format(str(args.max_seq_length)))\n\n    eval_features = generate_input(args.predict_file, None, dev_example_file, dev_feature_file, tokenizer,\n                                   max_seq_length=args.max_seq_length, max_num_choices=args.max_num_choices,\n                                   is_training=False)\n\n    print(""train features {}"".format(len(train_features)))\n    num_train_steps = int(\n        len(train_features) / args.train_batch_size / args.gradient_accumulation_steps * args.num_train_epochs)\n\n    print(""loaded train dataset"")\n    print(""Num generate examples = {}"".format(len(train_features)))\n    print(""Batch size = {}"".format(args.train_batch_size))\n    print(""Num steps for a epoch = {}"".format(num_train_steps))\n\n    all_input_ids = torch.tensor([f.input_ids for f in train_features], dtype=torch.long)\n    all_input_masks = torch.tensor([f.input_masks for f in train_features], dtype=torch.long)\n    all_segment_ids = torch.tensor([f.segment_ids for f in train_features], dtype=torch.long)\n    all_choice_masks = torch.tensor([f.choice_masks for f in train_features], dtype=torch.long)\n    all_labels = torch.tensor([f.label for f in train_features], dtype=torch.long)\n\n    train_data = TensorDataset(all_input_ids, all_input_masks, all_segment_ids, all_choice_masks, all_labels)\n    train_sampler = RandomSampler(train_data)\n    train_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=args.train_batch_size,\n                                  drop_last=True)\n\n    all_example_ids = [f.example_id for f in eval_features]\n    all_tags = [f.tag for f in eval_features]\n    all_input_ids = torch.tensor([f.input_ids for f in eval_features], dtype=torch.long)\n    all_input_masks = torch.tensor([f.input_masks for f in eval_features], dtype=torch.long)\n    all_segment_ids = torch.tensor([f.segment_ids for f in eval_features], dtype=torch.long)\n    all_choice_masks = torch.tensor([f.choice_masks for f in eval_features], dtype=torch.long)\n    all_example_index = torch.arange(all_input_ids.size(0), dtype=torch.long)\n    eval_data = TensorDataset(all_input_ids, all_input_masks, all_segment_ids, all_choice_masks,\n                              all_example_index)\n    # Run prediction for full data\n    eval_sampler = SequentialSampler(eval_data)\n    eval_dataloader = DataLoader(eval_data, sampler=eval_sampler, batch_size=args.predict_batch_size)\n\n    # Prepare model\n    if \'albert\' in args.bert_config_file:\n        if \'google\' in args.bert_config_file:\n            bert_config = AlbertConfig.from_json_file(args.bert_config_file)\n            model = reset_model(args, bert_config, AlbertForMultipleChoice)\n        else:\n            bert_config = ALBertConfig.from_json_file(args.bert_config_file)\n            model = reset_model(args, bert_config, ALBertForMultipleChoice)\n    else:\n        bert_config = BertConfig.from_json_file(args.bert_config_file)\n        model = reset_model(args, bert_config, BertForMultipleChoice)\n    model = model.to(device)\n    if n_gpu > 1:\n        model = torch.nn.DataParallel(model)\n\n    optimizer = get_optimization(model,\n                                 float16=args.fp16,\n                                 learning_rate=args.learning_rate,\n                                 total_steps=num_train_steps,\n                                 schedule=\'warmup_linear\',\n                                 warmup_rate=args.warmup_proportion,\n                                 weight_decay_rate=0.01,\n                                 max_grad_norm=1.0,\n                                 opt_pooler=True)\n\n    global_step = 0\n    best_acc = 0\n    acc = 0\n    for i in range(int(args.num_train_epochs)):\n        num_step = 0\n        average_loss = 0\n        model.train()\n        model.zero_grad()  # \xe7\xad\x89\xe4\xbb\xb7\xe4\xba\x8eoptimizer.zero_grad()\n        steps_per_epoch = num_train_steps // args.num_train_epochs\n        with tqdm(total=int(steps_per_epoch), desc=\'Epoch %d\' % (i + 1)) as pbar:\n            for step, batch in enumerate(train_dataloader):\n                if n_gpu == 1:\n                    batch = tuple(t.to(device) for t in batch)  # multi-gpu does scattering it-self\n                input_ids, input_masks, segment_ids, choice_masks, labels = batch\n                if step == 0 and i == 0:\n                    print(\'shape of input_ids: {}\'.format(input_ids.shape))\n                    print(\'shape of labels: {}\'.format(labels.shape))\n                loss = model(input_ids=input_ids,\n                             token_type_ids=segment_ids,\n                             attention_mask=input_masks,\n                             labels=labels)\n                if n_gpu > 1:\n                    loss = loss.mean()  # mean() to average on multi-gpu.\n                if args.gradient_accumulation_steps > 1:\n                    loss = loss / args.gradient_accumulation_steps\n                if args.fp16:\n                    optimizer.backward(loss)\n                    # modify learning rate with special warm up BERT uses\n                    # if args.fp16 is False, BertAdam is used and handles this automatically\n                    lr_this_step = args.learning_rate * warmup_linear(global_step / num_train_steps,\n                                                                      args.warmup_proportion)\n                    for param_group in optimizer.param_groups:\n                        param_group[\'lr\'] = lr_this_step\n                else:\n                    loss.backward()\n                if (step + 1) % args.gradient_accumulation_steps == 0:\n                    optimizer.step()\n                    optimizer.zero_grad()\n                    global_step += 1\n\n                average_loss += loss.item()\n                num_step += 1\n\n                pbar.set_postfix({\'loss\': \'{0:1.5f}\'.format(average_loss / (num_step + 1e-5))})\n                pbar.update(1)\n\n        print(""***** Running predictions *****"")\n        print(""Num split examples = {}"".format(len(eval_features)))\n        print(""Batch size = {}"".format(args.predict_batch_size))\n\n        model.eval()\n        all_results = []\n        print(""Start evaluating"")\n        for input_ids, input_masks, segment_ids, choice_masks, example_indices in tqdm(eval_dataloader,\n                                                                                       desc=""Evaluating"",\n                                                                                       disable=None):\n            if len(all_results) == 0:\n                print(\'shape of input_ids: {}\'.format(input_ids.shape))\n            input_ids = input_ids.to(device)\n            input_masks = input_masks.to(device)\n            segment_ids = segment_ids.to(device)\n            with torch.no_grad():\n                batch_logits = model(input_ids=input_ids,\n                                     token_type_ids=segment_ids,\n                                     attention_mask=input_masks,\n                                     labels=None)\n            for i, example_index in enumerate(example_indices):\n                logits = batch_logits[i].detach().cpu().tolist()\n                eval_feature = eval_features[example_index.item()]\n                unique_id = int(eval_feature.unique_id)\n                all_results.append(RawResult(unique_id=unique_id,\n                                             example_id=all_example_ids[unique_id],\n                                             tag=all_tags[unique_id],\n                                             logit=logits))\n\n        predict_file = \'dev_predictions.json\'\n        print(\'decoder raw results\')\n        tmp_predict_file = os.path.join(args.output_dir, ""raw_predictions.pkl"")\n        output_prediction_file = os.path.join(args.output_dir, predict_file)\n        results = get_final_predictions(all_results, tmp_predict_file, g=True)\n        write_predictions(results, output_prediction_file)\n        print(\'predictions saved to {}\'.format(output_prediction_file))\n\n        if args.predict_ans_file:\n            acc = evaluate(args.predict_ans_file, output_prediction_file)\n            print(f\'{args.predict_file} \xe9\xa2\x84\xe6\xb5\x8b\xe7\xb2\xbe\xe5\xba\xa6\xef\xbc\x9a{acc}\')\n\n        # Save a epoch trained model\n        if acc > best_acc:\n            best_acc = acc\n            output_model_file = os.path.join(args.output_dir, ""best_checkpoint.bin"")\n            print(\'save trained model from {}\'.format(output_model_file))\n            model_to_save = model.module if hasattr(model, \'module\') else model  # Only save the model it-self\n            torch.save(model_to_save.state_dict(), output_model_file)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
baselines/models_pytorch/mrc_pytorch/test_mrc.py,0,"b'import argparse\nimport collections\nimport json\nimport os\nfrom glob import glob\n\nimport torch\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom tqdm import tqdm\n\nfrom pytorch_modeling import BertConfig, BertForQuestionAnswering, ALBertConfig, ALBertForQA\nfrom google_albert_pytorch_modeling import AlbertConfig, AlbertForMRC\nfrom tools import official_tokenization as tokenization\nfrom tools import utils\n\n\ndef test(model, args, eval_examples, eval_features, device):\n    print(""***** Eval *****"")\n    RawResult = collections.namedtuple(""RawResult"",\n                                       [""unique_id"", ""start_logits"", ""end_logits""])\n    output_prediction_file = os.path.join(args.output_dir, args.output_file)\n    output_nbest_file = output_prediction_file.replace(\'predictions\', \'nbest\')\n\n    all_input_ids = torch.tensor([f[\'input_ids\'] for f in eval_features], dtype=torch.long)\n    all_input_mask = torch.tensor([f[\'input_mask\'] for f in eval_features], dtype=torch.long)\n    all_segment_ids = torch.tensor([f[\'segment_ids\'] for f in eval_features], dtype=torch.long)\n    all_example_index = torch.arange(all_input_ids.size(0), dtype=torch.long)\n\n    eval_data = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_example_index)\n    eval_dataloader = DataLoader(eval_data, batch_size=args.n_batch, shuffle=False)\n\n    model.eval()\n    all_results = []\n    print(""Start evaluating"")\n    for input_ids, input_mask, segment_ids, example_indices in tqdm(eval_dataloader, desc=""Evaluating""):\n        input_ids = input_ids.to(device)\n        input_mask = input_mask.to(device)\n        segment_ids = segment_ids.to(device)\n        with torch.no_grad():\n            batch_start_logits, batch_end_logits = model(input_ids, segment_ids, input_mask)\n\n        for i, example_index in enumerate(example_indices):\n            start_logits = batch_start_logits[i].detach().cpu().tolist()\n            end_logits = batch_end_logits[i].detach().cpu().tolist()\n            eval_feature = eval_features[example_index.item()]\n            unique_id = int(eval_feature[\'unique_id\'])\n            all_results.append(RawResult(unique_id=unique_id,\n                                         start_logits=start_logits,\n                                         end_logits=end_logits))\n\n    write_predictions(eval_examples, eval_features, all_results,\n                      n_best_size=args.n_best, max_answer_length=args.max_ans_length,\n                      do_lower_case=True, output_prediction_file=output_prediction_file,\n                      output_nbest_file=output_nbest_file)\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'--gpu_ids\', type=str, default=\'0\')\n    parser.add_argument(\'--task_name\', type=str, required=True, default=\'cmrc2018\')\n\n    # training parameter\n    parser.add_argument(\'--n_batch\', type=int, default=32)\n    parser.add_argument(\'--float16\', action=\'store_true\', default=False)  # only sm >= 7.0 (tensorcores)\n    parser.add_argument(\'--max_ans_length\', type=int, default=50)\n    parser.add_argument(\'--n_best\', type=int, default=20)\n    parser.add_argument(\'--vocab_size\', type=int, default=21128)\n    parser.add_argument(\'--max_seq_length\', type=int, default=256)\n\n    # data dir\n    parser.add_argument(\'--test_dir1\', type=str, required=True)\n    parser.add_argument(\'--test_dir2\', type=str, required=True)\n    parser.add_argument(\'--test_file\', type=str, default=\'cmrc2018_test_2k.json\')\n    parser.add_argument(\'--bert_config_file\', type=str, required=True)\n    parser.add_argument(\'--vocab_file\', type=str, required=True)\n    parser.add_argument(\'--init_restore_dir\', type=str, required=True)\n    parser.add_argument(\'--output_dir\', type=str, required=True)\n    parser.add_argument(\'--output_file\', type=str, default=\'predictions_test.json\')\n\n    # use some global vars for convenience\n    args = parser.parse_args()\n\n    if args.task_name.lower() == \'drcd\':\n        from preprocess.DRCD_output import write_predictions\n        from preprocess.DRCD_preprocess import json2features\n    elif args.task_name.lower() == \'cmrc2018\':\n        from preprocess.cmrc2018_output import write_predictions\n        from preprocess.cmrc2018_preprocess import json2features\n    else:\n        raise NotImplementedError\n\n    args.test_dir1 = args.test_dir1.replace(\'examples.json\', \'examples_\' + str(args.max_seq_length) + \'.json\')\n    args.test_dir2 = args.test_dir2.replace(\'features.json\', \'features_\' + str(args.max_seq_length) + \'.json\')\n\n    if args.init_restore_dir.endswith(\'.pth\') or \\\n            args.init_restore_dir.endswith(\'.pt\') or \\\n            args.init_restore_dir.endswith(\'.bin\'):\n        pass\n    else:\n        args.init_restore_dir = glob(args.init_restore_dir + \'*.pth\')\n        assert len(args.init_restore_dir) == 1\n        args.init_restore_dir = args.init_restore_dir[0]\n\n    os.environ[""CUDA_VISIBLE_DEVICES""] = args.gpu_ids\n    device = torch.device(""cuda"")\n    n_gpu = torch.cuda.device_count()\n    print(""device %s n_gpu %d"" % (device, n_gpu))\n    print(""device: {} n_gpu: {} 16-bits training: {}"".format(device, n_gpu, args.float16))\n\n    # load the bert setting\n    if \'albert\' not in args.bert_config_file:\n        bert_config = BertConfig.from_json_file(args.bert_config_file)\n    else:\n        if \'google\' in args.bert_config_file:\n            bert_config = AlbertConfig.from_json_file(args.bert_config_file)\n        else:\n            bert_config = ALBertConfig.from_json_file(args.bert_config_file)\n\n    # load data\n    print(\'loading data...\')\n    tokenizer = tokenization.BertTokenizer(vocab_file=args.vocab_file, do_lower_case=True)\n    assert args.vocab_size == len(tokenizer.vocab)\n\n    if not os.path.exists(args.test_dir1) or not os.path.exists(args.test_dir2):\n        json2features(args.test_file, [args.test_dir1, args.test_dir2], tokenizer, is_training=False,\n                      max_seq_length=args.max_seq_length)\n\n    if not os.path.exists(args.test_dir1):\n        json2features(input_file=args.test_file, output_files=[args.test_dir1, args.test_dir2],\n                      tokenizer=tokenizer, is_training=False, repeat_limit=3, max_query_length=64,\n                      max_seq_length=args.max_seq_length, doc_stride=128)\n    test_examples = json.load(open(args.test_dir1, \'r\'))\n    test_features = json.load(open(args.test_dir2, \'r\'))\n\n    dev_steps_per_epoch = len(test_features) // args.n_batch\n    if len(test_features) % args.n_batch != 0:\n        dev_steps_per_epoch += 1\n\n    # init model\n    print(\'init model...\')\n    if \'albert\' not in args.init_restore_dir:\n        model = BertForQuestionAnswering(bert_config)\n    else:\n        if \'google\' in args.init_restore_dir:\n            model = AlbertForMRC(bert_config)\n        else:\n            model = ALBertForQA(bert_config, dropout_rate=args.dropout)\n    utils.torch_show_all_params(model)\n    utils.torch_init_model(model, args.init_restore_dir)\n    if args.float16:\n        model.half()\n    model.to(device)\n    if n_gpu > 1:\n        model = torch.nn.DataParallel(model)\n\n    test(model, args, test_examples, test_features, device)\n'"
baselines/models_pytorch/mrc_pytorch/test_multichoice_mrc.py,0,"b'from __future__ import print_function\n\nimport argparse\nimport os\nfrom glob import glob\n\nimport torch\nfrom google_albert_pytorch_modeling import AlbertConfig, AlbertForMultipleChoice\nfrom preprocess.CHID_preprocess import RawResult, get_final_predictions, write_predictions, \\\n    generate_input\nfrom pytorch_modeling import ALBertConfig, ALBertForMultipleChoice\nfrom pytorch_modeling import BertConfig, BertForMultipleChoice\nfrom tools.official_tokenization import BertTokenizer\nfrom torch.utils.data import TensorDataset, DataLoader, SequentialSampler\nfrom tqdm import tqdm\n\n\ndef torch_init_model(model, init_restore_dir):\n    state_dict = torch.load(init_restore_dir, map_location=\'cpu\')\n    missing_keys = []\n    unexpected_keys = []\n    error_msgs = []\n    # copy state_dict so _load_from_state_dict can modify it\n    metadata = getattr(state_dict, \'_metadata\', None)\n    state_dict = state_dict.copy()\n    if metadata is not None:\n        state_dict._metadata = metadata\n\n    def load(module, prefix=\'\'):\n        local_metadata = {} if metadata is None else metadata.get(prefix[:-1], {})\n\n        module._load_from_state_dict(\n            state_dict, prefix, local_metadata, True, missing_keys, unexpected_keys, error_msgs)\n        for name, child in module._modules.items():\n            if child is not None:\n                load(child, prefix + name + \'.\')\n\n    load(model, prefix=\'\' if hasattr(model, \'bert\') else \'bert.\')\n\n    print(""missing keys:{}"".format(missing_keys))\n    print(\'unexpected keys:{}\'.format(unexpected_keys))\n    print(\'error msgs:{}\'.format(error_msgs))\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(""--gpu_ids"", default=\'0\', type=str)\n    parser.add_argument(""--bert_config_file"",\n                        default=\'check_points/pretrain_models/bert_wwm_ext_base/bert_config.json\',\n                        type=str,\n                        help=""The config json file corresponding to the pre-trained BERT model. ""\n                             ""This specifies the model architecture."")\n    parser.add_argument(""--vocab_file"", default=\'check_points/pretrain_models/bert_wwm_ext_base/vocab.txt\',\n                        type=str,\n                        help=""The vocabulary file that the BERT model was trained on."")\n    parser.add_argument(""--init_restore_dir"",\n                        required=True,\n                        type=str,\n                        help=""Initial checkpoint (usually from a pre-trained BERT model)."")\n    parser.add_argument(""--input_dir"", required=True, default=\'dataset/CHID\')\n    parser.add_argument(""--output_dir"", required=True, type=str,\n                        help=""The output directory where the model checkpoints and predictions will be written."")\n    parser.add_argument(""--predict_file"",\n                        required=True,\n                        type=str,\n                        help=""Initial checkpoint (usually from a pre-trained BERT model)."")\n    parser.add_argument(\'--output_file\', type=str, default=\'test_predictions.json\')\n\n    ## Other parameters\n    parser.add_argument(""--max_seq_length"", default=64, type=int,\n                        help=""The maximum total input sequence length after WordPiece tokenization. Sequences ""\n                             ""longer than this will be truncated, and sequences shorter than this will be padded."")\n    parser.add_argument(""--max_num_choices"", default=10, type=int,\n                        help=""The maximum number of cadicate answer,  shorter than this will be padded."")\n    parser.add_argument(""--predict_batch_size"", default=16, type=int, help=""Total batch size for predictions."")\n    parser.add_argument(""--do_lower_case"",\n                        default=True,\n                        help=""Whether to lower case the input text. True for uncased models, False for cased models."")\n    parser.add_argument(\'--fp16\',\n                        default=False,\n                        action=\'store_true\',\n                        help=""Whether to use 16-bit float precision instead of 32-bit"")\n\n    args = parser.parse_args()\n    print(args)\n    os.environ[""CUDA_VISIBLE_DEVICES""] = args.gpu_ids\n\n    device = torch.device(""cuda"" if torch.cuda.is_available() else ""cpu"")\n    print(""device: {}, 16-bits training: {}"".format(device, args.fp16))\n\n    tokenizer = BertTokenizer(vocab_file=args.vocab_file, do_lower_case=args.do_lower_case)\n\n    test_example_file = os.path.join(args.input_dir, \'test_examples_{}.pkl\'.format(str(args.max_seq_length)))\n    test_feature_file = os.path.join(args.input_dir, \'test_features_{}.pkl\'.format(str(args.max_seq_length)))\n\n    eval_features = generate_input(args.predict_file, None, test_example_file, test_feature_file, tokenizer,\n                                   max_seq_length=args.max_seq_length, max_num_choices=args.max_num_choices,\n                                   is_training=False)\n\n    # Prepare model\n    if \'albert\' in args.bert_config_file:\n        if \'google\' in args.bert_config_file:\n            bert_config = AlbertConfig.from_json_file(args.bert_config_file)\n            model = AlbertForMultipleChoice(bert_config, num_choices=args.max_num_choices)\n        else:\n            bert_config = ALBertConfig.from_json_file(args.bert_config_file)\n            model = ALBertForMultipleChoice(bert_config, num_choices=args.max_num_choices)\n    else:\n        bert_config = BertConfig.from_json_file(args.bert_config_file)\n        model = BertForMultipleChoice(bert_config, num_choices=args.max_num_choices)\n    model = model.to(device)\n    if args.init_restore_dir.endswith(\'.pth\') or \\\n            args.init_restore_dir.endswith(\'.pt\') or \\\n            args.init_restore_dir.endswith(\'.bin\'):\n        pass\n    else:\n        args.init_restore_dir = glob(args.init_restore_dir + \'*.pth\') + \\\n                                glob(args.init_restore_dir + \'*.pt\') + \\\n                                glob(args.init_restore_dir + \'*.bin\')\n        assert len(args.init_restore_dir) == 1\n        args.init_restore_dir = args.init_restore_dir[0]\n    torch_init_model(model, args.init_restore_dir)\n    if args.fp16:\n        model = model.half()\n\n    print(""***** Running predictions *****"")\n    print(""Num split examples = %d"", len(eval_features))\n    print(""Batch size = %d"", args.predict_batch_size)\n\n    all_example_ids = [f.example_id for f in eval_features]\n    all_tags = [f.tag for f in eval_features]\n    all_input_ids = torch.tensor([f.input_ids for f in eval_features], dtype=torch.long)\n    all_input_masks = torch.tensor([f.input_masks for f in eval_features], dtype=torch.long)\n    all_segment_ids = torch.tensor([f.segment_ids for f in eval_features], dtype=torch.long)\n    all_choice_masks = torch.tensor([f.choice_masks for f in eval_features], dtype=torch.long)\n    all_example_index = torch.arange(all_input_ids.size(0), dtype=torch.long)\n    eval_data = TensorDataset(all_input_ids, all_input_masks, all_segment_ids, all_choice_masks,\n                              all_example_index)\n    # Run prediction for full data\n    eval_sampler = SequentialSampler(eval_data)\n    eval_dataloader = DataLoader(eval_data, sampler=eval_sampler, batch_size=args.predict_batch_size)\n\n    model.eval()\n    all_results = []\n    print(""Start evaluating"")\n    for input_ids, input_masks, segment_ids, choice_masks, example_indices in tqdm(eval_dataloader,\n                                                                                   desc=""Evaluating"",\n                                                                                   disable=None):\n        if len(all_results) == 0:\n            print(\'shape of input_ids: {}\'.format(input_ids.shape))\n        input_ids = input_ids.to(device)\n        input_masks = input_masks.to(device)\n        segment_ids = segment_ids.to(device)\n        with torch.no_grad():\n            batch_logits = model(input_ids=input_ids,\n                                 token_type_ids=segment_ids,\n                                 attention_mask=input_masks,\n                                 labels=None)\n        for i, example_index in enumerate(example_indices):\n            logits = batch_logits[i].detach().cpu().tolist()\n            eval_feature = eval_features[example_index.item()]\n            unique_id = int(eval_feature.unique_id)\n            all_results.append(RawResult(unique_id=unique_id,\n                                         example_id=all_example_ids[unique_id],\n                                         tag=all_tags[unique_id],\n                                         logit=logits))\n    else:\n        print(""prediction is over"")\n\n    print(\'decoder raw results\')\n    tmp_predict_file = os.path.join(args.output_dir, ""test_raw_predictions.pkl"")\n    output_prediction_file = os.path.join(args.output_dir, args.output_file)\n    results = get_final_predictions(all_results, tmp_predict_file, g=True)\n    write_predictions(results, output_prediction_file)\n    print(\'predictions saved to {}\'.format(output_prediction_file))\n\n\nif __name__ == ""__main__"":\n    main()\n'"
baselines/models/albert/resources/create_pretraining_data_roberta.py,19,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Create masked LM/next sentence masked_lm TF examples for BERT.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport random\nimport re\nimport tokenization\nimport tensorflow as tf\nimport jieba\n\nflags = tf.flags\n\nFLAGS = flags.FLAGS\n\nflags.DEFINE_string(""input_file"", None,\n                    ""Input raw text file (or comma-separated list of files)."")\n\nflags.DEFINE_string(\n    ""output_file"", None,\n    ""Output TF example file (or comma-separated list of files)."")\n\nflags.DEFINE_string(""vocab_file"", None,\n                    ""The vocabulary file that the BERT model was trained on."")\n\nflags.DEFINE_bool(\n    ""do_lower_case"", True,\n    ""Whether to lower case the input text. Should be True for uncased ""\n    ""models and False for cased models."")\n\nflags.DEFINE_bool(\n    ""do_whole_word_mask"", False,\n    ""Whether to use whole word masking rather than per-WordPiece masking."")\n\nflags.DEFINE_integer(""max_seq_length"", 128, ""Maximum sequence length."")\n\nflags.DEFINE_integer(""max_predictions_per_seq"", 20,\n                     ""Maximum number of masked LM predictions per sequence."")\n\nflags.DEFINE_integer(""random_seed"", 12345, ""Random seed for data generation."")\n\nflags.DEFINE_integer(\n    ""dupe_factor"", 10,\n    ""Number of times to duplicate the input data (with different masks)."")\n\nflags.DEFINE_float(""masked_lm_prob"", 0.15, ""Masked LM probability."")\n\nflags.DEFINE_float(\n    ""short_seq_prob"", 0.1,\n    ""Probability of creating sequences which are shorter than the ""\n    ""maximum length."")\n\n\nclass TrainingInstance(object):\n    """"""A single training instance (sentence pair).""""""\n\n    def __init__(self, tokens, segment_ids, masked_lm_positions, masked_lm_labels,\n                 is_random_next):\n        self.tokens = tokens\n        self.segment_ids = segment_ids\n        self.is_random_next = is_random_next\n        self.masked_lm_positions = masked_lm_positions\n        self.masked_lm_labels = masked_lm_labels\n\n    def __str__(self):\n        s = """"\n        s += ""tokens: %s\\n"" % ("" "".join(\n            [tokenization.printable_text(x) for x in self.tokens]))\n        s += ""segment_ids: %s\\n"" % ("" "".join([str(x) for x in self.segment_ids]))\n        s += ""is_random_next: %s\\n"" % self.is_random_next\n        s += ""masked_lm_positions: %s\\n"" % ("" "".join(\n            [str(x) for x in self.masked_lm_positions]))\n        s += ""masked_lm_labels: %s\\n"" % ("" "".join(\n            [tokenization.printable_text(x) for x in self.masked_lm_labels]))\n        s += ""\\n""\n        return s\n\n    def __repr__(self):\n        return self.__str__()\n\n\ndef write_instance_to_example_files(instances, tokenizer, max_seq_length,\n                                    max_predictions_per_seq, output_files):\n    """"""Create TF example files from `TrainingInstance`s.""""""\n    writers = []\n    for output_file in output_files:\n        writers.append(tf.python_io.TFRecordWriter(output_file))\n\n    writer_index = 0\n\n    total_written = 0\n    for (inst_index, instance) in enumerate(instances):\n        input_ids = tokenizer.convert_tokens_to_ids(instance.tokens)\n        input_mask = [1] * len(input_ids)\n        segment_ids = list(instance.segment_ids)\n        assert len(input_ids) <= max_seq_length\n\n        while len(input_ids) < max_seq_length:\n            input_ids.append(0)\n            input_mask.append(0)\n            segment_ids.append(0)\n\n        assert len(input_ids) == max_seq_length\n        assert len(input_mask) == max_seq_length\n        # print(""length of segment_ids:"",len(segment_ids),""max_seq_length:"", max_seq_length)\n        assert len(segment_ids) == max_seq_length\n\n        masked_lm_positions = list(instance.masked_lm_positions)\n        masked_lm_ids = tokenizer.convert_tokens_to_ids(instance.masked_lm_labels)\n        masked_lm_weights = [1.0] * len(masked_lm_ids)\n\n        while len(masked_lm_positions) < max_predictions_per_seq:\n            masked_lm_positions.append(0)\n            masked_lm_ids.append(0)\n            masked_lm_weights.append(0.0)\n\n        next_sentence_label = 1 if instance.is_random_next else 0\n\n        features = collections.OrderedDict()\n        features[""input_ids""] = create_int_feature(input_ids)\n        features[""input_mask""] = create_int_feature(input_mask)\n        features[""segment_ids""] = create_int_feature(segment_ids)\n        features[""masked_lm_positions""] = create_int_feature(masked_lm_positions)\n        features[""masked_lm_ids""] = create_int_feature(masked_lm_ids)\n        features[""masked_lm_weights""] = create_float_feature(masked_lm_weights)\n        features[""next_sentence_labels""] = create_int_feature([next_sentence_label])\n\n        tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n\n        writers[writer_index].write(tf_example.SerializeToString())\n        writer_index = (writer_index + 1) % len(writers)\n\n        total_written += 1\n\n        if inst_index < 20:\n            tf.logging.info(""*** Example ***"")\n            tf.logging.info(""tokens: %s"" % "" "".join(\n                [tokenization.printable_text(x) for x in instance.tokens]))\n\n            for feature_name in features.keys():\n                feature = features[feature_name]\n                values = []\n                if feature.int64_list.value:\n                    values = feature.int64_list.value\n                elif feature.float_list.value:\n                    values = feature.float_list.value\n                tf.logging.info(\n                    ""%s: %s"" % (feature_name, "" "".join([str(x) for x in values])))\n\n    for writer in writers:\n        writer.close()\n\n    tf.logging.info(""Wrote %d total instances"", total_written)\n\n\ndef create_int_feature(values):\n    feature = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n    return feature\n\n\ndef create_float_feature(values):\n    feature = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n    return feature\n\n\ndef create_training_instances(input_files, tokenizer, max_seq_length,\n                              dupe_factor, short_seq_prob, masked_lm_prob,\n                              max_predictions_per_seq, rng):\n    """"""Create `TrainingInstance`s from raw text.""""""\n    all_documents = [[]]\n\n    # Input file format:\n    # (1) One sentence per line. These should ideally be actual sentences, not\n    # entire paragraphs or arbitrary spans of text. (Because we use the\n    # sentence boundaries for the ""next sentence prediction"" task).\n    # (2) Blank lines between documents. Document boundaries are needed so\n    # that the ""next sentence prediction"" task doesn\'t span between documents.\n    print(""create_training_instances.started..."")\n    for input_file in input_files:\n        with tf.gfile.GFile(input_file, ""r"") as reader:\n            while True:\n                line = tokenization.convert_to_unicode(reader.readline().replace(""<eop>"",""""))# .replace(""\xe2\x80\x9d"","""")) # \xe5\xb0\x86<eop>\xe3\x80\x81\xe2\x80\x9d\xe6\x9b\xbf\xe6\x8d\xa2\xe6\x8e\x89\xe3\x80\x82\n                if not line:\n                    break\n                line = line.strip()\n\n                # Empty lines are used as document delimiters\n                if not line:\n                    all_documents.append([])\n                tokens = tokenizer.tokenize(line)\n                if tokens:\n                    all_documents[-1].append(tokens)\n\n    # Remove empty documents\n    all_documents = [x for x in all_documents if x]\n    rng.shuffle(all_documents)\n\n    vocab_words = list(tokenizer.vocab.keys())\n    instances = []\n    for _ in range(dupe_factor):\n        for document_index in range(len(all_documents)):\n            instances.extend(\n                create_instances_from_document(\n                    all_documents, document_index, max_seq_length, short_seq_prob,\n                    masked_lm_prob, max_predictions_per_seq, vocab_words, rng))\n\n    rng.shuffle(instances)\n    print(""create_training_instances.ended..."")\n\n    return instances\n\n\ndef _is_chinese_char(cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n            (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n        return True\n\n\ndef get_new_segment(segment): #  \xe6\x96\xb0\xe5\xa2\x9e\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95 ####\n    """"""\n    \xe8\xbe\x93\xe5\x85\xa5\xe4\xb8\x80\xe5\x8f\xa5\xe8\xaf\x9d\xef\xbc\x8c\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe5\x8f\xa5\xe7\xbb\x8f\xe8\xbf\x87\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe8\xaf\x9d: \xe4\xb8\xba\xe4\xba\x86\xe6\x94\xaf\xe6\x8c\x81\xe4\xb8\xad\xe6\x96\x87\xe5\x85\xa8\xe7\xa7\xb0mask\xef\xbc\x8c\xe5\xb0\x86\xe8\xa2\xab\xe5\x88\x86\xe5\xbc\x80\xe7\x9a\x84\xe8\xaf\x8d\xef\xbc\x8c\xe5\xb0\x86\xe4\xb8\x8a\xe7\x89\xb9\xe6\xae\x8a\xe6\xa0\x87\xe8\xae\xb0(""#"")\xef\xbc\x8c\xe4\xbd\xbf\xe5\xbe\x97\xe5\x90\x8e\xe7\xbb\xad\xe5\xa4\x84\xe7\x90\x86\xe6\xa8\xa1\xe5\x9d\x97\xef\xbc\x8c\xe8\x83\xbd\xe5\xa4\x9f\xe7\x9f\xa5\xe9\x81\x93\xe5\x93\xaa\xe4\xba\x9b\xe5\xad\x97\xe6\x98\xaf\xe5\xb1\x9e\xe4\xba\x8e\xe5\x90\x8c\xe4\xb8\x80\xe4\xb8\xaa\xe8\xaf\x8d\xe7\x9a\x84\xe3\x80\x82\n    :param segment: \xe4\xb8\x80\xe5\x8f\xa5\xe8\xaf\x9d\n    :return: \xe4\xb8\x80\xe5\x8f\xa5\xe5\xa4\x84\xe7\x90\x86\xe8\xbf\x87\xe7\x9a\x84\xe8\xaf\x9d\n    """"""\n    seq_cws = jieba.lcut("""".join(segment))\n    seq_cws_dict = {x: 1 for x in seq_cws}\n    new_segment = []\n    i = 0\n    while i < len(segment):\n        if len(re.findall(\'[\\u4E00-\\u9FA5]\', segment[i]))==0: # \xe4\xb8\x8d\xe6\x98\xaf\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84\xef\xbc\x8c\xe5\x8e\x9f\xe6\x96\x87\xe5\x8a\xa0\xe8\xbf\x9b\xe5\x8e\xbb\xe3\x80\x82\n            new_segment.append(segment[i])\n            i += 1\n            continue\n\n        has_add = False\n        for length in range(3,0,-1):\n            if i+length>len(segment):\n                continue\n            if \'\'.join(segment[i:i+length]) in seq_cws_dict:\n                new_segment.append(segment[i])\n                for l in range(1, length):\n                    new_segment.append(\'##\' + segment[i+l])\n                i += length\n                has_add = True\n                break\n        if not has_add:\n            new_segment.append(segment[i])\n            i += 1\n    return new_segment\n\ndef get_raw_instance(document,max_sequence_length): # \xe6\x96\xb0\xe5\xa2\x9e\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95 TODO need check again to ensure full use of data\n    """"""\n    \xe8\x8e\xb7\xe5\x8f\x96\xe5\x88\x9d\xe6\xad\xa5\xe7\x9a\x84\xe8\xae\xad\xe7\xbb\x83\xe5\xae\x9e\xe4\xbe\x8b\xef\xbc\x8c\xe5\xb0\x86\xe6\x95\xb4\xe6\xae\xb5\xe6\x8c\x89\xe7\x85\xa7max_sequence_length\xe5\x88\x87\xe5\x88\x86\xe6\x88\x90\xe5\xa4\x9a\xe4\xb8\xaa\xe9\x83\xa8\xe5\x88\x86,\xe5\xb9\xb6\xe4\xbb\xa5\xe5\xa4\x9a\xe4\xb8\xaa\xe5\xa4\x84\xe7\x90\x86\xe5\xa5\xbd\xe7\x9a\x84\xe5\xae\x9e\xe4\xbe\x8b\xe7\x9a\x84\xe5\xbd\xa2\xe5\xbc\x8f\xe8\xbf\x94\xe5\x9b\x9e\xe3\x80\x82\n    :param document: \xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\n    :param max_sequence_length:\n    :return: a list. each element is a sequence of text\n    """"""\n    max_sequence_length_allowed=max_sequence_length-2\n    document = [seq for seq in document if len(seq)<max_sequence_length_allowed]\n    sizes = [len(seq) for seq in document]\n\n    result_list = []\n    curr_seq = [] # \xe5\xbd\x93\xe5\x89\x8d\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\n    sz_idx = 0\n    while sz_idx < len(sizes):\n        # \xe5\xbd\x93\xe5\x89\x8d\xe5\x8f\xa5\xe5\xad\x90\xe5\x8a\xa0\xe4\xb8\x8a\xe6\x96\xb0\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe9\x95\xbf\xe5\xba\xa6\xe5\xb0\x8f\xe4\xba\x8e\xe6\x9c\x80\xe5\xa4\xa7\xe9\x99\x90\xe5\x88\xb6\xef\xbc\x8c\xe5\x88\x99\xe5\x90\x88\xe5\xb9\xb6\xe5\xbd\x93\xe5\x89\x8d\xe5\x8f\xa5\xe5\xad\x90\xe5\x92\x8c\xe6\x96\xb0\xe5\x8f\xa5\xe5\xad\x90\xef\xbc\x9b\xe5\x90\xa6\xe5\x88\x99\xe5\x8d\xb3\xe8\xb6\x85\xe8\xbf\x87\xe4\xba\x86\xe6\x9c\x80\xe5\xa4\xa7\xe9\x99\x90\xe5\x88\xb6\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe5\x81\x9a\xe4\xb8\xba\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\xb0\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97\xe5\x8a\xa0\xe5\x88\xb0\xe7\x9b\xae\xe6\xa0\x87\xe5\x88\x97\xe8\xa1\xa8\xe4\xb8\xad\n        if len(curr_seq) + sizes[sz_idx] <= max_sequence_length_allowed: # or len(curr_seq)==0:\n            curr_seq += document[sz_idx]\n            sz_idx += 1\n        else:\n            result_list.append(curr_seq)\n            curr_seq = []\n    # \xe5\xaf\xb9\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe4\xb8\xaa\xe5\xba\x8f\xe5\x88\x97\xe8\xbf\x9b\xe8\xa1\x8c\xe5\xa4\x84\xe7\x90\x86\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe5\xa4\xaa\xe7\x9f\xad\xe7\x9a\x84\xe8\xaf\x9d\xef\xbc\x8c\xe4\xb8\xa2\xe5\xbc\x83\xe6\x8e\x89\xe3\x80\x82\n    if len(curr_seq)>max_sequence_length_allowed/2: # /2\n        result_list.append(curr_seq)\n\n    # # \xe8\xae\xa1\xe7\xae\x97\xe6\x80\xbb\xe5\x85\xb1\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xbe\x97\xe5\x88\xb0\xe5\xa4\x9a\xe5\xb0\x91\xe4\xbb\xbd\n    # num_instance=int(len(big_list)/max_sequence_length_allowed)+1\n    # print(""num_instance:"",num_instance)\n    # # \xe5\x88\x87\xe5\x88\x86\xe6\x88\x90\xe5\xa4\x9a\xe4\xbb\xbd\xef\xbc\x8c\xe6\xb7\xbb\xe5\x8a\xa0\xe5\x88\xb0\xe5\x88\x97\xe8\xa1\xa8\xe4\xb8\xad\n    # result_list=[]\n    # for j in range(num_instance):\n    #     index=j*max_sequence_length_allowed\n    #     end_index=index+max_sequence_length_allowed if j!=num_instance-1 else -1\n    #     result_list.append(big_list[index:end_index])\n    return result_list\n\ndef create_instances_from_document( # \xe6\x96\xb0\xe5\xa2\x9e\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95\n    # \xe7\x9b\xae\xe6\xa0\x87\xe6\x8c\x89\xe7\x85\xa7RoBERTa\xe7\x9a\x84\xe6\x80\x9d\xe8\xb7\xaf\xef\xbc\x8c\xe4\xbd\xbf\xe7\x94\xa8DOC-SENTENCES\xef\xbc\x8c\xe5\xb9\xb6\xe4\xbc\x9a\xe5\x8e\xbb\xe6\x8e\x89NSP\xe4\xbb\xbb\xe5\x8a\xa1: \xe4\xbb\x8e\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe8\xbf\x9e\xe7\xbb\xad\xe7\x9a\x84\xe8\x8e\xb7\xe5\xbe\x97\xe6\x96\x87\xe6\x9c\xac\xef\xbc\x8c\xe7\x9b\xb4\xe5\x88\xb0\xe8\xbe\xbe\xe5\x88\xb0\xe6\x9c\x80\xe5\xa4\xa7\xe9\x95\xbf\xe5\xba\xa6\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c\xe6\x98\xaf\xe4\xbb\x8e\xe4\xb8\x8b\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\x87\xe6\xa1\xa3\xe4\xb8\xad\xe8\x8e\xb7\xe5\xbe\x97\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe5\x8a\xa0\xe4\xb8\x8a\xe4\xb8\x80\xe4\xb8\xaa\xe5\x88\x86\xe9\x9a\x94\xe7\xac\xa6\n    #  document\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe3\x80\x82\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe5\x8f\xab\xe5\x81\x9asegment.\n    # \xe7\xbb\x99\xe5\xae\x9a\xe4\xb8\x80\xe4\xb8\xaadocument\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe7\x94\x9f\xe6\x88\x90\xe4\xb8\x80\xe4\xba\x9binstance.\n        all_documents, document_index, max_seq_length, short_seq_prob,\n        masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n    """"""Creates `TrainingInstance`s for a single document.""""""\n    document = all_documents[document_index]\n\n    # Account for [CLS], [SEP], [SEP]\n    max_num_tokens = max_seq_length - 3\n\n    # We *usually* want to fill up the entire sequence since we are padding\n    # to `max_seq_length` anyways, so short sequences are generally wasted\n    # computation. However, we *sometimes*\n    # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n    # sequences to minimize the mismatch between pre-training and fine-tuning.\n    # The `target_seq_length` is just a rough target however, whereas\n    # `max_seq_length` is a hard limit.\n\n    #target_seq_length = max_num_tokens\n    #if rng.random() < short_seq_prob:\n    #    target_seq_length = rng.randint(2, max_num_tokens)\n\n    instances = []\n    raw_text_list_list=get_raw_instance(document, max_seq_length) # document\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe3\x80\x82\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe5\x8f\xab\xe5\x81\x9asegment.\n    for j, raw_text_list in enumerate(raw_text_list_list):\n        ####################################################################################################################\n        raw_text_list = get_new_segment(raw_text_list) # \xe7\xbb\x93\xe5\x90\x88\xe5\x88\x86\xe8\xaf\x8d\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84whole mask\xe8\xae\xbe\xe7\xbd\xae\xe5\x8d\xb3\xe5\x9c\xa8\xe9\x9c\x80\xe8\xa6\x81\xe7\x9a\x84\xe5\x9c\xb0\xe6\x96\xb9\xe5\x8a\xa0\xe4\xb8\x8a\xe2\x80\x9c##\xe2\x80\x9d\n        # 1\xe3\x80\x81\xe8\xae\xbe\xe7\xbd\xaetoken, segment_ids\n        is_random_next=True # this will not be used, so it\'s value doesn\'t matter\n        tokens = []\n        segment_ids = []\n        tokens.append(""[CLS]"")\n        segment_ids.append(0)\n        for token in raw_text_list:\n            tokens.append(token)\n            segment_ids.append(0)\n        tokens.append(""[SEP]"")\n        segment_ids.append(0)\n        ################################################################################################################\n        # 2\xe3\x80\x81\xe8\xb0\x83\xe7\x94\xa8\xe5\x8e\x9f\xe6\x9c\x89\xe7\x9a\x84\xe6\x96\xb9\xe6\xb3\x95\n        (tokens, masked_lm_positions,\n         masked_lm_labels) = create_masked_lm_predictions(\n            tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n        instance = TrainingInstance(\n            tokens=tokens,\n            segment_ids=segment_ids,\n            is_random_next=is_random_next,\n            masked_lm_positions=masked_lm_positions,\n            masked_lm_labels=masked_lm_labels)\n        instances.append(instance)\n\n    return instances\n\n\n\ndef create_instances_from_document_original(\n        all_documents, document_index, max_seq_length, short_seq_prob,\n        masked_lm_prob, max_predictions_per_seq, vocab_words, rng):\n    """"""Creates `TrainingInstance`s for a single document.""""""\n    document = all_documents[document_index]\n\n    # Account for [CLS], [SEP], [SEP]\n    max_num_tokens = max_seq_length - 3\n\n    # We *usually* want to fill up the entire sequence since we are padding\n    # to `max_seq_length` anyways, so short sequences are generally wasted\n    # computation. However, we *sometimes*\n    # (i.e., short_seq_prob == 0.1 == 10% of the time) want to use shorter\n    # sequences to minimize the mismatch between pre-training and fine-tuning.\n    # The `target_seq_length` is just a rough target however, whereas\n    # `max_seq_length` is a hard limit.\n    target_seq_length = max_num_tokens\n    if rng.random() < short_seq_prob:\n        target_seq_length = rng.randint(2, max_num_tokens)\n\n    # We DON\'T just concatenate all of the tokens from a document into a long\n    # sequence and choose an arbitrary split point because this would make the\n    # next sentence prediction task too easy. Instead, we split the input into\n    # segments ""A"" and ""B"" based on the actual ""sentences"" provided by the user\n    # input.\n    instances = []\n    current_chunk = []\n    current_length = 0\n    i = 0\n    print(""document_index:"",document_index,""document:"",type(document),"" ;document:"",document) # document\xe5\x8d\xb3\xe4\xb8\x80\xe6\x95\xb4\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe5\xa4\x9a\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe3\x80\x82\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\xa5\xe5\xad\x90\xe5\x8f\xab\xe5\x81\x9asegment.\n    while i < len(document):\n        segment = document[i] # \xe5\x8f\x96\xe5\x88\xb0\xe4\xb8\x80\xe4\xb8\xaa\xe9\x83\xa8\xe5\x88\x86\xef\xbc\x88\xe5\x8f\xaf\xe8\x83\xbd\xe6\x98\xaf\xe4\xb8\x80\xe6\xae\xb5\xe8\xaf\x9d\xef\xbc\x89\n        print(""i:"",i,"" ;segment:"",segment)\n        ####################################################################################################################\n        segment = get_new_segment(segment) # \xe7\xbb\x93\xe5\x90\x88\xe5\x88\x86\xe8\xaf\x8d\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe7\x9a\x84whole mask\xe8\xae\xbe\xe7\xbd\xae\xe5\x8d\xb3\xe5\x9c\xa8\xe9\x9c\x80\xe8\xa6\x81\xe7\x9a\x84\xe5\x9c\xb0\xe6\x96\xb9\xe5\x8a\xa0\xe4\xb8\x8a\xe2\x80\x9c##\xe2\x80\x9d\n        ###################################################################################################################\n        current_chunk.append(segment)\n        current_length += len(segment)\n        print(""#####condition:"",i == len(document) - 1 or current_length >= target_seq_length)\n        if i == len(document) - 1 or current_length >= target_seq_length:\n            if current_chunk:\n                # `a_end` is how many segments from `current_chunk` go into the `A`\n                # (first) sentence.\n                a_end = 1\n                if len(current_chunk) >= 2:\n                    a_end = rng.randint(1, len(current_chunk) - 1)\n\n                tokens_a = []\n                for j in range(a_end):\n                    tokens_a.extend(current_chunk[j])\n\n                tokens_b = []\n                # Random next\n                is_random_next = False\n                if len(current_chunk) == 1 or rng.random() < 0.5:\n                    is_random_next = True\n                    target_b_length = target_seq_length - len(tokens_a)\n\n                    # This should rarely go for more than one iteration for large\n                    # corpora. However, just to be careful, we try to make sure that\n                    # the random document is not the same as the document\n                    # we\'re processing.\n                    for _ in range(10):\n                        random_document_index = rng.randint(0, len(all_documents) - 1)\n                        if random_document_index != document_index:\n                            break\n\n                    random_document = all_documents[random_document_index]\n                    random_start = rng.randint(0, len(random_document) - 1)\n                    for j in range(random_start, len(random_document)):\n                        tokens_b.extend(random_document[j])\n                        if len(tokens_b) >= target_b_length:\n                            break\n                    # We didn\'t actually use these segments so we ""put them back"" so\n                    # they don\'t go to waste.\n                    num_unused_segments = len(current_chunk) - a_end\n                    i -= num_unused_segments\n                # Actual next\n                else:\n                    is_random_next = False\n                    for j in range(a_end, len(current_chunk)):\n                        tokens_b.extend(current_chunk[j])\n                truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)\n\n                assert len(tokens_a) >= 1\n                assert len(tokens_b) >= 1\n\n                tokens = []\n                segment_ids = []\n                tokens.append(""[CLS]"")\n                segment_ids.append(0)\n                for token in tokens_a:\n                    tokens.append(token)\n                    segment_ids.append(0)\n\n                tokens.append(""[SEP]"")\n                segment_ids.append(0)\n\n                for token in tokens_b:\n                    tokens.append(token)\n                    segment_ids.append(1)\n                tokens.append(""[SEP]"")\n                segment_ids.append(1)\n\n                (tokens, masked_lm_positions,\n                 masked_lm_labels) = create_masked_lm_predictions(\n                     tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)\n                instance = TrainingInstance(\n                    tokens=tokens,\n                    segment_ids=segment_ids,\n                    is_random_next=is_random_next,\n                    masked_lm_positions=masked_lm_positions,\n                    masked_lm_labels=masked_lm_labels)\n                instances.append(instance)\n            current_chunk = []\n            current_length = 0\n        i += 1\n\n    return instances\n\n\nMaskedLmInstance = collections.namedtuple(""MaskedLmInstance"",\n                                          [""index"", ""label""])\n\n\ndef create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n    """"""Creates the predictions for the masked LM objective.""""""\n\n    cand_indexes = []\n    for (i, token) in enumerate(tokens):\n        if token == ""[CLS]"" or token == ""[SEP]"":\n            continue\n        # Whole Word Masking means that if we mask all of the wordpieces\n        # corresponding to an original word. When a word has been split into\n        # WordPieces, the first token does not have any marker and any subsequence\n        # tokens are prefixed with ##. So whenever we see the ## token, we\n        # append it to the previous set of word indexes.\n        #\n        # Note that Whole Word Masking does *not* change the training code\n        # at all -- we still predict each WordPiece independently, softmaxed\n        # over the entire vocabulary.\n        if (FLAGS.do_whole_word_mask and len(cand_indexes) >= 1 and\n                token.startswith(""##"")):\n            cand_indexes[-1].append(i)\n        else:\n            cand_indexes.append([i])\n\n    rng.shuffle(cand_indexes)\n\n    output_tokens = [t[2:] if len(re.findall(\'##[\\u4E00-\\u9FA5]\', t))>0 else t for t in tokens] # \xe5\x8e\xbb\xe6\x8e\x89""##""\n\n    num_to_predict = min(max_predictions_per_seq,\n                         max(1, int(round(len(tokens) * masked_lm_prob))))\n\n    masked_lms = []\n    covered_indexes = set()\n    for index_set in cand_indexes:\n        if len(masked_lms) >= num_to_predict:\n            break\n        # If adding a whole-word mask would exceed the maximum number of\n        # predictions, then just skip this candidate.\n        if len(masked_lms) + len(index_set) > num_to_predict:\n            continue\n        is_any_index_covered = False\n        for index in index_set:\n            if index in covered_indexes:\n                is_any_index_covered = True\n                break\n        if is_any_index_covered:\n            continue\n        for index in index_set:\n            covered_indexes.add(index)\n\n            masked_token = None\n            # 80% of the time, replace with [MASK]\n            if rng.random() < 0.8:\n                masked_token = ""[MASK]""\n            else:\n                # 10% of the time, keep original\n                if rng.random() < 0.5:\n                    masked_token = tokens[index][2:] if len(re.findall(\'##[\\u4E00-\\u9FA5]\', tokens[index]))>0 else tokens[index] # \xe5\x8e\xbb\xe6\x8e\x89""##""\n                # 10% of the time, replace with random word\n                else:\n                    masked_token = vocab_words[rng.randint(0, len(vocab_words) - 1)]\n\n            output_tokens[index] = masked_token\n\n            masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n    assert len(masked_lms) <= num_to_predict\n    masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n    masked_lm_positions = []\n    masked_lm_labels = []\n    for p in masked_lms:\n        masked_lm_positions.append(p.index)\n        masked_lm_labels.append(p.label)\n\n    # tf.logging.info(\'%s\' % (tokens))\n    # tf.logging.info(\'%s\' % (output_tokens))\n    return (output_tokens, masked_lm_positions, masked_lm_labels)\n\n\ndef truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng):\n    """"""Truncates a pair of sequences to a maximum sequence length.""""""\n    while True:\n        total_length = len(tokens_a) + len(tokens_b)\n        if total_length <= max_num_tokens:\n            break\n\n        trunc_tokens = tokens_a if len(tokens_a) > len(tokens_b) else tokens_b\n        assert len(trunc_tokens) >= 1\n\n        # We want to sometimes truncate from the front and sometimes from the\n        # back to add more randomness and avoid biases.\n        if rng.random() < 0.5:\n            del trunc_tokens[0]\n        else:\n            trunc_tokens.pop()\n\n\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n\n    tokenizer = tokenization.FullTokenizer(\n        vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)\n\n    input_files = []\n    for input_pattern in FLAGS.input_file.split("",""):\n        input_files.extend(tf.gfile.Glob(input_pattern))\n\n    tf.logging.info(""*** Reading from input files ***"")\n    for input_file in input_files:\n        tf.logging.info(""  %s"", input_file)\n\n    rng = random.Random(FLAGS.random_seed)\n    instances = create_training_instances(\n        input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,\n        FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,\n        rng)\n\n    output_files = FLAGS.output_file.split("","")\n    tf.logging.info(""*** Writing to output files ***"")\n    for output_file in output_files:\n        tf.logging.info(""  %s"", output_file)\n\n    write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,\n                                    FLAGS.max_predictions_per_seq, output_files)\n\n\nif __name__ == ""__main__"":\n    flags.mark_flag_as_required(""input_file"")\n    flags.mark_flag_as_required(""output_file"")\n    flags.mark_flag_as_required(""vocab_file"")\n    tf.app.run()'"
baselines/models_pytorch/classifier_pytorch/metrics/__init__.py,0,b''
baselines/models_pytorch/classifier_pytorch/metrics/clue_compute_metrics.py,0,"b'import csv\r\nimport sys\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\ntry:\r\n    from scipy.stats import pearsonr, spearmanr\r\n    from sklearn.metrics import matthews_corrcoef, f1_score\r\n    _has_sklearn = True\r\nexcept (AttributeError, ImportError) as e:\r\n    logger.warning(""To use data.metrics please install scikit-learn. See https://scikit-learn.org/stable/index.html"")\r\n    _has_sklearn = False\r\n\r\ndef simple_accuracy(preds, labels):\r\n    return (preds == labels).mean()\r\n\r\ndef acc_and_f1(preds, labels):\r\n    acc = simple_accuracy(preds, labels)\r\n    f1 = f1_score(y_true=labels, y_pred=preds)\r\n    return {\r\n        ""acc"": acc,\r\n        ""f1"": f1,\r\n        ""acc_and_f1"": (acc + f1) / 2,\r\n    }\r\n\r\ndef pearson_and_spearman(preds, labels):\r\n    pearson_corr = pearsonr(preds, labels)[0]\r\n    spearman_corr = spearmanr(preds, labels)[0]\r\n    return {\r\n        ""pearson"": pearson_corr,\r\n        ""spearmanr"": spearman_corr,\r\n        ""corr"": (pearson_corr + spearman_corr) / 2,\r\n    }\r\n\r\ndef compute_metrics(task_name, preds, labels):\r\n    assert len(preds) == len(labels)\r\n    if task_name == ""cls"":\r\n        return {""acc"": simple_accuracy(preds, labels)}\r\n    elif task_name == ""cmnli"":\r\n        return {""acc"": simple_accuracy(preds, labels)}\r\n    elif task_name == ""iflytek"":\r\n        return {""acc"": simple_accuracy(preds, labels)}\r\n    elif task_name == ""wsc"":\r\n        return {""acc"": simple_accuracy(preds, labels)}\r\n    elif task_name == ""tnews"":\r\n        return {""acc"": simple_accuracy(preds, labels)}\r\n    elif task_name == ""afqmc"":\r\n        return {""acc"": simple_accuracy(preds, labels)}\r\n    elif task_name == ""copa"":\r\n        return {""acc"": simple_accuracy(preds, labels)}\r\n    else:\r\n        raise KeyError(task_name)\r\n'"
baselines/models_pytorch/classifier_pytorch/processors/__init__.py,0,"b'from .utils import InputExample, InputFeatures, DataProcessor\nfrom .clue import (clue_output_modes, clue_processors, clue_tasks_num_labels,\n                   clue_convert_examples_to_features, collate_fn, xlnet_collate_fn)\n\n'"
baselines/models_pytorch/classifier_pytorch/processors/clue.py,1,"b'# -*- coding: utf-8 -*-\n# @Author: bo.shi\n# @Date:   2019-12-30 19:26:53\n# @Last Modified by:   bo.shi\n# @Last Modified time: 2020-01-01 11:39:23\n"""""" CLUE processors and helpers """"""\n\nimport logging\nimport os\nimport torch\nfrom .utils import DataProcessor, InputExample, InputFeatures\n\nlogger = logging.getLogger(__name__)\n\n\ndef collate_fn(batch):\n    """"""\n    batch should be a list of (sequence, target, length) tuples...\n    Returns a padded tensor of sequences sorted from longest to shortest,\n    """"""\n    all_input_ids, all_attention_mask, all_token_type_ids, all_lens, all_labels = map(torch.stack, zip(*batch))\n    max_len = max(all_lens).item()\n    all_input_ids = all_input_ids[:, :max_len]\n    all_attention_mask = all_attention_mask[:, :max_len]\n    all_token_type_ids = all_token_type_ids[:, :max_len]\n    return all_input_ids, all_attention_mask, all_token_type_ids, all_labels\n\n\ndef xlnet_collate_fn(batch):\n    """"""\n    batch should be a list of (sequence, target, length) tuples...\n    Returns a padded tensor of sequences sorted from longest to shortest,\n    """"""\n    all_input_ids, all_attention_mask, all_token_type_ids, all_lens, all_labels = map(torch.stack, zip(*batch))\n    max_len = max(all_lens).item()\n    all_input_ids = all_input_ids[:, -max_len:]\n    all_attention_mask = all_attention_mask[:, -max_len:]\n    all_token_type_ids = all_token_type_ids[:, -max_len:]\n    return all_input_ids, all_attention_mask, all_token_type_ids, all_labels\n\n\ndef clue_convert_examples_to_features(examples, tokenizer,\n                                      max_length=512,\n                                      task=None,\n                                      label_list=None,\n                                      output_mode=None,\n                                      pad_on_left=False,\n                                      pad_token=0,\n                                      pad_token_segment_id=0,\n                                      mask_padding_with_zero=True):\n    """"""\n    Loads a data file into a list of ``InputFeatures``\n    Args:\n        examples: List of ``InputExamples`` or ``tf.data.Dataset`` containing the examples.\n        tokenizer: Instance of a tokenizer that will tokenize the examples\n        max_length: Maximum example length\n        task: CLUE task\n        label_list: List of labels. Can be obtained from the processor using the ``processor.get_labels()`` method\n        output_mode: String indicating the output mode. Either ``regression`` or ``classification``\n        pad_on_left: If set to ``True``, the examples will be padded on the left rather than on the right (default)\n        pad_token: Padding token\n        pad_token_segment_id: The segment ID for the padding token (It is usually 0, but can vary such as for XLNet where it is 4)\n        mask_padding_with_zero: If set to ``True``, the attention mask will be filled by ``1`` for actual values\n            and by ``0`` for padded values. If set to ``False``, inverts it (``1`` for padded values, ``0`` for\n            actual values)\n\n    Returns:\n        If the input is a list of ``InputExamples``, will return\n        a list of task-specific ``InputFeatures`` which can be fed to the model.\n\n    """"""\n    if task is not None:\n        processor = clue_processors[task]()\n        if label_list is None:\n            label_list = processor.get_labels()\n            logger.info(""Using label list %s for task %s"" % (label_list, task))\n        if output_mode is None:\n            output_mode = clue_output_modes[task]\n            logger.info(""Using output mode %s for task %s"" % (output_mode, task))\n\n    label_map = {label: i for i, label in enumerate(label_list)}\n\n    features = []\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 10000 == 0:\n            logger.info(""Writing example %d"" % (ex_index))\n\n        inputs = tokenizer.encode_plus(\n            example.text_a,\n            example.text_b,\n            add_special_tokens=True,\n            max_length=max_length\n        )\n        input_ids, token_type_ids = inputs[""input_ids""], inputs[""token_type_ids""]\n\n        # The mask has 1 for real tokens and 0 for padding tokens. Only real\n        # tokens are attended to.\n        attention_mask = [1 if mask_padding_with_zero else 0] * len(input_ids)\n        input_len = len(input_ids)\n        # Zero-pad up to the sequence length.\n        padding_length = max_length - len(input_ids)\n        if pad_on_left:\n            input_ids = ([pad_token] * padding_length) + input_ids\n            attention_mask = ([0 if mask_padding_with_zero else 1] * padding_length) + attention_mask\n            token_type_ids = ([pad_token_segment_id] * padding_length) + token_type_ids\n        else:\n            input_ids = input_ids + ([pad_token] * padding_length)\n            attention_mask = attention_mask + ([0 if mask_padding_with_zero else 1] * padding_length)\n            token_type_ids = token_type_ids + ([pad_token_segment_id] * padding_length)\n\n        assert len(input_ids) == max_length, ""Error with input length {} vs {}"".format(len(input_ids), max_length)\n        assert len(attention_mask) == max_length, ""Error with input length {} vs {}"".format(len(attention_mask),\n                                                                                            max_length)\n        assert len(token_type_ids) == max_length, ""Error with input length {} vs {}"".format(len(token_type_ids),\n                                                                                            max_length)\n        if output_mode == ""classification"":\n            label = label_map[example.label]\n        elif output_mode == ""regression"":\n            label = float(example.label)\n        else:\n            raise KeyError(output_mode)\n\n        if ex_index < 5:\n            logger.info(""*** Example ***"")\n            logger.info(""guid: %s"" % (example.guid))\n            logger.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n            logger.info(""attention_mask: %s"" % "" "".join([str(x) for x in attention_mask]))\n            logger.info(""token_type_ids: %s"" % "" "".join([str(x) for x in token_type_ids]))\n            logger.info(""label: %s (id = %d)"" % (example.label, label))\n            logger.info(""input length: %d"" % (input_len))\n\n        features.append(\n            InputFeatures(input_ids=input_ids,\n                          attention_mask=attention_mask,\n                          token_type_ids=token_type_ids,\n                          label=label,\n                          input_len=input_len))\n    return features\n\n\nclass TnewsProcessor(DataProcessor):\n    """"""Processor for the TNEWS data set (CLUE version).""""""\n\n    def get_train_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n    def get_dev_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n    def get_test_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        labels = []\n        for i in range(17):\n            if i == 5 or i == 11:\n                continue\n            labels.append(str(100 + i))\n        return labels\n\n    def _create_examples(self, lines, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text_a = line[\'sentence\']\n            text_b = None\n            label = str(line[\'label\']) if set_type != \'test\' else ""100""\n            examples.append(\n                InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n        return examples\n\n\nclass IflytekProcessor(DataProcessor):\n    """"""Processor for the IFLYTEK data set (CLUE version).""""""\n\n    def get_train_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n    def get_dev_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n    def get_test_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        labels = []\n        for i in range(119):\n            labels.append(str(i))\n        return labels\n\n    def _create_examples(self, lines, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text_a = line[\'sentence\']\n            text_b = None\n            label = str(line[\'label\']) if set_type != \'test\' else ""0""\n            examples.append(\n                InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n        return examples\n\n\nclass AfqmcProcessor(DataProcessor):\n    """"""Processor for the AFQMC data set (CLUE version).""""""\n\n    def get_train_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n    def get_dev_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n    def get_test_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        return [""0"", ""1""]\n\n    def _create_examples(self, lines, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text_a = line[\'sentence1\']\n            text_b = line[\'sentence2\']\n            label = str(line[\'label\']) if set_type != \'test\' else ""0""\n            examples.append(\n                InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n        return examples\n\n\nclass CmnliProcessor(DataProcessor):\n    """"""Processor for the CMNLI data set (CLUE version).""""""\n\n    def get_train_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n    def get_dev_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n    def get_test_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        return [""contradiction"", ""entailment"", ""neutral""]\n\n    def _create_examples(self, lines, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text_a = line[""sentence1""]\n            text_b = line[""sentence2""]\n            label = str(line[""gold_label""]) if set_type != \'test\' else \'neutral\'\n            examples.append(\n                InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n        return examples\n\n\nclass CslProcessor(DataProcessor):\n    """"""Processor for the CSL data set (CLUE version).""""""\n\n    def get_train_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n    def get_dev_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n    def get_test_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        return [""0"", ""1""]\n\n    def _create_examples(self, lines, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text_a = "" "".join(line[\'keyword\'])\n            text_b = line[\'abst\']\n            label = str(line[\'label\']) if set_type != \'test\' else \'0\'\n            examples.append(\n                InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n        return examples\n\n\nclass WscProcessor(DataProcessor):\n    """"""Processor for the WSC data set (CLUE version).""""""\n\n    def get_train_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n    def get_dev_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n    def get_test_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        return [""true"", ""false""]\n\n    def _create_examples(self, lines, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            text_a = line[\'text\']\n            text_a_list = list(text_a)\n            target = line[\'target\']\n            query = target[\'span1_text\']\n            query_idx = target[\'span1_index\']\n            pronoun = target[\'span2_text\']\n            pronoun_idx = target[\'span2_index\']\n            assert text_a[pronoun_idx: (pronoun_idx + len(pronoun))] == pronoun, ""pronoun: {}"".format(pronoun)\n            assert text_a[query_idx: (query_idx + len(query))] == query, ""query: {}"".format(query)\n            if pronoun_idx > query_idx:\n                text_a_list.insert(query_idx, ""_"")\n                text_a_list.insert(query_idx + len(query) + 1, ""_"")\n                text_a_list.insert(pronoun_idx + 2, ""["")\n                text_a_list.insert(pronoun_idx + len(pronoun) + 2 + 1, ""]"")\n            else:\n                text_a_list.insert(pronoun_idx, ""["")\n                text_a_list.insert(pronoun_idx + len(pronoun) + 1, ""]"")\n                text_a_list.insert(query_idx + 2, ""_"")\n                text_a_list.insert(query_idx + len(query) + 2 + 1, ""_"")\n            text_a = """".join(text_a_list)\n            text_b = None\n            label = str(line[\'label\']) if set_type != \'test\' else \'true\'\n            examples.append(\n                InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n        return examples\n\n\nclass CopaProcessor(DataProcessor):\n    """"""Processor for the COPA data set (CLUE version).""""""\n\n    def get_train_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""train.json"")), ""train"")\n\n    def get_dev_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""dev.json"")), ""dev"")\n\n    def get_test_examples(self, data_dir):\n        """"""See base class.""""""\n        return self._create_examples(\n            self._read_json(os.path.join(data_dir, ""test.json"")), ""test"")\n\n    def get_labels(self):\n        """"""See base class.""""""\n        return [""0"", ""1""]\n\n    def _create_examples(self, lines, set_type):\n        examples = []\n        for (i, line) in enumerate(lines):\n            i = 2 * i\n            guid1 = ""%s-%s"" % (set_type, i)\n            guid2 = ""%s-%s"" % (set_type, i + 1)\n            premise = line[\'premise\']\n            choice0 = line[\'choice0\']\n            label = str(1 if line[\'label\'] == 0 else 0) if set_type != \'test\' else \'0\'\n            choice1 = line[\'choice1\']\n            label2 = str(0 if line[\'label\'] == 0 else 1) if set_type != \'test\' else \'0\'\n            if line[\'question\'] == \'effect\':\n                text_a = premise\n                text_b = choice0\n                text_a2 = premise\n                text_b2 = choice1\n            elif line[\'question\'] == \'cause\':\n                text_a = choice0\n                text_b = premise\n                text_a2 = choice1\n                text_b2 = premise\n            else:\n                raise ValueError(f\'unknowed {line[""question""]} type\')\n            examples.append(\n                InputExample(guid=guid1, text_a=text_a, text_b=text_b, label=label))\n            examples.append(\n                InputExample(guid=guid2, text_a=text_a2, text_b=text_b2, label=label2))\n        return examples\n\n    def _create_examples_version2(self, lines, set_type):\n        """"""Creates examples for the training and dev sets.""""""\n        examples = []\n        for (i, line) in enumerate(lines):\n            guid = ""%s-%s"" % (set_type, i)\n            if line[\'question\'] == \'cause\':\n                text_a = line[\'premise\'] + \'\xe8\xbf\x99\xe6\x98\xaf\xe4\xbb\x80\xe4\xb9\x88\xe5\x8e\x9f\xe5\x9b\xa0\xe9\x80\xa0\xe6\x88\x90\xe7\x9a\x84\xef\xbc\x9f\' + line[\'choice0\']\n                text_b = line[\'premise\'] + \'\xe8\xbf\x99\xe6\x98\xaf\xe4\xbb\x80\xe4\xb9\x88\xe5\x8e\x9f\xe5\x9b\xa0\xe9\x80\xa0\xe6\x88\x90\xe7\x9a\x84\xef\xbc\x9f\' + line[\'choice1\']\n            else:\n                text_a = line[\'premise\'] + \'\xe8\xbf\x99\xe9\x80\xa0\xe6\x88\x90\xe4\xba\x86\xe4\xbb\x80\xe4\xb9\x88\xe5\xbd\xb1\xe5\x93\x8d\xef\xbc\x9f\' + line[\'choice0\']\n                text_b = line[\'premise\'] + \'\xe8\xbf\x99\xe9\x80\xa0\xe6\x88\x90\xe4\xba\x86\xe4\xbb\x80\xe4\xb9\x88\xe5\xbd\xb1\xe5\x93\x8d\xef\xbc\x9f\' + line[\'choice1\']\n            label = str(1 if line[\'label\'] == 0 else 0) if set_type != \'test\' else \'0\'\n            examples.append(\n                InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n        return examples\n\n\nclue_tasks_num_labels = {\n    \'iflytek\': 119,\n    \'cmnli\': 3,\n    \'afqmc\': 2,\n    \'csl\': 2,\n    \'wsc\': 2,\n    \'copa\': 2,\n    \'tnews\': 15,\n}\n\nclue_processors = {\n    \'tnews\': TnewsProcessor,\n    \'iflytek\': IflytekProcessor,\n    \'cmnli\': CmnliProcessor,\n    \'afqmc\': AfqmcProcessor,\n    \'csl\': CslProcessor,\n    \'wsc\': WscProcessor,\n    \'copa\': CopaProcessor,\n}\n\nclue_output_modes = {\n    \'tnews\': ""classification"",\n    \'iflytek\': ""classification"",\n    \'cmnli\': ""classification"",\n    \'afqmc\': ""classification"",\n    \'csl\': ""classification"",\n    \'wsc\': ""classification"",\n    \'copa\': ""classification"",\n}\n'"
baselines/models_pytorch/classifier_pytorch/processors/utils.py,0,"b'import csv\nimport sys\nimport copy\nimport json\n\nclass InputExample(object):\n    """"""\n    A single training/test example for simple sequence classification.\n\n    Args:\n        guid: Unique id for the example.\n        text_a: string. The untokenized text of the first sequence. For single\n        sequence tasks, only this sequence must be specified.\n        text_b: (Optional) string. The untokenized text of the second sequence.\n        Only must be specified for sequence pair tasks.\n        label: (Optional) string. The label of the example. This should be\n        specified for train and dev examples, but not for test examples.\n    """"""\n    def __init__(self, guid, text_a, text_b=None, label=None):\n        self.guid = guid\n        self.text_a = text_a\n        self.text_b = text_b\n        self.label = label\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass InputFeatures(object):\n    """"""\n    A single set of features of data.\n\n    Args:\n        input_ids: Indices of input sequence tokens in the vocabulary.\n        attention_mask: Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            Usually  ``1`` for tokens that are NOT MASKED, ``0`` for MASKED (padded) tokens.\n        token_type_ids: Segment token indices to indicate first and second portions of the inputs.\n        label: Label corresponding to the input\n    """"""\n\n    def __init__(self, input_ids, attention_mask, token_type_ids, label,input_len):\n        self.input_ids = input_ids\n        self.attention_mask = attention_mask\n        self.token_type_ids = token_type_ids\n        self.input_len = input_len\n        self.label = label\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n\nclass DataProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def get_train_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        raise NotImplementedError()\n\n    def get_dev_examples(self, data_dir):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        raise NotImplementedError()\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        raise NotImplementedError()\n\n    @classmethod\n    def _read_tsv(cls, input_file, quotechar=None):\n        """"""Reads a tab separated value file.""""""\n        with open(input_file, ""r"", encoding=""utf-8-sig"") as f:\n            reader = csv.reader(f, delimiter=""\\t"", quotechar=quotechar)\n            lines = []\n            for line in reader:\n                lines.append(line)\n            return lines\n\n    @classmethod\n    def _read_json(cls, input_file):\n        """"""Reads a json list file.""""""\n        with open(input_file, ""r"") as f:\n            reader = f.readlines()\n            lines = []\n            for line in reader:\n                lines.append(json.loads(line.strip()))\n            return lines\n'"
baselines/models_pytorch/classifier_pytorch/tools/common.py,0,"b'import os\r\nimport random\r\nimport torch\r\nimport numpy as np\r\nimport json\r\nimport pickle\r\nimport torch.nn as nn\r\nfrom collections import OrderedDict\r\nfrom pathlib import Path\r\nimport logging\r\n\r\nlogger = logging.getLogger()\r\ndef print_config(config):\r\n    info = ""Running with the following configs:\\n""\r\n    for k, v in config.items():\r\n        info += f""\\t{k} : {str(v)}\\n""\r\n    print(""\\n"" + info + ""\\n"")\r\n    return\r\n\r\ndef init_logger(log_file=None, log_file_level=logging.NOTSET):\r\n    \'\'\'\r\n    Example:\r\n        >>> init_logger(log_file)\r\n        >>> logger.info(""abc\'"")\r\n    \'\'\'\r\n    if isinstance(log_file,Path):\r\n        log_file = str(log_file)\r\n    log_format = logging.Formatter(fmt=\'%(asctime)s - %(levelname)s - %(name)s -   %(message)s\',\r\n                                   datefmt=\'%m/%d/%Y %H:%M:%S\')\r\n\r\n    logger = logging.getLogger()\r\n    logger.setLevel(logging.INFO)\r\n    console_handler = logging.StreamHandler()\r\n    console_handler.setFormatter(log_format)\r\n    logger.handlers = [console_handler]\r\n    if log_file and log_file != \'\':\r\n        file_handler = logging.FileHandler(log_file)\r\n        file_handler.setLevel(log_file_level)\r\n        # file_handler.setFormatter(log_format)\r\n        logger.addHandler(file_handler)\r\n    return logger\r\n\r\ndef seed_everything(seed=1029):\r\n    \'\'\'\r\n    \xe8\xae\xbe\xe7\xbd\xae\xe6\x95\xb4\xe4\xb8\xaa\xe5\xbc\x80\xe5\x8f\x91\xe7\x8e\xaf\xe5\xa2\x83\xe7\x9a\x84seed\r\n    :param seed:\r\n    :param device:\r\n    :return:\r\n    \'\'\'\r\n    random.seed(seed)\r\n    os.environ[\'PYTHONHASHSEED\'] = str(seed)\r\n    np.random.seed(seed)\r\n    torch.manual_seed(seed)\r\n    torch.cuda.manual_seed(seed)\r\n    torch.cuda.manual_seed_all(seed)\r\n    # some cudnn methods can be random even after fixing the seed\r\n    # unless you tell it to be deterministic\r\n    torch.backends.cudnn.deterministic = True\r\n\r\n\r\ndef prepare_device(n_gpu_use):\r\n    """"""\r\n    setup GPU device if available, move model into configured device\r\n    # \xe5\xa6\x82\xe6\x9e\x9cn_gpu_use\xe4\xb8\xba\xe6\x95\xb0\xe5\xad\x97\xef\xbc\x8c\xe5\x88\x99\xe4\xbd\xbf\xe7\x94\xa8range\xe7\x94\x9f\xe6\x88\x90list\r\n    # \xe5\xa6\x82\xe6\x9e\x9c\xe8\xbe\x93\xe5\x85\xa5\xe7\x9a\x84\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaalist\xef\xbc\x8c\xe5\x88\x99\xe9\xbb\x98\xe8\xae\xa4\xe4\xbd\xbf\xe7\x94\xa8list[0]\xe4\xbd\x9c\xe4\xb8\xbacontroller\r\n     """"""\r\n    if not n_gpu_use:\r\n        device_type = \'cpu\'\r\n    else:\r\n        n_gpu_use = n_gpu_use.split("","")\r\n        device_type = f""cuda:{n_gpu_use[0]}""\r\n    n_gpu = torch.cuda.device_count()\r\n    if len(n_gpu_use) > 0 and n_gpu == 0:\r\n        logger.warning(""Warning: There\\\'s no GPU available on this machine, training will be performed on CPU."")\r\n        device_type = \'cpu\'\r\n    if len(n_gpu_use) > n_gpu:\r\n        msg = f""Warning: The number of GPU\\\'s configured to use is {n_gpu_use}, but only {n_gpu} are available on this machine.""\r\n        logger.warning(msg)\r\n        n_gpu_use = range(n_gpu)\r\n    device = torch.device(device_type)\r\n    list_ids = n_gpu_use\r\n    return device, list_ids\r\n\r\n\r\ndef model_device(n_gpu, model):\r\n    \'\'\'\r\n    \xe5\x88\xa4\xe6\x96\xad\xe7\x8e\xaf\xe5\xa2\x83 cpu\xe8\xbf\x98\xe6\x98\xafgpu\r\n    \xe6\x94\xaf\xe6\x8c\x81\xe5\x8d\x95\xe6\x9c\xba\xe5\xa4\x9a\xe5\x8d\xa1\r\n    :param n_gpu:\r\n    :param model:\r\n    :return:\r\n    \'\'\'\r\n    device, device_ids = prepare_device(n_gpu)\r\n    if len(device_ids) > 1:\r\n        logger.info(f""current {len(device_ids)} GPUs"")\r\n        model = torch.nn.DataParallel(model, device_ids=device_ids)\r\n    if len(device_ids) == 1:\r\n        os.environ[\'CUDA_VISIBLE_DEVICES\'] = str(device_ids[0])\r\n    model = model.to(device)\r\n    return model, device\r\n\r\n\r\ndef restore_checkpoint(resume_path, model=None):\r\n    \'\'\'\r\n    \xe5\x8a\xa0\xe8\xbd\xbd\xe6\xa8\xa1\xe5\x9e\x8b\r\n    :param resume_path:\r\n    :param model:\r\n    :param optimizer:\r\n    :return:\r\n    \xe6\xb3\xa8\xe6\x84\x8f\xef\xbc\x9a \xe5\xa6\x82\xe6\x9e\x9c\xe6\x98\xaf\xe5\x8a\xa0\xe8\xbd\xbdBert\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9a\x84\xe8\xaf\x9d\xef\xbc\x8c\xe9\x9c\x80\xe8\xa6\x81\xe8\xb0\x83\xe6\x95\xb4\xef\xbc\x8c\xe4\xb8\x8d\xe8\x83\xbd\xe4\xbd\xbf\xe7\x94\xa8\xe8\xaf\xa5\xe6\xa8\xa1\xe5\xbc\x8f\r\n    \xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8\xe6\xa8\xa1\xe5\x9d\x97\xe8\x87\xaa\xe5\xb8\xa6\xe7\x9a\x84Bert_model.from_pretrained(state_dict = your save state_dict)\r\n    \'\'\'\r\n    if isinstance(resume_path, Path):\r\n        resume_path = str(resume_path)\r\n    checkpoint = torch.load(resume_path)\r\n    best = checkpoint[\'best\']\r\n    start_epoch = checkpoint[\'epoch\'] + 1\r\n    states = checkpoint[\'state_dict\']\r\n    if isinstance(model, nn.DataParallel):\r\n        model.module.load_state_dict(states)\r\n    else:\r\n        model.load_state_dict(states)\r\n    return [model,best,start_epoch]\r\n\r\n\r\ndef save_pickle(data, file_path):\r\n    \'\'\'\r\n    \xe4\xbf\x9d\xe5\xad\x98\xe6\x88\x90pickle\xe6\x96\x87\xe4\xbb\xb6\r\n    :param data:\r\n    :param file_name:\r\n    :param pickle_path:\r\n    :return:\r\n    \'\'\'\r\n    if isinstance(file_path, Path):\r\n        file_path = str(file_path)\r\n    with open(file_path, \'wb\') as f:\r\n        pickle.dump(data, f)\r\n\r\n\r\ndef load_pickle(input_file):\r\n    \'\'\'\r\n    \xe8\xaf\xbb\xe5\x8f\x96pickle\xe6\x96\x87\xe4\xbb\xb6\r\n    :param pickle_path:\r\n    :param file_name:\r\n    :return:\r\n    \'\'\'\r\n    with open(str(input_file), \'rb\') as f:\r\n        data = pickle.load(f)\r\n    return data\r\n\r\n\r\ndef save_json(data, file_path):\r\n    \'\'\'\r\n    \xe4\xbf\x9d\xe5\xad\x98\xe6\x88\x90json\xe6\x96\x87\xe4\xbb\xb6\r\n    :param data:\r\n    :param json_path:\r\n    :param file_name:\r\n    :return:\r\n    \'\'\'\r\n    if not isinstance(file_path, Path):\r\n        file_path = Path(file_path)\r\n    # if isinstance(data,dict):\r\n    #     data = json.dumps(data)\r\n    with open(str(file_path), \'w\') as f:\r\n        json.dump(data, f)\r\n\r\ndef save_numpy(data, file_path):\r\n    \'\'\'\r\n    \xe4\xbf\x9d\xe5\xad\x98\xe6\x88\x90.npy\xe6\x96\x87\xe4\xbb\xb6\r\n    :param data:\r\n    :param file_path:\r\n    :return:\r\n    \'\'\'\r\n    if not isinstance(file_path, Path):\r\n        file_path = Path(file_path)\r\n    np.save(str(file_path),data)\r\n\r\ndef load_numpy(file_path):\r\n    \'\'\'\r\n    \xe5\x8a\xa0\xe8\xbd\xbd.npy\xe6\x96\x87\xe4\xbb\xb6\r\n    :param file_path:\r\n    :return:\r\n    \'\'\'\r\n    if not isinstance(file_path, Path):\r\n        file_path = Path(file_path)\r\n    np.load(str(file_path))\r\n\r\ndef load_json(file_path):\r\n    \'\'\'\r\n    \xe5\x8a\xa0\xe8\xbd\xbdjson\xe6\x96\x87\xe4\xbb\xb6\r\n    :param json_path:\r\n    :param file_name:\r\n    :return:\r\n    \'\'\'\r\n    if not isinstance(file_path, Path):\r\n        file_path = Path(file_path)\r\n    with open(str(file_path), \'r\') as f:\r\n        data = json.load(f)\r\n    return data\r\n\r\ndef json_to_text(file_path,data):\r\n    \'\'\'\r\n    \xe5\xb0\x86json list\xe5\x86\x99\xe5\x85\xa5text\xe6\x96\x87\xe4\xbb\xb6\xe4\xb8\xad\r\n    :param file_path:\r\n    :param data:\r\n    :return:\r\n    \'\'\'\r\n    if not isinstance(file_path, Path):\r\n        file_path = Path(file_path)\r\n    with open(str(file_path), \'w\') as fw:\r\n        for line in data:\r\n            line = json.dumps(line, ensure_ascii=False)\r\n            fw.write(line + \'\\n\')\r\n\r\ndef save_model(model, model_path):\r\n    """""" \xe5\xad\x98\xe5\x82\xa8\xe4\xb8\x8d\xe5\x90\xab\xe6\x9c\x89\xe6\x98\xbe\xe5\x8d\xa1\xe4\xbf\xa1\xe6\x81\xaf\xe7\x9a\x84state_dict\xe6\x88\x96model\r\n    :param model:\r\n    :param model_name:\r\n    :param only_param:\r\n    :return:\r\n    """"""\r\n    if isinstance(model_path, Path):\r\n        model_path = str(model_path)\r\n    if isinstance(model, nn.DataParallel):\r\n        model = model.module\r\n    state_dict = model.state_dict()\r\n    for key in state_dict:\r\n        state_dict[key] = state_dict[key].cpu()\r\n    torch.save(state_dict, model_path)\r\n\r\ndef load_model(model, model_path):\r\n    \'\'\'\r\n    \xe5\x8a\xa0\xe8\xbd\xbd\xe6\xa8\xa1\xe5\x9e\x8b\r\n    :param model:\r\n    :param model_name:\r\n    :param model_path:\r\n    :param only_param:\r\n    :return:\r\n    \'\'\'\r\n    if isinstance(model_path, Path):\r\n        model_path = str(model_path)\r\n    logging.info(f""loading model from {str(model_path)} ."")\r\n    states = torch.load(model_path)\r\n    state = states[\'state_dict\']\r\n    if isinstance(model, nn.DataParallel):\r\n        model.module.load_state_dict(state)\r\n    else:\r\n        model.load_state_dict(state)\r\n    return model\r\n\r\n\r\nclass AverageMeter(object):\r\n    \'\'\'\r\n    computes and stores the average and current value\r\n    Example:\r\n        >>> loss = AverageMeter()\r\n        >>> for step,batch in enumerate(train_data):\r\n        >>>     pred = self.model(batch)\r\n        >>>     raw_loss = self.metrics(pred,target)\r\n        >>>     loss.update(raw_loss.item(),n = 1)\r\n        >>> cur_loss = loss.avg\r\n    \'\'\'\r\n\r\n    def __init__(self):\r\n        self.reset()\r\n\r\n    def reset(self):\r\n        self.val = 0\r\n        self.avg = 0\r\n        self.sum = 0\r\n        self.count = 0\r\n\r\n    def update(self, val, n=1):\r\n        self.val = val\r\n        self.sum += val * n\r\n        self.count += n\r\n        self.avg = self.sum / self.count\r\n\r\n\r\ndef summary(model, *inputs, batch_size=-1, show_input=True):\r\n    \'\'\'\r\n    \xe6\x89\x93\xe5\x8d\xb0\xe6\xa8\xa1\xe5\x9e\x8b\xe7\xbb\x93\xe6\x9e\x84\xe4\xbf\xa1\xe6\x81\xaf\r\n    :param model:\r\n    :param inputs:\r\n    :param batch_size:\r\n    :param show_input:\r\n    :return:\r\n    Example:\r\n        >>> print(""model summary info: "")\r\n        >>> for step,batch in enumerate(train_data):\r\n        >>>     summary(self.model,*batch,show_input=True)\r\n        >>>     break\r\n    \'\'\'\r\n\r\n    def register_hook(module):\r\n        def hook(module, input, output=None):\r\n            class_name = str(module.__class__).split(""."")[-1].split(""\'"")[0]\r\n            module_idx = len(summary)\r\n\r\n            m_key = f""{class_name}-{module_idx + 1}""\r\n            summary[m_key] = OrderedDict()\r\n            summary[m_key][""input_shape""] = list(input[0].size())\r\n            summary[m_key][""input_shape""][0] = batch_size\r\n\r\n            if show_input is False and output is not None:\r\n                if isinstance(output, (list, tuple)):\r\n                    for out in output:\r\n                        if isinstance(out, torch.Tensor):\r\n                            summary[m_key][""output_shape""] = [\r\n                                [-1] + list(out.size())[1:]\r\n                            ][0]\r\n                        else:\r\n                            summary[m_key][""output_shape""] = [\r\n                                [-1] + list(out[0].size())[1:]\r\n                            ][0]\r\n                else:\r\n                    summary[m_key][""output_shape""] = list(output.size())\r\n                    summary[m_key][""output_shape""][0] = batch_size\r\n\r\n            params = 0\r\n            if hasattr(module, ""weight"") and hasattr(module.weight, ""size""):\r\n                params += torch.prod(torch.LongTensor(list(module.weight.size())))\r\n                summary[m_key][""trainable""] = module.weight.requires_grad\r\n            if hasattr(module, ""bias"") and hasattr(module.bias, ""size""):\r\n                params += torch.prod(torch.LongTensor(list(module.bias.size())))\r\n            summary[m_key][""nb_params""] = params\r\n\r\n        if (not isinstance(module, nn.Sequential) and not isinstance(module, nn.ModuleList) and not (module == model)):\r\n            if show_input is True:\r\n                hooks.append(module.register_forward_pre_hook(hook))\r\n            else:\r\n                hooks.append(module.register_forward_hook(hook))\r\n\r\n    # create properties\r\n    summary = OrderedDict()\r\n    hooks = []\r\n\r\n    # register hook\r\n    model.apply(register_hook)\r\n    model(*inputs)\r\n\r\n    # remove these hooks\r\n    for h in hooks:\r\n        h.remove()\r\n\r\n    print(""-----------------------------------------------------------------------"")\r\n    if show_input is True:\r\n        line_new = f""{\'Layer (type)\':>25}  {\'Input Shape\':>25} {\'Param #\':>15}""\r\n    else:\r\n        line_new = f""{\'Layer (type)\':>25}  {\'Output Shape\':>25} {\'Param #\':>15}""\r\n    print(line_new)\r\n    print(""======================================================================="")\r\n\r\n    total_params = 0\r\n    total_output = 0\r\n    trainable_params = 0\r\n    for layer in summary:\r\n        # input_shape, output_shape, trainable, nb_params\r\n        if show_input is True:\r\n            line_new = ""{:>25}  {:>25} {:>15}"".format(\r\n                layer,\r\n                str(summary[layer][""input_shape""]),\r\n                ""{0:,}"".format(summary[layer][""nb_params""]),\r\n            )\r\n        else:\r\n            line_new = ""{:>25}  {:>25} {:>15}"".format(\r\n                layer,\r\n                str(summary[layer][""output_shape""]),\r\n                ""{0:,}"".format(summary[layer][""nb_params""]),\r\n            )\r\n\r\n        total_params += summary[layer][""nb_params""]\r\n        if show_input is True:\r\n            total_output += np.prod(summary[layer][""input_shape""])\r\n        else:\r\n            total_output += np.prod(summary[layer][""output_shape""])\r\n        if ""trainable"" in summary[layer]:\r\n            if summary[layer][""trainable""] == True:\r\n                trainable_params += summary[layer][""nb_params""]\r\n\r\n        print(line_new)\r\n\r\n    print(""======================================================================="")\r\n    print(f""Total params: {total_params:0,}"")\r\n    print(f""Trainable params: {trainable_params:0,}"")\r\n    print(f""Non-trainable params: {(total_params - trainable_params):0,}"")\r\n    print(""-----------------------------------------------------------------------"")'"
baselines/models_pytorch/classifier_pytorch/tools/progressbar.py,0,"b'import time\r\n\r\nclass ProgressBar(object):\r\n    \'\'\'\r\n    custom progress bar\r\n    Example:\r\n        >>> pbar = ProgressBar(n_total=30,desc=\'Training\')\r\n        >>> step = 2\r\n        >>> pbar(step=step)\r\n    \'\'\'\r\n    def __init__(self, n_total,width=30,desc = \'Training\'):\r\n        self.width = width\r\n        self.n_total = n_total\r\n        self.start_time = time.time()\r\n        self.desc = desc\r\n\r\n    def __call__(self, step, info={}):\r\n        now = time.time()\r\n        current = step + 1\r\n        recv_per = current / self.n_total\r\n        bar = f\'[{self.desc}] {current}/{self.n_total} [\'\r\n        if recv_per >= 1:\r\n            recv_per = 1\r\n        prog_width = int(self.width * recv_per)\r\n        if prog_width > 0:\r\n            bar += \'=\' * (prog_width - 1)\r\n            if current< self.n_total:\r\n                bar += "">""\r\n            else:\r\n                bar += \'=\'\r\n        bar += \'.\' * (self.width - prog_width)\r\n        bar += \']\'\r\n        show_bar = f""\\r{bar}""\r\n        time_per_unit = (now - self.start_time) / current\r\n        if current < self.n_total:\r\n            eta = time_per_unit * (self.n_total - current)\r\n            if eta > 3600:\r\n                eta_format = (\'%d:%02d:%02d\' %\r\n                              (eta // 3600, (eta % 3600) // 60, eta % 60))\r\n            elif eta > 60:\r\n                eta_format = \'%d:%02d\' % (eta // 60, eta % 60)\r\n            else:\r\n                eta_format = \'%ds\' % eta\r\n            time_info = f\' - ETA: {eta_format}\'\r\n        else:\r\n            if time_per_unit >= 1:\r\n                time_info = f\' {time_per_unit:.1f}s/step\'\r\n            elif time_per_unit >= 1e-3:\r\n                time_info = f\' {time_per_unit * 1e3:.1f}ms/step\'\r\n            else:\r\n                time_info = f\' {time_per_unit * 1e6:.1f}us/step\'\r\n\r\n        show_bar += time_info\r\n        if len(info) != 0:\r\n            show_info = f\'{show_bar} \' + \\\r\n                        ""-"".join([f\' {key}: {value:.4f} \' for key, value in info.items()])\r\n            print(show_info, end=\'\')\r\n        else:\r\n            print(show_bar, end=\'\')\r\n'"
baselines/models_pytorch/classifier_pytorch/transformers/__init__.py,0,"b'__version__ = ""2.1.1""\n\n# Work around to update TensorFlow\'s absl.logging threshold which alters the\n# default Python logging output behavior when present.\n# see: https://github.com/abseil/abseil-py/issues/99\n# and: https://github.com/tensorflow/tensorflow/issues/26691#issuecomment-500369493\ntry:\n    import absl.logging\n    absl.logging.set_verbosity(\'info\')\n    absl.logging.set_stderrthreshold(\'info\')\n    absl.logging._warn_preinit_stderr = False\nexcept:\n    pass\n\nimport logging\n\nlogger = logging.getLogger(__name__)  # pylint: disable=invalid-name\n\n# Files and general utilities\nfrom .file_utils import (TRANSFORMERS_CACHE, PYTORCH_TRANSFORMERS_CACHE, PYTORCH_PRETRAINED_BERT_CACHE,\n                         cached_path, add_start_docstrings, add_end_docstrings,\n                         WEIGHTS_NAME, TF2_WEIGHTS_NAME, TF_WEIGHTS_NAME, CONFIG_NAME,\n                         is_tf_available, is_torch_available)\n\n# Tokenizers\nfrom .tokenization_utils import (PreTrainedTokenizer)\nfrom .tokenization_auto import AutoTokenizer\nfrom .tokenization_bert import BertTokenizer, BasicTokenizer, WordpieceTokenizer\nfrom .tokenization_openai import OpenAIGPTTokenizer\nfrom .tokenization_transfo_xl import (TransfoXLTokenizer, TransfoXLCorpus)\nfrom .tokenization_gpt2 import GPT2Tokenizer\nfrom .tokenization_ctrl import CTRLTokenizer\nfrom .tokenization_xlnet import XLNetTokenizer, SPIECE_UNDERLINE\nfrom .tokenization_xlm import XLMTokenizer\nfrom .tokenization_roberta import RobertaTokenizer\nfrom .tokenization_distilbert import DistilBertTokenizer\n\n# Configurations\nfrom .configuration_utils import PretrainedConfig\nfrom .configuration_auto import AutoConfig\nfrom .configuration_bert import BertConfig, BERT_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_openai import OpenAIGPTConfig, OPENAI_GPT_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_transfo_xl import TransfoXLConfig, TRANSFO_XL_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_gpt2 import GPT2Config, GPT2_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_ctrl import CTRLConfig, CTRL_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_xlnet import XLNetConfig, XLNET_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_ctrl import CTRLConfig, CTRL_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_xlm import XLMConfig, XLM_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_roberta import RobertaConfig, ROBERTA_PRETRAINED_CONFIG_ARCHIVE_MAP\nfrom .configuration_distilbert import DistilBertConfig, DISTILBERT_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n# Modeling\nif is_torch_available():\n    from .modeling_utils import (PreTrainedModel, prune_layer, Conv1D)\n    from .modeling_auto import (AutoModel, AutoModelForSequenceClassification, AutoModelForQuestionAnswering,\n                                AutoModelWithLMHead)\n\n    from .modeling_bert import (BertPreTrainedModel, BertModel, BertForPreTraining,\n                                BertForMaskedLM, BertForNextSentencePrediction,\n                                BertForSequenceClassification, BertForMultipleChoice,\n                                BertForTokenClassification, BertForQuestionAnswering,\n                                load_tf_weights_in_bert, BERT_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_openai import (OpenAIGPTPreTrainedModel, OpenAIGPTModel,\n                                OpenAIGPTLMHeadModel, OpenAIGPTDoubleHeadsModel,\n                                load_tf_weights_in_openai_gpt, OPENAI_GPT_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_transfo_xl import (TransfoXLPreTrainedModel, TransfoXLModel, TransfoXLLMHeadModel,\n                                    load_tf_weights_in_transfo_xl, TRANSFO_XL_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_gpt2 import (GPT2PreTrainedModel, GPT2Model,\n                                GPT2LMHeadModel, GPT2DoubleHeadsModel,\n                                load_tf_weights_in_gpt2, GPT2_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_ctrl import (CTRLPreTrainedModel, CTRLModel,\n                                CTRLLMHeadModel,\n                                CTRL_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_xlnet import (XLNetPreTrainedModel, XLNetModel, XLNetLMHeadModel,\n                                XLNetForSequenceClassification, XLNetForMultipleChoice,\n                                XLNetForQuestionAnsweringSimple, XLNetForQuestionAnswering,\n                                load_tf_weights_in_xlnet, XLNET_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_xlm import (XLMPreTrainedModel , XLMModel,\n                            XLMWithLMHeadModel, XLMForSequenceClassification,\n                            XLMForQuestionAnswering, XLMForQuestionAnsweringSimple,\n                            XLM_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_roberta import (RobertaForMaskedLM, RobertaModel,\n                                RobertaForSequenceClassification, RobertaForMultipleChoice,\n                                ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_distilbert import (DistilBertForMaskedLM, DistilBertModel,\n                                DistilBertForSequenceClassification, DistilBertForQuestionAnswering,\n                                DISTILBERT_PRETRAINED_MODEL_ARCHIVE_MAP)\n    from .modeling_albert import AlbertForSequenceClassification\n\n    # Optimization\n    from .optimization import (AdamW, ConstantLRSchedule, WarmupConstantSchedule, WarmupCosineSchedule,\n                               WarmupCosineWithHardRestartsSchedule, WarmupLinearSchedule)\nif not is_tf_available() and not is_torch_available():\n    logger.warning(""Neither PyTorch nor TensorFlow >= 2.0 have been found.""\n                   ""Models won\'t be available and only tokenizers, configuration""\n                   ""and file/data utilities can be used."")\n'"
baselines/models_pytorch/classifier_pytorch/transformers/__main__.py,0,"b'# coding: utf8\ndef main():\n    import sys\n    if (len(sys.argv) < 4 or len(sys.argv) > 6) or sys.argv[1] not in [""bert"", ""gpt"", ""transfo_xl"", ""gpt2"", ""xlnet"", ""xlm""]:\n        print(\n        ""This command line utility let you convert original (author released) model checkpoint to pytorch.\\n""\n        ""It should be used as one of: \\n""\n        "">> transformers bert TF_CHECKPOINT TF_CONFIG PYTORCH_DUMP_OUTPUT, \\n""\n        "">> transformers gpt OPENAI_GPT_CHECKPOINT_FOLDER_PATH PYTORCH_DUMP_OUTPUT [OPENAI_GPT_CONFIG], \\n""\n        "">> transformers transfo_xl TF_CHECKPOINT_OR_DATASET PYTORCH_DUMP_OUTPUT [TF_CONFIG] or \\n""\n        "">> transformers gpt2 TF_CHECKPOINT PYTORCH_DUMP_OUTPUT [GPT2_CONFIG] or \\n""\n        "">> transformers xlnet TF_CHECKPOINT TF_CONFIG PYTORCH_DUMP_OUTPUT [FINETUNING_TASK_NAME] or \\n""\n        "">> transformers xlm XLM_CHECKPOINT_PATH PYTORCH_DUMP_OUTPUT"")\n    else:\n        if sys.argv[1] == ""bert"":\n            try:\n                from convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch\n            except ImportError:\n                print(""transformers can only be used from the commandline to convert TensorFlow models in PyTorch, ""\n                    ""In that case, it requires TensorFlow to be installed. Please see ""\n                    ""https://www.tensorflow.org/install/ for installation instructions."")\n                raise\n\n            if len(sys.argv) != 5:\n                # pylint: disable=line-too-long\n                print(""Should be used as `transformers bert TF_CHECKPOINT TF_CONFIG PYTORCH_DUMP_OUTPUT`"")\n            else:\n                PYTORCH_DUMP_OUTPUT = sys.argv.pop()\n                TF_CONFIG = sys.argv.pop()\n                TF_CHECKPOINT = sys.argv.pop()\n                convert_tf_checkpoint_to_pytorch(TF_CHECKPOINT, TF_CONFIG, PYTORCH_DUMP_OUTPUT)\n        elif sys.argv[1] == ""gpt"":\n            from .convert_openai_original_tf_checkpoint_to_pytorch import convert_openai_checkpoint_to_pytorch\n            if len(sys.argv) < 4 or len(sys.argv) > 5:\n                # pylint: disable=line-too-long\n                print(""Should be used as `transformers gpt OPENAI_GPT_CHECKPOINT_FOLDER_PATH PYTORCH_DUMP_OUTPUT [OPENAI_GPT_CONFIG]`"")\n            else:\n                OPENAI_GPT_CHECKPOINT_FOLDER_PATH = sys.argv[2]\n                PYTORCH_DUMP_OUTPUT = sys.argv[3]\n                if len(sys.argv) == 5:\n                    OPENAI_GPT_CONFIG = sys.argv[4]\n                else:\n                    OPENAI_GPT_CONFIG = """"\n                convert_openai_checkpoint_to_pytorch(OPENAI_GPT_CHECKPOINT_FOLDER_PATH,\n                                                    OPENAI_GPT_CONFIG,\n                                                    PYTORCH_DUMP_OUTPUT)\n        elif sys.argv[1] == ""transfo_xl"":\n            try:\n                from .convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch\n            except ImportError:\n                print(""transformers can only be used from the commandline to convert TensorFlow models in PyTorch, ""\n                    ""In that case, it requires TensorFlow to be installed. Please see ""\n                    ""https://www.tensorflow.org/install/ for installation instructions."")\n                raise\n            if len(sys.argv) < 4 or len(sys.argv) > 5:\n                # pylint: disable=line-too-long\n                print(""Should be used as `transformers transfo_xl TF_CHECKPOINT/TF_DATASET_FILE PYTORCH_DUMP_OUTPUT [TF_CONFIG]`"")\n            else:\n                if \'ckpt\' in sys.argv[2].lower():\n                    TF_CHECKPOINT = sys.argv[2]\n                    TF_DATASET_FILE = """"\n                else:\n                    TF_DATASET_FILE = sys.argv[2]\n                    TF_CHECKPOINT = """"\n                PYTORCH_DUMP_OUTPUT = sys.argv[3]\n                if len(sys.argv) == 5:\n                    TF_CONFIG = sys.argv[4]\n                else:\n                    TF_CONFIG = """"\n                convert_transfo_xl_checkpoint_to_pytorch(TF_CHECKPOINT, TF_CONFIG, PYTORCH_DUMP_OUTPUT, TF_DATASET_FILE)\n        elif sys.argv[1] == ""gpt2"":\n            try:\n                from convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch\n            except ImportError:\n                print(""transformers can only be used from the commandline to convert TensorFlow models in PyTorch, ""\n                    ""In that case, it requires TensorFlow to be installed. Please see ""\n                    ""https://www.tensorflow.org/install/ for installation instructions."")\n                raise\n\n            if len(sys.argv) < 4 or len(sys.argv) > 5:\n                # pylint: disable=line-too-long\n                print(""Should be used as `transformers gpt2 TF_CHECKPOINT PYTORCH_DUMP_OUTPUT [TF_CONFIG]`"")\n            else:\n                TF_CHECKPOINT = sys.argv[2]\n                PYTORCH_DUMP_OUTPUT = sys.argv[3]\n                if len(sys.argv) == 5:\n                    TF_CONFIG = sys.argv[4]\n                else:\n                    TF_CONFIG = """"\n                convert_gpt2_checkpoint_to_pytorch(TF_CHECKPOINT, TF_CONFIG, PYTORCH_DUMP_OUTPUT)\n        elif sys.argv[1] == ""xlnet"":\n            try:\n                from convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch\n            except ImportError:\n                print(""transformers can only be used from the commandline to convert TensorFlow models in PyTorch, ""\n                    ""In that case, it requires TensorFlow to be installed. Please see ""\n                    ""https://www.tensorflow.org/install/ for installation instructions."")\n                raise\n\n            if len(sys.argv) < 5 or len(sys.argv) > 6:\n                # pylint: disable=line-too-long\n                print(""Should be used as `transformers xlnet TF_CHECKPOINT TF_CONFIG PYTORCH_DUMP_OUTPUT [FINETUNING_TASK_NAME]`"")\n            else:\n                TF_CHECKPOINT = sys.argv[2]\n                TF_CONFIG = sys.argv[3]\n                PYTORCH_DUMP_OUTPUT = sys.argv[4]\n                if len(sys.argv) == 6:\n                    FINETUNING_TASK = sys.argv[5]\n                else:\n                    FINETUNING_TASK = None\n\n                convert_xlnet_checkpoint_to_pytorch(TF_CHECKPOINT,\n                                                    TF_CONFIG,\n                                                    PYTORCH_DUMP_OUTPUT,\n                                                    FINETUNING_TASK)\n        elif sys.argv[1] == ""xlm"":\n            from .convert_xlm_original_pytorch_checkpoint_to_pytorch import convert_xlm_checkpoint_to_pytorch\n\n            if len(sys.argv) != 4:\n                # pylint: disable=line-too-long\n                print(""Should be used as `transformers xlm XLM_CHECKPOINT_PATH PYTORCH_DUMP_OUTPUT`"")\n            else:\n                XLM_CHECKPOINT_PATH = sys.argv[2]\n                PYTORCH_DUMP_OUTPUT = sys.argv[3]\n\n                convert_xlm_checkpoint_to_pytorch(XLM_CHECKPOINT_PATH, PYTORCH_DUMP_OUTPUT)\n\nif __name__ == \'__main__\':\n    main()\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_auto.py,0,"b'# coding=utf-8\n# Copyright 2018 The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Auto Model class. """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport logging\n\nfrom .configuration_bert import BertConfig\nfrom .configuration_openai import OpenAIGPTConfig\nfrom .configuration_gpt2 import GPT2Config\nfrom .configuration_transfo_xl import TransfoXLConfig\nfrom .configuration_xlnet import XLNetConfig\nfrom .configuration_xlm import XLMConfig\nfrom .configuration_roberta import RobertaConfig\nfrom .configuration_distilbert import DistilBertConfig\nfrom .configuration_ctrl import CTRLConfig\n\nlogger = logging.getLogger(__name__)\n\n\nclass AutoConfig(object):\n    r"""""":class:`~transformers.AutoConfig` is a generic configuration class\n        that will be instantiated as one of the configuration classes of the library\n        when created with the `AutoConfig.from_pretrained(pretrained_model_name_or_path)`\n        class method.\n\n        The `from_pretrained()` method take care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The base model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertConfig (DistilBERT model)\n            - contains `bert`: BertConfig (Bert model)\n            - contains `openai-gpt`: OpenAIGPTConfig (OpenAI GPT model)\n            - contains `gpt2`: GPT2Config (OpenAI GPT-2 model)\n            - contains `transfo-xl`: TransfoXLConfig (Transformer-XL model)\n            - contains `xlnet`: XLNetConfig (XLNet model)\n            - contains `xlm`: XLMConfig (XLM model)\n            - contains `roberta`: RobertaConfig (RoBERTa model)\n            - contains `ctrl` : CTRLConfig (CTRL model)\n        This class cannot be instantiated using `__init__()` (throw an error).\n    """"""\n    def __init__(self):\n        raise EnvironmentError(""AutoConfig is designed to be instantiated ""\n            ""using the `AutoConfig.from_pretrained(pretrained_model_name_or_path)` method."")\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, **kwargs):\n        r"""""" Instantiate a one of the configuration classes of the library\n        from a pre-trained model configuration.\n\n        The configuration class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertConfig (DistilBERT model)\n            - contains `bert`: BertConfig (Bert model)\n            - contains `openai-gpt`: OpenAIGPTConfig (OpenAI GPT model)\n            - contains `gpt2`: GPT2Config (OpenAI GPT-2 model)\n            - contains `transfo-xl`: TransfoXLConfig (Transformer-XL model)\n            - contains `xlnet`: XLNetConfig (XLNet model)\n            - contains `xlm`: XLMConfig (XLM model)\n            - contains `roberta`: RobertaConfig (RoBERTa model)\n            - contains `ctrl` : CTRLConfig (CTRL model)\n        Params:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model configuration to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing a configuration file saved using the :func:`~transformers.PretrainedConfig.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - a path or url to a saved configuration JSON `file`, e.g.: ``./my_model_directory/configuration.json``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            kwargs: (`optional`) dict: key/value pairs with which to update the configuration object after loading.\n\n                - The values in kwargs of any keys which are configuration attributes will be used to override the loaded values.\n                - Behavior concerning key/value pairs whose keys are *not* configuration attributes is controlled by the `return_unused_kwargs` keyword parameter.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            return_unused_kwargs: (`optional`) bool:\n\n                - If False, then this function returns just the final configuration object.\n                - If True, then this functions returns a tuple `(config, unused_kwargs)` where `unused_kwargs` is a dictionary consisting of the key/value pairs whose keys are not configuration attributes: ie the part of kwargs which has not been used to update `config` and is otherwise ignored.\n\n        Examples::\n\n            config = AutoConfig.from_pretrained(\'bert-base-uncased\')    # Download configuration from S3 and cache.\n            config = AutoConfig.from_pretrained(\'./test/bert_saved_model/\')  # E.g. config (or model) was saved using `save_pretrained(\'./test/saved_model/\')`\n            config = AutoConfig.from_pretrained(\'./test/bert_saved_model/my_configuration.json\')\n            config = AutoConfig.from_pretrained(\'bert-base-uncased\', output_attention=True, foo=False)\n            assert config.output_attention == True\n            config, unused_kwargs = AutoConfig.from_pretrained(\'bert-base-uncased\', output_attention=True,\n                                                               foo=False, return_unused_kwargs=True)\n            assert config.output_attention == True\n            assert unused_kwargs == {\'foo\': False}\n\n        """"""\n        if \'distilbert\' in pretrained_model_name_or_path:\n            return DistilBertConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'roberta\' in pretrained_model_name_or_path:\n            return RobertaConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'bert\' in pretrained_model_name_or_path:\n            return BertConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'openai-gpt\' in pretrained_model_name_or_path:\n            return OpenAIGPTConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'gpt2\' in pretrained_model_name_or_path:\n            return GPT2Config.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'transfo-xl\' in pretrained_model_name_or_path:\n            return TransfoXLConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'xlnet\' in pretrained_model_name_or_path:\n            return XLNetConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'xlm\' in pretrained_model_name_or_path:\n            return XLMConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        elif \'ctrl\' in pretrained_model_name_or_path:\n            return CTRLConfig.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        raise ValueError(""Unrecognized model identifier in {}. Should contains one of ""\n                         ""\'bert\', \'openai-gpt\', \'gpt2\', \'transfo-xl\', \'xlnet\', ""\n                         ""\'xlm\', \'roberta\', \'ctrl\'"".format(pretrained_model_name_or_path))\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_bert.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" BERT model configuration """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nBERT_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-config.json"",\n    \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-config.json"",\n    \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-config.json"",\n    \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-config.json"",\n    \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-config.json"",\n    \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-config.json"",\n    \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-config.json"",\n    \'bert-base-german-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-cased-config.json"",\n    \'bert-large-uncased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-config.json"",\n    \'bert-large-cased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-config.json"",\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-finetuned-squad-config.json"",\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-finetuned-squad-config.json"",\n    \'bert-base-cased-finetuned-mrpc\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-finetuned-mrpc-config.json"",\n    \'bert-base-german-dbmdz-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-cased-config.json"",\n    \'bert-base-german-dbmdz-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-uncased-config.json"",\n}\n\n\nclass BertConfig(PretrainedConfig):\n    r""""""\n        :class:`~transformers.BertConfig` is the configuration class to store the configuration of a\n        `BertModel`.\n\n\n        Arguments:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `BertModel`.\n            hidden_size: Size of the encoder layers and the pooler layer.\n            num_hidden_layers: Number of hidden layers in the Transformer encoder.\n            num_attention_heads: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n                layer in the Transformer encoder.\n            hidden_act: The non-linear activation function (function or string) in the\n                encoder and pooler. If string, ""gelu"", ""relu"", ""swish"" and ""gelu_new"" are supported.\n            hidden_dropout_prob: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attention_probs_dropout_prob: The dropout ratio for the attention\n                probabilities.\n            max_position_embeddings: The maximum sequence length that this model might\n                ever be used with. Typically set this to something large just in case\n                (e.g., 512 or 1024 or 2048).\n            type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n                `BertModel`.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n            layer_norm_eps: The epsilon used by LayerNorm.\n    """"""\n    pretrained_config_archive_map = BERT_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=30522,\n                 hidden_size=768,\n                 num_hidden_layers=12,\n                 num_attention_heads=12,\n                 intermediate_size=3072,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=2,\n                 initializer_range=0.02,\n                 layer_norm_eps=1e-12,\n                 **kwargs):\n        super(BertConfig, self).__init__(**kwargs)\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.hidden_size = hidden_size\n            self.num_hidden_layers = num_hidden_layers\n            self.num_attention_heads = num_attention_heads\n            self.hidden_act = hidden_act\n            self.intermediate_size = intermediate_size\n            self.hidden_dropout_prob = hidden_dropout_prob\n            self.attention_probs_dropout_prob = attention_probs_dropout_prob\n            self.max_position_embeddings = max_position_embeddings\n            self.type_vocab_size = type_vocab_size\n            self.initializer_range = initializer_range\n            self.layer_norm_eps = layer_norm_eps\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             "" or the path to a pretrained model config file (str)"")\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_ctrl.py,0,"b'# coding=utf-8\n# Copyright 2018 Salesforce and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Salesforce CTRL configuration """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nCTRL_PRETRAINED_CONFIG_ARCHIVE_MAP = {""ctrl"": ""https://storage.googleapis.com/sf-ctrl/pytorch/ctrl-config.json""}\n\nclass CTRLConfig(PretrainedConfig):\n    """"""Configuration class to store the configuration of a `CTRLModel`.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `CTRLModel` or a configuration json file.\n        n_positions: Number of positional embeddings.\n        n_ctx: Size of the causal mask (usually same as n_positions).\n        dff: Size of the inner dimension of the FFN.\n        n_embd: Dimensionality of the embeddings and hidden states.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        layer_norm_epsilon: epsilon to use in the layer norm layers\n        resid_pdrop: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        attn_pdrop: The dropout ratio for the attention\n            probabilities.\n        embd_pdrop: The dropout ratio for the embeddings.\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n    """"""\n    pretrained_config_archive_map = CTRL_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(\n        self,\n        vocab_size_or_config_json_file=246534,\n        n_positions=256,\n        n_ctx=256,\n        n_embd=1280,\n        dff=8192,\n        n_layer=48,\n        n_head=16,\n        resid_pdrop=0.1,\n        embd_pdrop=0.1,\n        attn_pdrop=0.1,\n        layer_norm_epsilon=1e-6,\n        initializer_range=0.02,\n\n        num_labels=1,\n        summary_type=\'cls_index\',\n        summary_use_proj=True,\n        summary_activation=None,\n        summary_proj_to_labels=True,\n        summary_first_dropout=0.1,\n        **kwargs\n    ):\n        """"""Constructs CTRLConfig.\n\n        Args:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `CTRLModel` or a configuration json file.\n            n_positions: Number of positional embeddings.\n            n_ctx: Size of the causal mask (usually same as n_positions).\n            dff: Size of the inner dimension of the FFN.\n            n_embd: Dimensionality of the embeddings and hidden states.\n            n_layer: Number of hidden layers in the Transformer encoder.\n            n_head: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            layer_norm_epsilon: epsilon to use in the layer norm layers\n            resid_pdrop: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attn_pdrop: The dropout ratio for the attention\n                probabilities.\n            embd_pdrop: The dropout ratio for the embeddings.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n        """"""\n        super(CTRLConfig, self).__init__(**kwargs)\n\n        self.vocab_size = vocab_size_or_config_json_file if isinstance(vocab_size_or_config_json_file, int) else -1\n        self.n_ctx = n_ctx\n        self.n_positions = n_positions\n        self.n_embd = n_embd\n        self.n_layer = n_layer\n        self.n_head = n_head\n        self.dff = dff\n        self.resid_pdrop = resid_pdrop\n        self.embd_pdrop = embd_pdrop\n        self.attn_pdrop = attn_pdrop\n        self.layer_norm_epsilon = layer_norm_epsilon\n        self.initializer_range = initializer_range\n\n        self.num_labels = num_labels\n        self.summary_type = summary_type\n        self.summary_use_proj = summary_use_proj\n        self.summary_activation = summary_activation\n        self.summary_first_dropout = summary_first_dropout\n        self.summary_proj_to_labels = summary_proj_to_labels\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=""utf-8"") as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif not isinstance(vocab_size_or_config_json_file, int):\n            raise ValueError(\n                ""First argument must be either a vocabulary size (int)""\n                ""or the path to a pretrained model config file (str)""\n            )\n\n    @property\n    def max_position_embeddings(self):\n        return self.n_positions\n\n    @property\n    def hidden_size(self):\n        return self.n_embd\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_distilbert.py,0,"b'# coding=utf-8\n# Copyright 2019-present, the HuggingFace Inc. team, The Google AI Language Team and Facebook, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" DistilBERT model configuration """"""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport sys\nimport json\nimport logging\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nDISTILBERT_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'distilbert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/distilbert-base-uncased-config.json"",\n    \'distilbert-base-uncased-distilled-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/distilbert-base-uncased-distilled-squad-config.json""\n}\n\n\nclass DistilBertConfig(PretrainedConfig):\n    pretrained_config_archive_map = DISTILBERT_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=30522,\n                 max_position_embeddings=512,\n                 sinusoidal_pos_embds=False,\n                 n_layers=6,\n                 n_heads=12,\n                 dim=768,\n                 hidden_dim=4*768,\n                 dropout=0.1,\n                 attention_dropout=0.1,\n                 activation=\'gelu\',\n                 initializer_range=0.02,\n                 tie_weights_=True,\n                 qa_dropout=0.1,\n                 seq_classif_dropout=0.2,\n                 **kwargs):\n        super(DistilBertConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.max_position_embeddings = max_position_embeddings\n            self.sinusoidal_pos_embds = sinusoidal_pos_embds\n            self.n_layers = n_layers\n            self.n_heads = n_heads\n            self.dim = dim\n            self.hidden_dim = hidden_dim\n            self.dropout = dropout\n            self.attention_dropout = attention_dropout\n            self.activation = activation\n            self.initializer_range = initializer_range\n            self.tie_weights_ = tie_weights_\n            self.qa_dropout = qa_dropout\n            self.seq_classif_dropout = seq_classif_dropout\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             "" or the path to a pretrained model config file (str)"")\n    @property\n    def hidden_size(self):\n        return self.dim\n\n    @property\n    def num_attention_heads(self):\n        return self.n_heads\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layers\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_gpt2.py,0,"b'# coding=utf-8\n# Copyright 2018 The OpenAI Team Authors and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" OpenAI GPT-2 configuration """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nGPT2_PRETRAINED_CONFIG_ARCHIVE_MAP = {""gpt2"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-config.json"",\n                                      ""gpt2-medium"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-config.json"",\n                                      ""gpt2-large"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-large-config.json"",\n                                      ""distilgpt2"": ""https://s3.amazonaws.com/models.huggingface.co/bert/distilgpt2-config.json"",}\n\nclass GPT2Config(PretrainedConfig):\n    """"""Configuration class to store the configuration of a `GPT2Model`.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `GPT2Model` or a configuration json file.\n        n_positions: Number of positional embeddings.\n        n_ctx: Size of the causal mask (usually same as n_positions).\n        n_embd: Dimensionality of the embeddings and hidden states.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        layer_norm_epsilon: epsilon to use in the layer norm layers\n        resid_pdrop: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        attn_pdrop: The dropout ratio for the attention\n            probabilities.\n        embd_pdrop: The dropout ratio for the embeddings.\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n    """"""\n    pretrained_config_archive_map = GPT2_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(\n        self,\n        vocab_size_or_config_json_file=50257,\n        n_positions=1024,\n        n_ctx=1024,\n        n_embd=768,\n        n_layer=12,\n        n_head=12,\n        resid_pdrop=0.1,\n        embd_pdrop=0.1,\n        attn_pdrop=0.1,\n        layer_norm_epsilon=1e-5,\n        initializer_range=0.02,\n\n        num_labels=1,\n        summary_type=\'cls_index\',\n        summary_use_proj=True,\n        summary_activation=None,\n        summary_proj_to_labels=True,\n        summary_first_dropout=0.1,\n        **kwargs\n    ):\n        """"""Constructs GPT2Config.\n\n        Args:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `GPT2Model` or a configuration json file.\n            n_positions: Number of positional embeddings.\n            n_ctx: Size of the causal mask (usually same as n_positions).\n            n_embd: Dimensionality of the embeddings and hidden states.\n            n_layer: Number of hidden layers in the Transformer encoder.\n            n_head: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            layer_norm_epsilon: epsilon to use in the layer norm layers\n            resid_pdrop: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attn_pdrop: The dropout ratio for the attention\n                probabilities.\n            embd_pdrop: The dropout ratio for the embeddings.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n        """"""\n        super(GPT2Config, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=""utf-8"") as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.n_ctx = n_ctx\n            self.n_positions = n_positions\n            self.n_embd = n_embd\n            self.n_layer = n_layer\n            self.n_head = n_head\n            self.resid_pdrop = resid_pdrop\n            self.embd_pdrop = embd_pdrop\n            self.attn_pdrop = attn_pdrop\n            self.layer_norm_epsilon = layer_norm_epsilon\n            self.initializer_range = initializer_range\n\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_first_dropout = summary_first_dropout\n            self.summary_proj_to_labels = summary_proj_to_labels\n        else:\n            raise ValueError(\n                ""First argument must be either a vocabulary size (int)""\n                ""or the path to a pretrained model config file (str)""\n            )\n\n    @property\n    def max_position_embeddings(self):\n        return self.n_positions\n\n    @property\n    def hidden_size(self):\n        return self.n_embd\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_openai.py,0,"b'# coding=utf-8\n# Copyright 2018 The OpenAI Team Authors and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" OpenAI GPT configuration """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nOPENAI_GPT_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    ""openai-gpt"": ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-config.json""\n}\n\nclass OpenAIGPTConfig(PretrainedConfig):\n    """"""\n    Configuration class to store the configuration of a `OpenAIGPTModel`.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `OpenAIGPTModel` or a configuration json file.\n        n_positions: Number of positional embeddings.\n        n_ctx: Size of the causal mask (usually same as n_positions).\n        n_embd: Dimensionality of the embeddings and hidden states.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        afn: The non-linear activation function (function or string) in the\n            encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n        resid_pdrop: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        attn_pdrop: The dropout ratio for the attention\n            probabilities.\n        embd_pdrop: The dropout ratio for the embeddings.\n        layer_norm_epsilon: epsilon to use in the layer norm layers\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n        predict_special_tokens: should we predict special tokens (when the model has a LM head)\n    """"""\n    pretrained_config_archive_map = OPENAI_GPT_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(\n        self,\n        vocab_size_or_config_json_file=40478,\n        n_positions=512,\n        n_ctx=512,\n        n_embd=768,\n        n_layer=12,\n        n_head=12,\n        afn=""gelu"",\n        resid_pdrop=0.1,\n        embd_pdrop=0.1,\n        attn_pdrop=0.1,\n        layer_norm_epsilon=1e-5,\n        initializer_range=0.02,\n        predict_special_tokens=True,\n\n        num_labels=1,\n        summary_type=\'cls_index\',\n        summary_use_proj=True,\n        summary_activation=None,\n        summary_proj_to_labels=True,\n        summary_first_dropout=0.1,\n        **kwargs\n    ):\n        """"""Constructs OpenAIGPTConfig.\n        """"""\n        super(OpenAIGPTConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=""utf-8"") as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.n_ctx = n_ctx\n            self.n_positions = n_positions\n            self.n_embd = n_embd\n            self.n_layer = n_layer\n            self.n_head = n_head\n            self.afn = afn\n            self.resid_pdrop = resid_pdrop\n            self.embd_pdrop = embd_pdrop\n            self.attn_pdrop = attn_pdrop\n            self.layer_norm_epsilon = layer_norm_epsilon\n            self.initializer_range = initializer_range\n            self.predict_special_tokens = predict_special_tokens\n\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_first_dropout = summary_first_dropout\n            self.summary_proj_to_labels = summary_proj_to_labels\n        else:\n            raise ValueError(\n                ""First argument must be either a vocabulary size (int)""\n                ""or the path to a pretrained model config file (str)""\n            )\n\n    @property\n    def max_position_embeddings(self):\n        return self.n_positions\n\n    @property\n    def hidden_size(self):\n        return self.n_embd\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_roberta.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" RoBERTa configuration """"""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\n\nfrom .configuration_bert import BertConfig\n\nlogger = logging.getLogger(__name__)\n\nROBERTA_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-config.json"",\n    \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-config.json"",\n    \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-config.json"",\n}\n\n\nclass RobertaConfig(BertConfig):\n    pretrained_config_archive_map = ROBERTA_PRETRAINED_CONFIG_ARCHIVE_MAP\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_transfo_xl.py,0,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Transformer XL configuration """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nTRANSFO_XL_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-config.json"",\n}\n\nclass TransfoXLConfig(PretrainedConfig):\n    """"""Configuration class to store the configuration of a `TransfoXLModel`.\n\n        Args:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `TransfoXLModel` or a configuration json file.\n            cutoffs: cutoffs for the adaptive softmax\n            d_model: Dimensionality of the model\'s hidden states.\n            d_embed: Dimensionality of the embeddings\n            d_head: Dimensionality of the model\'s heads.\n            div_val: divident value for adapative input and softmax\n            pre_lnorm: apply LayerNorm to the input instead of the output\n            d_inner: Inner dimension in FF\n            n_layer: Number of hidden layers in the Transformer encoder.\n            n_head: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            tgt_len: number of tokens to predict\n            ext_len: length of the extended context\n            mem_len: length of the retained previous heads\n            same_length: use the same attn length for all tokens\n            proj_share_all_but_first: True to share all but first projs, False not to share.\n            attn_type: attention type. 0 for Transformer-XL, 1 for Shaw et al, 2 for Vaswani et al, 3 for Al Rfou et al.\n            clamp_len: use the same pos embeddings after clamp_len\n            sample_softmax: number of samples in sampled softmax\n            adaptive: use adaptive softmax\n            tie_weight: tie the word embedding and softmax weights\n            dropout: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            dropatt: The dropout ratio for the attention probabilities.\n            untie_r: untie relative position biases\n            embd_pdrop: The dropout ratio for the embeddings.\n            init: parameter initializer to use\n            init_range: parameters initialized by U(-init_range, init_range).\n            proj_init_std: parameters initialized by N(0, init_std)\n            init_std: parameters initialized by N(0, init_std)\n    """"""\n    pretrained_config_archive_map = TRANSFO_XL_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=267735,\n                 cutoffs=[20000, 40000, 200000],\n                 d_model=1024,\n                 d_embed=1024,\n                 n_head=16,\n                 d_head=64,\n                 d_inner=4096,\n                 div_val=4,\n                 pre_lnorm=False,\n                 n_layer=18,\n                 tgt_len=128,\n                 ext_len=0,\n                 mem_len=1600,\n                 clamp_len=1000,\n                 same_length=True,\n                 proj_share_all_but_first=True,\n                 attn_type=0,\n                 sample_softmax=-1,\n                 adaptive=True,\n                 tie_weight=True,\n                 dropout=0.1,\n                 dropatt=0.0,\n                 untie_r=True,\n                 init=""normal"",\n                 init_range=0.01,\n                 proj_init_std=0.01,\n                 init_std=0.02,\n                 layer_norm_epsilon=1e-5,\n                 **kwargs):\n        """"""Constructs TransfoXLConfig.\n        """"""\n        super(TransfoXLConfig, self).__init__(**kwargs)\n        self.n_token = vocab_size_or_config_json_file if isinstance(vocab_size_or_config_json_file, int) else -1\n        self.cutoffs = []\n        self.cutoffs.extend(cutoffs)\n        self.tie_weight = tie_weight\n        if proj_share_all_but_first:\n            self.tie_projs = [False] + [True] * len(self.cutoffs)\n        else:\n            self.tie_projs = [False] + [False] * len(self.cutoffs)\n        self.d_model = d_model\n        self.d_embed = d_embed\n        self.d_head = d_head\n        self.d_inner = d_inner\n        self.div_val = div_val\n        self.pre_lnorm = pre_lnorm\n        self.n_layer = n_layer\n        self.n_head = n_head\n        self.tgt_len = tgt_len\n        self.ext_len = ext_len\n        self.mem_len = mem_len\n        self.same_length = same_length\n        self.attn_type = attn_type\n        self.clamp_len = clamp_len\n        self.sample_softmax = sample_softmax\n        self.adaptive = adaptive\n        self.dropout = dropout\n        self.dropatt = dropatt\n        self.untie_r = untie_r\n        self.init = init\n        self.init_range = init_range\n        self.proj_init_std = proj_init_std\n        self.init_std = init_std\n        self.layer_norm_epsilon = layer_norm_epsilon\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif not isinstance(vocab_size_or_config_json_file, int):\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             "" or the path to a pretrained model config file (str)"")\n\n    @property\n    def max_position_embeddings(self):\n        return self.tgt_len + self.ext_len + self.mem_len\n\n    @property\n    def vocab_size(self):\n        return self.n_token\n\n    @vocab_size.setter\n    def vocab_size(self, value):\n        self.n_token = value\n\n    @property\n    def hidden_size(self):\n        return self.d_model\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_utils.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Configuration base class and utilities.""""""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport copy\nimport json\nimport logging\nimport os\nfrom io import open\n\nfrom .file_utils import cached_path, CONFIG_NAME\n\nlogger = logging.getLogger(__name__)\n\nclass PretrainedConfig(object):\n    r"""""" Base class for all configuration classes.\n        Handles a few parameters common to all models\' configurations as well as methods for loading/downloading/saving configurations.\n\n        Note:\n            A configuration file can be loaded and saved to disk. Loading the configuration file and using this file to initialize a model does **not** load the model weights.\n            It only affects the model\'s configuration.\n\n        Class attributes (overridden by derived classes):\n            - ``pretrained_config_archive_map``: a python ``dict`` of with `short-cut-names` (string) as keys and `url` (string) of associated pretrained model configurations as values.\n\n        Parameters:\n            ``finetuning_task``: string, default `None`. Name of the task used to fine-tune the model. This can be used when converting from an original (TensorFlow or PyTorch) checkpoint.\n            ``num_labels``: integer, default `2`. Number of classes to use when the model is a classification model (sequences/tokens)\n            ``output_attentions``: boolean, default `False`. Should the model returns attentions weights.\n            ``output_hidden_states``: string, default `False`. Should the model returns all hidden-states.\n            ``torchscript``: string, default `False`. Is the model used with Torchscript.\n    """"""\n    pretrained_config_archive_map = {}\n\n    def __init__(self, **kwargs):\n        self.finetuning_task = kwargs.pop(\'finetuning_task\', None)\n        self.num_labels = kwargs.pop(\'num_labels\', 2)\n        self.output_attentions = kwargs.pop(\'output_attentions\', False)\n        self.output_hidden_states = kwargs.pop(\'output_hidden_states\', False)\n        self.output_past = kwargs.pop(\'output_past\', True)  # Not used by all models\n        self.torchscript = kwargs.pop(\'torchscript\', False)  # Only used by PyTorch models\n        self.use_bfloat16 = kwargs.pop(\'use_bfloat16\', False)\n        self.pruned_heads = kwargs.pop(\'pruned_heads\', {})\n\n    def save_pretrained(self, save_directory):\n        """""" Save a configuration object to the directory `save_directory`, so that it\n            can be re-loaded using the :func:`~transformers.PretrainedConfig.from_pretrained` class method.\n        """"""\n        assert os.path.isdir(save_directory), ""Saving path should be a directory where the model and configuration can be saved""\n\n        # If we save using the predefined names, we can load using `from_pretrained`\n        output_config_file = os.path.join(save_directory, CONFIG_NAME)\n\n        self.to_json_file(output_config_file)\n        logger.info(""Configuration saved in {}"".format(output_config_file))\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, **kwargs):\n        r"""""" Instantiate a :class:`~transformers.PretrainedConfig` (or a derived class) from a pre-trained model configuration.\n\n        Parameters:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model configuration to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing a configuration file saved using the :func:`~transformers.PretrainedConfig.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - a path or url to a saved configuration JSON `file`, e.g.: ``./my_model_directory/configuration.json``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            kwargs: (`optional`) dict: key/value pairs with which to update the configuration object after loading.\n\n                - The values in kwargs of any keys which are configuration attributes will be used to override the loaded values.\n                - Behavior concerning key/value pairs whose keys are *not* configuration attributes is controlled by the `return_unused_kwargs` keyword parameter.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            return_unused_kwargs: (`optional`) bool:\n\n                - If False, then this function returns just the final configuration object.\n                - If True, then this functions returns a tuple `(config, unused_kwargs)` where `unused_kwargs` is a dictionary consisting of the key/value pairs whose keys are not configuration attributes: ie the part of kwargs which has not been used to update `config` and is otherwise ignored.\n\n        Examples::\n\n            # We can\'t instantiate directly the base class `PretrainedConfig` so let\'s show the examples on a\n            # derived class: BertConfig\n            config = BertConfig.from_pretrained(\'bert-base-uncased\')    # Download configuration from S3 and cache.\n            config = BertConfig.from_pretrained(\'./test/saved_model/\')  # E.g. config (or model) was saved using `save_pretrained(\'./test/saved_model/\')`\n            config = BertConfig.from_pretrained(\'./test/saved_model/my_configuration.json\')\n            config = BertConfig.from_pretrained(\'bert-base-uncased\', output_attention=True, foo=False)\n            assert config.output_attention == True\n            config, unused_kwargs = BertConfig.from_pretrained(\'bert-base-uncased\', output_attention=True,\n                                                               foo=False, return_unused_kwargs=True)\n            assert config.output_attention == True\n            assert unused_kwargs == {\'foo\': False}\n\n        """"""\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        force_download = kwargs.pop(\'force_download\', False)\n        proxies = kwargs.pop(\'proxies\', None)\n        return_unused_kwargs = kwargs.pop(\'return_unused_kwargs\', False)\n\n        if pretrained_model_name_or_path in cls.pretrained_config_archive_map:\n            config_file = cls.pretrained_config_archive_map[pretrained_model_name_or_path]\n        elif os.path.isdir(pretrained_model_name_or_path):\n            config_file = os.path.join(pretrained_model_name_or_path, CONFIG_NAME)\n        else:\n            config_file = pretrained_model_name_or_path\n        # redirect to the cache, if necessary\n        try:\n            resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n        except EnvironmentError:\n            if pretrained_model_name_or_path in cls.pretrained_config_archive_map:\n                msg = ""Couldn\'t reach server at \'{}\' to download pretrained model configuration file."".format(\n                        config_file)\n            else:\n                msg = ""Model name \'{}\' was not found in model name list ({}). "" \\\n                      ""We assumed \'{}\' was a path or url to a configuration file named {} or "" \\\n                      ""a directory containing such a file but couldn\'t find any such file at this path or url."".format(\n                        pretrained_model_name_or_path,\n                        \', \'.join(cls.pretrained_config_archive_map.keys()),\n                        config_file, CONFIG_NAME)\n            raise EnvironmentError(msg)\n\n        if resolved_config_file == config_file:\n            logger.info(""loading configuration file {}"".format(config_file))\n        else:\n            logger.info(""loading configuration file {} from cache at {}"".format(\n                config_file, resolved_config_file))\n\n        # Load config\n        config = cls.from_json_file(resolved_config_file)\n\n        if hasattr(config, \'pruned_heads\'):\n            config.pruned_heads = dict((int(key), value) for key, value in config.pruned_heads.items())\n\n        # Update config with kwargs if needed\n        to_remove = []\n        for key, value in kwargs.items():\n            if hasattr(config, key):\n                setattr(config, key, value)\n                to_remove.append(key)\n        for key in to_remove:\n            kwargs.pop(key, None)\n\n        logger.info(""Model config %s"", str(config))\n        if return_unused_kwargs:\n            return config, kwargs\n        else:\n            return config\n\n    @classmethod\n    def from_dict(cls, json_object):\n        """"""Constructs a `Config` from a Python dictionary of parameters.""""""\n        config = cls(vocab_size_or_config_json_file=-1)\n        for key, value in json_object.items():\n            setattr(config, key, value)\n        return config\n\n    @classmethod\n    def from_json_file(cls, json_file):\n        """"""Constructs a `BertConfig` from a json file of parameters.""""""\n        with open(json_file, ""r"", encoding=\'utf-8\') as reader:\n            text = reader.read()\n        return cls.from_dict(json.loads(text))\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n    def to_json_file(self, json_file_path):\n        """""" Save this instance to a json file.""""""\n        with open(json_file_path, ""w"", encoding=\'utf-8\') as writer:\n            writer.write(self.to_json_string())\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_xlm.py,0,"b'# coding=utf-8\n# Copyright 2019-present, Facebook, Inc and the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" XLM configuration """"""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nXLM_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-config.json"",\n    \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-config.json"",\n    \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-config.json"",\n    \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-config.json"",\n    \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-config.json"",\n    \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-config.json"",\n    \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-enfr-1024-config.json"",\n    \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-ende-1024-config.json"",\n    \'xlm-mlm-17-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-17-1280-config.json"",\n    \'xlm-mlm-100-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-100-1280-config.json"",\n}\n\n\nclass XLMConfig(PretrainedConfig):\n    """"""Configuration class to store the configuration of a `XLMModel`.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `XLMModel`.\n        d_model: Size of the encoder layers and the pooler layer.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        d_inner: The size of the ""intermediate"" (i.e., feed-forward)\n            layer in the Transformer encoder.\n        ff_activation: The non-linear activation function (function or string) in the\n            encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n        untie_r: untie relative position biases\n        attn_type: \'bi\' for XLM, \'uni\' for Transformer-XL\n\n        dropout: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        max_position_embeddings: The maximum sequence length that this model might\n            ever be used with. Typically set this to something large just in case\n            (e.g., 512 or 1024 or 2048).\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n        layer_norm_eps: The epsilon used by LayerNorm.\n\n        dropout: float, dropout rate.\n        init: str, the initialization scheme, either ""normal"" or ""uniform"".\n        init_range: float, initialize the parameters with a uniform distribution\n            in [-init_range, init_range]. Only effective when init=""uniform"".\n        init_std: float, initialize the parameters with a normal distribution\n            with mean 0 and stddev init_std. Only effective when init=""normal"".\n        mem_len: int, the number of tokens to cache.\n        reuse_len: int, the number of tokens in the currect batch to be cached\n            and reused in the future.\n        bi_data: bool, whether to use bidirectional input pipeline.\n            Usually set to True during pretraining and False during finetuning.\n        clamp_len: int, clamp all relative distances larger than clamp_len.\n            -1 means no clamping.\n        same_length: bool, whether to use the same attention length for each token.\n    """"""\n    pretrained_config_archive_map = XLM_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=30145,\n                 emb_dim=2048,\n                 n_layers=12,\n                 n_heads=16,\n                 dropout=0.1,\n                 attention_dropout=0.1,\n                 gelu_activation=True,\n                 sinusoidal_embeddings=False,\n                 causal=False,\n                 asm=False,\n                 n_langs=1,\n                 use_lang_emb=True,\n                 max_position_embeddings=512,\n                 embed_init_std=2048 ** -0.5,\n                 layer_norm_eps=1e-12,\n                 init_std=0.02,\n                 bos_index=0,\n                 eos_index=1,\n                 pad_index=2,\n                 unk_index=3,\n                 mask_index=5,\n                 is_encoder=True,\n\n                 finetuning_task=None,\n                 num_labels=2,\n                 summary_type=\'first\',\n                 summary_use_proj=True,\n                 summary_activation=None,\n                 summary_proj_to_labels=True,\n                 summary_first_dropout=0.1,\n                 start_n_top=5,\n                 end_n_top=5,\n                 **kwargs):\n        """"""Constructs XLMConfig.\n        """"""\n        super(XLMConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.n_words = vocab_size_or_config_json_file\n            self.emb_dim = emb_dim\n            self.n_layers = n_layers\n            self.n_heads = n_heads\n            self.dropout = dropout\n            self.attention_dropout = attention_dropout\n            self.gelu_activation = gelu_activation\n            self.sinusoidal_embeddings = sinusoidal_embeddings\n            self.causal = causal\n            self.asm = asm\n            self.n_langs = n_langs\n            self.use_lang_emb = use_lang_emb\n            self.layer_norm_eps = layer_norm_eps\n            self.bos_index = bos_index\n            self.eos_index = eos_index\n            self.pad_index = pad_index\n            self.unk_index = unk_index\n            self.mask_index = mask_index\n            self.is_encoder = is_encoder\n            self.max_position_embeddings = max_position_embeddings\n            self.embed_init_std = embed_init_std\n            self.init_std = init_std\n            self.finetuning_task = finetuning_task\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_proj_to_labels = summary_proj_to_labels\n            self.summary_first_dropout = summary_first_dropout\n            self.start_n_top = start_n_top\n            self.end_n_top = end_n_top\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             "" or the path to a pretrained model config file (str)"")\n\n    @property\n    def vocab_size(self):\n        return self.n_words\n\n    @vocab_size.setter\n    def vocab_size(self, value):\n        self.n_words = value\n\n    @property\n    def hidden_size(self):\n        return self.emb_dim\n\n    @property\n    def num_attention_heads(self):\n        return self.n_heads\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layers\n'"
baselines/models_pytorch/classifier_pytorch/transformers/configuration_xlnet.py,0,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" XLNet configuration """"""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nXLNET_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'xlnet-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-base-cased-config.json"",\n    \'xlnet-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-large-cased-config.json"",\n}\n\n\nclass XLNetConfig(PretrainedConfig):\n    """"""Configuration class to store the configuration of a ``XLNetModel``.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of ``inputs_ids`` in ``XLNetModel``.\n        d_model: Size of the encoder layers and the pooler layer.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        d_inner: The size of the ""intermediate"" (i.e., feed-forward)\n            layer in the Transformer encoder.\n        ff_activation: The non-linear activation function (function or string) in the\n            encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n        untie_r: untie relative position biases\n        attn_type: \'bi\' for XLNet, \'uni\' for Transformer-XL\n\n        dropout: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n        layer_norm_eps: The epsilon used by LayerNorm.\n\n        dropout: float, dropout rate.\n        init: str, the initialization scheme, either ""normal"" or ""uniform"".\n        init_range: float, initialize the parameters with a uniform distribution\n            in [-init_range, init_range]. Only effective when init=""uniform"".\n        init_std: float, initialize the parameters with a normal distribution\n            with mean 0 and stddev init_std. Only effective when init=""normal"".\n        mem_len: int, the number of tokens to cache.\n        reuse_len: int, the number of tokens in the currect batch to be cached\n            and reused in the future.\n        bi_data: bool, whether to use bidirectional input pipeline.\n            Usually set to True during pretraining and False during finetuning.\n        clamp_len: int, clamp all relative distances larger than clamp_len.\n            -1 means no clamping.\n        same_length: bool, whether to use the same attention length for each token.\n        finetuning_task: name of the glue task on which the model was fine-tuned if any\n    """"""\n    pretrained_config_archive_map = XLNET_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=32000,\n                 d_model=1024,\n                 n_layer=24,\n                 n_head=16,\n                 d_inner=4096,\n                 max_position_embeddings=512,\n                 ff_activation=""gelu"",\n                 untie_r=True,\n                 attn_type=""bi"",\n\n                 initializer_range=0.02,\n                 layer_norm_eps=1e-12,\n\n                 dropout=0.1,\n                 mem_len=None,\n                 reuse_len=None,\n                 bi_data=False,\n                 clamp_len=-1,\n                 same_length=False,\n\n                 finetuning_task=None,\n                 num_labels=2,\n                 summary_type=\'last\',\n                 summary_use_proj=True,\n                 summary_activation=\'tanh\',\n                 summary_last_dropout=0.1,\n                 start_n_top=5,\n                 end_n_top=5,\n                 **kwargs):\n        """"""Constructs XLNetConfig.\n        """"""\n        super(XLNetConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                setattr(config, key, value)\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.n_token = vocab_size_or_config_json_file\n            self.d_model = d_model\n            self.n_layer = n_layer\n            self.n_head = n_head\n            assert d_model % n_head == 0\n            self.d_head = d_model // n_head\n            self.ff_activation = ff_activation\n            self.d_inner = d_inner\n            self.untie_r = untie_r\n            self.attn_type = attn_type\n\n            self.initializer_range = initializer_range\n            self.layer_norm_eps = layer_norm_eps\n\n            self.dropout = dropout\n            self.mem_len = mem_len\n            self.reuse_len = reuse_len\n            self.bi_data = bi_data\n            self.clamp_len = clamp_len\n            self.same_length = same_length\n\n            self.finetuning_task = finetuning_task\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_last_dropout = summary_last_dropout\n            self.start_n_top = start_n_top\n            self.end_n_top = end_n_top\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             "" or the path to a pretrained model config file (str)"")\n\n    @property\n    def max_position_embeddings(self):\n        return -1\n\n    @property\n    def vocab_size(self):\n        return self.n_token\n\n    @vocab_size.setter\n    def vocab_size(self, value):\n        self.n_token = value\n\n    @property\n    def hidden_size(self):\n        return self.d_model\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n'"
baselines/models_pytorch/classifier_pytorch/transformers/file_utils.py,2,"b'""""""\nUtilities for working with the local dataset cache.\nThis file is adapted from the AllenNLP library at https://github.com/allenai/allennlp\nCopyright by the AllenNLP authors.\n""""""\nfrom __future__ import (absolute_import, division, print_function, unicode_literals)\n\nimport sys\nimport json\nimport logging\nimport os\nimport six\nimport shutil\nimport tempfile\nimport fnmatch\nfrom functools import wraps\nfrom hashlib import sha256\nfrom io import open\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\nimport requests\nfrom tqdm import tqdm\n\nlogger = logging.getLogger(__name__)  # pylint: disable=invalid-name\n\ntry:\n    import tensorflow as tf\n    assert hasattr(tf, \'__version__\') and int(tf.__version__[0]) >= 2\n    _tf_available = True  # pylint: disable=invalid-name\n    logger.info(""TensorFlow version {} available."".format(tf.__version__))\nexcept (ImportError, AssertionError):\n    _tf_available = False  # pylint: disable=invalid-name\n\ntry:\n    import torch\n    _torch_available = True  # pylint: disable=invalid-name\n    logger.info(""PyTorch version {} available."".format(torch.__version__))\nexcept ImportError:\n    _torch_available = False  # pylint: disable=invalid-name\n\n\ntry:\n    from torch.hub import _get_torch_home\n    torch_cache_home = _get_torch_home()\nexcept ImportError:\n    torch_cache_home = os.path.expanduser(\n        os.getenv(\'TORCH_HOME\', os.path.join(\n            os.getenv(\'XDG_CACHE_HOME\', \'~/.cache\'), \'torch\')))\ndefault_cache_path = os.path.join(torch_cache_home, \'transformers\')\n\ntry:\n    from urllib.parse import urlparse\nexcept ImportError:\n    from urlparse import urlparse\n\ntry:\n    from pathlib import Path\n    PYTORCH_PRETRAINED_BERT_CACHE = Path(\n        os.getenv(\'PYTORCH_TRANSFORMERS_CACHE\', os.getenv(\'PYTORCH_PRETRAINED_BERT_CACHE\', default_cache_path)))\nexcept (AttributeError, ImportError):\n    PYTORCH_PRETRAINED_BERT_CACHE = os.getenv(\'PYTORCH_TRANSFORMERS_CACHE\',\n                                              os.getenv(\'PYTORCH_PRETRAINED_BERT_CACHE\',\n                                                        default_cache_path))\n\nPYTORCH_TRANSFORMERS_CACHE = PYTORCH_PRETRAINED_BERT_CACHE  # Kept for backward compatibility\nTRANSFORMERS_CACHE = PYTORCH_PRETRAINED_BERT_CACHE  # Kept for backward compatibility\n\nWEIGHTS_NAME = ""pytorch_model.bin""\nTF2_WEIGHTS_NAME = \'tf_model.h5\'\nTF_WEIGHTS_NAME = \'model.ckpt\'\nCONFIG_NAME = ""config.json""\n\ndef is_torch_available():\n    return _torch_available\n\ndef is_tf_available():\n    return _tf_available\n\nif not six.PY2:\n    def add_start_docstrings(*docstr):\n        def docstring_decorator(fn):\n            fn.__doc__ = \'\'.join(docstr) + fn.__doc__\n            return fn\n        return docstring_decorator\n\n    def add_end_docstrings(*docstr):\n        def docstring_decorator(fn):\n            fn.__doc__ = fn.__doc__ + \'\'.join(docstr)\n            return fn\n        return docstring_decorator\nelse:\n    # Not possible to update class docstrings on python2\n    def add_start_docstrings(*docstr):\n        def docstring_decorator(fn):\n            return fn\n        return docstring_decorator\n\n    def add_end_docstrings(*docstr):\n        def docstring_decorator(fn):\n            return fn\n        return docstring_decorator\n\ndef url_to_filename(url, etag=None):\n    """"""\n    Convert `url` into a hashed filename in a repeatable way.\n    If `etag` is specified, append its hash to the url\'s, delimited\n    by a period.\n    If the url ends with .h5 (Keras HDF5 weights) ands \'.h5\' to the name\n    so that TF 2.0 can identify it as a HDF5 file\n    (see https://github.com/tensorflow/tensorflow/blob/00fad90125b18b80fe054de1055770cfb8fe4ba3/tensorflow/python/keras/engine/network.py#L1380)\n    """"""\n    url_bytes = url.encode(\'utf-8\')\n    url_hash = sha256(url_bytes)\n    filename = url_hash.hexdigest()\n\n    if etag:\n        etag_bytes = etag.encode(\'utf-8\')\n        etag_hash = sha256(etag_bytes)\n        filename += \'.\' + etag_hash.hexdigest()\n\n    if url.endswith(\'.h5\'):\n        filename += \'.h5\'\n\n    return filename\n\n\ndef filename_to_url(filename, cache_dir=None):\n    """"""\n    Return the url and etag (which may be ``None``) stored for `filename`.\n    Raise ``EnvironmentError`` if `filename` or its stored metadata do not exist.\n    """"""\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    cache_path = os.path.join(cache_dir, filename)\n    if not os.path.exists(cache_path):\n        raise EnvironmentError(""file {} not found"".format(cache_path))\n\n    meta_path = cache_path + \'.json\'\n    if not os.path.exists(meta_path):\n        raise EnvironmentError(""file {} not found"".format(meta_path))\n\n    with open(meta_path, encoding=""utf-8"") as meta_file:\n        metadata = json.load(meta_file)\n    url = metadata[\'url\']\n    etag = metadata[\'etag\']\n\n    return url, etag\n\n\ndef cached_path(url_or_filename, cache_dir=None, force_download=False, proxies=None):\n    """"""\n    Given something that might be a URL (or might be a local path),\n    determine which. If it\'s a URL, download the file and cache it, and\n    return the path to the cached file. If it\'s already a local path,\n    make sure the file exists and then return the path.\n    Args:\n        cache_dir: specify a cache directory to save the file to (overwrite the default cache dir).\n        force_download: if True, re-dowload the file even if it\'s already cached in the cache dir.\n    """"""\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(url_or_filename, Path):\n        url_or_filename = str(url_or_filename)\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    parsed = urlparse(url_or_filename)\n\n    if parsed.scheme in (\'http\', \'https\', \'s3\'):\n        # URL, so get it from the cache (downloading if necessary)\n        return get_from_cache(url_or_filename, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n    elif os.path.exists(url_or_filename):\n        # File, and it exists.\n        return url_or_filename\n    elif parsed.scheme == \'\':\n        # File, but it doesn\'t exist.\n        raise EnvironmentError(""file {} not found"".format(url_or_filename))\n    else:\n        # Something unknown\n        raise ValueError(""unable to parse {} as a URL or as a local path"".format(url_or_filename))\n\n\ndef split_s3_path(url):\n    """"""Split a full s3 path into the bucket name and path.""""""\n    parsed = urlparse(url)\n    if not parsed.netloc or not parsed.path:\n        raise ValueError(""bad s3 path {}"".format(url))\n    bucket_name = parsed.netloc\n    s3_path = parsed.path\n    # Remove \'/\' at beginning of path.\n    if s3_path.startswith(""/""):\n        s3_path = s3_path[1:]\n    return bucket_name, s3_path\n\n\ndef s3_request(func):\n    """"""\n    Wrapper function for s3 requests in order to create more helpful error\n    messages.\n    """"""\n\n    @wraps(func)\n    def wrapper(url, *args, **kwargs):\n        try:\n            return func(url, *args, **kwargs)\n        except ClientError as exc:\n            if int(exc.response[""Error""][""Code""]) == 404:\n                raise EnvironmentError(""file {} not found"".format(url))\n            else:\n                raise\n\n    return wrapper\n\n\n@s3_request\ndef s3_etag(url, proxies=None):\n    """"""Check ETag on S3 object.""""""\n    s3_resource = boto3.resource(""s3"", config=Config(proxies=proxies))\n    bucket_name, s3_path = split_s3_path(url)\n    s3_object = s3_resource.Object(bucket_name, s3_path)\n    return s3_object.e_tag\n\n\n@s3_request\ndef s3_get(url, temp_file, proxies=None):\n    """"""Pull a file directly from S3.""""""\n    s3_resource = boto3.resource(""s3"", config=Config(proxies=proxies))\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)\n\n\ndef http_get(url, temp_file, proxies=None):\n    req = requests.get(url, stream=True, proxies=proxies)\n    content_length = req.headers.get(\'Content-Length\')\n    total = int(content_length) if content_length is not None else None\n    progress = tqdm(unit=""B"", total=total)\n    for chunk in req.iter_content(chunk_size=1024):\n        if chunk: # filter out keep-alive new chunks\n            progress.update(len(chunk))\n            temp_file.write(chunk)\n    progress.close()\n\n\ndef get_from_cache(url, cache_dir=None, force_download=False, proxies=None):\n    """"""\n    Given a URL, look for the corresponding dataset in the local cache.\n    If it\'s not there, download it. Then return the path to the cached file.\n    """"""\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n    if sys.version_info[0] == 2 and not isinstance(cache_dir, str):\n        cache_dir = str(cache_dir)\n\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    # Get eTag to add to filename, if it exists.\n    if url.startswith(""s3://""):\n        etag = s3_etag(url, proxies=proxies)\n    else:\n        try:\n            response = requests.head(url, allow_redirects=True, proxies=proxies)\n            if response.status_code != 200:\n                etag = None\n            else:\n                etag = response.headers.get(""ETag"")\n        except EnvironmentError:\n            etag = None\n\n    if sys.version_info[0] == 2 and etag is not None:\n        etag = etag.decode(\'utf-8\')\n    filename = url_to_filename(url, etag)\n\n    # get cache path to put the file\n    cache_path = os.path.join(cache_dir, filename)\n\n    # If we don\'t have a connection (etag is None) and can\'t identify the file\n    # try to get the last downloaded one\n    if not os.path.exists(cache_path) and etag is None:\n        matching_files = fnmatch.filter(os.listdir(cache_dir), filename + \'.*\')\n        matching_files = list(filter(lambda s: not s.endswith(\'.json\'), matching_files))\n        if matching_files:\n            cache_path = os.path.join(cache_dir, matching_files[-1])\n\n    if not os.path.exists(cache_path) or force_download:\n        # Download to temporary file, then copy to cache dir once finished.\n        # Otherwise you get corrupt cache entries if the download gets interrupted.\n        with tempfile.NamedTemporaryFile() as temp_file:\n            logger.info(""%s not found in cache or force_download set to True, downloading to %s"", url, temp_file.name)\n\n            # GET file object\n            if url.startswith(""s3://""):\n                s3_get(url, temp_file, proxies=proxies)\n            else:\n                http_get(url, temp_file, proxies=proxies)\n\n            # we are copying the file before closing it, so flush to avoid truncation\n            temp_file.flush()\n            # shutil.copyfileobj() starts at the current position, so go to the start\n            temp_file.seek(0)\n\n            logger.info(""copying %s to cache at %s"", temp_file.name, cache_path)\n            with open(cache_path, \'wb\') as cache_file:\n                shutil.copyfileobj(temp_file, cache_file)\n\n            logger.info(""creating metadata file for %s"", cache_path)\n            meta = {\'url\': url, \'etag\': etag}\n            meta_path = cache_path + \'.json\'\n            with open(meta_path, \'w\') as meta_file:\n                output_string = json.dumps(meta)\n                if sys.version_info[0] == 2 and isinstance(output_string, str):\n                    output_string = unicode(output_string, \'utf-8\')  # The beauty of python 2\n                meta_file.write(output_string)\n\n            logger.info(""removing temp file %s"", temp_file.name)\n\n    return cache_path\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_albert.py,2,"b'# coding=utf-8\r\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\r\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n#\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""PyTorch BERT model. """"""\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\nimport json\r\nimport logging\r\nimport math\r\nimport os\r\nimport sys\r\nfrom io import open\r\n\r\nimport torch\r\nfrom torch import nn\r\nfrom torch.nn import CrossEntropyLoss, MSELoss\r\n\r\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer\r\nfrom .configuration_bert import BertConfig\r\nfrom .file_utils import add_start_docstrings\r\nfrom .modeling_bert import (ACT2FN, BertSelfAttention, BertIntermediate,\r\n                            BertPooler,BertPredictionHeadTransform)\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nALBERT_PRETRAINED_MODEL_ARCHIVE_MAP = {\r\n    \'albert-base\': """",\r\n    \'albert-large\': """",\r\n    \'albert-xlarge\': """",\r\n    \'albert-xxlarge\': """",\r\n}\r\n\r\n\r\ndef load_tf_weights_in_albert(model, config, tf_checkpoint_path):\r\n    """""" Load tf checkpoints in a pytorch model.\r\n    """"""\r\n    try:\r\n        import re\r\n        import numpy as np\r\n        import tensorflow as tf\r\n    except ImportError:\r\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\r\n                     ""https://www.tensorflow.org/install/ for installation instructions."")\r\n        raise\r\n    tf_path = os.path.abspath(tf_checkpoint_path)\r\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\r\n    # Load weights from TF model\r\n    init_vars = tf.train.list_variables(tf_path)\r\n    names = []\r\n    arrays = []\r\n    for name, shape in init_vars:\r\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\r\n        array = tf.train.load_variable(tf_path, name)\r\n        names.append(name)\r\n        arrays.append(array)\r\n\r\n    for name, array in zip(names, arrays):\r\n        name = name.split(\'/\')\r\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\r\n        # which are not required for using pretrained model\r\n        if any(n in [""adam_v"", ""adam_m"", ""global_step""] for n in name):\r\n            logger.info(""Skipping {}"".format(""/"".join(name)))\r\n            continue\r\n        pointer = model\r\n        for m_name in name:\r\n            if re.fullmatch(r\'[A-Za-z]+_\\d+\', m_name):\r\n                l = re.split(r\'_(\\d+)\', m_name)\r\n            else:\r\n                l = [m_name]\r\n            if l[0] == \'kernel\' or l[0] == \'gamma\':\r\n                pointer = getattr(pointer, \'weight\')\r\n            elif l[0] == \'output_bias\' or l[0] == \'beta\':\r\n                pointer = getattr(pointer, \'bias\')\r\n            elif l[0] == \'output_weights\':\r\n                pointer = getattr(pointer, \'weight\')\r\n            elif l[0] == \'squad\':\r\n                pointer = getattr(pointer, \'classifier\')\r\n            else:\r\n                try:\r\n                    pointer = getattr(pointer, l[0])\r\n                except AttributeError:\r\n                    logger.info(""Skipping {}"".format(""/"".join(name)))\r\n                    continue\r\n            if len(l) >= 2:\r\n                num = int(l[1])\r\n                pointer = pointer[num]\r\n        if m_name[-11:] == \'_embeddings\':\r\n            pointer = getattr(pointer, \'weight\')\r\n        elif m_name[-13:] == \'_embeddings_2\':\r\n            pointer = getattr(pointer, \'weight\')\r\n            array = np.transpose(array)\r\n        elif m_name == \'kernel\':\r\n            array = np.transpose(array)\r\n        try:\r\n            assert pointer.shape == array.shape\r\n        except AssertionError as e:\r\n            e.args += (pointer.shape, array.shape)\r\n            raise\r\n        logger.info(""Initialize PyTorch weight {}"".format(name))\r\n        pointer.data = torch.from_numpy(array)\r\n    return model\r\n\r\n\r\nBertLayerNorm = torch.nn.LayerNorm\r\n\r\n\r\nclass AlbertEmbeddings(nn.Module):\r\n    """"""Construct the embeddings from word, position and token_type embeddings.\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertEmbeddings, self).__init__()\r\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.embedding_size, padding_idx=0)\r\n        # project layer\r\n        self.word_embeddings_2 = nn.Linear(config.embedding_size, config.hidden_size, bias=False)\r\n\r\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)\r\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)\r\n\r\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\r\n        # any TensorFlow checkpoint file\r\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n\r\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\r\n        seq_length = input_ids.size(1)\r\n        if position_ids is None:\r\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\r\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\r\n        if token_type_ids is None:\r\n            token_type_ids = torch.zeros_like(input_ids)\r\n\r\n        words_embeddings = self.word_embeddings(input_ids)\r\n        # project transform\r\n        words_embeddings = self.word_embeddings_2(words_embeddings)\r\n        position_embeddings = self.position_embeddings(position_ids)\r\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\r\n\r\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\r\n        embeddings = self.LayerNorm(embeddings)\r\n        embeddings = self.dropout(embeddings)\r\n        return embeddings\r\n\r\n\r\nclass BertSelfOutput(nn.Module):\r\n    def __init__(self, config):\r\n        super(BertSelfOutput, self).__init__()\r\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\r\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.ln_type = config.ln_type\r\n\r\n    def forward(self, hidden_states, input_tensor):\r\n        hidden_states = self.dense(hidden_states)\r\n        hidden_states = self.dropout(hidden_states)\r\n        if self.ln_type == \'preln\':\r\n            # preln\r\n            hidden_states = hidden_states + input_tensor\r\n        else:\r\n            # postln\r\n            hidden_states = self.LayerNorm(hidden_states + input_tensor)\r\n        return hidden_states\r\n\r\n\r\nclass BertAttention(nn.Module):\r\n    def __init__(self, config):\r\n        super(BertAttention, self).__init__()\r\n        self.self = BertSelfAttention(config)\r\n        self.output = BertSelfOutput(config)\r\n        self.pruned_heads = set()\r\n        self.ln_type = config.ln_type\r\n\r\n    def prune_heads(self, heads):\r\n        if len(heads) == 0:\r\n            return\r\n        mask = torch.ones(self.self.num_attention_heads, self.self.attention_head_size)\r\n        heads = set(heads) - self.pruned_heads  # Convert to set and emove already pruned heads\r\n        for head in heads:\r\n            # Compute how many pruned heads are before the head and move the index accordingly\r\n            head = head - sum(1 if h < head else 0 for h in self.pruned_heads)\r\n            mask[head] = 0\r\n        mask = mask.view(-1).contiguous().eq(1)\r\n        index = torch.arange(len(mask))[mask].long()\r\n\r\n        # Prune linear layers\r\n        self.self.query = prune_linear_layer(self.self.query, index)\r\n        self.self.key = prune_linear_layer(self.self.key, index)\r\n        self.self.value = prune_linear_layer(self.self.value, index)\r\n        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)\r\n\r\n        # Update hyper params and store pruned heads\r\n        self.self.num_attention_heads = self.self.num_attention_heads - len(heads)\r\n        self.self.all_head_size = self.self.attention_head_size * self.self.num_attention_heads\r\n        self.pruned_heads = self.pruned_heads.union(heads)\r\n\r\n    def forward(self, input_tensor, attention_mask=None, head_mask=None):\r\n        if self.ln_type == \'preln\':\r\n            # pre_ln\r\n            hidden_state = self.output.LayerNorm(input_tensor)\r\n            self_outputs = self.self(hidden_state, attention_mask, head_mask)\r\n        else:\r\n            # postln\r\n            self_outputs = self.self(input_tensor, attention_mask, head_mask)\r\n        attention_output = self.output(self_outputs[0], input_tensor)\r\n        outputs = (attention_output,) + self_outputs[1:]  # add attentions if we output them\r\n        return outputs\r\n\r\n\r\nclass BertOutput(nn.Module):\r\n    def __init__(self, config):\r\n        super(BertOutput, self).__init__()\r\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\r\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.ln_type = config.ln_type\r\n\r\n    def forward(self, hidden_states, input_tensor):\r\n        hidden_states = self.dense(hidden_states)\r\n        hidden_states = self.dropout(hidden_states)\r\n        if self.ln_type == \'preln\':\r\n            # preln\r\n            hidden_states = hidden_states + input_tensor\r\n        else:\r\n            # postln\r\n            hidden_states = self.LayerNorm(hidden_states + input_tensor)\r\n        return hidden_states\r\n\r\n\r\nclass BertLayer(nn.Module):\r\n    def __init__(self, config):\r\n        super(BertLayer, self).__init__()\r\n        self.attention = BertAttention(config)\r\n        self.intermediate = BertIntermediate(config)\r\n        self.output = BertOutput(config)\r\n        self.ln_type = config.ln_type\r\n\r\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\r\n        attention_outputs = self.attention(hidden_states, attention_mask, head_mask)\r\n        attention_output = attention_outputs[0]\r\n        if self.ln_type == \'preln\':\r\n            # preln\r\n            attention_output_pre = self.output.LayerNorm(attention_output)\r\n        else:\r\n            # postln\r\n            attention_output_pre = attention_output\r\n        intermediate_output = self.intermediate(attention_output_pre)\r\n        layer_output = self.output(intermediate_output, attention_output)\r\n        outputs = (layer_output,) + attention_outputs[1:]  # add attentions if we output them\r\n        return outputs\r\n\r\n\r\nclass AlbertEncoder(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertEncoder, self).__init__()\r\n        self.output_attentions = config.output_attentions\r\n        self.output_hidden_states = config.output_hidden_states\r\n        self.num_hidden_layers = config.num_hidden_layers\r\n        self.layer_shared = BertLayer(config)\r\n\r\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\r\n        all_hidden_states = ()\r\n        all_attentions = ()\r\n        for i in range(self.num_hidden_layers):\r\n            layer_module = self.layer_shared\r\n            if self.output_hidden_states:\r\n                all_hidden_states = all_hidden_states + (hidden_states,)\r\n\r\n            layer_outputs = layer_module(hidden_states, attention_mask, head_mask[i])\r\n            hidden_states = layer_outputs[0]\r\n\r\n            if self.output_attentions:\r\n                all_attentions = all_attentions + (layer_outputs[1],)\r\n\r\n        # Add last layer\r\n        if self.output_hidden_states:\r\n            all_hidden_states = all_hidden_states + (hidden_states,)\r\n\r\n        outputs = (hidden_states,)\r\n        if self.output_hidden_states:\r\n            outputs = outputs + (all_hidden_states,)\r\n        if self.output_attentions:\r\n            outputs = outputs + (all_attentions,)\r\n        return outputs  # last-layer hidden state, (all hidden states), (all attentions)\r\n\r\nclass AlbertLMPredictionHead(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertLMPredictionHead, self).__init__()\r\n        self.transform = BertPredictionHeadTransform(config)\r\n\r\n        # The output weights are the same as the input embeddings, but there is\r\n        # an output-only bias for each token.\r\n        self.project_layer = nn.Linear(config.hidden_size, config.embedding_size, bias=False)\r\n        self.decoder = nn.Linear(config.embedding_size,\r\n                                 config.vocab_size,\r\n                                 bias=False)\r\n\r\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\r\n\r\n    def forward(self, hidden_states):\r\n        hidden_states = self.transform(hidden_states)\r\n        hidden_states = self.project_layer(hidden_states)\r\n        hidden_states = self.decoder(hidden_states) + self.bias\r\n        return hidden_states\r\n\r\n\r\nclass AlbertOnlyMLMHead(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertOnlyMLMHead, self).__init__()\r\n        self.predictions = AlbertLMPredictionHead(config)\r\n\r\n    def forward(self, sequence_output):\r\n        prediction_scores = self.predictions(sequence_output)\r\n        return prediction_scores\r\n\r\n\r\nclass AlbertOnlyNSPHead(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertOnlyNSPHead, self).__init__()\r\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\r\n\r\n    def forward(self, pooled_output):\r\n        seq_relationship_score = self.seq_relationship(pooled_output)\r\n        return seq_relationship_score\r\n\r\n\r\nclass AlbertPreTrainingHeads(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertPreTrainingHeads, self).__init__()\r\n        self.predictions = AlbertLMPredictionHead(config)\r\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\r\n\r\n    def forward(self, sequence_output, pooled_output):\r\n        prediction_scores = self.predictions(sequence_output)\r\n        seq_relationship_score = self.seq_relationship(pooled_output)\r\n        return prediction_scores, seq_relationship_score\r\n\r\n\r\nclass AlbertPreTrainedModel(PreTrainedModel):\r\n    """""" An abstract class to handle weights initialization and\r\n        a simple interface for dowloading and loading pretrained models.\r\n    """"""\r\n    config_class = BertConfig\r\n    pretrained_model_archive_map = ALBERT_PRETRAINED_MODEL_ARCHIVE_MAP\r\n    load_tf_weights = load_tf_weights_in_albert\r\n    base_model_prefix = ""bert""\r\n\r\n    def _init_weights(self, module):\r\n        """""" Initialize the weights """"""\r\n        if isinstance(module, (nn.Linear, nn.Embedding)):\r\n            # Slightly different from the TF version which uses truncated_normal for initialization\r\n            # cf https://github.com/pytorch/pytorch/pull/5617\r\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\r\n        elif isinstance(module, BertLayerNorm):\r\n            module.bias.data.zero_()\r\n            module.weight.data.fill_(1.0)\r\n        if isinstance(module, nn.Linear) and module.bias is not None:\r\n            module.bias.data.zero_()\r\n\r\n\r\nBERT_START_DOCSTRING = r""""""    The BERT model was proposed in\r\n    `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_\r\n    by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova. It\'s a bidirectional transformer\r\n    pre-trained using a combination of masked language modeling objective and next sentence prediction\r\n    on a large corpus comprising the Toronto Book Corpus and Wikipedia.\r\n\r\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\r\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\r\n\r\n    .. _`BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`:\r\n        https://arxiv.org/abs/1810.04805\r\n\r\n    .. _`torch.nn.Module`:\r\n        https://pytorch.org/docs/stable/nn.html#module\r\n\r\n    Parameters:\r\n        config (:class:`~transformers.BertConfig`): Model configuration class with all the parameters of the model. \r\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\r\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\r\n""""""\r\n\r\nBERT_INPUTS_DOCSTRING = r""""""\r\n    Inputs:\r\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Indices of input sequence tokens in the vocabulary.\r\n            To match pre-training, BERT input sequence should be formatted with [CLS] and [SEP] tokens as follows:\r\n\r\n            (a) For sequence pairs:\r\n\r\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]``\r\n\r\n                ``token_type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1``\r\n\r\n            (b) For single sequences:\r\n\r\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\r\n\r\n                ``token_type_ids:   0   0   0   0  0     0   0``\r\n\r\n            Bert is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\r\n            the right rather than the left.\r\n\r\n            Indices can be obtained using :class:`transformers.BertTokenizer`.\r\n            See :func:`transformers.PreTrainedTokenizer.encode` and\r\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\r\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Mask to avoid performing attention on padding token indices.\r\n            Mask values selected in ``[0, 1]``:\r\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\r\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Segment token indices to indicate first and second portions of the inputs.\r\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\r\n            corresponds to a `sentence B` token\r\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\r\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Indices of positions of each input sequence tokens in the position embeddings.\r\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\r\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\r\n            Mask to nullify selected heads of the self-attention modules.\r\n            Mask values selected in ``[0, 1]``:\r\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\r\n""""""\r\n\r\n\r\n@add_start_docstrings(""The bare Bert Model transformer outputting raw hidden-states without any specific head on top."",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertModel(AlbertPreTrainedModel):\r\n    r""""""\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\r\n            Sequence of hidden-states at the output of the last layer of the model.\r\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\r\n            Last layer hidden-state of the first token of the sequence (classification token)\r\n            further processed by a Linear layer and a Tanh activation function. The Linear\r\n            layer weights are trained from the next sentence prediction (classification)\r\n            objective during Bert pretraining. This output is usually *not* a good summary\r\n            of the semantic content of the input, you\'re often better with averaging or pooling\r\n            the sequence of hidden-states for the whole input sequence.\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertModel.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids)\r\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertModel, self).__init__(config)\r\n\r\n        self.embeddings = AlbertEmbeddings(config)\r\n        self.encoder = AlbertEncoder(config)\r\n        self.pooler = BertPooler(config)\r\n\r\n        self.init_weights()\r\n\r\n    def _resize_token_embeddings(self, new_num_tokens):\r\n        old_embeddings = self.embeddings.word_embeddings\r\n        new_embeddings = self._get_resized_embeddings(old_embeddings, new_num_tokens)\r\n        self.embeddings.word_embeddings = new_embeddings\r\n        return self.embeddings.word_embeddings\r\n\r\n    def _prune_heads(self, heads_to_prune):\r\n        """""" Prunes heads of the model.\r\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\r\n            See base class PreTrainedModel\r\n        """"""\r\n        for layer, heads in heads_to_prune.items():\r\n            self.encoder.layer[layer].attention.prune_heads(heads)\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\r\n        if attention_mask is None:\r\n            attention_mask = torch.ones_like(input_ids)\r\n        if token_type_ids is None:\r\n            token_type_ids = torch.zeros_like(input_ids)\r\n\r\n        # We create a 3D attention mask from a 2D tensor mask.\r\n        # Sizes are [batch_size, 1, 1, to_seq_length]\r\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\r\n        # this attention mask is more simple than the triangular masking of causal attention\r\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\r\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\r\n\r\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\r\n        # masked positions, this operation will create a tensor which is 0.0 for\r\n        # positions we want to attend and -10000.0 for masked positions.\r\n        # Since we are adding it to the raw scores before the softmax, this is\r\n        # effectively the same as removing these entirely.\r\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype)  # fp16 compatibility\r\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\r\n\r\n        # Prepare head mask if needed\r\n        # 1.0 in head_mask indicate we keep the head\r\n        # attention_probs has shape bsz x n_heads x N x N\r\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\r\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\r\n        if head_mask is not None:\r\n            if head_mask.dim() == 1:\r\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\r\n                head_mask = head_mask.expand(self.config.num_hidden_layers, -1, -1, -1, -1)\r\n            elif head_mask.dim() == 2:\r\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(\r\n                    -1)  # We can specify head_mask for each layer\r\n            head_mask = head_mask.to(\r\n                dtype=next(self.parameters()).dtype)  # switch to fload if need + fp16 compatibility\r\n        else:\r\n            head_mask = [None] * self.config.num_hidden_layers\r\n\r\n        embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids)\r\n        encoder_outputs = self.encoder(embedding_output,\r\n                                       extended_attention_mask,\r\n                                       head_mask=head_mask)\r\n        sequence_output = encoder_outputs[0]\r\n        pooled_output = self.pooler(sequence_output)\r\n\r\n        outputs = (sequence_output, pooled_output,) + encoder_outputs[\r\n                                                      1:]  # add hidden_states and attentions if they are here\r\n        return outputs  # sequence_output, pooled_output, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with two heads on top as done during the pre-training:\r\n    a `masked language modeling` head and a `next sentence prediction (classification)` head. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForPreTraining(AlbertPreTrainedModel):\r\n    r""""""\r\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Labels for computing the masked language modeling loss.\r\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\r\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\r\n            in ``[0, ..., config.vocab_size]``\r\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\r\n            Indices should be in ``[0, 1]``.\r\n            ``0`` indicates sequence B is a continuation of sequence A,\r\n            ``1`` indicates sequence B is a random sequence.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when both ``masked_lm_labels`` and ``next_sentence_label`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Total loss as the sum of the masked language modeling loss and the next sequence prediction (classification) loss.\r\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\r\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\r\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\r\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForPreTraining.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids)\r\n        prediction_scores, seq_relationship_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForPreTraining, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.cls = AlbertPreTrainingHeads(config)\r\n\r\n        self.init_weights()\r\n        self.tie_weights()\r\n\r\n    def tie_weights(self):\r\n        """""" Make sure we are sharing the input and output embeddings.\r\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\r\n        """"""\r\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\r\n                                   self.bert.embeddings.word_embeddings)\r\n        self._tie_or_clone_data(self.cls.predictions.project_layer,\r\n                                self.bert.embeddings.word_embeddings_2)\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                masked_lm_labels=None, next_sentence_label=None):\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output, pooled_output = outputs[:2]\r\n        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\r\n\r\n        outputs = (prediction_scores, seq_relationship_score,) + outputs[\r\n                                                                 2:]  # add hidden states and attention if they are here\r\n\r\n        if masked_lm_labels is not None and next_sentence_label is not None:\r\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\r\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\r\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\r\n            total_loss = masked_lm_loss + next_sentence_loss\r\n            outputs = (total_loss,) + outputs\r\n\r\n        return outputs  # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a `language modeling` head on top. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForMaskedLM(AlbertPreTrainedModel):\r\n    r""""""\r\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Labels for computing the masked language modeling loss.\r\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\r\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\r\n            in ``[0, ..., config.vocab_size]``\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Masked language modeling loss.\r\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\r\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForMaskedLM.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, masked_lm_labels=input_ids)\r\n        loss, prediction_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForMaskedLM, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.cls = AlbertOnlyMLMHead(config)\r\n\r\n        self.init_weights()\r\n        self.tie_weights()\r\n\r\n    def tie_weights(self):\r\n        """""" Make sure we are sharing the input and output embeddings.\r\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\r\n        """"""\r\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\r\n                                   self.bert.embeddings.word_embeddings)\r\n        self._tie_or_clone_data(self.cls.predictions.project_layer,\r\n                                self.bert.embeddings.word_embeddings_2)\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                masked_lm_labels=None):\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output = outputs[0]\r\n        prediction_scores = self.cls(sequence_output)\r\n\r\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\r\n        if masked_lm_labels is not None:\r\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\r\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\r\n            outputs = (masked_lm_loss,) + outputs\r\n\r\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a `next sentence prediction (classification)` head on top. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForNextSentencePrediction(AlbertPreTrainedModel):\r\n    r""""""\r\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\r\n            Indices should be in ``[0, 1]``.\r\n            ``0`` indicates sequence B is a continuation of sequence A,\r\n            ``1`` indicates sequence B is a random sequence.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``next_sentence_label`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Next sequence prediction (classification) loss.\r\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\r\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForNextSentencePrediction.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids)\r\n        seq_relationship_scores = outputs[0]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForNextSentencePrediction, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.cls = AlbertOnlyNSPHead(config)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                next_sentence_label=None):\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        pooled_output = outputs[1]\r\n\r\n        seq_relationship_score = self.cls(pooled_output)\r\n\r\n        outputs = (seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\r\n        if next_sentence_label is not None:\r\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\r\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\r\n            outputs = (next_sentence_loss,) + outputs\r\n\r\n        return outputs  # (next_sentence_loss), seq_relationship_score, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model transformer with a sequence classification/regression head on top (a linear layer on top of\r\n    the pooled output) e.g. for GLUE tasks. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForSequenceClassification(AlbertPreTrainedModel):\r\n    r""""""\r\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the sequence classification/regression loss.\r\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\r\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\r\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Classification (or regression if config.num_labels==1) loss.\r\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\r\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForSequenceClassification.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, labels=labels)\r\n        loss, logits = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForSequenceClassification, self).__init__(config)\r\n        self.num_labels = config.num_labels\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.classifier = nn.Linear(config.hidden_size, self.config.num_labels)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\r\n                position_ids=None, head_mask=None, labels=None):\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        pooled_output = outputs[1]\r\n\r\n        pooled_output = self.dropout(pooled_output)\r\n        logits = self.classifier(pooled_output)\r\n\r\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\r\n\r\n        if labels is not None:\r\n            if self.num_labels == 1:\r\n                #  We are doing regression\r\n                loss_fct = MSELoss()\r\n                loss = loss_fct(logits.view(-1), labels.view(-1))\r\n            else:\r\n                loss_fct = CrossEntropyLoss()\r\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\r\n            outputs = (loss,) + outputs\r\n\r\n        return outputs  # (loss), logits, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a multiple choice classification head on top (a linear layer on top of\r\n    the pooled output and a softmax) e.g. for RocStories/SWAG tasks. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForMultipleChoice(AlbertPreTrainedModel):\r\n    r""""""\r\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the multiple choice classification loss.\r\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\r\n            of the input tensors. (see `input_ids` above)\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Classification loss.\r\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\r\n            of the input tensors. (see `input_ids` above).\r\n            Classification scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForMultipleChoice.from_pretrained(\'bert-base-uncased\')\r\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\r\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\r\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, labels=labels)\r\n        loss, classification_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForMultipleChoice, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.classifier = nn.Linear(config.hidden_size, 1)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\r\n                position_ids=None, head_mask=None, labels=None):\r\n        num_choices = input_ids.shape[1]\r\n\r\n        input_ids = input_ids.view(-1, input_ids.size(-1))\r\n        attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\r\n        token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\r\n        position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        pooled_output = outputs[1]\r\n\r\n        pooled_output = self.dropout(pooled_output)\r\n        logits = self.classifier(pooled_output)\r\n        reshaped_logits = logits.view(-1, num_choices)\r\n\r\n        outputs = (reshaped_logits,) + outputs[2:]  # add hidden states and attention if they are here\r\n\r\n        if labels is not None:\r\n            loss_fct = CrossEntropyLoss()\r\n            loss = loss_fct(reshaped_logits, labels)\r\n            outputs = (loss,) + outputs\r\n\r\n        return outputs  # (loss), reshaped_logits, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a token classification head on top (a linear layer on top of\r\n    the hidden-states output) e.g. for Named-Entity-Recognition (NER) tasks. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForTokenClassification(AlbertPreTrainedModel):\r\n    r""""""\r\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Labels for computing the token classification loss.\r\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Classification loss.\r\n        **scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.num_labels)``\r\n            Classification scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForTokenClassification.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        labels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, labels=labels)\r\n        loss, scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForTokenClassification, self).__init__(config)\r\n        self.num_labels = config.num_labels\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\r\n                position_ids=None, head_mask=None, labels=None):\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output = outputs[0]\r\n\r\n        sequence_output = self.dropout(sequence_output)\r\n        logits = self.classifier(sequence_output)\r\n\r\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\r\n        if labels is not None:\r\n            loss_fct = CrossEntropyLoss()\r\n            # Only keep active parts of the loss\r\n            if attention_mask is not None:\r\n                active_loss = attention_mask.view(-1) == 1\r\n                active_logits = logits.view(-1, self.num_labels)[active_loss]\r\n                active_labels = labels.view(-1)[active_loss]\r\n                loss = loss_fct(active_logits, active_labels)\r\n            else:\r\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\r\n            outputs = (loss,) + outputs\r\n\r\n        return outputs  # (loss), scores, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\r\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForQuestionAnswering(AlbertPreTrainedModel):\r\n    r""""""\r\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\r\n            Positions are clamped to the length of the sequence (`sequence_length`).\r\n            Position outside of the sequence are not taken into account for computing the loss.\r\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\r\n            Positions are clamped to the length of the sequence (`sequence_length`).\r\n            Position outside of the sequence are not taken into account for computing the loss.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\r\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\r\n            Span-start scores (before SoftMax).\r\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\r\n            Span-end scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForQuestionAnswering.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        start_positions = torch.tensor([1])\r\n        end_positions = torch.tensor([3])\r\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\r\n        loss, start_scores, end_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForQuestionAnswering, self).__init__(config)\r\n        self.num_labels = config.num_labels\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                start_positions=None, end_positions=None):\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output = outputs[0]\r\n\r\n        logits = self.qa_outputs(sequence_output)\r\n        start_logits, end_logits = logits.split(1, dim=-1)\r\n        start_logits = start_logits.squeeze(-1)\r\n        end_logits = end_logits.squeeze(-1)\r\n\r\n        outputs = (start_logits, end_logits,) + outputs[2:]\r\n        if start_positions is not None and end_positions is not None:\r\n            # If we are on multi-GPU, split add a dimension\r\n            if len(start_positions.size()) > 1:\r\n                start_positions = start_positions.squeeze(-1)\r\n            if len(end_positions.size()) > 1:\r\n                end_positions = end_positions.squeeze(-1)\r\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\r\n            ignored_index = start_logits.size(1)\r\n            start_positions.clamp_(0, ignored_index)\r\n            end_positions.clamp_(0, ignored_index)\r\n\r\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\r\n            start_loss = loss_fct(start_logits, start_positions)\r\n            end_loss = loss_fct(end_logits, end_positions)\r\n            total_loss = (start_loss + end_loss) / 2\r\n            outputs = (total_loss,) + outputs\r\n\r\n        return outputs  # (loss), start_logits, end_logits, (hidden_states), (attentions)\r\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_auto.py,0,"b'# coding=utf-8\n# Copyright 2018 The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Auto Model class. """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport logging\n\nfrom .modeling_bert import BertModel, BertForMaskedLM, BertForSequenceClassification, BertForQuestionAnswering\nfrom .modeling_openai import OpenAIGPTModel, OpenAIGPTLMHeadModel\nfrom .modeling_gpt2 import GPT2Model, GPT2LMHeadModel\nfrom .modeling_ctrl import CTRLModel, CTRLLMHeadModel\nfrom .modeling_transfo_xl import TransfoXLModel, TransfoXLLMHeadModel\nfrom .modeling_xlnet import XLNetModel, XLNetLMHeadModel, XLNetForSequenceClassification, XLNetForQuestionAnswering\nfrom .modeling_xlm import XLMModel, XLMWithLMHeadModel, XLMForSequenceClassification, XLMForQuestionAnswering\nfrom .modeling_roberta import RobertaModel, RobertaForMaskedLM, RobertaForSequenceClassification\nfrom .modeling_distilbert import DistilBertModel, DistilBertForQuestionAnswering, DistilBertForMaskedLM, DistilBertForSequenceClassification\n\nfrom .modeling_utils import PreTrainedModel, SequenceSummary\n\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\n\nclass AutoModel(object):\n    r""""""\n        :class:`~transformers.AutoModel` is a generic model class\n        that will be instantiated as one of the base model classes of the library\n        when created with the `AutoModel.from_pretrained(pretrained_model_name_or_path)`\n        class method.\n\n        The `from_pretrained()` method takes care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The base model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertModel (DistilBERT model)\n            - contains `roberta`: RobertaModel (RoBERTa model)\n            - contains `bert`: BertModel (Bert model)\n            - contains `openai-gpt`: OpenAIGPTModel (OpenAI GPT model)\n            - contains `gpt2`: GPT2Model (OpenAI GPT-2 model)\n            - contains `ctrl`: CTRLModel (Salesforce CTRL  model)\n            - contains `transfo-xl`: TransfoXLModel (Transformer-XL model)\n            - contains `xlnet`: XLNetModel (XLNet model)\n            - contains `xlm`: XLMModel (XLM model)\n\n        This class cannot be instantiated using `__init__()` (throws an error).\n    """"""\n    def __init__(self):\n        raise EnvironmentError(""AutoModel is designed to be instantiated ""\n            ""using the `AutoModel.from_pretrained(pretrained_model_name_or_path)` method."")\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n        r"""""" Instantiates one of the base model classes of the library\n        from a pre-trained model configuration.\n\n        The model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertModel (DistilBERT model)\n            - contains `roberta`: RobertaModel (RoBERTa model)\n            - contains `bert`: BertModel (Bert model)\n            - contains `openai-gpt`: OpenAIGPTModel (OpenAI GPT model)\n            - contains `gpt2`: GPT2Model (OpenAI GPT-2 model)\n            - contains `ctrl`: CTRLModel (Salesforce CTRL  model)\n            - contains `transfo-xl`: TransfoXLModel (Transformer-XL model)\n            - contains `xlnet`: XLNetModel (XLNet model)\n            - contains `xlm`: XLMModel (XLM model)\n\n            The model is set in evaluation mode by default using `model.eval()` (Dropout modules are deactivated)\n            To train the model, you should first set it back in training mode with `model.train()`\n\n        Params:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing model weights saved using :func:`~transformers.PreTrainedModel.save_pretrained`, e.g.: ``./my_model_directory/``.\n                - a path or url to a `tensorflow index checkpoint file` (e.g. `./tf_model/model.ckpt.index`). In this case, ``from_tf`` should be set to True and a configuration object should be provided as ``config`` argument. This loading path is slower than converting the TensorFlow checkpoint in a PyTorch model using the provided conversion scripts and loading the PyTorch model afterwards.\n\n            model_args: (`optional`) Sequence of positional arguments:\n                All remaning positional arguments will be passed to the underlying model\'s ``__init__`` method\n\n            config: (`optional`) instance of a class derived from :class:`~transformers.PretrainedConfig`:\n                Configuration for the model to use instead of an automatically loaded configuation. Configuration can be automatically loaded when:\n\n                - the model is a model provided by the library (loaded with the ``shortcut-name`` string of a pretrained model), or\n                - the model was saved using :func:`~transformers.PreTrainedModel.save_pretrained` and is reloaded by suppling the save directory.\n                - the model is loaded by suppling a local directory as ``pretrained_model_name_or_path`` and a configuration JSON file named `config.json` is found in the directory.\n\n            state_dict: (`optional`) dict:\n                an optional state dictionnary for the model to use instead of a state dictionary loaded from saved weights file.\n                This option can be used if you want to create a model from a pretrained configuration but load your own weights.\n                In this case though, you should check if using :func:`~transformers.PreTrainedModel.save_pretrained` and :func:`~transformers.PreTrainedModel.from_pretrained` is not a simpler option.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            output_loading_info: (`optional`) boolean:\n                Set to ``True`` to also return a dictionnary containing missing keys, unexpected keys and error messages.\n\n            kwargs: (`optional`) Remaining dictionary of keyword arguments:\n                Can be used to update the configuration object (after it being loaded) and initiate the model. (e.g. ``output_attention=True``). Behave differently depending on whether a `config` is provided or automatically loaded:\n\n                - If a configuration is provided with ``config``, ``**kwargs`` will be directly passed to the underlying model\'s ``__init__`` method (we assume all relevant updates to the configuration have already been done)\n                - If a configuration is not provided, ``kwargs`` will be first passed to the configuration class initialization function (:func:`~transformers.PretrainedConfig.from_pretrained`). Each key of ``kwargs`` that corresponds to a configuration attribute will be used to override said attribute with the supplied ``kwargs`` value. Remaining keys that do not correspond to any configuration attribute will be passed to the underlying model\'s ``__init__`` function.\n\n        Examples::\n\n            model = AutoModel.from_pretrained(\'bert-base-uncased\')    # Download model and configuration from S3 and cache.\n            model = AutoModel.from_pretrained(\'./test/bert_model/\')  # E.g. model was saved using `save_pretrained(\'./test/saved_model/\')`\n            model = AutoModel.from_pretrained(\'bert-base-uncased\', output_attention=True)  # Update configuration during loading\n            assert model.config.output_attention == True\n            # Loading from a TF checkpoint file instead of a PyTorch model (slower)\n            config = AutoConfig.from_json_file(\'./tf_model/bert_tf_model_config.json\')\n            model = AutoModel.from_pretrained(\'./tf_model/bert_tf_checkpoint.ckpt.index\', from_tf=True, config=config)\n\n        """"""\n        if \'distilbert\' in pretrained_model_name_or_path:\n            return DistilBertModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'roberta\' in pretrained_model_name_or_path:\n            return RobertaModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'bert\' in pretrained_model_name_or_path:\n            return BertModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'openai-gpt\' in pretrained_model_name_or_path:\n            return OpenAIGPTModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'gpt2\' in pretrained_model_name_or_path:\n            return GPT2Model.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'transfo-xl\' in pretrained_model_name_or_path:\n            return TransfoXLModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlnet\' in pretrained_model_name_or_path:\n            return XLNetModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlm\' in pretrained_model_name_or_path:\n            return XLMModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'ctrl\' in pretrained_model_name_or_path:\n            return CTRLModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        raise ValueError(""Unrecognized model identifier in {}. Should contains one of ""\n                         ""\'bert\', \'openai-gpt\', \'gpt2\', \'transfo-xl\', \'xlnet\', ""\n                         ""\'xlm\', \'roberta, \'ctrl\'"".format(pretrained_model_name_or_path))\n\n\nclass AutoModelWithLMHead(object):\n    r""""""\n        :class:`~transformers.AutoModelWithLMHead` is a generic model class\n        that will be instantiated as one of the language modeling model classes of the library\n        when created with the `AutoModelWithLMHead.from_pretrained(pretrained_model_name_or_path)`\n        class method.\n\n        The `from_pretrained()` method takes care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertForMaskedLM (DistilBERT model)\n            - contains `roberta`: RobertaForMaskedLM (RoBERTa model)\n            - contains `bert`: BertForMaskedLM (Bert model)\n            - contains `openai-gpt`: OpenAIGPTLMHeadModel (OpenAI GPT model)\n            - contains `gpt2`: GPT2LMHeadModel (OpenAI GPT-2 model)\n            - contains `ctrl`: CTRLLMModel (Salesforce CTRL model)\n            - contains `transfo-xl`: TransfoXLLMHeadModel (Transformer-XL model)\n            - contains `xlnet`: XLNetLMHeadModel (XLNet model)\n            - contains `xlm`: XLMWithLMHeadModel (XLM model)\n\n        This class cannot be instantiated using `__init__()` (throws an error).\n    """"""\n    def __init__(self):\n        raise EnvironmentError(""AutoModelWithLMHead is designed to be instantiated ""\n            ""using the `AutoModelWithLMHead.from_pretrained(pretrained_model_name_or_path)` method."")\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n        r"""""" Instantiates one of the language modeling model classes of the library\n        from a pre-trained model configuration.\n\n        The `from_pretrained()` method takes care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertForMaskedLM (DistilBERT model)\n            - contains `roberta`: RobertaForMaskedLM (RoBERTa model)\n            - contains `bert`: BertForMaskedLM (Bert model)\n            - contains `openai-gpt`: OpenAIGPTLMHeadModel (OpenAI GPT model)\n            - contains `gpt2`: GPT2LMHeadModel (OpenAI GPT-2 model)\n            - contains `transfo-xl`: TransfoXLLMHeadModel (Transformer-XL model)\n            - contains `xlnet`: XLNetLMHeadModel (XLNet model)\n            - contains `xlm`: XLMWithLMHeadModel (XLM model)\n\n        The model is set in evaluation mode by default using `model.eval()` (Dropout modules are deactivated)\n        To train the model, you should first set it back in training mode with `model.train()`\n\n        Params:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing model weights saved using :func:`~transformers.PreTrainedModel.save_pretrained`, e.g.: ``./my_model_directory/``.\n                - a path or url to a `tensorflow index checkpoint file` (e.g. `./tf_model/model.ckpt.index`). In this case, ``from_tf`` should be set to True and a configuration object should be provided as ``config`` argument. This loading path is slower than converting the TensorFlow checkpoint in a PyTorch model using the provided conversion scripts and loading the PyTorch model afterwards.\n\n            model_args: (`optional`) Sequence of positional arguments:\n                All remaning positional arguments will be passed to the underlying model\'s ``__init__`` method\n\n            config: (`optional`) instance of a class derived from :class:`~transformers.PretrainedConfig`:\n                Configuration for the model to use instead of an automatically loaded configuation. Configuration can be automatically loaded when:\n\n                - the model is a model provided by the library (loaded with the ``shortcut-name`` string of a pretrained model), or\n                - the model was saved using :func:`~transformers.PreTrainedModel.save_pretrained` and is reloaded by suppling the save directory.\n                - the model is loaded by suppling a local directory as ``pretrained_model_name_or_path`` and a configuration JSON file named `config.json` is found in the directory.\n\n            state_dict: (`optional`) dict:\n                an optional state dictionnary for the model to use instead of a state dictionary loaded from saved weights file.\n                This option can be used if you want to create a model from a pretrained configuration but load your own weights.\n                In this case though, you should check if using :func:`~transformers.PreTrainedModel.save_pretrained` and :func:`~transformers.PreTrainedModel.from_pretrained` is not a simpler option.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            output_loading_info: (`optional`) boolean:\n                Set to ``True`` to also return a dictionnary containing missing keys, unexpected keys and error messages.\n\n            kwargs: (`optional`) Remaining dictionary of keyword arguments:\n                Can be used to update the configuration object (after it being loaded) and initiate the model. (e.g. ``output_attention=True``). Behave differently depending on whether a `config` is provided or automatically loaded:\n\n                - If a configuration is provided with ``config``, ``**kwargs`` will be directly passed to the underlying model\'s ``__init__`` method (we assume all relevant updates to the configuration have already been done)\n                - If a configuration is not provided, ``kwargs`` will be first passed to the configuration class initialization function (:func:`~transformers.PretrainedConfig.from_pretrained`). Each key of ``kwargs`` that corresponds to a configuration attribute will be used to override said attribute with the supplied ``kwargs`` value. Remaining keys that do not correspond to any configuration attribute will be passed to the underlying model\'s ``__init__`` function.\n\n        Examples::\n\n            model = AutoModelWithLMHead.from_pretrained(\'bert-base-uncased\')    # Download model and configuration from S3 and cache.\n            model = AutoModelWithLMHead.from_pretrained(\'./test/bert_model/\')  # E.g. model was saved using `save_pretrained(\'./test/saved_model/\')`\n            model = AutoModelWithLMHead.from_pretrained(\'bert-base-uncased\', output_attention=True)  # Update configuration during loading\n            assert model.config.output_attention == True\n            # Loading from a TF checkpoint file instead of a PyTorch model (slower)\n            config = AutoConfig.from_json_file(\'./tf_model/bert_tf_model_config.json\')\n            model = AutoModelWithLMHead.from_pretrained(\'./tf_model/bert_tf_checkpoint.ckpt.index\', from_tf=True, config=config)\n\n        """"""\n        if \'distilbert\' in pretrained_model_name_or_path:\n            return DistilBertForMaskedLM.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'roberta\' in pretrained_model_name_or_path:\n            return RobertaForMaskedLM.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'bert\' in pretrained_model_name_or_path:\n            return BertForMaskedLM.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'openai-gpt\' in pretrained_model_name_or_path:\n            return OpenAIGPTLMHeadModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'gpt2\' in pretrained_model_name_or_path:\n            return GPT2LMHeadModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'transfo-xl\' in pretrained_model_name_or_path:\n            return TransfoXLLMHeadModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlnet\' in pretrained_model_name_or_path:\n            return XLNetLMHeadModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlm\' in pretrained_model_name_or_path:\n            return XLMWithLMHeadModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'ctrl\' in pretrained_model_name_or_path:\n            return CTRLLMHeadModel.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        raise ValueError(""Unrecognized model identifier in {}. Should contains one of ""\n                         ""\'bert\', \'openai-gpt\', \'gpt2\', \'transfo-xl\', \'xlnet\', ""\n                         ""\'xlm\', \'roberta\',\'ctrl\'"".format(pretrained_model_name_or_path))\n\n\nclass AutoModelForSequenceClassification(object):\n    r""""""\n        :class:`~transformers.AutoModelForSequenceClassification` is a generic model class\n        that will be instantiated as one of the sequence classification model classes of the library\n        when created with the `AutoModelForSequenceClassification.from_pretrained(pretrained_model_name_or_path)`\n        class method.\n\n        The `from_pretrained()` method takes care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertForSequenceClassification (DistilBERT model)\n            - contains `roberta`: RobertaForSequenceClassification (RoBERTa model)\n            - contains `bert`: BertForSequenceClassification (Bert model)\n            - contains `xlnet`: XLNetForSequenceClassification (XLNet model)\n            - contains `xlm`: XLMForSequenceClassification (XLM model)\n\n        This class cannot be instantiated using `__init__()` (throws an error).\n    """"""\n    def __init__(self):\n        raise EnvironmentError(""AutoModelWithLMHead is designed to be instantiated ""\n            ""using the `AutoModelWithLMHead.from_pretrained(pretrained_model_name_or_path)` method."")\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n        r"""""" Instantiates one of the sequence classification model classes of the library\n        from a pre-trained model configuration.\n\n        The `from_pretrained()` method takes care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertForSequenceClassification (DistilBERT model)\n            - contains `roberta`: RobertaForSequenceClassification (RoBERTa model)\n            - contains `bert`: BertForSequenceClassification (Bert model)\n            - contains `xlnet`: XLNetForSequenceClassification (XLNet model)\n            - contains `xlm`: XLMForSequenceClassification (XLM model)\n\n        The model is set in evaluation mode by default using `model.eval()` (Dropout modules are deactivated)\n        To train the model, you should first set it back in training mode with `model.train()`\n\n        Params:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing model weights saved using :func:`~transformers.PreTrainedModel.save_pretrained`, e.g.: ``./my_model_directory/``.\n                - a path or url to a `tensorflow index checkpoint file` (e.g. `./tf_model/model.ckpt.index`). In this case, ``from_tf`` should be set to True and a configuration object should be provided as ``config`` argument. This loading path is slower than converting the TensorFlow checkpoint in a PyTorch model using the provided conversion scripts and loading the PyTorch model afterwards.\n\n            model_args: (`optional`) Sequence of positional arguments:\n                All remaning positional arguments will be passed to the underlying model\'s ``__init__`` method\n\n            config: (`optional`) instance of a class derived from :class:`~transformers.PretrainedConfig`:\n                Configuration for the model to use instead of an automatically loaded configuation. Configuration can be automatically loaded when:\n\n                - the model is a model provided by the library (loaded with the ``shortcut-name`` string of a pretrained model), or\n                - the model was saved using :func:`~transformers.PreTrainedModel.save_pretrained` and is reloaded by suppling the save directory.\n                - the model is loaded by suppling a local directory as ``pretrained_model_name_or_path`` and a configuration JSON file named `config.json` is found in the directory.\n\n            state_dict: (`optional`) dict:\n                an optional state dictionnary for the model to use instead of a state dictionary loaded from saved weights file.\n                This option can be used if you want to create a model from a pretrained configuration but load your own weights.\n                In this case though, you should check if using :func:`~transformers.PreTrainedModel.save_pretrained` and :func:`~transformers.PreTrainedModel.from_pretrained` is not a simpler option.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            output_loading_info: (`optional`) boolean:\n                Set to ``True`` to also return a dictionnary containing missing keys, unexpected keys and error messages.\n\n            kwargs: (`optional`) Remaining dictionary of keyword arguments:\n                Can be used to update the configuration object (after it being loaded) and initiate the model. (e.g. ``output_attention=True``). Behave differently depending on whether a `config` is provided or automatically loaded:\n\n                - If a configuration is provided with ``config``, ``**kwargs`` will be directly passed to the underlying model\'s ``__init__`` method (we assume all relevant updates to the configuration have already been done)\n                - If a configuration is not provided, ``kwargs`` will be first passed to the configuration class initialization function (:func:`~transformers.PretrainedConfig.from_pretrained`). Each key of ``kwargs`` that corresponds to a configuration attribute will be used to override said attribute with the supplied ``kwargs`` value. Remaining keys that do not correspond to any configuration attribute will be passed to the underlying model\'s ``__init__`` function.\n\n        Examples::\n\n            model = AutoModelForSequenceClassification.from_pretrained(\'bert-base-uncased\')    # Download model and configuration from S3 and cache.\n            model = AutoModelForSequenceClassification.from_pretrained(\'./test/bert_model/\')  # E.g. model was saved using `save_pretrained(\'./test/saved_model/\')`\n            model = AutoModelForSequenceClassification.from_pretrained(\'bert-base-uncased\', output_attention=True)  # Update configuration during loading\n            assert model.config.output_attention == True\n            # Loading from a TF checkpoint file instead of a PyTorch model (slower)\n            config = AutoConfig.from_json_file(\'./tf_model/bert_tf_model_config.json\')\n            model = AutoModelForSequenceClassification.from_pretrained(\'./tf_model/bert_tf_checkpoint.ckpt.index\', from_tf=True, config=config)\n\n        """"""\n        if \'distilbert\' in pretrained_model_name_or_path:\n            return DistilBertForSequenceClassification.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'roberta\' in pretrained_model_name_or_path:\n            return RobertaForSequenceClassification.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'bert\' in pretrained_model_name_or_path:\n            return BertForSequenceClassification.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlnet\' in pretrained_model_name_or_path:\n            return XLNetForSequenceClassification.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlm\' in pretrained_model_name_or_path:\n            return XLMForSequenceClassification.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n\n        raise ValueError(""Unrecognized model identifier in {}. Should contains one of ""\n                         ""\'bert\', \'xlnet\', \'xlm\', \'roberta\'"".format(pretrained_model_name_or_path))\n\n\nclass AutoModelForQuestionAnswering(object):\n    r""""""\n        :class:`~transformers.AutoModelForQuestionAnswering` is a generic model class\n        that will be instantiated as one of the question answering model classes of the library\n        when created with the `AutoModelForQuestionAnswering.from_pretrained(pretrained_model_name_or_path)`\n        class method.\n\n        The `from_pretrained()` method takes care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertForQuestionAnswering (DistilBERT model)\n            - contains `bert`: BertForQuestionAnswering (Bert model)\n            - contains `xlnet`: XLNetForQuestionAnswering (XLNet model)\n            - contains `xlm`: XLMForQuestionAnswering (XLM model)\n\n        This class cannot be instantiated using `__init__()` (throws an error).\n    """"""\n    def __init__(self):\n        raise EnvironmentError(""AutoModelWithLMHead is designed to be instantiated ""\n            ""using the `AutoModelWithLMHead.from_pretrained(pretrained_model_name_or_path)` method."")\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n        r"""""" Instantiates one of the question answering model classes of the library\n        from a pre-trained model configuration.\n\n        The `from_pretrained()` method takes care of returning the correct model class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The model class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertForQuestionAnswering (DistilBERT model)\n            - contains `bert`: BertForQuestionAnswering (Bert model)\n            - contains `xlnet`: XLNetForQuestionAnswering (XLNet model)\n            - contains `xlm`: XLMForQuestionAnswering (XLM model)\n\n        The model is set in evaluation mode by default using `model.eval()` (Dropout modules are deactivated)\n        To train the model, you should first set it back in training mode with `model.train()`\n\n        Params:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing model weights saved using :func:`~transformers.PreTrainedModel.save_pretrained`, e.g.: ``./my_model_directory/``.\n                - a path or url to a `tensorflow index checkpoint file` (e.g. `./tf_model/model.ckpt.index`). In this case, ``from_tf`` should be set to True and a configuration object should be provided as ``config`` argument. This loading path is slower than converting the TensorFlow checkpoint in a PyTorch model using the provided conversion scripts and loading the PyTorch model afterwards.\n\n            model_args: (`optional`) Sequence of positional arguments:\n                All remaning positional arguments will be passed to the underlying model\'s ``__init__`` method\n\n            config: (`optional`) instance of a class derived from :class:`~transformers.PretrainedConfig`:\n                Configuration for the model to use instead of an automatically loaded configuation. Configuration can be automatically loaded when:\n\n                - the model is a model provided by the library (loaded with the ``shortcut-name`` string of a pretrained model), or\n                - the model was saved using :func:`~transformers.PreTrainedModel.save_pretrained` and is reloaded by suppling the save directory.\n                - the model is loaded by suppling a local directory as ``pretrained_model_name_or_path`` and a configuration JSON file named `config.json` is found in the directory.\n\n            state_dict: (`optional`) dict:\n                an optional state dictionnary for the model to use instead of a state dictionary loaded from saved weights file.\n                This option can be used if you want to create a model from a pretrained configuration but load your own weights.\n                In this case though, you should check if using :func:`~transformers.PreTrainedModel.save_pretrained` and :func:`~transformers.PreTrainedModel.from_pretrained` is not a simpler option.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            output_loading_info: (`optional`) boolean:\n                Set to ``True`` to also return a dictionnary containing missing keys, unexpected keys and error messages.\n\n            kwargs: (`optional`) Remaining dictionary of keyword arguments:\n                Can be used to update the configuration object (after it being loaded) and initiate the model. (e.g. ``output_attention=True``). Behave differently depending on whether a `config` is provided or automatically loaded:\n\n                - If a configuration is provided with ``config``, ``**kwargs`` will be directly passed to the underlying model\'s ``__init__`` method (we assume all relevant updates to the configuration have already been done)\n                - If a configuration is not provided, ``kwargs`` will be first passed to the configuration class initialization function (:func:`~transformers.PretrainedConfig.from_pretrained`). Each key of ``kwargs`` that corresponds to a configuration attribute will be used to override said attribute with the supplied ``kwargs`` value. Remaining keys that do not correspond to any configuration attribute will be passed to the underlying model\'s ``__init__`` function.\n\n        Examples::\n\n            model = AutoModelForQuestionAnswering.from_pretrained(\'bert-base-uncased\')    # Download model and configuration from S3 and cache.\n            model = AutoModelForQuestionAnswering.from_pretrained(\'./test/bert_model/\')  # E.g. model was saved using `save_pretrained(\'./test/saved_model/\')`\n            model = AutoModelForQuestionAnswering.from_pretrained(\'bert-base-uncased\', output_attention=True)  # Update configuration during loading\n            assert model.config.output_attention == True\n            # Loading from a TF checkpoint file instead of a PyTorch model (slower)\n            config = AutoConfig.from_json_file(\'./tf_model/bert_tf_model_config.json\')\n            model = AutoModelForQuestionAnswering.from_pretrained(\'./tf_model/bert_tf_checkpoint.ckpt.index\', from_tf=True, config=config)\n\n        """"""\n        if \'distilbert\' in pretrained_model_name_or_path:\n            return DistilBertForQuestionAnswering.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'bert\' in pretrained_model_name_or_path:\n            return BertForQuestionAnswering.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlnet\' in pretrained_model_name_or_path:\n            return XLNetForQuestionAnswering.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n        elif \'xlm\' in pretrained_model_name_or_path:\n            return XLMForQuestionAnswering.from_pretrained(pretrained_model_name_or_path, *model_args, **kwargs)\n\n        raise ValueError(""Unrecognized model identifier in {}. Should contains one of ""\n                         ""\'bert\', \'xlnet\', \'xlm\'"".format(pretrained_model_name_or_path))\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_bert.py,2,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch BERT model. """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer\nfrom .configuration_bert import BertConfig\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nBERT_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-pytorch_model.bin"",\n    \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-pytorch_model.bin"",\n    \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-pytorch_model.bin"",\n    \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-pytorch_model.bin"",\n    \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-pytorch_model.bin"",\n    \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-pytorch_model.bin"",\n    \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-pytorch_model.bin"",\n    \'bert-base-german-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-cased-pytorch_model.bin"",\n    \'bert-large-uncased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-pytorch_model.bin"",\n    \'bert-large-cased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-pytorch_model.bin"",\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-finetuned-squad-pytorch_model.bin"",\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-finetuned-squad-pytorch_model.bin"",\n    \'bert-base-cased-finetuned-mrpc\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-finetuned-mrpc-pytorch_model.bin"",\n    \'bert-base-german-dbmdz-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-cased-pytorch_model.bin"",\n    \'bert-base-german-dbmdz-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-uncased-pytorch_model.bin"",\n}\n\ndef load_tf_weights_in_bert(model, config, tf_checkpoint_path):\n    """""" Load tf checkpoints in a pytorch model.\n    """"""\n    try:\n        import re\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    tf_path = os.path.abspath(tf_checkpoint_path)\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array)\n\n    for name, array in zip(names, arrays):\n        name = name.split(\'/\')\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if any(n in [""adam_v"", ""adam_m"", ""global_step""] for n in name):\n            logger.info(""Skipping {}"".format(""/"".join(name)))\n            continue\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+_\\d+\', m_name):\n                l = re.split(r\'_(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'kernel\' or l[0] == \'gamma\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'output_bias\' or l[0] == \'beta\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'output_weights\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'squad\':\n                pointer = getattr(pointer, \'classifier\')\n            else:\n                try:\n                    pointer = getattr(pointer, l[0])\n                except AttributeError:\n                    logger.info(""Skipping {}"".format(""/"".join(name)))\n                    continue\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        if m_name[-11:] == \'_embeddings\':\n            pointer = getattr(pointer, \'weight\')\n        elif m_name == \'kernel\':\n            array = np.transpose(array)\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\n\ndef gelu(x):\n    """""" Original Implementation of the gelu activation function in Google Bert repo when initially created.\n        For information: OpenAI GPT\'s gelu is slightly different (and gives slightly different results):\n        0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    return x * 0.5 * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\ndef gelu_new(x):\n    """""" Implementation of the gelu activation function currently in Google Bert repo (identical to OpenAI GPT).\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT2FN = {""gelu"": gelu, ""relu"": torch.nn.functional.relu, ""swish"": swish, ""gelu_new"": gelu_new}\n\n\nBertLayerNorm = torch.nn.LayerNorm\n\nclass BertEmbeddings(nn.Module):\n    """"""Construct the embeddings from word, position and token_type embeddings.\n    """"""\n    def __init__(self, config):\n        super(BertEmbeddings, self).__init__()\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=0)\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)\n\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\n        # any TensorFlow checkpoint file\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        words_embeddings = self.word_embeddings(input_ids)\n        position_embeddings = self.position_embeddings(position_ids)\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\n\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\n        embeddings = self.LayerNorm(embeddings)\n        embeddings = self.dropout(embeddings)\n        return embeddings\n\n\nclass BertSelfAttention(nn.Module):\n    def __init__(self, config):\n        super(BertSelfAttention, self).__init__()\n        if config.hidden_size % config.num_attention_heads != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.hidden_size, config.num_attention_heads))\n        self.output_attentions = config.output_attentions\n\n        self.num_attention_heads = config.num_attention_heads\n        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)\n        self.all_head_size = self.num_attention_heads * self.attention_head_size\n\n        self.query = nn.Linear(config.hidden_size, self.all_head_size)\n        self.key = nn.Linear(config.hidden_size, self.all_head_size)\n        self.value = nn.Linear(config.hidden_size, self.all_head_size)\n\n        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)\n\n    def transpose_for_scores(self, x):\n        new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size)\n        x = x.view(*new_x_shape)\n        return x.permute(0, 2, 1, 3)\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        mixed_query_layer = self.query(hidden_states)\n        mixed_key_layer = self.key(hidden_states)\n        mixed_value_layer = self.value(hidden_states)\n\n        query_layer = self.transpose_for_scores(mixed_query_layer)\n        key_layer = self.transpose_for_scores(mixed_key_layer)\n        value_layer = self.transpose_for_scores(mixed_value_layer)\n\n        # Take the dot product between ""query"" and ""key"" to get the raw attention scores.\n        attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))\n        attention_scores = attention_scores / math.sqrt(self.attention_head_size)\n        if attention_mask is not None:\n            # Apply the attention mask is (precomputed for all layers in BertModel forward() function)\n            attention_scores = attention_scores + attention_mask\n\n        # Normalize the attention scores to probabilities.\n        attention_probs = nn.Softmax(dim=-1)(attention_scores)\n\n        # This is actually dropping out entire tokens to attend to, which might\n        # seem a bit unusual, but is taken from the original Transformer paper.\n        attention_probs = self.dropout(attention_probs)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attention_probs = attention_probs * head_mask\n\n        context_layer = torch.matmul(attention_probs, value_layer)\n\n        context_layer = context_layer.permute(0, 2, 1, 3).contiguous()\n        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)\n        context_layer = context_layer.view(*new_context_layer_shape)\n\n        outputs = (context_layer, attention_probs) if self.output_attentions else (context_layer,)\n        return outputs\n\n\nclass BertSelfOutput(nn.Module):\n    def __init__(self, config):\n        super(BertSelfOutput, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertAttention(nn.Module):\n    def __init__(self, config):\n        super(BertAttention, self).__init__()\n        self.self = BertSelfAttention(config)\n        self.output = BertSelfOutput(config)\n        self.pruned_heads = set()\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.self.num_attention_heads, self.self.attention_head_size)\n        heads = set(heads) - self.pruned_heads  # Convert to set and emove already pruned heads\n        for head in heads:\n            # Compute how many pruned heads are before the head and move the index accordingly\n            head = head - sum(1 if h < head else 0 for h in self.pruned_heads)\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n\n        # Prune linear layers\n        self.self.query = prune_linear_layer(self.self.query, index)\n        self.self.key = prune_linear_layer(self.self.key, index)\n        self.self.value = prune_linear_layer(self.self.value, index)\n        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)\n\n        # Update hyper params and store pruned heads\n        self.self.num_attention_heads = self.self.num_attention_heads - len(heads)\n        self.self.all_head_size = self.self.attention_head_size * self.self.num_attention_heads\n        self.pruned_heads = self.pruned_heads.union(heads)\n\n    def forward(self, input_tensor, attention_mask=None, head_mask=None):\n        self_outputs = self.self(input_tensor, attention_mask, head_mask)\n        attention_output = self.output(self_outputs[0], input_tensor)\n        outputs = (attention_output,) + self_outputs[1:]  # add attentions if we output them\n        return outputs\n\n\nclass BertIntermediate(nn.Module):\n    def __init__(self, config):\n        super(BertIntermediate, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.intermediate_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.intermediate_act_fn = config.hidden_act\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.intermediate_act_fn(hidden_states)\n        return hidden_states\n\n\nclass BertOutput(nn.Module):\n    def __init__(self, config):\n        super(BertOutput, self).__init__()\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertLayer(nn.Module):\n    def __init__(self, config):\n        super(BertLayer, self).__init__()\n        self.attention = BertAttention(config)\n        self.intermediate = BertIntermediate(config)\n        self.output = BertOutput(config)\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        attention_outputs = self.attention(hidden_states, attention_mask, head_mask)\n        attention_output = attention_outputs[0]\n        intermediate_output = self.intermediate(attention_output)\n        layer_output = self.output(intermediate_output, attention_output)\n        outputs = (layer_output,) + attention_outputs[1:]  # add attentions if we output them\n        return outputs\n\n\nclass BertEncoder(nn.Module):\n    def __init__(self, config):\n        super(BertEncoder, self).__init__()\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n        self.layer = nn.ModuleList([BertLayer(config) for _ in range(config.num_hidden_layers)])\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        all_hidden_states = ()\n        all_attentions = ()\n        for i, layer_module in enumerate(self.layer):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states,)\n\n            layer_outputs = layer_module(hidden_states, attention_mask, head_mask[i])\n            hidden_states = layer_outputs[0]\n\n            if self.output_attentions:\n                all_attentions = all_attentions + (layer_outputs[1],)\n\n        # Add last layer\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        outputs = (hidden_states,)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (all_attentions,)\n        return outputs  # last-layer hidden state, (all hidden states), (all attentions)\n\n\nclass BertPooler(nn.Module):\n    def __init__(self, config):\n        super(BertPooler, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.activation = nn.Tanh()\n\n    def forward(self, hidden_states):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token.\n        first_token_tensor = hidden_states[:, 0]\n        pooled_output = self.dense(first_token_tensor)\n        pooled_output = self.activation(pooled_output)\n        return pooled_output\n\n\nclass BertPredictionHeadTransform(nn.Module):\n    def __init__(self, config):\n        super(BertPredictionHeadTransform, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.transform_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.transform_act_fn = config.hidden_act\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.transform_act_fn(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states)\n        return hidden_states\n\n\nclass BertLMPredictionHead(nn.Module):\n    def __init__(self, config):\n        super(BertLMPredictionHead, self).__init__()\n        self.transform = BertPredictionHeadTransform(config)\n\n        # The output weights are the same as the input embeddings, but there is\n        # an output-only bias for each token.\n        self.decoder = nn.Linear(config.hidden_size,\n                                 config.vocab_size,\n                                 bias=False)\n\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\n\n    def forward(self, hidden_states):\n        hidden_states = self.transform(hidden_states)\n        hidden_states = self.decoder(hidden_states) + self.bias\n        return hidden_states\n\n\nclass BertOnlyMLMHead(nn.Module):\n    def __init__(self, config):\n        super(BertOnlyMLMHead, self).__init__()\n        self.predictions = BertLMPredictionHead(config)\n\n    def forward(self, sequence_output):\n        prediction_scores = self.predictions(sequence_output)\n        return prediction_scores\n\n\nclass BertOnlyNSPHead(nn.Module):\n    def __init__(self, config):\n        super(BertOnlyNSPHead, self).__init__()\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, pooled_output):\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return seq_relationship_score\n\n\nclass BertPreTrainingHeads(nn.Module):\n    def __init__(self, config):\n        super(BertPreTrainingHeads, self).__init__()\n        self.predictions = BertLMPredictionHead(config)\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, sequence_output, pooled_output):\n        prediction_scores = self.predictions(sequence_output)\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return prediction_scores, seq_relationship_score\n\n\nclass BertPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = BertConfig\n    pretrained_model_archive_map = BERT_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_bert\n    base_model_prefix = ""bert""\n\n    def _init_weights(self, module):\n        """""" Initialize the weights """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, BertLayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n\nBERT_START_DOCSTRING = r""""""    The BERT model was proposed in\n    `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_\n    by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova. It\'s a bidirectional transformer\n    pre-trained using a combination of masked language modeling objective and next sentence prediction\n    on a large corpus comprising the Toronto Book Corpus and Wikipedia.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`:\n        https://arxiv.org/abs/1810.04805\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.BertConfig`): Model configuration class with all the parameters of the model. \n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nBERT_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            To match pre-training, BERT input sequence should be formatted with [CLS] and [SEP] tokens as follows:\n\n            (a) For sequence pairs:\n\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]``\n                \n                ``token_type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1``\n\n            (b) For single sequences:\n\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\n                \n                ``token_type_ids:   0   0   0   0  0     0   0``\n\n            Bert is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n\n            Indices can be obtained using :class:`transformers.BertTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Segment token indices to indicate first and second portions of the inputs.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n            corresponds to a `sentence B` token\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare Bert Model transformer outputting raw hidden-states without any specific head on top."",\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertModel(BertPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the output of the last layer of the model.\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\n            Last layer hidden-state of the first token of the sequence (classification token)\n            further processed by a Linear layer and a Tanh activation function. The Linear\n            layer weights are trained from the next sentence prediction (classification)\n            objective during Bert pretraining. This output is usually *not* a good summary\n            of the semantic content of the input, you\'re often better with averaging or pooling\n            the sequence of hidden-states for the whole input sequence.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertModel.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(BertModel, self).__init__(config)\n\n        self.embeddings = BertEmbeddings(config)\n        self.encoder = BertEncoder(config)\n        self.pooler = BertPooler(config)\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        old_embeddings = self.embeddings.word_embeddings\n        new_embeddings = self._get_resized_embeddings(old_embeddings, new_num_tokens)\n        self.embeddings.word_embeddings = new_embeddings\n        return self.embeddings.word_embeddings\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n            See base class PreTrainedModel\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        # We create a 3D attention mask from a 2D tensor mask.\n        # Sizes are [batch_size, 1, 1, to_seq_length]\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n        # this attention mask is more simple than the triangular masking of causal attention\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n        # masked positions, this operation will create a tensor which is 0.0 for\n        # positions we want to attend and -10000.0 for masked positions.\n        # Since we are adding it to the raw scores before the softmax, this is\n        # effectively the same as removing these entirely.\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.num_hidden_layers, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.num_hidden_layers\n\n        embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids)\n        encoder_outputs = self.encoder(embedding_output,\n                                       extended_attention_mask,\n                                       head_mask=head_mask)\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output)\n\n        outputs = (sequence_output, pooled_output,) + encoder_outputs[1:]  # add hidden_states and attentions if they are here\n        return outputs  # sequence_output, pooled_output, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with two heads on top as done during the pre-training:\n    a `masked language modeling` head and a `next sentence prediction (classification)` head. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForPreTraining(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when both ``masked_lm_labels`` and ``next_sentence_label`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total loss as the sum of the masked language modeling loss and the next sequence prediction (classification) loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForPreTraining.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        prediction_scores, seq_relationship_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForPreTraining, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertPreTrainingHeads(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                masked_lm_labels=None, next_sentence_label=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output, pooled_output = outputs[:2]\n        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\n\n        outputs = (prediction_scores, seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if masked_lm_labels is not None and next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            total_loss = masked_lm_loss + next_sentence_loss\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a `language modeling` head on top. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForMaskedLM(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Masked language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMaskedLM.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, masked_lm_labels=input_ids)\n        loss, prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForMaskedLM, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertOnlyMLMHead(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                masked_lm_labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n        prediction_scores = self.cls(sequence_output)\n\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\n        if masked_lm_labels is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            outputs = (masked_lm_loss,) + outputs\n\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a `next sentence prediction (classification)` head on top. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForNextSentencePrediction(BertPreTrainedModel):\n    r""""""\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``next_sentence_label`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Next sequence prediction (classification) loss.\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForNextSentencePrediction.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        seq_relationship_scores = outputs[0]\n\n    """"""\n    def __init__(self, config):\n        super(BertForNextSentencePrediction, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertOnlyNSPHead(config)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                next_sentence_label=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        seq_relationship_score = self.cls(pooled_output)\n\n        outputs = (seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\n        if next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            outputs = (next_sentence_loss,) + outputs\n\n        return outputs  # (next_sentence_loss), seq_relationship_score, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model transformer with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForSequenceClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForSequenceClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, self.config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a multiple choice classification head on top (a linear layer on top of\n    the pooled output and a softmax) e.g. for RocStories/SWAG tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForMultipleChoice(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above).\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMultipleChoice.from_pretrained(\'bert-base-uncased\')\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, classification_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForMultipleChoice, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n        num_choices = input_ids.shape[1]\n\n        input_ids = input_ids.view(-1, input_ids.size(-1))\n        attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\n        token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\n        position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, num_choices)\n\n        outputs = (reshaped_logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), reshaped_logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a token classification head on top (a linear layer on top of\n    the hidden-states output) e.g. for Named-Entity-Recognition (NER) tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForTokenClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the token classification loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.num_labels)``\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForTokenClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForTokenClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n\n        sequence_output = self.dropout(sequence_output)\n        logits = self.classifier(sequence_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            # Only keep active parts of the loss\n            if attention_mask is not None:\n                active_loss = attention_mask.view(-1) == 1\n                active_logits = logits.view(-1, self.num_labels)[active_loss]\n                active_labels = labels.view(-1)[active_loss]\n                loss = loss_fct(active_logits, active_labels)\n            else:\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForQuestionAnswering(BertPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForQuestionAnswering.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForQuestionAnswering, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                start_positions=None, end_positions=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        outputs = (start_logits, end_logits,) + outputs[2:]\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), start_logits, end_logits, (hidden_states), (attentions)\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_ctrl.py,0,"b'# coding=utf-8\n# Copyright 2018 Salesforce and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" PyTorch CTRL model.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\nimport numpy as np\nimport torch\nimport torch.nn as nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn.parameter import Parameter\n\nfrom .modeling_utils import PreTrainedModel, Conv1D, prune_conv1d_layer, SequenceSummary\nfrom .configuration_ctrl import CTRLConfig\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nCTRL_PRETRAINED_MODEL_ARCHIVE_MAP = {""ctrl"": ""https://storage.googleapis.com/sf-ctrl/pytorch/seqlen256_v1.bin""}\n\n\ndef angle_defn(pos, i, d_model_size):\n    angle_rates = 1 / torch.pow(10000, (2 * (i//2)) / d_model_size)\n    return pos * angle_rates\n\ndef positional_encoding(position, d_model_size, dtype):\n    # create the sinusoidal pattern for the positional encoding\n    angle_rads = (angle_defn(torch.arange(position, dtype=dtype).unsqueeze(1),\n                  torch.arange(d_model_size, dtype=dtype).unsqueeze(0),\n                  d_model_size))\n\n    sines = torch.sin(angle_rads[:, 0::2])\n    cosines = torch.cos(angle_rads[:, 1::2])\n\n    pos_encoding = torch.cat([sines, cosines], dim=-1)\n    return pos_encoding\n\ndef scaled_dot_product_attention(q, k, v, mask, attention_mask=None, head_mask=None):\n    # calculate attention\n    matmul_qk = torch.matmul(q, k.permute(0,1,3,2))\n\n    dk = k.shape[-1]\n    scaled_attention_logits = matmul_qk / np.sqrt(dk)\n\n    if mask is not None:\n        scaled_attention_logits += (mask * -1e4)\n\n    if attention_mask is not None:\n        # Apply the attention mask\n        scaled_attention_logits = scaled_attention_logits + attention_mask\n\n    attention_weights = torch.softmax(scaled_attention_logits, dim=-1) \n\n    # Mask heads if we want to\n    if head_mask is not None:\n        attention_weights = attention_weights * head_mask\n\n    output = torch.matmul(attention_weights, v)\n\n    return output, attention_weights\n\n\nclass MultiHeadAttention(torch.nn.Module):\n    def __init__(self, d_model_size, num_heads, output_attentions=False):\n        super(MultiHeadAttention, self).__init__()\n        self.output_attentions = output_attentions\n        self.num_heads = num_heads\n        self.d_model_size = d_model_size\n\n        self.depth = int(d_model_size / self.num_heads)\n\n        self.Wq = torch.nn.Linear(d_model_size, d_model_size)\n        self.Wk = torch.nn.Linear(d_model_size, d_model_size)\n        self.Wv = torch.nn.Linear(d_model_size, d_model_size)\n\n        self.dense = torch.nn.Linear(d_model_size, d_model_size)\n\n    def split_into_heads(self, x, batch_size):\n        x = x.reshape(batch_size, -1, self.num_heads, self.depth)\n        return x.permute([0, 2, 1, 3])\n\n    def forward(self, v, k, q, mask, layer_past=None, attention_mask=None, head_mask=None):\n        batch_size = q.shape[0]\n\n        q = self.Wq(q)\n        k = self.Wk(k)\n        v = self.Wv(v)\n\n        q = self.split_into_heads(q, batch_size)\n        k = self.split_into_heads(k, batch_size)\n        v = self.split_into_heads(v, batch_size)\n        if layer_past is not None:\n            past_key, past_value = layer_past[0], layer_past[1]\n            k = torch.cat((past_key, k), dim=-2)\n            v = torch.cat((past_value, v), dim=-2)\n        present = torch.stack((k, v))\n\n        output = scaled_dot_product_attention(q, k, v, mask, attention_mask, head_mask)\n        scaled_attention = output[0].permute([0, 2, 1, 3])\n        attn = output[1]\n        original_size_attention = scaled_attention.reshape(batch_size, -1, self.d_model_size)\n        output = self.dense(original_size_attention)\n\n        outputs = (output, present)\n        if self.output_attentions:\n            outputs = outputs + (attn,)\n        return outputs\n\n\n\ndef point_wise_feed_forward_network(d_model_size, dff):\n    return torch.nn.Sequential(torch.nn.Linear(d_model_size, dff),\n                               torch.nn.ReLU(),\n                               torch.nn.Linear(dff, d_model_size))\n\n\nclass EncoderLayer(torch.nn.Module):\n    def __init__(self, d_model_size, num_heads, dff, rate=0.1, output_attentions=False):\n        super(EncoderLayer, self).__init__()\n\n        self.multi_head_attention = MultiHeadAttention(d_model_size, num_heads, output_attentions)\n        self.ffn = point_wise_feed_forward_network(d_model_size, dff)\n\n        self.layernorm1 = torch.nn.LayerNorm(d_model_size, eps=1e-6)\n        self.layernorm2 = torch.nn.LayerNorm(d_model_size, eps=1e-6)\n\n        self.dropout1 = torch.nn.Dropout(rate)\n        self.dropout2 = torch.nn.Dropout(rate)\n\n    def forward(self, x, mask, layer_past=None, attention_mask=None, head_mask=None):\n        normed = self.layernorm1(x)\n        attn_outputs = self.multi_head_attention(normed, normed, normed, mask,\n                                                      layer_past=layer_past,\n                                                      attention_mask=attention_mask,\n                                                      head_mask=head_mask)\n        attn_output = attn_outputs[0]\n        attn_output = self.dropout1(attn_output)\n        out1 = x + attn_output\n\n        out2 = self.layernorm2(out1)\n        ffn_output = self.ffn(out2)\n        ffn_output = self.dropout2(ffn_output)\n        out2 = out1 + ffn_output\n\n        outputs = (out2,) + attn_outputs[1:]\n        return outputs\n\n\nclass CTRLPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = CTRLConfig\n    pretrained_model_archive_map = CTRL_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""transformer""\n\n    def _init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding, Conv1D)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if isinstance(module, (nn.Linear, Conv1D)) and module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n\nCTRL_START_DOCSTRING = r""""""    CTRL model was proposed in \n    `CTRL: A Conditional Transformer Language Model for Controllable Generation`_\n    by Nitish Shirish Keskar*, Bryan McCann*, Lav R. Varshney, Caiming Xiong and Richard Socher.\n    It\'s a causal (unidirectional) transformer pre-trained using language modeling on a very large\n    corpus of ~140 GB of text data with the first token reserved as a control code (such as Links, Books, Wikipedia etc.).\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`CTRL: A Conditional Transformer Language Model for Controllable Generation`:\n        https://www.github.com/salesforce/ctrl\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.CTRLConfig`): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nCTRL_INPUTS_DOCSTRING = r""""""    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            CTRL is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n            Indices can be obtained using :class:`transformers.CTRLTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `past` output below). Can be used to speed up sequential decoding.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare CTRL Model transformer outputting raw hidden-states without any specific head on top."",\n                                            CTRL_START_DOCSTRING, CTRL_INPUTS_DOCSTRING)\nclass CTRLModel(CTRLPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = CTRLTokenizer.from_pretrained(\'ctrl\')\n        model = CTRLModel.from_pretrained(\'ctrl\')\n        input_ids = torch.tensor(tokenizer.encode(""Links Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(CTRLModel, self).__init__(config)\n        self.output_hidden_states = config.output_hidden_states\n        self.output_attentions = config.output_attentions\n        self.output_past = config.output_past\n\n        self.d_model_size = config.n_embd\n        self.num_layers = config.n_layer\n\n        self.pos_encoding = positional_encoding(config.n_positions, self.d_model_size, torch.float)\n\n        self.w = nn.Embedding(config.vocab_size, config.n_embd)\n\n        self.dropout = nn.Dropout(config.embd_pdrop)\n        self.h = nn.ModuleList([EncoderLayer(config.n_embd,\n                                             config.n_head,\n                                             config.dff,\n                                             config.resid_pdrop,\n                                             config.output_attentions) for _ in range(config.n_layer)])\n        self.layernorm = nn.LayerNorm(config.n_embd, eps=config.layer_norm_epsilon)\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.w = self._get_resized_embeddings(self.w, new_num_tokens)\n        return self.w\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n                heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.h[layer].attn.prune_heads(heads)\n\n    def forward(self, input_ids, past=None, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\n        input_shape = input_ids.size()\n        input_ids = input_ids.view(-1, input_shape[-1])\n        if past is None:\n            past_length = 0\n            past = [None] * len(self.h)\n        else:\n            past_length = past[0][0].size(-2)\n        if position_ids is None:\n            position_ids = torch.arange(past_length, input_ids.size(-1) + past_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n\n        # Attention mask.\n        if attention_mask is not None:\n            attention_mask = attention_mask.view(-1, input_shape[-1])\n            # We create a 3D attention mask from a 2D tensor mask.\n            # Sizes are [batch_size, 1, 1, to_seq_length]\n            # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n            # this attention mask is more simple than the triangular masking of causal attention\n            # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n            attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n            # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n            # masked positions, this operation will create a tensor which is 0.0 for\n            # positions we want to attend and -10000.0 for masked positions.\n            # Since we are adding it to the raw scores before the softmax, this is\n            # effectively the same as removing these entirely.\n            attention_mask = attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility\n            attention_mask = (1.0 - attention_mask) * -10000.0\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # head_mask has shape n_layer x batch x n_heads x N x N\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.n_layer\n\n        if token_type_ids is not None:\n            token_type_ids = token_type_ids.view(-1, input_shape[-1])\n            token_type_embeds = self.w(token_type_ids)\n            token_type_embeds *= np.sqrt(self.d_model_size)\n        else:\n            token_type_embeds = 0\n        position_ids = position_ids.view(-1, input_shape[-1])\n\n        inputs_embeds = self.w(input_ids)\n        # inputs_embeds = embedded.unsqueeze(0) if len(input_ids.shape)<2 else embedded\n        seq_len = input_ids.shape[-1]\n        mask = torch.triu(torch.ones(seq_len, seq_len), 1).to(inputs_embeds.device)\n\n        inputs_embeds *= np.sqrt(self.d_model_size)\n\n        pos_embeds = self.pos_encoding[position_ids, :].to(inputs_embeds.device)\n\n        hidden_states = inputs_embeds + pos_embeds + token_type_embeds\n\n        hidden_states = self.dropout(hidden_states)\n\n        output_shape = input_shape + (inputs_embeds.size(-1),)\n        presents = ()\n        all_hidden_states = ()\n        all_attentions = []\n        for i, (h, layer_past) in enumerate(zip(self.h, past)):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states.view(*output_shape),)\n            outputs = h(hidden_states,\n                        mask,\n                        layer_past=layer_past,\n                        attention_mask=attention_mask,\n                        head_mask=head_mask[i])\n            hidden_states, present = outputs[:2]\n            if self.output_past:\n                presents = presents + (present,)\n\n            if self.output_attentions:\n                all_attentions.append(outputs[2])\n\n        hidden_states = self.layernorm(hidden_states)\n        hidden_states = hidden_states.view(*output_shape)\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        outputs = (hidden_states,)\n        if self.output_past:\n            outputs = outputs + (presents,)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            # let the number of heads free (-1) so we can extract attention even after head pruning\n            attention_output_shape = input_shape[:-1] + (-1,) + all_attentions[0].shape[-2:]\n            all_attentions = tuple(t.view(*attention_output_shape) for t in all_attentions)\n            outputs = outputs + (all_attentions,)\n        return outputs\n\n\n@add_start_docstrings(""""""The CTRL Model transformer with a language modeling head on top\n(linear layer with weights tied to the input embeddings). """""", CTRL_START_DOCSTRING, CTRL_INPUTS_DOCSTRING)\nclass CTRLLMHeadModel(CTRLPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        import torch\n        from transformers import CTRLTokenizer, CTRLLMHeadModel\n\n        tokenizer = CTRLTokenizer.from_pretrained(\'ctrl\')\n        model = CTRLLMHeadModel.from_pretrained(\'ctrl\')\n\n        input_ids = torch.tensor(tokenizer.encode(""Links Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=input_ids)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(CTRLLMHeadModel, self).__init__(config)\n        self.transformer = CTRLModel(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=True)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n                Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head, self.transformer.w)\n\n    def forward(self, input_ids, past=None, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               past=past,\n                                               attention_mask=attention_mask,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               head_mask=head_mask)\n\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states)\n\n        outputs = (lm_logits,) + transformer_outputs[1:]\n\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), lm_logits, presents, (all hidden_states), (attentions)\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_distilbert.py,0,"b'# coding=utf-8\n# Copyright 2019-present, the HuggingFace Inc. team, The Google AI Language Team and Facebook, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" PyTorch DistilBERT model\n    adapted in part from Facebook, Inc XLM model (https://github.com/facebookresearch/XLM)\n    and in part from HuggingFace PyTorch version of Google AI Bert model (https://github.com/google-research/bert)\n""""""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport math\nimport copy\nimport sys\nfrom io import open\n\nimport itertools\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\n\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer\nfrom .configuration_distilbert import DistilBertConfig\nfrom .file_utils import add_start_docstrings\n\nimport logging\nlogger = logging.getLogger(__name__)\n\n\nDISTILBERT_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'distilbert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/distilbert-base-uncased-pytorch_model.bin"",\n    \'distilbert-base-uncased-distilled-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/distilbert-base-uncased-distilled-squad-pytorch_model.bin""\n}\n\n\n### UTILS AND BUILDING BLOCKS OF THE ARCHITECTURE ###\ndef gelu(x):\n    return 0.5 * x * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\ndef create_sinusoidal_embeddings(n_pos, dim, out):\n    position_enc = np.array([\n        [pos / np.power(10000, 2 * (j // 2) / dim) for j in range(dim)]\n        for pos in range(n_pos)\n    ])\n    out[:, 0::2] = torch.FloatTensor(np.sin(position_enc[:, 0::2]))\n    out[:, 1::2] = torch.FloatTensor(np.cos(position_enc[:, 1::2]))\n    out.detach_()\n    out.requires_grad = False\n\nclass Embeddings(nn.Module):\n    def __init__(self,\n                 config):\n        super(Embeddings, self).__init__()\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.dim, padding_idx=0)\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.dim)\n        if config.sinusoidal_pos_embds:\n            create_sinusoidal_embeddings(n_pos=config.max_position_embeddings,\n                                         dim=config.dim,\n                                         out=self.position_embeddings.weight)\n\n        self.LayerNorm = nn.LayerNorm(config.dim, eps=1e-12)\n        self.dropout = nn.Dropout(config.dropout)\n\n    def forward(self, input_ids):\n        """"""\n        Parameters\n        ----------\n        input_ids: torch.tensor(bs, max_seq_length)\n            The token ids to embed.\n\n        Outputs\n        -------\n        embeddings: torch.tensor(bs, max_seq_length, dim)\n            The embedded tokens (plus position embeddings, no token_type embeddings)\n        """"""\n        seq_length = input_ids.size(1)\n        position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device) # (max_seq_length)\n        position_ids = position_ids.unsqueeze(0).expand_as(input_ids)                      # (bs, max_seq_length)\n\n        word_embeddings = self.word_embeddings(input_ids)                   # (bs, max_seq_length, dim)\n        position_embeddings = self.position_embeddings(position_ids)        # (bs, max_seq_length, dim)\n\n        embeddings = word_embeddings + position_embeddings  # (bs, max_seq_length, dim)\n        embeddings = self.LayerNorm(embeddings)             # (bs, max_seq_length, dim)\n        embeddings = self.dropout(embeddings)               # (bs, max_seq_length, dim)\n        return embeddings\n\nclass MultiHeadSelfAttention(nn.Module):\n    def __init__(self, config):\n        super(MultiHeadSelfAttention, self).__init__()\n\n        self.n_heads = config.n_heads\n        self.dim = config.dim\n        self.dropout = nn.Dropout(p=config.attention_dropout)\n        self.output_attentions = config.output_attentions\n\n        assert self.dim % self.n_heads == 0\n\n        self.q_lin = nn.Linear(in_features=config.dim, out_features=config.dim)\n        self.k_lin = nn.Linear(in_features=config.dim, out_features=config.dim)\n        self.v_lin = nn.Linear(in_features=config.dim, out_features=config.dim)\n        self.out_lin = nn.Linear(in_features=config.dim, out_features=config.dim)\n\n        self.pruned_heads = set()\n\n    def prune_heads(self, heads):\n        attention_head_size = self.dim // self.n_heads\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.n_heads, attention_head_size)\n        heads = set(heads) - self.pruned_heads\n        for head in heads:\n            head -= sum(1 if h < head else 0 for h in self.pruned_heads)\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        # Prune linear layers\n        self.q_lin = prune_linear_layer(self.q_lin, index)\n        self.k_lin = prune_linear_layer(self.k_lin, index)\n        self.v_lin = prune_linear_layer(self.v_lin, index)\n        self.out_lin = prune_linear_layer(self.out_lin, index, dim=1)\n        # Update hyper params\n        self.n_heads = self.n_heads - len(heads)\n        self.dim = attention_head_size * self.n_heads\n        self.pruned_heads = self.pruned_heads.union(heads)\n\n    def forward(self, query, key, value, mask, head_mask = None):\n        """"""\n        Parameters\n        ----------\n        query: torch.tensor(bs, seq_length, dim)\n        key: torch.tensor(bs, seq_length, dim)\n        value: torch.tensor(bs, seq_length, dim)\n        mask: torch.tensor(bs, seq_length)\n\n        Outputs\n        -------\n        weights: torch.tensor(bs, n_heads, seq_length, seq_length)\n            Attention weights\n        context: torch.tensor(bs, seq_length, dim)\n            Contextualized layer. Optional: only if `output_attentions=True`\n        """"""\n        bs, q_length, dim = query.size()\n        k_length = key.size(1)\n        # assert dim == self.dim, \'Dimensions do not match: %s input vs %s configured\' % (dim, self.dim)\n        # assert key.size() == value.size()\n\n        dim_per_head = self.dim // self.n_heads\n\n        mask_reshp = (bs, 1, 1, k_length)\n\n        def shape(x):\n            """""" separate heads """"""\n            return x.view(bs, -1, self.n_heads, dim_per_head).transpose(1, 2)\n\n        def unshape(x):\n            """""" group heads """"""\n            return x.transpose(1, 2).contiguous().view(bs, -1, self.n_heads * dim_per_head)\n\n        q = shape(self.q_lin(query))           # (bs, n_heads, q_length, dim_per_head)\n        k = shape(self.k_lin(key))             # (bs, n_heads, k_length, dim_per_head)\n        v = shape(self.v_lin(value))           # (bs, n_heads, k_length, dim_per_head)\n\n        q = q / math.sqrt(dim_per_head)                     # (bs, n_heads, q_length, dim_per_head)\n        scores = torch.matmul(q, k.transpose(2,3))          # (bs, n_heads, q_length, k_length)\n        mask = (mask==0).view(mask_reshp).expand_as(scores) # (bs, n_heads, q_length, k_length)\n        scores.masked_fill_(mask, -float(\'inf\'))            # (bs, n_heads, q_length, k_length)\n\n        weights = nn.Softmax(dim=-1)(scores)   # (bs, n_heads, q_length, k_length)\n        weights = self.dropout(weights)        # (bs, n_heads, q_length, k_length)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            weights = weights * head_mask\n\n        context = torch.matmul(weights, v)     # (bs, n_heads, q_length, dim_per_head)\n        context = unshape(context)             # (bs, q_length, dim)\n        context = self.out_lin(context)        # (bs, q_length, dim)\n\n        if self.output_attentions:\n            return (context, weights)\n        else:\n            return (context,)\n\nclass FFN(nn.Module):\n    def __init__(self, config):\n        super(FFN, self).__init__()\n        self.dropout = nn.Dropout(p=config.dropout)\n        self.lin1 = nn.Linear(in_features=config.dim, out_features=config.hidden_dim)\n        self.lin2 = nn.Linear(in_features=config.hidden_dim, out_features=config.dim)\n        assert config.activation in [\'relu\', \'gelu\'], ""activation ({}) must be in [\'relu\', \'gelu\']"".format(config.activation)\n        self.activation = gelu if config.activation == \'gelu\' else nn.ReLU()\n\n    def forward(self, input):\n        x = self.lin1(input)\n        x = self.activation(x)\n        x = self.lin2(x)\n        x = self.dropout(x)\n        return x\n\nclass TransformerBlock(nn.Module):\n    def __init__(self, config):\n        super(TransformerBlock, self).__init__()\n\n        self.n_heads = config.n_heads\n        self.dim = config.dim\n        self.hidden_dim = config.hidden_dim\n        self.dropout = nn.Dropout(p=config.dropout)\n        self.activation = config.activation\n        self.output_attentions = config.output_attentions\n\n        assert config.dim % config.n_heads == 0\n\n        self.attention = MultiHeadSelfAttention(config)\n        self.sa_layer_norm = nn.LayerNorm(normalized_shape=config.dim, eps=1e-12)\n\n        self.ffn = FFN(config)\n        self.output_layer_norm = nn.LayerNorm(normalized_shape=config.dim, eps=1e-12)\n\n    def forward(self, x, attn_mask=None, head_mask=None):\n        """"""\n        Parameters\n        ----------\n        x: torch.tensor(bs, seq_length, dim)\n        attn_mask: torch.tensor(bs, seq_length)\n\n        Outputs\n        -------\n        sa_weights: torch.tensor(bs, n_heads, seq_length, seq_length)\n            The attention weights\n        ffn_output: torch.tensor(bs, seq_length, dim)\n            The output of the transformer block contextualization.\n        """"""\n        # Self-Attention\n        sa_output = self.attention(query=x, key=x, value=x, mask=attn_mask, head_mask=head_mask)\n        if self.output_attentions:\n            sa_output, sa_weights = sa_output                  # (bs, seq_length, dim), (bs, n_heads, seq_length, seq_length)\n        else: # To handle these `output_attention` or `output_hidden_states` cases returning tuples\n            assert type(sa_output) == tuple\n            sa_output = sa_output[0]\n        sa_output = self.sa_layer_norm(sa_output + x)          # (bs, seq_length, dim)\n\n        # Feed Forward Network\n        ffn_output = self.ffn(sa_output)                             # (bs, seq_length, dim)\n        ffn_output = self.output_layer_norm(ffn_output + sa_output)  # (bs, seq_length, dim)\n\n        output = (ffn_output,)\n        if self.output_attentions:\n            output = (sa_weights,) + output\n        return output\n\n\nclass Transformer(nn.Module):\n    def __init__(self, config):\n        super(Transformer, self).__init__()\n        self.n_layers = config.n_layers\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        layer = TransformerBlock(config)\n        self.layer = nn.ModuleList([copy.deepcopy(layer) for _ in range(config.n_layers)])\n\n    def forward(self, x, attn_mask=None, head_mask=None):\n        """"""\n        Parameters\n        ----------\n        x: torch.tensor(bs, seq_length, dim)\n            Input sequence embedded.\n        attn_mask: torch.tensor(bs, seq_length)\n            Attention mask on the sequence.\n\n        Outputs\n        -------\n        hidden_state: torch.tensor(bs, seq_length, dim)\n            Sequence of hiddens states in the last (top) layer\n        all_hidden_states: Tuple[torch.tensor(bs, seq_length, dim)]\n            Tuple of length n_layers with the hidden states from each layer.\n            Optional: only if output_hidden_states=True\n        all_attentions: Tuple[torch.tensor(bs, n_heads, seq_length, seq_length)]\n            Tuple of length n_layers with the attention weights from each layer\n            Optional: only if output_attentions=True\n        """"""\n        all_hidden_states = ()\n        all_attentions = ()\n\n        hidden_state = x\n        for i, layer_module in enumerate(self.layer):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_state,)\n\n            layer_outputs = layer_module(x=hidden_state,\n                                         attn_mask=attn_mask,\n                                         head_mask=head_mask[i])\n            hidden_state = layer_outputs[-1]\n\n            if self.output_attentions:\n                assert len(layer_outputs) == 2\n                attentions = layer_outputs[0]\n                all_attentions = all_attentions + (attentions,)\n            else:\n                assert len(layer_outputs) == 1\n\n        # Add last layer\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_state,)\n\n        outputs = (hidden_state,)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (all_attentions,)\n        return outputs  # last-layer hidden state, (all hidden states), (all attentions)\n\n\n### INTERFACE FOR ENCODER AND TASK SPECIFIC MODEL ###\nclass DistilBertPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for downloading and loading pretrained models.\n    """"""\n    config_class = DistilBertConfig\n    pretrained_model_archive_map = DISTILBERT_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = None\n    base_model_prefix = ""distilbert""\n\n    def __init__(self, *inputs, **kwargs):\n        super(DistilBertPreTrainedModel, self).__init__(*inputs, **kwargs)\n    \n    def _init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, nn.Embedding):\n            if module.weight.requires_grad:\n                module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        if isinstance(module, nn.Linear):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n\nDISTILBERT_START_DOCSTRING = r""""""\n    DistilBERT is a small, fast, cheap and light Transformer model\n    trained by distilling Bert base. It has 40% less parameters than\n    `bert-base-uncased`, runs 60% faster while preserving over 95% of\n    Bert\'s performances as measured on the GLUE language understanding benchmark.\n\n    Here are the differences between the interface of Bert and DistilBert:\n\n    - DistilBert doesn\'t have `token_type_ids`, you don\'t need to indicate which token belongs to which segment. Just separate your segments with the separation token `tokenizer.sep_token` (or `[SEP]`)\n    - DistilBert doesn\'t have options to select the input positions (`position_ids` input). This could be added if necessary though, just let\'s us know if you need this option.\n\n    For more information on DistilBERT, please refer to our\n    `detailed blog post`_\n    \n    .. _`detailed blog post`:\n        https://medium.com/huggingface/distilbert-8cf3380435b5\n\n    Parameters:\n        config (:class:`~transformers.DistilBertConfig`): Model configuration class with all the parameters of the model. \n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nDISTILBERT_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids** ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            The input sequences should start with `[CLS]` and end with `[SEP]` tokens.\n            \n            For now, ONLY BertTokenizer(`bert-base-uncased`) is supported and you should use this tokenizer when using DistilBERT.\n        **attention_mask**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare DistilBERT encoder/transformer outputting raw hidden-states without any specific head on top."",\n                      DISTILBERT_START_DOCSTRING, DISTILBERT_INPUTS_DOCSTRING)\nclass DistilBertModel(DistilBertPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the output of the last layer of the model.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = DistilBertTokenizer.from_pretrained(\'distilbert-base-uncased\')\n        model = DistilBertModel.from_pretrained(\'distilbert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(DistilBertModel, self).__init__(config)\n\n        self.embeddings = Embeddings(config)   # Embeddings\n        self.transformer = Transformer(config) # Encoder\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        old_embeddings = self.embeddings.word_embeddings\n        new_embeddings = self._get_resized_embeddings(old_embeddings, new_num_tokens)\n        self.embeddings.word_embeddings = new_embeddings\n        return self.embeddings.word_embeddings\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n            See base class PreTrainedModel\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.transformer.layer[layer].attention.prune_heads(heads)\n\n    def forward(self,\n                input_ids, attention_mask=None, head_mask=None):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids) # (bs, seq_length)\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.num_hidden_layers, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.num_hidden_layers\n\n        embedding_output = self.embeddings(input_ids)   # (bs, seq_length, dim)\n        tfmr_output = self.transformer(x=embedding_output,\n                                       attn_mask=attention_mask,\n                                       head_mask=head_mask)\n        hidden_state = tfmr_output[0]\n        output = (hidden_state, ) + tfmr_output[1:]\n\n        return output # last-layer hidden-state, (all hidden_states), (all attentions)\n\n\n@add_start_docstrings(""""""DistilBert Model with a `masked language modeling` head on top. """""",\n                      DISTILBERT_START_DOCSTRING, DISTILBERT_INPUTS_DOCSTRING)\nclass DistilBertForMaskedLM(DistilBertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Masked language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = DistilBertTokenizer.from_pretrained(\'distilbert-base-uncased\')\n        model = DistilBertForMaskedLM.from_pretrained(\'distilbert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, masked_lm_labels=input_ids)\n        loss, prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(DistilBertForMaskedLM, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        self.distilbert = DistilBertModel(config)\n        self.vocab_transform = nn.Linear(config.dim, config.dim)\n        self.vocab_layer_norm = nn.LayerNorm(config.dim, eps=1e-12)\n        self.vocab_projector = nn.Linear(config.dim, config.vocab_size)\n\n        self.init_weights()\n        self.tie_weights()\n\n        self.mlm_loss_fct = nn.CrossEntropyLoss(ignore_index=-1)\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.vocab_projector,\n                                   self.distilbert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, head_mask=None, masked_lm_labels=None):\n        dlbrt_output = self.distilbert(input_ids=input_ids,\n                                       attention_mask=attention_mask,\n                                       head_mask=head_mask)\n        hidden_states = dlbrt_output[0]                              # (bs, seq_length, dim)\n        prediction_logits = self.vocab_transform(hidden_states)      # (bs, seq_length, dim)\n        prediction_logits = gelu(prediction_logits)                  # (bs, seq_length, dim)\n        prediction_logits = self.vocab_layer_norm(prediction_logits) # (bs, seq_length, dim)\n        prediction_logits = self.vocab_projector(prediction_logits)  # (bs, seq_length, vocab_size)\n\n        outputs = (prediction_logits, ) + dlbrt_output[1:]\n        if masked_lm_labels is not None:\n            mlm_loss = self.mlm_loss_fct(prediction_logits.view(-1, prediction_logits.size(-1)),\n                                         masked_lm_labels.view(-1))\n            outputs = (mlm_loss,) + outputs     \n\n        return outputs # (mlm_loss), prediction_logits, (all hidden_states), (all attentions)\n\n\n@add_start_docstrings(""""""DistilBert Model transformer with a sequence classification/regression head on top (a linear layer on top of\n                         the pooled output) e.g. for GLUE tasks. """""",\n                      DISTILBERT_START_DOCSTRING, DISTILBERT_INPUTS_DOCSTRING)\nclass DistilBertForSequenceClassification(DistilBertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = DistilBertTokenizer.from_pretrained(\'distilbert-base-uncased\')\n        model = DistilBertForSequenceClassification.from_pretrained(\'distilbert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(DistilBertForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.distilbert = DistilBertModel(config)\n        self.pre_classifier = nn.Linear(config.dim, config.dim)\n        self.classifier = nn.Linear(config.dim, config.num_labels)\n        self.dropout = nn.Dropout(config.seq_classif_dropout)\n\n        self.init_weights()\n\n    def forward(self, input_ids,  attention_mask=None, head_mask=None, labels=None):\n        distilbert_output = self.distilbert(input_ids=input_ids,\n                                            attention_mask=attention_mask,\n                                            head_mask=head_mask)\n        hidden_state = distilbert_output[0]                    # (bs, seq_len, dim)\n        pooled_output = hidden_state[:, 0]                    # (bs, dim)\n        pooled_output = self.pre_classifier(pooled_output)   # (bs, dim)\n        pooled_output = nn.ReLU()(pooled_output)             # (bs, dim)\n        pooled_output = self.dropout(pooled_output)         # (bs, dim)\n        logits = self.classifier(pooled_output)              # (bs, dim)\n\n        outputs = (logits,) + distilbert_output[1:]\n        if labels is not None:\n            if self.num_labels == 1:\n                loss_fct = nn.MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = nn.CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""DistilBert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n                         the hidden-states output to compute `span start logits` and `span end logits`). """""",\n                      DISTILBERT_START_DOCSTRING, DISTILBERT_INPUTS_DOCSTRING)\nclass DistilBertForQuestionAnswering(DistilBertPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = DistilBertTokenizer.from_pretrained(\'distilbert-base-uncased\')\n        model = DistilBertForQuestionAnswering.from_pretrained(\'distilbert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:3]\n\n    """"""\n    def __init__(self, config):\n        super(DistilBertForQuestionAnswering, self).__init__(config)\n\n        self.distilbert = DistilBertModel(config)\n        self.qa_outputs = nn.Linear(config.dim, config.num_labels)\n        assert config.num_labels == 2\n        self.dropout = nn.Dropout(config.qa_dropout)\n\n        self.init_weights()\n        \n    def forward(self, input_ids, attention_mask=None, head_mask=None, start_positions=None, end_positions=None):\n        distilbert_output = self.distilbert(input_ids=input_ids,\n                                            attention_mask=attention_mask,\n                                            head_mask=head_mask)\n        hidden_states = distilbert_output[0]                                 # (bs, max_query_len, dim)\n\n        hidden_states = self.dropout(hidden_states)                       # (bs, max_query_len, dim)\n        logits = self.qa_outputs(hidden_states)                           # (bs, max_query_len, 2)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)                           # (bs, max_query_len)\n        end_logits = end_logits.squeeze(-1)                               # (bs, max_query_len)\n\n        outputs = (start_logits, end_logits,) + distilbert_output[1:]\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = nn.CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), start_logits, end_logits, (hidden_states), (attentions)\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_gpt2.py,2,"b'# coding=utf-8\n# Copyright 2018 The OpenAI Team Authors and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch OpenAI GPT-2 model.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn.parameter import Parameter\n\nfrom .modeling_utils import PreTrainedModel, Conv1D, prune_conv1d_layer, SequenceSummary\nfrom .configuration_gpt2 import GPT2Config\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nGPT2_PRETRAINED_MODEL_ARCHIVE_MAP = {""gpt2"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-pytorch_model.bin"",\n                                     ""gpt2-medium"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-pytorch_model.bin"",\n                                     ""gpt2-large"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-large-pytorch_model.bin"",\n                                     ""distilgpt2"": ""https://s3.amazonaws.com/models.huggingface.co/bert/distilgpt2-pytorch_model.bin"",}\n\ndef load_tf_weights_in_gpt2(model, config, gpt2_checkpoint_path):\n    """""" Load tf checkpoints in a pytorch model\n    """"""\n    try:\n        import re\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    tf_path = os.path.abspath(gpt2_checkpoint_path)\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array.squeeze())\n\n    for name, array in zip(names, arrays):\n        name = name[6:]  # skip ""model/""\n        name = name.split(\'/\')\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+\\d+\', m_name):\n                l = re.split(r\'(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'w\' or l[0] == \'g\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'b\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'wpe\' or l[0] == \'wte\':\n                pointer = getattr(pointer, l[0])\n                pointer = getattr(pointer, \'weight\')\n            else:\n                pointer = getattr(pointer, l[0])\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\n\ndef gelu(x):\n    return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n\n\nclass Attention(nn.Module):\n    def __init__(self, nx, n_ctx, config, scale=False):\n        super(Attention, self).__init__()\n        self.output_attentions = config.output_attentions\n\n        n_state = nx  # in Attention: n_state=768 (nx=n_embd)\n        # [switch nx => n_state from Block to Attention to keep identical to TF implem]\n        assert n_state % config.n_head == 0\n        self.register_buffer(""bias"", torch.tril(torch.ones(n_ctx, n_ctx)).view(1, 1, n_ctx, n_ctx))\n        self.n_head = config.n_head\n        self.split_size = n_state\n        self.scale = scale\n\n        self.c_attn = Conv1D(n_state * 3, nx)\n        self.c_proj = Conv1D(n_state, nx)\n        self.attn_dropout = nn.Dropout(config.attn_pdrop)\n        self.resid_dropout = nn.Dropout(config.resid_pdrop)\n        self.pruned_heads = set()\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.n_head, self.split_size // self.n_head)\n        heads = set(heads) - self.pruned_heads  # Convert to set and emove already pruned heads\n        for head in heads:\n            # Compute how many pruned heads are before the head and move the index accordingly\n            head = head - sum(1 if h < head else 0 for h in self.pruned_heads)\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        index_attn = torch.cat([index, index + self.split_size, index + (2*self.split_size)])\n\n        # Prune conv1d layers\n        self.c_attn = prune_conv1d_layer(self.c_attn, index_attn, dim=1)\n        self.c_proj = prune_conv1d_layer(self.c_proj, index, dim=0)\n\n        # Update hyper params\n        self.split_size = (self.split_size // self.n_head) * (self.n_head - len(heads))\n        self.n_head = self.n_head - len(heads)\n        self.pruned_heads = self.pruned_heads.union(heads)\n\n    def _attn(self, q, k, v, attention_mask=None, head_mask=None):\n        w = torch.matmul(q, k)\n        if self.scale:\n            w = w / math.sqrt(v.size(-1))\n        nd, ns = w.size(-2), w.size(-1)\n        b = self.bias[:, :, ns-nd:ns, :ns]\n        w = w * b - 1e4 * (1 - b)\n\n        if attention_mask is not None:\n            # Apply the attention mask\n            w = w + attention_mask\n\n        w = nn.Softmax(dim=-1)(w)\n        w = self.attn_dropout(w)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            w = w * head_mask\n\n        outputs = [torch.matmul(w, v)]\n        if self.output_attentions:\n            outputs.append(w)\n        return outputs\n\n    def merge_heads(self, x):\n        x = x.permute(0, 2, 1, 3).contiguous()\n        new_x_shape = x.size()[:-2] + (x.size(-2) * x.size(-1),)\n        return x.view(*new_x_shape)  # in Tensorflow implem: fct merge_states\n\n    def split_heads(self, x, k=False):\n        new_x_shape = x.size()[:-1] + (self.n_head, x.size(-1) // self.n_head)\n        x = x.view(*new_x_shape)  # in Tensorflow implem: fct split_states\n        if k:\n            return x.permute(0, 2, 3, 1)  # (batch, head, head_features, seq_length)\n        else:\n            return x.permute(0, 2, 1, 3)  # (batch, head, seq_length, head_features)\n\n    def forward(self, x, layer_past=None, attention_mask=None, head_mask=None):\n        x = self.c_attn(x)\n        query, key, value = x.split(self.split_size, dim=2)\n        query = self.split_heads(query)\n        key = self.split_heads(key, k=True)\n        value = self.split_heads(value)\n        if layer_past is not None:\n            past_key, past_value = layer_past[0].transpose(-2, -1), layer_past[1]  # transpose back cf below\n            key = torch.cat((past_key, key), dim=-1)\n            value = torch.cat((past_value, value), dim=-2)\n        present = torch.stack((key.transpose(-2, -1), value))  # transpose to have same shapes for stacking\n\n        attn_outputs = self._attn(query, key, value, attention_mask, head_mask)\n        a = attn_outputs[0]\n\n        a = self.merge_heads(a)\n        a = self.c_proj(a)\n        a = self.resid_dropout(a)\n\n        outputs = [a, present] + attn_outputs[1:]\n        return outputs  # a, present, (attentions)\n\n\nclass MLP(nn.Module):\n    def __init__(self, n_state, config):  # in MLP: n_state=3072 (4 * n_embd)\n        super(MLP, self).__init__()\n        nx = config.n_embd\n        self.c_fc = Conv1D(n_state, nx)\n        self.c_proj = Conv1D(nx, n_state)\n        self.act = gelu\n        self.dropout = nn.Dropout(config.resid_pdrop)\n\n    def forward(self, x):\n        h = self.act(self.c_fc(x))\n        h2 = self.c_proj(h)\n        return self.dropout(h2)\n\n\nclass Block(nn.Module):\n    def __init__(self, n_ctx, config, scale=False):\n        super(Block, self).__init__()\n        nx = config.n_embd\n        self.ln_1 = nn.LayerNorm(nx, eps=config.layer_norm_epsilon)\n        self.attn = Attention(nx, n_ctx, config, scale)\n        self.ln_2 = nn.LayerNorm(nx, eps=config.layer_norm_epsilon)\n        self.mlp = MLP(4 * nx, config)\n\n    def forward(self, x, layer_past=None, attention_mask=None, head_mask=None):\n        output_attn = self.attn(self.ln_1(x),\n                                layer_past=layer_past,\n                                attention_mask=attention_mask,\n                                head_mask=head_mask)\n        a = output_attn[0]  # output_attn: a, present, (attentions)\n\n        x = x + a\n        m = self.mlp(self.ln_2(x))\n        x = x + m\n\n        outputs = [x] + output_attn[1:]\n        return outputs  # x, present, (attentions)\n\n\nclass GPT2PreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = GPT2Config\n    pretrained_model_archive_map = GPT2_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_gpt2\n    base_model_prefix = ""transformer""\n\n    def __init__(self, *inputs, **kwargs):\n        super(GPT2PreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def _init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding, Conv1D)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if isinstance(module, (nn.Linear, Conv1D)) and module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n\nGPT2_START_DOCSTRING = r""""""    OpenAI GPT-2 model was proposed in\n    `Language Models are Unsupervised Multitask Learners`_\n    by Alec Radford*, Jeffrey Wu*, Rewon Child, David Luan, Dario Amodei** and Ilya Sutskever**.\n    It\'s a causal (unidirectional) transformer pre-trained using  language modeling on a very large\n    corpus of ~40 GB of text data.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Language Models are Unsupervised Multitask Learners`:\n        https://openai.com/blog/better-language-models/\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.GPT2Config`): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nGPT2_INPUTS_DOCSTRING = r""""""    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            GPT-2 is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n            Indices can be obtained using :class:`transformers.GPT2Tokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `past` output below). Can be used to speed up sequential decoding.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare GPT2 Model transformer outputting raw hidden-states without any specific head on top."",\n                      GPT2_START_DOCSTRING, GPT2_INPUTS_DOCSTRING)\nclass GPT2Model(GPT2PreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n        model = GPT2Model.from_pretrained(\'gpt2\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(GPT2Model, self).__init__(config)\n        self.output_hidden_states = config.output_hidden_states\n        self.output_attentions = config.output_attentions\n        self.output_past = config.output_past\n\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n        self.wpe = nn.Embedding(config.n_positions, config.n_embd)\n        self.drop = nn.Dropout(config.embd_pdrop)\n        self.h = nn.ModuleList([Block(config.n_ctx, config, scale=True) for _ in range(config.n_layer)])\n        self.ln_f = nn.LayerNorm(config.n_embd, eps=config.layer_norm_epsilon)\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.wte = self._get_resized_embeddings(self.wte, new_num_tokens)\n        return self.wte\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.h[layer].attn.prune_heads(heads)\n\n    def forward(self, input_ids, past=None, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\n        input_shape = input_ids.size()\n        input_ids = input_ids.view(-1, input_shape[-1])\n        if token_type_ids is not None:\n            token_type_ids = token_type_ids.view(-1, input_shape[-1])\n        if position_ids is not None:\n            position_ids = position_ids.view(-1, input_shape[-1])\n\n        if past is None:\n            past_length = 0\n            past = [None] * len(self.h)\n        else:\n            past_length = past[0][0].size(-2)\n        if position_ids is None:\n            position_ids = torch.arange(past_length, input_ids.size(-1) + past_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n\n        # Attention mask.\n        if attention_mask is not None:\n            attention_mask = attention_mask.view(-1, input_shape[-1])\n            # We create a 3D attention mask from a 2D tensor mask.\n            # Sizes are [batch_size, 1, 1, to_seq_length]\n            # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n            # this attention mask is more simple than the triangular masking of causal attention\n            # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n            attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n            # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n            # masked positions, this operation will create a tensor which is 0.0 for\n            # positions we want to attend and -10000.0 for masked positions.\n            # Since we are adding it to the raw scores before the softmax, this is\n            # effectively the same as removing these entirely.\n            attention_mask = attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility\n            attention_mask = (1.0 - attention_mask) * -10000.0\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # head_mask has shape n_layer x batch x n_heads x N x N\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.n_layer\n\n        inputs_embeds = self.wte(input_ids)\n        position_embeds = self.wpe(position_ids)\n        if token_type_ids is not None:\n            token_type_embeds = self.wte(token_type_ids)\n        else:\n            token_type_embeds = 0\n        hidden_states = inputs_embeds + position_embeds + token_type_embeds\n        hidden_states = self.drop(hidden_states)\n\n        output_shape = input_shape + (hidden_states.size(-1),)\n\n        presents = ()\n        all_attentions = []\n        all_hidden_states = ()\n        for i, (block, layer_past) in enumerate(zip(self.h, past)):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states.view(*output_shape),)\n\n            outputs = block(hidden_states,\n                            layer_past=layer_past,\n                            attention_mask=attention_mask,\n                            head_mask=head_mask[i])\n\n            hidden_states, present = outputs[:2]\n            if self.output_past:\n                presents = presents + (present,)\n\n            if self.output_attentions:\n                all_attentions.append(outputs[2])\n\n        hidden_states = self.ln_f(hidden_states)\n\n        hidden_states = hidden_states.view(*output_shape)\n        # Add last hidden state\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        outputs = (hidden_states,)\n        if self.output_past:\n            outputs = outputs + (presents,)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            # let the number of heads free (-1) so we can extract attention even after head pruning\n            attention_output_shape = input_shape[:-1] + (-1,) + all_attentions[0].shape[-2:]\n            all_attentions = tuple(t.view(*attention_output_shape) for t in all_attentions)\n            outputs = outputs + (all_attentions,)\n        return outputs  # last hidden state, (presents), (all hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""The GPT2 Model transformer with a language modeling head on top\n(linear layer with weights tied to the input embeddings). """""", GPT2_START_DOCSTRING, GPT2_INPUTS_DOCSTRING)\nclass GPT2LMHeadModel(GPT2PreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        import torch\n        from transformers import GPT2Tokenizer, GPT2LMHeadModel\n\n        tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n        model = GPT2LMHeadModel.from_pretrained(\'gpt2\')\n\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=input_ids)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(GPT2LMHeadModel, self).__init__(config)\n        self.transformer = GPT2Model(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.wte)\n\n    def forward(self, input_ids, past=None, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               past=past,\n                                               attention_mask=attention_mask,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states)\n\n        outputs = (lm_logits,) + transformer_outputs[1:]\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), lm_logits, presents, (all hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""The GPT2 Model transformer with a language modeling and a multiple-choice classification\nhead on top e.g. for RocStories/SWAG tasks. The two heads are two linear layers.\nThe language modeling head has its weights tied to the input embeddings,\nthe classification head takes as input the input of a specified classification token index in the input sequence).\n"""""", GPT2_START_DOCSTRING, GPT2_INPUTS_DOCSTRING)\nclass GPT2DoubleHeadsModel(GPT2PreTrainedModel):\n    r""""""\n        **mc_token_ids**: (`optional`, default to index of the last token of the input) ``torch.LongTensor`` of shape ``(batch_size, num_choices)``:\n            Index of the classification token in each input sequence.\n            Selected in the range ``[0, input_ids.size(-1) - 1[``.\n        **lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n        **mc_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **lm_loss**: (`optional`, returned when ``lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **mc_loss**: (`optional`, returned when ``multiple_choice_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Multiple choice classification loss.\n        **lm_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **mc_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)``\n            Prediction scores of the multiplechoice classification head (scores for each choice before SoftMax).\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        import torch\n        from transformers import GPT2Tokenizer, GPT2DoubleHeadsModel\n        \n        tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n        model = GPT2DoubleHeadsModel.from_pretrained(\'gpt2\')\n        \n        # Add a [CLS] to the vocabulary (we should train it also!)\n        tokenizer.add_special_tokens({\'cls_token\': \'[CLS]\'})\n        model.resize_token_embeddings(len(tokenizer))  # Update the model embeddings with the new vocabulary size\n        print(tokenizer.cls_token_id, len(tokenizer))  # The newly token the last token of the vocabulary\n        \n        choices = [""Hello, my dog is cute [CLS]"", ""Hello, my cat is cute [CLS]""]\n        encoded_choices = [tokenizer.encode(s) for s in choices]\n        cls_token_location = [tokens.index(tokenizer.cls_token_id) for tokens in encoded_choices]\n\n        input_ids = torch.tensor(encoded_choices).unsqueeze(0)  # Batch size: 1, number of choices: 2\n        mc_token_ids = torch.tensor([cls_token_location])  # Batch size: 1\n\n        outputs = model(input_ids, mc_token_ids=mc_token_ids)\n        lm_prediction_scores, mc_prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(GPT2DoubleHeadsModel, self).__init__(config)\n        self.transformer = GPT2Model(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n        self.multiple_choice_head = SequenceSummary(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.wte)\n\n    def forward(self, input_ids, past=None, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                mc_token_ids=None, lm_labels=None, mc_labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               past=past,\n                                               attention_mask=attention_mask,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               head_mask=head_mask)\n\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states)\n        mc_logits = self.multiple_choice_head(hidden_states, mc_token_ids).squeeze(-1)\n\n        outputs = (lm_logits, mc_logits) + transformer_outputs[1:]\n        if mc_labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(mc_logits.view(-1, mc_logits.size(-1)),\n                            mc_labels.view(-1))\n            outputs = (loss,) + outputs\n        if lm_labels is not None:\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = lm_labels[..., 1:].contiguous()\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (lm loss), (mc loss), lm logits, mc logits, presents, (all hidden_states), (attentions)\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_openai.py,0,"b'# coding=utf-8\n# Copyright 2018 The OpenAI Team Authors and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch OpenAI GPT model.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn.parameter import Parameter\n\nfrom .modeling_utils import PreTrainedModel, Conv1D, prune_conv1d_layer, SequenceSummary\nfrom .configuration_openai import OpenAIGPTConfig\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nOPENAI_GPT_PRETRAINED_MODEL_ARCHIVE_MAP = {""openai-gpt"": ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-pytorch_model.bin""}\n\n\ndef load_tf_weights_in_openai_gpt(model, config, openai_checkpoint_folder_path):\n    """""" Load tf pre-trained weights in a pytorch model (from NumPy arrays here)\n    """"""\n    import re\n    import numpy as np\n\n    if \'.ckpt\' in openai_checkpoint_folder_path:\n        openai_checkpoint_folder_path = os.path.dirname(openai_checkpoint_folder_path)\n\n    logger.info(""Loading weights from {}"".format(openai_checkpoint_folder_path))\n\n    names = json.load(open(openai_checkpoint_folder_path + \'/parameters_names.json\', ""r"", encoding=\'utf-8\'))\n    shapes = json.load(open(openai_checkpoint_folder_path + \'/params_shapes.json\', ""r"", encoding=\'utf-8\'))\n    offsets = np.cumsum([np.prod(shape) for shape in shapes])\n    init_params = [np.load(openai_checkpoint_folder_path + \'/params_{}.npy\'.format(n)) for n in range(10)]\n    init_params = np.split(np.concatenate(init_params, 0), offsets)[:-1]\n    init_params = [param.reshape(shape) for param, shape in zip(init_params, shapes)]\n\n    # This was used when we had a single embedding matrix for positions and tokens\n    # init_params[0] = np.concatenate([init_params[1], init_params[0]], 0)\n    # del init_params[1]\n    init_params = [arr.squeeze() for arr in init_params]\n\n    try:\n        assert model.tokens_embed.weight.shape == init_params[1].shape\n        assert model.positions_embed.weight.shape == init_params[0].shape\n    except AssertionError as e:\n        e.args += (model.tokens_embed.weight.shape, init_params[1].shape)\n        e.args += (model.positions_embed.weight.shape, init_params[0].shape)\n        raise\n\n    model.tokens_embed.weight.data = torch.from_numpy(init_params[1])\n    model.positions_embed.weight.data = torch.from_numpy(init_params[0])\n    names.pop(0)\n    # Pop position and token embedding arrays\n    init_params.pop(0)\n    init_params.pop(0)\n\n    for name, array in zip(names, init_params): # names[1:n_transfer], init_params[1:n_transfer]):\n        name = name[6:]  # skip ""model/""\n        assert name[-2:] == "":0""\n        name = name[:-2]\n        name = name.split(\'/\')\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+\\d+\', m_name):\n                l = re.split(r\'(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'g\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'b\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'w\':\n                pointer = getattr(pointer, \'weight\')\n            else:\n                pointer = getattr(pointer, l[0])\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\n\ndef gelu(x):\n    return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT_FNS = {""relu"": nn.ReLU, ""swish"": swish, ""gelu"": gelu}\n\n\nclass Attention(nn.Module):\n    def __init__(self, nx, n_ctx, config, scale=False):\n        super(Attention, self).__init__()\n        n_state = nx  # in Attention: n_state=768 (nx=n_embd)\n        # [switch nx => n_state from Block to Attention to keep identical to TF implem]\n        assert n_state % config.n_head == 0\n        self.register_buffer(""bias"", torch.tril(torch.ones(n_ctx, n_ctx)).view(1, 1, n_ctx, n_ctx))\n        self.n_head = config.n_head\n        self.split_size = n_state\n        self.scale = scale\n\n        self.output_attentions = config.output_attentions\n\n        self.c_attn = Conv1D(n_state * 3, nx)\n        self.c_proj = Conv1D(n_state, nx)\n        self.attn_dropout = nn.Dropout(config.attn_pdrop)\n        self.resid_dropout = nn.Dropout(config.resid_pdrop)\n        self.pruned_heads = set()\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.n_head, self.split_size // self.n_head)\n        heads = set(heads) - self.pruned_heads\n        for head in heads:\n            head -= sum(1 if h < head else 0 for h in self.pruned_heads)\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        index_attn = torch.cat([index, index + self.split_size, index + (2*self.split_size)])\n        # Prune conv1d layers\n        self.c_attn = prune_conv1d_layer(self.c_attn, index_attn, dim=1)\n        self.c_proj = prune_conv1d_layer(self.c_proj, index, dim=0)\n        # Update hyper params\n        self.split_size = (self.split_size // self.n_head) * (self.n_head - len(heads))\n        self.n_head = self.n_head - len(heads)\n        self.pruned_heads = self.pruned_heads.union(heads)\n\n    def _attn(self, q, k, v, attention_mask=None, head_mask=None):\n        w = torch.matmul(q, k)\n        if self.scale:\n            w = w / math.sqrt(v.size(-1))\n        # w = w * self.bias + -1e9 * (1 - self.bias)  # TF implem method: mask_attn_weights\n        # XD: self.b may be larger than w, so we need to crop it\n        b = self.bias[:, :, : w.size(-2), : w.size(-1)]\n        w = w * b + - 1e4 * (1 - b)\n\n        if attention_mask is not None:\n            # Apply the attention mask\n            w = w + attention_mask\n\n        w = nn.Softmax(dim=-1)(w)\n        w = self.attn_dropout(w)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            w = w * head_mask\n\n        outputs = [torch.matmul(w, v)]\n        if self.output_attentions:\n            outputs.append(w)\n        return outputs\n\n    def merge_heads(self, x):\n        x = x.permute(0, 2, 1, 3).contiguous()\n        new_x_shape = x.size()[:-2] + (x.size(-2) * x.size(-1),)\n        return x.view(*new_x_shape)  # in Tensorflow implem: fct merge_states\n\n    def split_heads(self, x, k=False):\n        new_x_shape = x.size()[:-1] + (self.n_head, x.size(-1) // self.n_head)\n        x = x.view(*new_x_shape)  # in Tensorflow implem: fct split_states\n        if k:\n            return x.permute(0, 2, 3, 1)\n        else:\n            return x.permute(0, 2, 1, 3)\n\n    def forward(self, x, attention_mask=None, head_mask=None):\n        x = self.c_attn(x)\n        query, key, value = x.split(self.split_size, dim=2)\n        query = self.split_heads(query)\n        key = self.split_heads(key, k=True)\n        value = self.split_heads(value)\n\n        attn_outputs = self._attn(query, key, value, attention_mask, head_mask)\n        a = attn_outputs[0]\n\n        a = self.merge_heads(a)\n        a = self.c_proj(a)\n        a = self.resid_dropout(a)\n\n        outputs = [a] + attn_outputs[1:]\n        return outputs  # a, (attentions)\n\n\nclass MLP(nn.Module):\n    def __init__(self, n_state, config):  # in MLP: n_state=3072 (4 * n_embd)\n        super(MLP, self).__init__()\n        nx = config.n_embd\n        self.c_fc = Conv1D(n_state, nx)\n        self.c_proj = Conv1D(nx, n_state)\n        self.act = ACT_FNS[config.afn]\n        self.dropout = nn.Dropout(config.resid_pdrop)\n\n    def forward(self, x):\n        h = self.act(self.c_fc(x))\n        h2 = self.c_proj(h)\n        return self.dropout(h2)\n\n\nclass Block(nn.Module):\n    def __init__(self, n_ctx, config, scale=False):\n        super(Block, self).__init__()\n        nx = config.n_embd\n        self.attn = Attention(nx, n_ctx, config, scale)\n        self.ln_1 = nn.LayerNorm(nx, eps=config.layer_norm_epsilon)\n        self.mlp = MLP(4 * nx, config)\n        self.ln_2 = nn.LayerNorm(nx, eps=config.layer_norm_epsilon)\n\n    def forward(self, x, attention_mask=None, head_mask=None):\n        attn_outputs = self.attn(x, attention_mask=attention_mask, head_mask=head_mask)\n        a = attn_outputs[0]\n\n        n = self.ln_1(x + a)\n        m = self.mlp(n)\n        h = self.ln_2(n + m)\n\n        outputs = [h] + attn_outputs[1:]\n        return outputs\n\n\nclass OpenAIGPTPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = OpenAIGPTConfig\n    pretrained_model_archive_map = OPENAI_GPT_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_openai_gpt\n    base_model_prefix = ""transformer""\n\n    def _init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding, Conv1D)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if isinstance(module, (nn.Linear, Conv1D)) and module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n\nOPENAI_GPT_START_DOCSTRING = r""""""    OpenAI GPT model was proposed in\n    `Improving Language Understanding by Generative Pre-Training`_\n    by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever.\n    It\'s a causal (unidirectional) transformer pre-trained using language modeling on a large\n    corpus will long range dependencies, the Toronto Book Corpus.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Improving Language Understanding by Generative Pre-Training`:\n        https://openai.com/blog/language-unsupervised/\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.OpenAIGPTConfig`): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nOPENAI_GPT_INPUTS_DOCSTRING = r""""""    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            GPT is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n            Indices can be obtained using :class:`transformers.BPT2Tokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices)\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare OpenAI GPT transformer model outputting raw hidden-states without any specific head on top."",\n                      OPENAI_GPT_START_DOCSTRING, OPENAI_GPT_INPUTS_DOCSTRING)\nclass OpenAIGPTModel(OpenAIGPTPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = OpenAIGPTTokenizer.from_pretrained(\'openai-gpt\')\n        model = OpenAIGPTModel.from_pretrained(\'openai-gpt\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(OpenAIGPTModel, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        self.tokens_embed = nn.Embedding(config.vocab_size, config.n_embd)\n        self.positions_embed = nn.Embedding(config.n_positions, config.n_embd)\n        self.drop = nn.Dropout(config.embd_pdrop)\n        self.h = nn.ModuleList([Block(config.n_ctx, config, scale=True) for _ in range(config.n_layer)])\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.tokens_embed = self._get_resized_embeddings(self.tokens_embed, new_num_tokens)\n        return self.tokens_embed\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.h[layer].attn.prune_heads(heads)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\n        if position_ids is None:\n            # This was used when we had a single embedding matrice from position and token embeddings\n            # start = self.config.vocab_size + self.config.n_special\n            # end = start + input_ids.size(-1)\n            # position_ids = torch.arange(start, end, dtype=torch.long, device=input_ids.device)\n            position_ids = torch.arange(input_ids.size(-1), dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n\n        # Attention mask.\n        if attention_mask is not None:\n            # We create a 3D attention mask from a 2D tensor mask.\n            # Sizes are [batch_size, 1, 1, to_seq_length]\n            # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n            # this attention mask is more simple than the triangular masking of causal attention\n            # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n            attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n            # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n            # masked positions, this operation will create a tensor which is 0.0 for\n            # positions we want to attend and -10000.0 for masked positions.\n            # Since we are adding it to the raw scores before the softmax, this is\n            # effectively the same as removing these entirely.\n            attention_mask = attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility\n            attention_mask = (1.0 - attention_mask) * -10000.0\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # head_mask has shape n_layer x batch x n_heads x N x N\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.n_layer\n\n        input_shape = input_ids.size()\n        input_ids = input_ids.view(-1, input_ids.size(-1))\n        position_ids = position_ids.view(-1, position_ids.size(-1))\n\n        inputs_embeds = self.tokens_embed(input_ids)\n        position_embeds = self.positions_embed(position_ids)\n        if token_type_ids is not None:\n            token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1))\n            token_type_embeds = self.tokens_embed(token_type_ids)\n        else:\n            token_type_embeds = 0\n        hidden_states = inputs_embeds + position_embeds + token_type_embeds\n        hidden_states = self.drop(hidden_states)\n\n        output_shape = input_shape + (hidden_states.size(-1),)\n\n        all_attentions = ()\n        all_hidden_states = ()\n        for i, block in enumerate(self.h):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states.view(*output_shape),)\n\n            outputs = block(hidden_states, attention_mask, head_mask[i])\n            hidden_states = outputs[0]\n            if self.output_attentions:\n                all_attentions = all_attentions + (outputs[1],)\n\n        # Add last layer\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states.view(*output_shape),)\n\n        outputs = (hidden_states.view(*output_shape),)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (all_attentions,)\n        return outputs  # last hidden state, (all hidden states), (all attentions)\n\n\n@add_start_docstrings(""""""OpenAI GPT Model transformer with a language modeling head on top\n(linear layer with weights tied to the input embeddings). """""", OPENAI_GPT_START_DOCSTRING, OPENAI_GPT_INPUTS_DOCSTRING)\nclass OpenAIGPTLMHeadModel(OpenAIGPTPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = OpenAIGPTTokenizer.from_pretrained(\'openai-gpt\')\n        model = OpenAIGPTLMHeadModel.from_pretrained(\'openai-gpt\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=input_ids)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(OpenAIGPTLMHeadModel, self).__init__(config)\n        self.transformer = OpenAIGPTModel(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.tokens_embed)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n        lm_logits = self.lm_head(hidden_states)\n\n        outputs = (lm_logits,) + transformer_outputs[1:]\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), lm_logits, (all hidden states), (all attentions)\n\n\n@add_start_docstrings(""""""OpenAI GPT Model transformer with a language modeling and a multiple-choice classification\nhead on top e.g. for RocStories/SWAG tasks. The two heads are two linear layers.\nThe language modeling head has its weights tied to the input embeddings,\nthe classification head takes as input the input of a specified classification token index in the input sequence).\n"""""", OPENAI_GPT_START_DOCSTRING, OPENAI_GPT_INPUTS_DOCSTRING)\nclass OpenAIGPTDoubleHeadsModel(OpenAIGPTPreTrainedModel):\n    r""""""\n        **mc_token_ids**: (`optional`, default to index of the last token of the input) ``torch.LongTensor`` of shape ``(batch_size, num_choices)``:\n            Index of the classification token in each input sequence.\n            Selected in the range ``[0, input_ids.size(-1) - 1[``.\n        **lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n        **mc_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n            `multiple_choice_labels`: optional multiple choice labels: ``torch.LongTensor`` of shape [batch_size]\n                with indices selected in [0, ..., num_choices].\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **lm_loss**: (`optional`, returned when ``lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **mc_loss**: (`optional`, returned when ``multiple_choice_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Multiple choice classification loss.\n        **lm_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **mc_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)``\n            Prediction scores of the multiplechoice classification head (scores for each choice before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = OpenAIGPTTokenizer.from_pretrained(\'openai-gpt\')\n        model = OpenAIGPTDoubleHeadsModel.from_pretrained(\'openai-gpt\')\n        tokenizer.add_special_tokens({\'cls_token\': \'[CLS]\'})  # Add a [CLS] to the vocabulary (we should train it also!)\n        choices = [""Hello, my dog is cute [CLS]"", ""Hello, my cat is cute [CLS]""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        mc_token_ids = torch.tensor([input_ids.size(-1), input_ids.size(-1)]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, mc_token_ids=mc_token_ids)\n        lm_prediction_scores, mc_prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(OpenAIGPTDoubleHeadsModel, self).__init__(config)\n\n        self.transformer = OpenAIGPTModel(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n        self.multiple_choice_head = SequenceSummary(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.tokens_embed)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                mc_token_ids=None, lm_labels=None, mc_labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states)\n        mc_logits = self.multiple_choice_head(hidden_states, mc_token_ids).squeeze(-1)\n\n        outputs = (lm_logits, mc_logits) + transformer_outputs[1:]\n        if mc_labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(mc_logits.view(-1, mc_logits.size(-1)),\n                            mc_labels.view(-1))\n            outputs = (loss,) + outputs\n        if lm_labels is not None:\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = lm_labels[..., 1:].contiguous()\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (lm loss), (mc loss), lm logits, mc logits, (all hidden_states), (attentions)\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_roberta.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch RoBERTa model. """"""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_bert import BertEmbeddings, BertLayerNorm, BertModel, BertPreTrainedModel, gelu\nfrom .configuration_roberta import RobertaConfig\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-pytorch_model.bin"",\n    \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-pytorch_model.bin"",\n    \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-pytorch_model.bin"",\n}\n\nclass RobertaEmbeddings(BertEmbeddings):\n    """"""\n    Same as BertEmbeddings with a tiny tweak for positional embeddings indexing.\n    """"""\n    def __init__(self, config):\n        super(RobertaEmbeddings, self).__init__(config)\n        self.padding_idx = 1\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=self.padding_idx)\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size,\n                                                padding_idx=self.padding_idx)\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            # Position numbers begin at padding_idx+1. Padding symbols are ignored.\n            # cf. fairseq\'s `utils.make_positions`\n            position_ids = torch.arange(self.padding_idx+1, seq_length+self.padding_idx+1, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        return super(RobertaEmbeddings, self).forward(input_ids,\n                                                      token_type_ids=token_type_ids,\n                                                      position_ids=position_ids)\n\n\nROBERTA_START_DOCSTRING = r""""""    The RoBERTa model was proposed in\n    `RoBERTa: A Robustly Optimized BERT Pretraining Approach`_\n    by Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer,\n    Veselin Stoyanov. It is based on Google\'s BERT model released in 2018.\n    \n    It builds on BERT and modifies key hyperparameters, removing the next-sentence pretraining\n    objective and training with much larger mini-batches and learning rates.\n    \n    This implementation is the same as BertModel with a tiny embeddings tweak as well as a setup for Roberta pretrained \n    models.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`RoBERTa: A Robustly Optimized BERT Pretraining Approach`:\n        https://arxiv.org/abs/1907.11692\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.RobertaConfig`): Model configuration class with all the parameters of the \n            model. Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nROBERTA_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            To match pre-training, RoBERTa input sequence should be formatted with <s> and </s> tokens as follows:\n\n            (a) For sequence pairs:\n\n                ``tokens:         <s> Is this Jacksonville ? </s> </s> No it is not . </s>``\n\n            (b) For single sequences:\n\n                ``tokens:         <s> the dog is hairy . </s>``\n\n            Fully encoded sequences or sequence pairs can be obtained using the RobertaTokenizer.encode function with \n            the ``add_special_tokens`` parameter set to ``True``.\n\n            RoBERTa is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **token_type_ids**: (`optional` need to be trained) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Optional segment token indices to indicate first and second portions of the inputs.\n            This embedding matrice is not trained (not pretrained during RoBERTa pretraining), you will have to train it\n            during finetuning.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n            corresponds to a `sentence B` token\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1[``.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare RoBERTa Model transformer outputting raw hidden-states without any specific head on top."",\n                      ROBERTA_START_DOCSTRING, ROBERTA_INPUTS_DOCSTRING)\nclass RobertaModel(BertModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the output of the last layer of the model.\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\n            Last layer hidden-state of the first token of the sequence (classification token)\n            further processed by a Linear layer and a Tanh activation function. The Linear\n            layer weights are trained from the next sentence prediction (classification)\n            objective during Bert pretraining. This output is usually *not* a good summary\n            of the semantic content of the input, you\'re often better with averaging or pooling\n            the sequence of hidden-states for the whole input sequence.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = RobertaTokenizer.from_pretrained(\'roberta-base\')\n        model = RobertaModel.from_pretrained(\'roberta-base\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    config_class = RobertaConfig\n    pretrained_model_archive_map = ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""roberta""\n\n    def __init__(self, config):\n        super(RobertaModel, self).__init__(config)\n\n        self.embeddings = RobertaEmbeddings(config)\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\n        if input_ids[:, 0].sum().item() != 0:\n            logger.warning(""A sequence with no special tokens has been passed to the RoBERTa model. ""\n                           ""This model requires special tokens in order to work. ""\n                           ""Please specify add_special_tokens=True in your tokenize.encode()""\n                           ""or tokenizer.convert_tokens_to_ids()."")\n        return super(RobertaModel, self).forward(input_ids,\n                                                 attention_mask=attention_mask,\n                                                 token_type_ids=token_type_ids,\n                                                 position_ids=position_ids,\n                                                 head_mask=head_mask)\n\n\n@add_start_docstrings(""""""RoBERTa Model with a `language modeling` head on top. """""",\n    ROBERTA_START_DOCSTRING, ROBERTA_INPUTS_DOCSTRING)\nclass RobertaForMaskedLM(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Masked language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = RobertaTokenizer.from_pretrained(\'roberta-base\')\n        model = RobertaForMaskedLM.from_pretrained(\'roberta-base\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, masked_lm_labels=input_ids)\n        loss, prediction_scores = outputs[:2]\n\n    """"""\n    config_class = RobertaConfig\n    pretrained_model_archive_map = ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""roberta""\n\n    def __init__(self, config):\n        super(RobertaForMaskedLM, self).__init__(config)\n\n        self.roberta = RobertaModel(config)\n        self.lm_head = RobertaLMHead(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head.decoder, self.roberta.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                masked_lm_labels=None):\n        outputs = self.roberta(input_ids,\n                               attention_mask=attention_mask,\n                               token_type_ids=token_type_ids,\n                               position_ids=position_ids,\n                               head_mask=head_mask)\n        sequence_output = outputs[0]\n        prediction_scores = self.lm_head(sequence_output)\n\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\n\n        if masked_lm_labels is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            outputs = (masked_lm_loss,) + outputs\n\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\n\n\nclass RobertaLMHead(nn.Module):\n    """"""Roberta Head for masked language modeling.""""""\n\n    def __init__(self, config):\n        super(RobertaLMHead, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.layer_norm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n\n        self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\n\n    def forward(self, features, **kwargs):\n        x = self.dense(features)\n        x = gelu(x)\n        x = self.layer_norm(x)\n\n        # project back to size of vocabulary with bias\n        x = self.decoder(x) + self.bias\n\n        return x\n\n\n@add_start_docstrings(""""""RoBERTa Model transformer with a sequence classification/regression head on top (a linear layer \n    on top of the pooled output) e.g. for GLUE tasks. """""",\n    ROBERTA_START_DOCSTRING, ROBERTA_INPUTS_DOCSTRING)\nclass RobertaForSequenceClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = RobertaTokenizer.from_pretrained(\'roberta-base\')\n        model = RobertaForSequenceClassification.from_pretrained(\'roberta-base\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    config_class = RobertaConfig\n    pretrained_model_archive_map = ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""roberta""\n\n    def __init__(self, config):\n        super(RobertaForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.roberta = RobertaModel(config)\n        self.classifier = RobertaClassificationHead(config)\n    \n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                labels=None):\n        outputs = self.roberta(input_ids,\n                               attention_mask=attention_mask,\n                               token_type_ids=token_type_ids,\n                               position_ids=position_ids,\n                               head_mask=head_mask)\n        sequence_output = outputs[0]\n        logits = self.classifier(sequence_output)\n\n        outputs = (logits,) + outputs[2:]\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), logits, (hidden_states), (attentions)\n\n@add_start_docstrings(""""""Roberta Model with a multiple choice classification head on top (a linear layer on top of\n    the pooled output and a softmax) e.g. for RocStories/SWAG tasks. """""",\n    ROBERTA_START_DOCSTRING, ROBERTA_INPUTS_DOCSTRING)\nclass RobertaForMultipleChoice(BertPreTrainedModel):\n    r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            To match pre-training, RoBerta input sequence should be formatted with [CLS] and [SEP] tokens as follows:\n\n            (a) For sequence pairs:\n\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] [SEP] no it is not . [SEP]``\n\n                ``token_type_ids:   0   0  0    0    0     0       0   0   0     1  1  1  1   1   1``\n\n            (b) For single sequences:\n\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\n\n                ``token_type_ids:   0   0   0   0  0     0   0``\n\n            Indices can be obtained using :class:`transformers.BertTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Segment token indices to indicate first and second portions of the inputs.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above).\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = RobertaTokenizer.from_pretrained(\'roberta-base\')\n        model = RobertaForMultipleChoice.from_pretrained(\'roberta-base\')\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\n        input_ids = torch.tensor([tokenizer.encode(s, add_special_tokens=True) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, classification_scores = outputs[:2]\n\n    """"""\n    config_class = RobertaConfig\n    pretrained_model_archive_map = ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""roberta""\n\n    def __init__(self, config):\n        super(RobertaForMultipleChoice, self).__init__(config)\n\n        self.roberta = RobertaModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n\n        self.init_weights()\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None,\n                position_ids=None, head_mask=None):\n        num_choices = input_ids.shape[1]\n\n        flat_input_ids = input_ids.view(-1, input_ids.size(-1))\n        flat_position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None\n        flat_token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\n        flat_attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\n        outputs = self.roberta(flat_input_ids, position_ids=flat_position_ids, token_type_ids=flat_token_type_ids,\n                            attention_mask=flat_attention_mask, head_mask=head_mask)\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, num_choices)\n\n        outputs = (reshaped_logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), reshaped_logits, (hidden_states), (attentions)\n\n\n\nclass RobertaClassificationHead(nn.Module):\n    """"""Head for sentence-level classification tasks.""""""\n\n    def __init__(self, config):\n        super(RobertaClassificationHead, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.out_proj = nn.Linear(config.hidden_size, config.num_labels)\n\n    def forward(self, features, **kwargs):\n        x = features[:, 0, :]  # take <s> token (equiv. to [CLS])\n        x = self.dropout(x)\n        x = self.dense(x)\n        x = torch.tanh(x)\n        x = self.dropout(x)\n        x = self.out_proj(x)\n        return x\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_transfo_xl.py,2,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" PyTorch Transformer XL model.\n    Adapted from https://github.com/kimiyoung/transformer-xl.\n    In particular https://github.com/kimiyoung/transformer-xl/blob/master/pytorch/mem_transformer.py\n""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport os\nimport json\nimport math\nimport logging\nimport collections\nimport sys\nfrom io import open\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn.parameter import Parameter\n\nfrom .modeling_utils import PreTrainedModel, Conv1D, prune_conv1d_layer, SequenceSummary\nfrom .configuration_transfo_xl import TransfoXLConfig\nfrom .modeling_transfo_xl_utilities import ProjectedAdaptiveLogSoftmax, sample_logits\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nTRANSFO_XL_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-pytorch_model.bin"",\n}\n\ndef build_tf_to_pytorch_map(model, config):\n    """""" A map of modules from TF to PyTorch.\n        This time I use a map to keep the PyTorch model as identical to the original PyTorch model as possible.\n    """"""\n    tf_to_pt_map = {}\n\n    if hasattr(model, \'transformer\'):\n        # We are loading in a TransfoXLLMHeadModel => we will load also the Adaptive Softmax\n        tf_to_pt_map.update({\n            ""transformer/adaptive_softmax/cutoff_0/cluster_W"": model.crit.cluster_weight,\n            ""transformer/adaptive_softmax/cutoff_0/cluster_b"": model.crit.cluster_bias})\n        for i, (out_l, proj_l, tie_proj) in enumerate(zip(\n                                model.crit.out_layers,\n                                model.crit.out_projs,\n                                config.tie_projs)):\n            layer_str = ""transformer/adaptive_softmax/cutoff_%d/"" % i\n            if config.tie_weight:\n                tf_to_pt_map.update({\n                    layer_str + \'b\': out_l.bias})\n            else:\n                raise NotImplementedError\n                # I don\'t think this is implemented in the TF code\n                tf_to_pt_map.update({\n                    layer_str + \'lookup_table\': out_l.weight,\n                    layer_str + \'b\': out_l.bias})\n            if not tie_proj:\n                tf_to_pt_map.update({\n                    layer_str + \'proj\': proj_l\n                    })\n        # Now load the rest of the transformer\n        model = model.transformer\n\n    # Embeddings\n    for i, (embed_l, proj_l) in enumerate(zip(model.word_emb.emb_layers, model.word_emb.emb_projs)):\n        layer_str = ""transformer/adaptive_embed/cutoff_%d/"" % i\n        tf_to_pt_map.update({\n            layer_str + \'lookup_table\': embed_l.weight,\n            layer_str + \'proj_W\': proj_l\n            })\n\n    # Transformer blocks\n    for i, b in enumerate(model.layers):\n        layer_str = ""transformer/layer_%d/"" % i\n        tf_to_pt_map.update({\n            layer_str + ""rel_attn/LayerNorm/gamma"": b.dec_attn.layer_norm.weight,\n            layer_str + ""rel_attn/LayerNorm/beta"": b.dec_attn.layer_norm.bias,\n            layer_str + ""rel_attn/o/kernel"": b.dec_attn.o_net.weight,\n            layer_str + ""rel_attn/qkv/kernel"": b.dec_attn.qkv_net.weight,\n            layer_str + ""rel_attn/r/kernel"": b.dec_attn.r_net.weight,\n            layer_str + ""ff/LayerNorm/gamma"": b.pos_ff.layer_norm.weight,\n            layer_str + ""ff/LayerNorm/beta"": b.pos_ff.layer_norm.bias,\n            layer_str + ""ff/layer_1/kernel"": b.pos_ff.CoreNet[0].weight,\n            layer_str + ""ff/layer_1/bias"": b.pos_ff.CoreNet[0].bias,\n            layer_str + ""ff/layer_2/kernel"": b.pos_ff.CoreNet[3].weight,\n            layer_str + ""ff/layer_2/bias"": b.pos_ff.CoreNet[3].bias,\n        })\n\n    # Relative positioning biases\n    if config.untie_r:\n        r_r_list = []\n        r_w_list = []\n        for b in model.layers:\n            r_r_list.append(b.dec_attn.r_r_bias)\n            r_w_list.append(b.dec_attn.r_w_bias)\n    else:\n        r_r_list = [model.r_r_bias]\n        r_w_list = [model.r_w_bias]\n    tf_to_pt_map.update({\n        \'transformer/r_r_bias\': r_r_list,\n        \'transformer/r_w_bias\': r_w_list})\n    return tf_to_pt_map\n\ndef load_tf_weights_in_transfo_xl(model, config, tf_path):\n    """""" Load tf checkpoints in a pytorch model\n    """"""\n    try:\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow models in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    # Build TF to PyTorch weights loading map\n    tf_to_pt_map = build_tf_to_pytorch_map(model, config)\n\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    tf_weights = {}\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        tf_weights[name] = array\n\n    for name, pointer in tf_to_pt_map.items():\n        assert name in tf_weights\n        array = tf_weights[name]\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if \'kernel\' in name or \'proj\' in name:\n            array = np.transpose(array)\n        if (\'r_r_bias\' in name or \'r_w_bias\' in name) and len(pointer) > 1:\n            # Here we will split the TF weigths\n            assert len(pointer) == array.shape[0]\n            for i, p_i in enumerate(pointer):\n                arr_i = array[i, ...]\n                try:\n                    assert p_i.shape == arr_i.shape\n                except AssertionError as e:\n                    e.args += (p_i.shape, arr_i.shape)\n                    raise\n                logger.info(""Initialize PyTorch weight {} for layer {}"".format(name, i))\n                p_i.data = torch.from_numpy(arr_i)\n        else:\n            try:\n                assert pointer.shape == array.shape\n            except AssertionError as e:\n                e.args += (pointer.shape, array.shape)\n                raise\n            logger.info(""Initialize PyTorch weight {}"".format(name))\n            pointer.data = torch.from_numpy(array)\n        tf_weights.pop(name, None)\n        tf_weights.pop(name + \'/Adam\', None)\n        tf_weights.pop(name + \'/Adam_1\', None)\n\n    logger.info(""Weights not copied to PyTorch model: {}"".format(\', \'.join(tf_weights.keys())))\n    return model\n\n\nclass PositionalEmbedding(nn.Module):\n    def __init__(self, demb):\n        super(PositionalEmbedding, self).__init__()\n\n        self.demb = demb\n\n        inv_freq = 1 / (10000 ** (torch.arange(0.0, demb, 2.0) / demb))\n        self.register_buffer(\'inv_freq\', inv_freq)\n\n    def forward(self, pos_seq, bsz=None):\n        sinusoid_inp = torch.ger(pos_seq, self.inv_freq)\n        pos_emb = torch.cat([sinusoid_inp.sin(), sinusoid_inp.cos()], dim=-1)\n\n        if bsz is not None:\n            return pos_emb[:,None,:].expand(-1, bsz, -1)\n        else:\n            return pos_emb[:,None,:]\n\n\n\nclass PositionwiseFF(nn.Module):\n    def __init__(self, d_model, d_inner, dropout, pre_lnorm=False, layer_norm_epsilon=1e-5):\n        super(PositionwiseFF, self).__init__()\n\n        self.d_model = d_model\n        self.d_inner = d_inner\n        self.dropout = dropout\n\n        self.CoreNet = nn.Sequential(\n            nn.Linear(d_model, d_inner), nn.ReLU(inplace=True),\n            nn.Dropout(dropout),\n            nn.Linear(d_inner, d_model),\n            nn.Dropout(dropout),\n        )\n\n        self.layer_norm = nn.LayerNorm(d_model, eps=layer_norm_epsilon)\n\n        self.pre_lnorm = pre_lnorm\n\n    def forward(self, inp):\n        if self.pre_lnorm:\n            ##### layer normalization + positionwise feed-forward\n            core_out = self.CoreNet(self.layer_norm(inp))\n\n            ##### residual connection\n            output = core_out + inp\n        else:\n            ##### positionwise feed-forward\n            core_out = self.CoreNet(inp)\n\n            ##### residual connection + layer normalization\n            output = self.layer_norm(inp + core_out)\n\n        return output\n\n\nclass RelPartialLearnableMultiHeadAttn(nn.Module):\n    def __init__(self, n_head, d_model, d_head, dropout, dropatt=0,\n                 tgt_len=None, ext_len=None, mem_len=None, pre_lnorm=False,\n                 r_r_bias=None, r_w_bias=None, output_attentions=False,\n                 layer_norm_epsilon=1e-5):\n        super(RelPartialLearnableMultiHeadAttn, self).__init__()\n\n        self.output_attentions = output_attentions\n        self.n_head = n_head\n        self.d_model = d_model\n        self.d_head = d_head\n        self.dropout = dropout\n\n        self.qkv_net = nn.Linear(d_model, 3 * n_head * d_head, bias=False)\n\n        self.drop = nn.Dropout(dropout)\n        self.dropatt = nn.Dropout(dropatt)\n        self.o_net = nn.Linear(n_head * d_head, d_model, bias=False)\n\n        self.layer_norm = nn.LayerNorm(d_model, eps=layer_norm_epsilon)\n\n        self.scale = 1 / (d_head ** 0.5)\n\n        self.pre_lnorm = pre_lnorm\n\n        if r_r_bias is None or r_w_bias is None: # Biases are not shared\n            self.r_r_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n            self.r_w_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        else:\n            self.r_r_bias = r_r_bias\n            self.r_w_bias = r_w_bias\n\n        self.r_net = nn.Linear(self.d_model, self.n_head * self.d_head, bias=False)\n\n    def _rel_shift(self, x):\n        zero_pad_shape = (x.size(0), 1) + x.size()[2:]\n        zero_pad = torch.zeros(zero_pad_shape, device=x.device, dtype=x.dtype)\n        x_padded = torch.cat([zero_pad, x], dim=1)\n\n        x_padded_shape = (x.size(1) + 1, x.size(0)) + x.size()[2:]\n        x_padded = x_padded.view(*x_padded_shape)\n\n        x = x_padded[1:].view_as(x)\n\n        return x\n\n    def forward(self, w, r, attn_mask=None, mems=None, head_mask=None):\n        qlen, rlen, bsz = w.size(0), r.size(0), w.size(1)\n\n        if mems is not None:\n            cat = torch.cat([mems, w], 0)\n            if self.pre_lnorm:\n                w_heads = self.qkv_net(self.layer_norm(cat))\n            else:\n                w_heads = self.qkv_net(cat)\n            r_head_k = self.r_net(r)\n\n            w_head_q, w_head_k, w_head_v = torch.chunk(w_heads, 3, dim=-1)\n            w_head_q = w_head_q[-qlen:]\n        else:\n            if self.pre_lnorm:\n                w_heads = self.qkv_net(self.layer_norm(w))\n            else:\n                w_heads = self.qkv_net(w)\n            r_head_k = self.r_net(r)\n\n            w_head_q, w_head_k, w_head_v = torch.chunk(w_heads, 3, dim=-1)\n\n        klen = w_head_k.size(0)\n\n        w_head_q = w_head_q.view(qlen, bsz, self.n_head, self.d_head)           # qlen x bsz x n_head x d_head\n        w_head_k = w_head_k.view(klen, bsz, self.n_head, self.d_head)           # qlen x bsz x n_head x d_head\n        w_head_v = w_head_v.view(klen, bsz, self.n_head, self.d_head)           # qlen x bsz x n_head x d_head\n\n        r_head_k = r_head_k.view(rlen, self.n_head, self.d_head)                # qlen x n_head x d_head\n\n        #### compute attention score\n        rw_head_q = w_head_q + self.r_w_bias                                    # qlen x bsz x n_head x d_head\n        AC = torch.einsum(\'ibnd,jbnd->ijbn\', (rw_head_q, w_head_k))             # qlen x klen x bsz x n_head\n\n        rr_head_q = w_head_q + self.r_r_bias\n        BD = torch.einsum(\'ibnd,jnd->ijbn\', (rr_head_q, r_head_k))              # qlen x klen x bsz x n_head\n        BD = self._rel_shift(BD)\n\n        # [qlen x klen x bsz x n_head]\n        attn_score = AC + BD\n        attn_score.mul_(self.scale)\n\n        #### compute attention probability\n        if attn_mask is not None and torch.sum(attn_mask).item():\n            attn_mask = (attn_mask == 1)  # Switch to bool\n            if attn_mask.dim() == 2:\n                if next(self.parameters()).dtype == torch.float16:\n                    attn_score = attn_score.float().masked_fill(\n                        attn_mask[None,:,:,None], -65000).type_as(attn_score)\n                else:\n                    attn_score = attn_score.float().masked_fill(\n                        attn_mask[None,:,:,None], -1e30).type_as(attn_score)\n            elif attn_mask.dim() == 3:\n                if next(self.parameters()).dtype == torch.float16:\n                    attn_score = attn_score.float().masked_fill(\n                        attn_mask[:,:,:,None], -65000).type_as(attn_score)\n                else:\n                    attn_score = attn_score.float().masked_fill(\n                        attn_mask[:,:,:,None], -1e30).type_as(attn_score)\n\n        # [qlen x klen x bsz x n_head]\n        attn_prob = F.softmax(attn_score, dim=1)\n        attn_prob = self.dropatt(attn_prob)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attn_prob = attn_prob * head_mask\n\n        #### compute attention vector\n        attn_vec = torch.einsum(\'ijbn,jbnd->ibnd\', (attn_prob, w_head_v))\n\n        # [qlen x bsz x n_head x d_head]\n        attn_vec = attn_vec.contiguous().view(\n            attn_vec.size(0), attn_vec.size(1), self.n_head * self.d_head)\n\n        ##### linear projection\n        attn_out = self.o_net(attn_vec)\n        attn_out = self.drop(attn_out)\n\n        if self.pre_lnorm:\n            ##### residual connection\n            outputs = [w + attn_out]\n        else:\n            ##### residual connection + layer normalization\n            outputs = [self.layer_norm(w + attn_out)]\n\n        if self.output_attentions:\n            outputs.append(attn_prob)\n\n        return outputs\n\n\nclass RelPartialLearnableDecoderLayer(nn.Module):\n    def __init__(self, n_head, d_model, d_head, d_inner, dropout, layer_norm_epsilon=1e-5,\n                 **kwargs):\n        super(RelPartialLearnableDecoderLayer, self).__init__()\n\n        self.dec_attn = RelPartialLearnableMultiHeadAttn(n_head, d_model,\n                            d_head, dropout, layer_norm_epsilon=layer_norm_epsilon, **kwargs)\n        self.pos_ff = PositionwiseFF(d_model, d_inner, dropout, \n                                     pre_lnorm=kwargs.get(\'pre_lnorm\'),\n                                     layer_norm_epsilon=layer_norm_epsilon)\n\n    def forward(self, dec_inp, r, dec_attn_mask=None, mems=None, head_mask=None):\n\n        attn_outputs = self.dec_attn(dec_inp, r,\n                               attn_mask=dec_attn_mask,\n                               mems=mems, head_mask=head_mask)\n        ff_output = self.pos_ff(attn_outputs[0])\n\n        outputs = [ff_output] + attn_outputs[1:]\n\n        return outputs\n\n\nclass AdaptiveEmbedding(nn.Module):\n    def __init__(self, n_token, d_embed, d_proj, cutoffs, div_val=1,\n                 sample_softmax=False):\n        super(AdaptiveEmbedding, self).__init__()\n\n        self.n_token = n_token\n        self.d_embed = d_embed\n\n        self.cutoffs = cutoffs + [n_token]\n        self.div_val = div_val\n        self.d_proj = d_proj\n\n        self.emb_scale = d_proj ** 0.5\n\n        self.cutoff_ends = [0] + self.cutoffs\n\n        self.emb_layers = nn.ModuleList()\n        self.emb_projs = nn.ParameterList()\n        if div_val == 1:\n            self.emb_layers.append(\n                nn.Embedding(n_token, d_embed, sparse=sample_softmax>0)\n            )\n            if d_proj != d_embed:\n                self.emb_projs.append(nn.Parameter(torch.FloatTensor(d_proj, d_embed)))\n        else:\n            for i in range(len(self.cutoffs)):\n                l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i+1]\n                d_emb_i = d_embed // (div_val ** i)\n                self.emb_layers.append(nn.Embedding(r_idx-l_idx, d_emb_i))\n                self.emb_projs.append(nn.Parameter(torch.FloatTensor(d_proj, d_emb_i)))\n\n    def forward(self, inp):\n        if self.div_val == 1:\n            embed = self.emb_layers[0](inp)\n            if self.d_proj != self.d_embed:\n                embed  = F.linear(embed, self.emb_projs[0])\n        else:\n            param = next(self.parameters())\n            inp_flat = inp.view(-1)\n            emb_flat = torch.zeros([inp_flat.size(0), self.d_proj],\n                dtype=param.dtype, device=param.device)\n            for i in range(len(self.cutoffs)):\n                l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i + 1]\n\n                mask_i = (inp_flat >= l_idx) & (inp_flat < r_idx)\n                indices_i = mask_i.nonzero().squeeze()\n\n                if indices_i.numel() == 0:\n                    continue\n\n                inp_i = inp_flat.index_select(0, indices_i) - l_idx\n                emb_i = self.emb_layers[i](inp_i)\n                emb_i = F.linear(emb_i, self.emb_projs[i])\n\n                emb_flat.index_copy_(0, indices_i, emb_i)\n\n            embed_shape = inp.size() + (self.d_proj,)\n            embed = emb_flat.view(embed_shape)\n\n        embed.mul_(self.emb_scale)\n\n        return embed\n\n\nclass TransfoXLPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = TransfoXLConfig\n    pretrained_model_archive_map = TRANSFO_XL_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_transfo_xl\n    base_model_prefix = ""transformer""\n\n    def _init_weight(self, weight):\n        if self.config.init == \'uniform\':\n            nn.init.uniform_(weight, -self.config.init_range, self.config.init_range)\n        elif self.config.init == \'normal\':\n            nn.init.normal_(weight, 0.0, self.config.init_std)\n\n    def _init_bias(self, bias):\n        nn.init.constant_(bias, 0.0)\n\n    def _init_weights(self, m):\n        """""" Initialize the weights.\n        """"""\n        classname = m.__class__.__name__\n        if classname.find(\'Linear\') != -1:\n            if hasattr(m, \'weight\') and m.weight is not None:\n                self._init_weight(m.weight)\n            if hasattr(m, \'bias\') and m.bias is not None:\n                self._init_bias(m.bias)\n        elif classname.find(\'AdaptiveEmbedding\') != -1:\n            if hasattr(m, \'emb_projs\'):\n                for i in range(len(m.emb_projs)):\n                    if m.emb_projs[i] is not None:\n                        nn.init.normal_(m.emb_projs[i], 0.0, self.config.proj_init_std)\n        elif classname.find(\'Embedding\') != -1:\n            if hasattr(m, \'weight\'):\n                self._init_weight(m.weight)\n        elif classname.find(\'ProjectedAdaptiveLogSoftmax\') != -1:\n            if hasattr(m, \'cluster_weight\') and m.cluster_weight is not None:\n                self._init_weight(m.cluster_weight)\n            if hasattr(m, \'cluster_bias\') and m.cluster_bias is not None:\n                self._init_bias(m.cluster_bias)\n            if hasattr(m, \'out_projs\'):\n                for i in range(len(m.out_projs)):\n                    if m.out_projs[i] is not None:\n                        nn.init.normal_(m.out_projs[i], 0.0, self.config.proj_init_std)\n        elif classname.find(\'LayerNorm\') != -1:\n            if hasattr(m, \'weight\'):\n                nn.init.normal_(m.weight, 1.0, self.config.init_std)\n            if hasattr(m, \'bias\') and m.bias is not None:\n                self._init_bias(m.bias)\n        else:\n            if hasattr(m, \'r_emb\'):\n                self._init_weight(m.r_emb)\n            if hasattr(m, \'r_w_bias\'):\n                self._init_weight(m.r_w_bias)\n            if hasattr(m, \'r_r_bias\'):\n                self._init_weight(m.r_r_bias)\n            if hasattr(m, \'r_bias\'):\n                self._init_bias(m.r_bias)\n\n\nTRANSFO_XL_START_DOCSTRING = r""""""    The Transformer-XL model was proposed in\n    `Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context`_\n    by Zihang Dai*, Zhilin Yang*, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov.\n    It\'s a causal (uni-directional) transformer with relative positioning (sinuso\xc3\xafdal) embeddings which can reuse\n    previously computed hidden-states to attend to longer context (memory).\n    This model also uses adaptive softmax inputs and outputs (tied).\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context`:\n        https://arxiv.org/abs/1901.02860\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.TransfoXLConfig`): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nTRANSFO_XL_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            Transformer-XL is a model with relative position embeddings so you can either pad the inputs on\n            the right or on the left.\n            Indices can be obtained using :class:`transformers.TransfoXLTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **mems**: (`optional`)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` output below). Can be used to speed up sequential decoding and attend to longer context.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare Bert Model transformer outputting raw hidden-states without any specific head on top."",\n                      TRANSFO_XL_START_DOCSTRING, TRANSFO_XL_INPUTS_DOCSTRING)\nclass TransfoXLModel(TransfoXLPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = TransfoXLTokenizer.from_pretrained(\'transfo-xl-wt103\')\n        model = TransfoXLModel.from_pretrained(\'transfo-xl-wt103\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states, mems = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(TransfoXLModel, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        self.n_token = config.n_token\n\n        self.d_embed = config.d_embed\n        self.d_model = config.d_model\n        self.n_head = config.n_head\n        self.d_head = config.d_head\n\n        self.word_emb = AdaptiveEmbedding(config.n_token, config.d_embed, config.d_model, config.cutoffs,\n                                          div_val=config.div_val)\n\n        self.drop = nn.Dropout(config.dropout)\n\n        self.n_layer = config.n_layer\n\n        self.tgt_len = config.tgt_len\n        self.mem_len = config.mem_len\n        self.ext_len = config.ext_len\n        self.max_klen = config.tgt_len + config.ext_len + config.mem_len\n\n        self.attn_type = config.attn_type\n\n        if not config.untie_r:\n            self.r_w_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n            self.r_r_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n\n        self.layers = nn.ModuleList()\n        if config.attn_type == 0: # the default attention\n            for i in range(config.n_layer):\n                self.layers.append(\n                    RelPartialLearnableDecoderLayer(\n                        config.n_head, config.d_model, config.d_head, config.d_inner, config.dropout,\n                        tgt_len=config.tgt_len, ext_len=config.ext_len, mem_len=config.mem_len,\n                        dropatt=config.dropatt, pre_lnorm=config.pre_lnorm,\n                        r_w_bias=None if config.untie_r else self.r_w_bias,\n                        r_r_bias=None if config.untie_r else self.r_r_bias,\n                        output_attentions=self.output_attentions,\n                        layer_norm_epsilon=config.layer_norm_epsilon)\n                )\n        else: # learnable embeddings and absolute embeddings are not used in our pretrained checkpoints\n            raise NotImplementedError  # Removed them to avoid maintaining dead code\n\n        self.same_length = config.same_length\n        self.clamp_len = config.clamp_len\n\n        if self.attn_type == 0: # default attention\n            self.pos_emb = PositionalEmbedding(self.d_model)\n        else: # learnable embeddings and absolute embeddings\n            raise NotImplementedError  # Removed these to avoid maintaining dead code - They are not used in our pretrained checkpoint\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        return self.word_emb\n\n    def backward_compatible(self):\n        self.sample_softmax = -1\n\n    def reset_length(self, tgt_len, ext_len, mem_len):\n        self.tgt_len = tgt_len\n        self.mem_len = mem_len\n        self.ext_len = ext_len\n\n    def _prune_heads(self, heads):\n        logger.info(""Head pruning is not implemented for Transformer-XL model"")\n        pass\n\n    def init_mems(self, data):\n        if self.mem_len > 0:\n            mems = []\n            param = next(self.parameters())\n            for i in range(self.n_layer):\n                empty = torch.zeros(self.mem_len, data.size(1), self.config.d_model,\n                                    dtype=param.dtype, device=param.device)\n                mems.append(empty)\n\n            return mems\n        else:\n            return None\n\n    def _update_mems(self, hids, mems, qlen, mlen):\n        # does not deal with None\n        if mems is None: return None\n\n        # mems is not None\n        assert len(hids) == len(mems), \'len(hids) != len(mems)\'\n\n        # There are `mlen + qlen` steps that can be cached into mems\n        # For the next step, the last `ext_len` of the `qlen` tokens\n        # will be used as the extended context. Hence, we only cache\n        # the tokens from `mlen + qlen - self.ext_len - self.mem_len`\n        # to `mlen + qlen - self.ext_len`.\n        with torch.no_grad():\n            new_mems = []\n            end_idx = mlen + max(0, qlen - 0 - self.ext_len)\n            beg_idx = max(0, end_idx - self.mem_len)\n            for i in range(len(hids)):\n\n                cat = torch.cat([mems[i], hids[i]], dim=0)\n                new_mems.append(cat[beg_idx:end_idx].detach())\n\n        return new_mems\n\n    def forward(self, input_ids, mems=None, head_mask=None):\n        # the original code for Transformer-XL used shapes [len, bsz] but we want a unified interface in the library\n        # so we transpose here from shape [bsz, len] to shape [len, bsz]\n        input_ids = input_ids.transpose(0, 1).contiguous()\n\n        if mems is None:\n            mems = self.init_mems(input_ids)\n\n        qlen, bsz = input_ids.size()\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads] (a head_mask for each layer)\n        # and head_mask is converted to shape [num_hidden_layers x qlen x klen x bsz x n_head]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(0).unsqueeze(0)\n                head_mask = head_mask.expand(self.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(1).unsqueeze(1)\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.n_layer\n\n        word_emb = self.word_emb(input_ids)\n\n        mlen = mems[0].size(0) if mems is not None else 0\n        klen = mlen + qlen\n        if self.same_length:\n            all_ones = word_emb.new_ones((qlen, klen), dtype=torch.uint8)\n            mask_len = klen - self.mem_len\n            if mask_len > 0:\n                mask_shift_len = qlen - mask_len\n            else:\n                mask_shift_len = qlen\n            dec_attn_mask = (torch.triu(all_ones, 1+mlen)\n                    + torch.tril(all_ones, -mask_shift_len))[:, :, None] # -1\n        else:\n            dec_attn_mask = torch.triu(\n                word_emb.new_ones((qlen, klen), dtype=torch.uint8), diagonal=1+mlen)[:,:,None]\n\n        hids = []\n        attentions = []\n        if self.attn_type == 0: # default\n            pos_seq = torch.arange(klen-1, -1, -1.0, device=word_emb.device,\n                                   dtype=word_emb.dtype)\n            if self.clamp_len > 0:\n                pos_seq.clamp_(max=self.clamp_len)\n            pos_emb = self.pos_emb(pos_seq)\n\n            core_out = self.drop(word_emb)\n            pos_emb = self.drop(pos_emb)\n\n            for i, layer in enumerate(self.layers):\n                hids.append(core_out)\n                mems_i = None if mems is None else mems[i]\n                layer_outputs = layer(core_out, pos_emb, dec_attn_mask=dec_attn_mask,\n                                      mems=mems_i, head_mask=head_mask[i])\n                core_out = layer_outputs[0]\n                if self.output_attentions:\n                    attentions.append(layer_outputs[1])\n        else: # learnable embeddings and absolute embeddings\n            raise NotImplementedError  # Removed these to avoid maintaining dead code - They are not used in our pretrained checkpoint\n\n        core_out = self.drop(core_out)\n\n        new_mems = self._update_mems(hids, mems, mlen, qlen)\n\n        # We transpose back here to shape [bsz, len, hidden_dim]\n        outputs = [core_out.transpose(0, 1).contiguous(), new_mems]\n        if self.output_hidden_states:\n            # Add last layer and transpose to library standard shape [bsz, len, hidden_dim]\n            hids.append(core_out)\n            hids = list(t.transpose(0, 1).contiguous() for t in hids)\n            outputs.append(hids)\n        if self.output_attentions:\n            # Transpose to library standard shape [bsz, n_heads, query_seq_len, key_seq_len]\n            attentions = list(t.permute(2, 3, 0, 1).contiguous() for t in attentions)\n            outputs.append(attentions)\n\n        return outputs  # last hidden state, new_mems, (all hidden states), (all attentions)\n\n\n@add_start_docstrings(""""""The Transformer-XL Model with a language modeling head on top\n    (adaptive softmax with weights tied to the adaptive input embeddings)"""""",\n    TRANSFO_XL_START_DOCSTRING, TRANSFO_XL_INPUTS_DOCSTRING)\nclass TransfoXLLMHeadModel(TransfoXLPreTrainedModel):\n    r""""""\n        **lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``None`` if ``lm_labels`` is provided else ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n            We don\'t output them when the loss is computed to speedup adaptive softmax decoding.\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = TransfoXLTokenizer.from_pretrained(\'transfo-xl-wt103\')\n        model = TransfoXLLMHeadModel.from_pretrained(\'transfo-xl-wt103\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        prediction_scores, mems = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(TransfoXLLMHeadModel, self).__init__(config)\n        self.transformer = TransfoXLModel(config)\n        self.sample_softmax = config.sample_softmax\n        # use sampled softmax\n        if config.sample_softmax > 0:\n            self.out_layer = nn.Linear(config.d_model, config.n_token)\n            self.sampler = LogUniformSampler(config.n_token, config.sample_softmax)\n        # use adaptive softmax (including standard softmax)\n        else:\n            self.crit = ProjectedAdaptiveLogSoftmax(config.n_token, config.d_embed, config.d_model,\n                                                    config.cutoffs, div_val=config.div_val)\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """"""\n        Run this to be sure output and input (adaptive) softmax weights are tied\n        """"""\n        # sampled softmax\n        if self.sample_softmax > 0:\n            if self.config.tie_weight:\n                self.out_layer.weight = self.transformer.word_emb.weight\n        # adaptive softmax (including standard softmax)\n        else:\n            if self.config.tie_weight:\n                for i in range(len(self.crit.out_layers)):\n                    self._tie_or_clone_weights(self.crit.out_layers[i],\n                                               self.transformer.word_emb.emb_layers[i])\n            if self.config.tie_projs:\n                for i, tie_proj in enumerate(self.config.tie_projs):\n                    if tie_proj and self.config.div_val == 1 and self.config.d_model != self.config.d_embed:\n                        if self.config.torchscript:\n                            self.crit.out_projs[i] = nn.Parameter(self.transformer.word_emb.emb_projs[0].clone())\n                        else:\n                            self.crit.out_projs[i] = self.transformer.word_emb.emb_projs[0]\n                    elif tie_proj and self.config.div_val != 1:\n                        if self.config.torchscript:\n                            self.crit.out_projs[i] = nn.Parameter(self.transformer.word_emb.emb_projs[i].clone())\n                        else:\n                            self.crit.out_projs[i] = self.transformer.word_emb.emb_projs[i]\n\n    def reset_length(self, tgt_len, ext_len, mem_len):\n        self.transformer.reset_length(tgt_len, ext_len, mem_len)\n\n    def init_mems(self, data):\n        return self.transformer.init_mems(data)\n\n    def forward(self, input_ids, mems=None, head_mask=None, labels=None):\n        bsz = input_ids.size(0)\n        tgt_len = input_ids.size(1)\n\n        transformer_outputs = self.transformer(input_ids, mems=mems, head_mask=head_mask)\n\n        last_hidden = transformer_outputs[0]\n        pred_hid = last_hidden[:, -tgt_len:]\n        outputs = transformer_outputs[1:]\n        if self.sample_softmax > 0 and self.training:\n            assert self.config.tie_weight\n            logit = sample_logits(self.transformer.word_emb, self.out_layer.bias, labels, pred_hid, self.sampler)\n            softmax_output = -F.log_softmax(logit, -1)[:, :, 0]\n            outputs = [softmax_output] + outputs\n            if labels is not None:\n                # TODO: This is not implemented\n                raise NotImplementedError\n        else:\n            softmax_output = self.crit(pred_hid.view(-1, pred_hid.size(-1)), labels)\n            if labels is None:\n                softmax_output = softmax_output.view(bsz, tgt_len, -1)\n                outputs = [softmax_output] + outputs\n            else:\n                softmax_output = softmax_output.view(bsz, tgt_len)\n                outputs = [softmax_output, None] + outputs\n\n        return outputs  # (loss), logits or None if labels is not None (speed up adaptive softmax), new_mems, (all hidden states), (all attentions)\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_transfo_xl_utilities.py,0,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Utilities for PyTorch Transformer XL model.\n    Directly adapted from https://github.com/kimiyoung/transformer-xl.\n""""""\n\nfrom collections import defaultdict\n\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n# CUDA_MAJOR = int(torch.version.cuda.split(\'.\')[0])\n# CUDA_MINOR = int(torch.version.cuda.split(\'.\')[1])\n\nclass ProjectedAdaptiveLogSoftmax(nn.Module):\n    def __init__(self, n_token, d_embed, d_proj, cutoffs, div_val=1,\n                 keep_order=False):\n        super(ProjectedAdaptiveLogSoftmax, self).__init__()\n\n        self.n_token = n_token\n        self.d_embed = d_embed\n        self.d_proj = d_proj\n\n        self.cutoffs = cutoffs + [n_token]\n        self.cutoff_ends = [0] + self.cutoffs\n        self.div_val = div_val\n\n        self.shortlist_size = self.cutoffs[0]\n        self.n_clusters = len(self.cutoffs) - 1\n        self.head_size = self.shortlist_size + self.n_clusters\n\n        if self.n_clusters > 0:\n            self.cluster_weight = nn.Parameter(torch.zeros(self.n_clusters, self.d_embed))\n            self.cluster_bias = nn.Parameter(torch.zeros(self.n_clusters))\n\n        self.out_layers = nn.ModuleList()\n        self.out_projs = nn.ParameterList()\n\n        if div_val == 1:\n            for i in range(len(self.cutoffs)):\n                if d_proj != d_embed:\n                    self.out_projs.append(\n                        nn.Parameter(torch.FloatTensor(d_proj, d_embed))\n                    )\n                else:\n                    self.out_projs.append(None)\n\n            self.out_layers.append(nn.Linear(d_embed, n_token))\n        else:\n            for i in range(len(self.cutoffs)):\n                l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i+1]\n                d_emb_i = d_embed // (div_val ** i)\n\n                self.out_projs.append(\n                    nn.Parameter(torch.FloatTensor(d_proj, d_emb_i))\n                )\n\n                self.out_layers.append(nn.Linear(d_emb_i, r_idx-l_idx))\n\n        self.keep_order = keep_order\n\n    def _compute_logit(self, hidden, weight, bias, proj):\n        if proj is None:\n            logit = F.linear(hidden, weight, bias=bias)\n        else:\n            # if CUDA_MAJOR <= 9 and CUDA_MINOR <= 1:\n            proj_hid = F.linear(hidden, proj.t().contiguous())\n            logit = F.linear(proj_hid, weight, bias=bias)\n            # else:\n            #     logit = torch.einsum(\'bd,de,ev->bv\', (hidden, proj, weight.t()))\n            #     if bias is not None:\n            #         logit = logit + bias\n\n        return logit\n\n    def forward(self, hidden, labels=None, keep_order=False):\n        \'\'\'\n            Params:\n                hidden :: [len*bsz x d_proj]\n                labels :: [len*bsz]\n            Return:\n                if labels is None:\n                    out :: [len*bsz] Negative log likelihood\n                else:\n                    out :: [len*bsz x n_tokens] log probabilities of tokens over the vocabulary\n            We could replace this implementation by the native PyTorch one\n            if their\'s had an option to set bias on all clusters in the native one.\n            here: https://github.com/pytorch/pytorch/blob/dbe6a7a9ff1a364a8706bf5df58a1ca96d2fd9da/torch/nn/modules/adaptive.py#L138\n        \'\'\'\n\n        if labels is not None:\n            labels = labels.view(-1)\n            if hidden.size(0) != labels.size(0):\n                raise RuntimeError(\'Input and labels should have the same size \'\n                                \'in the batch dimension.\')\n\n        if self.n_clusters == 0:\n            logit = self._compute_logit(hidden, self.out_layers[0].weight,\n                                        self.out_layers[0].bias, self.out_projs[0])\n            if labels is not None:\n                out = -F.log_softmax(logit, dim=-1) \\\n                        .gather(1, labels.unsqueeze(1)).squeeze(1)\n            else:\n                out = F.log_softmax(logit, dim=-1)\n        else:\n            # construct weights and biases\n            weights, biases = [], []\n            for i in range(len(self.cutoffs)):\n                if self.div_val == 1:\n                    l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i + 1]\n                    weight_i = self.out_layers[0].weight[l_idx:r_idx]\n                    bias_i = self.out_layers[0].bias[l_idx:r_idx]\n                else:\n                    weight_i = self.out_layers[i].weight\n                    bias_i = self.out_layers[i].bias\n\n                if i == 0:\n                    weight_i = torch.cat(\n                        [weight_i, self.cluster_weight], dim=0)\n                    bias_i = torch.cat(\n                        [bias_i, self.cluster_bias], dim=0)\n\n                weights.append(weight_i)\n                biases.append(bias_i)\n\n            head_weight, head_bias, head_proj = weights[0], biases[0], self.out_projs[0]\n\n            head_logit = self._compute_logit(hidden, head_weight, head_bias, head_proj)\n            head_logprob = F.log_softmax(head_logit, dim=1)\n\n            if labels is None:\n                out = hidden.new_empty((head_logit.size(0), self.n_token))\n            else:\n                out = torch.zeros_like(labels, dtype=hidden.dtype, device=hidden.device)\n\n            offset = 0\n            cutoff_values = [0] + self.cutoffs\n            for i in range(len(cutoff_values) - 1):\n                l_idx, r_idx = cutoff_values[i], cutoff_values[i + 1]\n\n                if labels is not None:\n                    mask_i = (labels >= l_idx) & (labels < r_idx)\n                    indices_i = mask_i.nonzero().squeeze()\n\n                    if indices_i.numel() == 0:\n                        continue\n\n                    target_i = labels.index_select(0, indices_i) - l_idx\n                    head_logprob_i = head_logprob.index_select(0, indices_i)\n                    hidden_i = hidden.index_select(0, indices_i)\n                else:\n                    hidden_i = hidden\n\n                if i == 0:\n                    if labels is not None:\n                        logprob_i = head_logprob_i.gather(1, target_i[:, None]).squeeze(1)\n                    else:\n                        out[:, :self.cutoffs[0]] = head_logprob[:, :self.cutoffs[0]]\n                else:\n                    weight_i, bias_i, proj_i = weights[i], biases[i], self.out_projs[i]\n\n                    tail_logit_i = self._compute_logit(hidden_i, weight_i, bias_i, proj_i)\n                    tail_logprob_i = F.log_softmax(tail_logit_i, dim=1)\n                    cluster_prob_idx = self.cutoffs[0] + i - 1  # No probability for the head cluster\n                    if labels is not None:\n                        logprob_i = head_logprob_i[:, cluster_prob_idx] \\\n                                + tail_logprob_i.gather(1, target_i[:, None]).squeeze(1)\n                    else:\n                        logprob_i = head_logprob[:, cluster_prob_idx, None] + tail_logprob_i\n                        out[:, l_idx:r_idx] = logprob_i\n\n                if labels is not None:\n                    if (hasattr(self, \'keep_order\') and self.keep_order) or keep_order:\n                        out.index_copy_(0, indices_i, -logprob_i)\n                    else:\n                        out[offset:offset+logprob_i.size(0)].copy_(-logprob_i)\n                    offset += logprob_i.size(0)\n\n        return out\n\n\n    def log_prob(self, hidden):\n        r"""""" Computes log probabilities for all :math:`n\\_classes`\n        From: https://github.com/pytorch/pytorch/blob/master/torch/nn/modules/adaptive.py\n        Args:\n            hidden (Tensor): a minibatch of examples\n        Returns:\n            log-probabilities of for each class :math:`c`\n            in range :math:`0 <= c <= n\\_classes`, where :math:`n\\_classes` is a\n            parameter passed to ``AdaptiveLogSoftmaxWithLoss`` constructor.\n        Shape:\n            - Input: :math:`(N, in\\_features)`\n            - Output: :math:`(N, n\\_classes)`\n        """"""\n        if self.n_clusters == 0:\n            logit = self._compute_logit(hidden, self.out_layers[0].weight,\n                                        self.out_layers[0].bias, self.out_projs[0])\n            return F.log_softmax(logit, dim=-1)\n        else:\n            # construct weights and biases\n            weights, biases = [], []\n            for i in range(len(self.cutoffs)):\n                if self.div_val == 1:\n                    l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i + 1]\n                    weight_i = self.out_layers[0].weight[l_idx:r_idx]\n                    bias_i = self.out_layers[0].bias[l_idx:r_idx]\n                else:\n                    weight_i = self.out_layers[i].weight\n                    bias_i = self.out_layers[i].bias\n\n                if i == 0:\n                    weight_i = torch.cat(\n                        [weight_i, self.cluster_weight], dim=0)\n                    bias_i = torch.cat(\n                        [bias_i, self.cluster_bias], dim=0)\n\n                weights.append(weight_i)\n                biases.append(bias_i)\n\n            head_weight, head_bias, head_proj = weights[0], biases[0], self.out_projs[0]\n            head_logit = self._compute_logit(hidden, head_weight, head_bias, head_proj)\n\n            out = hidden.new_empty((head_logit.size(0), self.n_token))\n            head_logprob = F.log_softmax(head_logit, dim=1)\n\n            cutoff_values = [0] + self.cutoffs\n            for i in range(len(cutoff_values) - 1):\n                start_idx, stop_idx = cutoff_values[i], cutoff_values[i + 1]\n\n                if i == 0:\n                    out[:, :self.cutoffs[0]] = head_logprob[:, :self.cutoffs[0]]\n                else:\n                    weight_i, bias_i, proj_i = weights[i], biases[i], self.out_projs[i]\n\n                    tail_logit_i = self._compute_logit(hidden, weight_i, bias_i, proj_i)\n                    tail_logprob_i = F.log_softmax(tail_logit_i, dim=1)\n\n                    logprob_i = head_logprob[:, -i] + tail_logprob_i\n                    out[:, start_idx, stop_idx] = logprob_i\n\n            return out\n\n\nclass LogUniformSampler(object):\n    def __init__(self, range_max, n_sample):\n        """"""\n        Reference : https://github.com/tensorflow/tensorflow/blob/r1.10/tensorflow/python/ops/candidate_sampling_ops.py\n            `P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)`\n\n        expected count can be approximated by 1 - (1 - p)^n\n        and we use a numerically stable version -expm1(num_tries * log1p(-p))\n\n        Our implementation fixes num_tries at 2 * n_sample, and the actual #samples will vary from run to run\n        """"""\n        with torch.no_grad():\n            self.range_max = range_max\n            log_indices = torch.arange(1., range_max+2., 1.).log_()\n            self.dist = (log_indices[1:] - log_indices[:-1]) / log_indices[-1]\n\n            self.log_q = (- (-self.dist.double().log1p_() * 2 * n_sample).expm1_()).log_().float()\n\n        self.n_sample = n_sample\n\n    def sample(self, labels):\n        """"""\n            labels: [b1, b2]\n        Return\n            true_log_probs: [b1, b2]\n            samp_log_probs: [n_sample]\n            neg_samples: [n_sample]\n        """"""\n\n        # neg_samples = torch.empty(0).long()\n        n_sample = self.n_sample\n        n_tries = 2 * n_sample\n\n        with torch.no_grad():\n            neg_samples = torch.multinomial(self.dist, n_tries, replacement=True).unique()\n            device = labels.device\n            neg_samples = neg_samples.to(device)\n            true_log_probs = self.log_q[labels].to(device)\n            samp_log_probs = self.log_q[neg_samples].to(device)\n            return true_log_probs, samp_log_probs, neg_samples\n\ndef sample_logits(embedding, bias, labels, inputs, sampler):\n    """"""\n        embedding: an nn.Embedding layer\n        bias: [n_vocab]\n        labels: [b1, b2]\n        inputs: [b1, b2, n_emb]\n        sampler: you may use a LogUniformSampler\n    Return\n        logits: [b1, b2, 1 + n_sample]\n    """"""\n    true_log_probs, samp_log_probs, neg_samples = sampler.sample(labels)\n    n_sample = neg_samples.size(0)\n    b1, b2 = labels.size(0), labels.size(1)\n    all_ids = torch.cat([labels.view(-1), neg_samples])\n    all_w = embedding(all_ids)\n    true_w = all_w[: -n_sample].view(b1, b2, -1)\n    sample_w = all_w[- n_sample:].view(n_sample, -1)\n\n    all_b = bias[all_ids]\n    true_b = all_b[: -n_sample].view(b1, b2)\n    sample_b = all_b[- n_sample:]\n\n    hit = (labels[:, :, None] == neg_samples).detach()\n\n    true_logits = torch.einsum(\'ijk,ijk->ij\',\n        [true_w, inputs]) + true_b - true_log_probs\n    sample_logits = torch.einsum(\'lk,ijk->ijl\',\n        [sample_w, inputs]) + sample_b - samp_log_probs\n    sample_logits.masked_fill_(hit, -1e30)\n    logits = torch.cat([true_logits[:, :, None], sample_logits], -1)\n\n    return logits\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_utils.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch BERT model.""""""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport copy\nimport json\nimport logging\nimport os\nfrom io import open\n\nimport six\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn import functional as F\n\nfrom .configuration_utils import PretrainedConfig\nfrom .file_utils import cached_path, WEIGHTS_NAME, TF_WEIGHTS_NAME, TF2_WEIGHTS_NAME\n\nlogger = logging.getLogger(__name__)\n\n\ntry:\n    from torch.nn import Identity\nexcept ImportError:\n    # Older PyTorch compatibility\n    class Identity(nn.Module):\n        r""""""A placeholder identity operator that is argument-insensitive.\n        """"""\n        def __init__(self, *args, **kwargs):\n            super(Identity, self).__init__()\n\n        def forward(self, input):\n            return input\n\nclass PreTrainedModel(nn.Module):\n    r"""""" Base class for all models.\n\n        :class:`~transformers.PreTrainedModel` takes care of storing the configuration of the models and handles methods for loading/downloading/saving models\n        as well as a few methods commons to all models to (i) resize the input embeddings and (ii) prune heads in the self-attention heads.\n\n        Class attributes (overridden by derived classes):\n            - ``config_class``: a class derived from :class:`~transformers.PretrainedConfig` to use as configuration class for this model architecture.\n            - ``pretrained_model_archive_map``: a python ``dict`` of with `short-cut-names` (string) as keys and `url` (string) of associated pretrained weights as values.\n            - ``load_tf_weights``: a python ``method`` for loading a TensorFlow checkpoint in a PyTorch model, taking as arguments:\n\n                - ``model``: an instance of the relevant subclass of :class:`~transformers.PreTrainedModel`,\n                - ``config``: an instance of the relevant subclass of :class:`~transformers.PretrainedConfig`,\n                - ``path``: a path (string) to the TensorFlow checkpoint.\n\n            - ``base_model_prefix``: a string indicating the attribute associated to the base model in derived classes of the same architecture adding modules on top of the base model.\n    """"""\n    config_class = None\n    pretrained_model_archive_map = {}\n    load_tf_weights = lambda model, config, path: None\n    base_model_prefix = """"\n\n    def __init__(self, config, *inputs, **kwargs):\n        super(PreTrainedModel, self).__init__()\n        if not isinstance(config, PretrainedConfig):\n            raise ValueError(\n                ""Parameter config in `{}(config)` should be an instance of class `PretrainedConfig`. ""\n                ""To create a model from a pretrained model use ""\n                ""`model = {}.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(\n                    self.__class__.__name__, self.__class__.__name__\n                ))\n        # Save config in model\n        self.config = config\n\n    def _get_resized_embeddings(self, old_embeddings, new_num_tokens=None):\n        """""" Build a resized Embedding Module from a provided token Embedding Module.\n            Increasing the size will add newly initialized vectors at the end\n            Reducing the size will remove vectors from the end\n\n        Args:\n            new_num_tokens: (`optional`) int\n                New number of tokens in the embedding matrix.\n                Increasing the size will add newly initialized vectors at the end\n                Reducing the size will remove vectors from the end\n                If not provided or None: return the provided token Embedding Module.\n        Return: ``torch.nn.Embeddings``\n            Pointer to the resized Embedding Module or the old Embedding Module if new_num_tokens is None\n        """"""\n        if new_num_tokens is None:\n            return old_embeddings\n\n        old_num_tokens, old_embedding_dim = old_embeddings.weight.size()\n        if old_num_tokens == new_num_tokens:\n            return old_embeddings\n\n        # Build new embeddings\n        new_embeddings = nn.Embedding(new_num_tokens, old_embedding_dim)\n        new_embeddings.to(old_embeddings.weight.device)\n\n        # initialize all new embeddings (in particular added tokens)\n        self._init_weights(new_embeddings)\n\n        # Copy word embeddings from the previous weights\n        num_tokens_to_copy = min(old_num_tokens, new_num_tokens)\n        new_embeddings.weight.data[:num_tokens_to_copy, :] = old_embeddings.weight.data[:num_tokens_to_copy, :]\n\n        return new_embeddings\n\n    def _tie_or_clone_weights(self, first_module, second_module):\n        """""" Tie or clone module weights depending of weither we are using TorchScript or not\n        """"""\n        if self.config.torchscript:\n            first_module.weight = nn.Parameter(second_module.weight.clone())\n        else:\n            first_module.weight = second_module.weight\n\n        if hasattr(first_module, \'bias\') and first_module.bias is not None:\n            first_module.bias.data = torch.nn.functional.pad(\n                first_module.bias.data,\n                (0, first_module.weight.shape[0] - first_module.bias.shape[0]),\n                \'constant\',\n                0\n            )\n\n    def _tie_or_clone_data(self, first_module, second_module):\n        """""" Tie or clone module weights depending of weither we are using TorchScript or not\n        """"""\n\n        if self.config.torchscript:\n            first_module.weight.data = nn.Parameter(second_module.weight.data.t().clone())\n        else:\n            first_module.weight.data = second_module.weight.data.t()\n        if hasattr(first_module, \'bias\') and first_module.bias is not None:\n            first_module.bias.data = torch.nn.functional.pad(\n                first_module.bias.data,\n                (0, first_module.weight.shape[0] - first_module.bias.shape[0]),\n                \'constant\',\n                0\n            )\n\n    def resize_token_embeddings(self, new_num_tokens=None):\n        """""" Resize input token embeddings matrix of the model if new_num_tokens != config.vocab_size.\n        Take care of tying weights embeddings afterwards if the model class has a `tie_weights()` method.\n\n        Arguments:\n\n            new_num_tokens: (`optional`) int:\n                New number of tokens in the embedding matrix. Increasing the size will add newly initialized vectors at the end. Reducing the size will remove vectors from the end.\n                If not provided or None: does nothing and just returns a pointer to the input tokens ``torch.nn.Embeddings`` Module of the model.\n\n        Return: ``torch.nn.Embeddings``\n            Pointer to the input tokens Embeddings Module of the model\n        """"""\n        base_model = getattr(self, self.base_model_prefix, self)  # get the base model if needed\n        model_embeds = base_model._resize_token_embeddings(new_num_tokens)\n        if new_num_tokens is None:\n            return model_embeds\n\n        # Update base model and current model config\n        self.config.vocab_size = new_num_tokens\n        base_model.vocab_size = new_num_tokens\n\n        # Tie weights again if needed\n        if hasattr(self, \'tie_weights\'):\n            self.tie_weights()\n\n        return model_embeds\n\n    def init_weights(self):\n        """""" Initialize and prunes weights if needed. """"""\n        # Initialize weights\n        self.apply(self._init_weights)\n\n        # Prune heads if needed\n        if self.config.pruned_heads:\n            self.prune_heads(self.config.pruned_heads)\n\n    def prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the base model.\n\n            Arguments:\n\n                heads_to_prune: dict with keys being selected layer indices (`int`) and associated values being the list of heads to prune in said layer (list of `int`).\n                E.g. {1: [0, 2], 2: [2, 3]} will prune heads 0 and 2 on layer 1 and heads 2 and 3 on layer 2.\n        """"""\n        base_model = getattr(self, self.base_model_prefix, self)  # get the base model if needed\n\n        # save new sets of pruned heads as union of previously stored pruned heads and newly pruned heads\n        for layer, heads in heads_to_prune.items():\n            union_heads = set(self.config.pruned_heads.get(layer, [])) | set(heads)\n            self.config.pruned_heads[layer] = list(union_heads)  # Unfortunately we have to store it as list for JSON\n\n        base_model._prune_heads(heads_to_prune)\n\n    def save_pretrained(self, save_directory):\n        """""" Save a model and its configuration file to a directory, so that it\n            can be re-loaded using the `:func:`~transformers.PreTrainedModel.from_pretrained`` class method.\n        """"""\n        assert os.path.isdir(save_directory), ""Saving path should be a directory where the model and configuration can be saved""\n\n        # Only save the model it-self if we are using distributed training\n        model_to_save = self.module if hasattr(self, \'module\') else self\n\n        # Save configuration file\n        model_to_save.config.save_pretrained(save_directory)\n\n        # If we save using the predefined names, we can load using `from_pretrained`\n        output_model_file = os.path.join(save_directory, WEIGHTS_NAME)\n        torch.save(model_to_save.state_dict(), output_model_file)\n        logger.info(""Model weights saved in {}"".format(output_model_file))\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n        r""""""Instantiate a pretrained pytorch model from a pre-trained model configuration.\n\n        The model is set in evaluation mode by default using ``model.eval()`` (Dropout modules are deactivated)\n        To train the model, you should first set it back in training mode with ``model.train()``\n\n        The warning ``Weights from XXX not initialized from pretrained model`` means that the weights of XXX do not come pre-trained with the rest of the model.\n        It is up to you to train those weights with a downstream fine-tuning task.\n\n        The warning ``Weights from XXX not used in YYY`` means that the layer XXX is not used by YYY, therefore those weights are discarded.\n\n        Parameters:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing model weights saved using :func:`~transformers.PreTrainedModel.save_pretrained`, e.g.: ``./my_model_directory/``.\n                - a path or url to a `tensorflow index checkpoint file` (e.g. `./tf_model/model.ckpt.index`). In this case, ``from_tf`` should be set to True and a configuration object should be provided as ``config`` argument. This loading path is slower than converting the TensorFlow checkpoint in a PyTorch model using the provided conversion scripts and loading the PyTorch model afterwards.\n                - None if you are both providing the configuration and state dictionary (resp. with keyword arguments ``config`` and ``state_dict``)\n\n            model_args: (`optional`) Sequence of positional arguments:\n                All remaning positional arguments will be passed to the underlying model\'s ``__init__`` method\n\n            config: (`optional`) instance of a class derived from :class:`~transformers.PretrainedConfig`:\n                Configuration for the model to use instead of an automatically loaded configuation. Configuration can be automatically loaded when:\n\n                - the model is a model provided by the library (loaded with the ``shortcut-name`` string of a pretrained model), or\n                - the model was saved using :func:`~transformers.PreTrainedModel.save_pretrained` and is reloaded by suppling the save directory.\n                - the model is loaded by suppling a local directory as ``pretrained_model_name_or_path`` and a configuration JSON file named `config.json` is found in the directory.\n\n            state_dict: (`optional`) dict:\n                an optional state dictionnary for the model to use instead of a state dictionary loaded from saved weights file.\n                This option can be used if you want to create a model from a pretrained configuration but load your own weights.\n                In this case though, you should check if using :func:`~transformers.PreTrainedModel.save_pretrained` and :func:`~transformers.PreTrainedModel.from_pretrained` is not a simpler option.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            output_loading_info: (`optional`) boolean:\n                Set to ``True`` to also return a dictionnary containing missing keys, unexpected keys and error messages.\n\n            kwargs: (`optional`) Remaining dictionary of keyword arguments:\n                Can be used to update the configuration object (after it being loaded) and initiate the model. (e.g. ``output_attention=True``). Behave differently depending on whether a `config` is provided or automatically loaded:\n\n                - If a configuration is provided with ``config``, ``**kwargs`` will be directly passed to the underlying model\'s ``__init__`` method (we assume all relevant updates to the configuration have already been done)\n                - If a configuration is not provided, ``kwargs`` will be first passed to the configuration class initialization function (:func:`~transformers.PretrainedConfig.from_pretrained`). Each key of ``kwargs`` that corresponds to a configuration attribute will be used to override said attribute with the supplied ``kwargs`` value. Remaining keys that do not correspond to any configuration attribute will be passed to the underlying model\'s ``__init__`` function.\n\n        Examples::\n\n            model = BertModel.from_pretrained(\'bert-base-uncased\')    # Download model and configuration from S3 and cache.\n            model = BertModel.from_pretrained(\'./test/saved_model/\')  # E.g. model was saved using `save_pretrained(\'./test/saved_model/\')`\n            model = BertModel.from_pretrained(\'bert-base-uncased\', output_attention=True)  # Update configuration during loading\n            assert model.config.output_attention == True\n            # Loading from a TF checkpoint file instead of a PyTorch model (slower)\n            config = BertConfig.from_json_file(\'./tf_model/my_tf_model_config.json\')\n            model = BertModel.from_pretrained(\'./tf_model/my_tf_checkpoint.ckpt.index\', from_tf=True, config=config)\n\n        """"""\n        config = kwargs.pop(\'config\', None)\n        state_dict = kwargs.pop(\'state_dict\', None)\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        from_tf = kwargs.pop(\'from_tf\', False)\n        force_download = kwargs.pop(\'force_download\', False)\n        proxies = kwargs.pop(\'proxies\', None)\n        output_loading_info = kwargs.pop(\'output_loading_info\', False)\n\n        # Load config\n        if config is None:\n            config, model_kwargs = cls.config_class.from_pretrained(\n                pretrained_model_name_or_path, *model_args,\n                cache_dir=cache_dir, return_unused_kwargs=True,\n                force_download=force_download,\n                **kwargs\n            )\n        else:\n            model_kwargs = kwargs\n\n        # Load model\n        if pretrained_model_name_or_path is not None:\n            if pretrained_model_name_or_path in cls.pretrained_model_archive_map:\n                archive_file = cls.pretrained_model_archive_map[pretrained_model_name_or_path]\n            elif os.path.isdir(pretrained_model_name_or_path):\n                if from_tf and os.path.isfile(os.path.join(pretrained_model_name_or_path, TF_WEIGHTS_NAME + "".index"")):\n                    # Load from a TF 1.0 checkpoint\n                    archive_file = os.path.join(pretrained_model_name_or_path, TF_WEIGHTS_NAME + "".index"")\n                elif from_tf and os.path.isfile(os.path.join(pretrained_model_name_or_path, TF2_WEIGHTS_NAME)):\n                    # Load from a TF 2.0 checkpoint\n                    archive_file = os.path.join(pretrained_model_name_or_path, TF2_WEIGHTS_NAME)\n                elif os.path.isfile(os.path.join(pretrained_model_name_or_path, WEIGHTS_NAME)):\n                    # Load from a PyTorch checkpoint\n                    archive_file = os.path.join(pretrained_model_name_or_path, WEIGHTS_NAME)\n                else:\n                    raise EnvironmentError(""Error no file named {} found in directory {} or `from_tf` set to False"".format(\n                        [WEIGHTS_NAME, TF2_WEIGHTS_NAME, TF_WEIGHTS_NAME + "".index""],\n                        pretrained_model_name_or_path))\n            elif os.path.isfile(pretrained_model_name_or_path):\n                archive_file = pretrained_model_name_or_path\n            else:\n                assert from_tf, ""Error finding file {}, no file or TF 1.X checkpoint found"".format(pretrained_model_name_or_path)\n                archive_file = pretrained_model_name_or_path + "".index""\n\n            # redirect to the cache, if necessary\n            try:\n                resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n            except EnvironmentError:\n                if pretrained_model_name_or_path in cls.pretrained_model_archive_map:\n                    msg = ""Couldn\'t reach server at \'{}\' to download pretrained weights."".format(\n                            archive_file)\n                else:\n                    msg = ""Model name \'{}\' was not found in model name list ({}). "" \\\n                        ""We assumed \'{}\' was a path or url to model weight files named one of {} but "" \\\n                        ""couldn\'t find any such file at this path or url."".format(\n                            pretrained_model_name_or_path,\n                            \', \'.join(cls.pretrained_model_archive_map.keys()),\n                            archive_file,\n                            [WEIGHTS_NAME, TF2_WEIGHTS_NAME, TF_WEIGHTS_NAME])\n                raise EnvironmentError(msg)\n\n            if resolved_archive_file == archive_file:\n                logger.info(""loading weights file {}"".format(archive_file))\n            else:\n                logger.info(""loading weights file {} from cache at {}"".format(\n                    archive_file, resolved_archive_file))\n        else:\n            resolved_archive_file = None\n\n        # Instantiate model.\n        model = cls(config, *model_args, **model_kwargs)\n\n        if state_dict is None and not from_tf:\n            state_dict = torch.load(resolved_archive_file, map_location=\'cpu\')\n\n        missing_keys = []\n        unexpected_keys = []\n        error_msgs = []\n\n        if from_tf:\n            if resolved_archive_file.endswith(\'.index\'):\n                # Load from a TensorFlow 1.X checkpoint - provided by original authors\n                model = cls.load_tf_weights(model, config, resolved_archive_file[:-6])  # Remove the \'.index\'\n            else:\n                # Load from our TensorFlow 2.0 checkpoints\n                try:\n                    from transformers import load_tf2_checkpoint_in_pytorch_model\n                    model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)\n                except ImportError as e:\n                    logger.error(""Loading a TensorFlow model in PyTorch, requires both PyTorch and TensorFlow to be installed. Please see ""\n                        ""https://pytorch.org/ and https://www.tensorflow.org/install/ for installation instructions."")\n                    raise e\n        else:\n            # Convert old format to new format if needed from a PyTorch state_dict\n            old_keys = []\n            new_keys = []\n            for key in state_dict.keys():\n                new_key = None\n                if \'gamma\' in key:\n                    new_key = key.replace(\'gamma\', \'weight\')\n                if \'beta\' in key:\n                    new_key = key.replace(\'beta\', \'bias\')\n                if new_key:\n                    old_keys.append(key)\n                    new_keys.append(new_key)\n            for old_key, new_key in zip(old_keys, new_keys):\n                state_dict[new_key] = state_dict.pop(old_key)\n\n            # copy state_dict so _load_from_state_dict can modify it\n            metadata = getattr(state_dict, \'_metadata\', None)\n            state_dict = state_dict.copy()\n            if metadata is not None:\n                state_dict._metadata = metadata\n\n            def load(module, prefix=\'\'):\n                local_metadata = {} if metadata is None else metadata.get(prefix[:-1], {})\n                module._load_from_state_dict(\n                    state_dict, prefix, local_metadata, True, missing_keys, unexpected_keys, error_msgs)\n                for name, child in module._modules.items():\n                    if child is not None:\n                        load(child, prefix + name + \'.\')\n\n            # Make sure we are able to load base models as well as derived models (with heads)\n            start_prefix = \'\'\n            model_to_load = model\n            if not hasattr(model, cls.base_model_prefix) and any(s.startswith(cls.base_model_prefix) for s in state_dict.keys()):\n                start_prefix = cls.base_model_prefix + \'.\'\n            if hasattr(model, cls.base_model_prefix) and not any(s.startswith(cls.base_model_prefix) for s in state_dict.keys()):\n                model_to_load = getattr(model, cls.base_model_prefix)\n\n            load(model_to_load, prefix=start_prefix)\n            if len(missing_keys) > 0:\n                logger.info(""Weights of {} not initialized from pretrained model: {}"".format(\n                    model.__class__.__name__, missing_keys))\n            if len(unexpected_keys) > 0:\n                logger.info(""Weights from pretrained model not used in {}: {}"".format(\n                    model.__class__.__name__, unexpected_keys))\n            if len(error_msgs) > 0:\n                raise RuntimeError(\'Error(s) in loading state_dict for {}:\\n\\t{}\'.format(\n                                model.__class__.__name__, ""\\n\\t"".join(error_msgs)))\n\n        if hasattr(model, \'tie_weights\'):\n            model.tie_weights()  # make sure word embedding weights are still tied\n\n        # Set model in evaluation mode to desactivate DropOut modules by default\n        model.eval()\n\n        if output_loading_info:\n            loading_info = {""missing_keys"": missing_keys, ""unexpected_keys"": unexpected_keys, ""error_msgs"": error_msgs}\n            return model, loading_info\n\n        return model\n\n\nclass Conv1D(nn.Module):\n    def __init__(self, nf, nx):\n        """""" Conv1D layer as defined by Radford et al. for OpenAI GPT (and also used in GPT-2)\n            Basically works like a Linear layer but the weights are transposed\n        """"""\n        super(Conv1D, self).__init__()\n        self.nf = nf\n        w = torch.empty(nx, nf)\n        nn.init.normal_(w, std=0.02)\n        self.weight = nn.Parameter(w)\n        self.bias = nn.Parameter(torch.zeros(nf))\n\n    def forward(self, x):\n        size_out = x.size()[:-1] + (self.nf,)\n        x = torch.addmm(self.bias, x.view(-1, x.size(-1)), self.weight)\n        x = x.view(*size_out)\n        return x\n\n\nclass PoolerStartLogits(nn.Module):\n    """""" Compute SQuAD start_logits from sequence hidden states. """"""\n    def __init__(self, config):\n        super(PoolerStartLogits, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, 1)\n\n    def forward(self, hidden_states, p_mask=None):\n        """""" Args:\n            **p_mask**: (`optional`) ``torch.FloatTensor`` of shape `(batch_size, seq_len)`\n                invalid position mask such as query and special symbols (PAD, SEP, CLS)\n                1.0 means token should be masked.\n        """"""\n        x = self.dense(hidden_states).squeeze(-1)\n\n        if p_mask is not None:\n            if next(self.parameters()).dtype == torch.float16:\n                x = x * (1 - p_mask) - 65500 * p_mask\n            else:\n                x = x * (1 - p_mask) - 1e30 * p_mask\n\n        return x\n\n\nclass PoolerEndLogits(nn.Module):\n    """""" Compute SQuAD end_logits from sequence hidden states and start token hidden state.\n    """"""\n    def __init__(self, config):\n        super(PoolerEndLogits, self).__init__()\n        self.dense_0 = nn.Linear(config.hidden_size * 2, config.hidden_size)\n        self.activation = nn.Tanh()\n        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dense_1 = nn.Linear(config.hidden_size, 1)\n\n    def forward(self, hidden_states, start_states=None, start_positions=None, p_mask=None):\n        """""" Args:\n            One of ``start_states``, ``start_positions`` should be not None.\n            If both are set, ``start_positions`` overrides ``start_states``.\n\n            **start_states**: ``torch.LongTensor`` of shape identical to hidden_states\n                hidden states of the first tokens for the labeled span.\n            **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n                position of the first token for the labeled span:\n            **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, seq_len)``\n                Mask of invalid position such as query and special symbols (PAD, SEP, CLS)\n                1.0 means token should be masked.\n        """"""\n        assert start_states is not None or start_positions is not None, ""One of start_states, start_positions should be not None""\n        if start_positions is not None:\n            slen, hsz = hidden_states.shape[-2:]\n            start_positions = start_positions[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            start_states = hidden_states.gather(-2, start_positions) # shape (bsz, 1, hsz)\n            start_states = start_states.expand(-1, slen, -1) # shape (bsz, slen, hsz)\n\n        x = self.dense_0(torch.cat([hidden_states, start_states], dim=-1))\n        x = self.activation(x)\n        x = self.LayerNorm(x)\n        x = self.dense_1(x).squeeze(-1)\n\n        if p_mask is not None:\n            if next(self.parameters()).dtype == torch.float16:\n                x = x * (1 - p_mask) - 65500 * p_mask\n            else:\n                x = x * (1 - p_mask) - 1e30 * p_mask\n\n        return x\n\n\nclass PoolerAnswerClass(nn.Module):\n    """""" Compute SQuAD 2.0 answer class from classification and start tokens hidden states. """"""\n    def __init__(self, config):\n        super(PoolerAnswerClass, self).__init__()\n        self.dense_0 = nn.Linear(config.hidden_size * 2, config.hidden_size)\n        self.activation = nn.Tanh()\n        self.dense_1 = nn.Linear(config.hidden_size, 1, bias=False)\n\n    def forward(self, hidden_states, start_states=None, start_positions=None, cls_index=None):\n        """"""\n        Args:\n            One of ``start_states``, ``start_positions`` should be not None.\n            If both are set, ``start_positions`` overrides ``start_states``.\n\n            **start_states**: ``torch.LongTensor`` of shape identical to ``hidden_states``.\n                hidden states of the first tokens for the labeled span.\n            **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n                position of the first token for the labeled span.\n            **cls_index**: torch.LongTensor of shape ``(batch_size,)``\n                position of the CLS token. If None, take the last token.\n\n            note(Original repo):\n                no dependency on end_feature so that we can obtain one single `cls_logits`\n                for each sample\n        """"""\n        hsz = hidden_states.shape[-1]\n        assert start_states is not None or start_positions is not None, ""One of start_states, start_positions should be not None""\n        if start_positions is not None:\n            start_positions = start_positions[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            start_states = hidden_states.gather(-2, start_positions).squeeze(-2) # shape (bsz, hsz)\n\n        if cls_index is not None:\n            cls_index = cls_index[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            cls_token_state = hidden_states.gather(-2, cls_index).squeeze(-2) # shape (bsz, hsz)\n        else:\n            cls_token_state = hidden_states[:, -1, :] # shape (bsz, hsz)\n\n        x = self.dense_0(torch.cat([start_states, cls_token_state], dim=-1))\n        x = self.activation(x)\n        x = self.dense_1(x).squeeze(-1)\n\n        return x\n\n\nclass SQuADHead(nn.Module):\n    r"""""" A SQuAD head inspired by XLNet.\n\n    Parameters:\n        config (:class:`~transformers.XLNetConfig`): Model configuration class with all the parameters of the model.\n\n    Inputs:\n        **hidden_states**: ``torch.FloatTensor`` of shape ``(batch_size, seq_len, hidden_size)``\n            hidden states of sequence tokens\n        **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            position of the first token for the labeled span.\n        **end_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            position of the last token for the labeled span.\n        **cls_index**: torch.LongTensor of shape ``(batch_size,)``\n            position of the CLS token. If None, take the last token.\n        **is_impossible**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            Whether the question has a possible answer in the paragraph or not.\n        **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, seq_len)``\n            Mask of invalid position such as query and special symbols (PAD, SEP, CLS)\n            1.0 means token should be masked.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned if both ``start_positions`` and ``end_positions`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss as the sum of start token, end token (and is_impossible if provided) classification losses.\n        **start_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top)``\n            Log probabilities for the top config.start_n_top start token possibilities (beam-search).\n        **start_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top)``\n            Indices for the top config.start_n_top start token possibilities (beam-search).\n        **end_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Log probabilities for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **end_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Indices for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **cls_logits**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size,)``\n            Log probabilities for the ``is_impossible`` label of the answers.\n    """"""\n    def __init__(self, config):\n        super(SQuADHead, self).__init__()\n        self.start_n_top = config.start_n_top\n        self.end_n_top = config.end_n_top\n\n        self.start_logits = PoolerStartLogits(config)\n        self.end_logits = PoolerEndLogits(config)\n        self.answer_class = PoolerAnswerClass(config)\n\n    def forward(self, hidden_states, start_positions=None, end_positions=None,\n                cls_index=None, is_impossible=None, p_mask=None):\n        outputs = ()\n\n        start_logits = self.start_logits(hidden_states, p_mask=p_mask)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, let\'s remove the dimension added by batch splitting\n            for x in (start_positions, end_positions, cls_index, is_impossible):\n                if x is not None and x.dim() > 1:\n                    x.squeeze_(-1)\n\n            # during training, compute the end logits based on the ground truth of the start position\n            end_logits = self.end_logits(hidden_states, start_positions=start_positions, p_mask=p_mask)\n\n            loss_fct = CrossEntropyLoss()\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n\n            if cls_index is not None and is_impossible is not None:\n                # Predict answerability from the representation of CLS and START\n                cls_logits = self.answer_class(hidden_states, start_positions=start_positions, cls_index=cls_index)\n                loss_fct_cls = nn.BCEWithLogitsLoss()\n                cls_loss = loss_fct_cls(cls_logits, is_impossible)\n\n                # note(zhiliny): by default multiply the loss by 0.5 so that the scale is comparable to start_loss and end_loss\n                total_loss += cls_loss * 0.5\n\n            outputs = (total_loss,) + outputs\n\n        else:\n            # during inference, compute the end logits based on beam search\n            bsz, slen, hsz = hidden_states.size()\n            start_log_probs = F.softmax(start_logits, dim=-1) # shape (bsz, slen)\n\n            start_top_log_probs, start_top_index = torch.topk(start_log_probs, self.start_n_top, dim=-1) # shape (bsz, start_n_top)\n            start_top_index_exp = start_top_index.unsqueeze(-1).expand(-1, -1, hsz) # shape (bsz, start_n_top, hsz)\n            start_states = torch.gather(hidden_states, -2, start_top_index_exp) # shape (bsz, start_n_top, hsz)\n            start_states = start_states.unsqueeze(1).expand(-1, slen, -1, -1) # shape (bsz, slen, start_n_top, hsz)\n\n            hidden_states_expanded = hidden_states.unsqueeze(2).expand_as(start_states) # shape (bsz, slen, start_n_top, hsz)\n            p_mask = p_mask.unsqueeze(-1) if p_mask is not None else None\n            end_logits = self.end_logits(hidden_states_expanded, start_states=start_states, p_mask=p_mask)\n            end_log_probs = F.softmax(end_logits, dim=1) # shape (bsz, slen, start_n_top)\n\n            end_top_log_probs, end_top_index = torch.topk(end_log_probs, self.end_n_top, dim=1) # shape (bsz, end_n_top, start_n_top)\n            end_top_log_probs = end_top_log_probs.view(-1, self.start_n_top * self.end_n_top)\n            end_top_index = end_top_index.view(-1, self.start_n_top * self.end_n_top)\n\n            start_states = torch.einsum(""blh,bl->bh"", hidden_states, start_log_probs)\n            cls_logits = self.answer_class(hidden_states, start_states=start_states, cls_index=cls_index)\n\n            outputs = (start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits) + outputs\n\n        # return start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits\n        # or (if labels are provided) (total_loss,)\n        return outputs\n\n\nclass SequenceSummary(nn.Module):\n    r"""""" Compute a single vector summary of a sequence hidden states according to various possibilities:\n        Args of the config class:\n            summary_type:\n                - \'last\' => [default] take the last token hidden state (like XLNet)\n                - \'first\' => take the first token hidden state (like Bert)\n                - \'mean\' => take the mean of all tokens hidden states\n                - \'cls_index\' => supply a Tensor of classification token position (GPT/GPT-2)\n                - \'attn\' => Not implemented now, use multi-head attention\n            summary_use_proj: Add a projection after the vector extraction\n            summary_proj_to_labels: If True, the projection outputs to config.num_labels classes (otherwise to hidden_size). Default: False.\n            summary_activation: \'tanh\' => add a tanh activation to the output, Other => no activation. Default\n            summary_first_dropout: Add a dropout before the projection and activation\n            summary_last_dropout: Add a dropout after the projection and activation\n    """"""\n    def __init__(self, config):\n        super(SequenceSummary, self).__init__()\n\n        self.summary_type = config.summary_type if hasattr(config, \'summary_use_proj\') else \'last\'\n        if self.summary_type == \'attn\':\n            # We should use a standard multi-head attention module with absolute positional embedding for that.\n            # Cf. https://github.com/zihangdai/xlnet/blob/master/modeling.py#L253-L276\n            # We can probably just use the multi-head attention module of PyTorch >=1.1.0\n            raise NotImplementedError\n\n        self.summary = Identity()\n        if hasattr(config, \'summary_use_proj\') and config.summary_use_proj:\n            if hasattr(config, \'summary_proj_to_labels\') and config.summary_proj_to_labels and config.num_labels > 0:\n                num_classes = config.num_labels\n            else:\n                num_classes = config.hidden_size\n            self.summary = nn.Linear(config.hidden_size, num_classes)\n\n        self.activation = Identity()\n        if hasattr(config, \'summary_activation\') and config.summary_activation == \'tanh\':\n            self.activation = nn.Tanh()\n\n        self.first_dropout = Identity()\n        if hasattr(config, \'summary_first_dropout\') and config.summary_first_dropout > 0:\n            self.first_dropout = nn.Dropout(config.summary_first_dropout)\n\n        self.last_dropout = Identity()\n        if hasattr(config, \'summary_last_dropout\') and config.summary_last_dropout > 0:\n            self.last_dropout = nn.Dropout(config.summary_last_dropout)\n\n    def forward(self, hidden_states, cls_index=None):\n        """""" hidden_states: float Tensor in shape [bsz, ..., seq_len, hidden_size], the hidden-states of the last layer.\n            cls_index: [optional] position of the classification token if summary_type == \'cls_index\',\n                shape (bsz,) or more generally (bsz, ...) where ... are optional leading dimensions of hidden_states.\n                if summary_type == \'cls_index\' and cls_index is None:\n                    we take the last token of the sequence as classification token\n        """"""\n        if self.summary_type == \'last\':\n            output = hidden_states[:, -1]\n        elif self.summary_type == \'first\':\n            output = hidden_states[:, 0]\n        elif self.summary_type == \'mean\':\n            output = hidden_states.mean(dim=1)\n        elif self.summary_type == \'cls_index\':\n            if cls_index is None:\n                cls_index = torch.full_like(hidden_states[..., :1, :], hidden_states.shape[-2]-1, dtype=torch.long)\n            else:\n                cls_index = cls_index.unsqueeze(-1).unsqueeze(-1)\n                cls_index = cls_index.expand((-1,) * (cls_index.dim()-1) + (hidden_states.size(-1),))\n            # shape of cls_index: (bsz, XX, 1, hidden_size) where XX are optional leading dim of hidden_states\n            output = hidden_states.gather(-2, cls_index).squeeze(-2) # shape (bsz, XX, hidden_size)\n        elif self.summary_type == \'attn\':\n            raise NotImplementedError\n\n        output = self.first_dropout(output)\n        output = self.summary(output)\n        output = self.activation(output)\n        output = self.last_dropout(output)\n\n        return output\n\n\ndef prune_linear_layer(layer, index, dim=0):\n    """""" Prune a linear layer (a model parameters) to keep only entries in index.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    index = index.to(layer.weight.device)\n    W = layer.weight.index_select(dim, index).clone().detach()\n    if layer.bias is not None:\n        if dim == 1:\n            b = layer.bias.clone().detach()\n        else:\n            b = layer.bias[index].clone().detach()\n    new_size = list(layer.weight.size())\n    new_size[dim] = len(index)\n    new_layer = nn.Linear(new_size[1], new_size[0], bias=layer.bias is not None).to(layer.weight.device)\n    new_layer.weight.requires_grad = False\n    new_layer.weight.copy_(W.contiguous())\n    new_layer.weight.requires_grad = True\n    if layer.bias is not None:\n        new_layer.bias.requires_grad = False\n        new_layer.bias.copy_(b.contiguous())\n        new_layer.bias.requires_grad = True\n    return new_layer\n\n\ndef prune_conv1d_layer(layer, index, dim=1):\n    """""" Prune a Conv1D layer (a model parameters) to keep only entries in index.\n        A Conv1D work as a Linear layer (see e.g. BERT) but the weights are transposed.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    index = index.to(layer.weight.device)\n    W = layer.weight.index_select(dim, index).clone().detach()\n    if dim == 0:\n        b = layer.bias.clone().detach()\n    else:\n        b = layer.bias[index].clone().detach()\n    new_size = list(layer.weight.size())\n    new_size[dim] = len(index)\n    new_layer = Conv1D(new_size[1], new_size[0]).to(layer.weight.device)\n    new_layer.weight.requires_grad = False\n    new_layer.weight.copy_(W.contiguous())\n    new_layer.weight.requires_grad = True\n    new_layer.bias.requires_grad = False\n    new_layer.bias.copy_(b.contiguous())\n    new_layer.bias.requires_grad = True\n    return new_layer\n\n\ndef prune_layer(layer, index, dim=None):\n    """""" Prune a Conv1D or nn.Linear layer (a model parameters) to keep only entries in index.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    if isinstance(layer, nn.Linear):\n        return prune_linear_layer(layer, index, dim=0 if dim is None else dim)\n    elif isinstance(layer, Conv1D):\n        return prune_conv1d_layer(layer, index, dim=1 if dim is None else dim)\n    else:\n        raise ValueError(""Can\'t prune layer of class {}"".format(layer.__class__))\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_xlm.py,0,"b'# coding=utf-8\n# Copyright 2019-present, Facebook, Inc and the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" PyTorch XLM model.\n""""""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport logging\nimport math\n\nimport itertools\nimport numpy as np\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer, SequenceSummary, SQuADHead\nfrom .configuration_xlm import XLMConfig\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nXLM_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-pytorch_model.bin"",\n    \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-pytorch_model.bin"",\n    \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-pytorch_model.bin"",\n    \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-pytorch_model.bin"",\n    \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-pytorch_model.bin"",\n    \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-pytorch_model.bin"",\n    \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-enfr-1024-pytorch_model.bin"",\n    \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-ende-1024-pytorch_model.bin"",\n    \'xlm-mlm-17-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-17-1280-pytorch_model.bin"",\n    \'xlm-mlm-100-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-100-1280-pytorch_model.bin"",\n}\n\n\ndef create_sinusoidal_embeddings(n_pos, dim, out):\n    position_enc = np.array([\n        [pos / np.power(10000, 2 * (j // 2) / dim) for j in range(dim)]\n        for pos in range(n_pos)\n    ])\n    out[:, 0::2] = torch.FloatTensor(np.sin(position_enc[:, 0::2]))\n    out[:, 1::2] = torch.FloatTensor(np.cos(position_enc[:, 1::2]))\n    out.detach_()\n    out.requires_grad = False\n\n\ndef gelu(x):\n    """"""\n    GELU activation\n    https://arxiv.org/abs/1606.08415\n    https://github.com/huggingface/pytorch-openai-transformer-lm/blob/master/model_pytorch.py#L14\n    https://github.com/huggingface/transformers/blob/master/modeling.py\n    """"""\n    # return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n    return 0.5 * x * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\n\ndef get_masks(slen, lengths, causal, padding_mask=None):\n    """"""\n    Generate hidden states mask, and optionally an attention mask.\n    """"""\n    bs = lengths.size(0)\n    if padding_mask is not None:\n        mask = padding_mask\n    else:\n        assert lengths.max().item() <= slen\n        alen = torch.arange(slen, dtype=torch.long, device=lengths.device)\n        mask = alen < lengths[:, None]\n\n    # attention mask is the same as mask, or triangular inferior attention (causal)\n    if causal:\n        attn_mask = alen[None, None, :].repeat(bs, slen, 1) <= alen[None, :, None]\n    else:\n        attn_mask = mask\n\n    # sanity check\n    assert mask.size() == (bs, slen)\n    assert causal is False or attn_mask.size() == (bs, slen, slen)\n\n    return mask, attn_mask\n\n\nclass MultiHeadAttention(nn.Module):\n\n    NEW_ID = itertools.count()\n\n    def __init__(self, n_heads, dim, config):\n        super(MultiHeadAttention, self).__init__()\n        self.layer_id = next(MultiHeadAttention.NEW_ID)\n        self.output_attentions = config.output_attentions\n        self.dim = dim\n        self.n_heads = n_heads\n        self.dropout = config.attention_dropout\n        assert self.dim % self.n_heads == 0\n\n        self.q_lin = nn.Linear(dim, dim)\n        self.k_lin = nn.Linear(dim, dim)\n        self.v_lin = nn.Linear(dim, dim)\n        self.out_lin = nn.Linear(dim, dim)\n        self.pruned_heads = set()\n\n    def prune_heads(self, heads):\n        attention_head_size = self.dim // self.n_heads\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.n_heads, attention_head_size)\n        heads = set(heads) - self.pruned_heads\n        for head in heads:\n            head -= sum(1 if h < head else 0 for h in self.pruned_heads)\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        # Prune linear layers\n        self.q_lin = prune_linear_layer(self.q_lin, index)\n        self.k_lin = prune_linear_layer(self.k_lin, index)\n        self.v_lin = prune_linear_layer(self.v_lin, index)\n        self.out_lin = prune_linear_layer(self.out_lin, index, dim=1)\n        # Update hyper params\n        self.n_heads = self.n_heads - len(heads)\n        self.dim = attention_head_size * self.n_heads\n        self.pruned_heads = self.pruned_heads.union(heads)\n\n    def forward(self, input, mask, kv=None, cache=None, head_mask=None):\n        """"""\n        Self-attention (if kv is None) or attention over source sentence (provided by kv).\n        """"""\n        # Input is (bs, qlen, dim)\n        # Mask is (bs, klen) (non-causal) or (bs, klen, klen)\n        bs, qlen, dim = input.size()\n        if kv is None:\n            klen = qlen if cache is None else cache[\'slen\'] + qlen\n        else:\n            klen = kv.size(1)\n        # assert dim == self.dim, \'Dimensions do not match: %s input vs %s configured\' % (dim, self.dim)\n        n_heads = self.n_heads\n        dim_per_head = self.dim // n_heads\n        mask_reshape = (bs, 1, qlen, klen) if mask.dim() == 3 else (bs, 1, 1, klen)\n\n        def shape(x):\n            """"""  projection """"""\n            return x.view(bs, -1, self.n_heads, dim_per_head).transpose(1, 2)\n\n        def unshape(x):\n            """"""  compute context """"""\n            return x.transpose(1, 2).contiguous().view(bs, -1, self.n_heads * dim_per_head)\n\n        q = shape(self.q_lin(input))                                          # (bs, n_heads, qlen, dim_per_head)\n        if kv is None:\n            k = shape(self.k_lin(input))                                      # (bs, n_heads, qlen, dim_per_head)\n            v = shape(self.v_lin(input))                                      # (bs, n_heads, qlen, dim_per_head)\n        elif cache is None or self.layer_id not in cache:\n            k = v = kv\n            k = shape(self.k_lin(k))                                          # (bs, n_heads, qlen, dim_per_head)\n            v = shape(self.v_lin(v))                                          # (bs, n_heads, qlen, dim_per_head)\n\n        if cache is not None:\n            if self.layer_id in cache:\n                if kv is None:\n                    k_, v_ = cache[self.layer_id]\n                    k = torch.cat([k_, k], dim=2)                             # (bs, n_heads, klen, dim_per_head)\n                    v = torch.cat([v_, v], dim=2)                             # (bs, n_heads, klen, dim_per_head)\n                else:\n                    k, v = cache[self.layer_id]\n            cache[self.layer_id] = (k, v)\n\n        q = q / math.sqrt(dim_per_head)                                       # (bs, n_heads, qlen, dim_per_head)\n        scores = torch.matmul(q, k.transpose(2, 3))                           # (bs, n_heads, qlen, klen)\n        mask = (mask == 0).view(mask_reshape).expand_as(scores)               # (bs, n_heads, qlen, klen)\n        scores.masked_fill_(mask, -float(\'inf\'))                              # (bs, n_heads, qlen, klen)\n\n        weights = F.softmax(scores.float(), dim=-1).type_as(scores)           # (bs, n_heads, qlen, klen)\n        weights = F.dropout(weights, p=self.dropout, training=self.training)  # (bs, n_heads, qlen, klen)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            weights = weights * head_mask\n\n        context = torch.matmul(weights, v)                                    # (bs, n_heads, qlen, dim_per_head)\n        context = unshape(context)                                            # (bs, qlen, dim)\n\n        outputs = (self.out_lin(context),)\n        if self.output_attentions:\n            outputs = outputs + (weights,)\n        return outputs\n\n\nclass TransformerFFN(nn.Module):\n\n    def __init__(self, in_dim, dim_hidden, out_dim, config):\n        super(TransformerFFN, self).__init__()\n        self.dropout = config.dropout\n        self.lin1 = nn.Linear(in_dim, dim_hidden)\n        self.lin2 = nn.Linear(dim_hidden, out_dim)\n        self.act = gelu if config.gelu_activation else F.relu\n\n    def forward(self, input):\n        x = self.lin1(input)\n        x = self.act(x)\n        x = self.lin2(x)\n        x = F.dropout(x, p=self.dropout, training=self.training)\n        return x\n\n\nclass XLMPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = XLMConfig\n    pretrained_model_archive_map = XLM_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = None\n    base_model_prefix = ""transformer""\n\n    def __init__(self, *inputs, **kwargs):\n        super(XLMPreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def _init_weights(self, module):\n        """""" Initialize the weights. """"""\n        if isinstance(module, nn.Embedding):\n            if self.config is not None and self.config.embed_init_std is not None:\n                nn.init.normal_(module.weight, mean=0, std=self.config.embed_init_std)\n        if isinstance(module, nn.Linear):\n            if self.config is not None and self.config.init_std is not None:\n                nn.init.normal_(module.weight, mean=0, std=self.config.init_std)\n                if hasattr(module, \'bias\') and module.bias is not None:\n                    nn.init.constant_(module.bias, 0.)\n        if isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n\nXLM_START_DOCSTRING = r""""""    The XLM model was proposed in\n    `Cross-lingual Language Model Pretraining`_\n    by Guillaume Lample*, Alexis Conneau*. It\'s a transformer pre-trained using one of the following objectives:\n\n        - a causal language modeling (CLM) objective (next token prediction),\n        - a masked language modeling (MLM) objective (Bert-like), or\n        - a Translation Language Modeling (TLM) object (extension of Bert\'s MLM to multiple language inputs)\n\n    Original code can be found `here`_.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Cross-lingual Language Model Pretraining`:\n        https://arxiv.org/abs/1901.07291\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    .. _`here`:\n        https://github.com/facebookresearch/XLM\n\n    Parameters:\n        config (:class:`~transformers.XLMConfig`): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nXLM_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n\n            XLM is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n\n            Indices can be obtained using :class:`transformers.XLMTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **langs**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens to be used to indicate the language of each token in the input.\n            Indices are languages ids which can be obtained from the language names by using two conversion mappings\n            provided in the configuration of the model (only provided for multilingual models).\n            More precisely, the `language name -> language id` mapping is in `model.config.lang2id` (dict str -> int) and\n            the `language id -> language name` mapping is `model.config.id2lang` (dict int -> str).\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **lengths**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Length of each sentence that can be used to avoid performing attention on padding token indices.\n            You can also use `attention_mask` for the same result (see above), kept here for compatbility.\n            Indices selected in ``[0, ..., input_ids.size(-1)]``:\n        **cache**:\n            dictionary with ``torch.FloatTensor`` that contains pre-computed\n            hidden-states (key and values in the attention blocks) as computed by the model\n            (see `cache` output below). Can be used to speed up sequential decoding.\n            The dictionary object will be modified in-place during the forward pass to add newly computed hidden-states.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare XLM Model transformer outputting raw hidden-states without any specific head on top."",\n                      XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMModel(XLMPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMModel.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):  #, dico, is_encoder, with_output):\n        super(XLMModel, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        # encoder / decoder, output layer\n        self.is_encoder = config.is_encoder\n        self.is_decoder = not config.is_encoder\n        if self.is_decoder:\n            raise NotImplementedError(""Currently XLM can only be used as an encoder"")\n        # self.with_output = with_output\n        self.causal = config.causal\n\n        # dictionary / languages\n        self.n_langs = config.n_langs\n        self.use_lang_emb = config.use_lang_emb\n        self.n_words = config.n_words\n        self.eos_index = config.eos_index\n        self.pad_index = config.pad_index\n        # self.dico = dico\n        # self.id2lang = config.id2lang\n        # self.lang2id = config.lang2id\n        # assert len(self.dico) == self.n_words\n        # assert len(self.id2lang) == len(self.lang2id) == self.n_langs\n\n        # model parameters\n        self.dim = config.emb_dim       # 512 by default\n        self.hidden_dim = self.dim * 4  # 2048 by default\n        self.n_heads = config.n_heads   # 8 by default\n        self.n_layers = config.n_layers\n        self.dropout = config.dropout\n        self.attention_dropout = config.attention_dropout\n        assert self.dim % self.n_heads == 0, \'transformer dim must be a multiple of n_heads\'\n\n        # embeddings\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, self.dim)\n        if config.sinusoidal_embeddings:\n            create_sinusoidal_embeddings(config.max_position_embeddings, self.dim, out=self.position_embeddings.weight)\n        if config.n_langs > 1 and config.use_lang_emb:\n            self.lang_embeddings = nn.Embedding(self.n_langs, self.dim)\n        self.embeddings = nn.Embedding(self.n_words, self.dim, padding_idx=self.pad_index)\n        self.layer_norm_emb = nn.LayerNorm(self.dim, eps=config.layer_norm_eps)\n\n        # transformer layers\n        self.attentions = nn.ModuleList()\n        self.layer_norm1 = nn.ModuleList()\n        self.ffns = nn.ModuleList()\n        self.layer_norm2 = nn.ModuleList()\n        # if self.is_decoder:\n        #     self.layer_norm15 = nn.ModuleList()\n        #     self.encoder_attn = nn.ModuleList()\n\n        for _ in range(self.n_layers):\n            self.attentions.append(MultiHeadAttention(self.n_heads, self.dim, config=config))\n            self.layer_norm1.append(nn.LayerNorm(self.dim, eps=config.layer_norm_eps))\n            # if self.is_decoder:\n            #     self.layer_norm15.append(nn.LayerNorm(self.dim, eps=config.layer_norm_eps))\n            #     self.encoder_attn.append(MultiHeadAttention(self.n_heads, self.dim, dropout=self.attention_dropout))\n            self.ffns.append(TransformerFFN(self.dim, self.hidden_dim, self.dim, config=config))\n            self.layer_norm2.append(nn.LayerNorm(self.dim, eps=config.layer_norm_eps))\n\n        if hasattr(config, ""pruned_heads""):\n            pruned_heads = config.pruned_heads.copy().items()\n            config.pruned_heads = {}\n            for layer, heads in pruned_heads:\n                if self.attentions[int(layer)].n_heads == config.n_heads:\n                    self.prune_heads({int(layer): list(map(int, heads))})\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.embeddings = self._get_resized_embeddings(self.embeddings, new_num_tokens)\n        return self.embeddings\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n            See base class PreTrainedModel\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.attentions[layer].prune_heads(heads)\n\n    def forward(self, input_ids, attention_mask=None, langs=None, token_type_ids=None, position_ids=None,\n                lengths=None, cache=None, head_mask=None):  # removed: src_enc=None, src_len=None\n        if lengths is None:\n            lengths = (input_ids != self.pad_index).sum(dim=1).long()\n        # mask = input_ids != self.pad_index\n\n        # check inputs\n        bs, slen = input_ids.size()\n        assert lengths.size(0) == bs\n        assert lengths.max().item() <= slen\n        # input_ids = input_ids.transpose(0, 1)  # batch size as dimension 0\n        # assert (src_enc is None) == (src_len is None)\n        # if src_enc is not None:\n        #     assert self.is_decoder\n        #     assert src_enc.size(0) == bs\n\n        # generate masks\n        mask, attn_mask = get_masks(slen, lengths, self.causal, padding_mask=attention_mask)\n        # if self.is_decoder and src_enc is not None:\n        #     src_mask = torch.arange(src_len.max(), dtype=torch.long, device=lengths.device) < src_len[:, None]\n\n        # position_ids\n        if position_ids is None:\n            position_ids = input_ids.new((slen,)).long()\n            position_ids = torch.arange(slen, out=position_ids).unsqueeze(0)\n        else:\n            assert position_ids.size() == (bs, slen)  # (slen, bs)\n            # position_ids = position_ids.transpose(0, 1)\n\n        # langs\n        if langs is not None:\n            assert langs.size() == (bs, slen)  # (slen, bs)\n            # langs = langs.transpose(0, 1)\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x qlen x klen]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.n_layers, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.n_layers\n\n        # do not recompute cached elements\n        if cache is not None:\n            _slen = slen - cache[\'slen\']\n            input_ids = input_ids[:, -_slen:]\n            position_ids = position_ids[:, -_slen:]\n            if langs is not None:\n                langs = langs[:, -_slen:]\n            mask = mask[:, -_slen:]\n            attn_mask = attn_mask[:, -_slen:]\n\n        # embeddings\n        tensor = self.embeddings(input_ids)\n        tensor = tensor + self.position_embeddings(position_ids).expand_as(tensor)\n        if langs is not None and self.use_lang_emb:\n            tensor = tensor + self.lang_embeddings(langs)\n        if token_type_ids is not None:\n            tensor = tensor + self.embeddings(token_type_ids)\n        tensor = self.layer_norm_emb(tensor)\n        tensor = F.dropout(tensor, p=self.dropout, training=self.training)\n        tensor *= mask.unsqueeze(-1).to(tensor.dtype)\n\n        # transformer layers\n        hidden_states = ()\n        attentions = ()\n        for i in range(self.n_layers):\n            if self.output_hidden_states:\n                hidden_states = hidden_states + (tensor,)\n\n            # self attention\n            attn_outputs = self.attentions[i](tensor, attn_mask, cache=cache, head_mask=head_mask[i])\n            attn = attn_outputs[0]\n            if self.output_attentions:\n                attentions = attentions + (attn_outputs[1],)\n            attn = F.dropout(attn, p=self.dropout, training=self.training)\n            tensor = tensor + attn\n            tensor = self.layer_norm1[i](tensor)\n\n            # encoder attention (for decoder only)\n            # if self.is_decoder and src_enc is not None:\n            #     attn = self.encoder_attn[i](tensor, src_mask, kv=src_enc, cache=cache)\n            #     attn = F.dropout(attn, p=self.dropout, training=self.training)\n            #     tensor = tensor + attn\n            #     tensor = self.layer_norm15[i](tensor)\n\n            # FFN\n            tensor = tensor + self.ffns[i](tensor)\n            tensor = self.layer_norm2[i](tensor)\n            tensor *= mask.unsqueeze(-1).to(tensor.dtype)\n\n        # Add last hidden state\n        if self.output_hidden_states:\n            hidden_states = hidden_states + (tensor,)\n\n        # update cache length\n        if cache is not None:\n            cache[\'slen\'] += tensor.size(1)\n\n        # move back sequence length to dimension 0\n        # tensor = tensor.transpose(0, 1)\n\n        outputs = (tensor,)\n        if self.output_hidden_states:\n            outputs = outputs + (hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (attentions,)\n        return outputs  # outputs, (hidden_states), (attentions)\n\n\nclass XLMPredLayer(nn.Module):\n    """"""\n    Prediction layer (cross_entropy or adaptive_softmax).\n    """"""\n    def __init__(self, config):\n        super(XLMPredLayer, self).__init__()\n        self.asm = config.asm\n        self.n_words = config.n_words\n        self.pad_index = config.pad_index\n        dim = config.emb_dim\n\n        if config.asm is False:\n            self.proj = nn.Linear(dim, config.n_words, bias=True)\n        else:\n            self.proj = nn.AdaptiveLogSoftmaxWithLoss(\n                in_features=dim,\n                n_classes=config.n_words,\n                cutoffs=config.asm_cutoffs,\n                div_value=config.asm_div_value,\n                head_bias=True,  # default is False\n            )\n\n    def forward(self, x, y=None):\n        """""" Compute the loss, and optionally the scores.\n        """"""\n        outputs = ()\n        if self.asm is False:\n            scores = self.proj(x)\n            outputs = (scores,) + outputs\n            if y is not None:\n                loss = F.cross_entropy(scores.view(-1, self.n_words), y.view(-1), reduction=\'elementwise_mean\')\n                outputs = (loss,) + outputs\n        else:\n            scores = self.proj.log_prob(x)\n            outputs = (scores,) + outputs\n            if y is not None:\n                _, loss = self.proj(x, y)\n                outputs = (loss,) + outputs\n\n        return outputs\n\n\n@add_start_docstrings(""""""The XLM Model transformer with a language modeling head on top\n    (linear layer with weights tied to the input embeddings). """""",\n    XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMWithLMHeadModel(XLMPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMWithLMHeadModel.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(XLMWithLMHeadModel, self).__init__(config)\n        self.transformer = XLMModel(config)\n        self.pred_layer = XLMPredLayer(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the embeddings\n        """"""\n        self._tie_or_clone_weights(self.pred_layer.proj, self.transformer.embeddings)\n\n    def forward(self, input_ids, attention_mask=None, langs=None, token_type_ids=None, position_ids=None,\n                lengths=None, cache=None, head_mask=None, labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               langs=langs,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               lengths=lengths, \n                                               cache=cache,\n                                               head_mask=head_mask)\n\n        output = transformer_outputs[0]\n        outputs = self.pred_layer(output, labels)\n        outputs = outputs + transformer_outputs[1:]  # Keep new_mems and attention/hidden states if they are here\n\n        return outputs\n\n\n@add_start_docstrings(""""""XLM Model with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n    XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMForSequenceClassification(XLMPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMForSequenceClassification.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLMForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.transformer = XLMModel(config)\n        self.sequence_summary = SequenceSummary(config)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, langs=None, token_type_ids=None, position_ids=None,\n                lengths=None, cache=None, head_mask=None, labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               langs=langs,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               lengths=lengths, \n                                               cache=cache,\n                                               head_mask=head_mask)\n\n        output = transformer_outputs[0]\n        logits = self.sequence_summary(output)\n\n        outputs = (logits,) + transformer_outputs[1:]  # Keep new_mems and attention/hidden states if they are here\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs\n\n\n@add_start_docstrings(""""""XLM Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMForQuestionAnsweringSimple(XLMPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **is_impossible**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels whether a question has an answer or no answer (SQuAD 2.0)\n        **cls_index**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the classification token to use as input for computing plausibility of the answer.\n        **p_mask**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Optional mask of tokens which can\'t be in answers (e.g. [CLS], [PAD], ...) \n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMForQuestionAnsweringSimple.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLMForQuestionAnsweringSimple, self).__init__(config)\n\n        self.transformer = XLMModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, langs=None, token_type_ids=None, position_ids=None,\n                lengths=None, cache=None, head_mask=None, start_positions=None, end_positions=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               langs=langs,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               lengths=lengths, \n                                               cache=cache,\n                                               head_mask=head_mask)\n\n        sequence_output = transformer_outputs[0]\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        outputs = (start_logits, end_logits,)\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            outputs = (total_loss,) + outputs\n\n        outputs = outputs + transformer_outputs[1:]  # Keep new_mems and attention/hidden states if they are here\n\n        return outputs\n\n\n@add_start_docstrings(""""""XLM Model with a beam-search span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMForQuestionAnswering(XLMPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **is_impossible**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels whether a question has an answer or no answer (SQuAD 2.0)\n        **cls_index**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the classification token to use as input for computing plausibility of the answer.\n        **p_mask**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Optional mask of tokens which can\'t be in answers (e.g. [CLS], [PAD], ...) \n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMForQuestionAnswering.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLMForQuestionAnswering, self).__init__(config)\n\n        self.transformer = XLMModel(config)\n        self.qa_outputs = SQuADHead(config)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, langs=None, token_type_ids=None, position_ids=None,\n                lengths=None, cache=None, head_mask=None, start_positions=None, end_positions=None,\n                is_impossible=None, cls_index=None, p_mask=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               langs=langs,\n                                               token_type_ids=token_type_ids,\n                                               position_ids=position_ids,\n                                               lengths=lengths, \n                                               cache=cache,\n                                               head_mask=head_mask)\n\n        output = transformer_outputs[0]\n\n        outputs = self.qa_outputs(output, start_positions=start_positions, end_positions=end_positions,\n                                  cls_index=cls_index, is_impossible=is_impossible, p_mask=p_mask)\n\n        outputs = outputs + transformer_outputs[1:]  # Keep new_mems and attention/hidden states if they are here\n\n        return outputs\n'"
baselines/models_pytorch/classifier_pytorch/transformers/modeling_xlnet.py,2,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" PyTorch XLNet model.\n""""""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer, SequenceSummary, PoolerAnswerClass, PoolerEndLogits, PoolerStartLogits\nfrom .configuration_xlnet import XLNetConfig\nfrom .file_utils import add_start_docstrings\n\n\nlogger = logging.getLogger(__name__)\n\nXLNET_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'xlnet-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-base-cased-pytorch_model.bin"",\n    \'xlnet-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-large-cased-pytorch_model.bin"",\n}\n\n\ndef build_tf_xlnet_to_pytorch_map(model, config, tf_weights=None):\n    """""" A map of modules from TF to PyTorch.\n        I use a map to keep the PyTorch model as\n        identical to the original PyTorch model as possible.\n    """"""\n\n    tf_to_pt_map = {}\n\n    if hasattr(model, \'transformer\'):\n        if hasattr(model, \'lm_loss\'):\n            # We will load also the output bias\n            tf_to_pt_map[\'model/lm_loss/bias\'] = model.lm_loss.bias\n        if hasattr(model, \'sequence_summary\') and \'model/sequnece_summary/summary/kernel\' in tf_weights:\n            # We will load also the sequence summary\n            tf_to_pt_map[\'model/sequnece_summary/summary/kernel\'] = model.sequence_summary.summary.weight\n            tf_to_pt_map[\'model/sequnece_summary/summary/bias\'] = model.sequence_summary.summary.bias\n        if hasattr(model, \'logits_proj\') and config.finetuning_task is not None \\\n                and \'model/regression_{}/logit/kernel\'.format(config.finetuning_task) in tf_weights:\n            tf_to_pt_map[\'model/regression_{}/logit/kernel\'.format(config.finetuning_task)] = model.logits_proj.weight\n            tf_to_pt_map[\'model/regression_{}/logit/bias\'.format(config.finetuning_task)] = model.logits_proj.bias\n\n        # Now load the rest of the transformer\n        model = model.transformer\n\n    # Embeddings and output\n    tf_to_pt_map.update({\'model/transformer/word_embedding/lookup_table\': model.word_embedding.weight,\n                         \'model/transformer/mask_emb/mask_emb\': model.mask_emb})\n\n    # Transformer blocks\n    for i, b in enumerate(model.layer):\n        layer_str = ""model/transformer/layer_%d/"" % i\n        tf_to_pt_map.update({\n            layer_str + ""rel_attn/LayerNorm/gamma"": b.rel_attn.layer_norm.weight,\n            layer_str + ""rel_attn/LayerNorm/beta"": b.rel_attn.layer_norm.bias,\n            layer_str + ""rel_attn/o/kernel"": b.rel_attn.o,\n            layer_str + ""rel_attn/q/kernel"": b.rel_attn.q,\n            layer_str + ""rel_attn/k/kernel"": b.rel_attn.k,\n            layer_str + ""rel_attn/r/kernel"": b.rel_attn.r,\n            layer_str + ""rel_attn/v/kernel"": b.rel_attn.v,\n            layer_str + ""ff/LayerNorm/gamma"": b.ff.layer_norm.weight,\n            layer_str + ""ff/LayerNorm/beta"": b.ff.layer_norm.bias,\n            layer_str + ""ff/layer_1/kernel"": b.ff.layer_1.weight,\n            layer_str + ""ff/layer_1/bias"": b.ff.layer_1.bias,\n            layer_str + ""ff/layer_2/kernel"": b.ff.layer_2.weight,\n            layer_str + ""ff/layer_2/bias"": b.ff.layer_2.bias,\n        })\n\n    # Relative positioning biases\n    if config.untie_r:\n        r_r_list = []\n        r_w_list = []\n        r_s_list = []\n        seg_embed_list = []\n        for b in model.layer:\n            r_r_list.append(b.rel_attn.r_r_bias)\n            r_w_list.append(b.rel_attn.r_w_bias)\n            r_s_list.append(b.rel_attn.r_s_bias)\n            seg_embed_list.append(b.rel_attn.seg_embed)\n    else:\n        r_r_list = [model.r_r_bias]\n        r_w_list = [model.r_w_bias]\n        r_s_list = [model.r_s_bias]\n        seg_embed_list = [model.seg_embed]\n    tf_to_pt_map.update({\n        \'model/transformer/r_r_bias\': r_r_list,\n        \'model/transformer/r_w_bias\': r_w_list,\n        \'model/transformer/r_s_bias\': r_s_list,\n        \'model/transformer/seg_embed\': seg_embed_list})\n    return tf_to_pt_map\n\ndef load_tf_weights_in_xlnet(model, config, tf_path):\n    """""" Load tf checkpoints in a pytorch model\n    """"""\n    try:\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow models in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    tf_weights = {}\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        tf_weights[name] = array\n\n    # Build TF to PyTorch weights loading map\n    tf_to_pt_map = build_tf_xlnet_to_pytorch_map(model, config, tf_weights)\n\n    for name, pointer in tf_to_pt_map.items():\n        logger.info(""Importing {}"".format(name))\n        if name not in tf_weights:\n            logger.info(""{} not in tf pre-trained weights, skipping"".format(name))\n            continue\n        array = tf_weights[name]\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if \'kernel\' in name and (\'ff\' in name or \'summary\' in name or \'logit\' in name):\n            logger.info(""Transposing"")\n            array = np.transpose(array)\n        if isinstance(pointer, list):\n            # Here we will split the TF weigths\n            assert len(pointer) == array.shape[0]\n            for i, p_i in enumerate(pointer):\n                arr_i = array[i, ...]\n                try:\n                    assert p_i.shape == arr_i.shape\n                except AssertionError as e:\n                    e.args += (p_i.shape, arr_i.shape)\n                    raise\n                logger.info(""Initialize PyTorch weight {} for layer {}"".format(name, i))\n                p_i.data = torch.from_numpy(arr_i)\n        else:\n            try:\n                assert pointer.shape == array.shape\n            except AssertionError as e:\n                e.args += (pointer.shape, array.shape)\n                raise\n            logger.info(""Initialize PyTorch weight {}"".format(name))\n            pointer.data = torch.from_numpy(array)\n        tf_weights.pop(name, None)\n        tf_weights.pop(name + \'/Adam\', None)\n        tf_weights.pop(name + \'/Adam_1\', None)\n\n    logger.info(""Weights not copied to PyTorch model: {}"".format(\', \'.join(tf_weights.keys())))\n    return model\n\n\ndef gelu(x):\n    """""" Implementation of the gelu activation function.\n        XLNet is using OpenAI GPT\'s gelu (not exactly the same as BERT)\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    cdf = 0.5 * (1.0 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n    return x * cdf\n\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT2FN = {""gelu"": gelu, ""relu"": torch.nn.functional.relu, ""swish"": swish}\n\n\ntry:\n    from apex.normalization.fused_layer_norm import FusedLayerNorm as XLNetLayerNorm\nexcept (ImportError, AttributeError) as e:\n    logger.info(""Better speed can be achieved with apex installed from https://www.github.com/nvidia/apex ."")\n    from torch.nn import LayerNorm as XLNetLayerNorm\n\nclass XLNetRelativeAttention(nn.Module):\n    def __init__(self, config):\n        super(XLNetRelativeAttention, self).__init__()\n        self.output_attentions = config.output_attentions\n\n        if config.d_model % config.n_head != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.d_model, config.n_head))\n\n        self.n_head = config.n_head\n        self.d_head = config.d_head\n        self.d_model = config.d_model\n        self.scale = 1 / (config.d_head ** 0.5)\n\n        self.q = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.k = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.v = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.o = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.r = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n\n        self.r_r_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        self.r_s_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        self.r_w_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        self.seg_embed = nn.Parameter(torch.FloatTensor(2, self.n_head, self.d_head))\n\n        self.layer_norm = XLNetLayerNorm(config.d_model, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.dropout)\n\n    def prune_heads(self, heads):\n        raise NotImplementedError\n\n    @staticmethod\n    def rel_shift(x, klen=-1):\n        """"""perform relative shift to form the relative attention score.""""""\n        x_size = x.shape\n\n        x = x.reshape(x_size[1], x_size[0], x_size[2], x_size[3])\n        x = x[1:, ...]\n        x = x.reshape(x_size[0], x_size[1] - 1, x_size[2], x_size[3])\n        # x = x[:, 0:klen, :, :]\n        x = torch.index_select(x, 1, torch.arange(klen, device=x.device, dtype=torch.long))\n\n        return x\n\n    @staticmethod\n    def rel_shift_bnij(x, klen=-1):\n        x_size = x.shape\n\n        x = x.reshape(x_size[0], x_size[1], x_size[3], x_size[2])\n        x = x[:, :, 1:, :]\n        x = x.reshape(x_size[0], x_size[1], x_size[2], x_size[3]-1)\n        # Note: the tensor-slice form was faster in my testing than torch.index_select\n        #       However, tracing doesn\'t like the nature of the slice, and if klen changes\n        #       during the run then it\'ll fail, whereas index_select will be fine.\n        x = torch.index_select(x, 3, torch.arange(klen, device=x.device, dtype=torch.long))\n        # x = x[:, :, :, :klen]\n\n        return x\n\n    def rel_attn_core(self, q_head, k_head_h, v_head_h, k_head_r, seg_mat=None, attn_mask=None, head_mask=None):\n        """"""Core relative positional attention operations.""""""\n\n        # content based attention score\n        ac = torch.einsum(\'ibnd,jbnd->bnij\', q_head + self.r_w_bias, k_head_h)\n\n        # position based attention score\n        bd = torch.einsum(\'ibnd,jbnd->bnij\', q_head + self.r_r_bias, k_head_r)\n        bd = self.rel_shift_bnij(bd, klen=ac.shape[3])\n\n        # segment based attention score\n        if seg_mat is None:\n            ef = 0\n        else:\n            ef = torch.einsum(\'ibnd,snd->ibns\', q_head + self.r_s_bias, self.seg_embed)\n            ef = torch.einsum(\'ijbs,ibns->bnij\', seg_mat, ef)\n\n        # merge attention scores and perform masking\n        attn_score = (ac + bd + ef) * self.scale\n        if attn_mask is not None:\n            # attn_score = attn_score * (1 - attn_mask) - 1e30 * attn_mask\n            if attn_mask.dtype == torch.float16:\n                attn_score = attn_score - 65500 * torch.einsum(\'ijbn->bnij\', attn_mask)\n            else:\n                attn_score = attn_score - 1e30 * torch.einsum(\'ijbn->bnij\', attn_mask)\n\n        # attention probability\n        attn_prob = F.softmax(attn_score, dim=3)\n        attn_prob = self.dropout(attn_prob)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attn_prob = attn_prob * torch.einsum(\'ijbn->bnij\', head_mask)\n\n        # attention output\n        attn_vec = torch.einsum(\'bnij,jbnd->ibnd\', attn_prob, v_head_h)\n\n        if self.output_attentions:\n            return attn_vec, torch.einsum(\'bnij->ijbn\', attn_prob)\n\n        return attn_vec\n\n    def post_attention(self, h, attn_vec, residual=True):\n        """"""Post-attention processing.""""""\n        # post-attention projection (back to `d_model`)\n        attn_out = torch.einsum(\'ibnd,hnd->ibh\', attn_vec, self.o)\n\n        attn_out = self.dropout(attn_out)\n        if residual:\n            attn_out = attn_out + h\n        output = self.layer_norm(attn_out)\n\n        return output\n\n    def forward(self, h, g,\n                      attn_mask_h, attn_mask_g,\n                      r, seg_mat,\n                      mems=None, target_mapping=None, head_mask=None):\n        if g is not None:\n            ###### Two-stream attention with relative positional encoding.\n            # content based attention score\n            if mems is not None and mems.dim() > 1:\n                cat = torch.cat([mems, h], dim=0)\n            else:\n                cat = h\n\n            # content-based key head\n            k_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.k)\n\n            # content-based value head\n            v_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.v)\n\n            # position-based key head\n            k_head_r = torch.einsum(\'ibh,hnd->ibnd\', r, self.r)\n\n            ##### h-stream\n            # content-stream query head\n            q_head_h = torch.einsum(\'ibh,hnd->ibnd\', h, self.q)\n\n            # core attention ops\n            attn_vec_h = self.rel_attn_core(\n                q_head_h, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_h, head_mask=head_mask)\n\n            if self.output_attentions:\n                attn_vec_h, attn_prob_h = attn_vec_h\n\n            # post processing\n            output_h = self.post_attention(h, attn_vec_h)\n\n            ##### g-stream\n            # query-stream query head\n            q_head_g = torch.einsum(\'ibh,hnd->ibnd\', g, self.q)\n\n            # core attention ops\n            if target_mapping is not None:\n                q_head_g = torch.einsum(\'mbnd,mlb->lbnd\', q_head_g, target_mapping)\n                attn_vec_g = self.rel_attn_core(\n                    q_head_g, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_g, head_mask=head_mask)\n\n                if self.output_attentions:\n                    attn_vec_g, attn_prob_g = attn_vec_g\n\n                attn_vec_g = torch.einsum(\'lbnd,mlb->mbnd\', attn_vec_g, target_mapping)\n            else:\n                attn_vec_g = self.rel_attn_core(\n                    q_head_g, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_g, head_mask=head_mask)\n\n                if self.output_attentions:\n                    attn_vec_g, attn_prob_g = attn_vec_g\n\n            # post processing\n            output_g = self.post_attention(g, attn_vec_g)\n\n            if self.output_attentions:\n                attn_prob = attn_prob_h, attn_prob_g\n\n        else:\n            ###### Multi-head attention with relative positional encoding\n            if mems is not None and mems.dim() > 1:\n                cat = torch.cat([mems, h], dim=0)\n            else:\n                cat = h\n\n            # content heads\n            q_head_h = torch.einsum(\'ibh,hnd->ibnd\', h, self.q)\n            k_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.k)\n            v_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.v)\n\n            # positional heads\n            k_head_r = torch.einsum(\'ibh,hnd->ibnd\', r, self.r)\n\n            # core attention ops\n            attn_vec = self.rel_attn_core(\n                q_head_h, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_h, head_mask=head_mask)\n\n            if self.output_attentions:\n                attn_vec, attn_prob = attn_vec\n\n            # post processing\n            output_h = self.post_attention(h, attn_vec)\n            output_g = None\n\n        outputs = (output_h, output_g)\n        if self.output_attentions:\n            outputs = outputs + (attn_prob,)\n        return outputs\n\nclass XLNetFeedForward(nn.Module):\n    def __init__(self, config):\n        super(XLNetFeedForward, self).__init__()\n        self.layer_norm = XLNetLayerNorm(config.d_model, eps=config.layer_norm_eps)\n        self.layer_1 = nn.Linear(config.d_model, config.d_inner)\n        self.layer_2 = nn.Linear(config.d_inner, config.d_model)\n        self.dropout = nn.Dropout(config.dropout)\n        if isinstance(config.ff_activation, str) or \\\n                (sys.version_info[0] == 2 and isinstance(config.ff_activation, unicode)):\n            self.activation_function = ACT2FN[config.ff_activation]\n        else:\n            self.activation_function = config.ff_activation\n\n    def forward(self, inp):\n        output = inp\n        output = self.layer_1(output)\n        output = self.activation_function(output)\n        output = self.dropout(output)\n        output = self.layer_2(output)\n        output = self.dropout(output)\n        output = self.layer_norm(output + inp)\n        return output\n\nclass XLNetLayer(nn.Module):\n    def __init__(self, config):\n        super(XLNetLayer, self).__init__()\n        self.rel_attn = XLNetRelativeAttention(config)\n        self.ff = XLNetFeedForward(config)\n        self.dropout = nn.Dropout(config.dropout)\n\n    def forward(self, output_h, output_g,\n                attn_mask_h, attn_mask_g,\n                r, seg_mat, mems=None, target_mapping=None, head_mask=None):\n        outputs = self.rel_attn(output_h, output_g, attn_mask_h, attn_mask_g,\n                                r, seg_mat, mems=mems, target_mapping=target_mapping,\n                                head_mask=head_mask)\n        output_h, output_g = outputs[:2]\n\n        if output_g is not None:\n            output_g = self.ff(output_g)\n        output_h = self.ff(output_h)\n\n        outputs = (output_h, output_g) + outputs[2:]  # Add again attentions if there are there\n        return outputs\n\n\nclass XLNetPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = XLNetConfig\n    pretrained_model_archive_map = XLNET_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_xlnet\n    base_model_prefix = ""transformer""\n\n    def _init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, XLNetLayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n        elif isinstance(module, XLNetRelativeAttention):\n            for param in [module.q, module.k, module.v, module.o, module.r,\n                          module.r_r_bias, module.r_s_bias, module.r_w_bias,\n                          module.seg_embed]:\n                param.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, XLNetModel):\n                module.mask_emb.data.normal_(mean=0.0, std=self.config.initializer_range)\n\n\nXLNET_START_DOCSTRING = r""""""    The XLNet model was proposed in\n    `XLNet: Generalized Autoregressive Pretraining for Language Understanding`_\n    by Zhilin Yang*, Zihang Dai*, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, Quoc V. Le.\n    XLnet is an extension of the Transformer-XL model pre-trained using an autoregressive method\n    to learn bidirectional contexts by maximizing the expected likelihood over all permutations\n    of the input sequence factorization order.\n\n    The specific attention pattern can be controlled at training and test time using the `perm_mask` input.\n\n    Do to the difficulty of training a fully auto-regressive model over various factorization order,\n    XLNet is pretrained using only a sub-set of the output tokens as target which are selected\n    with the `target_mapping` input.\n\n    To use XLNet for sequential decoding (i.e. not in fully bi-directional setting), use the `perm_mask` and\n    `target_mapping` inputs to control the attention span and outputs (see examples in `examples/run_generation.py`)\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`XLNet: Generalized Autoregressive Pretraining for Language Understanding`:\n        http://arxiv.org/abs/1906.08237\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.XLNetConfig`): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nXLNET_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            XLNet is a model with relative position embeddings so you can either pad the inputs on\n            the right or on the left.\n            Indices can be obtained using :class:`transformers.XLNetTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The type indices in XLNet are NOT selected in the vocabulary, they can be arbitrary numbers and\n            the important thing is that they should be different for tokens which belong to different segments.\n            The model will compute relative segment differences from the given type indices:\n            0 if the segment id of two tokens are the same, 1 if not.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **mems**: (`optional`)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as output by the model\n            (see `mems` output below). Can be used to speed up sequential decoding and attend to longer context.\n            To activate mems you need to set up config.mem_len to a positive value which will be the max number of tokens in\n            the memory output by the model. E.g. `model = XLNetModel.from_pretrained(\'xlnet-base-case, mem_len=1024)` will\n            instantiate a model which can use up to 1024 tokens of memory (in addition to the input it self).\n        **perm_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, sequence_length)``:\n            Mask to indicate the attention pattern for each input token with values selected in ``[0, 1]``:\n            If ``perm_mask[k, i, j] = 0``, i attend to j in batch k;\n            if ``perm_mask[k, i, j] = 1``, i does not attend to j in batch k.\n            If None, each token attends to all the others (full bidirectional attention).\n            Only used during pretraining (to define factorization order) or for sequential decoding (generation).\n        **target_mapping**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, num_predict, sequence_length)``:\n            Mask to indicate the output tokens to use.\n            If ``target_mapping[k, i, j] = 1``, the i-th predict in batch k is on the j-th token.\n            Only used during pretraining for partial prediction or for sequential decoding (generation).\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The type indices in XLNet are NOT selected in the vocabulary, they can be arbitrary numbers and\n            the important thing is that they should be different for tokens which belong to different segments.\n            The model will compute relative segment differences from the given type indices:\n            0 if the segment id of two tokens are the same, 1 if not.\n        **input_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Negative of `attention_mask`, i.e. with 0 for real tokens and 1 for padding.\n            Kept for compatibility with the original code base.\n            You can only uses one of `input_mask` and `attention_mask`\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are MASKED, ``0`` for tokens that are NOT MASKED.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare XLNet Model transformer outputting raw hidden-states without any specific head on top."",\n                      XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetModel(XLNetPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **mems**: (`optional`, returned when ``config.mem_len > 0``)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            if config.mem_len > 0 else tuple of None. Can be used to speed up sequential decoding and attend to longer context.\n            See details in the docstring of the `mems` input above.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLNetModel.from_pretrained(\'xlnet-large-cased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(XLNetModel, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n        self.output_past = config.output_past\n\n        self.mem_len = config.mem_len\n        self.reuse_len = config.reuse_len\n        self.d_model = config.d_model\n        self.same_length = config.same_length\n        self.attn_type = config.attn_type\n        self.bi_data = config.bi_data\n        self.clamp_len = config.clamp_len\n        self.n_layer = config.n_layer\n\n        self.word_embedding = nn.Embedding(config.n_token, config.d_model)\n        self.mask_emb = nn.Parameter(torch.FloatTensor(1, 1, config.d_model))\n        self.layer = nn.ModuleList([XLNetLayer(config) for _ in range(config.n_layer)])\n        self.dropout = nn.Dropout(config.dropout)\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.word_embedding = self._get_resized_embeddings(self.word_embedding, new_num_tokens)\n        return self.word_embedding\n\n    def _prune_heads(self, heads_to_prune):\n        raise NotImplementedError\n\n    def create_mask(self, qlen, mlen):\n        """"""\n        Creates causal attention mask. Float mask where 1.0 indicates masked, 0.0 indicates not-masked.\n\n        Args:\n            qlen: TODO Lysandre didn\'t fill\n            mlen: TODO Lysandre didn\'t fill\n\n        ::\n\n                  same_length=False:      same_length=True:\n                  <mlen > <  qlen >       <mlen > <  qlen >\n               ^ [0 0 0 0 0 1 1 1 1]     [0 0 0 0 0 1 1 1 1]\n                 [0 0 0 0 0 0 1 1 1]     [1 0 0 0 0 0 1 1 1]\n            qlen [0 0 0 0 0 0 0 1 1]     [1 1 0 0 0 0 0 1 1]\n                 [0 0 0 0 0 0 0 0 1]     [1 1 1 0 0 0 0 0 1]\n               v [0 0 0 0 0 0 0 0 0]     [1 1 1 1 0 0 0 0 0]\n\n        """"""\n        attn_mask = torch.ones([qlen, qlen])\n        mask_up = torch.triu(attn_mask, diagonal=1)\n        attn_mask_pad = torch.zeros([qlen, mlen])\n        ret = torch.cat([attn_mask_pad, mask_up], dim=1)\n        if self.same_length:\n            mask_lo = torch.tril(attn_mask, diagonal=-1)\n            ret = torch.cat([ret[:, :qlen] + mask_lo, ret[:, qlen:]], dim=1)\n\n        ret = ret.to(next(self.parameters()))\n        return ret\n\n    def cache_mem(self, curr_out, prev_mem):\n        """"""cache hidden states into memory.""""""\n        if self.reuse_len is not None and self.reuse_len > 0:\n            curr_out = curr_out[:self.reuse_len]\n\n        if prev_mem is None:\n            new_mem = curr_out[-self.mem_len:]\n        else:\n            new_mem = torch.cat([prev_mem, curr_out], dim=0)[-self.mem_len:]\n\n        return new_mem.detach()\n\n    @staticmethod\n    def positional_embedding(pos_seq, inv_freq, bsz=None):\n        sinusoid_inp = torch.einsum(\'i,d->id\', pos_seq, inv_freq)\n        pos_emb = torch.cat([torch.sin(sinusoid_inp), torch.cos(sinusoid_inp)], dim=-1)\n        pos_emb = pos_emb[:, None, :]\n\n        if bsz is not None:\n            pos_emb = pos_emb.expand(-1, bsz, -1)\n\n        return pos_emb\n\n    def relative_positional_encoding(self, qlen, klen, bsz=None):\n        """"""create relative positional encoding.""""""\n        freq_seq = torch.arange(0, self.d_model, 2.0, dtype=torch.float)\n        inv_freq = 1 / torch.pow(10000, (freq_seq / self.d_model))\n\n        if self.attn_type == \'bi\':\n            # beg, end = klen - 1, -qlen\n            beg, end = klen, -qlen\n        elif self.attn_type == \'uni\':\n            # beg, end = klen - 1, -1\n            beg, end = klen, -1\n        else:\n            raise ValueError(\'Unknown `attn_type` {}.\'.format(self.attn_type))\n\n        if self.bi_data:\n            fwd_pos_seq = torch.arange(beg, end, -1.0, dtype=torch.float)\n            bwd_pos_seq = torch.arange(-beg, -end, 1.0, dtype=torch.float)\n\n            if self.clamp_len > 0:\n                fwd_pos_seq = fwd_pos_seq.clamp(-self.clamp_len, self.clamp_len)\n                bwd_pos_seq = bwd_pos_seq.clamp(-self.clamp_len, self.clamp_len)\n\n            if bsz is not None:\n                fwd_pos_emb = self.positional_embedding(fwd_pos_seq, inv_freq, bsz//2)\n                bwd_pos_emb = self.positional_embedding(bwd_pos_seq, inv_freq, bsz//2)\n            else:\n                fwd_pos_emb = self.positional_embedding(fwd_pos_seq, inv_freq)\n                bwd_pos_emb = self.positional_embedding(bwd_pos_seq, inv_freq)\n\n            pos_emb = torch.cat([fwd_pos_emb, bwd_pos_emb], dim=1)\n        else:\n            fwd_pos_seq = torch.arange(beg, end, -1.0)\n            if self.clamp_len > 0:\n                fwd_pos_seq = fwd_pos_seq.clamp(-self.clamp_len, self.clamp_len)\n            pos_emb = self.positional_embedding(fwd_pos_seq, inv_freq, bsz)\n\n        pos_emb = pos_emb.to(next(self.parameters()))\n        return pos_emb\n\n    def forward(self, input_ids, attention_mask=None, mems=None, perm_mask=None, target_mapping=None,\n                token_type_ids=None, input_mask=None, head_mask=None):\n        # the original code for XLNet uses shapes [len, bsz] with the batch dimension at the end\n        # but we want a unified interface in the library with the batch size on the first dimension\n        # so we move here the first dimension (batch) to the end\n        input_ids = input_ids.transpose(0, 1).contiguous()\n        token_type_ids = token_type_ids.transpose(0, 1).contiguous() if token_type_ids is not None else None\n        input_mask = input_mask.transpose(0, 1).contiguous() if input_mask is not None else None\n        attention_mask = attention_mask.transpose(0, 1).contiguous() if attention_mask is not None else None\n        perm_mask = perm_mask.permute(1, 2, 0).contiguous() if perm_mask is not None else None\n        target_mapping = target_mapping.permute(1, 2, 0).contiguous() if target_mapping is not None else None\n\n        qlen, bsz = input_ids.shape[0], input_ids.shape[1]\n        mlen = mems[0].shape[0] if mems is not None and mems[0] is not None else 0\n        klen = mlen + qlen\n\n        dtype_float = next(self.parameters()).dtype\n        device = next(self.parameters()).device\n\n        ##### Attention mask\n        # causal attention mask\n        if self.attn_type == \'uni\':\n            attn_mask = self.create_mask(qlen, mlen)\n            attn_mask = attn_mask[:, :, None, None]\n        elif self.attn_type == \'bi\':\n            attn_mask = None\n        else:\n            raise ValueError(\'Unsupported attention type: {}\'.format(self.attn_type))\n\n        # data mask: input mask & perm mask\n        assert input_mask is None or attention_mask is None, ""You can only use one of input_mask (uses 1 for padding) ""\n        ""or attention_mask (uses 0 for padding, added for compatbility with BERT). Please choose one.""\n        if input_mask is None and attention_mask is not None:\n            input_mask = 1.0 - attention_mask\n        if input_mask is not None and perm_mask is not None:\n            data_mask = input_mask[None] + perm_mask\n        elif input_mask is not None and perm_mask is None:\n            data_mask = input_mask[None]\n        elif input_mask is None and perm_mask is not None:\n            data_mask = perm_mask\n        else:\n            data_mask = None\n\n        if data_mask is not None:\n            # all mems can be attended to\n            if mlen > 0:\n                mems_mask = torch.zeros([data_mask.shape[0], mlen, bsz]).to(data_mask)\n                data_mask = torch.cat([mems_mask, data_mask], dim=1)\n            if attn_mask is None:\n                attn_mask = data_mask[:, :, :, None]\n            else:\n                attn_mask += data_mask[:, :, :, None]\n\n        if attn_mask is not None:\n            attn_mask = (attn_mask > 0).to(dtype_float)\n\n        if attn_mask is not None:\n            non_tgt_mask = -torch.eye(qlen).to(attn_mask)\n            if mlen > 0:\n                non_tgt_mask = torch.cat([torch.zeros([qlen, mlen]).to(attn_mask), non_tgt_mask], dim=-1)\n            non_tgt_mask = ((attn_mask + non_tgt_mask[:, :, None, None]) > 0).to(attn_mask)\n        else:\n            non_tgt_mask = None\n\n        ##### Word embeddings and prepare h & g hidden states\n        word_emb_k = self.word_embedding(input_ids)\n        output_h = self.dropout(word_emb_k)\n        if target_mapping is not None:\n            word_emb_q = self.mask_emb.expand(target_mapping.shape[0], bsz, -1)\n        # else:  # We removed the inp_q input which was same as target mapping\n        #     inp_q_ext = inp_q[:, :, None]\n        #     word_emb_q = inp_q_ext * self.mask_emb + (1 - inp_q_ext) * word_emb_k\n            output_g = self.dropout(word_emb_q)\n        else:\n            output_g = None\n\n        ##### Segment embedding\n        if token_type_ids is not None:\n            # Convert `token_type_ids` to one-hot `seg_mat`\n            if mlen > 0:\n                mem_pad = torch.zeros([mlen, bsz], dtype=torch.long, device=device)\n                cat_ids = torch.cat([mem_pad, token_type_ids], dim=0)\n            else:\n                cat_ids = token_type_ids\n\n            # `1` indicates not in the same segment [qlen x klen x bsz]\n            seg_mat = (token_type_ids[:, None] != cat_ids[None, :]).long()\n            seg_mat = F.one_hot(seg_mat, num_classes=2).to(dtype_float)\n        else:\n            seg_mat = None\n\n        ##### Positional encoding\n        pos_emb = self.relative_positional_encoding(qlen, klen, bsz=bsz)\n        pos_emb = self.dropout(pos_emb)\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads] (a head_mask for each layer)\n        # and head_mask is converted to shape [num_hidden_layers x qlen x klen x bsz x n_head]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(0).unsqueeze(0)\n                head_mask = head_mask.expand(self.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(1).unsqueeze(1)\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.n_layer\n\n        new_mems = ()\n        if mems is None:\n            mems = [None] * len(self.layer)\n\n        attentions = []\n        hidden_states = []\n        for i, layer_module in enumerate(self.layer):\n            if self.mem_len is not None and self.mem_len > 0 and self.output_past:\n                # cache new mems\n                new_mems = new_mems + (self.cache_mem(output_h, mems[i]),)\n            if self.output_hidden_states:\n                hidden_states.append((output_h, output_g) if output_g is not None else output_h)\n\n            outputs = layer_module(output_h, output_g, attn_mask_h=non_tgt_mask, attn_mask_g=attn_mask,\n                                   r=pos_emb, seg_mat=seg_mat, mems=mems[i], target_mapping=target_mapping,\n                                   head_mask=head_mask[i])\n            output_h, output_g = outputs[:2]\n            if self.output_attentions:\n                attentions.append(outputs[2])\n\n        # Add last hidden state\n        if self.output_hidden_states:\n            hidden_states.append((output_h, output_g) if output_g is not None else output_h)\n\n        output = self.dropout(output_g if output_g is not None else output_h)\n\n        # Prepare outputs, we transpose back here to shape [bsz, len, hidden_dim] (cf. beginning of forward() method)\n        outputs = (output.permute(1, 0, 2).contiguous(),)\n\n        if self.mem_len is not None and self.mem_len > 0 and self.output_past:\n            outputs = outputs + (new_mems,)\n\n        if self.output_hidden_states:\n            if output_g is not None:\n                hidden_states = tuple(h.permute(1, 0, 2).contiguous() for hs in hidden_states for h in hs)\n            else:\n                hidden_states = tuple(hs.permute(1, 0, 2).contiguous() for hs in hidden_states)\n            outputs = outputs + (hidden_states,)\n        if self.output_attentions:\n            attentions = tuple(t.permute(2, 3, 0, 1).contiguous() for t in attentions)\n            outputs = outputs + (attentions,)\n\n        return outputs  # outputs, (new_mems), (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""XLNet Model with a language modeling head on top\n    (linear layer with weights tied to the input embeddings). """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetLMHeadModel(XLNetPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **mems**: (`optional`, returned when ``config.mem_len > 0``)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            if config.mem_len > 0 else tuple of None. Can be used to speed up sequential decoding and attend to longer context.\n            See details in the docstring of the `mems` input above.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLNetLMHeadModel.from_pretrained(\'xlnet-large-cased\')\n        # We show how to setup inputs to predict a next token using a bi-directional context.\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is very <mask>"")).unsqueeze(0)  # We will predict the masked token\n        perm_mask = torch.zeros((1, input_ids.shape[1], input_ids.shape[1]), dtype=torch.float)\n        perm_mask[:, :, -1] = 1.0  # Previous tokens don\'t see last token\n        target_mapping = torch.zeros((1, 1, input_ids.shape[1]), dtype=torch.float)  # Shape [1, 1, seq_length] => let\'s predict one token\n        target_mapping[0, 0, -1] = 1.0  # Our first (and only) prediction will be the last token of the sequence (the masked token)\n        outputs = model(input_ids, perm_mask=perm_mask, target_mapping=target_mapping)\n        next_token_logits = outputs[0]  # Output has shape [target_mapping.size(0), target_mapping.size(1), config.vocab_size]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetLMHeadModel, self).__init__(config)\n        self.attn_type = config.attn_type\n        self.same_length = config.same_length\n\n        self.transformer = XLNetModel(config)\n        self.lm_loss = nn.Linear(config.d_model, config.n_token, bias=True)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the embeddings\n        """"""\n        self._tie_or_clone_weights(self.lm_loss, self.transformer.word_embedding)\n\n    def forward(self, input_ids, attention_mask=None, mems=None, perm_mask=None, target_mapping=None,\n                token_type_ids=None, input_mask=None, head_mask=None, labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               mems=mems,\n                                               perm_mask=perm_mask,\n                                               target_mapping=target_mapping,\n                                               token_type_ids=token_type_ids,\n                                               input_mask=input_mask,\n                                               head_mask=head_mask)\n\n        logits = self.lm_loss(transformer_outputs[0])\n\n        outputs = (logits,) + transformer_outputs[1:]  # Keep mems, hidden states, attentions if there are in it\n\n        if labels is not None:\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(logits.view(-1, logits.size(-1)),\n                            labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # return (loss), logits, (mems), (hidden states), (attentions)\n\n\n@add_start_docstrings(""""""XLNet Model with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetForSequenceClassification(XLNetPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **mems**: (`optional`, returned when ``config.mem_len > 0``)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            if config.mem_len > 0 else tuple of None. Can be used to speed up sequential decoding and attend to longer context.\n            See details in the docstring of the `mems` input above.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLNetForSequenceClassification.from_pretrained(\'xlnet-large-cased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.transformer = XLNetModel(config)\n        self.sequence_summary = SequenceSummary(config)\n        self.logits_proj = nn.Linear(config.d_model, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, mems=None, perm_mask=None, target_mapping=None,\n                token_type_ids=None, input_mask=None, head_mask=None, labels=None):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               mems=mems,\n                                               perm_mask=perm_mask,\n                                               target_mapping=target_mapping,\n                                               token_type_ids=token_type_ids,\n                                               input_mask=input_mask,\n                                               head_mask=head_mask)\n        output = transformer_outputs[0]\n\n        output = self.sequence_summary(output)\n        logits = self.logits_proj(output)\n\n        outputs = (logits,) + transformer_outputs[1:]  # Keep mems, hidden states, attentions if there are in it\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # return (loss), logits, (mems), (hidden states), (attentions)\n\n@add_start_docstrings(""""""XLNet Model with a multiple choice classification head on top (a linear layer on top of\n    the pooled output and a softmax) e.g. for RACE/SWAG tasks. """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetForMultipleChoice(XLNetPreTrainedModel):\n    r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            The second dimension of the input (`num_choices`) indicates the number of choices to scores.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Segment token indices to indicate first and second portions of the inputs.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above).\n            Classification scores (before SoftMax).\n        **mems**: (`optional`, returned when ``config.mem_len > 0``)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            if config.mem_len > 0 else tuple of None. Can be used to speed up sequential decoding and attend to longer context.\n            See details in the docstring of the `mems` input above.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-base-cased\')\n        model = XLNetForMultipleChoice.from_pretrained(\'xlnet-base-cased\')\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, classification_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetForMultipleChoice, self).__init__(config)\n\n        self.transformer = XLNetModel(config)\n        self.sequence_summary = SequenceSummary(config)\n        self.logits_proj = nn.Linear(config.d_model, 1)\n\n        self.init_weights()\n\n    def forward(self, input_ids, token_type_ids=None, input_mask=None, attention_mask=None,\n                mems=None, perm_mask=None, target_mapping=None,\n                labels=None, head_mask=None):\n        num_choices = input_ids.shape[1]\n\n        flat_input_ids = input_ids.view(-1, input_ids.size(-1))\n        flat_token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\n        flat_attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\n        flat_input_mask = input_mask.view(-1, input_mask.size(-1)) if input_mask is not None else None\n\n        transformer_outputs = self.transformer(flat_input_ids, token_type_ids=flat_token_type_ids,\n                                               input_mask=flat_input_mask, attention_mask=flat_attention_mask,\n                                               mems=mems, perm_mask=perm_mask, target_mapping=target_mapping,\n                                               head_mask=head_mask)\n\n\n        output = transformer_outputs[0]\n\n        output = self.sequence_summary(output)\n        logits = self.logits_proj(output)\n        reshaped_logits = logits.view(-1, num_choices)\n        outputs = (reshaped_logits,) + transformer_outputs[1:]  # Keep mems, hidden states, attentions if there are in it\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # return (loss), logits, (mems), (hidden states), (attentions)\n\n\n@add_start_docstrings(""""""XLNet Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetForQuestionAnsweringSimple(XLNetPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned if both ``start_positions`` and ``end_positions`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss as the sum of start token, end token (and is_impossible if provided) classification losses.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **mems**: (`optional`, returned when ``config.mem_len > 0``)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            if config.mem_len > 0 else tuple of None. Can be used to speed up sequential decoding and attend to longer context.\n            See details in the docstring of the `mems` input above.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMForQuestionAnswering.from_pretrained(\'xlnet-large-cased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetForQuestionAnsweringSimple, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.transformer = XLNetModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, mems=None, perm_mask=None, target_mapping=None,\n                token_type_ids=None, input_mask=None, head_mask=None,\n                start_positions=None, end_positions=None):\n\n        outputs = self.transformer(input_ids,\n                                    attention_mask=attention_mask,\n                                    mems=mems,\n                                    perm_mask=perm_mask,\n                                    target_mapping=target_mapping,\n                                    token_type_ids=token_type_ids,\n                                    input_mask=input_mask,\n                                    head_mask=head_mask)\n\n        sequence_output = outputs[0]\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        outputs = (start_logits, end_logits,) + outputs[2:]\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), start_logits, end_logits, (mems), (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""XLNet Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetForQuestionAnswering(XLNetPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **is_impossible**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels whether a question has an answer or no answer (SQuAD 2.0)\n        **cls_index**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the classification token to use as input for computing plausibility of the answer.\n        **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Optional mask of tokens which can\'t be in answers (e.g. [CLS], [PAD], ...).\n            1.0 means token should be masked. 0.0 mean token is not masked.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned if both ``start_positions`` and ``end_positions`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss as the sum of start token, end token (and is_impossible if provided) classification losses.\n        **start_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top)``\n            Log probabilities for the top config.start_n_top start token possibilities (beam-search).\n        **start_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top)``\n            Indices for the top config.start_n_top start token possibilities (beam-search).\n        **end_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Log probabilities for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **end_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Indices for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **cls_logits**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size,)``\n            Log probabilities for the ``is_impossible`` label of the answers.\n        **mems**: (`optional`, returned when ``config.mem_len > 0``)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            if config.mem_len > 0 else tuple of None. Can be used to speed up sequential decoding and attend to longer context.\n            See details in the docstring of the `mems` input above.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer =  XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLMForQuestionAnswering.from_pretrained(\'xlnet-large-cased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetForQuestionAnswering, self).__init__(config)\n        self.start_n_top = config.start_n_top\n        self.end_n_top = config.end_n_top\n\n        self.transformer = XLNetModel(config)\n        self.start_logits = PoolerStartLogits(config)\n        self.end_logits = PoolerEndLogits(config)\n        self.answer_class = PoolerAnswerClass(config)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, mems=None, perm_mask=None, target_mapping=None,\n                token_type_ids=None, input_mask=None, head_mask=None,\n                start_positions=None, end_positions=None, is_impossible=None, cls_index=None, p_mask=None,):\n        transformer_outputs = self.transformer(input_ids,\n                                               attention_mask=attention_mask,\n                                               mems=mems,\n                                               perm_mask=perm_mask,\n                                               target_mapping=target_mapping,\n                                               token_type_ids=token_type_ids,\n                                               input_mask=input_mask,\n                                               head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n        start_logits = self.start_logits(hidden_states, p_mask=p_mask)\n\n        outputs = transformer_outputs[1:]  # Keep mems, hidden states, attentions if there are in it\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, let\'s remove the dimension added by batch splitting\n            for x in (start_positions, end_positions, cls_index, is_impossible):\n                if x is not None and x.dim() > 1:\n                    x.squeeze_(-1)\n\n            # during training, compute the end logits based on the ground truth of the start position\n            end_logits = self.end_logits(hidden_states, start_positions=start_positions, p_mask=p_mask)\n\n            loss_fct = CrossEntropyLoss()\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n\n            if cls_index is not None and is_impossible is not None:\n                # Predict answerability from the representation of CLS and START\n                cls_logits = self.answer_class(hidden_states, start_positions=start_positions, cls_index=cls_index)\n                loss_fct_cls = nn.BCEWithLogitsLoss()\n                cls_loss = loss_fct_cls(cls_logits, is_impossible)\n\n                # note(zhiliny): by default multiply the loss by 0.5 so that the scale is comparable to start_loss and end_loss\n                total_loss += cls_loss * 0.5\n\n            outputs = (total_loss,) + outputs\n\n        else:\n            # during inference, compute the end logits based on beam search\n            bsz, slen, hsz = hidden_states.size()\n            start_log_probs = F.softmax(start_logits, dim=-1) # shape (bsz, slen)\n\n            start_top_log_probs, start_top_index = torch.topk(start_log_probs, self.start_n_top, dim=-1) # shape (bsz, start_n_top)\n            start_top_index_exp = start_top_index.unsqueeze(-1).expand(-1, -1, hsz) # shape (bsz, start_n_top, hsz)\n            start_states = torch.gather(hidden_states, -2, start_top_index_exp) # shape (bsz, start_n_top, hsz)\n            start_states = start_states.unsqueeze(1).expand(-1, slen, -1, -1) # shape (bsz, slen, start_n_top, hsz)\n\n            hidden_states_expanded = hidden_states.unsqueeze(2).expand_as(start_states) # shape (bsz, slen, start_n_top, hsz)\n            p_mask = p_mask.unsqueeze(-1) if p_mask is not None else None\n            end_logits = self.end_logits(hidden_states_expanded, start_states=start_states, p_mask=p_mask)\n            end_log_probs = F.softmax(end_logits, dim=1) # shape (bsz, slen, start_n_top)\n\n            end_top_log_probs, end_top_index = torch.topk(end_log_probs, self.end_n_top, dim=1) # shape (bsz, end_n_top, start_n_top)\n            end_top_log_probs = end_top_log_probs.view(-1, self.start_n_top * self.end_n_top)\n            end_top_index = end_top_index.view(-1, self.start_n_top * self.end_n_top)\n\n            start_states = torch.einsum(""blh,bl->bh"", hidden_states, start_log_probs)  # get the representation of START as weighted sum of hidden states\n            cls_logits = self.answer_class(hidden_states, start_states=start_states, cls_index=cls_index)  # Shape (batch size,): one single `cls_logits` for each sample\n\n            outputs = (start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits) + outputs\n\n        # return start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits\n        # or (if labels are provided) (total_loss,)\n        return outputs\n'"
baselines/models_pytorch/classifier_pytorch/transformers/optimization.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch optimization for BERT model.""""""\n\nimport logging\nimport math\n\nimport torch\nfrom torch.optim import Optimizer\nfrom torch.optim.lr_scheduler import LambdaLR\n\nlogger = logging.getLogger(__name__)\n\nclass ConstantLRSchedule(LambdaLR):\n    """""" Constant learning rate schedule.\n    """"""\n    def __init__(self, optimizer, last_epoch=-1):\n        super(ConstantLRSchedule, self).__init__(optimizer, lambda _: 1.0, last_epoch=last_epoch)\n\n\nclass WarmupConstantSchedule(LambdaLR):\n    """""" Linear warmup and then constant.\n        Linearly increases learning rate schedule from 0 to 1 over `warmup_steps` training steps.\n        Keeps learning rate schedule equal to 1. after warmup_steps.\n    """"""\n    def __init__(self, optimizer, warmup_steps, last_epoch=-1):\n        self.warmup_steps = warmup_steps\n        super(WarmupConstantSchedule, self).__init__(optimizer, self.lr_lambda, last_epoch=last_epoch)\n\n    def lr_lambda(self, step):\n        if step < self.warmup_steps:\n            return float(step) / float(max(1.0, self.warmup_steps))\n        return 1.\n\n\nclass WarmupLinearSchedule(LambdaLR):\n    """""" Linear warmup and then linear decay.\n        Linearly increases learning rate from 0 to 1 over `warmup_steps` training steps.\n        Linearly decreases learning rate from 1. to 0. over remaining `t_total - warmup_steps` steps.\n    """"""\n    def __init__(self, optimizer, warmup_steps, t_total, last_epoch=-1):\n        self.warmup_steps = warmup_steps\n        self.t_total = t_total\n        super(WarmupLinearSchedule, self).__init__(optimizer, self.lr_lambda, last_epoch=last_epoch)\n\n    def lr_lambda(self, step):\n        if step < self.warmup_steps:\n            return float(step) / float(max(1, self.warmup_steps))\n        return max(0.0, float(self.t_total - step) / float(max(1.0, self.t_total - self.warmup_steps)))\n\n\nclass WarmupCosineSchedule(LambdaLR):\n    """""" Linear warmup and then cosine decay.\n        Linearly increases learning rate from 0 to 1 over `warmup_steps` training steps.\n        Decreases learning rate from 1. to 0. over remaining `t_total - warmup_steps` steps following a cosine curve.\n        If `cycles` (default=0.5) is different from default, learning rate follows cosine function after warmup.\n    """"""\n    def __init__(self, optimizer, warmup_steps, t_total, cycles=.5, last_epoch=-1):\n        self.warmup_steps = warmup_steps\n        self.t_total = t_total\n        self.cycles = cycles\n        super(WarmupCosineSchedule, self).__init__(optimizer, self.lr_lambda, last_epoch=last_epoch)\n\n    def lr_lambda(self, step):\n        if step < self.warmup_steps:\n            return float(step) / float(max(1.0, self.warmup_steps))\n        # progress after warmup\n        progress = float(step - self.warmup_steps) / float(max(1, self.t_total - self.warmup_steps))\n        return max(0.0, 0.5 * (1. + math.cos(math.pi * float(self.cycles) * 2.0 * progress)))\n\n\nclass WarmupCosineWithHardRestartsSchedule(LambdaLR):\n    """""" Linear warmup and then cosine cycles with hard restarts.\n        Linearly increases learning rate from 0 to 1 over `warmup_steps` training steps.\n        If `cycles` (default=1.) is different from default, learning rate follows `cycles` times a cosine decaying\n        learning rate (with hard restarts).\n    """"""\n    def __init__(self, optimizer, warmup_steps, t_total, cycles=1., last_epoch=-1):\n        self.warmup_steps = warmup_steps\n        self.t_total = t_total\n        self.cycles = cycles\n        super(WarmupCosineWithHardRestartsSchedule, self).__init__(optimizer, self.lr_lambda, last_epoch=last_epoch)\n\n    def lr_lambda(self, step):\n        if step < self.warmup_steps:\n            return float(step) / float(max(1, self.warmup_steps))\n        # progress after warmup\n        progress = float(step - self.warmup_steps) / float(max(1, self.t_total - self.warmup_steps))\n        if progress >= 1.0:\n            return 0.0\n        return max(0.0, 0.5 * (1. + math.cos(math.pi * ((float(self.cycles) * progress) % 1.0))))\n\n\n\nclass AdamW(Optimizer):\n    """""" Implements Adam algorithm with weight decay fix.\n\n    Parameters:\n        lr (float): learning rate. Default 1e-3.\n        betas (tuple of 2 floats): Adams beta parameters (b1, b2). Default: (0.9, 0.999)\n        eps (float): Adams epsilon. Default: 1e-6\n        weight_decay (float): Weight decay. Default: 0.0\n        correct_bias (bool): can be set to False to avoid correcting bias in Adam (e.g. like in Bert TF repository). Default True.\n    """"""\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), eps=1e-6, weight_decay=0.0, correct_bias=True):\n        if lr < 0.0:\n            raise ValueError(""Invalid learning rate: {} - should be >= 0.0"".format(lr))\n        if not 0.0 <= betas[0] < 1.0:\n            raise ValueError(""Invalid beta parameter: {} - should be in [0.0, 1.0["".format(betas[0]))\n        if not 0.0 <= betas[1]  < 1.0:\n            raise ValueError(""Invalid beta parameter: {} - should be in [0.0, 1.0["".format(betas[1]))\n        if not 0.0 <= eps:\n            raise ValueError(""Invalid epsilon value: {} - should be >= 0.0"".format(eps))\n        defaults = dict(lr=lr, betas=betas, eps=eps, weight_decay=weight_decay,\n                        correct_bias=correct_bias)\n        super(AdamW, self).__init__(params, defaults)\n\n    def step(self, closure=None):\n        """"""Performs a single optimization step.\n\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        """"""\n        loss = None\n        if closure is not None:\n            loss = closure()\n\n        for group in self.param_groups:\n            for p in group[\'params\']:\n                if p.grad is None:\n                    continue\n                grad = p.grad.data\n                if grad.is_sparse:\n                    raise RuntimeError(\'Adam does not support sparse gradients, please consider SparseAdam instead\')\n\n                state = self.state[p]\n\n                # State initialization\n                if len(state) == 0:\n                    state[\'step\'] = 0\n                    # Exponential moving average of gradient values\n                    state[\'exp_avg\'] = torch.zeros_like(p.data)\n                    # Exponential moving average of squared gradient values\n                    state[\'exp_avg_sq\'] = torch.zeros_like(p.data)\n\n                exp_avg, exp_avg_sq = state[\'exp_avg\'], state[\'exp_avg_sq\']\n                beta1, beta2 = group[\'betas\']\n\n                state[\'step\'] += 1\n\n                # Decay the first and second moment running average coefficient\n                # In-place operations to update the averages at the same time\n                exp_avg.mul_(beta1).add_(1.0 - beta1, grad)\n                exp_avg_sq.mul_(beta2).addcmul_(1.0 - beta2, grad, grad)\n                denom = exp_avg_sq.sqrt().add_(group[\'eps\'])\n\n                step_size = group[\'lr\']\n                if group[\'correct_bias\']:  # No bias correction for Bert\n                    bias_correction1 = 1.0 - beta1 ** state[\'step\']\n                    bias_correction2 = 1.0 - beta2 ** state[\'step\']\n                    step_size = step_size * math.sqrt(bias_correction2) / bias_correction1\n\n                p.data.addcdiv_(-step_size, exp_avg, denom)\n\n                # Just adding the square of the weights to the loss function is *not*\n                # the correct way of using L2 regularization/weight decay with Adam,\n                # since that will interact with the m and v parameters in strange ways.\n                #\n                # Instead we want to decay the weights in a manner that doesn\'t interact\n                # with the m/v parameters. This is equivalent to adding the square\n                # of the weights to the loss with plain (non-momentum) SGD.\n                # Add weight decay at the end (fixed version)\n                if group[\'weight_decay\'] > 0.0:\n                    p.data.add_(-group[\'lr\'] * group[\'weight_decay\'], p.data)\n\n        return loss\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_auto.py,0,"b'# coding=utf-8\n# Copyright 2018 The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Auto Model class. """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport logging\n\nfrom .tokenization_bert import BertTokenizer\nfrom .tokenization_openai import OpenAIGPTTokenizer\nfrom .tokenization_gpt2 import GPT2Tokenizer\nfrom .tokenization_ctrl import CTRLTokenizer\nfrom .tokenization_transfo_xl import TransfoXLTokenizer\nfrom .tokenization_xlnet import XLNetTokenizer\nfrom .tokenization_xlm import XLMTokenizer\nfrom .tokenization_roberta import RobertaTokenizer\nfrom .tokenization_distilbert import DistilBertTokenizer\n\nlogger = logging.getLogger(__name__)\n\nclass AutoTokenizer(object):\n    r"""""":class:`~transformers.AutoTokenizer` is a generic tokenizer class\n        that will be instantiated as one of the tokenizer classes of the library\n        when created with the `AutoTokenizer.from_pretrained(pretrained_model_name_or_path)`\n        class method.\n\n        The `from_pretrained()` method take care of returning the correct tokenizer class instance\n        using pattern matching on the `pretrained_model_name_or_path` string.\n\n        The tokenizer class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertTokenizer (DistilBert model)\n            - contains `roberta`: RobertaTokenizer (RoBERTa model)\n            - contains `bert`: BertTokenizer (Bert model)\n            - contains `openai-gpt`: OpenAIGPTTokenizer (OpenAI GPT model)\n            - contains `gpt2`: GPT2Tokenizer (OpenAI GPT-2 model)\n            - contains `ctrl`: CTRLTokenizer (Salesforce CTRL model)\n            - contains `transfo-xl`: TransfoXLTokenizer (Transformer-XL model)\n            - contains `xlnet`: XLNetTokenizer (XLNet model)\n            - contains `xlm`: XLMTokenizer (XLM model)\n\n        This class cannot be instantiated using `__init__()` (throw an error).\n    """"""\n    def __init__(self):\n        raise EnvironmentError(""AutoTokenizer is designed to be instantiated ""\n            ""using the `AutoTokenizer.from_pretrained(pretrained_model_name_or_path)` method."")\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *inputs, **kwargs):\n        r"""""" Instantiate a one of the tokenizer classes of the library\n        from a pre-trained model vocabulary.\n\n        The tokenizer class to instantiate is selected as the first pattern matching\n        in the `pretrained_model_name_or_path` string (in the following order):\n            - contains `distilbert`: DistilBertTokenizer (DistilBert model)\n            - contains `roberta`: RobertaTokenizer (XLM model)\n            - contains `bert`: BertTokenizer (Bert model)\n            - contains `openai-gpt`: OpenAIGPTTokenizer (OpenAI GPT model)\n            - contains `gpt2`: GPT2Tokenizer (OpenAI GPT-2 model)\n            - contains `ctrl`: CTRLTokenizer (Salesforce CTRL model)\n            - contains `transfo-xl`: TransfoXLTokenizer (Transformer-XL model)\n            - contains `xlnet`: XLNetTokenizer (XLNet model)\n            - contains `xlm`: XLMTokenizer (XLM model)\n\n        Params:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a predefined tokenizer to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing vocabulary files required by the tokenizer, for instance saved using the :func:`~transformers.PreTrainedTokenizer.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - (not applicable to all derived classes) a path or url to a single saved vocabulary file if and only if the tokenizer only requires a single vocabulary file (e.g. Bert, XLNet), e.g.: ``./my_model_directory/vocab.txt``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded predefined tokenizer vocabulary files should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the vocabulary files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            inputs: (`optional`) positional arguments: will be passed to the Tokenizer ``__init__`` method.\n\n            kwargs: (`optional`) keyword arguments: will be passed to the Tokenizer ``__init__`` method. Can be used to set special tokens like ``bos_token``, ``eos_token``, ``unk_token``, ``sep_token``, ``pad_token``, ``cls_token``, ``mask_token``, ``additional_special_tokens``. See parameters in the doc string of :class:`~transformers.PreTrainedTokenizer` for details.\n\n        Examples::\n\n            tokenizer = AutoTokenizer.from_pretrained(\'bert-base-uncased\')    # Download vocabulary from S3 and cache.\n            tokenizer = AutoTokenizer.from_pretrained(\'./test/bert_saved_model/\')  # E.g. tokenizer was saved using `save_pretrained(\'./test/saved_model/\')`\n\n        """"""\n        if \'distilbert\' in pretrained_model_name_or_path:\n            return DistilBertTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'roberta\' in pretrained_model_name_or_path:\n            return RobertaTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'bert\' in pretrained_model_name_or_path:\n            return BertTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'openai-gpt\' in pretrained_model_name_or_path:\n            return OpenAIGPTTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'gpt2\' in pretrained_model_name_or_path:\n            return GPT2Tokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'transfo-xl\' in pretrained_model_name_or_path:\n            return TransfoXLTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'xlnet\' in pretrained_model_name_or_path:\n            return XLNetTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'xlm\' in pretrained_model_name_or_path:\n            return XLMTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        elif \'ctrl\' in pretrained_model_name_or_path:\n            return CTRLTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        raise ValueError(""Unrecognized model identifier in {}. Should contains one of ""\n                         ""\'bert\', \'openai-gpt\', \'gpt2\', \'transfo-xl\', \'xlnet\', ""\n                         ""\'xlm\', \'roberta\', \'ctrl\'"".format(pretrained_model_name_or_path))\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_bert.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport logging\nimport os\nimport unicodedata\nfrom io import open\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'vocab_file\': \'vocab.txt\'}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-vocab.txt"",\n        \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt"",\n        \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-vocab.txt"",\n        \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-vocab.txt"",\n        \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-vocab.txt"",\n        \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-vocab.txt"",\n        \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-vocab.txt"",\n        \'bert-base-german-cased\': ""https://int-deepset-models-bert.s3.eu-central-1.amazonaws.com/pytorch/bert-base-german-cased-vocab.txt"",\n        \'bert-large-uncased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-vocab.txt"",\n        \'bert-large-cased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-vocab.txt"",\n        \'bert-large-uncased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-finetuned-squad-vocab.txt"",\n        \'bert-large-cased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-finetuned-squad-vocab.txt"",\n        \'bert-base-cased-finetuned-mrpc\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-finetuned-mrpc-vocab.txt"",\n        \'bert-base-german-dbmdz-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-cased-vocab.txt"",\n        \'bert-base-german-dbmdz-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-uncased-vocab.txt"",\n    }\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'bert-base-uncased\': 512,\n    \'bert-large-uncased\': 512,\n    \'bert-base-cased\': 512,\n    \'bert-large-cased\': 512,\n    \'bert-base-multilingual-uncased\': 512,\n    \'bert-base-multilingual-cased\': 512,\n    \'bert-base-chinese\': 512,\n    \'bert-base-german-cased\': 512,\n    \'bert-large-uncased-whole-word-masking\': 512,\n    \'bert-large-cased-whole-word-masking\': 512,\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': 512,\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': 512,\n    \'bert-base-cased-finetuned-mrpc\': 512,\n    \'bert-base-german-dbmdz-cased\': 512,\n    \'bert-base-german-dbmdz-uncased\': 512,\n}\n\nPRETRAINED_INIT_CONFIGURATION = {\n    \'bert-base-uncased\': {\'do_lower_case\': True},\n    \'bert-large-uncased\': {\'do_lower_case\': True},\n    \'bert-base-cased\': {\'do_lower_case\': False},\n    \'bert-large-cased\': {\'do_lower_case\': False},\n    \'bert-base-multilingual-uncased\': {\'do_lower_case\': True},\n    \'bert-base-multilingual-cased\': {\'do_lower_case\': False},\n    \'bert-base-chinese\': {\'do_lower_case\': False},\n    \'bert-base-german-cased\': {\'do_lower_case\': False},\n    \'bert-large-uncased-whole-word-masking\': {\'do_lower_case\': True},\n    \'bert-large-cased-whole-word-masking\': {\'do_lower_case\': False},\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': {\'do_lower_case\': True},\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': {\'do_lower_case\': False},\n    \'bert-base-cased-finetuned-mrpc\': {\'do_lower_case\': False},\n    \'bert-base-german-dbmdz-cased\': {\'do_lower_case\': False},\n    \'bert-base-german-dbmdz-uncased\': {\'do_lower_case\': True},\n}\n\n\ndef load_vocab(vocab_file):\n    """"""Loads a vocabulary file into a dictionary.""""""\n    vocab = collections.OrderedDict()\n    with open(vocab_file, ""r"", encoding=""utf-8"") as reader:\n        tokens = reader.readlines()\n    for index, token in enumerate(tokens):\n        token = token.rstrip(\'\\n\')\n        vocab[token] = index\n    return vocab\n\n\ndef whitespace_tokenize(text):\n    """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n    text = text.strip()\n    if not text:\n        return []\n    tokens = text.split()\n    return tokens\n\n\nclass BertTokenizer(PreTrainedTokenizer):\n    r""""""\n    Constructs a BertTokenizer.\n    :class:`~transformers.BertTokenizer` runs end-to-end tokenization: punctuation splitting + wordpiece\n\n    Args:\n        vocab_file: Path to a one-wordpiece-per-line vocabulary file\n        do_lower_case: Whether to lower case the input. Only has an effect when do_wordpiece_only=False\n        do_basic_tokenize: Whether to do basic tokenization before wordpiece.\n        max_len: An artificial maximum length to truncate tokenized sequences to; Effective maximum length is always the\n            minimum of this value (if specified) and the underlying BERT model\'s sequence length.\n        never_split: List of tokens which will never be split during tokenization. Only has an effect when\n            do_wordpiece_only=False\n    """"""\n\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    pretrained_init_configuration = PRETRAINED_INIT_CONFIGURATION\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, do_lower_case=True, do_basic_tokenize=True, never_split=None,\n                 unk_token=""[UNK]"", sep_token=""[SEP]"", pad_token=""[PAD]"", cls_token=""[CLS]"",\n                 mask_token=""[MASK]"", tokenize_chinese_chars=True, **kwargs):\n        """"""Constructs a BertTokenizer.\n\n        Args:\n            **vocab_file**: Path to a one-wordpiece-per-line vocabulary file\n            **do_lower_case**: (`optional`) boolean (default True)\n                Whether to lower case the input\n                Only has an effect when do_basic_tokenize=True\n            **do_basic_tokenize**: (`optional`) boolean (default True)\n                Whether to do basic tokenization before wordpiece.\n            **never_split**: (`optional`) list of string\n                List of tokens which will never be split during tokenization.\n                Only has an effect when do_basic_tokenize=True\n            **tokenize_chinese_chars**: (`optional`) boolean (default True)\n                Whether to tokenize Chinese characters.\n                This should likely be deactivated for Japanese:\n                see: https://github.com/huggingface/pytorch-pretrained-BERT/issues/328\n        """"""\n        super(BertTokenizer, self).__init__(unk_token=unk_token, sep_token=sep_token,\n                                            pad_token=pad_token, cls_token=cls_token,\n                                            mask_token=mask_token, **kwargs)\n        self.max_len_single_sentence = self.max_len - 2  # take into account special tokens\n        self.max_len_sentences_pair = self.max_len - 3  # take into account special tokens\n\n        if not os.path.isfile(vocab_file):\n            raise ValueError(\n                ""Can\'t find a vocabulary file at path \'{}\'. To load the vocabulary from a Google pretrained ""\n                ""model use `tokenizer = BertTokenizer.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(vocab_file))\n        self.vocab = load_vocab(vocab_file)\n        self.ids_to_tokens = collections.OrderedDict(\n            [(ids, tok) for tok, ids in self.vocab.items()])\n        self.do_basic_tokenize = do_basic_tokenize\n        if do_basic_tokenize:\n            self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case,\n                                                  never_split=never_split,\n                                                  tokenize_chinese_chars=tokenize_chinese_chars)\n        self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab, unk_token=self.unk_token)\n\n    @property\n    def vocab_size(self):\n        return len(self.vocab)\n\n    def _tokenize(self, text):\n        split_tokens = []\n        if self.do_basic_tokenize:\n            for token in self.basic_tokenizer.tokenize(text, never_split=self.all_special_tokens):\n                for sub_token in self.wordpiece_tokenizer.tokenize(token):\n                    split_tokens.append(sub_token)\n        else:\n            split_tokens = self.wordpiece_tokenizer.tokenize(text)\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.vocab.get(token, self.vocab.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.ids_to_tokens.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \' \'.join(tokens).replace(\' ##\', \'\').strip()\n        return out_string\n\n    def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None):\n        """"""\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks\n        by concatenating and adding special tokens.\n        A BERT sequence has the following format:\n            single sequence: [CLS] X [SEP]\n            pair of sequences: [CLS] A [SEP] B [SEP]\n        """"""\n        if token_ids_1 is None:\n            return [self.cls_token_id] + token_ids_0 + [self.sep_token_id]\n        cls = [self.cls_token_id]\n        sep = [self.sep_token_id]\n        return cls + token_ids_0 + sep + token_ids_1 + sep\n\n    def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False):\n        """"""\n        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer ``prepare_for_model`` or ``encode_plus`` methods.\n\n        Args:\n            token_ids_0: list of ids (must not contain special tokens)\n            token_ids_1: Optional list of ids (must not contain special tokens), necessary when fetching sequence ids\n                for sequence pairs\n            already_has_special_tokens: (default False) Set to True if the token list is already formated with\n                special tokens for the model\n\n        Returns:\n            A list of integers in the range [0, 1]: 0 for a special token, 1 for a sequence token.\n        """"""\n\n        if already_has_special_tokens:\n            if token_ids_1 is not None:\n                raise ValueError(""You should not supply a second sequence if the provided sequence of ""\n                                 ""ids is already formated with special tokens for the model."")\n            return list(map(lambda x: 1 if x in [self.sep_token_id, self.cls_token_id] else 0, token_ids_0))\n\n        if token_ids_1 is not None:\n            return [1] + ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1]\n        return [1] + ([0] * len(token_ids_0)) + [1]\n\n    def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None):\n        """"""\n        Creates a mask from the two sequences passed to be used in a sequence-pair classification task.\n        A BERT sequence pair mask has the following format:\n        0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1\n        | first sequence    | second sequence\n\n        if token_ids_1 is None, only returns the first portion of the mask (0\'s).\n        """"""\n        sep = [self.sep_token_id]\n        cls = [self.cls_token_id]\n        if token_ids_1 is None:\n            return len(cls + token_ids_0 + sep) * [0]\n        return len(cls + token_ids_0 + sep) * [0] + len(token_ids_1 + sep) * [1]\n\n    def save_vocabulary(self, vocab_path):\n        """"""Save the tokenizer vocabulary to a directory or file.""""""\n        index = 0\n        if os.path.isdir(vocab_path):\n            vocab_file = os.path.join(vocab_path, VOCAB_FILES_NAMES[\'vocab_file\'])\n        else:\n            vocab_file = vocab_path\n        with open(vocab_file, ""w"", encoding=""utf-8"") as writer:\n            for token, token_index in sorted(self.vocab.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: vocabulary indices are not consecutive.""\n                                   "" Please check that the vocabulary is not corrupted!"".format(vocab_file))\n                    index = token_index\n                writer.write(token + u\'\\n\')\n                index += 1\n        return (vocab_file,)\n\n\nclass BasicTokenizer(object):\n    """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n    def __init__(self, do_lower_case=True, never_split=None, tokenize_chinese_chars=True):\n        """""" Constructs a BasicTokenizer.\n\n        Args:\n            **do_lower_case**: Whether to lower case the input.\n            **never_split**: (`optional`) list of str\n                Kept for backward compatibility purposes.\n                Now implemented directly at the base class level (see :func:`PreTrainedTokenizer.tokenize`)\n                List of token not to split.\n            **tokenize_chinese_chars**: (`optional`) boolean (default True)\n                Whether to tokenize Chinese characters.\n                This should likely be deactivated for Japanese:\n                see: https://github.com/huggingface/pytorch-pretrained-BERT/issues/328\n        """"""\n        if never_split is None:\n            never_split = []\n        self.do_lower_case = do_lower_case\n        self.never_split = never_split\n        self.tokenize_chinese_chars = tokenize_chinese_chars\n\n    def tokenize(self, text, never_split=None):\n        """""" Basic Tokenization of a piece of text.\n            Split on ""white spaces"" only, for sub-word tokenization, see WordPieceTokenizer.\n\n        Args:\n            **never_split**: (`optional`) list of str\n                Kept for backward compatibility purposes.\n                Now implemented directly at the base class level (see :func:`PreTrainedTokenizer.tokenize`)\n                List of token not to split.\n        """"""\n        never_split = self.never_split + (never_split if never_split is not None else [])\n        text = self._clean_text(text)\n        # This was added on November 1st, 2018 for the multilingual and Chinese\n        # models. This is also applied to the English models now, but it doesn\'t\n        # matter since the English models were not trained on any Chinese data\n        # and generally don\'t have any Chinese data in them (there are Chinese\n        # characters in the vocabulary because Wikipedia does have some Chinese\n        # words in the English Wikipedia.).\n        if self.tokenize_chinese_chars:\n            text = self._tokenize_chinese_chars(text)\n        orig_tokens = whitespace_tokenize(text)\n        split_tokens = []\n        for token in orig_tokens:\n            if self.do_lower_case and token not in never_split:\n                token = token.lower()\n                token = self._run_strip_accents(token)\n            split_tokens.extend(self._run_split_on_punc(token))\n\n        output_tokens = whitespace_tokenize("" "".join(split_tokens))\n        return output_tokens\n\n    def _run_strip_accents(self, text):\n        """"""Strips accents from a piece of text.""""""\n        text = unicodedata.normalize(""NFD"", text)\n        output = []\n        for char in text:\n            cat = unicodedata.category(char)\n            if cat == ""Mn"":\n                continue\n            output.append(char)\n        return """".join(output)\n\n    def _run_split_on_punc(self, text, never_split=None):\n        """"""Splits punctuation on a piece of text.""""""\n        if never_split is not None and text in never_split:\n            return [text]\n        chars = list(text)\n        i = 0\n        start_new_word = True\n        output = []\n        while i < len(chars):\n            char = chars[i]\n            if _is_punctuation(char):\n                output.append([char])\n                start_new_word = True\n            else:\n                if start_new_word:\n                    output.append([])\n                start_new_word = False\n                output[-1].append(char)\n            i += 1\n\n        return ["""".join(x) for x in output]\n\n    def _tokenize_chinese_chars(self, text):\n        """"""Adds whitespace around any CJK character.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if self._is_chinese_char(cp):\n                output.append("" "")\n                output.append(char)\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n    def _is_chinese_char(self, cp):\n        """"""Checks whether CP is the codepoint of a CJK character.""""""\n        # This defines a ""chinese character"" as anything in the CJK Unicode block:\n        #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n        #\n        # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n        # despite its name. The modern Korean Hangul alphabet is a different block,\n        # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n        # space-separated words, so they are not treated specially and handled\n        # like the all of the other languages.\n        if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n                (cp >= 0x3400 and cp <= 0x4DBF) or  #\n                (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n                (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n                (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n                (cp >= 0x2B820 and cp <= 0x2CEAF) or\n                (cp >= 0xF900 and cp <= 0xFAFF) or  #\n                (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n            return True\n\n        return False\n\n    def _clean_text(self, text):\n        """"""Performs invalid character removal and whitespace cleanup on text.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if cp == 0 or cp == 0xfffd or _is_control(char):\n                continue\n            if _is_whitespace(char):\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n    """"""Runs WordPiece tokenization.""""""\n\n    def __init__(self, vocab, unk_token, max_input_chars_per_word=100):\n        self.vocab = vocab\n        self.unk_token = unk_token\n        self.max_input_chars_per_word = max_input_chars_per_word\n\n    def tokenize(self, text):\n        """"""Tokenizes a piece of text into its word pieces.\n\n        This uses a greedy longest-match-first algorithm to perform tokenization\n        using the given vocabulary.\n\n        For example:\n          input = ""unaffable""\n          output = [""un"", ""##aff"", ""##able""]\n\n        Args:\n          text: A single token or whitespace separated tokens. This should have\n            already been passed through `BasicTokenizer`.\n\n        Returns:\n          A list of wordpiece tokens.\n        """"""\n\n        output_tokens = []\n        for token in whitespace_tokenize(text):\n            chars = list(token)\n            if len(chars) > self.max_input_chars_per_word:\n                output_tokens.append(self.unk_token)\n                continue\n\n            is_bad = False\n            start = 0\n            sub_tokens = []\n            while start < len(chars):\n                end = len(chars)\n                cur_substr = None\n                while start < end:\n                    substr = """".join(chars[start:end])\n                    if start > 0:\n                        substr = ""##"" + substr\n                    if substr in self.vocab:\n                        cur_substr = substr\n                        break\n                    end -= 1\n                if cur_substr is None:\n                    is_bad = True\n                    break\n                sub_tokens.append(cur_substr)\n                start = end\n\n            if is_bad:\n                output_tokens.append(self.unk_token)\n            else:\n                output_tokens.extend(sub_tokens)\n        return output_tokens\n\n\ndef _is_whitespace(char):\n    """"""Checks whether `chars` is a whitespace character.""""""\n    # \\t, \\n, and \\r are technically contorl characters but we treat them\n    # as whitespace since they are generally considered as such.\n    if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return True\n    cat = unicodedata.category(char)\n    if cat == ""Zs"":\n        return True\n    return False\n\n\ndef _is_control(char):\n    """"""Checks whether `chars` is a control character.""""""\n    # These are technically control characters but we count them as whitespace\n    # characters.\n    if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return False\n    cat = unicodedata.category(char)\n    if cat.startswith(""C""):\n        return True\n    return False\n\n\ndef _is_punctuation(char):\n    """"""Checks whether `chars` is a punctuation character.""""""\n    cp = ord(char)\n    # We treat all non-letter/number ASCII as punctuation.\n    # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n    # Punctuation class but we treat them as punctuation anyways, for\n    # consistency.\n    if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n            (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n        return True\n    cat = unicodedata.category(char)\n    if cat.startswith(""P""):\n        return True\n    return False\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_ctrl.py,0,"b'# coding=utf-8\n# Copyright 2018 Salesforce and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for Salesforce CTRL.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport json\nimport logging\nimport os\nimport regex as re\nfrom io import open\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'ctrl\': ""https://raw.githubusercontent.com/salesforce/ctrl/master/ctrl-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'ctrl\': ""https://raw.githubusercontent.com/salesforce/ctrl/master/ctrl-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'ctrl\': 256,\n}\n\ndef get_pairs(word):\n    """"""Return set of symbol pairs in a word.\n\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    """"""\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n\n    pairs = set(pairs)\n    return pairs\n\nclass CTRLTokenizer(PreTrainedTokenizer):\n    """"""\n    CTRL BPE tokenizer. Peculiarities:\n        - Byte-level Byte-Pair-Encoding\n        - Requires a space to start the input string => the encoding methods should be called with the\n          ``add_prefix_space`` flag set to ``True``.\n          Otherwise, this tokenizer ``encode`` and ``decode`` method will not conserve\n          the absence of a space at the beginning of a string: `tokenizer.decode(tokenizer.encode(""Hello"")) = "" Hello""`\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, unk_token=""<unk>"", **kwargs):\n        super(CTRLTokenizer, self).__init__(unk_token=unk_token, **kwargs)\n        self.max_len_single_sentence = self.max_len # no default special tokens - you can update this value if you add special tokens\n        self.max_len_sentences_pair = self.max_len # no default special tokens - you can update this value if you add special tokens\n\n        self.encoder = json.load(open(vocab_file, encoding=""utf-8""))\n        self.decoder = {v:k for k,v in self.encoder.items()}\n        merges = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[1:-1]\n        merges = [tuple(merge.split()) for merge in merges]\n        self.bpe_ranks = dict(zip(merges, range(len(merges))))\n        self.cache = {}\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        if token in self.cache:\n            return self.cache[token]\n        word = tuple(token)\n        word = tuple(list(word[:-1]) + [word[-1]+\'</w>\'])\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token\n\n        while True:\n            bigram = min(pairs, key = lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \'@@ \'.join(word)\n        word = word[:-4]\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text):\n        """""" Tokenize a string.\n        """"""\n        split_tokens = []\n\n        text = text.split(\' \')\n\n        for token in text:\n            split_tokens.extend([t for t in self.bpe(token).split(\' \')])\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.decoder.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \' \'.join(tokens).replace(\'@@ \', \'\').strip()\n        return out_string\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            writer.write(u\'#version: 0.2\\n\')\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file\n\n    # def decode(self, token_ids, skip_special_tokens=False, clean_up_tokenization_spaces=True):\n    #     filtered_tokens = \' \'.join(self.convert_ids_to_tokens(token_ids, skip_special_tokens=skip_special_tokens))\n    #     tokens_generated_so_far = re.sub(\'(@@ )\', \'\', string=filtered_tokens)\n    #     tokens_generated_so_far = re.sub(\'(@@ ?$)\', \'\', string=tokens_generated_so_far)\n    #     return \'\'.join(tokens_generated_so_far)\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_distilbert.py,0,"b'# coding=utf-8\n# Copyright 2018 The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for DistilBERT.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport logging\nimport os\nimport unicodedata\nfrom io import open\n\nfrom .tokenization_bert import BertTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'vocab_file\': \'vocab.txt\'}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'distilbert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-vocab.txt"",\n        \'distilbert-base-uncased-distilled-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt"",\n    }\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'distilbert-base-uncased\': 512,\n    \'distilbert-base-uncased-distilled-squad\': 512,\n}\n\n\nclass DistilBertTokenizer(BertTokenizer):\n    r""""""\n    Constructs a DistilBertTokenizer.\n    :class:`~transformers.DistilBertTokenizer` is identical to BertTokenizer and runs end-to-end tokenization: punctuation splitting + wordpiece\n\n    Args:\n        vocab_file: Path to a one-wordpiece-per-line vocabulary file\n        do_lower_case: Whether to lower case the input. Only has an effect when do_wordpiece_only=False\n        do_basic_tokenize: Whether to do basic tokenization before wordpiece.\n        max_len: An artificial maximum length to truncate tokenized sequences to; Effective maximum length is always the\n            minimum of this value (if specified) and the underlying BERT model\'s sequence length.\n        never_split: List of tokens which will never be split during tokenization. Only has an effect when\n            do_wordpiece_only=False\n    """"""\n\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_gpt2.py,0,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport sys\nimport json\nimport logging\nimport os\nimport regex as re\nfrom io import open\n\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    # Just a dummy decorator to get the checks to run on python2\n    # because honestly I don\'t want to support a byte-level unicode BPE tokenizer on python 2 right now.\n    def lru_cache():\n        return lambda func: func\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'gpt2\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-vocab.json"",\n        \'gpt2-medium\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-vocab.json"",\n        \'gpt2-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-large-vocab.json"",\n        \'distilgpt2\': ""https://s3.amazonaws.com/models.huggingface.co/bert/distilgpt2-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'gpt2\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-merges.txt"",\n        \'gpt2-medium\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-merges.txt"",\n        \'gpt2-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-large-merges.txt"",\n        \'distilgpt2\': ""https://s3.amazonaws.com/models.huggingface.co/bert/distilgpt2-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'gpt2\': 1024,\n    \'gpt2-medium\': 1024,\n    \'gpt2-large\': 1024,\n    \'distilgpt2\': 1024,\n}\n\n@lru_cache()\ndef bytes_to_unicode():\n    """"""\n    Returns list of utf-8 byte and a mapping to unicode strings.\n    We specifically avoids mapping to whitespace/control characters the bpe code barfs on.\n    \n    The reversible bpe codes work on unicode strings.\n    This means you need a large # of unicode characters in your vocab if you want to avoid UNKs.\n    When you\'re at something like a 10B token dataset you end up needing around 5K for decent coverage.\n    This is a signficant percentage of your normal, say, 32K bpe vocab.\n    To avoid that, we want lookup tables between utf-8 bytes and unicode strings.\n    """"""\n    _chr = unichr if sys.version_info[0] == 2 else chr\n    bs = list(range(ord(""!""), ord(""~"")+1))+list(range(ord(""\xc2\xa1""), ord(""\xc2\xac"")+1))+list(range(ord(""\xc2\xae""), ord(""\xc3\xbf"")+1))\n    cs = bs[:]\n    n = 0\n    for b in range(2**8):\n        if b not in bs:\n            bs.append(b)\n            cs.append(2**8+n)\n            n += 1\n    cs = [_chr(n) for n in cs]\n    return dict(zip(bs, cs))\n\ndef get_pairs(word):\n    """"""Return set of symbol pairs in a word.\n\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    """"""\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n    return pairs\n\nclass GPT2Tokenizer(PreTrainedTokenizer):\n    """"""\n    GPT-2 BPE tokenizer. Peculiarities:\n        - Byte-level Byte-Pair-Encoding\n        - Requires a space to start the input string => the encoding methods should be called with the\n          ``add_prefix_space`` flag set to ``True``.\n          Otherwise, this tokenizer ``encode`` and ``decode`` method will not conserve\n          the absence of a space at the beginning of a string: `tokenizer.decode(tokenizer.encode(""Hello"")) = "" Hello""`\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, errors=\'replace\', unk_token=""<|endoftext|>"",\n                 bos_token=""<|endoftext|>"", eos_token=""<|endoftext|>"", **kwargs):\n        super(GPT2Tokenizer, self).__init__(bos_token=bos_token, eos_token=eos_token, unk_token=unk_token, **kwargs)\n        self.max_len_single_sentence = self.max_len # no default special tokens - you can update this value if you add special tokens\n        self.max_len_sentences_pair = self.max_len # no default special tokens - you can update this value if you add special tokens\n\n        self.encoder = json.load(open(vocab_file, encoding=""utf-8""))\n        self.decoder = {v: k for k, v in self.encoder.items()}\n        self.errors = errors  # how to handle errors in decoding\n        self.byte_encoder = bytes_to_unicode()\n        self.byte_decoder = {v: k for k, v in self.byte_encoder.items()}\n        bpe_data = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[1:-1]\n        bpe_merges = [tuple(merge.split()) for merge in bpe_data]\n        self.bpe_ranks = dict(zip(bpe_merges, range(len(bpe_merges))))\n        self.cache = {}\n\n        # Should haved added re.IGNORECASE so BPE merges can happen for capitalized versions of contractions\n        self.pat = re.compile(r""""""\'s|\'t|\'re|\'ve|\'m|\'ll|\'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+"""""")\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        if token in self.cache:\n            return self.cache[token]\n        word = tuple(token)\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token\n\n        while True:\n            bigram = min(pairs, key = lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \' \'.join(word)\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text, add_prefix_space=False):\n        """""" Tokenize a string.\n            Args:\n                - add_prefix_space (boolean, default False):\n                    Begin the sentence with at least one space toto get invariance to word order in GPT-2 (and RoBERTa) tokenizers.\n        """"""\n        if add_prefix_space:\n            text = \' \' + text\n\n        bpe_tokens = []\n        for token in re.findall(self.pat, text):\n            if sys.version_info[0] == 2:\n                token = \'\'.join(self.byte_encoder[ord(b)] for b in token) # Maps all our bytes to unicode strings, avoiding controle tokens of the BPE (spaces in our case)\n            else:\n                token = \'\'.join(self.byte_encoder[b] for b in token.encode(\'utf-8\')) # Maps all our bytes to unicode strings, avoiding controle tokens of the BPE (spaces in our case)\n            bpe_tokens.extend(bpe_token for bpe_token in self.bpe(token).split(\' \'))\n        return bpe_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.decoder.get(index)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        text = \'\'.join(tokens)\n        text = bytearray([self.byte_decoder[c] for c in text]).decode(\'utf-8\', errors=self.errors)\n        return text\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            writer.write(u\'#version: 0.2\\n\')\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_openai.py,0,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport json\nimport logging\nimport os\nimport re\nfrom io import open\n\nfrom .tokenization_utils import PreTrainedTokenizer\nfrom .tokenization_bert import BasicTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'openai-gpt\': ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'openai-gpt\': ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'openai-gpt\': 512,\n}\n\ndef get_pairs(word):\n    """"""\n    Return set of symbol pairs in a word.\n    word is represented as tuple of symbols (symbols being variable-length strings)\n    """"""\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n    return pairs\n\ndef text_standardize(text):\n    """"""\n    fixes some issues the spacy tokenizer had on books corpus\n    also does some whitespace standardization\n    """"""\n    text = text.replace(\'\xe2\x80\x94\', \'-\')\n    text = text.replace(\'\xe2\x80\x93\', \'-\')\n    text = text.replace(\'\xe2\x80\x95\', \'-\')\n    text = text.replace(\'\xe2\x80\xa6\', \'...\')\n    text = text.replace(\'\xc2\xb4\', ""\'"")\n    text = re.sub(r\'\'\'(-+|~+|!+|""+|;+|\\?+|\\++|,+|\\)+|\\(+|\\\\+|\\/+|\\*+|\\[+|\\]+|}+|{+|\\|+|_+)\'\'\', r\' \\1 \', text)\n    text = re.sub(r\'\\s*\\n\\s*\', \' \\n \', text)\n    text = re.sub(r\'[^\\S\\n]+\', \' \', text)\n    return text.strip()\n\nclass OpenAIGPTTokenizer(PreTrainedTokenizer):\n    """"""\n    BPE tokenizer. Peculiarities:\n        - lower case all inputs\n        - uses SpaCy tokenizer and ftfy for pre-BPE tokenization if they are installed, fallback to BERT\'s BasicTokenizer if not.\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, unk_token=""<unk>"", **kwargs):\n        super(OpenAIGPTTokenizer, self).__init__(unk_token=unk_token, **kwargs)\n\n        self.max_len_single_sentence = self.max_len # no default special tokens - you can update this value if you add special tokens\n        self.max_len_sentences_pair = self.max_len # no default special tokens - you can update this value if you add special tokens\n\n        try:\n            import ftfy\n            from spacy.lang.en import English\n            _nlp = English()\n            self.nlp = _nlp.Defaults.create_tokenizer(_nlp)\n            self.fix_text = ftfy.fix_text\n        except ImportError:\n            logger.warning(""ftfy or spacy is not installed using BERT BasicTokenizer instead of SpaCy & ftfy."")\n            self.nlp = BasicTokenizer(do_lower_case=True)\n            self.fix_text = None\n\n        self.encoder = json.load(open(vocab_file, encoding=""utf-8""))\n        self.decoder = {v:k for k,v in self.encoder.items()}\n        merges = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[1:-1]\n        merges = [tuple(merge.split()) for merge in merges]\n        self.bpe_ranks = dict(zip(merges, range(len(merges))))\n        self.cache = {}\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        word = tuple(token[:-1]) + (token[-1] + \'</w>\',)\n        if token in self.cache:\n            return self.cache[token]\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token+\'</w>\'\n\n        while True:\n            bigram = min(pairs, key=lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \' \'.join(word)\n        if word == \'\\n  </w>\':\n            word = \'\\n</w>\'\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text):\n        """""" Tokenize a string. """"""\n        split_tokens = []\n        if self.fix_text is None:\n            # Using BERT\'s BasicTokenizer\n            text = self.nlp.tokenize(text)\n            for token in text:\n                split_tokens.extend([t for t in self.bpe(token).split(\' \')])\n        else:\n            # Using SpaCy & ftfy (original tokenization process of OpenAI GPT)\n            text = self.nlp(text_standardize(self.fix_text(text)))\n            for token in text:\n                split_tokens.extend([t for t in self.bpe(token.text.lower()).split(\' \')])\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an id in a token (BPE) using the vocab.""""""\n        return self.decoder.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \'\'.join(tokens).replace(\'</w>\', \' \').strip()\n        return out_string\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            writer.write(u\'#version: 0.2\\n\')\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_roberta.py,0,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for RoBERTa.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport sys\nimport json\nimport logging\nimport os\nimport regex as re\nfrom io import open\n\nfrom .tokenization_gpt2 import GPT2Tokenizer\n\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    # Just a dummy decorator to get the checks to run on python2\n    # because honestly I don\'t want to support a byte-level unicode BPE tokenizer on python 2 right now.\n    def lru_cache():\n        return lambda func: func\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-vocab.json"",\n        \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-vocab.json"",\n        \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-merges.txt"",\n        \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-merges.txt"",\n        \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'roberta-base\': 512,\n    \'roberta-large\': 512,\n    \'roberta-large-mnli\': 512,\n}\n\n\nclass RobertaTokenizer(GPT2Tokenizer):\n    """"""\n    RoBERTa BPE tokenizer, derived from the GPT-2 tokenizer. Peculiarities:\n        - Byte-level Byte-Pair-Encoding\n        - Requires a space to start the input string => the encoding methods should be called with the\n          ``add_prefix_space`` flag set to ``True``.\n          Otherwise, this tokenizer ``encode`` and ``decode`` method will not conserve\n          the absence of a space at the beginning of a string: `tokenizer.decode(tokenizer.encode(""Hello"")) = "" Hello""`\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, errors=\'replace\', bos_token=""<s>"", eos_token=""</s>"", sep_token=""</s>"",\n                 cls_token=""<s>"", unk_token=""<unk>"", pad_token=\'<pad>\', mask_token=\'<mask>\', **kwargs):\n        super(RobertaTokenizer, self).__init__(vocab_file=vocab_file, merges_file=merges_file, errors=errors,\n                                               bos_token=bos_token, eos_token=eos_token, unk_token=unk_token,\n                                               sep_token=sep_token, cls_token=cls_token, pad_token=pad_token,\n                                               mask_token=mask_token, **kwargs)\n        self.max_len_single_sentence = self.max_len - 2  # take into account special tokens\n        self.max_len_sentences_pair = self.max_len - 4  # take into account special tokens\n\n    def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None):\n        """"""\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks\n        by concatenating and adding special tokens.\n        A RoBERTa sequence has the following format:\n            single sequence: <s> X </s>\n            pair of sequences: <s> A </s></s> B </s>\n        """"""\n        if token_ids_1 is None:\n            return [self.cls_token_id] + token_ids_0 + [self.sep_token_id]\n        cls = [self.cls_token_id]\n        sep = [self.sep_token_id]\n        return cls + token_ids_0 + sep + sep + token_ids_1 + sep\n\n    def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False):\n        """"""\n        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer ``prepare_for_model`` or ``encode_plus`` methods.\n\n        Args:\n            token_ids_0: list of ids (must not contain special tokens)\n            token_ids_1: Optional list of ids (must not contain special tokens), necessary when fetching sequence ids\n                for sequence pairs\n            already_has_special_tokens: (default False) Set to True if the token list is already formated with\n                special tokens for the model\n\n        Returns:\n            A list of integers in the range [0, 1]: 0 for a special token, 1 for a sequence token.\n        """"""\n        if already_has_special_tokens:\n            if token_ids_1 is not None:\n                raise ValueError(""You should not supply a second sequence if the provided sequence of ""\n                                 ""ids is already formated with special tokens for the model."")\n            return list(map(lambda x: 1 if x in [self.sep_token_id, self.cls_token_id] else 0, token_ids_0))\n\n        if token_ids_1 is None:\n            return [1] + ([0] * len(token_ids_0)) + [1]\n        return [1] + ([0] * len(token_ids_0)) + [1, 1] + ([0] * len(token_ids_1)) + [1]\n\n    def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None):\n        """"""\n        Creates a mask from the two sequences passed to be used in a sequence-pair classification task.\n        A RoBERTa sequence pair mask has the following format:\n        0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1\n        | first sequence    | second sequence\n\n        if token_ids_1 is None, only returns the first portion of the mask (0\'s).\n        """"""\n        sep = [self.sep_token_id]\n        cls = [self.cls_token_id]\n\n        if token_ids_1 is None:\n            return len(cls + token_ids_0 + sep) * [0]\n        return len(cls + token_ids_0 + sep + sep) * [0] + len(token_ids_1 + sep) * [1]\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_transfo_xl.py,0,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Tokenization classes for Transformer XL model.\n    Adapted from https://github.com/kimiyoung/transformer-xl.\n""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport glob\nimport logging\nimport os\nimport sys\nfrom collections import Counter, OrderedDict\nfrom io import open\n\nimport numpy as np\n\nfrom .file_utils import cached_path\nfrom .tokenization_utils import PreTrainedTokenizer\n\ntry:\n    import torch\nexcept ImportError:\n    pass\n\n# if sys.version_info[0] == 2:\n#     import cPickle as pickle\n# else:\n#     import pickle\n\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'pretrained_vocab_file\': \'vocab.bin\', \'vocab_file\': \'vocab.txt\'}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'pretrained_vocab_file\':\n    {\n        \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-vocab.bin"",\n    }\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'transfo-xl-wt103\': None,\n}\n\nPRETRAINED_CORPUS_ARCHIVE_MAP = {\n    \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-corpus.bin"",\n}\nCORPUS_NAME = \'corpus.bin\'\n\nclass TransfoXLTokenizer(PreTrainedTokenizer):\n    """"""\n    Transformer-XL tokenizer adapted from Vocab class in https://github.com/kimiyoung/transformer-xl\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, special=None, min_freq=0, max_size=None, lower_case=False,\n                 delimiter=None, vocab_file=None, pretrained_vocab_file=None,\n                 never_split=None, unk_token=""<unk>"", eos_token=""<eos>"",\n                 additional_special_tokens=[""<formula>""], **kwargs):\n        super(TransfoXLTokenizer, self).__init__(unk_token=unk_token, eos_token=eos_token,\n                                                 additional_special_tokens=additional_special_tokens,\n                                                 **kwargs)\n\n        self.max_len_single_sentence = self.max_len # no default special tokens - you can update this value if you add special tokens\n        self.max_len_sentences_pair = self.max_len # no default special tokens - you can update this value if you add special tokens\n\n        if never_split is None:\n            never_split = self.all_special_tokens\n        if special is None:\n            special = []\n        self.counter = Counter()\n        self.special = special\n        self.min_freq = min_freq\n        self.max_size = max_size\n        self.lower_case = lower_case\n        self.delimiter = delimiter\n        self.vocab_file = vocab_file\n        self.never_split = never_split\n\n        if pretrained_vocab_file is not None:\n            # Hack because, honestly this tokenizer was not made to be used\n            # in a library like ours, at all.\n            vocab_dict = torch.load(pretrained_vocab_file)\n            for key, value in vocab_dict.items():\n                if key not in self.__dict__:\n                    self.__dict__[key] = value\n\n        if vocab_file is not None:\n            self.build_vocab()\n\n    def count_file(self, path, verbose=False, add_eos=False):\n        if verbose: logger.info(\'counting file {} ...\'.format(path))\n        assert os.path.exists(path)\n\n        sents = []\n        with open(path, \'r\', encoding=\'utf-8\') as f:\n            for idx, line in enumerate(f):\n                if verbose and idx > 0 and idx % 500000 == 0:\n                    logger.info(\'    line {}\'.format(idx))\n                symbols = self.tokenize(line, add_eos=add_eos)\n                self.counter.update(symbols)\n                sents.append(symbols)\n\n        return sents\n\n    def count_sents(self, sents, verbose=False):\n        """"""\n            sents : a list of sentences, each a list of tokenized symbols\n        """"""\n        if verbose: logger.info(\'counting {} sents ...\'.format(len(sents)))\n        for idx, symbols in enumerate(sents):\n            if verbose and idx > 0 and idx % 500000 == 0:\n                logger.info(\'    line {}\'.format(idx))\n            self.counter.update(symbols)\n\n    def _build_from_file(self, vocab_file):\n        self.idx2sym = []\n        self.sym2idx = OrderedDict()\n\n        with open(vocab_file, \'r\', encoding=\'utf-8\') as f:\n            for line in f:\n                symb = line.strip().split()[0]\n                self.add_symbol(symb)\n        if \'<UNK>\' in self.sym2idx:\n            self.unk_idx = self.sym2idx[\'<UNK>\']\n        elif \'<unk>\' in self.sym2idx:\n            self.unk_idx = self.sym2idx[\'<unk>\']\n        else:\n            raise ValueError(\'No <unkown> token in vocabulary\')\n\n    def save_vocabulary(self, vocab_path):\n        """"""Save the tokenizer vocabulary to a directory or file.""""""\n        if os.path.isdir(vocab_path):\n            vocab_file = os.path.join(vocab_path, VOCAB_FILES_NAMES[\'pretrained_vocab_file\'])\n        torch.save(self.__dict__, vocab_file)\n        return (vocab_file,)\n\n    def build_vocab(self):\n        if self.vocab_file:\n            logger.info(\'building vocab from {}\'.format(self.vocab_file))\n            self._build_from_file(self.vocab_file)\n            logger.info(\'final vocab size {}\'.format(len(self)))\n        else:\n            logger.info(\'building vocab with min_freq={}, max_size={}\'.format(\n                self.min_freq, self.max_size))\n            self.idx2sym = []\n            self.sym2idx = OrderedDict()\n\n            for sym in self.special:\n                self.add_special(sym)\n\n            for sym, cnt in self.counter.most_common(self.max_size):\n                if cnt < self.min_freq: break\n                self.add_symbol(sym)\n\n            logger.info(\'final vocab size {} from {} unique tokens\'.format(\n                len(self), len(self.counter)))\n\n    def encode_file(self, path, ordered=False, verbose=False, add_eos=True,\n            add_double_eos=False):\n        if verbose: logger.info(\'encoding file {} ...\'.format(path))\n        assert os.path.exists(path)\n        encoded = []\n        with open(path, \'r\', encoding=\'utf-8\') as f:\n            for idx, line in enumerate(f):\n                if verbose and idx > 0 and idx % 500000 == 0:\n                    logger.info(\'    line {}\'.format(idx))\n                symbols = self.tokenize(line, add_eos=add_eos,\n                    add_double_eos=add_double_eos)\n                encoded.append(self.convert_to_tensor(symbols))\n\n        if ordered:\n            encoded = torch.cat(encoded)\n\n        return encoded\n\n    def encode_sents(self, sents, ordered=False, verbose=False):\n        if verbose: logger.info(\'encoding {} sents ...\'.format(len(sents)))\n        encoded = []\n        for idx, symbols in enumerate(sents):\n            if verbose and idx > 0 and idx % 500000 == 0:\n                logger.info(\'    line {}\'.format(idx))\n            encoded.append(self.convert_to_tensor(symbols))\n\n        if ordered:\n            encoded = torch.cat(encoded)\n\n        return encoded\n\n    def add_special(self, sym):\n        if sym not in self.sym2idx:\n            self.idx2sym.append(sym)\n            self.sym2idx[sym] = len(self.idx2sym) - 1\n            setattr(self, \'{}_idx\'.format(sym.strip(\'<>\')), self.sym2idx[sym])\n\n    def add_symbol(self, sym):\n        if sym not in self.sym2idx:\n            self.idx2sym.append(sym)\n            self.sym2idx[sym] = len(self.idx2sym) - 1\n\n    def _convert_id_to_token(self, idx):\n        """"""Converts an id in a token (BPE) using the vocab.""""""\n        assert 0 <= idx < len(self), \'Index {} out of vocabulary range\'.format(idx)\n        return self.idx2sym[idx]\n\n    def _convert_token_to_id(self, sym):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        if sym in self.sym2idx:\n            return self.sym2idx[sym]\n        else:\n            # logger.info(\'encounter unk {}\'.format(sym))\n            # assert \'<eos>\' not in sym\n            if hasattr(self, \'unk_idx\'):\n                return self.sym2idx.get(sym, self.unk_idx)\n            # Backward compatibility with pre-trained models\n            elif \'<unk>\' in self.sym2idx:\n                return self.sym2idx[\'<unk>\']\n            elif \'<UNK>\' in self.sym2idx:\n                return self.sym2idx[\'<UNK>\']\n            else:\n                raise ValueError(\'Token not in vocabulary and no <unk> token in vocabulary for replacement\')\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \' \'.join(tokens).strip()\n        return out_string\n\n    def convert_to_tensor(self, symbols):\n        return torch.LongTensor(self.convert_tokens_to_ids(symbols))\n\n    @property\n    def vocab_size(self):\n        return len(self.idx2sym)\n\n    def _tokenize(self, line, add_eos=False, add_double_eos=False):\n        line = line.strip()\n        # convert to lower case\n        if self.lower_case:\n            line = line.lower()\n\n        # empty delimiter \'\' will evaluate False\n        if self.delimiter == \'\':\n            symbols = line\n        else:\n            symbols = line.split(self.delimiter)\n\n        if add_double_eos: # lm1b\n            return [\'<S>\'] + symbols + [\'<S>\']\n        elif add_eos:\n            return symbols + [\'<eos>\']\n        else:\n            return symbols\n\n\nclass LMOrderedIterator(object):\n    def __init__(self, data, bsz, bptt, device=\'cpu\', ext_len=None):\n        """"""\n            data -- LongTensor -- the LongTensor is strictly ordered\n        """"""\n        self.bsz = bsz\n        self.bptt = bptt\n        self.ext_len = ext_len if ext_len is not None else 0\n\n        self.device = device\n\n        # Work out how cleanly we can divide the dataset into bsz parts.\n        self.n_step = data.size(0) // bsz\n\n        # Trim off any extra elements that wouldn\'t cleanly fit (remainders).\n        data = data.narrow(0, 0, self.n_step * bsz)\n\n        # Evenly divide the data across the bsz batches.\n        self.data = data.view(bsz, -1).t().contiguous().to(device)\n\n        # Number of mini-batches\n        self.n_batch = (self.n_step + self.bptt - 1) // self.bptt\n\n    def get_batch(self, i, bptt=None):\n        if bptt is None: bptt = self.bptt\n        seq_len = min(bptt, self.data.size(0) - 1 - i)\n\n        end_idx = i + seq_len\n        beg_idx = max(0, i - self.ext_len)\n\n        data = self.data[beg_idx:end_idx]\n        target = self.data[i+1:i+1+seq_len]\n\n        data_out = data.transpose(0, 1).contiguous().to(self.device)\n        target_out = target.transpose(0, 1).contiguous().to(self.device)\n\n        return data_out, target_out, seq_len\n\n    def get_fixlen_iter(self, start=0):\n        for i in range(start, self.data.size(0) - 1, self.bptt):\n            yield self.get_batch(i)\n\n    def get_varlen_iter(self, start=0, std=5, min_len=5, max_deviation=3):\n        max_len = self.bptt + max_deviation * std\n        i = start\n        while True:\n            bptt = self.bptt if np.random.random() < 0.95 else self.bptt / 2.\n            bptt = min(max_len, max(min_len, int(np.random.normal(bptt, std))))\n            data, target, seq_len = self.get_batch(i, bptt)\n            i += seq_len\n            yield data, target, seq_len\n            if i >= self.data.size(0) - 2:\n                break\n\n    def __iter__(self):\n        return self.get_fixlen_iter()\n\n\nclass LMShuffledIterator(object):\n    def __init__(self, data, bsz, bptt, device=\'cpu\', ext_len=None, shuffle=False):\n        """"""\n            data -- list[LongTensor] -- there is no order among the LongTensors\n        """"""\n        self.data = data\n\n        self.bsz = bsz\n        self.bptt = bptt\n        self.ext_len = ext_len if ext_len is not None else 0\n\n        self.device = device\n        self.shuffle = shuffle\n\n    def get_sent_stream(self):\n        # index iterator\n        epoch_indices = np.random.permutation(len(self.data)) if self.shuffle \\\n            else np.array(range(len(self.data)))\n\n        # sentence iterator\n        for idx in epoch_indices:\n            yield self.data[idx]\n\n    def stream_iterator(self, sent_stream):\n        # streams for each data in the batch\n        streams = [None] * self.bsz\n\n        data = torch.LongTensor(self.bptt, self.bsz)\n        target = torch.LongTensor(self.bptt, self.bsz)\n\n        n_retain = 0\n\n        while True:\n            # data   : [n_retain+bptt x bsz]\n            # target : [bptt x bsz]\n            data[n_retain:].fill_(-1)\n            target.fill_(-1)\n\n            valid_batch = True\n\n            for i in range(self.bsz):\n                n_filled = 0\n                try:\n                    while n_filled < self.bptt:\n                        if streams[i] is None or len(streams[i]) <= 1:\n                            streams[i] = next(sent_stream)\n                        # number of new tokens to fill in\n                        n_new = min(len(streams[i]) - 1, self.bptt - n_filled)\n                        # first n_retain tokens are retained from last batch\n                        data[n_retain+n_filled:n_retain+n_filled+n_new, i] = \\\n                            streams[i][:n_new]\n                        target[n_filled:n_filled+n_new, i] = \\\n                            streams[i][1:n_new+1]\n                        streams[i] = streams[i][n_new:]\n                        n_filled += n_new\n                except StopIteration:\n                    valid_batch = False\n                    break\n\n            if not valid_batch:\n                return\n\n            data_out = data.transpose(0, 1).contiguous().to(self.device)\n            target_out = target.transpose(0, 1).contiguous().to(self.device)\n\n            yield data_out, target_out, self.bptt\n\n            n_retain = min(data.size(0), self.ext_len)\n            if n_retain > 0:\n                data[:n_retain] = data[-n_retain:]\n            data.resize_(n_retain + self.bptt, data.size(1))\n\n    def __iter__(self):\n        # sent_stream is an iterator\n        sent_stream = self.get_sent_stream()\n\n        for batch in self.stream_iterator(sent_stream):\n            yield batch\n\n\nclass LMMultiFileIterator(LMShuffledIterator):\n    def __init__(self, paths, vocab, bsz, bptt, device=\'cpu\', ext_len=None,\n        shuffle=False):\n\n        self.paths = paths\n        self.vocab = vocab\n\n        self.bsz = bsz\n        self.bptt = bptt\n        self.ext_len = ext_len if ext_len is not None else 0\n\n        self.device = device\n        self.shuffle = shuffle\n\n    def get_sent_stream(self, path):\n        sents = self.vocab.encode_file(path, add_double_eos=True)\n        if self.shuffle:\n            np.random.shuffle(sents)\n        sent_stream = iter(sents)\n\n        return sent_stream\n\n    def __iter__(self):\n        if self.shuffle:\n            np.random.shuffle(self.paths)\n\n        for path in self.paths:\n            # sent_stream is an iterator\n            sent_stream = self.get_sent_stream(path)\n            for batch in self.stream_iterator(sent_stream):\n                yield batch\n\n\nclass TransfoXLCorpus(object):\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, cache_dir=None, *inputs, **kwargs):\n        """"""\n        Instantiate a pre-processed corpus.\n        """"""\n        vocab = TransfoXLTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        if pretrained_model_name_or_path in PRETRAINED_CORPUS_ARCHIVE_MAP:\n            corpus_file = PRETRAINED_CORPUS_ARCHIVE_MAP[pretrained_model_name_or_path]\n        else:\n            corpus_file = os.path.join(pretrained_model_name_or_path, CORPUS_NAME)\n        # redirect to the cache, if necessary\n        try:\n            resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)\n        except EnvironmentError:\n            logger.error(\n                ""Corpus \'{}\' was not found in corpus list ({}). ""\n                ""We assumed \'{}\' was a path or url but couldn\'t find files {} ""\n                ""at this path or url."".format(\n                    pretrained_model_name_or_path,\n                    \', \'.join(PRETRAINED_CORPUS_ARCHIVE_MAP.keys()),\n                    pretrained_model_name_or_path,\n                    corpus_file))\n            return None\n        if resolved_corpus_file == corpus_file:\n            logger.info(""loading corpus file {}"".format(corpus_file))\n        else:\n            logger.info(""loading corpus file {} from cache at {}"".format(\n                corpus_file, resolved_corpus_file))\n\n        # Instantiate tokenizer.\n        corpus = cls(*inputs, **kwargs)\n        corpus_dict = torch.load(resolved_corpus_file)\n        for key, value in corpus_dict.items():\n            corpus.__dict__[key] = value\n        corpus.vocab = vocab\n        if corpus.train is not None:\n            corpus.train = torch.tensor(corpus.train, dtype=torch.long)\n        if corpus.valid is not None:\n            corpus.valid = torch.tensor(corpus.valid, dtype=torch.long)\n        if corpus.test is not None:\n            corpus.test = torch.tensor(corpus.test, dtype=torch.long)\n        return corpus\n\n    def __init__(self, *args, **kwargs):\n        self.vocab = TransfoXLTokenizer(*args, **kwargs)\n        self.dataset = None\n        self.train = None\n        self.valid = None\n        self.test = None\n\n    def build_corpus(self, path, dataset):\n        self.dataset = dataset\n\n        if self.dataset in [\'ptb\', \'wt2\', \'enwik8\', \'text8\']:\n            self.vocab.count_file(os.path.join(path, \'train.txt\'))\n            self.vocab.count_file(os.path.join(path, \'valid.txt\'))\n            self.vocab.count_file(os.path.join(path, \'test.txt\'))\n        elif self.dataset == \'wt103\':\n            self.vocab.count_file(os.path.join(path, \'train.txt\'))\n        elif self.dataset == \'lm1b\':\n            train_path_pattern = os.path.join(\n                path, \'1-billion-word-language-modeling-benchmark-r13output\',\n                \'training-monolingual.tokenized.shuffled\', \'news.en-*\')\n            train_paths = glob.glob(train_path_pattern)\n            # the vocab will load from file when build_vocab() is called\n\n        self.vocab.build_vocab()\n\n        if self.dataset in [\'ptb\', \'wt2\', \'wt103\']:\n            self.train = self.vocab.encode_file(\n                os.path.join(path, \'train.txt\'), ordered=True)\n            self.valid = self.vocab.encode_file(\n                os.path.join(path, \'valid.txt\'), ordered=True)\n            self.test = self.vocab.encode_file(\n                os.path.join(path, \'test.txt\'), ordered=True)\n        elif self.dataset in [\'enwik8\', \'text8\']:\n            self.train = self.vocab.encode_file(\n                os.path.join(path, \'train.txt\'), ordered=True, add_eos=False)\n            self.valid = self.vocab.encode_file(\n                os.path.join(path, \'valid.txt\'), ordered=True, add_eos=False)\n            self.test = self.vocab.encode_file(\n                os.path.join(path, \'test.txt\'), ordered=True, add_eos=False)\n        elif self.dataset == \'lm1b\':\n            self.train = train_paths\n            self.valid = self.vocab.encode_file(\n                os.path.join(path, \'valid.txt\'), ordered=False, add_double_eos=True)\n            self.test = self.vocab.encode_file(\n                os.path.join(path, \'test.txt\'), ordered=False, add_double_eos=True)\n\n    def get_iterator(self, split, *args, **kwargs):\n        if split == \'train\':\n            if self.dataset in [\'ptb\', \'wt2\', \'wt103\', \'enwik8\', \'text8\']:\n                data_iter = LMOrderedIterator(self.train, *args, **kwargs)\n            elif self.dataset == \'lm1b\':\n                kwargs[\'shuffle\'] = True\n                data_iter = LMMultiFileIterator(self.train, self.vocab, *args, **kwargs)\n        elif split in [\'valid\', \'test\']:\n            data = self.valid if split == \'valid\' else self.test\n            if self.dataset in [\'ptb\', \'wt2\', \'wt103\', \'enwik8\', \'text8\']:\n                data_iter = LMOrderedIterator(data, *args, **kwargs)\n            elif self.dataset == \'lm1b\':\n                data_iter = LMShuffledIterator(data, *args, **kwargs)\n\n        return data_iter\n\n\ndef get_lm_corpus(datadir, dataset):\n    fn = os.path.join(datadir, \'cache.pt\')\n    fn_pickle = os.path.join(datadir, \'cache.pkl\')\n    if os.path.exists(fn):\n        logger.info(\'Loading cached dataset...\')\n        corpus = torch.load(fn_pickle)\n    elif os.path.exists(fn):\n        logger.info(\'Loading cached dataset from pickle...\')\n        with open(fn, ""rb"") as fp:\n            corpus = pickle.load(fp)\n    else:\n        logger.info(\'Producing dataset {}...\'.format(dataset))\n        kwargs = {}\n        if dataset in [\'wt103\', \'wt2\']:\n            kwargs[\'special\'] = [\'<eos>\']\n            kwargs[\'lower_case\'] = False\n        elif dataset == \'ptb\':\n            kwargs[\'special\'] = [\'<eos>\']\n            kwargs[\'lower_case\'] = True\n        elif dataset == \'lm1b\':\n            kwargs[\'special\'] = []\n            kwargs[\'lower_case\'] = False\n            kwargs[\'vocab_file\'] = os.path.join(datadir, \'1b_word_vocab.txt\')\n        elif dataset in [\'enwik8\', \'text8\']:\n            pass\n\n        corpus = TransfoXLCorpus(datadir, dataset, **kwargs)\n        torch.save(corpus, fn)\n\n    return corpus\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_utils.py,5,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\nimport os\nimport json\nimport six\nimport copy\nfrom io import open\n\nfrom .file_utils import cached_path, is_tf_available, is_torch_available\n\nif is_tf_available():\n    import tensorflow as tf\nif is_torch_available():\n    import torch\n\nlogger = logging.getLogger(__name__)\n\nSPECIAL_TOKENS_MAP_FILE = \'special_tokens_map.json\'\nADDED_TOKENS_FILE = \'added_tokens.json\'\nTOKENIZER_CONFIG_FILE = \'tokenizer_config.json\'\n\nclass PreTrainedTokenizer(object):\n    """""" Base class for all tokenizers.\n    Handle all the shared methods for tokenization and special tokens as well as methods dowloading/caching/loading pretrained tokenizers as well as adding tokens to the vocabulary.\n\n    This class also contain the added tokens in a unified way on top of all tokenizers so we don\'t have to handle the specific vocabulary augmentation methods of the various underlying dictionary structures (BPE, sentencepiece...).\n\n    Class attributes (overridden by derived classes):\n\n        - ``vocab_files_names``: a python ``dict`` with, as keys, the ``__init__`` keyword name of each vocabulary file required by the model, and as associated values, the filename for saving the associated file (string).\n        - ``pretrained_vocab_files_map``: a python ``dict of dict`` the high-level keys being the ``__init__`` keyword name of each vocabulary file required by the model, the low-level being the `short-cut-names` (string) of the pretrained models with, as associated values, the `url` (string) to the associated pretrained vocabulary file.\n        - ``max_model_input_sizes``: a python ``dict`` with, as keys, the `short-cut-names` (string) of the pretrained models, and as associated values, the maximum length of the sequence inputs of this model, or None if the model has no maximum input size.\n        - ``pretrained_init_configuration``: a python ``dict`` with, as keys, the `short-cut-names` (string) of the pretrained models, and as associated values, a dictionnary of specific arguments to pass to the ``__init__``method of the tokenizer class for this pretrained model when loading the tokenizer with the ``from_pretrained()`` method.\n\n    Parameters:\n\n        - ``bos_token``: (`Optional`) string: a beginning of sentence token. Will be associated to ``self.bos_token`` and ``self.bos_token_id``\n\n        - ``eos_token``: (`Optional`) string: an end of sentence token. Will be associated to ``self.eos_token`` and ``self.eos_token_id``\n\n        - ``unk_token``: (`Optional`) string: an unknown token. Will be associated to ``self.unk_token`` and ``self.unk_token_id``\n\n        - ``sep_token``: (`Optional`) string: a separation token (e.g. to separate context and query in an input sequence). Will be associated to ``self.sep_token`` and ``self.sep_token_id``\n\n        - ``pad_token``: (`Optional`) string: a padding token. Will be associated to ``self.pad_token`` and ``self.pad_token_id``\n\n        - ``cls_token``: (`Optional`) string: a classification token (e.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model). Will be associated to ``self.cls_token`` and ``self.cls_token_id``\n\n        - ``mask_token``: (`Optional`) string: a masking token (e.g. when training a model with masked-language modeling). Will be associated to ``self.mask_token`` and ``self.mask_token_id``\n\n        - ``additional_special_tokens``: (`Optional`) list: a list of additional special tokens. Adding all special tokens here ensure they won\'t be split by the tokenization process. Will be associated to ``self.additional_special_tokens`` and ``self.additional_special_tokens_ids``\n    """"""\n    vocab_files_names = {}\n    pretrained_vocab_files_map = {}\n    pretrained_init_configuration = {}\n    max_model_input_sizes = {}\n\n    SPECIAL_TOKENS_ATTRIBUTES = [""bos_token"", ""eos_token"", ""unk_token"", ""sep_token"",\n                                 ""pad_token"", ""cls_token"", ""mask_token"",\n                                 ""additional_special_tokens""]\n\n    @property\n    def bos_token(self):\n        """""" Beginning of sentence token (string). Log an error if used while not having been set. """"""\n        if self._bos_token is None:\n            logger.error(""Using bos_token, but it is not set yet."")\n        return self._bos_token\n\n    @property\n    def eos_token(self):\n        """""" End of sentence token (string). Log an error if used while not having been set. """"""\n        if self._eos_token is None:\n            logger.error(""Using eos_token, but it is not set yet."")\n        return self._eos_token\n\n    @property\n    def unk_token(self):\n        """""" Unknown token (string). Log an error if used while not having been set. """"""\n        if self._unk_token is None:\n            logger.error(""Using unk_token, but it is not set yet."")\n        return self._unk_token\n\n    @property\n    def sep_token(self):\n        """""" Separation token (string). E.g. separate context and query in an input sequence. Log an error if used while not having been set. """"""\n        if self._sep_token is None:\n            logger.error(""Using sep_token, but it is not set yet."")\n        return self._sep_token\n\n    @property\n    def pad_token(self):\n        """""" Padding token (string). Log an error if used while not having been set. """"""\n        if self._pad_token is None:\n            logger.error(""Using pad_token, but it is not set yet."")\n        return self._pad_token\n\n    @property\n    def cls_token(self):\n        """""" Classification token (string). E.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model. Log an error if used while not having been set. """"""\n        if self._cls_token is None:\n            logger.error(""Using cls_token, but it is not set yet."")\n        return self._cls_token\n\n    @property\n    def mask_token(self):\n        """""" Mask token (string). E.g. when training a model with masked-language modeling. Log an error if used while not having been set. """"""\n        if self._mask_token is None:\n            logger.error(""Using mask_token, but it is not set yet."")\n        return self._mask_token\n\n    @property\n    def additional_special_tokens(self):\n        """""" All the additional special tokens you may want to use (list of strings). Log an error if used while not having been set. """"""\n        if self._additional_special_tokens is None:\n            logger.error(""Using additional_special_tokens, but it is not set yet."")\n        return self._additional_special_tokens\n\n    @bos_token.setter\n    def bos_token(self, value):\n        self._bos_token = value\n\n    @eos_token.setter\n    def eos_token(self, value):\n        self._eos_token = value\n\n    @unk_token.setter\n    def unk_token(self, value):\n        self._unk_token = value\n\n    @sep_token.setter\n    def sep_token(self, value):\n        self._sep_token = value\n\n    @pad_token.setter\n    def pad_token(self, value):\n        self._pad_token = value\n\n    @cls_token.setter\n    def cls_token(self, value):\n        self._cls_token = value\n\n    @mask_token.setter\n    def mask_token(self, value):\n        self._mask_token = value\n\n    @additional_special_tokens.setter\n    def additional_special_tokens(self, value):\n        self._additional_special_tokens = value\n\n    @property\n    def bos_token_id(self):\n        """""" Id of the beginning of sentence token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.bos_token)\n\n    @property\n    def eos_token_id(self):\n        """""" Id of the end of sentence token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.eos_token)\n\n    @property\n    def unk_token_id(self):\n        """""" Id of the unknown token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.unk_token)\n\n    @property\n    def sep_token_id(self):\n        """""" Id of the separation token in the vocabulary. E.g. separate context and query in an input sequence. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.sep_token)\n\n    @property\n    def pad_token_id(self):\n        """""" Id of the padding token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.pad_token)\n\n    @property\n    def cls_token_id(self):\n        """""" Id of the classification token in the vocabulary. E.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.cls_token)\n\n    @property\n    def mask_token_id(self):\n        """""" Id of the mask token in the vocabulary. E.g. when training a model with masked-language modeling. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.mask_token)\n\n    @property\n    def additional_special_tokens_ids(self):\n        """""" Ids of all the additional special tokens in the vocabulary (list of integers). Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.additional_special_tokens)\n\n    def __init__(self, max_len=None, **kwargs):\n        self._bos_token = None\n        self._eos_token = None\n        self._unk_token = None\n        self._sep_token = None\n        self._pad_token = None\n        self._cls_token = None\n        self._mask_token = None\n        self._additional_special_tokens = []\n\n        self.max_len = max_len if max_len is not None else int(1e12)\n\n        # Added tokens\n        self.added_tokens_encoder = {}\n        self.added_tokens_decoder = {}\n\n        # inputs and kwargs for saving and re-loading (see ``from_pretrained`` and ``save_pretrained``)\n        self.init_inputs = ()\n        self.init_kwargs = {}\n\n        for key, value in kwargs.items():\n            if key in self.SPECIAL_TOKENS_ATTRIBUTES:\n                if key == \'additional_special_tokens\':\n                    assert isinstance(value, (list, tuple)) and all(isinstance(t, str) or (six.PY2 and isinstance(t, unicode)) for t in value)\n                else:\n                    assert isinstance(value, str) or (six.PY2 and isinstance(value, unicode))\n                setattr(self, key, value)\n\n\n    @classmethod\n    def from_pretrained(cls, *inputs, **kwargs):\n        r""""""\n        Instantiate a :class:`~transformers.PreTrainedTokenizer` (or a derived class) from a predefined tokenizer.\n\n        Args:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a predefined tokenizer to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing vocabulary files required by the tokenizer, for instance saved using the :func:`~transformers.PreTrainedTokenizer.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - (not applicable to all derived classes) a path or url to a single saved vocabulary file if and only if the tokenizer only requires a single vocabulary file (e.g. Bert, XLNet), e.g.: ``./my_model_directory/vocab.txt``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded predefined tokenizer vocabulary files should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the vocabulary files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            inputs: (`optional`) positional arguments: will be passed to the Tokenizer ``__init__`` method.\n\n            kwargs: (`optional`) keyword arguments: will be passed to the Tokenizer ``__init__`` method. Can be used to set special tokens like ``bos_token``, ``eos_token``, ``unk_token``, ``sep_token``, ``pad_token``, ``cls_token``, ``mask_token``, ``additional_special_tokens``. See parameters in the doc string of :class:`~transformers.PreTrainedTokenizer` for details.\n\n        Examples::\n\n            # We can\'t instantiate directly the base class `PreTrainedTokenizer` so let\'s show our examples on a derived class: BertTokenizer\n\n            # Download vocabulary from S3 and cache.\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n\n            # If vocabulary files are in a directory (e.g. tokenizer was saved using `save_pretrained(\'./test/saved_model/\')`)\n            tokenizer = BertTokenizer.from_pretrained(\'./test/saved_model/\')\n\n            # If the tokenizer uses a single vocabulary file, you can point directly to this file\n            tokenizer = BertTokenizer.from_pretrained(\'./test/saved_model/my_vocab.txt\')\n\n            # You can link tokens to special vocabulary when instantiating\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\', unk_token=\'<unk>\')\n            # You should be sure \'<unk>\' is in the vocabulary when doing that.\n            # Otherwise use tokenizer.add_special_tokens({\'unk_token\': \'<unk>\'}) instead)\n            assert tokenizer.unk_token == \'<unk>\'\n\n        """"""\n        return cls._from_pretrained(*inputs, **kwargs)\n\n\n    @classmethod\n    def _from_pretrained(cls, pretrained_model_name_or_path, *init_inputs, **kwargs):\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        force_download = kwargs.pop(\'force_download\', False)\n        proxies = kwargs.pop(\'proxies\', None)\n\n        s3_models = list(cls.max_model_input_sizes.keys())\n        vocab_files = {}\n        init_configuration = {}\n        if pretrained_model_name_or_path in s3_models:\n            # Get the vocabulary from AWS S3 bucket\n            for file_id, map_list in cls.pretrained_vocab_files_map.items():\n                vocab_files[file_id] = map_list[pretrained_model_name_or_path]\n            if cls.pretrained_init_configuration and pretrained_model_name_or_path in cls.pretrained_init_configuration:\n                init_configuration = cls.pretrained_init_configuration[pretrained_model_name_or_path]\n        else:\n            # Get the vocabulary from local files\n            logger.info(\n                ""Model name \'{}\' not found in model shortcut name list ({}). ""\n                ""Assuming \'{}\' is a path or url to a directory containing tokenizer files."".format(\n                    pretrained_model_name_or_path, \', \'.join(s3_models),\n                    pretrained_model_name_or_path))\n\n            # Look for the tokenizer main vocabulary files\n            for file_id, file_name in cls.vocab_files_names.items():\n                if os.path.isdir(pretrained_model_name_or_path):\n                    # If a directory is provided we look for the standard filenames\n                    full_file_name = os.path.join(pretrained_model_name_or_path, file_name)\n                else:\n                    # If a path to a file is provided we use it (will only work for non-BPE tokenizer using a single vocabulary file)\n                    full_file_name = pretrained_model_name_or_path\n                if not os.path.exists(full_file_name):\n                    logger.info(""Didn\'t find file {}. We won\'t load it."".format(full_file_name))\n                    full_file_name = None\n                vocab_files[file_id] = full_file_name\n\n            # Look for the additional tokens files\n            additional_files_names = {\'added_tokens_file\': ADDED_TOKENS_FILE,\n                                      \'special_tokens_map_file\': SPECIAL_TOKENS_MAP_FILE,\n                                      \'tokenizer_config_file\': TOKENIZER_CONFIG_FILE,\n                                      }\n\n            # If a path to a file was provided, get the parent directory\n            saved_directory = pretrained_model_name_or_path\n            if os.path.exists(saved_directory) and not os.path.isdir(saved_directory):\n                saved_directory = os.path.dirname(saved_directory)\n\n            for file_id, file_name in additional_files_names.items():\n                full_file_name = os.path.join(saved_directory, file_name)\n                if not os.path.exists(full_file_name):\n                    logger.info(""Didn\'t find file {}. We won\'t load it."".format(full_file_name))\n                    full_file_name = None\n                vocab_files[file_id] = full_file_name\n\n            if all(full_file_name is None for full_file_name in vocab_files.values()):\n                raise EnvironmentError(\n                    ""Model name \'{}\' was not found in tokenizers model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url to a directory containing vocabulary files ""\n                    ""named {} but couldn\'t find such vocabulary files at this path or url."".format(\n                        pretrained_model_name_or_path, \', \'.join(s3_models),\n                        pretrained_model_name_or_path, \n                        list(cls.vocab_files_names.values())))\n\n        # Get files from url, cache, or disk depending on the case\n        try:\n            resolved_vocab_files = {}\n            for file_id, file_path in vocab_files.items():\n                if file_path is None:\n                    resolved_vocab_files[file_id] = None\n                else:\n                    resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n        except EnvironmentError:\n            if pretrained_model_name_or_path in s3_models:\n                msg = ""Couldn\'t reach server at \'{}\' to download vocabulary files.""\n            else:\n                msg = ""Model name \'{}\' was not found in tokenizers model name list ({}). "" \\\n                    ""We assumed \'{}\' was a path or url to a directory containing vocabulary files "" \\\n                    ""named {}, but couldn\'t find such vocabulary files at this path or url."".format(\n                        pretrained_model_name_or_path, \', \'.join(s3_models),\n                        pretrained_model_name_or_path,\n                        list(cls.vocab_files_names.values()))\n\n            raise EnvironmentError(msg)\n\n        for file_id, file_path in vocab_files.items():\n            if file_path == resolved_vocab_files[file_id]:\n                logger.info(""loading file {}"".format(file_path))\n            else:\n                logger.info(""loading file {} from cache at {}"".format(\n                    file_path, resolved_vocab_files[file_id]))\n\n        # Prepare tokenizer initialization kwargs\n        # Did we saved some inputs and kwargs to reload ?\n        tokenizer_config_file = resolved_vocab_files.pop(\'tokenizer_config_file\', None)\n        if tokenizer_config_file is not None:\n            init_kwargs = json.load(open(tokenizer_config_file, encoding=""utf-8""))\n            saved_init_inputs = init_kwargs.pop(\'init_inputs\', ())\n            if not init_inputs:\n                init_inputs = saved_init_inputs\n        else:\n            init_kwargs = init_configuration\n\n        # Update with newly provided kwargs\n        init_kwargs.update(kwargs)\n\n        # Set max length if needed\n        if pretrained_model_name_or_path in cls.max_model_input_sizes:\n            # if we\'re using a pretrained model, ensure the tokenizer\n            # wont index sequences longer than the number of positional embeddings\n            max_len = cls.max_model_input_sizes[pretrained_model_name_or_path]\n            if max_len is not None and isinstance(max_len, (int, float)):\n                init_kwargs[\'max_len\'] = min(init_kwargs.get(\'max_len\', int(1e12)), max_len)\n\n        # Merge resolved_vocab_files arguments in init_kwargs.\n        added_tokens_file = resolved_vocab_files.pop(\'added_tokens_file\', None)\n        special_tokens_map_file = resolved_vocab_files.pop(\'special_tokens_map_file\', None)\n        for args_name, file_path in resolved_vocab_files.items():\n            if args_name not in init_kwargs:\n                init_kwargs[args_name] = file_path\n        if special_tokens_map_file is not None:\n            special_tokens_map = json.load(open(special_tokens_map_file, encoding=""utf-8""))\n            for key, value in special_tokens_map.items():\n                if key not in init_kwargs:\n                    init_kwargs[key] = value\n\n        # Instantiate tokenizer.\n        tokenizer = cls(*init_inputs, **init_kwargs)\n\n        # Save inputs and kwargs for saving and re-loading with ``save_pretrained``\n        tokenizer.init_inputs = init_inputs\n        tokenizer.init_kwargs = init_kwargs\n\n        # Add supplementary tokens.\n        if added_tokens_file is not None:\n            added_tok_encoder = json.load(open(added_tokens_file, encoding=""utf-8""))\n            added_tok_decoder = {v:k for k, v in added_tok_encoder.items()}\n            tokenizer.added_tokens_encoder.update(added_tok_encoder)\n            tokenizer.added_tokens_decoder.update(added_tok_decoder)\n\n        return tokenizer\n\n\n    def save_pretrained(self, save_directory):\n        """""" Save the tokenizer vocabulary files together with:\n                - added tokens,\n                - special-tokens-to-class-attributes-mapping,\n                - tokenizer instantiation positional and keywords inputs (e.g. do_lower_case for Bert).\n\n            This won\'t save modifications other than (added tokens and special token mapping) you may have\n            applied to the tokenizer after the instantiation (e.g. modifying tokenizer.do_lower_case after creation).\n\n            This method make sure the full tokenizer can then be re-loaded using the :func:`~transformers.PreTrainedTokenizer.from_pretrained` class method.\n        """"""\n        if not os.path.isdir(save_directory):\n            logger.error(""Saving directory ({}) should be a directory"".format(save_directory))\n            return\n\n        special_tokens_map_file = os.path.join(save_directory, SPECIAL_TOKENS_MAP_FILE)\n        added_tokens_file = os.path.join(save_directory, ADDED_TOKENS_FILE)\n        tokenizer_config_file = os.path.join(save_directory, TOKENIZER_CONFIG_FILE)\n\n        tokenizer_config = copy.deepcopy(self.init_kwargs)\n        tokenizer_config[\'init_inputs\'] = copy.deepcopy(self.init_inputs)\n        for file_id in self.vocab_files_names.keys():\n            tokenizer_config.pop(file_id, None)\n\n        with open(tokenizer_config_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(tokenizer_config, ensure_ascii=False))\n\n        with open(special_tokens_map_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.special_tokens_map, ensure_ascii=False))\n\n        with open(added_tokens_file, \'w\', encoding=\'utf-8\') as f:\n            if self.added_tokens_encoder:\n                out_str = json.dumps(self.added_tokens_encoder, ensure_ascii=False)\n            else:\n                out_str = u""{}""\n            f.write(out_str)\n\n        vocab_files = self.save_vocabulary(save_directory)\n\n        return vocab_files + (special_tokens_map_file, added_tokens_file)\n\n\n    def save_vocabulary(self, save_directory):\n        """""" Save the tokenizer vocabulary to a directory. This method does *NOT* save added tokens\n            and special token mappings.\n\n            Please use :func:`~transformers.PreTrainedTokenizer.save_pretrained` `()` to save the full Tokenizer state if you want to reload it using the :func:`~transformers.PreTrainedTokenizer.from_pretrained` class method.\n        """"""\n        raise NotImplementedError\n\n\n    def vocab_size(self):\n        """""" Size of the base vocabulary (without the added tokens) """"""\n        raise NotImplementedError\n\n\n    def __len__(self):\n        """""" Size of the full vocabulary with the added tokens """"""\n        return self.vocab_size + len(self.added_tokens_encoder)\n\n\n    def add_tokens(self, new_tokens):\n        """"""\n        Add a list of new tokens to the tokenizer class. If the new tokens are not in the\n        vocabulary, they are added to it with indices starting from length of the current vocabulary.\n\n        Args:\n            new_tokens: list of string. Each string is a token to add. Tokens are only added if they are not already in the vocabulary (tested by checking if the tokenizer assign the index of the ``unk_token`` to them).\n\n        Returns:\n            Number of tokens added to the vocabulary.\n\n        Examples::\n\n            # Let\'s see how to increase the vocabulary of Bert model and tokenizer\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n            model = BertModel.from_pretrained(\'bert-base-uncased\')\n\n            num_added_toks = tokenizer.add_tokens([\'new_tok1\', \'my_new-tok2\'])\n            print(\'We have added\', num_added_toks, \'tokens\')\n            model.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.\n        """"""\n        if not new_tokens:\n            return 0\n\n        to_add_tokens = []\n        for token in new_tokens:\n            assert isinstance(token, str) or (six.PY2 and isinstance(token, unicode))\n            if token != self.unk_token and \\\n                    self.convert_tokens_to_ids(token) == self.convert_tokens_to_ids(self.unk_token) and \\\n                    token not in to_add_tokens:\n                to_add_tokens.append(token)\n                logger.info(""Adding %s to the vocabulary"", token)\n\n        added_tok_encoder = dict((tok, len(self) + i) for i, tok in enumerate(to_add_tokens))\n        added_tok_decoder = {v:k for k, v in added_tok_encoder.items()}\n        self.added_tokens_encoder.update(added_tok_encoder)\n        self.added_tokens_decoder.update(added_tok_decoder)\n\n        return len(to_add_tokens)\n\n    def num_added_tokens(self, pair=False):\n        """"""\n        Returns the number of added tokens when encoding a sequence with special tokens.\n\n        Note:\n            This encodes inputs and checks the number of added tokens, and is therefore not efficient. Do not put this\n            inside your training loop.\n\n        Args:\n            pair: Returns the number of added tokens in the case of a sequence pair if set to True, returns the\n                number of added tokens in the case of a single sequence if set to False.\n\n        Returns:\n            Number of tokens added to sequences\n        """"""\n        token_ids_0 = []\n        token_ids_1 = []\n        return len(self.build_inputs_with_special_tokens(token_ids_0, token_ids_1 if pair else None))\n\n    def add_special_tokens(self, special_tokens_dict):\n        """"""\n        Add a dictionary of special tokens (eos, pad, cls...) to the encoder and link them\n        to class attributes. If special tokens are NOT in the vocabulary, they are added\n        to it (indexed starting from the last index of the current vocabulary).\n\n        Using `add_special_tokens` will ensure your special tokens can be used in several ways:\n\n        - special tokens are carefully handled by the tokenizer (they are never split)\n        - you can easily refer to special tokens using tokenizer class attributes like `tokenizer.cls_token`. This makes it easy to develop model-agnostic training and fine-tuning scripts.\n\n        When possible, special tokens are already registered for provided pretrained models (ex: BertTokenizer cls_token is already registered to be \'[CLS]\' and XLM\'s one is also registered to be \'</s>\')\n\n        Args:\n            special_tokens_dict: dict of string. Keys should be in the list of predefined special attributes:\n                [``bos_token``, ``eos_token``, ``unk_token``, ``sep_token``, ``pad_token``, ``cls_token``, ``mask_token``,\n                ``additional_special_tokens``].\n\n                Tokens are only added if they are not already in the vocabulary (tested by checking if the tokenizer assign the index of the ``unk_token`` to them).\n\n        Returns:\n            Number of tokens added to the vocabulary.\n\n        Examples::\n\n            # Let\'s see how to add a new classification token to GPT-2\n            tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n            model = GPT2Model.from_pretrained(\'gpt2\')\n\n            special_tokens_dict = {\'cls_token\': \'<CLS>\'}\n\n            num_added_toks = tokenizer.add_special_tokens(special_tokens_dict)\n            print(\'We have added\', num_added_toks, \'tokens\')\n            model.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.\n\n            assert tokenizer.cls_token == \'<CLS>\'\n        """"""\n        if not special_tokens_dict:\n            return 0\n\n        added_tokens = 0\n        for key, value in special_tokens_dict.items():\n            assert key in self.SPECIAL_TOKENS_ATTRIBUTES\n            if key == \'additional_special_tokens\':\n                assert isinstance(value, (list, tuple)) and all(isinstance(t, str) or (six.PY2 and isinstance(t, unicode)) for t in value)\n                added_tokens += self.add_tokens(value)\n            else:\n                assert isinstance(value, str) or (six.PY2 and isinstance(value, unicode))\n                added_tokens += self.add_tokens([value])\n            logger.info(""Assigning %s to the %s key of the tokenizer"", value, key)\n            setattr(self, key, value)\n\n        return added_tokens\n\n    def tokenize(self, text, **kwargs):\n        """""" Converts a string in a sequence of tokens (string), using the tokenizer.\n            Split in words for word-based vocabulary or sub-words for sub-word-based\n            vocabularies (BPE/SentencePieces/WordPieces).\n\n            Take care of added tokens.\n        """"""\n        def split_on_token(tok, text):\n            result = []\n            split_text = text.split(tok)\n            for i, sub_text in enumerate(split_text):\n                sub_text = sub_text.strip()\n                if i == 0 and not sub_text:\n                    result += [tok]\n                elif i == len(split_text) - 1:\n                    if sub_text:\n                        result += [sub_text]\n                    else:\n                        pass\n                else:\n                    if sub_text:\n                        result += [sub_text]\n                    result += [tok]\n            return result\n\n        def split_on_tokens(tok_list, text):\n            if not text:\n                return []\n            if not tok_list:\n                return self._tokenize(text, **kwargs)\n\n            tokenized_text = []\n            text_list = [text]\n            for tok in tok_list:\n                tokenized_text = []\n                for sub_text in text_list:\n                    if sub_text not in self.added_tokens_encoder \\\n                            and sub_text not in self.all_special_tokens:\n                        tokenized_text += split_on_token(tok, sub_text)\n                    else:\n                        tokenized_text += [sub_text]\n                text_list = tokenized_text\n\n            return sum((self._tokenize(token, **kwargs) if token not \\\n                    in self.added_tokens_encoder and token not in self.all_special_tokens \\\n                    else [token] for token in tokenized_text), [])\n\n        added_tokens = list(self.added_tokens_encoder.keys()) + self.all_special_tokens\n        tokenized_text = split_on_tokens(added_tokens, text)\n        return tokenized_text\n\n    def _tokenize(self, text, **kwargs):\n        """""" Converts a string in a sequence of tokens (string), using the tokenizer.\n            Split in words for word-based vocabulary or sub-words for sub-word-based\n            vocabularies (BPE/SentencePieces/WordPieces).\n\n            Do NOT take care of added tokens.\n        """"""\n        raise NotImplementedError\n\n    def convert_tokens_to_ids(self, tokens):\n        """""" Converts a single token, or a sequence of tokens, (str/unicode) in a single integer id\n            (resp. a sequence of ids), using the vocabulary.\n        """"""\n        if tokens is None:\n            return None\n\n        if isinstance(tokens, str) or (six.PY2 and isinstance(tokens, unicode)):\n            return self._convert_token_to_id_with_added_voc(tokens)\n\n        ids = []\n        for token in tokens:\n            ids.append(self._convert_token_to_id_with_added_voc(token))\n        if len(ids) > self.max_len:\n            logger.warning(""Token indices sequence length is longer than the specified maximum sequence length ""\n                           ""for this model ({} > {}). Running this sequence through the model will result in ""\n                           ""indexing errors"".format(len(ids), self.max_len))\n        return ids\n\n    def _convert_token_to_id_with_added_voc(self, token):\n        if token is None:\n            return None\n\n        if token in self.added_tokens_encoder:\n            return self.added_tokens_encoder[token]\n        return self._convert_token_to_id(token)\n\n    def _convert_token_to_id(self, token):\n        raise NotImplementedError\n\n    def encode(self,\n                text,\n                text_pair=None,\n                add_special_tokens=False,\n                max_length=None,\n                stride=0,\n                truncation_strategy=\'longest_first\',\n                return_tensors=None,\n                **kwargs):\n        """"""\n        Converts a string in a sequence of ids (integer), using the tokenizer and vocabulary.\n\n        Same as doing ``self.convert_tokens_to_ids(self.tokenize(text))``.\n\n        Args:\n            text: The first sequence to be encoded. This can be a string, a list of strings (tokenized string using\n                the `tokenize` method) or a list of integers (tokenized string ids using the `convert_tokens_to_ids`\n                method)\n            text_pair: Optional second sequence to be encoded. This can be a string, a list of strings (tokenized\n                string using the `tokenize` method) or a list of integers (tokenized string ids using the\n                `convert_tokens_to_ids` method)\n            add_special_tokens: if set to ``True``, the sequences will be encoded with the special tokens relative\n                to their model.\n            max_length: if set to a number, will limit the total sequence returned so that it has a maximum length.\n                If there are overflowing tokens, those will be added to the returned dictionary\n            stride: if set to a number along with max_length, the overflowing tokens returned will contain some tokens\n                from the main sequence returned. The value of this argument defines the number of additional tokens.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences)\n                - \'only_first\': Only truncate the first sequence\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n            return_tensors: (optional) can be set to \'tf\' or \'pt\' to return respectively TensorFlow tf.constant\n                or PyTorch torch.Tensor instead of a list of python integers.\n            **kwargs: passed to the `self.tokenize()` method\n        """"""\n        encoded_inputs = self.encode_plus(text,\n                                          text_pair=text_pair,\n                                          max_length=max_length,\n                                          add_special_tokens=add_special_tokens,\n                                          stride=stride,\n                                          truncation_strategy=truncation_strategy,\n                                          return_tensors=return_tensors,\n                                          **kwargs)\n\n        return encoded_inputs[""input_ids""]\n\n    def encode_plus(self,\n                    text,\n                    text_pair=None,\n                    add_special_tokens=False,\n                    max_length=None,\n                    stride=0,\n                    truncation_strategy=\'longest_first\',\n                    return_tensors=None,\n                    **kwargs):\n        """"""\n        Returns a dictionary containing the encoded sequence or sequence pair and additional informations:\n        the mask for sequence classification and the overflowing elements if a ``max_length`` is specified.\n\n        Args:\n            text: The first sequence to be encoded. This can be a string, a list of strings (tokenized string using\n                the `tokenize` method) or a list of integers (tokenized string ids using the `convert_tokens_to_ids`\n                method)\n            text_pair: Optional second sequence to be encoded. This can be a string, a list of strings (tokenized\n                string using the `tokenize` method) or a list of integers (tokenized string ids using the\n                `convert_tokens_to_ids` method)\n            add_special_tokens: if set to ``True``, the sequences will be encoded with the special tokens relative\n                to their model.\n            max_length: if set to a number, will limit the total sequence returned so that it has a maximum length.\n                If there are overflowing tokens, those will be added to the returned dictionary\n            stride: if set to a number along with max_length, the overflowing tokens returned will contain some tokens\n                from the main sequence returned. The value of this argument defines the number of additional tokens.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences)\n                - \'only_first\': Only truncate the first sequence\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n            return_tensors: (optional) can be set to \'tf\' or \'pt\' to return respectively TensorFlow tf.constant\n                or PyTorch torch.Tensor instead of a list of python integers.\n            **kwargs: passed to the `self.tokenize()` method\n        """"""\n\n        def get_input_ids(text):\n            if isinstance(text, six.string_types):\n                return self.convert_tokens_to_ids(self.tokenize(text, **kwargs))\n            elif isinstance(text, (list, tuple)) and len(text) > 0 and isinstance(text[0], six.string_types):\n                return self.convert_tokens_to_ids(text)\n            elif isinstance(text, (list, tuple)) and len(text) > 0 and isinstance(text[0], int):\n                return text\n            else:\n                raise ValueError(""Input is not valid. Should be a string, a list/tuple of strings or a list/tuple of integers."")\n\n        first_ids = get_input_ids(text)\n        second_ids = get_input_ids(text_pair) if text_pair is not None else None\n\n        return self.prepare_for_model(first_ids,\n                                      pair_ids=second_ids,\n                                      max_length=max_length,\n                                      add_special_tokens=add_special_tokens,\n                                      stride=stride,\n                                      truncation_strategy=truncation_strategy,\n                                      return_tensors=return_tensors)\n\n    def prepare_for_model(self, ids, pair_ids=None, max_length=None, add_special_tokens=False, stride=0,\n                          truncation_strategy=\'longest_first\', return_tensors=None):\n        """"""\n        Prepares a sequence of input id, or a pair of sequences of inputs ids so that it can be used by the model.\n        It adds special tokens, truncates\n        sequences if overflowing while taking into account the special tokens and manages a window stride for\n        overflowing tokens\n\n        Args:\n            ids: list of tokenized input ids. Can be obtained from a string by chaining the\n                `tokenize` and `convert_tokens_to_ids` methods.\n            pair_ids: Optional second list of input ids. Can be obtained from a string by chaining the\n                `tokenize` and `convert_tokens_to_ids` methods.\n            max_length: maximum length of the returned list. Will truncate by taking into account the special tokens.\n            add_special_tokens: if set to ``True``, the sequences will be encoded with the special tokens relative\n                to their model.\n            stride: window stride for overflowing tokens. Can be useful for edge effect removal when using sequential\n                list of inputs.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences)\n                - \'only_first\': Only truncate the first sequence\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n            return_tensors: (optional) can be set to \'tf\' or \'pt\' to return respectively TensorFlow tf.constant\n                or PyTorch torch.Tensor instead of a list of python integers.\n\n        Return:\n            A Dictionary of shape::\n\n                {\n                    input_ids: list[int],\n                    overflowing_tokens: list[int] if a ``max_length`` is specified, else None\n                    special_tokens_mask: list[int] if ``add_special_tokens`` if set to ``True``\n                }\n\n            With the fields:\n                ``input_ids``: list of tokens to be fed to a model\n\n                ``overflowing_tokens``: list of overflowing tokens if a max length is specified.\n\n                ``special_tokens_mask``: if adding special tokens, this is a list of [0, 1], with 0 specifying special added\n                tokens and 1 specifying sequence tokens.\n        """"""\n        pair = bool(pair_ids is not None)\n        len_ids = len(ids)\n        len_pair_ids = len(pair_ids) if pair else 0\n\n        encoded_inputs = {}\n        total_len = len_ids + len_pair_ids + (self.num_added_tokens(pair=pair) if add_special_tokens else 0)\n        if max_length and total_len > max_length:\n            ids, pair_ids, overflowing_tokens = self.truncate_sequences(ids, pair_ids=pair_ids,\n                                                                        num_tokens_to_remove=total_len-max_length,\n                                                                        truncation_strategy=truncation_strategy,\n                                                                        stride=stride)\n            encoded_inputs[""overflowing_tokens""] = overflowing_tokens\n            encoded_inputs[""num_truncated_tokens""] = total_len - max_length\n\n        if add_special_tokens:\n            sequence = self.build_inputs_with_special_tokens(ids, pair_ids)\n            token_type_ids = self.create_token_type_ids_from_sequences(ids, pair_ids)\n            encoded_inputs[""special_tokens_mask""] = self.get_special_tokens_mask(ids, pair_ids)\n        else:\n            sequence = ids + pair_ids if pair else ids\n            token_type_ids = [0] * len(ids) + ([1] * len(pair_ids) if pair else [])\n\n        if return_tensors == \'tf\' and is_tf_available():\n            sequence = tf.constant([sequence])\n            token_type_ids = tf.constant([token_type_ids])\n        elif return_tensors == \'pt\' and is_torch_available():\n            sequence = torch.tensor([sequence])\n            token_type_ids = torch.tensor([token_type_ids])\n        elif return_tensors is not None:\n            logger.warning(""Unable to convert output to tensors format {}, PyTorch or TensorFlow is not available."".format(return_tensors))\n\n        encoded_inputs[""input_ids""] = sequence\n        encoded_inputs[""token_type_ids""] = token_type_ids\n\n        if max_length and len(encoded_inputs[""input_ids""]) > max_length:\n            encoded_inputs[""input_ids""] = encoded_inputs[""input_ids""][:max_length]\n            encoded_inputs[""token_type_ids""] = encoded_inputs[""token_type_ids""][:max_length]\n            encoded_inputs[""special_tokens_mask""] = encoded_inputs[""special_tokens_mask""][:max_length]\n\n        return encoded_inputs\n\n    def truncate_sequences(self, ids, pair_ids=None, num_tokens_to_remove=0, truncation_strategy=\'longest_first\', stride=0):\n        """"""Truncates a sequence pair in place to the maximum length.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences).\n                    Overflowing tokens only contains overflow from the first sequence.\n                - \'only_first\': Only truncate the first sequence. raise an error if the first sequence is shorter or equal to than num_tokens_to_remove.\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n        """"""\n        if num_tokens_to_remove <= 0:\n            return ids, pair_ids, []\n\n        if truncation_strategy == \'longest_first\':\n            overflowing_tokens = []\n            for _ in range(num_tokens_to_remove):\n                if pair_ids is None or len(ids) > len(pair_ids):\n                    overflowing_tokens = [ids[-1]] + overflowing_tokens\n                    ids = ids[:-1]\n                else:\n                    pair_ids = pair_ids[:-1]\n            window_len = min(len(ids), stride)\n            if window_len > 0:\n                overflowing_tokens = ids[-window_len:] + overflowing_tokens\n        elif truncation_strategy == \'only_first\':\n            assert len(ids) > num_tokens_to_remove\n            window_len = min(len(ids), stride + num_tokens_to_remove)\n            overflowing_tokens = ids[-window_len:]\n            ids = ids[:-num_tokens_to_remove]\n        elif truncation_strategy == \'only_second\':\n            assert pair_ids is not None and len(pair_ids) > num_tokens_to_remove\n            window_len = min(len(pair_ids), stride + num_tokens_to_remove)\n            overflowing_tokens = pair_ids[-window_len:]\n            pair_ids = pair_ids[:-num_tokens_to_remove]\n        elif truncation_strategy == \'do_not_truncate\':\n            raise ValueError(""Input sequence are too long for max_length. Please select a truncation strategy."")\n        else:\n            raise ValueError(""Truncation_strategy should be selected in [\'longest_first\', \'only_first\', \'only_second\', \'do_not_truncate\']"")\n        return (ids, pair_ids, overflowing_tokens)\n\n    def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None):\n        logger.warning(""This tokenizer does not make use of special tokens."")\n        if token_ids_1 is None:\n            return len(token_ids_0) * [0]\n        return [0] * len(token_ids_0) + [1] * len(token_ids_1)\n\n    def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None):\n        """"""\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks\n        by concatenating and adding special tokens.\n        A RoBERTa sequence has the following format:\n            single sequence: <s> X </s>\n            pair of sequences: <s> A </s></s> B </s>\n        """"""\n        logger.warning(""This tokenizer does not make use of special tokens. Input is returned with no modification."")\n        if token_ids_1 is None:\n            return token_ids_0\n        return token_ids_0 + token_ids_1\n\n    def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False):\n        """"""\n        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer ``prepare_for_model`` or ``encode_plus`` methods.\n\n        Args:\n            token_ids_0: list of ids (must not contain special tokens)\n            token_ids_1: Optional list of ids (must not contain special tokens), necessary when fetching sequence ids\n                for sequence pairs\n            already_has_special_tokens: (default False) Set to True if the token list is already formated with\n                special tokens for the model\n\n        Returns:\n            A list of integers in the range [0, 1]: 0 for a special token, 1 for a sequence token.\n        """"""\n        return [0] * ((len(token_ids_1) if token_ids_1 else 0) + len(token_ids_0))\n\n    def convert_ids_to_tokens(self, ids, skip_special_tokens=False):\n        """""" Converts a single index or a sequence of indices (integers) in a token ""\n            (resp.) a sequence of tokens (str/unicode), using the vocabulary and added tokens.\n\n            Args:\n                skip_special_tokens: Don\'t decode special tokens (self.all_special_tokens). Default: False\n        """"""\n        if isinstance(ids, int):\n            if ids in self.added_tokens_decoder:\n                return self.added_tokens_decoder[ids]\n            else:\n                return self._convert_id_to_token(ids)\n        tokens = []\n        for index in ids:\n            if skip_special_tokens and index in self.all_special_ids:\n                continue\n            if index in self.added_tokens_decoder:\n                tokens.append(self.added_tokens_decoder[index])\n            else:\n                tokens.append(self._convert_id_to_token(index))\n        return tokens\n\n    def _convert_id_to_token(self, index):\n        raise NotImplementedError\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string.\n            The most simple way to do it is \' \'.join(self.convert_ids_to_tokens(token_ids))\n            but we often want to remove sub-word tokenization artifacts at the same time.\n        """"""\n        return \' \'.join(self.convert_ids_to_tokens(tokens))\n\n    def decode(self, token_ids, skip_special_tokens=False, clean_up_tokenization_spaces=True):\n        """"""\n        Converts a sequence of ids (integer) in a string, using the tokenizer and vocabulary\n        with options to remove special tokens and clean up tokenization spaces.\n        Similar to doing ``self.convert_tokens_to_string(self.convert_ids_to_tokens(token_ids))``.\n\n        Args:\n            token_ids: list of tokenized input ids. Can be obtained using the `encode` or `encode_plus` methods.\n            skip_special_tokens: if set to True, will replace special tokens.\n            clean_up_tokenization_spaces: if set to True, will clean up the tokenization spaces.\n        """"""\n        filtered_tokens = self.convert_ids_to_tokens(token_ids, skip_special_tokens=skip_special_tokens)\n\n        # To avoid mixing byte-level and unicode for byte-level BPT\n        # we need to build string separatly for added tokens and byte-level tokens\n        # cf. https://github.com/huggingface/transformers/issues/1133\n        sub_texts = []\n        current_sub_text = []\n        for token in filtered_tokens:\n            if skip_special_tokens and token in self.all_special_ids:\n                continue\n            if token in self.added_tokens_encoder:\n                if current_sub_text:\n                    sub_texts.append(self.convert_tokens_to_string(current_sub_text))\n                    current_sub_text = []\n                sub_texts.append("" "" + token)\n            else:\n                current_sub_text.append(token)\n        if current_sub_text:\n            sub_texts.append(self.convert_tokens_to_string(current_sub_text))\n        text = \'\'.join(sub_texts)\n\n        if clean_up_tokenization_spaces:\n            clean_text = self.clean_up_tokenization(text)\n            return clean_text\n        else:\n            return text\n\n    @property\n    def special_tokens_map(self):\n        """""" A dictionary mapping special token class attribute (cls_token, unk_token...) to their\n            values (\'<unk>\', \'<cls>\'...)\n        """"""\n        set_attr = {}\n        for attr in self.SPECIAL_TOKENS_ATTRIBUTES:\n            attr_value = getattr(self, ""_"" + attr)\n            if attr_value:\n                set_attr[attr] = attr_value\n        return set_attr\n\n    @property\n    def all_special_tokens(self):\n        """""" List all the special tokens (\'<unk>\', \'<cls>\'...) mapped to class attributes\n            (cls_token, unk_token...).\n        """"""\n        all_toks = []\n        set_attr = self.special_tokens_map\n        for attr_value in set_attr.values():\n            all_toks = all_toks + (list(attr_value) if isinstance(attr_value, (list, tuple)) else [attr_value])\n        all_toks = list(set(all_toks))\n        return all_toks\n\n    @property\n    def all_special_ids(self):\n        """""" List the vocabulary indices of the special tokens (\'<unk>\', \'<cls>\'...) mapped to\n            class attributes (cls_token, unk_token...).\n        """"""\n        all_toks = self.all_special_tokens\n        all_ids = list(self._convert_token_to_id(t) for t in all_toks)\n        return all_ids\n\n    @staticmethod\n    def clean_up_tokenization(out_string):\n        """""" Clean up a list of simple English tokenization artifacts like spaces before punctuations and abreviated forms.\n        """"""\n        out_string = out_string.replace(\' .\', \'.\').replace(\' ?\', \'?\').replace(\' !\', \'!\').replace(\' ,\', \',\'\n                        ).replace("" \' "", ""\'"").replace("" n\'t"", ""n\'t"").replace("" \'m"", ""\'m"").replace("" do not"", "" don\'t""\n                        ).replace("" \'s"", ""\'s"").replace("" \'ve"", ""\'ve"").replace("" \'re"", ""\'re"")\n        return out_string\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_xlm.py,0,"b'# coding=utf-8\n# Copyright 2019 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport json\nimport logging\nimport os\nimport re\nimport sys\nimport unicodedata\nfrom io import open\n\nimport sacremoses as sm\n\nfrom .tokenization_utils import PreTrainedTokenizer\nfrom .tokenization_bert import BasicTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-vocab.json"",\n        \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-vocab.json"",\n        \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-vocab.json"",\n        \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-vocab.json"",\n        \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-vocab.json"",\n        \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-vocab.json"",\n        \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-enfr-1024-vocab.json"",\n        \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-ende-1024-vocab.json"",\n        \'xlm-mlm-17-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-17-1280-vocab.json"",\n        \'xlm-mlm-100-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-100-1280-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-merges.txt"",\n        \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-merges.txt"",\n        \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-merges.txt"",\n        \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-merges.txt"",\n        \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-merges.txt"",\n        \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-merges.txt"",\n        \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-merges.txt"",\n        \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-merges.txt"",\n        \'xlm-mlm-17-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-17-1280-merges.txt"",\n        \'xlm-mlm-100-1280\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-100-1280-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'xlm-mlm-en-2048\': 512,\n    \'xlm-mlm-ende-1024\': 512,\n    \'xlm-mlm-enfr-1024\': 512,\n    \'xlm-mlm-enro-1024\': 512,\n    \'xlm-mlm-tlm-xnli15-1024\': 512,\n    \'xlm-mlm-xnli15-1024\': 512,\n    \'xlm-clm-enfr-1024\': 512,\n    \'xlm-clm-ende-1024\': 512,\n    \'xlm-mlm-17-1280\': 512,\n    \'xlm-mlm-100-1280\': 512,\n}\n\nPRETRAINED_INIT_CONFIGURATION = {\n    \'xlm-mlm-en-2048\': {""do_lowercase_and_remove_accent"": True},\n    \'xlm-mlm-ende-1024\': { ""do_lowercase_and_remove_accent"": True,\n                            ""id2lang"": { ""0"": ""de"",\n                                        ""1"": ""en""},\n                           ""lang2id"": { ""de"": 0,\n                                        ""en"": 1 }},\n    \'xlm-mlm-enfr-1024\': { ""do_lowercase_and_remove_accent"": True,\n                           ""id2lang"": { ""0"": ""en"",\n                                        ""1"": ""fr""},\n                           ""lang2id"": { ""en"": 0,\n                                        ""fr"": 1 }},\n    \'xlm-mlm-enro-1024\': { ""do_lowercase_and_remove_accent"": True,\n                           ""id2lang"": { ""0"": ""en"",\n                                        ""1"": ""ro""},\n                           ""lang2id"": { ""en"": 0,\n                                        ""ro"": 1 }},\n    \'xlm-mlm-tlm-xnli15-1024\': { ""do_lowercase_and_remove_accent"": True,\n                                 ""id2lang"": {   ""0"": ""ar"",\n                                                ""1"": ""bg"",\n                                                ""2"": ""de"",\n                                                ""3"": ""el"",\n                                                ""4"": ""en"",\n                                                ""5"": ""es"",\n                                                ""6"": ""fr"",\n                                                ""7"": ""hi"",\n                                                ""8"": ""ru"",\n                                                ""9"": ""sw"",\n                                                ""10"": ""th"",\n                                                ""11"": ""tr"",\n                                                ""12"": ""ur"",\n                                                ""13"": ""vi"",\n                                                ""14"": ""zh""},\n                                 ""lang2id"": {   ""ar"": 0,\n                                                ""bg"": 1,\n                                                ""de"": 2,\n                                                ""el"": 3,\n                                                ""en"": 4,\n                                                ""es"": 5,\n                                                ""fr"": 6,\n                                                ""hi"": 7,\n                                                ""ru"": 8,\n                                                ""sw"": 9,\n                                                ""th"": 10,\n                                                ""tr"": 11,\n                                                ""ur"": 12,\n                                                ""vi"": 13,\n                                                ""zh"": 14 }},\n    \'xlm-mlm-xnli15-1024\': { ""do_lowercase_and_remove_accent"": True,\n                             ""id2lang"": {   ""0"": ""ar"",\n                                                ""1"": ""bg"",\n                                                ""2"": ""de"",\n                                                ""3"": ""el"",\n                                                ""4"": ""en"",\n                                                ""5"": ""es"",\n                                                ""6"": ""fr"",\n                                                ""7"": ""hi"",\n                                                ""8"": ""ru"",\n                                                ""9"": ""sw"",\n                                                ""10"": ""th"",\n                                                ""11"": ""tr"",\n                                                ""12"": ""ur"",\n                                                ""13"": ""vi"",\n                                                ""14"": ""zh""},\n                                 ""lang2id"": {   ""ar"": 0,\n                                                ""bg"": 1,\n                                                ""de"": 2,\n                                                ""el"": 3,\n                                                ""en"": 4,\n                                                ""es"": 5,\n                                                ""fr"": 6,\n                                                ""hi"": 7,\n                                                ""ru"": 8,\n                                                ""sw"": 9,\n                                                ""th"": 10,\n                                                ""tr"": 11,\n                                                ""ur"": 12,\n                                                ""vi"": 13,\n                                                ""zh"": 14 }},\n    \'xlm-clm-enfr-1024\': { ""do_lowercase_and_remove_accent"": True,\n                           ""id2lang"": { ""0"": ""en"",\n                                        ""1"": ""fr""},\n                           ""lang2id"": { ""en"": 0,\n                                        ""fr"": 1 }},\n    \'xlm-clm-ende-1024\': { ""do_lowercase_and_remove_accent"": True,\n                           ""id2lang"": { ""0"": ""de"",\n                                        ""1"": ""en""},\n                           ""lang2id"": { ""de"": 0,\n                                        ""en"": 1 }},\n    \'xlm-mlm-17-1280\': {""do_lowercase_and_remove_accent"": False,\n                        ""id2lang"": {\n                            ""0"": ""ar"",\n                            ""1"": ""de"",\n                            ""2"": ""en"",\n                            ""3"": ""es"",\n                            ""4"": ""fr"",\n                            ""5"": ""hi"",\n                            ""6"": ""it"",\n                            ""7"": ""ja"",\n                            ""8"": ""ko"",\n                            ""9"": ""nl"",\n                            ""10"": ""pl"",\n                            ""11"": ""pt"",\n                            ""12"": ""ru"",\n                            ""13"": ""sv"",\n                            ""14"": ""tr"",\n                            ""15"": ""vi"",\n                            ""16"": ""zh""\n                        },\n                        ""lang2id"": {\n                            ""ar"": 0,\n                            ""de"": 1,\n                            ""en"": 2,\n                            ""es"": 3,\n                            ""fr"": 4,\n                            ""hi"": 5,\n                            ""it"": 6,\n                            ""ja"": 7,\n                            ""ko"": 8,\n                            ""nl"": 9,\n                            ""pl"": 10,\n                            ""pt"": 11,\n                            ""ru"": 12,\n                            ""sv"": 13,\n                            ""tr"": 14,\n                            ""vi"": 15,\n                            ""zh"": 16}},\n    \'xlm-mlm-100-1280\': {""do_lowercase_and_remove_accent"": False,\n                        ""id2lang"": {\n                            ""0"": ""af"",\n                            ""1"": ""als"",\n                            ""2"": ""am"",\n                            ""3"": ""an"",\n                            ""4"": ""ang"",\n                            ""5"": ""ar"",\n                            ""6"": ""arz"",\n                            ""7"": ""ast"",\n                            ""8"": ""az"",\n                            ""9"": ""bar"",\n                            ""10"": ""be"",\n                            ""11"": ""bg"",\n                            ""12"": ""bn"",\n                            ""13"": ""br"",\n                            ""14"": ""bs"",\n                            ""15"": ""ca"",\n                            ""16"": ""ceb"",\n                            ""17"": ""ckb"",\n                            ""18"": ""cs"",\n                            ""19"": ""cy"",\n                            ""20"": ""da"",\n                            ""21"": ""de"",\n                            ""22"": ""el"",\n                            ""23"": ""en"",\n                            ""24"": ""eo"",\n                            ""25"": ""es"",\n                            ""26"": ""et"",\n                            ""27"": ""eu"",\n                            ""28"": ""fa"",\n                            ""29"": ""fi"",\n                            ""30"": ""fr"",\n                            ""31"": ""fy"",\n                            ""32"": ""ga"",\n                            ""33"": ""gan"",\n                            ""34"": ""gl"",\n                            ""35"": ""gu"",\n                            ""36"": ""he"",\n                            ""37"": ""hi"",\n                            ""38"": ""hr"",\n                            ""39"": ""hu"",\n                            ""40"": ""hy"",\n                            ""41"": ""ia"",\n                            ""42"": ""id"",\n                            ""43"": ""is"",\n                            ""44"": ""it"",\n                            ""45"": ""ja"",\n                            ""46"": ""jv"",\n                            ""47"": ""ka"",\n                            ""48"": ""kk"",\n                            ""49"": ""kn"",\n                            ""50"": ""ko"",\n                            ""51"": ""ku"",\n                            ""52"": ""la"",\n                            ""53"": ""lb"",\n                            ""54"": ""lt"",\n                            ""55"": ""lv"",\n                            ""56"": ""mk"",\n                            ""57"": ""ml"",\n                            ""58"": ""mn"",\n                            ""59"": ""mr"",\n                            ""60"": ""ms"",\n                            ""61"": ""my"",\n                            ""62"": ""nds"",\n                            ""63"": ""ne"",\n                            ""64"": ""nl"",\n                            ""65"": ""nn"",\n                            ""66"": ""no"",\n                            ""67"": ""oc"",\n                            ""68"": ""pl"",\n                            ""69"": ""pt"",\n                            ""70"": ""ro"",\n                            ""71"": ""ru"",\n                            ""72"": ""scn"",\n                            ""73"": ""sco"",\n                            ""74"": ""sh"",\n                            ""75"": ""si"",\n                            ""76"": ""simple"",\n                            ""77"": ""sk"",\n                            ""78"": ""sl"",\n                            ""79"": ""sq"",\n                            ""80"": ""sr"",\n                            ""81"": ""sv"",\n                            ""82"": ""sw"",\n                            ""83"": ""ta"",\n                            ""84"": ""te"",\n                            ""85"": ""th"",\n                            ""86"": ""tl"",\n                            ""87"": ""tr"",\n                            ""88"": ""tt"",\n                            ""89"": ""uk"",\n                            ""90"": ""ur"",\n                            ""91"": ""uz"",\n                            ""92"": ""vi"",\n                            ""93"": ""war"",\n                            ""94"": ""wuu"",\n                            ""95"": ""yi"",\n                            ""96"": ""zh"",\n                            ""97"": ""zh_classical"",\n                            ""98"": ""zh_min_nan"",\n                            ""99"": ""zh_yue""\n                        },\n                        ""lang2id"": {\n                            ""af"": 0,\n                            ""als"": 1,\n                            ""am"": 2,\n                            ""an"": 3,\n                            ""ang"": 4,\n                            ""ar"": 5,\n                            ""arz"": 6,\n                            ""ast"": 7,\n                            ""az"": 8,\n                            ""bar"": 9,\n                            ""be"": 10,\n                            ""bg"": 11,\n                            ""bn"": 12,\n                            ""br"": 13,\n                            ""bs"": 14,\n                            ""ca"": 15,\n                            ""ceb"": 16,\n                            ""ckb"": 17,\n                            ""cs"": 18,\n                            ""cy"": 19,\n                            ""da"": 20,\n                            ""de"": 21,\n                            ""el"": 22,\n                            ""en"": 23,\n                            ""eo"": 24,\n                            ""es"": 25,\n                            ""et"": 26,\n                            ""eu"": 27,\n                            ""fa"": 28,\n                            ""fi"": 29,\n                            ""fr"": 30,\n                            ""fy"": 31,\n                            ""ga"": 32,\n                            ""gan"": 33,\n                            ""gl"": 34,\n                            ""gu"": 35,\n                            ""he"": 36,\n                            ""hi"": 37,\n                            ""hr"": 38,\n                            ""hu"": 39,\n                            ""hy"": 40,\n                            ""ia"": 41,\n                            ""id"": 42,\n                            ""is"": 43,\n                            ""it"": 44,\n                            ""ja"": 45,\n                            ""jv"": 46,\n                            ""ka"": 47,\n                            ""kk"": 48,\n                            ""kn"": 49,\n                            ""ko"": 50,\n                            ""ku"": 51,\n                            ""la"": 52,\n                            ""lb"": 53,\n                            ""lt"": 54,\n                            ""lv"": 55,\n                            ""mk"": 56,\n                            ""ml"": 57,\n                            ""mn"": 58,\n                            ""mr"": 59,\n                            ""ms"": 60,\n                            ""my"": 61,\n                            ""nds"": 62,\n                            ""ne"": 63,\n                            ""nl"": 64,\n                            ""nn"": 65,\n                            ""no"": 66,\n                            ""oc"": 67,\n                            ""pl"": 68,\n                            ""pt"": 69,\n                            ""ro"": 70,\n                            ""ru"": 71,\n                            ""scn"": 72,\n                            ""sco"": 73,\n                            ""sh"": 74,\n                            ""si"": 75,\n                            ""simple"": 76,\n                            ""sk"": 77,\n                            ""sl"": 78,\n                            ""sq"": 79,\n                            ""sr"": 80,\n                            ""sv"": 81,\n                            ""sw"": 82,\n                            ""ta"": 83,\n                            ""te"": 84,\n                            ""th"": 85,\n                            ""tl"": 86,\n                            ""tr"": 87,\n                            ""tt"": 88,\n                            ""uk"": 89,\n                            ""ur"": 90,\n                            ""uz"": 91,\n                            ""vi"": 92,\n                            ""war"": 93,\n                            ""wuu"": 94,\n                            ""yi"": 95,\n                            ""zh"": 96,\n                            ""zh_classical"": 97,\n                            ""zh_min_nan"": 98,\n                            ""zh_yue"": 99\n                        }},\n}\n\ndef get_pairs(word):\n    """"""\n    Return set of symbol pairs in a word.\n    word is represented as tuple of symbols (symbols being variable-length strings)\n    """"""\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n    return pairs\n\n\ndef lowercase_and_remove_accent(text):\n    """"""\n    Lowercase and strips accents from a piece of text based on\n    https://github.com/facebookresearch/XLM/blob/master/tools/lowercase_and_remove_accent.py\n    """"""\n    text = \' \'.join(text)\n    text = text.lower()\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n        cat = unicodedata.category(char)\n        if cat == ""Mn"":\n            continue\n        output.append(char)\n    return """".join(output).lower().split(\' \')\n\n\ndef replace_unicode_punct(text):\n    \'\'\'\n    Port of https://github.com/moses-smt/mosesdecoder/blob/master/scripts/tokenizer/replace-unicode-punctuation.perl\n    \'\'\'\n    text = text.replace(\'\xef\xbc\x8c\', \',\')\n    text = re.sub(r\'\xe3\x80\x82\\s*\', \'. \', text)\n    text = text.replace(\'\xe3\x80\x81\', \',\')\n    text = text.replace(\'\xe2\x80\x9d\', \'""\')\n    text = text.replace(\'\xe2\x80\x9c\', \'""\')\n    text = text.replace(\'\xe2\x88\xb6\', \':\')\n    text = text.replace(\'\xef\xbc\x9a\', \':\')\n    text = text.replace(\'\xef\xbc\x9f\', \'?\')\n    text = text.replace(\'\xe3\x80\x8a\', \'""\')\n    text = text.replace(\'\xe3\x80\x8b\', \'""\')\n    text = text.replace(\'\xef\xbc\x89\', \')\')\n    text = text.replace(\'\xef\xbc\x81\', \'!\')\n    text = text.replace(\'\xef\xbc\x88\', \'(\')\n    text = text.replace(\'\xef\xbc\x9b\', \';\')\n    text = text.replace(\'\xef\xbc\x91\', \'""\')\n    text = text.replace(\'\xe3\x80\x8d\', \'""\')\n    text = text.replace(\'\xe3\x80\x8c\', \'""\')\n    text = text.replace(\'\xef\xbc\x90\', \'0\')\n    text = text.replace(\'\xef\xbc\x93\', \'3\')\n    text = text.replace(\'\xef\xbc\x92\', \'2\')\n    text = text.replace(\'\xef\xbc\x95\', \'5\')\n    text = text.replace(\'\xef\xbc\x96\', \'6\')\n    text = text.replace(\'\xef\xbc\x99\', \'9\')\n    text = text.replace(\'\xef\xbc\x97\', \'7\')\n    text = text.replace(\'\xef\xbc\x98\', \'8\')\n    text = text.replace(\'\xef\xbc\x94\', \'4\')\n    text = re.sub(r\'\xef\xbc\x8e\\s*\', \'. \', text)\n    text = text.replace(\'\xef\xbd\x9e\', \'~\')\n    text = text.replace(\'\xe2\x80\x99\', \'\\\'\')\n    text = text.replace(\'\xe2\x80\xa6\', \'...\')\n    text = text.replace(\'\xe2\x94\x81\', \'-\')\n    text = text.replace(\'\xe3\x80\x88\', \'<\')\n    text = text.replace(\'\xe3\x80\x89\', \'>\')\n    text = text.replace(\'\xe3\x80\x90\', \'[\')\n    text = text.replace(\'\xe3\x80\x91\', \']\')\n    text = text.replace(\'\xef\xbc\x85\', \'%\')\n    return text\n\n\ndef remove_non_printing_char(text):\n    \'\'\'\n    Port of https://github.com/moses-smt/mosesdecoder/blob/master/scripts/tokenizer/remove-non-printing-char.perl\n    \'\'\'\n    output = []\n    for char in text:\n        cat = unicodedata.category(char)\n        if cat.startswith(\'C\'):\n            continue\n        output.append(char)\n    return """".join(output)\n\n\ndef romanian_preprocessing(text):\n    \'\'\'Sennrich\'s WMT16 scripts for Romanian preprocessing, used by model `xlm-mlm-enro-1024`\'\'\'\n    # https://github.com/rsennrich/wmt16-scripts/blob/master/preprocess/normalise-romanian.py\n    text = text.replace(""\\u015e"", ""\\u0218"").replace(""\\u015f"", ""\\u0219"")\n    text = text.replace(""\\u0162"", ""\\u021a"").replace(""\\u0163"", ""\\u021b"")\n    # https://github.com/rsennrich/wmt16-scripts/blob/master/preprocess/remove-diacritics.py\n    text = text.replace(""\\u0218"", ""S"").replace(""\\u0219"", ""s"") #s-comma\n    text = text.replace(""\\u021a"", ""T"").replace(""\\u021b"", ""t"") #t-comma\n    text = text.replace(""\\u0102"", ""A"").replace(""\\u0103"", ""a"")\n    text = text.replace(""\\u00C2"", ""A"").replace(""\\u00E2"", ""a"")\n    text = text.replace(""\\u00CE"", ""I"").replace(""\\u00EE"", ""i"")\n    return text\n\n\nclass XLMTokenizer(PreTrainedTokenizer):\n    """"""\n    BPE tokenizer for XLM\n\n        - Moses preprocessing & tokenization for most supported languages\n\n        - Language specific tokenization for Chinese (Jieba), Japanese (KyTea) and Thai (PyThaiNLP)\n\n        - (optionally) lower case & normalize all inputs text\n\n        - argument ``special_tokens`` and function ``set_special_tokens``, can be used to add additional symbols \\\n        (ex: ""__classify__"") to a vocabulary\n        \n        - `lang2id` attribute maps the languages supported by the model with their ids if provided (automatically set for pretrained vocabularies)\n\n        - `id2lang` attributes does reverse mapping if provided (automatically set for pretrained vocabularies)\n\n        - `do_lowercase_and_remove_accent` controle lower casing and accent (automatically set for pretrained vocabularies)\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    pretrained_init_configuration = PRETRAINED_INIT_CONFIGURATION\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, unk_token=""<unk>"", bos_token=""<s>"",\n                 sep_token=""</s>"", pad_token=""<pad>"", cls_token=""</s>"",\n                 mask_token=""<special1>"", additional_special_tokens=[""<special0>"",\n                 ""<special1>"", ""<special2>"", ""<special3>"", ""<special4>"", ""<special5>"",\n                 ""<special6>"", ""<special7>"", ""<special8>"", ""<special9>""],\n                 lang2id=None, id2lang=None, do_lowercase_and_remove_accent=True,\n                 **kwargs):\n        super(XLMTokenizer, self).__init__(unk_token=unk_token, bos_token=bos_token,\n                                           sep_token=sep_token, pad_token=pad_token,\n                                           cls_token=cls_token, mask_token=mask_token,\n                                           additional_special_tokens=additional_special_tokens,\n                                           **kwargs)\n\n        # cache of sm.MosesPunctNormalizer instance\n        self.cache_moses_punct_normalizer = dict()\n        # cache of sm.MosesTokenizer instance\n        self.cache_moses_tokenizer = dict()\n        self.lang_with_custom_tokenizer = set([\'zh\', \'th\', \'ja\'])\n        # True for current supported model (v1.2.0), False for XLM-17 & 100\n        self.do_lowercase_and_remove_accent = do_lowercase_and_remove_accent\n        self.lang2id = lang2id\n        self.id2lang = id2lang\n        if lang2id is not None and id2lang is not None:\n            assert len(lang2id) == len(id2lang)\n\n        self.ja_word_tokenizer = None\n        self.zh_word_tokenizer = None\n\n        self.encoder = json.load(open(vocab_file, encoding=""utf-8""))\n        self.decoder = {v:k for k,v in self.encoder.items()}\n        merges = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[:-1]\n        merges = [tuple(merge.split()[:2]) for merge in merges]\n        self.bpe_ranks = dict(zip(merges, range(len(merges))))\n        self.cache = {}\n\n    def moses_punct_norm(self, text, lang):\n        if lang not in self.cache_moses_punct_normalizer:\n            punct_normalizer = sm.MosesPunctNormalizer(lang=lang)\n            self.cache_moses_punct_normalizer[lang] = punct_normalizer\n        else:\n            punct_normalizer = self.cache_moses_punct_normalizer[lang]\n        return punct_normalizer.normalize(text)\n\n    def moses_tokenize(self, text, lang):\n        if lang not in self.cache_moses_tokenizer:\n            moses_tokenizer = sm.MosesTokenizer(lang=lang)\n            self.cache_moses_tokenizer[lang] = moses_tokenizer\n        else:\n            moses_tokenizer = self.cache_moses_tokenizer[lang]\n        return moses_tokenizer.tokenize(text, return_str=False, escape=False)\n\n    def moses_pipeline(self, text, lang):\n        text = replace_unicode_punct(text)\n        text = self.moses_punct_norm(text, lang)\n        text = remove_non_printing_char(text)\n        return text\n\n    def ja_tokenize(self, text):\n        if self.ja_word_tokenizer is None:\n            try:\n                import Mykytea\n                self.ja_word_tokenizer = Mykytea.Mykytea(\'-model %s/local/share/kytea/model.bin\' % os.path.expanduser(\'~\'))\n            except (AttributeError, ImportError) as e:\n                logger.error(""Make sure you install KyTea (https://github.com/neubig/kytea) and it\'s python wrapper (https://github.com/chezou/Mykytea-python) with the following steps"")\n                logger.error(""1. git clone git@github.com:neubig/kytea.git && cd kytea"")\n                logger.error(""2. autoreconf -i"")\n                logger.error(""3. ./configure --prefix=$HOME/local"")\n                logger.error(""4. make && make install"")\n                logger.error(""5. pip install kytea"")\n                raise e\n        return list(self.ja_word_tokenizer.getWS(text))\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        word = tuple(token[:-1]) + (token[-1] + \'</w>\',)\n        if token in self.cache:\n            return self.cache[token]\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token+\'</w>\'\n\n        while True:\n            bigram = min(pairs, key=lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \' \'.join(word)\n        if word == \'\\n  </w>\':\n            word = \'\\n</w>\'\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text, lang=\'en\', bypass_tokenizer=False):\n        """"""\n        Tokenize a string given language code. For Chinese, Japanese and Thai, we use a language specific tokenizerself. Otherwise, we use Moses.\n\n        Details of tokenization:\n        - [sacremoses](https://github.com/alvations/sacremoses): port of Moses\n            - Install with `pip install sacremoses`\n        - [pythainlp](https://github.com/PyThaiNLP/pythainlp): Thai tokenizer\n            - Install with `pip install pythainlp`\n        - [kytea](https://github.com/chezou/Mykytea-python): Japanese tokenizer, wrapper of [KyTea](https://github.com/neubig/kytea)\n            - Install with the following steps:\n            ```\n            git clone git@github.com:neubig/kytea.git && cd kytea\n            autoreconf -i\n            ./configure --prefix=$HOME/local\n            make && make install\n            pip install kytea\n            ```\n        - [jieba](https://github.com/fxsjy/jieba): Chinese tokenizer *\n            - Install with `pip install jieba`\n\n        \\* The original XLM used [Stanford Segmenter](https://nlp.stanford.edu/software/stanford-segmenter-2018-10-16.zip).\n        However, the wrapper (`nltk.tokenize.stanford_segmenter`) is slow due to JVM overhead, and it will be deprecated.\n        Jieba is a lot faster and pip-installable. Note there is some mismatch with the Stanford Segmenter. It should be fine\n        if you fine-tune the model with Chinese supervisionself. If you want the same exact behaviour, use the original XLM\n        [preprocessing script](https://github.com/facebookresearch/XLM/tree/master/tools) to tokenize the sentence externally,\n        and set `bypass_tokenizer=True` to bypass the tokenizer.\n\n        Args:\n            - lang: ISO language code (default = \'en\') (string). Languages should belong of the model supported languages. However, we don\'t enforce it.\n            - bypass_tokenizer: Allow users to preprocess and tokenize the sentences externally (default = False)  (bool). If True, we only apply BPE.\n\n        Returns:\n            List of tokens.\n        """"""\n        if lang and self.lang2id and lang not in self.lang2id:\n            logger.error(""Supplied language code not found in lang2id mapping. Please check that your language is supported by the loaded pretrained model."")\n        if bypass_tokenizer:\n            text = text.split()\n        elif lang not in self.lang_with_custom_tokenizer:\n            text = self.moses_pipeline(text, lang=lang)\n            # TODO: make sure we are using `xlm-mlm-enro-1024`, since XLM-100 doesn\'t have this step\n            if lang == \'ro\':\n                text = romanian_preprocessing(text)\n            text = self.moses_tokenize(text, lang=lang)\n        elif lang == \'th\':\n            text = self.moses_pipeline(text, lang=lang)\n            try:\n                if \'pythainlp\' not in sys.modules:\n                    from pythainlp.tokenize import word_tokenize as th_word_tokenize\n                else:\n                    th_word_tokenize = sys.modules[\'pythainlp\'].word_tokenize\n            except (AttributeError, ImportError) as e:\n                logger.error(""Make sure you install PyThaiNLP (https://github.com/PyThaiNLP/pythainlp) with the following steps"")\n                logger.error(""1. pip install pythainlp"")\n                raise e\n            text = th_word_tokenize(text)\n        elif lang == \'zh\':\n            try:\n                if \'jieba\' not in sys.modules:\n                    import jieba\n                else:\n                    jieba = sys.modules[\'jieba\']\n            except (AttributeError, ImportError) as e:\n                logger.error(""Make sure you install Jieba (https://github.com/fxsjy/jieba) with the following steps"")\n                logger.error(""1. pip install jieba"")\n                raise e\n            text = \' \'.join(jieba.cut(text))\n            text = self.moses_pipeline(text, lang=lang)\n            text = text.split()\n        elif lang == \'ja\':\n            text = self.moses_pipeline(text, lang=lang)\n            text = self.ja_tokenize(text)\n        else:\n            raise ValueError(\'It should not reach here\')\n\n        if self.do_lowercase_and_remove_accent and not bypass_tokenizer:\n            text = lowercase_and_remove_accent(text)\n\n        split_tokens = []\n        for token in text:\n            if token:\n                split_tokens.extend([t for t in self.bpe(token).split(\' \')])\n\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.decoder.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \'\'.join(tokens).replace(\'</w>\', \' \').strip()\n        return out_string\n\n    def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None):\n        """"""\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks\n        by concatenating and adding special tokens.\n        A RoBERTa sequence has the following format:\n            single sequence: <s> X </s>\n            pair of sequences: <s> A </s></s> B </s>\n        """"""\n        if token_ids_1 is None:\n            return [self.cls_token_id] + token_ids_0 + [self.sep_token_id]\n        sep = [self.sep_token_id]\n        cls = [self.cls_token_id]\n        return cls + token_ids_0 + sep + token_ids_1 + sep\n\n    def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False):\n        """"""\n        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer ``prepare_for_model`` or ``encode_plus`` methods.\n\n        Args:\n            token_ids_0: list of ids (must not contain special tokens)\n            token_ids_1: Optional list of ids (must not contain special tokens), necessary when fetching sequence ids\n                for sequence pairs\n            already_has_special_tokens: (default False) Set to True if the token list is already formated with\n                special tokens for the model\n\n        Returns:\n            A list of integers in the range [0, 1]: 0 for a special token, 1 for a sequence token.\n        """"""\n\n        if already_has_special_tokens:\n            if token_ids_1 is not None:\n                raise ValueError(""You should not supply a second sequence if the provided sequence of ""\n                                 ""ids is already formated with special tokens for the model."")\n            return list(map(lambda x: 1 if x in [self.sep_token_id, self.cls_token_id] else 0, token_ids_0))\n\n        if token_ids_1 is not None:\n            return [1] + ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1]\n        return [1] + ([0] * len(token_ids_0)) + [1]\n\n    def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None):\n        """"""\n        Creates a mask from the two sequences passed to be used in a sequence-pair classification task.\n        An XLM sequence pair mask has the following format:\n        0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1\n        | first sequence    | second sequence\n\n        if token_ids_1 is None, only returns the first portion of the mask (0\'s).\n        """"""\n        sep = [self.sep_token_id]\n        cls = [self.cls_token_id]\n        if token_ids_1 is None:\n            return len(cls + token_ids_0 + sep) * [0]\n        return len(cls + token_ids_0 + sep) * [0] + len(token_ids_1 + sep) * [1]\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file\n'"
baselines/models_pytorch/classifier_pytorch/transformers/tokenization_xlnet.py,0,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Tokenization classes for XLNet model.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\nimport os\nfrom shutil import copyfile\n\nimport unicodedata\nimport six\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'vocab_file\': \'spiece.model\'}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n    \'xlnet-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-base-cased-spiece.model"",\n    \'xlnet-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-large-cased-spiece.model"",\n    }\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'xlnet-base-cased\': None,\n    \'xlnet-large-cased\': None,\n}\n\nSPIECE_UNDERLINE = u\'\xe2\x96\x81\'\n\n# Segments (not really needed)\nSEG_ID_A   = 0\nSEG_ID_B   = 1\nSEG_ID_CLS = 2\nSEG_ID_SEP = 3\nSEG_ID_PAD = 4\n\nclass XLNetTokenizer(PreTrainedTokenizer):\n    """"""\n        SentencePiece based tokenizer. Peculiarities:\n\n            - requires `SentencePiece <https://github.com/google/sentencepiece>`_\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file,\n                 do_lower_case=False, remove_space=True, keep_accents=False,\n                 bos_token=""<s>"", eos_token=""</s>"", unk_token=""<unk>"", sep_token=""<sep>"",\n                 pad_token=""<pad>"", cls_token=""<cls>"", mask_token=""<mask>"",\n                 additional_special_tokens=[""<eop>"", ""<eod>""], **kwargs):\n        super(XLNetTokenizer, self).__init__(bos_token=bos_token, eos_token=eos_token,\n                                             unk_token=unk_token, sep_token=sep_token,\n                                             pad_token=pad_token, cls_token=cls_token,\n                                             mask_token=mask_token, additional_special_tokens=\n                                             additional_special_tokens, **kwargs)\n\n        self.max_len_single_sentence = self.max_len - 2  # take into account special tokens\n        self.max_len_sentences_pair = self.max_len - 3  # take into account special tokens\n\n        try:\n            import sentencepiece as spm\n        except ImportError:\n            logger.warning(""You need to install SentencePiece to use XLNetTokenizer: https://github.com/google/sentencepiece""\n                           ""pip install sentencepiece"")\n\n        self.do_lower_case = do_lower_case\n        self.remove_space = remove_space\n        self.keep_accents = keep_accents\n        self.vocab_file = vocab_file\n\n        self.sp_model = spm.SentencePieceProcessor()\n        self.sp_model.Load(vocab_file)\n\n    @property\n    def vocab_size(self):\n        return len(self.sp_model)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        state[""sp_model""] = None\n        return state\n\n    def __setstate__(self, d):\n        self.__dict__ = d\n        try:\n            import sentencepiece as spm\n        except ImportError:\n            logger.warning(""You need to install SentencePiece to use XLNetTokenizer: https://github.com/google/sentencepiece""\n                           ""pip install sentencepiece"")\n        self.sp_model = spm.SentencePieceProcessor()\n        self.sp_model.Load(self.vocab_file)\n\n    def preprocess_text(self, inputs):\n        if self.remove_space:\n            outputs = \' \'.join(inputs.strip().split())\n        else:\n            outputs = inputs\n        outputs = outputs.replace(""``"", \'""\').replace(""\'\'"", \'""\')\n\n        if six.PY2 and isinstance(outputs, str):\n            outputs = outputs.decode(\'utf-8\')\n\n        if not self.keep_accents:\n            outputs = unicodedata.normalize(\'NFKD\', outputs)\n            outputs = \'\'.join([c for c in outputs if not unicodedata.combining(c)])\n        if self.do_lower_case:\n            outputs = outputs.lower()\n\n        return outputs\n\n    def _tokenize(self, text, return_unicode=True, sample=False):\n        """""" Tokenize a string.\n            return_unicode is used only for py2\n        """"""\n        text = self.preprocess_text(text)\n        # note(zhiliny): in some systems, sentencepiece only accepts str for py2\n        if six.PY2 and isinstance(text, unicode):\n            text = text.encode(\'utf-8\')\n\n        if not sample:\n            pieces = self.sp_model.EncodeAsPieces(text)\n        else:\n            pieces = self.sp_model.SampleEncodeAsPieces(text, 64, 0.1)\n        new_pieces = []\n        for piece in pieces:\n            if len(piece) > 1 and piece[-1] == \',\' and piece[-2].isdigit():\n                cur_pieces = self.sp_model.EncodeAsPieces(\n                    piece[:-1].replace(SPIECE_UNDERLINE, \'\'))\n                if piece[0] != SPIECE_UNDERLINE and cur_pieces[0][0] == SPIECE_UNDERLINE:\n                    if len(cur_pieces[0]) == 1:\n                        cur_pieces = cur_pieces[1:]\n                    else:\n                        cur_pieces[0] = cur_pieces[0][1:]\n                cur_pieces.append(piece[-1])\n                new_pieces.extend(cur_pieces)\n            else:\n                new_pieces.append(piece)\n\n        # note(zhiliny): convert back to unicode for py2\n        if six.PY2 and return_unicode:\n            ret_pieces = []\n            for piece in new_pieces:\n                if isinstance(piece, str):\n                    piece = piece.decode(\'utf-8\')\n                ret_pieces.append(piece)\n            new_pieces = ret_pieces\n\n        return new_pieces\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.sp_model.PieceToId(token)\n\n    def _convert_id_to_token(self, index, return_unicode=True):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        token = self.sp_model.IdToPiece(index)\n        if six.PY2 and return_unicode and isinstance(token, str):\n            token = token.decode(\'utf-8\')\n        return token\n\n    def convert_tokens_to_string(self, tokens):\n        """"""Converts a sequence of tokens (strings for sub-words) in a single string.""""""\n        out_string = \'\'.join(tokens).replace(SPIECE_UNDERLINE, \' \').strip()\n        return out_string\n\n    def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None):\n        """"""\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks\n        by concatenating and adding special tokens.\n        A RoBERTa sequence has the following format:\n            single sequence: <s> X </s>\n            pair of sequences: <s> A </s></s> B </s>\n        """"""\n        sep = [self.sep_token_id]\n        cls = [self.cls_token_id]\n        if token_ids_1 is None:\n            return token_ids_0 + sep + cls\n        return token_ids_0 + sep + token_ids_1 + sep + cls\n\n    def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False):\n        """"""\n        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer ``prepare_for_model`` or ``encode_plus`` methods.\n\n        Args:\n            token_ids_0: list of ids (must not contain special tokens)\n            token_ids_1: Optional list of ids (must not contain special tokens), necessary when fetching sequence ids\n                for sequence pairs\n            already_has_special_tokens: (default False) Set to True if the token list is already formated with\n                special tokens for the model\n\n        Returns:\n            A list of integers in the range [0, 1]: 0 for a special token, 1 for a sequence token.\n        """"""\n\n        if already_has_special_tokens:\n            if token_ids_1 is not None:\n                raise ValueError(""You should not supply a second sequence if the provided sequence of ""\n                                 ""ids is already formated with special tokens for the model."")\n            return list(map(lambda x: 1 if x in [self.sep_token_id, self.cls_token_id] else 0, token_ids_0))\n\n        if token_ids_1 is not None:\n            return ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1, 1]\n        return ([0] * len(token_ids_0)) + [1, 1]\n\n    def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None):\n        """"""\n        Creates a mask from the two sequences passed to be used in a sequence-pair classification task.\n        A BERT sequence pair mask has the following format:\n        0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 2\n        | first sequence    | second sequence     | CLS segment ID\n        \n        if token_ids_1 is None, only returns the first portion of the mask (0\'s).\n        """"""\n        sep = [self.sep_token_id]\n        cls = [self.cls_token_id]\n        cls_segment_id = [2]\n\n        if token_ids_1 is None:\n            return len(token_ids_0 + sep + cls) * [0]\n        return len(token_ids_0 + sep) * [0] + len(token_ids_1 + sep) * [1] + cls_segment_id\n\n    def save_vocabulary(self, save_directory):\n        """""" Save the sentencepiece vocabulary (copy original file) and special tokens file\n            to a directory.\n        """"""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        out_vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n\n        if os.path.abspath(self.vocab_file) != os.path.abspath(out_vocab_file):\n            copyfile(self.vocab_file, out_vocab_file)\n\n        return (out_vocab_file,)\n'"
baselines/models_pytorch/mrc_pytorch/preprocess/CHID_preprocess.py,0,"b'\'\'\'\n@author: zhangxinrui\n@name: dataset_roberta.py\n@date: 10/07/2019\n\n\'\'\'\nimport collections\nimport os\nimport pickle\n\nimport numpy as np\nimport json\nfrom tqdm import tqdm\n\ntry:\n    import regex as re\nexcept Exception:\n    import re\n\nRawResult = collections.namedtuple(""RawResult"",\n                                   [""unique_id"", ""example_id"", ""tag"", ""logit""])\n\nSPIECE_UNDERLINE = \'\xe2\x96\x81\'\n\n\nclass ChidExample(object):\n    def __init__(self,\n                 example_id,\n                 tag,\n                 doc_tokens,\n                 options,\n                 answer_index=None):\n        self.example_id = example_id\n        self.tag = tag\n        self.doc_tokens = doc_tokens\n        self.options = options\n        self.answer_index = answer_index\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        s = """"\n        s += ""tag: %s"" % (self.tag)\n        s += "", context: %s"" % (\'\'.join(self.doc_tokens))\n        s += "", options: [%s]"" % ("", "".join(self.options))\n        if self.answer_index is not None:\n            s += "", answer: %s"" % self.options[self.answer_index]\n        return s\n\n\nclass InputFeatures(object):\n    """"""A single set of features of data.""""""\n\n    def __init__(self,\n                 unique_id,\n                 example_id,\n                 tag,\n                 tokens,\n                 input_ids,\n                 input_masks,\n                 segment_ids,\n                 choice_masks,\n                 label=None):\n        self.unique_id = unique_id\n        self.example_id = example_id\n        self.tag = tag\n        self.tokens = tokens\n        self.input_ids = input_ids\n        self.input_masks = input_masks\n        self.segment_ids = segment_ids\n        self.choice_masks = choice_masks\n        self.label = label  # \xe6\xad\xa3\xe7\xa1\xae\xe7\xad\x94\xe6\xa1\x88\xe5\x9c\xa8\xe6\x89\x80\xe6\x9c\x89\xe5\x80\x99\xe9\x80\x89\xe7\xad\x94\xe6\xa1\x88\xe4\xb8\xad\xe7\x9a\x84index\n\n\ndef read_chid_examples(input_data_file, input_label_file, is_training=True):\n    \'\'\'\n    \xe5\xb0\x86\xe5\x8e\x9f\xe5\xa7\x8b\xe6\x95\xb0\xe6\x8d\xae\xe5\xa4\x84\xe7\x90\x86\xe4\xb8\xba\xe5\xa6\x82\xe4\xb8\x8b\xe5\xbd\xa2\xe5\xbc\x8f\xef\xbc\x9a\n    part_passage\xe9\x81\x8d\xe5\x8e\x86\xe6\xaf\x8f\xe4\xb8\xaablak\xe7\x9a\x84\xe5\x91\xa8\xe5\x9b\xb4\xe4\xbd\x8d\xe7\xbd\xae\n    :param input_data:\n    :param is_training:\n    :return:\n    \'\'\'\n\n    if is_training:\n        input_label = json.load(open(input_label_file))\n    input_data = open(input_data_file)\n\n    def _is_chinese_char(cp):\n        if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n                (cp >= 0x3400 and cp <= 0x4DBF) or  #\n                (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n                (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n                (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n                (cp >= 0x2B820 and cp <= 0x2CEAF) or\n                (cp >= 0xF900 and cp <= 0xFAFF) or  #\n                (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n            return True\n\n        return False\n\n    def is_fuhao(c):\n        if c == \'\xe3\x80\x82\' or c == \'\xef\xbc\x8c\' or c == \'\xef\xbc\x81\' or c == \'\xef\xbc\x9f\' or c == \'\xef\xbc\x9b\' or c == \'\xe3\x80\x81\' or c == \'\xef\xbc\x9a\' or c == \'\xef\xbc\x88\' or c == \'\xef\xbc\x89\' \\\n                or c == \'\xef\xbc\x8d\' or c == \'~\' or c == \'\xe3\x80\x8c\' or c == \'\xe3\x80\x8a\' or c == \'\xe3\x80\x8b\' or c == \',\' or c == \'\xe3\x80\x8d\' or c == \'""\' or c == \'\xe2\x80\x9c\' or c == \'\xe2\x80\x9d\' \\\n                or c == \'$\' or c == \'\xe3\x80\x8e\' or c == \'\xe3\x80\x8f\' or c == \'\xe2\x80\x94\' or c == \';\' or c == \'\xe3\x80\x82\' or c == \'(\' or c == \')\' or c == \'-\' or c == \'\xef\xbd\x9e\' or c == \'\xe3\x80\x82\' \\\n                or c == \'\xe2\x80\x98\' or c == \'\xe2\x80\x99\':\n            return True\n        return False\n\n    def _tokenize_chinese_chars(text):\n        """"""Adds whitespace around any CJK character.""""""\n        output = []\n        is_blank = False\n        for index, char in enumerate(text):\n            cp = ord(char)\n            if is_blank:\n                output.append(char)\n                if context[index - 12:index + 1].startswith(""#idiom""):\n                    is_blank = False\n                    output.append(SPIECE_UNDERLINE)\n            else:\n                if text[index:index + 6] == ""#idiom"":\n                    is_blank = True\n                    if len(output) > 0 and output[-1] != SPIECE_UNDERLINE:\n                        output.append(SPIECE_UNDERLINE)\n                    output.append(char)\n                elif _is_chinese_char(cp) or is_fuhao(char):\n                    if len(output) > 0 and output[-1] != SPIECE_UNDERLINE:\n                        output.append(SPIECE_UNDERLINE)\n                    output.append(char)\n                    output.append(SPIECE_UNDERLINE)\n                else:\n                    output.append(char)\n        return """".join(output)\n\n    def is_whitespace(c):\n        if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F or c == SPIECE_UNDERLINE:\n            return True\n        return False\n\n    examples = []\n    example_id = 0\n    for data in tqdm(input_data):\n\n        data = eval(data)\n        options = data[\'candidates\']\n\n        for context in data[\'content\']:\n\n            context = context.replace(""\xe2\x80\x9c"", ""\\"""").replace(""\xe2\x80\x9d"", ""\\"""").replace(""\xe2\x80\x94\xe2\x80\x94"", ""--""). \\\n                replace(""\xe2\x80\x94"", ""-"").replace(""\xe2\x80\x95"", ""-"").replace(""\xe2\x80\xa6"", ""..."").replace(""\xe2\x80\x98"", ""\\\'"").replace(""\xe2\x80\x99"", ""\\\'"")\n            context = _tokenize_chinese_chars(context)\n\n            paragraph_text = context.strip()\n            doc_tokens = []\n            prev_is_whitespace = True\n            for c in paragraph_text:\n                if is_whitespace(c):\n                    prev_is_whitespace = True\n                else:\n                    if prev_is_whitespace:\n                        doc_tokens.append(c)\n                    else:\n                        doc_tokens[-1] += c\n                    prev_is_whitespace = False\n\n            tags = [blank for blank in doc_tokens if \'#idiom\' in blank]\n\n            if is_training:\n                for tag_index, tag in enumerate(tags):\n                    answer_index = input_label[tag]\n                    example = ChidExample(\n                        example_id=example_id,\n                        tag=tag,\n                        doc_tokens=doc_tokens,\n                        options=options,\n                        answer_index=answer_index)\n                    examples.append(example)\n            else:\n                for tag_index, tag in enumerate(tags):\n                    example = ChidExample(\n                        example_id=example_id,\n                        tag=tag,\n                        doc_tokens=doc_tokens,\n                        options=options)\n                    examples.append(example)\n        else:\n            example_id += 1\n    else:\n        print(\'\xe5\x8e\x9f\xe5\xa7\x8b\xe6\xa0\xb7\xe6\x9c\xac\xe4\xb8\xaa\xe6\x95\xb0\xef\xbc\x9a{}\'.format(example_id))\n\n    print(\'\xe5\xae\x9e\xe9\x99\x85\xe7\x94\x9f\xe6\x88\x90\xe6\x80\xbb\xe6\xa0\xb7\xe4\xbe\x8b\xe6\x95\xb0\xef\xbc\x9a{}\'.format(len(examples)))\n    return examples\n\n\ndef add_tokens_for_around(tokens, pos, num_tokens):\n    num_l = num_tokens // 2\n    num_r = num_tokens - num_l\n\n    if pos >= num_l and (len(tokens) - 1 - pos) >= num_r:\n        tokens_l = tokens[pos - num_l: pos]\n        tokens_r = tokens[pos + 1: pos + 1 + num_r]\n    elif pos <= num_l:\n        tokens_l = tokens[:pos]\n        right_len = num_tokens - len(tokens_l)\n        tokens_r = tokens[pos + 1: pos + 1 + right_len]\n    elif (len(tokens) - 1 - pos) <= num_r:\n        tokens_r = tokens[pos + 1:]\n        left_len = num_tokens - len(tokens_r)\n        tokens_l = tokens[pos - left_len: pos]\n    else:\n        raise ValueError(\'impossible\')\n\n    return tokens_l, tokens_r\n\n\ndef convert_examples_to_features(examples, tokenizer, max_seq_length=128, max_num_choices=10):\n    \'\'\'\n    \xe5\xb0\x86\xe6\x89\x80\xe6\x9c\x89\xe5\x80\x99\xe9\x80\x89\xe7\xad\x94\xe6\xa1\x88\xe6\x94\xbe\xe7\xbd\xae\xe5\x9c\xa8\xe7\x89\x87\xe6\xae\xb5\xe5\xbc\x80\xe5\xa4\xb4\n    \'\'\'\n\n    def _loop(example, unique_id, label):\n        \'\'\'\n        :param example:\n        :param unique_id:\n        :return:\n            input_ids = (C, seq_len)\n            token_type_ids = (C, seq_len) = segment_id\n            input_mask = (C, seq_len)\n            labels = int\n            choices_mask = (C)\n        \'\'\'\n        input_ids = []\n        input_masks = []\n        segment_ids = []\n        choice_masks = [1] * len(example.options)\n\n        tag = example.tag\n        all_doc_tokens = []\n        for (i, token) in enumerate(example.doc_tokens):\n            if \'#idiom\' in token:\n                sub_tokens = [str(token)]\n            else:\n                sub_tokens = tokenizer.tokenize(token)\n            for sub_token in sub_tokens:\n                all_doc_tokens.append(sub_token)\n\n        pos = all_doc_tokens.index(tag)\n        num_tokens = max_tokens_for_doc - 5  # [unused1]\xe5\x92\x8csegA\xe7\x9a\x84\xe6\x88\x90\xe8\xaf\xad\n        tmp_l, tmp_r = add_tokens_for_around(all_doc_tokens, pos, num_tokens)\n        num_l = len(tmp_l)\n        num_r = len(tmp_r)\n\n        tokens_l = []\n        for token in tmp_l:\n            if \'#idiom\' in token and token != tag:\n                tokens_l.extend([\'[MASK]\'] * 4)\n            else:\n                tokens_l.append(token)\n        tokens_l = tokens_l[-num_l:]\n        del tmp_l\n\n        tokens_r = []\n        for token in tmp_r:\n            if \'#idiom\' in token and token != tag:\n                tokens_r.extend([\'[MASK]\'] * 4)\n            else:\n                tokens_r.append(token)\n        tokens_r = tokens_r[: num_r]\n        del tmp_r\n\n        for i, elem in enumerate(example.options):\n            option = tokenizer.tokenize(elem)\n            tokens = [\'[CLS]\'] + option + [\'[SEP]\'] + tokens_l + [\'[unused1]\'] + tokens_r + [\'[SEP]\']\n\n            input_id = tokenizer.convert_tokens_to_ids(tokens)\n            input_mask = [1] * len(input_id)\n            segment_id = [0] * len(input_id)\n\n            while len(input_id) < max_seq_length:\n                input_id.append(0)\n                input_mask.append(0)\n                segment_id.append(0)\n            assert len(input_id) == max_seq_length\n            assert len(input_mask) == max_seq_length\n            assert len(segment_id) == max_seq_length\n\n            input_ids.append(input_id)\n            input_masks.append(input_mask)\n            segment_ids.append(segment_id)\n\n        if unique_id < 5:\n            print(""*** Example ***"")\n            print(""unique_id: {}"".format(unique_id))\n            print(""context_id: {}"".format(tag))\n            print(""label: {}"".format(label))\n            print(""tag_index: {}"".format(pos))\n            print(""tokens: {}"".format("""".join(tokens)))\n            print(""choice_masks: {}"".format(choice_masks))\n        while len(input_ids) < max_num_choices:\n            input_ids.append([0] * max_seq_length)\n            input_masks.append([0] * max_seq_length)\n            segment_ids.append([0] * max_seq_length)\n            choice_masks.append(0)\n        assert len(input_ids) == max_num_choices\n        assert len(input_masks) == max_num_choices\n        assert len(segment_ids) == max_num_choices\n        assert len(choice_masks) == max_num_choices\n\n        features.append(\n            InputFeatures(\n                unique_id=unique_id,\n                example_id=example.example_id,\n                tag=tag,\n                tokens=tokens,\n                input_ids=input_ids,\n                input_masks=input_masks,\n                segment_ids=segment_ids,\n                choice_masks=choice_masks,\n                label=label))\n\n    max_tokens_for_doc = max_seq_length - 3  # [CLS] choice [SEP] document [SEP]\n    features = []\n    unique_id = 0\n\n    for (example_index, example) in enumerate(tqdm(examples)):\n\n        label = example.answer_index\n        if label != None:\n            _loop(example, unique_id, label)\n        else:\n            _loop(example, unique_id, None)\n        unique_id += 1\n\n        if unique_id % 12000 == 0:\n            print(""unique_id: %s"" % (unique_id))\n    print(""unique_id: %s"" % (unique_id))\n    return features\n\n\ndef logits_matrix_to_array(logits_matrix, index_2_idiom):\n    """"""\xe4\xbb\x8e\xe7\x9f\xa9\xe9\x98\xb5\xe4\xb8\xad\xe8\xae\xa1\xe7\xae\x97\xe5\x85\xa8\xe5\xb1\x80\xe6\xa6\x82\xe7\x8e\x87\xe6\x9c\x80\xe5\xa4\xa7\xe7\x9a\x84\xe5\xba\x8f\xe5\x88\x97""""""\n    logits_matrix = np.array(logits_matrix)\n    logits_matrix = np.transpose(logits_matrix)\n    tmp = []\n    for i, row in enumerate(logits_matrix):\n        for j, col in enumerate(row):\n            tmp.append((i, j, col))\n    else:\n        choice = set(range(i + 1))\n        blanks = set(range(j + 1))\n    tmp = sorted(tmp, key=lambda x: x[2], reverse=True)\n    results = []\n    for i, j, v in tmp:\n        if (j in blanks) and (i in choice):\n            results.append((i, j))\n            blanks.remove(j)\n            choice.remove(i)\n    results = sorted(results, key=lambda x: x[1], reverse=False)\n    results = [[index_2_idiom[j], i] for i, j in results]\n    return results\n\n\ndef logits_matrix_max_array(logits_matrix, index_2_idiom):\n    logits_matrix = np.array(logits_matrix)\n    arg_max = logits_matrix.argmax(axis=1)\n    results = [[index_2_idiom[i], idx] for i, idx in enumerate(arg_max)]\n    return results\n\n\ndef get_final_predictions(all_results, tmp_predict_file, g=True):\n    if not os.path.exists(tmp_predict_file):\n        pickle.dump(all_results, open(tmp_predict_file, \'wb\'))\n\n    raw_results = {}\n    for i, elem in enumerate(all_results):\n        example_id = elem.example_id\n        if example_id not in raw_results:\n            raw_results[example_id] = [(elem.tag, elem.logit)]\n        else:\n            raw_results[example_id].append((elem.tag, elem.logit))\n\n    results = []\n    for example_id, elem in raw_results.items():\n        index_2_idiom = {index: tag for index, (tag, logit) in enumerate(elem)}\n        logits = [logit for _, logit in elem]\n        if g:\n            results.extend(logits_matrix_to_array(logits, index_2_idiom))\n        else:\n            results.extend(logits_matrix_max_array(logits, index_2_idiom))\n    return results\n\n\ndef write_predictions(results, output_prediction_file):\n    # output_prediction_file = result6.csv\n    # results = pd.DataFrame(results)\n    # results.to_csv(output_prediction_file, header=None, index=None)\n\n    results_dict = {}\n    for result in results:\n        results_dict[result[0]] = result[1]\n    with open(output_prediction_file, \'w\') as w:\n        json.dump(results_dict, w, indent=2)\n\n    print(""Writing predictions to: {}"".format(output_prediction_file))\n\n\ndef generate_input(data_file, label_file, example_file, feature_file, tokenizer, max_seq_length, max_num_choices,\n                   is_training=True):\n    if os.path.exists(feature_file):\n        features = pickle.load(open(feature_file, \'rb\'))\n    elif os.path.exists(example_file):\n        examples = pickle.load(open(example_file, \'rb\'))\n        features = convert_examples_to_features(examples, tokenizer, max_seq_length, max_num_choices)\n        pickle.dump(features, open(feature_file, \'wb\'))\n    else:\n        examples = read_chid_examples(data_file, label_file, is_training=is_training)\n        pickle.dump(examples, open(example_file, \'wb\'))\n        features = convert_examples_to_features(examples, tokenizer, max_seq_length, max_num_choices)\n        pickle.dump(features, open(feature_file, \'wb\'))\n\n    return features\n\n\ndef evaluate(ans_f, pre_f):\n    ans = json.load(open(ans_f))\n    pre = json.load(open(pre_f))\n\n    total_num = 0\n    acc_num = 0\n    for id_ in ans:\n        if id_ not in pre:\n            raise FileNotFoundError\n        total_num += 1\n        if ans[id_] == pre[id_]:\n            acc_num += 1\n\n    acc = acc_num / total_num\n    acc *= 100\n    return acc\n'"
baselines/models_pytorch/mrc_pytorch/preprocess/DRCD_output.py,0,"b'import collections\nimport json\nimport math\n\nfrom tqdm import tqdm\n\nfrom tools.official_tokenization import BasicTokenizer\n\n\ndef write_predictions_topk(config, all_examples, all_features, all_results, n_best_size,\n                           max_answer_length, do_lower_case, output_prediction_file,\n                           output_nbest_file):\n    """"""Write final predictions to the json file and log-odds of null if needed.""""""\n    print(""Writing predictions to: %s"" % (output_prediction_file))\n    print(""Writing nbest to: %s"" % (output_nbest_file))\n\n    example_index_to_features = collections.defaultdict(list)\n    for feature in all_features:\n        example_index_to_features[feature[\'example_index\']].append(feature)\n\n    unique_id_to_result = {}\n    for result in all_results:\n        unique_id_to_result[result.unique_id] = result\n\n    _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""PrelimPrediction"",\n        [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n    all_predictions = collections.OrderedDict()\n    all_nbest_json = collections.OrderedDict()\n\n    for (example_index, example) in enumerate(tqdm(all_examples)):\n        features = example_index_to_features[example_index]\n        prelim_predictions = []\n        # keep track of the minimum score of null start+end of position 0\n        for (feature_index, feature) in enumerate(features):\n            result = unique_id_to_result[feature[\'unique_id\']]\n            for i in range(config.start_n_top):\n                for j in range(config.end_n_top):\n                    start_logit = result.start_top_logits[i]\n                    start_index = result.start_top_index[i]\n\n                    j_index = i * config.end_n_top + j\n\n                    end_logit = result.end_top_logits[j_index]\n                    end_index = result.end_top_index[j_index]\n\n                    # We could hypothetically create invalid predictions, e.g., predict\n                    # that the start of the span is in the question. We throw out all\n                    # invalid predictions.\n                    if start_index >= len(feature[\'tokens\']):\n                        continue\n                    if end_index >= len(feature[\'tokens\']):\n                        continue\n                    if not feature[\'token_is_max_context\'].get(str(start_index), False):\n                        continue\n                    if end_index < start_index:\n                        continue\n                    length = end_index - start_index + 1\n                    if length > max_answer_length:\n                        continue\n\n                    prelim_predictions.append(\n                        _PrelimPrediction(\n                            feature_index=feature_index,\n                            start_index=start_index,\n                            end_index=end_index,\n                            start_logit=start_logit,\n                            end_logit=end_logit))\n\n        prelim_predictions = sorted(\n            prelim_predictions,\n            key=lambda x: (x.start_logit + x.end_logit),\n            reverse=True)\n\n        _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n            ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n        seen_predictions = {}\n        nbest = []\n        # ipdb.set_trace()\n        for pred in prelim_predictions:\n            if len(nbest) >= n_best_size:\n                break\n            feature = features[pred.feature_index]\n            if pred.start_index > 0:  # this is a non-null prediction\n                tok_tokens = feature[\'tokens\'][pred.start_index:(pred.end_index + 1)]\n                orig_doc_start = feature[\'token_to_orig_map\'][str(pred.start_index)]\n                orig_doc_end = feature[\'token_to_orig_map\'][str(pred.end_index)]\n                orig_tokens = example[\'ori_doc_tokens\'][orig_doc_start:(orig_doc_end + 1)]\n                tok_text = """".join(tok_tokens)\n\n                # De-tokenize WordPieces that have been split off.\n                tok_text = tok_text.replace("" ##"", """")\n                tok_text = tok_text.replace(""##"", """")\n\n                # Clean whitespace\n                tok_text = tok_text.strip()\n                tok_text = "" "".join(tok_text.split())\n                orig_text = """".join(orig_tokens)\n\n                final_text = get_final_text(tok_text, orig_text, do_lower_case)\n                if final_text in seen_predictions:\n                    continue\n\n                seen_predictions[final_text] = True\n            else:\n                final_text = """"\n                seen_predictions[final_text] = True\n\n            nbest.append(\n                _NbestPrediction(\n                    text=final_text,\n                    start_logit=pred.start_logit,\n                    end_logit=pred.end_logit))\n\n        # In very rare edge cases we could have no valid predictions. So we\n        # just create a nonce prediction in this case to avoid failure.\n        if not nbest:\n            nbest.append(_NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n        assert len(nbest) >= 1\n        # ipdb.set_trace()\n\n        total_scores = []\n        for entry in nbest:\n            total_scores.append(entry.start_logit + entry.end_logit)\n\n        probs = _compute_softmax(total_scores)\n\n        # ipdb.set_trace()\n\n        nbest_json = []\n        # ipdb.set_trace()\n        for (i, entry) in enumerate(nbest):\n            output = collections.OrderedDict()\n            output[""text""] = entry.text\n            output[""probability""] = float(probs[i])\n            output[""start_logit""] = float(entry.start_logit)\n            output[""end_logit""] = float(entry.end_logit)\n            nbest_json.append(output)\n\n        assert len(nbest_json) >= 1\n\n        # ipdb.set_trace()\n\n        all_predictions[example[\'qid\']] = nbest_json[0][""text""]\n        all_nbest_json[example[\'qid\']] = nbest_json\n\n    with open(output_prediction_file, ""w"") as writer:\n        writer.write(json.dumps(all_predictions, indent=4, ensure_ascii=False) + ""\\n"")\n\n    with open(output_nbest_file, ""w"") as writer:\n        writer.write(json.dumps(all_nbest_json, indent=4, ensure_ascii=False) + ""\\n"")\n\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, do_lower_case, output_prediction_file,\n                      output_nbest_file, version_2_with_negative=False, null_score_diff_threshold=0.):\n    """"""Write final predictions to the json file and log-odds of null if needed.""""""\n    print(""Writing predictions to: %s"" % (output_prediction_file))\n    print(""Writing nbest to: %s"" % (output_nbest_file))\n\n    example_index_to_features = collections.defaultdict(list)\n    for feature in all_features:\n        example_index_to_features[feature[\'example_index\']].append(feature)\n\n    unique_id_to_result = {}\n    for result in all_results:\n        unique_id_to_result[result.unique_id] = result\n\n    _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""PrelimPrediction"",\n        [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n    all_predictions = collections.OrderedDict()\n    all_nbest_json = collections.OrderedDict()\n    scores_diff_json = collections.OrderedDict()\n\n    for (example_index, example) in enumerate(tqdm(all_examples)):\n        features = example_index_to_features[example_index]\n        prelim_predictions = []\n        # keep track of the minimum score of null start+end of position 0\n        score_null = 1000000  # large and positive\n        min_null_feature_index = 0  # the paragraph slice with min null score\n        null_start_logit = 0  # the start logit at the slice with min null score\n        null_end_logit = 0  # the end logit at the slice with min null score\n        for (feature_index, feature) in enumerate(features):\n            result = unique_id_to_result[feature[\'unique_id\']]\n            start_indexes = _get_best_indexes(result.start_logits, n_best_size)\n            end_indexes = _get_best_indexes(result.end_logits, n_best_size)\n            # if we could have irrelevant answers, get the min score of irrelevant\n            if version_2_with_negative:\n                feature_null_score = result.start_logits[0] + result.end_logits[0]\n                if feature_null_score < score_null:\n                    score_null = feature_null_score\n                    min_null_feature_index = feature_index\n                    null_start_logit = result.start_logits[0]\n                    null_end_logit = result.end_logits[0]\n            for start_index in start_indexes:\n                for end_index in end_indexes:\n                    # We could hypothetically create invalid predictions, e.g., predict\n                    # that the start of the span is in the question. We throw out all\n                    # invalid predictions.\n                    if start_index >= len(feature[\'tokens\']):\n                        continue\n                    if end_index >= len(feature[\'tokens\']):\n                        continue\n                    if str(start_index) not in feature[\'token_to_orig_map\'] and \\\n                            start_index not in feature[\'token_to_orig_map\']:\n                        continue\n                    if str(end_index) not in feature[\'token_to_orig_map\'] and \\\n                            end_index not in feature[\'token_to_orig_map\']:\n                        continue\n                    if not feature[\'token_is_max_context\'].get(str(start_index), False):\n                        continue\n                    if end_index < start_index:\n                        continue\n                    length = end_index - start_index + 1\n                    if length > max_answer_length:\n                        continue\n                    prelim_predictions.append(\n                        _PrelimPrediction(\n                            feature_index=feature_index,\n                            start_index=start_index,\n                            end_index=end_index,\n                            start_logit=result.start_logits[start_index],\n                            end_logit=result.end_logits[end_index]))\n        if version_2_with_negative:\n            prelim_predictions.append(\n                _PrelimPrediction(\n                    feature_index=min_null_feature_index,\n                    start_index=0,\n                    end_index=0,\n                    start_logit=null_start_logit,\n                    end_logit=null_end_logit))\n        prelim_predictions = sorted(\n            prelim_predictions,\n            key=lambda x: (x.start_logit + x.end_logit),\n            reverse=True)\n\n        _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n            ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n        seen_predictions = {}\n        nbest = []\n        for pred in prelim_predictions:\n            if len(nbest) >= n_best_size:\n                break\n            feature = features[pred.feature_index]\n            if pred.start_index > 0:  # this is a non-null prediction\n                tok_tokens = feature[\'tokens\'][pred.start_index:(pred.end_index + 1)]\n                orig_doc_start = feature[\'token_to_orig_map\'][str(pred.start_index)]\n                orig_doc_end = feature[\'token_to_orig_map\'][str(pred.end_index)]\n                orig_tokens = example[\'ori_doc_tokens\'][orig_doc_start:(orig_doc_end + 1)]\n                tok_text = """".join(tok_tokens)\n\n                # De-tokenize WordPieces that have been split off.\n                tok_text = tok_text.replace("" ##"", """")\n                tok_text = tok_text.replace(""##"", """")\n\n                # Clean whitespace\n                tok_text = tok_text.strip()\n                tok_text = "" "".join(tok_text.split())\n                orig_text = """".join(orig_tokens)\n\n                final_text = get_final_text(tok_text, orig_text, do_lower_case)\n                if final_text in seen_predictions:\n                    continue\n\n                seen_predictions[final_text] = True\n            else:\n                final_text = """"\n                seen_predictions[final_text] = True\n\n            nbest.append(\n                _NbestPrediction(\n                    text=final_text,\n                    start_logit=pred.start_logit,\n                    end_logit=pred.end_logit))\n        # if we didn\'t include the empty option in the n-best, include it\n        if version_2_with_negative:\n            if """" not in seen_predictions:\n                nbest.append(\n                    _NbestPrediction(\n                        text="""",\n                        start_logit=null_start_logit,\n                        end_logit=null_end_logit))\n\n            # In very rare edge cases we could only have single null prediction.\n            # So we just create a nonce prediction in this case to avoid failure.\n            if len(nbest) == 1:\n                nbest.insert(0, _NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n        # In very rare edge cases we could have no valid predictions. So we\n        # just create a nonce prediction in this case to avoid failure.\n        if not nbest:\n            nbest.append(_NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n        assert len(nbest) >= 1\n\n        total_scores = []\n        best_non_null_entry = None\n        for entry in nbest:\n            total_scores.append(entry.start_logit + entry.end_logit)\n            if not best_non_null_entry:\n                if entry.text:\n                    best_non_null_entry = entry\n\n        probs = _compute_softmax(total_scores)\n\n        nbest_json = []\n        for (i, entry) in enumerate(nbest):\n            output = collections.OrderedDict()\n            output[""text""] = entry.text\n            output[""probability""] = float(probs[i])\n            output[""start_logit""] = float(entry.start_logit)\n            output[""end_logit""] = float(entry.end_logit)\n            nbest_json.append(output)\n\n        assert len(nbest_json) >= 1\n\n        if not version_2_with_negative:\n            all_predictions[example[\'qid\']] = nbest_json[0][""text""]\n            all_nbest_json[example[\'qid\']] = nbest_json\n        else:\n            # predict """" iff the null score - the score of best non-null > threshold\n            score_diff = score_null - best_non_null_entry.start_logit - (best_non_null_entry.end_logit)\n            scores_diff_json[example[\'qid\']] = score_diff\n            if score_diff > null_score_diff_threshold:\n                all_predictions[example[\'qid\']] = """"\n            else:\n                all_predictions[example[\'qid\']] = best_non_null_entry.text\n            all_nbest_json[example[\'qid\']] = nbest_json\n\n    with open(output_prediction_file, ""w"") as writer:\n        writer.write(json.dumps(all_predictions, indent=4, ensure_ascii=False) + ""\\n"")\n\n    with open(output_nbest_file, ""w"") as writer:\n        writer.write(json.dumps(all_nbest_json, indent=4, ensure_ascii=False) + ""\\n"")\n\n\ndef get_final_text(pred_text, orig_text, do_lower_case, verbose_logging=False):\n    """"""Project the tokenized prediction back to the original text.""""""\n\n    # When we created the data, we kept track of the alignment between original\n    # (whitespace tokenized) tokens and our WordPiece tokenized tokens. So\n    # now `orig_text` contains the span of our original text corresponding to the\n    # span that we predicted.\n    #\n    # However, `orig_text` may contain extra characters that we don\'t want in\n    # our prediction.\n    #\n    # For example, let\'s say:\n    #   pred_text = steve smith\n    #   orig_text = Steve Smith\'s\n    #\n    # We don\'t want to return `orig_text` because it contains the extra ""\'s"".\n    #\n    # We don\'t want to return `pred_text` because it\'s already been normalized\n    # (the SQuAD eval script also does punctuation stripping/lower casing but\n    # our tokenizer does additional normalization like stripping accent\n    # characters).\n    #\n    # What we really want to return is ""Steve Smith"".\n    #\n    # Therefore, we have to apply a semi-complicated alignment heuristic between\n    # `pred_text` and `orig_text` to get a character-to-character alignment. This\n    # can fail in certain cases in which case we just return `orig_text`.\n\n    def _strip_spaces(text):\n        ns_chars = []\n        ns_to_s_map = collections.OrderedDict()\n        for (i, c) in enumerate(text):\n            if c == "" "":\n                continue\n            ns_to_s_map[len(ns_chars)] = i\n            ns_chars.append(c)\n        ns_text = """".join(ns_chars)\n        return (ns_text, ns_to_s_map)\n\n    # We first tokenize `orig_text`, strip whitespace from the result\n    # and `pred_text`, and check if they are the same length. If they are\n    # NOT the same length, the heuristic has failed. If they are the same\n    # length, we assume the characters are one-to-one aligned.\n    tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n\n    tok_text = """".join(tokenizer.tokenize(orig_text))\n\n    start_position = tok_text.find(pred_text)\n    if start_position == -1:\n        if verbose_logging:\n            print(""Unable to find text: \'%s\' in \'%s\'"" % (pred_text, orig_text))\n        return orig_text\n    end_position = start_position + len(pred_text) - 1\n\n    (orig_ns_text, orig_ns_to_s_map) = _strip_spaces(orig_text)\n    (tok_ns_text, tok_ns_to_s_map) = _strip_spaces(tok_text)\n\n    if len(orig_ns_text) != len(tok_ns_text):\n        if verbose_logging:\n            print(""Length not equal after stripping spaces: \'%s\' vs \'%s\'"" % (orig_ns_text, tok_ns_text))\n        return orig_text\n\n    # We then project the characters in `pred_text` back to `orig_text` using\n    # the character-to-character alignment.\n    tok_s_to_ns_map = {}\n    for (i, tok_index) in tok_ns_to_s_map.items():\n        tok_s_to_ns_map[tok_index] = i\n\n    orig_start_position = None\n    if start_position in tok_s_to_ns_map:\n        ns_start_position = tok_s_to_ns_map[start_position]\n        if ns_start_position in orig_ns_to_s_map:\n            orig_start_position = orig_ns_to_s_map[ns_start_position]\n\n    if orig_start_position is None:\n        if verbose_logging:\n            print(""Couldn\'t map start position"")\n        return orig_text\n\n    orig_end_position = None\n    if end_position in tok_s_to_ns_map:\n        ns_end_position = tok_s_to_ns_map[end_position]\n        if ns_end_position in orig_ns_to_s_map:\n            orig_end_position = orig_ns_to_s_map[ns_end_position]\n\n    if orig_end_position is None:\n        if verbose_logging:\n            print(""Couldn\'t map end position"")\n        return orig_text\n\n    output_text = orig_text[orig_start_position:(orig_end_position + 1)]\n    return output_text\n\n\ndef _get_best_indexes(logits, n_best_size):\n    """"""Get the n-best logits from a list.""""""\n    index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n    best_indexes = []\n    for i in range(len(index_and_score)):\n        if i >= n_best_size:\n            break\n        best_indexes.append(index_and_score[i][0])\n    return best_indexes\n\n\ndef _compute_softmax(scores):\n    """"""Compute softmax probability over raw logits.""""""\n    if not scores:\n        return []\n\n    max_score = None\n    for score in scores:\n        if max_score is None or score > max_score:\n            max_score = score\n\n    exp_scores = []\n    total_sum = 0.0\n    for score in scores:\n        x = math.exp(score - max_score)\n        exp_scores.append(x)\n        total_sum += x\n\n    probs = []\n    for score in exp_scores:\n        probs.append(score / total_sum)\n    return probs\n'"
baselines/models_pytorch/mrc_pytorch/preprocess/DRCD_preprocess.py,0,"b'import collections\nimport copy\nimport json\nimport os\n\nfrom tqdm import tqdm\n\nfrom tools.langconv import Converter\n\nSPIECE_UNDERLINE = \'\xe2\x96\x81\'\n\ndef whitespace_tokenize(text):\n    """"""Runs basic whitespace cleaning and splitting on a peice of text.""""""\n    text = text.strip()\n    if not text:\n        return []\n    tokens = text.split()\n    return tokens\n\n\ndef _improve_answer_span(doc_tokens, input_start, input_end, tokenizer,\n                         orig_answer_text):\n    """"""Returns tokenized answer spans that better match the annotated answer.""""""\n\n    # The SQuAD annotations are character based. We first project them to\n    # whitespace-tokenized words. But then after WordPiece tokenization, we can\n    # often find a ""better match"". For example:\n    #\n    #   Question: What year was John Smith born?\n    #   Context: The leader was John Smith (1895-1943).\n    #   Answer: 1895\n    #\n    # The original whitespace-tokenized answer will be ""(1895-1943)."". However\n    # after tokenization, our tokens will be ""( 1895 - 1943 ) ."". So we can match\n    # the exact answer, 1895.\n    #\n    # However, this is not always possible. Consider the following:\n    #\n    #   Question: What country is the top exporter of electornics?\n    #   Context: The Japanese electronics industry is the lagest in the world.\n    #   Answer: Japan\n    #\n    # In this case, the annotator chose ""Japan"" as a character sub-span of\n    # the word ""Japanese"". Since our WordPiece tokenizer does not split\n    # ""Japanese"", we just use ""Japanese"" as the annotation. This is fairly rare\n    # in SQuAD, but does happen.\n    tok_answer_text = "" "".join(tokenizer.tokenize(orig_answer_text))\n\n    for new_start in range(input_start, input_end + 1):\n        for new_end in range(input_end, new_start - 1, -1):\n            text_span = "" "".join(doc_tokens[new_start:(new_end + 1)])\n            if text_span == tok_answer_text:\n                return (new_start, new_end)\n\n    return (input_start, input_end)\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n    """"""Check if this is the \'max context\' doc span for the token.""""""\n\n    # Because of the sliding window approach taken to scoring documents, a single\n    # token can appear in multiple documents. E.g.\n    #  Doc: the man went to the store and bought a gallon of milk\n    #  Span A: the man went to the\n    #  Span B: to the store and bought\n    #  Span C: and bought a gallon of\n    #  ...\n    #\n    # Now the word \'bought\' will have two scores from spans B and C. We only\n    # want to consider the score with ""maximum context"", which we define as\n    # the *minimum* of its left and right context (the *sum* of left and\n    # right context will always be the same, of course).\n    #\n    # In the example the maximum context for \'bought\' would be span C since\n    # it has 1 left context and 3 right context, while span B has 4 left context\n    # and 0 right context.\n    best_score = None\n    best_span_index = None\n    for (span_index, doc_span) in enumerate(doc_spans):\n        end = doc_span.start + doc_span.length - 1\n        if position < doc_span.start:\n            continue\n        if position > end:\n            continue\n        num_left_context = position - doc_span.start\n        num_right_context = end - position\n        score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n        if best_score is None or score > best_score:\n            best_score = score\n            best_span_index = span_index\n\n    return cur_span_index == best_span_index\n\n\ndef Traditional2Simplified(sentence):\n    \'\'\'\n    \xe5\xb0\x86sentence\xe4\xb8\xad\xe7\x9a\x84\xe7\xb9\x81\xe4\xbd\x93\xe5\xad\x97\xe8\xbd\xac\xe4\xb8\xba\xe7\xae\x80\xe4\xbd\x93\xe5\xad\x97\n    :param sentence: \xe5\xbe\x85\xe8\xbd\xac\xe6\x8d\xa2\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\n    :return: \xe5\xb0\x86\xe5\x8f\xa5\xe5\xad\x90\xe4\xb8\xad\xe7\xb9\x81\xe4\xbd\x93\xe5\xad\x97\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba\xe7\xae\x80\xe4\xbd\x93\xe5\xad\x97\xe4\xb9\x8b\xe5\x90\x8e\xe7\x9a\x84\xe5\x8f\xa5\xe5\xad\x90\n    \'\'\'\n    sentence = Converter(\'zh-hans\').convert(sentence)\n    return sentence\n\n\ndef json2features(input_file, output_files, tokenizer, is_training=False, max_query_length=64,\n                  max_seq_length=512, doc_stride=128):\n    with open(input_file, \'r\') as f:\n        train_data = json.load(f)\n        train_data = train_data[\'data\']\n\n    def _is_chinese_char(cp):\n        if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n                (cp >= 0x3400 and cp <= 0x4DBF) or  #\n                (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n                (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n                (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n                (cp >= 0x2B820 and cp <= 0x2CEAF) or\n                (cp >= 0xF900 and cp <= 0xFAFF) or  #\n                (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n            return True\n\n        return False\n\n    def is_fuhao(c):\n        if c == \'\xe3\x80\x82\' or c == \'\xef\xbc\x8c\' or c == \'\xef\xbc\x81\' or c == \'\xef\xbc\x9f\' or c == \'\xef\xbc\x9b\' or c == \'\xe3\x80\x81\' or c == \'\xef\xbc\x9a\' or c == \'\xef\xbc\x88\' or c == \'\xef\xbc\x89\' \\\n                or c == \'\xef\xbc\x8d\' or c == \'~\' or c == \'\xe3\x80\x8c\' or c == \'\xe3\x80\x8a\' or c == \'\xe3\x80\x8b\' or c == \',\' or c == \'\xe3\x80\x8d\' or c == \'""\' or c == \'\xe2\x80\x9c\' or c == \'\xe2\x80\x9d\' \\\n                or c == \'$\' or c == \'\xe3\x80\x8e\' or c == \'\xe3\x80\x8f\' or c == \'\xe2\x80\x94\' or c == \';\' or c == \'\xe3\x80\x82\' or c == \'(\' or c == \')\' or c == \'-\' or c == \'\xef\xbd\x9e\' or c == \'\xe3\x80\x82\' \\\n                or c == \'\xe2\x80\x98\' or c == \'\xe2\x80\x99\' or c == \'\xe2\x94\x80\' or c == \':\':\n            return True\n        return False\n\n    def _tokenize_chinese_chars(text):\n        """"""Adds whitespace around any CJK character.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if _is_chinese_char(cp) or is_fuhao(char):\n                if len(output) > 0 and output[-1] != SPIECE_UNDERLINE:\n                    output.append(SPIECE_UNDERLINE)\n                output.append(char)\n                output.append(SPIECE_UNDERLINE)\n            else:\n                output.append(char)\n        return """".join(output)\n\n    def is_whitespace(c):\n        if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F or c == SPIECE_UNDERLINE:\n            return True\n        return False\n\n    # to examples\n    examples = []\n    mis_match = 0\n    for article in tqdm(train_data):\n        for para in article[\'paragraphs\']:\n            context = copy.deepcopy(para[\'context\'])\n            # \xe8\xbd\xac\xe7\xae\x80\xe4\xbd\x93\n            context = Traditional2Simplified(context)\n            # context\xe4\xb8\xad\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe5\x89\x8d\xe5\x90\x8e\xe5\x8a\xa0\xe5\x85\xa5\xe7\xa9\xba\xe6\xa0\xbc\n            context_chs = _tokenize_chinese_chars(context)\n            context_fhs = _tokenize_chinese_chars(para[\'context\'])\n\n            doc_tokens = []\n            ori_doc_tokens = []\n            char_to_word_offset = []\n            prev_is_whitespace = True\n\n            for ic, c in enumerate(context_chs):\n                if is_whitespace(c):\n                    prev_is_whitespace = True\n                else:\n                    if prev_is_whitespace:\n                        doc_tokens.append(c)\n                        ori_doc_tokens.append(context_fhs[ic])\n                    else:\n                        doc_tokens[-1] += c\n                        ori_doc_tokens[-1] += context_fhs[ic]\n                    prev_is_whitespace = False\n                if c != SPIECE_UNDERLINE:\n                    char_to_word_offset.append(len(doc_tokens) - 1)\n\n            assert len(context_chs) == len(context_fhs)\n            for qas in para[\'qas\']:\n                qid = qas[\'id\']\n                ques_text = Traditional2Simplified(qas[\'question\'])\n                ans_text = Traditional2Simplified(qas[\'answers\'][0][\'text\'])\n                start_position_final = None\n                end_position_final = None\n\n                if is_training:\n                    start_position = qas[\'answers\'][0][\'answer_start\']\n                    end_position = start_position + len(ans_text) - 1\n\n                    while context[start_position] == "" "" or context[start_position] == ""\\t"" or \\\n                            context[start_position] == ""\\r"" or context[start_position] == ""\\n"":\n                        start_position += 1\n\n                    start_position_final = char_to_word_offset[start_position]\n                    end_position_final = char_to_word_offset[end_position]\n\n                    if doc_tokens[start_position_final] in {""\xe3\x80\x82"", ""\xef\xbc\x8c"", ""\xef\xbc\x9a"", "":"", ""."", "",""}:\n                        start_position_final += 1\n                    actual_text = """".join(doc_tokens[start_position_final:(end_position_final + 1)])\n                    cleaned_answer_text = """".join(whitespace_tokenize(ans_text))\n\n                    if actual_text != cleaned_answer_text:\n                        print(actual_text, \'V.S\', cleaned_answer_text)\n                        mis_match += 1\n\n                examples.append({\'doc_tokens\': doc_tokens,\n                                 \'ori_doc_tokens\': ori_doc_tokens,\n                                 \'orig_answer_text\': ans_text,\n                                 \'qid\': qid,\n                                 \'question\': ques_text,\n                                 \'answer\': ans_text,\n                                 \'start_position\': start_position_final,\n                                 \'end_position\': end_position_final})\n\n    print(\'examples num:\', len(examples))\n    print(\'mis match:\', mis_match)\n    os.makedirs(\'/\'.join(output_files[0].split(\'/\')[0:-1]), exist_ok=True)\n    json.dump(examples, open(output_files[0], \'w\'))\n\n    # to features\n    features = []\n    unique_id = 1000000000\n    for (example_index, example) in enumerate(tqdm(examples)):\n        query_tokens = tokenizer.tokenize(example[\'question\'])\n        if len(query_tokens) > max_query_length:\n            query_tokens = query_tokens[0:max_query_length]\n\n        tok_to_orig_index = []\n        orig_to_tok_index = []\n        all_doc_tokens = []\n        for (i, token) in enumerate(example[\'doc_tokens\']):\n            orig_to_tok_index.append(len(all_doc_tokens))\n            sub_tokens = tokenizer.tokenize(token)\n            for sub_token in sub_tokens:\n                tok_to_orig_index.append(i)\n                all_doc_tokens.append(sub_token)\n\n        tok_start_position = None\n        tok_end_position = None\n        if is_training:\n            tok_start_position = orig_to_tok_index[example[\'start_position\']]  # \xe5\x8e\x9f\xe6\x9d\xa5token\xe5\x88\xb0\xe6\x96\xb0token\xe7\x9a\x84\xe6\x98\xa0\xe5\xb0\x84\xef\xbc\x8c\xe8\xbf\x99\xe6\x98\xaf\xe6\x96\xb0token\xe7\x9a\x84\xe8\xb5\xb7\xe7\x82\xb9\n            if example[\'end_position\'] < len(example[\'doc_tokens\']) - 1:\n                tok_end_position = orig_to_tok_index[example[\'end_position\'] + 1] - 1\n            else:\n                tok_end_position = len(all_doc_tokens) - 1\n            (tok_start_position, tok_end_position) = _improve_answer_span(\n                all_doc_tokens, tok_start_position, tok_end_position, tokenizer,\n                example[\'orig_answer_text\'])\n\n        # The -3 accounts for [CLS], [SEP] and [SEP]\n        max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n        doc_spans = []\n        _DocSpan = collections.namedtuple(""DocSpan"", [""start"", ""length""])\n        start_offset = 0\n        while start_offset < len(all_doc_tokens):\n            length = len(all_doc_tokens) - start_offset\n            if length > max_tokens_for_doc:\n                length = max_tokens_for_doc\n            doc_spans.append(_DocSpan(start=start_offset, length=length))\n            if start_offset + length == len(all_doc_tokens):\n                break\n            start_offset += min(length, doc_stride)\n\n        for (doc_span_index, doc_span) in enumerate(doc_spans):\n            tokens = []\n            token_to_orig_map = {}\n            token_is_max_context = {}\n            segment_ids = []\n            tokens.append(""[CLS]"")\n            segment_ids.append(0)\n            for token in query_tokens:\n                tokens.append(token)\n                segment_ids.append(0)\n            tokens.append(""[SEP]"")\n            segment_ids.append(0)\n\n            for i in range(doc_span.length):\n                split_token_index = doc_span.start + i\n                token_to_orig_map[len(tokens)] = tok_to_orig_index[split_token_index]\n                is_max_context = _check_is_max_context(doc_spans, doc_span_index, split_token_index)\n                token_is_max_context[len(tokens)] = is_max_context\n                tokens.append(all_doc_tokens[split_token_index])\n                segment_ids.append(1)\n            tokens.append(""[SEP]"")\n            segment_ids.append(1)\n\n            input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n            # The mask has 1 for real tokens and 0 for padding tokens. Only real\n            # tokens are attended to.\n            input_mask = [1] * len(input_ids)\n\n            # Zero-pad up to the sequence length.\n            while len(input_ids) < max_seq_length:\n                input_ids.append(0)\n                input_mask.append(0)\n                segment_ids.append(0)\n\n            assert len(input_ids) == max_seq_length\n            assert len(input_mask) == max_seq_length\n            assert len(segment_ids) == max_seq_length\n\n            start_position = None\n            end_position = None\n            if is_training:\n                # For training, if our document chunk does not contain an annotation\n                # we throw it out, since there is nothing to predict.\n                if tok_start_position == -1 and tok_end_position == -1:\n                    start_position = 0  # \xe9\x97\xae\xe9\xa2\x98\xe6\x9c\xac\xe6\x9d\xa5\xe6\xb2\xa1\xe7\xad\x94\xe6\xa1\x88\xef\xbc\x8c0\xe6\x98\xaf[CLS]\xe7\x9a\x84\xe4\xbd\x8d\xe5\xad\x90\n                    end_position = 0\n                else:  # \xe5\xa6\x82\xe6\x9e\x9c\xe5\x8e\x9f\xe6\x9c\xac\xe6\x98\xaf\xe6\x9c\x89\xe7\xad\x94\xe6\xa1\x88\xe7\x9a\x84\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe5\x8e\xbb\xe9\x99\xa4\xe6\xb2\xa1\xe6\x9c\x89\xe7\xad\x94\xe6\xa1\x88\xe7\x9a\x84feature\n                    out_of_span = False\n                    doc_start = doc_span.start  # \xe6\x98\xa0\xe5\xb0\x84\xe5\x9b\x9e\xe5\x8e\x9f\xe6\x96\x87\xe7\x9a\x84\xe8\xb5\xb7\xe7\x82\xb9\xe5\x92\x8c\xe7\xbb\x88\xe7\x82\xb9\n                    doc_end = doc_span.start + doc_span.length - 1\n\n                    if not (tok_start_position >= doc_start and tok_end_position <= doc_end):  # \xe8\xaf\xa5\xe5\x88\x92\xe7\xaa\x97\xe6\xb2\xa1\xe7\xad\x94\xe6\xa1\x88\xe4\xbd\x9c\xe4\xb8\xba\xe6\x97\xa0\xe7\xad\x94\xe6\xa1\x88\xe5\xa2\x9e\xe5\xbc\xba\n                        out_of_span = True\n                    if out_of_span:\n                        start_position = 0\n                        end_position = 0\n                    else:\n                        doc_offset = len(query_tokens) + 2\n                        start_position = tok_start_position - doc_start + doc_offset\n                        end_position = tok_end_position - doc_start + doc_offset\n\n            features.append({\'unique_id\': unique_id,\n                             \'example_index\': example_index,\n                             \'doc_span_index\': doc_span_index,\n                             \'tokens\': tokens,\n                             \'token_to_orig_map\': token_to_orig_map,\n                             \'token_is_max_context\': token_is_max_context,\n                             \'input_ids\': input_ids,\n                             \'input_mask\': input_mask,\n                             \'segment_ids\': segment_ids,\n                             \'start_position\': start_position,\n                             \'end_position\': end_position})\n            unique_id += 1\n\n    print(\'features num:\', len(features))\n    json.dump(features, open(output_files[1], \'w\'))\n'"
baselines/models_pytorch/mrc_pytorch/preprocess/cmrc2018_evaluate.py,0,"b'# -*- coding: utf-8 -*-\n\'\'\'\nEvaluation script for CMRC 2018\nversion: v5 - special\nNote:\nv5 - special: Evaluate on SQuAD-style CMRC 2018 Datasets\nv5: formatted output, add usage description\nv4: fixed segmentation issues\n\'\'\'\nfrom __future__ import print_function\n\nimport json\nimport re\nfrom collections import OrderedDict\n\nimport nltk\n\n\n# split Chinese with English\ndef mixed_segmentation(in_str, rm_punc=False):\n    in_str = str(in_str).lower().strip()\n    segs_out = []\n    temp_str = """"\n    sp_char = [\'-\', \':\', \'_\', \'*\', \'^\', \'/\', \'\\\\\', \'~\', \'`\', \'+\', \'=\',\n               \'\xef\xbc\x8c\', \'\xe3\x80\x82\', \'\xef\xbc\x9a\', \'\xef\xbc\x9f\', \'\xef\xbc\x81\', \'\xe2\x80\x9c\', \'\xe2\x80\x9d\', \'\xef\xbc\x9b\', \'\xe2\x80\x99\', \'\xe3\x80\x8a\', \'\xe3\x80\x8b\', \'\xe2\x80\xa6\xe2\x80\xa6\', \'\xc2\xb7\', \'\xe3\x80\x81\',\n               \'\xe3\x80\x8c\', \'\xe3\x80\x8d\', \'\xef\xbc\x88\', \'\xef\xbc\x89\', \'\xef\xbc\x8d\', \'\xef\xbd\x9e\', \'\xe3\x80\x8e\', \'\xe3\x80\x8f\']\n    for char in in_str:\n        if rm_punc and char in sp_char:\n            continue\n        if re.search(r\'[\\u4e00-\\u9fa5]\', char) or char in sp_char:\n            if temp_str != """":\n                ss = nltk.word_tokenize(temp_str)\n                segs_out.extend(ss)\n                temp_str = """"\n            segs_out.append(char)\n        else:\n            temp_str += char\n\n    # handling last part\n    if temp_str != """":\n        ss = nltk.word_tokenize(temp_str)\n        segs_out.extend(ss)\n\n    return segs_out\n\n\n# remove punctuation\ndef remove_punctuation(in_str):\n    in_str = str(in_str).lower().strip()\n    sp_char = [\'-\', \':\', \'_\', \'*\', \'^\', \'/\', \'\\\\\', \'~\', \'`\', \'+\', \'=\',\n               \'\xef\xbc\x8c\', \'\xe3\x80\x82\', \'\xef\xbc\x9a\', \'\xef\xbc\x9f\', \'\xef\xbc\x81\', \'\xe2\x80\x9c\', \'\xe2\x80\x9d\', \'\xef\xbc\x9b\', \'\xe2\x80\x99\', \'\xe3\x80\x8a\', \'\xe3\x80\x8b\', \'\xe2\x80\xa6\xe2\x80\xa6\', \'\xc2\xb7\', \'\xe3\x80\x81\',\n               \'\xe3\x80\x8c\', \'\xe3\x80\x8d\', \'\xef\xbc\x88\', \'\xef\xbc\x89\', \'\xef\xbc\x8d\', \'\xef\xbd\x9e\', \'\xe3\x80\x8e\', \'\xe3\x80\x8f\']\n    out_segs = []\n    for char in in_str:\n        if char in sp_char:\n            continue\n        else:\n            out_segs.append(char)\n    return \'\'.join(out_segs)\n\n\n# find longest common string\ndef find_lcs(s1, s2):\n    m = [[0 for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n    mmax = 0\n    p = 0\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            if s1[i] == s2[j]:\n                m[i + 1][j + 1] = m[i][j] + 1\n                if m[i + 1][j + 1] > mmax:\n                    mmax = m[i + 1][j + 1]\n                    p = i + 1\n    return s1[p - mmax:p], mmax\n\n\ndef evaluate(ground_truth_file, prediction_file):\n    f1 = 0\n    em = 0\n    total_count = 0\n    skip_count = 0\n    for instance in ground_truth_file[""data""]:\n        # context_id   = instance[\'context_id\'].strip()\n        # context_text = instance[\'context_text\'].strip()\n        for para in instance[""paragraphs""]:\n            for qas in para[\'qas\']:\n                total_count += 1\n                query_id = qas[\'id\'].strip()\n                query_text = qas[\'question\'].strip()\n                answers = [x[""text""] for x in qas[\'answers\']]\n\n                if query_id not in prediction_file:\n                    print(\'Unanswered question: {}\\n\'.format(query_id))\n                    skip_count += 1\n                    continue\n\n                prediction = str(prediction_file[query_id])\n                f1 += calc_f1_score(answers, prediction)\n                em += calc_em_score(answers, prediction)\n\n    f1_score = 100.0 * f1 / total_count\n    em_score = 100.0 * em / total_count\n    return f1_score, em_score, total_count, skip_count\n\n\ndef evaluate2(ground_truth_file, prediction_file):\n    f1 = 0\n    em = 0\n    total_count = 0\n    skip_count = 0\n    yes_count = 0\n    yes_correct = 0\n    no_count = 0\n    no_correct = 0\n    unk_count = 0\n    unk_correct = 0\n\n    for instance in ground_truth_file[""data""]:\n        for para in instance[""paragraphs""]:\n            for qas in para[\'qas\']:\n                total_count += 1\n                query_id = qas[\'id\'].strip()\n                if query_id not in prediction_file:\n                    print(\'Unanswered question: {}\\n\'.format(query_id))\n                    skip_count += 1\n                    continue\n\n                prediction = str(prediction_file[query_id])\n\n                if len(qas[\'answers\']) == 0:\n                    unk_count += 1\n                    answers = [""""]\n                    if prediction == """":\n                        unk_correct += 1\n                else:\n                    answers = []\n                    for x in qas[\'answers\']:\n                        answers.append(x[\'text\'])\n                        if x[\'text\'] == \'YES\':\n                            if prediction == \'YES\':\n                                yes_correct += 1\n                            yes_count += 1\n                        if x[\'text\'] == \'NO\':\n                            if prediction == \'NO\':\n                                no_correct += 1\n                            no_count += 1\n\n                f1 += calc_f1_score(answers, prediction)\n                em += calc_em_score(answers, prediction)\n\n    f1_score = 100.0 * f1 / total_count\n    em_score = 100.0 * em / total_count\n    yes_acc = 100.0 * yes_correct / yes_count\n    no_acc = 100.0 * no_correct / no_count\n    unk_acc = 100.0 * unk_correct / unk_count\n    return f1_score, em_score, yes_acc, no_acc, unk_acc, total_count, skip_count\n\n\ndef calc_f1_score(answers, prediction):\n    f1_scores = []\n    for ans in answers:\n        ans_segs = mixed_segmentation(ans, rm_punc=True)\n        prediction_segs = mixed_segmentation(prediction, rm_punc=True)\n        lcs, lcs_len = find_lcs(ans_segs, prediction_segs)\n        if lcs_len == 0:\n            f1_scores.append(0)\n            continue\n        precision = 1.0 * lcs_len / len(prediction_segs)\n        recall = 1.0 * lcs_len / len(ans_segs)\n        f1 = (2 * precision * recall) / (precision + recall)\n        f1_scores.append(f1)\n    return max(f1_scores)\n\n\ndef calc_em_score(answers, prediction):\n    em = 0\n    for ans in answers:\n        ans_ = remove_punctuation(ans)\n        prediction_ = remove_punctuation(prediction)\n        if ans_ == prediction_:\n            em = 1\n            break\n    return em\n\n\ndef get_eval(original_file, prediction_file):\n    ground_truth_file = json.load(open(original_file, \'r\'))\n    prediction_file = json.load(open(prediction_file, \'r\'))\n    F1, EM, TOTAL, SKIP = evaluate(ground_truth_file, prediction_file)\n    AVG = (EM + F1) * 0.5\n    output_result = OrderedDict()\n    output_result[\'AVERAGE\'] = \'%.3f\' % AVG\n    output_result[\'F1\'] = \'%.3f\' % F1\n    output_result[\'EM\'] = \'%.3f\' % EM\n    output_result[\'TOTAL\'] = TOTAL\n    output_result[\'SKIP\'] = SKIP\n\n    return output_result\n\n\ndef get_eval_with_neg(original_file, prediction_file):\n    ground_truth_file = json.load(open(original_file, \'r\'))\n    prediction_file = json.load(open(prediction_file, \'r\'))\n    F1, EM, YES_ACC, NO_ACC, UNK_ACC, TOTAL, SKIP = evaluate2(ground_truth_file, prediction_file)\n    AVG = (EM + F1) * 0.5\n    output_result = OrderedDict()\n    output_result[\'AVERAGE\'] = \'%.3f\' % AVG\n    output_result[\'F1\'] = \'%.3f\' % F1\n    output_result[\'EM\'] = \'%.3f\' % EM\n    output_result[\'YES\'] = \'%.3f\' % YES_ACC\n    output_result[\'NO\'] = \'%.3f\' % NO_ACC\n    output_result[\'UNK\'] = \'%.3f\' % UNK_ACC\n    output_result[\'TOTAL\'] = TOTAL\n    output_result[\'SKIP\'] = SKIP\n\n    return output_result\n'"
baselines/models_pytorch/mrc_pytorch/preprocess/cmrc2018_output.py,0,"b'import collections\nimport json\nimport math\n\nfrom tqdm import tqdm\n\nfrom tools.official_tokenization import BasicTokenizer\n\n\ndef write_predictions_topk(FLAGS, all_examples, all_features, all_results, n_best_size,\n                           max_answer_length, output_prediction_file, output_nbest_file):\n    _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""PrelimPrediction"",\n        [""feature_index"", ""start_index"", ""end_index"",\n         ""start_log_prob"", ""end_log_prob""])\n\n    _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""NbestPrediction"", [""text"", ""start_log_prob"", ""end_log_prob""])\n\n    """"""Write final predictions to the json file and log-odds of null if needed.""""""\n    print(""Writing predictions to: %s"" % (output_prediction_file))\n\n    example_index_to_features = collections.defaultdict(list)\n    for feature in all_features:\n        example_index_to_features[feature[\'example_index\']].append(feature)\n\n    unique_id_to_result = {}\n    for result in all_results:\n        unique_id_to_result[result.unique_id] = result\n\n    all_predictions = collections.OrderedDict()\n    all_nbest_json = collections.OrderedDict()\n    scores_diff_json = collections.OrderedDict()\n\n    for (example_index, example) in enumerate(all_examples):\n        features = example_index_to_features[example_index]\n\n        prelim_predictions = []\n        # keep track of the minimum score of null start+end of position 0\n        score_null = 1000000  # large and positive\n\n        for (feature_index, feature) in enumerate(features):\n            result = unique_id_to_result[feature[\'unique_id\']]\n\n            cur_null_score = result.cls_logits\n\n            # if we could have irrelevant answers, get the min score of irrelevant\n            score_null = min(score_null, cur_null_score)\n\n            for i in range(FLAGS.start_n_top):\n                for j in range(FLAGS.end_n_top):\n                    start_log_prob = result.start_top_log_probs[i]\n                    start_index = result.start_top_index[i]\n\n                    j_index = i * FLAGS.end_n_top + j\n\n                    end_log_prob = result.end_top_log_probs[j_index]\n                    end_index = result.end_top_index[j_index]\n\n                    # We could hypothetically create invalid predictions, e.g., predict\n                    # that the start of the span is in the question. We throw out all\n                    # invalid predictions.\n                    if start_index >= feature[\'paragraph_len\'] - 1:\n                        continue\n                    if end_index >= feature[\'paragraph_len\'] - 1:\n                        continue\n\n                    if not feature[\'token_is_max_context\'].get(start_index, False) and \\\n                            not feature[\'token_is_max_context\'].get(str(start_index), False):\n                        continue\n                    if end_index < start_index:\n                        continue\n                    length = end_index - start_index + 1\n                    if length > max_answer_length:\n                        continue\n\n                    prelim_predictions.append(\n                        _PrelimPrediction(\n                            feature_index=feature_index,\n                            start_index=start_index,\n                            end_index=end_index,\n                            start_log_prob=start_log_prob,\n                            end_log_prob=end_log_prob))\n\n        prelim_predictions = sorted(\n            prelim_predictions,\n            key=lambda x: (x.start_log_prob + x.end_log_prob),\n            reverse=True)\n\n        seen_predictions = {}\n        nbest = []\n        for pred in prelim_predictions:\n            if len(nbest) >= n_best_size:\n                break\n            feature = features[pred.feature_index]\n\n            tok_start_to_orig_index = feature[\'tok_start_to_orig_index\']\n            tok_end_to_orig_index = feature[\'tok_end_to_orig_index\']\n            start_orig_pos = tok_start_to_orig_index[pred.start_index]\n            end_orig_pos = tok_end_to_orig_index[pred.end_index]\n\n            paragraph_text = example[\'paragraph_text\']\n            final_text = paragraph_text[start_orig_pos: end_orig_pos + 1].strip()\n\n            if final_text in seen_predictions:\n                continue\n\n            seen_predictions[final_text] = True\n\n            nbest.append(\n                _NbestPrediction(\n                    text=final_text,\n                    start_log_prob=pred.start_log_prob,\n                    end_log_prob=pred.end_log_prob))\n\n        # In very rare edge cases we could have no valid predictions. So we\n        # just create a nonce prediction in this case to avoid failure.\n        if not nbest:\n            nbest.append(\n                _NbestPrediction(text="""", start_log_prob=-1e6,\n                                 end_log_prob=-1e6))\n\n        total_scores = []\n        best_non_null_entry = None\n        for entry in nbest:\n            total_scores.append(entry.start_log_prob + entry.end_log_prob)\n            if not best_non_null_entry:\n                best_non_null_entry = entry\n\n        probs = _compute_softmax(total_scores)\n\n        nbest_json = []\n        for (i, entry) in enumerate(nbest):\n            output = collections.OrderedDict()\n            output[""text""] = entry.text\n            output[""probability""] = probs[i]\n            output[""start_log_prob""] = entry.start_log_prob\n            output[""end_log_prob""] = entry.end_log_prob\n            nbest_json.append(output)\n\n        assert len(nbest_json) >= 1\n        assert best_non_null_entry is not None\n\n        score_diff = score_null\n        scores_diff_json[example[\'qas_id\']] = score_diff\n        # note(zhiliny): always predict best_non_null_entry\n        # and the evaluation script will search for the best threshold\n        all_predictions[example[\'qas_id\']] = best_non_null_entry.text\n\n        all_nbest_json[example[\'qas_id\']] = nbest_json\n\n    with open(output_prediction_file, ""w"") as writer:\n        writer.write(json.dumps(all_predictions, indent=4, ensure_ascii=False) + ""\\n"")\n\n    with open(output_nbest_file, ""w"") as writer:\n        writer.write(json.dumps(all_nbest_json, indent=4, ensure_ascii=False) + ""\\n"")\n\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, do_lower_case, output_prediction_file,\n                      output_nbest_file, version_2_with_negative=False, null_score_diff_threshold=0.):\n    """"""Write final predictions to the json file and log-odds of null if needed.""""""\n    print(""Writing predictions to: %s"" % (output_prediction_file))\n    print(""Writing nbest to: %s"" % (output_nbest_file))\n\n    example_index_to_features = collections.defaultdict(list)\n    for feature in all_features:\n        example_index_to_features[feature[\'example_index\']].append(feature)\n\n    unique_id_to_result = {}\n    for result in all_results:\n        unique_id_to_result[result.unique_id] = result\n\n    _PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n        ""PrelimPrediction"",\n        [""feature_index"", ""start_index"", ""end_index"", ""start_logit"", ""end_logit""])\n\n    all_predictions = collections.OrderedDict()\n    all_nbest_json = collections.OrderedDict()\n    scores_diff_json = collections.OrderedDict()\n\n    for (example_index, example) in enumerate(tqdm(all_examples)):\n        features = example_index_to_features[example_index]\n        prelim_predictions = []\n        # keep track of the minimum score of null start+end of position 0\n        score_null = 1000000  # large and positive\n        min_null_feature_index = 0  # the paragraph slice with min null score\n        null_start_logit = 0  # the start logit at the slice with min null score\n        null_end_logit = 0  # the end logit at the slice with min null score\n        for (feature_index, feature) in enumerate(features):\n            result = unique_id_to_result[feature[\'unique_id\']]\n            start_indexes = _get_best_indexes(result.start_logits, n_best_size)\n            end_indexes = _get_best_indexes(result.end_logits, n_best_size)\n            # if we could have irrelevant answers, get the min score of irrelevant\n            if version_2_with_negative:\n                feature_null_score = result.start_logits[0] + result.end_logits[0]\n                if feature_null_score < score_null:\n                    score_null = feature_null_score\n                    min_null_feature_index = feature_index\n                    null_start_logit = result.start_logits[0]\n                    null_end_logit = result.end_logits[0]\n            for start_index in start_indexes:\n                for end_index in end_indexes:\n                    # We could hypothetically create invalid predictions, e.g., predict\n                    # that the start of the span is in the question. We throw out all\n                    # invalid predictions.\n                    if start_index >= len(feature[\'tokens\']):\n                        continue\n                    if end_index >= len(feature[\'tokens\']):\n                        continue\n                    if str(start_index) not in feature[\'token_to_orig_map\'] and \\\n                            start_index not in feature[\'token_to_orig_map\']:\n                        continue\n                    if str(end_index) not in feature[\'token_to_orig_map\'] and \\\n                            end_index not in feature[\'token_to_orig_map\']:\n                        continue\n                    if not feature[\'token_is_max_context\'].get(str(start_index), False):\n                        continue\n                    if end_index < start_index:\n                        continue\n                    length = end_index - start_index + 1\n                    if length > max_answer_length:\n                        continue\n                    prelim_predictions.append(\n                        _PrelimPrediction(\n                            feature_index=feature_index,\n                            start_index=start_index,\n                            end_index=end_index,\n                            start_logit=result.start_logits[start_index],\n                            end_logit=result.end_logits[end_index]))\n        if version_2_with_negative:\n            prelim_predictions.append(\n                _PrelimPrediction(\n                    feature_index=min_null_feature_index,\n                    start_index=0,\n                    end_index=0,\n                    start_logit=null_start_logit,\n                    end_logit=null_end_logit))\n        prelim_predictions = sorted(\n            prelim_predictions,\n            key=lambda x: (x.start_logit + x.end_logit),\n            reverse=True)\n\n        _NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n            ""NbestPrediction"", [""text"", ""start_logit"", ""end_logit""])\n\n        seen_predictions = {}\n        nbest = []\n        for pred in prelim_predictions:\n            if len(nbest) >= n_best_size:\n                break\n            feature = features[pred.feature_index]\n            if pred.start_index > 0:  # this is a non-null prediction\n                tok_tokens = feature[\'tokens\'][pred.start_index:(pred.end_index + 1)]\n                orig_doc_start = feature[\'token_to_orig_map\'][str(pred.start_index)]\n                orig_doc_end = feature[\'token_to_orig_map\'][str(pred.end_index)]\n                orig_tokens = example[\'doc_tokens\'][orig_doc_start:(orig_doc_end + 1)]\n                tok_text = """".join(tok_tokens)\n\n                # De-tokenize WordPieces that have been split off.\n                tok_text = tok_text.replace("" ##"", """")\n                tok_text = tok_text.replace(""##"", """")\n\n                # Clean whitespace\n                tok_text = tok_text.strip()\n                tok_text = "" "".join(tok_text.split())\n                orig_text = """".join(orig_tokens)\n\n                final_text = get_final_text(tok_text, orig_text, do_lower_case)\n                if final_text in seen_predictions:\n                    continue\n\n                seen_predictions[final_text] = True\n            else:\n                final_text = """"\n                seen_predictions[final_text] = True\n\n            nbest.append(\n                _NbestPrediction(\n                    text=final_text,\n                    start_logit=pred.start_logit,\n                    end_logit=pred.end_logit))\n        # if we didn\'t include the empty option in the n-best, include it\n        if version_2_with_negative:\n            if """" not in seen_predictions:\n                nbest.append(\n                    _NbestPrediction(\n                        text="""",\n                        start_logit=null_start_logit,\n                        end_logit=null_end_logit))\n\n            # In very rare edge cases we could only have single null prediction.\n            # So we just create a nonce prediction in this case to avoid failure.\n            if len(nbest) == 1:\n                nbest.insert(0, _NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n        # In very rare edge cases we could have no valid predictions. So we\n        # just create a nonce prediction in this case to avoid failure.\n        if not nbest:\n            nbest.append(_NbestPrediction(text=""empty"", start_logit=0.0, end_logit=0.0))\n\n        assert len(nbest) >= 1\n\n        total_scores = []\n        best_non_null_entry = None\n        for entry in nbest:\n            total_scores.append(entry.start_logit + entry.end_logit)\n            if not best_non_null_entry:\n                if entry.text:\n                    best_non_null_entry = entry\n\n        probs = _compute_softmax(total_scores)\n\n        nbest_json = []\n        for (i, entry) in enumerate(nbest):\n            output = collections.OrderedDict()\n            output[""text""] = entry.text\n            output[""probability""] = float(probs[i])\n            output[""start_logit""] = float(entry.start_logit)\n            output[""end_logit""] = float(entry.end_logit)\n            nbest_json.append(output)\n\n        assert len(nbest_json) >= 1\n\n        if not version_2_with_negative:\n            all_predictions[example[\'qid\']] = nbest_json[0][""text""]\n            all_nbest_json[example[\'qid\']] = nbest_json\n        else:\n            # predict """" iff the null score - the score of best non-null > threshold\n            score_diff = score_null - best_non_null_entry.start_logit - (best_non_null_entry.end_logit)\n            scores_diff_json[example[\'qid\']] = score_diff\n            if score_diff > null_score_diff_threshold:\n                all_predictions[example[\'qid\']] = """"\n            else:\n                all_predictions[example[\'qid\']] = best_non_null_entry.text\n            all_nbest_json[example[\'qid\']] = nbest_json\n\n    with open(output_prediction_file, ""w"") as writer:\n        writer.write(json.dumps(all_predictions, indent=4, ensure_ascii=False) + ""\\n"")\n\n    with open(output_nbest_file, ""w"") as writer:\n        writer.write(json.dumps(all_nbest_json, indent=4, ensure_ascii=False) + ""\\n"")\n\n\ndef get_final_text(pred_text, orig_text, do_lower_case, verbose_logging=False):\n    """"""Project the tokenized prediction back to the original text.""""""\n\n    # When we created the data, we kept track of the alignment between original\n    # (whitespace tokenized) tokens and our WordPiece tokenized tokens. So\n    # now `orig_text` contains the span of our original text corresponding to the\n    # span that we predicted.\n    #\n    # However, `orig_text` may contain extra characters that we don\'t want in\n    # our prediction.\n    #\n    # For example, let\'s say:\n    #   pred_text = steve smith\n    #   orig_text = Steve Smith\'s\n    #\n    # We don\'t want to return `orig_text` because it contains the extra ""\'s"".\n    #\n    # We don\'t want to return `pred_text` because it\'s already been normalized\n    # (the SQuAD eval script also does punctuation stripping/lower casing but\n    # our tokenizer does additional normalization like stripping accent\n    # characters).\n    #\n    # What we really want to return is ""Steve Smith"".\n    #\n    # Therefore, we have to apply a semi-complicated alignment heuristic between\n    # `pred_text` and `orig_text` to get a character-to-character alignment. This\n    # can fail in certain cases in which case we just return `orig_text`.\n\n    def _strip_spaces(text):\n        ns_chars = []\n        ns_to_s_map = collections.OrderedDict()\n        for (i, c) in enumerate(text):\n            if c == "" "":\n                continue\n            ns_to_s_map[len(ns_chars)] = i\n            ns_chars.append(c)\n        ns_text = """".join(ns_chars)\n        return (ns_text, ns_to_s_map)\n\n    # We first tokenize `orig_text`, strip whitespace from the result\n    # and `pred_text`, and check if they are the same length. If they are\n    # NOT the same length, the heuristic has failed. If they are the same\n    # length, we assume the characters are one-to-one aligned.\n    tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n\n    tok_text = """".join(tokenizer.tokenize(orig_text))\n\n    start_position = tok_text.find(pred_text)\n    if start_position == -1:\n        if verbose_logging:\n            print(""Unable to find text: \'%s\' in \'%s\'"" % (pred_text, orig_text))\n        return orig_text\n    end_position = start_position + len(pred_text) - 1\n\n    (orig_ns_text, orig_ns_to_s_map) = _strip_spaces(orig_text)\n    (tok_ns_text, tok_ns_to_s_map) = _strip_spaces(tok_text)\n\n    if len(orig_ns_text) != len(tok_ns_text):\n        if verbose_logging:\n            print(""Length not equal after stripping spaces: \'%s\' vs \'%s\'"" % (orig_ns_text, tok_ns_text))\n        return orig_text\n\n    # We then project the characters in `pred_text` back to `orig_text` using\n    # the character-to-character alignment.\n    tok_s_to_ns_map = {}\n    for (i, tok_index) in tok_ns_to_s_map.items():\n        tok_s_to_ns_map[tok_index] = i\n\n    orig_start_position = None\n    if start_position in tok_s_to_ns_map:\n        ns_start_position = tok_s_to_ns_map[start_position]\n        if ns_start_position in orig_ns_to_s_map:\n            orig_start_position = orig_ns_to_s_map[ns_start_position]\n\n    if orig_start_position is None:\n        if verbose_logging:\n            print(""Couldn\'t map start position"")\n        return orig_text\n\n    orig_end_position = None\n    if end_position in tok_s_to_ns_map:\n        ns_end_position = tok_s_to_ns_map[end_position]\n        if ns_end_position in orig_ns_to_s_map:\n            orig_end_position = orig_ns_to_s_map[ns_end_position]\n\n    if orig_end_position is None:\n        if verbose_logging:\n            print(""Couldn\'t map end position"")\n        return orig_text\n\n    output_text = orig_text[orig_start_position:(orig_end_position + 1)]\n    return output_text\n\n\ndef _get_best_indexes(logits, n_best_size):\n    """"""Get the n-best logits from a list.""""""\n    index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n    best_indexes = []\n    for i in range(len(index_and_score)):\n        if i >= n_best_size:\n            break\n        best_indexes.append(index_and_score[i][0])\n    return best_indexes\n\n\ndef _compute_softmax(scores):\n    """"""Compute softmax probability over raw logits.""""""\n    if not scores:\n        return []\n\n    max_score = None\n    for score in scores:\n        if max_score is None or score > max_score:\n            max_score = score\n\n    exp_scores = []\n    total_sum = 0.0\n    for score in scores:\n        x = math.exp(score - max_score)\n        exp_scores.append(x)\n        total_sum += x\n\n    probs = []\n    for score in exp_scores:\n        probs.append(score / total_sum)\n    return probs\n'"
baselines/models_pytorch/mrc_pytorch/preprocess/cmrc2018_preprocess.py,0,"b'import collections\nimport json\nimport os\n\nfrom tqdm import tqdm\n\nfrom tools import official_tokenization as tokenization\n\nSPIECE_UNDERLINE = \'\xe2\x96\x81\'\n\n\ndef _improve_answer_span(doc_tokens, input_start, input_end, tokenizer,\n                         orig_answer_text):\n    """"""Returns tokenized answer spans that better match the annotated answer.""""""\n\n    # The SQuAD annotations are character based. We first project them to\n    # whitespace-tokenized words. But then after WordPiece tokenization, we can\n    # often find a ""better match"". For example:\n    #\n    #   Question: What year was John Smith born?\n    #   Context: The leader was John Smith (1895-1943).\n    #   Answer: 1895\n    #\n    # The original whitespace-tokenized answer will be ""(1895-1943)."". However\n    # after tokenization, our tokens will be ""( 1895 - 1943 ) ."". So we can match\n    # the exact answer, 1895.\n    #\n    # However, this is not always possible. Consider the following:\n    #\n    #   Question: What country is the top exporter of electornics?\n    #   Context: The Japanese electronics industry is the lagest in the world.\n    #   Answer: Japan\n    #\n    # In this case, the annotator chose ""Japan"" as a character sub-span of\n    # the word ""Japanese"". Since our WordPiece tokenizer does not split\n    # ""Japanese"", we just use ""Japanese"" as the annotation. This is fairly rare\n    # in SQuAD, but does happen.\n    tok_answer_text = "" "".join(tokenizer.tokenize(orig_answer_text))\n\n    for new_start in range(input_start, input_end + 1):\n        for new_end in range(input_end, new_start - 1, -1):\n            text_span = "" "".join(doc_tokens[new_start:(new_end + 1)])\n            if text_span == tok_answer_text:\n                return (new_start, new_end)\n\n    return (input_start, input_end)\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n    """"""Check if this is the \'max context\' doc span for the token.""""""\n\n    # Because of the sliding window approach taken to scoring documents, a single\n    # token can appear in multiple documents. E.g.\n    #  Doc: the man went to the store and bought a gallon of milk\n    #  Span A: the man went to the\n    #  Span B: to the store and bought\n    #  Span C: and bought a gallon of\n    #  ...\n    #\n    # Now the word \'bought\' will have two scores from spans B and C. We only\n    # want to consider the score with ""maximum context"", which we define as\n    # the *minimum* of its left and right context (the *sum* of left and\n    # right context will always be the same, of course).\n    #\n    # In the example the maximum context for \'bought\' would be span C since\n    # it has 1 left context and 3 right context, while span B has 4 left context\n    # and 0 right context.\n    best_score = None\n    best_span_index = None\n    for (span_index, doc_span) in enumerate(doc_spans):\n        end = doc_span.start + doc_span.length - 1\n        if position < doc_span.start:\n            continue\n        if position > end:\n            continue\n        num_left_context = position - doc_span.start\n        num_right_context = end - position\n        score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n        if best_score is None or score > best_score:\n            best_score = score\n            best_span_index = span_index\n\n    return cur_span_index == best_span_index\n\n\ndef json2features(input_file, output_files, tokenizer, is_training=False, repeat_limit=3, max_query_length=64,\n                  max_seq_length=512, doc_stride=128):\n    with open(input_file, \'r\') as f:\n        train_data = json.load(f)\n        train_data = train_data[\'data\']\n\n    def _is_chinese_char(cp):\n        if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n                (cp >= 0x3400 and cp <= 0x4DBF) or  #\n                (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n                (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n                (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n                (cp >= 0x2B820 and cp <= 0x2CEAF) or\n                (cp >= 0xF900 and cp <= 0xFAFF) or  #\n                (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n            return True\n\n        return False\n\n    def is_fuhao(c):\n        if c == \'\xe3\x80\x82\' or c == \'\xef\xbc\x8c\' or c == \'\xef\xbc\x81\' or c == \'\xef\xbc\x9f\' or c == \'\xef\xbc\x9b\' or c == \'\xe3\x80\x81\' or c == \'\xef\xbc\x9a\' or c == \'\xef\xbc\x88\' or c == \'\xef\xbc\x89\' \\\n                or c == \'\xef\xbc\x8d\' or c == \'~\' or c == \'\xe3\x80\x8c\' or c == \'\xe3\x80\x8a\' or c == \'\xe3\x80\x8b\' or c == \',\' or c == \'\xe3\x80\x8d\' or c == \'""\' or c == \'\xe2\x80\x9c\' or c == \'\xe2\x80\x9d\' \\\n                or c == \'$\' or c == \'\xe3\x80\x8e\' or c == \'\xe3\x80\x8f\' or c == \'\xe2\x80\x94\' or c == \';\' or c == \'\xe3\x80\x82\' or c == \'(\' or c == \')\' or c == \'-\' or c == \'\xef\xbd\x9e\' or c == \'\xe3\x80\x82\' \\\n                or c == \'\xe2\x80\x98\' or c == \'\xe2\x80\x99\':\n            return True\n        return False\n\n    def _tokenize_chinese_chars(text):\n        """"""Adds whitespace around any CJK character.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if _is_chinese_char(cp) or is_fuhao(char):\n                if len(output) > 0 and output[-1] != SPIECE_UNDERLINE:\n                    output.append(SPIECE_UNDERLINE)\n                output.append(char)\n                output.append(SPIECE_UNDERLINE)\n            else:\n                output.append(char)\n        return """".join(output)\n\n    def is_whitespace(c):\n        if c == "" "" or c == ""\\t"" or c == ""\\r"" or c == ""\\n"" or ord(c) == 0x202F or c == SPIECE_UNDERLINE:\n            return True\n        return False\n\n    # to examples\n    examples = []\n    mis_match = 0\n    for article in tqdm(train_data):\n        for para in article[\'paragraphs\']:\n            context = para[\'context\']\n            context_chs = _tokenize_chinese_chars(context)\n            doc_tokens = []\n            char_to_word_offset = []\n            prev_is_whitespace = True\n            for c in context_chs:\n                if is_whitespace(c):\n                    prev_is_whitespace = True\n                else:\n                    if prev_is_whitespace:\n                        doc_tokens.append(c)\n                    else:\n                        doc_tokens[-1] += c\n                    prev_is_whitespace = False\n                if c != SPIECE_UNDERLINE:\n                    char_to_word_offset.append(len(doc_tokens) - 1)\n\n            for qas in para[\'qas\']:\n                qid = qas[\'id\']\n                ques_text = qas[\'question\']\n                ans_text = qas[\'answers\'][0][\'text\']\n\n                start_position_final = None\n                end_position_final = None\n                if is_training:\n                    count_i = 0\n                    start_position = qas[\'answers\'][0][\'answer_start\']\n\n                    end_position = start_position + len(ans_text) - 1\n                    while context[start_position:end_position + 1] != ans_text and count_i < repeat_limit:\n                        start_position -= 1\n                        end_position -= 1\n                        count_i += 1\n\n                    while context[start_position] == "" "" or context[start_position] == ""\\t"" or \\\n                            context[start_position] == ""\\r"" or context[start_position] == ""\\n"":\n                        start_position += 1\n\n                    start_position_final = char_to_word_offset[start_position]\n                    end_position_final = char_to_word_offset[end_position]\n\n                    if doc_tokens[start_position_final] in {""\xe3\x80\x82"", ""\xef\xbc\x8c"", ""\xef\xbc\x9a"", "":"", ""."", "",""}:\n                        start_position_final += 1\n\n                    actual_text = """".join(doc_tokens[start_position_final:(end_position_final + 1)])\n                    cleaned_answer_text = """".join(tokenization.whitespace_tokenize(ans_text))\n\n                    if actual_text != cleaned_answer_text:\n                        print(actual_text, \'V.S\', cleaned_answer_text)\n                        mis_match += 1\n                        # ipdb.set_trace()\n\n                examples.append({\'doc_tokens\': doc_tokens,\n                                 \'orig_answer_text\': ans_text,\n                                 \'qid\': qid,\n                                 \'question\': ques_text,\n                                 \'answer\': ans_text,\n                                 \'start_position\': start_position_final,\n                                 \'end_position\': end_position_final})\n\n    print(\'examples num:\', len(examples))\n    print(\'mis_match:\', mis_match)\n    os.makedirs(\'/\'.join(output_files[0].split(\'/\')[0:-1]), exist_ok=True)\n    json.dump(examples, open(output_files[0], \'w\'))\n\n    # to features\n    features = []\n    unique_id = 1000000000\n    for (example_index, example) in enumerate(tqdm(examples)):\n        query_tokens = tokenizer.tokenize(example[\'question\'])\n        if len(query_tokens) > max_query_length:\n            query_tokens = query_tokens[0:max_query_length]\n\n        tok_to_orig_index = []\n        orig_to_tok_index = []\n        all_doc_tokens = []\n        for (i, token) in enumerate(example[\'doc_tokens\']):\n            orig_to_tok_index.append(len(all_doc_tokens))\n            sub_tokens = tokenizer.tokenize(token)\n            for sub_token in sub_tokens:\n                tok_to_orig_index.append(i)\n                all_doc_tokens.append(sub_token)\n\n        tok_start_position = None\n        tok_end_position = None\n        if is_training:\n            tok_start_position = orig_to_tok_index[example[\'start_position\']]  # \xe5\x8e\x9f\xe6\x9d\xa5token\xe5\x88\xb0\xe6\x96\xb0token\xe7\x9a\x84\xe6\x98\xa0\xe5\xb0\x84\xef\xbc\x8c\xe8\xbf\x99\xe6\x98\xaf\xe6\x96\xb0token\xe7\x9a\x84\xe8\xb5\xb7\xe7\x82\xb9\n            if example[\'end_position\'] < len(example[\'doc_tokens\']) - 1:\n                tok_end_position = orig_to_tok_index[example[\'end_position\'] + 1] - 1\n            else:\n                tok_end_position = len(all_doc_tokens) - 1\n            (tok_start_position, tok_end_position) = _improve_answer_span(\n                all_doc_tokens, tok_start_position, tok_end_position, tokenizer,\n                example[\'orig_answer_text\'])\n\n        # The -3 accounts for [CLS], [SEP] and [SEP]\n        max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n        doc_spans = []\n        _DocSpan = collections.namedtuple(""DocSpan"", [""start"", ""length""])\n        start_offset = 0\n        while start_offset < len(all_doc_tokens):\n            length = len(all_doc_tokens) - start_offset\n            if length > max_tokens_for_doc:\n                length = max_tokens_for_doc\n            doc_spans.append(_DocSpan(start=start_offset, length=length))\n            if start_offset + length == len(all_doc_tokens):\n                break\n            start_offset += min(length, doc_stride)\n\n        for (doc_span_index, doc_span) in enumerate(doc_spans):\n            tokens = []\n            token_to_orig_map = {}\n            token_is_max_context = {}\n            segment_ids = []\n            tokens.append(""[CLS]"")\n            segment_ids.append(0)\n            for token in query_tokens:\n                tokens.append(token)\n                segment_ids.append(0)\n            tokens.append(""[SEP]"")\n            segment_ids.append(0)\n\n            for i in range(doc_span.length):\n                split_token_index = doc_span.start + i\n                token_to_orig_map[len(tokens)] = tok_to_orig_index[split_token_index]\n                is_max_context = _check_is_max_context(doc_spans, doc_span_index, split_token_index)\n                token_is_max_context[len(tokens)] = is_max_context\n                tokens.append(all_doc_tokens[split_token_index])\n                segment_ids.append(1)\n            tokens.append(""[SEP]"")\n            segment_ids.append(1)\n\n            input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n            # The mask has 1 for real tokens and 0 for padding tokens. Only real\n            # tokens are attended to.\n            input_mask = [1] * len(input_ids)\n\n            # Zero-pad up to the sequence length.\n            while len(input_ids) < max_seq_length:\n                input_ids.append(0)\n                input_mask.append(0)\n                segment_ids.append(0)\n\n            assert len(input_ids) == max_seq_length\n            assert len(input_mask) == max_seq_length\n            assert len(segment_ids) == max_seq_length\n\n            start_position = None\n            end_position = None\n            if is_training:\n                # For training, if our document chunk does not contain an annotation\n                # we throw it out, since there is nothing to predict.\n                if tok_start_position == -1 and tok_end_position == -1:\n                    start_position = 0  # \xe9\x97\xae\xe9\xa2\x98\xe6\x9c\xac\xe6\x9d\xa5\xe6\xb2\xa1\xe7\xad\x94\xe6\xa1\x88\xef\xbc\x8c0\xe6\x98\xaf[CLS]\xe7\x9a\x84\xe4\xbd\x8d\xe5\xad\x90\n                    end_position = 0\n                else:  # \xe5\xa6\x82\xe6\x9e\x9c\xe5\x8e\x9f\xe6\x9c\xac\xe6\x98\xaf\xe6\x9c\x89\xe7\xad\x94\xe6\xa1\x88\xe7\x9a\x84\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe5\x8e\xbb\xe9\x99\xa4\xe6\xb2\xa1\xe6\x9c\x89\xe7\xad\x94\xe6\xa1\x88\xe7\x9a\x84feature\n                    out_of_span = False\n                    doc_start = doc_span.start  # \xe6\x98\xa0\xe5\xb0\x84\xe5\x9b\x9e\xe5\x8e\x9f\xe6\x96\x87\xe7\x9a\x84\xe8\xb5\xb7\xe7\x82\xb9\xe5\x92\x8c\xe7\xbb\x88\xe7\x82\xb9\n                    doc_end = doc_span.start + doc_span.length - 1\n\n                    if not (tok_start_position >= doc_start and tok_end_position <= doc_end):  # \xe8\xaf\xa5\xe5\x88\x92\xe7\xaa\x97\xe6\xb2\xa1\xe7\xad\x94\xe6\xa1\x88\xe4\xbd\x9c\xe4\xb8\xba\xe6\x97\xa0\xe7\xad\x94\xe6\xa1\x88\xe5\xa2\x9e\xe5\xbc\xba\n                        out_of_span = True\n                    if out_of_span:\n                        start_position = 0\n                        end_position = 0\n                    else:\n                        doc_offset = len(query_tokens) + 2\n                        start_position = tok_start_position - doc_start + doc_offset\n                        end_position = tok_end_position - doc_start + doc_offset\n\n            features.append({\'unique_id\': unique_id,\n                             \'example_index\': example_index,\n                             \'doc_span_index\': doc_span_index,\n                             \'tokens\': tokens,\n                             \'token_to_orig_map\': token_to_orig_map,\n                             \'token_is_max_context\': token_is_max_context,\n                             \'input_ids\': input_ids,\n                             \'input_mask\': input_mask,\n                             \'segment_ids\': segment_ids,\n                             \'start_position\': start_position,\n                             \'end_position\': end_position})\n            unique_id += 1\n\n    print(\'features num:\', len(features))\n    json.dump(features, open(output_files[1], \'w\'))\n\n\ndef _convert_index(index, pos, M=None, is_start=True):\n    if pos >= len(index):\n        pos = len(index) - 1\n    if index[pos] is not None:\n        return index[pos]\n    N = len(index)\n    rear = pos\n    while rear < N - 1 and index[rear] is None:\n        rear += 1\n    front = pos\n    while front > 0 and index[front] is None:\n        front -= 1\n    assert index[front] is not None or index[rear] is not None\n    if index[front] is None:\n        if index[rear] >= 1:\n            if is_start:\n                return 0\n            else:\n                return index[rear] - 1\n        return index[rear]\n    if index[rear] is None:\n        if M is not None and index[front] < M - 1:\n            if is_start:\n                return index[front] + 1\n            else:\n                return M - 1\n        return index[front]\n    if is_start:\n        if index[rear] > index[front] + 1:\n            return index[front] + 1\n        else:\n            return index[rear]\n    else:\n        if index[rear] > index[front] + 1:\n            return index[rear] - 1\n        else:\n            return index[front]\n'"
baselines/models_pytorch/mrc_pytorch/tools/file_utils.py,0,"b'""""""\nUtilities for working with the local dataset cache.\nThis file is adapted from the AllenNLP library at https://github.com/allenai/allennlp\nCopyright by the AllenNLP authors.\n""""""\n\nimport json\nimport logging\nimport os\nimport shutil\nimport tempfile\nfrom functools import wraps\nfrom hashlib import sha256\nfrom pathlib import Path\nfrom typing import Optional, Tuple, Union, IO, Callable, Set\nfrom urllib.parse import urlparse\n\nimport boto3\nimport requests\nfrom botocore.exceptions import ClientError\nfrom tqdm import tqdm\n\nlogger = logging.getLogger(__name__)  # pylint: disable=invalid-name\n\nPYTORCH_PRETRAINED_BERT_CACHE = Path(os.getenv(\'PYTORCH_PRETRAINED_BERT_CACHE\',\n                                               Path.home() / \'.pytorch_pretrained_bert\'))\n\n\ndef url_to_filename(url: str, etag: str = None) -> str:\n    """"""\n    Convert `url` into a hashed filename in a repeatable way.\n    If `etag` is specified, append its hash to the url\'s, delimited\n    by a period.\n    """"""\n    url_bytes = url.encode(\'utf-8\')\n    url_hash = sha256(url_bytes)\n    filename = url_hash.hexdigest()\n\n    if etag:\n        etag_bytes = etag.encode(\'utf-8\')\n        etag_hash = sha256(etag_bytes)\n        filename += \'.\' + etag_hash.hexdigest()\n\n    return filename\n\n\ndef filename_to_url(filename: str, cache_dir: Union[str, Path] = None) -> Tuple[str, str]:\n    """"""\n    Return the url and etag (which may be ``None``) stored for `filename`.\n    Raise ``FileNotFoundError`` if `filename` or its stored metadata do not exist.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_PRETRAINED_BERT_CACHE\n    if isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    cache_path = os.path.join(cache_dir, filename)\n    if not os.path.exists(cache_path):\n        raise FileNotFoundError(""file {} not found"".format(cache_path))\n\n    meta_path = cache_path + \'.json\'\n    if not os.path.exists(meta_path):\n        raise FileNotFoundError(""file {} not found"".format(meta_path))\n\n    with open(meta_path) as meta_file:\n        metadata = json.load(meta_file)\n    url = metadata[\'url\']\n    etag = metadata[\'etag\']\n\n    return url, etag\n\n\ndef cached_path(url_or_filename: Union[str, Path], cache_dir: Union[str, Path] = None) -> str:\n    """"""\n    Given something that might be a URL (or might be a local path),\n    determine which. If it\'s a URL, download the file and cache it, and\n    return the path to the cached file. If it\'s already a local path,\n    make sure the file exists and then return the path.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_PRETRAINED_BERT_CACHE\n    if isinstance(url_or_filename, Path):\n        url_or_filename = str(url_or_filename)\n    if isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    parsed = urlparse(url_or_filename)\n\n    if parsed.scheme in (\'http\', \'https\', \'s3\'):\n        # URL, so get it from the cache (downloading if necessary)\n        return get_from_cache(url_or_filename, cache_dir)\n    elif os.path.exists(url_or_filename):\n        # File, and it exists.\n        return url_or_filename\n    elif parsed.scheme == \'\':\n        # File, but it doesn\'t exist.\n        raise FileNotFoundError(""file {} not found"".format(url_or_filename))\n    else:\n        # Something unknown\n        raise ValueError(""unable to parse {} as a URL or as a local path"".format(url_or_filename))\n\n\ndef split_s3_path(url: str) -> Tuple[str, str]:\n    """"""Split a full s3 path into the bucket name and path.""""""\n    parsed = urlparse(url)\n    if not parsed.netloc or not parsed.path:\n        raise ValueError(""bad s3 path {}"".format(url))\n    bucket_name = parsed.netloc\n    s3_path = parsed.path\n    # Remove \'/\' at beginning of path.\n    if s3_path.startswith(""/""):\n        s3_path = s3_path[1:]\n    return bucket_name, s3_path\n\n\ndef s3_request(func: Callable):\n    """"""\n    Wrapper function for s3 requests in order to create more helpful error\n    messages.\n    """"""\n\n    @wraps(func)\n    def wrapper(url: str, *args, **kwargs):\n        try:\n            return func(url, *args, **kwargs)\n        except ClientError as exc:\n            if int(exc.response[""Error""][""Code""]) == 404:\n                raise FileNotFoundError(""file {} not found"".format(url))\n            else:\n                raise\n\n    return wrapper\n\n\n@s3_request\ndef s3_etag(url: str) -> Optional[str]:\n    """"""Check ETag on S3 object.""""""\n    s3_resource = boto3.resource(""s3"")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_object = s3_resource.Object(bucket_name, s3_path)\n    return s3_object.e_tag\n\n\n@s3_request\ndef s3_get(url: str, temp_file: IO) -> None:\n    """"""Pull a file directly from S3.""""""\n    s3_resource = boto3.resource(""s3"")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)\n\n\ndef http_get(url: str, temp_file: IO) -> None:\n    req = requests.get(url, stream=True)\n    content_length = req.headers.get(\'Content-Length\')\n    total = int(content_length) if content_length is not None else None\n    progress = tqdm(unit=""B"", total=total)\n    for chunk in req.iter_content(chunk_size=1024):\n        if chunk: # filter out keep-alive new chunks\n            progress.update(len(chunk))\n            temp_file.write(chunk)\n    progress.close()\n\n\ndef get_from_cache(url: str, cache_dir: Union[str, Path] = None) -> str:\n    """"""\n    Given a URL, look for the corresponding dataset in the local cache.\n    If it\'s not there, download it. Then return the path to the cached file.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_PRETRAINED_BERT_CACHE\n    if isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    os.makedirs(cache_dir, exist_ok=True)\n\n    # Get eTag to add to filename, if it exists.\n    if url.startswith(""s3://""):\n        etag = s3_etag(url)\n    else:\n        response = requests.head(url, allow_redirects=True)\n        if response.status_code != 200:\n            raise IOError(""HEAD request failed for url {} with status code {}""\n                          .format(url, response.status_code))\n        etag = response.headers.get(""ETag"")\n\n    filename = url_to_filename(url, etag)\n\n    # get cache path to put the file\n    cache_path = os.path.join(cache_dir, filename)\n\n    if not os.path.exists(cache_path):\n        # Download to temporary file, then copy to cache dir once finished.\n        # Otherwise you get corrupt cache entries if the download gets interrupted.\n        with tempfile.NamedTemporaryFile() as temp_file:\n            logger.info(""%s not found in cache, downloading to %s"", url, temp_file.name)\n\n            # GET file object\n            if url.startswith(""s3://""):\n                s3_get(url, temp_file)\n            else:\n                http_get(url, temp_file)\n\n            # we are copying the file before closing it, so flush to avoid truncation\n            temp_file.flush()\n            # shutil.copyfileobj() starts at the current position, so go to the start\n            temp_file.seek(0)\n\n            logger.info(""copying %s to cache at %s"", temp_file.name, cache_path)\n            with open(cache_path, \'wb\') as cache_file:\n                shutil.copyfileobj(temp_file, cache_file)\n\n            logger.info(""creating metadata file for %s"", cache_path)\n            meta = {\'url\': url, \'etag\': etag}\n            meta_path = cache_path + \'.json\'\n            with open(meta_path, \'w\') as meta_file:\n                json.dump(meta, meta_file)\n\n            logger.info(""removing temp file %s"", temp_file.name)\n\n    return cache_path\n\n\ndef read_set_from_file(filename: str) -> Set[str]:\n    \'\'\'\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \'\'\'\n    collection = set()\n    with open(filename, \'r\', encoding=\'utf-8\') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection\n\n\ndef get_file_extension(path: str, dot=True, lower: bool = True):\n    ext = os.path.splitext(path)[1]\n    ext = ext if dot else ext[1:]\n    return ext.lower() if lower else ext\n'"
baselines/models_pytorch/mrc_pytorch/tools/langconv.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom copy import deepcopy\n\ntry:\n    import psyco\n    psyco.full()\nexcept:\n    pass\n\nfrom .zh_wiki import zh2Hant, zh2Hans\n\nimport sys\npy3k = sys.version_info >= (3, 0, 0)\n\nif py3k:\n    UEMPTY = \'\'\nelse:\n    _zh2Hant, _zh2Hans = {}, {}\n    for old, new in ((zh2Hant, _zh2Hant), (zh2Hans, _zh2Hans)):\n        for k, v in old.items():\n            new[k.decode(\'utf8\')] = v.decode(\'utf8\')\n    zh2Hant = _zh2Hant\n    zh2Hans = _zh2Hans\n    UEMPTY = \'\'.decode(\'utf8\')\n\n# states\n(START, END, FAIL, WAIT_TAIL) = list(range(4))\n# conditions\n(TAIL, ERROR, MATCHED_SWITCH, UNMATCHED_SWITCH, CONNECTOR) = list(range(5))\n\nMAPS = {}\n\nclass Node(object):\n    def __init__(self, from_word, to_word=None, is_tail=True,\n            have_child=False):\n        self.from_word = from_word\n        if to_word is None:\n            self.to_word = from_word\n            self.data = (is_tail, have_child, from_word)\n            self.is_original = True\n        else:\n            self.to_word = to_word or from_word\n            self.data = (is_tail, have_child, to_word)\n            self.is_original = False\n        self.is_tail = is_tail\n        self.have_child = have_child\n\n    def is_original_long_word(self):\n        return self.is_original and len(self.from_word)>1\n\n    def is_follow(self, chars):\n        return chars != self.from_word[:-1]\n\n    def __str__(self):\n        return \'<Node, %s, %s, %s, %s>\' % (repr(self.from_word),\n                repr(self.to_word), self.is_tail, self.have_child)\n\n    __repr__ = __str__\n\nclass ConvertMap(object):\n    def __init__(self, name, mapping=None):\n        self.name = name\n        self._map = {}\n        if mapping:\n            self.set_convert_map(mapping)\n\n    def set_convert_map(self, mapping):\n        convert_map = {}\n        have_child = {}\n        max_key_length = 0\n        for key in sorted(mapping.keys()):\n            if len(key)>1:\n                for i in range(1, len(key)):\n                    parent_key = key[:i]\n                    have_child[parent_key] = True\n            have_child[key] = False\n            max_key_length = max(max_key_length, len(key))\n        for key in sorted(have_child.keys()):\n            convert_map[key] = (key in mapping, have_child[key],\n                    mapping.get(key, UEMPTY))\n        self._map = convert_map\n        self.max_key_length = max_key_length\n\n    def __getitem__(self, k):\n        try:\n            is_tail, have_child, to_word  = self._map[k]\n            return Node(k, to_word, is_tail, have_child)\n        except:\n            return Node(k)\n\n    def __contains__(self, k):\n        return k in self._map\n\n    def __len__(self):\n        return len(self._map)\n\nclass StatesMachineException(Exception): pass\n\nclass StatesMachine(object):\n    def __init__(self):\n        self.state = START\n        self.final = UEMPTY\n        self.len = 0\n        self.pool = UEMPTY\n\n    def clone(self, pool):\n        new = deepcopy(self)\n        new.state = WAIT_TAIL\n        new.pool = pool\n        return new\n\n    def feed(self, char, map):\n        node = map[self.pool+char]\n\n        if node.have_child:\n            if node.is_tail:\n                if node.is_original:\n                    cond = UNMATCHED_SWITCH\n                else:\n                    cond = MATCHED_SWITCH\n            else:\n                cond = CONNECTOR\n        else:\n            if node.is_tail:\n                cond = TAIL\n            else:\n                cond = ERROR\n\n        new = None\n        if cond == ERROR:\n            self.state = FAIL\n        elif cond == TAIL:\n            if self.state == WAIT_TAIL and node.is_original_long_word():\n                self.state = FAIL\n            else:\n                self.final += node.to_word\n                self.len += 1\n                self.pool = UEMPTY\n                self.state = END\n        elif self.state == START or self.state == WAIT_TAIL:\n            if cond == MATCHED_SWITCH:\n                new = self.clone(node.from_word)\n                self.final += node.to_word\n                self.len += 1\n                self.state = END\n                self.pool = UEMPTY\n            elif cond == UNMATCHED_SWITCH or cond == CONNECTOR:\n                if self.state == START:\n                    new = self.clone(node.from_word)\n                    self.final += node.to_word\n                    self.len += 1\n                    self.state = END\n                else:\n                    if node.is_follow(self.pool):\n                        self.state = FAIL\n                    else:\n                        self.pool = node.from_word\n        elif self.state == END:\n            # END is a new START\n            self.state = START\n            new = self.feed(char, map)\n        elif self.state == FAIL:\n            raise StatesMachineException(\'Translate States Machine \'\n                    \'have error with input data %s\' % node)\n        return new\n\n    def __len__(self):\n        return self.len + 1\n\n    def __str__(self):\n        return \'<StatesMachine %s, pool: ""%s"", state: %s, final: %s>\' % (\n                id(self), self.pool, self.state, self.final)\n    __repr__ = __str__\n\nclass Converter(object):\n    def __init__(self, to_encoding):\n        self.to_encoding = to_encoding\n        self.map = MAPS[to_encoding]\n        self.start()\n\n    def feed(self, char):\n        branches = []\n        for fsm in self.machines:\n            new = fsm.feed(char, self.map)\n            if new:\n                branches.append(new)\n        if branches:\n            self.machines.extend(branches)\n        self.machines = [fsm for fsm in self.machines if fsm.state != FAIL]\n        all_ok = True\n        for fsm in self.machines:\n            if fsm.state != END:\n                all_ok = False\n        if all_ok:\n            self._clean()\n        return self.get_result()\n\n    def _clean(self):\n        if len(self.machines):\n            self.machines.sort(key=lambda x: len(x))\n            # self.machines.sort(cmp=lambda x,y: cmp(len(x), len(y)))\n            self.final += self.machines[0].final\n        self.machines = [StatesMachine()]\n\n    def start(self):\n        self.machines = [StatesMachine()]\n        self.final = UEMPTY\n\n    def end(self):\n        self.machines = [fsm for fsm in self.machines\n                if fsm.state == FAIL or fsm.state == END]\n        self._clean()\n\n    def convert(self, string):\n        self.start()\n        for char in string:\n            self.feed(char)\n        self.end()\n        return self.get_result()\n\n    def get_result(self):\n        return self.final\n\n\ndef registery(name, mapping):\n    global MAPS\n    MAPS[name] = ConvertMap(name, mapping)\n\nregistery(\'zh-hant\', zh2Hant)\nregistery(\'zh-hans\', zh2Hans)\ndel zh2Hant, zh2Hans\n\n\ndef run():\n    import sys\n    from optparse import OptionParser\n    parser = OptionParser()\n    parser.add_option(\'-e\', type=\'string\', dest=\'encoding\',\n            help=\'encoding\')\n    parser.add_option(\'-f\', type=\'string\', dest=\'file_in\',\n            help=\'input file (- for stdin)\')\n    parser.add_option(\'-t\', type=\'string\', dest=\'file_out\',\n            help=\'output file\')\n    (options, args) = parser.parse_args()\n    if not options.encoding:\n        parser.error(\'encoding must be set\')\n    if options.file_in:\n        if options.file_in == \'-\':\n            file_in = sys.stdin\n        else:\n            file_in = open(options.file_in)\n    else:\n        file_in = sys.stdin\n    if options.file_out:\n        if options.file_out == \'-\':\n            file_out = sys.stdout\n        else:\n            file_out = open(options.file_out, \'wb\')\n    else:\n        file_out = sys.stdout\n\n    c = Converter(options.encoding)\n    for line in file_in:\n        # print >> file_out, c.convert(line.rstrip(\'\\n\').decode(\n        file_out.write(c.convert(line.rstrip(\'\\n\').decode(\n            \'utf8\')).encode(\'utf8\'))\n\n\nif __name__ == \'__main__\':\n    run()\n\n'"
baselines/models_pytorch/mrc_pytorch/tools/official_tokenization.py,1,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HugginFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport unicodedata\nimport os\nimport logging\nimport six\n\nfrom tools.file_utils import cached_path\n\nlogger = logging.getLogger(__name__)\n\nPRETRAINED_VOCAB_ARCHIVE_MAP = {\n    \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-vocab.txt"",\n    \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt"",\n    \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-vocab.txt"",\n    \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-vocab.txt"",\n    \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-vocab.txt"",\n    \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-vocab.txt"",\n    \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-vocab.txt"",\n}\nVOCAB_NAME = \'vocab.txt\'\n\n\ndef load_vocab(vocab_file):\n    """"""Loads a vocabulary file into a dictionary.""""""\n    vocab = collections.OrderedDict()\n    index = 0\n    with open(vocab_file, ""r"", encoding=""utf-8"") as reader:\n        while True:\n            token = reader.readline()\n            if not token:\n                break\n            token = token.strip()\n            vocab[token] = index\n            index += 1\n    return vocab\n\n\ndef whitespace_tokenize(text):\n    """"""Runs basic whitespace cleaning and splitting on a peice of text.""""""\n    text = text.strip()\n    if not text:\n        return []\n    tokens = text.split()\n    return tokens\n\n\ndef printable_text(text):\n    """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n    # These functions want `str` for both Python2 and Python3, but in one case\n    # it\'s a Unicode string and in the other it\'s a byte string.\n    if six.PY3:\n        if isinstance(text, str):\n            return text\n        elif isinstance(text, bytes):\n            return text.decode(""utf-8"", ""ignore"")\n        else:\n            raise ValueError(""Unsupported string type: %s"" % (type(text)))\n    elif six.PY2:\n        if isinstance(text, str):\n            return text\n        elif isinstance(text, unicode):\n            return text.encode(""utf-8"")\n        else:\n            raise ValueError(""Unsupported string type: %s"" % (type(text)))\n    else:\n        raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef convert_to_unicode(text):\n    """"""Converts `text` to Unicode (if it\'s not already), assuming utf-8 input.""""""\n    if six.PY3:\n        if isinstance(text, str):\n            return text\n        elif isinstance(text, bytes):\n            return text.decode(""utf-8"", ""ignore"")\n        else:\n            raise ValueError(""Unsupported string type: %s"" % (type(text)))\n    elif six.PY2:\n        if isinstance(text, str):\n            return text.decode(""utf-8"", ""ignore"")\n        elif isinstance(text, unicode):\n            return text\n        else:\n            raise ValueError(""Unsupported string type: %s"" % (type(text)))\n    else:\n        raise ValueError(""Not running on Python2 or Python 3?"")\n\n\nclass BertTokenizer(object):\n    """"""Runs end-to-end tokenization: punctuation splitting + wordpiece""""""\n\n    def __init__(self, vocab_file, do_lower_case=True):\n        if not os.path.isfile(vocab_file):\n            raise ValueError(\n                ""Can\'t find a vocabulary file at path \'{}\'. To load the vocabulary from a Google pretrained ""\n                ""model use `tokenizer = BertTokenizer.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(vocab_file))\n        self.vocab = load_vocab(vocab_file)\n        self.ids_to_tokens = collections.OrderedDict(\n            [(ids, tok) for tok, ids in self.vocab.items()])\n        self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n        self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)\n\n    def tokenize(self, text):\n        split_tokens = []\n        for token in self.basic_tokenizer.tokenize(text):\n            for sub_token in self.wordpiece_tokenizer.tokenize(token):\n                split_tokens.append(sub_token)\n        return split_tokens\n\n    def convert_tokens_to_ids(self, tokens):\n        """"""Converts a sequence of tokens into ids using the vocab.""""""\n        ids = []\n        for token in tokens:\n            ids.append(self.vocab[token])\n        return ids\n\n    def convert_ids_to_tokens(self, ids):\n        """"""Converts a sequence of ids in wordpiece tokens using the vocab.""""""\n        tokens = []\n        for i in ids:\n            tokens.append(self.ids_to_tokens[i])\n        return tokens\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name, cache_dir=None, *inputs, **kwargs):\n        """"""\n        Instantiate a PreTrainedBertModel from a pre-trained model file.\n        Download and cache the pre-trained model file if needed.\n        """"""\n        if pretrained_model_name in PRETRAINED_VOCAB_ARCHIVE_MAP:\n            vocab_file = PRETRAINED_VOCAB_ARCHIVE_MAP[pretrained_model_name]\n        else:\n            vocab_file = pretrained_model_name\n        if os.path.isdir(vocab_file):\n            vocab_file = os.path.join(vocab_file, VOCAB_NAME)\n        # redirect to the cache, if necessary\n        try:\n            resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)\n        except FileNotFoundError:\n            logger.error(\n                ""Model name \'{}\' was not found in model name list ({}). ""\n                ""We assumed \'{}\' was a path or url but couldn\'t find any file ""\n                ""associated to this path or url."".format(\n                    pretrained_model_name,\n                    \', \'.join(PRETRAINED_VOCAB_ARCHIVE_MAP.keys()),\n                    vocab_file))\n            return None\n        if resolved_vocab_file == vocab_file:\n            logger.info(""loading vocabulary file {}"".format(vocab_file))\n        else:\n            logger.info(""loading vocabulary file {} from cache at {}"".format(\n                vocab_file, resolved_vocab_file))\n        # Instantiate tokenizer.\n        tokenizer = cls(resolved_vocab_file, *inputs, **kwargs)\n        return tokenizer\n\n\nclass BasicTokenizer(object):\n    """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n    def __init__(self, do_lower_case=True):\n        """"""Constructs a BasicTokenizer.\n\n        Args:\n          do_lower_case: Whether to lower case the input.\n        """"""\n        self.do_lower_case = do_lower_case\n\n    def tokenize(self, text):\n        """"""Tokenizes a piece of text.""""""\n        text = self._clean_text(text)\n        # This was added on November 1st, 2018 for the multilingual and Chinese\n        # models. This is also applied to the English models now, but it doesn\'t\n        # matter since the English models were not trained on any Chinese data\n        # and generally don\'t have any Chinese data in them (there are Chinese\n        # characters in the vocabulary because Wikipedia does have some Chinese\n        # words in the English Wikipedia.).\n        text = self._tokenize_chinese_chars(text)\n        orig_tokens = whitespace_tokenize(text)\n        split_tokens = []\n        for token in orig_tokens:\n            if self.do_lower_case:\n                token = token.lower()\n                token = self._run_strip_accents(token)\n            split_tokens.extend(self._run_split_on_punc(token))\n\n        output_tokens = whitespace_tokenize("" "".join(split_tokens))\n        return output_tokens\n\n    def _run_strip_accents(self, text):\n        """"""Strips accents from a piece of text.""""""\n        text = unicodedata.normalize(""NFD"", text)\n        output = []\n        for char in text:\n            cat = unicodedata.category(char)\n            if cat == ""Mn"":\n                continue\n            output.append(char)\n        return """".join(output)\n\n    def _run_split_on_punc(self, text):\n        """"""Splits punctuation on a piece of text.""""""\n        chars = list(text)\n        i = 0\n        start_new_word = True\n        output = []\n        while i < len(chars):\n            char = chars[i]\n            if _is_punctuation(char):\n                output.append([char])\n                start_new_word = True\n            else:\n                if start_new_word:\n                    output.append([])\n                start_new_word = False\n                output[-1].append(char)\n            i += 1\n\n        return ["""".join(x) for x in output]\n\n    def _tokenize_chinese_chars(self, text):\n        """"""Adds whitespace around any CJK character.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if self._is_chinese_char(cp):\n                output.append("" "")\n                output.append(char)\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n    def _is_chinese_char(self, cp):\n        """"""Checks whether CP is the codepoint of a CJK character.""""""\n        # This defines a ""chinese character"" as anything in the CJK Unicode block:\n        #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n        #\n        # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n        # despite its name. The modern Korean Hangul alphabet is a different block,\n        # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n        # space-separated words, so they are not treated specially and handled\n        # like the all of the other languages.\n        if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n                (cp >= 0x3400 and cp <= 0x4DBF) or  #\n                (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n                (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n                (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n                (cp >= 0x2B820 and cp <= 0x2CEAF) or\n                (cp >= 0xF900 and cp <= 0xFAFF) or  #\n                (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n            return True\n\n        return False\n\n    def _clean_text(self, text):\n        """"""Performs invalid character removal and whitespace cleanup on text.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if cp == 0 or cp == 0xfffd or _is_control(char):\n                continue\n            if _is_whitespace(char):\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n    """"""Runs WordPiece tokenization.""""""\n\n    def __init__(self, vocab, unk_token=""[UNK]"", max_input_chars_per_word=100):\n        self.vocab = vocab\n        self.unk_token = unk_token\n        self.max_input_chars_per_word = max_input_chars_per_word\n\n    def tokenize(self, text):\n        """"""Tokenizes a piece of text into its word pieces.\n\n        This uses a greedy longest-match-first algorithm to perform tokenization\n        using the given vocabulary.\n\n        For example:\n          input = ""unaffable""\n          output = [""un"", ""##aff"", ""##able""]\n\n        Args:\n          text: A single token or whitespace separated tokens. This should have\n            already been passed through `BasicTokenizer.\n\n        Returns:\n          A list of wordpiece tokens.\n        """"""\n\n        output_tokens = []\n        for token in whitespace_tokenize(text):\n            chars = list(token)\n            if len(chars) > self.max_input_chars_per_word:\n                output_tokens.append(self.unk_token)\n                continue\n\n            is_bad = False\n            start = 0\n            sub_tokens = []\n            while start < len(chars):\n                end = len(chars)\n                cur_substr = None\n                while start < end:\n                    substr = """".join(chars[start:end])\n                    if start > 0:\n                        substr = ""##"" + substr\n                    if substr in self.vocab:\n                        cur_substr = substr\n                        break\n                    end -= 1\n                if cur_substr is None:\n                    is_bad = True\n                    break\n                sub_tokens.append(cur_substr)\n                start = end\n\n            if is_bad:\n                output_tokens.append(self.unk_token)\n            else:\n                output_tokens.extend(sub_tokens)\n        return output_tokens\n\n\ndef _is_whitespace(char):\n    """"""Checks whether `chars` is a whitespace character.""""""\n    # \\t, \\n, and \\r are technically contorl characters but we treat them\n    # as whitespace since they are generally considered as such.\n    if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return True\n    cat = unicodedata.category(char)\n    if cat == ""Zs"":\n        return True\n    return False\n\n\ndef _is_control(char):\n    """"""Checks whether `chars` is a control character.""""""\n    # These are technically control characters but we count them as whitespace\n    # characters.\n    if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return False\n    cat = unicodedata.category(char)\n    if cat.startswith(""C""):\n        return True\n    return False\n\n\ndef _is_punctuation(char):\n    """"""Checks whether `chars` is a punctuation character.""""""\n    cp = ord(char)\n    # We treat all non-letter/number ASCII as punctuation.\n    # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n    # Punctuation class but we treat them as punctuation anyways, for\n    # consistency.\n    if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n            (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n        return True\n    cat = unicodedata.category(char)\n    if cat.startswith(""P""):\n        return True\n    return False'"
baselines/models_pytorch/mrc_pytorch/tools/pytorch_optimization.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HugginFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch optimization for BERT model.""""""\n\nimport math\n\nimport torch\nfrom torch.nn.utils import clip_grad_norm_\nfrom torch.optim.optimizer import Optimizer\n\n\ndef warmup_cosine(x, warmup=0.002):\n    if x < warmup:\n        return x / warmup\n    return 0.5 * (1.0 + torch.cos(math.pi * x))\n\n\ndef warmup_constant(x, warmup=0.002):\n    if x < warmup:\n        return x / warmup\n    return 1.0\n\n\ndef warmup_linear(x, warmup=0.002):\n    if x < warmup:\n        return x / warmup\n    return (1.0 - x) / (1.0 - warmup)\n\n\ndef warmup_fix(step, warmup_step):\n    return min(1.0, step / warmup_step)\n\n\nSCHEDULES = {\n    \'warmup_cosine\': warmup_cosine,\n    \'warmup_constant\': warmup_constant,\n    \'warmup_linear\': warmup_linear,\n    \'warmup_fix\': warmup_fix\n}\n\n\nclass BERTAdam(Optimizer):\n    """"""Implements BERT version of Adam algorithm with weight decay fix (and no ).\n    Params:\n        lr: learning rate\n        warmup: portion of t_total for the warmup, -1  means no warmup. Default: -1\n        t_total: total number of training steps for the learning\n            rate schedule, -1  means constant learning rate. Default: -1\n        schedule: schedule to use for the warmup (see above). Default: \'warmup_linear\'\n        b1: Adams b1. Default: 0.9\n        b2: Adams b2. Default: 0.999\n        e: Adams epsilon. Default: 1e-6\n        weight_decay_rate: Weight decay. Default: 0.01\n        max_grad_norm: Maximum norm for the gradients (-1 means no clipping). Default: 1.0\n    """"""\n\n    def __init__(self, params, lr, warmup=-1, t_total=-1, schedule=\'warmup_linear\',\n                 b1=0.9, b2=0.999, e=1e-6, weight_decay_rate=0.01, cycle_step=None,\n                 max_grad_norm=1.0):\n        if lr is not None and not lr >= 0.0:\n            raise ValueError(""Invalid learning rate: {} - should be >= 0.0"".format(lr))\n        if schedule not in SCHEDULES:\n            raise ValueError(""Invalid schedule parameter: {}"".format(schedule))\n        if not 0.0 <= warmup < 1.0 and not warmup == -1:\n            raise ValueError(""Invalid warmup: {} - should be in [0.0, 1.0[ or -1"".format(warmup))\n        if not 0.0 <= b1 < 1.0:\n            raise ValueError(""Invalid b1 parameter: {} - should be in [0.0, 1.0["".format(b1))\n        if not 0.0 <= b2 < 1.0:\n            raise ValueError(""Invalid b2 parameter: {} - should be in [0.0, 1.0["".format(b2))\n        if not e >= 0.0:\n            raise ValueError(""Invalid epsilon value: {} - should be >= 0.0"".format(e))\n        defaults = dict(lr=lr, schedule=schedule, warmup=warmup, t_total=t_total,\n                        b1=b1, b2=b2, e=e, weight_decay_rate=weight_decay_rate,\n                        max_grad_norm=max_grad_norm, cycle_step=cycle_step)\n        super(BERTAdam, self).__init__(params, defaults)\n\n    def step(self, closure=None):\n        """"""Performs a single optimization step.\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        """"""\n        loss = None\n        if closure is not None:\n            loss = closure()\n\n        for group in self.param_groups:\n            for p in group[\'params\']:\n                if p.grad is None:\n                    continue\n                grad = p.grad.data\n                if grad.is_sparse:\n                    raise RuntimeError(\'Adam does not support sparse gradients, please consider SparseAdam instead\')\n\n                state = self.state[p]\n\n                # State initialization\n                if len(state) == 0:\n                    state[\'step\'] = 0\n                    # Exponential moving average of gradient values\n                    state[\'next_m\'] = torch.zeros_like(p.data)\n                    # Exponential moving average of squared gradient values\n                    state[\'next_v\'] = torch.zeros_like(p.data)\n\n                next_m, next_v = state[\'next_m\'], state[\'next_v\']\n                beta1, beta2 = group[\'b1\'], group[\'b2\']\n\n                # Add grad clipping\n                if group[\'max_grad_norm\'] > 0:\n                    clip_grad_norm_(p, group[\'max_grad_norm\'])\n\n                # Decay the first and second moment running average coefficient\n                # In-place operations to update the averages at the same time\n                next_m.mul_(beta1).add_(1 - beta1, grad)\n                next_v.mul_(beta2).addcmul_(1 - beta2, grad, grad)\n                update = next_m / (next_v.sqrt() + group[\'e\'])\n\n                # Just adding the square of the weights to the loss function is *not*\n                # the correct way of using L2 regularization/weight decay with Adam,\n                # since that will interact with the m and v parameters in strange ways.\n                #\n                # Instead we want ot decay the weights in a manner that doesn\'t interact\n                # with the m/v parameters. This is equivalent to adding the square\n                # of the weights to the loss with plain (non-momentum) SGD.\n                if group[\'weight_decay_rate\'] > 0.0:\n                    update += group[\'weight_decay_rate\'] * p.data\n\n                schedule_fct = SCHEDULES[group[\'schedule\']]\n                if group[\'cycle_step\'] is not None and state[\'step\'] > group[\'cycle_step\']:\n                    lr_scheduled = group[\'lr\'] * (1 - ((state[\'step\'] % group[\'cycle_step\']) / group[\'cycle_step\']))\n                elif group[\'t_total\'] != -1 and group[\'schedule\'] != \'warmup_fix\':\n                    lr_scheduled = group[\'lr\'] * schedule_fct(state[\'step\'] / group[\'t_total\'], group[\'warmup\'])\n                elif group[\'schedule\'] == \'warmup_fix\':\n                    lr_scheduled = group[\'lr\'] * schedule_fct(state[\'step\'], group[\'warmup\'] * group[\'t_total\'])\n                else:\n                    lr_scheduled = group[\'lr\']\n\n                update_with_lr = lr_scheduled * update\n                p.data.add_(-update_with_lr)\n\n                state[\'step\'] += 1\n\n        return loss\n\n\ndef get_optimization(model, float16, learning_rate, total_steps, schedule,\n                     warmup_rate, weight_decay_rate, max_grad_norm, opt_pooler=False):\n    # Prepare optimizer\n    assert 0.0 <= warmup_rate <= 1.0\n    param_optimizer = list(model.named_parameters())\n\n    # hack to remove pooler, which is not used\n    # thus it produce None grad that break apex\n    if opt_pooler is False:\n        param_optimizer = [n for n in param_optimizer if \'pooler\' not in n[0]]\n    no_decay = [\'bias\', \'LayerNorm.bias\', \'LayerNorm.weight\']\n    optimizer_parameters = [\n        {\'params\': [p for n, p in param_optimizer if not any([nd in n for nd in no_decay])],\n         \'weight_decay_rate\': weight_decay_rate},\n        {\'params\': [p for n, p in param_optimizer if any([nd in n for nd in no_decay])],\n         \'weight_decay_rate\': 0.0}\n    ]\n    if float16:\n        try:\n            from apex.contrib.optimizers import FP16_Optimizer\n            from apex.contrib.optimizers import FusedAdam\n        except ImportError:\n            raise ImportError(\n                ""Please install apex from https://www.github.com/nvidia/apex to use distributed and fp16 training."")\n\n        optimizer = FusedAdam(optimizer_parameters,\n                              lr=learning_rate,\n                              bias_correction=False,\n                              max_grad_norm=max_grad_norm)\n        optimizer = FP16_Optimizer(optimizer, dynamic_loss_scale=True)\n    else:\n        optimizer = BERTAdam(params=optimizer_parameters,\n                             lr=learning_rate,\n                             warmup=warmup_rate,\n                             max_grad_norm=max_grad_norm,\n                             t_total=total_steps,\n                             schedule=schedule,\n                             weight_decay_rate=weight_decay_rate)\n\n    return optimizer\n'"
baselines/models_pytorch/mrc_pytorch/tools/utils.py,4,"b'import collections\nimport os\nimport re\nfrom glob import glob\n\nimport tensorflow as tf\nimport tensorflow.contrib.slim as slim\nimport torch\n\n\ndef check_args(args):\n    args.setting_file = os.path.join(args.checkpoint_dir, args.setting_file)\n    args.log_file = os.path.join(args.checkpoint_dir, args.log_file)\n    os.makedirs(args.checkpoint_dir, exist_ok=True)\n    with open(args.setting_file, \'wt\') as opt_file:\n        opt_file.write(\'------------ Options -------------\\n\')\n        print(\'------------ Options -------------\')\n        for k in args.__dict__:\n            v = args.__dict__[k]\n            opt_file.write(\'%s: %s\\n\' % (str(k), str(v)))\n            print(\'%s: %s\' % (str(k), str(v)))\n        opt_file.write(\'-------------- End ----------------\\n\')\n        print(\'------------ End -------------\')\n\n    return args\n\n\ndef show_all_variables(rank=0):\n    model_vars = tf.trainable_variables()\n    slim.model_analyzer.analyze_vars(model_vars, print_info=True if rank == 0 else False)\n\n\ndef torch_show_all_params(model, rank=0):\n    params = list(model.parameters())\n    k = 0\n    for i in params:\n        l = 1\n        for j in i.size():\n            l *= j\n        k = k + l\n    if rank == 0:\n        print(""Total param num\xef\xbc\x9a"" + str(k))\n\n\n# import ipdb\ndef get_assigment_map_from_checkpoint(tvars, init_checkpoint):\n    """"""Compute the union of the current variables and checkpoint variables.""""""\n    initialized_variable_names = {}\n    new_variable_names = set()\n    unused_variable_names = set()\n\n    name_to_variable = collections.OrderedDict()\n    for var in tvars:\n        name = var.name\n        m = re.match(""^(.*):\\\\d+$"", name)\n        if m is not None:\n            name = m.group(1)\n        name_to_variable[name] = var\n\n    init_vars = tf.train.list_variables(init_checkpoint)\n\n    assignment_map = collections.OrderedDict()\n    for x in init_vars:\n        (name, var) = (x[0], x[1])\n        if name not in name_to_variable:\n            if \'adam\' not in name:\n                unused_variable_names.add(name)\n            continue\n        # assignment_map[name] = name\n        assignment_map[name] = name_to_variable[name]\n        initialized_variable_names[name] = 1\n        initialized_variable_names[name + "":0""] = 1\n\n    for name in name_to_variable:\n        if name not in initialized_variable_names:\n            new_variable_names.add(name)\n    return assignment_map, initialized_variable_names, new_variable_names, unused_variable_names\n\n\n# loading weights\ndef init_from_checkpoint(init_checkpoint, tvars=None, rank=0):\n    if not tvars:\n        tvars = tf.trainable_variables()\n    assignment_map, initialized_variable_names, new_variable_names, unused_variable_names \\\n        = get_assigment_map_from_checkpoint(tvars, init_checkpoint)\n    tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n    if rank == 0:\n        # \xe6\x98\xbe\xe7\xa4\xba\xe6\x88\x90\xe5\x8a\x9f\xe5\x8a\xa0\xe8\xbd\xbd\xe7\x9a\x84\xe6\x9d\x83\xe9\x87\x8d\n        for t in initialized_variable_names:\n            if "":0"" not in t:\n                print(""Loading weights success: "" + t)\n\n        # \xe6\x98\xbe\xe7\xa4\xba\xe6\x96\xb0\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\n        print(\'New parameters:\', new_variable_names)\n\n        # \xe6\x98\xbe\xe7\xa4\xba\xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe5\x8f\x82\xe6\x95\xb0\xe4\xb8\xad\xe6\xb2\xa1\xe7\x94\xa8\xe5\x88\xb0\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\n        print(\'Unused parameters\', unused_variable_names)\n\n\ndef torch_init_model(model, init_checkpoint):\n    state_dict = torch.load(init_checkpoint, map_location=\'cpu\')\n    missing_keys = []\n    unexpected_keys = []\n    error_msgs = []\n    # copy state_dict so _load_from_state_dict can modify it\n    metadata = getattr(state_dict, \'_metadata\', None)\n    state_dict = state_dict.copy()\n    if metadata is not None:\n        state_dict._metadata = metadata\n\n    def load(module, prefix=\'\'):\n        local_metadata = {} if metadata is None else metadata.get(prefix[:-1], {})\n\n        module._load_from_state_dict(\n            state_dict, prefix, local_metadata, True, missing_keys, unexpected_keys, error_msgs)\n        for name, child in module._modules.items():\n            if child is not None:\n                load(child, prefix + name + \'.\')\n\n    load(model, prefix=\'\' if hasattr(model, \'bert\') else \'bert.\')\n\n    print(""missing keys:{}"".format(missing_keys))\n    print(\'unexpected keys:{}\'.format(unexpected_keys))\n    print(\'error msgs:{}\'.format(error_msgs))\n\n\ndef torch_save_model(model, output_dir, scores, max_save_num=1):\n    # Save model checkpoint\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    model_to_save = model.module if hasattr(model, \'module\') else model  # Take care of distributed/parallel training\n    saved_pths = glob(os.path.join(output_dir, \'*.pth\'))\n    saved_pths.sort()\n    while len(saved_pths) >= max_save_num:\n        if os.path.exists(saved_pths[0].replace(\'//\', \'/\')):\n            os.remove(saved_pths[0].replace(\'//\', \'/\'))\n            del saved_pths[0]\n\n    save_prex = ""checkpoint_score""\n    for k in scores:\n        save_prex += (\'_\' + k + \'-\' + str(scores[k])[:6])\n    save_prex += \'.pth\'\n\n    torch.save(model_to_save.state_dict(),\n               os.path.join(output_dir, save_prex))\n    print(""Saving model checkpoint to %s"", output_dir)\n'"
baselines/models_pytorch/mrc_pytorch/tools/zh_wiki.py,0,"b'# -*- coding: utf-8 -*-\n# copy fom wikipedia\n\nzh2Hant = {\n\'\xe5\x91\x86\': \'\xe7\x8d\x83\',\n""\xe6\x89\x93\xe5\x8d\xb0\xe6\x9c\xba"": ""\xe5\x8d\xb0\xe8\xa1\xa8\xe6\xa9\x9f"",\n\'\xe5\xb8\xae\xe5\x8a\xa9\xe6\x96\x87\xe4\xbb\xb6\': \'\xe8\xaa\xaa\xe6\x98\x8e\xe6\xaa\x94\xe6\xa1\x88\',\n""\xe7\x94\xbb"": ""\xe7\x95\xab"",\n""\xe9\xbe\x99"": ""\xe7\xab\x9c"",\n""\xe6\x9d\xbf"": ""\xe6\x9d\xbf"",\n""\xe8\xa1\xa8"": ""\xe8\xa1\xa8"",\n""\xe6\x89\x8d"": ""\xe6\x89\x8d"",\n""\xe4\xb8\x91"": ""\xe9\x86\x9c"",\n""\xe5\x87\xba"": ""\xe5\x87\xba"",\n""\xe6\xb7\x80"": ""\xe6\xbe\xb1"",\n""\xe5\x86\xac"": ""\xe5\x86\xac"",\n""\xe8\x8c\x83"": ""\xe7\xaf\x84"",\n""\xe4\xb8\xb0"": ""\xe8\xb1\x90"",\n""\xe5\x88\xae"": ""\xe5\x88\xae"",\n""\xe5\x90\x8e"": ""\xe5\xbe\x8c"",\n""\xe8\x83\xa1"": ""\xe8\x83\xa1"",\n""\xe5\x9b\x9e"": ""\xe5\x9b\x9e"",\n""\xe4\xbc\x99"": ""\xe5\xa4\xa5"",\n""\xe5\xa7\x9c"": ""\xe8\x96\x91"",\n""\xe5\x80\x9f"": ""\xe5\x80\x9f"",\n""\xe5\x85\x8b"": ""\xe5\x85\x8b"",\n""\xe5\x9b\xb0"": ""\xe5\x9b\xb0"",\n""\xe6\xbc\x93"": ""\xe6\xbc\x93"",\n""\xe9\x87\x8c"": ""\xe9\x87\x8c"",\n""\xe5\xb8\x98"": ""\xe7\xb0\xbe"",\n""\xe9\x9c\x89"": ""\xe9\x9c\x89"",\n""\xe9\x9d\xa2"": ""\xe9\x9d\xa2"",\n""\xe8\x94\x91"": ""\xe8\x94\x91"",\n""\xe5\x8d\x83"": ""\xe5\x8d\x83"",\n""\xe7\xa7\x8b"": ""\xe7\xa7\x8b"",\n""\xe6\x9d\xbe"": ""\xe6\x9d\xbe"",\n""\xe5\x92\xb8"": ""\xe5\x92\xb8"",\n""\xe5\x90\x91"": ""\xe5\x90\x91"",\n""\xe4\xbd\x99"": ""\xe9\xa4\x98"",\n""\xe9\x83\x81"": ""\xe9\xac\xb1"",\n""\xe5\xbe\xa1"": ""\xe5\xbe\xa1"",\n""\xe6\x84\xbf"": ""\xe9\xa1\x98"",\n""\xe4\xba\x91"": ""\xe9\x9b\xb2"",\n""\xe8\x8a\xb8"": ""\xe8\x8a\xb8"",\n""\xe6\xb2\x84"": ""\xe6\xb2\x84"",\n""\xe8\x87\xb4"": ""\xe8\x87\xb4"",\n""\xe5\x88\xb6"": ""\xe5\x88\xb6"",\n""\xe6\x9c\xb1"": ""\xe6\x9c\xb1"",\n""\xe7\xad\x91"": ""\xe7\xaf\x89"",\n""\xe5\x87\x86"": ""\xe6\xba\x96"",\n""\xe5\x8e\x82"": ""\xe5\xbb\xa0"",\n""\xe5\xb9\xbf"": ""\xe5\xbb\xa3"",\n""\xe8\xbe\x9f"": ""\xe9\x97\xa2"",\n""\xe5\x88\xab"": ""\xe5\x88\xa5"",\n""\xe5\x8d\x9c"": ""\xe5\x8d\x9c"",\n""\xe6\xb2\x88"": ""\xe6\xb2\x88"",\n""\xe5\x86\xb2"": ""\xe6\xb2\x96"",\n""\xe7\xa7\x8d"": ""\xe7\xa8\xae"",\n""\xe8\x99\xab"": ""\xe8\x9f\xb2"",\n""\xe6\x8b\x85"": ""\xe6\x93\x94"",\n""\xe5\x85\x9a"": ""\xe9\xbb\xa8"",\n""\xe6\x96\x97"": ""\xe9\xac\xa5"",\n""\xe5\x84\xbf"": ""\xe5\x85\x92"",\n""\xe5\xb9\xb2"": ""\xe4\xb9\xbe"",\n""\xe8\xb0\xb7"": ""\xe8\xb0\xb7"",\n""\xe6\x9f\x9c"": ""\xe6\xab\x83"",\n""\xe5\x90\x88"": ""\xe5\x90\x88"",\n""\xe5\x88\x92"": ""\xe5\x8a\x83"",\n""\xe5\x9d\x8f"": ""\xe5\xa3\x9e"",\n""\xe5\x87\xa0"": ""\xe5\xb9\xbe"",\n""\xe7\xb3\xbb"": ""\xe7\xb3\xbb"",\n""\xe5\xae\xb6"": ""\xe5\xae\xb6"",\n""\xe4\xbb\xb7"": ""\xe5\x83\xb9"",\n""\xe6\x8d\xae"": ""\xe6\x93\x9a"",\n""\xe5\x8d\xb7"": ""\xe6\x8d\xb2"",\n""\xe9\x80\x82"": ""\xe9\x81\xa9"",\n""\xe8\x9c\xa1"": ""\xe8\xa0\x9f"",\n""\xe8\x85\x8a"": ""\xe8\x87\x98"",\n""\xe4\xba\x86"": ""\xe4\xba\x86"",\n""\xe7\xb4\xaf"": ""\xe7\xb4\xaf"",\n""\xe4\xb9\x88"": ""\xe9\xba\xbd"",\n""\xe8\x92\x99"": ""\xe8\x92\x99"",\n""\xe4\xb8\x87"": ""\xe8\x90\xac"",\n""\xe5\xae\x81"": ""\xe5\xaf\xa7"",\n""\xe6\x9c\xb4"": ""\xe6\xa8\xb8"",\n""\xe8\x8b\xb9"": ""\xe8\x98\x8b"",\n""\xe4\xbb\x86"": ""\xe5\x83\x95"",\n""\xe6\x9b\xb2"": ""\xe6\x9b\xb2"",\n""\xe7\xa1\xae"": ""\xe7\xa2\xba"",\n""\xe8\x88\x8d"": ""\xe8\x88\x8d"",\n""\xe8\x83\x9c"": ""\xe5\x8b\x9d"",\n""\xe6\x9c\xaf"": ""\xe8\xa1\x93"",\n""\xe5\x8f\xb0"": ""\xe5\x8f\xb0"",\n""\xe4\xbd\x93"": ""\xe9\xab\x94"",\n""\xe6\xb6\x82"": ""\xe5\xa1\x97"",\n""\xe5\x8f\xb6"": ""\xe8\x91\x89"",\n""\xe5\x90\x81"": ""\xe5\x90\x81"",\n""\xe6\x97\x8b"": ""\xe6\x97\x8b"",\n""\xe4\xbd\xa3"": ""\xe5\x82\xad"",\n""\xe4\xb8\x8e"": ""\xe8\x88\x87"",\n""\xe6\x8a\x98"": ""\xe6\x8a\x98"",\n""\xe5\xbe\x81"": ""\xe5\xbe\xb5"",\n""\xe7\x97\x87"": ""\xe7\x97\x87"",\n""\xe6\x81\xb6"": ""\xe6\x83\xa1"",\n""\xe5\x8f\x91"": ""\xe7\x99\xbc"",\n""\xe5\xa4\x8d"": ""\xe5\xbe\xa9"",\n""\xe6\xb1\x87"": ""\xe5\x8c\xaf"",\n""\xe8\x8e\xb7"": ""\xe7\x8d\xb2"",\n""\xe9\xa5\xa5"": ""\xe9\xa3\xa2"",\n""\xe5\xb0\xbd"": ""\xe7\x9b\xa1"",\n""\xe5\x8e\x86"": ""\xe6\xad\xb7"",\n""\xe5\x8d\xa4"": ""\xe6\xbb\xb7"",\n""\xe5\xbc\xa5"": ""\xe5\xbd\x8c"",\n""\xe7\xad\xbe"": ""\xe7\xb0\xbd"",\n""\xe7\xba\xa4"": ""\xe7\xba\x96"",\n""\xe8\x8b\x8f"": ""\xe8\x98\x87"",\n""\xe5\x9d\x9b"": ""\xe5\xa3\x87"",\n""\xe5\x9b\xa2"": ""\xe5\x9c\x98"",\n""\xe9\xa1\xbb"": ""\xe9\xa0\x88"",\n""\xe8\x84\x8f"": ""\xe8\x87\x9f"",\n""\xe5\x8f\xaa"": ""\xe5\x8f\xaa"",\n""\xe9\x92\x9f"": ""\xe9\x90\x98"",\n""\xe8\x8d\xaf"": ""\xe8\x97\xa5"",\n""\xe5\x90\x8c"": ""\xe5\x90\x8c"",\n""\xe5\xbf\x97"": ""\xe5\xbf\x97"",\n""\xe6\x9d\xaf"": ""\xe6\x9d\xaf"",\n""\xe5\xb2\xb3"": ""\xe5\xb2\xb3"",\n""\xe5\xb8\x83"": ""\xe5\xb8\x83"",\n""\xe5\xbd\x93"": ""\xe7\x95\xb6"",\n""\xe5\x90\x8a"": ""\xe5\xbc\x94"",\n""\xe4\xbb\x87"": ""\xe4\xbb\x87"",\n""\xe8\x95\xb4"": ""\xe8\x98\x8a"",\n""\xe7\xba\xbf"": ""\xe7\xb7\x9a"",\n""\xe4\xb8\xba"": ""\xe7\x82\xba"",\n""\xe4\xba\xa7"": ""\xe7\x94\xa2"",\n""\xe4\xbc\x97"": ""\xe7\x9c\xbe"",\n""\xe4\xbc\xaa"": ""\xe5\x81\xbd"",\n""\xe5\x87\xab"": ""\xe9\xb3\xa7"",\n""\xe5\x8e\x95"": ""\xe5\xbb\x81"",\n""\xe5\x90\xaf"": ""\xe5\x95\x9f"",\n""\xe5\xa2\x99"": ""\xe7\x89\x86"",\n""\xe5\xa3\xb3"": ""\xe6\xae\xbc"",\n""\xe5\xa5\x96"": ""\xe7\x8d\x8e"",\n""\xe5\xa6\xab"": ""\xe5\xaa\xaf"",\n""\xe5\xb9\xb6"": ""\xe4\xb8\xa6"",\n""\xe5\xbd\x95"": ""\xe9\x8c\x84"",\n""\xe6\x82\xab"": ""\xe6\x84\xa8"",\n""\xe6\x9e\x81"": ""\xe6\xa5\xb5"",\n""\xe6\xb2\xa9"": ""\xe6\xba\x88"",\n""\xe7\x98\x98"": ""\xe7\x98\xba"",\n""\xe7\xa1\xb7"": ""\xe9\xb9\xbc"",\n""\xe7\xab\x96"": ""\xe8\xb1\x8e"",\n""\xe7\xbb\x9d"": ""\xe7\xb5\x95"",\n""\xe7\xbb\xa3"": ""\xe7\xb9\xa1"",\n""\xe7\xbb\xa6"": ""\xe7\xb5\x9b"",\n""\xe7\xbb\xb1"": ""\xe7\xb7\x94"",\n""\xe7\xbb\xb7"": ""\xe7\xb6\xb3"",\n""\xe7\xbb\xbf"": ""\xe7\xb6\xa0"",\n""\xe7\xbc\xb0"": ""\xe9\x9f\x81"",\n""\xe8\x8b\xa7"": ""\xe8\x8b\x8e"",\n""\xe8\x8e\xbc"": ""\xe8\x92\x93"",\n""\xe8\xaf\xb4"": ""\xe8\xaa\xaa"",\n""\xe8\xb0\xa3"": ""\xe8\xac\xa0"",\n""\xe8\xb0\xab"": ""\xe8\xad\xbe"",\n""\xe8\xb5\x83"": ""\xe8\xb4\x93"",\n""\xe8\xb5\x8d"": ""\xe9\xbd\x8e"",\n""\xe8\xb5\x9d"": ""\xe8\xb4\x97"",\n""\xe9\x85\x9d"": ""\xe9\x86\x9e"",\n""\xe9\x87\x87"": ""\xe6\x8e\xa1"",\n""\xe9\x92\xa9"": ""\xe9\x89\xa4"",\n""\xe9\x92\xb5"": ""\xe7\xbc\xbd"",\n""\xe9\x94\x88"": ""\xe9\x8a\xb9"",\n""\xe9\x94\x90"": ""\xe9\x8a\xb3"",\n""\xe9\x94\xa8"": ""\xe6\x9d\xb4"",\n""\xe9\x95\x8c"": ""\xe9\x90\xab"",\n""\xe9\x95\xa2"": ""\xe9\x92\x81"",\n""\xe9\x98\x85"": ""\xe9\x96\xb1"",\n""\xe9\xa2\x93"": ""\xe9\xa0\xb9"",\n""\xe9\xa2\x9c"": ""\xe9\xa1\x8f"",\n""\xe9\xaa\x82"": ""\xe7\xbd\xb5"",\n""\xe9\xb2\x87"": ""\xe9\xaf\xb0"",\n""\xe9\xb2\x9e"": ""\xe9\xaf\x97"",\n""\xe9\xb3\x84"": ""\xe9\xb1\xb7"",\n""\xe9\xb8\xa1"": ""\xe9\x9b\x9e"",\n""\xe9\xb9\x9a"": ""\xe9\xb6\xbf"",\n""\xe8\x8d\xa1"": ""\xe7\x9b\xaa"",\n""\xe9\x94\xa4"": ""\xe9\x8c\x98"",\n""\xe3\x9f\x86"": ""\xe3\xa0\x8f"",\n""\xe3\x9b\x9f"": ""\xf0\xa1\x9e\xb5"",\n""\xe4\xb8\x93"": ""\xe5\xb0\x88"",\n""\xe4\xb8\x9a"": ""\xe6\xa5\xad"",\n""\xe4\xb8\x9b"": ""\xe5\x8f\xa2"",\n""\xe4\xb8\x9c"": ""\xe6\x9d\xb1"",\n""\xe4\xb8\x9d"": ""\xe7\xb5\xb2"",\n""\xe4\xb8\xa2"": ""\xe4\xb8\x9f"",\n""\xe4\xb8\xa4"": ""\xe5\x85\xa9"",\n""\xe4\xb8\xa5"": ""\xe5\x9a\xb4"",\n""\xe4\xb8\xa7"": ""\xe5\x96\xaa"",\n""\xe4\xb8\xaa"": ""\xe5\x80\x8b"",\n""\xe4\xb8\xb4"": ""\xe8\x87\xa8"",\n""\xe4\xb8\xbd"": ""\xe9\xba\x97"",\n""\xe4\xb8\xbe"": ""\xe8\x88\x89"",\n""\xe4\xb9\x89"": ""\xe7\xbe\xa9"",\n""\xe4\xb9\x8c"": ""\xe7\x83\x8f"",\n""\xe4\xb9\x90"": ""\xe6\xa8\x82"",\n""\xe4\xb9\x94"": ""\xe5\x96\xac"",\n""\xe4\xb9\xa0"": ""\xe7\xbf\x92"",\n""\xe4\xb9\xa1"": ""\xe9\x84\x89"",\n""\xe4\xb9\xa6"": ""\xe6\x9b\xb8"",\n""\xe4\xb9\xb0"": ""\xe8\xb2\xb7"",\n""\xe4\xb9\xb1"": ""\xe4\xba\x82"",\n""\xe4\xba\x89"": ""\xe7\x88\xad"",\n""\xe4\xba\x8e"": ""\xe6\x96\xbc"",\n""\xe4\xba\x8f"": ""\xe8\x99\xa7"",\n""\xe4\xba\x9a"": ""\xe4\xba\x9e"",\n""\xe4\xba\xa9"": ""\xe7\x95\x9d"",\n""\xe4\xba\xb2"": ""\xe8\xa6\xaa"",\n""\xe4\xba\xb5"": ""\xe8\xa4\xbb"",\n""\xe4\xba\xb8"": ""\xe5\x9a\xb2"",\n""\xe4\xba\xbf"": ""\xe5\x84\x84"",\n""\xe4\xbb\x85"": ""\xe5\x83\x85"",\n""\xe4\xbb\x8e"": ""\xe5\xbe\x9e"",\n""\xe4\xbb\x91"": ""\xe4\xbe\x96"",\n""\xe4\xbb\x93"": ""\xe5\x80\x89"",\n""\xe4\xbb\xaa"": ""\xe5\x84\x80"",\n""\xe4\xbb\xac"": ""\xe5\x80\x91"",\n""\xe4\xbc\x98"": ""\xe5\x84\xaa"",\n""\xe4\xbc\x9a"": ""\xe6\x9c\x83"",\n""\xe4\xbc\x9b"": ""\xe5\x82\xb4"",\n""\xe4\xbc\x9e"": ""\xe5\x82\x98"",\n""\xe4\xbc\x9f"": ""\xe5\x81\x89"",\n""\xe4\xbc\xa0"": ""\xe5\x82\xb3"",\n""\xe4\xbc\xa3"": ""\xe4\xbf\x94"",\n""\xe4\xbc\xa4"": ""\xe5\x82\xb7"",\n""\xe4\xbc\xa5"": ""\xe5\x80\x80"",\n""\xe4\xbc\xa6"": ""\xe5\x80\xab"",\n""\xe4\xbc\xa7"": ""\xe5\x82\x96"",\n""\xe4\xbc\xab"": ""\xe4\xbd\x87"",\n""\xe4\xbd\xa5"": ""\xe5\x83\x89"",\n""\xe4\xbe\xa0"": ""\xe4\xbf\xa0"",\n""\xe4\xbe\xa3"": ""\xe4\xbe\xb6"",\n""\xe4\xbe\xa5"": ""\xe5\x83\xa5"",\n""\xe4\xbe\xa6"": ""\xe5\x81\xb5"",\n""\xe4\xbe\xa7"": ""\xe5\x81\xb4"",\n""\xe4\xbe\xa8"": ""\xe5\x83\x91"",\n""\xe4\xbe\xa9"": ""\xe5\x84\x88"",\n""\xe4\xbe\xaa"": ""\xe5\x84\x95"",\n""\xe4\xbe\xac"": ""\xe5\x84\x82"",\n""\xe4\xbf\xa3"": ""\xe4\xbf\x81"",\n""\xe4\xbf\xa6"": ""\xe5\x84\x94"",\n""\xe4\xbf\xa8"": ""\xe5\x84\xbc"",\n""\xe4\xbf\xa9"": ""\xe5\x80\x86"",\n""\xe4\xbf\xaa"": ""\xe5\x84\xb7"",\n""\xe4\xbf\xab"": ""\xe5\x80\x88"",\n""\xe4\xbf\xad"": ""\xe5\x84\x89"",\n""\xe5\x80\xba"": ""\xe5\x82\xb5"",\n""\xe5\x80\xbe"": ""\xe5\x82\xbe"",\n""\xe5\x81\xac"": ""\xe5\x82\xaf"",\n""\xe5\x81\xbb"": ""\xe5\x83\x82"",\n""\xe5\x81\xbe"": ""\xe5\x83\xa8"",\n""\xe5\x81\xbf"": ""\xe5\x84\x9f"",\n""\xe5\x82\xa5"": ""\xe5\x84\xbb"",\n""\xe5\x82\xa7"": ""\xe5\x84\x90"",\n""\xe5\x82\xa8"": ""\xe5\x84\xb2"",\n""\xe5\x82\xa9"": ""\xe5\x84\xba"",\n""\xe3\x91\xa9"": ""\xe5\x84\xb8"",\n""\xe5\x85\x91"": ""\xe5\x85\x8c"",\n""\xe5\x85\x96"": ""\xe5\x85\x97"",\n""\xe5\x85\xb0"": ""\xe8\x98\xad"",\n""\xe5\x85\xb3"": ""\xe9\x97\x9c"",\n""\xe5\x85\xb4"": ""\xe8\x88\x88"",\n""\xe5\x85\xb9"": ""\xe8\x8c\xb2"",\n""\xe5\x85\xbb"": ""\xe9\xa4\x8a"",\n""\xe5\x85\xbd"": ""\xe7\x8d\xb8"",\n""\xe5\x86\x81"": ""\xe5\x9b\x85"",\n""\xe5\x86\x85"": ""\xe5\x85\xa7"",\n""\xe5\x86\x88"": ""\xe5\xb2\xa1"",\n""\xe5\x86\x8c"": ""\xe5\x86\x8a"",\n""\xe5\x86\x99"": ""\xe5\xaf\xab"",\n""\xe5\x86\x9b"": ""\xe8\xbb\x8d"",\n""\xe5\x86\x9c"": ""\xe8\xbe\xb2"",\n""\xe5\x86\xaf"": ""\xe9\xa6\xae"",\n""\xe5\x86\xb3"": ""\xe6\xb1\xba"",\n""\xe5\x86\xb5"": ""\xe6\xb3\x81"",\n""\xe5\x86\xbb"": ""\xe5\x87\x8d"",\n""\xe5\x87\x80"": ""\xe5\x87\x88"",\n""\xe5\x87\x89"": ""\xe6\xb6\xbc"",\n""\xe5\x87\x8f"": ""\xe6\xb8\x9b"",\n""\xe5\x87\x91"": ""\xe6\xb9\x8a"",\n""\xe5\x87\x9b"": ""\xe5\x87\x9c"",\n""\xe5\x87\xa4"": ""\xe9\xb3\xb3"",\n""\xe5\x87\xad"": ""\xe6\x86\x91"",\n""\xe5\x87\xaf"": ""\xe5\x87\xb1"",\n""\xe5\x87\xbb"": ""\xe6\x93\x8a"",\n""\xe5\x87\xbf"": ""\xe9\x91\xbf"",\n""\xe5\x88\x8d"": ""\xe8\x8a\xbb"",\n""\xe5\x88\x98"": ""\xe5\x8a\x89"",\n""\xe5\x88\x99"": ""\xe5\x89\x87"",\n""\xe5\x88\x9a"": ""\xe5\x89\x9b"",\n""\xe5\x88\x9b"": ""\xe5\x89\xb5"",\n""\xe5\x88\xa0"": ""\xe5\x88\xaa"",\n""\xe5\x88\xac"": ""\xe5\x89\x97"",\n""\xe5\x88\xad"": ""\xe5\x89\x84"",\n""\xe5\x88\xb9"": ""\xe5\x89\x8e"",\n""\xe5\x88\xbd"": ""\xe5\x8a\x8a"",\n""\xe5\x88\xbf"": ""\xe5\x8a\x8c"",\n""\xe5\x89\x80"": ""\xe5\x89\xb4"",\n""\xe5\x89\x82"": ""\xe5\x8a\x91"",\n""\xe5\x89\x90"": ""\xe5\x89\xae"",\n""\xe5\x89\x91"": ""\xe5\x8a\x8d"",\n""\xe5\x89\xa5"": ""\xe5\x89\x9d"",\n""\xe5\x89\xa7"": ""\xe5\x8a\x87"",\n""\xe3\x93\xa5"": ""\xe5\x8a\x8f"",\n""\xe3\x94\x89"": ""\xe5\x8a\x9a"",\n""\xe5\x8a\x9d"": ""\xe5\x8b\xb8"",\n""\xe5\x8a\x9e"": ""\xe8\xbe\xa6"",\n""\xe5\x8a\xa1"": ""\xe5\x8b\x99"",\n""\xe5\x8a\xa2"": ""\xe5\x8b\xb1"",\n""\xe5\x8a\xa8"": ""\xe5\x8b\x95"",\n""\xe5\x8a\xb1"": ""\xe5\x8b\xb5"",\n""\xe5\x8a\xb2"": ""\xe5\x8b\x81"",\n""\xe5\x8a\xb3"": ""\xe5\x8b\x9e"",\n""\xe5\x8a\xbf"": ""\xe5\x8b\xa2"",\n""\xe5\x8b\x8b"": ""\xe5\x8b\x9b"",\n""\xe5\x8b\x9a"": ""\xe5\x8b\xa9"",\n""\xe5\x8c\x80"": ""\xe5\x8b\xbb"",\n""\xe5\x8c\xa6"": ""\xe5\x8c\xad"",\n""\xe5\x8c\xae"": ""\xe5\x8c\xb1"",\n""\xe5\x8c\xba"": ""\xe5\x8d\x80"",\n""\xe5\x8c\xbb"": ""\xe9\x86\xab"",\n""\xe5\x8d\x8e"": ""\xe8\x8f\xaf"",\n""\xe5\x8d\x8f"": ""\xe5\x8d\x94"",\n""\xe5\x8d\x95"": ""\xe5\x96\xae"",\n""\xe5\x8d\x96"": ""\xe8\xb3\xa3"",\n""\xe5\x8d\xa2"": ""\xe7\x9b\xa7"",\n""\xe5\x8d\xab"": ""\xe8\xa1\x9b"",\n""\xe5\x8d\xb4"": ""\xe5\x8d\xbb"",\n""\xe5\x8e\x85"": ""\xe5\xbb\xb3"",\n""\xe5\x8e\x89"": ""\xe5\x8e\xb2"",\n""\xe5\x8e\x8b"": ""\xe5\xa3\x93"",\n""\xe5\x8e\x8c"": ""\xe5\x8e\xad"",\n""\xe5\x8e\x8d"": ""\xe5\x8e\x99"",\n""\xe5\x8e\x90"": ""\xe9\xbe\x8e"",\n""\xe5\x8e\x98"": ""\xe9\x87\x90"",\n""\xe5\x8e\xa2"": ""\xe5\xbb\x82"",\n""\xe5\x8e\xa3"": ""\xe5\x8e\xb4"",\n""\xe5\x8e\xa6"": ""\xe5\xbb\x88"",\n""\xe5\x8e\xa8"": ""\xe5\xbb\x9a"",\n""\xe5\x8e\xa9"": ""\xe5\xbb\x84"",\n""\xe5\x8e\xae"": ""\xe5\xbb\x9d"",\n""\xe5\x8e\xbf"": ""\xe7\xb8\xa3"",\n""\xe5\x8f\x81"": ""\xe5\x8f\x84"",\n""\xe5\x8f\x82"": ""\xe5\x8f\x83"",\n""\xe5\x8f\x8c"": ""\xe9\x9b\x99"",\n""\xe5\x8f\x98"": ""\xe8\xae\x8a"",\n""\xe5\x8f\x99"": ""\xe6\x95\x98"",\n""\xe5\x8f\xa0"": ""\xe7\x96\x8a"",\n""\xe5\x8f\xb7"": ""\xe8\x99\x9f"",\n""\xe5\x8f\xb9"": ""\xe5\x98\x86"",\n""\xe5\x8f\xbd"": ""\xe5\x98\xb0"",\n""\xe5\x90\x93"": ""\xe5\x9a\x87"",\n""\xe5\x90\x95"": ""\xe5\x91\x82"",\n""\xe5\x90\x97"": ""\xe5\x97\x8e"",\n""\xe5\x90\xa3"": ""\xe5\x94\x9a"",\n""\xe5\x90\xa8"": ""\xe5\x99\xb8"",\n""\xe5\x90\xac"": ""\xe8\x81\xbd"",\n""\xe5\x90\xb4"": ""\xe5\x90\xb3"",\n""\xe5\x91\x90"": ""\xe5\x90\xb6"",\n""\xe5\x91\x92"": ""\xe5\x98\xb8"",\n""\xe5\x91\x93"": ""\xe5\x9b\x88"",\n""\xe5\x91\x95"": ""\xe5\x98\x94"",\n""\xe5\x91\x96"": ""\xe5\x9a\xa6"",\n""\xe5\x91\x97"": ""\xe5\x94\x84"",\n""\xe5\x91\x98"": ""\xe5\x93\xa1"",\n""\xe5\x91\x99"": ""\xe5\x92\xbc"",\n""\xe5\x91\x9b"": ""\xe5\x97\x86"",\n""\xe5\x91\x9c"": ""\xe5\x97\x9a"",\n""\xe5\x92\x8f"": ""\xe8\xa9\xa0"",\n""\xe5\x92\x99"": ""\xe5\x9a\xa8"",\n""\xe5\x92\x9b"": ""\xe5\x9a\x80"",\n""\xe5\x92\x9d"": ""\xe5\x99\x9d"",\n""\xe5\x92\xa4"": ""\xe5\x90\x92"",\n""\xe5\x93\x8d"": ""\xe9\x9f\xbf"",\n""\xe5\x93\x91"": ""\xe5\x95\x9e"",\n""\xe5\x93\x92"": ""\xe5\x99\xa0"",\n""\xe5\x93\x93"": ""\xe5\x98\xb5"",\n""\xe5\x93\x94"": ""\xe5\x97\xb6"",\n""\xe5\x93\x95"": ""\xe5\x99\xa6"",\n""\xe5\x93\x97"": ""\xe5\x98\xa9"",\n""\xe5\x93\x99"": ""\xe5\x99\xb2"",\n""\xe5\x93\x9c"": ""\xe5\x9a\x8c"",\n""\xe5\x93\x9d"": ""\xe5\x99\xa5"",\n""\xe5\x93\x9f"": ""\xe5\x96\xb2"",\n""\xe5\x94\x9b"": ""\xe5\x98\x9c"",\n""\xe5\x94\x9d"": ""\xe5\x97\x8a"",\n""\xe5\x94\xa0"": ""\xe5\x98\xae"",\n""\xe5\x94\xa1"": ""\xe5\x95\xa2"",\n""\xe5\x94\xa2"": ""\xe5\x97\xa9"",\n""\xe5\x94\xa4"": ""\xe5\x96\x9a"",\n""\xe5\x95\xa7"": ""\xe5\x98\x96"",\n""\xe5\x95\xac"": ""\xe5\x97\x87"",\n""\xe5\x95\xad"": ""\xe5\x9b\x80"",\n""\xe5\x95\xae"": ""\xe5\x9a\x99"",\n""\xe5\x95\xb4"": ""\xe5\x98\xbd"",\n""\xe5\x95\xb8"": ""\xe5\x98\xaf"",\n""\xe3\x96\x9e"": ""\xe5\x96\x8e"",\n""\xe5\x96\xb7"": ""\xe5\x99\xb4"",\n""\xe5\x96\xbd"": ""\xe5\x98\x8d"",\n""\xe5\x96\xbe"": ""\xe5\x9a\xb3"",\n""\xe5\x97\xab"": ""\xe5\x9b\x81"",\n""\xe5\x97\xb3"": ""\xe5\x99\xaf"",\n""\xe5\x98\x98"": ""\xe5\x99\x93"",\n""\xe5\x98\xa4"": ""\xe5\x9a\xb6"",\n""\xe5\x98\xb1"": ""\xe5\x9b\x91"",\n""\xe3\x96\x8a"": ""\xe5\x99\x9a"",\n""\xe5\x99\x9c"": ""\xe5\x9a\x95"",\n""\xe5\x9a\xa3"": ""\xe5\x9b\x82"",\n""\xe5\x9b\xad"": ""\xe5\x9c\x92"",\n""\xe5\x9b\xb1"": ""\xe5\x9b\xaa"",\n""\xe5\x9b\xb4"": ""\xe5\x9c\x8d"",\n""\xe5\x9b\xb5"": ""\xe5\x9c\x87"",\n""\xe5\x9b\xbd"": ""\xe5\x9c\x8b"",\n""\xe5\x9b\xbe"": ""\xe5\x9c\x96"",\n""\xe5\x9c\x86"": ""\xe5\x9c\x93"",\n""\xe5\x9c\xa3"": ""\xe8\x81\x96"",\n""\xe5\x9c\xb9"": ""\xe5\xa3\x99"",\n""\xe5\x9c\xba"": ""\xe5\xa0\xb4"",\n""\xe5\x9d\x82"": ""\xe9\x98\xaa"",\n""\xe5\x9d\x97"": ""\xe5\xa1\x8a"",\n""\xe5\x9d\x9a"": ""\xe5\xa0\x85"",\n""\xe5\x9d\x9c"": ""\xe5\xa3\xa2"",\n""\xe5\x9d\x9d"": ""\xe5\xa3\xa9"",\n""\xe5\x9d\x9e"": ""\xe5\xa1\xa2"",\n""\xe5\x9d\x9f"": ""\xe5\xa2\xb3"",\n""\xe5\x9d\xa0"": ""\xe5\xa2\x9c"",\n""\xe5\x9e\x84"": ""\xe5\xa3\x9f"",\n""\xe5\x9e\x85"": ""\xe5\xa3\xa0"",\n""\xe5\x9e\x86"": ""\xe5\xa3\x9a"",\n""\xe5\x9e\x92"": ""\xe5\xa3\x98"",\n""\xe5\x9e\xa6"": ""\xe5\xa2\xbe"",\n""\xe5\x9e\xa9"": ""\xe5\xa0\x8a"",\n""\xe5\x9e\xab"": ""\xe5\xa2\x8a"",\n""\xe5\x9e\xad"": ""\xe5\x9f\xa1"",\n""\xe5\x9e\xb1"": ""\xe5\xa3\x8b"",\n""\xe5\x9e\xb2"": ""\xe5\xa1\x8f"",\n""\xe5\x9e\xb4"": ""\xe5\xa0\x96"",\n""\xe5\x9f\x98"": ""\xe5\xa1\x92"",\n""\xe5\x9f\x99"": ""\xe5\xa1\xa4"",\n""\xe5\x9f\x9a"": ""\xe5\xa0\x9d"",\n""\xe5\x9f\xaf"": ""\xe5\x9e\xb5"",\n""\xe5\xa0\x91"": ""\xe5\xa1\xb9"",\n""\xe5\xa0\x95"": ""\xe5\xa2\xae"",\n""\xf0\xa1\x92\x84"": ""\xe5\xa3\x88"",\n""\xe5\xa3\xae"": ""\xe5\xa3\xaf"",\n""\xe5\xa3\xb0"": ""\xe8\x81\xb2"",\n""\xe5\xa3\xb6"": ""\xe5\xa3\xba"",\n""\xe5\xa3\xb8"": ""\xe5\xa3\xbc"",\n""\xe5\xa4\x84"": ""\xe8\x99\x95"",\n""\xe5\xa4\x87"": ""\xe5\x82\x99"",\n""\xe5\xa4\x9f"": ""\xe5\xa4\xa0"",\n""\xe5\xa4\xb4"": ""\xe9\xa0\xad"",\n""\xe5\xa4\xb8"": ""\xe8\xaa\x87"",\n""\xe5\xa4\xb9"": ""\xe5\xa4\xbe"",\n""\xe5\xa4\xba"": ""\xe5\xa5\xaa"",\n""\xe5\xa5\x81"": ""\xe5\xa5\xa9"",\n""\xe5\xa5\x82"": ""\xe5\xa5\x90"",\n""\xe5\xa5\x8b"": ""\xe5\xa5\xae"",\n""\xe5\xa5\xa5"": ""\xe5\xa5\xa7"",\n""\xe5\xa5\xb8"": ""\xe5\xa7\xa6"",\n""\xe5\xa6\x86"": ""\xe5\xa6\x9d"",\n""\xe5\xa6\x87"": ""\xe5\xa9\xa6"",\n""\xe5\xa6\x88"": ""\xe5\xaa\xbd"",\n""\xe5\xa6\xa9"": ""\xe5\xab\xb5"",\n""\xe5\xa6\xaa"": ""\xe5\xab\x97"",\n""\xe5\xa7\x97"": ""\xe5\xa7\x8d"",\n""\xe5\xa7\xb9"": ""\xe5\xa5\xbc"",\n""\xe5\xa8\x84"": ""\xe5\xa9\x81"",\n""\xe5\xa8\x85"": ""\xe5\xa9\xad"",\n""\xe5\xa8\x86"": ""\xe5\xac\x88"",\n""\xe5\xa8\x87"": ""\xe5\xac\x8c"",\n""\xe5\xa8\x88"": ""\xe5\xad\x8c"",\n""\xe5\xa8\xb1"": ""\xe5\xa8\x9b"",\n""\xe5\xa8\xb2"": ""\xe5\xaa\xa7"",\n""\xe5\xa8\xb4"": ""\xe5\xab\xbb"",\n""\xe5\xa9\xb3"": ""\xe5\xab\xbf"",\n""\xe5\xa9\xb4"": ""\xe5\xac\xb0"",\n""\xe5\xa9\xb5"": ""\xe5\xac\x8b"",\n""\xe5\xa9\xb6"": ""\xe5\xac\xb8"",\n""\xe5\xaa\xaa"": ""\xe5\xaa\xbc"",\n""\xe5\xab\x92"": ""\xe5\xac\xa1"",\n""\xe5\xab\x94"": ""\xe5\xac\xaa"",\n""\xe5\xab\xb1"": ""\xe5\xac\x99"",\n""\xe5\xac\xb7"": ""\xe5\xac\xa4"",\n""\xe5\xad\x99"": ""\xe5\xad\xab"",\n""\xe5\xad\xa6"": ""\xe5\xad\xb8"",\n""\xe5\xad\xaa"": ""\xe5\xad\xbf"",\n""\xe5\xae\x9d"": ""\xe5\xaf\xb6"",\n""\xe5\xae\x9e"": ""\xe5\xaf\xa6"",\n""\xe5\xae\xa0"": ""\xe5\xaf\xb5"",\n""\xe5\xae\xa1"": ""\xe5\xaf\xa9"",\n""\xe5\xae\xaa"": ""\xe6\x86\xb2"",\n""\xe5\xae\xab"": ""\xe5\xae\xae"",\n""\xe5\xae\xbd"": ""\xe5\xaf\xac"",\n""\xe5\xae\xbe"": ""\xe8\xb3\x93"",\n""\xe5\xaf\x9d"": ""\xe5\xaf\xa2"",\n""\xe5\xaf\xb9"": ""\xe5\xb0\x8d"",\n""\xe5\xaf\xbb"": ""\xe5\xb0\x8b"",\n""\xe5\xaf\xbc"": ""\xe5\xb0\x8e"",\n""\xe5\xaf\xbf"": ""\xe5\xa3\xbd"",\n""\xe5\xb0\x86"": ""\xe5\xb0\x87"",\n""\xe5\xb0\x94"": ""\xe7\x88\xbe"",\n""\xe5\xb0\x98"": ""\xe5\xa1\xb5"",\n""\xe5\xb0\x9d"": ""\xe5\x98\x97"",\n""\xe5\xb0\xa7"": ""\xe5\xa0\xaf"",\n""\xe5\xb0\xb4"": ""\xe5\xb0\xb7"",\n""\xe5\xb0\xb8"": ""\xe5\xb1\x8d"",\n""\xe5\xb1\x82"": ""\xe5\xb1\xa4"",\n""\xe5\xb1\x83"": ""\xe5\xb1\x93"",\n""\xe5\xb1\x89"": ""\xe5\xb1\x9c"",\n""\xe5\xb1\x8a"": ""\xe5\xb1\x86"",\n""\xe5\xb1\x9e"": ""\xe5\xb1\xac"",\n""\xe5\xb1\xa1"": ""\xe5\xb1\xa2"",\n""\xe5\xb1\xa6"": ""\xe5\xb1\xa8"",\n""\xe5\xb1\xbf"": ""\xe5\xb6\xbc"",\n""\xe5\xb2\x81"": ""\xe6\xad\xb2"",\n""\xe5\xb2\x82"": ""\xe8\xb1\x88"",\n""\xe5\xb2\x96"": ""\xe5\xb6\x87"",\n""\xe5\xb2\x97"": ""\xe5\xb4\x97"",\n""\xe5\xb2\x98"": ""\xe5\xb3\xb4"",\n""\xe5\xb2\x99"": ""\xe5\xb6\xb4"",\n""\xe5\xb2\x9a"": ""\xe5\xb5\x90"",\n""\xe5\xb2\x9b"": ""\xe5\xb3\xb6"",\n""\xe5\xb2\xad"": ""\xe5\xb6\xba"",\n""\xe5\xb2\xbd"": ""\xe5\xb4\xac"",\n""\xe5\xb2\xbf"": ""\xe5\xb7\x8b"",\n""\xe5\xb3\x84"": ""\xe5\xb6\xa7"",\n""\xe5\xb3\xa1"": ""\xe5\xb3\xbd"",\n""\xe5\xb3\xa3"": ""\xe5\xb6\xa2"",\n""\xe5\xb3\xa4"": ""\xe5\xb6\xa0"",\n""\xe5\xb3\xa5"": ""\xe5\xb4\xa2"",\n""\xe5\xb3\xa6"": ""\xe5\xb7\x92"",\n""\xe5\xb4\x82"": ""\xe5\xb6\x97"",\n""\xe5\xb4\x83"": ""\xe5\xb4\x8d"",\n""\xe5\xb4\x84"": ""\xe5\xb6\xae"",\n""\xe5\xb4\xad"": ""\xe5\xb6\x84"",\n""\xe5\xb5\x98"": ""\xe5\xb6\xb8"",\n""\xe5\xb5\x9a"": ""\xe5\xb6\x94"",\n""\xe5\xb5\x9d"": ""\xe5\xb6\x81"",\n""\xe5\xb7\x85"": ""\xe5\xb7\x94"",\n""\xe5\xb7\xa9"": ""\xe9\x9e\x8f"",\n""\xe5\xb7\xaf"": ""\xe5\xb7\xb0"",\n""\xe5\xb8\x81"": ""\xe5\xb9\xa3"",\n""\xe5\xb8\x85"": ""\xe5\xb8\xa5"",\n""\xe5\xb8\x88"": ""\xe5\xb8\xab"",\n""\xe5\xb8\x8f"": ""\xe5\xb9\x83"",\n""\xe5\xb8\x90"": ""\xe5\xb8\xb3"",\n""\xe5\xb8\x9c"": ""\xe5\xb9\x9f"",\n""\xe5\xb8\xa6"": ""\xe5\xb8\xb6"",\n""\xe5\xb8\xa7"": ""\xe5\xb9\x80"",\n""\xe5\xb8\xae"": ""\xe5\xb9\xab"",\n""\xe5\xb8\xb1"": ""\xe5\xb9\xac"",\n""\xe5\xb8\xbb"": ""\xe5\xb9\x98"",\n""\xe5\xb8\xbc"": ""\xe5\xb9\x97"",\n""\xe5\xb9\x82"": ""\xe5\x86\xaa"",\n""\xe5\xba\x84"": ""\xe8\x8e\x8a"",\n""\xe5\xba\x86"": ""\xe6\x85\xb6"",\n""\xe5\xba\x90"": ""\xe5\xbb\xac"",\n""\xe5\xba\x91"": ""\xe5\xbb\xa1"",\n""\xe5\xba\x93"": ""\xe5\xba\xab"",\n""\xe5\xba\x94"": ""\xe6\x87\x89"",\n""\xe5\xba\x99"": ""\xe5\xbb\x9f"",\n""\xe5\xba\x9e"": ""\xe9\xbe\x90"",\n""\xe5\xba\x9f"": ""\xe5\xbb\xa2"",\n""\xe5\xbb\xaa"": ""\xe5\xbb\xa9"",\n""\xe5\xbc\x80"": ""\xe9\x96\x8b"",\n""\xe5\xbc\x82"": ""\xe7\x95\xb0"",\n""\xe5\xbc\x83"": ""\xe6\xa3\x84"",\n""\xe5\xbc\x91"": ""\xe5\xbc\x92"",\n""\xe5\xbc\xa0"": ""\xe5\xbc\xb5"",\n""\xe5\xbc\xaa"": ""\xe5\xbc\xb3"",\n""\xe5\xbc\xaf"": ""\xe5\xbd\x8e"",\n""\xe5\xbc\xb9"": ""\xe5\xbd\x88"",\n""\xe5\xbc\xba"": ""\xe5\xbc\xb7"",\n""\xe5\xbd\x92"": ""\xe6\xad\xb8"",\n""\xe5\xbd\x9d"": ""\xe5\xbd\x9e"",\n""\xe5\xbd\xa6"": ""\xe5\xbd\xa5"",\n""\xe5\xbd\xbb"": ""\xe5\xbe\xb9"",\n""\xe5\xbe\x84"": ""\xe5\xbe\x91"",\n""\xe5\xbe\x95"": ""\xe5\xbe\xa0"",\n""\xe5\xbf\x86"": ""\xe6\x86\xb6"",\n""\xe5\xbf\x8f"": ""\xe6\x87\xba"",\n""\xe5\xbf\xa7"": ""\xe6\x86\x82"",\n""\xe5\xbf\xbe"": ""\xe6\x84\xbe"",\n""\xe6\x80\x80"": ""\xe6\x87\xb7"",\n""\xe6\x80\x81"": ""\xe6\x85\x8b"",\n""\xe6\x80\x82"": ""\xe6\x85\xab"",\n""\xe6\x80\x83"": ""\xe6\x86\xae"",\n""\xe6\x80\x84"": ""\xe6\x85\xaa"",\n""\xe6\x80\x85"": ""\xe6\x82\xb5"",\n""\xe6\x80\x86"": ""\xe6\x84\xb4"",\n""\xe6\x80\x9c"": ""\xe6\x86\x90"",\n""\xe6\x80\xbb"": ""\xe7\xb8\xbd"",\n""\xe6\x80\xbc"": ""\xe6\x87\x9f"",\n""\xe6\x80\xbf"": ""\xe6\x87\x8c"",\n""\xe6\x81\x8b"": ""\xe6\x88\x80"",\n""\xe6\x81\x92"": ""\xe6\x81\x86"",\n""\xe6\x81\xb3"": ""\xe6\x87\x87"",\n""\xe6\x81\xb8"": ""\xe6\x85\x9f"",\n""\xe6\x81\xb9"": ""\xe6\x87\xa8"",\n""\xe6\x81\xba"": ""\xe6\x84\xb7"",\n""\xe6\x81\xbb"": ""\xe6\x83\xbb"",\n""\xe6\x81\xbc"": ""\xe6\x83\xb1"",\n""\xe6\x81\xbd"": ""\xe6\x83\xb2"",\n""\xe6\x82\xa6"": ""\xe6\x82\x85"",\n""\xe6\x82\xac"": ""\xe6\x87\xb8"",\n""\xe6\x82\xad"": ""\xe6\x85\xb3"",\n""\xe6\x82\xae"": ""\xe6\x82\x9e"",\n""\xe6\x82\xaf"": ""\xe6\x86\xab"",\n""\xe6\x83\x8a"": ""\xe9\xa9\x9a"",\n""\xe6\x83\xa7"": ""\xe6\x87\xbc"",\n""\xe6\x83\xa8"": ""\xe6\x85\x98"",\n""\xe6\x83\xa9"": ""\xe6\x87\xb2"",\n""\xe6\x83\xab"": ""\xe6\x86\x8a"",\n""\xe6\x83\xac"": ""\xe6\x84\x9c"",\n""\xe6\x83\xad"": ""\xe6\x85\x9a"",\n""\xe6\x83\xae"": ""\xe6\x86\x9a"",\n""\xe6\x83\xaf"": ""\xe6\x85\xa3"",\n""\xe6\x84\xa0"": ""\xe6\x85\x8d"",\n""\xe6\x84\xa4"": ""\xe6\x86\xa4"",\n""\xe6\x84\xa6"": ""\xe6\x86\x92"",\n""\xe6\x85\x91"": ""\xe6\x87\xbe"",\n""\xe6\x87\x91"": ""\xe6\x87\xa3"",\n""\xe6\x87\x92"": ""\xe6\x87\xb6"",\n""\xe6\x87\x94"": ""\xe6\x87\x8d"",\n""\xe6\x88\x86"": ""\xe6\x88\x87"",\n""\xe6\x88\x8b"": ""\xe6\x88\x94"",\n""\xe6\x88\x8f"": ""\xe6\x88\xb2"",\n""\xe6\x88\x97"": ""\xe6\x88\xa7"",\n""\xe6\x88\x98"": ""\xe6\x88\xb0"",\n""\xe6\x88\xac"": ""\xe6\x88\xa9"",\n""\xe6\x88\xaf"": ""\xe6\x88\xb1"",\n""\xe6\x88\xb7"": ""\xe6\x88\xb6"",\n""\xe6\x89\x91"": ""\xe6\x92\xb2"",\n""\xe6\x89\xa7"": ""\xe5\x9f\xb7"",\n""\xe6\x89\xa9"": ""\xe6\x93\xb4"",\n""\xe6\x89\xaa"": ""\xe6\x8d\xab"",\n""\xe6\x89\xab"": ""\xe6\x8e\x83"",\n""\xe6\x89\xac"": ""\xe6\x8f\x9a"",\n""\xe6\x89\xb0"": ""\xe6\x93\xbe"",\n""\xe6\x8a\x9a"": ""\xe6\x92\xab"",\n""\xe6\x8a\x9b"": ""\xe6\x8b\x8b"",\n""\xe6\x8a\x9f"": ""\xe6\x91\xb6"",\n""\xe6\x8a\xa0"": ""\xe6\x91\xb3"",\n""\xe6\x8a\xa1"": ""\xe6\x8e\x84"",\n""\xe6\x8a\xa2"": ""\xe6\x90\xb6"",\n""\xe6\x8a\xa4"": ""\xe8\xad\xb7"",\n""\xe6\x8a\xa5"": ""\xe5\xa0\xb1"",\n""\xe6\x8b\x9f"": ""\xe6\x93\xac"",\n""\xe6\x8b\xa2"": ""\xe6\x94\x8f"",\n""\xe6\x8b\xa3"": ""\xe6\x8f\x80"",\n""\xe6\x8b\xa5"": ""\xe6\x93\x81"",\n""\xe6\x8b\xa6"": ""\xe6\x94\x94"",\n""\xe6\x8b\xa7"": ""\xe6\x93\xb0"",\n""\xe6\x8b\xa8"": ""\xe6\x92\xa5"",\n""\xe6\x8b\xa9"": ""\xe6\x93\x87"",\n""\xe6\x8c\x82"": ""\xe6\x8e\x9b"",\n""\xe6\x8c\x9a"": ""\xe6\x91\xaf"",\n""\xe6\x8c\x9b"": ""\xe6\x94\xa3"",\n""\xe6\x8c\x9c"": ""\xe6\x8e\x97"",\n""\xe6\x8c\x9d"": ""\xe6\x92\xbe"",\n""\xe6\x8c\x9e"": ""\xe6\x92\xbb"",\n""\xe6\x8c\x9f"": ""\xe6\x8c\xbe"",\n""\xe6\x8c\xa0"": ""\xe6\x92\x93"",\n""\xe6\x8c\xa1"": ""\xe6\x93\x8b"",\n""\xe6\x8c\xa2"": ""\xe6\x92\x9f"",\n""\xe6\x8c\xa3"": ""\xe6\x8e\x99"",\n""\xe6\x8c\xa4"": ""\xe6\x93\xa0"",\n""\xe6\x8c\xa5"": ""\xe6\x8f\xae"",\n""\xe6\x8c\xa6"": ""\xe6\x92\x8f"",\n""\xe6\x8c\xbd"": ""\xe8\xbc\x93"",\n""\xe6\x8d\x9d"": ""\xe6\x8c\xa9"",\n""\xe6\x8d\x9e"": ""\xe6\x92\x88"",\n""\xe6\x8d\x9f"": ""\xe6\x90\x8d"",\n""\xe6\x8d\xa1"": ""\xe6\x92\xbf"",\n""\xe6\x8d\xa2"": ""\xe6\x8f\x9b"",\n""\xe6\x8d\xa3"": ""\xe6\x90\x97"",\n""\xe6\x8e\xb3"": ""\xe6\x93\x84"",\n""\xe6\x8e\xb4"": ""\xe6\x91\x91"",\n""\xe6\x8e\xb7"": ""\xe6\x93\xb2"",\n""\xe6\x8e\xb8"": ""\xe6\x92\xa3"",\n""\xe6\x8e\xba"": ""\xe6\x91\xbb"",\n""\xe6\x8e\xbc"": ""\xe6\x91\x9c"",\n""\xe6\x8f\xbd"": ""\xe6\x94\xac"",\n""\xe6\x8f\xbe"": ""\xe6\x90\xb5"",\n""\xe6\x8f\xbf"": ""\xe6\x92\xb3"",\n""\xe6\x90\x80"": ""\xe6\x94\x99"",\n""\xe6\x90\x81"": ""\xe6\x93\xb1"",\n""\xe6\x90\x82"": ""\xe6\x91\x9f"",\n""\xe6\x90\x85"": ""\xe6\x94\xaa"",\n""\xe6\x90\xba"": ""\xe6\x94\x9c"",\n""\xe6\x91\x84"": ""\xe6\x94\x9d"",\n""\xe6\x91\x85"": ""\xe6\x94\x84"",\n""\xe6\x91\x86"": ""\xe6\x93\xba"",\n""\xe6\x91\x87"": ""\xe6\x90\x96"",\n""\xe6\x91\x88"": ""\xe6\x93\xaf"",\n""\xe6\x91\x8a"": ""\xe6\x94\xa4"",\n""\xe6\x92\x84"": ""\xe6\x94\x96"",\n""\xe6\x92\x91"": ""\xe6\x92\x90"",\n""\xe3\xa7\x91"": ""\xe6\x92\x9d"",\n""\xe6\x92\xb5"": ""\xe6\x94\x86"",\n""\xe6\x92\xb7"": ""\xe6\x93\xb7"",\n""\xe6\x92\xb8"": ""\xe6\x93\xbc"",\n""\xe6\x92\xba"": ""\xe6\x94\x9b"",\n""\xe3\xa7\x9f"": ""\xe6\x93\x93"",\n""\xe6\x93\x9e"": ""\xe6\x93\xbb"",\n""\xe6\x94\x92"": ""\xe6\x94\xa2"",\n""\xe6\x95\x8c"": ""\xe6\x95\xb5"",\n""\xe6\x95\x9b"": ""\xe6\x96\x82"",\n""\xe6\x95\xb0"": ""\xe6\x95\xb8"",\n""\xe6\x96\x8b"": ""\xe9\xbd\x8b"",\n""\xe6\x96\x93"": ""\xe6\x96\x95"",\n""\xe6\x96\xa9"": ""\xe6\x96\xac"",\n""\xe6\x96\xad"": ""\xe6\x96\xb7"",\n""\xe6\x97\xa0"": ""\xe7\x84\xa1"",\n""\xe6\x97\xa7"": ""\xe8\x88\x8a"",\n""\xe6\x97\xb6"": ""\xe6\x99\x82"",\n""\xe6\x97\xb7"": ""\xe6\x9b\xa0"",\n""\xe6\x97\xb8"": ""\xe6\x9a\x98"",\n""\xe6\x98\x99"": ""\xe6\x9b\x87"",\n""\xe6\x98\xbc"": ""\xe6\x99\x9d"",\n""\xe6\x98\xbd"": ""\xe6\x9b\xa8"",\n""\xe6\x98\xbe"": ""\xe9\xa1\xaf"",\n""\xe6\x99\x8b"": ""\xe6\x99\x89"",\n""\xe6\x99\x92"": ""\xe6\x9b\xac"",\n""\xe6\x99\x93"": ""\xe6\x9b\x89"",\n""\xe6\x99\x94"": ""\xe6\x9b\x84"",\n""\xe6\x99\x95"": ""\xe6\x9a\x88"",\n""\xe6\x99\x96"": ""\xe6\x9a\x89"",\n""\xe6\x9a\x82"": ""\xe6\x9a\xab"",\n""\xe6\x9a\xa7"": ""\xe6\x9b\x96"",\n""\xe6\x9c\xba"": ""\xe6\xa9\x9f"",\n""\xe6\x9d\x80"": ""\xe6\xae\xba"",\n""\xe6\x9d\x82"": ""\xe9\x9b\x9c"",\n""\xe6\x9d\x83"": ""\xe6\xac\x8a"",\n""\xe6\x9d\x86"": ""\xe6\xa1\xbf"",\n""\xe6\x9d\xa1"": ""\xe6\xa2\x9d"",\n""\xe6\x9d\xa5"": ""\xe4\xbe\x86"",\n""\xe6\x9d\xa8"": ""\xe6\xa5\x8a"",\n""\xe6\x9d\xa9"": ""\xe6\xa6\xaa"",\n""\xe6\x9d\xb0"": ""\xe5\x82\x91"",\n""\xe6\x9e\x84"": ""\xe6\xa7\x8b"",\n""\xe6\x9e\x9e"": ""\xe6\xa8\x85"",\n""\xe6\x9e\xa2"": ""\xe6\xa8\x9e"",\n""\xe6\x9e\xa3"": ""\xe6\xa3\x97"",\n""\xe6\x9e\xa5"": ""\xe6\xab\xaa"",\n""\xe6\x9e\xa7"": ""\xe6\xa2\x98"",\n""\xe6\x9e\xa8"": ""\xe6\xa3\x96"",\n""\xe6\x9e\xaa"": ""\xe6\xa7\x8d"",\n""\xe6\x9e\xab"": ""\xe6\xa5\x93"",\n""\xe6\x9e\xad"": ""\xe6\xa2\x9f"",\n""\xe6\x9f\xa0"": ""\xe6\xaa\xb8"",\n""\xe6\x9f\xbd"": ""\xe6\xaa\x89"",\n""\xe6\xa0\x80"": ""\xe6\xa2\x94"",\n""\xe6\xa0\x85"": ""\xe6\x9f\xb5"",\n""\xe6\xa0\x87"": ""\xe6\xa8\x99"",\n""\xe6\xa0\x88"": ""\xe6\xa3\xa7"",\n""\xe6\xa0\x89"": ""\xe6\xab\x9b"",\n""\xe6\xa0\x8a"": ""\xe6\xab\xb3"",\n""\xe6\xa0\x8b"": ""\xe6\xa3\x9f"",\n""\xe6\xa0\x8c"": ""\xe6\xab\xa8"",\n""\xe6\xa0\x8e"": ""\xe6\xab\x9f"",\n""\xe6\xa0\x8f"": ""\xe6\xac\x84"",\n""\xe6\xa0\x91"": ""\xe6\xa8\xb9"",\n""\xe6\xa0\x96"": ""\xe6\xa3\xb2"",\n""\xe6\xa0\x97"": ""\xe6\x85\x84"",\n""\xe6\xa0\xb7"": ""\xe6\xa8\xa3"",\n""\xe6\xa0\xbe"": ""\xe6\xac\x92"",\n""\xe6\xa1\xa0"": ""\xe6\xa4\x8f"",\n""\xe6\xa1\xa1"": ""\xe6\xa9\x88"",\n""\xe6\xa1\xa2"": ""\xe6\xa5\xa8"",\n""\xe6\xa1\xa3"": ""\xe6\xaa\x94"",\n""\xe6\xa1\xa4"": ""\xe6\xa6\xbf"",\n""\xe6\xa1\xa5"": ""\xe6\xa9\x8b"",\n""\xe6\xa1\xa6"": ""\xe6\xa8\xba"",\n""\xe6\xa1\xa7"": ""\xe6\xaa\x9c"",\n""\xe6\xa1\xa8"": ""\xe6\xa7\xb3"",\n""\xe6\xa1\xa9"": ""\xe6\xa8\x81"",\n""\xe6\xa2\xa6"": ""\xe5\xa4\xa2"",\n""\xe6\xa2\xbc"": ""\xe6\xaa\xae"",\n""\xe6\xa2\xbe"": ""\xe6\xa3\xb6"",\n""\xe6\xa2\xbf"": ""\xe6\xa7\xa4"",\n""\xe6\xa3\x80"": ""\xe6\xaa\xa2"",\n""\xe6\xa3\x81"": ""\xe6\xa2\xb2"",\n""\xe6\xa3\x82"": ""\xe6\xac\x9e"",\n""\xe6\xa4\x81"": ""\xe6\xa7\xa8"",\n""\xe6\xa4\x9f"": ""\xe6\xab\x9d"",\n""\xe6\xa4\xa0"": ""\xe6\xa7\xa7"",\n""\xe6\xa4\xa4"": ""\xe6\xac\x8f"",\n""\xe6\xa4\xad"": ""\xe6\xa9\xa2"",\n""\xe6\xa5\xbc"": ""\xe6\xa8\x93"",\n""\xe6\xa6\x84"": ""\xe6\xac\x96"",\n""\xe6\xa6\x85"": ""\xe6\xa6\xb2"",\n""\xe6\xa6\x87"": ""\xe6\xab\xac"",\n""\xe6\xa6\x88"": ""\xe6\xab\x9a"",\n""\xe6\xa6\x89"": ""\xe6\xab\xb8"",\n""\xe6\xa7\x9a"": ""\xe6\xaa\x9f"",\n""\xe6\xa7\x9b"": ""\xe6\xaa\xbb"",\n""\xe6\xa7\x9f"": ""\xe6\xaa\xb3"",\n""\xe6\xa7\xa0"": ""\xe6\xab\xa7"",\n""\xe6\xa8\xaa"": ""\xe6\xa9\xab"",\n""\xe6\xa8\xaf"": ""\xe6\xaa\xa3"",\n""\xe6\xa8\xb1"": ""\xe6\xab\xbb"",\n""\xe6\xa9\xa5"": ""\xe6\xab\xab"",\n""\xe6\xa9\xb1"": ""\xe6\xab\xa5"",\n""\xe6\xa9\xb9"": ""\xe6\xab\x93"",\n""\xe6\xa9\xbc"": ""\xe6\xab\x9e"",\n""\xe6\xaa\xa9"": ""\xe6\xaa\x81"",\n""\xe6\xac\xa2"": ""\xe6\xad\xa1"",\n""\xe6\xac\xa4"": ""\xe6\xad\x9f"",\n""\xe6\xac\xa7"": ""\xe6\xad\x90"",\n""\xe6\xad\xbc"": ""\xe6\xae\xb2"",\n""\xe6\xae\x81"": ""\xe6\xad\xbf"",\n""\xe6\xae\x87"": ""\xe6\xae\xa4"",\n""\xe6\xae\x8b"": ""\xe6\xae\x98"",\n""\xe6\xae\x92"": ""\xe6\xae\x9e"",\n""\xe6\xae\x93"": ""\xe6\xae\xae"",\n""\xe6\xae\x9a"": ""\xe6\xae\xab"",\n""\xe6\xae\xa1"": ""\xe6\xae\xaf"",\n""\xe3\xb1\xae"": ""\xe6\xae\xa8"",\n""\xe3\xb1\xa9"": ""\xe6\xae\xb0"",\n""\xe6\xae\xb4"": ""\xe6\xaf\x86"",\n""\xe6\xaf\x81"": ""\xe6\xaf\x80"",\n""\xe6\xaf\x82"": ""\xe8\xbd\x82"",\n""\xe6\xaf\x95"": ""\xe7\x95\xa2"",\n""\xe6\xaf\x99"": ""\xe6\x96\x83"",\n""\xe6\xaf\xa1"": ""\xe6\xb0\x88"",\n""\xe6\xaf\xb5"": ""\xe6\xaf\xbf"",\n""\xe6\xb0\x87"": ""\xe6\xb0\x8c"",\n""\xe6\xb0\x94"": ""\xe6\xb0\xa3"",\n""\xe6\xb0\xa2"": ""\xe6\xb0\xab"",\n""\xe6\xb0\xa9"": ""\xe6\xb0\xac"",\n""\xe6\xb0\xb2"": ""\xe6\xb0\xb3"",\n""\xe6\xb1\x89"": ""\xe6\xbc\xa2"",\n""\xe6\xb1\xa4"": ""\xe6\xb9\xaf"",\n""\xe6\xb1\xb9"": ""\xe6\xb4\xb6"",\n""\xe6\xb2\x9f"": ""\xe6\xba\x9d"",\n""\xe6\xb2\xa1"": ""\xe6\xb2\x92"",\n""\xe6\xb2\xa3"": ""\xe7\x81\x83"",\n""\xe6\xb2\xa4"": ""\xe6\xbc\x9a"",\n""\xe6\xb2\xa5"": ""\xe7\x80\x9d"",\n""\xe6\xb2\xa6"": ""\xe6\xb7\xaa"",\n""\xe6\xb2\xa7"": ""\xe6\xbb\x84"",\n""\xe6\xb2\xaa"": ""\xe6\xbb\xac"",\n""\xe6\xb3\x9e"": ""\xe6\xbf\x98"",\n""\xe6\xb3\xa8"": ""\xe8\xa8\xbb"",\n""\xe6\xb3\xaa"": ""\xe6\xb7\x9a"",\n""\xe6\xb3\xb6"": ""\xe6\xbe\xa9"",\n""\xe6\xb3\xb7"": ""\xe7\x80\xa7"",\n""\xe6\xb3\xb8"": ""\xe7\x80\x98"",\n""\xe6\xb3\xba"": ""\xe6\xbf\xbc"",\n""\xe6\xb3\xbb"": ""\xe7\x80\x89"",\n""\xe6\xb3\xbc"": ""\xe6\xbd\x91"",\n""\xe6\xb3\xbd"": ""\xe6\xbe\xa4"",\n""\xe6\xb3\xbe"": ""\xe6\xb6\x87"",\n""\xe6\xb4\x81"": ""\xe6\xbd\x94"",\n""\xe6\xb4\x92"": ""\xe7\x81\x91"",\n""\xe6\xb4\xbc"": ""\xe7\xaa\xaa"",\n""\xe6\xb5\x83"": ""\xe6\xb5\xb9"",\n""\xe6\xb5\x85"": ""\xe6\xb7\xba"",\n""\xe6\xb5\x86"": ""\xe6\xbc\xbf"",\n""\xe6\xb5\x87"": ""\xe6\xbe\x86"",\n""\xe6\xb5\x88"": ""\xe6\xb9\x9e"",\n""\xe6\xb5\x8a"": ""\xe6\xbf\x81"",\n""\xe6\xb5\x8b"": ""\xe6\xb8\xac"",\n""\xe6\xb5\x8d"": ""\xe6\xbe\xae"",\n""\xe6\xb5\x8e"": ""\xe6\xbf\x9f"",\n""\xe6\xb5\x8f"": ""\xe7\x80\x8f"",\n""\xe6\xb5\x90"": ""\xe6\xbb\xbb"",\n""\xe6\xb5\x91"": ""\xe6\xb8\xbe"",\n""\xe6\xb5\x92"": ""\xe6\xbb\xb8"",\n""\xe6\xb5\x93"": ""\xe6\xbf\x83"",\n""\xe6\xb5\x94"": ""\xe6\xbd\xaf"",\n""\xe6\xb6\x9b"": ""\xe6\xbf\xa4"",\n""\xe6\xb6\x9d"": ""\xe6\xbe\x87"",\n""\xe6\xb6\x9e"": ""\xe6\xb7\xb6"",\n""\xe6\xb6\x9f"": ""\xe6\xbc\xa3"",\n""\xe6\xb6\xa0"": ""\xe6\xbd\xbf"",\n""\xe6\xb6\xa1"": ""\xe6\xb8\xa6"",\n""\xe6\xb6\xa3"": ""\xe6\xb8\x99"",\n""\xe6\xb6\xa4"": ""\xe6\xbb\x8c"",\n""\xe6\xb6\xa6"": ""\xe6\xbd\xa4"",\n""\xe6\xb6\xa7"": ""\xe6\xbe\x97"",\n""\xe6\xb6\xa8"": ""\xe6\xbc\xb2"",\n""\xe6\xb6\xa9"": ""\xe6\xbe\x80"",\n""\xe6\xb8\x8a"": ""\xe6\xb7\xb5"",\n""\xe6\xb8\x8c"": ""\xe6\xb7\xa5"",\n""\xe6\xb8\x8d"": ""\xe6\xbc\xac"",\n""\xe6\xb8\x8e"": ""\xe7\x80\x86"",\n""\xe6\xb8\x90"": ""\xe6\xbc\xb8"",\n""\xe6\xb8\x91"": ""\xe6\xbe\xa0"",\n""\xe6\xb8\x94"": ""\xe6\xbc\x81"",\n""\xe6\xb8\x96"": ""\xe7\x80\x8b"",\n""\xe6\xb8\x97"": ""\xe6\xbb\xb2"",\n""\xe6\xb8\xa9"": ""\xe6\xba\xab"",\n""\xe6\xb9\xbe"": ""\xe7\x81\xa3"",\n""\xe6\xb9\xbf"": ""\xe6\xbf\x95"",\n""\xe6\xba\x83"": ""\xe6\xbd\xb0"",\n""\xe6\xba\x85"": ""\xe6\xbf\xba"",\n""\xe6\xba\x86"": ""\xe6\xbc\xb5"",\n""\xe6\xbb\x97"": ""\xe6\xbd\xb7"",\n""\xe6\xbb\x9a"": ""\xe6\xbb\xbe"",\n""\xe6\xbb\x9e"": ""\xe6\xbb\xaf"",\n""\xe6\xbb\x9f"": ""\xe7\x81\xa7"",\n""\xe6\xbb\xa0"": ""\xe7\x81\x84"",\n""\xe6\xbb\xa1"": ""\xe6\xbb\xbf"",\n""\xe6\xbb\xa2"": ""\xe7\x80\x85"",\n""\xe6\xbb\xa4"": ""\xe6\xbf\xbe"",\n""\xe6\xbb\xa5"": ""\xe6\xbf\xab"",\n""\xe6\xbb\xa6"": ""\xe7\x81\xa4"",\n""\xe6\xbb\xa8"": ""\xe6\xbf\xb1"",\n""\xe6\xbb\xa9"": ""\xe7\x81\x98"",\n""\xe6\xbb\xaa"": ""\xe6\xbe\xa6"",\n""\xe6\xbc\xa4"": ""\xe7\x81\xa0"",\n""\xe6\xbd\x86"": ""\xe7\x80\xa0"",\n""\xe6\xbd\x87"": ""\xe7\x80\x9f"",\n""\xe6\xbd\x8b"": ""\xe7\x80\xb2"",\n""\xe6\xbd\x8d"": ""\xe6\xbf\xb0"",\n""\xe6\xbd\x9c"": ""\xe6\xbd\x9b"",\n""\xe6\xbd\xb4"": ""\xe7\x80\xa6"",\n""\xe6\xbe\x9c"": ""\xe7\x80\xbe"",\n""\xe6\xbf\x91"": ""\xe7\x80\xa8"",\n""\xe6\xbf\x92"": ""\xe7\x80\x95"",\n""\xe3\xb2\xbf"": ""\xe7\x80\x87"",\n""\xe7\x81\x8f"": ""\xe7\x81\x9d"",\n""\xe7\x81\xad"": ""\xe6\xbb\x85"",\n""\xe7\x81\xaf"": ""\xe7\x87\x88"",\n""\xe7\x81\xb5"": ""\xe9\x9d\x88"",\n""\xe7\x81\xb6"": ""\xe7\xab\x88"",\n""\xe7\x81\xbe"": ""\xe7\x81\xbd"",\n""\xe7\x81\xbf"": ""\xe7\x87\xa6"",\n""\xe7\x82\x80"": ""\xe7\x85\xac"",\n""\xe7\x82\x89"": ""\xe7\x88\x90"",\n""\xe7\x82\x96"": ""\xe7\x87\x89"",\n""\xe7\x82\x9c"": ""\xe7\x85\x92"",\n""\xe7\x82\x9d"": ""\xe7\x86\x97"",\n""\xe7\x82\xb9"": ""\xe9\xbb\x9e"",\n""\xe7\x82\xbc"": ""\xe7\x85\x89"",\n""\xe7\x82\xbd"": ""\xe7\x86\xbe"",\n""\xe7\x83\x81"": ""\xe7\x88\x8d"",\n""\xe7\x83\x82"": ""\xe7\x88\x9b"",\n""\xe7\x83\x83"": ""\xe7\x83\xb4"",\n""\xe7\x83\x9b"": ""\xe7\x87\xad"",\n""\xe7\x83\x9f"": ""\xe7\x85\x99"",\n""\xe7\x83\xa6"": ""\xe7\x85\xa9"",\n""\xe7\x83\xa7"": ""\xe7\x87\x92"",\n""\xe7\x83\xa8"": ""\xe7\x87\x81"",\n""\xe7\x83\xa9"": ""\xe7\x87\xb4"",\n""\xe7\x83\xab"": ""\xe7\x87\x99"",\n""\xe7\x83\xac"": ""\xe7\x87\xbc"",\n""\xe7\x83\xad"": ""\xe7\x86\xb1"",\n""\xe7\x84\x95"": ""\xe7\x85\xa5"",\n""\xe7\x84\x96"": ""\xe7\x87\x9c"",\n""\xe7\x84\x98"": ""\xe7\x87\xbe"",\n""\xe3\xb6\xbd"": ""\xe7\x85\xb1"",\n""\xe7\x85\xb4"": ""\xe7\x86\x85"",\n""\xe3\xb6\xb6"": ""\xe7\x87\xb6"",\n""\xe7\x88\xb1"": ""\xe6\x84\x9b"",\n""\xe7\x88\xb7"": ""\xe7\x88\xba"",\n""\xe7\x89\x8d"": ""\xe7\x89\x98"",\n""\xe7\x89\xa6"": ""\xe6\xb0\x82"",\n""\xe7\x89\xb5"": ""\xe7\x89\xbd"",\n""\xe7\x89\xba"": ""\xe7\x8a\xa7"",\n""\xe7\x8a\x8a"": ""\xe7\x8a\xa2"",\n""\xe7\x8a\xb6"": ""\xe7\x8b\x80"",\n""\xe7\x8a\xb7"": ""\xe7\x8d\xb7"",\n""\xe7\x8a\xb8"": ""\xe7\x8d\x81"",\n""\xe7\x8a\xb9"": ""\xe7\x8c\xb6"",\n""\xe7\x8b\x88"": ""\xe7\x8b\xbd"",\n""\xe7\x8b\x9d"": ""\xe7\x8d\xae"",\n""\xe7\x8b\x9e"": ""\xe7\x8d\xb0"",\n""\xe7\x8b\xac"": ""\xe7\x8d\xa8"",\n""\xe7\x8b\xad"": ""\xe7\x8b\xb9"",\n""\xe7\x8b\xae"": ""\xe7\x8d\x85"",\n""\xe7\x8b\xaf"": ""\xe7\x8d\xaa"",\n""\xe7\x8b\xb0"": ""\xe7\x8c\x99"",\n""\xe7\x8b\xb1"": ""\xe7\x8d\x84"",\n""\xe7\x8b\xb2"": ""\xe7\x8c\xbb"",\n""\xe7\x8c\x83"": ""\xe7\x8d\xab"",\n""\xe7\x8c\x8e"": ""\xe7\x8d\xb5"",\n""\xe7\x8c\x95"": ""\xe7\x8d\xbc"",\n""\xe7\x8c\xa1"": ""\xe7\x8e\x80"",\n""\xe7\x8c\xaa"": ""\xe8\xb1\xac"",\n""\xe7\x8c\xab"": ""\xe8\xb2\x93"",\n""\xe7\x8c\xac"": ""\xe8\x9d\x9f"",\n""\xe7\x8c\xae"": ""\xe7\x8d\xbb"",\n""\xe7\x8d\xad"": ""\xe7\x8d\xba"",\n""\xe3\xba\x8d"": ""\xe7\x8d\xb1"",\n""\xe7\x8e\x91"": ""\xe7\x92\xa3"",\n""\xe7\x8e\x9a"": ""\xe7\x91\x92"",\n""\xe7\x8e\x9b"": ""\xe7\x91\xaa"",\n""\xe7\x8e\xae"": ""\xe7\x91\x8b"",\n""\xe7\x8e\xaf"": ""\xe7\x92\xb0"",\n""\xe7\x8e\xb0"": ""\xe7\x8f\xbe"",\n""\xe7\x8e\xb1"": ""\xe7\x91\xb2"",\n""\xe7\x8e\xba"": ""\xe7\x92\xbd"",\n""\xe7\x8f\x90"": ""\xe7\x90\xba"",\n""\xe7\x8f\x91"": ""\xe7\x93\x8f"",\n""\xe7\x8f\xb0"": ""\xe7\x92\xab"",\n""\xe7\x8f\xb2"": ""\xe7\x90\xbf"",\n""\xe7\x90\x8f"": ""\xe7\x92\x89"",\n""\xe7\x90\x90"": ""\xe7\x91\xa3"",\n""\xe7\x90\xbc"": ""\xe7\x93\x8a"",\n""\xe7\x91\xb6"": ""\xe7\x91\xa4"",\n""\xe7\x91\xb7"": ""\xe7\x92\xa6"",\n""\xe7\x92\x8e"": ""\xe7\x93\x94"",\n""\xe7\x93\x92"": ""\xe7\x93\x9a"",\n""\xe7\x93\xaf"": ""\xe7\x94\x8c"",\n""\xe7\x94\xb5"": ""\xe9\x9b\xbb"",\n""\xe7\x94\xbb"": ""\xe7\x95\xab"",\n""\xe7\x95\x85"": ""\xe6\x9a\xa2"",\n""\xe7\x95\xb4"": ""\xe7\x96\x87"",\n""\xe7\x96\x96"": ""\xe7\x99\xa4"",\n""\xe7\x96\x97"": ""\xe7\x99\x82"",\n""\xe7\x96\x9f"": ""\xe7\x98\xa7"",\n""\xe7\x96\xa0"": ""\xe7\x99\x98"",\n""\xe7\x96\xa1"": ""\xe7\x98\x8d"",\n""\xe7\x96\xac"": ""\xe7\x99\xa7"",\n""\xe7\x96\xad"": ""\xe7\x98\xb2"",\n""\xe7\x96\xae"": ""\xe7\x98\xa1"",\n""\xe7\x96\xaf"": ""\xe7\x98\x8b"",\n""\xe7\x96\xb1"": ""\xe7\x9a\xb0"",\n""\xe7\x96\xb4"": ""\xe7\x97\xbe"",\n""\xe7\x97\x88"": ""\xe7\x99\xb0"",\n""\xe7\x97\x89"": ""\xe7\x97\x99"",\n""\xe7\x97\x92"": ""\xe7\x99\xa2"",\n""\xe7\x97\x96"": ""\xe7\x98\x82"",\n""\xe7\x97\xa8"": ""\xe7\x99\x86"",\n""\xe7\x97\xaa"": ""\xe7\x98\x93"",\n""\xe7\x97\xab"": ""\xe7\x99\x87"",\n""\xe7\x98\x85"": ""\xe7\x99\x89"",\n""\xe7\x98\x86"": ""\xe7\x98\xae"",\n""\xe7\x98\x97"": ""\xe7\x98\x9e"",\n""\xe7\x98\xaa"": ""\xe7\x99\x9f"",\n""\xe7\x98\xab"": ""\xe7\x99\xb1"",\n""\xe7\x98\xbe"": ""\xe7\x99\xae"",\n""\xe7\x98\xbf"": ""\xe7\x99\xad"",\n""\xe7\x99\x9e"": ""\xe7\x99\xa9"",\n""\xe7\x99\xa3"": ""\xe7\x99\xac"",\n""\xe7\x99\xab"": ""\xe7\x99\xb2"",\n""\xe7\x9a\x91"": ""\xe7\x9a\x9a"",\n""\xe7\x9a\xb1"": ""\xe7\x9a\xba"",\n""\xe7\x9a\xb2"": ""\xe7\x9a\xb8"",\n""\xe7\x9b\x8f"": ""\xe7\x9b\x9e"",\n""\xe7\x9b\x90"": ""\xe9\xb9\xbd"",\n""\xe7\x9b\x91"": ""\xe7\x9b\xa3"",\n""\xe7\x9b\x96"": ""\xe8\x93\x8b"",\n""\xe7\x9b\x97"": ""\xe7\x9b\x9c"",\n""\xe7\x9b\x98"": ""\xe7\x9b\xa4"",\n""\xe7\x9c\x8d"": ""\xe7\x9e\x98"",\n""\xe7\x9c\xa6"": ""\xe7\x9c\xa5"",\n""\xe7\x9c\xac"": ""\xe7\x9f\x93"",\n""\xe7\x9d\x80"": ""\xe8\x91\x97"",\n""\xe7\x9d\x81"": ""\xe7\x9d\x9c"",\n""\xe7\x9d\x90"": ""\xe7\x9d\x9e"",\n""\xe7\x9d\x91"": ""\xe7\x9e\xbc"",\n""\xe7\x9e\x86"": ""\xe7\x9e\xb6"",\n""\xe7\x9e\x92"": ""\xe7\x9e\x9e"",\n""\xe4\x81\x96"": ""\xe7\x9e\x9c"",\n""\xe7\x9e\xa9"": ""\xe7\x9f\x9a"",\n""\xe7\x9f\xab"": ""\xe7\x9f\xaf"",\n""\xe7\x9f\xb6"": ""\xe7\xa3\xaf"",\n""\xe7\x9f\xbe"": ""\xe7\xa4\xac"",\n""\xe7\x9f\xbf"": ""\xe7\xa4\xa6"",\n""\xe7\xa0\x80"": ""\xe7\xa2\xad"",\n""\xe7\xa0\x81"": ""\xe7\xa2\xbc"",\n""\xe7\xa0\x96"": ""\xe7\xa3\x9a"",\n""\xe7\xa0\x97"": ""\xe7\xa1\xa8"",\n""\xe7\xa0\x9a"": ""\xe7\xa1\xaf"",\n""\xe7\xa0\x9c"": ""\xe7\xa2\xb8"",\n""\xe7\xa0\xba"": ""\xe7\xa4\xaa"",\n""\xe7\xa0\xbb"": ""\xe7\xa4\xb1"",\n""\xe7\xa0\xbe"": ""\xe7\xa4\xab"",\n""\xe7\xa1\x80"": ""\xe7\xa4\x8e"",\n""\xe7\xa1\x81"": ""\xe7\xa1\x9c"",\n""\xe7\xa1\x95"": ""\xe7\xa2\xa9"",\n""\xe7\xa1\x96"": ""\xe7\xa1\xa4"",\n""\xe7\xa1\x97"": ""\xe7\xa3\xbd"",\n""\xe7\xa1\x99"": ""\xe7\xa3\x91"",\n""\xe7\xa2\x8d"": ""\xe7\xa4\x99"",\n""\xe7\xa2\x9b"": ""\xe7\xa3\xa7"",\n""\xe7\xa2\x9c"": ""\xe7\xa3\xa3"",\n""\xe7\xa2\xb1"": ""\xe9\xb9\xbc"",\n""\xe7\xa4\xbc"": ""\xe7\xa6\xae"",\n""\xe7\xa5\x83"": ""\xe7\xa6\xa1"",\n""\xe7\xa5\x8e"": ""\xe7\xa6\x95"",\n""\xe7\xa5\xa2"": ""\xe7\xa6\xb0"",\n""\xe7\xa5\xaf"": ""\xe7\xa6\x8e"",\n""\xe7\xa5\xb7"": ""\xe7\xa6\xb1"",\n""\xe7\xa5\xb8"": ""\xe7\xa6\x8d"",\n""\xe7\xa6\x80"": ""\xe7\xa8\x9f"",\n""\xe7\xa6\x84"": ""\xe7\xa5\xbf"",\n""\xe7\xa6\x85"": ""\xe7\xa6\xaa"",\n""\xe7\xa6\xbb"": ""\xe9\x9b\xa2"",\n""\xe7\xa7\x83"": ""\xe7\xa6\xbf"",\n""\xe7\xa7\x86"": ""\xe7\xa8\x88"",\n""\xe7\xa7\xaf"": ""\xe7\xa9\x8d"",\n""\xe7\xa7\xb0"": ""\xe7\xa8\xb1"",\n""\xe7\xa7\xbd"": ""\xe7\xa9\xa2"",\n""\xe7\xa7\xbe"": ""\xe7\xa9\xa0"",\n""\xe7\xa8\x86"": ""\xe7\xa9\xad"",\n""\xe7\xa8\x8e"": ""\xe7\xa8\x85"",\n""\xe4\x85\x89"": ""\xe7\xa8\x8f"",\n""\xe7\xa8\xa3"": ""\xe7\xa9\x8c"",\n""\xe7\xa8\xb3"": ""\xe7\xa9\xa9"",\n""\xe7\xa9\x91"": ""\xe7\xa9\xa1"",\n""\xe7\xa9\xb7"": ""\xe7\xaa\xae"",\n""\xe7\xaa\x83"": ""\xe7\xab\x8a"",\n""\xe7\xaa\x8d"": ""\xe7\xab\x85"",\n""\xe7\xaa\x8e"": ""\xe7\xaa\xb5"",\n""\xe7\xaa\x91"": ""\xe7\xaa\xaf"",\n""\xe7\xaa\x9c"": ""\xe7\xab\x84"",\n""\xe7\xaa\x9d"": ""\xe7\xaa\xa9"",\n""\xe7\xaa\xa5"": ""\xe7\xaa\xba"",\n""\xe7\xaa\xa6"": ""\xe7\xab\x87"",\n""\xe7\xaa\xad"": ""\xe7\xaa\xb6"",\n""\xe7\xab\x9e"": ""\xe7\xab\xb6"",\n""\xe7\xac\x83"": ""\xe7\xaf\xa4"",\n""\xe7\xac\x8b"": ""\xe7\xad\x8d"",\n""\xe7\xac\x94"": ""\xe7\xad\x86"",\n""\xe7\xac\x95"": ""\xe7\xad\xa7"",\n""\xe7\xac\xba"": ""\xe7\xae\x8b"",\n""\xe7\xac\xbc"": ""\xe7\xb1\xa0"",\n""\xe7\xac\xbe"": ""\xe7\xb1\xa9"",\n""\xe7\xad\x9a"": ""\xe7\xaf\xb3"",\n""\xe7\xad\x9b"": ""\xe7\xaf\xa9"",\n""\xe7\xad\x9c"": ""\xe7\xb0\xb9"",\n""\xe7\xad\x9d"": ""\xe7\xae\x8f"",\n""\xe4\x87\xb2"": ""\xe7\xad\xb4"",\n""\xe7\xad\xb9"": ""\xe7\xb1\x8c"",\n""\xe7\xad\xbc"": ""\xe7\xaf\x94"",\n""\xe7\xae\x80"": ""\xe7\xb0\xa1"",\n""\xe7\xae\x93"": ""\xe7\xb1\x99"",\n""\xe7\xae\xa6"": ""\xe7\xb0\x80"",\n""\xe7\xae\xa7"": ""\xe7\xaf\x8b"",\n""\xe7\xae\xa8"": ""\xe7\xb1\x9c"",\n""\xe7\xae\xa9"": ""\xe7\xb1\xae"",\n""\xe7\xae\xaa"": ""\xe7\xb0\x9e"",\n""\xe7\xae\xab"": ""\xe7\xb0\xab"",\n""\xe7\xaf\x91"": ""\xe7\xb0\xa3"",\n""\xe7\xaf\x93"": ""\xe7\xb0\x8d"",\n""\xe7\xaf\xae"": ""\xe7\xb1\x83"",\n""\xe7\xaf\xb1"": ""\xe7\xb1\xac"",\n""\xe7\xb0\x96"": ""\xe7\xb1\xaa"",\n""\xe7\xb1\x81"": ""\xe7\xb1\x9f"",\n""\xe7\xb1\xb4"": ""\xe7\xb3\xb4"",\n""\xe7\xb1\xbb"": ""\xe9\xa1\x9e"",\n""\xe7\xb1\xbc"": ""\xe7\xa7\x88"",\n""\xe7\xb2\x9c"": ""\xe7\xb3\xb6"",\n""\xe7\xb2\x9d"": ""\xe7\xb3\xb2"",\n""\xe7\xb2\xa4"": ""\xe7\xb2\xb5"",\n""\xe7\xb2\xaa"": ""\xe7\xb3\x9e"",\n""\xe7\xb2\xae"": ""\xe7\xb3\xa7"",\n""\xe7\xb3\x81"": ""\xe7\xb3\x9d"",\n""\xe7\xb3\x87"": ""\xe9\xa4\xb1"",\n""\xe7\xb4\xa7"": ""\xe7\xb7\x8a"",\n""\xe4\x8c\xb7"": ""\xe7\xb4\xac"",\n""\xe4\x8c\xb9"": ""\xe7\xb5\x85"",\n""\xe7\xb5\xb7"": ""\xe7\xb8\xb6"",\n""\xe4\x8c\xbc"": ""\xe7\xb6\x90"",\n""\xe4\x8c\xbd"": ""\xe7\xb6\xb5"",\n""\xe4\x8c\xb8"": ""\xe7\xb8\xb3"",\n""\xe4\x8d\x81"": ""\xe7\xb9\xb8"",\n""\xe4\x8d\x80"": ""\xe7\xb9\xbf"",\n""\xe7\xba\x9f"": ""\xe7\xb3\xb9"",\n""\xe7\xba\xa0"": ""\xe7\xb3\xbe"",\n""\xe7\xba\xa1"": ""\xe7\xb4\x86"",\n""\xe7\xba\xa2"": ""\xe7\xb4\x85"",\n""\xe7\xba\xa3"": ""\xe7\xb4\x82"",\n""\xe7\xba\xa5"": ""\xe7\xb4\x87"",\n""\xe7\xba\xa6"": ""\xe7\xb4\x84"",\n""\xe7\xba\xa7"": ""\xe7\xb4\x9a"",\n""\xe7\xba\xa8"": ""\xe7\xb4\x88"",\n""\xe7\xba\xa9"": ""\xe7\xba\x8a"",\n""\xe7\xba\xaa"": ""\xe7\xb4\x80"",\n""\xe7\xba\xab"": ""\xe7\xb4\x89"",\n""\xe7\xba\xac"": ""\xe7\xb7\xaf"",\n""\xe7\xba\xad"": ""\xe7\xb4\x9c"",\n""\xe7\xba\xae"": ""\xe7\xb4\x98"",\n""\xe7\xba\xaf"": ""\xe7\xb4\x94"",\n""\xe7\xba\xb0"": ""\xe7\xb4\x95"",\n""\xe7\xba\xb1"": ""\xe7\xb4\x97"",\n""\xe7\xba\xb2"": ""\xe7\xb6\xb1"",\n""\xe7\xba\xb3"": ""\xe7\xb4\x8d"",\n""\xe7\xba\xb4"": ""\xe7\xb4\x9d"",\n""\xe7\xba\xb5"": ""\xe7\xb8\xb1"",\n""\xe7\xba\xb6"": ""\xe7\xb6\xb8"",\n""\xe7\xba\xb7"": ""\xe7\xb4\x9b"",\n""\xe7\xba\xb8"": ""\xe7\xb4\x99"",\n""\xe7\xba\xb9"": ""\xe7\xb4\x8b"",\n""\xe7\xba\xba"": ""\xe7\xb4\xa1"",\n""\xe7\xba\xbb"": ""\xe7\xb4\xb5"",\n""\xe7\xba\xbc"": ""\xe7\xb4\x96"",\n""\xe7\xba\xbd"": ""\xe7\xb4\x90"",\n""\xe7\xba\xbe"": ""\xe7\xb4\x93"",\n""\xe7\xbb\x80"": ""\xe7\xb4\xba"",\n""\xe7\xbb\x81"": ""\xe7\xb4\xb2"",\n""\xe7\xbb\x82"": ""\xe7\xb4\xb1"",\n""\xe7\xbb\x83"": ""\xe7\xb7\xb4"",\n""\xe7\xbb\x84"": ""\xe7\xb5\x84"",\n""\xe7\xbb\x85"": ""\xe7\xb4\xb3"",\n""\xe7\xbb\x86"": ""\xe7\xb4\xb0"",\n""\xe7\xbb\x87"": ""\xe7\xb9\x94"",\n""\xe7\xbb\x88"": ""\xe7\xb5\x82"",\n""\xe7\xbb\x89"": ""\xe7\xb8\x90"",\n""\xe7\xbb\x8a"": ""\xe7\xb5\x86"",\n""\xe7\xbb\x8b"": ""\xe7\xb4\xbc"",\n""\xe7\xbb\x8c"": ""\xe7\xb5\x80"",\n""\xe7\xbb\x8d"": ""\xe7\xb4\xb9"",\n""\xe7\xbb\x8e"": ""\xe7\xb9\xb9"",\n""\xe7\xbb\x8f"": ""\xe7\xb6\x93"",\n""\xe7\xbb\x90"": ""\xe7\xb4\xbf"",\n""\xe7\xbb\x91"": ""\xe7\xb6\x81"",\n""\xe7\xbb\x92"": ""\xe7\xb5\xa8"",\n""\xe7\xbb\x93"": ""\xe7\xb5\x90"",\n""\xe7\xbb\x94"": ""\xe7\xb5\x9d"",\n""\xe7\xbb\x95"": ""\xe7\xb9\x9e"",\n""\xe7\xbb\x96"": ""\xe7\xb5\xb0"",\n""\xe7\xbb\x97"": ""\xe7\xb5\x8e"",\n""\xe7\xbb\x98"": ""\xe7\xb9\xaa"",\n""\xe7\xbb\x99"": ""\xe7\xb5\xa6"",\n""\xe7\xbb\x9a"": ""\xe7\xb5\xa2"",\n""\xe7\xbb\x9b"": ""\xe7\xb5\xb3"",\n""\xe7\xbb\x9c"": ""\xe7\xb5\xa1"",\n""\xe7\xbb\x9e"": ""\xe7\xb5\x9e"",\n""\xe7\xbb\x9f"": ""\xe7\xb5\xb1"",\n""\xe7\xbb\xa0"": ""\xe7\xb6\x86"",\n""\xe7\xbb\xa1"": ""\xe7\xb6\x83"",\n""\xe7\xbb\xa2"": ""\xe7\xb5\xb9"",\n""\xe7\xbb\xa4"": ""\xe7\xb6\x8c"",\n""\xe7\xbb\xa5"": ""\xe7\xb6\x8f"",\n""\xe7\xbb\xa7"": ""\xe7\xb9\xbc"",\n""\xe7\xbb\xa8"": ""\xe7\xb6\x88"",\n""\xe7\xbb\xa9"": ""\xe7\xb8\xbe"",\n""\xe7\xbb\xaa"": ""\xe7\xb7\x92"",\n""\xe7\xbb\xab"": ""\xe7\xb6\xbe"",\n""\xe7\xbb\xac"": ""\xe7\xb7\x93"",\n""\xe7\xbb\xad"": ""\xe7\xba\x8c"",\n""\xe7\xbb\xae"": ""\xe7\xb6\xba"",\n""\xe7\xbb\xaf"": ""\xe7\xb7\x8b"",\n""\xe7\xbb\xb0"": ""\xe7\xb6\xbd"",\n""\xe7\xbb\xb2"": ""\xe7\xb7\x84"",\n""\xe7\xbb\xb3"": ""\xe7\xb9\xa9"",\n""\xe7\xbb\xb4"": ""\xe7\xb6\xad"",\n""\xe7\xbb\xb5"": ""\xe7\xb6\xbf"",\n""\xe7\xbb\xb6"": ""\xe7\xb6\xac"",\n""\xe7\xbb\xb8"": ""\xe7\xb6\xa2"",\n""\xe7\xbb\xb9"": ""\xe7\xb6\xaf"",\n""\xe7\xbb\xba"": ""\xe7\xb6\xb9"",\n""\xe7\xbb\xbb"": ""\xe7\xb6\xa3"",\n""\xe7\xbb\xbc"": ""\xe7\xb6\x9c"",\n""\xe7\xbb\xbd"": ""\xe7\xb6\xbb"",\n""\xe7\xbb\xbe"": ""\xe7\xb6\xb0"",\n""\xe7\xbc\x80"": ""\xe7\xb6\xb4"",\n""\xe7\xbc\x81"": ""\xe7\xb7\x87"",\n""\xe7\xbc\x82"": ""\xe7\xb7\x99"",\n""\xe7\xbc\x83"": ""\xe7\xb7\x97"",\n""\xe7\xbc\x84"": ""\xe7\xb7\x98"",\n""\xe7\xbc\x85"": ""\xe7\xb7\xac"",\n""\xe7\xbc\x86"": ""\xe7\xba\x9c"",\n""\xe7\xbc\x87"": ""\xe7\xb7\xb9"",\n""\xe7\xbc\x88"": ""\xe7\xb7\xb2"",\n""\xe7\xbc\x89"": ""\xe7\xb7\x9d"",\n""\xe7\xbc\x8a"": ""\xe7\xb8\x95"",\n""\xe7\xbc\x8b"": ""\xe7\xb9\xa2"",\n""\xe7\xbc\x8c"": ""\xe7\xb7\xa6"",\n""\xe7\xbc\x8d"": ""\xe7\xb6\x9e"",\n""\xe7\xbc\x8e"": ""\xe7\xb7\x9e"",\n""\xe7\xbc\x8f"": ""\xe7\xb7\xb6"",\n""\xe7\xbc\x91"": ""\xe7\xb7\xb1"",\n""\xe7\xbc\x92"": ""\xe7\xb8\x8b"",\n""\xe7\xbc\x93"": ""\xe7\xb7\xa9"",\n""\xe7\xbc\x94"": ""\xe7\xb7\xa0"",\n""\xe7\xbc\x95"": ""\xe7\xb8\xb7"",\n""\xe7\xbc\x96"": ""\xe7\xb7\xa8"",\n""\xe7\xbc\x97"": ""\xe7\xb7\xa1"",\n""\xe7\xbc\x98"": ""\xe7\xb7\xa3"",\n""\xe7\xbc\x99"": ""\xe7\xb8\x89"",\n""\xe7\xbc\x9a"": ""\xe7\xb8\x9b"",\n""\xe7\xbc\x9b"": ""\xe7\xb8\x9f"",\n""\xe7\xbc\x9c"": ""\xe7\xb8\x9d"",\n""\xe7\xbc\x9d"": ""\xe7\xb8\xab"",\n""\xe7\xbc\x9e"": ""\xe7\xb8\x97"",\n""\xe7\xbc\x9f"": ""\xe7\xb8\x9e"",\n""\xe7\xbc\xa0"": ""\xe7\xba\x8f"",\n""\xe7\xbc\xa1"": ""\xe7\xb8\xad"",\n""\xe7\xbc\xa2"": ""\xe7\xb8\x8a"",\n""\xe7\xbc\xa3"": ""\xe7\xb8\x91"",\n""\xe7\xbc\xa4"": ""\xe7\xb9\xbd"",\n""\xe7\xbc\xa5"": ""\xe7\xb8\xb9"",\n""\xe7\xbc\xa6"": ""\xe7\xb8\xb5"",\n""\xe7\xbc\xa7"": ""\xe7\xb8\xb2"",\n""\xe7\xbc\xa8"": ""\xe7\xba\x93"",\n""\xe7\xbc\xa9"": ""\xe7\xb8\xae"",\n""\xe7\xbc\xaa"": ""\xe7\xb9\x86"",\n""\xe7\xbc\xab"": ""\xe7\xb9\x85"",\n""\xe7\xbc\xac"": ""\xe7\xba\x88"",\n""\xe7\xbc\xad"": ""\xe7\xb9\x9a"",\n""\xe7\xbc\xae"": ""\xe7\xb9\x95"",\n""\xe7\xbc\xaf"": ""\xe7\xb9\x92"",\n""\xe7\xbc\xb1"": ""\xe7\xb9\xbe"",\n""\xe7\xbc\xb2"": ""\xe7\xb9\xb0"",\n""\xe7\xbc\xb3"": ""\xe7\xb9\xaf"",\n""\xe7\xbc\xb4"": ""\xe7\xb9\xb3"",\n""\xe7\xbc\xb5"": ""\xe7\xba\x98"",\n""\xe7\xbd\x82"": ""\xe7\xbd\x8c"",\n""\xe7\xbd\x91"": ""\xe7\xb6\xb2"",\n""\xe7\xbd\x97"": ""\xe7\xbe\x85"",\n""\xe7\xbd\x9a"": ""\xe7\xbd\xb0"",\n""\xe7\xbd\xa2"": ""\xe7\xbd\xb7"",\n""\xe7\xbd\xb4"": ""\xe7\xbe\x86"",\n""\xe7\xbe\x81"": ""\xe7\xbe\x88"",\n""\xe7\xbe\x9f"": ""\xe7\xbe\xa5"",\n""\xe7\xbf\x98"": ""\xe7\xbf\xb9"",\n""\xe8\x80\xa2"": ""\xe8\x80\xae"",\n""\xe8\x80\xa7"": ""\xe8\x80\xac"",\n""\xe8\x80\xb8"": ""\xe8\x81\xb3"",\n""\xe8\x80\xbb"": ""\xe6\x81\xa5"",\n""\xe8\x81\x82"": ""\xe8\x81\xb6"",\n""\xe8\x81\x8b"": ""\xe8\x81\xbe"",\n""\xe8\x81\x8c"": ""\xe8\x81\xb7"",\n""\xe8\x81\x8d"": ""\xe8\x81\xb9"",\n""\xe8\x81\x94"": ""\xe8\x81\xaf"",\n""\xe8\x81\xa9"": ""\xe8\x81\xb5"",\n""\xe8\x81\xaa"": ""\xe8\x81\xb0"",\n""\xe8\x82\x83"": ""\xe8\x82\x85"",\n""\xe8\x82\xa0"": ""\xe8\x85\xb8"",\n""\xe8\x82\xa4"": ""\xe8\x86\x9a"",\n""\xe8\x82\xae"": ""\xe9\xaa\xaf"",\n""\xe8\x82\xb4"": ""\xe9\xa4\x9a"",\n""\xe8\x82\xbe"": ""\xe8\x85\x8e"",\n""\xe8\x82\xbf"": ""\xe8\x85\xab"",\n""\xe8\x83\x80"": ""\xe8\x84\xb9"",\n""\xe8\x83\x81"": ""\xe8\x84\x85"",\n""\xe8\x83\x86"": ""\xe8\x86\xbd"",\n""\xe8\x83\xa7"": ""\xe6\x9c\xa7"",\n""\xe8\x83\xa8"": ""\xe8\x85\x96"",\n""\xe8\x83\xaa"": ""\xe8\x87\x9a"",\n""\xe8\x83\xab"": ""\xe8\x84\x9b"",\n""\xe8\x83\xb6"": ""\xe8\x86\xa0"",\n""\xe8\x84\x89"": ""\xe8\x84\x88"",\n""\xe8\x84\x8d"": ""\xe8\x86\xbe"",\n""\xe8\x84\x90"": ""\xe8\x87\x8d"",\n""\xe8\x84\x91"": ""\xe8\x85\xa6"",\n""\xe8\x84\x93"": ""\xe8\x86\xbf"",\n""\xe8\x84\x94"": ""\xe8\x87\xa0"",\n""\xe8\x84\x9a"": ""\xe8\x85\xb3"",\n""\xe8\x84\xb1"": ""\xe8\x84\xab"",\n""\xe8\x84\xb6"": ""\xe8\x85\xa1"",\n""\xe8\x84\xb8"": ""\xe8\x87\x89"",\n""\xe8\x85\xad"": ""\xe9\xbd\xb6"",\n""\xe8\x85\xbb"": ""\xe8\x86\xa9"",\n""\xe8\x85\xbc"": ""\xe9\x9d\xa6"",\n""\xe8\x85\xbd"": ""\xe8\x86\x83"",\n""\xe8\x85\xbe"": ""\xe9\xa8\xb0"",\n""\xe8\x86\x91"": ""\xe8\x87\x8f"",\n""\xe8\x87\x9c"": ""\xe8\x87\xa2"",\n""\xe8\x88\x86"": ""\xe8\xbc\xbf"",\n""\xe8\x88\xa3"": ""\xe8\x89\xa4"",\n""\xe8\x88\xb0"": ""\xe8\x89\xa6"",\n""\xe8\x88\xb1"": ""\xe8\x89\x99"",\n""\xe8\x88\xbb"": ""\xe8\x89\xab"",\n""\xe8\x89\xb0"": ""\xe8\x89\xb1"",\n""\xe8\x89\xb3"": ""\xe8\x89\xb7"",\n""\xe8\x89\xba"": ""\xe8\x97\x9d"",\n""\xe8\x8a\x82"": ""\xe7\xaf\x80"",\n""\xe8\x8a\x88"": ""\xe7\xbe\x8b"",\n""\xe8\x8a\x97"": ""\xe8\x96\x8c"",\n""\xe8\x8a\x9c"": ""\xe8\x95\xaa"",\n""\xe8\x8a\xa6"": ""\xe8\x98\x86"",\n""\xe8\x8b\x81"": ""\xe8\x93\xaf"",\n""\xe8\x8b\x87"": ""\xe8\x91\xa6"",\n""\xe8\x8b\x88"": ""\xe8\x97\xb6"",\n""\xe8\x8b\x8b"": ""\xe8\x8e\xa7"",\n""\xe8\x8b\x8c"": ""\xe8\x90\x87"",\n""\xe8\x8b\x8d"": ""\xe8\x92\xbc"",\n""\xe8\x8b\x8e"": ""\xe8\x8b\xa7"",\n""\xe8\x8c\x8e"": ""\xe8\x8e\x96"",\n""\xe8\x8c\x8f"": ""\xe8\x98\xa2"",\n""\xe8\x8c\x91"": ""\xe8\x94\xa6"",\n""\xe8\x8c\x94"": ""\xe5\xa1\x8b"",\n""\xe8\x8c\x95"": ""\xe7\x85\xa2"",\n""\xe8\x8c\xa7"": ""\xe7\xb9\xad"",\n""\xe8\x8d\x86"": ""\xe8\x8d\x8a"",\n""\xe8\x8d\x90"": ""\xe8\x96\xa6"",\n""\xe8\x8d\x99"": ""\xe8\x96\x98"",\n""\xe8\x8d\x9a"": ""\xe8\x8e\xa2"",\n""\xe8\x8d\x9b"": ""\xe8\x95\x98"",\n""\xe8\x8d\x9c"": ""\xe8\x93\xbd"",\n""\xe8\x8d\x9e"": ""\xe8\x95\x8e"",\n""\xe8\x8d\x9f"": ""\xe8\x96\x88"",\n""\xe8\x8d\xa0"": ""\xe8\x96\xba"",\n""\xe8\x8d\xa3"": ""\xe6\xa6\xae"",\n""\xe8\x8d\xa4"": ""\xe8\x91\xb7"",\n""\xe8\x8d\xa5"": ""\xe6\xbb\x8e"",\n""\xe8\x8d\xa6"": ""\xe7\x8a\x96"",\n""\xe8\x8d\xa7"": ""\xe7\x86\x92"",\n""\xe8\x8d\xa8"": ""\xe8\x95\x81"",\n""\xe8\x8d\xa9"": ""\xe8\x97\x8e"",\n""\xe8\x8d\xaa"": ""\xe8\x93\x80"",\n""\xe8\x8d\xab"": ""\xe8\x94\xad"",\n""\xe8\x8d\xac"": ""\xe8\x95\x92"",\n""\xe8\x8d\xad"": ""\xe8\x91\x92"",\n""\xe8\x8d\xae"": ""\xe8\x91\xa4"",\n""\xe8\x8e\x85"": ""\xe8\x92\x9e"",\n""\xe8\x8e\xb1"": ""\xe8\x90\x8a"",\n""\xe8\x8e\xb2"": ""\xe8\x93\xae"",\n""\xe8\x8e\xb3"": ""\xe8\x92\x94"",\n""\xe8\x8e\xb4"": ""\xe8\x90\xb5"",\n""\xe8\x8e\xb6"": ""\xe8\x96\x9f"",\n""\xe8\x8e\xb8"": ""\xe8\x95\x95"",\n""\xe8\x8e\xb9"": ""\xe7\x91\xa9"",\n""\xe8\x8e\xba"": ""\xe9\xb6\xaf"",\n""\xe8\x90\x9d"": ""\xe8\x98\xbf"",\n""\xe8\x90\xa4"": ""\xe8\x9e\xa2"",\n""\xe8\x90\xa5"": ""\xe7\x87\x9f"",\n""\xe8\x90\xa6"": ""\xe7\xb8\x88"",\n""\xe8\x90\xa7"": ""\xe8\x95\xad"",\n""\xe8\x90\xa8"": ""\xe8\x96\xa9"",\n""\xe8\x91\xb1"": ""\xe8\x94\xa5"",\n""\xe8\x92\x87"": ""\xe8\x95\x86"",\n""\xe8\x92\x89"": ""\xe8\x95\xa2"",\n""\xe8\x92\x8b"": ""\xe8\x94\xa3"",\n""\xe8\x92\x8c"": ""\xe8\x94\x9e"",\n""\xe8\x93\x9d"": ""\xe8\x97\x8d"",\n""\xe8\x93\x9f"": ""\xe8\x96\x8a"",\n""\xe8\x93\xa0"": ""\xe8\x98\xba"",\n""\xe8\x93\xa3"": ""\xe8\x95\xb7"",\n""\xe8\x93\xa5"": ""\xe9\x8e\xa3"",\n""\xe8\x93\xa6"": ""\xe9\xa9\x80"",\n""\xe8\x94\x82"": ""\xe8\x99\x86"",\n""\xe8\x94\xb7"": ""\xe8\x96\x94"",\n""\xe8\x94\xb9"": ""\xe8\x98\x9e"",\n""\xe8\x94\xba"": ""\xe8\x97\xba"",\n""\xe8\x94\xbc"": ""\xe8\x97\xb9"",\n""\xe8\x95\xb0"": ""\xe8\x96\x80"",\n""\xe8\x95\xb2"": ""\xe8\x98\x84"",\n""\xe8\x96\xae"": ""\xe8\x97\xaa"",\n""\xe4\x93\x95"": ""\xe8\x96\xb3"",\n""\xe8\x97\x93"": ""\xe8\x98\x9a"",\n""\xe8\x98\x96"": ""\xe6\xab\xb1"",\n""\xe8\x99\x8f"": ""\xe8\x99\x9c"",\n""\xe8\x99\x91"": ""\xe6\x85\xae"",\n""\xe8\x99\x9a"": ""\xe8\x99\x9b"",\n""\xe8\x99\xac"": ""\xe8\x99\xaf"",\n""\xe8\x99\xae"": ""\xe8\x9f\xa3"",\n""\xe8\x99\xbd"": ""\xe9\x9b\x96"",\n""\xe8\x99\xbe"": ""\xe8\x9d\xa6"",\n""\xe8\x99\xbf"": ""\xe8\xa0\x86"",\n""\xe8\x9a\x80"": ""\xe8\x9d\x95"",\n""\xe8\x9a\x81"": ""\xe8\x9f\xbb"",\n""\xe8\x9a\x82"": ""\xe8\x9e\x9e"",\n""\xe8\x9a\x95"": ""\xe8\xa0\xb6"",\n""\xe8\x9a\xac"": ""\xe8\x9c\x86"",\n""\xe8\x9b\x8a"": ""\xe8\xa0\xb1"",\n""\xe8\x9b\x8e"": ""\xe8\xa0\xa3"",\n""\xe8\x9b\x8f"": ""\xe8\x9f\xb6"",\n""\xe8\x9b\xae"": ""\xe8\xa0\xbb"",\n""\xe8\x9b\xb0"": ""\xe8\x9f\x84"",\n""\xe8\x9b\xb1"": ""\xe8\x9b\xba"",\n""\xe8\x9b\xb2"": ""\xe8\x9f\xaf"",\n""\xe8\x9b\xb3"": ""\xe8\x9e\x84"",\n""\xe8\x9b\xb4"": ""\xe8\xa0\x90"",\n""\xe8\x9c\x95"": ""\xe8\x9b\xbb"",\n""\xe8\x9c\x97"": ""\xe8\x9d\xb8"",\n""\xe8\x9d\x87"": ""\xe8\xa0\x85"",\n""\xe8\x9d\x88"": ""\xe8\x9f\x88"",\n""\xe8\x9d\x89"": ""\xe8\x9f\xac"",\n""\xe8\x9d\xbc"": ""\xe8\x9e\xbb"",\n""\xe8\x9d\xbe"": ""\xe8\xa0\x91"",\n""\xe8\x9e\x80"": ""\xe8\x9e\xbf"",\n""\xe8\x9e\xa8"": ""\xe8\x9f\x8e"",\n""\xe4\x97\x96"": ""\xe8\x9e\xae"",\n""\xe8\x9f\x8f"": ""\xe8\xa0\xa8"",\n""\xe8\xa1\x85"": ""\xe9\x87\x81"",\n""\xe8\xa1\x94"": ""\xe9\x8a\x9c"",\n""\xe8\xa1\xa5"": ""\xe8\xa3\x9c"",\n""\xe8\xa1\xac"": ""\xe8\xa5\xaf"",\n""\xe8\xa1\xae"": ""\xe8\xa2\x9e"",\n""\xe8\xa2\x84"": ""\xe8\xa5\x96"",\n""\xe8\xa2\x85"": ""\xe8\xa3\x8a"",\n""\xe8\xa2\x86"": ""\xe8\xa4\x98"",\n""\xe8\xa2\x9c"": ""\xe8\xa5\xaa"",\n""\xe8\xa2\xad"": ""\xe8\xa5\xb2"",\n""\xe8\xa2\xaf"": ""\xe8\xa5\x8f"",\n""\xe8\xa3\x85"": ""\xe8\xa3\x9d"",\n""\xe8\xa3\x86"": ""\xe8\xa5\xa0"",\n""\xe8\xa3\x88"": ""\xe8\xa4\x8c"",\n""\xe8\xa3\xa2"": ""\xe8\xa4\xb3"",\n""\xe8\xa3\xa3"": ""\xe8\xa5\x9d"",\n""\xe8\xa3\xa4"": ""\xe8\xa4\xb2"",\n""\xe8\xa3\xa5"": ""\xe8\xa5\x87"",\n""\xe8\xa4\x9b"": ""\xe8\xa4\xb8"",\n""\xe8\xa4\xb4"": ""\xe8\xa5\xa4"",\n""\xe4\x99\x93"": ""\xe8\xa5\xac"",\n""\xe8\xa7\x81"": ""\xe8\xa6\x8b"",\n""\xe8\xa7\x82"": ""\xe8\xa7\x80"",\n""\xe8\xa7\x83"": ""\xe8\xa6\x8e"",\n""\xe8\xa7\x84"": ""\xe8\xa6\x8f"",\n""\xe8\xa7\x85"": ""\xe8\xa6\x93"",\n""\xe8\xa7\x86"": ""\xe8\xa6\x96"",\n""\xe8\xa7\x87"": ""\xe8\xa6\x98"",\n""\xe8\xa7\x88"": ""\xe8\xa6\xbd"",\n""\xe8\xa7\x89"": ""\xe8\xa6\xba"",\n""\xe8\xa7\x8a"": ""\xe8\xa6\xac"",\n""\xe8\xa7\x8b"": ""\xe8\xa6\xa1"",\n""\xe8\xa7\x8c"": ""\xe8\xa6\xbf"",\n""\xe8\xa7\x8d"": ""\xe8\xa6\xa5"",\n""\xe8\xa7\x8e"": ""\xe8\xa6\xa6"",\n""\xe8\xa7\x8f"": ""\xe8\xa6\xaf"",\n""\xe8\xa7\x90"": ""\xe8\xa6\xb2"",\n""\xe8\xa7\x91"": ""\xe8\xa6\xb7"",\n""\xe8\xa7\x9e"": ""\xe8\xa7\xb4"",\n""\xe8\xa7\xa6"": ""\xe8\xa7\xb8"",\n""\xe8\xa7\xaf"": ""\xe8\xa7\xb6"",\n""\xe8\xa8\x9a"": ""\xe8\xaa\xbe"",\n""\xe4\x9c\xa3"": ""\xe8\xa8\xa2"",\n""\xe8\xaa\x89"": ""\xe8\xad\xbd"",\n""\xe8\xaa\x8a"": ""\xe8\xac\x84"",\n""\xe4\x9c\xa7"": ""\xe8\xad\x85"",\n""\xe8\xae\xa0"": ""\xe8\xa8\x81"",\n""\xe8\xae\xa1"": ""\xe8\xa8\x88"",\n""\xe8\xae\xa2"": ""\xe8\xa8\x82"",\n""\xe8\xae\xa3"": ""\xe8\xa8\x83"",\n""\xe8\xae\xa4"": ""\xe8\xaa\x8d"",\n""\xe8\xae\xa5"": ""\xe8\xad\x8f"",\n""\xe8\xae\xa6"": ""\xe8\xa8\x90"",\n""\xe8\xae\xa7"": ""\xe8\xa8\x8c"",\n""\xe8\xae\xa8"": ""\xe8\xa8\x8e"",\n""\xe8\xae\xa9"": ""\xe8\xae\x93"",\n""\xe8\xae\xaa"": ""\xe8\xa8\x95"",\n""\xe8\xae\xab"": ""\xe8\xa8\x96"",\n""\xe8\xae\xac"": ""\xe8\xa8\x97"",\n""\xe8\xae\xad"": ""\xe8\xa8\x93"",\n""\xe8\xae\xae"": ""\xe8\xad\xb0"",\n""\xe8\xae\xaf"": ""\xe8\xa8\x8a"",\n""\xe8\xae\xb0"": ""\xe8\xa8\x98"",\n""\xe8\xae\xb1"": ""\xe8\xa8\x92"",\n""\xe8\xae\xb2"": ""\xe8\xac\x9b"",\n""\xe8\xae\xb3"": ""\xe8\xab\xb1"",\n""\xe8\xae\xb4"": ""\xe8\xac\xb3"",\n""\xe8\xae\xb5"": ""\xe8\xa9\x8e"",\n""\xe8\xae\xb6"": ""\xe8\xa8\x9d"",\n""\xe8\xae\xb7"": ""\xe8\xa8\xa5"",\n""\xe8\xae\xb8"": ""\xe8\xa8\xb1"",\n""\xe8\xae\xb9"": ""\xe8\xa8\x9b"",\n""\xe8\xae\xba"": ""\xe8\xab\x96"",\n""\xe8\xae\xbb"": ""\xe8\xa8\xa9"",\n""\xe8\xae\xbc"": ""\xe8\xa8\x9f"",\n""\xe8\xae\xbd"": ""\xe8\xab\xb7"",\n""\xe8\xae\xbe"": ""\xe8\xa8\xad"",\n""\xe8\xae\xbf"": ""\xe8\xa8\xaa"",\n""\xe8\xaf\x80"": ""\xe8\xa8\xa3"",\n""\xe8\xaf\x81"": ""\xe8\xad\x89"",\n""\xe8\xaf\x82"": ""\xe8\xa9\x81"",\n""\xe8\xaf\x83"": ""\xe8\xa8\xb6"",\n""\xe8\xaf\x84"": ""\xe8\xa9\x95"",\n""\xe8\xaf\x85"": ""\xe8\xa9\x9b"",\n""\xe8\xaf\x86"": ""\xe8\xad\x98"",\n""\xe8\xaf\x87"": ""\xe8\xa9\x97"",\n""\xe8\xaf\x88"": ""\xe8\xa9\x90"",\n""\xe8\xaf\x89"": ""\xe8\xa8\xb4"",\n""\xe8\xaf\x8a"": ""\xe8\xa8\xba"",\n""\xe8\xaf\x8b"": ""\xe8\xa9\x86"",\n""\xe8\xaf\x8c"": ""\xe8\xac\x85"",\n""\xe8\xaf\x8d"": ""\xe8\xa9\x9e"",\n""\xe8\xaf\x8e"": ""\xe8\xa9\x98"",\n""\xe8\xaf\x8f"": ""\xe8\xa9\x94"",\n""\xe8\xaf\x90"": ""\xe8\xa9\x96"",\n""\xe8\xaf\x91"": ""\xe8\xad\xaf"",\n""\xe8\xaf\x92"": ""\xe8\xa9\x92"",\n""\xe8\xaf\x93"": ""\xe8\xaa\x86"",\n""\xe8\xaf\x94"": ""\xe8\xaa\x84"",\n""\xe8\xaf\x95"": ""\xe8\xa9\xa6"",\n""\xe8\xaf\x96"": ""\xe8\xa9\xbf"",\n""\xe8\xaf\x97"": ""\xe8\xa9\xa9"",\n""\xe8\xaf\x98"": ""\xe8\xa9\xb0"",\n""\xe8\xaf\x99"": ""\xe8\xa9\xbc"",\n""\xe8\xaf\x9a"": ""\xe8\xaa\xa0"",\n""\xe8\xaf\x9b"": ""\xe8\xaa\x85"",\n""\xe8\xaf\x9c"": ""\xe8\xa9\xb5"",\n""\xe8\xaf\x9d"": ""\xe8\xa9\xb1"",\n""\xe8\xaf\x9e"": ""\xe8\xaa\x95"",\n""\xe8\xaf\x9f"": ""\xe8\xa9\xac"",\n""\xe8\xaf\xa0"": ""\xe8\xa9\xae"",\n""\xe8\xaf\xa1"": ""\xe8\xa9\xad"",\n""\xe8\xaf\xa2"": ""\xe8\xa9\xa2"",\n""\xe8\xaf\xa3"": ""\xe8\xa9\xa3"",\n""\xe8\xaf\xa4"": ""\xe8\xab\x8d"",\n""\xe8\xaf\xa5"": ""\xe8\xa9\xb2"",\n""\xe8\xaf\xa6"": ""\xe8\xa9\xb3"",\n""\xe8\xaf\xa7"": ""\xe8\xa9\xab"",\n""\xe8\xaf\xa8"": ""\xe8\xab\xa2"",\n""\xe8\xaf\xa9"": ""\xe8\xa9\xa1"",\n""\xe8\xaf\xaa"": ""\xe8\xad\xb8"",\n""\xe8\xaf\xab"": ""\xe8\xaa\xa1"",\n""\xe8\xaf\xac"": ""\xe8\xaa\xa3"",\n""\xe8\xaf\xad"": ""\xe8\xaa\x9e"",\n""\xe8\xaf\xae"": ""\xe8\xaa\x9a"",\n""\xe8\xaf\xaf"": ""\xe8\xaa\xa4"",\n""\xe8\xaf\xb0"": ""\xe8\xaa\xa5"",\n""\xe8\xaf\xb1"": ""\xe8\xaa\x98"",\n""\xe8\xaf\xb2"": ""\xe8\xaa\xa8"",\n""\xe8\xaf\xb3"": ""\xe8\xaa\x91"",\n""\xe8\xaf\xb5"": ""\xe8\xaa\xa6"",\n""\xe8\xaf\xb6"": ""\xe8\xaa\x92"",\n""\xe8\xaf\xb7"": ""\xe8\xab\x8b"",\n""\xe8\xaf\xb8"": ""\xe8\xab\xb8"",\n""\xe8\xaf\xb9"": ""\xe8\xab\x8f"",\n""\xe8\xaf\xba"": ""\xe8\xab\xbe"",\n""\xe8\xaf\xbb"": ""\xe8\xae\x80"",\n""\xe8\xaf\xbc"": ""\xe8\xab\x91"",\n""\xe8\xaf\xbd"": ""\xe8\xaa\xb9"",\n""\xe8\xaf\xbe"": ""\xe8\xaa\xb2"",\n""\xe8\xaf\xbf"": ""\xe8\xab\x89"",\n""\xe8\xb0\x80"": ""\xe8\xab\x9b"",\n""\xe8\xb0\x81"": ""\xe8\xaa\xb0"",\n""\xe8\xb0\x82"": ""\xe8\xab\x97"",\n""\xe8\xb0\x83"": ""\xe8\xaa\xbf"",\n""\xe8\xb0\x84"": ""\xe8\xab\x82"",\n""\xe8\xb0\x85"": ""\xe8\xab\x92"",\n""\xe8\xb0\x86"": ""\xe8\xab\x84"",\n""\xe8\xb0\x87"": ""\xe8\xaa\xb6"",\n""\xe8\xb0\x88"": ""\xe8\xab\x87"",\n""\xe8\xb0\x8a"": ""\xe8\xaa\xbc"",\n""\xe8\xb0\x8b"": ""\xe8\xac\x80"",\n""\xe8\xb0\x8c"": ""\xe8\xab\xb6"",\n""\xe8\xb0\x8d"": ""\xe8\xab\x9c"",\n""\xe8\xb0\x8e"": ""\xe8\xac\x8a"",\n""\xe8\xb0\x8f"": ""\xe8\xab\xab"",\n""\xe8\xb0\x90"": ""\xe8\xab\xa7"",\n""\xe8\xb0\x91"": ""\xe8\xac\x94"",\n""\xe8\xb0\x92"": ""\xe8\xac\x81"",\n""\xe8\xb0\x93"": ""\xe8\xac\x82"",\n""\xe8\xb0\x94"": ""\xe8\xab\xa4"",\n""\xe8\xb0\x95"": ""\xe8\xab\xad"",\n""\xe8\xb0\x96"": ""\xe8\xab\xbc"",\n""\xe8\xb0\x97"": ""\xe8\xae\x92"",\n""\xe8\xb0\x98"": ""\xe8\xab\xae"",\n""\xe8\xb0\x99"": ""\xe8\xab\xb3"",\n""\xe8\xb0\x9a"": ""\xe8\xab\xba"",\n""\xe8\xb0\x9b"": ""\xe8\xab\xa6"",\n""\xe8\xb0\x9c"": ""\xe8\xac\x8e"",\n""\xe8\xb0\x9d"": ""\xe8\xab\x9e"",\n""\xe8\xb0\x9e"": ""\xe8\xab\x9d"",\n""\xe8\xb0\x9f"": ""\xe8\xac\xa8"",\n""\xe8\xb0\xa0"": ""\xe8\xae\x9c"",\n""\xe8\xb0\xa1"": ""\xe8\xac\x96"",\n""\xe8\xb0\xa2"": ""\xe8\xac\x9d"",\n""\xe8\xb0\xa4"": ""\xe8\xac\x97"",\n""\xe8\xb0\xa5"": ""\xe8\xac\x9a"",\n""\xe8\xb0\xa6"": ""\xe8\xac\x99"",\n""\xe8\xb0\xa7"": ""\xe8\xac\x90"",\n""\xe8\xb0\xa8"": ""\xe8\xac\xb9"",\n""\xe8\xb0\xa9"": ""\xe8\xac\xbe"",\n""\xe8\xb0\xaa"": ""\xe8\xac\xab"",\n""\xe8\xb0\xac"": ""\xe8\xac\xac"",\n""\xe8\xb0\xad"": ""\xe8\xad\x9a"",\n""\xe8\xb0\xae"": ""\xe8\xad\x96"",\n""\xe8\xb0\xaf"": ""\xe8\xad\x99"",\n""\xe8\xb0\xb0"": ""\xe8\xae\x95"",\n""\xe8\xb0\xb1"": ""\xe8\xad\x9c"",\n""\xe8\xb0\xb2"": ""\xe8\xad\x8e"",\n""\xe8\xb0\xb3"": ""\xe8\xae\x9e"",\n""\xe8\xb0\xb4"": ""\xe8\xad\xb4"",\n""\xe8\xb0\xb5"": ""\xe8\xad\xab"",\n""\xe8\xb0\xb6"": ""\xe8\xae\x96"",\n""\xe8\xb1\xae"": ""\xe8\xb1\xb6"",\n""\xe4\x9d\x99"": ""\xe8\xb2\x99"",\n""\xe4\x9e\x90"": ""\xe8\xb3\xb0"",\n""\xe8\xb4\x9d"": ""\xe8\xb2\x9d"",\n""\xe8\xb4\x9e"": ""\xe8\xb2\x9e"",\n""\xe8\xb4\x9f"": ""\xe8\xb2\xa0"",\n""\xe8\xb4\xa0"": ""\xe8\xb2\x9f"",\n""\xe8\xb4\xa1"": ""\xe8\xb2\xa2"",\n""\xe8\xb4\xa2"": ""\xe8\xb2\xa1"",\n""\xe8\xb4\xa3"": ""\xe8\xb2\xac"",\n""\xe8\xb4\xa4"": ""\xe8\xb3\xa2"",\n""\xe8\xb4\xa5"": ""\xe6\x95\x97"",\n""\xe8\xb4\xa6"": ""\xe8\xb3\xac"",\n""\xe8\xb4\xa7"": ""\xe8\xb2\xa8"",\n""\xe8\xb4\xa8"": ""\xe8\xb3\xaa"",\n""\xe8\xb4\xa9"": ""\xe8\xb2\xa9"",\n""\xe8\xb4\xaa"": ""\xe8\xb2\xaa"",\n""\xe8\xb4\xab"": ""\xe8\xb2\xa7"",\n""\xe8\xb4\xac"": ""\xe8\xb2\xb6"",\n""\xe8\xb4\xad"": ""\xe8\xb3\xbc"",\n""\xe8\xb4\xae"": ""\xe8\xb2\xaf"",\n""\xe8\xb4\xaf"": ""\xe8\xb2\xab"",\n""\xe8\xb4\xb0"": ""\xe8\xb2\xb3"",\n""\xe8\xb4\xb1"": ""\xe8\xb3\xa4"",\n""\xe8\xb4\xb2"": ""\xe8\xb3\x81"",\n""\xe8\xb4\xb3"": ""\xe8\xb2\xb0"",\n""\xe8\xb4\xb4"": ""\xe8\xb2\xbc"",\n""\xe8\xb4\xb5"": ""\xe8\xb2\xb4"",\n""\xe8\xb4\xb6"": ""\xe8\xb2\xba"",\n""\xe8\xb4\xb7"": ""\xe8\xb2\xb8"",\n""\xe8\xb4\xb8"": ""\xe8\xb2\xbf"",\n""\xe8\xb4\xb9"": ""\xe8\xb2\xbb"",\n""\xe8\xb4\xba"": ""\xe8\xb3\x80"",\n""\xe8\xb4\xbb"": ""\xe8\xb2\xbd"",\n""\xe8\xb4\xbc"": ""\xe8\xb3\x8a"",\n""\xe8\xb4\xbd"": ""\xe8\xb4\x84"",\n""\xe8\xb4\xbe"": ""\xe8\xb3\x88"",\n""\xe8\xb4\xbf"": ""\xe8\xb3\x84"",\n""\xe8\xb5\x80"": ""\xe8\xb2\xb2"",\n""\xe8\xb5\x81"": ""\xe8\xb3\x83"",\n""\xe8\xb5\x82"": ""\xe8\xb3\x82"",\n""\xe8\xb5\x84"": ""\xe8\xb3\x87"",\n""\xe8\xb5\x85"": ""\xe8\xb3\x85"",\n""\xe8\xb5\x86"": ""\xe8\xb4\x90"",\n""\xe8\xb5\x87"": ""\xe8\xb3\x95"",\n""\xe8\xb5\x88"": ""\xe8\xb3\x91"",\n""\xe8\xb5\x89"": ""\xe8\xb3\x9a"",\n""\xe8\xb5\x8a"": ""\xe8\xb3\x92"",\n""\xe8\xb5\x8b"": ""\xe8\xb3\xa6"",\n""\xe8\xb5\x8c"": ""\xe8\xb3\xad"",\n""\xe8\xb5\x8e"": ""\xe8\xb4\x96"",\n""\xe8\xb5\x8f"": ""\xe8\xb3\x9e"",\n""\xe8\xb5\x90"": ""\xe8\xb3\x9c"",\n""\xe8\xb5\x91"": ""\xe8\xb4\x94"",\n""\xe8\xb5\x92"": ""\xe8\xb3\x99"",\n""\xe8\xb5\x93"": ""\xe8\xb3\xa1"",\n""\xe8\xb5\x94"": ""\xe8\xb3\xa0"",\n""\xe8\xb5\x95"": ""\xe8\xb3\xa7"",\n""\xe8\xb5\x96"": ""\xe8\xb3\xb4"",\n""\xe8\xb5\x97"": ""\xe8\xb3\xb5"",\n""\xe8\xb5\x98"": ""\xe8\xb4\x85"",\n""\xe8\xb5\x99"": ""\xe8\xb3\xbb"",\n""\xe8\xb5\x9a"": ""\xe8\xb3\xba"",\n""\xe8\xb5\x9b"": ""\xe8\xb3\xbd"",\n""\xe8\xb5\x9c"": ""\xe8\xb3\xbe"",\n""\xe8\xb5\x9e"": ""\xe8\xb4\x8a"",\n""\xe8\xb5\x9f"": ""\xe8\xb4\x87"",\n""\xe8\xb5\xa0"": ""\xe8\xb4\x88"",\n""\xe8\xb5\xa1"": ""\xe8\xb4\x8d"",\n""\xe8\xb5\xa2"": ""\xe8\xb4\x8f"",\n""\xe8\xb5\xa3"": ""\xe8\xb4\x9b"",\n""\xe8\xb5\xaa"": ""\xe8\xb5\xac"",\n""\xe8\xb5\xb5"": ""\xe8\xb6\x99"",\n""\xe8\xb5\xb6"": ""\xe8\xb6\x95"",\n""\xe8\xb6\x8b"": ""\xe8\xb6\xa8"",\n""\xe8\xb6\xb1"": ""\xe8\xb6\xb2"",\n""\xe8\xb6\xb8"": ""\xe8\xba\x89"",\n""\xe8\xb7\x83"": ""\xe8\xba\x8d"",\n""\xe8\xb7\x84"": ""\xe8\xb9\x8c"",\n""\xe8\xb7\x9e"": ""\xe8\xba\x92"",\n""\xe8\xb7\xb5"": ""\xe8\xb8\x90"",\n""\xe8\xb7\xb6"": ""\xe8\xba\x82"",\n""\xe8\xb7\xb7"": ""\xe8\xb9\xba"",\n""\xe8\xb7\xb8"": ""\xe8\xb9\x95"",\n""\xe8\xb7\xb9"": ""\xe8\xba\x9a"",\n""\xe8\xb7\xbb"": ""\xe8\xba\x8b"",\n""\xe8\xb8\x8a"": ""\xe8\xb8\xb4"",\n""\xe8\xb8\x8c"": ""\xe8\xba\x8a"",\n""\xe8\xb8\xaa"": ""\xe8\xb9\xa4"",\n""\xe8\xb8\xac"": ""\xe8\xba\x93"",\n""\xe8\xb8\xaf"": ""\xe8\xba\x91"",\n""\xe8\xb9\x91"": ""\xe8\xba\xa1"",\n""\xe8\xb9\x92"": ""\xe8\xb9\xa3"",\n""\xe8\xb9\xb0"": ""\xe8\xba\x95"",\n""\xe8\xb9\xbf"": ""\xe8\xba\xa5"",\n""\xe8\xba\x8f"": ""\xe8\xba\xaa"",\n""\xe8\xba\x9c"": ""\xe8\xba\xa6"",\n""\xe8\xba\xaf"": ""\xe8\xbb\x80"",\n""\xe8\xbd\xa6"": ""\xe8\xbb\x8a"",\n""\xe8\xbd\xa7"": ""\xe8\xbb\x8b"",\n""\xe8\xbd\xa8"": ""\xe8\xbb\x8c"",\n""\xe8\xbd\xa9"": ""\xe8\xbb\x92"",\n""\xe8\xbd\xaa"": ""\xe8\xbb\x91"",\n""\xe8\xbd\xab"": ""\xe8\xbb\x94"",\n""\xe8\xbd\xac"": ""\xe8\xbd\x89"",\n""\xe8\xbd\xad"": ""\xe8\xbb\x9b"",\n""\xe8\xbd\xae"": ""\xe8\xbc\xaa"",\n""\xe8\xbd\xaf"": ""\xe8\xbb\x9f"",\n""\xe8\xbd\xb0"": ""\xe8\xbd\x9f"",\n""\xe8\xbd\xb1"": ""\xe8\xbb\xb2"",\n""\xe8\xbd\xb2"": ""\xe8\xbb\xbb"",\n""\xe8\xbd\xb3"": ""\xe8\xbd\xa4"",\n""\xe8\xbd\xb4"": ""\xe8\xbb\xb8"",\n""\xe8\xbd\xb5"": ""\xe8\xbb\xb9"",\n""\xe8\xbd\xb6"": ""\xe8\xbb\xbc"",\n""\xe8\xbd\xb7"": ""\xe8\xbb\xa4"",\n""\xe8\xbd\xb8"": ""\xe8\xbb\xab"",\n""\xe8\xbd\xb9"": ""\xe8\xbd\xa2"",\n""\xe8\xbd\xba"": ""\xe8\xbb\xba"",\n""\xe8\xbd\xbb"": ""\xe8\xbc\x95"",\n""\xe8\xbd\xbc"": ""\xe8\xbb\xbe"",\n""\xe8\xbd\xbd"": ""\xe8\xbc\x89"",\n""\xe8\xbd\xbe"": ""\xe8\xbc\x8a"",\n""\xe8\xbd\xbf"": ""\xe8\xbd\x8e"",\n""\xe8\xbe\x80"": ""\xe8\xbc\x88"",\n""\xe8\xbe\x81"": ""\xe8\xbc\x87"",\n""\xe8\xbe\x82"": ""\xe8\xbc\x85"",\n""\xe8\xbe\x83"": ""\xe8\xbc\x83"",\n""\xe8\xbe\x84"": ""\xe8\xbc\x92"",\n""\xe8\xbe\x85"": ""\xe8\xbc\x94"",\n""\xe8\xbe\x86"": ""\xe8\xbc\x9b"",\n""\xe8\xbe\x87"": ""\xe8\xbc\xa6"",\n""\xe8\xbe\x88"": ""\xe8\xbc\xa9"",\n""\xe8\xbe\x89"": ""\xe8\xbc\x9d"",\n""\xe8\xbe\x8a"": ""\xe8\xbc\xa5"",\n""\xe8\xbe\x8b"": ""\xe8\xbc\x9e"",\n""\xe8\xbe\x8c"": ""\xe8\xbc\xac"",\n""\xe8\xbe\x8d"": ""\xe8\xbc\x9f"",\n""\xe8\xbe\x8e"": ""\xe8\xbc\x9c"",\n""\xe8\xbe\x8f"": ""\xe8\xbc\xb3"",\n""\xe8\xbe\x90"": ""\xe8\xbc\xbb"",\n""\xe8\xbe\x91"": ""\xe8\xbc\xaf"",\n""\xe8\xbe\x92"": ""\xe8\xbd\x80"",\n""\xe8\xbe\x93"": ""\xe8\xbc\xb8"",\n""\xe8\xbe\x94"": ""\xe8\xbd\xa1"",\n""\xe8\xbe\x95"": ""\xe8\xbd\x85"",\n""\xe8\xbe\x96"": ""\xe8\xbd\x84"",\n""\xe8\xbe\x97"": ""\xe8\xbc\xbe"",\n""\xe8\xbe\x98"": ""\xe8\xbd\x86"",\n""\xe8\xbe\x99"": ""\xe8\xbd\x8d"",\n""\xe8\xbe\x9a"": ""\xe8\xbd\x94"",\n""\xe8\xbe\x9e"": ""\xe8\xbe\xad"",\n""\xe8\xbe\xa9"": ""\xe8\xbe\xaf"",\n""\xe8\xbe\xab"": ""\xe8\xbe\xae"",\n""\xe8\xbe\xb9"": ""\xe9\x82\x8a"",\n""\xe8\xbe\xbd"": ""\xe9\x81\xbc"",\n""\xe8\xbe\xbe"": ""\xe9\x81\x94"",\n""\xe8\xbf\x81"": ""\xe9\x81\xb7"",\n""\xe8\xbf\x87"": ""\xe9\x81\x8e"",\n""\xe8\xbf\x88"": ""\xe9\x82\x81"",\n""\xe8\xbf\x90"": ""\xe9\x81\x8b"",\n""\xe8\xbf\x98"": ""\xe9\x82\x84"",\n""\xe8\xbf\x99"": ""\xe9\x80\x99"",\n""\xe8\xbf\x9b"": ""\xe9\x80\xb2"",\n""\xe8\xbf\x9c"": ""\xe9\x81\xa0"",\n""\xe8\xbf\x9d"": ""\xe9\x81\x95"",\n""\xe8\xbf\x9e"": ""\xe9\x80\xa3"",\n""\xe8\xbf\x9f"": ""\xe9\x81\xb2"",\n""\xe8\xbf\xa9"": ""\xe9\x82\x87"",\n""\xe8\xbf\xb3"": ""\xe9\x80\x95"",\n""\xe8\xbf\xb9"": ""\xe8\xb7\xa1"",\n""\xe9\x80\x89"": ""\xe9\x81\xb8"",\n""\xe9\x80\x8a"": ""\xe9\x81\x9c"",\n""\xe9\x80\x92"": ""\xe9\x81\x9e"",\n""\xe9\x80\xa6"": ""\xe9\x82\x90"",\n""\xe9\x80\xbb"": ""\xe9\x82\x8f"",\n""\xe9\x81\x97"": ""\xe9\x81\xba"",\n""\xe9\x81\xa5"": ""\xe9\x81\x99"",\n""\xe9\x82\x93"": ""\xe9\x84\xa7"",\n""\xe9\x82\x9d"": ""\xe9\x84\xba"",\n""\xe9\x82\xac"": ""\xe9\x84\x94"",\n""\xe9\x82\xae"": ""\xe9\x83\xb5"",\n""\xe9\x82\xb9"": ""\xe9\x84\x92"",\n""\xe9\x82\xba"": ""\xe9\x84\xb4"",\n""\xe9\x82\xbb"": ""\xe9\x84\xb0"",\n""\xe9\x83\x8f"": ""\xe9\x83\x9f"",\n""\xe9\x83\x90"": ""\xe9\x84\xb6"",\n""\xe9\x83\x91"": ""\xe9\x84\xad"",\n""\xe9\x83\x93"": ""\xe9\x84\x86"",\n""\xe9\x83\xa6"": ""\xe9\x85\x88"",\n""\xe9\x83\xa7"": ""\xe9\x84\x96"",\n""\xe9\x83\xb8"": ""\xe9\x84\xb2"",\n""\xe9\x85\x82"": ""\xe9\x85\x87"",\n""\xe9\x85\xa6"": ""\xe9\x86\xb1"",\n""\xe9\x85\xb1"": ""\xe9\x86\xac"",\n""\xe9\x85\xbd"": ""\xe9\x87\x85"",\n""\xe9\x85\xbe"": ""\xe9\x87\x83"",\n""\xe9\x85\xbf"": ""\xe9\x87\x80"",\n""\xe9\x87\x8a"": ""\xe9\x87\x8b"",\n""\xe9\x89\xb4"": ""\xe9\x91\x92"",\n""\xe9\x8a\xae"": ""\xe9\x91\xbe"",\n""\xe9\x8c\xbe"": ""\xe9\x8f\xa8"",\n""\xf0\xa8\xb1\x8f"": ""\xe9\x8e\x9d"",\n""\xe9\x92\x85"": ""\xe9\x87\x92"",\n""\xe9\x92\x86"": ""\xe9\x87\x93"",\n""\xe9\x92\x87"": ""\xe9\x87\x94"",\n""\xe9\x92\x88"": ""\xe9\x87\x9d"",\n""\xe9\x92\x89"": ""\xe9\x87\x98"",\n""\xe9\x92\x8a"": ""\xe9\x87\x97"",\n""\xe9\x92\x8b"": ""\xe9\x87\x99"",\n""\xe9\x92\x8c"": ""\xe9\x87\x95"",\n""\xe9\x92\x8d"": ""\xe9\x87\xb7"",\n""\xe9\x92\x8e"": ""\xe9\x87\xba"",\n""\xe9\x92\x8f"": ""\xe9\x87\xa7"",\n""\xe9\x92\x90"": ""\xe9\x87\xa4"",\n""\xe9\x92\x91"": ""\xe9\x88\x92"",\n""\xe9\x92\x92"": ""\xe9\x87\xa9"",\n""\xe9\x92\x93"": ""\xe9\x87\xa3"",\n""\xe9\x92\x94"": ""\xe9\x8d\x86"",\n""\xe9\x92\x95"": ""\xe9\x87\xb9"",\n""\xe9\x92\x96"": ""\xe9\x8d\x9a"",\n""\xe9\x92\x97"": ""\xe9\x87\xb5"",\n""\xe9\x92\x98"": ""\xe9\x88\x83"",\n""\xe9\x92\x99"": ""\xe9\x88\xa3"",\n""\xe9\x92\x9a"": ""\xe9\x88\x88"",\n""\xe9\x92\x9b"": ""\xe9\x88\xa6"",\n""\xe9\x92\x9c"": ""\xe9\x89\x85"",\n""\xe9\x92\x9d"": ""\xe9\x88\x8d"",\n""\xe9\x92\x9e"": ""\xe9\x88\x94"",\n""\xe9\x92\xa0"": ""\xe9\x88\x89"",\n""\xe9\x92\xa1"": ""\xe9\x8b\x87"",\n""\xe9\x92\xa2"": ""\xe9\x8b\xbc"",\n""\xe9\x92\xa3"": ""\xe9\x88\x91"",\n""\xe9\x92\xa4"": ""\xe9\x88\x90"",\n""\xe9\x92\xa5"": ""\xe9\x91\xb0"",\n""\xe9\x92\xa6"": ""\xe6\xac\xbd"",\n""\xe9\x92\xa7"": ""\xe9\x88\x9e"",\n""\xe9\x92\xa8"": ""\xe9\x8e\xa2"",\n""\xe9\x92\xaa"": ""\xe9\x88\xa7"",\n""\xe9\x92\xab"": ""\xe9\x88\x81"",\n""\xe9\x92\xac"": ""\xe9\x88\xa5"",\n""\xe9\x92\xad"": ""\xe9\x88\x84"",\n""\xe9\x92\xae"": ""\xe9\x88\x95"",\n""\xe9\x92\xaf"": ""\xe9\x88\x80"",\n""\xe9\x92\xb0"": ""\xe9\x88\xba"",\n""\xe9\x92\xb1"": ""\xe9\x8c\xa2"",\n""\xe9\x92\xb2"": ""\xe9\x89\xa6"",\n""\xe9\x92\xb3"": ""\xe9\x89\x97"",\n""\xe9\x92\xb4"": ""\xe9\x88\xb7"",\n""\xe9\x92\xb6"": ""\xe9\x88\xb3"",\n""\xe9\x92\xb7"": ""\xe9\x89\x95"",\n""\xe9\x92\xb8"": ""\xe9\x88\xbd"",\n""\xe9\x92\xb9"": ""\xe9\x88\xb8"",\n""\xe9\x92\xba"": ""\xe9\x89\x9e"",\n""\xe9\x92\xbb"": ""\xe9\x91\xbd"",\n""\xe9\x92\xbc"": ""\xe9\x89\xac"",\n""\xe9\x92\xbd"": ""\xe9\x89\xad"",\n""\xe9\x92\xbe"": ""\xe9\x89\x80"",\n""\xe9\x92\xbf"": ""\xe9\x88\xbf"",\n""\xe9\x93\x80"": ""\xe9\x88\xbe"",\n""\xe9\x93\x81"": ""\xe9\x90\xb5"",\n""\xe9\x93\x82"": ""\xe9\x89\x91"",\n""\xe9\x93\x83"": ""\xe9\x88\xb4"",\n""\xe9\x93\x84"": ""\xe9\x91\xa0"",\n""\xe9\x93\x85"": ""\xe9\x89\x9b"",\n""\xe9\x93\x86"": ""\xe9\x89\x9a"",\n""\xe9\x93\x87"": ""\xe9\x89\x8b"",\n""\xe9\x93\x88"": ""\xe9\x88\xb0"",\n""\xe9\x93\x89"": ""\xe9\x89\x89"",\n""\xe9\x93\x8a"": ""\xe9\x89\x88"",\n""\xe9\x93\x8b"": ""\xe9\x89\x8d"",\n""\xe9\x93\x8c"": ""\xe9\x88\xae"",\n""\xe9\x93\x8d"": ""\xe9\x88\xb9"",\n""\xe9\x93\x8e"": ""\xe9\x90\xb8"",\n""\xe9\x93\x8f"": ""\xe9\x89\xb6"",\n""\xe9\x93\x90"": ""\xe9\x8a\xac"",\n""\xe9\x93\x91"": ""\xe9\x8a\xa0"",\n""\xe9\x93\x92"": ""\xe9\x89\xba"",\n""\xe9\x93\x93"": ""\xe9\x8b\xa9"",\n""\xe9\x93\x94"": ""\xe9\x8c\x8f"",\n""\xe9\x93\x95"": ""\xe9\x8a\xaa"",\n""\xe9\x93\x96"": ""\xe9\x8b\xae"",\n""\xe9\x93\x97"": ""\xe9\x8b\x8f"",\n""\xe9\x93\x98"": ""\xe9\x8b\xa3"",\n""\xe9\x93\x99"": ""\xe9\x90\x83"",\n""\xe9\x93\x9a"": ""\xe9\x8a\x8d"",\n""\xe9\x93\x9b"": ""\xe9\x90\xba"",\n""\xe9\x93\x9c"": ""\xe9\x8a\x85"",\n""\xe9\x93\x9d"": ""\xe9\x8b\x81"",\n""\xe9\x93\x9e"": ""\xe9\x8a\xb1"",\n""\xe9\x93\x9f"": ""\xe9\x8a\xa6"",\n""\xe9\x93\xa0"": ""\xe9\x8e\xa7"",\n""\xe9\x93\xa1"": ""\xe9\x8d\x98"",\n""\xe9\x93\xa2"": ""\xe9\x8a\x96"",\n""\xe9\x93\xa3"": ""\xe9\x8a\x91"",\n""\xe9\x93\xa4"": ""\xe9\x8b\x8c"",\n""\xe9\x93\xa5"": ""\xe9\x8a\xa9"",\n""\xe9\x93\xa6"": ""\xe9\x8a\x9b"",\n""\xe9\x93\xa7"": ""\xe9\x8f\xb5"",\n""\xe9\x93\xa8"": ""\xe9\x8a\x93"",\n""\xe9\x93\xa9"": ""\xe9\x8e\xa9"",\n""\xe9\x93\xaa"": ""\xe9\x89\xbf"",\n""\xe9\x93\xab"": ""\xe9\x8a\x9a"",\n""\xe9\x93\xac"": ""\xe9\x89\xbb"",\n""\xe9\x93\xad"": ""\xe9\x8a\x98"",\n""\xe9\x93\xae"": ""\xe9\x8c\x9a"",\n""\xe9\x93\xaf"": ""\xe9\x8a\xab"",\n""\xe9\x93\xb0"": ""\xe9\x89\xb8"",\n""\xe9\x93\xb1"": ""\xe9\x8a\xa5"",\n""\xe9\x93\xb2"": ""\xe9\x8f\x9f"",\n""\xe9\x93\xb3"": ""\xe9\x8a\x83"",\n""\xe9\x93\xb4"": ""\xe9\x90\x8b"",\n""\xe9\x93\xb5"": ""\xe9\x8a\xa8"",\n""\xe9\x93\xb6"": ""\xe9\x8a\x80"",\n""\xe9\x93\xb7"": ""\xe9\x8a\xa3"",\n""\xe9\x93\xb8"": ""\xe9\x91\x84"",\n""\xe9\x93\xb9"": ""\xe9\x90\x92"",\n""\xe9\x93\xba"": ""\xe9\x8b\xaa"",\n""\xe9\x93\xbb"": ""\xe9\x8b\x99"",\n""\xe9\x93\xbc"": ""\xe9\x8c\xb8"",\n""\xe9\x93\xbd"": ""\xe9\x8b\xb1"",\n""\xe9\x93\xbe"": ""\xe9\x8f\x88"",\n""\xe9\x93\xbf"": ""\xe9\x8f\x97"",\n""\xe9\x94\x80"": ""\xe9\x8a\xb7"",\n""\xe9\x94\x81"": ""\xe9\x8e\x96"",\n""\xe9\x94\x82"": ""\xe9\x8b\xb0"",\n""\xe9\x94\x83"": ""\xe9\x8b\xa5"",\n""\xe9\x94\x84"": ""\xe9\x8b\xa4"",\n""\xe9\x94\x85"": ""\xe9\x8d\x8b"",\n""\xe9\x94\x86"": ""\xe9\x8b\xaf"",\n""\xe9\x94\x87"": ""\xe9\x8b\xa8"",\n""\xe9\x94\x89"": ""\xe9\x8a\xbc"",\n""\xe9\x94\x8a"": ""\xe9\x8b\x9d"",\n""\xe9\x94\x8b"": ""\xe9\x8b\x92"",\n""\xe9\x94\x8c"": ""\xe9\x8b\x85"",\n""\xe9\x94\x8d"": ""\xe9\x8b\xb6"",\n""\xe9\x94\x8e"": ""\xe9\x90\xa6"",\n""\xe9\x94\x8f"": ""\xe9\x90\xa7"",\n""\xe9\x94\x91"": ""\xe9\x8a\xbb"",\n""\xe9\x94\x92"": ""\xe9\x8b\x83"",\n""\xe9\x94\x93"": ""\xe9\x8b\x9f"",\n""\xe9\x94\x94"": ""\xe9\x8b\xa6"",\n""\xe9\x94\x95"": ""\xe9\x8c\x92"",\n""\xe9\x94\x96"": ""\xe9\x8c\x86"",\n""\xe9\x94\x97"": ""\xe9\x8d\xba"",\n""\xe9\x94\x98"": ""\xe9\x8d\xa9"",\n""\xe9\x94\x99"": ""\xe9\x8c\xaf"",\n""\xe9\x94\x9a"": ""\xe9\x8c\xa8"",\n""\xe9\x94\x9b"": ""\xe9\x8c\x9b"",\n""\xe9\x94\x9c"": ""\xe9\x8c\xa1"",\n""\xe9\x94\x9d"": ""\xe9\x8d\x80"",\n""\xe9\x94\x9e"": ""\xe9\x8c\x81"",\n""\xe9\x94\x9f"": ""\xe9\x8c\x95"",\n""\xe9\x94\xa0"": ""\xe9\x8c\xa9"",\n""\xe9\x94\xa1"": ""\xe9\x8c\xab"",\n""\xe9\x94\xa2"": ""\xe9\x8c\xae"",\n""\xe9\x94\xa3"": ""\xe9\x91\xbc"",\n""\xe9\x94\xa5"": ""\xe9\x8c\x90"",\n""\xe9\x94\xa6"": ""\xe9\x8c\xa6"",\n""\xe9\x94\xa7"": ""\xe9\x91\x95"",\n""\xe9\x94\xa9"": ""\xe9\x8c\x88"",\n""\xe9\x94\xaa"": ""\xe9\x8d\x83"",\n""\xe9\x94\xab"": ""\xe9\x8c\x87"",\n""\xe9\x94\xac"": ""\xe9\x8c\x9f"",\n""\xe9\x94\xad"": ""\xe9\x8c\xa0"",\n""\xe9\x94\xae"": ""\xe9\x8d\xb5"",\n""\xe9\x94\xaf"": ""\xe9\x8b\xb8"",\n""\xe9\x94\xb0"": ""\xe9\x8c\xb3"",\n""\xe9\x94\xb1"": ""\xe9\x8c\x99"",\n""\xe9\x94\xb2"": ""\xe9\x8d\xa5"",\n""\xe9\x94\xb3"": ""\xe9\x8d\x88"",\n""\xe9\x94\xb4"": ""\xe9\x8d\x87"",\n""\xe9\x94\xb5"": ""\xe9\x8f\x98"",\n""\xe9\x94\xb6"": ""\xe9\x8d\xb6"",\n""\xe9\x94\xb7"": ""\xe9\x8d\x94"",\n""\xe9\x94\xb8"": ""\xe9\x8d\xa4"",\n""\xe9\x94\xb9"": ""\xe9\x8d\xac"",\n""\xe9\x94\xba"": ""\xe9\x8d\xbe"",\n""\xe9\x94\xbb"": ""\xe9\x8d\x9b"",\n""\xe9\x94\xbc"": ""\xe9\x8e\xaa"",\n""\xe9\x94\xbd"": ""\xe9\x8d\xa0"",\n""\xe9\x94\xbe"": ""\xe9\x8d\xb0"",\n""\xe9\x94\xbf"": ""\xe9\x8e\x84"",\n""\xe9\x95\x80"": ""\xe9\x8d\x8d"",\n""\xe9\x95\x81"": ""\xe9\x8e\x82"",\n""\xe9\x95\x82"": ""\xe9\x8f\xa4"",\n""\xe9\x95\x83"": ""\xe9\x8e\xa1"",\n""\xe9\x95\x84"": ""\xe9\x90\xa8"",\n""\xe9\x95\x85"": ""\xe9\x8e\x87"",\n""\xe9\x95\x86"": ""\xe9\x8f\x8c"",\n""\xe9\x95\x87"": ""\xe9\x8e\xae"",\n""\xe9\x95\x88"": ""\xe9\x8e\x9b"",\n""\xe9\x95\x89"": ""\xe9\x8e\x98"",\n""\xe9\x95\x8a"": ""\xe9\x91\xb7"",\n""\xe9\x95\x8b"": ""\xe9\x8e\xb2"",\n""\xe9\x95\x8d"": ""\xe9\x8e\xb3"",\n""\xe9\x95\x8e"": ""\xe9\x8e\xbf"",\n""\xe9\x95\x8f"": ""\xe9\x8e\xa6"",\n""\xe9\x95\x90"": ""\xe9\x8e\xac"",\n""\xe9\x95\x91"": ""\xe9\x8e\x8a"",\n""\xe9\x95\x92"": ""\xe9\x8e\xb0"",\n""\xe9\x95\x93"": ""\xe9\x8e\xb5"",\n""\xe9\x95\x94"": ""\xe9\x91\x8c"",\n""\xe9\x95\x95"": ""\xe9\x8e\x94"",\n""\xe9\x95\x96"": ""\xe9\x8f\xa2"",\n""\xe9\x95\x97"": ""\xe9\x8f\x9c"",\n""\xe9\x95\x98"": ""\xe9\x8f\x9d"",\n""\xe9\x95\x99"": ""\xe9\x8f\x8d"",\n""\xe9\x95\x9a"": ""\xe9\x8f\xb0"",\n""\xe9\x95\x9b"": ""\xe9\x8f\x9e"",\n""\xe9\x95\x9c"": ""\xe9\x8f\xa1"",\n""\xe9\x95\x9d"": ""\xe9\x8f\x91"",\n""\xe9\x95\x9e"": ""\xe9\x8f\x83"",\n""\xe9\x95\x9f"": ""\xe9\x8f\x87"",\n""\xe9\x95\xa0"": ""\xe9\x8f\x90"",\n""\xe9\x95\xa1"": ""\xe9\x90\x94"",\n""\xe9\x95\xa3"": ""\xe9\x90\x90"",\n""\xe9\x95\xa4"": ""\xe9\x8f\xb7"",\n""\xe9\x95\xa5"": ""\xe9\x91\xa5"",\n""\xe9\x95\xa6"": ""\xe9\x90\x93"",\n""\xe9\x95\xa7"": ""\xe9\x91\xad"",\n""\xe9\x95\xa8"": ""\xe9\x90\xa0"",\n""\xe9\x95\xa9"": ""\xe9\x91\xb9"",\n""\xe9\x95\xaa"": ""\xe9\x8f\xb9"",\n""\xe9\x95\xab"": ""\xe9\x90\x99"",\n""\xe9\x95\xac"": ""\xe9\x91\x8a"",\n""\xe9\x95\xad"": ""\xe9\x90\xb3"",\n""\xe9\x95\xae"": ""\xe9\x90\xb6"",\n""\xe9\x95\xaf"": ""\xe9\x90\xb2"",\n""\xe9\x95\xb0"": ""\xe9\x90\xae"",\n""\xe9\x95\xb1"": ""\xe9\x90\xbf"",\n""\xe9\x95\xb2"": ""\xe9\x91\x94"",\n""\xe9\x95\xb3"": ""\xe9\x91\xa3"",\n""\xe9\x95\xb4"": ""\xe9\x91\x9e"",\n""\xe9\x95\xb5"": ""\xe9\x91\xb1"",\n""\xe9\x95\xb6"": ""\xe9\x91\xb2"",\n""\xe9\x95\xbf"": ""\xe9\x95\xb7"",\n""\xe9\x97\xa8"": ""\xe9\x96\x80"",\n""\xe9\x97\xa9"": ""\xe9\x96\x82"",\n""\xe9\x97\xaa"": ""\xe9\x96\x83"",\n""\xe9\x97\xab"": ""\xe9\x96\x86"",\n""\xe9\x97\xac"": ""\xe9\x96\x88"",\n""\xe9\x97\xad"": ""\xe9\x96\x89"",\n""\xe9\x97\xae"": ""\xe5\x95\x8f"",\n""\xe9\x97\xaf"": ""\xe9\x97\x96"",\n""\xe9\x97\xb0"": ""\xe9\x96\x8f"",\n""\xe9\x97\xb1"": ""\xe9\x97\x88"",\n""\xe9\x97\xb2"": ""\xe9\x96\x91"",\n""\xe9\x97\xb3"": ""\xe9\x96\x8e"",\n""\xe9\x97\xb4"": ""\xe9\x96\x93"",\n""\xe9\x97\xb5"": ""\xe9\x96\x94"",\n""\xe9\x97\xb6"": ""\xe9\x96\x8c"",\n""\xe9\x97\xb7"": ""\xe6\x82\xb6"",\n""\xe9\x97\xb8"": ""\xe9\x96\x98"",\n""\xe9\x97\xb9"": ""\xe9\xac\xa7"",\n""\xe9\x97\xba"": ""\xe9\x96\xa8"",\n""\xe9\x97\xbb"": ""\xe8\x81\x9e"",\n""\xe9\x97\xbc"": ""\xe9\x97\xa5"",\n""\xe9\x97\xbd"": ""\xe9\x96\xa9"",\n""\xe9\x97\xbe"": ""\xe9\x96\xad"",\n""\xe9\x97\xbf"": ""\xe9\x97\x93"",\n""\xe9\x98\x80"": ""\xe9\x96\xa5"",\n""\xe9\x98\x81"": ""\xe9\x96\xa3"",\n""\xe9\x98\x82"": ""\xe9\x96\xa1"",\n""\xe9\x98\x83"": ""\xe9\x96\xab"",\n""\xe9\x98\x84"": ""\xe9\xac\xae"",\n""\xe9\x98\x86"": ""\xe9\x96\xac"",\n""\xe9\x98\x87"": ""\xe9\x97\x8d"",\n""\xe9\x98\x88"": ""\xe9\x96\xbe"",\n""\xe9\x98\x89"": ""\xe9\x96\xb9"",\n""\xe9\x98\x8a"": ""\xe9\x96\xb6"",\n""\xe9\x98\x8b"": ""\xe9\xac\xa9"",\n""\xe9\x98\x8c"": ""\xe9\x96\xbf"",\n""\xe9\x98\x8d"": ""\xe9\x96\xbd"",\n""\xe9\x98\x8e"": ""\xe9\x96\xbb"",\n""\xe9\x98\x8f"": ""\xe9\x96\xbc"",\n""\xe9\x98\x90"": ""\xe9\x97\xa1"",\n""\xe9\x98\x91"": ""\xe9\x97\x8c"",\n""\xe9\x98\x92"": ""\xe9\x97\x83"",\n""\xe9\x98\x93"": ""\xe9\x97\xa0"",\n""\xe9\x98\x94"": ""\xe9\x97\x8a"",\n""\xe9\x98\x95"": ""\xe9\x97\x8b"",\n""\xe9\x98\x96"": ""\xe9\x97\x94"",\n""\xe9\x98\x97"": ""\xe9\x97\x90"",\n""\xe9\x98\x98"": ""\xe9\x97\x92"",\n""\xe9\x98\x99"": ""\xe9\x97\x95"",\n""\xe9\x98\x9a"": ""\xe9\x97\x9e"",\n""\xe9\x98\x9b"": ""\xe9\x97\xa4"",\n""\xe9\x98\x9f"": ""\xe9\x9a\x8a"",\n""\xe9\x98\xb3"": ""\xe9\x99\xbd"",\n""\xe9\x98\xb4"": ""\xe9\x99\xb0"",\n""\xe9\x98\xb5"": ""\xe9\x99\xa3"",\n""\xe9\x98\xb6"": ""\xe9\x9a\x8e"",\n""\xe9\x99\x85"": ""\xe9\x9a\x9b"",\n""\xe9\x99\x86"": ""\xe9\x99\xb8"",\n""\xe9\x99\x87"": ""\xe9\x9a\xb4"",\n""\xe9\x99\x88"": ""\xe9\x99\xb3"",\n""\xe9\x99\x89"": ""\xe9\x99\x98"",\n""\xe9\x99\x95"": ""\xe9\x99\x9d"",\n""\xe9\x99\xa7"": ""\xe9\x9a\x89"",\n""\xe9\x99\xa8"": ""\xe9\x9a\x95"",\n""\xe9\x99\xa9"": ""\xe9\x9a\xaa"",\n""\xe9\x9a\x8f"": ""\xe9\x9a\xa8"",\n""\xe9\x9a\x90"": ""\xe9\x9a\xb1"",\n""\xe9\x9a\xb6"": ""\xe9\x9a\xb8"",\n""\xe9\x9a\xbd"": ""\xe9\x9b\x8b"",\n""\xe9\x9a\xbe"": ""\xe9\x9b\xa3"",\n""\xe9\x9b\x8f"": ""\xe9\x9b\x9b"",\n""\xe9\x9b\xa0"": ""\xe8\xae\x8e"",\n""\xe9\x9b\xb3"": ""\xe9\x9d\x82"",\n""\xe9\x9b\xbe"": ""\xe9\x9c\xa7"",\n""\xe9\x9c\x81"": ""\xe9\x9c\xbd"",\n""\xe9\x9c\xa1"": ""\xe9\x9c\xa2"",\n""\xe9\x9c\xad"": ""\xe9\x9d\x84"",\n""\xe9\x9d\x93"": ""\xe9\x9d\x9a"",\n""\xe9\x9d\x99"": ""\xe9\x9d\x9c"",\n""\xe9\x9d\xa5"": ""\xe9\x9d\xa8"",\n""\xe4\xa9\x84"": ""\xe9\x9d\xa6"",\n""\xe9\x9e\x91"": ""\xe9\x9f\x83"",\n""\xe9\x9e\x92"": ""\xe9\x9e\xbd"",\n""\xe9\x9e\xaf"": ""\xe9\x9f\x89"",\n""\xe9\x9f\xa6"": ""\xe9\x9f\x8b"",\n""\xe9\x9f\xa7"": ""\xe9\x9f\x8c"",\n""\xe9\x9f\xa8"": ""\xe9\x9f\x8d"",\n""\xe9\x9f\xa9"": ""\xe9\x9f\x93"",\n""\xe9\x9f\xaa"": ""\xe9\x9f\x99"",\n""\xe9\x9f\xab"": ""\xe9\x9f\x9e"",\n""\xe9\x9f\xac"": ""\xe9\x9f\x9c"",\n""\xe9\x9f\xb5"": ""\xe9\x9f\xbb"",\n""\xe9\xa1\xb5"": ""\xe9\xa0\x81"",\n""\xe9\xa1\xb6"": ""\xe9\xa0\x82"",\n""\xe9\xa1\xb7"": ""\xe9\xa0\x83"",\n""\xe9\xa1\xb8"": ""\xe9\xa0\x87"",\n""\xe9\xa1\xb9"": ""\xe9\xa0\x85"",\n""\xe9\xa1\xba"": ""\xe9\xa0\x86"",\n""\xe9\xa1\xbc"": ""\xe9\xa0\x8a"",\n""\xe9\xa1\xbd"": ""\xe9\xa0\x91"",\n""\xe9\xa1\xbe"": ""\xe9\xa1\xa7"",\n""\xe9\xa1\xbf"": ""\xe9\xa0\x93"",\n""\xe9\xa2\x80"": ""\xe9\xa0\x8e"",\n""\xe9\xa2\x81"": ""\xe9\xa0\x92"",\n""\xe9\xa2\x82"": ""\xe9\xa0\x8c"",\n""\xe9\xa2\x83"": ""\xe9\xa0\x8f"",\n""\xe9\xa2\x84"": ""\xe9\xa0\x90"",\n""\xe9\xa2\x85"": ""\xe9\xa1\xb1"",\n""\xe9\xa2\x86"": ""\xe9\xa0\x98"",\n""\xe9\xa2\x87"": ""\xe9\xa0\x97"",\n""\xe9\xa2\x88"": ""\xe9\xa0\xb8"",\n""\xe9\xa2\x89"": ""\xe9\xa0\xa1"",\n""\xe9\xa2\x8a"": ""\xe9\xa0\xb0"",\n""\xe9\xa2\x8b"": ""\xe9\xa0\xb2"",\n""\xe9\xa2\x8c"": ""\xe9\xa0\x9c"",\n""\xe9\xa2\x8d"": ""\xe6\xbd\x81"",\n""\xe9\xa2\x8e"": ""\xe7\x86\xb2"",\n""\xe9\xa2\x8f"": ""\xe9\xa0\xa6"",\n""\xe9\xa2\x90"": ""\xe9\xa0\xa4"",\n""\xe9\xa2\x91"": ""\xe9\xa0\xbb"",\n""\xe9\xa2\x92"": ""\xe9\xa0\xae"",\n""\xe9\xa2\x94"": ""\xe9\xa0\xb7"",\n""\xe9\xa2\x95"": ""\xe9\xa0\xb4"",\n""\xe9\xa2\x96"": ""\xe7\xa9\x8e"",\n""\xe9\xa2\x97"": ""\xe9\xa1\x86"",\n""\xe9\xa2\x98"": ""\xe9\xa1\x8c"",\n""\xe9\xa2\x99"": ""\xe9\xa1\x92"",\n""\xe9\xa2\x9a"": ""\xe9\xa1\x8e"",\n""\xe9\xa2\x9b"": ""\xe9\xa1\x93"",\n""\xe9\xa2\x9d"": ""\xe9\xa1\x8d"",\n""\xe9\xa2\x9e"": ""\xe9\xa1\xb3"",\n""\xe9\xa2\x9f"": ""\xe9\xa1\xa2"",\n""\xe9\xa2\xa0"": ""\xe9\xa1\x9b"",\n""\xe9\xa2\xa1"": ""\xe9\xa1\x99"",\n""\xe9\xa2\xa2"": ""\xe9\xa1\xa5"",\n""\xe9\xa2\xa4"": ""\xe9\xa1\xab"",\n""\xe9\xa2\xa5"": ""\xe9\xa1\xac"",\n""\xe9\xa2\xa6"": ""\xe9\xa1\xb0"",\n""\xe9\xa2\xa7"": ""\xe9\xa1\xb4"",\n""\xe9\xa3\x8e"": ""\xe9\xa2\xa8"",\n""\xe9\xa3\x8f"": ""\xe9\xa2\xba"",\n""\xe9\xa3\x90"": ""\xe9\xa2\xad"",\n""\xe9\xa3\x91"": ""\xe9\xa2\xae"",\n""\xe9\xa3\x92"": ""\xe9\xa2\xaf"",\n""\xe9\xa3\x93"": ""\xe9\xa2\xb6"",\n""\xe9\xa3\x94"": ""\xe9\xa2\xb8"",\n""\xe9\xa3\x95"": ""\xe9\xa2\xbc"",\n""\xe9\xa3\x96"": ""\xe9\xa2\xbb"",\n""\xe9\xa3\x97"": ""\xe9\xa3\x80"",\n""\xe9\xa3\x98"": ""\xe9\xa3\x84"",\n""\xe9\xa3\x99"": ""\xe9\xa3\x86"",\n""\xe9\xa3\x9a"": ""\xe9\xa3\x88"",\n""\xe9\xa3\x9e"": ""\xe9\xa3\x9b"",\n""\xe9\xa3\xa8"": ""\xe9\xa5\x97"",\n""\xe9\xa4\x8d"": ""\xe9\xa5\x9c"",\n""\xe9\xa5\xa3"": ""\xe9\xa3\xa0"",\n""\xe9\xa5\xa4"": ""\xe9\xa3\xa3"",\n""\xe9\xa5\xa6"": ""\xe9\xa3\xa5"",\n""\xe9\xa5\xa7"": ""\xe9\xa4\xb3"",\n""\xe9\xa5\xa8"": ""\xe9\xa3\xa9"",\n""\xe9\xa5\xa9"": ""\xe9\xa4\xbc"",\n""\xe9\xa5\xaa"": ""\xe9\xa3\xaa"",\n""\xe9\xa5\xab"": ""\xe9\xa3\xab"",\n""\xe9\xa5\xac"": ""\xe9\xa3\xad"",\n""\xe9\xa5\xad"": ""\xe9\xa3\xaf"",\n""\xe9\xa5\xae"": ""\xe9\xa3\xb2"",\n""\xe9\xa5\xaf"": ""\xe9\xa4\x9e"",\n""\xe9\xa5\xb0"": ""\xe9\xa3\xbe"",\n""\xe9\xa5\xb1"": ""\xe9\xa3\xbd"",\n""\xe9\xa5\xb2"": ""\xe9\xa3\xbc"",\n""\xe9\xa5\xb3"": ""\xe9\xa3\xbf"",\n""\xe9\xa5\xb4"": ""\xe9\xa3\xb4"",\n""\xe9\xa5\xb5"": ""\xe9\xa4\x8c"",\n""\xe9\xa5\xb6"": ""\xe9\xa5\x92"",\n""\xe9\xa5\xb7"": ""\xe9\xa4\x89"",\n""\xe9\xa5\xb8"": ""\xe9\xa4\x84"",\n""\xe9\xa5\xb9"": ""\xe9\xa4\x8e"",\n""\xe9\xa5\xba"": ""\xe9\xa4\x83"",\n""\xe9\xa5\xbb"": ""\xe9\xa4\x8f"",\n""\xe9\xa5\xbc"": ""\xe9\xa4\x85"",\n""\xe9\xa5\xbd"": ""\xe9\xa4\x91"",\n""\xe9\xa5\xbe"": ""\xe9\xa4\x96"",\n""\xe9\xa5\xbf"": ""\xe9\xa4\x93"",\n""\xe9\xa6\x80"": ""\xe9\xa4\x98"",\n""\xe9\xa6\x81"": ""\xe9\xa4\x92"",\n""\xe9\xa6\x82"": ""\xe9\xa4\x95"",\n""\xe9\xa6\x83"": ""\xe9\xa4\x9c"",\n""\xe9\xa6\x84"": ""\xe9\xa4\x9b"",\n""\xe9\xa6\x85"": ""\xe9\xa4\xa1"",\n""\xe9\xa6\x86"": ""\xe9\xa4\xa8"",\n""\xe9\xa6\x87"": ""\xe9\xa4\xb7"",\n""\xe9\xa6\x88"": ""\xe9\xa5\x8b"",\n""\xe9\xa6\x89"": ""\xe9\xa4\xb6"",\n""\xe9\xa6\x8a"": ""\xe9\xa4\xbf"",\n""\xe9\xa6\x8b"": ""\xe9\xa5\x9e"",\n""\xe9\xa6\x8c"": ""\xe9\xa5\x81"",\n""\xe9\xa6\x8d"": ""\xe9\xa5\x83"",\n""\xe9\xa6\x8e"": ""\xe9\xa4\xba"",\n""\xe9\xa6\x8f"": ""\xe9\xa4\xbe"",\n""\xe9\xa6\x90"": ""\xe9\xa5\x88"",\n""\xe9\xa6\x91"": ""\xe9\xa5\x89"",\n""\xe9\xa6\x92"": ""\xe9\xa5\x85"",\n""\xe9\xa6\x93"": ""\xe9\xa5\x8a"",\n""\xe9\xa6\x94"": ""\xe9\xa5\x8c"",\n""\xe9\xa6\x95"": ""\xe9\xa5\xa2"",\n""\xe4\xaf\x84"": ""\xe9\xa8\xa7"",\n""\xe9\xa9\xac"": ""\xe9\xa6\xac"",\n""\xe9\xa9\xad"": ""\xe9\xa6\xad"",\n""\xe9\xa9\xae"": ""\xe9\xa6\xb1"",\n""\xe9\xa9\xaf"": ""\xe9\xa6\xb4"",\n""\xe9\xa9\xb0"": ""\xe9\xa6\xb3"",\n""\xe9\xa9\xb1"": ""\xe9\xa9\x85"",\n""\xe9\xa9\xb2"": ""\xe9\xa6\xb9"",\n""\xe9\xa9\xb3"": ""\xe9\xa7\x81"",\n""\xe9\xa9\xb4"": ""\xe9\xa9\xa2"",\n""\xe9\xa9\xb5"": ""\xe9\xa7\x94"",\n""\xe9\xa9\xb6"": ""\xe9\xa7\x9b"",\n""\xe9\xa9\xb7"": ""\xe9\xa7\x9f"",\n""\xe9\xa9\xb8"": ""\xe9\xa7\x99"",\n""\xe9\xa9\xb9"": ""\xe9\xa7\x92"",\n""\xe9\xa9\xba"": ""\xe9\xa8\xb6"",\n""\xe9\xa9\xbb"": ""\xe9\xa7\x90"",\n""\xe9\xa9\xbc"": ""\xe9\xa7\x9d"",\n""\xe9\xa9\xbd"": ""\xe9\xa7\x91"",\n""\xe9\xa9\xbe"": ""\xe9\xa7\x95"",\n""\xe9\xa9\xbf"": ""\xe9\xa9\x9b"",\n""\xe9\xaa\x80"": ""\xe9\xa7\x98"",\n""\xe9\xaa\x81"": ""\xe9\xa9\x8d"",\n""\xe9\xaa\x83"": ""\xe9\xa7\xb0"",\n""\xe9\xaa\x84"": ""\xe9\xa9\x95"",\n""\xe9\xaa\x85"": ""\xe9\xa9\x8a"",\n""\xe9\xaa\x86"": ""\xe9\xa7\xb1"",\n""\xe9\xaa\x87"": ""\xe9\xa7\xad"",\n""\xe9\xaa\x88"": ""\xe9\xa7\xa2"",\n""\xe9\xaa\x89"": ""\xe9\xa9\xab"",\n""\xe9\xaa\x8a"": ""\xe9\xa9\xaa"",\n""\xe9\xaa\x8b"": ""\xe9\xa8\x81"",\n""\xe9\xaa\x8c"": ""\xe9\xa9\x97"",\n""\xe9\xaa\x8d"": ""\xe9\xa8\x82"",\n""\xe9\xaa\x8e"": ""\xe9\xa7\xb8"",\n""\xe9\xaa\x8f"": ""\xe9\xa7\xbf"",\n""\xe9\xaa\x90"": ""\xe9\xa8\x8f"",\n""\xe9\xaa\x91"": ""\xe9\xa8\x8e"",\n""\xe9\xaa\x92"": ""\xe9\xa8\x8d"",\n""\xe9\xaa\x93"": ""\xe9\xa8\x85"",\n""\xe9\xaa\x94"": ""\xe9\xa8\x8c"",\n""\xe9\xaa\x95"": ""\xe9\xa9\x8c"",\n""\xe9\xaa\x96"": ""\xe9\xa9\x82"",\n""\xe9\xaa\x97"": ""\xe9\xa8\x99"",\n""\xe9\xaa\x98"": ""\xe9\xa8\xad"",\n""\xe9\xaa\x99"": ""\xe9\xa8\xa4"",\n""\xe9\xaa\x9a"": ""\xe9\xa8\xb7"",\n""\xe9\xaa\x9b"": ""\xe9\xa8\x96"",\n""\xe9\xaa\x9c"": ""\xe9\xa9\x81"",\n""\xe9\xaa\x9d"": ""\xe9\xa8\xae"",\n""\xe9\xaa\x9e"": ""\xe9\xa8\xab"",\n""\xe9\xaa\x9f"": ""\xe9\xa8\xb8"",\n""\xe9\xaa\xa0"": ""\xe9\xa9\x83"",\n""\xe9\xaa\xa1"": ""\xe9\xa8\xbe"",\n""\xe9\xaa\xa2"": ""\xe9\xa9\x84"",\n""\xe9\xaa\xa3"": ""\xe9\xa9\x8f"",\n""\xe9\xaa\xa4"": ""\xe9\xa9\x9f"",\n""\xe9\xaa\xa5"": ""\xe9\xa9\xa5"",\n""\xe9\xaa\xa6"": ""\xe9\xa9\xa6"",\n""\xe9\xaa\xa7"": ""\xe9\xa9\xa4"",\n""\xe9\xab\x85"": ""\xe9\xab\x8f"",\n""\xe9\xab\x8b"": ""\xe9\xab\x96"",\n""\xe9\xab\x8c"": ""\xe9\xab\x95"",\n""\xe9\xac\x93"": ""\xe9\xac\xa2"",\n""\xe9\xad\x87"": ""\xe9\xad\x98"",\n""\xe9\xad\x89"": ""\xe9\xad\x8e"",\n""\xe9\xb1\xbc"": ""\xe9\xad\x9a"",\n""\xe9\xb1\xbd"": ""\xe9\xad\x9b"",\n""\xe9\xb1\xbe"": ""\xe9\xad\xa2"",\n""\xe9\xb1\xbf"": ""\xe9\xad\xb7"",\n""\xe9\xb2\x80"": ""\xe9\xad\xa8"",\n""\xe9\xb2\x81"": ""\xe9\xad\xaf"",\n""\xe9\xb2\x82"": ""\xe9\xad\xb4"",\n""\xe9\xb2\x83"": ""\xe4\xb0\xbe"",\n""\xe9\xb2\x84"": ""\xe9\xad\xba"",\n""\xe9\xb2\x85"": ""\xe9\xae\x81"",\n""\xe9\xb2\x86"": ""\xe9\xae\x83"",\n""\xe9\xb2\x88"": ""\xe9\xb1\xb8"",\n""\xe9\xb2\x89"": ""\xe9\xae\x8b"",\n""\xe9\xb2\x8a"": ""\xe9\xae\x93"",\n""\xe9\xb2\x8b"": ""\xe9\xae\x92"",\n""\xe9\xb2\x8c"": ""\xe9\xae\x8a"",\n""\xe9\xb2\x8d"": ""\xe9\xae\x91"",\n""\xe9\xb2\x8e"": ""\xe9\xb1\x9f"",\n""\xe9\xb2\x8f"": ""\xe9\xae\x8d"",\n""\xe9\xb2\x90"": ""\xe9\xae\x90"",\n""\xe9\xb2\x91"": ""\xe9\xae\xad"",\n""\xe9\xb2\x92"": ""\xe9\xae\x9a"",\n""\xe9\xb2\x93"": ""\xe9\xae\xb3"",\n""\xe9\xb2\x94"": ""\xe9\xae\xaa"",\n""\xe9\xb2\x95"": ""\xe9\xae\x9e"",\n""\xe9\xb2\x96"": ""\xe9\xae\xa6"",\n""\xe9\xb2\x97"": ""\xe9\xb0\x82"",\n""\xe9\xb2\x98"": ""\xe9\xae\x9c"",\n""\xe9\xb2\x99"": ""\xe9\xb1\xa0"",\n""\xe9\xb2\x9a"": ""\xe9\xb1\xad"",\n""\xe9\xb2\x9b"": ""\xe9\xae\xab"",\n""\xe9\xb2\x9c"": ""\xe9\xae\xae"",\n""\xe9\xb2\x9d"": ""\xe9\xae\xba"",\n""\xe9\xb2\x9f"": ""\xe9\xb1\x98"",\n""\xe9\xb2\xa0"": ""\xe9\xaf\x81"",\n""\xe9\xb2\xa1"": ""\xe9\xb1\xba"",\n""\xe9\xb2\xa2"": ""\xe9\xb0\xb1"",\n""\xe9\xb2\xa3"": ""\xe9\xb0\xb9"",\n""\xe9\xb2\xa4"": ""\xe9\xaf\x89"",\n""\xe9\xb2\xa5"": ""\xe9\xb0\xa3"",\n""\xe9\xb2\xa6"": ""\xe9\xb0\xb7"",\n""\xe9\xb2\xa7"": ""\xe9\xaf\x80"",\n""\xe9\xb2\xa8"": ""\xe9\xaf\x8a"",\n""\xe9\xb2\xa9"": ""\xe9\xaf\x87"",\n""\xe9\xb2\xaa"": ""\xe9\xae\xb6"",\n""\xe9\xb2\xab"": ""\xe9\xaf\xbd"",\n""\xe9\xb2\xac"": ""\xe9\xaf\x92"",\n""\xe9\xb2\xad"": ""\xe9\xaf\x96"",\n""\xe9\xb2\xae"": ""\xe9\xaf\xaa"",\n""\xe9\xb2\xaf"": ""\xe9\xaf\x95"",\n""\xe9\xb2\xb0"": ""\xe9\xaf\xab"",\n""\xe9\xb2\xb1"": ""\xe9\xaf\xa1"",\n""\xe9\xb2\xb2"": ""\xe9\xaf\xa4"",\n""\xe9\xb2\xb3"": ""\xe9\xaf\xa7"",\n""\xe9\xb2\xb4"": ""\xe9\xaf\x9d"",\n""\xe9\xb2\xb5"": ""\xe9\xaf\xa2"",\n""\xe9\xb2\xb6"": ""\xe9\xaf\xb0"",\n""\xe9\xb2\xb7"": ""\xe9\xaf\x9b"",\n""\xe9\xb2\xb8"": ""\xe9\xaf\xa8"",\n""\xe9\xb2\xb9"": ""\xe9\xb0\xba"",\n""\xe9\xb2\xba"": ""\xe9\xaf\xb4"",\n""\xe9\xb2\xbb"": ""\xe9\xaf\x94"",\n""\xe9\xb2\xbc"": ""\xe9\xb1\x9d"",\n""\xe9\xb2\xbd"": ""\xe9\xb0\x88"",\n""\xe9\xb2\xbe"": ""\xe9\xb0\x8f"",\n""\xe9\xb2\xbf"": ""\xe9\xb1\xa8"",\n""\xe9\xb3\x80"": ""\xe9\xaf\xb7"",\n""\xe9\xb3\x81"": ""\xe9\xb0\xae"",\n""\xe9\xb3\x82"": ""\xe9\xb0\x83"",\n""\xe9\xb3\x83"": ""\xe9\xb0\x93"",\n""\xe9\xb3\x85"": ""\xe9\xb0\x8d"",\n""\xe9\xb3\x86"": ""\xe9\xb0\x92"",\n""\xe9\xb3\x87"": ""\xe9\xb0\x89"",\n""\xe9\xb3\x88"": ""\xe9\xb0\x81"",\n""\xe9\xb3\x89"": ""\xe9\xb1\x82"",\n""\xe9\xb3\x8a"": ""\xe9\xaf\xbf"",\n""\xe9\xb3\x8b"": ""\xe9\xb0\xa0"",\n""\xe9\xb3\x8c"": ""\xe9\xb0\xb2"",\n""\xe9\xb3\x8d"": ""\xe9\xb0\xad"",\n""\xe9\xb3\x8e"": ""\xe9\xb0\xa8"",\n""\xe9\xb3\x8f"": ""\xe9\xb0\xa5"",\n""\xe9\xb3\x90"": ""\xe9\xb0\xa9"",\n""\xe9\xb3\x91"": ""\xe9\xb0\x9f"",\n""\xe9\xb3\x92"": ""\xe9\xb0\x9c"",\n""\xe9\xb3\x93"": ""\xe9\xb0\xb3"",\n""\xe9\xb3\x94"": ""\xe9\xb0\xbe"",\n""\xe9\xb3\x95"": ""\xe9\xb1\x88"",\n""\xe9\xb3\x96"": ""\xe9\xb1\x89"",\n""\xe9\xb3\x97"": ""\xe9\xb0\xbb"",\n""\xe9\xb3\x98"": ""\xe9\xb0\xb5"",\n""\xe9\xb3\x99"": ""\xe9\xb1\x85"",\n""\xe9\xb3\x9a"": ""\xe4\xb2\x81"",\n""\xe9\xb3\x9b"": ""\xe9\xb0\xbc"",\n""\xe9\xb3\x9c"": ""\xe9\xb1\x96"",\n""\xe9\xb3\x9d"": ""\xe9\xb1\x94"",\n""\xe9\xb3\x9e"": ""\xe9\xb1\x97"",\n""\xe9\xb3\x9f"": ""\xe9\xb1\x92"",\n""\xe9\xb3\xa0"": ""\xe9\xb1\xaf"",\n""\xe9\xb3\xa1"": ""\xe9\xb1\xa4"",\n""\xe9\xb3\xa2"": ""\xe9\xb1\xa7"",\n""\xe9\xb3\xa3"": ""\xe9\xb1\xa3"",\n""\xe4\xb4\x93"": ""\xe9\xb3\xbe"",\n""\xe4\xb4\x95"": ""\xe9\xb4\xb7"",\n""\xe4\xb4\x94"": ""\xe9\xb5\x81"",\n""\xe4\xb4\x96"": ""\xe9\xb6\x84"",\n""\xe4\xb4\x97"": ""\xe9\xb6\xaa"",\n""\xe4\xb4\x98"": ""\xe9\xb7\x88"",\n""\xe4\xb4\x99"": ""\xe9\xb7\xbf"",\n""\xe3\xb6\x89"": ""\xe9\xb8\x82"",\n""\xe9\xb8\x9f"": ""\xe9\xb3\xa5"",\n""\xe9\xb8\xa0"": ""\xe9\xb3\xa9"",\n""\xe9\xb8\xa2"": ""\xe9\xb3\xb6"",\n""\xe9\xb8\xa3"": ""\xe9\xb3\xb4"",\n""\xe9\xb8\xa4"": ""\xe9\xb3\xb2"",\n""\xe9\xb8\xa5"": ""\xe9\xb7\x97"",\n""\xe9\xb8\xa6"": ""\xe9\xb4\x89"",\n""\xe9\xb8\xa7"": ""\xe9\xb6\xac"",\n""\xe9\xb8\xa8"": ""\xe9\xb4\x87"",\n""\xe9\xb8\xa9"": ""\xe9\xb4\x86"",\n""\xe9\xb8\xaa"": ""\xe9\xb4\xa3"",\n""\xe9\xb8\xab"": ""\xe9\xb6\x87"",\n""\xe9\xb8\xac"": ""\xe9\xb8\x95"",\n""\xe9\xb8\xad"": ""\xe9\xb4\xa8"",\n""\xe9\xb8\xae"": ""\xe9\xb4\x9e"",\n""\xe9\xb8\xaf"": ""\xe9\xb4\xa6"",\n""\xe9\xb8\xb0"": ""\xe9\xb4\x92"",\n""\xe9\xb8\xb1"": ""\xe9\xb4\x9f"",\n""\xe9\xb8\xb2"": ""\xe9\xb4\x9d"",\n""\xe9\xb8\xb3"": ""\xe9\xb4\x9b"",\n""\xe9\xb8\xb4"": ""\xe9\xb7\xbd"",\n""\xe9\xb8\xb5"": ""\xe9\xb4\x95"",\n""\xe9\xb8\xb6"": ""\xe9\xb7\xa5"",\n""\xe9\xb8\xb7"": ""\xe9\xb7\x99"",\n""\xe9\xb8\xb8"": ""\xe9\xb4\xaf"",\n""\xe9\xb8\xb9"": ""\xe9\xb4\xb0"",\n""\xe9\xb8\xba"": ""\xe9\xb5\x82"",\n""\xe9\xb8\xbb"": ""\xe9\xb4\xb4"",\n""\xe9\xb8\xbc"": ""\xe9\xb5\x83"",\n""\xe9\xb8\xbd"": ""\xe9\xb4\xbf"",\n""\xe9\xb8\xbe"": ""\xe9\xb8\x9e"",\n""\xe9\xb8\xbf"": ""\xe9\xb4\xbb"",\n""\xe9\xb9\x80"": ""\xe9\xb5\x90"",\n""\xe9\xb9\x81"": ""\xe9\xb5\x93"",\n""\xe9\xb9\x82"": ""\xe9\xb8\x9d"",\n""\xe9\xb9\x83"": ""\xe9\xb5\x91"",\n""\xe9\xb9\x84"": ""\xe9\xb5\xa0"",\n""\xe9\xb9\x85"": ""\xe9\xb5\x9d"",\n""\xe9\xb9\x86"": ""\xe9\xb5\x92"",\n""\xe9\xb9\x87"": ""\xe9\xb7\xb3"",\n""\xe9\xb9\x88"": ""\xe9\xb5\x9c"",\n""\xe9\xb9\x89"": ""\xe9\xb5\xa1"",\n""\xe9\xb9\x8a"": ""\xe9\xb5\xb2"",\n""\xe9\xb9\x8b"": ""\xe9\xb6\x93"",\n""\xe9\xb9\x8c"": ""\xe9\xb5\xaa"",\n""\xe9\xb9\x8d"": ""\xe9\xb5\xbe"",\n""\xe9\xb9\x8e"": ""\xe9\xb5\xaf"",\n""\xe9\xb9\x8f"": ""\xe9\xb5\xac"",\n""\xe9\xb9\x90"": ""\xe9\xb5\xae"",\n""\xe9\xb9\x91"": ""\xe9\xb6\x89"",\n""\xe9\xb9\x92"": ""\xe9\xb6\x8a"",\n""\xe9\xb9\x93"": ""\xe9\xb5\xb7"",\n""\xe9\xb9\x94"": ""\xe9\xb7\xab"",\n""\xe9\xb9\x95"": ""\xe9\xb6\x98"",\n""\xe9\xb9\x96"": ""\xe9\xb6\xa1"",\n""\xe9\xb9\x97"": ""\xe9\xb6\x9a"",\n""\xe9\xb9\x98"": ""\xe9\xb6\xbb"",\n""\xe9\xb9\x99"": ""\xe9\xb6\x96"",\n""\xe9\xb9\x9b"": ""\xe9\xb6\xa5"",\n""\xe9\xb9\x9c"": ""\xe9\xb6\xa9"",\n""\xe9\xb9\x9d"": ""\xe9\xb7\x8a"",\n""\xe9\xb9\x9e"": ""\xe9\xb7\x82"",\n""\xe9\xb9\x9f"": ""\xe9\xb6\xb2"",\n""\xe9\xb9\xa0"": ""\xe9\xb6\xb9"",\n""\xe9\xb9\xa1"": ""\xe9\xb6\xba"",\n""\xe9\xb9\xa2"": ""\xe9\xb7\x81"",\n""\xe9\xb9\xa3"": ""\xe9\xb6\xbc"",\n""\xe9\xb9\xa4"": ""\xe9\xb6\xb4"",\n""\xe9\xb9\xa5"": ""\xe9\xb7\x96"",\n""\xe9\xb9\xa6"": ""\xe9\xb8\x9a"",\n""\xe9\xb9\xa7"": ""\xe9\xb7\x93"",\n""\xe9\xb9\xa8"": ""\xe9\xb7\x9a"",\n""\xe9\xb9\xa9"": ""\xe9\xb7\xaf"",\n""\xe9\xb9\xaa"": ""\xe9\xb7\xa6"",\n""\xe9\xb9\xab"": ""\xe9\xb7\xb2"",\n""\xe9\xb9\xac"": ""\xe9\xb7\xb8"",\n""\xe9\xb9\xad"": ""\xe9\xb7\xba"",\n""\xe9\xb9\xaf"": ""\xe9\xb8\x87"",\n""\xe9\xb9\xb0"": ""\xe9\xb7\xb9"",\n""\xe9\xb9\xb1"": ""\xe9\xb8\x8c"",\n""\xe9\xb9\xb2"": ""\xe9\xb8\x8f"",\n""\xe9\xb9\xb3"": ""\xe9\xb8\x9b"",\n""\xe9\xb9\xb4"": ""\xe9\xb8\x98"",\n""\xe9\xb9\xbe"": ""\xe9\xb9\xba"",\n""\xe9\xba\xa6"": ""\xe9\xba\xa5"",\n""\xe9\xba\xb8"": ""\xe9\xba\xa9"",\n""\xe9\xbb\x84"": ""\xe9\xbb\x83"",\n""\xe9\xbb\x89"": ""\xe9\xbb\x8c"",\n""\xe9\xbb\xa1"": ""\xe9\xbb\xb6"",\n""\xe9\xbb\xa9"": ""\xe9\xbb\xb7"",\n""\xe9\xbb\xaa"": ""\xe9\xbb\xb2"",\n""\xe9\xbb\xbe"": ""\xe9\xbb\xbd"",\n""\xe9\xbc\x8b"": ""\xe9\xbb\xbf"",\n""\xe9\xbc\x8d"": ""\xe9\xbc\x89"",\n""\xe9\xbc\x97"": ""\xe9\x9e\x80"",\n""\xe9\xbc\xb9"": ""\xe9\xbc\xb4"",\n""\xe9\xbd\x90"": ""\xe9\xbd\x8a"",\n""\xe9\xbd\x91"": ""\xe9\xbd\x8f"",\n""\xe9\xbd\xbf"": ""\xe9\xbd\x92"",\n""\xe9\xbe\x80"": ""\xe9\xbd\x94"",\n""\xe9\xbe\x81"": ""\xe9\xbd\x95"",\n""\xe9\xbe\x82"": ""\xe9\xbd\x97"",\n""\xe9\xbe\x83"": ""\xe9\xbd\x9f"",\n""\xe9\xbe\x84"": ""\xe9\xbd\xa1"",\n""\xe9\xbe\x85"": ""\xe9\xbd\x99"",\n""\xe9\xbe\x86"": ""\xe9\xbd\xa0"",\n""\xe9\xbe\x87"": ""\xe9\xbd\x9c"",\n""\xe9\xbe\x88"": ""\xe9\xbd\xa6"",\n""\xe9\xbe\x89"": ""\xe9\xbd\xac"",\n""\xe9\xbe\x8a"": ""\xe9\xbd\xaa"",\n""\xe9\xbe\x8b"": ""\xe9\xbd\xb2"",\n""\xe9\xbe\x8c"": ""\xe9\xbd\xb7"",\n""\xe9\xbe\x99"": ""\xe9\xbe\x8d"",\n""\xe9\xbe\x9a"": ""\xe9\xbe\x94"",\n""\xe9\xbe\x9b"": ""\xe9\xbe\x95"",\n""\xe9\xbe\x9f"": ""\xe9\xbe\x9c"",\n""\xe4\xb8\x80\xe4\xbc\x99"": ""\xe4\xb8\x80\xe4\xbc\x99"",\n""\xe4\xb8\x80\xe5\xb9\xb6"": ""\xe4\xb8\x80\xe4\xbd\xb5"",\n""\xe4\xb8\x80\xe5\x87\x86"": ""\xe4\xb8\x80\xe5\x87\x86"",\n""\xe4\xb8\x80\xe5\x88\x92"": ""\xe4\xb8\x80\xe5\x88\x92"",\n""\xe4\xb8\x80\xe5\x9c\xb0\xe9\x87\x8c"": ""\xe4\xb8\x80\xe5\x9c\xb0\xe8\xa3\xa1"",\n""\xe4\xb8\x80\xe5\xb9\xb2"": ""\xe4\xb8\x80\xe5\xb9\xb2"",\n""\xe4\xb8\x80\xe6\xa0\x91\xe7\x99\xbe\xe8\x8e\xb7"": ""\xe4\xb8\x80\xe6\xa8\xb9\xe7\x99\xbe\xe7\xa9\xab"",\n""\xe4\xb8\x80\xe5\x8f\xb0"": ""\xe4\xb8\x80\xe8\x87\xba"",\n""\xe4\xb8\x80\xe5\x86\xb2"": ""\xe4\xb8\x80\xe8\xa1\x9d"",\n""\xe4\xb8\x80\xe5\x8f\xaa"": ""\xe4\xb8\x80\xe9\x9a\xbb"",\n""\xe4\xb8\x80\xe5\x8f\x91\xe5\x8d\x83\xe9\x92\xa7"": ""\xe4\xb8\x80\xe9\xab\xae\xe5\x8d\x83\xe9\x88\x9e"",\n""\xe4\xb8\x80\xe5\x87\xba"": ""\xe4\xb8\x80\xe9\xbd\xa3"",\n""\xe4\xb8\x83\xe5\x8f\xaa"": ""\xe4\xb8\x83\xe9\x9a\xbb"",\n""\xe4\xb8\x89\xe5\x85\x83\xe9\x87\x8c"": ""\xe4\xb8\x89\xe5\x85\x83\xe8\xa3\xa1"",\n""\xe4\xb8\x89\xe5\x9b\xbd\xe5\xbf\x97"": ""\xe4\xb8\x89\xe5\x9c\x8b\xe8\xaa\x8c"",\n""\xe4\xb8\x89\xe5\xa4\x8d"": ""\xe4\xb8\x89\xe8\xa4\x87"",\n""\xe4\xb8\x89\xe5\x8f\xaa"": ""\xe4\xb8\x89\xe9\x9a\xbb"",\n""\xe4\xb8\x8a\xe5\x90\x8a"": ""\xe4\xb8\x8a\xe5\x90\x8a"",\n""\xe4\xb8\x8a\xe5\x8f\xb0"": ""\xe4\xb8\x8a\xe8\x87\xba"",\n""\xe4\xb8\x8b\xe4\xb8\x8d\xe4\xba\x86\xe5\x8f\xb0"": ""\xe4\xb8\x8b\xe4\xb8\x8d\xe4\xba\x86\xe8\x87\xba"",\n""\xe4\xb8\x8b\xe5\x8f\xb0"": ""\xe4\xb8\x8b\xe8\x87\xba"",\n""\xe4\xb8\x8b\xe9\x9d\xa2"": ""\xe4\xb8\x8b\xe9\xba\xb5"",\n""\xe4\xb8\x8d\xe5\x87\x86"": ""\xe4\xb8\x8d\xe5\x87\x86"",\n""\xe4\xb8\x8d\xe5\x90\x8a"": ""\xe4\xb8\x8d\xe5\x90\x8a"",\n""\xe4\xb8\x8d\xe7\x9f\xa5\xe5\xb0\xb1\xe9\x87\x8c"": ""\xe4\xb8\x8d\xe7\x9f\xa5\xe5\xb0\xb1\xe8\xa3\xa1"",\n""\xe4\xb8\x8d\xe7\x9f\xa5\xe6\x89\x80\xe4\xba\x91"": ""\xe4\xb8\x8d\xe7\x9f\xa5\xe6\x89\x80\xe4\xba\x91"",\n""\xe4\xb8\x8d\xe9\x94\x88\xe9\x92\xa2"": ""\xe4\xb8\x8d\xe9\x8f\xbd\xe9\x8b\xbc"",\n""\xe4\xb8\x91\xe5\x89\xa7"": ""\xe4\xb8\x91\xe5\x8a\x87"",\n""\xe4\xb8\x91\xe6\x97\xa6"": ""\xe4\xb8\x91\xe6\x97\xa6"",\n""\xe4\xb8\x91\xe8\xa7\x92"": ""\xe4\xb8\x91\xe8\xa7\x92"",\n""\xe5\xb9\xb6\xe5\xad\x98\xe7\x9d\x80"": ""\xe4\xb8\xa6\xe5\xad\x98\xe8\x91\x97"",\n""\xe4\xb8\xad\xe5\xb2\xb3"": ""\xe4\xb8\xad\xe5\xb6\xbd"",\n""\xe4\xb8\xad\xe5\x8f\xb0\xe5\x8c\xbb\xe4\xb8\x93"": ""\xe4\xb8\xad\xe8\x87\xba\xe9\x86\xab\xe5\xb0\x88"",\n""\xe4\xb8\xb0\xe5\x8d\x97"": ""\xe4\xb8\xb0\xe5\x8d\x97"",\n""\xe4\xb8\xb0\xe5\x8f\xb0"": ""\xe4\xb8\xb0\xe5\x8f\xb0"",\n""\xe4\xb8\xb0\xe5\xa7\xbf"": ""\xe4\xb8\xb0\xe5\xa7\xbf"",\n""\xe4\xb8\xb0\xe9\x87\x87"": ""\xe4\xb8\xb0\xe9\x87\x87"",\n""\xe4\xb8\xb0\xe9\x9f\xb5"": ""\xe4\xb8\xb0\xe9\x9f\xbb"",\n""\xe4\xb8\xbb\xe5\xb9\xb2"": ""\xe4\xb8\xbb\xe5\xb9\xb9"",\n""\xe4\xb9\x88\xe4\xb9\x88\xe5\x94\xb1\xe5\x94\xb1"": ""\xe4\xb9\x88\xe4\xb9\x88\xe5\x94\xb1\xe5\x94\xb1"",\n""\xe4\xb9\x88\xe5\x84\xbf"": ""\xe4\xb9\x88\xe5\x85\x92"",\n""\xe4\xb9\x88\xe5\x96\x9d"": ""\xe4\xb9\x88\xe5\x96\x9d"",\n""\xe4\xb9\x88\xe5\xa6\xb9"": ""\xe4\xb9\x88\xe5\xa6\xb9"",\n""\xe4\xb9\x88\xe5\xbc\x9f"": ""\xe4\xb9\x88\xe5\xbc\x9f"",\n""\xe4\xb9\x88\xe7\x88\xb7"": ""\xe4\xb9\x88\xe7\x88\xba"",\n""\xe4\xb9\x9d\xe4\xb8\x96\xe4\xb9\x8b\xe9\x9b\xa0"": ""\xe4\xb9\x9d\xe4\xb8\x96\xe4\xb9\x8b\xe8\xae\x8e"",\n""\xe4\xb9\x9d\xe5\x8f\xaa"": ""\xe4\xb9\x9d\xe9\x9a\xbb"",\n""\xe5\xb9\xb2\xe4\xb8\x9d"": ""\xe4\xb9\xbe\xe7\xb5\xb2"",\n""\xe5\xb9\xb2\xe7\x9d\x80\xe6\x80\xa5"": ""\xe4\xb9\xbe\xe8\x91\x97\xe6\x80\xa5"",\n""\xe4\xb9\xb1\xe5\x8f\x91"": ""\xe4\xba\x82\xe9\xab\xae"",\n""\xe4\xba\x91\xe4\xba\x91"": ""\xe4\xba\x91\xe4\xba\x91"",\n""\xe4\xba\x91\xe5\xb0\x94"": ""\xe4\xba\x91\xe7\x88\xbe"",\n""\xe4\xba\x94\xe5\xb2\xb3"": ""\xe4\xba\x94\xe5\xb6\xbd"",\n""\xe4\xba\x94\xe6\x96\x97\xe6\x9f\x9c"": ""\xe4\xba\x94\xe6\x96\x97\xe6\xab\x83"",\n""\xe4\xba\x94\xe6\x96\x97\xe6\xa9\xb1"": ""\xe4\xba\x94\xe6\x96\x97\xe6\xab\xa5"",\n""\xe4\xba\x94\xe8\xb0\xb7"": ""\xe4\xba\x94\xe7\xa9\x80"",\n""\xe4\xba\x94\xe8\xa1\x8c\xe7\x94\x9f\xe5\x85\x8b"": ""\xe4\xba\x94\xe8\xa1\x8c\xe7\x94\x9f\xe5\x89\x8b"",\n""\xe4\xba\x94\xe5\x8f\xaa"": ""\xe4\xba\x94\xe9\x9a\xbb"",\n""\xe4\xba\x94\xe5\x87\xba"": ""\xe4\xba\x94\xe9\xbd\xa3"",\n""\xe4\xba\xa4\xe5\x8d\xb7"": ""\xe4\xba\xa4\xe5\x8d\xb7"",\n""\xe4\xba\xba\xe4\xba\x91\xe4\xba\xa6\xe4\xba\x91"": ""\xe4\xba\xba\xe4\xba\x91\xe4\xba\xa6\xe4\xba\x91"",\n""\xe4\xba\xba\xe7\x89\xa9\xe5\xbf\x97"": ""\xe4\xba\xba\xe7\x89\xa9\xe8\xaa\x8c"",\n""\xe4\xbb\x80\xe9\x94\xa6\xe9\x9d\xa2"": ""\xe4\xbb\x80\xe9\x8c\xa6\xe9\xba\xb5"",\n""\xe4\xbb\x80\xe4\xb9\x88"": ""\xe4\xbb\x80\xe9\xba\xbc"",\n""\xe4\xbb\x86\xe5\x80\x92"": ""\xe4\xbb\x86\xe5\x80\x92"",\n""\xe4\xbb\x8b\xe7\xb3\xbb\xe8\xaf\x8d"": ""\xe4\xbb\x8b\xe4\xbf\x82\xe8\xa9\x9e"",\n""\xe4\xbb\x8b\xe7\xb3\xbb\xe8\xaf\x8d"": ""\xe4\xbb\x8b\xe7\xb9\xab\xe8\xa9\x9e"",\n""\xe4\xbb\xbf\xe5\x88\xb6"": ""\xe4\xbb\xbf\xe8\xa3\xbd"",\n""\xe4\xbc\x99\xe4\xbc\x95"": ""\xe4\xbc\x99\xe4\xbc\x95"",\n""\xe4\xbc\x99\xe4\xbc\xb4"": ""\xe4\xbc\x99\xe4\xbc\xb4"",\n""\xe4\xbc\x99\xe5\x90\x8c"": ""\xe4\xbc\x99\xe5\x90\x8c"",\n""\xe4\xbc\x99\xe5\xa4\xab"": ""\xe4\xbc\x99\xe5\xa4\xab"",\n""\xe4\xbc\x99\xe6\x88\xbf"": ""\xe4\xbc\x99\xe6\x88\xbf"",\n""\xe4\xbc\x99\xe8\xae\xa1"": ""\xe4\xbc\x99\xe8\xa8\x88"",\n""\xe4\xbc\x99\xe9\xa3\x9f"": ""\xe4\xbc\x99\xe9\xa3\x9f"",\n""\xe5\xb8\x83\xe4\xb8\x8b"": ""\xe4\xbd\x88\xe4\xb8\x8b"",\n""\xe5\xb8\x83\xe5\x91\x8a"": ""\xe4\xbd\x88\xe5\x91\x8a"",\n""\xe5\xb8\x83\xe5\x93\xa8"": ""\xe4\xbd\x88\xe5\x93\xa8"",\n""\xe5\xb8\x83\xe5\xb1\x80"": ""\xe4\xbd\x88\xe5\xb1\x80"",\n""\xe5\xb8\x83\xe5\xb2\x97"": ""\xe4\xbd\x88\xe5\xb4\x97"",\n""\xe5\xb8\x83\xe6\x96\xbd"": ""\xe4\xbd\x88\xe6\x96\xbd"",\n""\xe5\xb8\x83\xe6\x99\xaf"": ""\xe4\xbd\x88\xe6\x99\xaf"",\n""\xe5\xb8\x83\xe6\xbb\xa1"": ""\xe4\xbd\x88\xe6\xbb\xbf"",\n""\xe5\xb8\x83\xe7\xba\xbf"": ""\xe4\xbd\x88\xe7\xb7\x9a"",\n""\xe5\xb8\x83\xe7\xbd\xae"": ""\xe4\xbd\x88\xe7\xbd\xae"",\n""\xe5\xb8\x83\xe7\xbd\xb2"": ""\xe4\xbd\x88\xe7\xbd\xb2"",\n""\xe5\xb8\x83\xe9\x81\x93"": ""\xe4\xbd\x88\xe9\x81\x93"",\n""\xe5\xb8\x83\xe8\xbe\xbe"": ""\xe4\xbd\x88\xe9\x81\x94"",\n""\xe5\xb8\x83\xe9\x98\xb2"": ""\xe4\xbd\x88\xe9\x98\xb2"",\n""\xe5\xb8\x83\xe9\x98\xb5"": ""\xe4\xbd\x88\xe9\x99\xa3"",\n""\xe5\xb8\x83\xe9\x9b\xb7"": ""\xe4\xbd\x88\xe9\x9b\xb7"",\n""\xe4\xbd\x93\xe8\x82\xb2\xe9\x94\xbb\xe9\x8d\x8a"": ""\xe4\xbd\x93\xe8\x82\xb2\xe9\x8d\x9b\xe9\x8d\x8a"",\n""\xe4\xbd\x95\xe5\xb9\xb2"": ""\xe4\xbd\x95\xe5\xb9\xb2"",\n""\xe4\xbd\x9c\xe5\x87\x86"": ""\xe4\xbd\x9c\xe5\x87\x86"",\n""\xe4\xbd\xa3\xe4\xba\xba"": ""\xe4\xbd\xa3\xe4\xba\xba"",\n""\xe4\xbd\xa3\xe5\xb7\xa5"": ""\xe4\xbd\xa3\xe5\xb7\xa5"",\n""\xe4\xbd\xa3\xe9\x87\x91"": ""\xe4\xbd\xa3\xe9\x87\x91"",\n""\xe5\xb9\xb6\xe5\x85\xa5"": ""\xe4\xbd\xb5\xe5\x85\xa5"",\n""\xe5\xb9\xb6\xe5\x88\x97"": ""\xe4\xbd\xb5\xe5\x88\x97"",\n""\xe5\xb9\xb6\xe5\x88\xb0"": ""\xe4\xbd\xb5\xe5\x88\xb0"",\n""\xe5\xb9\xb6\xe5\x90\x88"": ""\xe4\xbd\xb5\xe5\x90\x88"",\n""\xe5\xb9\xb6\xe5\x90\x9e"": ""\xe4\xbd\xb5\xe5\x90\x9e"",\n""\xe5\xb9\xb6\xe5\x9c\xa8"": ""\xe4\xbd\xb5\xe5\x9c\xa8"",\n""\xe5\xb9\xb6\xe6\x88\x90"": ""\xe4\xbd\xb5\xe6\x88\x90"",\n""\xe5\xb9\xb6\xe6\x8e\x92"": ""\xe4\xbd\xb5\xe6\x8e\x92"",\n""\xe5\xb9\xb6\xe6\x8b\xa2"": ""\xe4\xbd\xb5\xe6\x94\x8f"",\n""\xe5\xb9\xb6\xe6\xa1\x88"": ""\xe4\xbd\xb5\xe6\xa1\x88"",\n""\xe5\xb9\xb6\xe4\xb8\xba"": ""\xe4\xbd\xb5\xe7\x82\xba"",\n""\xe5\xb9\xb6\xe5\x8f\x91"": ""\xe4\xbd\xb5\xe7\x99\xbc"",\n""\xe5\xb9\xb6\xe7\xa7\x91"": ""\xe4\xbd\xb5\xe7\xa7\x91"",\n""\xe5\xb9\xb6\xe8\xb4\xad"": ""\xe4\xbd\xb5\xe8\xb3\xbc"",\n""\xe5\xb9\xb6\xe8\xbf\x9b"": ""\xe4\xbd\xb5\xe9\x80\xb2"",\n""\xe6\x9d\xa5\xe5\xa4\x8d"": ""\xe4\xbe\x86\xe8\xa4\x87"",\n""\xe4\xbe\x9b\xe5\x88\xb6"": ""\xe4\xbe\x9b\xe8\xa3\xbd"",\n""\xe4\xbe\x9d\xe4\xbe\x9d\xe4\xb8\x8d\xe8\x88\x8d"": ""\xe4\xbe\x9d\xe4\xbe\x9d\xe4\xb8\x8d\xe6\x8d\xa8"",\n""\xe4\xbe\xb5\xe5\xb9\xb6"": ""\xe4\xbe\xb5\xe4\xbd\xb5"",\n""\xe4\xbe\xbf\xe8\xbe\x9f"": ""\xe4\xbe\xbf\xe8\xbe\x9f"",\n""\xe7\xb3\xbb\xe6\x95\xb0"": ""\xe4\xbf\x82\xe6\x95\xb8"",\n""\xe7\xb3\xbb\xe4\xb8\xba"": ""\xe4\xbf\x82\xe7\x82\xba"",\n""\xe4\xbf\x9d\xe9\x99\xa9\xe6\x9f\x9c"": ""\xe4\xbf\x9d\xe9\x9a\xaa\xe6\x9f\x9c"",\n""\xe4\xbf\xa1\xe5\x8f\xb7\xe5\x8f\xb0"": ""\xe4\xbf\xa1\xe8\x99\x9f\xe8\x87\xba"",\n""\xe4\xbf\xae\xe5\xa4\x8d"": ""\xe4\xbf\xae\xe8\xa4\x87"",\n""\xe4\xbf\xae\xe8\x83\xa1\xe5\x88\x80"": ""\xe4\xbf\xae\xe9\xac\x8d\xe5\x88\x80"",\n""\xe4\xbf\xaf\xe5\x86\xb2"": ""\xe4\xbf\xaf\xe8\xa1\x9d"",\n""\xe4\xb8\xaa\xe9\x87\x8c"": ""\xe5\x80\x8b\xe8\xa3\xa1"",\n""\xe5\x80\x9f\xe7\x9d\x80"": ""\xe5\x80\x9f\xe8\x91\x97"",\n""\xe5\x81\x87\xe5\x8f\x91"": ""\xe5\x81\x87\xe9\xab\xae"",\n""\xe5\x81\x9c\xe5\x88\xb6"": ""\xe5\x81\x9c\xe8\xa3\xbd"",\n""\xe5\x81\xb7\xe9\xb8\xa1\xe4\xb8\x8d\xe7\x9d\x80"": ""\xe5\x81\xb7\xe9\x9b\x9e\xe4\xb8\x8d\xe8\x91\x97"",\n""\xe5\xae\xb6\xe4\xbc\x99"": ""\xe5\x82\xa2\xe4\xbc\x99"",\n""\xe5\xae\xb6\xe4\xbf\xb1"": ""\xe5\x82\xa2\xe4\xbf\xb1"",\n""\xe5\xae\xb6\xe5\x85\xb7"": ""\xe5\x82\xa2\xe5\x85\xb7"",\n""\xe4\xbc\xa0\xe5\xb8\x83"": ""\xe5\x82\xb3\xe4\xbd\x88"",\n""\xe5\x80\xba\xe5\x8f\xb0\xe9\xab\x98\xe7\xad\x91"": ""\xe5\x82\xb5\xe8\x87\xba\xe9\xab\x98\xe7\xaf\x89"",\n""\xe5\x82\xbb\xe9\x87\x8c\xe5\x82\xbb\xe6\xb0\x94"": ""\xe5\x82\xbb\xe8\xa3\xa1\xe5\x82\xbb\xe6\xb0\xa3"",\n""\xe5\x80\xbe\xe5\xae\xb6\xe8\x8d\xa1\xe4\xba\xa7"": ""\xe5\x82\xbe\xe5\xae\xb6\xe8\x95\xa9\xe7\x94\xa2"",\n""\xe5\x80\xbe\xe5\xa4\x8d"": ""\xe5\x82\xbe\xe8\xa4\x87"",\n""\xe5\x80\xbe\xe5\xa4\x8d"": ""\xe5\x82\xbe\xe8\xa6\x86"",\n""\xe5\x83\xb1\xe4\xbd\xa3"": ""\xe5\x83\xb1\xe4\xbd\xa3"",\n""\xe4\xbb\xaa\xe8\xa1\xa8"": ""\xe5\x84\x80\xe9\x8c\xb6"",\n""\xe4\xba\xbf\xe5\x8f\xaa"": ""\xe5\x84\x84\xe9\x9a\xbb"",\n""\xe5\xb0\xbd\xe5\xb0\xbd"": ""\xe5\x84\x98\xe5\x84\x98"",\n""\xe5\xb0\xbd\xe5\x85\x88"": ""\xe5\x84\x98\xe5\x85\x88"",\n""\xe5\xb0\xbd\xe5\x85\xb6\xe6\x89\x80\xe6\x9c\x89"": ""\xe5\x84\x98\xe5\x85\xb6\xe6\x89\x80\xe6\x9c\x89"",\n""\xe5\xb0\xbd\xe5\x8a\x9b"": ""\xe5\x84\x98\xe5\x8a\x9b"",\n""\xe5\xb0\xbd\xe5\xbf\xab"": ""\xe5\x84\x98\xe5\xbf\xab"",\n""\xe5\xb0\xbd\xe6\x97\xa9"": ""\xe5\x84\x98\xe6\x97\xa9"",\n""\xe5\xb0\xbd\xe6\x98\xaf"": ""\xe5\x84\x98\xe6\x98\xaf"",\n""\xe5\xb0\xbd\xe7\xae\xa1"": ""\xe5\x84\x98\xe7\xae\xa1"",\n""\xe5\xb0\xbd\xe9\x80\x9f"": ""\xe5\x84\x98\xe9\x80\x9f"",\n""\xe5\xb0\xbd\xe9\x87\x8f"": ""\xe5\x84\x98\xe9\x87\x8f"",\n""\xe5\x85\x81\xe5\x87\x86"": ""\xe5\x85\x81\xe5\x87\x86"",\n""\xe5\x85\x84\xe5\x8f\xb0"": ""\xe5\x85\x84\xe8\x87\xba"",\n""\xe5\x85\x85\xe9\xa5\xa5"": ""\xe5\x85\x85\xe9\xa5\x91"",\n""\xe5\x85\x89\xe9\x87\x87"": ""\xe5\x85\x89\xe9\x87\x87"",\n""\xe5\x85\x8b\xe9\x87\x8c"": ""\xe5\x85\x8b\xe8\xa3\xa1"",\n""\xe5\x85\x8b\xe5\xa4\x8d"": ""\xe5\x85\x8b\xe8\xa4\x87"",\n""\xe5\x85\xa5\xe4\xbc\x99"": ""\xe5\x85\xa5\xe4\xbc\x99"",\n""\xe5\x86\x85\xe5\x88\xb6"": ""\xe5\x85\xa7\xe8\xa3\xbd"",\n""\xe4\xb8\xa4\xe5\x8f\xaa"": ""\xe5\x85\xa9\xe9\x9a\xbb"",\n""\xe5\x85\xab\xe5\xad\x97\xe8\x83\xa1"": ""\xe5\x85\xab\xe5\xad\x97\xe9\xac\x8d"",\n""\xe5\x85\xab\xe5\x8f\xaa"": ""\xe5\x85\xab\xe9\x9a\xbb"",\n""\xe5\x85\xac\xe5\xb8\x83"": ""\xe5\x85\xac\xe4\xbd\x88"",\n""\xe5\x85\xac\xe5\xb9\xb2"": ""\xe5\x85\xac\xe5\xb9\xb9"",\n""\xe5\x85\xac\xe6\x96\x97"": ""\xe5\x85\xac\xe6\x96\x97"",\n""\xe5\x85\xac\xe5\x8e\x86"": ""\xe5\x85\xac\xe6\x9b\x86"",\n""\xe5\x85\xad\xe5\x8f\xaa"": ""\xe5\x85\xad\xe9\x9a\xbb"",\n""\xe5\x85\xad\xe5\x87\xba"": ""\xe5\x85\xad\xe9\xbd\xa3"",\n""\xe5\x85\xbc\xe5\xb9\xb6"": ""\xe5\x85\xbc\xe4\xbd\xb5"",\n""\xe5\x86\xa4\xe9\x9b\xa0"": ""\xe5\x86\xa4\xe8\xae\x8e"",\n""\xe5\x87\x86\xe4\xba\x88"": ""\xe5\x87\x86\xe4\xba\x88"",\n""\xe5\x87\x86\xe5\x81\x87"": ""\xe5\x87\x86\xe5\x81\x87"",\n""\xe5\x87\x86\xe5\xb0\x86"": ""\xe5\x87\x86\xe5\xb0\x87"",\n""\xe5\x87\x86\xe8\x80\x83\xe8\xaf\x81"": ""\xe5\x87\x86\xe8\x80\x83\xe8\xad\x89"",\n""\xe5\x87\x86\xe8\xae\xb8"": ""\xe5\x87\x86\xe8\xa8\xb1"",\n""\xe5\x87\xa0\xe5\x87\xa0"": ""\xe5\x87\xa0\xe5\x87\xa0"",\n""\xe5\x87\xa0\xe6\xa1\x88"": ""\xe5\x87\xa0\xe6\xa1\x88"",\n""\xe5\x87\xa0\xe4\xb8\x9d"": ""\xe5\x87\xa0\xe7\xb5\xb2"",\n""\xe5\x87\xb9\xe6\xb4\x9e\xe9\x87\x8c"": ""\xe5\x87\xb9\xe6\xb4\x9e\xe8\xa3\xa1"",\n""\xe5\x87\xba\xe5\xbe\x81"": ""\xe5\x87\xba\xe5\xbe\x81"",\n""\xe5\x87\xba\xe9\x94\xa4"": ""\xe5\x87\xba\xe9\x8e\x9a"",\n""\xe5\x88\x80\xe5\x89\x8a\xe9\x9d\xa2"": ""\xe5\x88\x80\xe5\x89\x8a\xe9\xba\xb5"",\n""\xe5\x88\x81\xe6\x96\x97"": ""\xe5\x88\x81\xe6\x96\x97"",\n""\xe5\x88\x86\xe5\xb8\x83"": ""\xe5\x88\x86\xe4\xbd\x88"",\n""\xe5\x88\x87\xe9\x9d\xa2"": ""\xe5\x88\x87\xe9\xba\xb5"",\n""\xe5\x88\x8a\xe5\xb8\x83"": ""\xe5\x88\x8a\xe4\xbd\x88"",\n""\xe5\x88\x92\xe4\xb8\x8a"": ""\xe5\x88\x92\xe4\xb8\x8a"",\n""\xe5\x88\x92\xe4\xb8\x8b"": ""\xe5\x88\x92\xe4\xb8\x8b"",\n""\xe5\x88\x92\xe4\xb8\x8d\xe6\x9d\xa5"": ""\xe5\x88\x92\xe4\xb8\x8d\xe4\xbe\x86"",\n""\xe5\x88\x92\xe4\xba\x86"": ""\xe5\x88\x92\xe4\xba\x86"",\n""\xe5\x88\x92\xe5\x85\xb7"": ""\xe5\x88\x92\xe5\x85\xb7"",\n""\xe5\x88\x92\xe5\x87\xba"": ""\xe5\x88\x92\xe5\x87\xba"",\n""\xe5\x88\x92\xe5\x88\xb0"": ""\xe5\x88\x92\xe5\x88\xb0"",\n""\xe5\x88\x92\xe5\x8a\xa8"": ""\xe5\x88\x92\xe5\x8b\x95"",\n""\xe5\x88\x92\xe5\x8e\xbb"": ""\xe5\x88\x92\xe5\x8e\xbb"",\n""\xe5\x88\x92\xe5\xad\x90"": ""\xe5\x88\x92\xe5\xad\x90"",\n""\xe5\x88\x92\xe5\xbe\x97\xe6\x9d\xa5"": ""\xe5\x88\x92\xe5\xbe\x97\xe4\xbe\x86"",\n""\xe5\x88\x92\xe6\x8b\xb3"": ""\xe5\x88\x92\xe6\x8b\xb3"",\n""\xe5\x88\x92\xe6\xa1\xa8"": ""\xe5\x88\x92\xe6\xa7\xb3"",\n""\xe5\x88\x92\xe6\xb0\xb4"": ""\xe5\x88\x92\xe6\xb0\xb4"",\n""\xe5\x88\x92\xe7\xae\x97"": ""\xe5\x88\x92\xe7\xae\x97"",\n""\xe5\x88\x92\xe8\x88\xb9"": ""\xe5\x88\x92\xe8\x88\xb9"",\n""\xe5\x88\x92\xe8\x89\x87"": ""\xe5\x88\x92\xe8\x89\x87"",\n""\xe5\x88\x92\xe7\x9d\x80"": ""\xe5\x88\x92\xe8\x91\x97"",\n""\xe5\x88\x92\xe7\x9d\x80\xe8\xb5\xb0"": ""\xe5\x88\x92\xe8\x91\x97\xe8\xb5\xb0"",\n""\xe5\x88\x92\xe8\xa1\x8c"": ""\xe5\x88\x92\xe8\xa1\x8c"",\n""\xe5\x88\x92\xe8\xb5\xb0"": ""\xe5\x88\x92\xe8\xb5\xb0"",\n""\xe5\x88\x92\xe8\xb5\xb7"": ""\xe5\x88\x92\xe8\xb5\xb7"",\n""\xe5\x88\x92\xe8\xbf\x9b"": ""\xe5\x88\x92\xe9\x80\xb2"",\n""\xe5\x88\x92\xe8\xbf\x87"": ""\xe5\x88\x92\xe9\x81\x8e"",\n""\xe5\x88\x9d\xe5\xbe\x81"": ""\xe5\x88\x9d\xe5\xbe\x81"",\n""\xe5\x88\xab\xe8\x87\xb4"": ""\xe5\x88\xa5\xe7\xb7\xbb"",\n""\xe5\x88\xab\xe7\x9d\x80"": ""\xe5\x88\xa5\xe8\x91\x97"",\n""\xe5\x88\xab\xe5\x8f\xaa"": ""\xe5\x88\xa5\xe9\x9a\xbb"",\n""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9a"": ""\xe5\x88\xa9\xe6\xaf\x94\xe8\xa3\xa1\xe4\xba\x9e"",\n""\xe5\x88\xae\xe7\x9d\x80"": ""\xe5\x88\xae\xe8\x91\x97"",\n""\xe5\x88\xae\xe8\x83\xa1\xe5\x88\x80"": ""\xe5\x88\xae\xe9\xac\x8d\xe5\x88\x80"",\n""\xe5\x89\x83\xe5\x8f\x91"": ""\xe5\x89\x83\xe9\xab\xae"",\n""\xe5\x89\x83\xe9\xa1\xbb"": ""\xe5\x89\x83\xe9\xac\x9a"",\n""\xe5\x89\x8a\xe5\x8f\x91"": ""\xe5\x89\x8a\xe9\xab\xae"",\n""\xe5\x85\x8b\xe5\x88\xb6"": ""\xe5\x89\x8b\xe5\x88\xb6"",\n""\xe5\x85\x8b\xe6\x98\x9f"": ""\xe5\x89\x8b\xe6\x98\x9f"",\n""\xe5\x85\x8b\xe6\x9c\x8d"": ""\xe5\x89\x8b\xe6\x9c\x8d"",\n""\xe5\x85\x8b\xe6\xad\xbb"": ""\xe5\x89\x8b\xe6\xad\xbb"",\n""\xe5\x85\x8b\xe8\x96\x84"": ""\xe5\x89\x8b\xe8\x96\x84"",\n""\xe5\x89\x8d\xe4\xbb\x86\xe5\x90\x8e\xe7\xbb\xa7"": ""\xe5\x89\x8d\xe4\xbb\x86\xe5\xbe\x8c\xe7\xb9\xbc"",\n""\xe5\x89\x8d\xe5\x8f\xb0"": ""\xe5\x89\x8d\xe8\x87\xba"",\n""\xe5\x89\x8d\xe8\xbd\xa6\xe4\xb9\x8b\xe5\xa4\x8d"": ""\xe5\x89\x8d\xe8\xbb\x8a\xe4\xb9\x8b\xe8\xa6\x86"",\n""\xe5\x88\x9a\xe6\x89\x8d"": ""\xe5\x89\x9b\xe7\xba\x94"",\n""\xe5\x89\xaa\xe5\x8f\x91"": ""\xe5\x89\xaa\xe9\xab\xae"",\n""\xe5\x89\xb2\xe8\x88\x8d"": ""\xe5\x89\xb2\xe6\x8d\xa8"",\n""\xe5\x88\x9b\xe5\x88\xb6"": ""\xe5\x89\xb5\xe8\xa3\xbd"",\n""\xe5\x8a\xa0\xe9\x87\x8c\xe5\xae\x81"": ""\xe5\x8a\xa0\xe8\xa3\xa1\xe5\xaf\xa7"",\n""\xe5\x8a\xa8\xe8\x8d\xa1"": ""\xe5\x8b\x95\xe8\x95\xa9"",\n""\xe5\x8a\xb3\xe5\x8a\x9b\xe5\xa3\xab\xe8\xa1\xa8"": ""\xe5\x8b\x9e\xe5\x8a\x9b\xe5\xa3\xab\xe9\x8c\xb6"",\n""\xe5\x8c\x85\xe5\x87\x86"": ""\xe5\x8c\x85\xe5\x87\x86"",\n""\xe5\x8c\x85\xe8\xb0\xb7"": ""\xe5\x8c\x85\xe7\xa9\x80"",\n""\xe5\x8c\x97\xe6\x96\x97"": ""\xe5\x8c\x97\xe6\x96\x97"",\n""\xe5\x8c\x97\xe5\x9b\x9e"": ""\xe5\x8c\x97\xe8\xbf\xb4"",\n""\xe5\x8c\xa1\xe5\xa4\x8d"": ""\xe5\x8c\xa1\xe8\xa4\x87"",\n""\xe5\x8c\xaa\xe5\xb9\xb2"": ""\xe5\x8c\xaa\xe5\xb9\xb9"",\n""\xe5\x8d\x81\xe5\x8d\xb7"": ""\xe5\x8d\x81\xe5\x8d\xb7"",\n""\xe5\x8d\x81\xe5\x8f\xb0"": ""\xe5\x8d\x81\xe8\x87\xba"",\n""\xe5\x8d\x81\xe5\x8f\xaa"": ""\xe5\x8d\x81\xe9\x9a\xbb"",\n""\xe5\x8d\x81\xe5\x87\xba"": ""\xe5\x8d\x81\xe9\xbd\xa3"",\n""\xe5\x8d\x83\xe4\xb8\x9d\xe4\xb8\x87\xe7\xbc\x95"": ""\xe5\x8d\x83\xe7\xb5\xb2\xe8\x90\xac\xe7\xb8\xb7"",\n""\xe5\x8d\x83\xe5\x9b\x9e\xe7\x99\xbe\xe6\x8a\x98"": ""\xe5\x8d\x83\xe8\xbf\xb4\xe7\x99\xbe\xe6\x8a\x98"",\n""\xe5\x8d\x83\xe5\x9b\x9e\xe7\x99\xbe\xe8\xbd\xac"": ""\xe5\x8d\x83\xe8\xbf\xb4\xe7\x99\xbe\xe8\xbd\x89"",\n""\xe5\x8d\x83\xe9\x92\xa7\xe4\xb8\x80\xe5\x8f\x91"": ""\xe5\x8d\x83\xe9\x88\x9e\xe4\xb8\x80\xe9\xab\xae"",\n""\xe5\x8d\x83\xe5\x8f\xaa"": ""\xe5\x8d\x83\xe9\x9a\xbb"",\n""\xe5\x8d\x87\xe6\x96\x97\xe5\xb0\x8f\xe6\xb0\x91"": ""\xe5\x8d\x87\xe6\x96\x97\xe5\xb0\x8f\xe6\xb0\x91"",\n""\xe5\x8d\x8a\xe5\x8f\xaa"": ""\xe5\x8d\x8a\xe9\x9a\xbb"",\n""\xe5\x8d\x97\xe5\xb2\xb3"": ""\xe5\x8d\x97\xe5\xb6\xbd"",\n""\xe5\x8d\x97\xe5\xbe\x81"": ""\xe5\x8d\x97\xe5\xbe\x81"",\n""\xe5\x8d\x97\xe5\x8f\xb0"": ""\xe5\x8d\x97\xe8\x87\xba"",\n""\xe5\x8d\x97\xe5\x9b\x9e"": ""\xe5\x8d\x97\xe8\xbf\xb4"",\n""\xe5\x8d\xa1\xe9\x87\x8c"": ""\xe5\x8d\xa1\xe8\xa3\xa1"",\n""\xe5\x8d\xb0\xe5\x88\xb6"": ""\xe5\x8d\xb0\xe8\xa3\xbd"",\n""\xe5\x8d\xb7\xe5\x85\xa5"": ""\xe5\x8d\xb7\xe5\x85\xa5"",\n""\xe5\x8d\xb7\xe5\x8f\x96"": ""\xe5\x8d\xb7\xe5\x8f\x96"",\n""\xe5\x8d\xb7\xe5\x9c\x9f\xe9\x87\x8d\xe6\x9d\xa5"": ""\xe5\x8d\xb7\xe5\x9c\x9f\xe9\x87\x8d\xe4\xbe\x86"",\n""\xe5\x8d\xb7\xe5\xad\x90"": ""\xe5\x8d\xb7\xe5\xad\x90"",\n""\xe5\x8d\xb7\xe5\xae\x97"": ""\xe5\x8d\xb7\xe5\xae\x97"",\n""\xe5\x8d\xb7\xe5\xb0\xba"": ""\xe5\x8d\xb7\xe5\xb0\xba"",\n""\xe5\x8d\xb7\xe5\xb1\x82\xe4\xba\x91"": ""\xe5\x8d\xb7\xe5\xb1\xa4\xe9\x9b\xb2"",\n""\xe5\x8d\xb7\xe5\xb8\x99"": ""\xe5\x8d\xb7\xe5\xb8\x99"",\n""\xe5\x8d\xb7\xe6\x89\xac\xe6\x9c\xba"": ""\xe5\x8d\xb7\xe6\x8f\x9a\xe6\xa9\x9f"",\n""\xe5\x8d\xb7\xe6\x9b\xb2"": ""\xe5\x8d\xb7\xe6\x9b\xb2"",\n""\xe5\x8d\xb7\xe6\x9f\x93"": ""\xe5\x8d\xb7\xe6\x9f\x93"",\n""\xe5\x8d\xb7\xe7\x83\x9f"": ""\xe5\x8d\xb7\xe7\x85\x99"",\n""\xe5\x8d\xb7\xe7\xad\x92"": ""\xe5\x8d\xb7\xe7\xad\x92"",\n""\xe5\x8d\xb7\xe7\xba\xac"": ""\xe5\x8d\xb7\xe7\xb7\xaf"",\n""\xe5\x8d\xb7\xe7\xbb\x95"": ""\xe5\x8d\xb7\xe7\xb9\x9e"",\n""\xe5\x8d\xb7\xe8\xa3\x85"": ""\xe5\x8d\xb7\xe8\xa3\x9d"",\n""\xe5\x8d\xb7\xe8\xbd\xb4"": ""\xe5\x8d\xb7\xe8\xbb\xb8"",\n""\xe5\x8d\xb7\xe4\xba\x91"": ""\xe5\x8d\xb7\xe9\x9b\xb2"",\n""\xe5\x8d\xb7\xe9\xa2\x86"": ""\xe5\x8d\xb7\xe9\xa0\x98"",\n""\xe5\x8d\xb7\xe5\x8f\x91"": ""\xe5\x8d\xb7\xe9\xab\xae"",\n""\xe5\x8d\xb7\xe9\xa1\xbb"": ""\xe5\x8d\xb7\xe9\xac\x9a"",\n""\xe5\x8f\x82\xe4\xb8\x8e"": ""\xe5\x8f\x83\xe4\xb8\x8e"",\n""\xe5\x8f\x82\xe4\xb8\x8e\xe8\x80\x85"": ""\xe5\x8f\x83\xe4\xb8\x8e\xe8\x80\x85"",\n""\xe5\x8f\x82\xe5\x90\x88"": ""\xe5\x8f\x83\xe5\x90\x88"",\n""\xe5\x8f\x82\xe8\x80\x83\xe4\xbb\xb7\xe5\x80\xbc"": ""\xe5\x8f\x83\xe8\x80\x83\xe5\x83\xb9\xe5\x80\xbc"",\n""\xe5\x8f\x82\xe4\xb8\x8e"": ""\xe5\x8f\x83\xe8\x88\x87"",\n""\xe5\x8f\x82\xe4\xb8\x8e\xe4\xba\xba\xe5\x91\x98"": ""\xe5\x8f\x83\xe8\x88\x87\xe4\xba\xba\xe5\x93\xa1"",\n""\xe5\x8f\x82\xe4\xb8\x8e\xe5\x88\xb6"": ""\xe5\x8f\x83\xe8\x88\x87\xe5\x88\xb6"",\n""\xe5\x8f\x82\xe4\xb8\x8e\xe6\x84\x9f"": ""\xe5\x8f\x83\xe8\x88\x87\xe6\x84\x9f"",\n""\xe5\x8f\x82\xe4\xb8\x8e\xe8\x80\x85"": ""\xe5\x8f\x83\xe8\x88\x87\xe8\x80\x85"",\n""\xe5\x8f\x82\xe8\xa7\x82\xe5\x9b\xa2"": ""\xe5\x8f\x83\xe8\xa7\x80\xe5\x9c\x98"",\n""\xe5\x8f\x82\xe8\xa7\x82\xe5\x9b\xa2\xe4\xbd\x93"": ""\xe5\x8f\x83\xe8\xa7\x80\xe5\x9c\x98\xe9\xab\x94"",\n""\xe5\x8f\x82\xe9\x98\x85"": ""\xe5\x8f\x83\xe9\x96\xb1"",\n""\xe5\x8f\x8d\xe5\x86\xb2"": ""\xe5\x8f\x8d\xe8\xa1\x9d"",\n""\xe5\x8f\x8d\xe5\xa4\x8d"": ""\xe5\x8f\x8d\xe8\xa4\x87"",\n""\xe5\x8f\x8d\xe5\xa4\x8d"": ""\xe5\x8f\x8d\xe8\xa6\x86"",\n""\xe5\x8f\x96\xe8\x88\x8d"": ""\xe5\x8f\x96\xe6\x8d\xa8"",\n""\xe5\x8f\xa3\xe9\x87\x8c"": ""\xe5\x8f\xa3\xe8\xa3\xa1"",\n""\xe5\x8f\xaa\xe5\x87\x86"": ""\xe5\x8f\xaa\xe5\x87\x86"",\n""\xe5\x8f\xaa\xe5\x86\xb2"": ""\xe5\x8f\xaa\xe8\xa1\x9d"",\n""\xe5\x8f\xae\xe5\xbd\x93"": ""\xe5\x8f\xae\xe5\x99\xb9"",\n""\xe5\x8f\xaf\xe6\x80\x9c\xe8\x99\xab"": ""\xe5\x8f\xaf\xe6\x86\x90\xe8\x99\xab"",\n""\xe5\x8f\xaf\xe7\xb4\xa7\xe5\x8f\xaf\xe6\x9d\xbe"": ""\xe5\x8f\xaf\xe7\xb7\x8a\xe5\x8f\xaf\xe9\xac\x86"",\n""\xe5\x8f\xb0\xe5\x88\xb6"": ""\xe5\x8f\xb0\xe8\xa3\xbd"",\n""\xe5\x8f\xb8\xe4\xbb\xa4\xe5\x8f\xb0"": ""\xe5\x8f\xb8\xe4\xbb\xa4\xe8\x87\xba"",\n""\xe5\x90\x83\xe7\x9d\x80\xe4\xb8\x8d\xe5\xb0\xbd"": ""\xe5\x90\x83\xe8\x91\x97\xe4\xb8\x8d\xe7\x9b\xa1"",\n""\xe5\x90\x83\xe9\x87\x8c\xe6\x89\x92\xe5\xa4\x96"": ""\xe5\x90\x83\xe8\xa3\xa1\xe6\x89\x92\xe5\xa4\x96"",\n""\xe5\x90\x83\xe9\x87\x8c\xe7\x88\xac\xe5\xa4\x96"": ""\xe5\x90\x83\xe8\xa3\xa1\xe7\x88\xac\xe5\xa4\x96"",\n""\xe5\x90\x84\xe5\x90\x8a"": ""\xe5\x90\x84\xe5\x90\x8a"",\n""\xe5\x90\x88\xe4\xbc\x99"": ""\xe5\x90\x88\xe4\xbc\x99"",\n""\xe5\x90\x88\xe5\xb9\xb6"": ""\xe5\x90\x88\xe4\xbd\xb5"",\n""\xe5\x90\x88\xe7\x9d\x80"": ""\xe5\x90\x88\xe8\x91\x97"",\n""\xe5\x90\x88\xe7\x9d\x80\xe8\x80\x85"": ""\xe5\x90\x88\xe8\x91\x97\xe8\x80\x85"",\n""\xe5\x90\x8a\xe4\xb8\x8a"": ""\xe5\x90\x8a\xe4\xb8\x8a"",\n""\xe5\x90\x8a\xe4\xb8\x8b"": ""\xe5\x90\x8a\xe4\xb8\x8b"",\n""\xe5\x90\x8a\xe4\xba\x86"": ""\xe5\x90\x8a\xe4\xba\x86"",\n""\xe5\x90\x8a\xe4\xb8\xaa"": ""\xe5\x90\x8a\xe5\x80\x8b"",\n""\xe5\x90\x8a\xe5\x84\xbf\xe9\x83\x8e\xe5\xbd\x93"": ""\xe5\x90\x8a\xe5\x85\x92\xe9\x83\x8e\xe7\x95\xb6"",\n""\xe5\x90\x8a\xe5\x88\xb0"": ""\xe5\x90\x8a\xe5\x88\xb0"",\n""\xe5\x90\x8a\xe5\x8e\xbb"": ""\xe5\x90\x8a\xe5\x8e\xbb"",\n""\xe5\x90\x8a\xe5\x8f\x96"": ""\xe5\x90\x8a\xe5\x8f\x96"",\n""\xe5\x90\x8a\xe5\x90\x8a"": ""\xe5\x90\x8a\xe5\x90\x8a"",\n""\xe5\x90\x8a\xe5\x97\x93"": ""\xe5\x90\x8a\xe5\x97\x93"",\n""\xe5\x90\x8a\xe5\xa5\xbd"": ""\xe5\x90\x8a\xe5\xa5\xbd"",\n""\xe5\x90\x8a\xe5\xad\x90"": ""\xe5\x90\x8a\xe5\xad\x90"",\n""\xe5\x90\x8a\xe5\xb8\xa6"": ""\xe5\x90\x8a\xe5\xb8\xb6"",\n""\xe5\x90\x8a\xe5\xb8\xa6\xe8\xa3\xa4"": ""\xe5\x90\x8a\xe5\xb8\xb6\xe8\xa4\xb2"",\n""\xe5\x90\x8a\xe5\xba\x8a"": ""\xe5\x90\x8a\xe5\xba\x8a"",\n""\xe5\x90\x8a\xe5\xbe\x97"": ""\xe5\x90\x8a\xe5\xbe\x97"",\n""\xe5\x90\x8a\xe6\x8c\x82"": ""\xe5\x90\x8a\xe6\x8e\x9b"",\n""\xe5\x90\x8a\xe6\x8c\x82\xe7\x9d\x80"": ""\xe5\x90\x8a\xe6\x8e\x9b\xe8\x91\x97"",\n""\xe5\x90\x8a\xe6\x9d\x86"": ""\xe5\x90\x8a\xe6\x9d\x86"",\n""\xe5\x90\x8a\xe6\x9e\xb6"": ""\xe5\x90\x8a\xe6\x9e\xb6"",\n""\xe5\x90\x8a\xe6\xa1\xb6"": ""\xe5\x90\x8a\xe6\xa1\xb6"",\n""\xe5\x90\x8a\xe6\x9d\x86"": ""\xe5\x90\x8a\xe6\xa1\xbf"",\n""\xe5\x90\x8a\xe6\xa1\xa5"": ""\xe5\x90\x8a\xe6\xa9\x8b"",\n""\xe5\x90\x8a\xe6\xad\xbb"": ""\xe5\x90\x8a\xe6\xad\xbb"",\n""\xe5\x90\x8a\xe7\x81\xaf"": ""\xe5\x90\x8a\xe7\x87\x88"",\n""\xe5\x90\x8a\xe7\x8e\xaf"": ""\xe5\x90\x8a\xe7\x92\xb0"",\n""\xe5\x90\x8a\xe7\x9b\x98"": ""\xe5\x90\x8a\xe7\x9b\xa4"",\n""\xe5\x90\x8a\xe7\xb4\xa2"": ""\xe5\x90\x8a\xe7\xb4\xa2"",\n""\xe5\x90\x8a\xe7\x9d\x80"": ""\xe5\x90\x8a\xe8\x91\x97"",\n""\xe5\x90\x8a\xe8\xa3\x85"": ""\xe5\x90\x8a\xe8\xa3\x9d"",\n""\xe5\x90\x8a\xe8\xa3\xa4"": ""\xe5\x90\x8a\xe8\xa4\xb2"",\n""\xe5\x90\x8a\xe8\xa3\xa4\xe5\xb8\xa6"": ""\xe5\x90\x8a\xe8\xa4\xb2\xe5\xb8\xb6"",\n""\xe5\x90\x8a\xe8\xa2\x9c"": ""\xe5\x90\x8a\xe8\xa5\xaa"",\n""\xe5\x90\x8a\xe8\xb5\xb0"": ""\xe5\x90\x8a\xe8\xb5\xb0"",\n""\xe5\x90\x8a\xe8\xb5\xb7"": ""\xe5\x90\x8a\xe8\xb5\xb7"",\n""\xe5\x90\x8a\xe8\xbd\xa6"": ""\xe5\x90\x8a\xe8\xbb\x8a"",\n""\xe5\x90\x8a\xe9\x92\xa9"": ""\xe5\x90\x8a\xe9\x89\xa4"",\n""\xe5\x90\x8a\xe9\x94\x80"": ""\xe5\x90\x8a\xe9\x8a\xb7"",\n""\xe5\x90\x8a\xe9\x92\x9f"": ""\xe5\x90\x8a\xe9\x90\x98"",\n""\xe5\x90\x8c\xe4\xbc\x99"": ""\xe5\x90\x8c\xe4\xbc\x99"",\n""\xe5\x90\x8d\xe8\xa1\xa8"": ""\xe5\x90\x8d\xe9\x8c\xb6"",\n""\xe5\x90\x8e\xe5\x86\xa0"": ""\xe5\x90\x8e\xe5\x86\xa0"",\n""\xe5\x90\x8e\xe5\x9c\x9f"": ""\xe5\x90\x8e\xe5\x9c\x9f"",\n""\xe5\x90\x8e\xe5\xa6\x83"": ""\xe5\x90\x8e\xe5\xa6\x83"",\n""\xe5\x90\x8e\xe5\xba\xa7"": ""\xe5\x90\x8e\xe5\xba\xa7"",\n""\xe5\x90\x8e\xe7\xa8\xb7"": ""\xe5\x90\x8e\xe7\xa8\xb7"",\n""\xe5\x90\x8e\xe7\xbe\xbf"": ""\xe5\x90\x8e\xe7\xbe\xbf"",\n""\xe5\x90\x8e\xe9\x87\x8c"": ""\xe5\x90\x8e\xe9\x87\x8c"",\n""\xe5\x90\x91\xe7\x9d\x80"": ""\xe5\x90\x91\xe8\x91\x97"",\n""\xe5\x90\x9e\xe5\xb9\xb6"": ""\xe5\x90\x9e\xe4\xbd\xb5"",\n""\xe5\x90\xb9\xe5\x8f\x91"": ""\xe5\x90\xb9\xe9\xab\xae"",\n""\xe5\x90\x95\xe5\x90\x8e"": ""\xe5\x91\x82\xe5\x90\x8e"",\n""\xe7\x8d\x83\xe9\x87\x8c\xe7\x8d\x83\xe6\xb0\x94"": ""\xe5\x91\x86\xe8\xa3\xa1\xe5\x91\x86\xe6\xb0\xa3"",\n""\xe5\x91\xa8\xe8\x80\x8c\xe5\xa4\x8d\xe5\xa7\x8b"": ""\xe5\x91\xa8\xe8\x80\x8c\xe8\xa4\x87\xe5\xa7\x8b"",\n""\xe5\x91\xbc\xe5\x90\x81"": ""\xe5\x91\xbc\xe7\xb1\xb2"",\n""\xe5\x92\x8c\xe9\x9d\xa2"": ""\xe5\x92\x8c\xe9\xba\xb5"",\n""\xe5\x93\xaa\xe9\x87\x8c"": ""\xe5\x93\xaa\xe8\xa3\xa1"",\n""\xe5\x93\xad\xe8\x84\x8f"": ""\xe5\x93\xad\xe9\xab\x92"",\n""\xe9\x97\xae\xe5\x8d\xb7"": ""\xe5\x95\x8f\xe5\x8d\xb7"",\n""\xe5\x96\x9d\xe9\x87\x87"": ""\xe5\x96\x9d\xe9\x87\x87"",\n""\xe5\x8d\x95\xe5\xb9\xb2"": ""\xe5\x96\xae\xe5\xb9\xb2"",\n""\xe5\x8d\x95\xe5\x8f\xaa"": ""\xe5\x96\xae\xe9\x9a\xbb"",\n""\xe5\x98\xb4\xe9\x87\x8c"": ""\xe5\x98\xb4\xe8\xa3\xa1"",\n""\xe6\x81\xb6\xe5\xbf\x83"": ""\xe5\x99\x81\xe5\xbf\x83"",\n""\xe5\xbd\x93\xe5\x95\xb7"": ""\xe5\x99\xb9\xe5\x95\xb7"",\n""\xe5\xbd\x93\xe5\xbd\x93"": ""\xe5\x99\xb9\xe5\x99\xb9"",\n""\xe5\x99\x9c\xe8\x8b\x8f"": ""\xe5\x9a\x95\xe5\x9b\x8c"",\n""\xe5\x90\x91\xe5\xaf\xbc"": ""\xe5\x9a\xae\xe5\xb0\x8e"",\n""\xe5\x90\x91\xe5\xbe\x80"": ""\xe5\x9a\xae\xe5\xbe\x80"",\n""\xe5\x90\x91\xe5\xba\x94"": ""\xe5\x9a\xae\xe6\x87\x89"",\n""\xe5\x90\x91\xe6\x97\xa5"": ""\xe5\x9a\xae\xe6\x97\xa5"",\n""\xe5\x90\x91\xe8\xbf\xa9"": ""\xe5\x9a\xae\xe9\x82\x87"",\n""\xe4\xb8\xa5\xe4\xb8\x9d\xe5\x90\x88\xe7\xbc\x9d"": ""\xe5\x9a\xb4\xe7\xb5\xb2\xe5\x90\x88\xe7\xb8\xab"",\n""\xe4\xb8\xa5\xe5\xa4\x8d"": ""\xe5\x9a\xb4\xe8\xa4\x87"",\n""\xe5\x9b\x9b\xe8\x88\x8d\xe4\xba\x94\xe5\x85\xa5"": ""\xe5\x9b\x9b\xe6\x8d\xa8\xe4\xba\x94\xe5\x85\xa5"",\n""\xe5\x9b\x9b\xe5\x8f\xaa"": ""\xe5\x9b\x9b\xe9\x9a\xbb"",\n""\xe5\x9b\x9b\xe5\x87\xba"": ""\xe5\x9b\x9b\xe9\xbd\xa3"",\n""\xe5\x9b\x9e\xe4\xb8\x9d"": ""\xe5\x9b\x9e\xe7\xb5\xb2"",\n""\xe5\x9b\x9e\xe7\x9d\x80"": ""\xe5\x9b\x9e\xe8\x91\x97"",\n""\xe5\x9b\x9e\xe8\x8d\xa1"": ""\xe5\x9b\x9e\xe8\x95\xa9"",\n""\xe5\x9b\x9e\xe5\xa4\x8d"": ""\xe5\x9b\x9e\xe8\xa6\x86"",\n""\xe5\x9b\x9e\xe9\x87\x87"": ""\xe5\x9b\x9e\xe9\x87\x87"",\n""\xe5\x9c\x88\xe5\xad\x90\xe9\x87\x8c"": ""\xe5\x9c\x88\xe5\xad\x90\xe8\xa3\xa1"",\n""\xe5\x9c\x88\xe9\x87\x8c"": ""\xe5\x9c\x88\xe8\xa3\xa1"",\n""\xe5\x9b\xbd\xe5\x8e\x86"": ""\xe5\x9c\x8b\xe6\x9b\x86"",\n""\xe5\x9b\xbd\xe9\x9b\xa0"": ""\xe5\x9c\x8b\xe8\xae\x8e"",\n""\xe5\x9b\xad\xe9\x87\x8c"": ""\xe5\x9c\x92\xe8\xa3\xa1"",\n""\xe5\x9b\xbe\xe9\x87\x8c"": ""\xe5\x9c\x96\xe8\xa3\xa1"",\n""\xe5\x9c\x9f\xe9\x87\x8c"": ""\xe5\x9c\x9f\xe8\xa3\xa1"",\n""\xe5\x9c\x9f\xe5\x88\xb6"": ""\xe5\x9c\x9f\xe8\xa3\xbd"",\n""\xe5\x9c\xb0\xe5\xbf\x97"": ""\xe5\x9c\xb0\xe8\xaa\x8c"",\n""\xe5\x9d\x8d\xe5\x8f\xb0"": ""\xe5\x9d\x8d\xe8\x87\xba"",\n""\xe5\x9d\x91\xe9\x87\x8c"": ""\xe5\x9d\x91\xe8\xa3\xa1"",\n""\xe5\x9d\xa6\xe8\x8d\xa1"": ""\xe5\x9d\xa6\xe8\x95\xa9"",\n""\xe5\x9e\x82\xe5\x8f\x91"": ""\xe5\x9e\x82\xe9\xab\xae"",\n""\xe5\x9e\xae\xe5\x8f\xb0"": ""\xe5\x9e\xae\xe8\x87\xba"",\n""\xe5\x9f\x8b\xe5\xb8\x83"": ""\xe5\x9f\x8b\xe4\xbd\x88"",\n""\xe5\x9f\x8e\xe9\x87\x8c"": ""\xe5\x9f\x8e\xe8\xa3\xa1"",\n""\xe5\x9f\xba\xe5\xb9\xb2"": ""\xe5\x9f\xba\xe5\xb9\xb9"",\n""\xe6\x8a\xa5\xe5\xa4\x8d"": ""\xe5\xa0\xb1\xe8\xa4\x87"",\n""\xe5\xa1\x8c\xe5\x8f\xb0"": ""\xe5\xa1\x8c\xe8\x87\xba"",\n""\xe5\xa1\x94\xe5\x8f\xb0"": ""\xe5\xa1\x94\xe8\x87\xba"",\n""\xe6\xb6\x82\xe7\x9d\x80"": ""\xe5\xa1\x97\xe8\x91\x97"",\n""\xe5\xa2\x93\xe5\xbf\x97"": ""\xe5\xa2\x93\xe8\xaa\x8c"",\n""\xe5\xa2\xa8\xe6\x96\x97"": ""\xe5\xa2\xa8\xe6\x96\x97"",\n""\xe5\xa2\xa8\xe7\xb4\xa2\xe9\x87\x8c\xe5\xb0\xbc"": ""\xe5\xa2\xa8\xe7\xb4\xa2\xe8\xa3\xa1\xe5\xb0\xbc"",\n""\xe5\x9e\xa6\xe5\xa4\x8d"": ""\xe5\xa2\xbe\xe8\xa4\x87"",\n""\xe5\x9e\x84\xe6\x96\xad\xe4\xbb\xb7\xe6\xa0\xbc"": ""\xe5\xa3\x9f\xe6\x96\xb7\xe5\x83\xb9\xe6\xa0\xbc"",\n""\xe5\x9e\x84\xe6\x96\xad\xe8\xb5\x84\xe4\xba\xa7"": ""\xe5\xa3\x9f\xe6\x96\xb7\xe8\xb3\x87\xe7\x94\xa2"",\n""\xe5\x9e\x84\xe6\x96\xad\xe9\x9b\x86\xe5\x9b\xa2"": ""\xe5\xa3\x9f\xe6\x96\xb7\xe9\x9b\x86\xe5\x9c\x98"",\n""\xe5\xa3\xb6\xe9\x87\x8c"": ""\xe5\xa3\xba\xe8\xa3\xa1"",\n""\xe5\xaf\xbf\xe9\x9d\xa2"": ""\xe5\xa3\xbd\xe9\xba\xb5"",\n""\xe5\xa4\x8f\xe5\xa4\xa9\xe9\x87\x8c"": ""\xe5\xa4\x8f\xe5\xa4\xa9\xe8\xa3\xa1"",\n""\xe5\xa4\x8f\xe5\x8e\x86"": ""\xe5\xa4\x8f\xe6\x9b\x86"",\n""\xe5\xa4\x96\xe5\x88\xb6"": ""\xe5\xa4\x96\xe8\xa3\xbd"",\n""\xe5\xa4\x9a\xe5\x86\xb2"": ""\xe5\xa4\x9a\xe8\xa1\x9d"",\n""\xe5\xa4\x9a\xe9\x87\x87\xe5\xa4\x9a\xe5\xa7\xbf"": ""\xe5\xa4\x9a\xe9\x87\x87\xe5\xa4\x9a\xe5\xa7\xbf"",\n""\xe5\xa4\x9a\xe4\xb9\x88"": ""\xe5\xa4\x9a\xe9\xba\xbc"",\n""\xe5\xa4\x9c\xe5\x85\x89\xe8\xa1\xa8"": ""\xe5\xa4\x9c\xe5\x85\x89\xe9\x8c\xb6"",\n""\xe5\xa4\x9c\xe9\x87\x8c"": ""\xe5\xa4\x9c\xe8\xa3\xa1"",\n""\xe6\xa2\xa6\xe9\x87\x8c"": ""\xe5\xa4\xa2\xe8\xa3\xa1"",\n""\xe5\xa4\xa7\xe4\xbc\x99"": ""\xe5\xa4\xa7\xe4\xbc\x99"",\n""\xe5\xa4\xa7\xe5\x8d\xb7"": ""\xe5\xa4\xa7\xe5\x8d\xb7"",\n""\xe5\xa4\xa7\xe5\xb9\xb2"": ""\xe5\xa4\xa7\xe5\xb9\xb2"",\n""\xe5\xa4\xa7\xe5\xb9\xb2"": ""\xe5\xa4\xa7\xe5\xb9\xb9"",\n""\xe5\xa4\xa7\xe9\x94\xa4"": ""\xe5\xa4\xa7\xe9\x8e\x9a"",\n""\xe5\xa4\xa7\xe5\x8f\xaa"": ""\xe5\xa4\xa7\xe9\x9a\xbb"",\n""\xe5\xa4\xa9\xe5\x90\x8e"": ""\xe5\xa4\xa9\xe5\x90\x8e"",\n""\xe5\xa4\xa9\xe5\xb9\xb2"": ""\xe5\xa4\xa9\xe5\xb9\xb2"",\n""\xe5\xa4\xa9\xe6\x96\x87\xe5\x8f\xb0"": ""\xe5\xa4\xa9\xe6\x96\x87\xe8\x87\xba"",\n""\xe5\xa4\xa9\xe7\xbf\xbb\xe5\x9c\xb0\xe5\xa4\x8d"": ""\xe5\xa4\xa9\xe7\xbf\xbb\xe5\x9c\xb0\xe8\xa6\x86"",\n""\xe5\xa4\xaa\xe5\x90\x8e"": ""\xe5\xa4\xaa\xe5\x90\x8e"",\n""\xe5\xa5\x8f\xe6\x8a\x98"": ""\xe5\xa5\x8f\xe6\x91\xba"",\n""\xe5\xa5\xb3\xe4\xb8\x91"": ""\xe5\xa5\xb3\xe4\xb8\x91"",\n""\xe5\xa5\xb3\xe4\xbd\xa3"": ""\xe5\xa5\xb3\xe4\xbd\xa3"",\n""\xe5\xa5\xbd\xe5\xae\xb6\xe5\xa4\xa5"": ""\xe5\xa5\xbd\xe5\x82\xa2\xe5\xa4\xa5"",\n""\xe5\xa5\xbd\xe6\x88\x8f\xe8\xbf\x9e\xe5\x8f\xb0"": ""\xe5\xa5\xbd\xe6\x88\xb2\xe9\x80\xa3\xe8\x87\xba"",\n""\xe5\xa6\x82\xe6\xb3\x95\xe6\xb3\xa1\xe5\x88\xb6"": ""\xe5\xa6\x82\xe6\xb3\x95\xe6\xb3\xa1\xe8\xa3\xbd"",\n""\xe5\xa6\x86\xe5\x8f\xb0"": ""\xe5\xa6\x9d\xe8\x87\xba"",\n""\xe5\xa7\x9c\xe5\xa4\xaa\xe5\x85\xac"": ""\xe5\xa7\x9c\xe5\xa4\xaa\xe5\x85\xac"",\n""\xe5\xa7\x9c\xe5\xad\x90\xe7\x89\x99"": ""\xe5\xa7\x9c\xe5\xad\x90\xe7\x89\x99"",\n""\xe5\xa7\x9c\xe4\xb8\x9d"": ""\xe5\xa7\x9c\xe7\xb5\xb2"",\n""\xe5\xad\x97\xe6\xb1\x87"": ""\xe5\xad\x97\xe5\xbd\x99"",\n""\xe5\xad\x97\xe9\x87\x8c\xe8\xa1\x8c\xe9\x97\xb4"": ""\xe5\xad\x97\xe8\xa3\xa1\xe8\xa1\x8c\xe9\x96\x93"",\n""\xe5\xad\x98\xe6\x8a\x98"": ""\xe5\xad\x98\xe6\x91\xba"",\n""\xe5\xad\x9f\xe5\xa7\x9c\xe5\xa5\xb3"": ""\xe5\xad\x9f\xe5\xa7\x9c\xe5\xa5\xb3"",\n""\xe5\xae\x87\xe5\xae\x99\xe5\xbf\x97"": ""\xe5\xae\x87\xe5\xae\x99\xe8\xaa\x8c"",\n""\xe5\xae\x9a\xe5\x87\x86"": ""\xe5\xae\x9a\xe5\x87\x86"",\n""\xe5\xae\x9a\xe5\x88\xb6"": ""\xe5\xae\x9a\xe8\xa3\xbd"",\n""\xe5\xae\xa3\xe5\xb8\x83"": ""\xe5\xae\xa3\xe4\xbd\x88"",\n""\xe5\xae\xab\xe9\x87\x8c"": ""\xe5\xae\xae\xe8\xa3\xa1"",\n""\xe5\xae\xb6\xe4\xbc\x99"": ""\xe5\xae\xb6\xe4\xbc\x99"",\n""\xe5\xae\xb6\xe9\x87\x8c"": ""\xe5\xae\xb6\xe8\xa3\xa1"",\n""\xe5\xaf\x86\xe5\xb8\x83"": ""\xe5\xaf\x86\xe4\xbd\x88"",\n""\xe5\xaf\x87\xe9\x9b\xa0"": ""\xe5\xaf\x87\xe8\xae\x8e"",\n""\xe5\xae\x9e\xe5\xb9\xb2"": ""\xe5\xaf\xa6\xe5\xb9\xb9"",\n""\xe5\x86\x99\xe5\xad\x97\xe5\x8f\xb0"": ""\xe5\xaf\xab\xe5\xad\x97\xe6\xaa\xaf"",\n""\xe5\x86\x99\xe5\xad\x97\xe5\x8f\xb0"": ""\xe5\xaf\xab\xe5\xad\x97\xe8\x87\xba"",\n""\xe5\xae\xbd\xe6\x9d\xbe"": ""\xe5\xaf\xac\xe9\xac\x86"",\n""\xe5\xb0\x81\xe9\x9d\xa2\xe9\x87\x8c"": ""\xe5\xb0\x81\xe9\x9d\xa2\xe8\xa3\xa1"",\n""\xe5\xb0\x84\xe5\xb9\xb2"": ""\xe5\xb0\x84\xe5\xb9\xb2"",\n""\xe5\xaf\xb9\xe8\xa1\xa8"": ""\xe5\xb0\x8d\xe9\x8c\xb6"",\n""\xe5\xb0\x8f\xe4\xb8\x91"": ""\xe5\xb0\x8f\xe4\xb8\x91"",\n""\xe5\xb0\x8f\xe4\xbc\x99"": ""\xe5\xb0\x8f\xe4\xbc\x99"",\n""\xe5\xb0\x8f\xe5\x8f\xaa"": ""\xe5\xb0\x8f\xe9\x9a\xbb"",\n""\xe5\xb0\x91\xe5\x90\x8a"": ""\xe5\xb0\x91\xe5\x90\x8a"",\n""\xe5\xb0\xba\xe5\xb8\x83\xe6\x96\x97\xe7\xb2\x9f"": ""\xe5\xb0\xba\xe5\xb8\x83\xe6\x96\x97\xe7\xb2\x9f"",\n""\xe5\xb0\xbc\xe5\x85\x8b\xe6\x9d\xbe"": ""\xe5\xb0\xbc\xe5\x85\x8b\xe9\xac\x86"",\n""\xe5\xb0\xbc\xe9\x87\x87"": ""\xe5\xb0\xbc\xe9\x87\x87"",\n""\xe5\xb0\xbf\xe6\x96\x97"": ""\xe5\xb0\xbf\xe6\x96\x97"",\n""\xe5\xb1\x80\xe9\x87\x8c"": ""\xe5\xb1\x80\xe8\xa3\xa1"",\n""\xe5\xb1\x85\xe9\x87\x8c"": ""\xe5\xb1\x85\xe8\xa3\xa1"",\n""\xe5\xb1\x8b\xe5\xad\x90\xe9\x87\x8c"": ""\xe5\xb1\x8b\xe5\xad\x90\xe8\xa3\xa1"",\n""\xe5\xb1\x8b\xe9\x87\x8c"": ""\xe5\xb1\x8b\xe8\xa3\xa1"",\n""\xe5\xb1\x95\xe5\xb8\x83"": ""\xe5\xb1\x95\xe4\xbd\x88"",\n""\xe5\xb1\xa1\xe4\xbb\x86\xe5\xb1\xa1\xe8\xb5\xb7"": ""\xe5\xb1\xa2\xe4\xbb\x86\xe5\xb1\xa2\xe8\xb5\xb7"",\n""\xe5\xb1\xaf\xe9\x87\x8c"": ""\xe5\xb1\xaf\xe8\xa3\xa1"",\n""\xe5\xb1\xb1\xe5\xb2\xb3"": ""\xe5\xb1\xb1\xe5\xb6\xbd"",\n""\xe5\xb1\xb1\xe9\x87\x8c"": ""\xe5\xb1\xb1\xe8\xa3\xa1"",\n""\xe5\xb3\xb0\xe5\x9b\x9e"": ""\xe5\xb3\xb0\xe8\xbf\xb4"",\n""\xe5\xb7\xa1\xe5\x9b\x9e"": ""\xe5\xb7\xa1\xe8\xbf\xb4"",\n""\xe5\xb7\xa7\xe5\xb9\xb2"": ""\xe5\xb7\xa7\xe5\xb9\xb9"",\n""\xe5\xb7\xb4\xe5\xb0\x94\xe5\xb9\xb2"": ""\xe5\xb7\xb4\xe7\x88\xbe\xe5\xb9\xb9"",\n""\xe5\xb7\xb4\xe9\x87\x8c"": ""\xe5\xb7\xb4\xe8\xa3\xa1"",\n""\xe5\xb7\xb7\xe9\x87\x8c"": ""\xe5\xb7\xb7\xe8\xa3\xa1"",\n""\xe5\xb8\x82\xe9\x87\x8c"": ""\xe5\xb8\x82\xe8\xa3\xa1"",\n""\xe5\xb8\x83\xe8\xb0\xb7"": ""\xe5\xb8\x83\xe7\xa9\x80"",\n""\xe5\xb8\x8c\xe8\x85\x8a"": ""\xe5\xb8\x8c\xe8\x85\x8a"",\n""\xe5\xb8\x98\xe5\xad\x90"": ""\xe5\xb8\x98\xe5\xad\x90"",\n""\xe5\xb8\x98\xe5\xb8\x83"": ""\xe5\xb8\x98\xe5\xb8\x83"",\n""\xe5\xb8\xad\xe5\x8d\xb7"": ""\xe5\xb8\xad\xe5\x8d\xb7"",\n""\xe5\xb8\xa6\xe5\x9b\xa2\xe5\x8f\x82\xe5\x8a\xa0"": ""\xe5\xb8\xb6\xe5\x9c\x98\xe5\x8f\x83\xe5\x8a\xa0"",\n""\xe5\xb8\xa6\xe5\x8f\x91\xe4\xbf\xae\xe8\xa1\x8c"": ""\xe5\xb8\xb6\xe9\xab\xae\xe4\xbf\xae\xe8\xa1\x8c"",\n""\xe5\xb9\xb2\xe4\xbc\x91"": ""\xe5\xb9\xb2\xe4\xbc\x91"",\n""\xe5\xb9\xb2\xe7\xb3\xbb"": ""\xe5\xb9\xb2\xe4\xbf\x82"",\n""\xe5\xb9\xb2\xe5\x8d\xbf\xe4\xbd\x95\xe4\xba\x8b"": ""\xe5\xb9\xb2\xe5\x8d\xbf\xe4\xbd\x95\xe4\xba\x8b"",\n""\xe5\xb9\xb2\xe5\xb0\x86"": ""\xe5\xb9\xb2\xe5\xb0\x87"",\n""\xe5\xb9\xb2\xe6\x88\x88"": ""\xe5\xb9\xb2\xe6\x88\x88"",\n""\xe5\xb9\xb2\xe6\x8c\xa0"": ""\xe5\xb9\xb2\xe6\x92\x93"",\n""\xe5\xb9\xb2\xe6\x89\xb0"": ""\xe5\xb9\xb2\xe6\x93\xbe"",\n""\xe5\xb9\xb2\xe6\x94\xaf"": ""\xe5\xb9\xb2\xe6\x94\xaf"",\n""\xe5\xb9\xb2\xe6\x94\xbf"": ""\xe5\xb9\xb2\xe6\x94\xbf"",\n""\xe5\xb9\xb2\xe6\x97\xb6"": ""\xe5\xb9\xb2\xe6\x99\x82"",\n""\xe5\xb9\xb2\xe6\xb6\x89"": ""\xe5\xb9\xb2\xe6\xb6\x89"",\n""\xe5\xb9\xb2\xe7\x8a\xaf"": ""\xe5\xb9\xb2\xe7\x8a\xaf"",\n""\xe5\xb9\xb2\xe4\xb8\x8e"": ""\xe5\xb9\xb2\xe8\x88\x87"",\n""\xe5\xb9\xb2\xe7\x9d\x80\xe6\x80\xa5"": ""\xe5\xb9\xb2\xe8\x91\x97\xe6\x80\xa5"",\n""\xe5\xb9\xb2\xe8\xb4\x9d"": ""\xe5\xb9\xb2\xe8\xb2\x9d"",\n""\xe5\xb9\xb2\xe9\xa2\x84"": ""\xe5\xb9\xb2\xe9\xa0\x90"",\n""\xe5\xb9\xb3\xe5\x8f\xb0"": ""\xe5\xb9\xb3\xe8\x87\xba"",\n""\xe5\xb9\xb4\xe5\x8e\x86"": ""\xe5\xb9\xb4\xe6\x9b\x86"",\n""\xe5\xb9\xb4\xe9\x87\x8c"": ""\xe5\xb9\xb4\xe8\xa3\xa1"",\n""\xe5\xb9\xb2\xe4\xb8\x8a"": ""\xe5\xb9\xb9\xe4\xb8\x8a"",\n""\xe5\xb9\xb2\xe4\xb8\x8b\xe5\x8e\xbb"": ""\xe5\xb9\xb9\xe4\xb8\x8b\xe5\x8e\xbb"",\n""\xe5\xb9\xb2\xe4\xba\x86"": ""\xe5\xb9\xb9\xe4\xba\x86"",\n""\xe5\xb9\xb2\xe4\xba\x8b"": ""\xe5\xb9\xb9\xe4\xba\x8b"",\n""\xe5\xb9\xb2\xe4\xba\x9b"": ""\xe5\xb9\xb9\xe4\xba\x9b"",\n""\xe5\xb9\xb2\xe4\xb8\xaa"": ""\xe5\xb9\xb9\xe5\x80\x8b"",\n""\xe5\xb9\xb2\xe5\x8a\xb2"": ""\xe5\xb9\xb9\xe5\x8b\x81"",\n""\xe5\xb9\xb2\xe5\x91\x98"": ""\xe5\xb9\xb9\xe5\x93\xa1"",\n""\xe5\xb9\xb2\xe5\x90\x97"": ""\xe5\xb9\xb9\xe5\x97\x8e"",\n""\xe5\xb9\xb2\xe5\x98\x9b"": ""\xe5\xb9\xb9\xe5\x98\x9b"",\n""\xe5\xb9\xb2\xe5\x9d\x8f\xe4\xba\x8b"": ""\xe5\xb9\xb9\xe5\xa3\x9e\xe4\xba\x8b"",\n""\xe5\xb9\xb2\xe5\xae\x8c"": ""\xe5\xb9\xb9\xe5\xae\x8c"",\n""\xe5\xb9\xb2\xe5\xbe\x97"": ""\xe5\xb9\xb9\xe5\xbe\x97"",\n""\xe5\xb9\xb2\xe6\x80\xa7\xe6\xb2\xb9"": ""\xe5\xb9\xb9\xe6\x80\xa7\xe6\xb2\xb9"",\n""\xe5\xb9\xb2\xe6\x89\x8d"": ""\xe5\xb9\xb9\xe6\x89\x8d"",\n""\xe5\xb9\xb2\xe6\x8e\x89"": ""\xe5\xb9\xb9\xe6\x8e\x89"",\n""\xe5\xb9\xb2\xe6\xa0\xa1"": ""\xe5\xb9\xb9\xe6\xa0\xa1"",\n""\xe5\xb9\xb2\xe6\xb4\xbb"": ""\xe5\xb9\xb9\xe6\xb4\xbb"",\n""\xe5\xb9\xb2\xe6\xb5\x81"": ""\xe5\xb9\xb9\xe6\xb5\x81"",\n""\xe5\xb9\xb2\xe7\x90\x83\xe6\xb8\xa9\xe5\xba\xa6"": ""\xe5\xb9\xb9\xe7\x90\x83\xe6\xba\xab\xe5\xba\xa6"",\n""\xe5\xb9\xb2\xe7\xba\xbf"": ""\xe5\xb9\xb9\xe7\xb7\x9a"",\n""\xe5\xb9\xb2\xe7\xbb\x83"": ""\xe5\xb9\xb9\xe7\xb7\xb4"",\n""\xe5\xb9\xb2\xe8\xad\xa6"": ""\xe5\xb9\xb9\xe8\xad\xa6"",\n""\xe5\xb9\xb2\xe8\xb5\xb7\xe6\x9d\xa5"": ""\xe5\xb9\xb9\xe8\xb5\xb7\xe4\xbe\x86"",\n""\xe5\xb9\xb2\xe8\xb7\xaf"": ""\xe5\xb9\xb9\xe8\xb7\xaf"",\n""\xe5\xb9\xb2\xe9\x81\x93"": ""\xe5\xb9\xb9\xe9\x81\x93"",\n""\xe5\xb9\xb2\xe9\x83\xa8"": ""\xe5\xb9\xb9\xe9\x83\xa8"",\n""\xe5\xb9\xb2\xe4\xb9\x88"": ""\xe5\xb9\xb9\xe9\xba\xbc"",\n""\xe5\x87\xa0\xe4\xb8\x9d"": ""\xe5\xb9\xbe\xe7\xb5\xb2"",\n""\xe5\x87\xa0\xe5\x8f\xaa"": ""\xe5\xb9\xbe\xe9\x9a\xbb"",\n""\xe5\x87\xa0\xe5\x87\xba"": ""\xe5\xb9\xbe\xe9\xbd\xa3"",\n""\xe5\xba\x95\xe9\x87\x8c"": ""\xe5\xba\x95\xe8\xa3\xa1"",\n""\xe5\xba\xb7\xe9\x87\x87\xe6\x81\xa9"": ""\xe5\xba\xb7\xe9\x87\x87\xe6\x81\xa9"",\n""\xe5\xba\x99\xe9\x87\x8c"": ""\xe5\xbb\x9f\xe8\xa3\xa1"",\n""\xe5\xbb\xba\xe5\x8f\xb0"": ""\xe5\xbb\xba\xe8\x87\xba"",\n""\xe5\xbc\x84\xe8\x84\x8f"": ""\xe5\xbc\x84\xe9\xab\x92"",\n""\xe5\xbc\x94\xe5\x8d\xb7"": ""\xe5\xbc\x94\xe5\x8d\xb7"",\n""\xe5\xbc\x98\xe5\x8e\x86"": ""\xe5\xbc\x98\xe6\x9b\x86"",\n""\xe5\x88\xab\xe6\x89\xad"": ""\xe5\xbd\x86\xe6\x89\xad"",\n""\xe5\x88\xab\xe6\x8b\x97"": ""\xe5\xbd\x86\xe6\x8b\x97"",\n""\xe5\x88\xab\xe6\xb0\x94"": ""\xe5\xbd\x86\xe6\xb0\xa3"",\n""\xe5\x88\xab\xe8\x84\x9a"": ""\xe5\xbd\x86\xe8\x85\xb3"",\n""\xe5\x88\xab\xe7\x9d\x80"": ""\xe5\xbd\x86\xe8\x91\x97"",\n""\xe5\xbc\xb9\xe5\xad\x90\xe5\x8f\xb0"": ""\xe5\xbd\x88\xe5\xad\x90\xe6\xaa\xaf"",\n""\xe5\xbc\xb9\xe8\x8d\xaf"": ""\xe5\xbd\x88\xe8\x91\xaf"",\n""\xe6\xb1\x87\xe6\x8a\xa5"": ""\xe5\xbd\x99\xe5\xa0\xb1"",\n""\xe6\xb1\x87\xe6\x95\xb4"": ""\xe5\xbd\x99\xe6\x95\xb4"",\n""\xe6\xb1\x87\xe7\xbc\x96"": ""\xe5\xbd\x99\xe7\xb7\xa8"",\n""\xe6\xb1\x87\xe6\x80\xbb"": ""\xe5\xbd\x99\xe7\xb8\xbd"",\n""\xe6\xb1\x87\xe7\xba\x82"": ""\xe5\xbd\x99\xe7\xba\x82"",\n""\xe6\xb1\x87\xe8\xbe\x91"": ""\xe5\xbd\x99\xe8\xbc\xaf"",\n""\xe6\xb1\x87\xe9\x9b\x86"": ""\xe5\xbd\x99\xe9\x9b\x86"",\n""\xe5\xbd\xa2\xe5\x8d\x95\xe5\xbd\xb1\xe5\x8f\xaa"": ""\xe5\xbd\xa2\xe5\x96\xae\xe5\xbd\xb1\xe9\x9a\xbb"",\n""\xe5\xbd\xb1\xe5\x90\x8e"": ""\xe5\xbd\xb1\xe5\x90\x8e"",\n""\xe5\xbe\x80\xe9\x87\x8c"": ""\xe5\xbe\x80\xe8\xa3\xa1"",\n""\xe5\xbe\x80\xe5\xa4\x8d"": ""\xe5\xbe\x80\xe8\xa4\x87"",\n""\xe5\xbe\x81\xe4\xbc\x90"": ""\xe5\xbe\x81\xe4\xbc\x90"",\n""\xe5\xbe\x81\xe5\x85\xb5"": ""\xe5\xbe\x81\xe5\x85\xb5"",\n""\xe5\xbe\x81\xe5\xb0\x98"": ""\xe5\xbe\x81\xe5\xa1\xb5"",\n""\xe5\xbe\x81\xe5\xa4\xab"": ""\xe5\xbe\x81\xe5\xa4\xab"",\n""\xe5\xbe\x81\xe6\x88\x98"": ""\xe5\xbe\x81\xe6\x88\xb0"",\n""\xe5\xbe\x81\xe6\x94\xb6"": ""\xe5\xbe\x81\xe6\x94\xb6"",\n""\xe5\xbe\x81\xe6\x9c\x8d"": ""\xe5\xbe\x81\xe6\x9c\x8d"",\n""\xe5\xbe\x81\xe6\xb1\x82"": ""\xe5\xbe\x81\xe6\xb1\x82"",\n""\xe5\xbe\x81\xe5\x8f\x91"": ""\xe5\xbe\x81\xe7\x99\xbc"",\n""\xe5\xbe\x81\xe8\xa1\xa3"": ""\xe5\xbe\x81\xe8\xa1\xa3"",\n""\xe5\xbe\x81\xe8\xae\xa8"": ""\xe5\xbe\x81\xe8\xa8\x8e"",\n""\xe5\xbe\x81\xe9\x80\x94"": ""\xe5\xbe\x81\xe9\x80\x94"",\n""\xe5\x90\x8e\xe5\x8f\xb0"": ""\xe5\xbe\x8c\xe8\x87\xba"",\n""\xe4\xbb\x8e\xe9\x87\x8c\xe5\x88\xb0\xe5\xa4\x96"": ""\xe5\xbe\x9e\xe8\xa3\xa1\xe5\x88\xb0\xe5\xa4\x96"",\n""\xe4\xbb\x8e\xe9\x87\x8c\xe5\x90\x91\xe5\xa4\x96"": ""\xe5\xbe\x9e\xe8\xa3\xa1\xe5\x90\x91\xe5\xa4\x96"",\n""\xe5\xa4\x8d\xe9\x9b\xa0"": ""\xe5\xbe\xa9\xe8\xae\x8e"",\n""\xe5\xa4\x8d\xe8\xbe\x9f"": ""\xe5\xbe\xa9\xe8\xbe\x9f"",\n""\xe5\xbe\xb7\xe5\xb9\xb2\xe9\xab\x98\xe5\x8e\x9f"": ""\xe5\xbe\xb7\xe5\xb9\xb2\xe9\xab\x98\xe5\x8e\x9f"",\n""\xe5\xbf\x83\xe6\x84\xbf"": ""\xe5\xbf\x83\xe6\x84\xbf"",\n""\xe5\xbf\x83\xe8\x8d\xa1\xe7\xa5\x9e\xe9\xa9\xb0"": ""\xe5\xbf\x83\xe8\x95\xa9\xe7\xa5\x9e\xe9\xa6\xb3"",\n""\xe5\xbf\x83\xe9\x87\x8c"": ""\xe5\xbf\x83\xe8\xa3\xa1"",\n""\xe5\xbf\x99\xe9\x87\x8c"": ""\xe5\xbf\x99\xe8\xa3\xa1"",\n""\xe5\xbf\xab\xe5\xb9\xb2"": ""\xe5\xbf\xab\xe5\xb9\xb9"",\n""\xe5\xbf\xab\xe5\x86\xb2"": ""\xe5\xbf\xab\xe8\xa1\x9d"",\n""\xe6\x80\x8e\xe4\xb9\x88"": ""\xe6\x80\x8e\xe9\xba\xbc"",\n""\xe6\x80\x8e\xe4\xb9\x88\xe7\x9d\x80"": ""\xe6\x80\x8e\xe9\xba\xbc\xe8\x91\x97"",\n""\xe6\x80\x92\xe5\x8f\x91\xe5\x86\xb2\xe5\x86\xa0"": ""\xe6\x80\x92\xe9\xab\xae\xe8\xa1\x9d\xe5\x86\xa0"",\n""\xe6\x80\xa5\xe5\x86\xb2\xe8\x80\x8c\xe4\xb8\x8b"": ""\xe6\x80\xa5\xe8\xa1\x9d\xe8\x80\x8c\xe4\xb8\x8b"",\n""\xe6\x80\xaa\xe9\x87\x8c\xe6\x80\xaa\xe6\xb0\x94"": ""\xe6\x80\xaa\xe8\xa3\xa1\xe6\x80\xaa\xe6\xb0\xa3"",\n""\xe6\x81\xa9\xe5\x87\x86"": ""\xe6\x81\xa9\xe5\x87\x86"",\n""\xe6\x83\x85\xe6\x9c\x89\xe6\x89\x80\xe9\x92\x9f"": ""\xe6\x83\x85\xe6\x9c\x89\xe6\x89\x80\xe9\x8d\xbe"",\n""\xe6\x84\x8f\xe9\x9d\xa2"": ""\xe6\x84\x8f\xe9\xba\xb5"",\n""\xe6\x85\x8c\xe9\x87\x8c\xe6\x85\x8c\xe5\xbc\xa0"": ""\xe6\x85\x8c\xe8\xa3\xa1\xe6\x85\x8c\xe5\xbc\xb5"",\n""\xe6\x85\xb0\xe5\x80\x9f"": ""\xe6\x85\xb0\xe8\x97\x89"",\n""\xe5\xbf\xa7\xe9\x83\x81"": ""\xe6\x86\x82\xe9\x83\x81"",\n""\xe5\x87\xad\xe5\x90\x8a"": ""\xe6\x86\x91\xe5\x90\x8a"",\n""\xe5\x87\xad\xe5\x80\x9f"": ""\xe6\x86\x91\xe8\x97\x89"",\n""\xe5\x87\xad\xe5\x80\x9f\xe7\x9d\x80"": ""\xe6\x86\x91\xe8\x97\x89\xe8\x91\x97"",\n""\xe8\x92\x99\xe6\x87\x82"": ""\xe6\x87\x9e\xe6\x87\x82"",\n""\xe6\x80\x80\xe9\x87\x8c"": ""\xe6\x87\xb7\xe8\xa3\xa1"",\n""\xe6\x80\x80\xe8\xa1\xa8"": ""\xe6\x87\xb7\xe9\x8c\xb6"",\n""\xe6\x82\xac\xe5\x90\x8a"": ""\xe6\x87\xb8\xe5\x90\x8a"",\n""\xe6\x81\x8b\xe6\x81\x8b\xe4\xb8\x8d\xe8\x88\x8d"": ""\xe6\x88\x80\xe6\x88\x80\xe4\xb8\x8d\xe6\x8d\xa8"",\n""\xe6\x88\x8f\xe5\x8f\xb0"": ""\xe6\x88\xb2\xe8\x87\xba"",\n""\xe6\x88\xb4\xe8\xa1\xa8"": ""\xe6\x88\xb4\xe9\x8c\xb6"",\n""\xe6\x88\xbd\xe6\x96\x97"": ""\xe6\x88\xbd\xe6\x96\x97"",\n""\xe6\x88\xbf\xe9\x87\x8c"": ""\xe6\x88\xbf\xe8\xa3\xa1"",\n""\xe6\x89\x8b\xe4\xb8\x8d\xe9\x87\x8a\xe5\x8d\xb7"": ""\xe6\x89\x8b\xe4\xb8\x8d\xe9\x87\x8b\xe5\x8d\xb7"",\n""\xe6\x89\x8b\xe5\x8d\xb7"": ""\xe6\x89\x8b\xe5\x8d\xb7"",\n""\xe6\x89\x8b\xe6\x8a\x98"": ""\xe6\x89\x8b\xe6\x91\xba"",\n""\xe6\x89\x8b\xe9\x87\x8c"": ""\xe6\x89\x8b\xe8\xa3\xa1"",\n""\xe6\x89\x8b\xe8\xa1\xa8"": ""\xe6\x89\x8b\xe9\x8c\xb6"",\n""\xe6\x89\x8b\xe6\x9d\xbe"": ""\xe6\x89\x8b\xe9\xac\x86"",\n""\xe6\x89\x8d\xe5\xb9\xb2"": ""\xe6\x89\x8d\xe5\xb9\xb9"",\n""\xe6\x89\x8d\xe9\xab\x98\xe5\x85\xab\xe6\x96\x97"": ""\xe6\x89\x8d\xe9\xab\x98\xe5\x85\xab\xe6\x96\x97"",\n""\xe6\x89\x93\xe8\xb0\xb7"": ""\xe6\x89\x93\xe7\xa9\x80"",\n""\xe6\x89\x9e\xe5\xbe\xa1"": ""\xe6\x89\x9e\xe7\xa6\xa6"",\n""\xe6\x89\xb9\xe5\x87\x86"": ""\xe6\x89\xb9\xe5\x87\x86"",\n""\xe6\x89\xb9\xe5\xa4\x8d"": ""\xe6\x89\xb9\xe8\xa4\x87"",\n""\xe6\x89\xb9\xe5\xa4\x8d"": ""\xe6\x89\xb9\xe8\xa6\x86"",\n""\xe6\x89\xbf\xe5\x88\xb6"": ""\xe6\x89\xbf\xe8\xa3\xbd"",\n""\xe6\x8a\x97\xe5\xbe\xa1"": ""\xe6\x8a\x97\xe7\xa6\xa6"",\n""\xe6\x8a\x98\xe5\x86\xb2"": ""\xe6\x8a\x98\xe8\xa1\x9d"",\n""\xe6\x8a\xab\xe5\xa4\x8d"": ""\xe6\x8a\xab\xe8\xa6\x86"",\n""\xe6\x8a\xab\xe5\x8f\x91"": ""\xe6\x8a\xab\xe9\xab\xae"",\n""\xe6\x8a\xb1\xe6\x9c\xb4"": ""\xe6\x8a\xb1\xe6\x9c\xb4"",\n""\xe6\x8a\xb5\xe5\xbe\xa1"": ""\xe6\x8a\xb5\xe7\xa6\xa6"",\n""\xe6\x8b\x86\xe4\xbc\x99"": ""\xe6\x8b\x86\xe4\xbc\x99"",\n""\xe6\x8b\x86\xe5\x8f\xb0"": ""\xe6\x8b\x86\xe8\x87\xba"",\n""\xe6\x8b\x88\xe9\xa1\xbb"": ""\xe6\x8b\x88\xe9\xac\x9a"",\n""\xe6\x8b\x89\xe7\xba\xa4"": ""\xe6\x8b\x89\xe7\xb8\xb4"",\n""\xe6\x8b\x89\xe9\x9d\xa2"": ""\xe6\x8b\x89\xe9\xba\xb5"",\n""\xe6\x8b\x96\xe5\x90\x8a"": ""\xe6\x8b\x96\xe5\x90\x8a"",\n""\xe6\x8b\x97\xe5\x88\xab"": ""\xe6\x8b\x97\xe5\xbd\x86"",\n""\xe6\x8b\xae\xe6\x8d\xae"": ""\xe6\x8b\xae\xe6\x8d\xae"",\n""\xe6\x8c\xaf\xe8\x8d\xa1"": ""\xe6\x8c\xaf\xe8\x95\xa9"",\n""\xe6\x8d\x8d\xe5\xbe\xa1"": ""\xe6\x8d\x8d\xe7\xa6\xa6"",\n""\xe8\x88\x8d\xe4\xb8\x8d\xe5\xbe\x97"": ""\xe6\x8d\xa8\xe4\xb8\x8d\xe5\xbe\x97"",\n""\xe8\x88\x8d\xe5\x87\xba"": ""\xe6\x8d\xa8\xe5\x87\xba"",\n""\xe8\x88\x8d\xe5\x8e\xbb"": ""\xe6\x8d\xa8\xe5\x8e\xbb"",\n""\xe8\x88\x8d\xe5\x91\xbd"": ""\xe6\x8d\xa8\xe5\x91\xbd"",\n""\xe8\x88\x8d\xe5\xb7\xb1\xe4\xbb\x8e\xe4\xba\xba"": ""\xe6\x8d\xa8\xe5\xb7\xb1\xe5\xbe\x9e\xe4\xba\xba"",\n""\xe8\x88\x8d\xe5\xb7\xb1\xe6\x95\x91\xe4\xba\xba"": ""\xe6\x8d\xa8\xe5\xb7\xb1\xe6\x95\x91\xe4\xba\xba"",\n""\xe8\x88\x8d\xe5\xb7\xb1\xe4\xb8\xba\xe4\xba\xba"": ""\xe6\x8d\xa8\xe5\xb7\xb1\xe7\x82\xba\xe4\xba\xba"",\n""\xe8\x88\x8d\xe5\xb7\xb1\xe4\xb8\xba\xe5\x85\xac"": ""\xe6\x8d\xa8\xe5\xb7\xb1\xe7\x82\xba\xe5\x85\xac"",\n""\xe8\x88\x8d\xe5\xb7\xb1\xe4\xb8\xba\xe5\x9b\xbd"": ""\xe6\x8d\xa8\xe5\xb7\xb1\xe7\x82\xba\xe5\x9c\x8b"",\n""\xe8\x88\x8d\xe5\xbe\x97"": ""\xe6\x8d\xa8\xe5\xbe\x97"",\n""\xe8\x88\x8d\xe6\x88\x91\xe5\x85\xb6\xe8\xb0\x81"": ""\xe6\x8d\xa8\xe6\x88\x91\xe5\x85\xb6\xe8\xaa\xb0"",\n""\xe8\x88\x8d\xe6\x9c\xac\xe9\x80\x90\xe6\x9c\xab"": ""\xe6\x8d\xa8\xe6\x9c\xac\xe9\x80\x90\xe6\x9c\xab"",\n""\xe8\x88\x8d\xe5\xbc\x83"": ""\xe6\x8d\xa8\xe6\xa3\x84"",\n""\xe8\x88\x8d\xe6\xad\xbb\xe5\xbf\x98\xe7\x94\x9f"": ""\xe6\x8d\xa8\xe6\xad\xbb\xe5\xbf\x98\xe7\x94\x9f"",\n""\xe8\x88\x8d\xe7\x94\x9f"": ""\xe6\x8d\xa8\xe7\x94\x9f"",\n""\xe8\x88\x8d\xe7\x9f\xad\xe5\x8f\x96\xe9\x95\xbf"": ""\xe6\x8d\xa8\xe7\x9f\xad\xe5\x8f\x96\xe9\x95\xb7"",\n""\xe8\x88\x8d\xe8\xba\xab"": ""\xe6\x8d\xa8\xe8\xba\xab"",\n""\xe8\x88\x8d\xe8\xbd\xa6\xe4\xbf\x9d\xe5\xb8\x85"": ""\xe6\x8d\xa8\xe8\xbb\x8a\xe4\xbf\x9d\xe5\xb8\xa5"",\n""\xe8\x88\x8d\xe8\xbf\x91\xe6\xb1\x82\xe8\xbf\x9c"": ""\xe6\x8d\xa8\xe8\xbf\x91\xe6\xb1\x82\xe9\x81\xa0"",\n""\xe6\x8d\xb2\xe5\x8f\x91"": ""\xe6\x8d\xb2\xe9\xab\xae"",\n""\xe6\x8d\xb5\xe9\x9d\xa2"": ""\xe6\x8d\xb5\xe9\xba\xb5"",\n""\xe6\x89\xab\xe8\x8d\xa1"": ""\xe6\x8e\x83\xe8\x95\xa9"",\n""\xe6\x8e\x8c\xe6\x9f\x9c"": ""\xe6\x8e\x8c\xe6\x9f\x9c"",\n""\xe6\x8e\x92\xe9\xaa\xa8\xe9\x9d\xa2"": ""\xe6\x8e\x92\xe9\xaa\xa8\xe9\xba\xb5"",\n""\xe6\x8c\x82\xe5\xb8\x98"": ""\xe6\x8e\x9b\xe5\xb8\x98"",\n""\xe6\x8c\x82\xe9\x9d\xa2"": ""\xe6\x8e\x9b\xe9\xba\xb5"",\n""\xe6\x8e\xa5\xe7\x9d\x80\xe8\xaf\xb4"": ""\xe6\x8e\xa5\xe8\x91\x97\xe8\xaa\xaa"",\n""\xe6\x8f\x90\xe5\xbf\x83\xe5\x90\x8a\xe8\x83\x86"": ""\xe6\x8f\x90\xe5\xbf\x83\xe5\x90\x8a\xe8\x86\xbd"",\n""\xe6\x8f\x92\xe5\x9b\xbe\xe5\x8d\xb7"": ""\xe6\x8f\x92\xe5\x9c\x96\xe5\x8d\xb7"",\n""\xe6\x8d\xa2\xe5\x90\x8a"": ""\xe6\x8f\x9b\xe5\x90\x8a"",\n""\xe6\x8d\xa2\xe5\x8f\xaa"": ""\xe6\x8f\x9b\xe9\x9a\xbb"",\n""\xe6\x8d\xa2\xe5\x8f\x91"": ""\xe6\x8f\x9b\xe9\xab\xae"",\n""\xe6\x91\x87\xe8\x8d\xa1"": ""\xe6\x90\x96\xe8\x95\xa9"",\n""\xe6\x90\xad\xe4\xbc\x99"": ""\xe6\x90\xad\xe4\xbc\x99"",\n""\xe6\x8a\x98\xe5\x90\x88"": ""\xe6\x91\xba\xe5\x90\x88"",\n""\xe6\x8a\x98\xe5\xa5\x8f"": ""\xe6\x91\xba\xe5\xa5\x8f"",\n""\xe6\x8a\x98\xe5\xad\x90"": ""\xe6\x91\xba\xe5\xad\x90"",\n""\xe6\x8a\x98\xe5\xb0\xba"": ""\xe6\x91\xba\xe5\xb0\xba"",\n""\xe6\x8a\x98\xe6\x89\x87"": ""\xe6\x91\xba\xe6\x89\x87"",\n""\xe6\x8a\x98\xe6\xa2\xaf"": ""\xe6\x91\xba\xe6\xa2\xaf"",\n""\xe6\x8a\x98\xe6\xa4\x85"": ""\xe6\x91\xba\xe6\xa4\x85"",\n""\xe6\x8a\x98\xe5\x8f\xa0"": ""\xe6\x91\xba\xe7\x96\x8a"",\n""\xe6\x8a\x98\xe7\x97\x95"": ""\xe6\x91\xba\xe7\x97\x95"",\n""\xe6\x8a\x98\xe7\xaf\xb7"": ""\xe6\x91\xba\xe7\xaf\xb7"",\n""\xe6\x8a\x98\xe7\xba\xb8"": ""\xe6\x91\xba\xe7\xb4\x99"",\n""\xe6\x8a\x98\xe8\xa3\x99"": ""\xe6\x91\xba\xe8\xa3\x99"",\n""\xe6\x92\x92\xe5\xb8\x83"": ""\xe6\x92\x92\xe4\xbd\x88"",\n""\xe6\x92\x9a\xe9\xa1\xbb"": ""\xe6\x92\x9a\xe9\xac\x9a"",\n""\xe6\x92\x9e\xe7\x90\x83\xe5\x8f\xb0"": ""\xe6\x92\x9e\xe7\x90\x83\xe6\xaa\xaf"",\n""\xe6\x93\x82\xe5\x8f\xb0"": ""\xe6\x93\x82\xe8\x87\xba"",\n""\xe6\x8b\x85\xe4\xbb\x94\xe9\x9d\xa2"": ""\xe6\x93\x94\xe4\xbb\x94\xe9\xba\xb5"",\n""\xe6\x8b\x85\xe6\x8b\x85\xe9\x9d\xa2"": ""\xe6\x93\x94\xe6\x93\x94\xe9\xba\xb5"",\n""\xe6\x8b\x85\xe7\x9d\x80"": ""\xe6\x93\x94\xe8\x91\x97"",\n""\xe6\x8b\x85\xe8\xb4\x9f\xe7\x9d\x80"": ""\xe6\x93\x94\xe8\xb2\xa0\xe8\x91\x97"",\n""\xe6\x8d\xae\xe4\xba\x91"": ""\xe6\x93\x9a\xe4\xba\x91"",\n""\xe6\x93\xa2\xe5\x8f\x91\xe9\x9a\xbe\xe6\x95\xb0"": ""\xe6\x93\xa2\xe9\xab\xae\xe9\x9b\xa3\xe6\x95\xb8"",\n""\xe6\x91\x86\xe5\xb8\x83"": ""\xe6\x93\xba\xe4\xbd\x88"",\n""\xe6\x91\x84\xe5\x88\xb6"": ""\xe6\x94\x9d\xe8\xa3\xbd"",\n""\xe6\x94\xaf\xe5\xb9\xb2"": ""\xe6\x94\xaf\xe5\xb9\xb9"",\n""\xe6\x94\xb6\xe8\x8e\xb7"": ""\xe6\x94\xb6\xe7\xa9\xab"",\n""\xe6\x94\xb9\xe5\x88\xb6"": ""\xe6\x94\xb9\xe8\xa3\xbd"",\n""\xe6\x94\xbb\xe5\x85\x8b"": ""\xe6\x94\xbb\xe5\x89\x8b"",\n""\xe6\x94\xbe\xe8\x8d\xa1"": ""\xe6\x94\xbe\xe8\x95\xa9"",\n""\xe6\x94\xbe\xe6\x9d\xbe"": ""\xe6\x94\xbe\xe9\xac\x86"",\n""\xe5\x8f\x99\xe8\xaf\xb4\xe7\x9d\x80"": ""\xe6\x95\x98\xe8\xaa\xaa\xe8\x91\x97"",\n""\xe6\x95\xa3\xe4\xbc\x99"": ""\xe6\x95\xa3\xe4\xbc\x99"",\n""\xe6\x95\xa3\xe5\xb8\x83"": ""\xe6\x95\xa3\xe4\xbd\x88"",\n""\xe6\x95\xa3\xe8\x8d\xa1"": ""\xe6\x95\xa3\xe8\x95\xa9"",\n""\xe6\x95\xa3\xe5\x8f\x91"": ""\xe6\x95\xa3\xe9\xab\xae"",\n""\xe6\x95\xb4\xe5\x8f\xaa"": ""\xe6\x95\xb4\xe9\x9a\xbb"",\n""\xe6\x95\xb4\xe5\x87\xba"": ""\xe6\x95\xb4\xe9\xbd\xa3"",\n""\xe6\x96\x87\xe9\x87\x87"": ""\xe6\x96\x87\xe9\x87\x87"",\n""\xe6\x96\x97\xe5\x85\xad"": ""\xe6\x96\x97\xe5\x85\xad"",\n""\xe6\x96\x97\xe5\x8d\x97"": ""\xe6\x96\x97\xe5\x8d\x97"",\n""\xe6\x96\x97\xe5\xa4\xa7"": ""\xe6\x96\x97\xe5\xa4\xa7"",\n""\xe6\x96\x97\xe5\xad\x90"": ""\xe6\x96\x97\xe5\xad\x90"",\n""\xe6\x96\x97\xe5\xae\xa4"": ""\xe6\x96\x97\xe5\xae\xa4"",\n""\xe6\x96\x97\xe6\x96\xb9"": ""\xe6\x96\x97\xe6\x96\xb9"",\n""\xe6\x96\x97\xe6\xa0\xb1"": ""\xe6\x96\x97\xe6\xa0\xb1"",\n""\xe6\x96\x97\xe7\xac\xa0"": ""\xe6\x96\x97\xe7\xac\xa0"",\n""\xe6\x96\x97\xe7\xae\x95"": ""\xe6\x96\x97\xe7\xae\x95"",\n""\xe6\x96\x97\xe7\xaf\xb7"": ""\xe6\x96\x97\xe7\xaf\xb7"",\n""\xe6\x96\x97\xe8\x83\x86"": ""\xe6\x96\x97\xe8\x86\xbd"",\n""\xe6\x96\x97\xe8\xbd\xac\xe5\x8f\x82\xe6\xa8\xaa"": ""\xe6\x96\x97\xe8\xbd\x89\xe5\x8f\x83\xe6\xa9\xab"",\n""\xe6\x96\x97\xe9\x87\x8f"": ""\xe6\x96\x97\xe9\x87\x8f"",\n""\xe6\x96\x97\xe9\x97\xa8"": ""\xe6\x96\x97\xe9\x96\x80"",\n""\xe6\x96\x99\xe6\x96\x97"": ""\xe6\x96\x99\xe6\x96\x97"",\n""\xe6\x96\xaf\xe9\x87\x8c\xe5\x85\xb0\xe5\x8d\xa1"": ""\xe6\x96\xaf\xe8\xa3\xa1\xe8\x98\xad\xe5\x8d\xa1"",\n""\xe6\x96\xb0\xe5\x8e\x86"": ""\xe6\x96\xb0\xe6\x9b\x86"",\n""\xe6\x96\xad\xe5\xa4\xb4\xe5\x8f\xb0"": ""\xe6\x96\xb7\xe9\xa0\xad\xe8\x87\xba"",\n""\xe6\x96\xb9\xe6\x89\x8d"": ""\xe6\x96\xb9\xe7\xba\x94"",\n""\xe6\x96\xbd\xe8\x88\x8d"": ""\xe6\x96\xbd\xe6\x8d\xa8"",\n""\xe6\x97\x8b\xe7\xbb\x95\xe7\x9d\x80"": ""\xe6\x97\x8b\xe7\xb9\x9e\xe8\x91\x97"",\n""\xe6\x97\x8b\xe5\x9b\x9e"": ""\xe6\x97\x8b\xe8\xbf\xb4"",\n""\xe6\x97\x8f\xe9\x87\x8c"": ""\xe6\x97\x8f\xe8\xa3\xa1"",\n""\xe6\x97\xa5\xe5\x8e\x86"": ""\xe6\x97\xa5\xe6\x9b\x86"",\n""\xe6\x97\xa5\xe5\xbf\x97"": ""\xe6\x97\xa5\xe8\xaa\x8c"",\n""\xe6\x97\xa5\xe8\xbf\x9b\xe6\x96\x97\xe9\x87\x91"": ""\xe6\x97\xa5\xe9\x80\xb2\xe6\x96\x97\xe9\x87\x91"",\n""\xe6\x98\x8e\xe4\xba\x86"": ""\xe6\x98\x8e\xe7\x9e\xad"",\n""\xe6\x98\x8e\xe7\xaa\x97\xe5\x87\x80\xe5\x87\xa0"": ""\xe6\x98\x8e\xe7\xaa\x97\xe6\xb7\xa8\xe5\x87\xa0"",\n""\xe6\x98\x8e\xe9\x87\x8c"": ""\xe6\x98\x8e\xe8\xa3\xa1"",\n""\xe6\x98\x9f\xe6\x96\x97"": ""\xe6\x98\x9f\xe6\x96\x97"",\n""\xe6\x98\x9f\xe5\x8e\x86"": ""\xe6\x98\x9f\xe6\x9b\x86"",\n""\xe6\x98\x9f\xe7\xa7\xbb\xe6\x96\x97\xe6\x8d\xa2"": ""\xe6\x98\x9f\xe7\xa7\xbb\xe6\x96\x97\xe6\x8f\x9b"",\n""\xe6\x98\x9f\xe7\xa7\xbb\xe6\x96\x97\xe8\xbd\xac"": ""\xe6\x98\x9f\xe7\xa7\xbb\xe6\x96\x97\xe8\xbd\x89"",\n""\xe6\x98\x9f\xe7\xbd\x97\xe6\xa3\x8b\xe5\xb8\x83"": ""\xe6\x98\x9f\xe7\xbe\x85\xe6\xa3\x8b\xe4\xbd\x88"",\n""\xe6\x98\x9f\xe8\xbe\xb0\xe8\xa1\xa8"": ""\xe6\x98\x9f\xe8\xbe\xb0\xe9\x8c\xb6"",\n""\xe6\x98\xa5\xe5\x81\x87\xe9\x87\x8c"": ""\xe6\x98\xa5\xe5\x81\x87\xe8\xa3\xa1"",\n""\xe6\x98\xa5\xe5\xa4\xa9\xe9\x87\x8c"": ""\xe6\x98\xa5\xe5\xa4\xa9\xe8\xa3\xa1"",\n""\xe6\x99\x83\xe8\x8d\xa1"": ""\xe6\x99\x83\xe8\x95\xa9"",\n""\xe6\x99\xaf\xe8\x87\xb4"": ""\xe6\x99\xaf\xe7\xb7\xbb"",\n""\xe6\x9a\x97\xe5\x9c\xb0\xe9\x87\x8c"": ""\xe6\x9a\x97\xe5\x9c\xb0\xe8\xa3\xa1"",\n""\xe6\x9a\x97\xe6\xb2\x9f\xe9\x87\x8c"": ""\xe6\x9a\x97\xe6\xba\x9d\xe8\xa3\xa1"",\n""\xe6\x9a\x97\xe9\x87\x8c"": ""\xe6\x9a\x97\xe8\xa3\xa1"",\n""\xe5\x8e\x86\xe6\x95\xb0"": ""\xe6\x9b\x86\xe6\x95\xb8"",\n""\xe5\x8e\x86\xe4\xb9\xa6"": ""\xe6\x9b\x86\xe6\x9b\xb8"",\n""\xe5\x8e\x86\xe6\xb3\x95"": ""\xe6\x9b\x86\xe6\xb3\x95"",\n""\xe4\xb9\xa6\xe5\x8d\xb7"": ""\xe6\x9b\xb8\xe5\x8d\xb7"",\n""\xe4\xbc\x9a\xe5\xb9\xb2"": ""\xe6\x9c\x83\xe5\xb9\xb9"",\n""\xe4\xbc\x9a\xe9\x87\x8c"": ""\xe6\x9c\x83\xe8\xa3\xa1"",\n""\xe6\x9c\x88\xe5\x8e\x86"": ""\xe6\x9c\x88\xe6\x9b\x86"",\n""\xe6\x9c\x88\xe5\x8f\xb0"": ""\xe6\x9c\x88\xe8\x87\xba"",\n""\xe6\x9c\x89\xe5\x8f\xaa"": ""\xe6\x9c\x89\xe9\x9a\xbb"",\n""\xe6\x9c\xa8\xe5\x88\xb6"": ""\xe6\x9c\xa8\xe8\xa3\xbd"",\n""\xe6\x9c\xac\xe5\x8f\xb0"": ""\xe6\x9c\xac\xe8\x87\xba"",\n""\xe6\x9c\xb4\xe5\xad\x90"": ""\xe6\x9c\xb4\xe5\xad\x90"",\n""\xe6\x9c\xb4\xe5\xae\x9e"": ""\xe6\x9c\xb4\xe5\xaf\xa6"",\n""\xe6\x9c\xb4\xe7\xa1\x9d"": ""\xe6\x9c\xb4\xe7\xa1\x9d"",\n""\xe6\x9c\xb4\xe7\xb4\xa0"": ""\xe6\x9c\xb4\xe7\xb4\xa0"",\n""\xe6\x9c\xb4\xe8\xb5\x84\xe8\x8c\x85\xe6\x96\xaf"": ""\xe6\x9c\xb4\xe8\xb3\x87\xe8\x8c\x85\xe6\x96\xaf"",\n""\xe6\x9d\x91\xe9\x87\x8c"": ""\xe6\x9d\x91\xe8\xa3\xa1"",\n""\xe6\x9d\x9f\xe5\x8f\x91"": ""\xe6\x9d\x9f\xe9\xab\xae"",\n""\xe4\xb8\x9c\xe5\xb2\xb3"": ""\xe6\x9d\xb1\xe5\xb6\xbd"",\n""\xe4\xb8\x9c\xe5\xbe\x81"": ""\xe6\x9d\xb1\xe5\xbe\x81"",\n""\xe6\x9d\xbe\xe8\xb5\x9e\xe5\xb9\xb2\xe5\xb8\x83"": ""\xe6\x9d\xbe\xe8\xb4\x8a\xe5\xb9\xb2\xe5\xb8\x83"",\n""\xe6\x9d\xbf\xe7\x9d\x80\xe8\x84\xb8"": ""\xe6\x9d\xbf\xe8\x91\x97\xe8\x87\x89"",\n""\xe6\x9d\xbf\xe8\x8d\xa1"": ""\xe6\x9d\xbf\xe8\x95\xa9"",\n""\xe6\x9e\x95\xe5\x80\x9f"": ""\xe6\x9e\x95\xe8\x97\x89"",\n""\xe6\x9e\x97\xe5\xae\x8f\xe5\xb2\xb3"": ""\xe6\x9e\x97\xe5\xae\x8f\xe5\xb6\xbd"",\n""\xe6\x9e\x9d\xe5\xb9\xb2"": ""\xe6\x9e\x9d\xe5\xb9\xb9"",\n""\xe6\x9e\xaf\xe5\xb9\xb2"": ""\xe6\x9e\xaf\xe5\xb9\xb9"",\n""\xe6\x9f\x90\xe5\x8f\xaa"": ""\xe6\x9f\x90\xe9\x9a\xbb"",\n""\xe6\x9f\x93\xe5\x8f\x91"": ""\xe6\x9f\x93\xe9\xab\xae"",\n""\xe6\x9f\x9c\xe4\xb8\x8a"": ""\xe6\x9f\x9c\xe4\xb8\x8a"",\n""\xe6\x9f\x9c\xe5\x8f\xb0"": ""\xe6\x9f\x9c\xe5\x8f\xb0"",\n""\xe6\x9f\x9c\xe5\xad\x90"": ""\xe6\x9f\x9c\xe5\xad\x90"",\n""\xe6\x9f\xa5\xe5\x8d\xb7"": ""\xe6\x9f\xa5\xe5\x8d\xb7"",\n""\xe6\x9f\xa5\xe5\x8f\xb7\xe5\x8f\xb0"": ""\xe6\x9f\xa5\xe8\x99\x9f\xe8\x87\xba"",\n""\xe6\xa0\xa1\xe9\x9b\xa0\xe5\xad\xa6"": ""\xe6\xa0\xa1\xe8\xae\x8e\xe5\xad\xb8"",\n""\xe6\xa0\xb8\xe5\x87\x86"": ""\xe6\xa0\xb8\xe5\x87\x86"",\n""\xe6\xa0\xb8\xe5\xa4\x8d"": ""\xe6\xa0\xb8\xe8\xa6\x86"",\n""\xe6\xa0\xbc\xe9\x87\x8c"": ""\xe6\xa0\xbc\xe8\xa3\xa1"",\n""\xe6\xa1\x88\xe5\x8d\xb7"": ""\xe6\xa1\x88\xe5\x8d\xb7"",\n""\xe6\x9d\xa1\xe5\xb9\xb2"": ""\xe6\xa2\x9d\xe5\xb9\xb9"",\n""\xe6\xa3\x89\xe5\x8d\xb7"": ""\xe6\xa3\x89\xe5\x8d\xb7"",\n""\xe6\xa3\x89\xe5\x88\xb6"": ""\xe6\xa3\x89\xe8\xa3\xbd"",\n""\xe6\xa4\x8d\xe5\x8f\x91"": ""\xe6\xa4\x8d\xe9\xab\xae"",\n""\xe6\xa5\xbc\xe5\x8f\xb0"": ""\xe6\xa8\x93\xe8\x87\xba"",\n""\xe6\xa0\x87\xe5\xbf\x97\xe7\x9d\x80"": ""\xe6\xa8\x99\xe5\xbf\x97\xe8\x91\x97"",\n""\xe6\xa0\x87\xe8\x87\xb4"": ""\xe6\xa8\x99\xe7\xb7\xbb"",\n""\xe6\xa0\x87\xe5\xbf\x97"": ""\xe6\xa8\x99\xe8\xaa\x8c"",\n""\xe6\xa8\xa1\xe5\x88\xb6"": ""\xe6\xa8\xa1\xe8\xa3\xbd"",\n""\xe6\xa0\x91\xe5\xb9\xb2"": ""\xe6\xa8\xb9\xe5\xb9\xb9"",\n""\xe6\xa8\xaa\xe5\xbe\x81\xe6\x9a\xb4\xe6\x95\x9b"": ""\xe6\xa9\xab\xe5\xbe\x81\xe6\x9a\xb4\xe6\x96\x82"",\n""\xe6\xa8\xaa\xe5\x86\xb2"": ""\xe6\xa9\xab\xe8\xa1\x9d"",\n""\xe6\xa1\xa3\xe5\x8d\xb7"": ""\xe6\xaa\x94\xe5\x8d\xb7"",\n""\xe6\xa3\x80\xe5\xa4\x8d"": ""\xe6\xaa\xa2\xe8\xa6\x86"",\n""\xe5\x8f\xb0\xe5\xad\x90"": ""\xe6\xaa\xaf\xe5\xad\x90"",\n""\xe5\x8f\xb0\xe5\xb8\x83"": ""\xe6\xaa\xaf\xe5\xb8\x83"",\n""\xe5\x8f\xb0\xe7\x81\xaf"": ""\xe6\xaa\xaf\xe7\x87\x88"",\n""\xe5\x8f\xb0\xe7\x90\x83"": ""\xe6\xaa\xaf\xe7\x90\x83"",\n""\xe5\x8f\xb0\xe9\x9d\xa2"": ""\xe6\xaa\xaf\xe9\x9d\xa2"",\n""\xe6\x9f\x9c\xe5\x8f\xb0"": ""\xe6\xab\x83\xe6\xaa\xaf"",\n""\xe6\x9f\x9c\xe5\x8f\xb0"": ""\xe6\xab\x83\xe8\x87\xba"",\n""\xe6\xa0\x8f\xe5\xb9\xb2"": ""\xe6\xac\x84\xe5\xb9\xb2"",\n""\xe6\xac\xba\xe8\x92\x99"": ""\xe6\xac\xba\xe7\x9f\x87"",\n""\xe6\xad\x8c\xe5\x90\x8e"": ""\xe6\xad\x8c\xe5\x90\x8e"",\n""\xe6\xac\xa7\xe5\x87\xa0\xe9\x87\x8c\xe5\xbe\x97"": ""\xe6\xad\x90\xe5\xb9\xbe\xe8\xa3\xa1\xe5\xbe\x97"",\n""\xe6\xad\xa3\xe5\xbd\x93\xe7\x9d\x80"": ""\xe6\xad\xa3\xe7\x95\xb6\xe8\x91\x97"",\n""\xe6\xad\xa6\xe5\x90\x8e"": ""\xe6\xad\xa6\xe5\x90\x8e"",\n""\xe6\xad\xa6\xe6\x9d\xbe"": ""\xe6\xad\xa6\xe9\xac\x86"",\n""\xe5\xbd\x92\xe5\xb9\xb6"": ""\xe6\xad\xb8\xe4\xbd\xb5"",\n""\xe6\xad\xbb\xe9\x87\x8c\xe6\xb1\x82\xe7\x94\x9f"": ""\xe6\xad\xbb\xe8\xa3\xa1\xe6\xb1\x82\xe7\x94\x9f"",\n""\xe6\xad\xbb\xe9\x87\x8c\xe9\x80\x83\xe7\x94\x9f"": ""\xe6\xad\xbb\xe8\xa3\xa1\xe9\x80\x83\xe7\x94\x9f"",\n""\xe6\xae\x8b\xe5\x8d\xb7"": ""\xe6\xae\x98\xe5\x8d\xb7"",\n""\xe6\x9d\x80\xe8\x99\xab\xe8\x8d\xaf"": ""\xe6\xae\xba\xe8\x99\xab\xe8\x97\xa5"",\n""\xe5\xa3\xb3\xe9\x87\x8c"": ""\xe6\xae\xbc\xe8\xa3\xa1"",\n""\xe6\xaf\x8d\xe5\x90\x8e"": ""\xe6\xaf\x8d\xe5\x90\x8e"",\n""\xe6\xaf\x8f\xe5\x8f\xaa"": ""\xe6\xaf\x8f\xe9\x9a\xbb"",\n""\xe6\xaf\x94\xe5\xb9\xb2"": ""\xe6\xaf\x94\xe5\xb9\xb2"",\n""\xe6\xaf\x9b\xe5\x8d\xb7"": ""\xe6\xaf\x9b\xe5\x8d\xb7"",\n""\xe6\xaf\x9b\xe5\x8f\x91"": ""\xe6\xaf\x9b\xe9\xab\xae"",\n""\xe6\xaf\xab\xe5\x8f\x91"": ""\xe6\xaf\xab\xe9\xab\xae"",\n""\xe6\xb0\x94\xe5\x86\xb2\xe7\x89\x9b\xe6\x96\x97"": ""\xe6\xb0\xa3\xe6\xb2\x96\xe7\x89\x9b\xe6\x96\x97"",\n""\xe6\xb0\x94\xe8\xb1\xa1\xe5\x8f\xb0"": ""\xe6\xb0\xa3\xe8\xb1\xa1\xe8\x87\xba"",\n""\xe6\xb0\xaf\xe9\x9c\x89\xe7\xb4\xa0"": ""\xe6\xb0\xaf\xe9\xbb\xb4\xe7\xb4\xa0"",\n""\xe6\xb0\xb4\xe6\x96\x97"": ""\xe6\xb0\xb4\xe6\x96\x97"",\n""\xe6\xb0\xb4\xe9\x87\x8c"": ""\xe6\xb0\xb4\xe8\xa3\xa1"",\n""\xe6\xb0\xb4\xe8\xa1\xa8"": ""\xe6\xb0\xb4\xe9\x8c\xb6"",\n""\xe6\xb0\xb8\xe5\x8e\x86"": ""\xe6\xb0\xb8\xe6\x9b\x86"",\n""\xe6\xb1\xa1\xe8\x94\x91"": ""\xe6\xb1\x99\xe8\xa1\x8a"",\n""\xe6\xb1\xa0\xe9\x87\x8c"": ""\xe6\xb1\xa0\xe8\xa3\xa1"",\n""\xe6\xb1\xa1\xe8\x94\x91"": ""\xe6\xb1\xa1\xe8\xa1\x8a"",\n""\xe6\xb2\x88\xe7\x9d\x80"": ""\xe6\xb2\x88\xe8\x91\x97"",\n""\xe6\xb2\xa1\xe4\xba\x8b\xe5\xb9\xb2"": ""\xe6\xb2\x92\xe4\xba\x8b\xe5\xb9\xb9"",\n""\xe6\xb2\xa1\xe7\xb2\xbe\xe6\x89\x93\xe9\x87\x87"": ""\xe6\xb2\x92\xe7\xb2\xbe\xe6\x89\x93\xe9\x87\x87"",\n""\xe5\x86\xb2\xe7\x9d\x80"": ""\xe6\xb2\x96\xe8\x91\x97"",\n""\xe6\xb2\x99\xe9\x87\x8c\xe6\xb7\x98\xe9\x87\x91"": ""\xe6\xb2\x99\xe8\xa3\xa1\xe6\xb7\x98\xe9\x87\x91"",\n""\xe6\xb2\xb3\xe9\x87\x8c"": ""\xe6\xb2\xb3\xe8\xa3\xa1"",\n""\xe6\xb2\xb9\xe9\x9d\xa2"": ""\xe6\xb2\xb9\xe9\xba\xb5"",\n""\xe6\xb3\xa1\xe9\x9d\xa2"": ""\xe6\xb3\xa1\xe9\xba\xb5"",\n""\xe6\xb3\xb0\xe6\x96\x97"": ""\xe6\xb3\xb0\xe6\x96\x97"",\n""\xe6\xb4\x97\xe6\x89\x8b\xe4\xb8\x8d\xe5\xb9\xb2"": ""\xe6\xb4\x97\xe6\x89\x8b\xe4\xb8\x8d\xe5\xb9\xb9"",\n""\xe6\xb4\x97\xe5\x8f\x91\xe7\xb2\xbe"": ""\xe6\xb4\x97\xe9\xab\xae\xe7\xb2\xbe"",\n""\xe6\xb4\xbe\xe5\x9b\xa2\xe5\x8f\x82\xe5\x8a\xa0"": ""\xe6\xb4\xbe\xe5\x9c\x98\xe5\x8f\x83\xe5\x8a\xa0"",\n""\xe6\xb5\x81\xe8\x8d\xa1"": ""\xe6\xb5\x81\xe8\x95\xa9"",\n""\xe6\xb5\xa9\xe8\x8d\xa1"": ""\xe6\xb5\xa9\xe8\x95\xa9"",\n""\xe6\xb5\xaa\xe7\x90\xb4\xe8\xa1\xa8"": ""\xe6\xb5\xaa\xe7\x90\xb4\xe9\x8c\xb6"",\n""\xe6\xb5\xaa\xe8\x8d\xa1"": ""\xe6\xb5\xaa\xe8\x95\xa9"",\n""\xe6\xb5\xae\xe8\x8d\xa1"": ""\xe6\xb5\xae\xe8\x95\xa9"",\n""\xe6\xb5\xb7\xe9\x87\x8c"": ""\xe6\xb5\xb7\xe8\xa3\xa1"",\n""\xe6\xb6\x82\xe7\x9d\x80"": ""\xe6\xb6\x82\xe8\x91\x97"",\n""\xe6\xb6\xb2\xe6\x99\xb6\xe8\xa1\xa8"": ""\xe6\xb6\xb2\xe6\x99\xb6\xe9\x8c\xb6"",\n""\xe5\x87\x89\xe9\x9d\xa2"": ""\xe6\xb6\xbc\xe9\xba\xb5"",\n""\xe6\xb7\xa1\xe6\x9c\xb1"": ""\xe6\xb7\xa1\xe7\xa1\x83"",\n""\xe6\xb7\xab\xe8\x8d\xa1"": ""\xe6\xb7\xab\xe8\x95\xa9"",\n""\xe6\xb5\x8b\xe9\xaa\x8c\xe5\x8d\xb7"": ""\xe6\xb8\xac\xe9\xa9\x97\xe5\x8d\xb7"",\n""\xe6\xb8\xaf\xe5\x88\xb6"": ""\xe6\xb8\xaf\xe8\xa3\xbd"",\n""\xe6\xb8\xb8\xe8\x8d\xa1"": ""\xe6\xb8\xb8\xe8\x95\xa9"",\n""\xe5\x87\x91\xe5\x90\x88\xe7\x9d\x80"": ""\xe6\xb9\x8a\xe5\x90\x88\xe8\x91\x97"",\n""\xe6\xb9\x96\xe9\x87\x8c"": ""\xe6\xb9\x96\xe8\xa3\xa1"",\n""\xe6\xb1\xa4\xe5\x9b\xa2"": ""\xe6\xb9\xaf\xe7\xb3\xb0"",\n""\xe6\xb1\xa4\xe9\x9d\xa2"": ""\xe6\xb9\xaf\xe9\xba\xb5"",\n""\xe5\x8d\xa4\xe5\x88\xb6"": ""\xe6\xbb\xb7\xe8\xa3\xbd"",\n""\xe5\x8d\xa4\xe9\x9d\xa2"": ""\xe6\xbb\xb7\xe9\xba\xb5"",\n""\xe6\xbb\xa1\xe5\xb8\x83"": ""\xe6\xbb\xbf\xe4\xbd\x88"",\n""\xe6\xbc\x82\xe8\x8d\xa1"": ""\xe6\xbc\x82\xe8\x95\xa9"",\n""\xe6\xbc\x8f\xe6\x96\x97"": ""\xe6\xbc\x8f\xe6\x96\x97"",\n""\xe6\xbc\x94\xe5\xa5\x8f\xe5\x8f\xb0"": ""\xe6\xbc\x94\xe5\xa5\x8f\xe8\x87\xba"",\n""\xe6\xbd\xad\xe9\x87\x8c"": ""\xe6\xbd\xad\xe8\xa3\xa1"",\n""\xe6\xbf\x80\xe8\x8d\xa1"": ""\xe6\xbf\x80\xe8\x95\xa9"",\n""\xe6\xb5\x93\xe9\x83\x81"": ""\xe6\xbf\x83\xe9\x83\x81"",\n""\xe6\xb5\x93\xe5\x8f\x91"": ""\xe6\xbf\x83\xe9\xab\xae"",\n""\xe6\xb9\xbf\xe5\x9c\xb0\xe6\x9d\xbe"": ""\xe6\xbf\x95\xe5\x9c\xb0\xe9\xac\x86"",\n""\xe8\x92\x99\xe8\x92\x99"": ""\xe6\xbf\x9b\xe6\xbf\x9b"",\n""\xe8\x92\x99\xe9\x9b\xbe"": ""\xe6\xbf\x9b\xe9\x9c\xa7"",\n""\xe7\x80\x9b\xe5\x8f\xb0"": ""\xe7\x80\x9b\xe8\x87\xba"",\n""\xe5\xbc\xa5\xe6\xbc\xab"": ""\xe7\x80\xb0\xe6\xbc\xab"",\n""\xe5\xbc\xa5\xe6\xbc\xab\xe7\x9d\x80"": ""\xe7\x80\xb0\xe6\xbc\xab\xe8\x91\x97"",\n""\xe7\x81\xab\xe5\xb9\xb6"": ""\xe7\x81\xab\xe4\xbd\xb5"",\n""\xe7\x81\xb0\xe8\x92\x99"": ""\xe7\x81\xb0\xe6\xbf\x9b"",\n""\xe7\x82\x92\xe9\x9d\xa2"": ""\xe7\x82\x92\xe9\xba\xb5"",\n""\xe7\x82\xae\xe5\x88\xb6"": ""\xe7\x82\xae\xe8\xa3\xbd"",\n""\xe7\x82\xb8\xe8\x8d\xaf"": ""\xe7\x82\xb8\xe8\x91\xaf"",\n""\xe7\x82\xb8\xe9\x85\xb1\xe9\x9d\xa2"": ""\xe7\x82\xb8\xe9\x86\xac\xe9\xba\xb5"",\n""\xe4\xb8\xba\xe7\x9d\x80"": ""\xe7\x82\xba\xe8\x91\x97"",\n""\xe4\xb9\x8c\xe5\xb9\xb2\xe8\xbe\xbe"": ""\xe7\x83\x8f\xe5\xb9\xb2\xe9\x81\x94"",\n""\xe4\xb9\x8c\xe8\x8b\x8f\xe9\x87\x8c\xe6\xb1\x9f"": ""\xe7\x83\x8f\xe8\x98\x87\xe8\xa3\xa1\xe6\xb1\x9f"",\n""\xe4\xb9\x8c\xe5\x8f\x91"": ""\xe7\x83\x8f\xe9\xab\xae"",\n""\xe4\xb9\x8c\xe9\xbe\x99\xe9\x9d\xa2"": ""\xe7\x83\x8f\xe9\xbe\x8d\xe9\xba\xb5"",\n""\xe7\x83\x98\xe5\x88\xb6"": ""\xe7\x83\x98\xe8\xa3\xbd"",\n""\xe7\x83\xbd\xe7\x81\xab\xe5\x8f\xb0"": ""\xe7\x83\xbd\xe7\x81\xab\xe8\x87\xba"",\n""\xe6\x97\xa0\xe5\xb9\xb2"": ""\xe7\x84\xa1\xe5\xb9\xb2"",\n""\xe6\x97\xa0\xe7\xb2\xbe\xe6\x89\x93\xe9\x87\x87"": ""\xe7\x84\xa1\xe7\xb2\xbe\xe6\x89\x93\xe9\x87\x87"",\n""\xe7\x82\xbc\xe5\x88\xb6"": ""\xe7\x85\x89\xe8\xa3\xbd"",\n""\xe7\x83\x9f\xe5\x8d\xb7\xe5\x84\xbf"": ""\xe7\x85\x99\xe5\x8d\xb7\xe5\x85\x92"",\n""\xe7\x83\x9f\xe6\x96\x97"": ""\xe7\x85\x99\xe6\x96\x97"",\n""\xe7\x83\x9f\xe6\x96\x97\xe4\xb8\x9d"": ""\xe7\x85\x99\xe6\x96\x97\xe7\xb5\xb2"",\n""\xe7\x83\x9f\xe5\x8f\xb0"": ""\xe7\x85\x99\xe8\x87\xba"",\n""\xe7\x85\xa7\xe5\x87\x86"": ""\xe7\x85\xa7\xe5\x87\x86"",\n""\xe7\x86\xa8\xe6\x96\x97"": ""\xe7\x86\xa8\xe6\x96\x97"",\n""\xe7\x81\xaf\xe5\x8f\xb0"": ""\xe7\x87\x88\xe8\x87\xba"",\n""\xe7\x87\x8e\xe5\x8f\x91"": ""\xe7\x87\x8e\xe9\xab\xae"",\n""\xe7\x83\xab\xe5\x8f\x91"": ""\xe7\x87\x99\xe9\xab\xae"",\n""\xe7\x83\xab\xe9\x9d\xa2"": ""\xe7\x87\x99\xe9\xba\xb5"",\n""\xe7\x83\x9b\xe5\x8f\xb0"": ""\xe7\x87\xad\xe8\x87\xba"",\n""\xe7\x82\x89\xe5\x8f\xb0"": ""\xe7\x88\x90\xe8\x87\xba"",\n""\xe7\x88\xbd\xe8\x8d\xa1"": ""\xe7\x88\xbd\xe8\x95\xa9"",\n""\xe7\x89\x87\xe8\xa8\x80\xe5\x8f\xaa\xe8\xaf\xad"": ""\xe7\x89\x87\xe8\xa8\x80\xe9\x9a\xbb\xe8\xaa\x9e"",\n""\xe7\x89\x9b\xe8\x82\x89\xe9\x9d\xa2"": ""\xe7\x89\x9b\xe8\x82\x89\xe9\xba\xb5"",\n""\xe7\x89\x9b\xe5\x8f\xaa"": ""\xe7\x89\x9b\xe9\x9a\xbb"",\n""\xe7\x89\xb9\xe5\x87\x86"": ""\xe7\x89\xb9\xe5\x87\x86"",\n""\xe7\x89\xb9\xe5\xbe\x81"": ""\xe7\x89\xb9\xe5\xbe\x81"",\n""\xe7\x89\xb9\xe9\x87\x8c"": ""\xe7\x89\xb9\xe8\xa3\xa1"",\n""\xe7\x89\xb9\xe5\x88\xb6"": ""\xe7\x89\xb9\xe8\xa3\xbd"",\n""\xe7\x89\xb5\xe7\xb3\xbb"": ""\xe7\x89\xbd\xe7\xb9\xab"",\n""\xe7\x8b\xbc\xe5\x80\x9f"": ""\xe7\x8b\xbc\xe8\x97\x89"",\n""\xe7\x8c\x9b\xe5\x86\xb2"": ""\xe7\x8c\x9b\xe8\xa1\x9d"",\n""\xe5\xa5\x96\xe6\x9d\xaf"": ""\xe7\x8d\x8e\xe7\x9b\x83"",\n""\xe8\x8e\xb7\xe5\x87\x86"": ""\xe7\x8d\xb2\xe5\x87\x86"",\n""\xe7\x8e\x87\xe5\x9b\xa2\xe5\x8f\x82\xe5\x8a\xa0"": ""\xe7\x8e\x87\xe5\x9c\x98\xe5\x8f\x83\xe5\x8a\xa0"",\n""\xe7\x8e\x8b\xe4\xbe\xaf\xe5\x90\x8e"": ""\xe7\x8e\x8b\xe4\xbe\xaf\xe5\x90\x8e"",\n""\xe7\x8e\x8b\xe5\x90\x8e"": ""\xe7\x8e\x8b\xe5\x90\x8e"",\n""\xe7\x8f\xad\xe9\x87\x8c"": ""\xe7\x8f\xad\xe8\xa3\xa1"",\n""\xe7\x90\x86\xe5\x8f\x91"": ""\xe7\x90\x86\xe9\xab\xae"",\n""\xe7\x91\xb6\xe5\x8f\xb0"": ""\xe7\x91\xa4\xe8\x87\xba"",\n""\xe7\x94\x9a\xe4\xb9\x88"": ""\xe7\x94\x9a\xe9\xba\xbc"",\n""\xe7\x94\x9c\xe9\x9d\xa2\xe9\x85\xb1"": ""\xe7\x94\x9c\xe9\xba\xb5\xe9\x86\xac"",\n""\xe7\x94\x9f\xe5\x8a\x9b\xe9\x9d\xa2"": ""\xe7\x94\x9f\xe5\x8a\x9b\xe9\xba\xb5"",\n""\xe7\x94\x9f\xe9\x94\x88"": ""\xe7\x94\x9f\xe9\x8f\xbd"",\n""\xe7\x94\x9f\xe5\x8f\x91"": ""\xe7\x94\x9f\xe9\xab\xae"",\n""\xe7\x94\xb0\xe9\x87\x8c"": ""\xe7\x94\xb0\xe8\xa3\xa1"",\n""\xe7\x94\xb1\xe9\xa6\x80"": ""\xe7\x94\xb1\xe4\xbd\x99"",\n""\xe7\x94\xb7\xe4\xbd\xa3"": ""\xe7\x94\xb7\xe4\xbd\xa3"",\n""\xe7\x94\xb7\xe7\x94\xa8\xe8\xa1\xa8"": ""\xe7\x94\xb7\xe7\x94\xa8\xe9\x8c\xb6"",\n""\xe7\x95\x99\xe5\x8f\x91"": ""\xe7\x95\x99\xe9\xab\xae"",\n""\xe7\x95\x9a\xe6\x96\x97"": ""\xe7\x95\x9a\xe6\x96\x97"",\n""\xe5\xbd\x93\xe7\x9d\x80"": ""\xe7\x95\xb6\xe8\x91\x97"",\n""\xe7\x96\x8f\xe6\x9d\xbe"": ""\xe7\x96\x8f\xe9\xac\x86"",\n""\xe7\x96\xb2\xe5\x9b\xb0"": ""\xe7\x96\xb2\xe7\x9d\x8f"",\n""\xe7\x97\x85\xe7\x97\x87"": ""\xe7\x97\x85\xe7\x99\xa5"",\n""\xe7\x97\x87\xe5\x80\x99"": ""\xe7\x99\xa5\xe5\x80\x99"",\n""\xe7\x97\x87\xe7\x8a\xb6"": ""\xe7\x99\xa5\xe7\x8b\x80"",\n""\xe7\x97\x87\xe7\xbb\x93"": ""\xe7\x99\xa5\xe7\xb5\x90"",\n""\xe7\x99\xbb\xe5\x8f\xb0"": ""\xe7\x99\xbb\xe8\x87\xba"",\n""\xe5\x8f\x91\xe5\xb8\x83"": ""\xe7\x99\xbc\xe4\xbd\x88"",\n""\xe5\x8f\x91\xe7\x9d\x80"": ""\xe7\x99\xbc\xe8\x91\x97"",\n""\xe5\x8f\x91\xe9\x9d\xa2"": ""\xe7\x99\xbc\xe9\xba\xb5"",\n""\xe5\x8f\x91\xe9\x9c\x89"": ""\xe7\x99\xbc\xe9\xbb\xb4"",\n""\xe7\x99\xbd\xe5\x8d\xb7"": ""\xe7\x99\xbd\xe5\x8d\xb7"",\n""\xe7\x99\xbd\xe5\xb9\xb2\xe5\x84\xbf"": ""\xe7\x99\xbd\xe5\xb9\xb2\xe5\x85\x92"",\n""\xe7\x99\xbd\xe5\x8f\x91"": ""\xe7\x99\xbd\xe9\xab\xae"",\n""\xe7\x99\xbd\xe9\x9d\xa2"": ""\xe7\x99\xbd\xe9\xba\xb5"",\n""\xe7\x99\xbe\xe9\x87\x8c"": ""\xe7\x99\xbe\xe8\xa3\xa1"",\n""\xe7\x99\xbe\xe5\x8f\xaa"": ""\xe7\x99\xbe\xe9\x9a\xbb"",\n""\xe7\x9a\x87\xe5\x90\x8e"": ""\xe7\x9a\x87\xe5\x90\x8e"",\n""\xe7\x9a\x87\xe5\x8e\x86"": ""\xe7\x9a\x87\xe6\x9b\x86"",\n""\xe7\x9a\x93\xe5\x8f\x91"": ""\xe7\x9a\x93\xe9\xab\xae"",\n""\xe7\x9a\xae\xe9\x87\x8c\xe9\x98\xb3\xe7\xa7\x8b"": ""\xe7\x9a\xae\xe8\xa3\x8f\xe9\x99\xbd\xe7\xa7\x8b"",\n""\xe7\x9a\xae\xe9\x87\x8c\xe6\x98\xa5\xe7\xa7\x8b"": ""\xe7\x9a\xae\xe8\xa3\xa1\xe6\x98\xa5\xe7\xa7\x8b"",\n""\xe7\x9a\xae\xe5\x88\xb6"": ""\xe7\x9a\xae\xe8\xa3\xbd"",\n""\xe7\x9a\xb1\xe6\x8a\x98"": ""\xe7\x9a\xba\xe6\x91\xba"",\n""\xe7\x9b\x92\xe9\x87\x8c"": ""\xe7\x9b\x92\xe8\xa3\xa1"",\n""\xe7\x9b\x91\xe5\x88\xb6"": ""\xe7\x9b\xa3\xe8\xa3\xbd"",\n""\xe7\x9b\x98\xe9\x87\x8c"": ""\xe7\x9b\xa4\xe8\xa3\xa1"",\n""\xe7\x9b\x98\xe5\x9b\x9e"": ""\xe7\x9b\xa4\xe8\xbf\xb4"",\n""\xe7\x9b\xb4\xe6\x8e\xa5\xe5\x8f\x82\xe4\xb8\x8e"": ""\xe7\x9b\xb4\xe6\x8e\xa5\xe5\x8f\x83\xe4\xb8\x8e"",\n""\xe7\x9b\xb4\xe5\x86\xb2"": ""\xe7\x9b\xb4\xe8\xa1\x9d"",\n""\xe7\x9b\xb8\xe5\x85\x8b"": ""\xe7\x9b\xb8\xe5\x89\x8b"",\n""\xe7\x9b\xb8\xe5\xb9\xb2"": ""\xe7\x9b\xb8\xe5\xb9\xb2"",\n""\xe7\x9b\xb8\xe5\x86\xb2"": ""\xe7\x9b\xb8\xe8\xa1\x9d"",\n""\xe7\x9c\x8b\xe5\x8f\xb0"": ""\xe7\x9c\x8b\xe8\x87\xba"",\n""\xe7\x9c\xbc\xe5\xb8\x98"": ""\xe7\x9c\xbc\xe5\xb8\x98"",\n""\xe7\x9c\xbc\xe7\x9c\xb6\xe9\x87\x8c"": ""\xe7\x9c\xbc\xe7\x9c\xb6\xe8\xa3\xa1"",\n""\xe7\x9c\xbc\xe9\x87\x8c"": ""\xe7\x9c\xbc\xe8\xa3\xa1"",\n""\xe5\x9b\xb0\xe4\xb9\x8f"": ""\xe7\x9d\x8f\xe4\xb9\x8f"",\n""\xe7\x9d\xa1\xe7\x9d\x80\xe4\xba\x86"": ""\xe7\x9d\xa1\xe8\x91\x97\xe4\xba\x86"",\n""\xe4\xba\x86\xe5\xa6\x82"": ""\xe7\x9e\xad\xe5\xa6\x82"",\n""\xe4\xba\x86\xe6\x9c\x9b"": ""\xe7\x9e\xad\xe6\x9c\x9b"",\n""\xe4\xba\x86\xe7\x84\xb6"": ""\xe7\x9e\xad\xe7\x84\xb6"",\n""\xe4\xba\x86\xe8\x8b\xa5\xe6\x8c\x87\xe6\x8e\x8c"": ""\xe7\x9e\xad\xe8\x8b\xa5\xe6\x8c\x87\xe6\x8e\x8c"",\n""\xe4\xba\x86\xe8\xa7\xa3"": ""\xe7\x9e\xad\xe8\xa7\xa3"",\n""\xe8\x92\x99\xe4\xbd\x8f"": ""\xe7\x9f\x87\xe4\xbd\x8f"",\n""\xe8\x92\x99\xe6\x98\xa7\xe6\x97\xa0\xe7\x9f\xa5"": ""\xe7\x9f\x87\xe6\x98\xa7\xe7\x84\xa1\xe7\x9f\xa5"",\n""\xe8\x92\x99\xe6\xb7\xb7"": ""\xe7\x9f\x87\xe6\xb7\xb7"",\n""\xe8\x92\x99\xe8\x92\x99"": ""\xe7\x9f\x87\xe7\x9f\x87"",\n""\xe8\x92\x99\xe7\x9c\xac"": ""\xe7\x9f\x87\xe7\x9f\x93"",\n""\xe8\x92\x99\xe8\x94\xbd"": ""\xe7\x9f\x87\xe8\x94\xbd"",\n""\xe8\x92\x99\xe9\xaa\x97"": ""\xe7\x9f\x87\xe9\xa8\x99"",\n""\xe7\x9f\xad\xe5\x8f\x91"": ""\xe7\x9f\xad\xe9\xab\xae"",\n""\xe7\x9f\xb3\xe8\x8b\xb1\xe8\xa1\xa8"": ""\xe7\x9f\xb3\xe8\x8b\xb1\xe9\x8c\xb6"",\n""\xe7\xa0\x94\xe5\x88\xb6"": ""\xe7\xa0\x94\xe8\xa3\xbd"",\n""\xe7\xa0\xb0\xe5\xbd\x93"": ""\xe7\xa0\xb0\xe5\x99\xb9"",\n""\xe7\xa0\xb2\xe5\x8f\xb0"": ""\xe7\xa0\xb2\xe8\x87\xba"",\n""\xe6\x9c\xb1\xe5\x94\x87\xe7\x9a\x93\xe9\xbd\xbf"": ""\xe7\xa1\x83\xe5\x94\x87\xe7\x9a\x93\xe9\xbd\x92"",\n""\xe6\x9c\xb1\xe6\x89\xb9"": ""\xe7\xa1\x83\xe6\x89\xb9"",\n""\xe6\x9c\xb1\xe7\xa0\x82"": ""\xe7\xa1\x83\xe7\xa0\x82"",\n""\xe6\x9c\xb1\xe7\xac\x94"": ""\xe7\xa1\x83\xe7\xad\x86"",\n""\xe6\x9c\xb1\xe7\xba\xa2\xe8\x89\xb2"": ""\xe7\xa1\x83\xe7\xb4\x85\xe8\x89\xb2"",\n""\xe6\x9c\xb1\xe8\x89\xb2"": ""\xe7\xa1\x83\xe8\x89\xb2"",\n""\xe7\xa1\xac\xe5\xb9\xb2"": ""\xe7\xa1\xac\xe5\xb9\xb9"",\n""\xe7\xa0\x9a\xe5\x8f\xb0"": ""\xe7\xa1\xaf\xe8\x87\xba"",\n""\xe7\xa2\x91\xe5\xbf\x97"": ""\xe7\xa2\x91\xe8\xaa\x8c"",\n""\xe7\xa3\x81\xe5\x88\xb6"": ""\xe7\xa3\x81\xe8\xa3\xbd"",\n""\xe7\xa3\xa8\xe5\x88\xb6"": ""\xe7\xa3\xa8\xe8\xa3\xbd"",\n""\xe7\xa4\xba\xe5\xa4\x8d"": ""\xe7\xa4\xba\xe8\xa6\x86"",\n""\xe7\xa4\xbe\xe9\x87\x8c"": ""\xe7\xa4\xbe\xe8\xa3\xa1"",\n""\xe7\xa5\x9e\xe9\x87\x87"": ""\xe7\xa5\x9e\xe9\x87\x87"",\n""\xe5\xbe\xa1\xe4\xbe\xae"": ""\xe7\xa6\xa6\xe4\xbe\xae"",\n""\xe5\xbe\xa1\xe5\xaf\x87"": ""\xe7\xa6\xa6\xe5\xaf\x87"",\n""\xe5\xbe\xa1\xe5\xaf\x92"": ""\xe7\xa6\xa6\xe5\xaf\x92"",\n""\xe5\xbe\xa1\xe6\x95\x8c"": ""\xe7\xa6\xa6\xe6\x95\xb5"",\n""\xe7\xa7\x83\xe5\x8f\x91"": ""\xe7\xa6\xbf\xe9\xab\xae"",\n""\xe7\xa7\x80\xe5\x8f\x91"": ""\xe7\xa7\x80\xe9\xab\xae"",\n""\xe7\xa7\x81\xe4\xb8\x8b\xe9\x87\x8c"": ""\xe7\xa7\x81\xe4\xb8\x8b\xe8\xa3\xa1"",\n""\xe7\xa7\x8b\xe5\xa4\xa9\xe9\x87\x8c"": ""\xe7\xa7\x8b\xe5\xa4\xa9\xe8\xa3\xa1"",\n""\xe7\xa7\x8b\xe8\xa3\xa4"": ""\xe7\xa7\x8b\xe8\xa4\xb2"",\n""\xe7\xa7\x92\xe8\xa1\xa8"": ""\xe7\xa7\x92\xe9\x8c\xb6"",\n""\xe7\xa8\x80\xe6\x9d\xbe"": ""\xe7\xa8\x80\xe9\xac\x86"",\n""\xe7\xa6\x80\xe5\xa4\x8d"": ""\xe7\xa8\x9f\xe8\xa6\x86"",\n""\xe7\xa8\xbb\xe8\xb0\xb7"": ""\xe7\xa8\xbb\xe7\xa9\x80"",\n""\xe7\xa8\xbd\xe5\xbe\x81"": ""\xe7\xa8\xbd\xe5\xbe\x81"",\n""\xe8\xb0\xb7\xe4\xbb\x93"": ""\xe7\xa9\x80\xe5\x80\x89"",\n""\xe8\xb0\xb7\xe5\x9c\xba"": ""\xe7\xa9\x80\xe5\xa0\xb4"",\n""\xe8\xb0\xb7\xe5\xad\x90"": ""\xe7\xa9\x80\xe5\xad\x90"",\n""\xe8\xb0\xb7\xe5\xa3\xb3"": ""\xe7\xa9\x80\xe6\xae\xbc"",\n""\xe8\xb0\xb7\xe7\x89\xa9"": ""\xe7\xa9\x80\xe7\x89\xa9"",\n""\xe8\xb0\xb7\xe7\x9a\xae"": ""\xe7\xa9\x80\xe7\x9a\xae"",\n""\xe8\xb0\xb7\xe7\xa5\x9e"": ""\xe7\xa9\x80\xe7\xa5\x9e"",\n""\xe8\xb0\xb7\xe7\xb2\x92"": ""\xe7\xa9\x80\xe7\xb2\x92"",\n""\xe8\xb0\xb7\xe8\x88\xb1"": ""\xe7\xa9\x80\xe8\x89\x99"",\n""\xe8\xb0\xb7\xe8\x8b\x97"": ""\xe7\xa9\x80\xe8\x8b\x97"",\n""\xe8\xb0\xb7\xe8\x8d\x89"": ""\xe7\xa9\x80\xe8\x8d\x89"",\n""\xe8\xb0\xb7\xe8\xb4\xb1\xe4\xbc\xa4\xe5\x86\x9c"": ""\xe7\xa9\x80\xe8\xb3\xa4\xe5\x82\xb7\xe8\xbe\xb2"",\n""\xe8\xb0\xb7\xe9\x81\x93"": ""\xe7\xa9\x80\xe9\x81\x93"",\n""\xe8\xb0\xb7\xe9\x9b\xa8"": ""\xe7\xa9\x80\xe9\x9b\xa8"",\n""\xe8\xb0\xb7\xe7\xb1\xbb"": ""\xe7\xa9\x80\xe9\xa1\x9e"",\n""\xe7\xa7\xaf\xe6\x9e\x81\xe5\x8f\x82\xe4\xb8\x8e"": ""\xe7\xa9\x8d\xe6\x9e\x81\xe5\x8f\x83\xe4\xb8\x8e"",\n""\xe7\xa7\xaf\xe6\x9e\x81\xe5\x8f\x82\xe5\x8a\xa0"": ""\xe7\xa9\x8d\xe6\x9e\x81\xe5\x8f\x83\xe5\x8a\xa0"",\n""\xe7\xa9\xba\xe8\x8d\xa1"": ""\xe7\xa9\xba\xe8\x95\xa9"",\n""\xe7\xaa\x97\xe5\xb8\x98"": ""\xe7\xaa\x97\xe5\xb8\x98"",\n""\xe7\xaa\x97\xe6\x98\x8e\xe5\x87\xa0\xe5\x87\x80"": ""\xe7\xaa\x97\xe6\x98\x8e\xe5\x87\xa0\xe6\xb7\xa8"",\n""\xe7\xaa\x97\xe5\x8f\xb0"": ""\xe7\xaa\x97\xe6\xaa\xaf"",\n""\xe7\xaa\x97\xe5\x8f\xb0"": ""\xe7\xaa\x97\xe8\x87\xba"",\n""\xe7\xaa\x9d\xe9\x87\x8c"": ""\xe7\xaa\xa9\xe8\xa3\xa1"",\n""\xe7\xaa\x9d\xe9\x98\x94\xe5\x8f\xb0"": ""\xe7\xaa\xa9\xe9\x97\x8a\xe8\x87\xba"",\n""\xe7\xa9\xb7\xe8\xbf\xbd\xe4\xb8\x8d\xe8\x88\x8d"": ""\xe7\xaa\xae\xe8\xbf\xbd\xe4\xb8\x8d\xe6\x8d\xa8"",\n""\xe7\xac\x86\xe6\x96\x97"": ""\xe7\xac\x86\xe6\x96\x97"",\n""\xe7\xac\x91\xe9\x87\x8c\xe8\x97\x8f\xe5\x88\x80"": ""\xe7\xac\x91\xe8\xa3\xa1\xe8\x97\x8f\xe5\x88\x80"",\n""\xe7\xac\xac\xe4\xb8\x80\xe5\x8d\xb7"": ""\xe7\xac\xac\xe4\xb8\x80\xe5\x8d\xb7"",\n""\xe7\xad\x8b\xe6\x96\x97"": ""\xe7\xad\x8b\xe6\x96\x97"",\n""\xe7\xad\x94\xe5\x8d\xb7"": ""\xe7\xad\x94\xe5\x8d\xb7"",\n""\xe7\xad\x94\xe5\xa4\x8d"": ""\xe7\xad\x94\xe8\xa4\x87"",\n""\xe7\xad\x94\xe5\xa4\x8d"": ""\xe7\xad\x94\xe8\xa6\x86"",\n""\xe7\xad\xb5\xe5\x87\xa0"": ""\xe7\xad\xb5\xe5\x87\xa0"",\n""\xe7\xae\x95\xe6\x96\x97"": ""\xe7\xae\x95\xe6\x96\x97"",\n""\xe7\xad\xbe\xe7\x9d\x80"": ""\xe7\xb0\xbd\xe8\x91\x97"",\n""\xe5\x90\x81\xe6\xb1\x82"": ""\xe7\xb1\xb2\xe6\xb1\x82"",\n""\xe5\x90\x81\xe8\xaf\xb7"": ""\xe7\xb1\xb2\xe8\xab\x8b"",\n""\xe7\xb2\x97\xe5\x88\xb6"": ""\xe7\xb2\x97\xe8\xa3\xbd"",\n""\xe7\xb2\x97\xe5\x8d\xa4"": ""\xe7\xb2\x97\xe9\xb9\xb5"",\n""\xe7\xb2\xbe\xe5\xb9\xb2"": ""\xe7\xb2\xbe\xe5\xb9\xb9"",\n""\xe7\xb2\xbe\xe6\x98\x8e\xe5\xbc\xba\xe5\xb9\xb2"": ""\xe7\xb2\xbe\xe6\x98\x8e\xe5\xbc\xb7\xe5\xb9\xb9"",\n""\xe7\xb2\xbe\xe8\x87\xb4"": ""\xe7\xb2\xbe\xe7\xb7\xbb"",\n""\xe7\xb2\xbe\xe5\x88\xb6"": ""\xe7\xb2\xbe\xe8\xa3\xbd"",\n""\xe7\xb2\xbe\xe8\xbe\x9f"": ""\xe7\xb2\xbe\xe8\xbe\x9f"",\n""\xe7\xb2\xbe\xe9\x87\x87"": ""\xe7\xb2\xbe\xe9\x87\x87"",\n""\xe7\xb3\x8a\xe9\x87\x8c\xe7\xb3\x8a\xe6\xb6\x82"": ""\xe7\xb3\x8a\xe8\xa3\xa1\xe7\xb3\x8a\xe5\xa1\x97"",\n""\xe5\x9b\xa2\xe5\xad\x90"": ""\xe7\xb3\xb0\xe5\xad\x90"",\n""\xe7\xb3\xbb\xe7\x9d\x80"": ""\xe7\xb3\xbb\xe8\x91\x97"",\n""\xe7\xba\xaa\xe5\x8e\x86"": ""\xe7\xb4\x80\xe6\x9b\x86"",\n""\xe7\xba\xa2\xe5\x8f\x91"": ""\xe7\xb4\x85\xe9\xab\xae"",\n""\xe7\xba\xa2\xe9\x9c\x89\xe7\xb4\xa0"": ""\xe7\xb4\x85\xe9\xbb\xb4\xe7\xb4\xa0"",\n""\xe7\xba\xa1\xe5\x9b\x9e"": ""\xe7\xb4\x86\xe8\xbf\xb4"",\n""\xe7\xba\xb3\xe9\x87\x87"": ""\xe7\xb4\x8d\xe9\x87\x87"",\n""\xe7\xb4\xa0\xe9\xa3\x9f\xe9\x9d\xa2"": ""\xe7\xb4\xa0\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe7\xb4\xa0\xe9\x9d\xa2"": ""\xe7\xb4\xa0\xe9\xba\xb5"",\n""\xe7\xb4\xab\xe5\xbe\xae\xe6\x96\x97\xe6\x95\xb0"": ""\xe7\xb4\xab\xe5\xbe\xae\xe6\x96\x97\xe6\x95\xb8"",\n""\xe7\xbb\x86\xe8\x87\xb4"": ""\xe7\xb4\xb0\xe7\xb7\xbb"",\n""\xe7\xbb\x84\xe9\x87\x8c"": ""\xe7\xb5\x84\xe8\xa3\xa1"",\n""\xe7\xbb\x93\xe5\x8f\x91"": ""\xe7\xb5\x90\xe9\xab\xae"",\n""\xe7\xbb\x9d\xe5\xaf\xb9\xe5\x8f\x82\xe7\x85\xa7"": ""\xe7\xb5\x95\xe5\xb0\x8d\xe5\x8f\x83\xe7\x85\xa7"",\n""\xe4\xb8\x9d\xe6\x9d\xa5\xe7\xba\xbf\xe5\x8e\xbb"": ""\xe7\xb5\xb2\xe4\xbe\x86\xe7\xb7\x9a\xe5\x8e\xbb"",\n""\xe4\xb8\x9d\xe5\xb8\x83"": ""\xe7\xb5\xb2\xe5\xb8\x83"",\n""\xe4\xb8\x9d\xe6\x9d\xbf"": ""\xe7\xb5\xb2\xe6\x9d\xbf"",\n""\xe4\xb8\x9d\xe7\x93\x9c\xe5\xb8\x83"": ""\xe7\xb5\xb2\xe7\x93\x9c\xe5\xb8\x83"",\n""\xe4\xb8\x9d\xe7\xbb\x92\xe5\xb8\x83"": ""\xe7\xb5\xb2\xe7\xb5\xa8\xe5\xb8\x83"",\n""\xe4\xb8\x9d\xe7\xba\xbf"": ""\xe7\xb5\xb2\xe7\xb7\x9a"",\n""\xe4\xb8\x9d\xe7\xbb\x87\xe5\x8e\x82"": ""\xe7\xb5\xb2\xe7\xb9\x94\xe5\xbb\xa0"",\n""\xe4\xb8\x9d\xe8\x99\xab"": ""\xe7\xb5\xb2\xe8\x9f\xb2"",\n""\xe7\xb6\x91\xe5\x90\x8a"": ""\xe7\xb6\x91\xe5\x90\x8a"",\n""\xe7\xbb\x8f\xe5\x8d\xb7"": ""\xe7\xb6\x93\xe5\x8d\xb7"",\n""\xe7\xbb\xbf\xe9\x9c\x89\xe7\xb4\xa0"": ""\xe7\xb6\xa0\xe9\xbb\xb4\xe7\xb4\xa0"",\n""\xe7\xbb\xb4\xe7\xb3\xbb"": ""\xe7\xb6\xad\xe7\xb9\xab"",\n""\xe7\xbb\xbe\xe5\x8f\x91"": ""\xe7\xb6\xb0\xe9\xab\xae"",\n""\xe7\xbd\x91\xe9\x87\x8c"": ""\xe7\xb6\xb2\xe8\xa3\xa1"",\n""\xe7\xb4\xa7\xe7\xbb\xb7"": ""\xe7\xb7\x8a\xe7\xb9\x83"",\n""\xe7\xb4\xa7\xe7\xbb\xb7\xe7\x9d\x80"": ""\xe7\xb7\x8a\xe7\xb9\x83\xe8\x91\x97"",\n""\xe7\xb4\xa7\xe8\xbf\xbd\xe4\xb8\x8d\xe8\x88\x8d"": ""\xe7\xb7\x8a\xe8\xbf\xbd\xe4\xb8\x8d\xe6\x8d\xa8"",\n""\xe7\xbc\x96\xe5\x88\xb6"": ""\xe7\xb7\xa8\xe8\xa3\xbd"",\n""\xe7\xbc\x96\xe5\x8f\x91"": ""\xe7\xb7\xa8\xe9\xab\xae"",\n""\xe7\xbc\x93\xe5\x86\xb2"": ""\xe7\xb7\xa9\xe8\xa1\x9d"",\n""\xe8\x87\xb4\xe5\xaf\x86"": ""\xe7\xb7\xbb\xe5\xaf\x86"",\n""\xe8\x90\xa6\xe5\x9b\x9e"": ""\xe7\xb8\x88\xe8\xbf\xb4"",\n""\xe5\x8e\xbf\xe9\x87\x8c"": ""\xe7\xb8\xa3\xe8\xa3\xa1"",\n""\xe5\x8e\xbf\xe5\xbf\x97"": ""\xe7\xb8\xa3\xe8\xaa\x8c"",\n""\xe7\xbc\x9d\xe9\x87\x8c"": ""\xe7\xb8\xab\xe8\xa3\xa1"",\n""\xe7\xbc\x9d\xe5\x88\xb6"": ""\xe7\xb8\xab\xe8\xa3\xbd"",\n""\xe7\xba\xa4\xe5\xa4\xab"": ""\xe7\xb8\xb4\xe5\xa4\xab"",\n""\xe7\xb9\x81\xe5\xa4\x8d"": ""\xe7\xb9\x81\xe8\xa4\x87"",\n""\xe7\xbb\xb7\xe4\xbd\x8f"": ""\xe7\xb9\x83\xe4\xbd\x8f"",\n""\xe7\xbb\xb7\xe5\xad\x90"": ""\xe7\xb9\x83\xe5\xad\x90"",\n""\xe7\xbb\xb7\xe5\xb8\xa6"": ""\xe7\xb9\x83\xe5\xb8\xb6"",\n""\xe7\xbb\xb7\xe7\xb4\xa7"": ""\xe7\xb9\x83\xe7\xb7\x8a"",\n""\xe7\xbb\xb7\xe8\x84\xb8"": ""\xe7\xb9\x83\xe8\x87\x89"",\n""\xe7\xbb\xb7\xe7\x9d\x80"": ""\xe7\xb9\x83\xe8\x91\x97"",\n""\xe7\xbb\xb7\xe7\x9d\x80\xe8\x84\xb8"": ""\xe7\xb9\x83\xe8\x91\x97\xe8\x87\x89"",\n""\xe7\xbb\xb7\xe7\x9d\x80\xe8\x84\xb8\xe5\x84\xbf"": ""\xe7\xb9\x83\xe8\x91\x97\xe8\x87\x89\xe5\x85\x92"",\n""\xe7\xbb\xb7\xe5\xbc\x80"": ""\xe7\xb9\x83\xe9\x96\x8b"",\n""\xe7\xbb\x98\xe5\x88\xb6"": ""\xe7\xb9\xaa\xe8\xa3\xbd"",\n""\xe7\xb3\xbb\xe4\xb8\x8a"": ""\xe7\xb9\xab\xe4\xb8\x8a"",\n""\xe7\xb3\xbb\xe5\x88\xb0"": ""\xe7\xb9\xab\xe5\x88\xb0"",\n""\xe7\xb3\xbb\xe5\x9b\x9a"": ""\xe7\xb9\xab\xe5\x9b\x9a"",\n""\xe7\xb3\xbb\xe5\xbf\x83"": ""\xe7\xb9\xab\xe5\xbf\x83"",\n""\xe7\xb3\xbb\xe5\xbf\xb5"": ""\xe7\xb9\xab\xe5\xbf\xb5"",\n""\xe7\xb3\xbb\xe6\x80\x80"": ""\xe7\xb9\xab\xe6\x87\xb7"",\n""\xe7\xb3\xbb\xe6\x95\xb0"": ""\xe7\xb9\xab\xe6\x95\xb8"",\n""\xe7\xb3\xbb\xe4\xba\x8e"": ""\xe7\xb9\xab\xe6\x96\xbc"",\n""\xe7\xb3\xbb\xe7\xb3\xbb"": ""\xe7\xb9\xab\xe7\xb3\xbb"",\n""\xe7\xb3\xbb\xe7\xb4\xa7"": ""\xe7\xb9\xab\xe7\xb7\x8a"",\n""\xe7\xb3\xbb\xe7\xbb\xb3"": ""\xe7\xb9\xab\xe7\xb9\xa9"",\n""\xe7\xb3\xbb\xe7\x9d\x80"": ""\xe7\xb9\xab\xe8\x91\x97"",\n""\xe7\xb3\xbb\xe8\xbe\x9e"": ""\xe7\xb9\xab\xe8\xbe\xad"",\n""\xe7\xbc\xb4\xe5\x8d\xb7"": ""\xe7\xb9\xb3\xe5\x8d\xb7"",\n""\xe7\xb4\xaf\xe5\x9b\x9a"": ""\xe7\xba\x8d\xe5\x9b\x9a"",\n""\xe7\xb4\xaf\xe7\xb4\xaf"": ""\xe7\xba\x8d\xe7\xba\x8d"",\n""\xe5\x9d\x9b\xe5\xad\x90"": ""\xe7\xbd\x88\xe5\xad\x90"",\n""\xe5\x9d\x9b\xe5\x9d\x9b\xe7\xbd\x90\xe7\xbd\x90"": ""\xe7\xbd\x88\xe7\xbd\x88\xe7\xbd\x90\xe7\xbd\x90"",\n""\xe9\xaa\x82\xe7\x9d\x80"": ""\xe7\xbd\xb5\xe8\x91\x97"",\n""\xe7\xbe\x8e\xe5\x88\xb6"": ""\xe7\xbe\x8e\xe8\xa3\xbd"",\n""\xe7\xbe\x8e\xe5\x8f\x91"": ""\xe7\xbe\x8e\xe9\xab\xae"",\n""\xe7\xbf\xbb\xe6\x9d\xa5\xe5\xa4\x8d\xe5\x8e\xbb"": ""\xe7\xbf\xbb\xe4\xbe\x86\xe8\xa6\x86\xe5\x8e\xbb"",\n""\xe7\xbf\xbb\xe5\xa4\xa9\xe5\xa4\x8d\xe5\x9c\xb0"": ""\xe7\xbf\xbb\xe5\xa4\xa9\xe8\xa6\x86\xe5\x9c\xb0"",\n""\xe7\xbf\xbb\xe5\xa4\x8d"": ""\xe7\xbf\xbb\xe8\xa6\x86"",\n""\xe7\xbf\xbb\xe4\xba\x91\xe5\xa4\x8d\xe9\x9b\xa8"": ""\xe7\xbf\xbb\xe9\x9b\xb2\xe8\xa6\x86\xe9\x9b\xa8"",\n""\xe8\x80\x81\xe4\xb9\x88"": ""\xe8\x80\x81\xe4\xb9\x88"",\n""\xe8\x80\x81\xe6\x9d\xbf"": ""\xe8\x80\x81\xe9\x97\x86"",\n""\xe8\x80\x83\xe5\x8d\xb7"": ""\xe8\x80\x83\xe5\x8d\xb7"",\n""\xe8\x80\x95\xe8\x8e\xb7"": ""\xe8\x80\x95\xe7\xa9\xab"",\n""\xe8\x81\x8a\xe6\x96\x8b\xe5\xbf\x97\xe5\xbc\x82"": ""\xe8\x81\x8a\xe9\xbd\x8b\xe8\xaa\x8c\xe7\x95\xb0"",\n""\xe8\x81\x94\xe7\xb3\xbb"": ""\xe8\x81\xaf\xe4\xbf\x82"",\n""\xe8\x81\x94\xe7\xb3\xbb"": ""\xe8\x81\xaf\xe7\xb9\xab"",\n""\xe8\x82\x89\xe4\xb8\x9d\xe9\x9d\xa2"": ""\xe8\x82\x89\xe7\xb5\xb2\xe9\xba\xb5"",\n""\xe8\x82\x89\xe7\xbe\xb9\xe9\x9d\xa2"": ""\xe8\x82\x89\xe7\xbe\xb9\xe9\xba\xb5"",\n""\xe8\x82\x89\xe6\x9d\xbe"": ""\xe8\x82\x89\xe9\xac\x86"",\n""\xe8\x82\xa2\xe4\xbd\x93"": ""\xe8\x82\xa2\xe4\xbd\x93"",\n""\xe8\x83\x8c\xe5\x90\x91\xe7\x9d\x80"": ""\xe8\x83\x8c\xe5\x90\x91\xe8\x91\x97"",\n""\xe8\x83\x8c\xe5\x9c\xb0\xe9\x87\x8c"": ""\xe8\x83\x8c\xe5\x9c\xb0\xe8\xa3\xa1"",\n""\xe8\x83\xa1\xe9\x87\x8c\xe8\x83\xa1\xe6\xb6\x82"": ""\xe8\x83\xa1\xe8\xa3\xa1\xe8\x83\xa1\xe5\xa1\x97"",\n""\xe8\x83\xbd\xe5\xb9\xb2"": ""\xe8\x83\xbd\xe5\xb9\xb9"",\n""\xe8\x84\x89\xe5\x86\xb2"": ""\xe8\x84\x88\xe8\xa1\x9d"",\n""\xe8\x84\xb1\xe5\x8f\x91"": ""\xe8\x84\xab\xe9\xab\xae"",\n""\xe8\x85\x8a\xe5\x91\xb3"": ""\xe8\x85\x8a\xe5\x91\xb3"",\n""\xe8\x85\x8a\xe7\xac\x94"": ""\xe8\x85\x8a\xe7\xad\x86"",\n""\xe8\x85\x8a\xe8\x82\x89"": ""\xe8\x85\x8a\xe8\x82\x89"",\n""\xe8\x84\x91\xe5\xad\x90\xe9\x87\x8c"": ""\xe8\x85\xa6\xe5\xad\x90\xe8\xa3\xa1"",\n""\xe8\x85\xb0\xe9\x87\x8c"": ""\xe8\x85\xb0\xe8\xa3\xa1"",\n""\xe8\x83\xb6\xe5\x8d\xb7"": ""\xe8\x86\xa0\xe5\x8d\xb7"",\n""\xe8\x87\xaa\xe5\x88\xb6"": ""\xe8\x87\xaa\xe8\xa3\xbd"",\n""\xe8\x87\xaa\xe8\xa7\x89\xe8\x87\xaa\xe6\x84\xbf"": ""\xe8\x87\xaa\xe8\xa6\xba\xe8\x87\xaa\xe6\x84\xbf"",\n""\xe5\x8f\xb0\xe4\xb8\x8a"": ""\xe8\x87\xba\xe4\xb8\x8a"",\n""\xe5\x8f\xb0\xe4\xb8\x8b"": ""\xe8\x87\xba\xe4\xb8\x8b"",\n""\xe5\x8f\xb0\xe4\xb8\xad"": ""\xe8\x87\xba\xe4\xb8\xad"",\n""\xe5\x8f\xb0\xe5\x8c\x97"": ""\xe8\x87\xba\xe5\x8c\x97"",\n""\xe5\x8f\xb0\xe5\x8d\x97"": ""\xe8\x87\xba\xe5\x8d\x97"",\n""\xe5\x8f\xb0\xe5\x9c\xb0"": ""\xe8\x87\xba\xe5\x9c\xb0"",\n""\xe5\x8f\xb0\xe5\xa1\x91"": ""\xe8\x87\xba\xe5\xa1\x91"",\n""\xe5\x8f\xb0\xe5\xa4\xa7"": ""\xe8\x87\xba\xe5\xa4\xa7"",\n""\xe5\x8f\xb0\xe5\xb8\x81"": ""\xe8\x87\xba\xe5\xb9\xa3"",\n""\xe5\x8f\xb0\xe5\xba\xa7"": ""\xe8\x87\xba\xe5\xba\xa7"",\n""\xe5\x8f\xb0\xe4\xb8\x9c"": ""\xe8\x87\xba\xe6\x9d\xb1"",\n""\xe5\x8f\xb0\xe6\x9f\xb1"": ""\xe8\x87\xba\xe6\x9f\xb1"",\n""\xe5\x8f\xb0\xe6\xa6\xad"": ""\xe8\x87\xba\xe6\xa6\xad"",\n""\xe5\x8f\xb0\xe6\xb1\xbd"": ""\xe8\x87\xba\xe6\xb1\xbd"",\n""\xe5\x8f\xb0\xe6\xb5\xb7"": ""\xe8\x87\xba\xe6\xb5\xb7"",\n""\xe5\x8f\xb0\xe6\xbe\x8e\xe9\x87\x91\xe9\xa9\xac"": ""\xe8\x87\xba\xe6\xbe\x8e\xe9\x87\x91\xe9\xa6\xac"",\n""\xe5\x8f\xb0\xe6\xb9\xbe"": ""\xe8\x87\xba\xe7\x81\xa3"",\n""\xe5\x8f\xb0\xe7\x81\xaf"": ""\xe8\x87\xba\xe7\x87\x88"",\n""\xe5\x8f\xb0\xe7\x90\x83"": ""\xe8\x87\xba\xe7\x90\x83"",\n""\xe5\x8f\xb0\xe7\x9c\x81"": ""\xe8\x87\xba\xe7\x9c\x81"",\n""\xe5\x8f\xb0\xe7\xab\xaf"": ""\xe8\x87\xba\xe7\xab\xaf"",\n""\xe5\x8f\xb0\xe7\xb3\x96"": ""\xe8\x87\xba\xe7\xb3\x96"",\n""\xe5\x8f\xb0\xe8\x82\xa5"": ""\xe8\x87\xba\xe8\x82\xa5"",\n""\xe5\x8f\xb0\xe8\x88\xaa"": ""\xe8\x87\xba\xe8\x88\xaa"",\n""\xe5\x8f\xb0\xe8\xa7\x86"": ""\xe8\x87\xba\xe8\xa6\x96"",\n""\xe5\x8f\xb0\xe8\xaf\x8d"": ""\xe8\x87\xba\xe8\xa9\x9e"",\n""\xe5\x8f\xb0\xe8\xbd\xa6"": ""\xe8\x87\xba\xe8\xbb\x8a"",\n""\xe5\x8f\xb0\xe9\x93\x81"": ""\xe8\x87\xba\xe9\x90\xb5"",\n""\xe5\x8f\xb0\xe9\x98\xb6"": ""\xe8\x87\xba\xe9\x9a\x8e"",\n""\xe5\x8f\xb0\xe7\x94\xb5"": ""\xe8\x87\xba\xe9\x9b\xbb"",\n""\xe5\x8f\xb0\xe9\x9d\xa2"": ""\xe8\x87\xba\xe9\x9d\xa2"",\n""\xe8\x88\x82\xe8\xb0\xb7"": ""\xe8\x88\x82\xe7\xa9\x80"",\n""\xe5\x85\xb4\xe8\x87\xb4"": ""\xe8\x88\x88\xe7\xb7\xbb"",\n""\xe5\x85\xb4\xe9\xab\x98\xe9\x87\x87\xe7\x83\x88"": ""\xe8\x88\x88\xe9\xab\x98\xe9\x87\x87\xe7\x83\x88"",\n""\xe6\x97\xa7\xe5\x8e\x86"": ""\xe8\x88\x8a\xe6\x9b\x86"",\n""\xe8\x88\x92\xe5\x8d\xb7"": ""\xe8\x88\x92\xe5\x8d\xb7"",\n""\xe8\x88\x9e\xe5\x8f\xb0"": ""\xe8\x88\x9e\xe8\x87\xba"",\n""\xe8\x88\xaa\xe6\xb5\xb7\xe5\x8e\x86"": ""\xe8\x88\xaa\xe6\xb5\xb7\xe6\x9b\x86"",\n""\xe8\x88\xb9\xe5\x8f\xaa"": ""\xe8\x88\xb9\xe9\x9a\xbb"",\n""\xe8\x88\xb0\xe5\x8f\xaa"": ""\xe8\x89\xa6\xe9\x9a\xbb"",\n""\xe8\x8a\xac\xe9\x83\x81"": ""\xe8\x8a\xac\xe9\x83\x81"",\n""\xe8\x8a\xb1\xe5\x8d\xb7"": ""\xe8\x8a\xb1\xe5\x8d\xb7"",\n""\xe8\x8a\xb1\xe7\x9b\x86\xe9\x87\x8c"": ""\xe8\x8a\xb1\xe7\x9b\x86\xe8\xa3\xa1"",\n""\xe8\x8a\xb1\xe9\x87\x87"": ""\xe8\x8a\xb1\xe9\x87\x87"",\n""\xe8\x8b\x91\xe9\x87\x8c"": ""\xe8\x8b\x91\xe8\xa3\xa1"",\n""\xe8\x8b\xa5\xe5\xb9\xb2"": ""\xe8\x8b\xa5\xe5\xb9\xb2"",\n""\xe8\x8b\xa6\xe5\xb9\xb2"": ""\xe8\x8b\xa6\xe5\xb9\xb9"",\n""\xe8\x8b\xa6\xe9\x87\x8c"": ""\xe8\x8b\xa6\xe8\xa3\x8f"",\n""\xe8\x8b\xa6\xe5\x8d\xa4"": ""\xe8\x8b\xa6\xe9\xb9\xb5"",\n""\xe8\x8c\x83\xe4\xbb\xb2\xe6\xb7\xb9"": ""\xe8\x8c\x83\xe4\xbb\xb2\xe6\xb7\xb9"",\n""\xe8\x8c\x83\xe8\xa0\xa1"": ""\xe8\x8c\x83\xe8\xa0\xa1"",\n""\xe8\x8c\x83\xe9\x98\xb3"": ""\xe8\x8c\x83\xe9\x99\xbd"",\n""\xe8\x8c\x85\xe5\x8f\xb0"": ""\xe8\x8c\x85\xe8\x87\xba"",\n""\xe8\x8c\xb6\xe5\x87\xa0"": ""\xe8\x8c\xb6\xe5\x87\xa0"",\n""\xe8\x8d\x89\xe4\xb8\x9b\xe9\x87\x8c"": ""\xe8\x8d\x89\xe5\x8f\xa2\xe8\xa3\xa1"",\n""\xe5\xba\x84\xe9\x87\x8c"": ""\xe8\x8e\x8a\xe8\xa3\xa1"",\n""\xe8\x8c\x8e\xe5\xb9\xb2"": ""\xe8\x8e\x96\xe5\xb9\xb9"",\n""\xe8\x8e\xbd\xe8\x8d\xa1"": ""\xe8\x8e\xbd\xe8\x95\xa9"",\n""\xe8\x8f\x8c\xe4\xb8\x9d\xe4\xbd\x93"": ""\xe8\x8f\x8c\xe7\xb5\xb2\xe4\xbd\x93"",\n""\xe8\x8f\x8c\xe4\xb8\x9d\xe4\xbd\x93"": ""\xe8\x8f\x8c\xe7\xb5\xb2\xe9\xab\x94"",\n""\xe5\x8d\x8e\xe9\x87\x8c"": ""\xe8\x8f\xaf\xe8\xa3\xa1"",\n""\xe5\x8d\x8e\xe5\x8f\x91"": ""\xe8\x8f\xaf\xe9\xab\xae"",\n""\xe4\xb8\x87\xe5\x8d\xb7"": ""\xe8\x90\xac\xe5\x8d\xb7"",\n""\xe4\xb8\x87\xe5\x8e\x86"": ""\xe8\x90\xac\xe6\x9b\x86"",\n""\xe4\xb8\x87\xe5\x8f\xaa"": ""\xe8\x90\xac\xe9\x9a\xbb"",\n""\xe8\x90\xbd\xe5\x8f\x91"": ""\xe8\x90\xbd\xe9\xab\xae"",\n""\xe7\x9d\x80\xe5\x84\xbf"": ""\xe8\x91\x97\xe5\x85\x92"",\n""\xe7\x9d\x80\xe4\xb9\xa6\xe7\xab\x8b\xe8\xaf\xb4"": ""\xe8\x91\x97\xe6\x9b\xb8\xe7\xab\x8b\xe8\xaa\xaa"",\n""\xe7\x9d\x80\xe8\x89\xb2\xe8\xbd\xaf\xe4\xbd\x93"": ""\xe8\x91\x97\xe8\x89\xb2\xe8\xbb\x9f\xe9\xab\x94"",\n""\xe7\x9d\x80\xe9\x87\x8d\xe6\x8c\x87\xe5\x87\xba"": ""\xe8\x91\x97\xe9\x87\x8d\xe6\x8c\x87\xe5\x87\xba"",\n""\xe7\x9d\x80\xe5\xbd\x95"": ""\xe8\x91\x97\xe9\x8c\x84"",\n""\xe7\x9d\x80\xe5\xbd\x95\xe8\xa7\x84\xe5\x88\x99"": ""\xe8\x91\x97\xe9\x8c\x84\xe8\xa6\x8f\xe5\x89\x87"",\n""\xe8\x93\x84\xe5\x8f\x91"": ""\xe8\x93\x84\xe9\xab\xae"",\n""\xe8\x93\x84\xe9\xa1\xbb"": ""\xe8\x93\x84\xe9\xac\x9a"",\n""\xe8\x93\xac\xe5\x8f\x91"": ""\xe8\x93\xac\xe9\xab\xae"",\n""\xe8\x93\xac\xe6\x9d\xbe"": ""\xe8\x93\xac\xe9\xac\x86"",\n""\xe8\x8e\xb2\xe5\x8f\xb0"": ""\xe8\x93\xae\xe8\x87\xba"",\n""\xe8\x8d\xa1\xe6\x9d\xa5\xe8\x8d\xa1\xe5\x8e\xbb"": ""\xe8\x95\xa9\xe4\xbe\x86\xe8\x95\xa9\xe5\x8e\xbb"",\n""\xe8\x8d\xa1\xe5\xa5\xb3"": ""\xe8\x95\xa9\xe5\xa5\xb3"",\n""\xe8\x8d\xa1\xe5\xa6\x87"": ""\xe8\x95\xa9\xe5\xa9\xa6"",\n""\xe8\x8d\xa1\xe5\xaf\x87"": ""\xe8\x95\xa9\xe5\xaf\x87"",\n""\xe8\x8d\xa1\xe5\xb9\xb3"": ""\xe8\x95\xa9\xe5\xb9\xb3"",\n""\xe8\x8d\xa1\xe6\xb6\xa4"": ""\xe8\x95\xa9\xe6\xbb\x8c"",\n""\xe8\x8d\xa1\xe6\xbc\xbe"": ""\xe8\x95\xa9\xe6\xbc\xbe"",\n""\xe8\x8d\xa1\xe7\x84\xb6"": ""\xe8\x95\xa9\xe7\x84\xb6"",\n""\xe8\x8d\xa1\xe8\x88\x9f"": ""\xe8\x95\xa9\xe8\x88\x9f"",\n""\xe8\x8d\xa1\xe8\x88\xb9"": ""\xe8\x95\xa9\xe8\x88\xb9"",\n""\xe8\x8d\xa1\xe8\x8d\xa1"": ""\xe8\x95\xa9\xe8\x95\xa9"",\n""\xe8\x96\x91\xe4\xb8\x9d"": ""\xe8\x96\x91\xe7\xb5\xb2"",\n""\xe8\x96\x99\xe5\x8f\x91"": ""\xe8\x96\x99\xe9\xab\xae"",\n""\xe5\x80\x9f\xe4\xbb\xa5"": ""\xe8\x97\x89\xe4\xbb\xa5"",\n""\xe5\x80\x9f\xe5\x8f\xa3"": ""\xe8\x97\x89\xe5\x8f\xa3"",\n""\xe5\x80\x9f\xe6\x95\x85"": ""\xe8\x97\x89\xe6\x95\x85"",\n""\xe5\x80\x9f\xe6\x9c\xba"": ""\xe8\x97\x89\xe6\xa9\x9f"",\n""\xe5\x80\x9f\xe6\xad\xa4"": ""\xe8\x97\x89\xe6\xad\xa4"",\n""\xe5\x80\x9f\xe7\x94\xb1"": ""\xe8\x97\x89\xe7\x94\xb1"",\n""\xe5\x80\x9f\xe7\xab\xaf"": ""\xe8\x97\x89\xe7\xab\xaf"",\n""\xe5\x80\x9f\xe7\x9d\x80"": ""\xe8\x97\x89\xe8\x91\x97"",\n""\xe5\x80\x9f\xe5\x80\x9f"": ""\xe8\x97\x89\xe8\x97\x89"",\n""\xe5\x80\x9f\xe8\xaf\x8d"": ""\xe8\x97\x89\xe8\xa9\x9e"",\n""\xe5\x80\x9f\xe8\xb5\x84"": ""\xe8\x97\x89\xe8\xb3\x87"",\n""\xe5\x80\x9f\xe9\x85\x92\xe6\xb5\x87\xe6\x84\x81"": ""\xe8\x97\x89\xe9\x85\x92\xe6\xbe\x86\xe6\x84\x81"",\n""\xe8\x97\xa4\xe5\x88\xb6"": ""\xe8\x97\xa4\xe8\xa3\xbd"",\n""\xe8\x95\xb4\xe5\x90\xab\xe7\x9d\x80"": ""\xe8\x98\x8a\xe5\x90\xab\xe8\x91\x97"",\n""\xe8\x95\xb4\xe6\xb6\xb5\xe7\x9d\x80"": ""\xe8\x98\x8a\xe6\xb6\xb5\xe8\x91\x97"",\n""\xe8\x95\xb4\xe5\x80\x9f"": ""\xe8\x98\x8a\xe8\x97\x89"",\n""\xe8\x90\x9d\xe5\x8d\x9c"": ""\xe8\x98\xbf\xe8\x94\x94"",\n""\xe8\x99\x8e\xe9\xa1\xbb"": ""\xe8\x99\x8e\xe9\xac\x9a"",\n""\xe5\x8f\xb7\xe5\xbf\x97"": ""\xe8\x99\x9f\xe8\xaa\x8c"",\n""\xe8\x9c\x82\xe5\x90\x8e"": ""\xe8\x9c\x82\xe5\x90\x8e"",\n""\xe8\x9b\xae\xe5\xb9\xb2"": ""\xe8\xa0\xbb\xe5\xb9\xb9"",\n""\xe8\xa1\x8c\xe4\xba\x8b\xe5\x8e\x86"": ""\xe8\xa1\x8c\xe4\xba\x8b\xe6\x9b\x86"",\n""\xe8\x83\xa1\xe5\x90\x8c"": ""\xe8\xa1\x9a\xe8\xa1\x95"",\n""\xe5\x86\xb2\xe4\xb8\x8a"": ""\xe8\xa1\x9d\xe4\xb8\x8a"",\n""\xe5\x86\xb2\xe4\xb8\x8b"": ""\xe8\xa1\x9d\xe4\xb8\x8b"",\n""\xe5\x86\xb2\xe6\x9d\xa5"": ""\xe8\xa1\x9d\xe4\xbe\x86"",\n""\xe5\x86\xb2\xe5\x80\x92"": ""\xe8\xa1\x9d\xe5\x80\x92"",\n""\xe5\x86\xb2\xe5\x87\xba"": ""\xe8\xa1\x9d\xe5\x87\xba"",\n""\xe5\x86\xb2\xe5\x88\xb0"": ""\xe8\xa1\x9d\xe5\x88\xb0"",\n""\xe5\x86\xb2\xe5\x88\xba"": ""\xe8\xa1\x9d\xe5\x88\xba"",\n""\xe5\x86\xb2\xe5\x85\x8b"": ""\xe8\xa1\x9d\xe5\x89\x8b"",\n""\xe5\x86\xb2\xe5\x8a\x9b"": ""\xe8\xa1\x9d\xe5\x8a\x9b"",\n""\xe5\x86\xb2\xe5\x8a\xb2"": ""\xe8\xa1\x9d\xe5\x8b\x81"",\n""\xe5\x86\xb2\xe5\x8a\xa8"": ""\xe8\xa1\x9d\xe5\x8b\x95"",\n""\xe5\x86\xb2\xe5\x8e\xbb"": ""\xe8\xa1\x9d\xe5\x8e\xbb"",\n""\xe5\x86\xb2\xe5\x8f\xa3"": ""\xe8\xa1\x9d\xe5\x8f\xa3"",\n""\xe5\x86\xb2\xe5\x9e\xae"": ""\xe8\xa1\x9d\xe5\x9e\xae"",\n""\xe5\x86\xb2\xe5\xa0\x82"": ""\xe8\xa1\x9d\xe5\xa0\x82"",\n""\xe5\x86\xb2\xe5\x8e\x8b"": ""\xe8\xa1\x9d\xe5\xa3\x93"",\n""\xe5\x86\xb2\xe5\xa4\xa9"": ""\xe8\xa1\x9d\xe5\xa4\xa9"",\n""\xe5\x86\xb2\xe6\x8e\x89"": ""\xe8\xa1\x9d\xe6\x8e\x89"",\n""\xe5\x86\xb2\xe6\x92\x9e"": ""\xe8\xa1\x9d\xe6\x92\x9e"",\n""\xe5\x86\xb2\xe5\x87\xbb"": ""\xe8\xa1\x9d\xe6\x93\x8a"",\n""\xe5\x86\xb2\xe6\x95\xa3"": ""\xe8\xa1\x9d\xe6\x95\xa3"",\n""\xe5\x86\xb2\xe5\x86\xb3"": ""\xe8\xa1\x9d\xe6\xb1\xba"",\n""\xe5\x86\xb2\xe6\xb5\xaa"": ""\xe8\xa1\x9d\xe6\xb5\xaa"",\n""\xe5\x86\xb2\xe6\xbf\x80"": ""\xe8\xa1\x9d\xe6\xbf\x80"",\n""\xe5\x86\xb2\xe7\xa0\xb4"": ""\xe8\xa1\x9d\xe7\xa0\xb4"",\n""\xe5\x86\xb2\xe7\xa8\x8b"": ""\xe8\xa1\x9d\xe7\xa8\x8b"",\n""\xe5\x86\xb2\xe7\xaa\x81"": ""\xe8\xa1\x9d\xe7\xaa\x81"",\n""\xe5\x86\xb2\xe7\xba\xbf"": ""\xe8\xa1\x9d\xe7\xb7\x9a"",\n""\xe5\x86\xb2\xe7\x9d\x80"": ""\xe8\xa1\x9d\xe8\x91\x97"",\n""\xe5\x86\xb2\xe5\x86\xb2"": ""\xe8\xa1\x9d\xe8\xa1\x9d"",\n""\xe5\x86\xb2\xe8\xa6\x81"": ""\xe8\xa1\x9d\xe8\xa6\x81"",\n""\xe5\x86\xb2\xe8\xb5\xb7"": ""\xe8\xa1\x9d\xe8\xb5\xb7"",\n""\xe5\x86\xb2\xe8\xbf\x9b"": ""\xe8\xa1\x9d\xe9\x80\xb2"",\n""\xe5\x86\xb2\xe8\xbf\x87"": ""\xe8\xa1\x9d\xe9\x81\x8e"",\n""\xe5\x86\xb2\xe9\x94\x8b"": ""\xe8\xa1\x9d\xe9\x8b\x92"",\n""\xe8\xa1\xa8\xe9\x87\x8c"": ""\xe8\xa1\xa8\xe8\xa3\xa1"",\n""\xe8\xa2\x96\xe9\x87\x8c"": ""\xe8\xa2\x96\xe8\xa3\xa1"",\n""\xe8\xa2\xab\xe9\x87\x8c"": ""\xe8\xa2\xab\xe8\xa3\xa1"",\n""\xe8\xa2\xab\xe5\xa4\x8d"": ""\xe8\xa2\xab\xe8\xa4\x87"",\n""\xe8\xa2\xab\xe5\xa4\x8d"": ""\xe8\xa2\xab\xe8\xa6\x86"",\n""\xe8\xa2\xab\xe5\xa4\x8d\xe7\x9d\x80"": ""\xe8\xa2\xab\xe8\xa6\x86\xe8\x91\x97"",\n""\xe8\xa2\xab\xe5\x8f\x91"": ""\xe8\xa2\xab\xe9\xab\xae"",\n""\xe8\xa3\x81\xe5\xb9\xb6"": ""\xe8\xa3\x81\xe4\xbd\xb5"",\n""\xe8\xa3\x81\xe5\x88\xb6"": ""\xe8\xa3\x81\xe8\xa3\xbd"",\n""\xe9\x87\x8c\xe9\x9d\xa2"": ""\xe8\xa3\x8f\xe9\x9d\xa2"",\n""\xe9\x87\x8c\xe4\xba\xba"": ""\xe8\xa3\xa1\xe4\xba\xba"",\n""\xe9\x87\x8c\xe5\x8a\xa0"": ""\xe8\xa3\xa1\xe5\x8a\xa0"",\n""\xe9\x87\x8c\xe5\xa4\x96"": ""\xe8\xa3\xa1\xe5\xa4\x96"",\n""\xe9\x87\x8c\xe5\xad\x90"": ""\xe8\xa3\xa1\xe5\xad\x90"",\n""\xe9\x87\x8c\xe5\xb1\x8b"": ""\xe8\xa3\xa1\xe5\xb1\x8b"",\n""\xe9\x87\x8c\xe5\xb1\x82"": ""\xe8\xa3\xa1\xe5\xb1\xa4"",\n""\xe9\x87\x8c\xe5\xb8\x83"": ""\xe8\xa3\xa1\xe5\xb8\x83"",\n""\xe9\x87\x8c\xe5\xb8\xa6"": ""\xe8\xa3\xa1\xe5\xb8\xb6"",\n""\xe9\x87\x8c\xe5\xbc\xa6"": ""\xe8\xa3\xa1\xe5\xbc\xa6"",\n""\xe9\x87\x8c\xe5\xba\x94\xe5\xa4\x96\xe5\x90\x88"": ""\xe8\xa3\xa1\xe6\x87\x89\xe5\xa4\x96\xe5\x90\x88"",\n""\xe9\x87\x8c\xe6\x8b\x89"": ""\xe8\xa3\xa1\xe6\x8b\x89"",\n""\xe9\x87\x8c\xe6\x96\xaf"": ""\xe8\xa3\xa1\xe6\x96\xaf"",\n""\xe9\x87\x8c\xe6\xb5\xb7"": ""\xe8\xa3\xa1\xe6\xb5\xb7"",\n""\xe9\x87\x8c\xe8\x84\x8a"": ""\xe8\xa3\xa1\xe8\x84\x8a"",\n""\xe9\x87\x8c\xe8\xa1\xa3"": ""\xe8\xa3\xa1\xe8\xa1\xa3"",\n""\xe9\x87\x8c\xe9\x87\x8c"": ""\xe8\xa3\xa1\xe8\xa3\xa1"",\n""\xe9\x87\x8c\xe9\x80\x9a\xe5\xa4\x96\xe5\x9b\xbd"": ""\xe8\xa3\xa1\xe9\x80\x9a\xe5\xa4\x96\xe5\x9c\x8b"",\n""\xe9\x87\x8c\xe9\x80\x9a\xe5\xa4\x96\xe6\x95\x8c"": ""\xe8\xa3\xa1\xe9\x80\x9a\xe5\xa4\x96\xe6\x95\xb5"",\n""\xe9\x87\x8c\xe8\xbe\xb9"": ""\xe8\xa3\xa1\xe9\x82\x8a"",\n""\xe9\x87\x8c\xe9\x97\xb4"": ""\xe8\xa3\xa1\xe9\x96\x93"",\n""\xe9\x87\x8c\xe9\x9d\xa2"": ""\xe8\xa3\xa1\xe9\x9d\xa2"",\n""\xe9\x87\x8c\xe5\xa4\xb4"": ""\xe8\xa3\xa1\xe9\xa0\xad"",\n""\xe5\x88\xb6\xe4\xbb\xb6"": ""\xe8\xa3\xbd\xe4\xbb\xb6"",\n""\xe5\x88\xb6\xe4\xbd\x9c"": ""\xe8\xa3\xbd\xe4\xbd\x9c"",\n""\xe5\x88\xb6\xe5\x81\x9a"": ""\xe8\xa3\xbd\xe5\x81\x9a"",\n""\xe5\x88\xb6\xe5\xa4\x87"": ""\xe8\xa3\xbd\xe5\x82\x99"",\n""\xe5\x88\xb6\xe5\x86\xb0"": ""\xe8\xa3\xbd\xe5\x86\xb0"",\n""\xe5\x88\xb6\xe5\x86\xb7"": ""\xe8\xa3\xbd\xe5\x86\xb7"",\n""\xe5\x88\xb6\xe5\x89\x82"": ""\xe8\xa3\xbd\xe5\x8a\x91"",\n""\xe5\x88\xb6\xe5\x93\x81"": ""\xe8\xa3\xbd\xe5\x93\x81"",\n""\xe5\x88\xb6\xe5\x9b\xbe"": ""\xe8\xa3\xbd\xe5\x9c\x96"",\n""\xe5\x88\xb6\xe6\x88\x90"": ""\xe8\xa3\xbd\xe6\x88\x90"",\n""\xe5\x88\xb6\xe6\xb3\x95"": ""\xe8\xa3\xbd\xe6\xb3\x95"",\n""\xe5\x88\xb6\xe4\xb8\xba"": ""\xe8\xa3\xbd\xe7\x82\xba"",\n""\xe5\x88\xb6\xe7\x89\x87"": ""\xe8\xa3\xbd\xe7\x89\x87"",\n""\xe5\x88\xb6\xe7\x89\x88"": ""\xe8\xa3\xbd\xe7\x89\x88"",\n""\xe5\x88\xb6\xe7\xa8\x8b"": ""\xe8\xa3\xbd\xe7\xa8\x8b"",\n""\xe5\x88\xb6\xe7\xb3\x96"": ""\xe8\xa3\xbd\xe7\xb3\x96"",\n""\xe5\x88\xb6\xe7\xba\xb8"": ""\xe8\xa3\xbd\xe7\xb4\x99"",\n""\xe5\x88\xb6\xe8\x8d\xaf"": ""\xe8\xa3\xbd\xe8\x97\xa5"",\n""\xe5\x88\xb6\xe8\xa1\xa8"": ""\xe8\xa3\xbd\xe8\xa1\xa8"",\n""\xe5\x88\xb6\xe8\xa3\x81"": ""\xe8\xa3\xbd\xe8\xa3\x81"",\n""\xe5\x88\xb6\xe9\x80\xa0"": ""\xe8\xa3\xbd\xe9\x80\xa0"",\n""\xe5\x88\xb6\xe9\x9d\xa9"": ""\xe8\xa3\xbd\xe9\x9d\xa9"",\n""\xe5\x88\xb6\xe9\x9e\x8b"": ""\xe8\xa3\xbd\xe9\x9e\x8b"",\n""\xe5\x88\xb6\xe7\x9b\x90"": ""\xe8\xa3\xbd\xe9\xb9\xbd"",\n""\xe5\xa4\x8d\xe4\xbb\x9e\xe5\xb9\xb4\xe5\xa6\x82"": ""\xe8\xa4\x87\xe4\xbb\x9e\xe5\xb9\xb4\xe5\xa6\x82"",\n""\xe5\xa4\x8d\xe4\xbb\xa5\xe7\x99\xbe\xe4\xb8\x87"": ""\xe8\xa4\x87\xe4\xbb\xa5\xe7\x99\xbe\xe8\x90\xac"",\n""\xe5\xa4\x8d\xe4\xbd\x8d"": ""\xe8\xa4\x87\xe4\xbd\x8d"",\n""\xe5\xa4\x8d\xe4\xbf\xa1"": ""\xe8\xa4\x87\xe4\xbf\xa1"",\n""\xe5\xa4\x8d\xe5\x88\x86\xe6\x95\xb0"": ""\xe8\xa4\x87\xe5\x88\x86\xe6\x95\xb8"",\n""\xe5\xa4\x8d\xe5\x88\x97"": ""\xe8\xa4\x87\xe5\x88\x97"",\n""\xe5\xa4\x8d\xe5\x88\xa9"": ""\xe8\xa4\x87\xe5\x88\xa9"",\n""\xe5\xa4\x8d\xe5\x8d\xb0"": ""\xe8\xa4\x87\xe5\x8d\xb0"",\n""\xe5\xa4\x8d\xe5\x8e\x9f"": ""\xe8\xa4\x87\xe5\x8e\x9f"",\n""\xe5\xa4\x8d\xe5\x8f\xa5"": ""\xe8\xa4\x87\xe5\x8f\xa5"",\n""\xe5\xa4\x8d\xe5\x90\x88"": ""\xe8\xa4\x87\xe5\x90\x88"",\n""\xe5\xa4\x8d\xe5\x90\x8d"": ""\xe8\xa4\x87\xe5\x90\x8d"",\n""\xe5\xa4\x8d\xe5\x91\x98"": ""\xe8\xa4\x87\xe5\x93\xa1"",\n""\xe5\xa4\x8d\xe5\xa3\x81"": ""\xe8\xa4\x87\xe5\xa3\x81"",\n""\xe5\xa4\x8d\xe5\xa3\xae"": ""\xe8\xa4\x87\xe5\xa3\xaf"",\n""\xe5\xa4\x8d\xe5\xa7\x93"": ""\xe8\xa4\x87\xe5\xa7\x93"",\n""\xe5\xa4\x8d\xe5\xad\x97\xe9\x94\xae"": ""\xe8\xa4\x87\xe5\xad\x97\xe9\x8d\xb5"",\n""\xe5\xa4\x8d\xe5\xae\xa1"": ""\xe8\xa4\x87\xe5\xaf\xa9"",\n""\xe5\xa4\x8d\xe5\x86\x99"": ""\xe8\xa4\x87\xe5\xaf\xab"",\n""\xe5\xa4\x8d\xe5\xbc\x8f"": ""\xe8\xa4\x87\xe5\xbc\x8f"",\n""\xe5\xa4\x8d\xe5\xa4\x8d"": ""\xe8\xa4\x87\xe5\xbe\xa9"",\n""\xe5\xa4\x8d\xe6\x95\xb0"": ""\xe8\xa4\x87\xe6\x95\xb8"",\n""\xe5\xa4\x8d\xe6\x9c\xac"": ""\xe8\xa4\x87\xe6\x9c\xac"",\n""\xe5\xa4\x8d\xe6\x9f\xa5"": ""\xe8\xa4\x87\xe6\x9f\xa5"",\n""\xe5\xa4\x8d\xe6\xa0\xb8"": ""\xe8\xa4\x87\xe6\xa0\xb8"",\n""\xe5\xa4\x8d\xe6\xa3\x80"": ""\xe8\xa4\x87\xe6\xaa\xa2"",\n""\xe5\xa4\x8d\xe6\xac\xa1"": ""\xe8\xa4\x87\xe6\xac\xa1"",\n""\xe5\xa4\x8d\xe6\xaf\x94"": ""\xe8\xa4\x87\xe6\xaf\x94"",\n""\xe5\xa4\x8d\xe5\x86\xb3"": ""\xe8\xa4\x87\xe6\xb1\xba"",\n""\xe5\xa4\x8d\xe6\xb4\xbb"": ""\xe8\xa4\x87\xe6\xb4\xbb"",\n""\xe5\xa4\x8d\xe6\xb5\x8b"": ""\xe8\xa4\x87\xe6\xb8\xac"",\n""\xe5\xa4\x8d\xe4\xba\xa9\xe7\x8f\x8d"": ""\xe8\xa4\x87\xe7\x95\x9d\xe7\x8f\x8d"",\n""\xe5\xa4\x8d\xe5\x8f\x91"": ""\xe8\xa4\x87\xe7\x99\xbc"",\n""\xe5\xa4\x8d\xe7\x9b\xae"": ""\xe8\xa4\x87\xe7\x9b\xae"",\n""\xe5\xa4\x8d\xe7\x9c\xbc"": ""\xe8\xa4\x87\xe7\x9c\xbc"",\n""\xe5\xa4\x8d\xe7\xa7\x8d"": ""\xe8\xa4\x87\xe7\xa8\xae"",\n""\xe5\xa4\x8d\xe7\xba\xbf"": ""\xe8\xa4\x87\xe7\xb7\x9a"",\n""\xe5\xa4\x8d\xe4\xb9\xa0"": ""\xe8\xa4\x87\xe7\xbf\x92"",\n""\xe5\xa4\x8d\xe5\x85\xb4\xe7\xa4\xbe"": ""\xe8\xa4\x87\xe8\x88\x88\xe7\xa4\xbe"",\n""\xe5\xa4\x8d\xe6\x97\xa7"": ""\xe8\xa4\x87\xe8\x88\x8a"",\n""\xe5\xa4\x8d\xe8\x89\xb2"": ""\xe8\xa4\x87\xe8\x89\xb2"",\n""\xe5\xa4\x8d\xe5\x8f\xb6"": ""\xe8\xa4\x87\xe8\x91\x89"",\n""\xe5\xa4\x8d\xe7\x9b\x96"": ""\xe8\xa4\x87\xe8\x93\x8b"",\n""\xe5\xa4\x8d\xe8\x8b\x8f"": ""\xe8\xa4\x87\xe8\x98\x87"",\n""\xe5\xa4\x8d\xe5\x88\xb6"": ""\xe8\xa4\x87\xe8\xa3\xbd"",\n""\xe5\xa4\x8d\xe8\xaf\x8a"": ""\xe8\xa4\x87\xe8\xa8\xba"",\n""\xe5\xa4\x8d\xe8\xaf\x8d"": ""\xe8\xa4\x87\xe8\xa9\x9e"",\n""\xe5\xa4\x8d\xe8\xaf\x95"": ""\xe8\xa4\x87\xe8\xa9\xa6"",\n""\xe5\xa4\x8d\xe8\xaf\xbe"": ""\xe8\xa4\x87\xe8\xaa\xb2"",\n""\xe5\xa4\x8d\xe8\xae\xae"": ""\xe8\xa4\x87\xe8\xad\xb0"",\n""\xe5\xa4\x8d\xe5\x8f\x98\xe5\x87\xbd\xe6\x95\xb0"": ""\xe8\xa4\x87\xe8\xae\x8a\xe5\x87\xbd\xe6\x95\xb8"",\n""\xe5\xa4\x8d\xe8\xb5\x9b"": ""\xe8\xa4\x87\xe8\xb3\xbd"",\n""\xe5\xa4\x8d\xe8\xbf\xb0"": ""\xe8\xa4\x87\xe8\xbf\xb0"",\n""\xe5\xa4\x8d\xe9\x80\x89"": ""\xe8\xa4\x87\xe9\x81\xb8"",\n""\xe5\xa4\x8d\xe9\x92\xb1"": ""\xe8\xa4\x87\xe9\x8c\xa2"",\n""\xe5\xa4\x8d\xe6\x9d\x82"": ""\xe8\xa4\x87\xe9\x9b\x9c"",\n""\xe5\xa4\x8d\xe7\x94\xb5"": ""\xe8\xa4\x87\xe9\x9b\xbb"",\n""\xe5\xa4\x8d\xe9\x9f\xb3"": ""\xe8\xa4\x87\xe9\x9f\xb3"",\n""\xe5\xa4\x8d\xe9\x9f\xb5"": ""\xe8\xa4\x87\xe9\x9f\xbb"",\n""\xe8\xa1\xac\xe9\x87\x8c"": ""\xe8\xa5\xaf\xe8\xa3\xa1"",\n""\xe8\xa5\xbf\xe5\xb2\xb3"": ""\xe8\xa5\xbf\xe5\xb6\xbd"",\n""\xe8\xa5\xbf\xe5\xbe\x81"": ""\xe8\xa5\xbf\xe5\xbe\x81"",\n""\xe8\xa5\xbf\xe5\x8e\x86"": ""\xe8\xa5\xbf\xe6\x9b\x86"",\n""\xe8\xa6\x81\xe5\x86\xb2"": ""\xe8\xa6\x81\xe8\xa1\x9d"",\n""\xe8\xa6\x81\xe4\xb9\x88"": ""\xe8\xa6\x81\xe9\xba\xbc"",\n""\xe5\xa4\x8d\xe4\xb8\x8a"": ""\xe8\xa6\x86\xe4\xb8\x8a"",\n""\xe5\xa4\x8d\xe4\xba\xa1"": ""\xe8\xa6\x86\xe4\xba\xa1"",\n""\xe5\xa4\x8d\xe4\xbd\x8f"": ""\xe8\xa6\x86\xe4\xbd\x8f"",\n""\xe5\xa4\x8d\xe4\xbf\xa1"": ""\xe8\xa6\x86\xe4\xbf\xa1"",\n""\xe5\xa4\x8d\xe5\x91\xbd"": ""\xe8\xa6\x86\xe5\x91\xbd"",\n""\xe5\xa4\x8d\xe5\x9c\xa8"": ""\xe8\xa6\x86\xe5\x9c\xa8"",\n""\xe5\xa4\x8d\xe5\xae\xa1"": ""\xe8\xa6\x86\xe5\xaf\xa9"",\n""\xe5\xa4\x8d\xe5\xb7\xa2\xe4\xb9\x8b\xe4\xb8\x8b"": ""\xe8\xa6\x86\xe5\xb7\xa2\xe4\xb9\x8b\xe4\xb8\x8b"",\n""\xe5\xa4\x8d\xe6\x88\x90"": ""\xe8\xa6\x86\xe6\x88\x90"",\n""\xe5\xa4\x8d\xe8\xb4\xa5"": ""\xe8\xa6\x86\xe6\x95\x97"",\n""\xe5\xa4\x8d\xe6\x96\x87"": ""\xe8\xa6\x86\xe6\x96\x87"",\n""\xe5\xa4\x8d\xe6\xa0\xa1"": ""\xe8\xa6\x86\xe6\xa0\xa1"",\n""\xe5\xa4\x8d\xe6\xa0\xb8"": ""\xe8\xa6\x86\xe6\xa0\xb8"",\n""\xe5\xa4\x8d\xe6\xb0\xb4\xe9\x9a\xbe\xe6\x94\xb6"": ""\xe8\xa6\x86\xe6\xb0\xb4\xe9\x9b\xa3\xe6\x94\xb6"",\n""\xe5\xa4\x8d\xe6\xb2\xa1"": ""\xe8\xa6\x86\xe6\xb2\x92"",\n""\xe5\xa4\x8d\xe7\x81\xad"": ""\xe8\xa6\x86\xe6\xbb\x85"",\n""\xe5\xa4\x8d\xe7\x9b\x86"": ""\xe8\xa6\x86\xe7\x9b\x86"",\n""\xe5\xa4\x8d\xe8\x88\x9f"": ""\xe8\xa6\x86\xe8\x88\x9f"",\n""\xe5\xa4\x8d\xe7\x9d\x80"": ""\xe8\xa6\x86\xe8\x91\x97"",\n""\xe5\xa4\x8d\xe7\x9b\x96"": ""\xe8\xa6\x86\xe8\x93\x8b"",\n""\xe5\xa4\x8d\xe7\x9b\x96\xe7\x9d\x80"": ""\xe8\xa6\x86\xe8\x93\x8b\xe8\x91\x97"",\n""\xe5\xa4\x8d\xe8\xaf\x95"": ""\xe8\xa6\x86\xe8\xa9\xa6"",\n""\xe5\xa4\x8d\xe8\xae\xae"": ""\xe8\xa6\x86\xe8\xad\xb0"",\n""\xe5\xa4\x8d\xe8\xbd\xa6"": ""\xe8\xa6\x86\xe8\xbb\x8a"",\n""\xe5\xa4\x8d\xe8\xbd\xbd"": ""\xe8\xa6\x86\xe8\xbc\x89"",\n""\xe5\xa4\x8d\xe8\xbe\x99"": ""\xe8\xa6\x86\xe8\xbd\x8d"",\n""\xe5\xa4\x8d\xe7\x94\xb5"": ""\xe8\xa6\x86\xe9\x9b\xbb"",\n""\xe8\xa7\x81\xe5\xa4\x8d"": ""\xe8\xa6\x8b\xe8\xa6\x86"",\n""\xe4\xba\xb2\xe5\xbe\x81"": ""\xe8\xa6\xaa\xe5\xbe\x81"",\n""\xe8\xa7\x82\xe4\xbc\x97\xe5\x8f\xb0"": ""\xe8\xa7\x80\xe7\x9c\xbe\xe8\x87\xba"",\n""\xe8\xa7\x82\xe5\x8f\xb0"": ""\xe8\xa7\x80\xe8\x87\xba"",\n""\xe8\xa7\x82\xe8\xb1\xa1\xe5\x8f\xb0"": ""\xe8\xa7\x80\xe8\xb1\xa1\xe8\x87\xba"",\n""\xe8\xa7\x92\xe8\x90\xbd\xe9\x87\x8c"": ""\xe8\xa7\x92\xe8\x90\xbd\xe8\xa3\xa1"",\n""\xe8\xa7\x94\xe6\x96\x97"": ""\xe8\xa7\x94\xe6\x96\x97"",\n""\xe8\xa7\xa6\xe9\xa1\xbb"": ""\xe8\xa7\xb8\xe9\xac\x9a"",\n""\xe8\xae\xa2\xe5\x88\xb6"": ""\xe8\xa8\x82\xe8\xa3\xbd"",\n""\xe8\xaf\x89\xe8\xaf\xb4\xe7\x9d\x80"": ""\xe8\xa8\xb4\xe8\xaa\xaa\xe8\x91\x97"",\n""\xe8\xaf\x8d\xe6\xb1\x87"": ""\xe8\xa9\x9e\xe5\xbd\x99"",\n""\xe8\xaf\x95\xe5\x8d\xb7"": ""\xe8\xa9\xa6\xe5\x8d\xb7"",\n""\xe8\xaf\x97\xe5\x8d\xb7"": ""\xe8\xa9\xa9\xe5\x8d\xb7"",\n""\xe8\xaf\x9d\xe9\x87\x8c\xe6\x9c\x89\xe8\xaf\x9d"": ""\xe8\xa9\xb1\xe8\xa3\xa1\xe6\x9c\x89\xe8\xa9\xb1"",\n""\xe5\xbf\x97\xe5\x93\x80"": ""\xe8\xaa\x8c\xe5\x93\x80"",\n""\xe5\xbf\x97\xe5\x96\x9c"": ""\xe8\xaa\x8c\xe5\x96\x9c"",\n""\xe5\xbf\x97\xe5\xba\x86"": ""\xe8\xaa\x8c\xe6\x85\xb6"",\n""\xe8\xaf\xad\xe4\xba\x91"": ""\xe8\xaa\x9e\xe4\xba\x91"",\n""\xe8\xaf\xad\xe6\xb1\x87"": ""\xe8\xaa\x9e\xe5\xbd\x99"",\n""\xe8\xaf\xac\xe8\x94\x91"": ""\xe8\xaa\xa3\xe8\xa1\x8a"",\n""\xe8\xaf\xb5\xe7\xbb\x8f\xe5\x8f\xb0"": ""\xe8\xaa\xa6\xe7\xb6\x93\xe8\x87\xba"",\n""\xe8\xaf\xb4\xe7\x9d\x80"": ""\xe8\xaa\xaa\xe8\x91\x97"",\n""\xe8\xaf\xbe\xe5\xbe\x81"": ""\xe8\xaa\xb2\xe5\xbe\x81"",\n""\xe8\xb0\x83\xe5\x88\xb6"": ""\xe8\xaa\xbf\xe8\xa3\xbd"",\n""\xe8\xb0\x83\xe9\xa2\x91\xe5\x8f\xb0"": ""\xe8\xaa\xbf\xe9\xa0\xbb\xe8\x87\xba"",\n""\xe8\xaf\xb7\xe5\x8f\x82\xe9\x98\x85"": ""\xe8\xab\x8b\xe5\x8f\x83\xe9\x96\xb1"",\n""\xe8\xae\xb2\xe5\x8f\xb0"": ""\xe8\xac\x9b\xe8\x87\xba"",\n""\xe8\xb0\xa2\xe7\xbb\x9d\xe5\x8f\x82\xe8\xa7\x82"": ""\xe8\xac\x9d\xe7\xb5\x95\xe5\x8f\x83\xe8\xa7\x80"",\n""\xe6\x8a\xa4\xe5\x8f\x91"": ""\xe8\xad\xb7\xe9\xab\xae"",\n""\xe9\x9b\xa0\xe9\x9a\x99"": ""\xe8\xae\x8e\xe9\x9a\x99"",\n""\xe8\xb1\x86\xe8\x85\x90\xe5\xb9\xb2"": ""\xe8\xb1\x86\xe8\x85\x90\xe5\xb9\xb2"",\n""\xe7\xab\x96\xe7\x9d\x80"": ""\xe8\xb1\x8e\xe8\x91\x97"",\n""\xe4\xb8\xb0\xe5\xaf\x8c\xe5\xa4\x9a\xe9\x87\x87"": ""\xe8\xb1\x90\xe5\xaf\x8c\xe5\xa4\x9a\xe9\x87\x87"",\n""\xe4\xb8\xb0\xe6\xbb\xa8"": ""\xe8\xb1\x90\xe6\xbf\xb1"",\n""\xe4\xb8\xb0\xe6\xbb\xa8\xe4\xb9\xa1"": ""\xe8\xb1\x90\xe6\xbf\xb1\xe9\x84\x89"",\n""\xe4\xb8\xb0\xe9\x87\x87"": ""\xe8\xb1\x90\xe9\x87\x87"",\n""\xe8\xb1\xa1\xe5\xbe\x81\xe7\x9d\x80"": ""\xe8\xb1\xa1\xe5\xbe\xb5\xe8\x91\x97"",\n""\xe8\xb4\xb5\xe5\xb9\xb2"": ""\xe8\xb2\xb4\xe5\xb9\xb9"",\n""\xe8\xb4\xbe\xe5\x90\x8e"": ""\xe8\xb3\x88\xe5\x90\x8e"",\n""\xe8\xb5\x88\xe9\xa5\xa5"": ""\xe8\xb3\x91\xe9\xa5\x91"",\n""\xe8\xb4\xa4\xe5\x90\x8e"": ""\xe8\xb3\xa2\xe5\x90\x8e"",\n""\xe8\xb4\xa8\xe6\x9c\xb4"": ""\xe8\xb3\xaa\xe6\x9c\xb4"",\n""\xe8\xb5\x8c\xe5\x8f\xb0"": ""\xe8\xb3\xad\xe6\xaa\xaf"",\n""\xe8\xb4\xad\xe5\xb9\xb6"": ""\xe8\xb3\xbc\xe4\xbd\xb5"",\n""\xe8\xb5\xa4\xe6\x9d\xbe"": ""\xe8\xb5\xa4\xe9\xac\x86"",\n""\xe8\xb5\xb7\xe5\x90\x8a"": ""\xe8\xb5\xb7\xe5\x90\x8a"",\n""\xe8\xb5\xb7\xe5\xa4\x8d"": ""\xe8\xb5\xb7\xe8\xa4\x87"",\n""\xe8\xb5\xb6\xe5\x88\xb6"": ""\xe8\xb6\x95\xe8\xa3\xbd"",\n""\xe8\xb7\x8c\xe8\x8d\xa1"": ""\xe8\xb7\x8c\xe8\x95\xa9"",\n""\xe8\xb7\x9f\xe6\x96\x97"": ""\xe8\xb7\x9f\xe6\x96\x97"",\n""\xe8\xb7\xb3\xe8\x8d\xa1"": ""\xe8\xb7\xb3\xe8\x95\xa9"",\n""\xe8\xb7\xb3\xe8\xa1\xa8"": ""\xe8\xb7\xb3\xe9\x8c\xb6"",\n""\xe8\xb8\xac\xe4\xbb\x86"": ""\xe8\xba\x93\xe4\xbb\x86"",\n""\xe8\xba\xaf\xe5\xb9\xb2"": ""\xe8\xbb\x80\xe5\xb9\xb9"",\n""\xe8\xbd\xa6\xe5\xba\x93\xe9\x87\x8c"": ""\xe8\xbb\x8a\xe5\xba\xab\xe8\xa3\xa1"",\n""\xe8\xbd\xa6\xe7\xab\x99\xe9\x87\x8c"": ""\xe8\xbb\x8a\xe7\xab\x99\xe8\xa3\xa1"",\n""\xe8\xbd\xa6\xe9\x87\x8c"": ""\xe8\xbb\x8a\xe8\xa3\xa1"",\n""\xe8\xbd\xbb\xe6\x9d\xbe"": ""\xe8\xbc\x95\xe9\xac\x86"",\n""\xe8\xbd\xae\xe5\x9b\x9e"": ""\xe8\xbc\xaa\xe8\xbf\xb4"",\n""\xe8\xbd\xac\xe5\x8f\xb0"": ""\xe8\xbd\x89\xe6\xaa\xaf"",\n""\xe8\xbe\x9b\xe4\xb8\x91"": ""\xe8\xbe\x9b\xe4\xb8\x91"",\n""\xe8\xbe\x9f\xe9\x82\xaa"": ""\xe8\xbe\x9f\xe9\x82\xaa"",\n""\xe5\x8a\x9e\xe4\xbc\x99"": ""\xe8\xbe\xa6\xe4\xbc\x99"",\n""\xe5\x8a\x9e\xe5\x85\xac\xe5\x8f\xb0"": ""\xe8\xbe\xa6\xe5\x85\xac\xe6\xaa\xaf"",\n""\xe8\xbe\x9e\xe6\xb1\x87"": ""\xe8\xbe\xad\xe5\xbd\x99"",\n""\xe5\x86\x9c\xe5\x8e\x86"": ""\xe8\xbe\xb2\xe6\x9b\x86"",\n""\xe8\xbf\x82\xe5\x9b\x9e"": ""\xe8\xbf\x82\xe8\xbf\xb4"",\n""\xe8\xbf\x91\xe6\x97\xa5\xe9\x87\x8c"": ""\xe8\xbf\x91\xe6\x97\xa5\xe8\xa3\xa1"",\n""\xe8\xbf\xa5\xe7\x84\xb6\xe5\x9b\x9e\xe5\xbc\x82"": ""\xe8\xbf\xa5\xe7\x84\xb6\xe8\xbf\xb4\xe7\x95\xb0"",\n""\xe5\x9b\x9e\xe5\x85\x89\xe8\xbf\x94\xe7\x85\xa7"": ""\xe8\xbf\xb4\xe5\x85\x89\xe8\xbf\x94\xe7\x85\xa7"",\n""\xe5\x9b\x9e\xe5\x90\x91"": ""\xe8\xbf\xb4\xe5\x90\x91"",\n""\xe5\x9b\x9e\xe5\x9c\x88"": ""\xe8\xbf\xb4\xe5\x9c\x88"",\n""\xe5\x9b\x9e\xe5\xbb\x8a"": ""\xe8\xbf\xb4\xe5\xbb\x8a"",\n""\xe5\x9b\x9e\xe5\xbd\xa2\xe5\xa4\xb9"": ""\xe8\xbf\xb4\xe5\xbd\xa2\xe5\xa4\xbe"",\n""\xe5\x9b\x9e\xe6\x96\x87"": ""\xe8\xbf\xb4\xe6\x96\x87"",\n""\xe5\x9b\x9e\xe6\x97\x8b"": ""\xe8\xbf\xb4\xe6\x97\x8b"",\n""\xe5\x9b\x9e\xe6\xb5\x81"": ""\xe8\xbf\xb4\xe6\xb5\x81"",\n""\xe5\x9b\x9e\xe7\x8e\xaf"": ""\xe8\xbf\xb4\xe7\x92\xb0"",\n""\xe5\x9b\x9e\xe8\x8d\xa1"": ""\xe8\xbf\xb4\xe7\x9b\xaa"",\n""\xe5\x9b\x9e\xe7\xba\xb9\xe9\x92\x88"": ""\xe8\xbf\xb4\xe7\xb4\x8b\xe9\x87\x9d"",\n""\xe5\x9b\x9e\xe7\xbb\x95"": ""\xe8\xbf\xb4\xe7\xb9\x9e"",\n""\xe5\x9b\x9e\xe8\x82\xa0"": ""\xe8\xbf\xb4\xe8\x85\xb8"",\n""\xe5\x9b\x9e\xe8\x8d\xa1"": ""\xe8\xbf\xb4\xe8\x95\xa9"",\n""\xe5\x9b\x9e\xe8\xaf\xb5"": ""\xe8\xbf\xb4\xe8\xaa\xa6"",\n""\xe5\x9b\x9e\xe8\xb7\xaf"": ""\xe8\xbf\xb4\xe8\xb7\xaf"",\n""\xe5\x9b\x9e\xe8\xbd\xac"": ""\xe8\xbf\xb4\xe8\xbd\x89"",\n""\xe5\x9b\x9e\xe9\x80\x92\xe6\x80\xa7"": ""\xe8\xbf\xb4\xe9\x81\x9e\xe6\x80\xa7"",\n""\xe5\x9b\x9e\xe9\x81\xbf"": ""\xe8\xbf\xb4\xe9\x81\xbf"",\n""\xe5\x9b\x9e\xe5\x93\x8d"": ""\xe8\xbf\xb4\xe9\x9f\xbf"",\n""\xe5\x9b\x9e\xe9\xa3\x8e"": ""\xe8\xbf\xb4\xe9\xa2\xa8"",\n""\xe5\x9b\x9e\xe9\xa6\x96"": ""\xe8\xbf\xb4\xe9\xa6\x96"",\n""\xe8\xbf\xb7\xe8\x92\x99"": ""\xe8\xbf\xb7\xe6\xbf\x9b"",\n""\xe9\x80\x80\xe4\xbc\x99"": ""\xe9\x80\x80\xe4\xbc\x99"",\n""\xe8\xbf\x99\xe4\xb9\x88\xe7\x9d\x80"": ""\xe9\x80\x99\xe4\xb9\x88\xe8\x91\x97"",\n""\xe8\xbf\x99\xe9\x87\x8c"": ""\xe9\x80\x99\xe8\xa3\x8f"",\n""\xe8\xbf\x99\xe9\x87\x8c"": ""\xe9\x80\x99\xe8\xa3\xa1"",\n""\xe8\xbf\x99\xe5\x8f\xaa"": ""\xe9\x80\x99\xe9\x9a\xbb"",\n""\xe8\xbf\x99\xe4\xb9\x88"": ""\xe9\x80\x99\xe9\xba\xbc"",\n""\xe8\xbf\x99\xe4\xb9\x88\xe7\x9d\x80"": ""\xe9\x80\x99\xe9\xba\xbc\xe8\x91\x97"",\n""\xe9\x80\x9a\xe5\xbf\x83\xe9\x9d\xa2"": ""\xe9\x80\x9a\xe5\xbf\x83\xe9\xba\xb5"",\n""\xe9\x80\x9f\xe9\xa3\x9f\xe9\x9d\xa2"": ""\xe9\x80\x9f\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe8\xbf\x9e\xe7\xb3\xbb"": ""\xe9\x80\xa3\xe7\xb9\xab"",\n""\xe8\xbf\x9e\xe5\x8f\xb0\xe5\xa5\xbd\xe6\x88\x8f"": ""\xe9\x80\xa3\xe8\x87\xba\xe5\xa5\xbd\xe6\x88\xb2"",\n""\xe6\xb8\xb8\xe8\x8d\xa1"": ""\xe9\x81\x8a\xe8\x95\xa9"",\n""\xe9\x81\x8d\xe5\xb8\x83"": ""\xe9\x81\x8d\xe4\xbd\x88"",\n""\xe9\x80\x92\xe5\x9b\x9e"": ""\xe9\x81\x9e\xe8\xbf\xb4"",\n""\xe8\xbf\x9c\xe5\xbe\x81"": ""\xe9\x81\xa0\xe5\xbe\x81"",\n""\xe9\x80\x82\xe6\x89\x8d"": ""\xe9\x81\xa9\xe7\xba\x94"",\n""\xe9\x81\xae\xe5\xa4\x8d"": ""\xe9\x81\xae\xe8\xa6\x86"",\n""\xe8\xbf\x98\xe5\x86\xb2"": ""\xe9\x82\x84\xe8\xa1\x9d"",\n""\xe9\x82\x8b\xe9\x87\x8c\xe9\x82\x8b\xe9\x81\xa2"": ""\xe9\x82\x8b\xe8\xa3\xa1\xe9\x82\x8b\xe9\x81\xa2"",\n""\xe9\x82\xa3\xe9\x87\x8c"": ""\xe9\x82\xa3\xe8\xa3\xa1"",\n""\xe9\x82\xa3\xe5\x8f\xaa"": ""\xe9\x82\xa3\xe9\x9a\xbb"",\n""\xe9\x82\xa3\xe4\xb9\x88"": ""\xe9\x82\xa3\xe9\xba\xbc"",\n""\xe9\x82\xa3\xe4\xb9\x88\xe7\x9d\x80"": ""\xe9\x82\xa3\xe9\xba\xbc\xe8\x91\x97"",\n""\xe9\x82\xaa\xe8\xbe\x9f"": ""\xe9\x82\xaa\xe8\xbe\x9f"",\n""\xe9\x83\x81\xe7\x83\x88"": ""\xe9\x83\x81\xe7\x83\x88"",\n""\xe9\x83\x81\xe7\xa9\x86"": ""\xe9\x83\x81\xe7\xa9\x86"",\n""\xe9\x83\x81\xe9\x83\x81"": ""\xe9\x83\x81\xe9\x83\x81"",\n""\xe9\x83\x81\xe9\x97\xad"": ""\xe9\x83\x81\xe9\x96\x89"",\n""\xe9\x83\x81\xe9\xa6\xa5"": ""\xe9\x83\x81\xe9\xa6\xa5"",\n""\xe4\xb9\xa1\xe6\x84\xbf"": ""\xe9\x84\x89\xe6\x84\xbf"",\n""\xe4\xb9\xa1\xe9\x87\x8c"": ""\xe9\x84\x89\xe8\xa3\xa1"",\n""\xe9\x82\xbb\xe9\x87\x8c"": ""\xe9\x84\xb0\xe8\xa3\xa1"",\n""\xe9\x85\x8d\xe5\x90\x88\xe7\x9d\x80"": ""\xe9\x85\x8d\xe5\x90\x88\xe8\x91\x97"",\n""\xe9\x85\x8d\xe5\x88\xb6"": ""\xe9\x85\x8d\xe8\xa3\xbd"",\n""\xe9\x85\x92\xe6\x9d\xaf"": ""\xe9\x85\x92\xe7\x9b\x83"",\n""\xe9\x85\x92\xe5\x9d\x9b"": ""\xe9\x85\x92\xe7\xbd\x88"",\n""\xe9\x85\xa5\xe6\x9d\xbe"": ""\xe9\x85\xa5\xe9\xac\x86"",\n""\xe9\x86\x8b\xe5\x9d\x9b"": ""\xe9\x86\x8b\xe7\xbd\x88"",\n""\xe9\x85\x9d\xe5\x80\x9f"": ""\xe9\x86\x9e\xe8\x97\x89"",\n""\xe9\x85\x9d\xe9\x85\xbf\xe7\x9d\x80"": ""\xe9\x86\x9e\xe9\x87\x80\xe8\x91\x97"",\n""\xe5\x8c\xbb\xe8\x8d\xaf"": ""\xe9\x86\xab\xe8\x91\xaf"",\n""\xe9\x86\xb2\xe9\x83\x81"": ""\xe9\x86\xb2\xe9\x83\x81"",\n""\xe9\x85\xbf\xe5\x88\xb6"": ""\xe9\x87\x80\xe8\xa3\xbd"",\n""\xe9\x87\x87\xe5\x9c\xb0"": ""\xe9\x87\x87\xe5\x9c\xb0"",\n""\xe9\x87\x87\xe5\xa5\xb3"": ""\xe9\x87\x87\xe5\xa5\xb3"",\n""\xe9\x87\x87\xe5\xa3\xb0"": ""\xe9\x87\x87\xe8\x81\xb2"",\n""\xe9\x87\x87\xe8\x89\xb2"": ""\xe9\x87\x87\xe8\x89\xb2"",\n""\xe9\x87\x87\xe9\x82\x91"": ""\xe9\x87\x87\xe9\x82\x91"",\n""\xe9\x87\x8c\xe7\xa8\x8b\xe8\xa1\xa8"": ""\xe9\x87\x8c\xe7\xa8\x8b\xe9\x8c\xb6"",\n""\xe9\x87\x8d\xe6\x8a\x98"": ""\xe9\x87\x8d\xe6\x91\xba"",\n""\xe9\x87\x8d\xe5\xa4\x8d"": ""\xe9\x87\x8d\xe8\xa4\x87"",\n""\xe9\x87\x8d\xe5\xa4\x8d"": ""\xe9\x87\x8d\xe8\xa6\x86"",\n""\xe9\x87\x8d\xe9\x94\xa4"": ""\xe9\x87\x8d\xe9\x8e\x9a"",\n""\xe9\x87\x8e\xe5\x8f\xb0\xe6\x88\x8f"": ""\xe9\x87\x8e\xe8\x87\xba\xe6\x88\xb2"",\n""\xe9\x87\x91\xe6\x96\x97"": ""\xe9\x87\x91\xe6\x96\x97"",\n""\xe9\x87\x91\xe8\xa1\xa8"": ""\xe9\x87\x91\xe9\x8c\xb6"",\n""\xe9\x87\x91\xe5\x8f\x91"": ""\xe9\x87\x91\xe9\xab\xae"",\n""\xe9\x87\x91\xe9\x9c\x89\xe7\xb4\xa0"": ""\xe9\x87\x91\xe9\xbb\xb4\xe7\xb4\xa0"",\n""\xe9\x92\x89\xe9\x94\xa4"": ""\xe9\x87\x98\xe9\x8e\x9a"",\n""\xe9\x93\xb6\xe6\x9c\xb1"": ""\xe9\x8a\x80\xe7\xa1\x83"",\n""\xe9\x93\xb6\xe5\x8f\x91"": ""\xe9\x8a\x80\xe9\xab\xae"",\n""\xe9\x93\x9c\xe5\x88\xb6"": ""\xe9\x8a\x85\xe8\xa3\xbd"",\n""\xe9\x93\x9d\xe5\x88\xb6"": ""\xe9\x8b\x81\xe8\xa3\xbd"",\n""\xe9\x92\xa2\xe5\x88\xb6"": ""\xe9\x8b\xbc\xe8\xa3\xbd"",\n""\xe5\xbd\x95\xe7\x9d\x80"": ""\xe9\x8c\x84\xe8\x91\x97"",\n""\xe5\xbd\x95\xe5\x88\xb6"": ""\xe9\x8c\x84\xe8\xa3\xbd"",\n""\xe8\xa1\xa8\xe5\xb8\xa6"": ""\xe9\x8c\xb6\xe5\xb8\xb6"",\n""\xe8\xa1\xa8\xe5\xba\x97"": ""\xe9\x8c\xb6\xe5\xba\x97"",\n""\xe8\xa1\xa8\xe5\x8e\x82"": ""\xe9\x8c\xb6\xe5\xbb\xa0"",\n""\xe8\xa1\xa8\xe5\xa3\xb3"": ""\xe9\x8c\xb6\xe6\xae\xbc"",\n""\xe8\xa1\xa8\xe9\x93\xbe"": ""\xe9\x8c\xb6\xe9\x8f\x88"",\n""\xe8\xa1\xa8\xe9\x9d\xa2"": ""\xe9\x8c\xb6\xe9\x9d\xa2"",\n""\xe9\x94\x85\xe5\x8f\xb0"": ""\xe9\x8d\x8b\xe8\x87\xba"",\n""\xe9\x94\xbb\xe9\x8d\x8a\xe5\x87\xba"": ""\xe9\x8d\x9b\xe9\x8d\x8a\xe5\x87\xba"",\n""\xe9\x94\xbb\xe9\x8d\x8a\xe8\xba\xab\xe4\xbd\x93"": ""\xe9\x8d\x9b\xe9\x8d\x8a\xe8\xba\xab\xe4\xbd\x93"",\n""\xe9\x94\xb2\xe8\x80\x8c\xe4\xb8\x8d\xe8\x88\x8d"": ""\xe9\x8d\xa5\xe8\x80\x8c\xe4\xb8\x8d\xe6\x8d\xa8"",\n""\xe9\x94\xa4\xe5\x84\xbf"": ""\xe9\x8e\x9a\xe5\x85\x92"",\n""\xe9\x94\xa4\xe5\xad\x90"": ""\xe9\x8e\x9a\xe5\xad\x90"",\n""\xe9\x94\xa4\xe5\xa4\xb4"": ""\xe9\x8e\x9a\xe9\xa0\xad"",\n""\xe9\x93\xbe\xe9\x9c\x89\xe7\xb4\xa0"": ""\xe9\x8f\x88\xe9\xbb\xb4\xe7\xb4\xa0"",\n""\xe9\x95\x9c\xe5\x8f\xb0"": ""\xe9\x8f\xa1\xe8\x87\xba"",\n""\xe9\x94\x88\xe7\x97\x85"": ""\xe9\x8f\xbd\xe7\x97\x85"",\n""\xe9\x94\x88\xe8\x8f\x8c"": ""\xe9\x8f\xbd\xe8\x8f\x8c"",\n""\xe9\x94\x88\xe8\x9a\x80"": ""\xe9\x8f\xbd\xe8\x9d\x95"",\n""\xe9\x92\x9f\xe8\xa1\xa8"": ""\xe9\x90\x98\xe9\x8c\xb6"",\n""\xe9\x93\x81\xe9\x94\xa4"": ""\xe9\x90\xb5\xe9\x8e\x9a"",\n""\xe9\x93\x81\xe9\x94\x88"": ""\xe9\x90\xb5\xe9\x8f\xbd"",\n""\xe9\x95\xbf\xe5\xbe\x81"": ""\xe9\x95\xb7\xe5\xbe\x81"",\n""\xe9\x95\xbf\xe5\x8f\x91"": ""\xe9\x95\xb7\xe9\xab\xae"",\n""\xe9\x95\xbf\xe9\xa1\xbb\xe9\xb2\xb8"": ""\xe9\x95\xb7\xe9\xac\x9a\xe9\xaf\xa8"",\n""\xe9\x97\xa8\xe5\xb8\x98"": ""\xe9\x96\x80\xe5\xb8\x98"",\n""\xe9\x97\xa8\xe6\x96\x97"": ""\xe9\x96\x80\xe6\x96\x97"",\n""\xe9\x97\xa8\xe9\x87\x8c"": ""\xe9\x96\x80\xe8\xa3\xa1"",\n""\xe5\xbc\x80\xe4\xbc\x99"": ""\xe9\x96\x8b\xe4\xbc\x99"",\n""\xe5\xbc\x80\xe5\x8d\xb7"": ""\xe9\x96\x8b\xe5\x8d\xb7"",\n""\xe5\xbc\x80\xe8\xaf\x9a\xe5\xb8\x83\xe5\x85\xac"": ""\xe9\x96\x8b\xe8\xaa\xa0\xe4\xbd\x88\xe5\x85\xac"",\n""\xe5\xbc\x80\xe9\x87\x87"": ""\xe9\x96\x8b\xe9\x87\x87"",\n""\xe9\x96\x92\xe6\x83\x85\xe9\x80\xb8\xe8\x87\xb4"": ""\xe9\x96\x92\xe6\x83\x85\xe9\x80\xb8\xe7\xb7\xbb"",\n""\xe9\x96\x92\xe8\x8d\xa1"": ""\xe9\x96\x92\xe8\x95\xa9"",\n""\xe9\x97\xb4\xe4\xb8\x8d\xe5\xae\xb9\xe5\x8f\x91"": ""\xe9\x96\x93\xe4\xb8\x8d\xe5\xae\xb9\xe9\xab\xae"",\n""\xe9\x97\xb5\xe9\x87\x87\xe5\xb0\x94"": ""\xe9\x96\x94\xe9\x87\x87\xe7\x88\xbe"",\n""\xe9\x98\x85\xe5\x8d\xb7"": ""\xe9\x96\xb1\xe5\x8d\xb7"",\n""\xe9\x98\x91\xe5\xb9\xb2"": ""\xe9\x97\x8c\xe5\xb9\xb2"",\n""\xe5\x85\xb3\xe7\xb3\xbb"": ""\xe9\x97\x9c\xe4\xbf\x82"",\n""\xe5\x85\xb3\xe7\xb3\xbb\xe7\x9d\x80"": ""\xe9\x97\x9c\xe4\xbf\x82\xe8\x91\x97"",\n""\xe9\x98\xb2\xe5\xbe\xa1"": ""\xe9\x98\xb2\xe7\xa6\xa6"",\n""\xe9\x98\xb2\xe9\x94\x88"": ""\xe9\x98\xb2\xe9\x8f\xbd"",\n""\xe9\x98\xb2\xe5\x8f\xb0"": ""\xe9\x98\xb2\xe9\xa2\xb1"",\n""\xe9\x98\xbf\xe6\x96\x97"": ""\xe9\x98\xbf\xe6\x96\x97"",\n""\xe9\x98\xbf\xe9\x87\x8c"": ""\xe9\x98\xbf\xe8\xa3\xa1"",\n""\xe9\x99\xa4\xe6\x97\xa7\xe5\xb8\x83\xe6\x96\xb0"": ""\xe9\x99\xa4\xe8\x88\x8a\xe4\xbd\x88\xe6\x96\xb0"",\n""\xe9\x98\xb4\xe5\xb9\xb2"": ""\xe9\x99\xb0\xe5\xb9\xb2"",\n""\xe9\x98\xb4\xe5\x8e\x86"": ""\xe9\x99\xb0\xe6\x9b\x86"",\n""\xe9\x98\xb4\xe9\x83\x81"": ""\xe9\x99\xb0\xe9\x83\x81"",\n""\xe9\x99\x86\xe5\xbe\x81\xe7\xa5\xa5"": ""\xe9\x99\xb8\xe5\xbe\x81\xe7\xa5\xa5"",\n""\xe9\x98\xb3\xe6\x98\xa5\xe9\x9d\xa2"": ""\xe9\x99\xbd\xe6\x98\xa5\xe9\xba\xb5"",\n""\xe9\x98\xb3\xe5\x8e\x86"": ""\xe9\x99\xbd\xe6\x9b\x86"",\n""\xe9\x98\xb3\xe5\x8f\xb0"": ""\xe9\x99\xbd\xe8\x87\xba"",\n""\xe5\x8f\xaa\xe5\xad\x97"": ""\xe9\x9a\xbb\xe5\xad\x97"",\n""\xe5\x8f\xaa\xe5\xbd\xb1"": ""\xe9\x9a\xbb\xe5\xbd\xb1"",\n""\xe5\x8f\xaa\xe6\x89\x8b\xe9\x81\xae\xe5\xa4\xa9"": ""\xe9\x9a\xbb\xe6\x89\x8b\xe9\x81\xae\xe5\xa4\xa9"",\n""\xe5\x8f\xaa\xe7\x9c\xbc"": ""\xe9\x9a\xbb\xe7\x9c\xbc"",\n""\xe5\x8f\xaa\xe8\xa8\x80\xe7\x89\x87\xe8\xaf\xad"": ""\xe9\x9a\xbb\xe8\xa8\x80\xe7\x89\x87\xe8\xaa\x9e"",\n""\xe5\x8f\xaa\xe8\xba\xab"": ""\xe9\x9a\xbb\xe8\xba\xab"",\n""\xe9\x9b\x85\xe8\x87\xb4"": ""\xe9\x9b\x85\xe7\xb7\xbb"",\n""\xe9\x9b\x87\xe4\xbd\xa3"": ""\xe9\x9b\x87\xe4\xbd\xa3"",\n""\xe5\x8f\x8c\xe6\x8a\x98"": ""\xe9\x9b\x99\xe6\x91\xba"",\n""\xe6\x9d\x82\xe5\xbf\x97"": ""\xe9\x9b\x9c\xe8\xaa\x8c"",\n""\xe9\xb8\xa1\xe4\xb8\x9d"": ""\xe9\x9b\x9e\xe7\xb5\xb2"",\n""\xe9\xb8\xa1\xe4\xb8\x9d\xe9\x9d\xa2"": ""\xe9\x9b\x9e\xe7\xb5\xb2\xe9\xba\xb5"",\n""\xe9\xb8\xa1\xe8\x85\xbf\xe9\x9d\xa2"": ""\xe9\x9b\x9e\xe8\x85\xbf\xe9\xba\xb5"",\n""\xe9\xb8\xa1\xe5\x8f\xaa"": ""\xe9\x9b\x9e\xe9\x9a\xbb"",\n""\xe9\x9a\xbe\xe8\x88\x8d"": ""\xe9\x9b\xa3\xe6\x8d\xa8"",\n""\xe9\x9b\xaa\xe9\x87\x8c"": ""\xe9\x9b\xaa\xe8\xa3\xa1"",\n""\xe4\xba\x91\xe9\xa1\xbb"": ""\xe9\x9b\xb2\xe9\xac\x9a"",\n""\xe7\x94\xb5\xe5\xad\x90\xe8\xa1\xa8"": ""\xe9\x9b\xbb\xe5\xad\x90\xe9\x8c\xb6"",\n""\xe7\x94\xb5\xe5\x8f\xb0"": ""\xe9\x9b\xbb\xe8\x87\xba"",\n""\xe7\x94\xb5\xe5\x86\xb2"": ""\xe9\x9b\xbb\xe8\xa1\x9d"",\n""\xe7\x94\xb5\xe5\xa4\x8d"": ""\xe9\x9b\xbb\xe8\xa6\x86"",\n""\xe7\x94\xb5\xe8\xa7\x86\xe5\x8f\xb0"": ""\xe9\x9b\xbb\xe8\xa6\x96\xe8\x87\xba"",\n""\xe7\x94\xb5\xe8\xa1\xa8"": ""\xe9\x9b\xbb\xe9\x8c\xb6"",\n""\xe9\x9c\x87\xe8\x8d\xa1"": ""\xe9\x9c\x87\xe8\x95\xa9"",\n""\xe9\x9b\xbe\xe9\x87\x8c"": ""\xe9\x9c\xa7\xe8\xa3\xa1"",\n""\xe9\x9c\xb2\xe5\x8f\xb0"": ""\xe9\x9c\xb2\xe8\x87\xba"",\n""\xe7\x81\xb5\xe5\x8f\xb0"": ""\xe9\x9d\x88\xe8\x87\xba"",\n""\xe9\x9d\x92\xe7\x93\xa6\xe5\x8f\xb0"": ""\xe9\x9d\x92\xe7\x93\xa6\xe8\x87\xba"",\n""\xe9\x9d\x92\xe9\x9c\x89"": ""\xe9\x9d\x92\xe9\xbb\xb4"",\n""\xe9\x9d\xa2\xe6\x9c\x9d\xe7\x9d\x80"": ""\xe9\x9d\xa2\xe6\x9c\x9d\xe8\x91\x97"",\n""\xe9\x9d\xa2\xe4\xb8\xb4\xe7\x9d\x80"": ""\xe9\x9d\xa2\xe8\x87\xa8\xe8\x91\x97"",\n""\xe9\x9e\x8b\xe9\x87\x8c"": ""\xe9\x9e\x8b\xe8\xa3\xa1"",\n""\xe9\x9e\xa3\xe5\x88\xb6"": ""\xe9\x9e\xa3\xe8\xa3\xbd"",\n""\xe7\xa7\x8b\xe5\x8d\x83"": ""\xe9\x9e\xa6\xe9\x9f\x86"",\n""\xe9\x9e\xad\xe8\xbe\x9f\xe5\x85\xa5\xe9\x87\x8c"": ""\xe9\x9e\xad\xe8\xbe\x9f\xe5\x85\xa5\xe8\xa3\xa1"",\n""\xe9\x9f\xa9\xe5\x9b\xbd\xe5\x88\xb6"": ""\xe9\x9f\x93\xe5\x9c\x8b\xe8\xa3\xbd"",\n""\xe9\x9f\xa9\xe5\x88\xb6"": ""\xe9\x9f\x93\xe8\xa3\xbd"",\n""\xe9\xa2\x84\xe5\x88\xb6"": ""\xe9\xa0\x90\xe8\xa3\xbd"",\n""\xe9\xa2\x81\xe5\xb8\x83"": ""\xe9\xa0\x92\xe4\xbd\x88"",\n""\xe5\xa4\xb4\xe9\x87\x8c"": ""\xe9\xa0\xad\xe8\xa3\xa1"",\n""\xe5\xa4\xb4\xe5\x8f\x91"": ""\xe9\xa0\xad\xe9\xab\xae"",\n""\xe9\xa2\x8a\xe9\xa1\xbb"": ""\xe9\xa0\xb0\xe9\xac\x9a"",\n""\xe9\xa2\xa0\xe4\xbb\x86"": ""\xe9\xa1\x9b\xe4\xbb\x86"",\n""\xe9\xa2\xa0\xe5\xa4\x8d"": ""\xe9\xa1\x9b\xe8\xa4\x87"",\n""\xe9\xa2\xa0\xe5\xa4\x8d"": ""\xe9\xa1\x9b\xe8\xa6\x86"",\n""\xe6\x98\xbe\xe7\x9d\x80\xe6\xa0\x87\xe5\xbf\x97"": ""\xe9\xa1\xaf\xe8\x91\x97\xe6\xa8\x99\xe5\xbf\x97"",\n""\xe9\xa3\x8e\xe5\x9c\x9f\xe5\xbf\x97"": ""\xe9\xa2\xa8\xe5\x9c\x9f\xe8\xaa\x8c"",\n""\xe9\xa3\x8e\xe6\x96\x97"": ""\xe9\xa2\xa8\xe6\x96\x97"",\n""\xe9\xa3\x8e\xe7\x89\xa9\xe5\xbf\x97"": ""\xe9\xa2\xa8\xe7\x89\xa9\xe8\xaa\x8c"",\n""\xe9\xa3\x8e\xe9\x87\x8c"": ""\xe9\xa2\xa8\xe8\xa3\xa1"",\n""\xe9\xa3\x8e\xe9\x87\x87"": ""\xe9\xa2\xa8\xe9\x87\x87"",\n""\xe5\x8f\xb0\xe9\xa3\x8e"": ""\xe9\xa2\xb1\xe9\xa2\xa8"",\n""\xe5\x88\xae\xe4\xba\x86"": ""\xe9\xa2\xb3\xe4\xba\x86"",\n""\xe5\x88\xae\xe5\x80\x92"": ""\xe9\xa2\xb3\xe5\x80\x92"",\n""\xe5\x88\xae\xe5\x8e\xbb"": ""\xe9\xa2\xb3\xe5\x8e\xbb"",\n""\xe5\x88\xae\xe5\xbe\x97"": ""\xe9\xa2\xb3\xe5\xbe\x97"",\n""\xe5\x88\xae\xe7\x9d\x80"": ""\xe9\xa2\xb3\xe8\x91\x97"",\n""\xe5\x88\xae\xe8\xb5\xb0"": ""\xe9\xa2\xb3\xe8\xb5\xb0"",\n""\xe5\x88\xae\xe8\xb5\xb7"": ""\xe9\xa2\xb3\xe8\xb5\xb7"",\n""\xe5\x88\xae\xe9\xa3\x8e"": ""\xe9\xa2\xb3\xe9\xa2\xa8"",\n""\xe9\xa3\x98\xe8\x8d\xa1"": ""\xe9\xa3\x84\xe8\x95\xa9"",\n""\xe9\xa5\xad\xe5\x9b\xa2"": ""\xe9\xa3\xaf\xe7\xb3\xb0"",\n""\xe9\xa5\xbc\xe5\xb9\xb2"": ""\xe9\xa4\x85\xe5\xb9\xb2"",\n""\xe9\xa6\x84\xe9\xa5\xa8\xe9\x9d\xa2"": ""\xe9\xa4\x9b\xe9\xa3\xa9\xe9\xba\xb5"",\n""\xe9\xa5\xa5\xe4\xb8\x8d\xe6\x8b\xa9\xe9\xa3\x9f"": ""\xe9\xa5\x91\xe4\xb8\x8d\xe6\x93\x87\xe9\xa3\x9f"",\n""\xe9\xa5\xa5\xe5\xaf\x92"": ""\xe9\xa5\x91\xe5\xaf\x92"",\n""\xe9\xa5\xa5\xe6\xb0\x91"": ""\xe9\xa5\x91\xe6\xb0\x91"",\n""\xe9\xa5\xa5\xe6\xb8\xb4"": ""\xe9\xa5\x91\xe6\xb8\xb4"",\n""\xe9\xa5\xa5\xe6\xba\xba"": ""\xe9\xa5\x91\xe6\xba\xba"",\n""\xe9\xa5\xa5\xe8\x8d\x92"": ""\xe9\xa5\x91\xe8\x8d\x92"",\n""\xe9\xa5\xa5\xe9\xa5\xb1"": ""\xe9\xa5\x91\xe9\xa3\xbd"",\n""\xe9\xa5\xa5\xe9\xa5\xbf"": ""\xe9\xa5\x91\xe9\xa4\x93"",\n""\xe9\xa5\xa5\xe9\xa6\x91"": ""\xe9\xa5\x91\xe9\xa5\x89"",\n""\xe9\xa6\x96\xe5\xbd\x93\xe5\x85\xb6\xe5\x86\xb2"": ""\xe9\xa6\x96\xe7\x95\xb6\xe5\x85\xb6\xe8\xa1\x9d"",\n""\xe9\xa6\x99\xe9\x83\x81"": ""\xe9\xa6\x99\xe9\x83\x81"",\n""\xe9\xa6\xa5\xe9\x83\x81"": ""\xe9\xa6\xa5\xe9\x83\x81"",\n""\xe9\xa9\xac\xe9\x87\x8c"": ""\xe9\xa6\xac\xe8\xa3\xa1"",\n""\xe9\xa9\xac\xe8\xa1\xa8"": ""\xe9\xa6\xac\xe9\x8c\xb6"",\n""\xe9\xaa\x80\xe8\x8d\xa1"": ""\xe9\xa7\x98\xe8\x95\xa9"",\n""\xe8\x85\xbe\xe5\x86\xb2"": ""\xe9\xa8\xb0\xe8\xa1\x9d"",\n""\xe9\xaa\xa8\xe5\xad\x90\xe9\x87\x8c"": ""\xe9\xaa\xa8\xe5\xad\x90\xe8\xa3\xa1"",\n""\xe9\xaa\xa8\xe5\xb9\xb2"": ""\xe9\xaa\xa8\xe5\xb9\xb9"",\n""\xe9\xaa\xa8\xe7\x81\xb0\xe5\x9d\x9b"": ""\xe9\xaa\xa8\xe7\x81\xb0\xe7\xbd\x88"",\n""\xe8\x82\xae\xe8\x84\x8f"": ""\xe9\xaa\xaf\xe9\xab\x92"",\n""\xe8\x84\x8f\xe4\xb9\xb1"": ""\xe9\xab\x92\xe4\xba\x82"",\n""\xe8\x84\x8f\xe5\x85\xae\xe5\x85\xae"": ""\xe9\xab\x92\xe5\x85\xae\xe5\x85\xae"",\n""\xe8\x84\x8f\xe5\xad\x97"": ""\xe9\xab\x92\xe5\xad\x97"",\n""\xe8\x84\x8f\xe5\xbe\x97"": ""\xe9\xab\x92\xe5\xbe\x97"",\n""\xe8\x84\x8f\xe4\xb8\x9c\xe8\xa5\xbf"": ""\xe9\xab\x92\xe6\x9d\xb1\xe8\xa5\xbf"",\n""\xe8\x84\x8f\xe6\xb0\xb4"": ""\xe9\xab\x92\xe6\xb0\xb4"",\n""\xe8\x84\x8f\xe7\x9a\x84"": ""\xe9\xab\x92\xe7\x9a\x84"",\n""\xe8\x84\x8f\xe8\xaf\x9d"": ""\xe9\xab\x92\xe8\xa9\xb1"",\n""\xe8\x84\x8f\xe9\x92\xb1"": ""\xe9\xab\x92\xe9\x8c\xa2"",\n""\xe9\xab\x98\xe5\xb9\xb2"": ""\xe9\xab\x98\xe5\xb9\xb9"",\n""\xe9\xab\x98\xe5\x8f\xb0"": ""\xe9\xab\x98\xe8\x87\xba"",\n""\xe9\xab\xad\xe9\xa1\xbb"": ""\xe9\xab\xad\xe9\xac\x9a"",\n""\xe5\x8f\x91\xe5\x9e\x8b"": ""\xe9\xab\xae\xe5\x9e\x8b"",\n""\xe5\x8f\x91\xe5\xa4\xb9"": ""\xe9\xab\xae\xe5\xa4\xbe"",\n""\xe5\x8f\x91\xe5\xa6\xbb"": ""\xe9\xab\xae\xe5\xa6\xbb"",\n""\xe5\x8f\x91\xe5\xa7\x90"": ""\xe9\xab\xae\xe5\xa7\x90"",\n""\xe5\x8f\x91\xe5\xb8\xa6"": ""\xe9\xab\xae\xe5\xb8\xb6"",\n""\xe5\x8f\x91\xe5\xbb\x8a"": ""\xe9\xab\xae\xe5\xbb\x8a"",\n""\xe5\x8f\x91\xe5\xbc\x8f"": ""\xe9\xab\xae\xe5\xbc\x8f"",\n""\xe5\x8f\x91\xe6\x8c\x87"": ""\xe9\xab\xae\xe6\x8c\x87"",\n""\xe5\x8f\x91\xe6\x8d\xb2"": ""\xe9\xab\xae\xe6\x8d\xb2"",\n""\xe5\x8f\x91\xe6\xa0\xb9"": ""\xe9\xab\xae\xe6\xa0\xb9"",\n""\xe5\x8f\x91\xe6\xaf\x9b"": ""\xe9\xab\xae\xe6\xaf\x9b"",\n""\xe5\x8f\x91\xe6\xb2\xb9"": ""\xe9\xab\xae\xe6\xb2\xb9"",\n""\xe5\x8f\x91\xe7\x8a\xb6"": ""\xe9\xab\xae\xe7\x8b\x80"",\n""\xe5\x8f\x91\xe7\x9f\xad\xe5\xbf\x83\xe9\x95\xbf"": ""\xe9\xab\xae\xe7\x9f\xad\xe5\xbf\x83\xe9\x95\xb7"",\n""\xe5\x8f\x91\xe7\xab\xaf"": ""\xe9\xab\xae\xe7\xab\xaf"",\n""\xe5\x8f\x91\xe7\xbb\x93"": ""\xe9\xab\xae\xe7\xb5\x90"",\n""\xe5\x8f\x91\xe4\xb8\x9d"": ""\xe9\xab\xae\xe7\xb5\xb2"",\n""\xe5\x8f\x91\xe7\xbd\x91"": ""\xe9\xab\xae\xe7\xb6\xb2"",\n""\xe5\x8f\x91\xe8\x82\xa4"": ""\xe9\xab\xae\xe8\x86\x9a"",\n""\xe5\x8f\x91\xe8\x83\xb6"": ""\xe9\xab\xae\xe8\x86\xa0"",\n""\xe5\x8f\x91\xe8\x8f\x9c"": ""\xe9\xab\xae\xe8\x8f\x9c"",\n""\xe5\x8f\x91\xe8\x9c\xa1"": ""\xe9\xab\xae\xe8\xa0\x9f"",\n""\xe5\x8f\x91\xe8\xbe\xab"": ""\xe9\xab\xae\xe8\xbe\xae"",\n""\xe5\x8f\x91\xe9\x92\x88"": ""\xe9\xab\xae\xe9\x87\x9d"",\n""\xe5\x8f\x91\xe9\x95\xbf"": ""\xe9\xab\xae\xe9\x95\xb7"",\n""\xe5\x8f\x91\xe9\x99\x85"": ""\xe9\xab\xae\xe9\x9a\x9b"",\n""\xe5\x8f\x91\xe9\x9c\x9c"": ""\xe9\xab\xae\xe9\x9c\x9c"",\n""\xe5\x8f\x91\xe9\xab\xbb"": ""\xe9\xab\xae\xe9\xab\xbb"",\n""\xe5\x8f\x91\xe9\xac\x93"": ""\xe9\xab\xae\xe9\xac\xa2"",\n""\xe9\xac\x85\xe6\x9d\xbe"": ""\xe9\xac\x85\xe9\xac\x86"",\n""\xe6\x9d\xbe\xe4\xba\x86"": ""\xe9\xac\x86\xe4\xba\x86"",\n""\xe6\x9d\xbe\xe4\xba\x9b"": ""\xe9\xac\x86\xe4\xba\x9b"",\n""\xe6\x9d\xbe\xe5\x8a\xb2"": ""\xe9\xac\x86\xe5\x8b\x81"",\n""\xe6\x9d\xbe\xe5\x8a\xa8"": ""\xe9\xac\x86\xe5\x8b\x95"",\n""\xe6\x9d\xbe\xe5\x8f\xa3"": ""\xe9\xac\x86\xe5\x8f\xa3"",\n""\xe6\x9d\xbe\xe5\x9c\x9f"": ""\xe9\xac\x86\xe5\x9c\x9f"",\n""\xe6\x9d\xbe\xe5\xbc\x9b"": ""\xe9\xac\x86\xe5\xbc\x9b"",\n""\xe6\x9d\xbe\xe5\xbf\xab"": ""\xe9\xac\x86\xe5\xbf\xab"",\n""\xe6\x9d\xbe\xe6\x87\x88"": ""\xe9\xac\x86\xe6\x87\x88"",\n""\xe6\x9d\xbe\xe6\x89\x8b"": ""\xe9\xac\x86\xe6\x89\x8b"",\n""\xe6\x9d\xbe\xe6\x95\xa3"": ""\xe9\xac\x86\xe6\x95\xa3"",\n""\xe6\x9d\xbe\xe6\x9e\x97"": ""\xe9\xac\x86\xe6\x9e\x97"",\n""\xe6\x9d\xbe\xe6\x9f\x94"": ""\xe9\xac\x86\xe6\x9f\x94"",\n""\xe6\x9d\xbe\xe6\xaf\x9b\xe8\x99\xab"": ""\xe9\xac\x86\xe6\xaf\x9b\xe8\x9f\xb2"",\n""\xe6\x9d\xbe\xe6\xb5\xae"": ""\xe9\xac\x86\xe6\xb5\xae"",\n""\xe6\x9d\xbe\xe6\xb6\x9b"": ""\xe9\xac\x86\xe6\xbf\xa4"",\n""\xe6\x9d\xbe\xe7\xa7\x91"": ""\xe9\xac\x86\xe7\xa7\x91"",\n""\xe6\x9d\xbe\xe8\x8a\x82\xe6\xb2\xb9"": ""\xe9\xac\x86\xe7\xaf\x80\xe6\xb2\xb9"",\n""\xe6\x9d\xbe\xe7\xbb\x91"": ""\xe9\xac\x86\xe7\xb6\x81"",\n""\xe6\x9d\xbe\xe7\xb4\xa7"": ""\xe9\xac\x86\xe7\xb7\x8a"",\n""\xe6\x9d\xbe\xe7\xbc\x93"": ""\xe9\xac\x86\xe7\xb7\xa9"",\n""\xe6\x9d\xbe\xe8\x84\x86"": ""\xe9\xac\x86\xe8\x84\x86"",\n""\xe6\x9d\xbe\xe8\x84\xb1"": ""\xe9\xac\x86\xe8\x84\xab"",\n""\xe6\x9d\xbe\xe8\xb5\xb7"": ""\xe9\xac\x86\xe8\xb5\xb7"",\n""\xe6\x9d\xbe\xe8\xbd\xaf"": ""\xe9\xac\x86\xe8\xbb\x9f"",\n""\xe6\x9d\xbe\xe9\x80\x9a"": ""\xe9\xac\x86\xe9\x80\x9a"",\n""\xe6\x9d\xbe\xe5\xbc\x80"": ""\xe9\xac\x86\xe9\x96\x8b"",\n""\xe6\x9d\xbe\xe9\xa5\xbc"": ""\xe9\xac\x86\xe9\xa4\x85"",\n""\xe6\x9d\xbe\xe6\x9d\xbe"": ""\xe9\xac\x86\xe9\xac\x86"",\n""\xe9\xac\x88\xe5\x8f\x91"": ""\xe9\xac\x88\xe9\xab\xae"",\n""\xe8\x83\xa1\xe5\xad\x90"": ""\xe9\xac\x8d\xe5\xad\x90"",\n""\xe8\x83\xa1\xe6\xa2\xa2"": ""\xe9\xac\x8d\xe6\xa2\xa2"",\n""\xe8\x83\xa1\xe6\xb8\xa3"": ""\xe9\xac\x8d\xe6\xb8\xa3"",\n""\xe8\x83\xa1\xe9\xab\xad"": ""\xe9\xac\x8d\xe9\xab\xad"",\n""\xe8\x83\xa1\xe9\xa1\xbb"": ""\xe9\xac\x8d\xe9\xac\x9a"",\n""\xe9\xa1\xbb\xe6\xa0\xb9"": ""\xe9\xac\x9a\xe6\xa0\xb9"",\n""\xe9\xa1\xbb\xe6\xaf\x9b"": ""\xe9\xac\x9a\xe6\xaf\x9b"",\n""\xe9\xa1\xbb\xe7\x94\x9f"": ""\xe9\xac\x9a\xe7\x94\x9f"",\n""\xe9\xa1\xbb\xe7\x9c\x89"": ""\xe9\xac\x9a\xe7\x9c\x89"",\n""\xe9\xa1\xbb\xe5\x8f\x91"": ""\xe9\xac\x9a\xe9\xab\xae"",\n""\xe9\xa1\xbb\xe9\xa1\xbb"": ""\xe9\xac\x9a\xe9\xac\x9a"",\n""\xe9\xac\x93\xe5\x8f\x91"": ""\xe9\xac\xa2\xe9\xab\xae"",\n""\xe6\x96\x97\xe7\x9d\x80"": ""\xe9\xac\xa5\xe8\x91\x97"",\n""\xe9\x97\xb9\xe7\x9d\x80\xe7\x8e\xa9\xe5\x84\xbf"": ""\xe9\xac\xa7\xe8\x91\x97\xe7\x8e\xa9\xe5\x84\xbf"",\n""\xe9\x97\xb9\xe7\x9d\x80\xe7\x8e\xa9\xe5\x84\xbf"": ""\xe9\xac\xa7\xe8\x91\x97\xe7\x8e\xa9\xe5\x85\x92"",\n""\xe9\x83\x81\xe9\x83\x81"": ""\xe9\xac\xb1\xe9\x83\x81"",\n""\xe9\xb1\xbc\xe6\x9d\xbe"": ""\xe9\xad\x9a\xe9\xac\x86"",\n""\xe9\xb2\xb8\xe9\xa1\xbb"": ""\xe9\xaf\xa8\xe9\xac\x9a"",\n""\xe9\xb2\x87\xe9\xb1\xbc"": ""\xe9\xaf\xb0\xe9\xad\x9a"",\n""\xe9\xb9\xa4\xe5\x8f\x91"": ""\xe9\xb6\xb4\xe9\xab\xae"",\n""\xe5\x8d\xa4\xe5\x8c\x96"": ""\xe9\xb9\xb5\xe5\x8c\x96"",\n""\xe5\x8d\xa4\xe5\x91\xb3"": ""\xe9\xb9\xb5\xe5\x91\xb3"",\n""\xe5\x8d\xa4\xe6\x97\x8f"": ""\xe9\xb9\xb5\xe6\x97\x8f"",\n""\xe5\x8d\xa4\xe6\xb0\xb4"": ""\xe9\xb9\xb5\xe6\xb0\xb4"",\n""\xe5\x8d\xa4\xe6\xb1\x81"": ""\xe9\xb9\xb5\xe6\xb1\x81"",\n""\xe5\x8d\xa4\xe7\xb0\xbf"": ""\xe9\xb9\xb5\xe7\xb0\xbf"",\n""\xe5\x8d\xa4\xe7\xb4\xa0"": ""\xe9\xb9\xb5\xe7\xb4\xa0"",\n""\xe5\x8d\xa4\xe8\x8e\xbd"": ""\xe9\xb9\xb5\xe8\x8e\xbd"",\n""\xe5\x8d\xa4\xe9\x92\x9d"": ""\xe9\xb9\xb5\xe9\x88\x8d"",\n""\xe5\x92\xb8\xe5\x91\xb3"": ""\xe9\xb9\xb9\xe5\x91\xb3"",\n""\xe5\x92\xb8\xe5\x9c\x9f"": ""\xe9\xb9\xb9\xe5\x9c\x9f"",\n""\xe5\x92\xb8\xe5\xba\xa6"": ""\xe9\xb9\xb9\xe5\xba\xa6"",\n""\xe5\x92\xb8\xe5\xbe\x97"": ""\xe9\xb9\xb9\xe5\xbe\x97"",\n""\xe5\x92\xb8\xe6\xb0\xb4"": ""\xe9\xb9\xb9\xe6\xb0\xb4"",\n""\xe5\x92\xb8\xe6\xb5\xb7"": ""\xe9\xb9\xb9\xe6\xb5\xb7"",\n""\xe5\x92\xb8\xe6\xb7\xa1"": ""\xe9\xb9\xb9\xe6\xb7\xa1"",\n""\xe5\x92\xb8\xe6\xb9\x96"": ""\xe9\xb9\xb9\xe6\xb9\x96"",\n""\xe5\x92\xb8\xe6\xb1\xa4"": ""\xe9\xb9\xb9\xe6\xb9\xaf"",\n""\xe5\x92\xb8\xe7\x9a\x84"": ""\xe9\xb9\xb9\xe7\x9a\x84"",\n""\xe5\x92\xb8\xe8\x82\x89"": ""\xe9\xb9\xb9\xe8\x82\x89"",\n""\xe5\x92\xb8\xe8\x8f\x9c"": ""\xe9\xb9\xb9\xe8\x8f\x9c"",\n""\xe5\x92\xb8\xe8\x9b\x8b"": ""\xe9\xb9\xb9\xe8\x9b\x8b"",\n""\xe5\x92\xb8\xe7\x8c\xaa\xe8\x82\x89"": ""\xe9\xb9\xb9\xe8\xb1\xac\xe8\x82\x89"",\n""\xe5\x92\xb8\xe7\xb1\xbb"": ""\xe9\xb9\xb9\xe9\xa1\x9e"",\n""\xe5\x92\xb8\xe9\xb1\xbc"": ""\xe9\xb9\xb9\xe9\xad\x9a"",\n""\xe5\x92\xb8\xe9\xb8\xad\xe8\x9b\x8b"": ""\xe9\xb9\xb9\xe9\xb4\xa8\xe8\x9b\x8b"",\n""\xe5\x92\xb8\xe5\x8d\xa4"": ""\xe9\xb9\xb9\xe9\xb9\xb5"",\n""\xe5\x92\xb8\xe5\x92\xb8"": ""\xe9\xb9\xb9\xe9\xb9\xb9"",\n""\xe7\x9b\x90\xe5\x8d\xa4"": ""\xe9\xb9\xbd\xe9\xb9\xb5"",\n""\xe9\x9d\xa2\xe4\xbb\xb7"": ""\xe9\xba\xb5\xe5\x83\xb9"",\n""\xe9\x9d\xa2\xe5\x8c\x85"": ""\xe9\xba\xb5\xe5\x8c\x85"",\n""\xe9\x9d\xa2\xe5\x9b\xa2"": ""\xe9\xba\xb5\xe5\x9c\x98"",\n""\xe9\x9d\xa2\xe5\xba\x97"": ""\xe9\xba\xb5\xe5\xba\x97"",\n""\xe9\x9d\xa2\xe5\x8e\x82"": ""\xe9\xba\xb5\xe5\xbb\xa0"",\n""\xe9\x9d\xa2\xe6\x9d\x96"": ""\xe9\xba\xb5\xe6\x9d\x96"",\n""\xe9\x9d\xa2\xe6\x9d\xa1"": ""\xe9\xba\xb5\xe6\xa2\x9d"",\n""\xe9\x9d\xa2\xe7\x81\xb0"": ""\xe9\xba\xb5\xe7\x81\xb0"",\n""\xe9\x9d\xa2\xe7\x9a\xae"": ""\xe9\xba\xb5\xe7\x9a\xae"",\n""\xe9\x9d\xa2\xe7\xad\x8b"": ""\xe9\xba\xb5\xe7\xad\x8b"",\n""\xe9\x9d\xa2\xe7\xb2\x89"": ""\xe9\xba\xb5\xe7\xb2\x89"",\n""\xe9\x9d\xa2\xe7\xb3\x8a"": ""\xe9\xba\xb5\xe7\xb3\x8a"",\n""\xe9\x9d\xa2\xe7\xba\xbf"": ""\xe9\xba\xb5\xe7\xb7\x9a"",\n""\xe9\x9d\xa2\xe8\x8c\xb6"": ""\xe9\xba\xb5\xe8\x8c\xb6"",\n""\xe9\x9d\xa2\xe9\xa3\x9f"": ""\xe9\xba\xb5\xe9\xa3\x9f"",\n""\xe9\x9d\xa2\xe9\xa5\xba"": ""\xe9\xba\xb5\xe9\xa4\x83"",\n""\xe9\x9d\xa2\xe9\xa5\xbc"": ""\xe9\xba\xb5\xe9\xa4\x85"",\n""\xe9\xba\xbb\xe9\x85\xb1\xe9\x9d\xa2"": ""\xe9\xba\xbb\xe9\x86\xac\xe9\xba\xb5"",\n""\xe9\xbb\x84\xe5\x8e\x86"": ""\xe9\xbb\x83\xe6\x9b\x86"",\n""\xe9\xbb\x84\xe5\x8f\x91\xe5\x9e\x82\xe9\xab\xab"": ""\xe9\xbb\x83\xe9\xab\xae\xe5\x9e\x82\xe9\xab\xab"",\n""\xe9\xbb\x91\xe5\x8f\x91"": ""\xe9\xbb\x91\xe9\xab\xae"",\n""\xe9\xbb\x91\xe6\x9d\xbe"": ""\xe9\xbb\x91\xe9\xac\x86"",\n""\xe9\x9c\x89\xe6\xaf\x92"": ""\xe9\xbb\xb4\xe6\xaf\x92"",\n""\xe9\x9c\x89\xe8\x8f\x8c"": ""\xe9\xbb\xb4\xe8\x8f\x8c"",\n""\xe9\xbc\x93\xe9\x87\x8c"": ""\xe9\xbc\x93\xe8\xa3\xa1"",\n""\xe5\x86\xac\xe5\x86\xac"": ""\xe9\xbc\x95\xe9\xbc\x95"",\n""\xe9\xbe\x99\xe5\x8d\xb7"": ""\xe9\xbe\x8d\xe5\x8d\xb7"",\n""\xe9\xbe\x99\xe9\xa1\xbb"": ""\xe9\xbe\x8d\xe9\xac\x9a"",\n}\n\nzh2Hans = {\n\'\xe9\xa1\xaf\xe8\x91\x97\': \'\xe6\x98\xbe\xe8\x91\x97\',\n\'\xe5\x9c\x9f\xe8\x91\x97\': \'\xe5\x9c\x9f\xe8\x91\x97\',\n\'\xe5\x8d\xb0\xe8\xa1\xa8\xe6\xa9\x9f\': \'\xe6\x89\x93\xe5\x8d\xb0\xe6\x9c\xba\',\n\'\xe8\xaa\xaa\xe6\x98\x8e\xe6\xaa\x94\xe6\xa1\x88\': \'\xe5\xb8\xae\xe5\x8a\xa9\xe6\x96\x87\xe4\xbb\xb6\',\n""\xe7\x80\x8b"": ""\xe6\xb2\x88"",\n""\xe7\x95\xab"": ""\xe5\x88\x92"",\n""\xe9\x8d\xbe"": ""\xe9\x92\x9f"",\n""\xe9\x9d\xa6"": ""\xe8\x85\xbc"",\n""\xe9\xa4\x98"": ""\xe4\xbd\x99"",\n""\xe9\xaf\xb0"": ""\xe9\xb2\x87"",\n""\xe9\xb9\xbc"": ""\xe7\xa2\xb1"",\n""\xe3\xa0\x8f"": ""\xe3\x9f\x86"",\n""\xf0\xa1\x9e\xb5"": ""\xe3\x9b\x9f"",\n""\xe4\xb8\x87"": ""\xe4\xb8\x87"",\n""\xe4\xb8\x8e"": ""\xe4\xb8\x8e"",\n""\xe4\xb8\x91"": ""\xe4\xb8\x91"",\n""\xe4\xb8\x9f"": ""\xe4\xb8\xa2"",\n""\xe4\xb8\xa6"": ""\xe5\xb9\xb6"",\n""\xe4\xb8\xb0"": ""\xe4\xb8\xb0"",\n""\xe4\xb9\x88"": ""\xe4\xb9\x88"",\n""\xe4\xb9\xbe"": ""\xe5\xb9\xb2"",\n""\xe4\xb9\xbe\xe5\x9d\xa4"": ""\xe4\xb9\xbe\xe5\x9d\xa4"",\n""\xe4\xb9\xbe\xe9\x9a\x86"": ""\xe4\xb9\xbe\xe9\x9a\x86"",\n""\xe4\xba\x82"": ""\xe4\xb9\xb1"",\n""\xe4\xba\x91"": ""\xe4\xba\x91"",\n""\xe4\xba\x99"": ""\xe4\xba\x98"",\n""\xe4\xba\x9e"": ""\xe4\xba\x9a"",\n""\xe4\xbb\x86"": ""\xe4\xbb\x86"",\n""\xe4\xbb\xb7"": ""\xe4\xbb\xb7"",\n""\xe4\xbc\x99"": ""\xe4\xbc\x99"",\n""\xe4\xbd\x87"": ""\xe4\xbc\xab"",\n""\xe4\xbd\x88"": ""\xe5\xb8\x83"",\n""\xe4\xbd\x93"": ""\xe4\xbd\x93"",\n""\xe4\xbd\x99"": ""\xe4\xbd\x99"",\n""\xe4\xbd\x99"": ""\xe9\xa6\x80"",\n""\xe4\xbd\xa3"": ""\xe4\xbd\xa3"",\n""\xe4\xbd\xb5"": ""\xe5\xb9\xb6"",\n""\xe4\xbe\x86"": ""\xe6\x9d\xa5"",\n""\xe4\xbe\x96"": ""\xe4\xbb\x91"",\n""\xe4\xbe\xb6"": ""\xe4\xbe\xa3"",\n""\xe4\xbf\x81"": ""\xe4\xbf\xa3"",\n""\xe4\xbf\x82"": ""\xe7\xb3\xbb"",\n""\xe4\xbf\x94"": ""\xe4\xbc\xa3"",\n""\xe4\xbf\xa0"": ""\xe4\xbe\xa0"",\n""\xe5\x80\x80"": ""\xe4\xbc\xa5"",\n""\xe5\x80\x86"": ""\xe4\xbf\xa9"",\n""\xe5\x80\x88"": ""\xe4\xbf\xab"",\n""\xe5\x80\x89"": ""\xe4\xbb\x93"",\n""\xe5\x80\x8b"": ""\xe4\xb8\xaa"",\n""\xe5\x80\x91"": ""\xe4\xbb\xac"",\n""\xe5\x80\xab"": ""\xe4\xbc\xa6"",\n""\xe5\x81\x89"": ""\xe4\xbc\x9f"",\n""\xe5\x81\xb4"": ""\xe4\xbe\xa7"",\n""\xe5\x81\xb5"": ""\xe4\xbe\xa6"",\n""\xe5\x81\xbd"": ""\xe4\xbc\xaa"",\n""\xe5\x82\x91"": ""\xe6\x9d\xb0"",\n""\xe5\x82\x96"": ""\xe4\xbc\xa7"",\n""\xe5\x82\x98"": ""\xe4\xbc\x9e"",\n""\xe5\x82\x99"": ""\xe5\xa4\x87"",\n""\xe5\x82\xa2"": ""\xe5\xae\xb6"",\n""\xe5\x82\xad"": ""\xe4\xbd\xa3"",\n""\xe5\x82\xaf"": ""\xe5\x81\xac"",\n""\xe5\x82\xb3"": ""\xe4\xbc\xa0"",\n""\xe5\x82\xb4"": ""\xe4\xbc\x9b"",\n""\xe5\x82\xb5"": ""\xe5\x80\xba"",\n""\xe5\x82\xb7"": ""\xe4\xbc\xa4"",\n""\xe5\x82\xbe"": ""\xe5\x80\xbe"",\n""\xe5\x83\x82"": ""\xe5\x81\xbb"",\n""\xe5\x83\x85"": ""\xe4\xbb\x85"",\n""\xe5\x83\x89"": ""\xe4\xbd\xa5"",\n""\xe5\x83\x91"": ""\xe4\xbe\xa8"",\n""\xe5\x83\x95"": ""\xe4\xbb\x86"",\n""\xe5\x83\x9e"": ""\xe4\xbc\xaa"",\n""\xe5\x83\xa5"": ""\xe4\xbe\xa5"",\n""\xe5\x83\xa8"": ""\xe5\x81\xbe"",\n""\xe5\x83\xb9"": ""\xe4\xbb\xb7"",\n""\xe5\x84\x80"": ""\xe4\xbb\xaa"",\n""\xe5\x84\x82"": ""\xe4\xbe\xac"",\n""\xe5\x84\x84"": ""\xe4\xba\xbf"",\n""\xe5\x84\x88"": ""\xe4\xbe\xa9"",\n""\xe5\x84\x89"": ""\xe4\xbf\xad"",\n""\xe5\x84\x90"": ""\xe5\x82\xa7"",\n""\xe5\x84\x94"": ""\xe4\xbf\xa6"",\n""\xe5\x84\x95"": ""\xe4\xbe\xaa"",\n""\xe5\x84\x98"": ""\xe5\xb0\xbd"",\n""\xe5\x84\x9f"": ""\xe5\x81\xbf"",\n""\xe5\x84\xaa"": ""\xe4\xbc\x98"",\n""\xe5\x84\xb2"": ""\xe5\x82\xa8"",\n""\xe5\x84\xb7"": ""\xe4\xbf\xaa"",\n""\xe5\x84\xb8"": ""\xe3\x91\xa9"",\n""\xe5\x84\xba"": ""\xe5\x82\xa9"",\n""\xe5\x84\xbb"": ""\xe5\x82\xa5"",\n""\xe5\x84\xbc"": ""\xe4\xbf\xa8"",\n""\xe5\x84\xbf"": ""\xe5\x84\xbf"",\n""\xe5\x85\x87"": ""\xe5\x87\xb6"",\n""\xe5\x85\x8c"": ""\xe5\x85\x91"",\n""\xe5\x85\x92"": ""\xe5\x84\xbf"",\n""\xe5\x85\x97"": ""\xe5\x85\x96"",\n""\xe5\x85\x9a"": ""\xe5\x85\x9a"",\n""\xe5\x85\xa7"": ""\xe5\x86\x85"",\n""\xe5\x85\xa9"": ""\xe4\xb8\xa4"",\n""\xe5\x86\x8a"": ""\xe5\x86\x8c"",\n""\xe5\x86\xaa"": ""\xe5\xb9\x82"",\n""\xe5\x87\x86"": ""\xe5\x87\x86"",\n""\xe5\x87\x88"": ""\xe5\x87\x80"",\n""\xe5\x87\x8d"": ""\xe5\x86\xbb"",\n""\xe5\x87\x9c"": ""\xe5\x87\x9b"",\n""\xe5\x87\xa0"": ""\xe5\x87\xa0"",\n""\xe5\x87\xb1"": ""\xe5\x87\xaf"",\n""\xe5\x88\x92"": ""\xe5\x88\x92"",\n""\xe5\x88\xa5"": ""\xe5\x88\xab"",\n""\xe5\x88\xaa"": ""\xe5\x88\xa0"",\n""\xe5\x89\x84"": ""\xe5\x88\xad"",\n""\xe5\x89\x87"": ""\xe5\x88\x99"",\n""\xe5\x89\x8b"": ""\xe5\x85\x8b"",\n""\xe5\x89\x8e"": ""\xe5\x88\xb9"",\n""\xe5\x89\x97"": ""\xe5\x88\xac"",\n""\xe5\x89\x9b"": ""\xe5\x88\x9a"",\n""\xe5\x89\x9d"": ""\xe5\x89\xa5"",\n""\xe5\x89\xae"": ""\xe5\x89\x90"",\n""\xe5\x89\xb4"": ""\xe5\x89\x80"",\n""\xe5\x89\xb5"": ""\xe5\x88\x9b"",\n""\xe5\x8a\x83"": ""\xe5\x88\x92"",\n""\xe5\x8a\x87"": ""\xe5\x89\xa7"",\n""\xe5\x8a\x89"": ""\xe5\x88\x98"",\n""\xe5\x8a\x8a"": ""\xe5\x88\xbd"",\n""\xe5\x8a\x8c"": ""\xe5\x88\xbf"",\n""\xe5\x8a\x8d"": ""\xe5\x89\x91"",\n""\xe5\x8a\x8f"": ""\xe3\x93\xa5"",\n""\xe5\x8a\x91"": ""\xe5\x89\x82"",\n""\xe5\x8a\x9a"": ""\xe3\x94\x89"",\n""\xe5\x8b\x81"": ""\xe5\x8a\xb2"",\n""\xe5\x8b\x95"": ""\xe5\x8a\xa8"",\n""\xe5\x8b\x99"": ""\xe5\x8a\xa1"",\n""\xe5\x8b\x9b"": ""\xe5\x8b\x8b"",\n""\xe5\x8b\x9d"": ""\xe8\x83\x9c"",\n""\xe5\x8b\x9e"": ""\xe5\x8a\xb3"",\n""\xe5\x8b\xa2"": ""\xe5\x8a\xbf"",\n""\xe5\x8b\xa9"": ""\xe5\x8b\x9a"",\n""\xe5\x8b\xb1"": ""\xe5\x8a\xa2"",\n""\xe5\x8b\xb5"": ""\xe5\x8a\xb1"",\n""\xe5\x8b\xb8"": ""\xe5\x8a\x9d"",\n""\xe5\x8b\xbb"": ""\xe5\x8c\x80"",\n""\xe5\x8c\xad"": ""\xe5\x8c\xa6"",\n""\xe5\x8c\xaf"": ""\xe6\xb1\x87"",\n""\xe5\x8c\xb1"": ""\xe5\x8c\xae"",\n""\xe5\x8d\x80"": ""\xe5\x8c\xba"",\n""\xe5\x8d\x94"": ""\xe5\x8d\x8f"",\n""\xe5\x8d\xb7"": ""\xe5\x8d\xb7"",\n""\xe5\x8d\xbb"": ""\xe5\x8d\xb4"",\n""\xe5\x8e\x82"": ""\xe5\x8e\x82"",\n""\xe5\x8e\x99"": ""\xe5\x8e\x8d"",\n""\xe5\x8e\xa0"": ""\xe5\x8e\x95"",\n""\xe5\x8e\xad"": ""\xe5\x8e\x8c"",\n""\xe5\x8e\xb2"": ""\xe5\x8e\x89"",\n""\xe5\x8e\xb4"": ""\xe5\x8e\xa3"",\n""\xe5\x8f\x83"": ""\xe5\x8f\x82"",\n""\xe5\x8f\x84"": ""\xe5\x8f\x81"",\n""\xe5\x8f\xa2"": ""\xe4\xb8\x9b"",\n""\xe5\x8f\xb0"": ""\xe5\x8f\xb0"",\n""\xe5\x8f\xb6"": ""\xe5\x8f\xb6"",\n""\xe5\x90\x8a"": ""\xe5\x90\x8a"",\n""\xe5\x90\x8e"": ""\xe5\x90\x8e"",\n""\xe5\x90\x92"": ""\xe5\x92\xa4"",\n""\xe5\x90\xb3"": ""\xe5\x90\xb4"",\n""\xe5\x90\xb6"": ""\xe5\x91\x90"",\n""\xe5\x91\x82"": ""\xe5\x90\x95"",\n""\xe7\x8d\x83"": ""\xe5\x91\x86"",\n""\xe5\x92\xbc"": ""\xe5\x91\x99"",\n""\xe5\x93\xa1"": ""\xe5\x91\x98"",\n""\xe5\x94\x84"": ""\xe5\x91\x97"",\n""\xe5\x94\x9a"": ""\xe5\x90\xa3"",\n""\xe5\x95\x8f"": ""\xe9\x97\xae"",\n""\xe5\x95\x93"": ""\xe5\x90\xaf"",\n""\xe5\x95\x9e"": ""\xe5\x93\x91"",\n""\xe5\x95\x9f"": ""\xe5\x90\xaf"",\n""\xe5\x95\xa2"": ""\xe5\x94\xa1"",\n""\xe5\x96\x8e"": ""\xe3\x96\x9e"",\n""\xe5\x96\x9a"": ""\xe5\x94\xa4"",\n""\xe5\x96\xaa"": ""\xe4\xb8\xa7"",\n""\xe5\x96\xac"": ""\xe4\xb9\x94"",\n""\xe5\x96\xae"": ""\xe5\x8d\x95"",\n""\xe5\x96\xb2"": ""\xe5\x93\x9f"",\n""\xe5\x97\x86"": ""\xe5\x91\x9b"",\n""\xe5\x97\x87"": ""\xe5\x95\xac"",\n""\xe5\x97\x8a"": ""\xe5\x94\x9d"",\n""\xe5\x97\x8e"": ""\xe5\x90\x97"",\n""\xe5\x97\x9a"": ""\xe5\x91\x9c"",\n""\xe5\x97\xa9"": ""\xe5\x94\xa2"",\n""\xe5\x97\xb6"": ""\xe5\x93\x94"",\n""\xe5\x98\x86"": ""\xe5\x8f\xb9"",\n""\xe5\x98\x8d"": ""\xe5\x96\xbd"",\n""\xe5\x98\x94"": ""\xe5\x91\x95"",\n""\xe5\x98\x96"": ""\xe5\x95\xa7"",\n""\xe5\x98\x97"": ""\xe5\xb0\x9d"",\n""\xe5\x98\x9c"": ""\xe5\x94\x9b"",\n""\xe5\x98\xa9"": ""\xe5\x93\x97"",\n""\xe5\x98\xae"": ""\xe5\x94\xa0"",\n""\xe5\x98\xaf"": ""\xe5\x95\xb8"",\n""\xe5\x98\xb0"": ""\xe5\x8f\xbd"",\n""\xe5\x98\xb5"": ""\xe5\x93\x93"",\n""\xe5\x98\xb8"": ""\xe5\x91\x92"",\n""\xe5\x98\xbd"": ""\xe5\x95\xb4"",\n""\xe5\x99\x81"": ""\xe6\x81\xb6"",\n""\xe5\x99\x93"": ""\xe5\x98\x98"",\n""\xe5\x99\x9a"": ""\xe3\x96\x8a"",\n""\xe5\x99\x9d"": ""\xe5\x92\x9d"",\n""\xe5\x99\xa0"": ""\xe5\x93\x92"",\n""\xe5\x99\xa5"": ""\xe5\x93\x9d"",\n""\xe5\x99\xa6"": ""\xe5\x93\x95"",\n""\xe5\x99\xaf"": ""\xe5\x97\xb3"",\n""\xe5\x99\xb2"": ""\xe5\x93\x99"",\n""\xe5\x99\xb4"": ""\xe5\x96\xb7"",\n""\xe5\x99\xb8"": ""\xe5\x90\xa8"",\n""\xe5\x99\xb9"": ""\xe5\xbd\x93"",\n""\xe5\x9a\x80"": ""\xe5\x92\x9b"",\n""\xe5\x9a\x87"": ""\xe5\x90\x93"",\n""\xe5\x9a\x8c"": ""\xe5\x93\x9c"",\n""\xe5\x9a\x95"": ""\xe5\x99\x9c"",\n""\xe5\x9a\x99"": ""\xe5\x95\xae"",\n""\xe5\x9a\xa5"": ""\xe5\x92\xbd"",\n""\xe5\x9a\xa6"": ""\xe5\x91\x96"",\n""\xe5\x9a\xa8"": ""\xe5\x92\x99"",\n""\xe5\x9a\xae"": ""\xe5\x90\x91"",\n""\xe5\x9a\xb2"": ""\xe4\xba\xb8"",\n""\xe5\x9a\xb3"": ""\xe5\x96\xbe"",\n""\xe5\x9a\xb4"": ""\xe4\xb8\xa5"",\n""\xe5\x9a\xb6"": ""\xe5\x98\xa4"",\n""\xe5\x9b\x80"": ""\xe5\x95\xad"",\n""\xe5\x9b\x81"": ""\xe5\x97\xab"",\n""\xe5\x9b\x82"": ""\xe5\x9a\xa3"",\n""\xe5\x9b\x85"": ""\xe5\x86\x81"",\n""\xe5\x9b\x88"": ""\xe5\x91\x93"",\n""\xe5\x9b\x8c"": ""\xe8\x8b\x8f"",\n""\xe5\x9b\x91"": ""\xe5\x98\xb1"",\n""\xe5\x9b\xaa"": ""\xe5\x9b\xb1"",\n""\xe5\x9c\x87"": ""\xe5\x9b\xb5"",\n""\xe5\x9c\x8b"": ""\xe5\x9b\xbd"",\n""\xe5\x9c\x8d"": ""\xe5\x9b\xb4"",\n""\xe5\x9c\x92"": ""\xe5\x9b\xad"",\n""\xe5\x9c\x93"": ""\xe5\x9c\x86"",\n""\xe5\x9c\x96"": ""\xe5\x9b\xbe"",\n""\xe5\x9c\x98"": ""\xe5\x9b\xa2"",\n""\xe5\x9d\x8f"": ""\xe5\x9d\x8f"",\n""\xe5\x9e\xb5"": ""\xe5\x9f\xaf"",\n""\xe5\x9f\xa1"": ""\xe5\x9e\xad"",\n""\xe5\x9f\xb0"": ""\xe9\x87\x87"",\n""\xe5\x9f\xb7"": ""\xe6\x89\xa7"",\n""\xe5\xa0\x85"": ""\xe5\x9d\x9a"",\n""\xe5\xa0\x8a"": ""\xe5\x9e\xa9"",\n""\xe5\xa0\x96"": ""\xe5\x9e\xb4"",\n""\xe5\xa0\x9d"": ""\xe5\x9f\x9a"",\n""\xe5\xa0\xaf"": ""\xe5\xb0\xa7"",\n""\xe5\xa0\xb1"": ""\xe6\x8a\xa5"",\n""\xe5\xa0\xb4"": ""\xe5\x9c\xba"",\n""\xe5\xa1\x8a"": ""\xe5\x9d\x97"",\n""\xe5\xa1\x8b"": ""\xe8\x8c\x94"",\n""\xe5\xa1\x8f"": ""\xe5\x9e\xb2"",\n""\xe5\xa1\x92"": ""\xe5\x9f\x98"",\n""\xe5\xa1\x97"": ""\xe6\xb6\x82"",\n""\xe5\xa1\x9a"": ""\xe5\x86\xa2"",\n""\xe5\xa1\xa2"": ""\xe5\x9d\x9e"",\n""\xe5\xa1\xa4"": ""\xe5\x9f\x99"",\n""\xe5\xa1\xb5"": ""\xe5\xb0\x98"",\n""\xe5\xa1\xb9"": ""\xe5\xa0\x91"",\n""\xe5\xa2\x8a"": ""\xe5\x9e\xab"",\n""\xe5\xa2\x9c"": ""\xe5\x9d\xa0"",\n""\xe5\xa2\xae"": ""\xe5\xa0\x95"",\n""\xe5\xa2\xb3"": ""\xe5\x9d\x9f"",\n""\xe5\xa2\xbb"": ""\xe5\xa2\x99"",\n""\xe5\xa2\xbe"": ""\xe5\x9e\xa6"",\n""\xe5\xa3\x87"": ""\xe5\x9d\x9b"",\n""\xe5\xa3\x88"": ""\xf0\xa1\x92\x84"",\n""\xe5\xa3\x8b"": ""\xe5\x9e\xb1"",\n""\xe5\xa3\x93"": ""\xe5\x8e\x8b"",\n""\xe5\xa3\x98"": ""\xe5\x9e\x92"",\n""\xe5\xa3\x99"": ""\xe5\x9c\xb9"",\n""\xe5\xa3\x9a"": ""\xe5\x9e\x86"",\n""\xe5\xa3\x9e"": ""\xe5\x9d\x8f"",\n""\xe5\xa3\x9f"": ""\xe5\x9e\x84"",\n""\xe5\xa3\xa0"": ""\xe5\x9e\x85"",\n""\xe5\xa3\xa2"": ""\xe5\x9d\x9c"",\n""\xe5\xa3\xa9"": ""\xe5\x9d\x9d"",\n""\xe5\xa3\xaf"": ""\xe5\xa3\xae"",\n""\xe5\xa3\xba"": ""\xe5\xa3\xb6"",\n""\xe5\xa3\xbc"": ""\xe5\xa3\xb8"",\n""\xe5\xa3\xbd"": ""\xe5\xaf\xbf"",\n""\xe5\xa4\xa0"": ""\xe5\xa4\x9f"",\n""\xe5\xa4\xa2"": ""\xe6\xa2\xa6"",\n""\xe5\xa4\xbe"": ""\xe5\xa4\xb9"",\n""\xe5\xa5\x90"": ""\xe5\xa5\x82"",\n""\xe5\xa5\xa7"": ""\xe5\xa5\xa5"",\n""\xe5\xa5\xa9"": ""\xe5\xa5\x81"",\n""\xe5\xa5\xaa"": ""\xe5\xa4\xba"",\n""\xe5\xa5\xac"": ""\xe5\xa5\x96"",\n""\xe5\xa5\xae"": ""\xe5\xa5\x8b"",\n""\xe5\xa5\xbc"": ""\xe5\xa7\xb9"",\n""\xe5\xa6\x9d"": ""\xe5\xa6\x86"",\n""\xe5\xa7\x8d"": ""\xe5\xa7\x97"",\n""\xe5\xa7\x9c"": ""\xe5\xa7\x9c"",\n""\xe5\xa7\xa6"": ""\xe5\xa5\xb8"",\n""\xe5\xa8\x9b"": ""\xe5\xa8\xb1"",\n""\xe5\xa9\x81"": ""\xe5\xa8\x84"",\n""\xe5\xa9\xa6"": ""\xe5\xa6\x87"",\n""\xe5\xa9\xad"": ""\xe5\xa8\x85"",\n""\xe5\xaa\xa7"": ""\xe5\xa8\xb2"",\n""\xe5\xaa\xaf"": ""\xe5\xa6\xab"",\n""\xe5\xaa\xbc"": ""\xe5\xaa\xaa"",\n""\xe5\xaa\xbd"": ""\xe5\xa6\x88"",\n""\xe5\xab\x97"": ""\xe5\xa6\xaa"",\n""\xe5\xab\xb5"": ""\xe5\xa6\xa9"",\n""\xe5\xab\xbb"": ""\xe5\xa8\xb4"",\n""\xe5\xab\xbf"": ""\xe5\xa9\xb3"",\n""\xe5\xac\x80"": ""\xe5\xa6\xab"",\n""\xe5\xac\x88"": ""\xe5\xa8\x86"",\n""\xe5\xac\x8b"": ""\xe5\xa9\xb5"",\n""\xe5\xac\x8c"": ""\xe5\xa8\x87"",\n""\xe5\xac\x99"": ""\xe5\xab\xb1"",\n""\xe5\xac\xa1"": ""\xe5\xab\x92"",\n""\xe5\xac\xa4"": ""\xe5\xac\xb7"",\n""\xe5\xac\xaa"": ""\xe5\xab\x94"",\n""\xe5\xac\xb0"": ""\xe5\xa9\xb4"",\n""\xe5\xac\xb8"": ""\xe5\xa9\xb6"",\n""\xe5\xad\x8c"": ""\xe5\xa8\x88"",\n""\xe5\xad\xab"": ""\xe5\xad\x99"",\n""\xe5\xad\xb8"": ""\xe5\xad\xa6"",\n""\xe5\xad\xbf"": ""\xe5\xad\xaa"",\n""\xe5\xae\x81"": ""\xe5\xae\x81"",\n""\xe5\xae\xae"": ""\xe5\xae\xab"",\n""\xe5\xaf\xa2"": ""\xe5\xaf\x9d"",\n""\xe5\xaf\xa6"": ""\xe5\xae\x9e"",\n""\xe5\xaf\xa7"": ""\xe5\xae\x81"",\n""\xe5\xaf\xa9"": ""\xe5\xae\xa1"",\n""\xe5\xaf\xab"": ""\xe5\x86\x99"",\n""\xe5\xaf\xac"": ""\xe5\xae\xbd"",\n""\xe5\xaf\xb5"": ""\xe5\xae\xa0"",\n""\xe5\xaf\xb6"": ""\xe5\xae\x9d"",\n""\xe5\xb0\x87"": ""\xe5\xb0\x86"",\n""\xe5\xb0\x88"": ""\xe4\xb8\x93"",\n""\xe5\xb0\x8b"": ""\xe5\xaf\xbb"",\n""\xe5\xb0\x8d"": ""\xe5\xaf\xb9"",\n""\xe5\xb0\x8e"": ""\xe5\xaf\xbc"",\n""\xe5\xb0\xb7"": ""\xe5\xb0\xb4"",\n""\xe5\xb1\x86"": ""\xe5\xb1\x8a"",\n""\xe5\xb1\x8d"": ""\xe5\xb0\xb8"",\n""\xe5\xb1\x93"": ""\xe5\xb1\x83"",\n""\xe5\xb1\x9c"": ""\xe5\xb1\x89"",\n""\xe5\xb1\xa2"": ""\xe5\xb1\xa1"",\n""\xe5\xb1\xa4"": ""\xe5\xb1\x82"",\n""\xe5\xb1\xa8"": ""\xe5\xb1\xa6"",\n""\xe5\xb1\xac"": ""\xe5\xb1\x9e"",\n""\xe5\xb2\xa1"": ""\xe5\x86\x88"",\n""\xe5\xb3\xb4"": ""\xe5\xb2\x98"",\n""\xe5\xb3\xb6"": ""\xe5\xb2\x9b"",\n""\xe5\xb3\xbd"": ""\xe5\xb3\xa1"",\n""\xe5\xb4\x8d"": ""\xe5\xb4\x83"",\n""\xe5\xb4\x97"": ""\xe5\xb2\x97"",\n""\xe5\xb4\xa2"": ""\xe5\xb3\xa5"",\n""\xe5\xb4\xac"": ""\xe5\xb2\xbd"",\n""\xe5\xb5\x90"": ""\xe5\xb2\x9a"",\n""\xe5\xb6\x81"": ""\xe5\xb5\x9d"",\n""\xe5\xb6\x84"": ""\xe5\xb4\xad"",\n""\xe5\xb6\x87"": ""\xe5\xb2\x96"",\n""\xe5\xb6\x94"": ""\xe5\xb5\x9a"",\n""\xe5\xb6\x97"": ""\xe5\xb4\x82"",\n""\xe5\xb6\xa0"": ""\xe5\xb3\xa4"",\n""\xe5\xb6\xa2"": ""\xe5\xb3\xa3"",\n""\xe5\xb6\xa7"": ""\xe5\xb3\x84"",\n""\xe5\xb6\xae"": ""\xe5\xb4\x84"",\n""\xe5\xb6\xb4"": ""\xe5\xb2\x99"",\n""\xe5\xb6\xb8"": ""\xe5\xb5\x98"",\n""\xe5\xb6\xba"": ""\xe5\xb2\xad"",\n""\xe5\xb6\xbc"": ""\xe5\xb1\xbf"",\n""\xe5\xb6\xbd"": ""\xe5\xb2\xb3"",\n""\xe5\xb7\x8b"": ""\xe5\xb2\xbf"",\n""\xe5\xb7\x92"": ""\xe5\xb3\xa6"",\n""\xe5\xb7\x94"": ""\xe5\xb7\x85"",\n""\xe5\xb7\xb0"": ""\xe5\xb7\xaf"",\n""\xe5\xb8\x98"": ""\xe5\xb8\x98"",\n""\xe5\xb8\xa5"": ""\xe5\xb8\x85"",\n""\xe5\xb8\xab"": ""\xe5\xb8\x88"",\n""\xe5\xb8\xb3"": ""\xe5\xb8\x90"",\n""\xe5\xb8\xb6"": ""\xe5\xb8\xa6"",\n""\xe5\xb9\x80"": ""\xe5\xb8\xa7"",\n""\xe5\xb9\x83"": ""\xe5\xb8\x8f"",\n""\xe5\xb9\x97"": ""\xe5\xb8\xbc"",\n""\xe5\xb9\x98"": ""\xe5\xb8\xbb"",\n""\xe5\xb9\x9f"": ""\xe5\xb8\x9c"",\n""\xe5\xb9\xa3"": ""\xe5\xb8\x81"",\n""\xe5\xb9\xab"": ""\xe5\xb8\xae"",\n""\xe5\xb9\xac"": ""\xe5\xb8\xb1"",\n""\xe5\xb9\xb9"": ""\xe5\xb9\xb2"",\n""\xe5\xb9\xba"": ""\xe4\xb9\x88"",\n""\xe5\xb9\xbe"": ""\xe5\x87\xa0"",\n""\xe5\xb9\xbf"": ""\xe5\xb9\xbf"",\n""\xe5\xba\xab"": ""\xe5\xba\x93"",\n""\xe5\xbb\x81"": ""\xe5\x8e\x95"",\n""\xe5\xbb\x82"": ""\xe5\x8e\xa2"",\n""\xe5\xbb\x84"": ""\xe5\x8e\xa9"",\n""\xe5\xbb\x88"": ""\xe5\x8e\xa6"",\n""\xe5\xbb\x9a"": ""\xe5\x8e\xa8"",\n""\xe5\xbb\x9d"": ""\xe5\x8e\xae"",\n""\xe5\xbb\x9f"": ""\xe5\xba\x99"",\n""\xe5\xbb\xa0"": ""\xe5\x8e\x82"",\n""\xe5\xbb\xa1"": ""\xe5\xba\x91"",\n""\xe5\xbb\xa2"": ""\xe5\xba\x9f"",\n""\xe5\xbb\xa3"": ""\xe5\xb9\xbf"",\n""\xe5\xbb\xa9"": ""\xe5\xbb\xaa"",\n""\xe5\xbb\xac"": ""\xe5\xba\x90"",\n""\xe5\xbb\xb3"": ""\xe5\x8e\x85"",\n""\xe5\xbc\x92"": ""\xe5\xbc\x91"",\n""\xe5\xbc\xb3"": ""\xe5\xbc\xaa"",\n""\xe5\xbc\xb5"": ""\xe5\xbc\xa0"",\n""\xe5\xbc\xb7"": ""\xe5\xbc\xba"",\n""\xe5\xbd\x86"": ""\xe5\x88\xab"",\n""\xe5\xbd\x88"": ""\xe5\xbc\xb9"",\n""\xe5\xbd\x8c"": ""\xe5\xbc\xa5"",\n""\xe5\xbd\x8e"": ""\xe5\xbc\xaf"",\n""\xe5\xbd\x99"": ""\xe6\xb1\x87"",\n""\xe5\xbd\x9e"": ""\xe5\xbd\x9d"",\n""\xe5\xbd\xa5"": ""\xe5\xbd\xa6"",\n""\xe5\xbe\x81"": ""\xe5\xbe\x81"",\n""\xe5\xbe\x8c"": ""\xe5\x90\x8e"",\n""\xe5\xbe\x91"": ""\xe5\xbe\x84"",\n""\xe5\xbe\x9e"": ""\xe4\xbb\x8e"",\n""\xe5\xbe\xa0"": ""\xe5\xbe\x95"",\n""\xe5\xbe\xa9"": ""\xe5\xa4\x8d"",\n""\xe5\xbe\xb5"": ""\xe5\xbe\x81"",\n""\xe5\xbe\xb9"": ""\xe5\xbd\xbb"",\n""\xe5\xbf\x97"": ""\xe5\xbf\x97"",\n""\xe6\x81\x86"": ""\xe6\x81\x92"",\n""\xe6\x81\xa5"": ""\xe8\x80\xbb"",\n""\xe6\x82\x85"": ""\xe6\x82\xa6"",\n""\xe6\x82\x9e"": ""\xe6\x82\xae"",\n""\xe6\x82\xb5"": ""\xe6\x80\x85"",\n""\xe6\x82\xb6"": ""\xe9\x97\xb7"",\n""\xe6\x83\xa1"": ""\xe6\x81\xb6"",\n""\xe6\x83\xb1"": ""\xe6\x81\xbc"",\n""\xe6\x83\xb2"": ""\xe6\x81\xbd"",\n""\xe6\x83\xbb"": ""\xe6\x81\xbb"",\n""\xe6\x84\x9b"": ""\xe7\x88\xb1"",\n""\xe6\x84\x9c"": ""\xe6\x83\xac"",\n""\xe6\x84\xa8"": ""\xe6\x82\xab"",\n""\xe6\x84\xb4"": ""\xe6\x80\x86"",\n""\xe6\x84\xb7"": ""\xe6\x81\xba"",\n""\xe6\x84\xbe"": ""\xe5\xbf\xbe"",\n""\xe6\x84\xbf"": ""\xe6\x84\xbf"",\n""\xe6\x85\x84"": ""\xe6\xa0\x97"",\n""\xe6\x85\x8b"": ""\xe6\x80\x81"",\n""\xe6\x85\x8d"": ""\xe6\x84\xa0"",\n""\xe6\x85\x98"": ""\xe6\x83\xa8"",\n""\xe6\x85\x9a"": ""\xe6\x83\xad"",\n""\xe6\x85\x9f"": ""\xe6\x81\xb8"",\n""\xe6\x85\xa3"": ""\xe6\x83\xaf"",\n""\xe6\x85\xa4"": ""\xe6\x82\xab"",\n""\xe6\x85\xaa"": ""\xe6\x80\x84"",\n""\xe6\x85\xab"": ""\xe6\x80\x82"",\n""\xe6\x85\xae"": ""\xe8\x99\x91"",\n""\xe6\x85\xb3"": ""\xe6\x82\xad"",\n""\xe6\x85\xb6"": ""\xe5\xba\x86"",\n""\xe6\x86\x82"": ""\xe5\xbf\xa7"",\n""\xe6\x86\x8a"": ""\xe6\x83\xab"",\n""\xe6\x86\x90"": ""\xe6\x80\x9c"",\n""\xe6\x86\x91"": ""\xe5\x87\xad"",\n""\xe6\x86\x92"": ""\xe6\x84\xa6"",\n""\xe6\x86\x9a"": ""\xe6\x83\xae"",\n""\xe6\x86\xa4"": ""\xe6\x84\xa4"",\n""\xe6\x86\xab"": ""\xe6\x82\xaf"",\n""\xe6\x86\xae"": ""\xe6\x80\x83"",\n""\xe6\x86\xb2"": ""\xe5\xae\xaa"",\n""\xe6\x86\xb6"": ""\xe5\xbf\x86"",\n""\xe6\x87\x87"": ""\xe6\x81\xb3"",\n""\xe6\x87\x89"": ""\xe5\xba\x94"",\n""\xe6\x87\x8c"": ""\xe6\x80\xbf"",\n""\xe6\x87\x8d"": ""\xe6\x87\x94"",\n""\xe6\x87\x9e"": ""\xe8\x92\x99"",\n""\xe6\x87\x9f"": ""\xe6\x80\xbc"",\n""\xe6\x87\xa3"": ""\xe6\x87\x91"",\n""\xe6\x87\xa8"": ""\xe6\x81\xb9"",\n""\xe6\x87\xb2"": ""\xe6\x83\xa9"",\n""\xe6\x87\xb6"": ""\xe6\x87\x92"",\n""\xe6\x87\xb7"": ""\xe6\x80\x80"",\n""\xe6\x87\xb8"": ""\xe6\x82\xac"",\n""\xe6\x87\xba"": ""\xe5\xbf\x8f"",\n""\xe6\x87\xbc"": ""\xe6\x83\xa7"",\n""\xe6\x87\xbe"": ""\xe6\x85\x91"",\n""\xe6\x88\x80"": ""\xe6\x81\x8b"",\n""\xe6\x88\x87"": ""\xe6\x88\x86"",\n""\xe6\x88\x94"": ""\xe6\x88\x8b"",\n""\xe6\x88\xa7"": ""\xe6\x88\x97"",\n""\xe6\x88\xa9"": ""\xe6\x88\xac"",\n""\xe6\x88\xb0"": ""\xe6\x88\x98"",\n""\xe6\x88\xb1"": ""\xe6\x88\xaf"",\n""\xe6\x88\xb2"": ""\xe6\x88\x8f"",\n""\xe6\x88\xb6"": ""\xe6\x88\xb7"",\n""\xe6\x8b\x85"": ""\xe6\x8b\x85"",\n""\xe6\x8b\x8b"": ""\xe6\x8a\x9b"",\n""\xe6\x8c\xa9"": ""\xe6\x8d\x9d"",\n""\xe6\x8c\xbe"": ""\xe6\x8c\x9f"",\n""\xe6\x8d\xa8"": ""\xe8\x88\x8d"",\n""\xe6\x8d\xab"": ""\xe6\x89\xaa"",\n""\xe6\x8d\xae"": ""\xe6\x8d\xae"",\n""\xe6\x8e\x83"": ""\xe6\x89\xab"",\n""\xe6\x8e\x84"": ""\xe6\x8a\xa1"",\n""\xe6\x8e\x97"": ""\xe6\x8c\x9c"",\n""\xe6\x8e\x99"": ""\xe6\x8c\xa3"",\n""\xe6\x8e\x9b"": ""\xe6\x8c\x82"",\n""\xe6\x8e\xa1"": ""\xe9\x87\x87"",\n""\xe6\x8f\x80"": ""\xe6\x8b\xa3"",\n""\xe6\x8f\x9a"": ""\xe6\x89\xac"",\n""\xe6\x8f\x9b"": ""\xe6\x8d\xa2"",\n""\xe6\x8f\xae"": ""\xe6\x8c\xa5"",\n""\xe6\x90\x8d"": ""\xe6\x8d\x9f"",\n""\xe6\x90\x96"": ""\xe6\x91\x87"",\n""\xe6\x90\x97"": ""\xe6\x8d\xa3"",\n""\xe6\x90\xb5"": ""\xe6\x8f\xbe"",\n""\xe6\x90\xb6"": ""\xe6\x8a\xa2"",\n""\xe6\x91\x91"": ""\xe6\x8e\xb4"",\n""\xe6\x91\x9c"": ""\xe6\x8e\xbc"",\n""\xe6\x91\x9f"": ""\xe6\x90\x82"",\n""\xe6\x91\xaf"": ""\xe6\x8c\x9a"",\n""\xe6\x91\xb3"": ""\xe6\x8a\xa0"",\n""\xe6\x91\xb6"": ""\xe6\x8a\x9f"",\n""\xe6\x91\xba"": ""\xe6\x8a\x98"",\n""\xe6\x91\xbb"": ""\xe6\x8e\xba"",\n""\xe6\x92\x88"": ""\xe6\x8d\x9e"",\n""\xe6\x92\x8f"": ""\xe6\x8c\xa6"",\n""\xe6\x92\x90"": ""\xe6\x92\x91"",\n""\xe6\x92\x93"": ""\xe6\x8c\xa0"",\n""\xe6\x92\x9d"": ""\xe3\xa7\x91"",\n""\xe6\x92\x9f"": ""\xe6\x8c\xa2"",\n""\xe6\x92\xa3"": ""\xe6\x8e\xb8"",\n""\xe6\x92\xa5"": ""\xe6\x8b\xa8"",\n""\xe6\x92\xab"": ""\xe6\x8a\x9a"",\n""\xe6\x92\xb2"": ""\xe6\x89\x91"",\n""\xe6\x92\xb3"": ""\xe6\x8f\xbf"",\n""\xe6\x92\xbb"": ""\xe6\x8c\x9e"",\n""\xe6\x92\xbe"": ""\xe6\x8c\x9d"",\n""\xe6\x92\xbf"": ""\xe6\x8d\xa1"",\n""\xe6\x93\x81"": ""\xe6\x8b\xa5"",\n""\xe6\x93\x84"": ""\xe6\x8e\xb3"",\n""\xe6\x93\x87"": ""\xe6\x8b\xa9"",\n""\xe6\x93\x8a"": ""\xe5\x87\xbb"",\n""\xe6\x93\x8b"": ""\xe6\x8c\xa1"",\n""\xe6\x93\x93"": ""\xe3\xa7\x9f"",\n""\xe6\x93\x94"": ""\xe6\x8b\x85"",\n""\xe6\x93\x9a"": ""\xe6\x8d\xae"",\n""\xe6\x93\xa0"": ""\xe6\x8c\xa4"",\n""\xe6\x93\xac"": ""\xe6\x8b\x9f"",\n""\xe6\x93\xaf"": ""\xe6\x91\x88"",\n""\xe6\x93\xb0"": ""\xe6\x8b\xa7"",\n""\xe6\x93\xb1"": ""\xe6\x90\x81"",\n""\xe6\x93\xb2"": ""\xe6\x8e\xb7"",\n""\xe6\x93\xb4"": ""\xe6\x89\xa9"",\n""\xe6\x93\xb7"": ""\xe6\x92\xb7"",\n""\xe6\x93\xba"": ""\xe6\x91\x86"",\n""\xe6\x93\xbb"": ""\xe6\x93\x9e"",\n""\xe6\x93\xbc"": ""\xe6\x92\xb8"",\n""\xe6\x93\xbe"": ""\xe6\x89\xb0"",\n""\xe6\x94\x84"": ""\xe6\x91\x85"",\n""\xe6\x94\x86"": ""\xe6\x92\xb5"",\n""\xe6\x94\x8f"": ""\xe6\x8b\xa2"",\n""\xe6\x94\x94"": ""\xe6\x8b\xa6"",\n""\xe6\x94\x96"": ""\xe6\x92\x84"",\n""\xe6\x94\x99"": ""\xe6\x90\x80"",\n""\xe6\x94\x9b"": ""\xe6\x92\xba"",\n""\xe6\x94\x9c"": ""\xe6\x90\xba"",\n""\xe6\x94\x9d"": ""\xe6\x91\x84"",\n""\xe6\x94\xa2"": ""\xe6\x94\x92"",\n""\xe6\x94\xa3"": ""\xe6\x8c\x9b"",\n""\xe6\x94\xa4"": ""\xe6\x91\x8a"",\n""\xe6\x94\xaa"": ""\xe6\x90\x85"",\n""\xe6\x94\xac"": ""\xe6\x8f\xbd"",\n""\xe6\x95\x97"": ""\xe8\xb4\xa5"",\n""\xe6\x95\x98"": ""\xe5\x8f\x99"",\n""\xe6\x95\xb5"": ""\xe6\x95\x8c"",\n""\xe6\x95\xb8"": ""\xe6\x95\xb0"",\n""\xe6\x96\x82"": ""\xe6\x95\x9b"",\n""\xe6\x96\x83"": ""\xe6\xaf\x99"",\n""\xe6\x96\x95"": ""\xe6\x96\x93"",\n""\xe6\x96\x97"": ""\xe6\x96\x97"",\n""\xe6\x96\xac"": ""\xe6\x96\xa9"",\n""\xe6\x96\xb7"": ""\xe6\x96\xad"",\n""\xe6\x96\xbc"": ""\xe4\xba\x8e"",\n""\xe6\x99\x82"": ""\xe6\x97\xb6"",\n""\xe6\x99\x89"": ""\xe6\x99\x8b"",\n""\xe6\x99\x9d"": ""\xe6\x98\xbc"",\n""\xe6\x9a\x88"": ""\xe6\x99\x95"",\n""\xe6\x9a\x89"": ""\xe6\x99\x96"",\n""\xe6\x9a\x98"": ""\xe6\x97\xb8"",\n""\xe6\x9a\xa2"": ""\xe7\x95\x85"",\n""\xe6\x9a\xab"": ""\xe6\x9a\x82"",\n""\xe6\x9b\x84"": ""\xe6\x99\x94"",\n""\xe6\x9b\x86"": ""\xe5\x8e\x86"",\n""\xe6\x9b\x87"": ""\xe6\x98\x99"",\n""\xe6\x9b\x89"": ""\xe6\x99\x93"",\n""\xe6\x9b\x8f"": ""\xe5\x90\x91"",\n""\xe6\x9b\x96"": ""\xe6\x9a\xa7"",\n""\xe6\x9b\xa0"": ""\xe6\x97\xb7"",\n""\xe6\x9b\xa8"": ""\xe6\x98\xbd"",\n""\xe6\x9b\xac"": ""\xe6\x99\x92"",\n""\xe6\x9b\xb8"": ""\xe4\xb9\xa6"",\n""\xe6\x9c\x83"": ""\xe4\xbc\x9a"",\n""\xe6\x9c\xa7"": ""\xe8\x83\xa7"",\n""\xe6\x9c\xae"": ""\xe6\x9c\xaf"",\n""\xe6\x9c\xaf"": ""\xe6\x9c\xaf"",\n""\xe6\x9c\xb4"": ""\xe6\x9c\xb4"",\n""\xe6\x9d\xb1"": ""\xe4\xb8\x9c"",\n""\xe6\x9d\xb4"": ""\xe9\x94\xa8"",\n""\xe6\x9e\x81"": ""\xe6\x9e\x81"",\n""\xe6\x9f\x9c"": ""\xe6\x9f\x9c"",\n""\xe6\x9f\xb5"": ""\xe6\xa0\x85"",\n""\xe6\xa1\xbf"": ""\xe6\x9d\x86"",\n""\xe6\xa2\x94"": ""\xe6\xa0\x80"",\n""\xe6\xa2\x98"": ""\xe6\x9e\xa7"",\n""\xe6\xa2\x9d"": ""\xe6\x9d\xa1"",\n""\xe6\xa2\x9f"": ""\xe6\x9e\xad"",\n""\xe6\xa2\xb2"": ""\xe6\xa3\x81"",\n""\xe6\xa3\x84"": ""\xe5\xbc\x83"",\n""\xe6\xa3\x96"": ""\xe6\x9e\xa8"",\n""\xe6\xa3\x97"": ""\xe6\x9e\xa3"",\n""\xe6\xa3\x9f"": ""\xe6\xa0\x8b"",\n""\xe6\xa3\xa7"": ""\xe6\xa0\x88"",\n""\xe6\xa3\xb2"": ""\xe6\xa0\x96"",\n""\xe6\xa3\xb6"": ""\xe6\xa2\xbe"",\n""\xe6\xa4\x8f"": ""\xe6\xa1\xa0"",\n""\xe6\xa5\x8a"": ""\xe6\x9d\xa8"",\n""\xe6\xa5\x93"": ""\xe6\x9e\xab"",\n""\xe6\xa5\xa8"": ""\xe6\xa1\xa2"",\n""\xe6\xa5\xad"": ""\xe4\xb8\x9a"",\n""\xe6\xa5\xb5"": ""\xe6\x9e\x81"",\n""\xe6\xa6\xaa"": ""\xe6\x9d\xa9"",\n""\xe6\xa6\xae"": ""\xe8\x8d\xa3"",\n""\xe6\xa6\xb2"": ""\xe6\xa6\x85"",\n""\xe6\xa6\xbf"": ""\xe6\xa1\xa4"",\n""\xe6\xa7\x8b"": ""\xe6\x9e\x84"",\n""\xe6\xa7\x8d"": ""\xe6\x9e\xaa"",\n""\xe6\xa7\xa4"": ""\xe6\xa2\xbf"",\n""\xe6\xa7\xa7"": ""\xe6\xa4\xa0"",\n""\xe6\xa7\xa8"": ""\xe6\xa4\x81"",\n""\xe6\xa7\xb3"": ""\xe6\xa1\xa8"",\n""\xe6\xa8\x81"": ""\xe6\xa1\xa9"",\n""\xe6\xa8\x82"": ""\xe4\xb9\x90"",\n""\xe6\xa8\x85"": ""\xe6\x9e\x9e"",\n""\xe6\xa8\x93"": ""\xe6\xa5\xbc"",\n""\xe6\xa8\x99"": ""\xe6\xa0\x87"",\n""\xe6\xa8\x9e"": ""\xe6\x9e\xa2"",\n""\xe6\xa8\xa3"": ""\xe6\xa0\xb7"",\n""\xe6\xa8\xb8"": ""\xe6\x9c\xb4"",\n""\xe6\xa8\xb9"": ""\xe6\xa0\x91"",\n""\xe6\xa8\xba"": ""\xe6\xa1\xa6"",\n""\xe6\xa9\x88"": ""\xe6\xa1\xa1"",\n""\xe6\xa9\x8b"": ""\xe6\xa1\xa5"",\n""\xe6\xa9\x9f"": ""\xe6\x9c\xba"",\n""\xe6\xa9\xa2"": ""\xe6\xa4\xad"",\n""\xe6\xa9\xab"": ""\xe6\xa8\xaa"",\n""\xe6\xaa\x81"": ""\xe6\xaa\xa9"",\n""\xe6\xaa\x89"": ""\xe6\x9f\xbd"",\n""\xe6\xaa\x94"": ""\xe6\xa1\xa3"",\n""\xe6\xaa\x9c"": ""\xe6\xa1\xa7"",\n""\xe6\xaa\x9f"": ""\xe6\xa7\x9a"",\n""\xe6\xaa\xa2"": ""\xe6\xa3\x80"",\n""\xe6\xaa\xa3"": ""\xe6\xa8\xaf"",\n""\xe6\xaa\xae"": ""\xe6\xa2\xbc"",\n""\xe6\xaa\xaf"": ""\xe5\x8f\xb0"",\n""\xe6\xaa\xb3"": ""\xe6\xa7\x9f"",\n""\xe6\xaa\xb8"": ""\xe6\x9f\xa0"",\n""\xe6\xaa\xbb"": ""\xe6\xa7\x9b"",\n""\xe6\xab\x83"": ""\xe6\x9f\x9c"",\n""\xe6\xab\x93"": ""\xe6\xa9\xb9"",\n""\xe6\xab\x9a"": ""\xe6\xa6\x88"",\n""\xe6\xab\x9b"": ""\xe6\xa0\x89"",\n""\xe6\xab\x9d"": ""\xe6\xa4\x9f"",\n""\xe6\xab\x9e"": ""\xe6\xa9\xbc"",\n""\xe6\xab\x9f"": ""\xe6\xa0\x8e"",\n""\xe6\xab\xa5"": ""\xe6\xa9\xb1"",\n""\xe6\xab\xa7"": ""\xe6\xa7\xa0"",\n""\xe6\xab\xa8"": ""\xe6\xa0\x8c"",\n""\xe6\xab\xaa"": ""\xe6\x9e\xa5"",\n""\xe6\xab\xab"": ""\xe6\xa9\xa5"",\n""\xe6\xab\xac"": ""\xe6\xa6\x87"",\n""\xe6\xab\xb1"": ""\xe8\x98\x96"",\n""\xe6\xab\xb3"": ""\xe6\xa0\x8a"",\n""\xe6\xab\xb8"": ""\xe6\xa6\x89"",\n""\xe6\xab\xbb"": ""\xe6\xa8\xb1"",\n""\xe6\xac\x84"": ""\xe6\xa0\x8f"",\n""\xe6\xac\x8a"": ""\xe6\x9d\x83"",\n""\xe6\xac\x8f"": ""\xe6\xa4\xa4"",\n""\xe6\xac\x92"": ""\xe6\xa0\xbe"",\n""\xe6\xac\x96"": ""\xe6\xa6\x84"",\n""\xe6\xac\x9e"": ""\xe6\xa3\x82"",\n""\xe6\xac\xbd"": ""\xe9\x92\xa6"",\n""\xe6\xad\x90"": ""\xe6\xac\xa7"",\n""\xe6\xad\x9f"": ""\xe6\xac\xa4"",\n""\xe6\xad\xa1"": ""\xe6\xac\xa2"",\n""\xe6\xad\xb2"": ""\xe5\xb2\x81"",\n""\xe6\xad\xb7"": ""\xe5\x8e\x86"",\n""\xe6\xad\xb8"": ""\xe5\xbd\x92"",\n""\xe6\xad\xbf"": ""\xe6\xae\x81"",\n""\xe6\xae\x98"": ""\xe6\xae\x8b"",\n""\xe6\xae\x9e"": ""\xe6\xae\x92"",\n""\xe6\xae\xa4"": ""\xe6\xae\x87"",\n""\xe6\xae\xa8"": ""\xe3\xb1\xae"",\n""\xe6\xae\xab"": ""\xe6\xae\x9a"",\n""\xe6\xae\xae"": ""\xe6\xae\x93"",\n""\xe6\xae\xaf"": ""\xe6\xae\xa1"",\n""\xe6\xae\xb0"": ""\xe3\xb1\xa9"",\n""\xe6\xae\xb2"": ""\xe6\xad\xbc"",\n""\xe6\xae\xba"": ""\xe6\x9d\x80"",\n""\xe6\xae\xbb"": ""\xe5\xa3\xb3"",\n""\xe6\xae\xbc"": ""\xe5\xa3\xb3"",\n""\xe6\xaf\x80"": ""\xe6\xaf\x81"",\n""\xe6\xaf\x86"": ""\xe6\xae\xb4"",\n""\xe6\xaf\xbf"": ""\xe6\xaf\xb5"",\n""\xe6\xb0\x82"": ""\xe7\x89\xa6"",\n""\xe6\xb0\x88"": ""\xe6\xaf\xa1"",\n""\xe6\xb0\x8c"": ""\xe6\xb0\x87"",\n""\xe6\xb0\xa3"": ""\xe6\xb0\x94"",\n""\xe6\xb0\xab"": ""\xe6\xb0\xa2"",\n""\xe6\xb0\xac"": ""\xe6\xb0\xa9"",\n""\xe6\xb0\xb3"": ""\xe6\xb0\xb2"",\n""\xe6\xb1\x99"": ""\xe6\xb1\xa1"",\n""\xe6\xb1\xba"": ""\xe5\x86\xb3"",\n""\xe6\xb2\x92"": ""\xe6\xb2\xa1"",\n""\xe6\xb2\x96"": ""\xe5\x86\xb2"",\n""\xe6\xb3\x81"": ""\xe5\x86\xb5"",\n""\xe6\xb4\xb6"": ""\xe6\xb1\xb9"",\n""\xe6\xb5\xb9"": ""\xe6\xb5\x83"",\n""\xe6\xb6\x82"": ""\xe6\xb6\x82"",\n""\xe6\xb6\x87"": ""\xe6\xb3\xbe"",\n""\xe6\xb6\xbc"": ""\xe5\x87\x89"",\n""\xe6\xb7\x80"": ""\xe6\xb7\x80"",\n""\xe6\xb7\x92"": ""\xe5\x87\x84"",\n""\xe6\xb7\x9a"": ""\xe6\xb3\xaa"",\n""\xe6\xb7\xa5"": ""\xe6\xb8\x8c"",\n""\xe6\xb7\xa8"": ""\xe5\x87\x80"",\n""\xe6\xb7\xa9"": ""\xe5\x87\x8c"",\n""\xe6\xb7\xaa"": ""\xe6\xb2\xa6"",\n""\xe6\xb7\xb5"": ""\xe6\xb8\x8a"",\n""\xe6\xb7\xb6"": ""\xe6\xb6\x9e"",\n""\xe6\xb7\xba"": ""\xe6\xb5\x85"",\n""\xe6\xb8\x99"": ""\xe6\xb6\xa3"",\n""\xe6\xb8\x9b"": ""\xe5\x87\x8f"",\n""\xe6\xb8\xa6"": ""\xe6\xb6\xa1"",\n""\xe6\xb8\xac"": ""\xe6\xb5\x8b"",\n""\xe6\xb8\xbe"": ""\xe6\xb5\x91"",\n""\xe6\xb9\x8a"": ""\xe5\x87\x91"",\n""\xe6\xb9\x9e"": ""\xe6\xb5\x88"",\n""\xe6\xb9\xaf"": ""\xe6\xb1\xa4"",\n""\xe6\xba\x88"": ""\xe6\xb2\xa9"",\n""\xe6\xba\x96"": ""\xe5\x87\x86"",\n""\xe6\xba\x9d"": ""\xe6\xb2\x9f"",\n""\xe6\xba\xab"": ""\xe6\xb8\xa9"",\n""\xe6\xbb\x84"": ""\xe6\xb2\xa7"",\n""\xe6\xbb\x85"": ""\xe7\x81\xad"",\n""\xe6\xbb\x8c"": ""\xe6\xb6\xa4"",\n""\xe6\xbb\x8e"": ""\xe8\x8d\xa5"",\n""\xe6\xbb\xac"": ""\xe6\xb2\xaa"",\n""\xe6\xbb\xaf"": ""\xe6\xbb\x9e"",\n""\xe6\xbb\xb2"": ""\xe6\xb8\x97"",\n""\xe6\xbb\xb7"": ""\xe5\x8d\xa4"",\n""\xe6\xbb\xb8"": ""\xe6\xb5\x92"",\n""\xe6\xbb\xbb"": ""\xe6\xb5\x90"",\n""\xe6\xbb\xbe"": ""\xe6\xbb\x9a"",\n""\xe6\xbb\xbf"": ""\xe6\xbb\xa1"",\n""\xe6\xbc\x81"": ""\xe6\xb8\x94"",\n""\xe6\xbc\x9a"": ""\xe6\xb2\xa4"",\n""\xe6\xbc\xa2"": ""\xe6\xb1\x89"",\n""\xe6\xbc\xa3"": ""\xe6\xb6\x9f"",\n""\xe6\xbc\xac"": ""\xe6\xb8\x8d"",\n""\xe6\xbc\xb2"": ""\xe6\xb6\xa8"",\n""\xe6\xbc\xb5"": ""\xe6\xba\x86"",\n""\xe6\xbc\xb8"": ""\xe6\xb8\x90"",\n""\xe6\xbc\xbf"": ""\xe6\xb5\x86"",\n""\xe6\xbd\x81"": ""\xe9\xa2\x8d"",\n""\xe6\xbd\x91"": ""\xe6\xb3\xbc"",\n""\xe6\xbd\x94"": ""\xe6\xb4\x81"",\n""\xe6\xbd\x99"": ""\xe6\xb2\xa9"",\n""\xe6\xbd\x9b"": ""\xe6\xbd\x9c"",\n""\xe6\xbd\xa4"": ""\xe6\xb6\xa6"",\n""\xe6\xbd\xaf"": ""\xe6\xb5\x94"",\n""\xe6\xbd\xb0"": ""\xe6\xba\x83"",\n""\xe6\xbd\xb7"": ""\xe6\xbb\x97"",\n""\xe6\xbd\xbf"": ""\xe6\xb6\xa0"",\n""\xe6\xbe\x80"": ""\xe6\xb6\xa9"",\n""\xe6\xbe\x86"": ""\xe6\xb5\x87"",\n""\xe6\xbe\x87"": ""\xe6\xb6\x9d"",\n""\xe6\xbe\x90"": ""\xe6\xb2\x84"",\n""\xe6\xbe\x97"": ""\xe6\xb6\xa7"",\n""\xe6\xbe\xa0"": ""\xe6\xb8\x91"",\n""\xe6\xbe\xa4"": ""\xe6\xb3\xbd"",\n""\xe6\xbe\xa6"": ""\xe6\xbb\xaa"",\n""\xe6\xbe\xa9"": ""\xe6\xb3\xb6"",\n""\xe6\xbe\xae"": ""\xe6\xb5\x8d"",\n""\xe6\xbe\xb1"": ""\xe6\xb7\x80"",\n""\xe6\xbf\x81"": ""\xe6\xb5\x8a"",\n""\xe6\xbf\x83"": ""\xe6\xb5\x93"",\n""\xe6\xbf\x95"": ""\xe6\xb9\xbf"",\n""\xe6\xbf\x98"": ""\xe6\xb3\x9e"",\n""\xe6\xbf\x9b"": ""\xe8\x92\x99"",\n""\xe6\xbf\x9f"": ""\xe6\xb5\x8e"",\n""\xe6\xbf\xa4"": ""\xe6\xb6\x9b"",\n""\xe6\xbf\xab"": ""\xe6\xbb\xa5"",\n""\xe6\xbf\xb0"": ""\xe6\xbd\x8d"",\n""\xe6\xbf\xb1"": ""\xe6\xbb\xa8"",\n""\xe6\xbf\xba"": ""\xe6\xba\x85"",\n""\xe6\xbf\xbc"": ""\xe6\xb3\xba"",\n""\xe6\xbf\xbe"": ""\xe6\xbb\xa4"",\n""\xe7\x80\x85"": ""\xe6\xbb\xa2"",\n""\xe7\x80\x86"": ""\xe6\xb8\x8e"",\n""\xe7\x80\x87"": ""\xe3\xb2\xbf"",\n""\xe7\x80\x89"": ""\xe6\xb3\xbb"",\n""\xe7\x80\x8b"": ""\xe6\xb2\x88"",\n""\xe7\x80\x8f"": ""\xe6\xb5\x8f"",\n""\xe7\x80\x95"": ""\xe6\xbf\x92"",\n""\xe7\x80\x98"": ""\xe6\xb3\xb8"",\n""\xe7\x80\x9d"": ""\xe6\xb2\xa5"",\n""\xe7\x80\x9f"": ""\xe6\xbd\x87"",\n""\xe7\x80\xa0"": ""\xe6\xbd\x86"",\n""\xe7\x80\xa6"": ""\xe6\xbd\xb4"",\n""\xe7\x80\xa7"": ""\xe6\xb3\xb7"",\n""\xe7\x80\xa8"": ""\xe6\xbf\x91"",\n""\xe7\x80\xb0"": ""\xe5\xbc\xa5"",\n""\xe7\x80\xb2"": ""\xe6\xbd\x8b"",\n""\xe7\x80\xbe"": ""\xe6\xbe\x9c"",\n""\xe7\x81\x83"": ""\xe6\xb2\xa3"",\n""\xe7\x81\x84"": ""\xe6\xbb\xa0"",\n""\xe7\x81\x91"": ""\xe6\xb4\x92"",\n""\xe7\x81\x95"": ""\xe6\xbc\x93"",\n""\xe7\x81\x98"": ""\xe6\xbb\xa9"",\n""\xe7\x81\x9d"": ""\xe7\x81\x8f"",\n""\xe7\x81\xa0"": ""\xe6\xbc\xa4"",\n""\xe7\x81\xa3"": ""\xe6\xb9\xbe"",\n""\xe7\x81\xa4"": ""\xe6\xbb\xa6"",\n""\xe7\x81\xa7"": ""\xe6\xbb\x9f"",\n""\xe7\x81\xbd"": ""\xe7\x81\xbe"",\n""\xe7\x82\xba"": ""\xe4\xb8\xba"",\n""\xe7\x83\x8f"": ""\xe4\xb9\x8c"",\n""\xe7\x83\xb4"": ""\xe7\x83\x83"",\n""\xe7\x84\xa1"": ""\xe6\x97\xa0"",\n""\xe7\x85\x89"": ""\xe7\x82\xbc"",\n""\xe7\x85\x92"": ""\xe7\x82\x9c"",\n""\xe7\x85\x99"": ""\xe7\x83\x9f"",\n""\xe7\x85\xa2"": ""\xe8\x8c\x95"",\n""\xe7\x85\xa5"": ""\xe7\x84\x95"",\n""\xe7\x85\xa9"": ""\xe7\x83\xa6"",\n""\xe7\x85\xac"": ""\xe7\x82\x80"",\n""\xe7\x85\xb1"": ""\xe3\xb6\xbd"",\n""\xe7\x86\x85"": ""\xe7\x85\xb4"",\n""\xe7\x86\x92"": ""\xe8\x8d\xa7"",\n""\xe7\x86\x97"": ""\xe7\x82\x9d"",\n""\xe7\x86\xb1"": ""\xe7\x83\xad"",\n""\xe7\x86\xb2"": ""\xe9\xa2\x8e"",\n""\xe7\x86\xbe"": ""\xe7\x82\xbd"",\n""\xe7\x87\x81"": ""\xe7\x83\xa8"",\n""\xe7\x87\x88"": ""\xe7\x81\xaf"",\n""\xe7\x87\x89"": ""\xe7\x82\x96"",\n""\xe7\x87\x92"": ""\xe7\x83\xa7"",\n""\xe7\x87\x99"": ""\xe7\x83\xab"",\n""\xe7\x87\x9c"": ""\xe7\x84\x96"",\n""\xe7\x87\x9f"": ""\xe8\x90\xa5"",\n""\xe7\x87\xa6"": ""\xe7\x81\xbf"",\n""\xe7\x87\xad"": ""\xe7\x83\x9b"",\n""\xe7\x87\xb4"": ""\xe7\x83\xa9"",\n""\xe7\x87\xb6"": ""\xe3\xb6\xb6"",\n""\xe7\x87\xbc"": ""\xe7\x83\xac"",\n""\xe7\x87\xbe"": ""\xe7\x84\x98"",\n""\xe7\x88\x8d"": ""\xe7\x83\x81"",\n""\xe7\x88\x90"": ""\xe7\x82\x89"",\n""\xe7\x88\x9b"": ""\xe7\x83\x82"",\n""\xe7\x88\xad"": ""\xe4\xba\x89"",\n""\xe7\x88\xb2"": ""\xe4\xb8\xba"",\n""\xe7\x88\xba"": ""\xe7\x88\xb7"",\n""\xe7\x88\xbe"": ""\xe5\xb0\x94"",\n""\xe7\x89\x86"": ""\xe5\xa2\x99"",\n""\xe7\x89\x98"": ""\xe7\x89\x8d"",\n""\xe7\x89\xbd"": ""\xe7\x89\xb5"",\n""\xe7\x8a\x96"": ""\xe8\x8d\xa6"",\n""\xe7\x8a\xa2"": ""\xe7\x8a\x8a"",\n""\xe7\x8a\xa7"": ""\xe7\x89\xba"",\n""\xe7\x8b\x80"": ""\xe7\x8a\xb6"",\n""\xe7\x8b\xb9"": ""\xe7\x8b\xad"",\n""\xe7\x8b\xbd"": ""\xe7\x8b\x88"",\n""\xe7\x8c\x99"": ""\xe7\x8b\xb0"",\n""\xe7\x8c\xb6"": ""\xe7\x8a\xb9"",\n""\xe7\x8c\xbb"": ""\xe7\x8b\xb2"",\n""\xe7\x8d\x81"": ""\xe7\x8a\xb8"",\n""\xe7\x8d\x84"": ""\xe7\x8b\xb1"",\n""\xe7\x8d\x85"": ""\xe7\x8b\xae"",\n""\xe7\x8d\x8e"": ""\xe5\xa5\x96"",\n""\xe7\x8d\xa8"": ""\xe7\x8b\xac"",\n""\xe7\x8d\xaa"": ""\xe7\x8b\xaf"",\n""\xe7\x8d\xab"": ""\xe7\x8c\x83"",\n""\xe7\x8d\xae"": ""\xe7\x8b\x9d"",\n""\xe7\x8d\xb0"": ""\xe7\x8b\x9e"",\n""\xe7\x8d\xb1"": ""\xe3\xba\x8d"",\n""\xe7\x8d\xb2"": ""\xe8\x8e\xb7"",\n""\xe7\x8d\xb5"": ""\xe7\x8c\x8e"",\n""\xe7\x8d\xb7"": ""\xe7\x8a\xb7"",\n""\xe7\x8d\xb8"": ""\xe5\x85\xbd"",\n""\xe7\x8d\xba"": ""\xe7\x8d\xad"",\n""\xe7\x8d\xbb"": ""\xe7\x8c\xae"",\n""\xe7\x8d\xbc"": ""\xe7\x8c\x95"",\n""\xe7\x8e\x80"": ""\xe7\x8c\xa1"",\n""\xe7\x8f\xbe"": ""\xe7\x8e\xb0"",\n""\xe7\x90\xba"": ""\xe7\x8f\x90"",\n""\xe7\x90\xbf"": ""\xe7\x8f\xb2"",\n""\xe7\x91\x8b"": ""\xe7\x8e\xae"",\n""\xe7\x91\x92"": ""\xe7\x8e\x9a"",\n""\xe7\x91\xa3"": ""\xe7\x90\x90"",\n""\xe7\x91\xa4"": ""\xe7\x91\xb6"",\n""\xe7\x91\xa9"": ""\xe8\x8e\xb9"",\n""\xe7\x91\xaa"": ""\xe7\x8e\x9b"",\n""\xe7\x91\xb2"": ""\xe7\x8e\xb1"",\n""\xe7\x92\x89"": ""\xe7\x90\x8f"",\n""\xe7\x92\xa3"": ""\xe7\x8e\x91"",\n""\xe7\x92\xa6"": ""\xe7\x91\xb7"",\n""\xe7\x92\xab"": ""\xe7\x8f\xb0"",\n""\xe7\x92\xb0"": ""\xe7\x8e\xaf"",\n""\xe7\x92\xbd"": ""\xe7\x8e\xba"",\n""\xe7\x93\x8a"": ""\xe7\x90\xbc"",\n""\xe7\x93\x8f"": ""\xe7\x8f\x91"",\n""\xe7\x93\x94"": ""\xe7\x92\x8e"",\n""\xe7\x93\x9a"": ""\xe7\x93\x92"",\n""\xe7\x94\x8c"": ""\xe7\x93\xaf"",\n""\xe7\x94\xa2"": ""\xe4\xba\xa7"",\n""\xe7\x94\xa3"": ""\xe4\xba\xa7"",\n""\xe7\x95\x9d"": ""\xe4\xba\xa9"",\n""\xe7\x95\xa2"": ""\xe6\xaf\x95"",\n""\xe7\x95\xb0"": ""\xe5\xbc\x82"",\n""\xe7\x95\xb5"": ""\xe7\x94\xbb"",\n""\xe7\x95\xb6"": ""\xe5\xbd\x93"",\n""\xe7\x96\x87"": ""\xe7\x95\xb4"",\n""\xe7\x96\x8a"": ""\xe5\x8f\xa0"",\n""\xe7\x97\x99"": ""\xe7\x97\x89"",\n""\xe7\x97\xbe"": ""\xe7\x96\xb4"",\n""\xe7\x98\x82"": ""\xe7\x97\x96"",\n""\xe7\x98\x8b"": ""\xe7\x96\xaf"",\n""\xe7\x98\x8d"": ""\xe7\x96\xa1"",\n""\xe7\x98\x93"": ""\xe7\x97\xaa"",\n""\xe7\x98\x9e"": ""\xe7\x98\x97"",\n""\xe7\x98\xa1"": ""\xe7\x96\xae"",\n""\xe7\x98\xa7"": ""\xe7\x96\x9f"",\n""\xe7\x98\xae"": ""\xe7\x98\x86"",\n""\xe7\x98\xb2"": ""\xe7\x96\xad"",\n""\xe7\x98\xba"": ""\xe7\x98\x98"",\n""\xe7\x98\xbb"": ""\xe7\x98\x98"",\n""\xe7\x99\x82"": ""\xe7\x96\x97"",\n""\xe7\x99\x86"": ""\xe7\x97\xa8"",\n""\xe7\x99\x87"": ""\xe7\x97\xab"",\n""\xe7\x99\x89"": ""\xe7\x98\x85"",\n""\xe7\x99\x98"": ""\xe7\x96\xa0"",\n""\xe7\x99\x9f"": ""\xe7\x98\xaa"",\n""\xe7\x99\xa2"": ""\xe7\x97\x92"",\n""\xe7\x99\xa4"": ""\xe7\x96\x96"",\n""\xe7\x99\xa5"": ""\xe7\x97\x87"",\n""\xe7\x99\xa7"": ""\xe7\x96\xac"",\n""\xe7\x99\xa9"": ""\xe7\x99\x9e"",\n""\xe7\x99\xac"": ""\xe7\x99\xa3"",\n""\xe7\x99\xad"": ""\xe7\x98\xbf"",\n""\xe7\x99\xae"": ""\xe7\x98\xbe"",\n""\xe7\x99\xb0"": ""\xe7\x97\x88"",\n""\xe7\x99\xb1"": ""\xe7\x98\xab"",\n""\xe7\x99\xb2"": ""\xe7\x99\xab"",\n""\xe7\x99\xbc"": ""\xe5\x8f\x91"",\n""\xe7\x9a\x9a"": ""\xe7\x9a\x91"",\n""\xe7\x9a\xb0"": ""\xe7\x96\xb1"",\n""\xe7\x9a\xb8"": ""\xe7\x9a\xb2"",\n""\xe7\x9a\xba"": ""\xe7\x9a\xb1"",\n""\xe7\x9b\x83"": ""\xe6\x9d\xaf"",\n""\xe7\x9b\x9c"": ""\xe7\x9b\x97"",\n""\xe7\x9b\x9e"": ""\xe7\x9b\x8f"",\n""\xe7\x9b\xa1"": ""\xe5\xb0\xbd"",\n""\xe7\x9b\xa3"": ""\xe7\x9b\x91"",\n""\xe7\x9b\xa4"": ""\xe7\x9b\x98"",\n""\xe7\x9b\xa7"": ""\xe5\x8d\xa2"",\n""\xe7\x9b\xaa"": ""\xe8\x8d\xa1"",\n""\xe7\x9c\xa5"": ""\xe7\x9c\xa6"",\n""\xe7\x9c\xbe"": ""\xe4\xbc\x97"",\n""\xe7\x9d\x8f"": ""\xe5\x9b\xb0"",\n""\xe7\x9d\x9c"": ""\xe7\x9d\x81"",\n""\xe7\x9d\x9e"": ""\xe7\x9d\x90"",\n""\xe7\x9e\x98"": ""\xe7\x9c\x8d"",\n""\xe7\x9e\x9c"": ""\xe4\x81\x96"",\n""\xe7\x9e\x9e"": ""\xe7\x9e\x92"",\n""\xe7\x9e\xad"": ""\xe4\xba\x86"",\n""\xe7\x9e\xb6"": ""\xe7\x9e\x86"",\n""\xe7\x9e\xbc"": ""\xe7\x9d\x91"",\n""\xe7\x9f\x87"": ""\xe8\x92\x99"",\n""\xe7\x9f\x93"": ""\xe7\x9c\xac"",\n""\xe7\x9f\x9a"": ""\xe7\x9e\xa9"",\n""\xe7\x9f\xaf"": ""\xe7\x9f\xab"",\n""\xe7\xa1\x83"": ""\xe6\x9c\xb1"",\n""\xe7\xa1\x9c"": ""\xe7\xa1\x81"",\n""\xe7\xa1\xa4"": ""\xe7\xa1\x96"",\n""\xe7\xa1\xa8"": ""\xe7\xa0\x97"",\n""\xe7\xa1\xae"": ""\xe7\xa1\xae"",\n""\xe7\xa1\xaf"": ""\xe7\xa0\x9a"",\n""\xe7\xa2\xa9"": ""\xe7\xa1\x95"",\n""\xe7\xa2\xad"": ""\xe7\xa0\x80"",\n""\xe7\xa2\xb8"": ""\xe7\xa0\x9c"",\n""\xe7\xa2\xba"": ""\xe7\xa1\xae"",\n""\xe7\xa2\xbc"": ""\xe7\xa0\x81"",\n""\xe7\xa3\x91"": ""\xe7\xa1\x99"",\n""\xe7\xa3\x9a"": ""\xe7\xa0\x96"",\n""\xe7\xa3\xa3"": ""\xe7\xa2\x9c"",\n""\xe7\xa3\xa7"": ""\xe7\xa2\x9b"",\n""\xe7\xa3\xaf"": ""\xe7\x9f\xb6"",\n""\xe7\xa3\xbd"": ""\xe7\xa1\x97"",\n""\xe7\xa4\x86"": ""\xe7\xa1\xb7"",\n""\xe7\xa4\x8e"": ""\xe7\xa1\x80"",\n""\xe7\xa4\x99"": ""\xe7\xa2\x8d"",\n""\xe7\xa4\xa6"": ""\xe7\x9f\xbf"",\n""\xe7\xa4\xaa"": ""\xe7\xa0\xba"",\n""\xe7\xa4\xab"": ""\xe7\xa0\xbe"",\n""\xe7\xa4\xac"": ""\xe7\x9f\xbe"",\n""\xe7\xa4\xb1"": ""\xe7\xa0\xbb"",\n""\xe7\xa5\xbf"": ""\xe7\xa6\x84"",\n""\xe7\xa6\x8d"": ""\xe7\xa5\xb8"",\n""\xe7\xa6\x8e"": ""\xe7\xa5\xaf"",\n""\xe7\xa6\x95"": ""\xe7\xa5\x8e"",\n""\xe7\xa6\xa1"": ""\xe7\xa5\x83"",\n""\xe7\xa6\xa6"": ""\xe5\xbe\xa1"",\n""\xe7\xa6\xaa"": ""\xe7\xa6\x85"",\n""\xe7\xa6\xae"": ""\xe7\xa4\xbc"",\n""\xe7\xa6\xb0"": ""\xe7\xa5\xa2"",\n""\xe7\xa6\xb1"": ""\xe7\xa5\xb7"",\n""\xe7\xa6\xbf"": ""\xe7\xa7\x83"",\n""\xe7\xa7\x88"": ""\xe7\xb1\xbc"",\n""\xe7\xa7\x8d"": ""\xe7\xa7\x8d"",\n""\xe7\xa8\x85"": ""\xe7\xa8\x8e"",\n""\xe7\xa8\x88"": ""\xe7\xa7\x86"",\n""\xe7\xa8\x8f"": ""\xe4\x85\x89"",\n""\xe7\xa8\x9f"": ""\xe7\xa6\x80"",\n""\xe7\xa8\xae"": ""\xe7\xa7\x8d"",\n""\xe7\xa8\xb1"": ""\xe7\xa7\xb0"",\n""\xe7\xa9\x80"": ""\xe8\xb0\xb7"",\n""\xe7\xa9\x8c"": ""\xe7\xa8\xa3"",\n""\xe7\xa9\x8d"": ""\xe7\xa7\xaf"",\n""\xe7\xa9\x8e"": ""\xe9\xa2\x96"",\n""\xe7\xa9\xa0"": ""\xe7\xa7\xbe"",\n""\xe7\xa9\xa1"": ""\xe7\xa9\x91"",\n""\xe7\xa9\xa2"": ""\xe7\xa7\xbd"",\n""\xe7\xa9\xa9"": ""\xe7\xa8\xb3"",\n""\xe7\xa9\xab"": ""\xe8\x8e\xb7"",\n""\xe7\xa9\xad"": ""\xe7\xa8\x86"",\n""\xe7\xaa\xa9"": ""\xe7\xaa\x9d"",\n""\xe7\xaa\xaa"": ""\xe6\xb4\xbc"",\n""\xe7\xaa\xae"": ""\xe7\xa9\xb7"",\n""\xe7\xaa\xaf"": ""\xe7\xaa\x91"",\n""\xe7\xaa\xb5"": ""\xe7\xaa\x8e"",\n""\xe7\xaa\xb6"": ""\xe7\xaa\xad"",\n""\xe7\xaa\xba"": ""\xe7\xaa\xa5"",\n""\xe7\xab\x84"": ""\xe7\xaa\x9c"",\n""\xe7\xab\x85"": ""\xe7\xaa\x8d"",\n""\xe7\xab\x87"": ""\xe7\xaa\xa6"",\n""\xe7\xab\x88"": ""\xe7\x81\xb6"",\n""\xe7\xab\x8a"": ""\xe7\xaa\x83"",\n""\xe7\xab\xaa"": ""\xe7\xab\x96"",\n""\xe7\xab\xb6"": ""\xe7\xab\x9e"",\n""\xe7\xad\x86"": ""\xe7\xac\x94"",\n""\xe7\xad\x8d"": ""\xe7\xac\x8b"",\n""\xe7\xad\x91"": ""\xe7\xad\x91"",\n""\xe7\xad\xa7"": ""\xe7\xac\x95"",\n""\xe7\xad\xb4"": ""\xe4\x87\xb2"",\n""\xe7\xae\x8b"": ""\xe7\xac\xba"",\n""\xe7\xae\x8f"": ""\xe7\xad\x9d"",\n""\xe7\xaf\x80"": ""\xe8\x8a\x82"",\n""\xe7\xaf\x84"": ""\xe8\x8c\x83"",\n""\xe7\xaf\x89"": ""\xe7\xad\x91"",\n""\xe7\xaf\x8b"": ""\xe7\xae\xa7"",\n""\xe7\xaf\x94"": ""\xe7\xad\xbc"",\n""\xe7\xaf\xa4"": ""\xe7\xac\x83"",\n""\xe7\xaf\xa9"": ""\xe7\xad\x9b"",\n""\xe7\xaf\xb3"": ""\xe7\xad\x9a"",\n""\xe7\xb0\x80"": ""\xe7\xae\xa6"",\n""\xe7\xb0\x8d"": ""\xe7\xaf\x93"",\n""\xe7\xb0\x9e"": ""\xe7\xae\xaa"",\n""\xe7\xb0\xa1"": ""\xe7\xae\x80"",\n""\xe7\xb0\xa3"": ""\xe7\xaf\x91"",\n""\xe7\xb0\xab"": ""\xe7\xae\xab"",\n""\xe7\xb0\xb9"": ""\xe7\xad\x9c"",\n""\xe7\xb0\xbd"": ""\xe7\xad\xbe"",\n""\xe7\xb0\xbe"": ""\xe5\xb8\x98"",\n""\xe7\xb1\x83"": ""\xe7\xaf\xae"",\n""\xe7\xb1\x8c"": ""\xe7\xad\xb9"",\n""\xe7\xb1\x96"": ""\xe7\xad\xbe"",\n""\xe7\xb1\x99"": ""\xe7\xae\x93"",\n""\xe7\xb1\x9c"": ""\xe7\xae\xa8"",\n""\xe7\xb1\x9f"": ""\xe7\xb1\x81"",\n""\xe7\xb1\xa0"": ""\xe7\xac\xbc"",\n""\xe7\xb1\xa9"": ""\xe7\xac\xbe"",\n""\xe7\xb1\xaa"": ""\xe7\xb0\x96"",\n""\xe7\xb1\xac"": ""\xe7\xaf\xb1"",\n""\xe7\xb1\xae"": ""\xe7\xae\xa9"",\n""\xe7\xb1\xb2"": ""\xe5\x90\x81"",\n""\xe7\xb2\xb5"": ""\xe7\xb2\xa4"",\n""\xe7\xb3\x9d"": ""\xe7\xb3\x81"",\n""\xe7\xb3\x9e"": ""\xe7\xb2\xaa"",\n""\xe7\xb3\xa7"": ""\xe7\xb2\xae"",\n""\xe7\xb3\xb0"": ""\xe5\x9b\xa2"",\n""\xe7\xb3\xb2"": ""\xe7\xb2\x9d"",\n""\xe7\xb3\xb4"": ""\xe7\xb1\xb4"",\n""\xe7\xb3\xb6"": ""\xe7\xb2\x9c"",\n""\xe7\xb3\xb9"": ""\xe7\xba\x9f"",\n""\xe7\xb3\xbe"": ""\xe7\xba\xa0"",\n""\xe7\xb4\x80"": ""\xe7\xba\xaa"",\n""\xe7\xb4\x82"": ""\xe7\xba\xa3"",\n""\xe7\xb4\x84"": ""\xe7\xba\xa6"",\n""\xe7\xb4\x85"": ""\xe7\xba\xa2"",\n""\xe7\xb4\x86"": ""\xe7\xba\xa1"",\n""\xe7\xb4\x87"": ""\xe7\xba\xa5"",\n""\xe7\xb4\x88"": ""\xe7\xba\xa8"",\n""\xe7\xb4\x89"": ""\xe7\xba\xab"",\n""\xe7\xb4\x8b"": ""\xe7\xba\xb9"",\n""\xe7\xb4\x8d"": ""\xe7\xba\xb3"",\n""\xe7\xb4\x90"": ""\xe7\xba\xbd"",\n""\xe7\xb4\x93"": ""\xe7\xba\xbe"",\n""\xe7\xb4\x94"": ""\xe7\xba\xaf"",\n""\xe7\xb4\x95"": ""\xe7\xba\xb0"",\n""\xe7\xb4\x96"": ""\xe7\xba\xbc"",\n""\xe7\xb4\x97"": ""\xe7\xba\xb1"",\n""\xe7\xb4\x98"": ""\xe7\xba\xae"",\n""\xe7\xb4\x99"": ""\xe7\xba\xb8"",\n""\xe7\xb4\x9a"": ""\xe7\xba\xa7"",\n""\xe7\xb4\x9b"": ""\xe7\xba\xb7"",\n""\xe7\xb4\x9c"": ""\xe7\xba\xad"",\n""\xe7\xb4\x9d"": ""\xe7\xba\xb4"",\n""\xe7\xb4\xa1"": ""\xe7\xba\xba"",\n""\xe7\xb4\xac"": ""\xe4\x8c\xb7"",\n""\xe7\xb4\xb0"": ""\xe7\xbb\x86"",\n""\xe7\xb4\xb1"": ""\xe7\xbb\x82"",\n""\xe7\xb4\xb2"": ""\xe7\xbb\x81"",\n""\xe7\xb4\xb3"": ""\xe7\xbb\x85"",\n""\xe7\xb4\xb5"": ""\xe7\xba\xbb"",\n""\xe7\xb4\xb9"": ""\xe7\xbb\x8d"",\n""\xe7\xb4\xba"": ""\xe7\xbb\x80"",\n""\xe7\xb4\xbc"": ""\xe7\xbb\x8b"",\n""\xe7\xb4\xbf"": ""\xe7\xbb\x90"",\n""\xe7\xb5\x80"": ""\xe7\xbb\x8c"",\n""\xe7\xb5\x82"": ""\xe7\xbb\x88"",\n""\xe7\xb5\x84"": ""\xe7\xbb\x84"",\n""\xe7\xb5\x85"": ""\xe4\x8c\xb9"",\n""\xe7\xb5\x86"": ""\xe7\xbb\x8a"",\n""\xe7\xb5\x8e"": ""\xe7\xbb\x97"",\n""\xe7\xb5\x90"": ""\xe7\xbb\x93"",\n""\xe7\xb5\x95"": ""\xe7\xbb\x9d"",\n""\xe7\xb5\x9b"": ""\xe7\xbb\xa6"",\n""\xe7\xb5\x9d"": ""\xe7\xbb\x94"",\n""\xe7\xb5\x9e"": ""\xe7\xbb\x9e"",\n""\xe7\xb5\xa1"": ""\xe7\xbb\x9c"",\n""\xe7\xb5\xa2"": ""\xe7\xbb\x9a"",\n""\xe7\xb5\xa6"": ""\xe7\xbb\x99"",\n""\xe7\xb5\xa8"": ""\xe7\xbb\x92"",\n""\xe7\xb5\xb0"": ""\xe7\xbb\x96"",\n""\xe7\xb5\xb1"": ""\xe7\xbb\x9f"",\n""\xe7\xb5\xb2"": ""\xe4\xb8\x9d"",\n""\xe7\xb5\xb3"": ""\xe7\xbb\x9b"",\n""\xe7\xb5\xb6"": ""\xe7\xbb\x9d"",\n""\xe7\xb5\xb9"": ""\xe7\xbb\xa2"",\n""\xe7\xb6\x81"": ""\xe7\xbb\x91"",\n""\xe7\xb6\x83"": ""\xe7\xbb\xa1"",\n""\xe7\xb6\x86"": ""\xe7\xbb\xa0"",\n""\xe7\xb6\x88"": ""\xe7\xbb\xa8"",\n""\xe7\xb6\x89"": ""\xe7\xbb\xa3"",\n""\xe7\xb6\x8c"": ""\xe7\xbb\xa4"",\n""\xe7\xb6\x8f"": ""\xe7\xbb\xa5"",\n""\xe7\xb6\x90"": ""\xe4\x8c\xbc"",\n""\xe7\xb6\x93"": ""\xe7\xbb\x8f"",\n""\xe7\xb6\x9c"": ""\xe7\xbb\xbc"",\n""\xe7\xb6\x9e"": ""\xe7\xbc\x8d"",\n""\xe7\xb6\xa0"": ""\xe7\xbb\xbf"",\n""\xe7\xb6\xa2"": ""\xe7\xbb\xb8"",\n""\xe7\xb6\xa3"": ""\xe7\xbb\xbb"",\n""\xe7\xb6\xab"": ""\xe7\xba\xbf"",\n""\xe7\xb6\xac"": ""\xe7\xbb\xb6"",\n""\xe7\xb6\xad"": ""\xe7\xbb\xb4"",\n""\xe7\xb6\xaf"": ""\xe7\xbb\xb9"",\n""\xe7\xb6\xb0"": ""\xe7\xbb\xbe"",\n""\xe7\xb6\xb1"": ""\xe7\xba\xb2"",\n""\xe7\xb6\xb2"": ""\xe7\xbd\x91"",\n""\xe7\xb6\xb3"": ""\xe7\xbb\xb7"",\n""\xe7\xb6\xb4"": ""\xe7\xbc\x80"",\n""\xe7\xb6\xb5"": ""\xe4\x8c\xbd"",\n""\xe7\xb6\xb8"": ""\xe7\xba\xb6"",\n""\xe7\xb6\xb9"": ""\xe7\xbb\xba"",\n""\xe7\xb6\xba"": ""\xe7\xbb\xae"",\n""\xe7\xb6\xbb"": ""\xe7\xbb\xbd"",\n""\xe7\xb6\xbd"": ""\xe7\xbb\xb0"",\n""\xe7\xb6\xbe"": ""\xe7\xbb\xab"",\n""\xe7\xb6\xbf"": ""\xe7\xbb\xb5"",\n""\xe7\xb7\x84"": ""\xe7\xbb\xb2"",\n""\xe7\xb7\x87"": ""\xe7\xbc\x81"",\n""\xe7\xb7\x8a"": ""\xe7\xb4\xa7"",\n""\xe7\xb7\x8b"": ""\xe7\xbb\xaf"",\n""\xe7\xb7\x91"": ""\xe7\xbb\xbf"",\n""\xe7\xb7\x92"": ""\xe7\xbb\xaa"",\n""\xe7\xb7\x93"": ""\xe7\xbb\xac"",\n""\xe7\xb7\x94"": ""\xe7\xbb\xb1"",\n""\xe7\xb7\x97"": ""\xe7\xbc\x83"",\n""\xe7\xb7\x98"": ""\xe7\xbc\x84"",\n""\xe7\xb7\x99"": ""\xe7\xbc\x82"",\n""\xe7\xb7\x9a"": ""\xe7\xba\xbf"",\n""\xe7\xb7\x9d"": ""\xe7\xbc\x89"",\n""\xe7\xb7\x9e"": ""\xe7\xbc\x8e"",\n""\xe7\xb7\xa0"": ""\xe7\xbc\x94"",\n""\xe7\xb7\xa1"": ""\xe7\xbc\x97"",\n""\xe7\xb7\xa3"": ""\xe7\xbc\x98"",\n""\xe7\xb7\xa6"": ""\xe7\xbc\x8c"",\n""\xe7\xb7\xa8"": ""\xe7\xbc\x96"",\n""\xe7\xb7\xa9"": ""\xe7\xbc\x93"",\n""\xe7\xb7\xac"": ""\xe7\xbc\x85"",\n""\xe7\xb7\xaf"": ""\xe7\xba\xac"",\n""\xe7\xb7\xb1"": ""\xe7\xbc\x91"",\n""\xe7\xb7\xb2"": ""\xe7\xbc\x88"",\n""\xe7\xb7\xb4"": ""\xe7\xbb\x83"",\n""\xe7\xb7\xb6"": ""\xe7\xbc\x8f"",\n""\xe7\xb7\xb9"": ""\xe7\xbc\x87"",\n""\xe7\xb7\xbb"": ""\xe8\x87\xb4"",\n""\xe7\xb8\x88"": ""\xe8\x90\xa6"",\n""\xe7\xb8\x89"": ""\xe7\xbc\x99"",\n""\xe7\xb8\x8a"": ""\xe7\xbc\xa2"",\n""\xe7\xb8\x8b"": ""\xe7\xbc\x92"",\n""\xe7\xb8\x90"": ""\xe7\xbb\x89"",\n""\xe7\xb8\x91"": ""\xe7\xbc\xa3"",\n""\xe7\xb8\x95"": ""\xe7\xbc\x8a"",\n""\xe7\xb8\x97"": ""\xe7\xbc\x9e"",\n""\xe7\xb8\x9b"": ""\xe7\xbc\x9a"",\n""\xe7\xb8\x9d"": ""\xe7\xbc\x9c"",\n""\xe7\xb8\x9e"": ""\xe7\xbc\x9f"",\n""\xe7\xb8\x9f"": ""\xe7\xbc\x9b"",\n""\xe7\xb8\xa3"": ""\xe5\x8e\xbf"",\n""\xe7\xb8\xa7"": ""\xe7\xbb\xa6"",\n""\xe7\xb8\xab"": ""\xe7\xbc\x9d"",\n""\xe7\xb8\xad"": ""\xe7\xbc\xa1"",\n""\xe7\xb8\xae"": ""\xe7\xbc\xa9"",\n""\xe7\xb8\xb1"": ""\xe7\xba\xb5"",\n""\xe7\xb8\xb2"": ""\xe7\xbc\xa7"",\n""\xe7\xb8\xb3"": ""\xe4\x8c\xb8"",\n""\xe7\xb8\xb4"": ""\xe7\xba\xa4"",\n""\xe7\xb8\xb5"": ""\xe7\xbc\xa6"",\n""\xe7\xb8\xb6"": ""\xe7\xb5\xb7"",\n""\xe7\xb8\xb7"": ""\xe7\xbc\x95"",\n""\xe7\xb8\xb9"": ""\xe7\xbc\xa5"",\n""\xe7\xb8\xbd"": ""\xe6\x80\xbb"",\n""\xe7\xb8\xbe"": ""\xe7\xbb\xa9"",\n""\xe7\xb9\x83"": ""\xe7\xbb\xb7"",\n""\xe7\xb9\x85"": ""\xe7\xbc\xab"",\n""\xe7\xb9\x86"": ""\xe7\xbc\xaa"",\n""\xe7\xb9\x92"": ""\xe7\xbc\xaf"",\n""\xe7\xb9\x94"": ""\xe7\xbb\x87"",\n""\xe7\xb9\x95"": ""\xe7\xbc\xae"",\n""\xe7\xb9\x9a"": ""\xe7\xbc\xad"",\n""\xe7\xb9\x9e"": ""\xe7\xbb\x95"",\n""\xe7\xb9\xa1"": ""\xe7\xbb\xa3"",\n""\xe7\xb9\xa2"": ""\xe7\xbc\x8b"",\n""\xe7\xb9\xa9"": ""\xe7\xbb\xb3"",\n""\xe7\xb9\xaa"": ""\xe7\xbb\x98"",\n""\xe7\xb9\xab"": ""\xe7\xb3\xbb"",\n""\xe7\xb9\xad"": ""\xe8\x8c\xa7"",\n""\xe7\xb9\xae"": ""\xe7\xbc\xb0"",\n""\xe7\xb9\xaf"": ""\xe7\xbc\xb3"",\n""\xe7\xb9\xb0"": ""\xe7\xbc\xb2"",\n""\xe7\xb9\xb3"": ""\xe7\xbc\xb4"",\n""\xe7\xb9\xb8"": ""\xe4\x8d\x81"",\n""\xe7\xb9\xb9"": ""\xe7\xbb\x8e"",\n""\xe7\xb9\xbc"": ""\xe7\xbb\xa7"",\n""\xe7\xb9\xbd"": ""\xe7\xbc\xa4"",\n""\xe7\xb9\xbe"": ""\xe7\xbc\xb1"",\n""\xe7\xb9\xbf"": ""\xe4\x8d\x80"",\n""\xe7\xba\x88"": ""\xe7\xbc\xac"",\n""\xe7\xba\x8a"": ""\xe7\xba\xa9"",\n""\xe7\xba\x8c"": ""\xe7\xbb\xad"",\n""\xe7\xba\x8d"": ""\xe7\xb4\xaf"",\n""\xe7\xba\x8f"": ""\xe7\xbc\xa0"",\n""\xe7\xba\x93"": ""\xe7\xbc\xa8"",\n""\xe7\xba\x94"": ""\xe6\x89\x8d"",\n""\xe7\xba\x96"": ""\xe7\xba\xa4"",\n""\xe7\xba\x98"": ""\xe7\xbc\xb5"",\n""\xe7\xba\x9c"": ""\xe7\xbc\x86"",\n""\xe7\xbc\xbd"": ""\xe9\x92\xb5"",\n""\xe7\xbd\x88"": ""\xe5\x9d\x9b"",\n""\xe7\xbd\x8c"": ""\xe7\xbd\x82"",\n""\xe7\xbd\xb0"": ""\xe7\xbd\x9a"",\n""\xe7\xbd\xb5"": ""\xe9\xaa\x82"",\n""\xe7\xbd\xb7"": ""\xe7\xbd\xa2"",\n""\xe7\xbe\x85"": ""\xe7\xbd\x97"",\n""\xe7\xbe\x86"": ""\xe7\xbd\xb4"",\n""\xe7\xbe\x88"": ""\xe7\xbe\x81"",\n""\xe7\xbe\x8b"": ""\xe8\x8a\x88"",\n""\xe7\xbe\xa5"": ""\xe7\xbe\x9f"",\n""\xe7\xbe\xa9"": ""\xe4\xb9\x89"",\n""\xe7\xbf\x92"": ""\xe4\xb9\xa0"",\n""\xe7\xbf\xb9"": ""\xe7\xbf\x98"",\n""\xe8\x80\xac"": ""\xe8\x80\xa7"",\n""\xe8\x80\xae"": ""\xe8\x80\xa2"",\n""\xe8\x81\x96"": ""\xe5\x9c\xa3"",\n""\xe8\x81\x9e"": ""\xe9\x97\xbb"",\n""\xe8\x81\xaf"": ""\xe8\x81\x94"",\n""\xe8\x81\xb0"": ""\xe8\x81\xaa"",\n""\xe8\x81\xb2"": ""\xe5\xa3\xb0"",\n""\xe8\x81\xb3"": ""\xe8\x80\xb8"",\n""\xe8\x81\xb5"": ""\xe8\x81\xa9"",\n""\xe8\x81\xb6"": ""\xe8\x81\x82"",\n""\xe8\x81\xb7"": ""\xe8\x81\x8c"",\n""\xe8\x81\xb9"": ""\xe8\x81\x8d"",\n""\xe8\x81\xbd"": ""\xe5\x90\xac"",\n""\xe8\x81\xbe"": ""\xe8\x81\x8b"",\n""\xe8\x82\x85"": ""\xe8\x82\x83"",\n""\xe8\x83\x9c"": ""\xe8\x83\x9c"",\n""\xe8\x84\x85"": ""\xe8\x83\x81"",\n""\xe8\x84\x88"": ""\xe8\x84\x89"",\n""\xe8\x84\x9b"": ""\xe8\x83\xab"",\n""\xe8\x84\xab"": ""\xe8\x84\xb1"",\n""\xe8\x84\xb9"": ""\xe8\x83\x80"",\n""\xe8\x85\x8a"": ""\xe8\x85\x8a"",\n""\xe8\x85\x8e"": ""\xe8\x82\xbe"",\n""\xe8\x85\x96"": ""\xe8\x83\xa8"",\n""\xe8\x85\xa1"": ""\xe8\x84\xb6"",\n""\xe8\x85\xa6"": ""\xe8\x84\x91"",\n""\xe8\x85\xab"": ""\xe8\x82\xbf"",\n""\xe8\x85\xb3"": ""\xe8\x84\x9a"",\n""\xe8\x85\xb8"": ""\xe8\x82\xa0"",\n""\xe8\x86\x83"": ""\xe8\x85\xbd"",\n""\xe8\x86\x9a"": ""\xe8\x82\xa4"",\n""\xe8\x86\xa0"": ""\xe8\x83\xb6"",\n""\xe8\x86\xa9"": ""\xe8\x85\xbb"",\n""\xe8\x86\xbd"": ""\xe8\x83\x86"",\n""\xe8\x86\xbe"": ""\xe8\x84\x8d"",\n""\xe8\x86\xbf"": ""\xe8\x84\x93"",\n""\xe8\x87\x89"": ""\xe8\x84\xb8"",\n""\xe8\x87\x8d"": ""\xe8\x84\x90"",\n""\xe8\x87\x8f"": ""\xe8\x86\x91"",\n""\xe8\x87\x98"": ""\xe8\x85\x8a"",\n""\xe8\x87\x9a"": ""\xe8\x83\xaa"",\n""\xe8\x87\x9f"": ""\xe8\x84\x8f"",\n""\xe8\x87\xa0"": ""\xe8\x84\x94"",\n""\xe8\x87\xa2"": ""\xe8\x87\x9c"",\n""\xe8\x87\xa5"": ""\xe5\x8d\xa7"",\n""\xe8\x87\xa8"": ""\xe4\xb8\xb4"",\n""\xe8\x87\xba"": ""\xe5\x8f\xb0"",\n""\xe8\x88\x87"": ""\xe4\xb8\x8e"",\n""\xe8\x88\x88"": ""\xe5\x85\xb4"",\n""\xe8\x88\x89"": ""\xe4\xb8\xbe"",\n""\xe8\x88\x8a"": ""\xe6\x97\xa7"",\n""\xe8\x89\x99"": ""\xe8\x88\xb1"",\n""\xe8\x89\xa4"": ""\xe8\x88\xa3"",\n""\xe8\x89\xa6"": ""\xe8\x88\xb0"",\n""\xe8\x89\xab"": ""\xe8\x88\xbb"",\n""\xe8\x89\xb1"": ""\xe8\x89\xb0"",\n""\xe8\x89\xb7"": ""\xe8\x89\xb3"",\n""\xe8\x8a\xbb"": ""\xe5\x88\x8d"",\n""\xe8\x8b\xa7"": ""\xe8\x8b\x8e"",\n""\xe8\x8b\xb9"": ""\xe8\x8b\xb9"",\n""\xe8\x8c\x83"": ""\xe8\x8c\x83"",\n""\xe8\x8c\xb2"": ""\xe5\x85\xb9"",\n""\xe8\x8d\x8a"": ""\xe8\x8d\x86"",\n""\xe8\x8e\x8a"": ""\xe5\xba\x84"",\n""\xe8\x8e\x96"": ""\xe8\x8c\x8e"",\n""\xe8\x8e\xa2"": ""\xe8\x8d\x9a"",\n""\xe8\x8e\xa7"": ""\xe8\x8b\x8b"",\n""\xe8\x8f\xaf"": ""\xe5\x8d\x8e"",\n""\xe8\x90\x87"": ""\xe8\x8b\x8c"",\n""\xe8\x90\x8a"": ""\xe8\x8e\xb1"",\n""\xe8\x90\xac"": ""\xe4\xb8\x87"",\n""\xe8\x90\xb5"": ""\xe8\x8e\xb4"",\n""\xe8\x91\x89"": ""\xe5\x8f\xb6"",\n""\xe8\x91\x92"": ""\xe8\x8d\xad"",\n""\xe8\x91\x97"": ""\xe7\x9d\x80"",\n""\xe8\x91\x97\xe5\x90\x8d"": ""\xe8\x91\x97\xe5\x90\x8d"",\n""\xe8\x91\xa4"": ""\xe8\x8d\xae"",\n""\xe8\x91\xa6"": ""\xe8\x8b\x87"",\n""\xe8\x91\xaf"": ""\xe8\x8d\xaf"",\n""\xe8\x91\xb7"": ""\xe8\x8d\xa4"",\n""\xe8\x92\x93"": ""\xe8\x8e\xbc"",\n""\xe8\x92\x94"": ""\xe8\x8e\xb3"",\n""\xe8\x92\x9e"": ""\xe8\x8e\x85"",\n""\xe8\x92\xbc"": ""\xe8\x8b\x8d"",\n""\xe8\x93\x80"": ""\xe8\x8d\xaa"",\n""\xe8\x93\x8b"": ""\xe7\x9b\x96"",\n""\xe8\x93\xae"": ""\xe8\x8e\xb2"",\n""\xe8\x93\xaf"": ""\xe8\x8b\x81"",\n""\xe8\x93\xb4"": ""\xe8\x8e\xbc"",\n""\xe8\x93\xbd"": ""\xe8\x8d\x9c"",\n""\xe8\x94\x94"": ""\xe5\x8d\x9c"",\n""\xe8\x94\x9e"": ""\xe8\x92\x8c"",\n""\xe8\x94\xa3"": ""\xe8\x92\x8b"",\n""\xe8\x94\xa5"": ""\xe8\x91\xb1"",\n""\xe8\x94\xa6"": ""\xe8\x8c\x91"",\n""\xe8\x94\xad"": ""\xe8\x8d\xab"",\n""\xe8\x95\x81"": ""\xe8\x8d\xa8"",\n""\xe8\x95\x86"": ""\xe8\x92\x87"",\n""\xe8\x95\x8e"": ""\xe8\x8d\x9e"",\n""\xe8\x95\x92"": ""\xe8\x8d\xac"",\n""\xe8\x95\x93"": ""\xe8\x8a\xb8"",\n""\xe8\x95\x95"": ""\xe8\x8e\xb8"",\n""\xe8\x95\x98"": ""\xe8\x8d\x9b"",\n""\xe8\x95\xa2"": ""\xe8\x92\x89"",\n""\xe8\x95\xa9"": ""\xe8\x8d\xa1"",\n""\xe8\x95\xaa"": ""\xe8\x8a\x9c"",\n""\xe8\x95\xad"": ""\xe8\x90\xa7"",\n""\xe8\x95\xb7"": ""\xe8\x93\xa3"",\n""\xe8\x96\x80"": ""\xe8\x95\xb0"",\n""\xe8\x96\x88"": ""\xe8\x8d\x9f"",\n""\xe8\x96\x8a"": ""\xe8\x93\x9f"",\n""\xe8\x96\x8c"": ""\xe8\x8a\x97"",\n""\xe8\x96\x94"": ""\xe8\x94\xb7"",\n""\xe8\x96\x98"": ""\xe8\x8d\x99"",\n""\xe8\x96\x9f"": ""\xe8\x8e\xb6"",\n""\xe8\x96\xa6"": ""\xe8\x8d\x90"",\n""\xe8\x96\xa9"": ""\xe8\x90\xa8"",\n""\xe8\x96\xb3"": ""\xe4\x93\x95"",\n""\xe8\x96\xb4"": ""\xe8\x8b\xa7"",\n""\xe8\x96\xba"": ""\xe8\x8d\xa0"",\n""\xe8\x97\x89"": ""\xe5\x80\x9f"",\n""\xe8\x97\x8d"": ""\xe8\x93\x9d"",\n""\xe8\x97\x8e"": ""\xe8\x8d\xa9"",\n""\xe8\x97\x9d"": ""\xe8\x89\xba"",\n""\xe8\x97\xa5"": ""\xe8\x8d\xaf"",\n""\xe8\x97\xaa"": ""\xe8\x96\xae"",\n""\xe8\x97\xb4"": ""\xe8\x95\xb4"",\n""\xe8\x97\xb6"": ""\xe8\x8b\x88"",\n""\xe8\x97\xb9"": ""\xe8\x94\xbc"",\n""\xe8\x97\xba"": ""\xe8\x94\xba"",\n""\xe8\x98\x84"": ""\xe8\x95\xb2"",\n""\xe8\x98\x86"": ""\xe8\x8a\xa6"",\n""\xe8\x98\x87"": ""\xe8\x8b\x8f"",\n""\xe8\x98\x8a"": ""\xe8\x95\xb4"",\n""\xe8\x98\x8b"": ""\xe8\x8b\xb9"",\n""\xe8\x98\x9a"": ""\xe8\x97\x93"",\n""\xe8\x98\x9e"": ""\xe8\x94\xb9"",\n""\xe8\x98\xa2"": ""\xe8\x8c\x8f"",\n""\xe8\x98\xad"": ""\xe5\x85\xb0"",\n""\xe8\x98\xba"": ""\xe8\x93\xa0"",\n""\xe8\x98\xbf"": ""\xe8\x90\x9d"",\n""\xe8\x99\x86"": ""\xe8\x94\x82"",\n""\xe8\x99\x95"": ""\xe5\xa4\x84"",\n""\xe8\x99\x9b"": ""\xe8\x99\x9a"",\n""\xe8\x99\x9c"": ""\xe8\x99\x8f"",\n""\xe8\x99\x9f"": ""\xe5\x8f\xb7"",\n""\xe8\x99\xa7"": ""\xe4\xba\x8f"",\n""\xe8\x99\xab"": ""\xe8\x99\xab"",\n""\xe8\x99\xaf"": ""\xe8\x99\xac"",\n""\xe8\x9b\xba"": ""\xe8\x9b\xb1"",\n""\xe8\x9b\xbb"": ""\xe8\x9c\x95"",\n""\xe8\x9c\x86"": ""\xe8\x9a\xac"",\n""\xe8\x9c\xa1"": ""\xe8\x9c\xa1"",\n""\xe8\x9d\x95"": ""\xe8\x9a\x80"",\n""\xe8\x9d\x9f"": ""\xe7\x8c\xac"",\n""\xe8\x9d\xa6"": ""\xe8\x99\xbe"",\n""\xe8\x9d\xb8"": ""\xe8\x9c\x97"",\n""\xe8\x9e\x84"": ""\xe8\x9b\xb3"",\n""\xe8\x9e\x9e"": ""\xe8\x9a\x82"",\n""\xe8\x9e\xa2"": ""\xe8\x90\xa4"",\n""\xe8\x9e\xae"": ""\xe4\x97\x96"",\n""\xe8\x9e\xbb"": ""\xe8\x9d\xbc"",\n""\xe8\x9e\xbf"": ""\xe8\x9e\x80"",\n""\xe8\x9f\x84"": ""\xe8\x9b\xb0"",\n""\xe8\x9f\x88"": ""\xe8\x9d\x88"",\n""\xe8\x9f\x8e"": ""\xe8\x9e\xa8"",\n""\xe8\x9f\xa3"": ""\xe8\x99\xae"",\n""\xe8\x9f\xac"": ""\xe8\x9d\x89"",\n""\xe8\x9f\xaf"": ""\xe8\x9b\xb2"",\n""\xe8\x9f\xb2"": ""\xe8\x99\xab"",\n""\xe8\x9f\xb6"": ""\xe8\x9b\x8f"",\n""\xe8\x9f\xbb"": ""\xe8\x9a\x81"",\n""\xe8\xa0\x85"": ""\xe8\x9d\x87"",\n""\xe8\xa0\x86"": ""\xe8\x99\xbf"",\n""\xe8\xa0\x90"": ""\xe8\x9b\xb4"",\n""\xe8\xa0\x91"": ""\xe8\x9d\xbe"",\n""\xe8\xa0\x9f"": ""\xe8\x9c\xa1"",\n""\xe8\xa0\xa3"": ""\xe8\x9b\x8e"",\n""\xe8\xa0\xa8"": ""\xe8\x9f\x8f"",\n""\xe8\xa0\xb1"": ""\xe8\x9b\x8a"",\n""\xe8\xa0\xb6"": ""\xe8\x9a\x95"",\n""\xe8\xa0\xbb"": ""\xe8\x9b\xae"",\n""\xe8\xa1\x86"": ""\xe4\xbc\x97"",\n""\xe8\xa1\x8a"": ""\xe8\x94\x91"",\n""\xe8\xa1\x93"": ""\xe6\x9c\xaf"",\n""\xe8\xa1\x95"": ""\xe5\x90\x8c"",\n""\xe8\xa1\x9a"": ""\xe8\x83\xa1"",\n""\xe8\xa1\x9b"": ""\xe5\x8d\xab"",\n""\xe8\xa1\x9d"": ""\xe5\x86\xb2"",\n""\xe8\xa1\xb9"": ""\xe5\x8f\xaa"",\n""\xe8\xa2\x9e"": ""\xe8\xa1\xae"",\n""\xe8\xa3\x8a"": ""\xe8\xa2\x85"",\n""\xe8\xa3\x8f"": ""\xe9\x87\x8c"",\n""\xe8\xa3\x9c"": ""\xe8\xa1\xa5"",\n""\xe8\xa3\x9d"": ""\xe8\xa3\x85"",\n""\xe8\xa3\xa1"": ""\xe9\x87\x8c"",\n""\xe8\xa3\xbd"": ""\xe5\x88\xb6"",\n""\xe8\xa4\x87"": ""\xe5\xa4\x8d"",\n""\xe8\xa4\x8c"": ""\xe8\xa3\x88"",\n""\xe8\xa4\x98"": ""\xe8\xa2\x86"",\n""\xe8\xa4\xb2"": ""\xe8\xa3\xa4"",\n""\xe8\xa4\xb3"": ""\xe8\xa3\xa2"",\n""\xe8\xa4\xb8"": ""\xe8\xa4\x9b"",\n""\xe8\xa4\xbb"": ""\xe4\xba\xb5"",\n""\xe8\xa5\x87"": ""\xe8\xa3\xa5"",\n""\xe8\xa5\x8f"": ""\xe8\xa2\xaf"",\n""\xe8\xa5\x96"": ""\xe8\xa2\x84"",\n""\xe8\xa5\x9d"": ""\xe8\xa3\xa3"",\n""\xe8\xa5\xa0"": ""\xe8\xa3\x86"",\n""\xe8\xa5\xa4"": ""\xe8\xa4\xb4"",\n""\xe8\xa5\xaa"": ""\xe8\xa2\x9c"",\n""\xe8\xa5\xac"": ""\xe4\x99\x93"",\n""\xe8\xa5\xaf"": ""\xe8\xa1\xac"",\n""\xe8\xa5\xb2"": ""\xe8\xa2\xad"",\n""\xe8\xa6\x86"": ""\xe5\xa4\x8d"",\n""\xe8\xa6\x86\xe8\x93\x8b"": ""\xe8\xa6\x86\xe7\x9b\x96"",\n""\xe7\xbf\xbb\xe4\xbe\x86\xe8\xa6\x86\xe5\x8e\xbb"": ""\xe7\xbf\xbb\xe6\x9d\xa5\xe8\xa6\x86\xe5\x8e\xbb"",\n""\xe8\xa6\x8b"": ""\xe8\xa7\x81"",\n""\xe8\xa6\x8e"": ""\xe8\xa7\x83"",\n""\xe8\xa6\x8f"": ""\xe8\xa7\x84"",\n""\xe8\xa6\x93"": ""\xe8\xa7\x85"",\n""\xe8\xa6\x96"": ""\xe8\xa7\x86"",\n""\xe8\xa6\x98"": ""\xe8\xa7\x87"",\n""\xe8\xa6\xa1"": ""\xe8\xa7\x8b"",\n""\xe8\xa6\xa5"": ""\xe8\xa7\x8d"",\n""\xe8\xa6\xa6"": ""\xe8\xa7\x8e"",\n""\xe8\xa6\xaa"": ""\xe4\xba\xb2"",\n""\xe8\xa6\xac"": ""\xe8\xa7\x8a"",\n""\xe8\xa6\xaf"": ""\xe8\xa7\x8f"",\n""\xe8\xa6\xb2"": ""\xe8\xa7\x90"",\n""\xe8\xa6\xb7"": ""\xe8\xa7\x91"",\n""\xe8\xa6\xba"": ""\xe8\xa7\x89"",\n""\xe8\xa6\xbd"": ""\xe8\xa7\x88"",\n""\xe8\xa6\xbf"": ""\xe8\xa7\x8c"",\n""\xe8\xa7\x80"": ""\xe8\xa7\x82"",\n""\xe8\xa7\xb4"": ""\xe8\xa7\x9e"",\n""\xe8\xa7\xb6"": ""\xe8\xa7\xaf"",\n""\xe8\xa7\xb8"": ""\xe8\xa7\xa6"",\n""\xe8\xa8\x81"": ""\xe8\xae\xa0"",\n""\xe8\xa8\x82"": ""\xe8\xae\xa2"",\n""\xe8\xa8\x83"": ""\xe8\xae\xa3"",\n""\xe8\xa8\x88"": ""\xe8\xae\xa1"",\n""\xe8\xa8\x8a"": ""\xe8\xae\xaf"",\n""\xe8\xa8\x8c"": ""\xe8\xae\xa7"",\n""\xe8\xa8\x8e"": ""\xe8\xae\xa8"",\n""\xe8\xa8\x90"": ""\xe8\xae\xa6"",\n""\xe8\xa8\x92"": ""\xe8\xae\xb1"",\n""\xe8\xa8\x93"": ""\xe8\xae\xad"",\n""\xe8\xa8\x95"": ""\xe8\xae\xaa"",\n""\xe8\xa8\x96"": ""\xe8\xae\xab"",\n""\xe8\xa8\x97"": ""\xe8\xae\xac"",\n""\xe8\xa8\x98"": ""\xe8\xae\xb0"",\n""\xe8\xa8\x9b"": ""\xe8\xae\xb9"",\n""\xe8\xa8\x9d"": ""\xe8\xae\xb6"",\n""\xe8\xa8\x9f"": ""\xe8\xae\xbc"",\n""\xe8\xa8\xa2"": ""\xe4\x9c\xa3"",\n""\xe8\xa8\xa3"": ""\xe8\xaf\x80"",\n""\xe8\xa8\xa5"": ""\xe8\xae\xb7"",\n""\xe8\xa8\xa9"": ""\xe8\xae\xbb"",\n""\xe8\xa8\xaa"": ""\xe8\xae\xbf"",\n""\xe8\xa8\xad"": ""\xe8\xae\xbe"",\n""\xe8\xa8\xb1"": ""\xe8\xae\xb8"",\n""\xe8\xa8\xb4"": ""\xe8\xaf\x89"",\n""\xe8\xa8\xb6"": ""\xe8\xaf\x83"",\n""\xe8\xa8\xba"": ""\xe8\xaf\x8a"",\n""\xe8\xa8\xbb"": ""\xe6\xb3\xa8"",\n""\xe8\xa9\x81"": ""\xe8\xaf\x82"",\n""\xe8\xa9\x86"": ""\xe8\xaf\x8b"",\n""\xe8\xa9\x8e"": ""\xe8\xae\xb5"",\n""\xe8\xa9\x90"": ""\xe8\xaf\x88"",\n""\xe8\xa9\x92"": ""\xe8\xaf\x92"",\n""\xe8\xa9\x94"": ""\xe8\xaf\x8f"",\n""\xe8\xa9\x95"": ""\xe8\xaf\x84"",\n""\xe8\xa9\x96"": ""\xe8\xaf\x90"",\n""\xe8\xa9\x97"": ""\xe8\xaf\x87"",\n""\xe8\xa9\x98"": ""\xe8\xaf\x8e"",\n""\xe8\xa9\x9b"": ""\xe8\xaf\x85"",\n""\xe8\xa9\x9e"": ""\xe8\xaf\x8d"",\n""\xe8\xa9\xa0"": ""\xe5\x92\x8f"",\n""\xe8\xa9\xa1"": ""\xe8\xaf\xa9"",\n""\xe8\xa9\xa2"": ""\xe8\xaf\xa2"",\n""\xe8\xa9\xa3"": ""\xe8\xaf\xa3"",\n""\xe8\xa9\xa6"": ""\xe8\xaf\x95"",\n""\xe8\xa9\xa9"": ""\xe8\xaf\x97"",\n""\xe8\xa9\xab"": ""\xe8\xaf\xa7"",\n""\xe8\xa9\xac"": ""\xe8\xaf\x9f"",\n""\xe8\xa9\xad"": ""\xe8\xaf\xa1"",\n""\xe8\xa9\xae"": ""\xe8\xaf\xa0"",\n""\xe8\xa9\xb0"": ""\xe8\xaf\x98"",\n""\xe8\xa9\xb1"": ""\xe8\xaf\x9d"",\n""\xe8\xa9\xb2"": ""\xe8\xaf\xa5"",\n""\xe8\xa9\xb3"": ""\xe8\xaf\xa6"",\n""\xe8\xa9\xb5"": ""\xe8\xaf\x9c"",\n""\xe8\xa9\xbc"": ""\xe8\xaf\x99"",\n""\xe8\xa9\xbf"": ""\xe8\xaf\x96"",\n""\xe8\xaa\x84"": ""\xe8\xaf\x94"",\n""\xe8\xaa\x85"": ""\xe8\xaf\x9b"",\n""\xe8\xaa\x86"": ""\xe8\xaf\x93"",\n""\xe8\xaa\x87"": ""\xe5\xa4\xb8"",\n""\xe8\xaa\x8c"": ""\xe5\xbf\x97"",\n""\xe8\xaa\x8d"": ""\xe8\xae\xa4"",\n""\xe8\xaa\x91"": ""\xe8\xaf\xb3"",\n""\xe8\xaa\x92"": ""\xe8\xaf\xb6"",\n""\xe8\xaa\x95"": ""\xe8\xaf\x9e"",\n""\xe8\xaa\x98"": ""\xe8\xaf\xb1"",\n""\xe8\xaa\x9a"": ""\xe8\xaf\xae"",\n""\xe8\xaa\x9e"": ""\xe8\xaf\xad"",\n""\xe8\xaa\xa0"": ""\xe8\xaf\x9a"",\n""\xe8\xaa\xa1"": ""\xe8\xaf\xab"",\n""\xe8\xaa\xa3"": ""\xe8\xaf\xac"",\n""\xe8\xaa\xa4"": ""\xe8\xaf\xaf"",\n""\xe8\xaa\xa5"": ""\xe8\xaf\xb0"",\n""\xe8\xaa\xa6"": ""\xe8\xaf\xb5"",\n""\xe8\xaa\xa8"": ""\xe8\xaf\xb2"",\n""\xe8\xaa\xaa"": ""\xe8\xaf\xb4"",\n""\xe8\xaa\xac"": ""\xe8\xaf\xb4"",\n""\xe8\xaa\xb0"": ""\xe8\xb0\x81"",\n""\xe8\xaa\xb2"": ""\xe8\xaf\xbe"",\n""\xe8\xaa\xb6"": ""\xe8\xb0\x87"",\n""\xe8\xaa\xb9"": ""\xe8\xaf\xbd"",\n""\xe8\xaa\xbc"": ""\xe8\xb0\x8a"",\n""\xe8\xaa\xbe"": ""\xe8\xa8\x9a"",\n""\xe8\xaa\xbf"": ""\xe8\xb0\x83"",\n""\xe8\xab\x82"": ""\xe8\xb0\x84"",\n""\xe8\xab\x84"": ""\xe8\xb0\x86"",\n""\xe8\xab\x87"": ""\xe8\xb0\x88"",\n""\xe8\xab\x89"": ""\xe8\xaf\xbf"",\n""\xe8\xab\x8b"": ""\xe8\xaf\xb7"",\n""\xe8\xab\x8d"": ""\xe8\xaf\xa4"",\n""\xe8\xab\x8f"": ""\xe8\xaf\xb9"",\n""\xe8\xab\x91"": ""\xe8\xaf\xbc"",\n""\xe8\xab\x92"": ""\xe8\xb0\x85"",\n""\xe8\xab\x96"": ""\xe8\xae\xba"",\n""\xe8\xab\x97"": ""\xe8\xb0\x82"",\n""\xe8\xab\x9b"": ""\xe8\xb0\x80"",\n""\xe8\xab\x9c"": ""\xe8\xb0\x8d"",\n""\xe8\xab\x9d"": ""\xe8\xb0\x9e"",\n""\xe8\xab\x9e"": ""\xe8\xb0\x9d"",\n""\xe8\xab\xa2"": ""\xe8\xaf\xa8"",\n""\xe8\xab\xa4"": ""\xe8\xb0\x94"",\n""\xe8\xab\xa6"": ""\xe8\xb0\x9b"",\n""\xe8\xab\xa7"": ""\xe8\xb0\x90"",\n""\xe8\xab\xab"": ""\xe8\xb0\x8f"",\n""\xe8\xab\xad"": ""\xe8\xb0\x95"",\n""\xe8\xab\xae"": ""\xe8\xb0\x98"",\n""\xe8\xab\xb1"": ""\xe8\xae\xb3"",\n""\xe8\xab\xb3"": ""\xe8\xb0\x99"",\n""\xe8\xab\xb6"": ""\xe8\xb0\x8c"",\n""\xe8\xab\xb7"": ""\xe8\xae\xbd"",\n""\xe8\xab\xb8"": ""\xe8\xaf\xb8"",\n""\xe8\xab\xba"": ""\xe8\xb0\x9a"",\n""\xe8\xab\xbc"": ""\xe8\xb0\x96"",\n""\xe8\xab\xbe"": ""\xe8\xaf\xba"",\n""\xe8\xac\x80"": ""\xe8\xb0\x8b"",\n""\xe8\xac\x81"": ""\xe8\xb0\x92"",\n""\xe8\xac\x82"": ""\xe8\xb0\x93"",\n""\xe8\xac\x84"": ""\xe8\xaa\x8a"",\n""\xe8\xac\x85"": ""\xe8\xaf\x8c"",\n""\xe8\xac\x8a"": ""\xe8\xb0\x8e"",\n""\xe8\xac\x8e"": ""\xe8\xb0\x9c"",\n""\xe8\xac\x90"": ""\xe8\xb0\xa7"",\n""\xe8\xac\x94"": ""\xe8\xb0\x91"",\n""\xe8\xac\x96"": ""\xe8\xb0\xa1"",\n""\xe8\xac\x97"": ""\xe8\xb0\xa4"",\n""\xe8\xac\x99"": ""\xe8\xb0\xa6"",\n""\xe8\xac\x9a"": ""\xe8\xb0\xa5"",\n""\xe8\xac\x9b"": ""\xe8\xae\xb2"",\n""\xe8\xac\x9d"": ""\xe8\xb0\xa2"",\n""\xe8\xac\xa0"": ""\xe8\xb0\xa3"",\n""\xe8\xac\xa1"": ""\xe8\xb0\xa3"",\n""\xe8\xac\xa8"": ""\xe8\xb0\x9f"",\n""\xe8\xac\xab"": ""\xe8\xb0\xaa"",\n""\xe8\xac\xac"": ""\xe8\xb0\xac"",\n""\xe8\xac\xad"": ""\xe8\xb0\xab"",\n""\xe8\xac\xb3"": ""\xe8\xae\xb4"",\n""\xe8\xac\xb9"": ""\xe8\xb0\xa8"",\n""\xe8\xac\xbe"": ""\xe8\xb0\xa9"",\n""\xe8\xad\x85"": ""\xe4\x9c\xa7"",\n""\xe8\xad\x89"": ""\xe8\xaf\x81"",\n""\xe8\xad\x8e"": ""\xe8\xb0\xb2"",\n""\xe8\xad\x8f"": ""\xe8\xae\xa5"",\n""\xe8\xad\x96"": ""\xe8\xb0\xae"",\n""\xe8\xad\x98"": ""\xe8\xaf\x86"",\n""\xe8\xad\x99"": ""\xe8\xb0\xaf"",\n""\xe8\xad\x9a"": ""\xe8\xb0\xad"",\n""\xe8\xad\x9c"": ""\xe8\xb0\xb1"",\n""\xe8\xad\xab"": ""\xe8\xb0\xb5"",\n""\xe8\xad\xaf"": ""\xe8\xaf\x91"",\n""\xe8\xad\xb0"": ""\xe8\xae\xae"",\n""\xe8\xad\xb4"": ""\xe8\xb0\xb4"",\n""\xe8\xad\xb7"": ""\xe6\x8a\xa4"",\n""\xe8\xad\xb8"": ""\xe8\xaf\xaa"",\n""\xe8\xad\xbd"": ""\xe8\xaa\x89"",\n""\xe8\xad\xbe"": ""\xe8\xb0\xab"",\n""\xe8\xae\x80"": ""\xe8\xaf\xbb"",\n""\xe8\xae\x8a"": ""\xe5\x8f\x98"",\n""\xe8\xae\x8e"": ""\xe4\xbb\x87"",\n""\xe8\xae\x8e"": ""\xe9\x9b\xa0"",\n""\xe8\xae\x92"": ""\xe8\xb0\x97"",\n""\xe8\xae\x93"": ""\xe8\xae\xa9"",\n""\xe8\xae\x95"": ""\xe8\xb0\xb0"",\n""\xe8\xae\x96"": ""\xe8\xb0\xb6"",\n""\xe8\xae\x9c"": ""\xe8\xb0\xa0"",\n""\xe8\xae\x9e"": ""\xe8\xb0\xb3"",\n""\xe8\xb1\x88"": ""\xe5\xb2\x82"",\n""\xe8\xb1\x8e"": ""\xe7\xab\x96"",\n""\xe8\xb1\x90"": ""\xe4\xb8\xb0"",\n""\xe8\xb1\xac"": ""\xe7\x8c\xaa"",\n""\xe8\xb1\xb6"": ""\xe8\xb1\xae"",\n""\xe8\xb2\x93"": ""\xe7\x8c\xab"",\n""\xe8\xb2\x99"": ""\xe4\x9d\x99"",\n""\xe8\xb2\x9d"": ""\xe8\xb4\x9d"",\n""\xe8\xb2\x9e"": ""\xe8\xb4\x9e"",\n""\xe8\xb2\x9f"": ""\xe8\xb4\xa0"",\n""\xe8\xb2\xa0"": ""\xe8\xb4\x9f"",\n""\xe8\xb2\xa1"": ""\xe8\xb4\xa2"",\n""\xe8\xb2\xa2"": ""\xe8\xb4\xa1"",\n""\xe8\xb2\xa7"": ""\xe8\xb4\xab"",\n""\xe8\xb2\xa8"": ""\xe8\xb4\xa7"",\n""\xe8\xb2\xa9"": ""\xe8\xb4\xa9"",\n""\xe8\xb2\xaa"": ""\xe8\xb4\xaa"",\n""\xe8\xb2\xab"": ""\xe8\xb4\xaf"",\n""\xe8\xb2\xac"": ""\xe8\xb4\xa3"",\n""\xe8\xb2\xaf"": ""\xe8\xb4\xae"",\n""\xe8\xb2\xb0"": ""\xe8\xb4\xb3"",\n""\xe8\xb2\xb2"": ""\xe8\xb5\x80"",\n""\xe8\xb2\xb3"": ""\xe8\xb4\xb0"",\n""\xe8\xb2\xb4"": ""\xe8\xb4\xb5"",\n""\xe8\xb2\xb6"": ""\xe8\xb4\xac"",\n""\xe8\xb2\xb7"": ""\xe4\xb9\xb0"",\n""\xe8\xb2\xb8"": ""\xe8\xb4\xb7"",\n""\xe8\xb2\xba"": ""\xe8\xb4\xb6"",\n""\xe8\xb2\xbb"": ""\xe8\xb4\xb9"",\n""\xe8\xb2\xbc"": ""\xe8\xb4\xb4"",\n""\xe8\xb2\xbd"": ""\xe8\xb4\xbb"",\n""\xe8\xb2\xbf"": ""\xe8\xb4\xb8"",\n""\xe8\xb3\x80"": ""\xe8\xb4\xba"",\n""\xe8\xb3\x81"": ""\xe8\xb4\xb2"",\n""\xe8\xb3\x82"": ""\xe8\xb5\x82"",\n""\xe8\xb3\x83"": ""\xe8\xb5\x81"",\n""\xe8\xb3\x84"": ""\xe8\xb4\xbf"",\n""\xe8\xb3\x85"": ""\xe8\xb5\x85"",\n""\xe8\xb3\x87"": ""\xe8\xb5\x84"",\n""\xe8\xb3\x88"": ""\xe8\xb4\xbe"",\n""\xe8\xb3\x8a"": ""\xe8\xb4\xbc"",\n""\xe8\xb3\x91"": ""\xe8\xb5\x88"",\n""\xe8\xb3\x92"": ""\xe8\xb5\x8a"",\n""\xe8\xb3\x93"": ""\xe5\xae\xbe"",\n""\xe8\xb3\x95"": ""\xe8\xb5\x87"",\n""\xe8\xb3\x99"": ""\xe8\xb5\x92"",\n""\xe8\xb3\x9a"": ""\xe8\xb5\x89"",\n""\xe8\xb3\x9c"": ""\xe8\xb5\x90"",\n""\xe8\xb3\x9e"": ""\xe8\xb5\x8f"",\n""\xe8\xb3\xa0"": ""\xe8\xb5\x94"",\n""\xe8\xb3\xa1"": ""\xe8\xb5\x93"",\n""\xe8\xb3\xa2"": ""\xe8\xb4\xa4"",\n""\xe8\xb3\xa3"": ""\xe5\x8d\x96"",\n""\xe8\xb3\xa4"": ""\xe8\xb4\xb1"",\n""\xe8\xb3\xa6"": ""\xe8\xb5\x8b"",\n""\xe8\xb3\xa7"": ""\xe8\xb5\x95"",\n""\xe8\xb3\xaa"": ""\xe8\xb4\xa8"",\n""\xe8\xb3\xab"": ""\xe8\xb5\x8d"",\n""\xe8\xb3\xac"": ""\xe8\xb4\xa6"",\n""\xe8\xb3\xad"": ""\xe8\xb5\x8c"",\n""\xe8\xb3\xb0"": ""\xe4\x9e\x90"",\n""\xe8\xb3\xb4"": ""\xe8\xb5\x96"",\n""\xe8\xb3\xb5"": ""\xe8\xb5\x97"",\n""\xe8\xb3\xba"": ""\xe8\xb5\x9a"",\n""\xe8\xb3\xbb"": ""\xe8\xb5\x99"",\n""\xe8\xb3\xbc"": ""\xe8\xb4\xad"",\n""\xe8\xb3\xbd"": ""\xe8\xb5\x9b"",\n""\xe8\xb3\xbe"": ""\xe8\xb5\x9c"",\n""\xe8\xb4\x84"": ""\xe8\xb4\xbd"",\n""\xe8\xb4\x85"": ""\xe8\xb5\x98"",\n""\xe8\xb4\x87"": ""\xe8\xb5\x9f"",\n""\xe8\xb4\x88"": ""\xe8\xb5\xa0"",\n""\xe8\xb4\x8a"": ""\xe8\xb5\x9e"",\n""\xe8\xb4\x8b"": ""\xe8\xb5\x9d"",\n""\xe8\xb4\x8d"": ""\xe8\xb5\xa1"",\n""\xe8\xb4\x8f"": ""\xe8\xb5\xa2"",\n""\xe8\xb4\x90"": ""\xe8\xb5\x86"",\n""\xe8\xb4\x93"": ""\xe8\xb5\x83"",\n""\xe8\xb4\x94"": ""\xe8\xb5\x91"",\n""\xe8\xb4\x96"": ""\xe8\xb5\x8e"",\n""\xe8\xb4\x97"": ""\xe8\xb5\x9d"",\n""\xe8\xb4\x9b"": ""\xe8\xb5\xa3"",\n""\xe8\xb4\x9c"": ""\xe8\xb5\x83"",\n""\xe8\xb5\xac"": ""\xe8\xb5\xaa"",\n""\xe8\xb6\x95"": ""\xe8\xb5\xb6"",\n""\xe8\xb6\x99"": ""\xe8\xb5\xb5"",\n""\xe8\xb6\xa8"": ""\xe8\xb6\x8b"",\n""\xe8\xb6\xb2"": ""\xe8\xb6\xb1"",\n""\xe8\xb7\xa1"": ""\xe8\xbf\xb9"",\n""\xe8\xb8\x90"": ""\xe8\xb7\xb5"",\n""\xe8\xb8\xb4"": ""\xe8\xb8\x8a"",\n""\xe8\xb9\x8c"": ""\xe8\xb7\x84"",\n""\xe8\xb9\x95"": ""\xe8\xb7\xb8"",\n""\xe8\xb9\xa3"": ""\xe8\xb9\x92"",\n""\xe8\xb9\xa4"": ""\xe8\xb8\xaa"",\n""\xe8\xb9\xba"": ""\xe8\xb7\xb7"",\n""\xe8\xba\x82"": ""\xe8\xb7\xb6"",\n""\xe8\xba\x89"": ""\xe8\xb6\xb8"",\n""\xe8\xba\x8a"": ""\xe8\xb8\x8c"",\n""\xe8\xba\x8b"": ""\xe8\xb7\xbb"",\n""\xe8\xba\x8d"": ""\xe8\xb7\x83"",\n""\xe8\xba\x91"": ""\xe8\xb8\xaf"",\n""\xe8\xba\x92"": ""\xe8\xb7\x9e"",\n""\xe8\xba\x93"": ""\xe8\xb8\xac"",\n""\xe8\xba\x95"": ""\xe8\xb9\xb0"",\n""\xe8\xba\x9a"": ""\xe8\xb7\xb9"",\n""\xe8\xba\xa1"": ""\xe8\xb9\x91"",\n""\xe8\xba\xa5"": ""\xe8\xb9\xbf"",\n""\xe8\xba\xa6"": ""\xe8\xba\x9c"",\n""\xe8\xba\xaa"": ""\xe8\xba\x8f"",\n""\xe8\xbb\x80"": ""\xe8\xba\xaf"",\n""\xe8\xbb\x8a"": ""\xe8\xbd\xa6"",\n""\xe8\xbb\x8b"": ""\xe8\xbd\xa7"",\n""\xe8\xbb\x8c"": ""\xe8\xbd\xa8"",\n""\xe8\xbb\x8d"": ""\xe5\x86\x9b"",\n""\xe8\xbb\x91"": ""\xe8\xbd\xaa"",\n""\xe8\xbb\x92"": ""\xe8\xbd\xa9"",\n""\xe8\xbb\x94"": ""\xe8\xbd\xab"",\n""\xe8\xbb\x9b"": ""\xe8\xbd\xad"",\n""\xe8\xbb\x9f"": ""\xe8\xbd\xaf"",\n""\xe8\xbb\xa4"": ""\xe8\xbd\xb7"",\n""\xe8\xbb\xab"": ""\xe8\xbd\xb8"",\n""\xe8\xbb\xb2"": ""\xe8\xbd\xb1"",\n""\xe8\xbb\xb8"": ""\xe8\xbd\xb4"",\n""\xe8\xbb\xb9"": ""\xe8\xbd\xb5"",\n""\xe8\xbb\xba"": ""\xe8\xbd\xba"",\n""\xe8\xbb\xbb"": ""\xe8\xbd\xb2"",\n""\xe8\xbb\xbc"": ""\xe8\xbd\xb6"",\n""\xe8\xbb\xbe"": ""\xe8\xbd\xbc"",\n""\xe8\xbc\x83"": ""\xe8\xbe\x83"",\n""\xe8\xbc\x85"": ""\xe8\xbe\x82"",\n""\xe8\xbc\x87"": ""\xe8\xbe\x81"",\n""\xe8\xbc\x88"": ""\xe8\xbe\x80"",\n""\xe8\xbc\x89"": ""\xe8\xbd\xbd"",\n""\xe8\xbc\x8a"": ""\xe8\xbd\xbe"",\n""\xe8\xbc\x92"": ""\xe8\xbe\x84"",\n""\xe8\xbc\x93"": ""\xe6\x8c\xbd"",\n""\xe8\xbc\x94"": ""\xe8\xbe\x85"",\n""\xe8\xbc\x95"": ""\xe8\xbd\xbb"",\n""\xe8\xbc\x9b"": ""\xe8\xbe\x86"",\n""\xe8\xbc\x9c"": ""\xe8\xbe\x8e"",\n""\xe8\xbc\x9d"": ""\xe8\xbe\x89"",\n""\xe8\xbc\x9e"": ""\xe8\xbe\x8b"",\n""\xe8\xbc\x9f"": ""\xe8\xbe\x8d"",\n""\xe8\xbc\xa5"": ""\xe8\xbe\x8a"",\n""\xe8\xbc\xa6"": ""\xe8\xbe\x87"",\n""\xe8\xbc\xa9"": ""\xe8\xbe\x88"",\n""\xe8\xbc\xaa"": ""\xe8\xbd\xae"",\n""\xe8\xbc\xac"": ""\xe8\xbe\x8c"",\n""\xe8\xbc\xaf"": ""\xe8\xbe\x91"",\n""\xe8\xbc\xb3"": ""\xe8\xbe\x8f"",\n""\xe8\xbc\xb8"": ""\xe8\xbe\x93"",\n""\xe8\xbc\xbb"": ""\xe8\xbe\x90"",\n""\xe8\xbc\xbe"": ""\xe8\xbe\x97"",\n""\xe8\xbc\xbf"": ""\xe8\x88\x86"",\n""\xe8\xbd\x80"": ""\xe8\xbe\x92"",\n""\xe8\xbd\x82"": ""\xe6\xaf\x82"",\n""\xe8\xbd\x84"": ""\xe8\xbe\x96"",\n""\xe8\xbd\x85"": ""\xe8\xbe\x95"",\n""\xe8\xbd\x86"": ""\xe8\xbe\x98"",\n""\xe8\xbd\x89"": ""\xe8\xbd\xac"",\n""\xe8\xbd\x8d"": ""\xe8\xbe\x99"",\n""\xe8\xbd\x8e"": ""\xe8\xbd\xbf"",\n""\xe8\xbd\x94"": ""\xe8\xbe\x9a"",\n""\xe8\xbd\x9f"": ""\xe8\xbd\xb0"",\n""\xe8\xbd\xa1"": ""\xe8\xbe\x94"",\n""\xe8\xbd\xa2"": ""\xe8\xbd\xb9"",\n""\xe8\xbd\xa4"": ""\xe8\xbd\xb3"",\n""\xe8\xbe\x9f"": ""\xe8\xbe\x9f"",\n""\xe8\xbe\xa6"": ""\xe5\x8a\x9e"",\n""\xe8\xbe\xad"": ""\xe8\xbe\x9e"",\n""\xe8\xbe\xae"": ""\xe8\xbe\xab"",\n""\xe8\xbe\xaf"": ""\xe8\xbe\xa9"",\n""\xe8\xbe\xb2"": ""\xe5\x86\x9c"",\n""\xe8\xbf\xb4"": ""\xe5\x9b\x9e"",\n""\xe9\x80\x82"": ""\xe9\x80\x82"",\n""\xe9\x80\x95"": ""\xe8\xbf\xb3"",\n""\xe9\x80\x99"": ""\xe8\xbf\x99"",\n""\xe9\x80\xa3"": ""\xe8\xbf\x9e"",\n""\xe9\x80\xb1"": ""\xe5\x91\xa8"",\n""\xe9\x80\xb2"": ""\xe8\xbf\x9b"",\n""\xe9\x81\x8a"": ""\xe6\xb8\xb8"",\n""\xe9\x81\x8b"": ""\xe8\xbf\x90"",\n""\xe9\x81\x8e"": ""\xe8\xbf\x87"",\n""\xe9\x81\x94"": ""\xe8\xbe\xbe"",\n""\xe9\x81\x95"": ""\xe8\xbf\x9d"",\n""\xe9\x81\x99"": ""\xe9\x81\xa5"",\n""\xe9\x81\x9c"": ""\xe9\x80\x8a"",\n""\xe9\x81\x9e"": ""\xe9\x80\x92"",\n""\xe9\x81\xa0"": ""\xe8\xbf\x9c"",\n""\xe9\x81\xa9"": ""\xe9\x80\x82"",\n""\xe9\x81\xb2"": ""\xe8\xbf\x9f"",\n""\xe9\x81\xb7"": ""\xe8\xbf\x81"",\n""\xe9\x81\xb8"": ""\xe9\x80\x89"",\n""\xe9\x81\xba"": ""\xe9\x81\x97"",\n""\xe9\x81\xbc"": ""\xe8\xbe\xbd"",\n""\xe9\x82\x81"": ""\xe8\xbf\x88"",\n""\xe9\x82\x84"": ""\xe8\xbf\x98"",\n""\xe9\x82\x87"": ""\xe8\xbf\xa9"",\n""\xe9\x82\x8a"": ""\xe8\xbe\xb9"",\n""\xe9\x82\x8f"": ""\xe9\x80\xbb"",\n""\xe9\x82\x90"": ""\xe9\x80\xa6"",\n""\xe9\x83\x81"": ""\xe9\x83\x81"",\n""\xe9\x83\x9f"": ""\xe9\x83\x8f"",\n""\xe9\x83\xb5"": ""\xe9\x82\xae"",\n""\xe9\x84\x86"": ""\xe9\x83\x93"",\n""\xe9\x84\x89"": ""\xe4\xb9\xa1"",\n""\xe9\x84\x92"": ""\xe9\x82\xb9"",\n""\xe9\x84\x94"": ""\xe9\x82\xac"",\n""\xe9\x84\x96"": ""\xe9\x83\xa7"",\n""\xe9\x84\xa7"": ""\xe9\x82\x93"",\n""\xe9\x84\xad"": ""\xe9\x83\x91"",\n""\xe9\x84\xb0"": ""\xe9\x82\xbb"",\n""\xe9\x84\xb2"": ""\xe9\x83\xb8"",\n""\xe9\x84\xb4"": ""\xe9\x82\xba"",\n""\xe9\x84\xb6"": ""\xe9\x83\x90"",\n""\xe9\x84\xba"": ""\xe9\x82\x9d"",\n""\xe9\x85\x87"": ""\xe9\x85\x82"",\n""\xe9\x85\x88"": ""\xe9\x83\xa6"",\n""\xe9\x86\x96"": ""\xe9\x85\x9d"",\n""\xe9\x86\x9c"": ""\xe4\xb8\x91"",\n""\xe9\x86\x9e"": ""\xe9\x85\x9d"",\n""\xe9\x86\xab"": ""\xe5\x8c\xbb"",\n""\xe9\x86\xac"": ""\xe9\x85\xb1"",\n""\xe9\x86\xb1"": ""\xe9\x85\xa6"",\n""\xe9\x87\x80"": ""\xe9\x85\xbf"",\n""\xe9\x87\x81"": ""\xe8\xa1\x85"",\n""\xe9\x87\x83"": ""\xe9\x85\xbe"",\n""\xe9\x87\x85"": ""\xe9\x85\xbd"",\n""\xe9\x87\x87"": ""\xe9\x87\x87"",\n""\xe9\x87\x8b"": ""\xe9\x87\x8a"",\n""\xe9\x87\x90"": ""\xe5\x8e\x98"",\n""\xe9\x87\x92"": ""\xe9\x92\x85"",\n""\xe9\x87\x93"": ""\xe9\x92\x86"",\n""\xe9\x87\x94"": ""\xe9\x92\x87"",\n""\xe9\x87\x95"": ""\xe9\x92\x8c"",\n""\xe9\x87\x97"": ""\xe9\x92\x8a"",\n""\xe9\x87\x98"": ""\xe9\x92\x89"",\n""\xe9\x87\x99"": ""\xe9\x92\x8b"",\n""\xe9\x87\x9d"": ""\xe9\x92\x88"",\n""\xe9\x87\xa3"": ""\xe9\x92\x93"",\n""\xe9\x87\xa4"": ""\xe9\x92\x90"",\n""\xe9\x87\xa7"": ""\xe9\x92\x8f"",\n""\xe9\x87\xa9"": ""\xe9\x92\x92"",\n""\xe9\x87\xb5"": ""\xe9\x92\x97"",\n""\xe9\x87\xb7"": ""\xe9\x92\x8d"",\n""\xe9\x87\xb9"": ""\xe9\x92\x95"",\n""\xe9\x87\xba"": ""\xe9\x92\x8e"",\n""\xe9\x88\x80"": ""\xe9\x92\xaf"",\n""\xe9\x88\x81"": ""\xe9\x92\xab"",\n""\xe9\x88\x83"": ""\xe9\x92\x98"",\n""\xe9\x88\x84"": ""\xe9\x92\xad"",\n""\xe9\x88\x88"": ""\xe9\x92\x9a"",\n""\xe9\x88\x89"": ""\xe9\x92\xa0"",\n""\xe9\x88\x8d"": ""\xe9\x92\x9d"",\n""\xe9\x88\x8e"": ""\xe9\x92\xa9"",\n""\xe9\x88\x90"": ""\xe9\x92\xa4"",\n""\xe9\x88\x91"": ""\xe9\x92\xa3"",\n""\xe9\x88\x92"": ""\xe9\x92\x91"",\n""\xe9\x88\x94"": ""\xe9\x92\x9e"",\n""\xe9\x88\x95"": ""\xe9\x92\xae"",\n""\xe9\x88\x9e"": ""\xe9\x92\xa7"",\n""\xe9\x88\xa3"": ""\xe9\x92\x99"",\n""\xe9\x88\xa5"": ""\xe9\x92\xac"",\n""\xe9\x88\xa6"": ""\xe9\x92\x9b"",\n""\xe9\x88\xa7"": ""\xe9\x92\xaa"",\n""\xe9\x88\xae"": ""\xe9\x93\x8c"",\n""\xe9\x88\xb0"": ""\xe9\x93\x88"",\n""\xe9\x88\xb3"": ""\xe9\x92\xb6"",\n""\xe9\x88\xb4"": ""\xe9\x93\x83"",\n""\xe9\x88\xb7"": ""\xe9\x92\xb4"",\n""\xe9\x88\xb8"": ""\xe9\x92\xb9"",\n""\xe9\x88\xb9"": ""\xe9\x93\x8d"",\n""\xe9\x88\xba"": ""\xe9\x92\xb0"",\n""\xe9\x88\xbd"": ""\xe9\x92\xb8"",\n""\xe9\x88\xbe"": ""\xe9\x93\x80"",\n""\xe9\x88\xbf"": ""\xe9\x92\xbf"",\n""\xe9\x89\x80"": ""\xe9\x92\xbe"",\n""\xe9\x89\x85"": ""\xe9\x92\x9c"",\n""\xe9\x89\x88"": ""\xe9\x93\x8a"",\n""\xe9\x89\x89"": ""\xe9\x93\x89"",\n""\xe9\x89\x8b"": ""\xe9\x93\x87"",\n""\xe9\x89\x8d"": ""\xe9\x93\x8b"",\n""\xe9\x89\x91"": ""\xe9\x93\x82"",\n""\xe9\x89\x95"": ""\xe9\x92\xb7"",\n""\xe9\x89\x97"": ""\xe9\x92\xb3"",\n""\xe9\x89\x9a"": ""\xe9\x93\x86"",\n""\xe9\x89\x9b"": ""\xe9\x93\x85"",\n""\xe9\x89\x9e"": ""\xe9\x92\xba"",\n""\xe9\x89\xa2"": ""\xe9\x92\xb5"",\n""\xe9\x89\xa4"": ""\xe9\x92\xa9"",\n""\xe9\x89\xa6"": ""\xe9\x92\xb2"",\n""\xe9\x89\xac"": ""\xe9\x92\xbc"",\n""\xe9\x89\xad"": ""\xe9\x92\xbd"",\n""\xe9\x89\xb6"": ""\xe9\x93\x8f"",\n""\xe9\x89\xb8"": ""\xe9\x93\xb0"",\n""\xe9\x89\xba"": ""\xe9\x93\x92"",\n""\xe9\x89\xbb"": ""\xe9\x93\xac"",\n""\xe9\x89\xbf"": ""\xe9\x93\xaa"",\n""\xe9\x8a\x80"": ""\xe9\x93\xb6"",\n""\xe9\x8a\x83"": ""\xe9\x93\xb3"",\n""\xe9\x8a\x85"": ""\xe9\x93\x9c"",\n""\xe9\x8a\x8d"": ""\xe9\x93\x9a"",\n""\xe9\x8a\x91"": ""\xe9\x93\xa3"",\n""\xe9\x8a\x93"": ""\xe9\x93\xa8"",\n""\xe9\x8a\x96"": ""\xe9\x93\xa2"",\n""\xe9\x8a\x98"": ""\xe9\x93\xad"",\n""\xe9\x8a\x9a"": ""\xe9\x93\xab"",\n""\xe9\x8a\x9b"": ""\xe9\x93\xa6"",\n""\xe9\x8a\x9c"": ""\xe8\xa1\x94"",\n""\xe9\x8a\xa0"": ""\xe9\x93\x91"",\n""\xe9\x8a\xa3"": ""\xe9\x93\xb7"",\n""\xe9\x8a\xa5"": ""\xe9\x93\xb1"",\n""\xe9\x8a\xa6"": ""\xe9\x93\x9f"",\n""\xe9\x8a\xa8"": ""\xe9\x93\xb5"",\n""\xe9\x8a\xa9"": ""\xe9\x93\xa5"",\n""\xe9\x8a\xaa"": ""\xe9\x93\x95"",\n""\xe9\x8a\xab"": ""\xe9\x93\xaf"",\n""\xe9\x8a\xac"": ""\xe9\x93\x90"",\n""\xe9\x8a\xb1"": ""\xe9\x93\x9e"",\n""\xe9\x8a\xb3"": ""\xe9\x94\x90"",\n""\xe9\x8a\xb7"": ""\xe9\x94\x80"",\n""\xe9\x8a\xb9"": ""\xe9\x94\x88"",\n""\xe9\x8a\xbb"": ""\xe9\x94\x91"",\n""\xe9\x8a\xbc"": ""\xe9\x94\x89"",\n""\xe9\x8b\x81"": ""\xe9\x93\x9d"",\n""\xe9\x8b\x83"": ""\xe9\x94\x92"",\n""\xe9\x8b\x85"": ""\xe9\x94\x8c"",\n""\xe9\x8b\x87"": ""\xe9\x92\xa1"",\n""\xe9\x8b\x8c"": ""\xe9\x93\xa4"",\n""\xe9\x8b\x8f"": ""\xe9\x93\x97"",\n""\xe9\x8b\x92"": ""\xe9\x94\x8b"",\n""\xe9\x8b\x99"": ""\xe9\x93\xbb"",\n""\xe9\x8b\x9d"": ""\xe9\x94\x8a"",\n""\xe9\x8b\x9f"": ""\xe9\x94\x93"",\n""\xe9\x8b\xa3"": ""\xe9\x93\x98"",\n""\xe9\x8b\xa4"": ""\xe9\x94\x84"",\n""\xe9\x8b\xa5"": ""\xe9\x94\x83"",\n""\xe9\x8b\xa6"": ""\xe9\x94\x94"",\n""\xe9\x8b\xa8"": ""\xe9\x94\x87"",\n""\xe9\x8b\xa9"": ""\xe9\x93\x93"",\n""\xe9\x8b\xaa"": ""\xe9\x93\xba"",\n""\xe9\x8b\xad"": ""\xe9\x94\x90"",\n""\xe9\x8b\xae"": ""\xe9\x93\x96"",\n""\xe9\x8b\xaf"": ""\xe9\x94\x86"",\n""\xe9\x8b\xb0"": ""\xe9\x94\x82"",\n""\xe9\x8b\xb1"": ""\xe9\x93\xbd"",\n""\xe9\x8b\xb6"": ""\xe9\x94\x8d"",\n""\xe9\x8b\xb8"": ""\xe9\x94\xaf"",\n""\xe9\x8b\xbc"": ""\xe9\x92\xa2"",\n""\xe9\x8c\x81"": ""\xe9\x94\x9e"",\n""\xe9\x8c\x84"": ""\xe5\xbd\x95"",\n""\xe9\x8c\x86"": ""\xe9\x94\x96"",\n""\xe9\x8c\x87"": ""\xe9\x94\xab"",\n""\xe9\x8c\x88"": ""\xe9\x94\xa9"",\n""\xe9\x8c\x8f"": ""\xe9\x93\x94"",\n""\xe9\x8c\x90"": ""\xe9\x94\xa5"",\n""\xe9\x8c\x92"": ""\xe9\x94\x95"",\n""\xe9\x8c\x95"": ""\xe9\x94\x9f"",\n""\xe9\x8c\x98"": ""\xe9\x94\xa4"",\n""\xe9\x8c\x99"": ""\xe9\x94\xb1"",\n""\xe9\x8c\x9a"": ""\xe9\x93\xae"",\n""\xe9\x8c\x9b"": ""\xe9\x94\x9b"",\n""\xe9\x8c\x9f"": ""\xe9\x94\xac"",\n""\xe9\x8c\xa0"": ""\xe9\x94\xad"",\n""\xe9\x8c\xa1"": ""\xe9\x94\x9c"",\n""\xe9\x8c\xa2"": ""\xe9\x92\xb1"",\n""\xe9\x8c\xa6"": ""\xe9\x94\xa6"",\n""\xe9\x8c\xa8"": ""\xe9\x94\x9a"",\n""\xe9\x8c\xa9"": ""\xe9\x94\xa0"",\n""\xe9\x8c\xab"": ""\xe9\x94\xa1"",\n""\xe9\x8c\xae"": ""\xe9\x94\xa2"",\n""\xe9\x8c\xaf"": ""\xe9\x94\x99"",\n""\xe9\x8c\xb2"": ""\xe5\xbd\x95"",\n""\xe9\x8c\xb3"": ""\xe9\x94\xb0"",\n""\xe9\x8c\xb6"": ""\xe8\xa1\xa8"",\n""\xe9\x8c\xb8"": ""\xe9\x93\xbc"",\n""\xe9\x8d\x80"": ""\xe9\x94\x9d"",\n""\xe9\x8d\x81"": ""\xe9\x94\xa8"",\n""\xe9\x8d\x83"": ""\xe9\x94\xaa"",\n""\xe9\x8d\x86"": ""\xe9\x92\x94"",\n""\xe9\x8d\x87"": ""\xe9\x94\xb4"",\n""\xe9\x8d\x88"": ""\xe9\x94\xb3"",\n""\xe9\x8d\x8b"": ""\xe9\x94\x85"",\n""\xe9\x8d\x8d"": ""\xe9\x95\x80"",\n""\xe9\x8d\x94"": ""\xe9\x94\xb7"",\n""\xe9\x8d\x98"": ""\xe9\x93\xa1"",\n""\xe9\x8d\x9a"": ""\xe9\x92\x96"",\n""\xe9\x8d\x9b"": ""\xe9\x94\xbb"",\n""\xe9\x8d\xa0"": ""\xe9\x94\xbd"",\n""\xe9\x8d\xa4"": ""\xe9\x94\xb8"",\n""\xe9\x8d\xa5"": ""\xe9\x94\xb2"",\n""\xe9\x8d\xa9"": ""\xe9\x94\x98"",\n""\xe9\x8d\xac"": ""\xe9\x94\xb9"",\n""\xe9\x8d\xb0"": ""\xe9\x94\xbe"",\n""\xe9\x8d\xb5"": ""\xe9\x94\xae"",\n""\xe9\x8d\xb6"": ""\xe9\x94\xb6"",\n""\xe9\x8d\xba"": ""\xe9\x94\x97"",\n""\xe9\x8d\xbe"": ""\xe9\x92\x9f"",\n""\xe9\x8e\x82"": ""\xe9\x95\x81"",\n""\xe9\x8e\x84"": ""\xe9\x94\xbf"",\n""\xe9\x8e\x87"": ""\xe9\x95\x85"",\n""\xe9\x8e\x8a"": ""\xe9\x95\x91"",\n""\xe9\x8e\x94"": ""\xe9\x95\x95"",\n""\xe9\x8e\x96"": ""\xe9\x94\x81"",\n""\xe9\x8e\x98"": ""\xe9\x95\x89"",\n""\xe9\x8e\x9a"": ""\xe9\x94\xa4"",\n""\xe9\x8e\x9b"": ""\xe9\x95\x88"",\n""\xe9\x8e\x9d"": ""\xf0\xa8\xb1\x8f"",\n""\xe9\x8e\xa1"": ""\xe9\x95\x83"",\n""\xe9\x8e\xa2"": ""\xe9\x92\xa8"",\n""\xe9\x8e\xa3"": ""\xe8\x93\xa5"",\n""\xe9\x8e\xa6"": ""\xe9\x95\x8f"",\n""\xe9\x8e\xa7"": ""\xe9\x93\xa0"",\n""\xe9\x8e\xa9"": ""\xe9\x93\xa9"",\n""\xe9\x8e\xaa"": ""\xe9\x94\xbc"",\n""\xe9\x8e\xac"": ""\xe9\x95\x90"",\n""\xe9\x8e\xae"": ""\xe9\x95\x87"",\n""\xe9\x8e\xb0"": ""\xe9\x95\x92"",\n""\xe9\x8e\xb2"": ""\xe9\x95\x8b"",\n""\xe9\x8e\xb3"": ""\xe9\x95\x8d"",\n""\xe9\x8e\xb5"": ""\xe9\x95\x93"",\n""\xe9\x8e\xb8"": ""\xe9\x95\x8c"",\n""\xe9\x8e\xbf"": ""\xe9\x95\x8e"",\n""\xe9\x8f\x83"": ""\xe9\x95\x9e"",\n""\xe9\x8f\x87"": ""\xe9\x95\x9f"",\n""\xe9\x8f\x88"": ""\xe9\x93\xbe"",\n""\xe9\x8f\x8c"": ""\xe9\x95\x86"",\n""\xe9\x8f\x8d"": ""\xe9\x95\x99"",\n""\xe9\x8f\x90"": ""\xe9\x95\xa0"",\n""\xe9\x8f\x91"": ""\xe9\x95\x9d"",\n""\xe9\x8f\x97"": ""\xe9\x93\xbf"",\n""\xe9\x8f\x98"": ""\xe9\x94\xb5"",\n""\xe9\x8f\x9c"": ""\xe9\x95\x97"",\n""\xe9\x8f\x9d"": ""\xe9\x95\x98"",\n""\xe9\x8f\x9e"": ""\xe9\x95\x9b"",\n""\xe9\x8f\x9f"": ""\xe9\x93\xb2"",\n""\xe9\x8f\xa1"": ""\xe9\x95\x9c"",\n""\xe9\x8f\xa2"": ""\xe9\x95\x96"",\n""\xe9\x8f\xa4"": ""\xe9\x95\x82"",\n""\xe9\x8f\xa8"": ""\xe9\x8c\xbe"",\n""\xe9\x8f\xb0"": ""\xe9\x95\x9a"",\n""\xe9\x8f\xb5"": ""\xe9\x93\xa7"",\n""\xe9\x8f\xb7"": ""\xe9\x95\xa4"",\n""\xe9\x8f\xb9"": ""\xe9\x95\xaa"",\n""\xe9\x8f\xbd"": ""\xe9\x94\x88"",\n""\xe9\x90\x83"": ""\xe9\x93\x99"",\n""\xe9\x90\x8b"": ""\xe9\x93\xb4"",\n""\xe9\x90\x90"": ""\xe9\x95\xa3"",\n""\xe9\x90\x92"": ""\xe9\x93\xb9"",\n""\xe9\x90\x93"": ""\xe9\x95\xa6"",\n""\xe9\x90\x94"": ""\xe9\x95\xa1"",\n""\xe9\x90\x98"": ""\xe9\x92\x9f"",\n""\xe9\x90\x99"": ""\xe9\x95\xab"",\n""\xe9\x90\x9d"": ""\xe9\x95\xa2"",\n""\xe9\x90\xa0"": ""\xe9\x95\xa8"",\n""\xe9\x90\xa6"": ""\xe9\x94\x8e"",\n""\xe9\x90\xa7"": ""\xe9\x94\x8f"",\n""\xe9\x90\xa8"": ""\xe9\x95\x84"",\n""\xe9\x90\xab"": ""\xe9\x95\x8c"",\n""\xe9\x90\xae"": ""\xe9\x95\xb0"",\n""\xe9\x90\xb2"": ""\xe9\x95\xaf"",\n""\xe9\x90\xb3"": ""\xe9\x95\xad"",\n""\xe9\x90\xb5"": ""\xe9\x93\x81"",\n""\xe9\x90\xb6"": ""\xe9\x95\xae"",\n""\xe9\x90\xb8"": ""\xe9\x93\x8e"",\n""\xe9\x90\xba"": ""\xe9\x93\x9b"",\n""\xe9\x90\xbf"": ""\xe9\x95\xb1"",\n""\xe9\x91\x84"": ""\xe9\x93\xb8"",\n""\xe9\x91\x8a"": ""\xe9\x95\xac"",\n""\xe9\x91\x8c"": ""\xe9\x95\x94"",\n""\xe9\x91\x92"": ""\xe9\x89\xb4"",\n""\xe9\x91\x94"": ""\xe9\x95\xb2"",\n""\xe9\x91\x95"": ""\xe9\x94\xa7"",\n""\xe9\x91\x9e"": ""\xe9\x95\xb4"",\n""\xe9\x91\xa0"": ""\xe9\x93\x84"",\n""\xe9\x91\xa3"": ""\xe9\x95\xb3"",\n""\xe9\x91\xa5"": ""\xe9\x95\xa5"",\n""\xe9\x91\xad"": ""\xe9\x95\xa7"",\n""\xe9\x91\xb0"": ""\xe9\x92\xa5"",\n""\xe9\x91\xb1"": ""\xe9\x95\xb5"",\n""\xe9\x91\xb2"": ""\xe9\x95\xb6"",\n""\xe9\x91\xb7"": ""\xe9\x95\x8a"",\n""\xe9\x91\xb9"": ""\xe9\x95\xa9"",\n""\xe9\x91\xbc"": ""\xe9\x94\xa3"",\n""\xe9\x91\xbd"": ""\xe9\x92\xbb"",\n""\xe9\x91\xbe"": ""\xe9\x8a\xae"",\n""\xe9\x91\xbf"": ""\xe5\x87\xbf"",\n""\xe9\x92\x81"": ""\xe9\x95\xa2"",\n""\xe9\x95\x9f"": ""\xe6\x97\x8b"",\n""\xe9\x95\xb7"": ""\xe9\x95\xbf"",\n""\xe9\x96\x80"": ""\xe9\x97\xa8"",\n""\xe9\x96\x82"": ""\xe9\x97\xa9"",\n""\xe9\x96\x83"": ""\xe9\x97\xaa"",\n""\xe9\x96\x86"": ""\xe9\x97\xab"",\n""\xe9\x96\x88"": ""\xe9\x97\xac"",\n""\xe9\x96\x89"": ""\xe9\x97\xad"",\n""\xe9\x96\x8b"": ""\xe5\xbc\x80"",\n""\xe9\x96\x8c"": ""\xe9\x97\xb6"",\n""\xe9\x96\x8e"": ""\xe9\x97\xb3"",\n""\xe9\x96\x8f"": ""\xe9\x97\xb0"",\n""\xe9\x96\x91"": ""\xe9\x97\xb2"",\n""\xe9\x96\x93"": ""\xe9\x97\xb4"",\n""\xe9\x96\x94"": ""\xe9\x97\xb5"",\n""\xe9\x96\x98"": ""\xe9\x97\xb8"",\n""\xe9\x96\xa1"": ""\xe9\x98\x82"",\n""\xe9\x96\xa3"": ""\xe9\x98\x81"",\n""\xe9\x96\xa4"": ""\xe5\x90\x88"",\n""\xe9\x96\xa5"": ""\xe9\x98\x80"",\n""\xe9\x96\xa8"": ""\xe9\x97\xba"",\n""\xe9\x96\xa9"": ""\xe9\x97\xbd"",\n""\xe9\x96\xab"": ""\xe9\x98\x83"",\n""\xe9\x96\xac"": ""\xe9\x98\x86"",\n""\xe9\x96\xad"": ""\xe9\x97\xbe"",\n""\xe9\x96\xb1"": ""\xe9\x98\x85"",\n""\xe9\x96\xb2"": ""\xe9\x98\x85"",\n""\xe9\x96\xb6"": ""\xe9\x98\x8a"",\n""\xe9\x96\xb9"": ""\xe9\x98\x89"",\n""\xe9\x96\xbb"": ""\xe9\x98\x8e"",\n""\xe9\x96\xbc"": ""\xe9\x98\x8f"",\n""\xe9\x96\xbd"": ""\xe9\x98\x8d"",\n""\xe9\x96\xbe"": ""\xe9\x98\x88"",\n""\xe9\x96\xbf"": ""\xe9\x98\x8c"",\n""\xe9\x97\x83"": ""\xe9\x98\x92"",\n""\xe9\x97\x86"": ""\xe6\x9d\xbf"",\n""\xe9\x97\x88"": ""\xe9\x97\xb1"",\n""\xe9\x97\x8a"": ""\xe9\x98\x94"",\n""\xe9\x97\x8b"": ""\xe9\x98\x95"",\n""\xe9\x97\x8c"": ""\xe9\x98\x91"",\n""\xe9\x97\x8d"": ""\xe9\x98\x87"",\n""\xe9\x97\x90"": ""\xe9\x98\x97"",\n""\xe9\x97\x92"": ""\xe9\x98\x98"",\n""\xe9\x97\x93"": ""\xe9\x97\xbf"",\n""\xe9\x97\x94"": ""\xe9\x98\x96"",\n""\xe9\x97\x95"": ""\xe9\x98\x99"",\n""\xe9\x97\x96"": ""\xe9\x97\xaf"",\n""\xe9\x97\x9c"": ""\xe5\x85\xb3"",\n""\xe9\x97\x9e"": ""\xe9\x98\x9a"",\n""\xe9\x97\xa0"": ""\xe9\x98\x93"",\n""\xe9\x97\xa1"": ""\xe9\x98\x90"",\n""\xe9\x97\xa4"": ""\xe9\x98\x9b"",\n""\xe9\x97\xa5"": ""\xe9\x97\xbc"",\n""\xe9\x98\xaa"": ""\xe5\x9d\x82"",\n""\xe9\x99\x98"": ""\xe9\x99\x89"",\n""\xe9\x99\x9d"": ""\xe9\x99\x95"",\n""\xe9\x99\xa3"": ""\xe9\x98\xb5"",\n""\xe9\x99\xb0"": ""\xe9\x98\xb4"",\n""\xe9\x99\xb3"": ""\xe9\x99\x88"",\n""\xe9\x99\xb8"": ""\xe9\x99\x86"",\n""\xe9\x99\xbd"": ""\xe9\x98\xb3"",\n""\xe9\x9a\x89"": ""\xe9\x99\xa7"",\n""\xe9\x9a\x8a"": ""\xe9\x98\x9f"",\n""\xe9\x9a\x8e"": ""\xe9\x98\xb6"",\n""\xe9\x9a\x95"": ""\xe9\x99\xa8"",\n""\xe9\x9a\x9b"": ""\xe9\x99\x85"",\n""\xe9\x9a\xa8"": ""\xe9\x9a\x8f"",\n""\xe9\x9a\xaa"": ""\xe9\x99\xa9"",\n""\xe9\x9a\xb1"": ""\xe9\x9a\x90"",\n""\xe9\x9a\xb4"": ""\xe9\x99\x87"",\n""\xe9\x9a\xb8"": ""\xe9\x9a\xb6"",\n""\xe9\x9a\xbb"": ""\xe5\x8f\xaa"",\n""\xe9\x9b\x8b"": ""\xe9\x9a\xbd"",\n""\xe9\x9b\x96"": ""\xe8\x99\xbd"",\n""\xe9\x9b\x99"": ""\xe5\x8f\x8c"",\n""\xe9\x9b\x9b"": ""\xe9\x9b\x8f"",\n""\xe9\x9b\x9c"": ""\xe6\x9d\x82"",\n""\xe9\x9b\x9e"": ""\xe9\xb8\xa1"",\n""\xe9\x9b\xa2"": ""\xe7\xa6\xbb"",\n""\xe9\x9b\xa3"": ""\xe9\x9a\xbe"",\n""\xe9\x9b\xb2"": ""\xe4\xba\x91"",\n""\xe9\x9b\xbb"": ""\xe7\x94\xb5"",\n""\xe9\x9c\xa2"": ""\xe9\x9c\xa1"",\n""\xe9\x9c\xa7"": ""\xe9\x9b\xbe"",\n""\xe9\x9c\xbd"": ""\xe9\x9c\x81"",\n""\xe9\x9d\x82"": ""\xe9\x9b\xb3"",\n""\xe9\x9d\x84"": ""\xe9\x9c\xad"",\n""\xe9\x9d\x88"": ""\xe7\x81\xb5"",\n""\xe9\x9d\x9a"": ""\xe9\x9d\x93"",\n""\xe9\x9d\x9c"": ""\xe9\x9d\x99"",\n""\xe9\x9d\xa8"": ""\xe9\x9d\xa5"",\n""\xe9\x9e\x80"": ""\xe9\xbc\x97"",\n""\xe9\x9e\x8f"": ""\xe5\xb7\xa9"",\n""\xe9\x9e\x9d"": ""\xe7\xbb\xb1"",\n""\xe9\x9e\xa6"": ""\xe7\xa7\x8b"",\n""\xe9\x9e\xbd"": ""\xe9\x9e\x92"",\n""\xe9\x9f\x81"": ""\xe7\xbc\xb0"",\n""\xe9\x9f\x83"": ""\xe9\x9e\x91"",\n""\xe9\x9f\x86"": ""\xe5\x8d\x83"",\n""\xe9\x9f\x89"": ""\xe9\x9e\xaf"",\n""\xe9\x9f\x8b"": ""\xe9\x9f\xa6"",\n""\xe9\x9f\x8c"": ""\xe9\x9f\xa7"",\n""\xe9\x9f\x8d"": ""\xe9\x9f\xa8"",\n""\xe9\x9f\x93"": ""\xe9\x9f\xa9"",\n""\xe9\x9f\x99"": ""\xe9\x9f\xaa"",\n""\xe9\x9f\x9c"": ""\xe9\x9f\xac"",\n""\xe9\x9f\x9e"": ""\xe9\x9f\xab"",\n""\xe9\x9f\xbb"": ""\xe9\x9f\xb5"",\n""\xe9\x9f\xbf"": ""\xe5\x93\x8d"",\n""\xe9\xa0\x81"": ""\xe9\xa1\xb5"",\n""\xe9\xa0\x82"": ""\xe9\xa1\xb6"",\n""\xe9\xa0\x83"": ""\xe9\xa1\xb7"",\n""\xe9\xa0\x85"": ""\xe9\xa1\xb9"",\n""\xe9\xa0\x86"": ""\xe9\xa1\xba"",\n""\xe9\xa0\x87"": ""\xe9\xa1\xb8"",\n""\xe9\xa0\x88"": ""\xe9\xa1\xbb"",\n""\xe9\xa0\x8a"": ""\xe9\xa1\xbc"",\n""\xe9\xa0\x8c"": ""\xe9\xa2\x82"",\n""\xe9\xa0\x8e"": ""\xe9\xa2\x80"",\n""\xe9\xa0\x8f"": ""\xe9\xa2\x83"",\n""\xe9\xa0\x90"": ""\xe9\xa2\x84"",\n""\xe9\xa0\x91"": ""\xe9\xa1\xbd"",\n""\xe9\xa0\x92"": ""\xe9\xa2\x81"",\n""\xe9\xa0\x93"": ""\xe9\xa1\xbf"",\n""\xe9\xa0\x97"": ""\xe9\xa2\x87"",\n""\xe9\xa0\x98"": ""\xe9\xa2\x86"",\n""\xe9\xa0\x9c"": ""\xe9\xa2\x8c"",\n""\xe9\xa0\xa1"": ""\xe9\xa2\x89"",\n""\xe9\xa0\xa4"": ""\xe9\xa2\x90"",\n""\xe9\xa0\xa6"": ""\xe9\xa2\x8f"",\n""\xe9\xa0\xad"": ""\xe5\xa4\xb4"",\n""\xe9\xa0\xae"": ""\xe9\xa2\x92"",\n""\xe9\xa0\xb0"": ""\xe9\xa2\x8a"",\n""\xe9\xa0\xb2"": ""\xe9\xa2\x8b"",\n""\xe9\xa0\xb4"": ""\xe9\xa2\x95"",\n""\xe9\xa0\xb7"": ""\xe9\xa2\x94"",\n""\xe9\xa0\xb8"": ""\xe9\xa2\x88"",\n""\xe9\xa0\xb9"": ""\xe9\xa2\x93"",\n""\xe9\xa0\xbb"": ""\xe9\xa2\x91"",\n""\xe9\xa0\xbd"": ""\xe9\xa2\x93"",\n""\xe9\xa1\x86"": ""\xe9\xa2\x97"",\n""\xe9\xa1\x8c"": ""\xe9\xa2\x98"",\n""\xe9\xa1\x8d"": ""\xe9\xa2\x9d"",\n""\xe9\xa1\x8e"": ""\xe9\xa2\x9a"",\n""\xe9\xa1\x8f"": ""\xe9\xa2\x9c"",\n""\xe9\xa1\x92"": ""\xe9\xa2\x99"",\n""\xe9\xa1\x93"": ""\xe9\xa2\x9b"",\n""\xe9\xa1\x94"": ""\xe9\xa2\x9c"",\n""\xe9\xa1\x98"": ""\xe6\x84\xbf"",\n""\xe9\xa1\x99"": ""\xe9\xa2\xa1"",\n""\xe9\xa1\x9b"": ""\xe9\xa2\xa0"",\n""\xe9\xa1\x9e"": ""\xe7\xb1\xbb"",\n""\xe9\xa1\xa2"": ""\xe9\xa2\x9f"",\n""\xe9\xa1\xa5"": ""\xe9\xa2\xa2"",\n""\xe9\xa1\xa7"": ""\xe9\xa1\xbe"",\n""\xe9\xa1\xab"": ""\xe9\xa2\xa4"",\n""\xe9\xa1\xac"": ""\xe9\xa2\xa5"",\n""\xe9\xa1\xaf"": ""\xe6\x98\xbe"",\n""\xe9\xa1\xb0"": ""\xe9\xa2\xa6"",\n""\xe9\xa1\xb1"": ""\xe9\xa2\x85"",\n""\xe9\xa1\xb3"": ""\xe9\xa2\x9e"",\n""\xe9\xa1\xb4"": ""\xe9\xa2\xa7"",\n""\xe9\xa2\xa8"": ""\xe9\xa3\x8e"",\n""\xe9\xa2\xad"": ""\xe9\xa3\x90"",\n""\xe9\xa2\xae"": ""\xe9\xa3\x91"",\n""\xe9\xa2\xaf"": ""\xe9\xa3\x92"",\n""\xe9\xa2\xb1"": ""\xe5\x8f\xb0"",\n""\xe9\xa2\xb3"": ""\xe5\x88\xae"",\n""\xe9\xa2\xb6"": ""\xe9\xa3\x93"",\n""\xe9\xa2\xb8"": ""\xe9\xa3\x94"",\n""\xe9\xa2\xba"": ""\xe9\xa3\x8f"",\n""\xe9\xa2\xbb"": ""\xe9\xa3\x96"",\n""\xe9\xa2\xbc"": ""\xe9\xa3\x95"",\n""\xe9\xa3\x80"": ""\xe9\xa3\x97"",\n""\xe9\xa3\x84"": ""\xe9\xa3\x98"",\n""\xe9\xa3\x86"": ""\xe9\xa3\x99"",\n""\xe9\xa3\x88"": ""\xe9\xa3\x9a"",\n""\xe9\xa3\x9b"": ""\xe9\xa3\x9e"",\n""\xe9\xa3\xa0"": ""\xe9\xa5\xa3"",\n""\xe9\xa3\xa2"": ""\xe9\xa5\xa5"",\n""\xe9\xa3\xa3"": ""\xe9\xa5\xa4"",\n""\xe9\xa3\xa5"": ""\xe9\xa5\xa6"",\n""\xe9\xa3\xa9"": ""\xe9\xa5\xa8"",\n""\xe9\xa3\xaa"": ""\xe9\xa5\xaa"",\n""\xe9\xa3\xab"": ""\xe9\xa5\xab"",\n""\xe9\xa3\xad"": ""\xe9\xa5\xac"",\n""\xe9\xa3\xaf"": ""\xe9\xa5\xad"",\n""\xe9\xa3\xb2"": ""\xe9\xa5\xae"",\n""\xe9\xa3\xb4"": ""\xe9\xa5\xb4"",\n""\xe9\xa3\xbc"": ""\xe9\xa5\xb2"",\n""\xe9\xa3\xbd"": ""\xe9\xa5\xb1"",\n""\xe9\xa3\xbe"": ""\xe9\xa5\xb0"",\n""\xe9\xa3\xbf"": ""\xe9\xa5\xb3"",\n""\xe9\xa4\x83"": ""\xe9\xa5\xba"",\n""\xe9\xa4\x84"": ""\xe9\xa5\xb8"",\n""\xe9\xa4\x85"": ""\xe9\xa5\xbc"",\n""\xe9\xa4\x89"": ""\xe9\xa5\xb7"",\n""\xe9\xa4\x8a"": ""\xe5\x85\xbb"",\n""\xe9\xa4\x8c"": ""\xe9\xa5\xb5"",\n""\xe9\xa4\x8e"": ""\xe9\xa5\xb9"",\n""\xe9\xa4\x8f"": ""\xe9\xa5\xbb"",\n""\xe9\xa4\x91"": ""\xe9\xa5\xbd"",\n""\xe9\xa4\x92"": ""\xe9\xa6\x81"",\n""\xe9\xa4\x93"": ""\xe9\xa5\xbf"",\n""\xe9\xa4\x95"": ""\xe9\xa6\x82"",\n""\xe9\xa4\x96"": ""\xe9\xa5\xbe"",\n""\xe9\xa4\x9a"": ""\xe8\x82\xb4"",\n""\xe9\xa4\x9b"": ""\xe9\xa6\x84"",\n""\xe9\xa4\x9c"": ""\xe9\xa6\x83"",\n""\xe9\xa4\x9e"": ""\xe9\xa5\xaf"",\n""\xe9\xa4\xa1"": ""\xe9\xa6\x85"",\n""\xe9\xa4\xa8"": ""\xe9\xa6\x86"",\n""\xe9\xa4\xb1"": ""\xe7\xb3\x87"",\n""\xe9\xa4\xb3"": ""\xe9\xa5\xa7"",\n""\xe9\xa4\xb6"": ""\xe9\xa6\x89"",\n""\xe9\xa4\xb7"": ""\xe9\xa6\x87"",\n""\xe9\xa4\xba"": ""\xe9\xa6\x8e"",\n""\xe9\xa4\xbc"": ""\xe9\xa5\xa9"",\n""\xe9\xa4\xbe"": ""\xe9\xa6\x8f"",\n""\xe9\xa4\xbf"": ""\xe9\xa6\x8a"",\n""\xe9\xa5\x81"": ""\xe9\xa6\x8c"",\n""\xe9\xa5\x83"": ""\xe9\xa6\x8d"",\n""\xe9\xa5\x85"": ""\xe9\xa6\x92"",\n""\xe9\xa5\x88"": ""\xe9\xa6\x90"",\n""\xe9\xa5\x89"": ""\xe9\xa6\x91"",\n""\xe9\xa5\x8a"": ""\xe9\xa6\x93"",\n""\xe9\xa5\x8b"": ""\xe9\xa6\x88"",\n""\xe9\xa5\x8c"": ""\xe9\xa6\x94"",\n""\xe9\xa5\x91"": ""\xe9\xa5\xa5"",\n""\xe9\xa5\x92"": ""\xe9\xa5\xb6"",\n""\xe9\xa5\x97"": ""\xe9\xa3\xa8"",\n""\xe9\xa5\x9c"": ""\xe9\xa4\x8d"",\n""\xe9\xa5\x9e"": ""\xe9\xa6\x8b"",\n""\xe9\xa5\xa2"": ""\xe9\xa6\x95"",\n""\xe9\xa6\xac"": ""\xe9\xa9\xac"",\n""\xe9\xa6\xad"": ""\xe9\xa9\xad"",\n""\xe9\xa6\xae"": ""\xe5\x86\xaf"",\n""\xe9\xa6\xb1"": ""\xe9\xa9\xae"",\n""\xe9\xa6\xb3"": ""\xe9\xa9\xb0"",\n""\xe9\xa6\xb4"": ""\xe9\xa9\xaf"",\n""\xe9\xa6\xb9"": ""\xe9\xa9\xb2"",\n""\xe9\xa7\x81"": ""\xe9\xa9\xb3"",\n""\xe9\xa7\x90"": ""\xe9\xa9\xbb"",\n""\xe9\xa7\x91"": ""\xe9\xa9\xbd"",\n""\xe9\xa7\x92"": ""\xe9\xa9\xb9"",\n""\xe9\xa7\x94"": ""\xe9\xa9\xb5"",\n""\xe9\xa7\x95"": ""\xe9\xa9\xbe"",\n""\xe9\xa7\x98"": ""\xe9\xaa\x80"",\n""\xe9\xa7\x99"": ""\xe9\xa9\xb8"",\n""\xe9\xa7\x9b"": ""\xe9\xa9\xb6"",\n""\xe9\xa7\x9d"": ""\xe9\xa9\xbc"",\n""\xe9\xa7\x9f"": ""\xe9\xa9\xb7"",\n""\xe9\xa7\xa1"": ""\xe9\xaa\x82"",\n""\xe9\xa7\xa2"": ""\xe9\xaa\x88"",\n""\xe9\xa7\xad"": ""\xe9\xaa\x87"",\n""\xe9\xa7\xb0"": ""\xe9\xaa\x83"",\n""\xe9\xa7\xb1"": ""\xe9\xaa\x86"",\n""\xe9\xa7\xb8"": ""\xe9\xaa\x8e"",\n""\xe9\xa7\xbf"": ""\xe9\xaa\x8f"",\n""\xe9\xa8\x81"": ""\xe9\xaa\x8b"",\n""\xe9\xa8\x82"": ""\xe9\xaa\x8d"",\n""\xe9\xa8\x85"": ""\xe9\xaa\x93"",\n""\xe9\xa8\x8c"": ""\xe9\xaa\x94"",\n""\xe9\xa8\x8d"": ""\xe9\xaa\x92"",\n""\xe9\xa8\x8e"": ""\xe9\xaa\x91"",\n""\xe9\xa8\x8f"": ""\xe9\xaa\x90"",\n""\xe9\xa8\x96"": ""\xe9\xaa\x9b"",\n""\xe9\xa8\x99"": ""\xe9\xaa\x97"",\n""\xe9\xa8\xa4"": ""\xe9\xaa\x99"",\n""\xe9\xa8\xa7"": ""\xe4\xaf\x84"",\n""\xe9\xa8\xab"": ""\xe9\xaa\x9e"",\n""\xe9\xa8\xad"": ""\xe9\xaa\x98"",\n""\xe9\xa8\xae"": ""\xe9\xaa\x9d"",\n""\xe9\xa8\xb0"": ""\xe8\x85\xbe"",\n""\xe9\xa8\xb6"": ""\xe9\xa9\xba"",\n""\xe9\xa8\xb7"": ""\xe9\xaa\x9a"",\n""\xe9\xa8\xb8"": ""\xe9\xaa\x9f"",\n""\xe9\xa8\xbe"": ""\xe9\xaa\xa1"",\n""\xe9\xa9\x80"": ""\xe8\x93\xa6"",\n""\xe9\xa9\x81"": ""\xe9\xaa\x9c"",\n""\xe9\xa9\x82"": ""\xe9\xaa\x96"",\n""\xe9\xa9\x83"": ""\xe9\xaa\xa0"",\n""\xe9\xa9\x84"": ""\xe9\xaa\xa2"",\n""\xe9\xa9\x85"": ""\xe9\xa9\xb1"",\n""\xe9\xa9\x8a"": ""\xe9\xaa\x85"",\n""\xe9\xa9\x8c"": ""\xe9\xaa\x95"",\n""\xe9\xa9\x8d"": ""\xe9\xaa\x81"",\n""\xe9\xa9\x8f"": ""\xe9\xaa\xa3"",\n""\xe9\xa9\x95"": ""\xe9\xaa\x84"",\n""\xe9\xa9\x97"": ""\xe9\xaa\x8c"",\n""\xe9\xa9\x9a"": ""\xe6\x83\x8a"",\n""\xe9\xa9\x9b"": ""\xe9\xa9\xbf"",\n""\xe9\xa9\x9f"": ""\xe9\xaa\xa4"",\n""\xe9\xa9\xa2"": ""\xe9\xa9\xb4"",\n""\xe9\xa9\xa4"": ""\xe9\xaa\xa7"",\n""\xe9\xa9\xa5"": ""\xe9\xaa\xa5"",\n""\xe9\xa9\xa6"": ""\xe9\xaa\xa6"",\n""\xe9\xa9\xaa"": ""\xe9\xaa\x8a"",\n""\xe9\xa9\xab"": ""\xe9\xaa\x89"",\n""\xe9\xaa\xaf"": ""\xe8\x82\xae"",\n""\xe9\xab\x8f"": ""\xe9\xab\x85"",\n""\xe9\xab\x92"": ""\xe8\x84\x8f"",\n""\xe9\xab\x94"": ""\xe4\xbd\x93"",\n""\xe9\xab\x95"": ""\xe9\xab\x8c"",\n""\xe9\xab\x96"": ""\xe9\xab\x8b"",\n""\xe9\xab\xae"": ""\xe5\x8f\x91"",\n""\xe9\xac\x86"": ""\xe6\x9d\xbe"",\n""\xe9\xac\x8d"": ""\xe8\x83\xa1"",\n""\xe9\xac\x9a"": ""\xe9\xa1\xbb"",\n""\xe9\xac\xa2"": ""\xe9\xac\x93"",\n""\xe9\xac\xa5"": ""\xe6\x96\x97"",\n""\xe9\xac\xa7"": ""\xe9\x97\xb9"",\n""\xe9\xac\xa9"": ""\xe9\x98\x8b"",\n""\xe9\xac\xae"": ""\xe9\x98\x84"",\n""\xe9\xac\xb1"": ""\xe9\x83\x81"",\n""\xe9\xad\x8e"": ""\xe9\xad\x89"",\n""\xe9\xad\x98"": ""\xe9\xad\x87"",\n""\xe9\xad\x9a"": ""\xe9\xb1\xbc"",\n""\xe9\xad\x9b"": ""\xe9\xb1\xbd"",\n""\xe9\xad\xa2"": ""\xe9\xb1\xbe"",\n""\xe9\xad\xa8"": ""\xe9\xb2\x80"",\n""\xe9\xad\xaf"": ""\xe9\xb2\x81"",\n""\xe9\xad\xb4"": ""\xe9\xb2\x82"",\n""\xe9\xad\xb7"": ""\xe9\xb1\xbf"",\n""\xe9\xad\xba"": ""\xe9\xb2\x84"",\n""\xe9\xae\x81"": ""\xe9\xb2\x85"",\n""\xe9\xae\x83"": ""\xe9\xb2\x86"",\n""\xe9\xae\x8a"": ""\xe9\xb2\x8c"",\n""\xe9\xae\x8b"": ""\xe9\xb2\x89"",\n""\xe9\xae\x8d"": ""\xe9\xb2\x8f"",\n""\xe9\xae\x8e"": ""\xe9\xb2\x87"",\n""\xe9\xae\x90"": ""\xe9\xb2\x90"",\n""\xe9\xae\x91"": ""\xe9\xb2\x8d"",\n""\xe9\xae\x92"": ""\xe9\xb2\x8b"",\n""\xe9\xae\x93"": ""\xe9\xb2\x8a"",\n""\xe9\xae\x9a"": ""\xe9\xb2\x92"",\n""\xe9\xae\x9c"": ""\xe9\xb2\x98"",\n""\xe9\xae\x9d"": ""\xe9\xb2\x9e"",\n""\xe9\xae\x9e"": ""\xe9\xb2\x95"",\n""\xe9\xae\xa6"": ""\xe9\xb2\x96"",\n""\xe9\xae\xaa"": ""\xe9\xb2\x94"",\n""\xe9\xae\xab"": ""\xe9\xb2\x9b"",\n""\xe9\xae\xad"": ""\xe9\xb2\x91"",\n""\xe9\xae\xae"": ""\xe9\xb2\x9c"",\n""\xe9\xae\xb3"": ""\xe9\xb2\x93"",\n""\xe9\xae\xb6"": ""\xe9\xb2\xaa"",\n""\xe9\xae\xba"": ""\xe9\xb2\x9d"",\n""\xe9\xaf\x80"": ""\xe9\xb2\xa7"",\n""\xe9\xaf\x81"": ""\xe9\xb2\xa0"",\n""\xe9\xaf\x87"": ""\xe9\xb2\xa9"",\n""\xe9\xaf\x89"": ""\xe9\xb2\xa4"",\n""\xe9\xaf\x8a"": ""\xe9\xb2\xa8"",\n""\xe9\xaf\x92"": ""\xe9\xb2\xac"",\n""\xe9\xaf\x94"": ""\xe9\xb2\xbb"",\n""\xe9\xaf\x95"": ""\xe9\xb2\xaf"",\n""\xe9\xaf\x96"": ""\xe9\xb2\xad"",\n""\xe9\xaf\x97"": ""\xe9\xb2\x9e"",\n""\xe9\xaf\x9b"": ""\xe9\xb2\xb7"",\n""\xe9\xaf\x9d"": ""\xe9\xb2\xb4"",\n""\xe9\xaf\xa1"": ""\xe9\xb2\xb1"",\n""\xe9\xaf\xa2"": ""\xe9\xb2\xb5"",\n""\xe9\xaf\xa4"": ""\xe9\xb2\xb2"",\n""\xe9\xaf\xa7"": ""\xe9\xb2\xb3"",\n""\xe9\xaf\xa8"": ""\xe9\xb2\xb8"",\n""\xe9\xaf\xaa"": ""\xe9\xb2\xae"",\n""\xe9\xaf\xab"": ""\xe9\xb2\xb0"",\n""\xe9\xaf\xb4"": ""\xe9\xb2\xba"",\n""\xe9\xaf\xb7"": ""\xe9\xb3\x80"",\n""\xe9\xaf\xbd"": ""\xe9\xb2\xab"",\n""\xe9\xaf\xbf"": ""\xe9\xb3\x8a"",\n""\xe9\xb0\x81"": ""\xe9\xb3\x88"",\n""\xe9\xb0\x82"": ""\xe9\xb2\x97"",\n""\xe9\xb0\x83"": ""\xe9\xb3\x82"",\n""\xe9\xb0\x88"": ""\xe9\xb2\xbd"",\n""\xe9\xb0\x89"": ""\xe9\xb3\x87"",\n""\xe9\xb0\x8d"": ""\xe9\xb3\x85"",\n""\xe9\xb0\x8f"": ""\xe9\xb2\xbe"",\n""\xe9\xb0\x90"": ""\xe9\xb3\x84"",\n""\xe9\xb0\x92"": ""\xe9\xb3\x86"",\n""\xe9\xb0\x93"": ""\xe9\xb3\x83"",\n""\xe9\xb0\x9c"": ""\xe9\xb3\x92"",\n""\xe9\xb0\x9f"": ""\xe9\xb3\x91"",\n""\xe9\xb0\xa0"": ""\xe9\xb3\x8b"",\n""\xe9\xb0\xa3"": ""\xe9\xb2\xa5"",\n""\xe9\xb0\xa5"": ""\xe9\xb3\x8f"",\n""\xe9\xb0\xa8"": ""\xe9\xb3\x8e"",\n""\xe9\xb0\xa9"": ""\xe9\xb3\x90"",\n""\xe9\xb0\xad"": ""\xe9\xb3\x8d"",\n""\xe9\xb0\xae"": ""\xe9\xb3\x81"",\n""\xe9\xb0\xb1"": ""\xe9\xb2\xa2"",\n""\xe9\xb0\xb2"": ""\xe9\xb3\x8c"",\n""\xe9\xb0\xb3"": ""\xe9\xb3\x93"",\n""\xe9\xb0\xb5"": ""\xe9\xb3\x98"",\n""\xe9\xb0\xb7"": ""\xe9\xb2\xa6"",\n""\xe9\xb0\xb9"": ""\xe9\xb2\xa3"",\n""\xe9\xb0\xba"": ""\xe9\xb2\xb9"",\n""\xe9\xb0\xbb"": ""\xe9\xb3\x97"",\n""\xe9\xb0\xbc"": ""\xe9\xb3\x9b"",\n""\xe9\xb0\xbe"": ""\xe9\xb3\x94"",\n""\xe9\xb1\x82"": ""\xe9\xb3\x89"",\n""\xe9\xb1\x85"": ""\xe9\xb3\x99"",\n""\xe9\xb1\x88"": ""\xe9\xb3\x95"",\n""\xe9\xb1\x89"": ""\xe9\xb3\x96"",\n""\xe9\xb1\x92"": ""\xe9\xb3\x9f"",\n""\xe9\xb1\x94"": ""\xe9\xb3\x9d"",\n""\xe9\xb1\x96"": ""\xe9\xb3\x9c"",\n""\xe9\xb1\x97"": ""\xe9\xb3\x9e"",\n""\xe9\xb1\x98"": ""\xe9\xb2\x9f"",\n""\xe9\xb1\x9d"": ""\xe9\xb2\xbc"",\n""\xe9\xb1\x9f"": ""\xe9\xb2\x8e"",\n""\xe9\xb1\xa0"": ""\xe9\xb2\x99"",\n""\xe9\xb1\xa3"": ""\xe9\xb3\xa3"",\n""\xe9\xb1\xa4"": ""\xe9\xb3\xa1"",\n""\xe9\xb1\xa7"": ""\xe9\xb3\xa2"",\n""\xe9\xb1\xa8"": ""\xe9\xb2\xbf"",\n""\xe9\xb1\xad"": ""\xe9\xb2\x9a"",\n""\xe9\xb1\xaf"": ""\xe9\xb3\xa0"",\n""\xe9\xb1\xb7"": ""\xe9\xb3\x84"",\n""\xe9\xb1\xb8"": ""\xe9\xb2\x88"",\n""\xe9\xb1\xba"": ""\xe9\xb2\xa1"",\n""\xe4\xb0\xbe"": ""\xe9\xb2\x83"",\n""\xe4\xb2\x81"": ""\xe9\xb3\x9a"",\n""\xe9\xb3\xa5"": ""\xe9\xb8\x9f"",\n""\xe9\xb3\xa7"": ""\xe5\x87\xab"",\n""\xe9\xb3\xa9"": ""\xe9\xb8\xa0"",\n""\xe9\xb3\xac"": ""\xe5\x87\xab"",\n""\xe9\xb3\xb2"": ""\xe9\xb8\xa4"",\n""\xe9\xb3\xb3"": ""\xe5\x87\xa4"",\n""\xe9\xb3\xb4"": ""\xe9\xb8\xa3"",\n""\xe9\xb3\xb6"": ""\xe9\xb8\xa2"",\n""\xe9\xb3\xbe"": ""\xe4\xb4\x93"",\n""\xe9\xb4\x86"": ""\xe9\xb8\xa9"",\n""\xe9\xb4\x87"": ""\xe9\xb8\xa8"",\n""\xe9\xb4\x89"": ""\xe9\xb8\xa6"",\n""\xe9\xb4\x92"": ""\xe9\xb8\xb0"",\n""\xe9\xb4\x95"": ""\xe9\xb8\xb5"",\n""\xe9\xb4\x9b"": ""\xe9\xb8\xb3"",\n""\xe9\xb4\x9d"": ""\xe9\xb8\xb2"",\n""\xe9\xb4\x9e"": ""\xe9\xb8\xae"",\n""\xe9\xb4\x9f"": ""\xe9\xb8\xb1"",\n""\xe9\xb4\xa3"": ""\xe9\xb8\xaa"",\n""\xe9\xb4\xa6"": ""\xe9\xb8\xaf"",\n""\xe9\xb4\xa8"": ""\xe9\xb8\xad"",\n""\xe9\xb4\xaf"": ""\xe9\xb8\xb8"",\n""\xe9\xb4\xb0"": ""\xe9\xb8\xb9"",\n""\xe9\xb4\xb4"": ""\xe9\xb8\xbb"",\n""\xe9\xb4\xb7"": ""\xe4\xb4\x95"",\n""\xe9\xb4\xbb"": ""\xe9\xb8\xbf"",\n""\xe9\xb4\xbf"": ""\xe9\xb8\xbd"",\n""\xe9\xb5\x81"": ""\xe4\xb4\x94"",\n""\xe9\xb5\x82"": ""\xe9\xb8\xba"",\n""\xe9\xb5\x83"": ""\xe9\xb8\xbc"",\n""\xe9\xb5\x90"": ""\xe9\xb9\x80"",\n""\xe9\xb5\x91"": ""\xe9\xb9\x83"",\n""\xe9\xb5\x92"": ""\xe9\xb9\x86"",\n""\xe9\xb5\x93"": ""\xe9\xb9\x81"",\n""\xe9\xb5\x9c"": ""\xe9\xb9\x88"",\n""\xe9\xb5\x9d"": ""\xe9\xb9\x85"",\n""\xe9\xb5\xa0"": ""\xe9\xb9\x84"",\n""\xe9\xb5\xa1"": ""\xe9\xb9\x89"",\n""\xe9\xb5\xaa"": ""\xe9\xb9\x8c"",\n""\xe9\xb5\xac"": ""\xe9\xb9\x8f"",\n""\xe9\xb5\xae"": ""\xe9\xb9\x90"",\n""\xe9\xb5\xaf"": ""\xe9\xb9\x8e"",\n""\xe9\xb5\xb2"": ""\xe9\xb9\x8a"",\n""\xe9\xb5\xb7"": ""\xe9\xb9\x93"",\n""\xe9\xb5\xbe"": ""\xe9\xb9\x8d"",\n""\xe9\xb6\x84"": ""\xe4\xb4\x96"",\n""\xe9\xb6\x87"": ""\xe9\xb8\xab"",\n""\xe9\xb6\x89"": ""\xe9\xb9\x91"",\n""\xe9\xb6\x8a"": ""\xe9\xb9\x92"",\n""\xe9\xb6\x93"": ""\xe9\xb9\x8b"",\n""\xe9\xb6\x96"": ""\xe9\xb9\x99"",\n""\xe9\xb6\x98"": ""\xe9\xb9\x95"",\n""\xe9\xb6\x9a"": ""\xe9\xb9\x97"",\n""\xe9\xb6\xa1"": ""\xe9\xb9\x96"",\n""\xe9\xb6\xa5"": ""\xe9\xb9\x9b"",\n""\xe9\xb6\xa9"": ""\xe9\xb9\x9c"",\n""\xe9\xb6\xaa"": ""\xe4\xb4\x97"",\n""\xe9\xb6\xac"": ""\xe9\xb8\xa7"",\n""\xe9\xb6\xaf"": ""\xe8\x8e\xba"",\n""\xe9\xb6\xb2"": ""\xe9\xb9\x9f"",\n""\xe9\xb6\xb4"": ""\xe9\xb9\xa4"",\n""\xe9\xb6\xb9"": ""\xe9\xb9\xa0"",\n""\xe9\xb6\xba"": ""\xe9\xb9\xa1"",\n""\xe9\xb6\xbb"": ""\xe9\xb9\x98"",\n""\xe9\xb6\xbc"": ""\xe9\xb9\xa3"",\n""\xe9\xb6\xbf"": ""\xe9\xb9\x9a"",\n""\xe9\xb7\x80"": ""\xe9\xb9\x9a"",\n""\xe9\xb7\x81"": ""\xe9\xb9\xa2"",\n""\xe9\xb7\x82"": ""\xe9\xb9\x9e"",\n""\xe9\xb7\x84"": ""\xe9\xb8\xa1"",\n""\xe9\xb7\x88"": ""\xe4\xb4\x98"",\n""\xe9\xb7\x8a"": ""\xe9\xb9\x9d"",\n""\xe9\xb7\x93"": ""\xe9\xb9\xa7"",\n""\xe9\xb7\x96"": ""\xe9\xb9\xa5"",\n""\xe9\xb7\x97"": ""\xe9\xb8\xa5"",\n""\xe9\xb7\x99"": ""\xe9\xb8\xb7"",\n""\xe9\xb7\x9a"": ""\xe9\xb9\xa8"",\n""\xe9\xb7\xa5"": ""\xe9\xb8\xb6"",\n""\xe9\xb7\xa6"": ""\xe9\xb9\xaa"",\n""\xe9\xb7\xab"": ""\xe9\xb9\x94"",\n""\xe9\xb7\xaf"": ""\xe9\xb9\xa9"",\n""\xe9\xb7\xb2"": ""\xe9\xb9\xab"",\n""\xe9\xb7\xb3"": ""\xe9\xb9\x87"",\n""\xe9\xb7\xb8"": ""\xe9\xb9\xac"",\n""\xe9\xb7\xb9"": ""\xe9\xb9\xb0"",\n""\xe9\xb7\xba"": ""\xe9\xb9\xad"",\n""\xe9\xb7\xbd"": ""\xe9\xb8\xb4"",\n""\xe9\xb7\xbf"": ""\xe4\xb4\x99"",\n""\xe9\xb8\x82"": ""\xe3\xb6\x89"",\n""\xe9\xb8\x87"": ""\xe9\xb9\xaf"",\n""\xe9\xb8\x8c"": ""\xe9\xb9\xb1"",\n""\xe9\xb8\x8f"": ""\xe9\xb9\xb2"",\n""\xe9\xb8\x95"": ""\xe9\xb8\xac"",\n""\xe9\xb8\x98"": ""\xe9\xb9\xb4"",\n""\xe9\xb8\x9a"": ""\xe9\xb9\xa6"",\n""\xe9\xb8\x9b"": ""\xe9\xb9\xb3"",\n""\xe9\xb8\x9d"": ""\xe9\xb9\x82"",\n""\xe9\xb8\x9e"": ""\xe9\xb8\xbe"",\n""\xe9\xb9\xb5"": ""\xe5\x8d\xa4"",\n""\xe9\xb9\xb9"": ""\xe5\x92\xb8"",\n""\xe9\xb9\xba"": ""\xe9\xb9\xbe"",\n""\xe9\xb9\xbd"": ""\xe7\x9b\x90"",\n""\xe9\xba\x97"": ""\xe4\xb8\xbd"",\n""\xe9\xba\xa5"": ""\xe9\xba\xa6"",\n""\xe9\xba\xa9"": ""\xe9\xba\xb8"",\n""\xe9\xba\xaf"": ""\xe6\x9b\xb2"",\n""\xe9\xba\xb5"": ""\xe9\x9d\xa2"",\n""\xe9\xba\xbc"": ""\xe4\xb9\x88"",\n""\xe9\xba\xbd"": ""\xe4\xb9\x88"",\n""\xe9\xbb\x83"": ""\xe9\xbb\x84"",\n""\xe9\xbb\x8c"": ""\xe9\xbb\x89"",\n""\xe9\xbb\x9e"": ""\xe7\x82\xb9"",\n""\xe9\xbb\xa8"": ""\xe5\x85\x9a"",\n""\xe9\xbb\xb2"": ""\xe9\xbb\xaa"",\n""\xe9\xbb\xb4"": ""\xe9\x9c\x89"",\n""\xe9\xbb\xb6"": ""\xe9\xbb\xa1"",\n""\xe9\xbb\xb7"": ""\xe9\xbb\xa9"",\n""\xe9\xbb\xbd"": ""\xe9\xbb\xbe"",\n""\xe9\xbb\xbf"": ""\xe9\xbc\x8b"",\n""\xe9\xbc\x89"": ""\xe9\xbc\x8d"",\n""\xe9\xbc\x95"": ""\xe5\x86\xac"",\n""\xe9\xbc\xb4"": ""\xe9\xbc\xb9"",\n""\xe9\xbd\x8a"": ""\xe9\xbd\x90"",\n""\xe9\xbd\x8b"": ""\xe6\x96\x8b"",\n""\xe9\xbd\x8e"": ""\xe8\xb5\x8d"",\n""\xe9\xbd\x8f"": ""\xe9\xbd\x91"",\n""\xe9\xbd\x92"": ""\xe9\xbd\xbf"",\n""\xe9\xbd\x94"": ""\xe9\xbe\x80"",\n""\xe9\xbd\x95"": ""\xe9\xbe\x81"",\n""\xe9\xbd\x97"": ""\xe9\xbe\x82"",\n""\xe9\xbd\x99"": ""\xe9\xbe\x85"",\n""\xe9\xbd\x9c"": ""\xe9\xbe\x87"",\n""\xe9\xbd\x9f"": ""\xe9\xbe\x83"",\n""\xe9\xbd\xa0"": ""\xe9\xbe\x86"",\n""\xe9\xbd\xa1"": ""\xe9\xbe\x84"",\n""\xe9\xbd\xa3"": ""\xe5\x87\xba"",\n""\xe9\xbd\xa6"": ""\xe9\xbe\x88"",\n""\xe9\xbd\xaa"": ""\xe9\xbe\x8a"",\n""\xe9\xbd\xac"": ""\xe9\xbe\x89"",\n""\xe9\xbd\xb2"": ""\xe9\xbe\x8b"",\n""\xe9\xbd\xb6"": ""\xe8\x85\xad"",\n""\xe9\xbd\xb7"": ""\xe9\xbe\x8c"",\n""\xe9\xbe\x8d"": ""\xe9\xbe\x99"",\n""\xe9\xbe\x8e"": ""\xe5\x8e\x90"",\n""\xe9\xbe\x90"": ""\xe5\xba\x9e"",\n""\xe9\xbe\x94"": ""\xe9\xbe\x9a"",\n""\xe9\xbe\x95"": ""\xe9\xbe\x9b"",\n""\xe9\xbe\x9c"": ""\xe9\xbe\x9f"",\n\n""\xe5\xb9\xbe\xe7\x95\xab"": ""\xe5\x87\xa0\xe7\x94\xbb"",\n""\xe8\xb3\xa3\xe7\x95\xab"": ""\xe5\x8d\x96\xe7\x94\xbb"",\n""\xe6\xbb\xb7\xe9\xb9\xbc"": ""\xe5\x8d\xa4\xe7\xa2\xb1"",\n""\xe5\x8e\x9f\xe7\x95\xab"": ""\xe5\x8e\x9f\xe7\x94\xbb"",\n""\xe5\x8f\xa3\xe9\xb9\xbc"": ""\xe5\x8f\xa3\xe7\xa2\xb1"",\n""\xe5\x8f\xa4\xe7\x95\xab"": ""\xe5\x8f\xa4\xe7\x94\xbb"",\n""\xe5\x90\x8d\xe7\x95\xab"": ""\xe5\x90\x8d\xe7\x94\xbb"",\n""\xe5\xa5\x87\xe7\x95\xab"": ""\xe5\xa5\x87\xe7\x94\xbb"",\n""\xe5\xa6\x82\xe7\x95\xab"": ""\xe5\xa6\x82\xe7\x94\xbb"",\n""\xe5\xbc\xb1\xe9\xb9\xbc"": ""\xe5\xbc\xb1\xe7\xa2\xb1"",\n""\xe5\xbd\xa9\xe7\x95\xab"": ""\xe5\xbd\xa9\xe7\x94\xbb"",\n""\xe6\x89\x80\xe7\x95\xab"": ""\xe6\x89\x80\xe7\x94\xbb"",\n""\xe6\x89\x89\xe7\x95\xab"": ""\xe6\x89\x89\xe7\x94\xbb"",\n""\xe6\x95\x99\xe7\x95\xab"": ""\xe6\x95\x99\xe7\x94\xbb"",\n""\xe6\xb0\xb4\xe9\xb9\xbc"": ""\xe6\xb0\xb4\xe7\xa2\xb1"",\n""\xe6\xb4\x8b\xe9\xb9\xbc"": ""\xe6\xb4\x8b\xe7\xa2\xb1"",\n""\xe7\x82\xad\xe7\x95\xab"": ""\xe7\x82\xad\xe7\x94\xbb"",\n""\xe7\x95\xab\xe4\xb8\x80"": ""\xe7\x94\xbb\xe4\xb8\x80"",\n""\xe7\x95\xab\xe4\xb8\x8a"": ""\xe7\x94\xbb\xe4\xb8\x8a"",\n""\xe7\x95\xab\xe4\xb8\x8b"": ""\xe7\x94\xbb\xe4\xb8\x8b"",\n""\xe7\x95\xab\xe4\xb8\xad"": ""\xe7\x94\xbb\xe4\xb8\xad"",\n""\xe7\x95\xab\xe4\xbe\x9b"": ""\xe7\x94\xbb\xe4\xbe\x9b"",\n""\xe7\x95\xab\xe5\x85\x92"": ""\xe7\x94\xbb\xe5\x84\xbf"",\n""\xe7\x95\xab\xe5\x85\xb7"": ""\xe7\x94\xbb\xe5\x85\xb7"",\n""\xe7\x95\xab\xe5\x87\xba"": ""\xe7\x94\xbb\xe5\x87\xba"",\n""\xe7\x95\xab\xe5\x8f\xb2"": ""\xe7\x94\xbb\xe5\x8f\xb2"",\n""\xe7\x95\xab\xe5\x93\x81"": ""\xe7\x94\xbb\xe5\x93\x81"",\n""\xe7\x95\xab\xe5\x95\x86"": ""\xe7\x94\xbb\xe5\x95\x86"",\n""\xe7\x95\xab\xe5\x9c\x88"": ""\xe7\x94\xbb\xe5\x9c\x88"",\n""\xe7\x95\xab\xe5\xa2\x83"": ""\xe7\x94\xbb\xe5\xa2\x83"",\n""\xe7\x95\xab\xe5\xb7\xa5"": ""\xe7\x94\xbb\xe5\xb7\xa5"",\n""\xe7\x95\xab\xe5\xb8\x96"": ""\xe7\x94\xbb\xe5\xb8\x96"",\n""\xe7\x95\xab\xe5\xb9\x85"": ""\xe7\x94\xbb\xe5\xb9\x85"",\n""\xe7\x95\xab\xe6\x84\x8f"": ""\xe7\x94\xbb\xe6\x84\x8f"",\n""\xe7\x95\xab\xe6\x88\x90"": ""\xe7\x94\xbb\xe6\x88\x90"",\n""\xe7\x95\xab\xe6\x99\xaf"": ""\xe7\x94\xbb\xe6\x99\xaf"",\n""\xe7\x95\xab\xe6\x9c\xac"": ""\xe7\x94\xbb\xe6\x9c\xac"",\n""\xe7\x95\xab\xe6\x9e\xb6"": ""\xe7\x94\xbb\xe6\x9e\xb6"",\n""\xe7\x95\xab\xe6\xa1\x86"": ""\xe7\x94\xbb\xe6\xa1\x86"",\n""\xe7\x95\xab\xe6\xb3\x95"": ""\xe7\x94\xbb\xe6\xb3\x95"",\n""\xe7\x95\xab\xe7\x8e\x8b"": ""\xe7\x94\xbb\xe7\x8e\x8b"",\n""\xe7\x95\xab\xe7\x95\x8c"": ""\xe7\x94\xbb\xe7\x95\x8c"",\n""\xe7\x95\xab\xe7\xac\xa6"": ""\xe7\x94\xbb\xe7\xac\xa6"",\n""\xe7\x95\xab\xe7\xb4\x99"": ""\xe7\x94\xbb\xe7\xba\xb8"",\n""\xe7\x95\xab\xe7\xb7\x9a"": ""\xe7\x94\xbb\xe7\xba\xbf"",\n""\xe7\x95\xab\xe8\x88\xaa"": ""\xe7\x94\xbb\xe8\x88\xaa"",\n""\xe7\x95\xab\xe8\x88\xab"": ""\xe7\x94\xbb\xe8\x88\xab"",\n""\xe7\x95\xab\xe8\x99\x8e"": ""\xe7\x94\xbb\xe8\x99\x8e"",\n""\xe7\x95\xab\xe8\xab\x96"": ""\xe7\x94\xbb\xe8\xae\xba"",\n""\xe7\x95\xab\xe8\xad\x9c"": ""\xe7\x94\xbb\xe8\xb0\xb1"",\n""\xe7\x95\xab\xe8\xb1\xa1"": ""\xe7\x94\xbb\xe8\xb1\xa1"",\n""\xe7\x95\xab\xe8\xb3\xaa"": ""\xe7\x94\xbb\xe8\xb4\xa8"",\n""\xe7\x95\xab\xe8\xb2\xbc"": ""\xe7\x94\xbb\xe8\xb4\xb4"",\n""\xe7\x95\xab\xe8\xbb\xb8"": ""\xe7\x94\xbb\xe8\xbd\xb4"",\n""\xe7\x95\xab\xe9\xa0\x81"": ""\xe7\x94\xbb\xe9\xa1\xb5"",\n""\xe9\xb9\xbd\xe9\xb9\xbc"": ""\xe7\x9b\x90\xe7\xa2\xb1"",\n""\xe9\xb9\xbc"": ""\xe7\xa2\xb1"",\n""\xe9\xb9\xbc\xe5\x9f\xba"": ""\xe7\xa2\xb1\xe5\x9f\xba"",\n""\xe9\xb9\xbc\xe5\xba\xa6"": ""\xe7\xa2\xb1\xe5\xba\xa6"",\n""\xe9\xb9\xbc\xe6\xb0\xb4"": ""\xe7\xa2\xb1\xe6\xb0\xb4"",\n""\xe9\xb9\xbc\xe7\x86\x94"": ""\xe7\xa2\xb1\xe7\x86\x94"",\n""\xe7\xa3\x81\xe7\x95\xab"": ""\xe7\xa3\x81\xe7\x94\xbb"",\n""\xe7\xad\x96\xe7\x95\xab"": ""\xe7\xad\x96\xe7\x94\xbb"",\n""\xe7\xb5\x84\xe7\x95\xab"": ""\xe7\xbb\x84\xe7\x94\xbb"",\n""\xe7\xb5\xb9\xe7\x95\xab"": ""\xe7\xbb\xa2\xe7\x94\xbb"",\n""\xe8\x80\x90\xe9\xb9\xbc"": ""\xe8\x80\x90\xe7\xa2\xb1"",\n""\xe8\x82\x89\xe9\xb9\xbc"": ""\xe8\x82\x89\xe7\xa2\xb1"",\n""\xe8\x86\xa0\xe7\x95\xab"": ""\xe8\x83\xb6\xe7\x94\xbb"",\n""\xe8\x8c\xb6\xe9\xb9\xbc"": ""\xe8\x8c\xb6\xe7\xa2\xb1"",\n""\xe8\xa5\xbf\xe7\x95\xab"": ""\xe8\xa5\xbf\xe7\x94\xbb"",\n""\xe8\xb2\xbc\xe7\x95\xab"": ""\xe8\xb4\xb4\xe7\x94\xbb"",\n""\xe8\xbf\x94\xe9\xb9\xbc"": ""\xe8\xbf\x94\xe7\xa2\xb1"",\n""\xe9\x8d\xbe\xe9\x8d\x9b"": ""\xe9\x94\xba\xe9\x94\xbb"",\n""\xe9\x8d\x9b\xe9\x8d\xbe"": ""\xe9\x94\xbb\xe9\x94\xba"",\n""\xe9\x9b\x95\xe7\x95\xab"": ""\xe9\x9b\x95\xe7\x94\xbb"",\n""\xe9\xaf\xb0"": ""\xe9\xb2\xb6"",\n""\xe4\xb8\x89\xe8\x81\xaf\xe7\x95\xab"": ""\xe4\xb8\x89\xe8\x81\x94\xe7\x94\xbb"",\n""\xe4\xb8\xad\xe5\x9c\x8b\xe7\x95\xab"": ""\xe4\xb8\xad\xe5\x9b\xbd\xe7\x94\xbb"",\n""\xe6\x9b\xb8\xe7\x95\xab"": ""\xe4\xb9\xa6\xe7\x94\xbb"",\n""\xe6\x9b\xb8\xe7\x95\xab\xe7\xa4\xbe"": ""\xe4\xb9\xa6\xe7\x94\xbb\xe7\xa4\xbe"",\n""\xe4\xba\x94\xe7\xad\x86\xe7\x95\xab"": ""\xe4\xba\x94\xe7\xac\x94\xe7\x94\xbb"",\n""\xe4\xbd\x9c\xe7\x95\xab"": ""\xe4\xbd\x9c\xe7\x94\xbb"",\n""\xe5\x85\xa5\xe7\x95\xab"": ""\xe5\x85\xa5\xe7\x94\xbb"",\n""\xe5\xaf\xab\xe7\x94\x9f\xe7\x95\xab"": ""\xe5\x86\x99\xe7\x94\x9f\xe7\x94\xbb"",\n""\xe5\x88\xbb\xe7\x95\xab"": ""\xe5\x88\xbb\xe7\x94\xbb"",\n""\xe5\x8b\x95\xe7\x95\xab"": ""\xe5\x8a\xa8\xe7\x94\xbb"",\n""\xe5\x8b\xbe\xe7\x95\xab"": ""\xe5\x8b\xbe\xe7\x94\xbb"",\n""\xe5\x96\xae\xe8\x89\xb2\xe7\x95\xab"": ""\xe5\x8d\x95\xe8\x89\xb2\xe7\x94\xbb"",\n""\xe5\x8d\xa1\xe9\x80\x9a\xe7\x95\xab"": ""\xe5\x8d\xa1\xe9\x80\x9a\xe7\x94\xbb"",\n""\xe5\x9c\x8b\xe7\x95\xab"": ""\xe5\x9b\xbd\xe7\x94\xbb"",\n""\xe5\x9c\x96\xe7\x95\xab"": ""\xe5\x9b\xbe\xe7\x94\xbb"",\n""\xe5\xa3\x81\xe7\x95\xab"": ""\xe5\xa3\x81\xe7\x94\xbb"",\n""\xe5\xad\x97\xe7\x95\xab"": ""\xe5\xad\x97\xe7\x94\xbb"",\n""\xe5\xae\xa3\xe5\x82\xb3\xe7\x95\xab"": ""\xe5\xae\xa3\xe4\xbc\xa0\xe7\x94\xbb"",\n""\xe5\xb7\xa5\xe7\xad\x86\xe7\x95\xab"": ""\xe5\xb7\xa5\xe7\xac\x94\xe7\x94\xbb"",\n""\xe5\xb9\xb4\xe7\x95\xab"": ""\xe5\xb9\xb4\xe7\x94\xbb"",\n""\xe5\xb9\xbd\xe9\xbb\x98\xe7\x95\xab"": ""\xe5\xb9\xbd\xe9\xbb\x98\xe7\x94\xbb"",\n""\xe6\x8c\x87\xe7\x95\xab"": ""\xe6\x8c\x87\xe7\x94\xbb"",\n""\xe6\x8f\x8f\xe7\x95\xab"": ""\xe6\x8f\x8f\xe7\x94\xbb"",\n""\xe6\x8f\x92\xe7\x95\xab"": ""\xe6\x8f\x92\xe7\x94\xbb"",\n""\xe6\x93\x98\xe7\x95\xab"": ""\xe6\x93\x98\xe7\x94\xbb"",\n""\xe6\x98\xa5\xe7\x95\xab"": ""\xe6\x98\xa5\xe7\x94\xbb"",\n""\xe6\x9c\xa8\xe5\x88\xbb\xe7\x95\xab"": ""\xe6\x9c\xa8\xe5\x88\xbb\xe7\x94\xbb"",\n""\xe6\xa9\x9f\xe6\xa2\xb0\xe7\x95\xab"": ""\xe6\x9c\xba\xe6\xa2\xb0\xe7\x94\xbb"",\n""\xe6\xaf\x94\xe7\x95\xab"": ""\xe6\xaf\x94\xe7\x94\xbb"",\n""\xe6\xaf\x9b\xe7\xad\x86\xe7\x95\xab"": ""\xe6\xaf\x9b\xe7\xac\x94\xe7\x94\xbb"",\n""\xe6\xb0\xb4\xe7\xb2\x89\xe7\x95\xab"": ""\xe6\xb0\xb4\xe7\xb2\x89\xe7\x94\xbb"",\n""\xe6\xb2\xb9\xe7\x95\xab"": ""\xe6\xb2\xb9\xe7\x94\xbb"",\n""\xe6\xb5\xb7\xe6\x99\xaf\xe7\x95\xab"": ""\xe6\xb5\xb7\xe6\x99\xaf\xe7\x94\xbb"",\n""\xe6\xbc\xab\xe7\x95\xab"": ""\xe6\xbc\xab\xe7\x94\xbb"",\n""\xe9\xbb\x9e\xe7\x95\xab"": ""\xe7\x82\xb9\xe7\x94\xbb"",\n""\xe7\x89\x88\xe7\x95\xab"": ""\xe7\x89\x88\xe7\x94\xbb"",\n""\xe7\x95\xab"": ""\xe7\x94\xbb"",\n""\xe7\x95\xab\xe5\x83\x8f"": ""\xe7\x94\xbb\xe5\x83\x8f"",\n""\xe7\x95\xab\xe5\x86\x8a"": ""\xe7\x94\xbb\xe5\x86\x8c"",\n""\xe7\x95\xab\xe5\x88\x8a"": ""\xe7\x94\xbb\xe5\x88\x8a"",\n""\xe7\x95\xab\xe5\x8c\xa0"": ""\xe7\x94\xbb\xe5\x8c\xa0"",\n""\xe7\x95\xab\xe6\x8d\xb2"": ""\xe7\x94\xbb\xe5\x8d\xb7"",\n""\xe7\x95\xab\xe5\x9c\x96"": ""\xe7\x94\xbb\xe5\x9b\xbe"",\n""\xe7\x95\xab\xe5\xa3\x87"": ""\xe7\x94\xbb\xe5\x9d\x9b"",\n""\xe7\x95\xab\xe5\xae\xa4"": ""\xe7\x94\xbb\xe5\xae\xa4"",\n""\xe7\x95\xab\xe5\xae\xb6"": ""\xe7\x94\xbb\xe5\xae\xb6"",\n""\xe7\x95\xab\xe5\xb1\x8f"": ""\xe7\x94\xbb\xe5\xb1\x8f"",\n""\xe7\x95\xab\xe5\xb1\x95"": ""\xe7\x94\xbb\xe5\xb1\x95"",\n""\xe7\x95\xab\xe5\xb8\x83"": ""\xe7\x94\xbb\xe5\xb8\x83"",\n""\xe7\x95\xab\xe5\xb8\xab"": ""\xe7\x94\xbb\xe5\xb8\x88"",\n""\xe7\x95\xab\xe5\xbb\x8a"": ""\xe7\x94\xbb\xe5\xbb\x8a"",\n""\xe7\x95\xab\xe5\xa0\xb1"": ""\xe7\x94\xbb\xe6\x8a\xa5"",\n""\xe7\x95\xab\xe6\x8a\xbc"": ""\xe7\x94\xbb\xe6\x8a\xbc"",\n""\xe7\x95\xab\xe6\x9d\xbf"": ""\xe7\x94\xbb\xe6\x9d\xbf"",\n""\xe7\x95\xab\xe7\x89\x87"": ""\xe7\x94\xbb\xe7\x89\x87"",\n""\xe7\x95\xab\xe7\x95\xab"": ""\xe7\x94\xbb\xe7\x94\xbb"",\n""\xe7\x95\xab\xe7\x9a\xae"": ""\xe7\x94\xbb\xe7\x9a\xae"",\n""\xe7\x95\xab\xe7\x9c\x89\xe9\xb3\xa5"": ""\xe7\x94\xbb\xe7\x9c\x89\xe9\xb8\x9f"",\n""\xe7\x95\xab\xe7\xa8\xbf"": ""\xe7\x94\xbb\xe7\xa8\xbf"",\n""\xe7\x95\xab\xe7\xad\x86"": ""\xe7\x94\xbb\xe7\xac\x94"",\n""\xe7\x95\xab\xe9\x99\xa2"": ""\xe7\x94\xbb\xe9\x99\xa2"",\n""\xe7\x95\xab\xe9\x9b\x86"": ""\xe7\x94\xbb\xe9\x9b\x86"",\n""\xe7\x95\xab\xe9\x9d\xa2"": ""\xe7\x94\xbb\xe9\x9d\xa2"",\n""\xe7\xad\x86\xe7\x95\xab"": ""\xe7\xac\x94\xe7\x94\xbb"",\n""\xe7\xb4\xb0\xe5\xaf\x86\xe7\x95\xab"": ""\xe7\xbb\x86\xe5\xaf\x86\xe7\x94\xbb"",\n""\xe7\xb9\xaa\xe7\x95\xab"": ""\xe7\xbb\x98\xe7\x94\xbb"",\n""\xe8\x87\xaa\xe7\x95\xab\xe5\x83\x8f"": ""\xe8\x87\xaa\xe7\x94\xbb\xe5\x83\x8f"",\n""\xe8\xa0\x9f\xe7\xad\x86\xe7\x95\xab"": ""\xe8\x9c\xa1\xe7\xac\x94\xe7\x94\xbb"",\n""\xe8\xa3\xb8\xe9\xab\x94\xe7\x95\xab"": ""\xe8\xa3\xb8\xe4\xbd\x93\xe7\x94\xbb"",\n""\xe8\xa5\xbf\xe6\xb4\x8b\xe7\x95\xab"": ""\xe8\xa5\xbf\xe6\xb4\x8b\xe7\x94\xbb"",\n""\xe9\x80\x8f\xe8\xa6\x96\xe7\x95\xab"": ""\xe9\x80\x8f\xe8\xa7\x86\xe7\x94\xbb"",\n""\xe9\x8a\x85\xe7\x89\x88\xe7\x95\xab"": ""\xe9\x93\x9c\xe7\x89\x88\xe7\x94\xbb"",\n""\xe9\x8d\xbe"": ""\xe9\x94\xba"",\n""\xe9\x9d\x9c\xe7\x89\xa9\xe7\x95\xab"": ""\xe9\x9d\x99\xe7\x89\xa9\xe7\x94\xbb"",\n""\xe9\xa4\x98"": ""\xe9\xa6\x80"",\n}\n\nzh2TW = {\n""\xe7\xbc\xba\xe7\x9c\x81"": ""\xe9\xa0\x90\xe8\xa8\xad"",\n""\xe4\xb8\xb2\xe8\xa1\x8c"": ""\xe4\xb8\xb2\xe5\x88\x97"",\n""\xe4\xbb\xa5\xe5\xa4\xaa\xe7\xbd\x91"": ""\xe4\xb9\x99\xe5\xa4\xaa\xe7\xb6\xb2"",\n""\xe4\xbd\x8d\xe5\x9b\xbe"": ""\xe9\xbb\x9e\xe9\x99\xa3\xe5\x9c\x96"",\n""\xe4\xbe\x8b\xe7\xa8\x8b"": ""\xe5\xb8\xb8\xe5\xbc\x8f"",\n""\xe4\xbf\xa1\xe9\x81\x93"": ""\xe9\x80\x9a\xe9\x81\x93"",\n""\xe5\x85\x89\xe6\xa0\x87"": ""\xe6\xb8\xb8\xe6\xa8\x99"",\n""\xe5\x85\x89\xe7\x9b\x98"": ""\xe5\x85\x89\xe7\xa2\x9f"",\n""\xe5\x85\x89\xe9\xa9\xb1"": ""\xe5\x85\x89\xe7\xa2\x9f\xe6\xa9\x9f"",\n""\xe5\x85\xa8\xe8\xa7\x92"": ""\xe5\x85\xa8\xe5\xbd\xa2"",\n""\xe5\x8a\xa0\xe8\xbd\xbd"": ""\xe8\xbc\x89\xe5\x85\xa5"",\n""\xe5\x8d\x8a\xe8\xa7\x92"": ""\xe5\x8d\x8a\xe5\xbd\xa2"",\n""\xe5\x8f\x98\xe9\x87\x8f"": ""\xe8\xae\x8a\xe6\x95\xb8"",\n""\xe5\x99\xaa\xe5\xa3\xb0"": ""\xe9\x9b\x9c\xe8\xa8\x8a"",\n""\xe8\x84\xb1\xe6\x9c\xba"": ""\xe9\x9b\xa2\xe7\xb7\x9a"",\n""\xe5\xa3\xb0\xe5\x8d\xa1"": ""\xe9\x9f\xb3\xe6\x95\x88\xe5\x8d\xa1"",\n""\xe8\x80\x81\xe5\xad\x97\xe5\x8f\xb7"": ""\xe8\x80\x81\xe5\xad\x97\xe8\x99\x9f"",\n""\xe5\xad\x97\xe5\x8f\xb7"": ""\xe5\xad\x97\xe5\x9e\x8b\xe5\xa4\xa7\xe5\xb0\x8f"",\n""\xe5\xad\x97\xe5\xba\x93"": ""\xe5\xad\x97\xe5\x9e\x8b\xe6\xaa\x94"",\n""\xe5\xad\x97\xe6\xae\xb5"": ""\xe6\xac\x84\xe4\xbd\x8d"",\n""\xe5\xad\x97\xe7\xac\xa6"": ""\xe5\xad\x97\xe5\x85\x83"",\n""\xe5\xad\x98\xe7\x9b\x98"": ""\xe5\xad\x98\xe6\xaa\x94"",\n""\xe5\xaf\xbb\xe5\x9d\x80"": ""\xe5\xae\x9a\xe5\x9d\x80"",\n""\xe5\xb0\xbe\xe6\xb3\xa8"": ""\xe7\xab\xa0\xe7\xaf\x80\xe9\x99\x84\xe8\xa8\xbb"",\n""\xe5\xbc\x82\xe6\xad\xa5"": ""\xe9\x9d\x9e\xe5\x90\x8c\xe6\xad\xa5"",\n""\xe6\x80\xbb\xe7\xba\xbf"": ""\xe5\x8c\xaf\xe6\xb5\x81\xe6\x8e\x92"",\n""\xe6\x8b\xac\xe5\x8f\xb7"": ""\xe6\x8b\xac\xe5\xbc\xa7"",\n""\xe6\x8e\xa5\xe5\x8f\xa3"": ""\xe4\xbb\x8b\xe9\x9d\xa2"",\n""\xe6\x8e\xa7\xe4\xbb\xb6"": ""\xe6\x8e\xa7\xe5\x88\xb6\xe9\xa0\x85"",\n""\xe6\x9d\x83\xe9\x99\x90"": ""\xe8\xa8\xb1\xe5\x8f\xaf\xe6\xac\x8a"",\n""\xe7\x9b\x98\xe7\x89\x87"": ""\xe7\xa2\x9f\xe7\x89\x87"",\n""\xe7\xa1\x85\xe7\x89\x87"": ""\xe7\x9f\xbd\xe7\x89\x87"",\n""\xe7\xa1\x85\xe8\xb0\xb7"": ""\xe7\x9f\xbd\xe8\xb0\xb7"",\n""\xe7\xa1\xac\xe7\x9b\x98"": ""\xe7\xa1\xac\xe7\xa2\x9f"",\n""\xe7\xa3\x81\xe7\x9b\x98"": ""\xe7\xa3\x81\xe7\xa2\x9f"",\n""\xe7\xa3\x81\xe9\x81\x93"": ""\xe7\xa3\x81\xe8\xbb\x8c"",\n""\xe7\xa8\x8b\xe6\x8e\xa7"": ""\xe7\xa8\x8b\xe5\xbc\x8f\xe6\x8e\xa7\xe5\x88\xb6"",\n""\xe7\xab\xaf\xe5\x8f\xa3"": ""\xe5\x9f\xa0"",\n""\xe7\xae\x97\xe5\xad\x90"": ""\xe9\x81\x8b\xe7\xae\x97\xe5\x85\x83"",\n""\xe7\xae\x97\xe6\xb3\x95"": ""\xe6\xbc\x94\xe7\xae\x97\xe6\xb3\x95"",\n""\xe8\x8a\xaf\xe7\x89\x87"": ""\xe6\x99\xb6\xe7\x89\x87"",\n""\xe8\x8a\xaf\xe7\x89\x87"": ""\xe6\x99\xb6\xe5\x85\x83"",\n""\xe8\xaf\x8d\xe7\xbb\x84"": ""\xe7\x89\x87\xe8\xaa\x9e"",\n""\xe8\xaf\x91\xe7\xa0\x81"": ""\xe8\xa7\xa3\xe7\xa2\xbc"",\n""\xe8\xbd\xaf\xe9\xa9\xb1"": ""\xe8\xbb\x9f\xe7\xa2\x9f\xe6\xa9\x9f"",\n""\xe5\xbf\xab\xe9\x97\xaa\xe5\xad\x98\xe5\x82\xa8\xe5\x99\xa8"": ""\xe5\xbf\xab\xe9\x96\x83\xe8\xa8\x98\xe6\x86\xb6\xe9\xab\x94"",\n""\xe9\x97\xaa\xe5\xad\x98"": ""\xe5\xbf\xab\xe9\x96\x83\xe8\xa8\x98\xe6\x86\xb6\xe9\xab\x94"",\n""\xe9\xbc\xa0\xe6\xa0\x87"": ""\xe6\xbb\x91\xe9\xbc\xa0"",\n""\xe8\xbf\x9b\xe5\x88\xb6"": ""\xe9\x80\xb2\xe4\xbd\x8d"",\n""\xe4\xba\xa4\xe4\xba\x92\xe5\xbc\x8f"": ""\xe4\xba\x92\xe5\x8b\x95\xe5\xbc\x8f"",\n""\xe4\xbb\xbf\xe7\x9c\x9f"": ""\xe6\xa8\xa1\xe6\x93\xac"",\n""\xe4\xbc\x98\xe5\x85\x88\xe7\xba\xa7"": ""\xe5\x84\xaa\xe5\x85\x88\xe9\xa0\x86\xe5\xba\x8f"",\n""\xe4\xbc\xa0\xe6\x84\x9f"": ""\xe6\x84\x9f\xe6\xb8\xac"",\n""\xe4\xbe\xbf\xe6\x90\xba\xe5\xbc\x8f"": ""\xe6\x94\x9c\xe5\xb8\xb6\xe5\x9e\x8b"",\n""\xe4\xbf\xa1\xe6\x81\xaf\xe8\xae\xba"": ""\xe8\xb3\x87\xe8\xa8\x8a\xe7\x90\x86\xe8\xab\x96"",\n""\xe5\x86\x99\xe4\xbf\x9d\xe6\x8a\xa4"": ""\xe9\x98\xb2\xe5\xaf\xab"",\n""\xe5\x88\x86\xe5\xb8\x83\xe5\xbc\x8f"": ""\xe5\x88\x86\xe6\x95\xa3\xe5\xbc\x8f"",\n""\xe5\x88\x86\xe8\xbe\xa8\xe7\x8e\x87"": ""\xe8\xa7\xa3\xe6\x9e\x90\xe5\xba\xa6"",\n""\xe6\x9c\x8d\xe5\x8a\xa1\xe5\x99\xa8"": ""\xe4\xbc\xba\xe6\x9c\x8d\xe5\x99\xa8"",\n""\xe7\xad\x89\xe4\xba\x8e"": ""\xe7\xad\x89\xe6\x96\xbc"",\n""\xe5\xb1\x80\xe5\x9f\x9f\xe7\xbd\x91"": ""\xe5\x8d\x80\xe5\x9f\x9f\xe7\xb6\xb2"",\n""\xe8\xae\xa1\xe7\xae\x97\xe6\x9c\xba"": ""\xe9\x9b\xbb\xe8\x85\xa6"",\n""\xe6\x89\xab\xe7\x9e\x84\xe4\xbb\xaa"": ""\xe6\x8e\x83\xe7\x9e\x84\xe5\x99\xa8"",\n""\xe5\xae\xbd\xe5\xb8\xa6"": ""\xe5\xaf\xac\xe9\xa0\xbb"",\n""\xe6\x95\xb0\xe6\x8d\xae\xe5\xba\x93"": ""\xe8\xb3\x87\xe6\x96\x99\xe5\xba\xab"",\n""\xe5\xa5\xb6\xe9\x85\xaa"": ""\xe4\xb9\xb3\xe9\x85\xaa"",\n""\xe5\xb7\xa8\xe5\x95\x86"": ""\xe9\x89\x85\xe8\xb3\x88"",\n""\xe6\x89\x8b\xe7\x94\xb5"": ""\xe6\x89\x8b\xe9\x9b\xbb\xe7\xad\x92"",\n""\xe4\xb8\x87\xe5\x8e\x86"": ""\xe8\x90\xac\xe6\x9b\x86"",\n""\xe6\xb0\xb8\xe5\x8e\x86"": ""\xe6\xb0\xb8\xe6\x9b\x86"",\n""\xe8\xaf\x8d\xe6\xb1\x87"": ""\xe8\xbe\xad\xe5\xbd\x99"",\n""\xe4\xb9\xa0\xe7\x94\xa8"": ""\xe6\x85\xa3\xe7\x94\xa8"",\n""\xe5\x85\x83\xe9\x9f\xb3"": ""\xe6\xaf\x8d\xe9\x9f\xb3"",\n""\xe4\xbb\xbb\xe6\x84\x8f\xe7\x90\x83"": ""\xe8\x87\xaa\xe7\x94\xb1\xe7\x90\x83"",\n""\xe5\xa4\xb4\xe7\x90\x83"": ""\xe9\xa0\xad\xe6\xa7\x8c"",\n""\xe5\x85\xa5\xe7\x90\x83"": ""\xe9\x80\xb2\xe7\x90\x83"",\n""\xe7\xb2\x92\xe5\x85\xa5\xe7\x90\x83"": ""\xe9\xa1\x86\xe9\x80\xb2\xe7\x90\x83"",\n""\xe6\x89\x93\xe9\x97\xa8"": ""\xe5\xb0\x84\xe9\x96\x80"",\n""\xe7\x81\xab\xe9\x94\x85\xe7\x9b\x96\xe5\xb8\xbd"": ""\xe8\x93\x8b\xe7\x81\xab\xe9\x8d\x8b"",\n""\xe6\x89\x93\xe5\x8d\xb0\xe6\x9c\xba"": ""\xe5\x8d\xb0\xe8\xa1\xa8\xe6\xa9\x9f"",\n""\xe6\x89\x93\xe5\x8d\xb0\xe6\xa9\x9f"": ""\xe5\x8d\xb0\xe8\xa1\xa8\xe6\xa9\x9f"",\n""\xe5\xad\x97\xe8\x8a\x82"": ""\xe4\xbd\x8d\xe5\x85\x83\xe7\xb5\x84"",\n""\xe5\xad\x97\xe7\xaf\x80"": ""\xe4\xbd\x8d\xe5\x85\x83\xe7\xb5\x84"",\n""\xe6\x89\x93\xe5\x8d\xb0"": ""\xe5\x88\x97\xe5\x8d\xb0"",\n""\xe6\x89\x93\xe5\x8d\xb0"": ""\xe5\x88\x97\xe5\x8d\xb0"",\n""\xe7\xa1\xac\xe4\xbb\xb6"": ""\xe7\xa1\xac\xe9\xab\x94"",\n""\xe7\xa1\xac\xe4\xbb\xb6"": ""\xe7\xa1\xac\xe9\xab\x94"",\n""\xe4\xba\x8c\xe6\x9e\x81\xe7\xae\xa1"": ""\xe4\xba\x8c\xe6\xa5\xb5\xe9\xab\x94"",\n""\xe4\xba\x8c\xe6\xa5\xb5\xe7\xae\xa1"": ""\xe4\xba\x8c\xe6\xa5\xb5\xe9\xab\x94"",\n""\xe4\xb8\x89\xe6\x9e\x81\xe7\xae\xa1"": ""\xe4\xb8\x89\xe6\xa5\xb5\xe9\xab\x94"",\n""\xe4\xb8\x89\xe6\xa5\xb5\xe7\xae\xa1"": ""\xe4\xb8\x89\xe6\xa5\xb5\xe9\xab\x94"",\n""\xe8\xbd\xaf\xe4\xbb\xb6"": ""\xe8\xbb\x9f\xe9\xab\x94"",\n""\xe8\xbb\x9f\xe4\xbb\xb6"": ""\xe8\xbb\x9f\xe9\xab\x94"",\n""\xe7\xbd\x91\xe7\xbb\x9c"": ""\xe7\xb6\xb2\xe8\xb7\xaf"",\n""\xe7\xb6\xb2\xe7\xb5\xa1"": ""\xe7\xb6\xb2\xe8\xb7\xaf"",\n""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe8\x83\xbd"": ""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe6\x85\xa7"",\n""\xe8\x88\xaa\xe5\xa4\xa9\xe9\xa3\x9e\xe6\x9c\xba"": ""\xe5\xa4\xaa\xe7\xa9\xba\xe6\xa2\xad"",\n""\xe7\xa9\xbf\xe6\xa2\xad\xe6\xa9\x9f"": ""\xe5\xa4\xaa\xe7\xa9\xba\xe6\xa2\xad"",\n""\xe5\x9b\xa0\xe7\x89\xb9\xe7\xbd\x91"": ""\xe7\xb6\xb2\xe9\x9a\x9b\xe7\xb6\xb2\xe8\xb7\xaf"",\n""\xe4\xba\x92\xe8\x81\xaf\xe7\xb6\xb2"": ""\xe7\xb6\xb2\xe9\x9a\x9b\xe7\xb6\xb2\xe8\xb7\xaf"",\n""\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xba"": ""\xe6\xa9\x9f\xe5\x99\xa8\xe4\xba\xba"",\n""\xe6\xa9\x9f\xe6\xa2\xb0\xe4\xba\xba"": ""\xe6\xa9\x9f\xe5\x99\xa8\xe4\xba\xba"",\n""\xe7\xa7\xbb\xe5\x8a\xa8\xe7\x94\xb5\xe8\xaf\x9d"": ""\xe8\xa1\x8c\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"",\n""\xe6\xb5\x81\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"": ""\xe8\xa1\x8c\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"",\n""\xe8\xb0\x83\xe5\x88\xb6\xe8\xa7\xa3\xe8\xb0\x83\xe5\x99\xa8"": ""\xe6\x95\xb8\xe6\x93\x9a\xe6\xa9\x9f"",\n""\xe8\xaa\xbf\xe5\x88\xb6\xe8\xa7\xa3\xe8\xaa\xbf\xe5\x99\xa8"": ""\xe6\x95\xb8\xe6\x93\x9a\xe6\xa9\x9f"",\n""\xe7\x9f\xad\xe4\xbf\xa1"": ""\xe7\xb0\xa1\xe8\xa8\x8a"",\n""\xe7\x9f\xad\xe8\xa8\x8a"": ""\xe7\xb0\xa1\xe8\xa8\x8a"",\n""\xe4\xb9\x8c\xe5\x85\xb9\xe5\x88\xab\xe5\x85\x8b\xe6\x96\xaf\xe5\x9d\xa6"": ""\xe7\x83\x8f\xe8\x8c\xb2\xe5\x88\xa5\xe5\x85\x8b"",\n""\xe4\xb9\x8d\xe5\xbe\x97"": ""\xe6\x9f\xa5\xe5\xbe\xb7"",\n""\xe4\xb9\x8d\xe5\xbe\x97"": ""\xe6\x9f\xa5\xe5\xbe\xb7"",\n""\xe4\xb9\x9f\xe9\x97\xa8"": ""\xe8\x91\x89\xe9\x96\x80"",\n""\xe4\xb9\x9f\xe9\x96\x80"": ""\xe8\x91\x89\xe9\x96\x80"",\n""\xe4\xbc\xaf\xe5\x88\xa9\xe5\x85\xb9"": ""\xe8\xb2\x9d\xe9\x87\x8c\xe6\x96\xaf"",\n""\xe4\xbc\xaf\xe5\x88\xa9\xe8\x8c\xb2"": ""\xe8\xb2\x9d\xe9\x87\x8c\xe6\x96\xaf"",\n""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"": ""\xe7\xb6\xad\xe5\xbe\xb7\xe8\xa7\x92"",\n""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"": ""\xe7\xb6\xad\xe5\xbe\xb7\xe8\xa7\x92"",\n""\xe5\x85\x8b\xe7\xbd\x97\xe5\x9c\xb0\xe4\xba\x9a"": ""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9f\x83\xe8\xa5\xbf\xe4\xba\x9e"",\n""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9c\xb0\xe4\xba\x9e"": ""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9f\x83\xe8\xa5\xbf\xe4\xba\x9e"",\n""\xe5\x86\x88\xe6\xaf\x94\xe4\xba\x9a"": ""\xe7\x94\x98\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe5\xb2\xa1\xe6\xaf\x94\xe4\xba\x9e"": ""\xe7\x94\x98\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a\xe6\xaf\x94\xe7\xbb\x8d"": ""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xa2"",\n""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xb9"": ""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xa2"",\n""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"": ""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe6\x96\xaf\xe7\x99\xbb"",\n""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"": ""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe6\x96\xaf\xe7\x99\xbb"",\n""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9a"": ""\xe8\xb3\xb4\xe6\xaf\x94\xe7\x91\x9e\xe4\xba\x9e"",\n""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9e"": ""\xe8\xb3\xb4\xe6\xaf\x94\xe7\x91\x9e\xe4\xba\x9e"",\n""\xe5\x8a\xa0\xe7\xba\xb3"": ""\xe8\xbf\xa6\xe7\xb4\x8d"",\n""\xe5\x8a\xa0\xe7\xb4\x8d"": ""\xe8\xbf\xa6\xe7\xb4\x8d"",\n""\xe5\x8a\xa0\xe8\x93\xac"": ""\xe5\x8a\xa0\xe5\xbd\xad"",\n""\xe5\x8a\xa0\xe8\x93\xac"": ""\xe5\x8a\xa0\xe5\xbd\xad"",\n""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xba\xb3"": ""\xe6\xb3\xa2\xe6\x9c\xad\xe9\x82\xa3"",\n""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xb4\x8d"": ""\xe6\xb3\xa2\xe6\x9c\xad\xe9\x82\xa3"",\n""\xe5\x8d\xa1\xe5\xa1\x94\xe5\xb0\x94"": ""\xe5\x8d\xa1\xe9\x81\x94"",\n""\xe5\x8d\xa1\xe5\xa1\x94\xe7\x88\xbe"": ""\xe5\x8d\xa1\xe9\x81\x94"",\n""\xe5\x8d\xa2\xe6\x97\xba\xe8\xbe\xbe"": ""\xe7\x9b\xa7\xe5\xae\x89\xe9\x81\x94"",\n""\xe7\x9b\xa7\xe6\x97\xba\xe9\x81\x94"": ""\xe7\x9b\xa7\xe5\xae\x89\xe9\x81\x94"",\n""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa9\xac\xe6\x8b\x89"": ""\xe7\x93\x9c\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"",\n""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"": ""\xe7\x93\x9c\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"",\n""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe5\xb0\x94"": ""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a"",\n""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe7\x88\xbe"": ""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a"",\n""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9a"": ""\xe5\x8e\x84\xe5\x88\xa9\xe5\x9e\x82\xe4\xba\x9e"",\n""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9e"": ""\xe5\x8e\x84\xe5\x88\xa9\xe5\x9e\x82\xe4\xba\x9e"",\n""\xe5\x90\x89\xe5\xb8\x83\xe6\x8f\x90"": ""\xe5\x90\x89\xe5\xb8\x83\xe5\x9c\xb0"",\n""\xe5\x90\x89\xe5\xb8\x83\xe5\xa0\xa4"": ""\xe5\x90\x89\xe5\xb8\x83\xe5\x9c\xb0"",\n""\xe5\x93\x88\xe8\x90\xa8\xe5\x85\x8b\xe6\x96\xaf\xe5\x9d\xa6"": ""\xe5\x93\x88\xe8\x96\xa9\xe5\x85\x8b"",\n""\xe5\x93\xa5\xe6\x96\xaf\xe8\xbe\xbe\xe9\xbb\x8e\xe5\x8a\xa0"": ""\xe5\x93\xa5\xe6\x96\xaf\xe5\xa4\xa7\xe9\xbb\x8e\xe5\x8a\xa0"",\n""\xe5\x93\xa5\xe6\x96\xaf\xe9\x81\x94\xe9\xbb\x8e\xe5\x8a\xa0"": ""\xe5\x93\xa5\xe6\x96\xaf\xe5\xa4\xa7\xe9\xbb\x8e\xe5\x8a\xa0"",\n""\xe5\x9b\xbe\xe7\x93\xa6\xe5\x8d\xa2"": ""\xe5\x90\x90\xe7\x93\xa6\xe9\xad\xaf"",\n""\xe5\x9c\x96\xe7\x93\xa6\xe7\x9b\xa7"": ""\xe5\x90\x90\xe7\x93\xa6\xe9\xad\xaf"",\n""\xe5\x9c\x9f\xe5\xba\x93\xe6\x9b\xbc\xe6\x96\xaf\xe5\x9d\xa6"": ""\xe5\x9c\x9f\xe5\xba\xab\xe6\x9b\xbc"",\n""\xe5\x9c\xa3\xe5\x8d\xa2\xe8\xa5\xbf\xe4\xba\x9a"": ""\xe8\x81\x96\xe9\x9c\xb2\xe8\xa5\xbf\xe4\xba\x9e"",\n""\xe8\x81\x96\xe7\x9b\xa7\xe8\xa5\xbf\xe4\xba\x9e"": ""\xe8\x81\x96\xe9\x9c\xb2\xe8\xa5\xbf\xe4\xba\x9e"",\n""\xe5\x9c\xa3\xe5\x9f\xba\xe8\x8c\xa8\xe5\x92\x8c\xe5\xb0\xbc\xe7\xbb\xb4\xe6\x96\xaf"": ""\xe8\x81\x96\xe5\x85\x8b\xe9\x87\x8c\xe6\x96\xaf\xe5\xa4\x9a\xe7\xa6\x8f\xe5\x8f\x8a\xe5\xb0\xbc\xe7\xb6\xad\xe6\x96\xaf"",\n""\xe8\x81\x96\xe5\x90\x89\xe6\x96\xaf\xe7\xb4\x8d\xe5\x9f\x9f\xe6\x96\xaf"": ""\xe8\x81\x96\xe5\x85\x8b\xe9\x87\x8c\xe6\x96\xaf\xe5\xa4\x9a\xe7\xa6\x8f\xe5\x8f\x8a\xe5\xb0\xbc\xe7\xb6\xad\xe6\x96\xaf"",\n""\xe5\x9c\xa3\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe4\xb8\x81\xe6\x96\xaf"": ""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe5\x8f\x8a\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe4\xb8\x81"",\n""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe4\xb8\x81\xe6\x96\xaf"": ""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe5\x8f\x8a\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe4\xb8\x81"",\n""\xe5\x9c\xa3\xe9\xa9\xac\xe5\x8a\x9b\xe8\xaf\xba"": ""\xe8\x81\x96\xe9\xa6\xac\xe5\x88\xa9\xe8\xab\xbe"",\n""\xe8\x81\x96\xe9\xa6\xac\xe5\x8a\x9b\xe8\xab\xbe"": ""\xe8\x81\x96\xe9\xa6\xac\xe5\x88\xa9\xe8\xab\xbe"",\n""\xe5\x9c\xad\xe4\xba\x9a\xe9\x82\xa3"": ""\xe8\x93\x8b\xe4\xba\x9e\xe9\x82\xa3"",\n""\xe5\x9c\xad\xe4\xba\x9e\xe9\x82\xa3"": ""\xe8\x93\x8b\xe4\xba\x9e\xe9\x82\xa3"",\n""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe5\x9d\xa6\xe5\xb0\x9a\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe5\x9d\xa6\xe5\xb0\x9a\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9a"": ""\xe8\xa1\xa3\xe7\xb4\xa2\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9e"": ""\xe8\xa1\xa3\xe7\xb4\xa2\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"": ""\xe5\x90\x89\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"",\n""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"": ""\xe5\x90\x89\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"",\n""\xe5\xa1\x94\xe5\x90\x89\xe5\x85\x8b\xe6\x96\xaf\xe5\x9d\xa6"": ""\xe5\xa1\x94\xe5\x90\x89\xe5\x85\x8b"",\n""\xe5\xa1\x9e\xe6\x8b\x89\xe5\x88\xa9\xe6\x98\x82"": ""\xe7\x8d\x85\xe5\xad\x90\xe5\xb1\xb1"",\n""\xe5\xa1\x9e\xe6\x8b\x89\xe5\x88\xa9\xe6\x98\x82"": ""\xe7\x8d\x85\xe5\xad\x90\xe5\xb1\xb1"",\n""\xe5\xa1\x9e\xe6\xb5\xa6\xe8\xb7\xaf\xe6\x96\xaf"": ""\xe5\xa1\x9e\xe6\x99\xae\xe5\x8b\x92\xe6\x96\xaf"",\n""\xe5\xa1\x9e\xe6\xb5\xa6\xe8\xb7\xaf\xe6\x96\xaf"": ""\xe5\xa1\x9e\xe6\x99\xae\xe5\x8b\x92\xe6\x96\xaf"",\n""\xe5\xa1\x9e\xe8\x88\x8c\xe5\xb0\x94"": ""\xe5\xa1\x9e\xe5\xb8\xad\xe7\x88\xbe"",\n""\xe5\xa1\x9e\xe8\x88\x8c\xe7\x88\xbe"": ""\xe5\xa1\x9e\xe5\xb8\xad\xe7\x88\xbe"",\n""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0"": ""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0"",\n""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"": ""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0"",\n""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\x94\xe9\x82\xa6"": ""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x85\x8b"",\n""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\xaf\xe9\x82\xa6"": ""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x85\x8b"",\n""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe8\xbe\xbe"": ""\xe5\xae\x89\xe5\x9c\xb0\xe5\x8d\xa1\xe5\x8f\x8a\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"",\n""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"": ""\xe5\xae\x89\xe5\x9c\xb0\xe5\x8d\xa1\xe5\x8f\x8a\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9a"": ""\xe5\xa5\x88\xe5\x8f\x8a\xe5\x88\xa9\xe4\xba\x9e"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9e"": ""\xe5\xa5\x88\xe5\x8f\x8a\xe5\x88\xa9\xe4\xba\x9e"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe5\xb0\x94"": ""\xe5\xb0\xbc\xe6\x97\xa5"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe7\x88\xbe"": ""\xe5\xb0\xbc\xe6\x97\xa5"",\n""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"": ""\xe5\xb7\xb4\xe8\xb2\x9d\xe5\xa4\x9a"",\n""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"": ""\xe5\xb7\xb4\xe8\xb2\x9d\xe5\xa4\x9a"",\n""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9a\xe6\x96\xb0\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a"": ""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe7\xb4\x90\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e"",\n""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe6\x96\xb0\xe7\x95\xbf\xe5\x85\xa7\xe4\xba\x9e"": ""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe7\xb4\x90\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e"",\n""\xe5\xb8\x83\xe5\x9f\xba\xe7\xba\xb3\xe6\xb3\x95\xe7\xb4\xa2"": ""\xe5\xb8\x83\xe5\x90\x89\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"",\n""\xe5\xb8\x83\xe5\x9f\xba\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"": ""\xe5\xb8\x83\xe5\x90\x89\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"",\n""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"": ""\xe8\x92\xb2\xe9\x9a\x86\xe5\x9c\xb0"",\n""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"": ""\xe8\x92\xb2\xe9\x9a\x86\xe5\x9c\xb0"",\n""\xe5\xb8\x8c\xe8\x85\x8a"": ""\xe5\xb8\x8c\xe8\x87\x98"",\n""\xe5\xb8\x95\xe5\x8a\xb3"": ""\xe5\xb8\x9b\xe7\x90\x89"",\n""\xe6\x84\x8f\xe5\xa4\xa7\xe5\x88\xa9"": ""\xe7\xbe\xa9\xe5\xa4\xa7\xe5\x88\xa9"",\n""\xe6\x84\x8f\xe5\xa4\xa7\xe5\x88\xa9"": ""\xe7\xbe\xa9\xe5\xa4\xa7\xe5\x88\xa9"",\n""\xe6\x89\x80\xe7\xbd\x97\xe9\x97\xa8\xe7\xbe\xa4\xe5\xb2\x9b"": ""\xe7\xb4\xa2\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"",\n""\xe6\x89\x80\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"": ""\xe7\xb4\xa2\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"",\n""\xe6\x96\x87\xe8\x8e\xb1"": ""\xe6\xb1\xb6\xe8\x90\x8a"",\n""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe5\x85\xb0"": ""\xe5\x8f\xb2\xe7\x93\xa6\xe6\xbf\x9f\xe8\x98\xad"",\n""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe8\x98\xad"": ""\xe5\x8f\xb2\xe7\x93\xa6\xe6\xbf\x9f\xe8\x98\xad"",\n""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe6\x96\xaf\xe6\xb4\x9b\xe7\xb6\xad\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe6\x96\xaf\xe6\xb4\x9b\xe7\xb6\xad\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe6\x96\xb0\xe8\xa5\xbf\xe5\x85\xb0"": ""\xe7\xb4\x90\xe8\xa5\xbf\xe8\x98\xad"",\n""\xe6\x96\xb0\xe8\xa5\xbf\xe8\x98\xad"": ""\xe7\xb4\x90\xe8\xa5\xbf\xe8\x98\xad"",\n""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe8\xbe\xbe"": ""\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe9\x81\x94"",\n""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe9\x81\x94"": ""\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe9\x81\x94"",\n""\xe6\xa0\xbc\xe9\xb2\x81\xe5\x90\x89\xe4\xba\x9a"": ""\xe5\x96\xac\xe6\xb2\xbb\xe4\xba\x9e"",\n""\xe6\xa0\xbc\xe9\xad\xaf\xe5\x90\x89\xe4\xba\x9e"": ""\xe5\x96\xac\xe6\xb2\xbb\xe4\xba\x9e"",\n""\xe4\xbd\x90\xe6\xb2\xbb\xe4\xba\x9a"": ""\xe5\x96\xac\xe6\xb2\xbb\xe4\xba\x9e"",\n""\xe4\xbd\x90\xe6\xb2\xbb\xe4\xba\x9e"": ""\xe5\x96\xac\xe6\xb2\xbb\xe4\xba\x9e"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe8\x8c\x85\xe5\x88\xa9\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe8\x8c\x85\xe5\x88\xa9\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe6\xb1\x82\xe6\x96\xaf"": ""\xe6\xa8\xa1\xe9\x87\x8c\xe8\xa5\xbf\xe6\x96\xaf"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe8\xa3\x98\xe6\x96\xaf"": ""\xe6\xa8\xa1\xe9\x87\x8c\xe8\xa5\xbf\xe6\x96\xaf"",\n""\xe6\xb2\x99\xe7\x89\xb9\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"": ""\xe6\xb2\x99\xe7\x83\x8f\xe5\x9c\xb0\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"",\n""\xe6\xb2\x99\xe5\x9c\xb0\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"": ""\xe6\xb2\x99\xe7\x83\x8f\xe5\x9c\xb0\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"",\n""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9a\xe5\x92\x8c\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xbb\xb4\xe9\x82\xa3"": ""\xe6\xb3\xa2\xe5\xa3\xab\xe5\xb0\xbc\xe4\xba\x9e\xe8\xb5\xab\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe7\xb4\x8d"",\n""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9e\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe9\x82\xa3"": ""\xe6\xb3\xa2\xe5\xa3\xab\xe5\xb0\xbc\xe4\xba\x9e\xe8\xb5\xab\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe7\xb4\x8d"",\n""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\xa6"": ""\xe8\xbe\x9b\xe5\xb7\xb4\xe5\xa8\x81"",\n""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\x8b"": ""\xe8\xbe\x9b\xe5\xb7\xb4\xe5\xa8\x81"",\n""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"": ""\xe5\xae\x8f\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"",\n""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"": ""\xe5\xae\x8f\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"",\n""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe8\xbe\xbe\xe5\x92\x8c\xe6\x89\x98\xe5\xb7\xb4\xe5\x93\xa5"": ""\xe5\x8d\x83\xe9\x87\x8c\xe9\x81\x94\xe6\x89\x98\xe8\xb2\x9d\xe5\x93\xa5"",\n""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe9\x81\x94\xe5\x92\x8c\xe5\xa4\x9a\xe5\xb7\xb4\xe5\x93\xa5"": ""\xe5\x8d\x83\xe9\x87\x8c\xe9\x81\x94\xe6\x89\x98\xe8\xb2\x9d\xe5\x93\xa5"",\n""\xe7\x91\x99\xe9\xb2\x81"": ""\xe8\xab\xbe\xe9\xad\xaf"",\n""\xe7\x91\x99\xe9\xad\xaf"": ""\xe8\xab\xbe\xe9\xad\xaf"",\n""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9b\xbe"": ""\xe8\x90\xac\xe9\x82\xa3\xe6\x9d\x9c"",\n""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9c\x96"": ""\xe8\x90\xac\xe9\x82\xa3\xe6\x9d\x9c"",\n""\xe6\xba\xab\xe7\xb4\x8d\xe5\x9c\x96\xe8\x90\xac"": ""\xe9\x82\xa3\xe6\x9d\x9c"",\n""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbd\x97"": ""\xe8\x91\x9b\xe6\x91\xa9"",\n""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbe\x85"": ""\xe8\x91\x9b\xe6\x91\xa9"",\n""\xe7\xa7\x91\xe7\x89\xb9\xe8\xbf\xaa\xe7\x93\xa6"": ""\xe8\xb1\xa1\xe7\x89\x99\xe6\xb5\xb7\xe5\xb2\xb8"",\n""\xe7\xaa\x81\xe5\xb0\xbc\xe6\x96\xaf"": ""\xe7\xaa\x81\xe5\xb0\xbc\xe8\xa5\xbf\xe4\xba\x9e"",\n""\xe7\xb4\xa2\xe9\xa9\xac\xe9\x87\x8c"": ""\xe7\xb4\xa2\xe9\xa6\xac\xe5\x88\xa9\xe4\xba\x9e"",\n""\xe7\xb4\xa2\xe9\xa6\xac\xe9\x87\x8c"": ""\xe7\xb4\xa2\xe9\xa6\xac\xe5\x88\xa9\xe4\xba\x9e"",\n""\xe8\x80\x81\xe6\x8c\x9d"": ""\xe5\xaf\xae\xe5\x9c\x8b"",\n""\xe8\x80\x81\xe6\x92\xbe"": ""\xe5\xaf\xae\xe5\x9c\x8b"",\n""\xe8\x82\xaf\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe8\x82\xaf\xe4\xba\x9e"",\n""\xe8\x82\xaf\xe9\x9b\x85"": ""\xe8\x82\xaf\xe4\xba\x9e"",\n""\xe8\x8b\x8f\xe9\x87\x8c\xe5\x8d\x97"": ""\xe8\x98\x87\xe5\x88\xa9\xe5\x8d\x97"",\n""\xe8\x8e\xab\xe6\xa1\x91\xe6\xaf\x94\xe5\x85\x8b"": ""\xe8\x8e\xab\xe4\xb8\x89\xe6\xaf\x94\xe5\x85\x8b"",\n""\xe8\x8e\xb1\xe7\xb4\xa2\xe6\x89\x98"": ""\xe8\xb3\xb4\xe7\xb4\xa2\xe6\x89\x98"",\n""\xe8\x90\x8a\xe7\xb4\xa2\xe6\x89\x98"": ""\xe8\xb3\xb4\xe7\xb4\xa2\xe6\x89\x98"",\n""\xe8\xb4\x9d\xe5\xae\x81"": ""\xe8\xb2\x9d\xe5\x8d\x97"",\n""\xe8\xb2\x9d\xe5\xaf\xa7"": ""\xe8\xb2\x9d\xe5\x8d\x97"",\n""\xe8\xb5\x9e\xe6\xaf\x94\xe4\xba\x9a"": ""\xe5\xb0\x9a\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe8\xb4\x8a\xe6\xaf\x94\xe4\xba\x9e"": ""\xe5\xb0\x9a\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"": ""\xe4\xba\x9e\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x84\xb6"",\n""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"": ""\xe4\xba\x9e\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x84\xb6"",\n""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\x94\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xbf\xe5\x9b\xbd"": ""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe5\xa4\xa7\xe5\x85\xac\xe5\x9c\x8b"",\n""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xb7\xe5\x9c\x8b"": ""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe5\xa4\xa7\xe5\x85\xac\xe5\x9c\x8b"",\n""\xe9\xa9\xac\xe5\xb0\x94\xe4\xbb\xa3\xe5\xa4\xab"": ""\xe9\xa6\xac\xe7\x88\xbe\xe5\x9c\xb0\xe5\xa4\xab"",\n""\xe9\xa6\xac\xe7\x88\xbe\xe4\xbb\xa3\xe5\xa4\xab"": ""\xe9\xa6\xac\xe7\x88\xbe\xe5\x9c\xb0\xe5\xa4\xab"",\n""\xe9\xa9\xac\xe8\x80\xb3\xe4\xbb\x96"": ""\xe9\xa6\xac\xe7\x88\xbe\xe4\xbb\x96"",\n""\xe9\xa9\xac\xe9\x87\x8c\xe5\x85\xb1\xe5\x92\x8c\xe5\x9b\xbd"": ""\xe9\xa6\xac\xe5\x88\xa9\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"",\n""\xe9\xa6\xac\xe9\x87\x8c\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"": ""\xe9\xa6\xac\xe5\x88\xa9\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"",\n""\xe6\x96\xb9\xe4\xbe\xbf\xe9\x9d\xa2"": ""\xe9\x80\x9f\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe5\xbf\xab\xe9\x80\x9f\xe9\x9d\xa2"": ""\xe9\x80\x9f\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe5\x8d\xb3\xe9\xa3\x9f\xe9\xba\xb5"": ""\xe9\x80\x9f\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe8\x96\xaf\xe4\xbb\x94"": ""\xe5\x9c\x9f\xe8\xb1\x86"",\n""\xe8\xb9\xa6\xe6\x9e\x81\xe8\xb7\xb3"": ""\xe7\xac\xa8\xe8\xb1\xac\xe8\xb7\xb3"",\n""\xe7\xbb\x91\xe7\xb4\xa7\xe8\xb7\xb3"": ""\xe7\xac\xa8\xe8\xb1\xac\xe8\xb7\xb3"",\n""\xe5\x86\xb7\xe8\x8f\x9c"": ""\xe5\x86\xb7\xe7\x9b\xa4"",\n""\xe5\x87\x89\xe8\x8f\x9c"": ""\xe5\x86\xb7\xe7\x9b\xa4"",\n""\xe5\x87\xba\xe7\xa7\x9f\xe8\xbd\xa6"": ""\xe8\xa8\x88\xe7\xa8\x8b\xe8\xbb\x8a"",\n""\xe5\x8f\xb0\xe7\x90\x83"": ""\xe6\x92\x9e\xe7\x90\x83"",\n""\xe6\xa1\x8c\xe7\x90\x83"": ""\xe6\x92\x9e\xe7\x90\x83"",\n""\xe9\x9b\xaa\xe7\xb3\x95"": ""\xe5\x86\xb0\xe6\xb7\x87\xe6\xb7\x8b"",\n""\xe5\x8d\xab\xe7\x94\x9f"": ""\xe8\xa1\x9b\xe7\x94\x9f"",\n""\xe8\xa1\x9e\xe7\x94\x9f"": ""\xe8\xa1\x9b\xe7\x94\x9f"",\n""\xe5\xb9\xb3\xe6\xb2\xbb"": ""\xe8\xb3\x93\xe5\xa3\xab"",\n""\xe5\xa5\x94\xe9\xa9\xb0"": ""\xe8\xb3\x93\xe5\xa3\xab"",\n""\xe7\xa9\x8d\xe6\x9e\xb6"": ""\xe6\x8d\xb7\xe8\xb1\xb9"",\n""\xe7\xa6\x8f\xe5\xa3\xab"": ""\xe7\xa6\x8f\xe6\x96\xaf"",\n""\xe9\x9b\xaa\xe9\x93\x81\xe9\xbe\x99"": ""\xe9\x9b\xaa\xe9\x90\xb5\xe9\xbe\x8d"",\n""\xe9\xa9\xac\xe8\x87\xaa\xe8\xbe\xbe"": ""\xe9\xa6\xac\xe8\x87\xaa\xe9\x81\x94"",\n""\xe8\x90\xac\xe4\xba\x8b\xe5\xbe\x97"": ""\xe9\xa6\xac\xe8\x87\xaa\xe9\x81\x94"",\n""\xe6\x8b\xbf\xe7\xa0\xb4\xe4\xbb\x91"": ""\xe6\x8b\xbf\xe7\xa0\xb4\xe5\xb4\x99"",\n""\xe6\x8b\xbf\xe7\xa0\xb4\xe4\xbe\x96"": ""\xe6\x8b\xbf\xe7\xa0\xb4\xe5\xb4\x99"",\n""\xe5\xb8\x83\xe4\xbb\x80"": ""\xe5\xb8\x83\xe5\xb8\x8c"",\n""\xe5\xb8\x83\xe6\xae\x8a"": ""\xe5\xb8\x83\xe5\xb8\x8c"",\n""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa1\xbf"": ""\xe6\x9f\xaf\xe6\x9e\x97\xe9\xa0\x93"",\n""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa0\x93"": ""\xe6\x9f\xaf\xe6\x9e\x97\xe9\xa0\x93"",\n""\xe4\xbe\xaf\xe8\xb5\x9b\xe5\x9b\xa0"": ""\xe6\xb5\xb7\xe7\x8f\x8a"",\n""\xe4\xbe\xaf\xe8\xb3\xbd\xe5\x9b\xa0"": ""\xe6\xb5\xb7\xe7\x8f\x8a"",\n""\xe5\x87\xa1\xe9\xab\x98"": ""\xe6\xa2\xb5\xe8\xb0\xb7"",\n""\xe7\x8b\x84\xe5\xae\x89\xe5\xa8\x9c"": ""\xe9\xbb\x9b\xe5\xae\x89\xe5\xa8\x9c"",\n""\xe6\x88\xb4\xe5\xae\x89\xe5\xa8\x9c"": ""\xe9\xbb\x9b\xe5\xae\x89\xe5\xa8\x9c"",\n""\xe8\xb5\xab\xe6\x8b\x89"": ""\xe5\xb8\x8c\xe6\x8b\x89"",\n}\n\nzh2HK = {\n""\xe6\x89\x93\xe5\x8d\xb0\xe6\x9c\xba"": ""\xe6\x89\x93\xe5\x8d\xb0\xe6\xa9\x9f"",\n""\xe5\x8d\xb0\xe8\xa1\xa8\xe6\xa9\x9f"": ""\xe6\x89\x93\xe5\x8d\xb0\xe6\xa9\x9f"",\n""\xe5\xad\x97\xe8\x8a\x82"": ""\xe4\xbd\x8d\xe5\x85\x83\xe7\xb5\x84"",\n""\xe5\xad\x97\xe7\xaf\x80"": ""\xe4\xbd\x8d\xe5\x85\x83\xe7\xb5\x84"",\n""\xe6\x89\x93\xe5\x8d\xb0"": ""\xe6\x89\x93\xe5\x8d\xb0"",\n""\xe5\x88\x97\xe5\x8d\xb0"": ""\xe6\x89\x93\xe5\x8d\xb0"",\n""\xe7\xa1\xac\xe4\xbb\xb6"": ""\xe7\xa1\xac\xe4\xbb\xb6"",\n""\xe7\xa1\xac\xe9\xab\x94"": ""\xe7\xa1\xac\xe4\xbb\xb6"",\n""\xe4\xba\x8c\xe6\x9e\x81\xe7\xae\xa1"": ""\xe4\xba\x8c\xe6\xa5\xb5\xe7\xae\xa1"",\n""\xe4\xba\x8c\xe6\xa5\xb5\xe9\xab\x94"": ""\xe4\xba\x8c\xe6\xa5\xb5\xe7\xae\xa1"",\n""\xe4\xb8\x89\xe6\x9e\x81\xe7\xae\xa1"": ""\xe4\xb8\x89\xe6\xa5\xb5\xe7\xae\xa1"",\n""\xe4\xb8\x89\xe6\xa5\xb5\xe9\xab\x94"": ""\xe4\xb8\x89\xe6\xa5\xb5\xe7\xae\xa1"",\n""\xe6\x95\xb0\xe7\xa0\x81"": ""\xe6\x95\xb8\xe7\xa2\xbc"",\n""\xe6\x95\xb8\xe4\xbd\x8d"": ""\xe6\x95\xb8\xe7\xa2\xbc"",\n""\xe8\xbd\xaf\xe4\xbb\xb6"": ""\xe8\xbb\x9f\xe4\xbb\xb6"",\n""\xe8\xbb\x9f\xe9\xab\x94"": ""\xe8\xbb\x9f\xe4\xbb\xb6"",\n""\xe7\xbd\x91\xe7\xbb\x9c"": ""\xe7\xb6\xb2\xe7\xb5\xa1"",\n""\xe7\xb6\xb2\xe8\xb7\xaf"": ""\xe7\xb6\xb2\xe7\xb5\xa1"",\n""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe8\x83\xbd"": ""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe8\x83\xbd"",\n""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe6\x85\xa7"": ""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe8\x83\xbd"",\n""\xe8\x88\xaa\xe5\xa4\xa9\xe9\xa3\x9e\xe6\x9c\xba"": ""\xe7\xa9\xbf\xe6\xa2\xad\xe6\xa9\x9f"",\n""\xe5\xa4\xaa\xe7\xa9\xba\xe6\xa2\xad"": ""\xe7\xa9\xbf\xe6\xa2\xad\xe6\xa9\x9f"",\n""\xe5\x9b\xa0\xe7\x89\xb9\xe7\xbd\x91"": ""\xe4\xba\x92\xe8\x81\xaf\xe7\xb6\xb2"",\n""\xe7\xb6\xb2\xe9\x9a\x9b\xe7\xb6\xb2\xe8\xb7\xaf"": ""\xe4\xba\x92\xe8\x81\xaf\xe7\xb6\xb2"",\n""\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xba"": ""\xe6\xa9\x9f\xe6\xa2\xb0\xe4\xba\xba"",\n""\xe6\xa9\x9f\xe5\x99\xa8\xe4\xba\xba"": ""\xe6\xa9\x9f\xe6\xa2\xb0\xe4\xba\xba"",\n""\xe7\xa7\xbb\xe5\x8a\xa8\xe7\x94\xb5\xe8\xaf\x9d"": ""\xe6\xb5\x81\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"",\n""\xe8\xa1\x8c\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"": ""\xe6\xb5\x81\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"",\n""\xe8\xb0\x83\xe5\x88\xb6\xe8\xa7\xa3\xe8\xb0\x83\xe5\x99\xa8"": ""\xe8\xaa\xbf\xe5\x88\xb6\xe8\xa7\xa3\xe8\xaa\xbf\xe5\x99\xa8"",\n""\xe6\x95\xb8\xe6\x93\x9a\xe6\xa9\x9f"": ""\xe8\xaa\xbf\xe5\x88\xb6\xe8\xa7\xa3\xe8\xaa\xbf\xe5\x99\xa8"",\n""\xe7\x9f\xad\xe4\xbf\xa1"": ""\xe7\x9f\xad\xe8\xa8\x8a"",\n""\xe7\xb0\xa1\xe8\xa8\x8a"": ""\xe7\x9f\xad\xe8\xa8\x8a"",\n""\xe4\xb9\x8d\xe5\xbe\x97"": ""\xe4\xb9\x8d\xe5\xbe\x97"",\n""\xe6\x9f\xa5\xe5\xbe\xb7"": ""\xe4\xb9\x8d\xe5\xbe\x97"",\n""\xe4\xb9\x9f\xe9\x97\xa8"": ""\xe4\xb9\x9f\xe9\x96\x80"",\n""\xe8\x91\x89\xe9\x96\x80"": ""\xe4\xb9\x9f\xe9\x96\x80"",\n""\xe4\xbc\xaf\xe5\x88\xa9\xe5\x85\xb9"": ""\xe4\xbc\xaf\xe5\x88\xa9\xe8\x8c\xb2"",\n""\xe8\xb2\x9d\xe9\x87\x8c\xe6\x96\xaf"": ""\xe4\xbc\xaf\xe5\x88\xa9\xe8\x8c\xb2"",\n""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"": ""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"",\n""\xe7\xb6\xad\xe5\xbe\xb7\xe8\xa7\x92"": ""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"",\n""\xe5\x85\x8b\xe7\xbd\x97\xe5\x9c\xb0\xe4\xba\x9a"": ""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9c\xb0\xe4\xba\x9e"",\n""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9f\x83\xe8\xa5\xbf\xe4\xba\x9e"": ""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9c\xb0\xe4\xba\x9e"",\n""\xe5\x86\x88\xe6\xaf\x94\xe4\xba\x9a"": ""\xe5\xb2\xa1\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe7\x94\x98\xe6\xaf\x94\xe4\xba\x9e"": ""\xe5\xb2\xa1\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a\xe6\xaf\x94\xe7\xbb\x8d"": ""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xb9"",\n""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xa2"": ""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xb9"",\n""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"": ""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"",\n""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe6\x96\xaf\xe7\x99\xbb"": ""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"",\n""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9a"": ""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9e"",\n""\xe8\xb3\xb4\xe6\xaf\x94\xe7\x91\x9e\xe4\xba\x9e"": ""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9e"",\n""\xe5\x8a\xa0\xe7\xba\xb3"": ""\xe5\x8a\xa0\xe7\xb4\x8d"",\n""\xe8\xbf\xa6\xe7\xb4\x8d"": ""\xe5\x8a\xa0\xe7\xb4\x8d"",\n""\xe5\x8a\xa0\xe8\x93\xac"": ""\xe5\x8a\xa0\xe8\x93\xac"",\n""\xe5\x8a\xa0\xe5\xbd\xad"": ""\xe5\x8a\xa0\xe8\x93\xac"",\n""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xba\xb3"": ""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xb4\x8d"",\n""\xe6\xb3\xa2\xe6\x9c\xad\xe9\x82\xa3"": ""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xb4\x8d"",\n""\xe5\x8d\xa1\xe5\xa1\x94\xe5\xb0\x94"": ""\xe5\x8d\xa1\xe5\xa1\x94\xe7\x88\xbe"",\n""\xe5\x8d\xa1\xe9\x81\x94"": ""\xe5\x8d\xa1\xe5\xa1\x94\xe7\x88\xbe"",\n""\xe5\x8d\xa2\xe6\x97\xba\xe8\xbe\xbe"": ""\xe7\x9b\xa7\xe6\x97\xba\xe9\x81\x94"",\n""\xe7\x9b\xa7\xe5\xae\x89\xe9\x81\x94"": ""\xe7\x9b\xa7\xe6\x97\xba\xe9\x81\x94"",\n""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa9\xac\xe6\x8b\x89"": ""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"",\n""\xe7\x93\x9c\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"": ""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"",\n""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe5\xb0\x94"": ""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe7\x88\xbe"",\n""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a"": ""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe7\x88\xbe"",\n""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9a"": ""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9e"",\n""\xe5\x8e\x84\xe5\x88\xa9\xe5\x9e\x82\xe4\xba\x9e"": ""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9e"",\n""\xe5\x90\x89\xe5\xb8\x83\xe6\x8f\x90"": ""\xe5\x90\x89\xe5\xb8\x83\xe5\xa0\xa4"",\n""\xe5\x90\x89\xe5\xb8\x83\xe5\x9c\xb0"": ""\xe5\x90\x89\xe5\xb8\x83\xe5\xa0\xa4"",\n""\xe5\x93\xa5\xe6\x96\xaf\xe8\xbe\xbe\xe9\xbb\x8e\xe5\x8a\xa0"": ""\xe5\x93\xa5\xe6\x96\xaf\xe9\x81\x94\xe9\xbb\x8e\xe5\x8a\xa0"",\n""\xe5\x93\xa5\xe6\x96\xaf\xe5\xa4\xa7\xe9\xbb\x8e\xe5\x8a\xa0"": ""\xe5\x93\xa5\xe6\x96\xaf\xe9\x81\x94\xe9\xbb\x8e\xe5\x8a\xa0"",\n""\xe5\x9b\xbe\xe7\x93\xa6\xe5\x8d\xa2"": ""\xe5\x9c\x96\xe7\x93\xa6\xe7\x9b\xa7"",\n""\xe5\x90\x90\xe7\x93\xa6\xe9\xad\xaf"": ""\xe5\x9c\x96\xe7\x93\xa6\xe7\x9b\xa7"",\n""\xe5\x9c\xa3\xe5\x8d\xa2\xe8\xa5\xbf\xe4\xba\x9a"": ""\xe8\x81\x96\xe7\x9b\xa7\xe8\xa5\xbf\xe4\xba\x9e"",\n""\xe8\x81\x96\xe9\x9c\xb2\xe8\xa5\xbf\xe4\xba\x9e"": ""\xe8\x81\x96\xe7\x9b\xa7\xe8\xa5\xbf\xe4\xba\x9e"",\n""\xe5\x9c\xa3\xe5\x9f\xba\xe8\x8c\xa8\xe5\x92\x8c\xe5\xb0\xbc\xe7\xbb\xb4\xe6\x96\xaf"": ""\xe8\x81\x96\xe5\x90\x89\xe6\x96\xaf\xe7\xb4\x8d\xe5\x9f\x9f\xe6\x96\xaf"",\n""\xe8\x81\x96\xe5\x85\x8b\xe9\x87\x8c\xe6\x96\xaf\xe5\xa4\x9a\xe7\xa6\x8f\xe5\x8f\x8a\xe5\xb0\xbc\xe7\xb6\xad\xe6\x96\xaf"": ""\xe8\x81\x96\xe5\x90\x89\xe6\x96\xaf\xe7\xb4\x8d\xe5\x9f\x9f\xe6\x96\xaf"",\n""\xe5\x9c\xa3\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe4\xb8\x81\xe6\x96\xaf"": ""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe4\xb8\x81\xe6\x96\xaf"",\n""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe5\x8f\x8a\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe4\xb8\x81"": ""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe4\xb8\x81\xe6\x96\xaf"",\n""\xe5\x9c\xa3\xe9\xa9\xac\xe5\x8a\x9b\xe8\xaf\xba"": ""\xe8\x81\x96\xe9\xa6\xac\xe5\x8a\x9b\xe8\xab\xbe"",\n""\xe8\x81\x96\xe9\xa6\xac\xe5\x88\xa9\xe8\xab\xbe"": ""\xe8\x81\x96\xe9\xa6\xac\xe5\x8a\x9b\xe8\xab\xbe"",\n""\xe5\x9c\xad\xe4\xba\x9a\xe9\x82\xa3"": ""\xe5\x9c\xad\xe4\xba\x9e\xe9\x82\xa3"",\n""\xe8\x93\x8b\xe4\xba\x9e\xe9\x82\xa3"": ""\xe5\x9c\xad\xe4\xba\x9e\xe9\x82\xa3"",\n""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe5\x9d\xa6\xe5\xb0\x9a\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9a"": ""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe8\xa1\xa3\xe7\xb4\xa2\xe5\x8c\xb9\xe4\xba\x9e"": ""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe8\xa1\xa3\xe7\xb4\xa2\xe6\xaf\x94\xe4\xba\x9e"": ""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"": ""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"",\n""\xe5\x90\x89\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"": ""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"",\n""\xe7\x8b\xae\xe5\xad\x90\xe5\xb1\xb1"": ""\xe7\x8d\x85\xe5\xad\x90\xe5\xb1\xb1"",\n""\xe5\xa1\x9e\xe6\x99\xae\xe5\x8b\x92\xe6\x96\xaf"": ""\xe5\xa1\x9e\xe6\xb5\xa6\xe8\xb7\xaf\xe6\x96\xaf"",\n""\xe5\xa1\x9e\xe8\x88\x8c\xe5\xb0\x94"": ""\xe5\xa1\x9e\xe8\x88\x8c\xe7\x88\xbe"",\n""\xe5\xa1\x9e\xe5\xb8\xad\xe7\x88\xbe"": ""\xe5\xa1\x9e\xe8\x88\x8c\xe7\x88\xbe"",\n""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0"": ""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"",\n""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0"": ""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"",\n""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\x94\xe9\x82\xa6"": ""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\xaf\xe9\x82\xa6"",\n""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x85\x8b"": ""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\xaf\xe9\x82\xa6"",\n""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe8\xbe\xbe"": ""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"",\n""\xe5\xae\x89\xe5\x9c\xb0\xe5\x8d\xa1\xe5\x8f\x8a\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"": ""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9a"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9e"",\n""\xe5\xa5\x88\xe5\x8f\x8a\xe5\x88\xa9\xe4\xba\x9e"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9e"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe5\xb0\x94"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe7\x88\xbe"",\n""\xe5\xb0\xbc\xe6\x97\xa5"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe7\x88\xbe"",\n""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"": ""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"",\n""\xe5\xb7\xb4\xe8\xb2\x9d\xe5\xa4\x9a"": ""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"",\n""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9a\xe6\x96\xb0\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a"": ""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe6\x96\xb0\xe7\x95\xbf\xe5\x85\xa7\xe4\xba\x9e"",\n""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe7\xb4\x90\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e"": ""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe6\x96\xb0\xe7\x95\xbf\xe5\x85\xa7\xe4\xba\x9e"",\n""\xe5\xb8\x83\xe5\x9f\xba\xe7\xba\xb3\xe6\xb3\x95\xe7\xb4\xa2"": ""\xe5\xb8\x83\xe5\x9f\xba\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"",\n""\xe5\xb8\x83\xe5\x90\x89\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"": ""\xe5\xb8\x83\xe5\x9f\xba\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"",\n""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"": ""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"",\n""\xe8\x92\xb2\xe9\x9a\x86\xe5\x9c\xb0"": ""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"",\n""\xe7\xbe\xa9\xe5\xa4\xa7\xe5\x88\xa9"": ""\xe6\x84\x8f\xe5\xa4\xa7\xe5\x88\xa9"",\n""\xe6\x89\x80\xe7\xbd\x97\xe9\x97\xa8\xe7\xbe\xa4\xe5\xb2\x9b"": ""\xe6\x89\x80\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"",\n""\xe7\xb4\xa2\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"": ""\xe6\x89\x80\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"",\n""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe5\x85\xb0"": ""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe8\x98\xad"",\n""\xe5\x8f\xb2\xe7\x93\xa6\xe6\xbf\x9f\xe8\x98\xad"": ""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe8\x98\xad"",\n""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe6\x96\xaf\xe6\xb4\x9b\xe7\xb6\xad\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe6\x96\xb0\xe8\xa5\xbf\xe5\x85\xb0"": ""\xe6\x96\xb0\xe8\xa5\xbf\xe8\x98\xad"",\n""\xe7\xb4\x90\xe8\xa5\xbf\xe8\x98\xad"": ""\xe6\x96\xb0\xe8\xa5\xbf\xe8\x98\xad"",\n""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe8\xbe\xbe"": ""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe9\x81\x94"",\n""\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe9\x81\x94"": ""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe9\x81\x94"",\n""\xe6\xa0\xbc\xe9\xb2\x81\xe5\x90\x89\xe4\xba\x9a"": ""\xe5\x96\xac\xe6\xb2\xbb\xe4\xba\x9e"",\n""\xe6\xa0\xbc\xe9\xad\xaf\xe5\x90\x89\xe4\xba\x9e"": ""\xe5\x96\xac\xe6\xb2\xbb\xe4\xba\x9e"",\n""\xe6\xa2\xb5\xe8\x92\x82\xe5\x86\x88"": ""\xe6\xa2\xb5\xe8\x92\x82\xe5\xb2\xa1"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe8\x8c\x85\xe5\x88\xa9\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe6\xb1\x82\xe6\x96\xaf"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe8\xa3\x98\xe6\x96\xaf"",\n""\xe6\xa8\xa1\xe9\x87\x8c\xe8\xa5\xbf\xe6\x96\xaf"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe8\xa3\x98\xe6\x96\xaf"",\n""\xe6\xb2\x99\xe7\x83\x8f\xe5\x9c\xb0\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"": ""\xe6\xb2\x99\xe7\x89\xb9\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"",\n""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9a\xe5\x92\x8c\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xbb\xb4\xe9\x82\xa3"": ""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9e\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe9\x82\xa3"",\n""\xe6\xb3\xa2\xe5\xa3\xab\xe5\xb0\xbc\xe4\xba\x9e\xe8\xb5\xab\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe7\xb4\x8d"": ""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9e\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe9\x82\xa3"",\n""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\xa6"": ""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\x8b"",\n""\xe8\xbe\x9b\xe5\xb7\xb4\xe5\xa8\x81"": ""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\x8b"",\n""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"": ""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"",\n""\xe5\xae\x8f\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"": ""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"",\n""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe8\xbe\xbe\xe5\x92\x8c\xe6\x89\x98\xe5\xb7\xb4\xe5\x93\xa5"": ""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe9\x81\x94\xe5\x92\x8c\xe5\xa4\x9a\xe5\xb7\xb4\xe5\x93\xa5"",\n""\xe5\x8d\x83\xe9\x87\x8c\xe9\x81\x94\xe6\x89\x98\xe8\xb2\x9d\xe5\x93\xa5"": ""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe9\x81\x94\xe5\x92\x8c\xe5\xa4\x9a\xe5\xb7\xb4\xe5\x93\xa5"",\n""\xe7\x91\x99\xe9\xb2\x81"": ""\xe7\x91\x99\xe9\xad\xaf"",\n""\xe8\xab\xbe\xe9\xad\xaf"": ""\xe7\x91\x99\xe9\xad\xaf"",\n""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9b\xbe"": ""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9c\x96"",\n""\xe8\x90\xac\xe9\x82\xa3\xe6\x9d\x9c"": ""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9c\x96"",\n""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbd\x97"": ""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbe\x85"",\n""\xe8\x91\x9b\xe6\x91\xa9"": ""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbe\x85"",\n""\xe7\xb4\xa2\xe9\xa9\xac\xe9\x87\x8c"": ""\xe7\xb4\xa2\xe9\xa6\xac\xe9\x87\x8c"",\n""\xe7\xb4\xa2\xe9\xa6\xac\xe5\x88\xa9\xe4\xba\x9e"": ""\xe7\xb4\xa2\xe9\xa6\xac\xe9\x87\x8c"",\n""\xe8\x80\x81\xe6\x8c\x9d"": ""\xe8\x80\x81\xe6\x92\xbe"",\n""\xe5\xaf\xae\xe5\x9c\x8b"": ""\xe8\x80\x81\xe6\x92\xbe"",\n""\xe8\x82\xaf\xe5\xb0\xbc\xe4\xba\x9a"": ""\xe8\x82\xaf\xe9\x9b\x85"",\n""\xe8\x82\xaf\xe4\xba\x9e"": ""\xe8\x82\xaf\xe9\x9b\x85"",\n""\xe8\x8e\xab\xe6\xa1\x91\xe6\xaf\x94\xe5\x85\x8b"": ""\xe8\x8e\xab\xe6\xa1\x91\xe6\xaf\x94\xe5\x85\x8b"",\n""\xe8\x8e\xab\xe4\xb8\x89\xe6\xaf\x94\xe5\x85\x8b"": ""\xe8\x8e\xab\xe6\xa1\x91\xe6\xaf\x94\xe5\x85\x8b"",\n""\xe8\x8e\xb1\xe7\xb4\xa2\xe6\x89\x98"": ""\xe8\x90\x8a\xe7\xb4\xa2\xe6\x89\x98"",\n""\xe8\xb3\xb4\xe7\xb4\xa2\xe6\x89\x98"": ""\xe8\x90\x8a\xe7\xb4\xa2\xe6\x89\x98"",\n""\xe8\xb4\x9d\xe5\xae\x81"": ""\xe8\xb2\x9d\xe5\xaf\xa7"",\n""\xe8\xb2\x9d\xe5\x8d\x97"": ""\xe8\xb2\x9d\xe5\xaf\xa7"",\n""\xe8\xb5\x9e\xe6\xaf\x94\xe4\xba\x9a"": ""\xe8\xb4\x8a\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe5\xb0\x9a\xe6\xaf\x94\xe4\xba\x9e"": ""\xe8\xb4\x8a\xe6\xaf\x94\xe4\xba\x9e"",\n""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"": ""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"",\n""\xe4\xba\x9e\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x84\xb6"": ""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"",\n""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\x94\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xbf\xe5\x9b\xbd"": ""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xb7\xe5\x9c\x8b"",\n""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe5\xa4\xa7\xe5\x85\xac\xe5\x9c\x8b"": ""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xb7\xe5\x9c\x8b"",\n""\xe9\xa9\xac\xe5\xb0\x94\xe4\xbb\xa3\xe5\xa4\xab"": ""\xe9\xa6\xac\xe7\x88\xbe\xe4\xbb\xa3\xe5\xa4\xab"",\n""\xe9\xa6\xac\xe7\x88\xbe\xe5\x9c\xb0\xe5\xa4\xab"": ""\xe9\xa6\xac\xe7\x88\xbe\xe4\xbb\xa3\xe5\xa4\xab"",\n""\xe9\xa6\xac\xe5\x88\xa9\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"": ""\xe9\xa6\xac\xe9\x87\x8c\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"",\n""\xe6\x96\xb9\xe4\xbe\xbf\xe9\x9d\xa2"": ""\xe5\x8d\xb3\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe5\xbf\xab\xe9\x80\x9f\xe9\x9d\xa2"": ""\xe5\x8d\xb3\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe9\x80\x9f\xe9\xa3\x9f\xe9\xba\xb5"": ""\xe5\x8d\xb3\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe6\xb3\xa1\xe9\xba\xb5"": ""\xe5\x8d\xb3\xe9\xa3\x9f\xe9\xba\xb5"",\n""\xe5\x9c\x9f\xe8\xb1\x86"": ""\xe9\xa6\xac\xe9\x88\xb4\xe8\x96\xaf"",\n""\xe5\x8d\x8e\xe4\xb9\x90"": ""\xe4\xb8\xad\xe6\xa8\x82"",\n""\xe6\xb0\x91\xe4\xb9\x90"": ""\xe4\xb8\xad\xe6\xa8\x82"",\n""\xe8\xa8\x88\xe7\xa8\x8b\xe8\xbb\x8a"": ""\xe7\x9a\x84\xe5\xa3\xab"",\n""\xe5\x87\xba\xe7\xa7\x9f\xe8\xbd\xa6"": ""\xe7\x9a\x84\xe5\xa3\xab"",\n""\xe5\x85\xac\xe8\xbb\x8a"": ""\xe5\xb7\xb4\xe5\xa3\xab"",\n""\xe8\x87\xaa\xe8\xa1\x8c\xe8\xbd\xa6"": ""\xe5\x96\xae\xe8\xbb\x8a"",\n""\xe7\x8a\xac\xe5\x8f\xaa"": ""\xe7\x8b\x97\xe9\x9a\xbb"",\n""\xe5\x8f\xb0\xe7\x90\x83"": ""\xe6\xa1\x8c\xe7\x90\x83"",\n""\xe6\x92\x9e\xe7\x90\x83"": ""\xe6\xa1\x8c\xe7\x90\x83"",\n""\xe5\x86\xb0\xe6\xb7\x87\xe6\xb7\x8b"": ""\xe9\x9b\xaa\xe7\xb3\x95"",\n""\xe8\xb3\x93\xe5\xa3\xab"": ""\xe5\xb9\xb3\xe6\xb2\xbb"",\n""\xe6\x8d\xb7\xe8\xb1\xb9"": ""\xe7\xa9\x8d\xe6\x9e\xb6"",\n""\xe7\xa6\x8f\xe6\x96\xaf"": ""\xe7\xa6\x8f\xe5\xa3\xab"",\n""\xe9\x9b\xaa\xe9\x93\x81\xe9\xbe\x99"": ""\xe5\x85\x88\xe9\x80\xb2"",\n""\xe9\x9b\xaa\xe9\x90\xb5\xe9\xbe\x8d"": ""\xe5\x85\x88\xe9\x80\xb2"",\n""\xe6\xb2\x83\xe5\xb0\x93\xe6\xb2\x83"": ""\xe5\xaf\x8c\xe8\xb1\xaa"",\n""\xe9\xa9\xac\xe8\x87\xaa\xe8\xbe\xbe"": ""\xe8\x90\xac\xe4\xba\x8b\xe5\xbe\x97"",\n""\xe9\xa6\xac\xe8\x87\xaa\xe9\x81\x94"": ""\xe8\x90\xac\xe4\xba\x8b\xe5\xbe\x97"",\n""\xe5\xaf\xb6\xe7\x8d\x85"": ""\xe6\xa8\x99\xe8\x87\xb4"",\n""\xe6\x8b\xbf\xe7\xa0\xb4\xe5\xb4\x99"": ""\xe6\x8b\xbf\xe7\xa0\xb4\xe4\xbe\x96"",\n""\xe5\xb8\x83\xe4\xbb\x80"": ""\xe5\xb8\x83\xe6\xae\x8a"",\n""\xe5\xb8\x83\xe5\xb8\x8c"": ""\xe5\xb8\x83\xe6\xae\x8a"",\n""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa1\xbf"": ""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa0\x93"",\n""\xe6\x9f\xaf\xe6\x9e\x97\xe9\xa0\x93"": ""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa0\x93"",\n""\xe8\x90\xa8\xe8\xbe\xbe\xe5\xa7\x86"": ""\xe8\x96\xa9\xe9\x81\x94\xe5\xa7\x86"",\n""\xe6\xb5\xb7\xe7\x8f\x8a"": ""\xe4\xbe\xaf\xe8\xb3\xbd\xe5\x9b\xa0"",\n""\xe4\xbe\xaf\xe8\xb5\x9b\xe5\x9b\xa0"": ""\xe4\xbe\xaf\xe8\xb3\xbd\xe5\x9b\xa0"",\n""\xe5\xa4\xa7\xe5\x8d\xab\xc2\xb7\xe8\xb4\x9d\xe5\x85\x8b\xe6\xb1\x89\xe5\xa7\x86"": ""\xe5\xa4\xa7\xe8\xa1\x9b\xe7\xa2\xa7\xe5\x92\xb8"",\n""\xe8\xbf\x88\xe5\x85\x8b\xe5\xb0\x94\xc2\xb7\xe6\xac\xa7\xe6\x96\x87"": ""\xe7\xb1\xb3\xe9\xab\x98\xe5\xa5\xa7\xe9\x9b\xb2"",\n""\xe7\x8f\x8d\xe5\xa6\xae\xe5\xbc\x97\xc2\xb7\xe5\x8d\xa1\xe6\x99\xae\xe9\x87\x8c\xe4\xba\x9a\xe8\x92\x82"": ""\xe5\x8d\xa1\xe4\xbd\xa9\xe9\x9b\x85\xe8\x92\x82"",\n""\xe9\xa9\xac\xe6\x8b\x89\xe7\x89\xb9\xc2\xb7\xe8\x90\xa8\xe8\x8a\xac"": ""\xe6\xb2\x99\xe8\x8a\xac"",\n""\xe8\xbf\x88\xe5\x85\x8b\xe5\xb0\x94\xc2\xb7\xe8\x88\x92\xe9\xa9\xac\xe8\xb5\xab"": ""\xe8\x88\x92\xe9\xba\xa5\xe5\x8a\xa0"",\n""\xe5\xb8\x8c\xe7\x89\xb9\xe5\x8b\x92"": ""\xe5\xb8\x8c\xe7\x89\xb9\xe6\x8b\x89"",\n""\xe7\x8b\x84\xe5\xae\x89\xe5\xa8\x9c"": ""\xe6\x88\xb4\xe5\xae\x89\xe5\xa8\x9c"",\n""\xe9\xbb\x9b\xe5\xae\x89\xe5\xa8\x9c"": ""\xe6\x88\xb4\xe5\xae\x89\xe5\xa8\x9c"",\n}\n\nzh2CN = {\n""\xe8\xa8\x98\xe6\x86\xb6\xe9\xab\x94"": ""\xe5\x86\x85\xe5\xad\x98"",\n""\xe9\xa0\x90\xe8\xa8\xad"": ""\xe9\xbb\x98\xe8\xae\xa4"",\n""\xe4\xb8\xb2\xe5\x88\x97"": ""\xe4\xb8\xb2\xe8\xa1\x8c"",\n""\xe4\xb9\x99\xe5\xa4\xaa\xe7\xb6\xb2"": ""\xe4\xbb\xa5\xe5\xa4\xaa\xe7\xbd\x91"",\n""\xe9\xbb\x9e\xe9\x99\xa3\xe5\x9c\x96"": ""\xe4\xbd\x8d\xe5\x9b\xbe"",\n""\xe5\xb8\xb8\xe5\xbc\x8f"": ""\xe4\xbe\x8b\xe7\xa8\x8b"",\n""\xe6\xb8\xb8\xe6\xa8\x99"": ""\xe5\x85\x89\xe6\xa0\x87"",\n""\xe5\x85\x89\xe7\xa2\x9f"": ""\xe5\x85\x89\xe7\x9b\x98"",\n""\xe5\x85\x89\xe7\xa2\x9f\xe6\xa9\x9f"": ""\xe5\x85\x89\xe9\xa9\xb1"",\n""\xe5\x85\xa8\xe5\xbd\xa2"": ""\xe5\x85\xa8\xe8\xa7\x92"",\n""\xe5\x85\xb1\xe7\x94\xa8"": ""\xe5\x85\xb1\xe4\xba\xab"",\n""\xe8\xbc\x89\xe5\x85\xa5"": ""\xe5\x8a\xa0\xe8\xbd\xbd"",\n""\xe5\x8d\x8a\xe5\xbd\xa2"": ""\xe5\x8d\x8a\xe8\xa7\x92"",\n""\xe8\xae\x8a\xe6\x95\xb8"": ""\xe5\x8f\x98\xe9\x87\x8f"",\n""\xe9\x9b\x9c\xe8\xa8\x8a"": ""\xe5\x99\xaa\xe5\xa3\xb0"",\n""\xe5\x9b\xa0\xe6\x95\xb8"": ""\xe5\x9b\xa0\xe5\xad\x90"",\n""\xe5\x8a\x9f\xe8\x83\xbd\xe8\xae\x8a\xe6\x95\xb8\xe5\x90\x8d\xe7\xa8\xb1"": ""\xe5\x9f\x9f\xe5\x90\x8d"",\n""\xe9\x9f\xb3\xe6\x95\x88\xe5\x8d\xa1"": ""\xe5\xa3\xb0\xe5\x8d\xa1"",\n""\xe5\xad\x97\xe5\x9e\x8b\xe5\xa4\xa7\xe5\xb0\x8f"": ""\xe5\xad\x97\xe5\x8f\xb7"",\n""\xe5\xad\x97\xe5\x9e\x8b\xe6\xaa\x94"": ""\xe5\xad\x97\xe5\xba\x93"",\n""\xe6\xac\x84\xe4\xbd\x8d"": ""\xe5\xad\x97\xe6\xae\xb5"",\n""\xe5\xad\x97\xe5\x85\x83"": ""\xe5\xad\x97\xe7\xac\xa6"",\n""\xe5\xad\x98\xe6\xaa\x94"": ""\xe5\xad\x98\xe7\x9b\x98"",\n""\xe5\xae\x9a\xe5\x9d\x80"": ""\xe5\xaf\xbb\xe5\x9d\x80"",\n""\xe7\xab\xa0\xe7\xaf\x80\xe9\x99\x84\xe8\xa8\xbb"": ""\xe5\xb0\xbe\xe6\xb3\xa8"",\n""\xe9\x9d\x9e\xe5\x90\x8c\xe6\xad\xa5"": ""\xe5\xbc\x82\xe6\xad\xa5"",\n""\xe5\x8c\xaf\xe6\xb5\x81\xe6\x8e\x92"": ""\xe6\x80\xbb\xe7\xba\xbf"",\n""\xe6\x8b\xac\xe5\xbc\xa7"": ""\xe6\x8b\xac\xe5\x8f\xb7"",\n""\xe4\xbb\x8b\xe9\x9d\xa2"": ""\xe6\x8e\xa5\xe5\x8f\xa3"",\n""\xe6\x8e\xa7\xe5\x88\xb6\xe9\xa0\x85"": ""\xe6\x8e\xa7\xe4\xbb\xb6"",\n""\xe8\xa8\xb1\xe5\x8f\xaf\xe6\xac\x8a"": ""\xe6\x9d\x83\xe9\x99\x90"",\n""\xe7\xa2\x9f\xe7\x89\x87"": ""\xe7\x9b\x98\xe7\x89\x87"",\n""\xe7\x9f\xbd\xe7\x89\x87"": ""\xe7\xa1\x85\xe7\x89\x87"",\n""\xe7\x9f\xbd\xe8\xb0\xb7"": ""\xe7\xa1\x85\xe8\xb0\xb7"",\n""\xe7\xa1\xac\xe7\xa2\x9f"": ""\xe7\xa1\xac\xe7\x9b\x98"",\n""\xe7\xa3\x81\xe7\xa2\x9f"": ""\xe7\xa3\x81\xe7\x9b\x98"",\n""\xe7\xa3\x81\xe8\xbb\x8c"": ""\xe7\xa3\x81\xe9\x81\x93"",\n""\xe7\xa8\x8b\xe5\xbc\x8f\xe6\x8e\xa7\xe5\x88\xb6"": ""\xe7\xa8\x8b\xe6\x8e\xa7"",\n""\xe9\x81\x8b\xe7\xae\x97\xe5\x85\x83"": ""\xe7\xae\x97\xe5\xad\x90"",\n""\xe6\xbc\x94\xe7\xae\x97\xe6\xb3\x95"": ""\xe7\xae\x97\xe6\xb3\x95"",\n""\xe6\x99\xb6\xe7\x89\x87"": ""\xe8\x8a\xaf\xe7\x89\x87"",\n""\xe6\x99\xb6\xe5\x85\x83"": ""\xe8\x8a\xaf\xe7\x89\x87"",\n""\xe7\x89\x87\xe8\xaa\x9e"": ""\xe8\xaf\x8d\xe7\xbb\x84"",\n""\xe8\xbb\x9f\xe7\xa2\x9f\xe6\xa9\x9f"": ""\xe8\xbd\xaf\xe9\xa9\xb1"",\n""\xe5\xbf\xab\xe9\x96\x83\xe8\xa8\x98\xe6\x86\xb6\xe9\xab\x94"": ""\xe5\xbf\xab\xe9\x97\xaa\xe5\xad\x98\xe5\x82\xa8\xe5\x99\xa8"",\n""\xe6\xbb\x91\xe9\xbc\xa0"": ""\xe9\xbc\xa0\xe6\xa0\x87"",\n""\xe9\x80\xb2\xe4\xbd\x8d"": ""\xe8\xbf\x9b\xe5\x88\xb6"",\n""\xe4\xba\x92\xe5\x8b\x95\xe5\xbc\x8f"": ""\xe4\xba\xa4\xe4\xba\x92\xe5\xbc\x8f"",\n""\xe5\x84\xaa\xe5\x85\x88\xe9\xa0\x86\xe5\xba\x8f"": ""\xe4\xbc\x98\xe5\x85\x88\xe7\xba\xa7"",\n""\xe6\x84\x9f\xe6\xb8\xac"": ""\xe4\xbc\xa0\xe6\x84\x9f"",\n""\xe6\x94\x9c\xe5\xb8\xb6\xe5\x9e\x8b"": ""\xe4\xbe\xbf\xe6\x90\xba\xe5\xbc\x8f"",\n""\xe8\xb3\x87\xe8\xa8\x8a\xe7\x90\x86\xe8\xab\x96"": ""\xe4\xbf\xa1\xe6\x81\xaf\xe8\xae\xba"",\n""\xe8\xbf\xb4\xe5\x9c\x88"": ""\xe5\xbe\xaa\xe7\x8e\xaf"",\n""\xe9\x98\xb2\xe5\xaf\xab"": ""\xe5\x86\x99\xe4\xbf\x9d\xe6\x8a\xa4"",\n""\xe5\x88\x86\xe6\x95\xa3\xe5\xbc\x8f"": ""\xe5\x88\x86\xe5\xb8\x83\xe5\xbc\x8f"",\n""\xe8\xa7\xa3\xe6\x9e\x90\xe5\xba\xa6"": ""\xe5\x88\x86\xe8\xbe\xa8\xe7\x8e\x87"",\n""\xe4\xbc\xba\xe6\x9c\x8d\xe5\x99\xa8"": ""\xe6\x9c\x8d\xe5\x8a\xa1\xe5\x99\xa8"",\n""\xe7\xad\x89\xe6\x96\xbc"": ""\xe7\xad\x89\xe4\xba\x8e"",\n""\xe5\x8d\x80\xe5\x9f\x9f\xe7\xb6\xb2"": ""\xe5\xb1\x80\xe5\x9f\x9f\xe7\xbd\x91"",\n""\xe5\xb7\xa8\xe9\x9b\x86"": ""\xe5\xae\x8f"",\n""\xe6\x8e\x83\xe7\x9e\x84\xe5\x99\xa8"": ""\xe6\x89\xab\xe7\x9e\x84\xe4\xbb\xaa"",\n""\xe5\xaf\xac\xe9\xa0\xbb"": ""\xe5\xae\xbd\xe5\xb8\xa6"",\n""\xe8\xb3\x87\xe6\x96\x99\xe5\xba\xab"": ""\xe6\x95\xb0\xe6\x8d\xae\xe5\xba\x93"",\n""\xe4\xb9\xb3\xe9\x85\xaa"": ""\xe5\xa5\xb6\xe9\x85\xaa"",\n""\xe9\x89\x85\xe8\xb3\x88"": ""\xe5\xb7\xa8\xe5\x95\x86"",\n""\xe6\x89\x8b\xe9\x9b\xbb\xe7\xad\x92"": ""\xe6\x89\x8b\xe7\x94\xb5"",\n""\xe8\x90\xac\xe6\x9b\x86"": ""\xe4\xb8\x87\xe5\x8e\x86"",\n""\xe6\xb0\xb8\xe6\x9b\x86"": ""\xe6\xb0\xb8\xe5\x8e\x86"",\n""\xe8\xbe\xad\xe5\xbd\x99"": ""\xe8\xaf\x8d\xe6\xb1\x87"",\n""\xe6\xaf\x8d\xe9\x9f\xb3"": ""\xe5\x85\x83\xe9\x9f\xb3"",\n""\xe8\x87\xaa\xe7\x94\xb1\xe7\x90\x83"": ""\xe4\xbb\xbb\xe6\x84\x8f\xe7\x90\x83"",\n""\xe9\xa0\xad\xe6\xa7\x8c"": ""\xe5\xa4\xb4\xe7\x90\x83"",\n""\xe9\x80\xb2\xe7\x90\x83"": ""\xe5\x85\xa5\xe7\x90\x83"",\n""\xe9\xa1\x86\xe9\x80\xb2\xe7\x90\x83"": ""\xe7\xb2\x92\xe5\x85\xa5\xe7\x90\x83"",\n""\xe5\xb0\x84\xe9\x96\x80"": ""\xe6\x89\x93\xe9\x97\xa8"",\n""\xe8\x93\x8b\xe7\x81\xab\xe9\x8d\x8b"": ""\xe7\x81\xab\xe9\x94\x85\xe7\x9b\x96\xe5\xb8\xbd"",\n""\xe5\x8d\xb0\xe8\xa1\xa8\xe6\xa9\x9f"": ""\xe6\x89\x93\xe5\x8d\xb0\xe6\x9c\xba"",\n""\xe6\x89\x93\xe5\x8d\xb0\xe6\xa9\x9f"": ""\xe6\x89\x93\xe5\x8d\xb0\xe6\x9c\xba"",\n""\xe4\xbd\x8d\xe5\x85\x83\xe7\xb5\x84"": ""\xe5\xad\x97\xe8\x8a\x82"",\n""\xe5\xad\x97\xe7\xaf\x80"": ""\xe5\xad\x97\xe8\x8a\x82"",\n""\xe5\x88\x97\xe5\x8d\xb0"": ""\xe6\x89\x93\xe5\x8d\xb0"",\n""\xe6\x89\x93\xe5\x8d\xb0"": ""\xe6\x89\x93\xe5\x8d\xb0"",\n""\xe7\xa1\xac\xe9\xab\x94"": ""\xe7\xa1\xac\xe4\xbb\xb6"",\n""\xe4\xba\x8c\xe6\xa5\xb5\xe9\xab\x94"": ""\xe4\xba\x8c\xe6\x9e\x81\xe7\xae\xa1"",\n""\xe4\xba\x8c\xe6\xa5\xb5\xe7\xae\xa1"": ""\xe4\xba\x8c\xe6\x9e\x81\xe7\xae\xa1"",\n""\xe4\xb8\x89\xe6\xa5\xb5\xe9\xab\x94"": ""\xe4\xb8\x89\xe6\x9e\x81\xe7\xae\xa1"",\n""\xe4\xb8\x89\xe6\xa5\xb5\xe7\xae\xa1"": ""\xe4\xb8\x89\xe6\x9e\x81\xe7\xae\xa1"",\n""\xe6\x95\xb8\xe4\xbd\x8d"": ""\xe6\x95\xb0\xe7\xa0\x81"",\n""\xe6\x95\xb8\xe7\xa2\xbc"": ""\xe6\x95\xb0\xe7\xa0\x81"",\n""\xe8\xbb\x9f\xe9\xab\x94"": ""\xe8\xbd\xaf\xe4\xbb\xb6"",\n""\xe8\xbb\x9f\xe4\xbb\xb6"": ""\xe8\xbd\xaf\xe4\xbb\xb6"",\n""\xe7\xb6\xb2\xe8\xb7\xaf"": ""\xe7\xbd\x91\xe7\xbb\x9c"",\n""\xe7\xb6\xb2\xe7\xb5\xa1"": ""\xe7\xbd\x91\xe7\xbb\x9c"",\n""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe6\x85\xa7"": ""\xe4\xba\xba\xe5\xb7\xa5\xe6\x99\xba\xe8\x83\xbd"",\n""\xe5\xa4\xaa\xe7\xa9\xba\xe6\xa2\xad"": ""\xe8\x88\xaa\xe5\xa4\xa9\xe9\xa3\x9e\xe6\x9c\xba"",\n""\xe7\xa9\xbf\xe6\xa2\xad\xe6\xa9\x9f"": ""\xe8\x88\xaa\xe5\xa4\xa9\xe9\xa3\x9e\xe6\x9c\xba"",\n""\xe7\xb6\xb2\xe9\x9a\x9b\xe7\xb6\xb2\xe8\xb7\xaf"": ""\xe5\x9b\xa0\xe7\x89\xb9\xe7\xbd\x91"",\n""\xe4\xba\x92\xe8\x81\xaf\xe7\xb6\xb2"": ""\xe5\x9b\xa0\xe7\x89\xb9\xe7\xbd\x91"",\n""\xe6\xa9\x9f\xe6\xa2\xb0\xe4\xba\xba"": ""\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xba"",\n""\xe6\xa9\x9f\xe5\x99\xa8\xe4\xba\xba"": ""\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xba"",\n""\xe8\xa1\x8c\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"": ""\xe7\xa7\xbb\xe5\x8a\xa8\xe7\x94\xb5\xe8\xaf\x9d"",\n""\xe6\xb5\x81\xe5\x8b\x95\xe9\x9b\xbb\xe8\xa9\xb1"": ""\xe7\xa7\xbb\xe5\x8a\xa8\xe7\x94\xb5\xe8\xaf\x9d"",\n""\xe8\xaa\xbf\xe5\x88\xb6\xe8\xa7\xa3\xe8\xaa\xbf\xe5\x99\xa8"": ""\xe8\xb0\x83\xe5\x88\xb6\xe8\xa7\xa3\xe8\xb0\x83\xe5\x99\xa8"",\n""\xe6\x95\xb8\xe6\x93\x9a\xe6\xa9\x9f"": ""\xe8\xb0\x83\xe5\x88\xb6\xe8\xa7\xa3\xe8\xb0\x83\xe5\x99\xa8"",\n""\xe7\x9f\xad\xe8\xa8\x8a"": ""\xe7\x9f\xad\xe4\xbf\xa1"",\n""\xe7\xb0\xa1\xe8\xa8\x8a"": ""\xe7\x9f\xad\xe4\xbf\xa1"",\n""\xe7\x83\x8f\xe8\x8c\xb2\xe5\x88\xa5\xe5\x85\x8b"": ""\xe4\xb9\x8c\xe5\x85\xb9\xe5\x88\xab\xe5\x85\x8b\xe6\x96\xaf\xe5\x9d\xa6"",\n""\xe6\x9f\xa5\xe5\xbe\xb7"": ""\xe4\xb9\x8d\xe5\xbe\x97"",\n""\xe4\xb9\x8d\xe5\xbe\x97"": ""\xe4\xb9\x8d\xe5\xbe\x97"",\n""\xe4\xb9\x9f\xe9\x96\x80"": """",\n""\xe8\x91\x89\xe9\x96\x80"": ""\xe4\xb9\x9f\xe9\x97\xa8"",\n""\xe4\xbc\xaf\xe5\x88\xa9\xe8\x8c\xb2"": ""\xe4\xbc\xaf\xe5\x88\xa9\xe5\x85\xb9"",\n""\xe8\xb2\x9d\xe9\x87\x8c\xe6\x96\xaf"": ""\xe4\xbc\xaf\xe5\x88\xa9\xe5\x85\xb9"",\n""\xe7\xb6\xad\xe5\xbe\xb7\xe8\xa7\x92"": ""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"",\n""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"": ""\xe4\xbd\x9b\xe5\xbe\x97\xe8\xa7\x92"",\n""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9c\xb0\xe4\xba\x9e"": ""\xe5\x85\x8b\xe7\xbd\x97\xe5\x9c\xb0\xe4\xba\x9a"",\n""\xe5\x85\x8b\xe7\xbe\x85\xe5\x9f\x83\xe8\xa5\xbf\xe4\xba\x9e"": ""\xe5\x85\x8b\xe7\xbd\x97\xe5\x9c\xb0\xe4\xba\x9a"",\n""\xe5\xb2\xa1\xe6\xaf\x94\xe4\xba\x9e"": ""\xe5\x86\x88\xe6\xaf\x94\xe4\xba\x9a"",\n""\xe7\x94\x98\xe6\xaf\x94\xe4\xba\x9e"": ""\xe5\x86\x88\xe6\xaf\x94\xe4\xba\x9a"",\n""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xb9"": ""\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a\xe6\xaf\x94\xe7\xbb\x8d"",\n""\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e\xe6\xaf\x94\xe7\xb4\xa2"": ""\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a\xe6\xaf\x94\xe7\xbb\x8d"",\n""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe6\x96\xaf\xe7\x99\xbb"": ""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"",\n""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"": ""\xe5\x88\x97\xe6\x94\xaf\xe6\x95\xa6\xe5\xa3\xab\xe7\x99\xbb"",\n""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9e"": ""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9a"",\n""\xe8\xb3\xb4\xe6\xaf\x94\xe7\x91\x9e\xe4\xba\x9e"": ""\xe5\x88\xa9\xe6\xaf\x94\xe9\x87\x8c\xe4\xba\x9a"",\n""\xe5\x8a\xa0\xe7\xb4\x8d"": ""\xe5\x8a\xa0\xe7\xba\xb3"",\n""\xe8\xbf\xa6\xe7\xb4\x8d"": ""\xe5\x8a\xa0\xe7\xba\xb3"",\n""\xe5\x8a\xa0\xe5\xbd\xad"": ""\xe5\x8a\xa0\xe8\x93\xac"",\n""\xe5\x8a\xa0\xe8\x93\xac"": ""\xe5\x8a\xa0\xe8\x93\xac"",\n""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xb4\x8d"": ""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xba\xb3"",\n""\xe6\xb3\xa2\xe6\x9c\xad\xe9\x82\xa3"": ""\xe5\x8d\x9a\xe8\x8c\xa8\xe7\x93\xa6\xe7\xba\xb3"",\n""\xe5\x8d\xa1\xe5\xa1\x94\xe7\x88\xbe"": ""\xe5\x8d\xa1\xe5\xa1\x94\xe5\xb0\x94"",\n""\xe5\x8d\xa1\xe9\x81\x94"": ""\xe5\x8d\xa1\xe5\xa1\x94\xe5\xb0\x94"",\n""\xe7\x9b\xa7\xe6\x97\xba\xe9\x81\x94"": ""\xe5\x8d\xa2\xe6\x97\xba\xe8\xbe\xbe"",\n""\xe7\x9b\xa7\xe5\xae\x89\xe9\x81\x94"": ""\xe5\x8d\xa2\xe6\x97\xba\xe8\xbe\xbe"",\n""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"": ""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa9\xac\xe6\x8b\x89"",\n""\xe7\x93\x9c\xe5\x9c\xb0\xe9\xa6\xac\xe6\x8b\x89"": ""\xe5\x8d\xb1\xe5\x9c\xb0\xe9\xa9\xac\xe6\x8b\x89"",\n""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe7\x88\xbe"": ""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe5\xb0\x94"",\n""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a"": ""\xe5\x8e\x84\xe7\x93\x9c\xe5\xa4\x9a\xe5\xb0\x94"",\n""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9e"": ""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9a"",\n""\xe5\x8e\x84\xe5\x88\xa9\xe5\x9e\x82\xe4\xba\x9e"": ""\xe5\x8e\x84\xe7\xab\x8b\xe7\x89\xb9\xe9\x87\x8c\xe4\xba\x9a"",\n""\xe5\x90\x89\xe5\xb8\x83\xe5\xa0\xa4"": ""\xe5\x90\x89\xe5\xb8\x83\xe6\x8f\x90"",\n""\xe5\x90\x89\xe5\xb8\x83\xe5\x9c\xb0"": ""\xe5\x90\x89\xe5\xb8\x83\xe6\x8f\x90"",\n""\xe5\x93\x88\xe8\x96\xa9\xe5\x85\x8b"": ""\xe5\x93\x88\xe8\x90\xa8\xe5\x85\x8b\xe6\x96\xaf\xe5\x9d\xa6"",\n""\xe5\x93\xa5\xe6\x96\xaf\xe9\x81\x94\xe9\xbb\x8e\xe5\x8a\xa0"": ""\xe5\x93\xa5\xe6\x96\xaf\xe8\xbe\xbe\xe9\xbb\x8e\xe5\x8a\xa0"",\n""\xe5\x93\xa5\xe6\x96\xaf\xe5\xa4\xa7\xe9\xbb\x8e\xe5\x8a\xa0"": ""\xe5\x93\xa5\xe6\x96\xaf\xe8\xbe\xbe\xe9\xbb\x8e\xe5\x8a\xa0"",\n""\xe5\x9c\x96\xe7\x93\xa6\xe7\x9b\xa7"": ""\xe5\x9b\xbe\xe7\x93\xa6\xe5\x8d\xa2"",\n""\xe5\x90\x90\xe7\x93\xa6\xe9\xad\xaf"": ""\xe5\x9b\xbe\xe7\x93\xa6\xe5\x8d\xa2"",\n""\xe5\x9c\x9f\xe5\xba\xab\xe6\x9b\xbc"": ""\xe5\x9c\x9f\xe5\xba\x93\xe6\x9b\xbc\xe6\x96\xaf\xe5\x9d\xa6"",\n""\xe8\x81\x96\xe7\x9b\xa7\xe8\xa5\xbf\xe4\xba\x9e"": ""\xe5\x9c\xa3\xe5\x8d\xa2\xe8\xa5\xbf\xe4\xba\x9a"",\n""\xe8\x81\x96\xe9\x9c\xb2\xe8\xa5\xbf\xe4\xba\x9e"": ""\xe5\x9c\xa3\xe5\x8d\xa2\xe8\xa5\xbf\xe4\xba\x9a"",\n""\xe8\x81\x96\xe5\x90\x89\xe6\x96\xaf\xe7\xb4\x8d\xe5\x9f\x9f\xe6\x96\xaf"": ""\xe5\x9c\xa3\xe5\x9f\xba\xe8\x8c\xa8\xe5\x92\x8c\xe5\xb0\xbc\xe7\xbb\xb4\xe6\x96\xaf"",\n""\xe8\x81\x96\xe5\x85\x8b\xe9\x87\x8c\xe6\x96\xaf\xe5\xa4\x9a\xe7\xa6\x8f\xe5\x8f\x8a\xe5\xb0\xbc\xe7\xb6\xad\xe6\x96\xaf"": ""\xe5\x9c\xa3\xe5\x9f\xba\xe8\x8c\xa8\xe5\x92\x8c\xe5\xb0\xbc\xe7\xbb\xb4\xe6\x96\xaf"",\n""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe4\xb8\x81\xe6\x96\xaf"": ""\xe5\x9c\xa3\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe4\xb8\x81\xe6\x96\xaf"",\n""\xe8\x81\x96\xe6\x96\x87\xe6\xa3\xae\xe5\x8f\x8a\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe4\xb8\x81"": ""\xe5\x9c\xa3\xe6\x96\x87\xe6\xa3\xae\xe7\x89\xb9\xe5\x92\x8c\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe4\xb8\x81\xe6\x96\xaf"",\n""\xe8\x81\x96\xe9\xa6\xac\xe5\x8a\x9b\xe8\xab\xbe"": ""\xe5\x9c\xa3\xe9\xa9\xac\xe5\x8a\x9b\xe8\xaf\xba"",\n""\xe8\x81\x96\xe9\xa6\xac\xe5\x88\xa9\xe8\xab\xbe"": ""\xe5\x9c\xa3\xe9\xa9\xac\xe5\x8a\x9b\xe8\xaf\xba"",\n""\xe5\x9c\xad\xe4\xba\x9e\xe9\x82\xa3"": ""\xe5\x9c\xad\xe4\xba\x9a\xe9\x82\xa3"",\n""\xe8\x93\x8b\xe4\xba\x9e\xe9\x82\xa3"": ""\xe5\x9c\xad\xe4\xba\x9a\xe9\x82\xa3"",\n""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe5\x9d\xa6\xe5\xb0\x9a\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe5\x9d\xa6\xe6\xa1\x91\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9e"": ""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9a"",\n""\xe8\xa1\xa3\xe7\xb4\xa2\xe5\x8c\xb9\xe4\xba\x9e"": ""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9a"",\n""\xe8\xa1\xa3\xe7\xb4\xa2\xe6\xaf\x94\xe4\xba\x9e"": ""\xe5\x9f\x83\xe5\xa1\x9e\xe4\xbf\x84\xe6\xaf\x94\xe4\xba\x9a"",\n""\xe5\x90\x89\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"": ""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"",\n""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"": ""\xe5\x9f\xba\xe9\x87\x8c\xe5\xb7\xb4\xe6\x96\xaf"",\n""\xe5\xa1\x94\xe5\x90\x89\xe5\x85\x8b"": ""\xe5\xa1\x94\xe5\x90\x89\xe5\x85\x8b\xe6\x96\xaf\xe5\x9d\xa6"",\n""\xe5\xa1\x9e\xe6\x8b\x89\xe5\x88\xa9\xe6\x98\x82"": ""\xe5\xa1\x9e\xe6\x8b\x89\xe5\x88\xa9\xe6\x98\x82"",\n""\xe5\xa1\x9e\xe6\x99\xae\xe5\x8b\x92\xe6\x96\xaf"": ""\xe5\xa1\x9e\xe6\xb5\xa6\xe8\xb7\xaf\xe6\x96\xaf"",\n""\xe5\xa1\x9e\xe6\xb5\xa6\xe8\xb7\xaf\xe6\x96\xaf"": ""\xe5\xa1\x9e\xe6\xb5\xa6\xe8\xb7\xaf\xe6\x96\xaf"",\n""\xe5\xa1\x9e\xe8\x88\x8c\xe7\x88\xbe"": ""\xe5\xa1\x9e\xe8\x88\x8c\xe5\xb0\x94"",\n""\xe5\xa1\x9e\xe5\xb8\xad\xe7\x88\xbe"": ""\xe5\xa1\x9e\xe8\x88\x8c\xe5\xb0\x94"",\n""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"": ""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0"",\n""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0"": ""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0"",\n""\xe5\xa4\x9a\xe6\x98\x8e\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\xaf\xe9\x82\xa6"": ""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\x94\xe9\x82\xa6"",\n""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x85\x8b"": ""\xe5\xa4\x9a\xe7\xb1\xb3\xe5\xb0\xbc\xe5\x8a\xa0\xe8\x81\x94\xe9\x82\xa6"",\n""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"": ""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe8\xbe\xbe"",\n""\xe5\xae\x89\xe5\x9c\xb0\xe5\x8d\xa1\xe5\x8f\x8a\xe5\xb7\xb4\xe5\xb8\x83\xe9\x81\x94"": ""\xe5\xae\x89\xe6\x8f\x90\xe7\x93\x9c\xe5\x92\x8c\xe5\xb7\xb4\xe5\xb8\x83\xe8\xbe\xbe"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9e"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9a"",\n""\xe5\xa5\x88\xe5\x8f\x8a\xe5\x88\xa9\xe4\xba\x9e"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe5\x88\xa9\xe4\xba\x9a"",\n""\xe5\xb0\xbc\xe6\x97\xa5\xe7\x88\xbe"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe5\xb0\x94"",\n""\xe5\xb0\xbc\xe6\x97\xa5"": ""\xe5\xb0\xbc\xe6\x97\xa5\xe5\xb0\x94"",\n""\xe5\xb7\xb4\xe8\xb2\x9d\xe5\xa4\x9a"": ""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"",\n""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"": ""\xe5\xb7\xb4\xe5\xb7\xb4\xe5\xa4\x9a\xe6\x96\xaf"",\n""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe6\x96\xb0\xe7\x95\xbf\xe5\x85\xa7\xe4\xba\x9e"": ""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9a\xe6\x96\xb0\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a"",\n""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9e\xe7\xb4\x90\xe5\xb9\xbe\xe5\x85\xa7\xe4\xba\x9e"": ""\xe5\xb7\xb4\xe5\xb8\x83\xe4\xba\x9a\xe6\x96\xb0\xe5\x87\xa0\xe5\x86\x85\xe4\xba\x9a"",\n""\xe5\xb8\x83\xe5\x9f\xba\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"": ""\xe5\xb8\x83\xe5\x9f\xba\xe7\xba\xb3\xe6\xb3\x95\xe7\xb4\xa2"",\n""\xe5\xb8\x83\xe5\x90\x89\xe7\xb4\x8d\xe6\xb3\x95\xe7\xb4\xa2"": ""\xe5\xb8\x83\xe5\x9f\xba\xe7\xba\xb3\xe6\xb3\x95\xe7\xb4\xa2"",\n""\xe8\x92\xb2\xe9\x9a\x86\xe5\x9c\xb0"": ""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"",\n""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"": ""\xe5\xb8\x83\xe9\x9a\x86\xe8\xbf\xaa"",\n""\xe5\xb8\x8c\xe8\x87\x98"": ""\xe5\xb8\x8c\xe8\x85\x8a"",\n""\xe5\xb8\x9b\xe7\x90\x89"": ""\xe5\xb8\x95\xe5\x8a\xb3"",\n""\xe7\xbe\xa9\xe5\xa4\xa7\xe5\x88\xa9"": ""\xe6\x84\x8f\xe5\xa4\xa7\xe5\x88\xa9"",\n""\xe6\x84\x8f\xe5\xa4\xa7\xe5\x88\xa9"": ""\xe6\x84\x8f\xe5\xa4\xa7\xe5\x88\xa9"",\n""\xe6\x89\x80\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"": ""\xe6\x89\x80\xe7\xbd\x97\xe9\x97\xa8\xe7\xbe\xa4\xe5\xb2\x9b"",\n""\xe7\xb4\xa2\xe7\xbe\x85\xe9\x96\x80\xe7\xbe\xa4\xe5\xb3\xb6"": ""\xe6\x89\x80\xe7\xbd\x97\xe9\x97\xa8\xe7\xbe\xa4\xe5\xb2\x9b"",\n""\xe6\xb1\xb6\xe8\x90\x8a"": ""\xe6\x96\x87\xe8\x8e\xb1"",\n""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe8\x98\xad"": ""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe5\x85\xb0"",\n""\xe5\x8f\xb2\xe7\x93\xa6\xe6\xbf\x9f\xe8\x98\xad"": ""\xe6\x96\xaf\xe5\xa8\x81\xe5\xa3\xab\xe5\x85\xb0"",\n""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe6\x96\xaf\xe6\xb4\x9b\xe7\xb6\xad\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe6\x96\xaf\xe6\xb4\x9b\xe6\x96\x87\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe6\x96\xb0\xe8\xa5\xbf\xe8\x98\xad"": ""\xe6\x96\xb0\xe8\xa5\xbf\xe5\x85\xb0"",\n""\xe7\xb4\x90\xe8\xa5\xbf\xe8\x98\xad"": ""\xe6\x96\xb0\xe8\xa5\xbf\xe5\x85\xb0"",\n""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xb4\x8d\xe9\x81\x94"": ""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe8\xbe\xbe"",\n""\xe6\xa0\xbc\xe7\x91\x9e\xe9\x82\xa3\xe9\x81\x94"": ""\xe6\xa0\xbc\xe6\x9e\x97\xe7\xba\xb3\xe8\xbe\xbe"",\n""\xe6\xa0\xbc\xe9\xad\xaf\xe5\x90\x89\xe4\xba\x9e"": ""\xe4\xb9\x94\xe6\xb2\xbb\xe4\xba\x9a"",\n""\xe5\x96\xac\xe6\xb2\xbb\xe4\xba\x9e"": ""\xe4\xb9\x94\xe6\xb2\xbb\xe4\xba\x9a"",\n""\xe6\xa2\xb5\xe8\x92\x82\xe5\xb2\xa1"": ""\xe6\xa2\xb5\xe8\x92\x82\xe5\x86\x88"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe8\x8c\x85\xe5\x88\xa9\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9e"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe5\xa1\x94\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe6\xaf\x9b\xe9\x87\x8c\xe8\xa3\x98\xe6\x96\xaf"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe6\xb1\x82\xe6\x96\xaf"",\n""\xe6\xa8\xa1\xe9\x87\x8c\xe8\xa5\xbf\xe6\x96\xaf"": ""\xe6\xaf\x9b\xe9\x87\x8c\xe6\xb1\x82\xe6\x96\xaf"",\n""\xe6\xb2\x99\xe5\x9c\xb0\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"": ""\xe6\xb2\x99\xe7\x89\xb9\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"",\n""\xe6\xb2\x99\xe7\x83\x8f\xe5\x9c\xb0\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"": ""\xe6\xb2\x99\xe7\x89\xb9\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf"",\n""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9e\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe9\x82\xa3"": ""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9a\xe5\x92\x8c\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xbb\xb4\xe9\x82\xa3"",\n""\xe6\xb3\xa2\xe5\xa3\xab\xe5\xb0\xbc\xe4\xba\x9e\xe8\xb5\xab\xe5\xa1\x9e\xe5\x93\xa5\xe7\xb6\xad\xe7\xb4\x8d"": ""\xe6\xb3\xa2\xe6\x96\xaf\xe5\xb0\xbc\xe4\xba\x9a\xe5\x92\x8c\xe9\xbb\x91\xe5\xa1\x9e\xe5\x93\xa5\xe7\xbb\xb4\xe9\x82\xa3"",\n""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\x8b"": ""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\xa6"",\n""\xe8\xbe\x9b\xe5\xb7\xb4\xe5\xa8\x81"": ""\xe6\xb4\xa5\xe5\xb7\xb4\xe5\xb8\x83\xe9\x9f\xa6"",\n""\xe5\xae\x8f\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"": ""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"",\n""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"": ""\xe6\xb4\xaa\xe9\x83\xbd\xe6\x8b\x89\xe6\x96\xaf"",\n""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe9\x81\x94\xe5\x92\x8c\xe5\xa4\x9a\xe5\xb7\xb4\xe5\x93\xa5"": ""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe8\xbe\xbe\xe5\x92\x8c\xe6\x89\x98\xe5\xb7\xb4\xe5\x93\xa5"",\n""\xe5\x8d\x83\xe9\x87\x8c\xe9\x81\x94\xe6\x89\x98\xe8\xb2\x9d\xe5\x93\xa5"": ""\xe7\x89\xb9\xe7\xab\x8b\xe5\xb0\xbc\xe8\xbe\xbe\xe5\x92\x8c\xe6\x89\x98\xe5\xb7\xb4\xe5\x93\xa5"",\n""\xe7\x91\x99\xe9\xad\xaf"": ""\xe7\x91\x99\xe9\xb2\x81"",\n""\xe8\xab\xbe\xe9\xad\xaf"": ""\xe7\x91\x99\xe9\xb2\x81"",\n""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9c\x96"": ""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9b\xbe"",\n""\xe8\x90\xac\xe9\x82\xa3\xe6\x9d\x9c"": ""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9b\xbe"",\n""\xe6\xba\xab\xe7\xb4\x8d\xe5\x9c\x96"": ""\xe7\x93\xa6\xe5\x8a\xaa\xe9\x98\xbf\xe5\x9b\xbe"",\n""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbe\x85"": ""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbd\x97"",\n""\xe8\x91\x9b\xe6\x91\xa9"": ""\xe7\xa7\x91\xe6\x91\xa9\xe7\xbd\x97"",\n""\xe8\xb1\xa1\xe7\x89\x99\xe6\xb5\xb7\xe5\xb2\xb8"": ""\xe7\xa7\x91\xe7\x89\xb9\xe8\xbf\xaa\xe7\x93\xa6"",\n""\xe7\xaa\x81\xe5\xb0\xbc\xe8\xa5\xbf\xe4\xba\x9e"": ""\xe7\xaa\x81\xe5\xb0\xbc\xe6\x96\xaf"",\n""\xe7\xb4\xa2\xe9\xa6\xac\xe9\x87\x8c"": ""\xe7\xb4\xa2\xe9\xa9\xac\xe9\x87\x8c"",\n""\xe7\xb4\xa2\xe9\xa6\xac\xe5\x88\xa9\xe4\xba\x9e"": ""\xe7\xb4\xa2\xe9\xa9\xac\xe9\x87\x8c"",\n""\xe8\x80\x81\xe6\x92\xbe"": ""\xe8\x80\x81\xe6\x8c\x9d"",\n""\xe5\xaf\xae\xe5\x9c\x8b"": ""\xe8\x80\x81\xe6\x8c\x9d"",\n""\xe8\x82\xaf\xe9\x9b\x85"": ""\xe8\x82\xaf\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe8\x82\xaf\xe4\xba\x9e"": ""\xe8\x82\xaf\xe5\xb0\xbc\xe4\xba\x9a"",\n""\xe8\x98\x87\xe5\x88\xa9\xe5\x8d\x97"": ""\xe8\x8b\x8f\xe9\x87\x8c\xe5\x8d\x97"",\n""\xe8\x8e\xab\xe4\xb8\x89\xe6\xaf\x94\xe5\x85\x8b"": ""\xe8\x8e\xab\xe6\xa1\x91\xe6\xaf\x94\xe5\x85\x8b"",\n""\xe8\x8e\xab\xe6\xa1\x91\xe6\xaf\x94\xe5\x85\x8b"": ""\xe8\x8e\xab\xe6\xa1\x91\xe6\xaf\x94\xe5\x85\x8b"",\n""\xe8\x90\x8a\xe7\xb4\xa2\xe6\x89\x98"": ""\xe8\x8e\xb1\xe7\xb4\xa2\xe6\x89\x98"",\n""\xe8\xb3\xb4\xe7\xb4\xa2\xe6\x89\x98"": ""\xe8\x8e\xb1\xe7\xb4\xa2\xe6\x89\x98"",\n""\xe8\xb2\x9d\xe5\xaf\xa7"": ""\xe8\xb4\x9d\xe5\xae\x81"",\n""\xe8\xb2\x9d\xe5\x8d\x97"": ""\xe8\xb4\x9d\xe5\xae\x81"",\n""\xe8\xb4\x8a\xe6\xaf\x94\xe4\xba\x9e"": ""\xe8\xb5\x9e\xe6\xaf\x94\xe4\xba\x9a"",\n""\xe5\xb0\x9a\xe6\xaf\x94\xe4\xba\x9e"": ""\xe8\xb5\x9e\xe6\xaf\x94\xe4\xba\x9a"",\n""\xe4\xba\x9e\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x84\xb6"": ""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"",\n""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"": ""\xe9\x98\xbf\xe5\xa1\x9e\xe6\x8b\x9c\xe7\x96\x86"",\n""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xb7\xe5\x9c\x8b"": ""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\x94\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xbf\xe5\x9b\xbd"",\n""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\xaf\xe5\x90\x88\xe5\xa4\xa7\xe5\x85\xac\xe5\x9c\x8b"": ""\xe9\x98\xbf\xe6\x8b\x89\xe4\xbc\xaf\xe8\x81\x94\xe5\x90\x88\xe9\x85\x8b\xe9\x95\xbf\xe5\x9b\xbd"",\n""\xe5\x8d\x97\xe9\x9f\x93"": ""\xe9\x9f\xa9\xe5\x9b\xbd"",\n""\xe9\xa6\xac\xe7\x88\xbe\xe4\xbb\xa3\xe5\xa4\xab"": ""\xe9\xa9\xac\xe5\xb0\x94\xe4\xbb\xa3\xe5\xa4\xab"",\n""\xe9\xa6\xac\xe7\x88\xbe\xe5\x9c\xb0\xe5\xa4\xab"": ""\xe9\xa9\xac\xe5\xb0\x94\xe4\xbb\xa3\xe5\xa4\xab"",\n""\xe9\xa6\xac\xe7\x88\xbe\xe4\xbb\x96"": ""\xe9\xa9\xac\xe8\x80\xb3\xe4\xbb\x96"",\n""\xe9\xa6\xac\xe5\x88\xa9\xe5\x85\xb1\xe5\x92\x8c\xe5\x9c\x8b"": ""\xe9\xa9\xac\xe9\x87\x8c\xe5\x85\xb1\xe5\x92\x8c\xe5\x9b\xbd"",\n""\xe5\x8d\xb3\xe9\xa3\x9f\xe9\xba\xb5"": ""\xe6\x96\xb9\xe4\xbe\xbf\xe9\x9d\xa2"",\n""\xe5\xbf\xab\xe9\x80\x9f\xe9\x9d\xa2"": ""\xe6\x96\xb9\xe4\xbe\xbf\xe9\x9d\xa2"",\n""\xe9\x80\x9f\xe9\xa3\x9f\xe9\xba\xb5"": ""\xe6\x96\xb9\xe4\xbe\xbf\xe9\x9d\xa2"",\n""\xe6\xb3\xa1\xe9\xba\xb5"": ""\xe6\x96\xb9\xe4\xbe\xbf\xe9\x9d\xa2"",\n""\xe7\xac\xa8\xe8\xb1\xac\xe8\xb7\xb3"": ""\xe8\xb9\xa6\xe6\x9e\x81\xe8\xb7\xb3"",\n""\xe7\xbb\x91\xe7\xb4\xa7\xe8\xb7\xb3"": ""\xe8\xb9\xa6\xe6\x9e\x81\xe8\xb7\xb3"",\n""\xe5\x86\xb7\xe7\x9b\xa4"": ""\xe5\x87\x89\xe8\x8f\x9c"",\n""\xe5\x86\xb7\xe8\x8f\x9c"": ""\xe5\x87\x89\xe8\x8f\x9c"",\n""\xe6\x95\xa3\xe9\x92\xb1"": ""\xe9\x9b\xb6\xe9\x92\xb1"",\n""\xe8\xb0\x90\xe6\x98\x9f"": ""\xe7\xac\x91\xe6\x98\x9f"",\n""\xe5\xa4\x9c\xe5\xad\xa6"": ""\xe5\xa4\x9c\xe6\xa0\xa1"",\n""\xe5\x8d\x8e\xe4\xb9\x90"": ""\xe6\xb0\x91\xe4\xb9\x90"",\n""\xe4\xb8\xad\xe6\xa8\x82"": ""\xe6\xb0\x91\xe4\xb9\x90"",\n""\xe5\xb1\x8b\xe4\xbb\xb7"": ""\xe6\x88\xbf\xe4\xbb\xb7"",\n""\xe7\x9a\x84\xe5\xa3\xab"": ""\xe5\x87\xba\xe7\xa7\x9f\xe8\xbd\xa6"",\n""\xe8\xa8\x88\xe7\xa8\x8b\xe8\xbb\x8a"": ""\xe5\x87\xba\xe7\xa7\x9f\xe8\xbd\xa6"",\n""\xe5\x85\xac\xe8\xbb\x8a"": ""\xe5\x85\xac\xe5\x85\xb1\xe6\xb1\xbd\xe8\xbd\xa6"",\n""\xe5\x96\xae\xe8\xbb\x8a"": ""\xe8\x87\xaa\xe8\xa1\x8c\xe8\xbd\xa6"",\n""\xe7\xaf\x80\xe6\x85\xb6"": ""\xe8\x8a\x82\xe6\x97\xa5"",\n""\xe8\x8a\x9d\xe5\xa3\xab"": ""\xe4\xb9\xbe\xe9\x85\xaa"",\n""\xe7\x8b\x97\xe9\x9a\xbb"": ""\xe7\x8a\xac\xe5\x8f\xaa"",\n""\xe5\xa3\xab\xe5\xa4\x9a\xe5\x95\xa4\xe6\xa2\xa8"": ""\xe8\x8d\x89\xe8\x8e\x93"",\n""\xe5\xbf\x8c\xe5\xbb\x89"": ""\xe5\xa5\xb6\xe6\xb2\xb9"",\n""\xe6\xa1\x8c\xe7\x90\x83"": ""\xe5\x8f\xb0\xe7\x90\x83"",\n""\xe6\x92\x9e\xe7\x90\x83"": ""\xe5\x8f\xb0\xe7\x90\x83"",\n""\xe9\x9b\xaa\xe7\xb3\x95"": ""\xe5\x86\xb0\xe6\xb7\x87\xe6\xb7\x8b"",\n""\xe8\xa1\x9e\xe7\x94\x9f"": ""\xe5\x8d\xab\xe7\x94\x9f"",\n""\xe8\xa1\x9b\xe7\x94\x9f"": ""\xe5\x8d\xab\xe7\x94\x9f"",\n""\xe8\xb3\x93\xe5\xa3\xab"": ""\xe5\xa5\x94\xe9\xa9\xb0"",\n""\xe5\xb9\xb3\xe6\xb2\xbb"": ""\xe5\xa5\x94\xe9\xa9\xb0"",\n""\xe7\xa9\x8d\xe6\x9e\xb6"": ""\xe6\x8d\xb7\xe8\xb1\xb9"",\n""\xe7\xa6\x8f\xe6\x96\xaf"": ""\xe5\xa4\xa7\xe4\xbc\x97"",\n""\xe7\xa6\x8f\xe5\xa3\xab"": ""\xe5\xa4\xa7\xe4\xbc\x97"",\n""\xe9\x9b\xaa\xe9\x90\xb5\xe9\xbe\x8d"": ""\xe9\x9b\xaa\xe9\x93\x81\xe9\xbe\x99"",\n""\xe8\x90\xac\xe4\xba\x8b\xe5\xbe\x97"": ""\xe9\xa9\xac\xe8\x87\xaa\xe8\xbe\xbe"",\n""\xe9\xa6\xac\xe8\x87\xaa\xe9\x81\x94"": ""\xe9\xa9\xac\xe8\x87\xaa\xe8\xbe\xbe"",\n""\xe5\xaf\xb6\xe7\x8d\x85"": ""\xe6\xa0\x87\xe5\xbf\x97"",\n""\xe6\x8b\xbf\xe7\xa0\xb4\xe5\xb4\x99"": ""\xe6\x8b\xbf\xe7\xa0\xb4\xe4\xbb\x91"",\n""\xe5\xb8\x83\xe6\xae\x8a"": ""\xe5\xb8\x83\xe4\xbb\x80"",\n""\xe5\xb8\x83\xe5\xb8\x8c"": ""\xe5\xb8\x83\xe4\xbb\x80"",\n""\xe6\x9f\xaf\xe6\x9e\x97\xe9\xa0\x93"": ""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa1\xbf"",\n""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa0\x93"": ""\xe5\x85\x8b\xe6\x9e\x97\xe9\xa1\xbf"",\n""\xe8\x96\xa9\xe9\x81\x94\xe5\xa7\x86"": ""\xe8\x90\xa8\xe8\xbe\xbe\xe5\xa7\x86"",\n""\xe6\xb5\xb7\xe7\x8f\x8a"": ""\xe8\x90\xa8\xe8\xbe\xbe\xe5\xa7\x86"",\n""\xe6\xa2\xb5\xe8\xb0\xb7"": ""\xe5\x87\xa1\xe9\xab\x98"",\n""\xe5\xa4\xa7\xe8\xa1\x9b\xe7\xa2\xa7\xe5\x92\xb8"": ""\xe5\xa4\xa7\xe5\x8d\xab\xc2\xb7\xe8\xb4\x9d\xe5\x85\x8b\xe6\xb1\x89\xe5\xa7\x86"",\n""\xe7\xb1\xb3\xe9\xab\x98\xe5\xa5\xa7\xe9\x9b\xb2"": ""\xe8\xbf\x88\xe5\x85\x8b\xe5\xb0\x94\xc2\xb7\xe6\xac\xa7\xe6\x96\x87"",\n""\xe5\x8d\xa1\xe4\xbd\xa9\xe9\x9b\x85\xe8\x92\x82"": ""\xe7\x8f\x8d\xe5\xa6\xae\xe5\xbc\x97\xc2\xb7\xe5\x8d\xa1\xe6\x99\xae\xe9\x87\x8c\xe4\xba\x9a\xe8\x92\x82"",\n""\xe6\xb2\x99\xe8\x8a\xac"": ""\xe9\xa9\xac\xe6\x8b\x89\xe7\x89\xb9\xc2\xb7\xe8\x90\xa8\xe8\x8a\xac"",\n""\xe8\x88\x92\xe9\xba\xa5\xe5\x8a\xa0"": ""\xe8\xbf\x88\xe5\x85\x8b\xe5\xb0\x94\xc2\xb7\xe8\x88\x92\xe9\xa9\xac\xe8\xb5\xab"",\n""\xe5\xb8\x8c\xe7\x89\xb9\xe6\x8b\x89"": ""\xe5\xb8\x8c\xe7\x89\xb9\xe5\x8b\x92"",\n""\xe9\xbb\x9b\xe5\xae\x89\xe5\xa8\x9c"": ""\xe6\x88\xb4\xe5\xae\x89\xe5\xa8\x9c"",\n""\xe5\xb8\x8c\xe6\x8b\x89"": ""\xe8\xb5\xab\xe6\x8b\x89"",\n}\n\nzh2SG = {\n""\xe6\x96\xb9\xe4\xbe\xbf\xe9\x9d\xa2"": ""\xe5\xbf\xab\xe9\x80\x9f\xe9\x9d\xa2"",\n""\xe9\x80\x9f\xe9\xa3\x9f\xe9\xba\xb5"": ""\xe5\xbf\xab\xe9\x80\x9f\xe9\x9d\xa2"",\n""\xe5\x8d\xb3\xe9\xa3\x9f\xe9\xba\xb5"": ""\xe5\xbf\xab\xe9\x80\x9f\xe9\x9d\xa2"",\n""\xe8\xb9\xa6\xe6\x9e\x81\xe8\xb7\xb3"": ""\xe7\xbb\x91\xe7\xb4\xa7\xe8\xb7\xb3"",\n""\xe7\xac\xa8\xe8\xb1\xac\xe8\xb7\xb3"": ""\xe7\xbb\x91\xe7\xb4\xa7\xe8\xb7\xb3"",\n""\xe5\x87\x89\xe8\x8f\x9c"": ""\xe5\x86\xb7\xe8\x8f\x9c"",\n""\xe5\x86\xb7\xe7\x9b\xa4"": ""\xe5\x86\xb7\xe8\x8f\x9c"",\n""\xe9\x9b\xb6\xe9\x92\xb1"": ""\xe6\x95\xa3\xe9\x92\xb1"",\n""\xe6\x95\xa3\xe7\xb4\x99"": ""\xe6\x95\xa3\xe9\x92\xb1"",\n""\xe7\xac\x91\xe6\x98\x9f"": ""\xe8\xb0\x90\xe6\x98\x9f"",\n""\xe5\xa4\x9c\xe6\xa0\xa1"": ""\xe5\xa4\x9c\xe5\xad\xa6"",\n""\xe6\xb0\x91\xe4\xb9\x90"": ""\xe5\x8d\x8e\xe4\xb9\x90"",\n""\xe4\xbd\x8f\xe6\x88\xbf"": ""\xe4\xbd\x8f\xe5\xb1\x8b"",\n""\xe6\x88\xbf\xe4\xbb\xb7"": ""\xe5\xb1\x8b\xe4\xbb\xb7"",\n""\xe6\xb3\xa1\xe9\xba\xb5"": ""\xe5\xbf\xab\xe9\x80\x9f\xe9\x9d\xa2"",\n}\n'"
