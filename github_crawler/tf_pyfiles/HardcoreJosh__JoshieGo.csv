file_path,api_count,code
clib/setup.py,0,"b""from distutils.core import setup, Extension\r\n\r\nmodule1 = Extension('gofeat',\r\n                    sources=['gofeat.cpp'], include_dirs=['./'], \r\n                    extra_compile_args=['-std=c++11'])\r\n\r\nsetup(name='gofeat',\r\n      version='1.0',\r\n      description='go features including liberty, ladder, ko, etc.',\r\n      ext_modules=[module1])\r\n"""
clib/test.py,0,"b""import sys\nimport cv2\nsys.path.append('./build/lib.macosx-10.7-x86_64-3.6/')\nsys.path.append('/Users/joshua/Coding/go/JoshieGo/src/')\nfrom game import Board\nimport gofeat\nimport numpy as np\nimport pickle\nimport time\n\ndef py_get_liberty(matrix):\n    black_liberty = np.zeros((19, 19, 8), dtype=np.uint8)\n    white_liberty = np.zeros((19, 19, 8), dtype=np.uint8)\n    visited = {}\n    for i in range(19):\n        for j in range(19):\n            if matrix[i][j] == 1 and (i, j) not in visited:\n                groups = Board.get_group(i, j, matrix, visited=visited)\n                num_liberty = Board.check_liberty(groups, matrix, cnt=True)\n                if num_liberty > 8:\n                    num_liberty = 8\n                for stone in groups:\n                    black_liberty[stone[0]][stone[1]][num_liberty-1] = 1\n\n            if matrix[i][j] == 2 and (i, j) not in visited:\n                groups = Board.get_group(i, j, matrix, visited=visited)\n                num_liberty = Board.check_liberty(groups, matrix, cnt=True)\n                if num_liberty > 8:\n                    num_liberty = 8\n                for stone in groups:\n                    white_liberty[stone[0]][stone[1]][num_liberty-1] = 1\n\n    stones = np.concatenate((black_liberty, white_liberty), axis=2)\n    return stones\n\n\n\ngames = pickle.load(open('go_test.pkl', 'rb'))\ncnt = 0\nfor board_mtx, move in zip(games[0], games[1]):\n    cnt += 1\n    if cnt % 200 != 0:\n        continue\n    \n    mtx = board_mtx\n    tic = time.time()\n    for i in range(20):\n        py_ret_mtx = py_get_liberty(mtx)\n    toc = time.time()\n    print(toc-tic)\n\n    tic = time.time()\n    for i in range(20):\n        string = Board.mtx2str(mtx)\n        string = gofeat.get_liberty(string)\n        ret_mtx = np.fromstring(string, sep=' ', dtype=np.int).reshape(16, 19, 19).transpose(1, 2, 0)\n    toc = time.time()\n    print(toc-tic)\n    print(np.sum(py_ret_mtx - ret_mtx))\n    print(ret_mtx.shape)\n\n    # for i in range(16):\n    #     print('num', i+1)\n    #     li_b = Board(board_mtx=ret_mtx[i, :, :])\n    #     li_canvas = li_b.visualize_board(grid_size=35)\n    #     board = Board(board_mtx=board_mtx)\n    #     canvas = board.visualize_board(grid_size=35)\n    #     cv2.imshow('board', canvas)\n    #     cv2.imshow('stones', li_canvas)\n    #     cv2.waitKey()\n"""
src/MCTS.py,12,"b""import numpy as np\nfrom policy_net import PolicyNet\nfrom value_net import ValueNet\nimport tensorflow as tf\nimport time\n\n\nclass MCTS(object):\n\n    def __init__(self, policy_net_path, value_net_path, time_limit=20):\n        self.time_limit = time_limit\n        self.game = None\n        self.root = None\n        policy_model = PolicyNet('./train/', '/val/')\n        value_model = ValueNet('./train/', '/val/')\n\n        g_policy = tf.Graph()\n        with g_policy.as_default():\n            self.policy_board = tf.placeholder(dtype=tf.float32)\n            self.p_is_training = tf.placeholder(dtype=tf.bool)\n            self.policy_out = policy_model.inference(self.policy_board, is_training=self.p_is_training)\n            self.policy_loader = tf.train.Saver()\n\n            config = tf.ConfigProto()\n            config.gpu_options.allow_growth = True\n            self.policy_sess = tf.Session(config=config)\n            print('load policy model:', policy_net_path)\n            self.policy_loader.restore(self.policy_sess, policy_net_path)\n\n        g_value = tf.Graph()\n        with g_value.as_default():\n            self.value_board = tf.placeholder(dtype=tf.float32, shape=(None, 19, 19, 21))\n            self.v_is_training = tf.placeholder(dtype=tf.bool)\n            _, self.value_out = value_model.inference(self.value_board, self.v_is_training)\n            self.value_loader = tf.train.Saver()\n\n            config = tf.ConfigProto()\n            config.gpu_options.allow_growth = True\n            self.value_sess = tf.Session(config=config)\n            print('load value model:', value_net_path)\n            self.value_loader.restore(self.value_sess, value_net_path)\n\n    def set_game(self, game):\n        self.game = game\n        self.root = Node(move=game.current_moves[-1], p=None)\n\n    def eval_node(self, node, game, is_value=True, width=8):\n        board_mtx = game.boards[-1].board_mtx\n        if is_value:\n\n            t0 = time.time()\n            value_query = ValueNet.preprocess_board(board_mtx, {'next_to_play': game.next_to_play,\n                                                                'ko_state:': game.ko_state[-1],\n                                                                'current_move': game.current_moves[-1]},\n                                                    random=False, contain_liberty=True)\n            value_query = np.asarray([value_query], dtype=np.float32)\n            t1 = time.time()\n            black_win_rate, = self.value_sess.run([self.value_out], feed_dict={self.value_board: value_query,\n                                                                               self.v_is_training: False})\n\n            black_win_rate = black_win_rate.reshape((1, ))[0]\n            t2 = time.time()\n            print('TIME', t1-t0, t2-t1)\n\n            node.black_win_rate = black_win_rate\n\n        else:\n            label_y = {'next_to_play': game.next_to_play, 'ko_state:': game.ko_state[-1],\n                       'current_move': game.current_moves[-1]}\n            policy_query = PolicyNet.preprocess_board(board_mtx, label_y,\n                                                      random=False, contain_liberty=True)\n            policy_query = np.asarray([policy_query], dtype=np.float32)\n\n            p, = self.policy_sess.run(self.policy_out, feed_dict={self.policy_board:policy_query, self.p_is_training: False})\n            probs = np.reshape(p, (19, 19))\n            probs -= np.max(probs)\n            probs = np.exp(probs) / np.sum(np.exp(probs))\n\n            ids = np.dstack(np.unravel_index(np.argsort(probs.ravel()), (19, 19)))[0]\n            ids = ids[::-1][:width, :]\n            moves = [([move[0], move[1]], probs[move[0]][move[1]]) for move in ids]\n            node.moves = [move for move in moves if game.legal_place(*move[0])]\n\n    def start(self):\n        cnt = 0\n        start = time.time()\n        while True:\n            cnt += 1\n            print('prob No.', cnt)\n            self.prob()\n            print(time.time() - start)\n            for child in self.root.children:\n                print('b_win_rate / prior / visit_cnt / move:',\n                      child.black_win_rate, child.p, child.visit_cnt, child.last_move)\n            if time.time() - start > self.time_limit:\n                self.root.children.sort(key=lambda c: -c.visit_cnt)\n                for child in self.root.children:\n                    print(child.visit_cnt, child.last_move)\n                return self.root.children[0].last_move[0]\n\n    def prob(self, expand_limit=1):\n        path = [self.root]\n        self.root.black_win_rate = -1\n\n        value = -1\n        for node in path:\n            if not node.is_leaf:\n                next_node = self.select(self.game, node)\n                path.append(next_node)\n                self.game.mk_move(next_node.last_move[0][0], next_node.last_move[0][1])\n            else:\n                value = node.black_win_rate\n                if node.visit_cnt > expand_limit:\n                    self.expand(self.game, node)\n                    for child in node.children:\n                        self.evaluate(self.game, child)\n                    node.is_leaf = False\n        print('length of path of this prob:', len(path))\n        self.backup(path, value)\n        while len(path) != 1:\n            self.game.roll_back()\n            path.pop()\n\n    def select(self, game, node):  # A node has to be expanded before selected\n        if game.next_to_play == 1:\n            node.children.sort(key=lambda child: child.black_win_rate + child.p / (1 + child.visit_cnt))\n        else:\n            node.children.sort(key=lambda child: -child.black_win_rate + child.p / (1 + child.visit_cnt))\n        return node.children[-1]\n\n    def expand(self, game, node):  # A node has to be evaluated before expanded\n        if node.next_moves is None:\n            self.eval_node(node, game, is_value=False)\n\n        for move in node.moves:\n            child = Node(move, p=move[1])\n            node.children.append(child)\n\n    def evaluate(self, game, node):\n        if node.black_win_rate is None:\n            game.mk_move(node.last_move[0][0], node.last_move[0][1])\n            self.eval_node(node, game, is_value=True)\n            game.roll_back()\n        return node.black_win_rate\n\n    def backup(self, path, value):\n        print('len of path', len(path))\n        for node in path:\n            node.visit_cnt += 1\n            num = node.visit_cnt\n            node.black_win_rate = (float(num-1) * node.black_win_rate + value) / num\n\n\nclass Node(object):\n\n    def __init__(self, move, p):\n        self.last_move = move\n        self.next_moves = None\n        self.children = []\n        self.black_win_rate = None\n        self.p = p\n        self.is_leaf = True\n        self.visit_cnt = 0\n\n\nif __name__ == '__main__':\n    import pickle\n    from game import Game\n\n    search = MCTS(\n        policy_net_path='./trained_models/policy',\n        value_net_path='./trained_models/value')\n\n    test_game = Game()\n    search.set_game(test_game)\n\n    for i in range(100):\n        search.set_game(test_game)\n        search.start()\n\n\n\n\n"""
src/SGFparser.py,0,"b""import glob\nimport cv2\nimport pickle\nfrom game import Board, Game\n\n\nclass SGFParser(object):\n\n    def __init__(self, f_):\n        self.bd = -1\n        self.wd = -1\n        self.f = f_\n        self.result = None\n        self.ha = False\n        self.game = Game()\n        self.pre_move = None\n        self.moves = []\n\n        self.num_moves = -1\n        self.cs = []\n\n    def valid(self):\n        return (not self.ha) and (self.result is not None) and (self.bd >= 6 and self.wd >= 6)\n\n    def parse_kgs(self):\n        for line in self.f:\n            print(line)\n            if not line.startswith(';'):\n                tokens = line.split(']')\n                for token in tokens:\n                    if token[:2] == 'BR':\n                        self.bd = int(line[3])\n                    if token[:2] == 'WR':\n                        self.wd = int(line[3])\n                    if token[:2] == 'RE':\n                        if '+' not in line or not line.split('+')[1].startswith('Time'):\n                            self.result = line[3]\n                    if token[:2] == 'HA':\n                        self.ha = True\n            else:\n                if not self.valid():\n                    return\n                tokens = [token for token in line.split(';') if 5 <= len(token) <= 6 and token[2] != ']']\n                for token in tokens:\n                    self.moves.append(token)\n\n    def parse_aya(self):\n        for line in self.f:\n            if line[0] == '(':\n                self.num_moves = int(line.split(',')[1])\n            if line[0] == ';' and line[3] != 't':\n                tokens = [token for token in line.split(';') if len(token) > 1]\n                for token in tokens:\n                    self.moves.append(token[:5])\n                    win_rate = token.split('C')\n                    if len(win_rate) > 1:\n                        rate, cnt = float(win_rate[1].split(',')[0][1:]), int(win_rate[1].split(',')[1][:-2])\n                        self.cs.append((rate, cnt))\n                    else:\n                        self.cs.append((-1, -1))\n\n    def add_data(self, x_list, y_list):\n        last = -1\n        for i, move in enumerate(self.moves[:-1]):\n            self.game.mk_move(*Board.letter2num(move))\n\n            if self.cs[i][1] > 2500 and i < self.num_moves and i-last > 30 or \\\n               self.cs[i][1] > 2000 and i < 50 and i-last > 30:\n                    board_mtx = self.game.boards[-1].board_mtx\n                    label = {'current_move': Board.letter2num(move),\n                             'next_move': Board.letter2num(self.moves[i+1]),\n                             'next_to_play': self.game.next_to_play,\n                             'ko_state:': self.game.ko_state[-1],\n                             'result': self.cs[i][0]\n                             }\n                    x_list.append(board_mtx)\n                    y_list.append(label)\n                    last = i\n\n                    img = self.game.get_current_board_img()\n                    print(board_mtx)\n                    print(label)\n                    print(self.cs[i])\n                    cv2.imshow('img', img)\n                    cv2.waitKey()\n\n            if i >= self.num_moves:\n                return\n\nif __name__ == '__main__':\n\n    # directory = 'F:\\\\database\\\\computer-go-dataset-master\\\\KGS\\\\kgs4d-19-2008\\\\'\n    # directory = 'F:\\\\database\\\\computer-go-dataset-master\\\\KGS\\\\kgs-19-2017-02-new\\\\'\n    # dirs = glob.glob('F:\\\\database\\\\computer-go-dataset-master\\\\KGS\\\\*')\n    dirs = glob.glob('F:\\\\database\\\\computer-go-dataset-master\\\\aya_selfplay\\\\*')\n\n    x_list = []\n    y_list = []\n    prev = 0\n    cnt = 0\n    # for d in dirs:\n    #     print(d)\n    for directory in dirs:\n        print(directory)\n        names = glob.glob(directory + '\\\\*.sgf')\n        for name in names:\n            with open(name, 'r') as f:\n                sgf = SGFParser(f)\n                sgf.parse_aya()\n                sgf.add_data(x_list, y_list)\n\n            if int(len(x_list) / 10000) > prev:\n                print(len(x_list), len(y_list))\n                prev += 1\n\n            if len(x_list) > 1000000:\n            # if len(x_list) > 1000:\n                cnt += 1\n                pickle.dump((x_list, y_list), open('aya_value_ko_feat' + str(cnt).zfill(2) + '.pkl', 'wb'), protocol=2)\n                x_list = []\n                y_list = []\n                prev = 0\n\n    cnt += 1\n    pickle.dump((x_list, y_list), open('aya_value_ko_feat' + str(cnt).zfill(2) + '.pkl', 'wb'), protocol=2)\n"""
src/game.py,0,"b""import numpy as np\nimport cv2\n\n\nclass Game(object):\n    def __init__(self, grid_size=35, handicap=0):\n        if handicap == 0:\n            self.boards = [Board()]\n            self.next_to_play = 1\n        else:\n            board_mtx = np.zeros((19, 19), dtype=np.int)\n            if handicap == 2:\n                board_mtx[3][15] = 1\n                board_mtx[15][3] = 1\n            self.boards = [Board(board_mtx)]\n            self.next_to_play = 2\n        self.next_masks = [np.ones((19, 19), dtype=np.int)]\n        self.grid_size = grid_size\n        self.ko_state = [False]\n        self.current_moves = [(-1, -1)]\n\n    def add_board(self, board):\n        self.boards.append(board)\n        self.next_to_play = 3 - self.next_to_play\n\n    def legal_place(self, x=None, y=None):\n        board = self.boards[-1]\n        legal = self.next_masks[-1]\n        legal[board.board_mtx == 1] = 0\n        legal[board.board_mtx == 2] = 0\n        if x is None:\n            return legal\n        else:\n            is_suicide, groups_captured, ko_cnt, forbidden = self.test_xy(x, y)\n            if is_suicide and groups_captured == 0:\n                legal[x][y] = 0\n\n            return 0 <= x <= 18 and 0 <= y <= 18 and legal[x][y] == 1\n\n    def mk_move(self, x, y):\n        is_suicide, groups_captured, ko_cnt, forbidden = self.test_xy(x, y)\n\n        legal = self.legal_place(x, y)\n        # if is_suicide and groups_captured == 0:\n        #     legal[x][y] = 0\n        # if 0 <= x <= 18 and 0 <= y <= 18 and legal[x][y] == 1:\n        if legal:\n            if is_suicide and ko_cnt == 1:\n                self.ko_state.append(True)\n            else:\n                self.ko_state.append(False)\n            self.current_moves.append((x, y))\n            mtx = self.boards[-1].board_mtx.copy()\n            new_board = Board(mtx)\n            new_board.add_move(move=None, x=x, y=y, move_color=self.next_to_play)\n            self.add_board(new_board)\n\n            # update next_masks\n            self.next_masks.append(np.ones((19, 19), dtype=np.int))\n            if is_suicide and ko_cnt == 1:\n                self.next_masks[-1][forbidden[0]][forbidden[1]] = 0\n        else:\n            return\n\n    def test_xy(self, x, y):\n        board_mtx = self.boards[-1].board_mtx.copy()\n        board_mtx[x][y] = self.next_to_play\n        stones = Board.get_group(x, y, board_mtx)\n        forbidden = None\n        is_suicide = not Board.check_liberty(stones, board_mtx)  # does this move makes stones have no liberties\n        groups_captured = 0  # if it is suicide, how many groups of enemy stones are captured\n        ko_cnt = 0  # if it is suicide and our group size is 1, how many enemy groups of len == 1 are captured\n\n        neighbors = Board.neighbor(x, y)\n        if is_suicide:\n            for pos in neighbors:\n                if board_mtx[pos[0]][pos[1]] == 3 - self.next_to_play:\n                    nei_group = Board.get_group(pos[0], pos[1], board_mtx)\n                    if not Board.check_liberty(nei_group, board_mtx):\n                        groups_captured += 1\n                        if len(stones) == 1 and len(nei_group) == 1:\n                            ko_cnt += 1\n                            forbidden = nei_group[0]\n        return is_suicide, groups_captured, ko_cnt, forbidden\n\n    def cap_click(self, event, x, y, flags, param):\n        if event == cv2.EVENT_LBUTTONDOWN:\n            xx, yy = int(round(float(x)/self.grid_size))-1, int(round(float(y)/self.grid_size))-1\n            self.mk_move(xx, yy)\n            if 'MCTS' in param:\n                param['MCTS'] = False\n\n        if event == cv2.EVENT_RBUTTONDOWN:\n            if len(self.boards) >= 2:\n                self.roll_back()\n\n        if event == cv2.EVENT_MBUTTONDOWN:\n            xx, yy = int(round(float(x)/self.grid_size))-1, int(round(float(y)/self.grid_size))-1\n            self.mk_move(xx, yy)\n            if 'MCTS' in param:\n                param['MCTS'] = True\n\n    def get_current_board_img(self, choices=None, last_move=None):\n        return self.boards[-1].visualize_board(grid_size=self.grid_size, choices=choices, last_move=last_move)\n\n    def roll_back(self):\n        self.boards.pop()\n        self.next_masks.pop()\n        self.ko_state.pop()\n        self.current_moves.pop()\n        self.next_to_play = 3 - self.next_to_play\n\n\nclass Board(object):\n\n    def __init__(self, board_mtx=None):\n        if board_mtx is None:\n            self.board_mtx = np.zeros((19, 19)).astype(np.uint8)\n        else:\n            self.board_mtx = board_mtx\n\n    def visualize_board(self, grid_size=40, line_thickness=2, choices=None, last_move=None):\n        canvas = np.ones((grid_size*20, grid_size*20, 3), dtype=np.uint8) * 100\n\n        for x in range(1, 20):\n            cv2.line(canvas, (x*grid_size, grid_size), (x*grid_size, 19*grid_size), (0, 0, 0), line_thickness)\n            cv2.line(canvas, (grid_size, x*grid_size), (19*grid_size, x*grid_size), (0, 0, 0), line_thickness)\n\n        for x in range(3):\n            for y in range(3):\n                cv2.circle(canvas, (4*grid_size+6*x*grid_size, 4*grid_size+6*y*grid_size), int(grid_size/9), color=(0, 0, 0), thickness=int(grid_size/10))\n\n        for x in range(19):\n            for y in range(19):\n                if self.board_mtx[x][y] == 1:\n                    cv2.circle(canvas, ((x+1)*grid_size, (y+1)*grid_size), int(grid_size/2.2), color=(0, 0, 0), thickness=-1)\n                if self.board_mtx[x][y] == 2:\n                    cv2.circle(canvas, ((x+1)*grid_size, (y+1)*grid_size), int(grid_size/2.2), color=(200, 200, 200), thickness=-1)\n\n        if choices is not None:\n            letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']\n            for move, letter in zip(choices, letters):\n                x, y, prob = move[0][0], move[0][1], move[1]\n                cv2.putText(canvas, letter, (int((x+0.65)*grid_size), int((y+1.4)*grid_size)),\n                            cv2.FONT_HERSHEY_SIMPLEX, 1.5, (0, 0, 0), thickness=3)\n\n        if last_move is not None and 0 <= last_move[0] <=18 and 0 <= last_move[1] <= 18:\n            x, y = last_move[0], last_move[1]\n            if self.board_mtx[x][y] == 1:\n                cv2.circle(canvas, ((x+1)*grid_size, (y+1)*grid_size), int(grid_size/3), color=(200, 200, 200), thickness=2)\n            if self.board_mtx[x][y] == 2:\n                cv2.circle(canvas, ((x+1)*grid_size, (y+1)*grid_size), int(grid_size/3), color=(0, 0, 0), thickness=2)\n\n        return canvas\n\n    def add_move(self, move, x=None, y=None, move_color=None):\n        if x is None:\n            x, y = Board.letter2num(move)\n            if move[0] == 'B':\n                self.board_mtx[x][y] = 1\n                move_color = 1\n            else:\n                self.board_mtx[x][y] = 2\n                move_color = 2\n        else:\n            self.board_mtx[x][y] = move_color\n\n        for cross in Board.neighbor(x, y):\n            cross_color = self.board_mtx[cross[0]][cross[1]]\n            if cross_color != 0 and cross_color != move_color:\n                stones = Board.get_group(cross[0], cross[1], self.board_mtx)\n                if not Board.check_liberty(stones, self.board_mtx):\n                    for pos in stones:\n                        self.board_mtx[pos[0]][pos[1]] = 0\n\n    @staticmethod\n    def mtx2str(mtx):\n        string = np.array2string(mtx)\n        string = string.replace('[', ' ')\n        string = string.replace(']', ' ')\n        return string\n\n    @staticmethod\n    def str2mtx(string):\n        return np.fromstring(string, dtype=int, sep=' ').reshape((19, 19))\n\n    @staticmethod\n    def get_group(x, y, board_mtx, visited=None):\n        stones = list()\n        color = board_mtx[x][y]\n        stones.append((x, y))\n        is_visited = np.zeros((19, 19), dtype=np.uint8)\n        is_visited[x][y] = 1\n\n        for stone in stones:\n            for pos in Board.neighbor(*stone):\n                if color == board_mtx[pos[0]][pos[1]] and is_visited[pos[0]][pos[1]] == 0:\n                    stones.append(pos)\n                    is_visited[pos[0]][pos[1]] = 1\n                    if visited is not None:\n                        visited[pos] = 1\n        return stones\n\n    @staticmethod\n    def check_liberty(stone_pos_list, board_mtx, cnt=False):\n        if not cnt:\n            for pos in stone_pos_list:\n                for cross in Board.neighbor(*pos):\n                    if board_mtx[cross[0]][cross[1]] == 0:\n                        return True\n            return False\n        else:\n            # num_liberty = 0\n            d = {}\n            for pos in stone_pos_list:\n                for cross in Board.neighbor(*pos):\n                    if board_mtx[cross[0]][cross[1]] == 0:\n                        d[cross] = 1\n            return len(d)\n\n    @staticmethod\n    def neighbor(x, y):\n        result = []\n        if 0 <= x-1:\n            result.append((x-1, y))\n        if x+1 <= 18:\n            result.append((x+1, y))\n        if 0 <= y-1:\n            result.append((x, y-1))\n        if y+1 <= 18:\n            result.append((x, y+1))\n        return result\n\n    @staticmethod\n    def letter2num(move):\n        x = int(ord(move[2]) - ord('a'))\n        y = int(ord(move[3]) - ord('a'))\n        return x, y\n\n\nif __name__ == '__main__':\n\n    game = Game(handicap=0, grid_size=30)\n\n    # m = np.random.randint(0, 19, size=(2,), dtype=np.int)\n    # m = tuple(m)\n    # for num in range(100):\n    #     for i in range(10000):\n    #         game.mk_move(*m)\n    #         if i % 300 == 0:\n    #             game = Game()\n    #     print(num)\n\n    board_img = game.get_current_board_img()\n    cv2.imshow('board_img', board_img)\n    cv2.setMouseCallback('board_img', game.cap_click)\n    while True:\n        board_img = game.get_current_board_img()\n        cv2.imshow('board_img', board_img)\n        cv2.waitKey(33)\n"""
src/input.py,0,"b""import pickle as cPickle\nimport numpy as np\nimport glob\n\n\nclass InputData(object):\n\n    def __init__(self, directory, batch_size=128, wildcard=None):\n        self._directory = directory\n        self._batch_size = batch_size\n        self._wildcard = wildcard\n        self._subset_file_names = self._fetch_pkl_filename()\n        self._X = None\n        self._label = None\n        self._rand_idx = None\n        self._is_load = False\n        self._within_subset_cursor = 0\n        self._subset_counter = 0\n        self.epoch = 0\n\n    def _fetch_pkl_filename(self):\n        if self._wildcard is None:\n            return glob.glob(self._directory + '*.pkl')\n        else:\n            return glob.glob(self._wildcard)\n\n    def load(self, subset_counter=0):\n        print(self._subset_file_names)\n\n        print('From data_io.input.load: loading from file', self._subset_file_names[subset_counter])\n        self._X, self._label = cPickle.load(open(self._subset_file_names[subset_counter], 'rb'))\n        self._X = np.asarray(self._X)\n        self._label = np.asarray(self._label)\n        self._rand_idx = np.arange(self._X.shape[0])\n        np.random.shuffle(self._rand_idx)\n        self._is_load = True\n\n    def next_batch(self):\n        if not self._is_load or self._within_subset_cursor >= len(self._rand_idx):\n            if self._subset_counter == 0:\n                self.epoch += 1\n            try:\n                self.load(self._subset_counter)\n            except (IOError, KeyError) as e:\n                if self._subset_counter < len(self._subset_file_names) - 1:\n                    self._subset_counter += 1\n                else:\n                    self._subset_counter = 0\n                print('IOError or KeyError')\n                return [], []\n\n            self._within_subset_cursor = 0\n            if self._subset_counter < len(self._subset_file_names) - 1:\n                self._subset_counter += 1\n            else:\n                self._subset_counter = 0\n\n        idx = self._rand_idx[self._within_subset_cursor: self._within_subset_cursor + self._batch_size]\n        self._within_subset_cursor += self._batch_size\n        X_batch = self._X[idx]\n        y_batch = self._label[idx]\n\n        return X_batch, y_batch\n\n\n\n\n"""
src/play.py,0,"b'from game import Game, Board\nimport socket\nfrom MCTS import MCTS\n\n\nHANDICAP = 0\nPORT = 6667\nHOST = \'10.180.47.12\'\n# HOST = \'127.0.0.1\'\n\n\nclass GamePlay(object):\n    def __init__(self, policy_net_path, value_net_path):\n        self.mcts = MCTS(policy_net_path, value_net_path, time_limit=20)\n\n    def play(self, game):\n        self.mcts.set_game(game)\n        return self.mcts.start()\n\n\ndef client():\n    s = socket.socket()\n    host = HOST\n    print(\'connecting to \' + host)\n    port = PORT\n    s.connect((host, port))\n    game_play = GamePlay(\n                         policy_net_path=\'../trained_models/policy\',\n                         value_net_path=\'../trained_models/value\')\n\n    game = Game(handicap=HANDICAP)\n    while True:\n        message = s.recv(4096)\n        message = message.decode(\'utf-8\')\n        print(type(message), message)\n        # board_mtx, next_to_move = message.split(\'|\')\n        move, next_to_move, current_board, is_search = message.split(\'|\')\n        print(move, next_to_move, current_board, is_search)\n        if int(is_search) == 1:\n            game_play.mcts.time_limit = 20\n        else:\n            game_play.mcts.time_limit = 0.5\n        while Board.mtx2str(game.boards[-1].board_mtx) != current_board:\n            print(\'roll_back\')\n            game.roll_back()\n        print(len(game.boards))\n        moves = move.split(\',\')\n        x, y = int(moves[0][1:]), int(moves[1][1:-1])\n        game.mk_move(x, y)\n\n        output = game_play.play(game)\n        game.mk_move(output[0], output[1])\n        s.send(bytes(str(output), encoding=\'utf-8\'))\n        # s.send(str(output))\n\n    s.close()\n\n\ndef server():\n    import cv2\n    s = socket.socket()\n    host = socket.gethostname()\n    print(host)\n    print(socket.gethostbyname(socket.gethostname()))\n    host = HOST\n    port = PORT\n    s.bind((host, port))\n\n    s.listen(5)\n    while True:\n        print(\'listening...\')\n        game = Game(handicap=HANDICAP)\n        board_img = game.get_current_board_img()\n        cv2.imshow(\'board_img\', board_img)\n        param = {\'MCTS\': False}\n        cv2.setMouseCallback(\'board_img\', game.cap_click, param=param)\n        cv2.waitKey(33)\n        c, addr = s.accept()\n        print(\'Got connection from\', addr)\n\n        while True:\n            before_len = len(game.boards)\n            board_img = game.get_current_board_img(last_move=game.current_moves[-1])\n            cv2.imshow(\'board_img\', board_img)\n            cv2.waitKey(33)\n            now_len = len(game.boards)\n            if now_len > before_len:\n                print(param[\'MCTS\'])\n                board_img = game.get_current_board_img(last_move=game.current_moves[-1])\n                cv2.imshow(\'board_img\', board_img)\n                cv2.waitKey(33)\n                latest_board = game.boards[-2]  # board before human move\n                next_to_play = game.next_to_play\n                board_str = Board.mtx2str(latest_board.board_mtx)\n                next_to_play = str(next_to_play)\n\n                print(\'next_to_play:\', next_to_play)\n                c.send(str.encode(str(game.current_moves[-1]) + \'|\' + next_to_play + \'|\' + board_str + \'|\'\n                                  + str(int(param[\'MCTS\']))))\n                print(str(game.current_moves[-1]))\n\n                move = c.recv(1024).decode(\'utf-8\')\n                print(\'move\', move)\n                temp = move.split(\',\')\n                x, y = int(temp[0][1:]), int(temp[1][1:-1])\n                print(x, y, game.next_to_play)\n                game.mk_move(x, y)\n\n        c.close()\n\nif __name__ == \'__main__\':\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument(""--is_server"")\n    args = parser.parse_args()\n\n    if args.is_server:\n        server()\n    else:\n        client()\n'"
src/policy_net.py,34,"b""import tensorflow as tf\nimport numpy as np\nfrom input import InputData\nfrom game import Board\n\n\nclass PolicyNet(object):\n    def __init__(self, train_data_path, validate_data_path):\n        self.train_data = InputData(train_data_path, batch_size=128)\n        self.validate_data = validate_data_path\n\n    def conv(self, feature_map, filters_in, filters_out, k_size, scope, padding='SAME', dilation_rate=1, is_activation=True):\n        with tf.variable_scope(scope) as scope2:\n            kernel = tf.get_variable('kernel', shape=[k_size, k_size, filters_in, filters_out],\n                                     initializer=tf.contrib.layers.xavier_initializer())\n            bias = tf.get_variable('b', shape=[filters_out], initializer=tf.contrib.layers.xavier_initializer())\n            out = tf.nn.convolution(feature_map, kernel, padding, dilation_rate=[dilation_rate, dilation_rate],\n                                    name='conv') + bias\n            if is_activation:\n                out = tf.nn.relu(out, name='out')\n            return out\n\n    def batch_norm(self, x, is_training, name):\n        with tf.variable_scope(name):\n            beta = tf.Variable(tf.constant(0.0, shape=[x.shape[-1]]), name='beta', trainable=True)\n            gamma = tf.Variable(tf.constant(1.0, shape=[x.shape[-1]]), name='gamma', trainable=True)\n            axises = np.arange(len(x.shape) - 1)\n            batch_mean, batch_var = tf.nn.moments(x, axises, name='moments')\n            ema = tf.train.ExponentialMovingAverage(decay=0.5)\n\n            def mean_var_with_update():\n                ema_apply_op = ema.apply([batch_mean, batch_var])\n                with tf.control_dependencies([ema_apply_op]):\n                    return tf.identity(batch_mean), tf.identity(batch_var)\n\n            mean, var = tf.cond(is_training, mean_var_with_update,\n                                lambda: (ema.average(batch_mean), ema.average(batch_var)))\n            normed = tf.nn.batch_normalization(x, mean, var, beta, gamma, 1e-3)\n        return normed\n\n    def residual_block(self, feat_map, num_in, num_out, scope_name, is_training, dilation_rate=(1, 1)):\n        with tf.variable_scope(scope_name):\n            bottleneck = self.conv(feat_map, num_in, num_out, k_size=3, scope='c1', dilation_rate=dilation_rate[0],\n                                   is_activation=False)\n            bottleneck = self.batch_norm(bottleneck, is_training=is_training, name='bn1')\n            bottleneck = tf.nn.relu(bottleneck)\n\n            bottleneck = self.conv(bottleneck, num_out, num_out, k_size=3, scope='c2', dilation_rate=dilation_rate[1],\n                                   is_activation=False)\n            bottleneck = self.batch_norm(bottleneck, is_training=is_training, name='bn2')\n            out = tf.add(bottleneck, feat_map, name='add')\n            out = tf.nn.relu(out)\n\n        return out\n\n    def inference(self, feat_map, is_training):\n        with tf.variable_scope('net'):\n            out = self.conv(feat_map, filters_in=21, filters_out=128, k_size=3, scope='c1', padding='SAME',\n                            is_activation=False)\n            out = self.batch_norm(out, is_training=is_training, name='bn1')\n            out = tf.nn.relu(out)\n\n            out = self.residual_block(out, 128, 128, scope_name='res1', is_training=is_training)\n            out = self.residual_block(out, 128, 128, scope_name='res2', is_training=is_training)\n            out = self.residual_block(out, 128, 128, scope_name='res3', is_training=is_training,\n                                      dilation_rate=[2, 4])\n            out = self.residual_block(out, 128, 128, scope_name='res4', is_training=is_training,\n                                      dilation_rate=[8, 1])\n            out = self.residual_block(out, 128, 128, scope_name='res5', is_training=is_training)\n\n            out = self.conv(out, filters_in=128, filters_out=128, k_size=3, scope='c2', padding='SAME',\n                            is_activation=False)\n            out = self.batch_norm(out, is_training=is_training, name='bn2')\n            out = tf.nn.relu(out)\n            out = self.conv(out, filters_in=128, filters_out=1, k_size=3, scope='c3', padding='SAME',\n                            is_activation=False)\n            return out\n\n    def loss(self, logits, labels):\n        logits = tf.reshape(logits, shape=[-1, 361])\n        labels = tf.reshape(labels, shape=[-1, 361])\n        return tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=labels, logits=logits))\n\n    def train(self, learning_rate, save_path, resume_path=None):\n        model_x = tf.placeholder(dtype=tf.float32, shape=(None, 19, 19, 21))\n        model_y = tf.placeholder(dtype=tf.float32, shape=(None, 19, 19, 1))\n        is_training = tf.placeholder(dtype=tf.bool)\n\n        out = self.inference(model_x, is_training=is_training)\n        loss = self.loss(logits=out, labels=model_y)\n\n        train_op = tf.train.AdamOptimizer(learning_rate).minimize(loss)\n\n        saver = tf.train.Saver(max_to_keep=20)\n        loader = tf.train.Saver()\n        config = tf.ConfigProto()\n        config.gpu_options.allow_growth = True\n        with tf.Session(config=config) as sess:\n            if resume_path is None:\n                sess.run(tf.global_variables_initializer())\n            else:\n                print('resume:', resume_path)\n                loader.restore(sess, resume_path)\n            step = 0\n            # epoch = self.train_data.epoch + 1\n            epoch = self.train_data.epoch\n            while True:\n                step += 1\n                x, y = self.train_data.next_batch()\n                x, y = PolicyNet.pre_process(x, y)\n                if len(x) == 0:\n                    continue\n                feed_dict = {model_x: x, model_y: y, is_training: True}\n                _, loss_ = sess.run([train_op, loss], feed_dict=feed_dict)\n                print('loss:', loss_, 'step', step, 'epoch', self.train_data.epoch)\n                if self.train_data.epoch > epoch:\n                    epoch = self.train_data.epoch\n                    print('save:')\n                    saver.save(sess, save_path, global_step=epoch)\n\n    @staticmethod\n    def pre_process(x, y):\n        x = np.asarray([PolicyNet.preprocess_board(xx, yy, contain_liberty=True) for (xx, yy) in zip(x, y)], dtype=np.float32)\n        y = np.asarray([PolicyNet.preprocess_label(yy) for yy in y], dtype=np.float32)\n        return x, y\n\n    @staticmethod\n    def preprocess_board(board_mtx, y, random=True, contain_liberty=False):\n        # rand = np.random.randint(0, 2)\n        # if rand == 1:\n        #     board_mtx = board_mtx.T\n        #     y['next_to_move'] = (y['next_to_move'][1], y['next_to_move'][0])\n        #     y['current_move'] = (y['current_move'][1], y['current_move'][0])\n        if random:\n            rand = np.random.randint(0, 8)\n            if rand <= 3:\n                board_mtx = board_mtx.T\n                y['current_move'] = (y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (y['next_move'][1], y['next_move'][0])\n            i = rand % 4\n            if i == 1:\n                board_mtx = np.rot90(board_mtx)\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                # print(a[2-idx[1]][idx[0]])\n\n            if i == 2:\n                board_mtx = np.rot90(board_mtx)\n                board_mtx = np.rot90(board_mtx)\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n            if i == 3:\n                board_mtx = np.rot90(board_mtx)\n                board_mtx = np.rot90(board_mtx)\n                board_mtx = np.rot90(board_mtx)\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n\n        black_stones = np.zeros((19, 19, 1), dtype=np.uint8)\n        black_stones[board_mtx == 1] = 1\n        white_stones = np.zeros((19, 19, 1), dtype=np.uint8)\n        white_stones[board_mtx == 2] = 1\n\n        if contain_liberty:\n            black_liberty = np.zeros((19, 19, 8), dtype=np.uint8)\n            white_liberty = np.zeros((19, 19, 8), dtype=np.uint8)\n            visited = {}\n            for i in range(19):\n                for j in range(19):\n                    if board_mtx[i][j] == 1 and (i, j) not in visited:\n                        groups = Board.get_group(i, j, board_mtx, visited=visited)\n                        num_liberty = Board.check_liberty(groups, board_mtx, cnt=True)\n                        if num_liberty > 8:\n                            num_liberty = 8\n                        for stone in groups:\n                            black_liberty[stone[0]][stone[1]][num_liberty-1] = 1\n\n                    if board_mtx[i][j] == 2 and (i, j) not in visited:\n                        groups = Board.get_group(i, j, board_mtx, visited=visited)\n                        num_liberty = Board.check_liberty(groups, board_mtx, cnt=True)\n                        if num_liberty > 8:\n                            num_liberty = 8\n                        for stone in groups:\n                            white_liberty[stone[0]][stone[1]][num_liberty-1] = 1\n\n            black_stones = np.concatenate((black_stones, black_liberty), axis=2)\n            white_stones = np.concatenate((white_stones, white_liberty), axis=2)\n            # for i in range(9):\n            #     print(board_mtx)\n            #     print('liberty:', i)\n            #     print(black_stones[:, :, i])\n            #     print('===')\n            #\n            # print('XXXXXX')\n            # print('XXXXXX')\n            # print('XXXXXX')\n            #\n            # for i in range(9):\n            #     print(board_mtx)\n            #     print('liberty:', i)\n            #     print(white_stones[:, :, i])\n            #     print('===')\n            # exit()\n\n        stones = np.concatenate((black_stones, white_stones), axis=2)\n\n        ones = np.ones((19, 19, 1), dtype=np.uint8)\n        last_move = np.zeros((19, 19, 1), dtype=np.uint8)\n        if not y['ko_state:']:\n            last_move[y['current_move'][0]][y['current_move'][1]] = 1\n        else:\n            last_move[y['current_move'][0]][y['current_move'][1]] = -1\n\n        is_black_next = np.ones((19, 19, 1), dtype=np.uint8)\n        if y['next_to_play'] == 2:\n            is_black_next -= 1\n\n        feat = np.concatenate((stones, last_move, is_black_next, ones), axis=2)\n\n        return feat\n\n    @staticmethod\n    def preprocess_label(y):\n        mtx = np.zeros((19, 19, 1), dtype=np.uint8)\n        mtx[y['next_move'][0]][y['next_move'][1]] = 1\n        return mtx\n\n\nif __name__ == '__main__':\n    train_dir = '/mnt/chenzhao/GoData/policy_kgs/'\n    # train_dir = '/mnt/chenzhao/GoData/'\n    net = PolicyNet(train_dir, '')\n    net.train(1e-4, save_path='/mnt/chenzhao/GoCheck/policy/kgs/policy_kgs_liberty_feat1e-4_',\n              resume_path='/mnt/chenzhao/GoCheck/policy/kgs/policy_kgs_liberty_feat-2')\n"""
src/value_net.py,38,"b""import tensorflow as tf\nimport numpy as np\nfrom game import Board\nfrom input import InputData\n\n\nclass ValueNet(object):\n\n    def __init__(self, train_data, val_data):\n        self.train_data = train_data\n        self.val_data = val_data\n\n    def conv(self, feature_map, filters_in, filters_out, k_size, scope, padding='SAME', dilation_rate=1, is_activation=True):\n        with tf.variable_scope(scope):\n            kernel = tf.get_variable('kernel', shape=[k_size, k_size, filters_in, filters_out],\n                                     initializer=tf.contrib.layers.xavier_initializer())\n            bias = tf.get_variable('b', shape=[filters_out], initializer=tf.contrib.layers.xavier_initializer())\n            out = tf.nn.convolution(feature_map, kernel, padding, dilation_rate=[dilation_rate, dilation_rate],\n                                    name='conv') + bias\n            if is_activation:\n                out = tf.nn.relu(out, name='out')\n            return out\n\n    def batch_norm(self, x, is_training, name):\n        with tf.variable_scope(name):\n            beta = tf.Variable(tf.constant(0.0, shape=[x.shape[-1]]), name='beta', trainable=True)\n            gamma = tf.Variable(tf.constant(1.0, shape=[x.shape[-1]]), name='gamma', trainable=True)\n            axises = np.arange(len(x.shape) - 1)\n            batch_mean, batch_var = tf.nn.moments(x, axises, name='moments')\n            ema = tf.train.ExponentialMovingAverage(decay=0.5)\n\n            def mean_var_with_update():\n                ema_apply_op = ema.apply([batch_mean, batch_var])\n                with tf.control_dependencies([ema_apply_op]):\n                    return tf.identity(batch_mean), tf.identity(batch_var)\n\n            mean, var = tf.cond(is_training, mean_var_with_update,\n                                lambda: (ema.average(batch_mean), ema.average(batch_var)))\n            normed = tf.nn.batch_normalization(x, mean, var, beta, gamma, 1e-3)\n        return normed\n\n    def residual_block(self, feat_map, num_in, num_out, scope_name, is_training, dilation_rate=(1, 1)):\n        with tf.variable_scope(scope_name):\n            bottleneck = self.conv(feat_map, num_in, num_out, k_size=3, scope='c1', dilation_rate=dilation_rate[0],\n                                   is_activation=False)\n            bottleneck = self.batch_norm(bottleneck, is_training=is_training, name='bn1')\n            bottleneck = tf.nn.relu(bottleneck)\n\n            bottleneck = self.conv(bottleneck, num_out, num_out, k_size=3, scope='c2', dilation_rate=dilation_rate[1],\n                                   is_activation=False)\n            bottleneck = self.batch_norm(bottleneck, is_training=is_training, name='bn2')\n            out = tf.add(bottleneck, feat_map, name='add')\n            out = tf.nn.relu(out)\n\n        return out\n\n    def inference(self, feat_map, is_training):\n        with tf.variable_scope('net'):\n            out = self.conv(feat_map, filters_in=21, filters_out=128, k_size=3, scope='c1', padding='SAME',\n                            is_activation=False)\n            out = self.batch_norm(out, is_training=is_training, name='bn1')\n            out = tf.nn.relu(out)\n\n            out = self.residual_block(out, 128, 128, scope_name='res1', is_training=is_training)\n            out = self.residual_block(out, 128, 128, scope_name='res2', is_training=is_training)\n            out = self.residual_block(out, 128, 128, scope_name='res3', is_training=is_training,\n                                      dilation_rate=[2, 4])\n            out = self.residual_block(out, 128, 128, scope_name='res4', is_training=is_training,\n                                      dilation_rate=[8, 1])\n            out = self.residual_block(out, 128, 128, scope_name='res5', is_training=is_training)\n\n            out = self.conv(out, filters_in=128, filters_out=128, k_size=3, scope='c2', padding='SAME',\n                            is_activation=False)\n            out = self.batch_norm(out, is_training=is_training, name='bn2')\n            out = tf.nn.relu(out)\n\n            out = self.conv(out, filters_in=128, filters_out=1, k_size=1, scope='c3', padding='SAME',\n                            is_activation=False)\n            out = self.batch_norm(out, is_training=is_training, name='bn3')\n            out = tf.nn.relu(out)\n\n            out_logits = self.conv(out, filters_in=1, filters_out=1, k_size=19, scope='c4', padding='VALID', is_activation=False)\n\n            out = tf.nn.sigmoid(out_logits)\n            return out_logits, out\n\n    def loss(self, labels, predictions):\n        return tf.losses.mean_squared_error(labels=labels, predictions=predictions)\n\n    def train(self, learning_rate, save_path, resume_path=None):\n        model_x = tf.placeholder(dtype=tf.float32, shape=(None, 19, 19, 21))\n        model_y = tf.placeholder(dtype=tf.float32, shape=(None, 1, 1, 1))\n        is_training = tf.placeholder(dtype=tf.bool)\n\n        out_logits, out = self.inference(model_x, is_training=is_training)\n        loss = self.loss(labels=model_y, predictions=out)\n\n        all_trainable = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES)\n        kernels = [var for var in all_trainable if 'kernel' in var.name]\n        lossL2 = tf.reduce_mean([tf.reduce_mean(tf.square(v)) for v in kernels]) * 1e-3\n\n        all_loss = loss + lossL2\n\n        train_op = tf.train.AdamOptimizer(learning_rate).minimize(all_loss)\n        loader = tf.train.Saver()\n        saver = tf.train.Saver(max_to_keep=20)\n\n        config = tf.ConfigProto()\n        config.gpu_options.allow_growth = True\n        with tf.Session(config=config) as sess:\n            # sess.run(tf.variables_initializer(tf.global_variables()))\n            if resume_path is None:\n                sess.run(tf.global_variables_initializer())\n            else:\n                print('resume:', resume_path)\n                sess.run(tf.global_variables_initializer())\n                loader.restore(sess, resume_path)\n            step = 0\n            epoch = self.train_data.epoch\n            while True:\n                step += 1\n                x, y = self.train_data.next_batch()\n                if len(x) == 0:\n                    continue\n                x, y = ValueNet.pre_process(x, y)\n                feed_dict = {model_x: x, model_y: y, is_training: True}\n                out_, _, loss_, l2_ = sess.run([out, train_op, loss, lossL2], feed_dict=feed_dict)\n                if step % 100 == 0:\n                    for oo, yy in zip(out_, y)[:10]:\n                        print(oo, yy)\n                print('step:', step, 'loss:', loss_, l2_, 'epoch:', epoch)\n                if self.train_data.epoch > epoch:\n                    epoch = self.train_data.epoch\n                    print('save:')\n                    saver.save(sess, save_path, global_step=epoch)\n\n    @staticmethod\n    def pre_process(x, y):\n        x = np.asarray([ValueNet.preprocess_board(xx, yy, contain_liberty=True) for (xx, yy) in zip(x, y)], dtype=np.float32)\n        y = np.asarray([ValueNet.preprocess_label(yy) for yy in y], dtype=np.float32).reshape((-1, 1, 1, 1))\n        return x, y\n\n    @staticmethod\n    def preprocess_board(board_mtx, y, random=True, contain_liberty=False):\n        if random:\n            rand = np.random.randint(0, 8)\n            if rand <= 3:\n                board_mtx = board_mtx.T\n                y['current_move'] = (y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (y['next_move'][1], y['next_move'][0])\n            i = rand % 4\n            if i == 1:\n                board_mtx = np.rot90(board_mtx)\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                # print(a[2-idx[1]][idx[0]])\n\n            if i == 2:\n                board_mtx = np.rot90(board_mtx)\n                board_mtx = np.rot90(board_mtx)\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n            if i == 3:\n                board_mtx = np.rot90(board_mtx)\n                board_mtx = np.rot90(board_mtx)\n                board_mtx = np.rot90(board_mtx)\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n                y['current_move'] = (18-y['current_move'][1], y['current_move'][0])\n                y['next_move'] = (18-y['next_move'][1], y['next_move'][0])\n\n        black_stones = np.zeros((19, 19, 1), dtype=np.uint8)\n        black_stones[board_mtx == 1] = 1\n        white_stones = np.zeros((19, 19, 1), dtype=np.uint8)\n        white_stones[board_mtx == 2] = 1\n\n        if contain_liberty:\n            black_liberty = np.zeros((19, 19, 8), dtype=np.uint8)\n            white_liberty = np.zeros((19, 19, 8), dtype=np.uint8)\n            visited = {}\n            for i in range(19):\n                for j in range(19):\n                    if board_mtx[i][j] == 1 and (i, j) not in visited:\n                        groups = Board.get_group(i, j, board_mtx, visited=visited)\n                        num_liberty = Board.check_liberty(groups, board_mtx, cnt=True)\n                        if num_liberty > 8:\n                            num_liberty = 8\n                        for stone in groups:\n                            black_liberty[stone[0]][stone[1]][num_liberty-1] = 1\n\n                    if board_mtx[i][j] == 2 and (i, j) not in visited:\n                        groups = Board.get_group(i, j, board_mtx, visited=visited)\n                        num_liberty = Board.check_liberty(groups, board_mtx, cnt=True)\n                        if num_liberty > 8:\n                            num_liberty = 8\n                        for stone in groups:\n                            white_liberty[stone[0]][stone[1]][num_liberty-1] = 1\n\n            black_stones = np.concatenate((black_stones, black_liberty), axis=2)\n            white_stones = np.concatenate((white_stones, white_liberty), axis=2)\n\n        stones = np.concatenate((black_stones, white_stones), axis=2)\n\n        ones = np.ones((19, 19, 1), dtype=np.uint8)\n        last_move = np.zeros((19, 19, 1), dtype=np.uint8)\n        if not y['ko_state:']:\n            last_move[y['current_move'][0]][y['current_move'][1]] = 1\n        else:\n            last_move[y['current_move'][0]][y['current_move'][1]] = -1\n\n        is_black_next = np.ones((19, 19, 1), dtype=np.uint8)\n        if y['next_to_play'] == 2:\n            is_black_next -= 1\n\n        feat = np.concatenate((stones, last_move, is_black_next, ones), axis=2)\n        return feat\n\n    @staticmethod\n    def preprocess_label(y):\n        if type(y['result']) is float:\n            return y['result']\n        else:\n            if y['result'] == 'B':\n                return np.asarray([1])\n            else:\n                return np.asarray([0])\n\nif __name__ == '__main__':\n\n    # train_data = InputData('/mnt/chenzhao/GoData/value_aya_ko/', batch_size=128)\n    train_data = InputData('/mnt/chenzhao/GoData/', batch_size=128)\n    # train_data = InputData('/mnt/chenzhao/GoData/', batch_size=128)\n    value_net = ValueNet(train_data, '')\n    value_net.train(1e-4, save_path='/mnt/chenzhao/GoCheck/value/correct_bn/aya_ko-all_trained-kgsfinetune',\n                    # resume_path='/mnt/chenzhao/GoCheck/value/correct_bn/aya_bn-1')\n                    resume_path='/mnt/chenzhao/GoCheck/value/correct_bn/aya_ko-all_trained-2')\n\n"""
