file_path,api_count,code
assignment1/cs231n/data_utils.py,0,"b'from __future__ import print_function\n\nfrom six.moves import cPickle as pickle\nimport numpy as np\nimport os\nfrom scipy.misc import imread\nimport platform\n\ndef load_pickle(f):\n    version = platform.python_version_tuple()\n    if version[0] == \'2\':\n        return  pickle.load(f)\n    elif version[0] == \'3\':\n        return  pickle.load(f, encoding=\'latin1\')\n    raise ValueError(""invalid python version: {}"".format(version))\n\ndef load_CIFAR_batch(filename):\n  """""" load single batch of cifar """"""\n  with open(filename, \'rb\') as f:\n    datadict = load_pickle(f)\n    X = datadict[\'data\']\n    Y = datadict[\'labels\']\n    X = X.reshape(10000, 3, 32, 32).transpose(0,2,3,1).astype(""float"")\n    Y = np.array(Y)\n    return X, Y\n\ndef load_CIFAR10(ROOT):\n  """""" load all of cifar """"""\n  xs = []\n  ys = []\n  for b in range(1,6):\n    f = os.path.join(ROOT, \'data_batch_%d\' % (b, ))\n    X, Y = load_CIFAR_batch(f)\n    xs.append(X)\n    ys.append(Y)    \n  Xtr = np.concatenate(xs)\n  Ytr = np.concatenate(ys)\n  del X, Y\n  Xte, Yte = load_CIFAR_batch(os.path.join(ROOT, \'test_batch\'))\n  return Xtr, Ytr, Xte, Yte\n\n\ndef get_CIFAR10_data(num_training=49000, num_validation=1000, num_test=1000,\n                     subtract_mean=True):\n    """"""\n    Load the CIFAR-10 dataset from disk and perform preprocessing to prepare\n    it for classifiers. These are the same steps as we used for the SVM, but\n    condensed to a single function.\n    """"""\n    # Load the raw CIFAR-10 data\n    cifar10_dir = \'cs231n/datasets/cifar-10-batches-py\'\n    X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)\n        \n    # Subsample the data\n    mask = list(range(num_training, num_training + num_validation))\n    X_val = X_train[mask]\n    y_val = y_train[mask]\n    mask = list(range(num_training))\n    X_train = X_train[mask]\n    y_train = y_train[mask]\n    mask = list(range(num_test))\n    X_test = X_test[mask]\n    y_test = y_test[mask]\n\n    # Normalize the data: subtract the mean image\n    if subtract_mean:\n      mean_image = np.mean(X_train, axis=0)\n      X_train -= mean_image\n      X_val -= mean_image\n      X_test -= mean_image\n    \n    # Transpose so that channels come first\n    X_train = X_train.transpose(0, 3, 1, 2).copy()\n    X_val = X_val.transpose(0, 3, 1, 2).copy()\n    X_test = X_test.transpose(0, 3, 1, 2).copy()\n\n    # Package data into a dictionary\n    return {\n      \'X_train\': X_train, \'y_train\': y_train,\n      \'X_val\': X_val, \'y_val\': y_val,\n      \'X_test\': X_test, \'y_test\': y_test,\n    }\n    \n\ndef load_tiny_imagenet(path, dtype=np.float32, subtract_mean=True):\n  """"""\n  Load TinyImageNet. Each of TinyImageNet-100-A, TinyImageNet-100-B, and\n  TinyImageNet-200 have the same directory structure, so this can be used\n  to load any of them.\n\n  Inputs:\n  - path: String giving path to the directory to load.\n  - dtype: numpy datatype used to load the data.\n  - subtract_mean: Whether to subtract the mean training image.\n\n  Returns: A dictionary with the following entries:\n  - class_names: A list where class_names[i] is a list of strings giving the\n    WordNet names for class i in the loaded dataset.\n  - X_train: (N_tr, 3, 64, 64) array of training images\n  - y_train: (N_tr,) array of training labels\n  - X_val: (N_val, 3, 64, 64) array of validation images\n  - y_val: (N_val,) array of validation labels\n  - X_test: (N_test, 3, 64, 64) array of testing images.\n  - y_test: (N_test,) array of test labels; if test labels are not available\n    (such as in student code) then y_test will be None.\n  - mean_image: (3, 64, 64) array giving mean training image\n  """"""\n  # First load wnids\n  with open(os.path.join(path, \'wnids.txt\'), \'r\') as f:\n    wnids = [x.strip() for x in f]\n\n  # Map wnids to integer labels\n  wnid_to_label = {wnid: i for i, wnid in enumerate(wnids)}\n\n  # Use words.txt to get names for each class\n  with open(os.path.join(path, \'words.txt\'), \'r\') as f:\n    wnid_to_words = dict(line.split(\'\\t\') for line in f)\n    for wnid, words in wnid_to_words.iteritems():\n      wnid_to_words[wnid] = [w.strip() for w in words.split(\',\')]\n  class_names = [wnid_to_words[wnid] for wnid in wnids]\n\n  # Next load training data.\n  X_train = []\n  y_train = []\n  for i, wnid in enumerate(wnids):\n    if (i + 1) % 20 == 0:\n      print(\'loading training data for synset %d / %d\' % (i + 1, len(wnids)))\n    # To figure out the filenames we need to open the boxes file\n    boxes_file = os.path.join(path, \'train\', wnid, \'%s_boxes.txt\' % wnid)\n    with open(boxes_file, \'r\') as f:\n      filenames = [x.split(\'\\t\')[0] for x in f]\n    num_images = len(filenames)\n    \n    X_train_block = np.zeros((num_images, 3, 64, 64), dtype=dtype)\n    y_train_block = wnid_to_label[wnid] * np.ones(num_images, dtype=np.int64)\n    for j, img_file in enumerate(filenames):\n      img_file = os.path.join(path, \'train\', wnid, \'images\', img_file)\n      img = imread(img_file)\n      if img.ndim == 2:\n        ## grayscale file\n        img.shape = (64, 64, 1)\n      X_train_block[j] = img.transpose(2, 0, 1)\n    X_train.append(X_train_block)\n    y_train.append(y_train_block)\n      \n  # We need to concatenate all training data\n  X_train = np.concatenate(X_train, axis=0)\n  y_train = np.concatenate(y_train, axis=0)\n  \n  # Next load validation data\n  with open(os.path.join(path, \'val\', \'val_annotations.txt\'), \'r\') as f:\n    img_files = []\n    val_wnids = []\n    for line in f:\n      img_file, wnid = line.split(\'\\t\')[:2]\n      img_files.append(img_file)\n      val_wnids.append(wnid)\n    num_val = len(img_files)\n    y_val = np.array([wnid_to_label[wnid] for wnid in val_wnids])\n    X_val = np.zeros((num_val, 3, 64, 64), dtype=dtype)\n    for i, img_file in enumerate(img_files):\n      img_file = os.path.join(path, \'val\', \'images\', img_file)\n      img = imread(img_file)\n      if img.ndim == 2:\n        img.shape = (64, 64, 1)\n      X_val[i] = img.transpose(2, 0, 1)\n\n  # Next load test images\n  # Students won\'t have test labels, so we need to iterate over files in the\n  # images directory.\n  img_files = os.listdir(os.path.join(path, \'test\', \'images\'))\n  X_test = np.zeros((len(img_files), 3, 64, 64), dtype=dtype)\n  for i, img_file in enumerate(img_files):\n    img_file = os.path.join(path, \'test\', \'images\', img_file)\n    img = imread(img_file)\n    if img.ndim == 2:\n      img.shape = (64, 64, 1)\n    X_test[i] = img.transpose(2, 0, 1)\n\n  y_test = None\n  y_test_file = os.path.join(path, \'test\', \'test_annotations.txt\')\n  if os.path.isfile(y_test_file):\n    with open(y_test_file, \'r\') as f:\n      img_file_to_wnid = {}\n      for line in f:\n        line = line.split(\'\\t\')\n        img_file_to_wnid[line[0]] = line[1]\n    y_test = [wnid_to_label[img_file_to_wnid[img_file]] for img_file in img_files]\n    y_test = np.array(y_test)\n  \n  mean_image = X_train.mean(axis=0)\n  if subtract_mean:\n    X_train -= mean_image[None]\n    X_val -= mean_image[None]\n    X_test -= mean_image[None]\n\n  return {\n    \'class_names\': class_names,\n    \'X_train\': X_train,\n    \'y_train\': y_train,\n    \'X_val\': X_val,\n    \'y_val\': y_val,\n    \'X_test\': X_test,\n    \'y_test\': y_test,\n    \'class_names\': class_names,\n    \'mean_image\': mean_image,\n  }\n\n\ndef load_models(models_dir):\n  """"""\n  Load saved models from disk. This will attempt to unpickle all files in a\n  directory; any files that give errors on unpickling (such as README.txt) will\n  be skipped.\n\n  Inputs:\n  - models_dir: String giving the path to a directory containing model files.\n    Each model file is a pickled dictionary with a \'model\' field.\n\n  Returns:\n  A dictionary mapping model file names to models.\n  """"""\n  models = {}\n  for model_file in os.listdir(models_dir):\n    with open(os.path.join(models_dir, model_file), \'rb\') as f:\n      try:\n        models[model_file] = load_pickle(f)[\'model\']\n      except pickle.UnpicklingError:\n        continue\n  return models\n'"
assignment1/cs231n/features.py,0,"b'from __future__ import print_function\n# from past.builtins import xrange\nimport sys\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\nimport matplotlib\nimport numpy as np\nfrom scipy.ndimage import uniform_filter\n\n\ndef extract_features(imgs, feature_fns, verbose=False):\n    """"""\n  Given pixel data for images and several feature functions that can operate on\n  single images, apply all feature functions to all images, concatenating the\n  feature vectors for each image and storing the features for all images in\n  a single matrix.\n\n  Inputs:\n  - imgs: N x H X W X C array of pixel data for N images.\n  - feature_fns: List of k feature functions. The ith feature function should\n    take as input an H x W x D array and return a (one-dimensional) array of\n    length F_i.\n  - verbose: Boolean; if true, print progress.\n\n  Returns:\n  An array of shape (N, F_1 + ... + F_k) where each column is the concatenation\n  of all features for a single image.\n  """"""\n    num_images = imgs.shape[0]\n    if num_images == 0:\n        return np.array([])\n\n    # Use the first image to determine feature dimensions\n    feature_dims = []\n    first_image_features = []\n    for feature_fn in feature_fns:\n        feats = feature_fn(imgs[0].squeeze())\n        assert len(feats.shape) == 1, \'Feature functions must be one-dimensional\'\n        feature_dims.append(feats.size)\n        first_image_features.append(feats)\n\n    # Now that we know the dimensions of the features, we can allocate a single\n    # big array to store all features as columns.\n    total_feature_dim = sum(feature_dims)\n    imgs_features = np.zeros((num_images, total_feature_dim))\n    imgs_features[0] = np.hstack(first_image_features).T\n\n    # Extract features for the rest of the images.\n    for i in xrange(1, num_images):\n        idx = 0\n        for feature_fn, feature_dim in zip(feature_fns, feature_dims):\n            next_idx = idx + feature_dim\n            imgs_features[i, idx:next_idx] = feature_fn(imgs[i].squeeze())\n            idx = next_idx\n        if verbose and i % 1000 == 0:\n            print(\'Done extracting features for %d / %d images\' % (i, num_images))\n\n    return imgs_features\n\n\ndef rgb2gray(rgb):\n    """"""Convert RGB image to grayscale\n\n    Parameters:\n      rgb : RGB image\n\n    Returns:\n      gray : grayscale image\n  \n  """"""\n    return np.dot(rgb[..., :3], [0.299, 0.587, 0.144])\n\n\ndef hog_feature(im):\n    """"""Compute Histogram of Gradient (HOG) feature for an image\n  \n       Modified from skimage.feature.hog\n       http://pydoc.net/Python/scikits-image/0.4.2/skimage.feature.hog\n     \n     Reference:\n       Histograms of Oriented Gradients for Human Detection\n       Navneet Dalal and Bill Triggs, CVPR 2005\n     \n    Parameters:\n      im : an input grayscale or rgb image\n\n    Returns:\n      feat: Histogram of Gradient (HOG) feature\n    \n  """"""\n\n    # convert rgb to grayscale if needed\n    if im.ndim == 3:\n        image = rgb2gray(im)\n    else:\n        image = np.atleast_2d(im)\n\n    sx, sy = image.shape  # image size\n    orientations = 9  # number of gradient bins\n    cx, cy = (8, 8)  # pixels per cell\n\n    gx = np.zeros(image.shape)\n    gy = np.zeros(image.shape)\n    gx[:, :-1] = np.diff(image, n=1, axis=1)  # compute gradient on x-direction\n    gy[:-1, :] = np.diff(image, n=1, axis=0)  # compute gradient on y-direction\n    grad_mag = np.sqrt(gx ** 2 + gy ** 2)  # gradient magnitude\n    grad_ori = np.arctan2(gy, (gx + 1e-15)) * (180 / np.pi) + 90  # gradient orientation\n\n    n_cellsx = int(np.floor(sx / cx))  # number of cells in x\n    n_cellsy = int(np.floor(sy / cy))  # number of cells in y\n    # compute orientations integral images\n    orientation_histogram = np.zeros((n_cellsx, n_cellsy, orientations))\n    for i in range(orientations):\n        # create new integral image for this orientation\n        # isolate orientations in this range\n        temp_ori = np.where(grad_ori < 180 / orientations * (i + 1),\n                            grad_ori, 0)\n        temp_ori = np.where(grad_ori >= 180 / orientations * i,\n                            temp_ori, 0)\n        # select magnitudes for those orientations\n        cond2 = temp_ori > 0\n        temp_mag = np.where(cond2, grad_mag, 0)\n        orientation_histogram[:, :, i] = uniform_filter(temp_mag, size=(cx, cy))[::cx, ::cy].T\n\n    return orientation_histogram.ravel()\n\n\ndef color_histogram_hsv(im, nbin=10, xmin=0, xmax=255, normalized=True):\n    """"""\n  Compute color histogram for an image using hue.\n\n  Inputs:\n  - im: H x W x C array of pixel data for an RGB image.\n  - nbin: Number of histogram bins. (default: 10)\n  - xmin: Minimum pixel value (default: 0)\n  - xmax: Maximum pixel value (default: 255)\n  - normalized: Whether to normalize the histogram (default: True)\n\n  Returns:\n    1D vector of length nbin giving the color histogram over the hue of the\n    input image.\n  """"""\n    ndim = im.ndim\n    bins = np.linspace(xmin, xmax, nbin + 1)\n    hsv = matplotlib.colors.rgb_to_hsv(im / xmax) * xmax\n    imhist, bin_edges = np.histogram(hsv[:, :, 0], bins=bins, density=normalized)\n    imhist = imhist * np.diff(bin_edges)\n\n    # return histogram\n    return imhist\n\n\npass\n'"
assignment1/cs231n/gradient_check.py,0,"b'from __future__ import print_function\n# from past.builtins import xrange\nimport sys\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\nimport numpy as np\nfrom random import randrange\n\n\ndef eval_numerical_gradient(f, x, verbose=True, h=0.00001):\n    """"""\n  a naive implementation of numerical gradient of f at x \n  - f should be a function that takes a single argument\n  - x is the point (numpy array) to evaluate the gradient at\n  """"""\n\n    fx = f(x)  # evaluate function value at original point\n    grad = np.zeros_like(x)\n    # iterate over all indexes in x\n    it = np.nditer(x, flags=[\'multi_index\'], op_flags=[\'readwrite\'])\n    while not it.finished:\n\n        # evaluate function at x+h\n        ix = it.multi_index\n        oldval = x[ix]\n        x[ix] = oldval + h  # increment by h\n        fxph = f(x)  # evalute f(x + h)\n        x[ix] = oldval - h\n        fxmh = f(x)  # evaluate f(x - h)\n        x[ix] = oldval  # restore\n\n        # compute the partial derivative with centered formula\n        grad[ix] = (fxph - fxmh) / (2 * h)  # the slope\n        if verbose:\n            print(ix, grad[ix])\n        it.iternext()  # step to next dimension\n\n    return grad\n\n\ndef eval_numerical_gradient_array(f, x, df, h=1e-5):\n    """"""\n  Evaluate a numeric gradient for a function that accepts a numpy\n  array and returns a numpy array.\n  """"""\n    grad = np.zeros_like(x)\n    it = np.nditer(x, flags=[\'multi_index\'], op_flags=[\'readwrite\'])\n    while not it.finished:\n        ix = it.multi_index\n\n        oldval = x[ix]\n        x[ix] = oldval + h\n        pos = f(x).copy()\n        x[ix] = oldval - h\n        neg = f(x).copy()\n        x[ix] = oldval\n\n        grad[ix] = np.sum((pos - neg) * df) / (2 * h)\n        it.iternext()\n    return grad\n\n\ndef eval_numerical_gradient_blobs(f, inputs, output, h=1e-5):\n    """"""\n  Compute numeric gradients for a function that operates on input\n  and output blobs.\n  \n  We assume that f accepts several input blobs as arguments, followed by a blob\n  into which outputs will be written. For example, f might be called like this:\n\n  f(x, w, out)\n  \n  where x and w are input Blobs, and the result of f will be written to out.\n\n  Inputs: \n  - f: function\n  - inputs: tuple of input blobs\n  - output: output blob\n  - h: step size\n  """"""\n    numeric_diffs = []\n    for input_blob in inputs:\n        diff = np.zeros_like(input_blob.diffs)\n        it = np.nditer(input_blob.vals, flags=[\'multi_index\'],\n                       op_flags=[\'readwrite\'])\n        while not it.finished:\n            idx = it.multi_index\n            orig = input_blob.vals[idx]\n\n            input_blob.vals[idx] = orig + h\n            f(*(inputs + (output,)))\n            pos = np.copy(output.vals)\n            input_blob.vals[idx] = orig - h\n            f(*(inputs + (output,)))\n            neg = np.copy(output.vals)\n            input_blob.vals[idx] = orig\n\n            diff[idx] = np.sum((pos - neg) * output.diffs) / (2.0 * h)\n\n            it.iternext()\n        numeric_diffs.append(diff)\n    return numeric_diffs\n\n\ndef eval_numerical_gradient_net(net, inputs, output, h=1e-5):\n    return eval_numerical_gradient_blobs(lambda *args: net.forward(),\n                                         inputs, output, h=h)\n\n\ndef grad_check_sparse(f, x, analytic_grad, num_checks=10, h=1e-5):\n    """"""\n  sample a few random elements and only return numerical\n  in this dimensions.\n  """"""\n\n    for i in xrange(num_checks):\n        ix = tuple([randrange(m) for m in x.shape])\n\n        oldval = x[ix]\n        x[ix] = oldval + h  # increment by h\n        fxph = f(x)  # evaluate f(x + h)\n        x[ix] = oldval - h  # increment by h\n        fxmh = f(x)  # evaluate f(x - h)\n        x[ix] = oldval  # reset\n\n        grad_numerical = (fxph - fxmh) / (2 * h)\n        grad_analytic = analytic_grad[ix]\n        rel_error = abs(grad_numerical - grad_analytic) / (abs(grad_numerical) + abs(grad_analytic))\n        print(\'numerical: %f analytic: %f, relative error: %e\' % (grad_numerical, grad_analytic, rel_error))\n'"
assignment1/cs231n/vis_utils.py,0,"b'# from past.builtins import xrange\nimport sys\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\nfrom math import sqrt, ceil\nimport numpy as np\n\ndef visualize_grid(Xs, ubound=255.0, padding=1):\n  """"""\n  Reshape a 4D tensor of image data to a grid for easy visualization.\n\n  Inputs:\n  - Xs: Data of shape (N, H, W, C)\n  - ubound: Output grid will have values scaled to the range [0, ubound]\n  - padding: The number of blank pixels between elements of the grid\n  """"""\n  (N, H, W, C) = Xs.shape\n  grid_size = int(ceil(sqrt(N)))\n  grid_height = H * grid_size + padding * (grid_size - 1)\n  grid_width = W * grid_size + padding * (grid_size - 1)\n  grid = np.zeros((grid_height, grid_width, C))\n  next_idx = 0\n  y0, y1 = 0, H\n  for y in xrange(grid_size):\n    x0, x1 = 0, W\n    for x in xrange(grid_size):\n      if next_idx < N:\n        img = Xs[next_idx]\n        low, high = np.min(img), np.max(img)\n        grid[y0:y1, x0:x1] = ubound * (img - low) / (high - low)\n        # grid[y0:y1, x0:x1] = Xs[next_idx]\n        next_idx += 1\n      x0 += W + padding\n      x1 += W + padding\n    y0 += H + padding\n    y1 += H + padding\n  # grid_max = np.max(grid)\n  # grid_min = np.min(grid)\n  # grid = ubound * (grid - grid_min) / (grid_max - grid_min)\n  return grid\n\ndef vis_grid(Xs):\n  """""" visualize a grid of images """"""\n  (N, H, W, C) = Xs.shape\n  A = int(ceil(sqrt(N)))\n  G = np.ones((A*H+A, A*W+A, C), Xs.dtype)\n  G *= np.min(Xs)\n  n = 0\n  for y in range(A):\n    for x in range(A):\n      if n < N:\n        G[y*H+y:(y+1)*H+y, x*W+x:(x+1)*W+x, :] = Xs[n,:,:,:]\n        n += 1\n  # normalize to [0,1]\n  maxg = G.max()\n  ming = G.min()\n  G = (G - ming)/(maxg-ming)\n  return G\n  \ndef vis_nn(rows):\n  """""" visualize array of arrays of images """"""\n  N = len(rows)\n  D = len(rows[0])\n  H,W,C = rows[0][0].shape\n  Xs = rows[0][0]\n  G = np.ones((N*H+N, D*W+D, C), Xs.dtype)\n  for y in range(N):\n    for x in range(D):\n      G[y*H+y:(y+1)*H+y, x*W+x:(x+1)*W+x, :] = rows[y][x]\n  # normalize to [0,1]\n  maxg = G.max()\n  ming = G.min()\n  G = (G - ming)/(maxg-ming)\n  return G\n\n\n\n'"
assignment2/cs231n/data_utils.py,0,"b'from __future__ import print_function\n\nfrom builtins import range\nfrom six.moves import cPickle as pickle\nimport numpy as np\nimport os\nfrom scipy.misc import imread\nimport platform\n\ndef load_pickle(f):\n    version = platform.python_version_tuple()\n    if version[0] == \'2\':\n        return  pickle.load(f)\n    elif version[0] == \'3\':\n        return  pickle.load(f, encoding=\'latin1\')\n    raise ValueError(""invalid python version: {}"".format(version))\n\ndef load_CIFAR_batch(filename):\n    """""" load single batch of cifar """"""\n    with open(filename, \'rb\') as f:\n        datadict = load_pickle(f)\n        X = datadict[\'data\']\n        Y = datadict[\'labels\']\n        X = X.reshape(10000, 3, 32, 32).transpose(0,2,3,1).astype(""float"")\n        Y = np.array(Y)\n        return X, Y\n\ndef load_CIFAR10(ROOT):\n    """""" load all of cifar """"""\n    xs = []\n    ys = []\n    for b in range(1,6):\n        f = os.path.join(ROOT, \'data_batch_%d\' % (b, ))\n        X, Y = load_CIFAR_batch(f)\n        xs.append(X)\n        ys.append(Y)\n    Xtr = np.concatenate(xs)\n    Ytr = np.concatenate(ys)\n    del X, Y\n    Xte, Yte = load_CIFAR_batch(os.path.join(ROOT, \'test_batch\'))\n    return Xtr, Ytr, Xte, Yte\n\n\ndef get_CIFAR10_data(num_training=49000, num_validation=1000, num_test=1000,\n                     subtract_mean=True):\n    """"""\n    Load the CIFAR-10 dataset from disk and perform preprocessing to prepare\n    it for classifiers. These are the same steps as we used for the SVM, but\n    condensed to a single function.\n    """"""\n    # Load the raw CIFAR-10 data\n    cifar10_dir = \'cs231n/datasets/cifar-10-batches-py\'\n    X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)\n\n    # Subsample the data\n    mask = list(range(num_training, num_training + num_validation))\n    X_val = X_train[mask]\n    y_val = y_train[mask]\n    mask = list(range(num_training))\n    X_train = X_train[mask]\n    y_train = y_train[mask]\n    mask = list(range(num_test))\n    X_test = X_test[mask]\n    y_test = y_test[mask]\n\n    # Normalize the data: subtract the mean image\n    if subtract_mean:\n        mean_image = np.mean(X_train, axis=0)\n        X_train -= mean_image\n        X_val -= mean_image\n        X_test -= mean_image\n\n    # Transpose so that channels come first\n    X_train = X_train.transpose(0, 3, 1, 2).copy()\n    X_val = X_val.transpose(0, 3, 1, 2).copy()\n    X_test = X_test.transpose(0, 3, 1, 2).copy()\n\n    # Package data into a dictionary\n    return {\n      \'X_train\': X_train, \'y_train\': y_train,\n      \'X_val\': X_val, \'y_val\': y_val,\n      \'X_test\': X_test, \'y_test\': y_test,\n    }\n\n\ndef load_tiny_imagenet(path, dtype=np.float32, subtract_mean=True):\n    """"""\n    Load TinyImageNet. Each of TinyImageNet-100-A, TinyImageNet-100-B, and\n    TinyImageNet-200 have the same directory structure, so this can be used\n    to load any of them.\n\n    Inputs:\n    - path: String giving path to the directory to load.\n    - dtype: numpy datatype used to load the data.\n    - subtract_mean: Whether to subtract the mean training image.\n\n    Returns: A dictionary with the following entries:\n    - class_names: A list where class_names[i] is a list of strings giving the\n      WordNet names for class i in the loaded dataset.\n    - X_train: (N_tr, 3, 64, 64) array of training images\n    - y_train: (N_tr,) array of training labels\n    - X_val: (N_val, 3, 64, 64) array of validation images\n    - y_val: (N_val,) array of validation labels\n    - X_test: (N_test, 3, 64, 64) array of testing images.\n    - y_test: (N_test,) array of test labels; if test labels are not available\n      (such as in student code) then y_test will be None.\n    - mean_image: (3, 64, 64) array giving mean training image\n    """"""\n    # First load wnids\n    with open(os.path.join(path, \'wnids.txt\'), \'r\') as f:\n        wnids = [x.strip() for x in f]\n\n    # Map wnids to integer labels\n    wnid_to_label = {wnid: i for i, wnid in enumerate(wnids)}\n\n    # Use words.txt to get names for each class\n    with open(os.path.join(path, \'words.txt\'), \'r\') as f:\n        wnid_to_words = dict(line.split(\'\\t\') for line in f)\n        for wnid, words in wnid_to_words.items():\n            wnid_to_words[wnid] = [w.strip() for w in words.split(\',\')]\n    class_names = [wnid_to_words[wnid] for wnid in wnids]\n\n    # Next load training data.\n    X_train = []\n    y_train = []\n    for i, wnid in enumerate(wnids):\n        if (i + 1) % 20 == 0:\n            print(\'loading training data for synset %d / %d\'\n                  % (i + 1, len(wnids)))\n        # To figure out the filenames we need to open the boxes file\n        boxes_file = os.path.join(path, \'train\', wnid, \'%s_boxes.txt\' % wnid)\n        with open(boxes_file, \'r\') as f:\n            filenames = [x.split(\'\\t\')[0] for x in f]\n        num_images = len(filenames)\n\n        X_train_block = np.zeros((num_images, 3, 64, 64), dtype=dtype)\n        y_train_block = wnid_to_label[wnid] * \\\n                        np.ones(num_images, dtype=np.int64)\n        for j, img_file in enumerate(filenames):\n            img_file = os.path.join(path, \'train\', wnid, \'images\', img_file)\n            img = imread(img_file)\n            if img.ndim == 2:\n        ## grayscale file\n                img.shape = (64, 64, 1)\n            X_train_block[j] = img.transpose(2, 0, 1)\n        X_train.append(X_train_block)\n        y_train.append(y_train_block)\n\n    # We need to concatenate all training data\n    X_train = np.concatenate(X_train, axis=0)\n    y_train = np.concatenate(y_train, axis=0)\n\n    # Next load validation data\n    with open(os.path.join(path, \'val\', \'val_annotations.txt\'), \'r\') as f:\n        img_files = []\n        val_wnids = []\n        for line in f:\n            img_file, wnid = line.split(\'\\t\')[:2]\n            img_files.append(img_file)\n            val_wnids.append(wnid)\n        num_val = len(img_files)\n        y_val = np.array([wnid_to_label[wnid] for wnid in val_wnids])\n        X_val = np.zeros((num_val, 3, 64, 64), dtype=dtype)\n        for i, img_file in enumerate(img_files):\n            img_file = os.path.join(path, \'val\', \'images\', img_file)\n            img = imread(img_file)\n            if img.ndim == 2:\n                img.shape = (64, 64, 1)\n            X_val[i] = img.transpose(2, 0, 1)\n\n    # Next load test images\n    # Students won\'t have test labels, so we need to iterate over files in the\n    # images directory.\n    img_files = os.listdir(os.path.join(path, \'test\', \'images\'))\n    X_test = np.zeros((len(img_files), 3, 64, 64), dtype=dtype)\n    for i, img_file in enumerate(img_files):\n        img_file = os.path.join(path, \'test\', \'images\', img_file)\n        img = imread(img_file)\n        if img.ndim == 2:\n            img.shape = (64, 64, 1)\n        X_test[i] = img.transpose(2, 0, 1)\n\n    y_test = None\n    y_test_file = os.path.join(path, \'test\', \'test_annotations.txt\')\n    if os.path.isfile(y_test_file):\n        with open(y_test_file, \'r\') as f:\n            img_file_to_wnid = {}\n            for line in f:\n                line = line.split(\'\\t\')\n                img_file_to_wnid[line[0]] = line[1]\n        y_test = [wnid_to_label[img_file_to_wnid[img_file]]\n                  for img_file in img_files]\n        y_test = np.array(y_test)\n\n    mean_image = X_train.mean(axis=0)\n    if subtract_mean:\n        X_train -= mean_image[None]\n        X_val -= mean_image[None]\n        X_test -= mean_image[None]\n\n    return {\n      \'class_names\': class_names,\n      \'X_train\': X_train,\n      \'y_train\': y_train,\n      \'X_val\': X_val,\n      \'y_val\': y_val,\n      \'X_test\': X_test,\n      \'y_test\': y_test,\n      \'class_names\': class_names,\n      \'mean_image\': mean_image,\n    }\n\n\ndef load_models(models_dir):\n    """"""\n    Load saved models from disk. This will attempt to unpickle all files in a\n    directory; any files that give errors on unpickling (such as README.txt)\n    will be skipped.\n\n    Inputs:\n    - models_dir: String giving the path to a directory containing model files.\n      Each model file is a pickled dictionary with a \'model\' field.\n\n    Returns:\n    A dictionary mapping model file names to models.\n    """"""\n    models = {}\n    for model_file in os.listdir(models_dir):\n        with open(os.path.join(models_dir, model_file), \'rb\') as f:\n            try:\n                models[model_file] = load_pickle(f)[\'model\']\n            except pickle.UnpicklingError:\n                continue\n    return models\n\n\ndef load_imagenet_val(num=None):\n    """"""Load a handful of validation images from ImageNet.\n\n    Inputs:\n    - num: Number of images to load (max of 25)\n\n    Returns:\n    - X: numpy array with shape [num, 224, 224, 3]\n    - y: numpy array of integer image labels, shape [num]\n    - class_names: dict mapping integer label to class name\n    """"""\n    imagenet_fn = \'cs231n/datasets/imagenet_val_25.npz\'\n    if not os.path.isfile(imagenet_fn):\n      print(\'file %s not found\' % imagenet_fn)\n      print(\'Run the following:\')\n      print(\'cd cs231n/datasets\')\n      print(\'bash get_imagenet_val.sh\')\n      assert False, \'Need to download imagenet_val_25.npz\'\n    f = np.load(imagenet_fn)\n    X = f[\'X\']\n    y = f[\'y\']\n    class_names = f[\'label_map\'].item()\n    if num is not None:\n        X = X[:num]\n        y = y[:num]\n    return X, y, class_names\n'"
assignment2/cs231n/fast_layers.py,0,"b'from __future__ import print_function\nimport numpy as np\n# try:\n#     from cs231n.im2col_cython import col2im_cython, im2col_cython\n#     from cs231n.im2col_cython import col2im_6d_cython\n# except ImportError:\n#     print(\'run the following from the cs231n directory and try again:\')\n#     print(\'python setup.py build_ext --inplace\')\n#     print(\'You may also need to restart your iPython kernel\')\n\nfrom cs231n.im2col import *\n\n\ndef conv_forward_im2col(x, w, b, conv_param):\n    """"""\n    A fast implementation of the forward pass for a convolutional layer\n    based on im2col and col2im.\n    """"""\n    N, C, H, W = x.shape\n    num_filters, _, filter_height, filter_width = w.shape\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    # Check dimensions\n    assert (W + 2 * pad - filter_width) % stride == 0, \'width does not work\'\n    assert (H + 2 * pad - filter_height) % stride == 0, \'height does not work\'\n\n    # Create output\n    out_height = (H + 2 * pad - filter_height) // stride + 1\n    out_width = (W + 2 * pad - filter_width) // stride + 1\n    out = np.zeros((N, num_filters, out_height, out_width), dtype=x.dtype)\n\n    x_cols = im2col_indices(x, w.shape[2], w.shape[3], pad, stride)\n    # x_cols = im2col_cython(x, w.shape[2], w.shape[3], pad, stride)\n    res = w.reshape((w.shape[0], -1)).dot(x_cols) + b.reshape(-1, 1)\n\n    out = res.reshape(w.shape[0], out.shape[2], out.shape[3], x.shape[0])\n    out = out.transpose(3, 0, 1, 2)\n\n    cache = (x, w, b, conv_param, x_cols)\n    return out, cache\n\n\ndef conv_forward_strides(x, w, b, conv_param):\n    N, C, H, W = x.shape\n    F, _, HH, WW = w.shape\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    # Check dimensions\n    #assert (W + 2 * pad - WW) % stride == 0, \'width does not work\'\n    #assert (H + 2 * pad - HH) % stride == 0, \'height does not work\'\n\n    # Pad the input\n    p = pad\n    x_padded = np.pad(x, ((0, 0), (0, 0), (p, p), (p, p)), mode=\'constant\')\n\n    # Figure out output dimensions\n    H += 2 * pad\n    W += 2 * pad\n    out_h = (H - HH) // stride + 1\n    out_w = (W - WW) // stride + 1\n\n    # Perform an im2col operation by picking clever strides\n    shape = (C, HH, WW, N, out_h, out_w)\n    strides = (H * W, W, 1, C * H * W, stride * W, stride)\n    strides = x.itemsize * np.array(strides)\n    x_stride = np.lib.stride_tricks.as_strided(x_padded,\n                  shape=shape, strides=strides)\n    x_cols = np.ascontiguousarray(x_stride)\n    x_cols.shape = (C * HH * WW, N * out_h * out_w)\n\n    # Now all our convolutions are a big matrix multiply\n    res = w.reshape(F, -1).dot(x_cols) + b.reshape(-1, 1)\n\n    # Reshape the output\n    res.shape = (F, N, out_h, out_w)\n    out = res.transpose(1, 0, 2, 3)\n\n    # Be nice and return a contiguous array\n    # The old version of conv_forward_fast doesn\'t do this, so for a fair\n    # comparison we won\'t either\n    out = np.ascontiguousarray(out)\n\n    cache = (x, w, b, conv_param, x_cols)\n    return out, cache\n\n\ndef conv_backward_strides(dout, cache):\n    x, w, b, conv_param, x_cols = cache\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    N, C, H, W = x.shape\n    F, _, HH, WW = w.shape\n    _, _, out_h, out_w = dout.shape\n\n    db = np.sum(dout, axis=(0, 2, 3))\n\n    dout_reshaped = dout.transpose(1, 0, 2, 3).reshape(F, -1)\n    dw = dout_reshaped.dot(x_cols.T).reshape(w.shape)\n\n    dx_cols = w.reshape(F, -1).T.dot(dout_reshaped)\n    dx_cols.shape = (C, HH, WW, N, out_h, out_w)\n    dx = col2im_6d_cython(dx_cols, N, C, H, W, HH, WW, pad, stride)\n\n    return dx, dw, db\n\n\ndef conv_backward_im2col(dout, cache):\n    """"""\n    A fast implementation of the backward pass for a convolutional layer\n    based on im2col and col2im.\n    """"""\n    x, w, b, conv_param, x_cols = cache\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    db = np.sum(dout, axis=(0, 2, 3))\n\n    num_filters, _, filter_height, filter_width = w.shape\n    dout_reshaped = dout.transpose(1, 2, 3, 0).reshape(num_filters, -1)\n    dw = dout_reshaped.dot(x_cols.T).reshape(w.shape)\n\n    dx_cols = w.reshape(num_filters, -1).T.dot(dout_reshaped)\n    dx = col2im_indices(dx_cols, x.shape, filter_height, filter_width, pad, stride)\n    # dx = col2im_cython(dx_cols, x.shape[0], x.shape[1], x.shape[2], x.shape[3],\n    #                    filter_height, filter_width, pad, stride)\n\n    return dx, dw, db\n\n\nconv_forward_fast = conv_forward_im2col\nconv_backward_fast = conv_backward_im2col\n\n\ndef max_pool_forward_fast(x, pool_param):\n    """"""\n    A fast implementation of the forward pass for a max pooling layer.\n\n    This chooses between the reshape method and the im2col method. If the pooling\n    regions are square and tile the input image, then we can use the reshape\n    method which is very fast. Otherwise we fall back on the im2col method, which\n    is not much faster than the naive method.\n    """"""\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n\n    same_size = pool_height == pool_width == stride\n    tiles = H % pool_height == 0 and W % pool_width == 0\n    if same_size and tiles:\n        out, reshape_cache = max_pool_forward_reshape(x, pool_param)\n        cache = (\'reshape\', reshape_cache)\n    else:\n        out, im2col_cache = max_pool_forward_im2col(x, pool_param)\n        cache = (\'im2col\', im2col_cache)\n    return out, cache\n\n\ndef max_pool_backward_fast(dout, cache):\n    """"""\n    A fast implementation of the backward pass for a max pooling layer.\n\n    This switches between the reshape method an the im2col method depending on\n    which method was used to generate the cache.\n    """"""\n    method, real_cache = cache\n    if method == \'reshape\':\n        return max_pool_backward_reshape(dout, real_cache)\n    elif method == \'im2col\':\n        return max_pool_backward_im2col(dout, real_cache)\n    else:\n        raise ValueError(\'Unrecognized method ""%s""\' % method)\n\n\ndef max_pool_forward_reshape(x, pool_param):\n    """"""\n    A fast implementation of the forward pass for the max pooling layer that uses\n    some clever reshaping.\n\n    This can only be used for square pooling regions that tile the input.\n    """"""\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n    assert pool_height == pool_width == stride, \'Invalid pool params\'\n    assert H % pool_height == 0\n    assert W % pool_height == 0\n    x_reshaped = x.reshape(N, C, H // pool_height, pool_height,\n                           W // pool_width, pool_width)\n    out = x_reshaped.max(axis=3).max(axis=4)\n\n    cache = (x, x_reshaped, out)\n    return out, cache\n\n\ndef max_pool_backward_reshape(dout, cache):\n    """"""\n    A fast implementation of the backward pass for the max pooling layer that\n    uses some clever broadcasting and reshaping.\n\n    This can only be used if the forward pass was computed using\n    max_pool_forward_reshape.\n\n    NOTE: If there are multiple argmaxes, this method will assign gradient to\n    ALL argmax elements of the input rather than picking one. In this case the\n    gradient will actually be incorrect. However this is unlikely to occur in\n    practice, so it shouldn\'t matter much. One possible solution is to split the\n    upstream gradient equally among all argmax elements; this should result in a\n    valid subgradient. You can make this happen by uncommenting the line below;\n    however this results in a significant performance penalty (about 40% slower)\n    and is unlikely to matter in practice so we don\'t do it.\n    """"""\n    x, x_reshaped, out = cache\n\n    dx_reshaped = np.zeros_like(x_reshaped)\n    out_newaxis = out[:, :, :, np.newaxis, :, np.newaxis]\n    mask = (x_reshaped == out_newaxis)\n    dout_newaxis = dout[:, :, :, np.newaxis, :, np.newaxis]\n    dout_broadcast, _ = np.broadcast_arrays(dout_newaxis, dx_reshaped)\n    dx_reshaped[mask] = dout_broadcast[mask]\n    dx_reshaped /= np.sum(mask, axis=(3, 5), keepdims=True)\n    dx = dx_reshaped.reshape(x.shape)\n\n    return dx\n\n\ndef max_pool_forward_im2col(x, pool_param):\n    """"""\n    An implementation of the forward pass for max pooling based on im2col.\n\n    This isn\'t much faster than the naive version, so it should be avoided if\n    possible.\n    """"""\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n\n    assert (H - pool_height) % stride == 0, \'Invalid height\'\n    assert (W - pool_width) % stride == 0, \'Invalid width\'\n\n    out_height = (H - pool_height) // stride + 1\n    out_width = (W - pool_width) // stride + 1\n\n    x_split = x.reshape(N * C, 1, H, W)\n    x_cols = im2col(x_split, pool_height, pool_width, padding=0, stride=stride)\n    x_cols_argmax = np.argmax(x_cols, axis=0)\n    x_cols_max = x_cols[x_cols_argmax, np.arange(x_cols.shape[1])]\n    out = x_cols_max.reshape(out_height, out_width, N, C).transpose(2, 3, 0, 1)\n\n    cache = (x, x_cols, x_cols_argmax, pool_param)\n    return out, cache\n\n\ndef max_pool_backward_im2col(dout, cache):\n    """"""\n    An implementation of the backward pass for max pooling based on im2col.\n\n    This isn\'t much faster than the naive version, so it should be avoided if\n    possible.\n    """"""\n    x, x_cols, x_cols_argmax, pool_param = cache\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n\n    dout_reshaped = dout.transpose(2, 3, 0, 1).flatten()\n    dx_cols = np.zeros_like(x_cols)\n    dx_cols[x_cols_argmax, np.arange(dx_cols.shape[1])] = dout_reshaped\n    dx = col2im_indices(dx_cols, (N * C, 1, H, W), pool_height, pool_width,\n                padding=0, stride=stride)\n    dx = dx.reshape(x.shape)\n\n    return dx\n'"
assignment2/cs231n/gradient_check.py,0,"b'from __future__ import print_function\nfrom builtins import range\n# from past.builtins import xrange\nimport sys\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\nimport numpy as np\nfrom random import randrange\n\ndef eval_numerical_gradient(f, x, verbose=True, h=0.00001):\n    """"""\n    a naive implementation of numerical gradient of f at x\n    - f should be a function that takes a single argument\n    - x is the point (numpy array) to evaluate the gradient at\n    """"""\n\n    fx = f(x) # evaluate function value at original point\n    grad = np.zeros_like(x)\n    # iterate over all indexes in x\n    it = np.nditer(x, flags=[\'multi_index\'], op_flags=[\'readwrite\'])\n    while not it.finished:\n\n        # evaluate function at x+h\n        ix = it.multi_index\n        oldval = x[ix]\n        x[ix] = oldval + h # increment by h\n        fxph = f(x) # evalute f(x + h)\n        x[ix] = oldval - h\n        fxmh = f(x) # evaluate f(x - h)\n        x[ix] = oldval # restore\n\n        # compute the partial derivative with centered formula\n        grad[ix] = (fxph - fxmh) / (2 * h) # the slope\n        if verbose:\n            print(ix, grad[ix])\n        it.iternext() # step to next dimension\n\n    return grad\n\n\ndef eval_numerical_gradient_array(f, x, df, h=1e-5):\n    """"""\n    Evaluate a numeric gradient for a function that accepts a numpy\n    array and returns a numpy array.\n    """"""\n    grad = np.zeros_like(x)\n    it = np.nditer(x, flags=[\'multi_index\'], op_flags=[\'readwrite\'])\n    while not it.finished:\n        ix = it.multi_index\n\n        oldval = x[ix]\n        x[ix] = oldval + h\n        pos = f(x).copy()\n        x[ix] = oldval - h\n        neg = f(x).copy()\n        x[ix] = oldval\n\n        grad[ix] = np.sum((pos - neg) * df) / (2 * h)\n        it.iternext()\n    return grad\n\n\ndef eval_numerical_gradient_blobs(f, inputs, output, h=1e-5):\n    """"""\n    Compute numeric gradients for a function that operates on input\n    and output blobs.\n\n    We assume that f accepts several input blobs as arguments, followed by a\n    blob where outputs will be written. For example, f might be called like:\n\n    f(x, w, out)\n\n    where x and w are input Blobs, and the result of f will be written to out.\n\n    Inputs:\n    - f: function\n    - inputs: tuple of input blobs\n    - output: output blob\n    - h: step size\n    """"""\n    numeric_diffs = []\n    for input_blob in inputs:\n        diff = np.zeros_like(input_blob.diffs)\n        it = np.nditer(input_blob.vals, flags=[\'multi_index\'],\n                       op_flags=[\'readwrite\'])\n        while not it.finished:\n            idx = it.multi_index\n            orig = input_blob.vals[idx]\n\n            input_blob.vals[idx] = orig + h\n            f(*(inputs + (output,)))\n            pos = np.copy(output.vals)\n            input_blob.vals[idx] = orig - h\n            f(*(inputs + (output,)))\n            neg = np.copy(output.vals)\n            input_blob.vals[idx] = orig\n\n            diff[idx] = np.sum((pos - neg) * output.diffs) / (2.0 * h)\n\n            it.iternext()\n        numeric_diffs.append(diff)\n    return numeric_diffs\n\n\ndef eval_numerical_gradient_net(net, inputs, output, h=1e-5):\n    return eval_numerical_gradient_blobs(lambda *args: net.forward(),\n                inputs, output, h=h)\n\n\ndef grad_check_sparse(f, x, analytic_grad, num_checks=10, h=1e-5):\n    """"""\n    sample a few random elements and only return numerical\n    in this dimensions.\n    """"""\n\n    for i in range(num_checks):\n        ix = tuple([randrange(m) for m in x.shape])\n\n        oldval = x[ix]\n        x[ix] = oldval + h # increment by h\n        fxph = f(x) # evaluate f(x + h)\n        x[ix] = oldval - h # increment by h\n        fxmh = f(x) # evaluate f(x - h)\n        x[ix] = oldval # reset\n\n        grad_numerical = (fxph - fxmh) / (2 * h)\n        grad_analytic = analytic_grad[ix]\n        rel_error = (abs(grad_numerical - grad_analytic) /\n                    (abs(grad_numerical) + abs(grad_analytic)))\n        print(\'numerical: %f analytic: %f, relative error: %e\'\n              %(grad_numerical, grad_analytic, rel_error))\n'"
assignment2/cs231n/im2col.py,0,"b'from builtins import range\nimport numpy as np\n\n\ndef get_im2col_indices(x_shape, field_height, field_width, padding=1, stride=1):\n    # First figure out what the size of the output should be\n    N, C, H, W = x_shape\n    assert (H + 2 * padding - field_height) % stride == 0\n    assert (W + 2 * padding - field_height) % stride == 0\n    out_height = (H + 2 * padding - field_height) // stride + 1\n    out_width = (W + 2 * padding - field_width) // stride + 1\n\n    i0 = np.repeat(np.arange(field_height), field_width)\n    i0 = np.tile(i0, C)\n    i1 = stride * np.repeat(np.arange(out_height), out_width)\n    j0 = np.tile(np.arange(field_width), field_height * C)\n    j1 = stride * np.tile(np.arange(out_width), out_height)\n    i = i0.reshape(-1, 1) + i1.reshape(1, -1)\n    j = j0.reshape(-1, 1) + j1.reshape(1, -1)\n\n    k = np.repeat(np.arange(C), field_height * field_width).reshape(-1, 1)\n\n    return k, i, j\n\n\ndef im2col_indices(x, field_height, field_width, padding=1, stride=1):\n    """""" An implementation of im2col based on some fancy indexing """"""\n    # Zero-pad the input\n    p = padding\n    x_padded = np.pad(x, ((0, 0), (0, 0), (p, p), (p, p)), mode=\'constant\')\n\n    k, i, j = get_im2col_indices(x.shape, field_height, field_width, padding,\n                                 stride)\n\n    cols = x_padded[:, k, i, j]\n    C = x.shape[1]\n    cols = cols.transpose(1, 2, 0).reshape(field_height * field_width * C, -1)\n    return cols\n\n\ndef col2im_indices(cols, x_shape, field_height=3, field_width=3, padding=1,\n                   stride=1):\n    """""" An implementation of col2im based on fancy indexing and np.add.at """"""\n    N, C, H, W = x_shape\n    H_padded, W_padded = H + 2 * padding, W + 2 * padding\n    x_padded = np.zeros((N, C, H_padded, W_padded), dtype=cols.dtype)\n    k, i, j = get_im2col_indices(x_shape, field_height, field_width, padding,\n                                 stride)\n    cols_reshaped = cols.reshape(C * field_height * field_width, -1, N)\n    cols_reshaped = cols_reshaped.transpose(2, 0, 1)\n    np.add.at(x_padded, (slice(None), k, i, j), cols_reshaped)\n    if padding == 0:\n        return x_padded\n    return x_padded[:, :, padding:-padding, padding:-padding]\n\npass\n'"
assignment2/cs231n/layer_utils.py,0,"b'pass\nfrom cs231n.layers import *\nfrom cs231n.fast_layers import *\n\n\ndef affine_relu_forward(x, w, b):\n    """"""\n    Convenience layer that performs an affine transform followed by a ReLU\n\n    Inputs:\n    - x: Input to the affine layer\n    - w, b: Weights for the affine layer\n\n    Returns a tuple of:\n    - out: Output from the ReLU\n    - cache: Object to give to the backward pass\n    """"""\n    a, fc_cache = affine_forward(x, w, b)\n    out, relu_cache = relu_forward(a)\n    cache = (fc_cache, relu_cache)\n    return out, cache\n\n\ndef affine_relu_backward(dout, cache):\n    """"""\n    Backward pass for the affine-relu convenience layer\n    """"""\n    fc_cache, relu_cache = cache\n    da = relu_backward(dout, relu_cache)\n    dx, dw, db = affine_backward(da, fc_cache)\n    return dx, dw, db\n\n\ndef conv_relu_forward(x, w, b, conv_param):\n    """"""\n    A convenience layer that performs a convolution followed by a ReLU.\n\n    Inputs:\n    - x: Input to the convolutional layer\n    - w, b, conv_param: Weights and parameters for the convolutional layer\n\n    Returns a tuple of:\n    - out: Output from the ReLU\n    - cache: Object to give to the backward pass\n    """"""\n    a, conv_cache = conv_forward_fast(x, w, b, conv_param)\n    out, relu_cache = relu_forward(a)\n    cache = (conv_cache, relu_cache)\n    return out, cache\n\n\ndef conv_relu_backward(dout, cache):\n    """"""\n    Backward pass for the conv-relu convenience layer.\n    """"""\n    conv_cache, relu_cache = cache\n    da = relu_backward(dout, relu_cache)\n    dx, dw, db = conv_backward_fast(da, conv_cache)\n    return dx, dw, db\n\n\ndef conv_bn_relu_forward(x, w, b, gamma, beta, conv_param, bn_param):\n    a, conv_cache = conv_forward_fast(x, w, b, conv_param)\n    an, bn_cache = spatial_batchnorm_forward(a, gamma, beta, bn_param)\n    out, relu_cache = relu_forward(an)\n    cache = (conv_cache, bn_cache, relu_cache)\n    return out, cache\n\n\ndef conv_bn_relu_backward(dout, cache):\n    conv_cache, bn_cache, relu_cache = cache\n    dan = relu_backward(dout, relu_cache)\n    da, dgamma, dbeta = spatial_batchnorm_backward(dan, bn_cache)\n    dx, dw, db = conv_backward_fast(da, conv_cache)\n    return dx, dw, db, dgamma, dbeta\n\n\ndef conv_relu_pool_forward(x, w, b, conv_param, pool_param):\n    """"""\n    Convenience layer that performs a convolution, a ReLU, and a pool.\n\n    Inputs:\n    - x: Input to the convolutional layer\n    - w, b, conv_param: Weights and parameters for the convolutional layer\n    - pool_param: Parameters for the pooling layer\n\n    Returns a tuple of:\n    - out: Output from the pooling layer\n    - cache: Object to give to the backward pass\n    """"""\n    a, conv_cache = conv_forward_fast(x, w, b, conv_param)\n    s, relu_cache = relu_forward(a)\n    out, pool_cache = max_pool_forward_fast(s, pool_param)\n    cache = (conv_cache, relu_cache, pool_cache)\n    return out, cache\n\n\ndef conv_relu_pool_backward(dout, cache):\n    """"""\n    Backward pass for the conv-relu-pool convenience layer\n    """"""\n    conv_cache, relu_cache, pool_cache = cache\n    ds = max_pool_backward_fast(dout, pool_cache)\n    da = relu_backward(ds, relu_cache)\n    dx, dw, db = conv_backward_fast(da, conv_cache)\n    return dx, dw, db\n'"
assignment2/cs231n/layers.py,0,"b'from builtins import range\nimport numpy as np\n\n\ndef affine_forward(x, w, b):\n    """"""\n    Computes the forward pass for an affine (fully-connected) layer.\n\n    The input x has shape (N, d_1, ..., d_k) and contains a minibatch of N\n    examples, where each example x[i] has shape (d_1, ..., d_k). We will\n    reshape each input into a vector of dimension D = d_1 * ... * d_k, and\n    then transform it to an output vector of dimension M.\n\n    Inputs:\n    - x: A numpy array containing input data, of shape (N, d_1, ..., d_k)\n    - w: A numpy array of weights, of shape (D, M)\n    - b: A numpy array of biases, of shape (M,)\n\n    Returns a tuple of:\n    - out: output, of shape (N, M)\n    - cache: (x, w, b)\n    """"""\n    out = None\n    ###########################################################################\n    # TODO: Implement the affine forward pass. Store the result in out. You   #\n    # will need to reshape the input into rows.                               #\n    ###########################################################################\n\n    out = x.reshape(x.shape[0], -1).dot(w) + b\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    cache = (x, w, b)\n    return out, cache\n\n\ndef affine_backward(dout, cache):\n    """"""\n    Computes the backward pass for an affine layer.\n\n    Inputs:\n    - dout: Upstream derivative, of shape (N, M)\n    - cache: Tuple of:\n      - x: Input data, of shape (N, d_1, ... d_k)\n      - w: Weights, of shape (D, M)\n\n    Returns a tuple of:\n    - dx: Gradient with respect to x, of shape (N, d1, ..., d_k)\n    - dw: Gradient with respect to w, of shape (D, M)\n    - db: Gradient with respect to b, of shape (M,)\n    """"""\n    x, w, b = cache\n    dx, dw, db = None, None, None\n    ###########################################################################\n    # TODO: Implement the affine backward pass.                               #\n    ###########################################################################\n\n    dx = dout.dot(w.T).reshape(x.shape)\n    dw = x.reshape(x.shape[0], -1).T.dot(dout)\n    db = np.sum(dout, axis=0)\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    return dx, dw, db\n\n\ndef relu_forward(x):\n    """"""\n    Computes the forward pass for a layer of rectified linear units (ReLUs).\n\n    Input:\n    - x: Inputs, of any shape\n\n    Returns a tuple of:\n    - out: Output, of the same shape as x\n    - cache: x\n    """"""\n    out = None\n    ###########################################################################\n    # TODO: Implement the ReLU forward pass.                                  #\n    ###########################################################################\n\n    out = np.maximum(0, x)\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    cache = x\n    return out, cache\n\n\ndef relu_backward(dout, cache):\n    """"""\n    Computes the backward pass for a layer of rectified linear units (ReLUs).\n\n    Input:\n    - dout: Upstream derivatives, of any shape\n    - cache: Input x, of same shape as dout\n\n    Returns:\n    - dx: Gradient with respect to x\n    """"""\n    dx, x = None, cache\n    ###########################################################################\n    # TODO: Implement the ReLU backward pass.                                 #\n    ###########################################################################\n\n    dx = (x > 0) * dout\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    return dx\n\n\ndef batchnorm_forward(x, gamma, beta, bn_param):\n    """"""\n    Forward pass for batch normalization.\n\n    During training the sample mean and (uncorrected) sample variance are\n    computed from minibatch statistics and used to normalize the incoming data.\n    During training we also keep an exponentially decaying running mean of the\n    mean and variance of each feature, and these averages are used to normalize\n    data at test-time.\n\n    At each timestep we update the running averages for mean and variance using\n    an exponential decay based on the momentum parameter:\n\n    running_mean = momentum * running_mean + (1 - momentum) * sample_mean\n    running_var = momentum * running_var + (1 - momentum) * sample_var\n\n    Note that the batch normalization paper suggests a different test-time\n    behavior: they compute sample mean and variance for each feature using a\n    large number of training images rather than using a running average. For\n    this implementation we have chosen to use running averages instead since\n    they do not require an additional estimation step; the torch7\n    implementation of batch normalization also uses running averages.\n\n    Input:\n    - x: Data of shape (N, D)\n    - gamma: Scale parameter of shape (D,)\n    - beta: Shift parameter of shape (D,)\n    - bn_param: Dictionary with the following keys:\n      - mode: \'train\' or \'test\'; required\n      - eps: Constant for numeric stability\n      - momentum: Constant for running mean / variance.\n      - running_mean: Array of shape (D,) giving running mean of features\n      - running_var: Array of shape (D,) giving running variance of features\n\n    Returns a tuple of:\n    - out: of shape (N, D)\n    - cache: A tuple of values needed in the backward pass\n    """"""\n    mode = bn_param[\'mode\']\n    eps = bn_param.get(\'eps\', 1e-5)\n    momentum = bn_param.get(\'momentum\', 0.9)\n\n    N, D = x.shape\n    running_mean = bn_param.get(\'running_mean\', np.zeros(D, dtype=x.dtype))\n    running_var = bn_param.get(\'running_var\', np.zeros(D, dtype=x.dtype))\n\n    out, cache = None, None\n    if mode == \'train\':\n        #######################################################################\n        # TODO: Implement the training-time forward pass for batch norm.      #\n        # Use minibatch statistics to compute the mean and variance, use      #\n        # these statistics to normalize the incoming data, and scale and      #\n        # shift the normalized data using gamma and beta.                     #\n        #                                                                     #\n        # You should store the output in the variable out. Any intermediates  #\n        # that you need for the backward pass should be stored in the cache   #\n        # variable.                                                           #\n        #                                                                     #\n        # You should also use your computed sample mean and variance together #\n        # with the momentum variable to update the running mean and running   #\n        # variance, storing your result in the running_mean and running_var   #\n        # variables.                                                          #\n        #######################################################################\n\n        # Mean\n        mu = np.mean(x, axis=0)\n        # Variance\n        var = 1 / float(N) * np.sum((x - mu) ** 2, axis=0)\n        # Normalized Data\n        x_hat = (x - mu) / np.sqrt(var + eps)\n        # Scale and Shift\n        y = gamma * x_hat + beta\n        out = y\n\n        # Make the record of means and variances in running parameters\n        running_mean = momentum * running_mean + (1 - momentum) * mu\n        running_var = momentum * running_var + (1 - momentum) * var\n\n        # TODO: Cache\n        cache = (x_hat, mu, var, eps, gamma, beta, x)\n\n        #######################################################################\n        #                           END OF YOUR CODE                          #\n        #######################################################################\n    elif mode == \'test\':\n        #######################################################################\n        # TODO: Implement the test-time forward pass for batch normalization. #\n        # Use the running mean and variance to normalize the incoming data,   #\n        # then scale and shift the normalized data using gamma and beta.      #\n        # Store the result in the out variable.                               #\n        #######################################################################\n\n        # Normalized Data\n        x_hat = (x - running_mean) / np.sqrt(running_var + eps)\n        # Scale and Shift\n        y = gamma * x_hat + beta\n        out = y\n\n        # TODO: Cache? Nuh...\n\n        #######################################################################\n        #                          END OF YOUR CODE                           #\n        #######################################################################\n    else:\n        raise ValueError(\'Invalid forward batchnorm mode ""%s""\' % mode)\n\n    # Store the updated running means back into bn_param\n    bn_param[\'running_mean\'] = running_mean\n    bn_param[\'running_var\'] = running_var\n\n    return out, cache\n\n\ndef batchnorm_backward(dout, cache):\n    """"""\n    Backward pass for batch normalization.\n\n    For this implementation, you should write out a computation graph for\n    batch normalization on paper and propagate gradients backward through\n    intermediate nodes.\n\n    Inputs:\n    - dout: Upstream derivatives, of shape (N, D)\n    - cache: Variable of intermediates from batchnorm_forward.\n\n    Returns a tuple of:\n    - dx: Gradient with respect to inputs x, of shape (N, D)\n    - dgamma: Gradient with respect to scale parameter gamma, of shape (D,)\n    - dbeta: Gradient with respect to shift parameter beta, of shape (D,)\n    """"""\n\n    ###########################################################################\n    # TODO: Implement the backward pass for batch normalization. Store the    #\n    # results in the dx, dgamma, and dbeta variables.                         #\n    ###########################################################################\n\n    x_hat, mu, var, eps, gamma, beta, x = cache\n    N, D = dout.shape\n\n    dbeta = np.sum(dout, axis=0)\n    dgamma = np.sum(dout * x_hat, axis=0)\n\n    # for dx visit this backprop diagram:\n    # https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html\n    dx_hat = dout * gamma\n    dxmu1 = dx_hat * 1 / np.sqrt(var + eps)\n    divar = np.sum(dx_hat * (x - mu), axis=0)\n    dvar = divar * -1 / 2 * (var + eps) ** (-3/2)\n    dsq = 1 / N * np.ones((N, D)) * dvar\n    dxmu2 = 2 * (x - mu) * dsq\n    dx1 = dxmu1 + dxmu2\n    dmu = -1 * np.sum(dxmu1 + dxmu2, axis=0)\n    dx2 = 1 / N * np.ones((N, D)) * dmu\n    dx = dx1 + dx2\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n\n    return dx, dgamma, dbeta\n\n\ndef batchnorm_backward_alt(dout, cache):\n    """"""\n    Alternative backward pass for batch normalization.\n\n    For this implementation you should work out the derivatives for the batch\n    normalization backward pass on paper and simplify as much as possible. You\n    should be able to derive a simple expression for the backward pass.\n\n    Note: This implementation should expect to receive the same cache variable\n    as batchnorm_backward, but might not use all of the values in the cache.\n\n    Inputs / outputs: Same as batchnorm_backward\n    """"""\n    dx, dgamma, dbeta = None, None, None\n    ###########################################################################\n    # TODO: Implement the backward pass for batch normalization. Store the    #\n    # results in the dx, dgamma, and dbeta variables.                         #\n    #                                                                         #\n    # After computing the gradient with respect to the centered inputs, you   #\n    # should be able to compute gradients with respect to the inputs in a     #\n    # single statement; our implementation fits on a single 80-character line.#\n    ###########################################################################\n    pass\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n\n    return dx, dgamma, dbeta\n\n\ndef dropout_forward(x, dropout_param):\n    """"""\n    Performs the forward pass for (inverted) dropout.\n\n    Inputs:\n    - x: Input data, of any shape\n    - dropout_param: A dictionary with the following keys:\n      - p: Dropout parameter. We drop each neuron output with probability p.\n      - mode: \'test\' or \'train\'. If the mode is train, then perform dropout;\n        if the mode is test, then just return the input.\n      - seed: Seed for the random number generator. Passing seed makes this\n        function deterministic, which is needed for gradient checking but not\n        in real networks.\n\n    Outputs:\n    - out: Array of the same shape as x.\n    - cache: tuple (dropout_param, mask). In training mode, mask is the dropout\n      mask that was used to multiply the input; in test mode, mask is None.\n    """"""\n    p, mode = dropout_param[\'p\'], dropout_param[\'mode\']\n    if \'seed\' in dropout_param:\n        np.random.seed(dropout_param[\'seed\'])\n\n    mask = None\n    out = None\n\n    if mode == \'train\':\n        #######################################################################\n        # TODO: Implement training phase forward pass for inverted dropout.   #\n        # Store the dropout mask in the mask variable.                        #\n        #######################################################################\n\n        mask = (np.random.rand(*x.shape) < p) / p\n        out = x * mask\n\n        #######################################################################\n        #                           END OF YOUR CODE                          #\n        #######################################################################\n    elif mode == \'test\':\n        #######################################################################\n        # TODO: Implement the test phase forward pass for inverted dropout.   #\n        #######################################################################\n\n        out = x\n\n        #######################################################################\n        #                            END OF YOUR CODE                         #\n        #######################################################################\n\n    cache = (dropout_param, mask)\n    out = out.astype(x.dtype, copy=False)\n\n    return out, cache\n\n\ndef dropout_backward(dout, cache):\n    """"""\n    Perform the backward pass for (inverted) dropout.\n\n    Inputs:\n    - dout: Upstream derivatives, of any shape\n    - cache: (dropout_param, mask) from dropout_forward.\n    """"""\n    dropout_param, mask = cache\n    mode = dropout_param[\'mode\']\n\n    dx = None\n    if mode == \'train\':\n        #######################################################################\n        # TODO: Implement training phase backward pass for inverted dropout   #\n        #######################################################################\n\n        dx = dout * mask\n\n        #######################################################################\n        #                          END OF YOUR CODE                           #\n        #######################################################################\n    elif mode == \'test\':\n        dx = dout\n    return dx\n\n\ndef conv_forward_naive(x, w, b, conv_param):\n    """"""\n    A naive implementation of the forward pass for a convolutional layer.\n\n    The input consists of N data points, each with C channels, height H and\n    width W. We convolve each input with F different filters, where each filter\n    spans all C channels and has height HH and width HH.\n\n    Input:\n    - x: Input data of shape (N, C, H, W)\n    - w: Filter weights of shape (F, C, HH, WW)\n    - b: Biases, of shape (F,)\n    - conv_param: A dictionary with the following keys:\n      - \'stride\': The number of pixels between adjacent receptive fields in the\n        horizontal and vertical directions.\n      - \'pad\': The number of pixels that will be used to zero-pad the input.\n\n    Returns a tuple of:\n    - out: Output data, of shape (N, F, H\', W\') where H\' and W\' are given by\n      H\' = 1 + (H + 2 * pad - HH) / stride\n      W\' = 1 + (W + 2 * pad - WW) / stride\n    - cache: (x, w, b, conv_param)\n    """"""\n    out = None\n    ###########################################################################\n    # TODO: Implement the convolutional forward pass.                         #\n    # Hint: you can use the function np.pad for padding.                      #\n    ###########################################################################\n\n    # Extract shapes and constants\n    N, C, H, W = x.shape\n    F, _, HH, WW = w.shape\n    stride = conv_param.get(\'stride\', 1)\n    pad = conv_param.get(\'pad\', 0)\n    # Check for parameter sanity\n    assert (H + 2 * pad - HH) % stride == 0, \'Sanity Check Status: Conv Layer Failed in Height\'\n    assert (W + 2 * pad - WW) % stride == 0, \'Sanity Check Status: Conv Layer Failed in Width\'\n    H_prime = 1 + (H + 2 * pad - HH) // stride\n    W_prime = 1 + (W + 2 * pad - WW) // stride\n    # Padding\n    x_pad = np.pad(x, ((0, 0), (0, 0), (pad, pad), (pad, pad)), \'constant\', constant_values=0)\n    # Construct output\n    out = np.zeros((N, F, H_prime, W_prime))\n    # Naive Loops\n    for n in range(N):\n        for f in range(F):\n            for j in range(0, H_prime):\n                for i in range(0, W_prime):\n                    out[n, f, j, i] = (x_pad[n, :, j*stride:j*stride+HH, i*stride:i*stride+WW] * w[f, :, :, :]).sum() + b[f]\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    cache = (x, w, b, conv_param)\n    return out, cache\n\n\ndef conv_backward_naive(dout, cache):\n    """"""\n    A naive implementation of the backward pass for a convolutional layer.\n\n    Inputs:\n    - dout: Upstream derivatives of shape (N, F, H\', W\')\n    - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive\n\n    Returns a tuple of:\n    - dx: Gradient with respect to x\n    - dw: Gradient with respect to w\n    - db: Gradient with respect to b\n    """"""\n    dx, dw, db = None, None, None\n    ###########################################################################\n    # TODO: Implement the convolutional backward pass.                        #\n    ###########################################################################\n\n    # Extract shapes and constants\n    x, w, b, conv_param = cache\n    N, C, H, W = x.shape\n    F, _, HH, WW = w.shape\n    stride = conv_param.get(\'stride\', 1)\n    pad = conv_param.get(\'pad\', 0)\n    # Padding\n    x_pad = np.pad(x, ((0, 0), (0, 0), (pad, pad), (pad, pad)), \'constant\', constant_values=0)\n    H_prime = 1 + (H + 2 * pad - HH) // stride\n    W_prime = 1 + (W + 2 * pad - WW) // stride\n    # Construct output\n    dx_pad = np.zeros_like(x_pad)\n    dx = np.zeros_like(x)\n    dw = np.zeros_like(w)\n    db = np.zeros_like(b)\n    # Naive Loops\n    for n in range(N):\n        for f in range(F):\n            db[f] += dout[n, f].sum()\n            for j in range(0, H_prime):\n                for i in range(0, W_prime):\n                    dw[f] += x_pad[n, :, j * stride:j * stride + HH, i * stride:i * stride + WW] * dout[n, f, j, i]\n                    dx_pad[n, :, j * stride:j * stride + HH, i * stride:i * stride + WW] += w[f] * dout[n, f, j, i]\n    # Extract dx from dx_pad\n    dx = dx_pad[:, :, pad:pad+H, pad:pad+W]\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    return dx, dw, db\n\n\ndef max_pool_forward_naive(x, pool_param):\n    """"""\n    A naive implementation of the forward pass for a max pooling layer.\n\n    Inputs:\n    - x: Input data, of shape (N, C, H, W)\n    - pool_param: dictionary with the following keys:\n      - \'pool_height\': The height of each pooling region\n      - \'pool_width\': The width of each pooling region\n      - \'stride\': The distance between adjacent pooling regions\n\n    Returns a tuple of:\n    - out: Output data\n    - cache: (x, pool_param)\n    """"""\n    out = None\n    ###########################################################################\n    # TODO: Implement the max pooling forward pass                            #\n    ###########################################################################\n\n    # Extract shapes and constants\n    N, C, H, W = x.shape\n    HH = pool_param.get(\'pool_height\', 2)\n    WW = pool_param.get(\'pool_width\', 2)\n    stride = pool_param.get(\'stride\', 2)\n    assert (H - HH) % stride == 0, \'Sanity Check Status: Max Pool Failed in Height\'\n    assert (W - WW) % stride == 0, \'Sanity Check Status: Max Pool Failed in Width\'\n    H_prime = 1 + (H - HH) // stride\n    W_prime = 1 + (W - WW) // stride\n    # Construct output\n    out = np.zeros((N, C, H_prime, W_prime))\n    # Naive Loops\n    for n in range(N):\n        for j in range(H_prime):\n            for i in range(W_prime):\n                out[n, :, j, i] = np.amax(x[n, :, j*stride:j*stride+HH, i*stride:i*stride+WW], axis=(-1, -2))\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    cache = (x, pool_param)\n    return out, cache\n\n\ndef max_pool_backward_naive(dout, cache):\n    """"""\n    A naive implementation of the backward pass for a max pooling layer.\n\n    Inputs:\n    - dout: Upstream derivatives\n    - cache: A tuple of (x, pool_param) as in the forward pass.\n\n    Returns:\n    - dx: Gradient with respect to x\n    """"""\n    dx = None\n    ###########################################################################\n    # TODO: Implement the max pooling backward pass                           #\n    ###########################################################################\n\n    # Extract constants and shapes\n    x, pool_param = cache\n    N, C, H, W = x.shape\n    HH = pool_param.get(\'pool_height\', 2)\n    WW = pool_param.get(\'pool_width\', 2)\n    stride = pool_param.get(\'stride\', 2)\n    H_prime = 1 + (H - HH) // stride\n    W_prime = 1 + (W - WW) // stride\n    # Construct output\n    dx = np.zeros_like(x)\n    # Naive Loops\n    for n in range(N):\n        for c in range(C):\n            for j in range(H_prime):\n                for i in range(W_prime):\n                    ind = np.argmax(x[n, c, j*stride:j*stride+HH, i*stride:i*stride+WW])\n                    ind1, ind2 = np.unravel_index(ind, (HH, WW))\n                    dx[n, c, j*stride:j*stride+HH, i*stride:i*stride+WW][ind1, ind2] = dout[n, c, j, i]\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    return dx\n\n\ndef spatial_batchnorm_forward(x, gamma, beta, bn_param):\n    """"""\n    Computes the forward pass for spatial batch normalization.\n\n    Inputs:\n    - x: Input data of shape (N, C, H, W)\n    - gamma: Scale parameter, of shape (C,)\n    - beta: Shift parameter, of shape (C,)\n    - bn_param: Dictionary with the following keys:\n      - mode: \'train\' or \'test\'; required\n      - eps: Constant for numeric stability\n      - momentum: Constant for running mean / variance. momentum=0 means that\n        old information is discarded completely at every time step, while\n        momentum=1 means that new information is never incorporated. The\n        default of momentum=0.9 should work well in most situations.\n      - running_mean: Array of shape (D,) giving running mean of features\n      - running_var Array of shape (D,) giving running variance of features\n\n    Returns a tuple of:\n    - out: Output data, of shape (N, C, H, W)\n    - cache: Values needed for the backward pass\n    """"""\n    out, cache = None, None\n\n    ###########################################################################\n    # TODO: Implement the forward pass for spatial batch normalization.       #\n    #                                                                         #\n    # HINT: You can implement spatial batch normalization using the vanilla   #\n    # version of batch normalization defined above. Your implementation should#\n    # be very short; ours is less than five lines.                            #\n    ###########################################################################\n\n    mode = bn_param[\'mode\']\n    eps = bn_param.get(\'eps\', 1e-5)\n    momentum = bn_param.get(\'momentum\', 0.9)\n\n    N, C, H, W = x.shape\n    running_mean = bn_param.get(\'running_mean\', np.zeros((1, C, 1, 1), dtype=x.dtype))\n    running_var = bn_param.get(\'running_var\', np.zeros((1, C, 1, 1), dtype=x.dtype))\n\n    if mode == \'train\':\n        # Mean\n        mu = np.mean(x, axis=(0, 2, 3)).reshape(1, C, 1, 1)\n        # Variance\n        var = 1 / float(N * H * W) * np.sum((x - mu) ** 2, axis=(0, 2, 3)).reshape(1, C, 1, 1)\n        # Normalized Data\n        x_hat = (x - mu) / np.sqrt(var + eps)\n        # Scale and Shift\n        y = gamma.reshape(1, C, 1, 1) * x_hat + beta.reshape(1, C, 1, 1)\n        out = y\n\n        # Make the record of means and variances in running parameters\n        running_mean = momentum * running_mean + (1 - momentum) * mu\n        running_var = momentum * running_var + (1 - momentum) * var\n\n        cache = (x_hat, mu, var, eps, gamma, beta, x)\n\n    elif mode == \'test\':\n        # Normalized Data\n        x_hat = (x - running_mean) / np.sqrt(running_var + eps)\n        # Scale and Shift\n        y = gamma.reshape(1, C, 1, 1) * x_hat + beta.reshape(1, C, 1, 1)\n        out = y\n\n    else:\n        raise ValueError(\'Invalid forward batchnorm mode ""%s""\' % mode)\n\n    # Store the updated running means back into bn_param\n    bn_param[\'running_mean\'] = running_mean\n    bn_param[\'running_var\'] = running_var\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n\n    return out, cache\n\n\ndef spatial_batchnorm_backward(dout, cache):\n    """"""\n    Computes the backward pass for spatial batch normalization.\n\n    Inputs:\n    - dout: Upstream derivatives, of shape (N, C, H, W)\n    - cache: Values from the forward pass\n\n    Returns a tuple of:\n    - dx: Gradient with respect to inputs, of shape (N, C, H, W)\n    - dgamma: Gradient with respect to scale parameter, of shape (C,)\n    - dbeta: Gradient with respect to shift parameter, of shape (C,)\n    """"""\n    dx, dgamma, dbeta = None, None, None\n\n    ###########################################################################\n    # TODO: Implement the backward pass for spatial batch normalization.      #\n    #                                                                         #\n    # HINT: You can implement spatial batch normalization using the vanilla   #\n    # version of batch normalization defined above. Your implementation should#\n    # be very short; ours is less than five lines.                            #\n    ###########################################################################\n\n    x_hat, mu, var, eps, gamma, beta, x = cache\n    N, C, H, W = dout.shape\n\n    dbeta = np.sum(dout, axis=(0, 2, 3))\n    dgamma = np.sum(dout * x_hat, axis=(0, 2, 3))\n\n    # for dx visit this backprop diagram:\n    # https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html\n\n    gamma_reshape = gamma.reshape(1, C, 1, 1)\n    beta_reshape = beta.reshape(1, C, 1, 1)\n    Nt = N * H * W\n\n    dx_hat = dout * gamma_reshape\n    dxmu1 = dx_hat * 1 / np.sqrt(var + eps)\n    divar = np.sum(dx_hat * (x - mu), axis=(0, 2, 3)).reshape(1, C, 1, 1)\n    dvar = divar * -1 / 2 * (var + eps) ** (-3 / 2)\n    dsq = 1 / Nt * np.broadcast_to(np.broadcast_to(np.squeeze(dvar), (W, H, C)).transpose(2, 1, 0), (N, C, H, W))\n    dxmu2 = 2 * (x - mu) * dsq\n    dx1 = dxmu1 + dxmu2\n    dmu = -1 * np.sum(dxmu1 + dxmu2, axis=(0, 2, 3))\n    dx2 = 1 / Nt * np.broadcast_to(np.broadcast_to(np.squeeze(dmu), (W, H, C)).transpose(2, 1, 0), (N, C, H, W))\n    dx = dx1 + dx2\n\n    # \xd8\xad\xd8\xa7\xd8\xac\xdb\x8c\xd8\x8c \xd9\xbe\xd8\xb4\xd9\x85\xd8\xa7\xd9\x85\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n\n    return dx, dgamma, dbeta\n\n\ndef svm_loss(x, y):\n    """"""\n    Computes the loss and gradient using for multiclass SVM classification.\n\n    Inputs:\n    - x: Input data, of shape (N, C) where x[i, j] is the score for the jth\n      class for the ith input.\n    - y: Vector of labels, of shape (N,) where y[i] is the label for x[i] and\n      0 <= y[i] < C\n\n    Returns a tuple of:\n    - loss: Scalar giving the loss\n    - dx: Gradient of the loss with respect to x\n    """"""\n    N = x.shape[0]\n    correct_class_scores = x[np.arange(N), y]\n    margins = np.maximum(0, x - correct_class_scores[:, np.newaxis] + 1.0)\n    margins[np.arange(N), y] = 0\n    loss = np.sum(margins) / N\n    num_pos = np.sum(margins > 0, axis=1)\n    dx = np.zeros_like(x)\n    dx[margins > 0] = 1\n    dx[np.arange(N), y] -= num_pos\n    dx /= N\n    return loss, dx\n\n\ndef softmax_loss(x, y):\n    """"""\n    Computes the loss and gradient for softmax classification.\n\n    Inputs:\n    - x: Input data, of shape (N, C) where x[i, j] is the score for the jth\n      class for the ith input.\n    - y: Vector of labels, of shape (N,) where y[i] is the label for x[i] and\n      0 <= y[i] < C\n\n    Returns a tuple of:\n    - loss: Scalar giving the loss\n    - dx: Gradient of the loss with respect to x\n    """"""\n    shifted_logits = x - np.max(x, axis=1, keepdims=True)\n    Z = np.sum(np.exp(shifted_logits), axis=1, keepdims=True)\n    log_probs = shifted_logits - np.log(Z)\n    probs = np.exp(log_probs)\n    N = x.shape[0]\n    loss = -np.sum(log_probs[np.arange(N), y]) / N\n    dx = probs.copy()\n    dx[np.arange(N), y] -= 1\n    dx /= N\n    return loss, dx\n'"
assignment2/cs231n/optim.py,0,"b'import numpy as np\n\n""""""\nThis file implements various first-order update rules that are commonly used\nfor training neural networks. Each update rule accepts current weights and the\ngradient of the loss with respect to those weights and produces the next set of\nweights. Each update rule has the same interface:\n\ndef update(w, dw, config=None):\n\nInputs:\n  - w: A numpy array giving the current weights.\n  - dw: A numpy array of the same shape as w giving the gradient of the\n    loss with respect to w.\n  - config: A dictionary containing hyperparameter values such as learning\n    rate, momentum, etc. If the update rule requires caching values over many\n    iterations, then config will also hold these cached values.\n\nReturns:\n  - next_w: The next point after the update.\n  - config: The config dictionary to be passed to the next iteration of the\n    update rule.\n\nNOTE: For most update rules, the default learning rate will probably not\nperform well; however the default values of the other hyperparameters should\nwork well for a variety of different problems.\n\nFor efficiency, update rules may perform in-place updates, mutating w and\nsetting next_w equal to w.\n""""""\n\n\ndef sgd(w, dw, config=None):\n    """"""\n    Performs vanilla stochastic gradient descent.\n\n    config format:\n    - learning_rate: Scalar learning rate.\n    """"""\n    if config is None: config = {}\n    config.setdefault(\'learning_rate\', 1e-2)\n\n    w -= config[\'learning_rate\'] * dw\n    return w, config\n\n\ndef sgd_momentum(w, dw, config=None):\n    """"""\n    Performs stochastic gradient descent with momentum.\n\n    config format:\n    - learning_rate: Scalar learning rate.\n    - momentum: Scalar between 0 and 1 giving the momentum value.\n      Setting momentum = 0 reduces to sgd.\n    - velocity: A numpy array of the same shape as w and dw used to store a\n      moving average of the gradients.\n    """"""\n    if config is None: config = {}\n    learning_rate = config.setdefault(\'learning_rate\', 1e-2)\n    mu = config.setdefault(\'momentum\', 0.9)\n    v = config.get(\'velocity\', np.zeros_like(w))\n\n    ###########################################################################\n    # TODO: Implement the momentum update formula. Store the updated value in #\n    # the next_w variable. You should also use and update the velocity v.     #\n    ###########################################################################\n\n    # Momentum update\n    v = mu * v - learning_rate * dw  # integrate velocity\n    next_w = w + v  # integrate position\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n    config[\'velocity\'] = v\n\n    return next_w, config\n\n\n\ndef rmsprop(x, dx, config=None):\n    """"""\n    Uses the RMSProp update rule, which uses a moving average of squared\n    gradient values to set adaptive per-parameter learning rates.\n\n    config format:\n    - learning_rate: Scalar learning rate.\n    - decay_rate: Scalar between 0 and 1 giving the decay rate for the squared\n      gradient cache.\n    - epsilon: Small scalar used for smoothing to avoid dividing by zero.\n    - cache: Moving average of second moments of gradients.\n    """"""\n    if config is None: config = {}\n    learning_rate = config.setdefault(\'learning_rate\', 1e-2)\n    decay_rate = config.setdefault(\'decay_rate\', 0.99)\n    eps = config.setdefault(\'epsilon\', 1e-8)\n    cache = config.setdefault(\'cache\', np.zeros_like(x))\n\n    ###########################################################################\n    # TODO: Implement the RMSprop update formula, storing the next value of x #\n    # in the next_x variable. Don\'t forget to update cache value stored in    #\n    # config[\'cache\'].                                                        #\n    ###########################################################################\n\n    cache = decay_rate * cache + (1 - decay_rate) * dx ** 2\n    next_x = x - learning_rate * dx / (np.sqrt(cache) + eps)\n\n    config[\'cache\'] = cache\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n\n    return next_x, config\n\n\ndef adam(x, dx, config=None):\n    """"""\n    Uses the Adam update rule, which incorporates moving averages of both the\n    gradient and its square and a bias correction term.\n\n    config format:\n    - learning_rate: Scalar learning rate.\n    - beta1: Decay rate for moving average of first moment of gradient.\n    - beta2: Decay rate for moving average of second moment of gradient.\n    - epsilon: Small scalar used for smoothing to avoid dividing by zero.\n    - m: Moving average of gradient.\n    - v: Moving average of squared gradient.\n    - t: Iteration number.\n    """"""\n    if config is None: config = {}\n    learning_rate = config.setdefault(\'learning_rate\', 1e-3)\n    beta1 = config.setdefault(\'beta1\', 0.9)\n    beta2 = config.setdefault(\'beta2\', 0.999)\n    eps = config.setdefault(\'epsilon\', 1e-8)\n    m = config.setdefault(\'m\', np.zeros_like(x))\n    v = config.setdefault(\'v\', np.zeros_like(x))\n    t = config.setdefault(\'t\', 1)\n\n    ###########################################################################\n    # TODO: Implement the Adam update formula, storing the next value of x in #\n    # the next_x variable. Don\'t forget to update the m, v, and t variables   #\n    # stored in config.                                                       #\n    ###########################################################################\n\n    t += 1\n    m = beta1 * m + (1 - beta1) * dx\n    mt = m / (1 - beta1 ** t)\n    v = beta2 * v + (1 - beta2) * (dx ** 2)\n    vt = v / (1 - beta2 ** t)\n    next_x = x - learning_rate * mt / (np.sqrt(vt) + eps)\n\n    config[\'t\'] = t\n    config[\'m\'] = m\n    config[\'v\'] = v\n\n    ###########################################################################\n    #                             END OF YOUR CODE                            #\n    ###########################################################################\n\n    return next_x, config\n'"
assignment2/cs231n/setup.py,0,"b""from distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Build import cythonize\nimport numpy\n\nextensions = [\n  Extension('im2col_cython', ['im2col_cython.pyx'],\n            include_dirs = [numpy.get_include()]\n  ),\n]\n\nsetup(\n    ext_modules = cythonize(extensions),\n)\n"""
assignment2/cs231n/solver.py,0,"b'from __future__ import print_function, division\nfrom future import standard_library\nstandard_library.install_aliases()\nfrom builtins import range\nfrom builtins import object\nimport os\nimport pickle as pickle\n\nimport numpy as np\n\nfrom cs231n import optim\n\n\nclass Solver(object):\n    """"""\n    A Solver encapsulates all the logic necessary for training classification\n    models. The Solver performs stochastic gradient descent using different\n    update rules defined in optim.py.\n\n    The solver accepts both training and validation data and labels so it can\n    periodically check classification accuracy on both training and validation\n    data to watch out for overfitting.\n\n    To train a model, you will first construct a Solver instance, passing the\n    model, dataset, and various options (learning rate, batch size, etc) to the\n    constructor. You will then call the train() method to run the optimization\n    procedure and train the model.\n\n    After the train() method returns, model.params will contain the parameters\n    that performed best on the validation set over the course of training.\n    In addition, the instance variable solver.loss_history will contain a list\n    of all losses encountered during training and the instance variables\n    solver.train_acc_history and solver.val_acc_history will be lists of the\n    accuracies of the model on the training and validation set at each epoch.\n\n    Example usage might look something like this:\n\n    data = {\n      \'X_train\': # training data\n      \'y_train\': # training labels\n      \'X_val\': # validation data\n      \'y_val\': # validation labels\n    }\n    model = MyAwesomeModel(hidden_size=100, reg=10)\n    solver = Solver(model, data,\n                    update_rule=\'sgd\',\n                    optim_config={\n                      \'learning_rate\': 1e-3,\n                    },\n                    lr_decay=0.95,\n                    num_epochs=10, batch_size=100,\n                    print_every=100)\n    solver.train()\n\n\n    A Solver works on a model object that must conform to the following API:\n\n    - model.params must be a dictionary mapping string parameter names to numpy\n      arrays containing parameter values.\n\n    - model.loss(X, y) must be a function that computes training-time loss and\n      gradients, and test-time classification scores, with the following inputs\n      and outputs:\n\n      Inputs:\n      - X: Array giving a minibatch of input data of shape (N, d_1, ..., d_k)\n      - y: Array of labels, of shape (N,) giving labels for X where y[i] is the\n        label for X[i].\n\n      Returns:\n      If y is None, run a test-time forward pass and return:\n      - scores: Array of shape (N, C) giving classification scores for X where\n        scores[i, c] gives the score of class c for X[i].\n\n      If y is not None, run a training time forward and backward pass and\n      return a tuple of:\n      - loss: Scalar giving the loss\n      - grads: Dictionary with the same keys as self.params mapping parameter\n        names to gradients of the loss with respect to those parameters.\n    """"""\n\n    def __init__(self, model, data, **kwargs):\n        """"""\n        Construct a new Solver instance.\n\n        Required arguments:\n        - model: A model object conforming to the API described above\n        - data: A dictionary of training and validation data containing:\n          \'X_train\': Array, shape (N_train, d_1, ..., d_k) of training images\n          \'X_val\': Array, shape (N_val, d_1, ..., d_k) of validation images\n          \'y_train\': Array, shape (N_train,) of labels for training images\n          \'y_val\': Array, shape (N_val,) of labels for validation images\n\n        Optional arguments:\n        - update_rule: A string giving the name of an update rule in optim.py.\n          Default is \'sgd\'.\n        - optim_config: A dictionary containing hyperparameters that will be\n          passed to the chosen update rule. Each update rule requires different\n          hyperparameters (see optim.py) but all update rules require a\n          \'learning_rate\' parameter so that should always be present.\n        - lr_decay: A scalar for learning rate decay; after each epoch the\n          learning rate is multiplied by this value.\n        - batch_size: Size of minibatches used to compute loss and gradient\n          during training.\n        - num_epochs: The number of epochs to run for during training.\n        - print_every: Integer; training losses will be printed every\n          print_every iterations.\n        - verbose: Boolean; if set to false then no output will be printed\n          during training.\n        - num_train_samples: Number of training samples used to check training\n          accuracy; default is 1000; set to None to use entire training set.\n        - num_val_samples: Number of validation samples to use to check val\n          accuracy; default is None, which uses the entire validation set.\n        - checkpoint_name: If not None, then save model checkpoints here every\n          epoch.\n        """"""\n        self.model = model\n        self.X_train = data[\'X_train\']\n        self.y_train = data[\'y_train\']\n        self.X_val = data[\'X_val\']\n        self.y_val = data[\'y_val\']\n\n        # Unpack keyword arguments\n        self.update_rule = kwargs.pop(\'update_rule\', \'sgd\')\n        self.optim_config = kwargs.pop(\'optim_config\', {})\n        self.lr_decay = kwargs.pop(\'lr_decay\', 1.0)\n        self.batch_size = kwargs.pop(\'batch_size\', 100)\n        self.num_epochs = kwargs.pop(\'num_epochs\', 10)\n        self.num_train_samples = kwargs.pop(\'num_train_samples\', 1000)\n        self.num_val_samples = kwargs.pop(\'num_val_samples\', None)\n\n        self.checkpoint_name = kwargs.pop(\'checkpoint_name\', None)\n        self.print_every = kwargs.pop(\'print_every\', 10)\n        self.verbose = kwargs.pop(\'verbose\', True)\n\n        # Throw an error if there are extra keyword arguments\n        if len(kwargs) > 0:\n            extra = \', \'.join(\'""%s""\' % k for k in list(kwargs.keys()))\n            raise ValueError(\'Unrecognized arguments %s\' % extra)\n\n        # Make sure the update rule exists, then replace the string\n        # name with the actual function\n        if not hasattr(optim, self.update_rule):\n            raise ValueError(\'Invalid update_rule ""%s""\' % self.update_rule)\n        self.update_rule = getattr(optim, self.update_rule)\n\n        self._reset()\n\n\n    def _reset(self):\n        """"""\n        Set up some book-keeping variables for optimization. Don\'t call this\n        manually.\n        """"""\n        # Set up some variables for book-keeping\n        self.epoch = 0\n        self.best_val_acc = 0\n        self.best_params = {}\n        self.loss_history = []\n        self.train_acc_history = []\n        self.val_acc_history = []\n\n        # Make a deep copy of the optim_config for each parameter\n        self.optim_configs = {}\n        for p in self.model.params:\n            d = {k: v for k, v in self.optim_config.items()}\n            self.optim_configs[p] = d\n\n\n    def _step(self):\n        """"""\n        Make a single gradient update. This is called by train() and should not\n        be called manually.\n        """"""\n        # Make a minibatch of training data\n        num_train = self.X_train.shape[0]\n        batch_mask = np.random.choice(num_train, self.batch_size)\n        X_batch = self.X_train[batch_mask]\n        y_batch = self.y_train[batch_mask]\n\n        # Compute loss and gradient\n        loss, grads = self.model.loss(X_batch, y_batch)\n        self.loss_history.append(loss)\n\n        # Perform a parameter update\n        for p, w in self.model.params.items():\n            dw = grads[p]\n            config = self.optim_configs[p]\n            next_w, next_config = self.update_rule(w, dw, config)\n            self.model.params[p] = next_w\n            self.optim_configs[p] = next_config\n\n\n    def _save_checkpoint(self):\n        if self.checkpoint_name is None: return\n        checkpoint = {\n          \'model\': self.model,\n          \'update_rule\': self.update_rule,\n          \'lr_decay\': self.lr_decay,\n          \'optim_config\': self.optim_config,\n          \'batch_size\': self.batch_size,\n          \'num_train_samples\': self.num_train_samples,\n          \'num_val_samples\': self.num_val_samples,\n          \'epoch\': self.epoch,\n          \'loss_history\': self.loss_history,\n          \'train_acc_history\': self.train_acc_history,\n          \'val_acc_history\': self.val_acc_history,\n        }\n        filename = \'%s_epoch_%d.pkl\' % (self.checkpoint_name, self.epoch)\n        if self.verbose:\n            print(\'Saving checkpoint to ""%s""\' % filename)\n        with open(filename, \'wb\') as f:\n            pickle.dump(checkpoint, f)\n\n\n    def check_accuracy(self, X, y, num_samples=None, batch_size=100):\n        """"""\n        Check accuracy of the model on the provided data.\n\n        Inputs:\n        - X: Array of data, of shape (N, d_1, ..., d_k)\n        - y: Array of labels, of shape (N,)\n        - num_samples: If not None, subsample the data and only test the model\n          on num_samples datapoints.\n        - batch_size: Split X and y into batches of this size to avoid using\n          too much memory.\n\n        Returns:\n        - acc: Scalar giving the fraction of instances that were correctly\n          classified by the model.\n        """"""\n\n        # Maybe subsample the data\n        N = X.shape[0]\n        if num_samples is not None and N > num_samples:\n            mask = np.random.choice(N, num_samples)\n            N = num_samples\n            X = X[mask]\n            y = y[mask]\n\n        # Compute predictions in batches\n        num_batches = N // batch_size\n        if N % batch_size != 0:\n            num_batches += 1\n        y_pred = []\n        for i in range(num_batches):\n            start = i * batch_size\n            end = (i + 1) * batch_size\n            scores = self.model.loss(X[start:end])\n            y_pred.append(np.argmax(scores, axis=1))\n        y_pred = np.hstack(y_pred)\n        acc = np.mean(y_pred == y)\n\n        return acc\n\n\n    def train(self):\n        """"""\n        Run optimization to train the model.\n        """"""\n        num_train = self.X_train.shape[0]\n        iterations_per_epoch = max(num_train // self.batch_size, 1)\n        num_iterations = self.num_epochs * iterations_per_epoch\n\n        for t in range(num_iterations):\n            self._step()\n\n            # Maybe print training loss\n            if self.verbose and t % self.print_every == 0:\n                print(\'(Iteration %d / %d) loss: %f\' % (\n                       t + 1, num_iterations, self.loss_history[-1]))\n\n            # At the end of every epoch, increment the epoch counter and decay\n            # the learning rate.\n            epoch_end = (t + 1) % iterations_per_epoch == 0\n            if epoch_end:\n                self.epoch += 1\n                for k in self.optim_configs:\n                    self.optim_configs[k][\'learning_rate\'] *= self.lr_decay\n\n            # Check train and val accuracy on the first iteration, the last\n            # iteration, and at the end of each epoch.\n            first_it = (t == 0)\n            last_it = (t == num_iterations - 1)\n            if first_it or last_it or epoch_end:\n                train_acc = self.check_accuracy(self.X_train, self.y_train,\n                    num_samples=self.num_train_samples)\n                val_acc = self.check_accuracy(self.X_val, self.y_val,\n                    num_samples=self.num_val_samples)\n                self.train_acc_history.append(train_acc)\n                self.val_acc_history.append(val_acc)\n                self._save_checkpoint()\n\n                if self.verbose:\n                    print(\'(Epoch %d / %d) train acc: %f; val_acc: %f\' % (\n                           self.epoch, self.num_epochs, train_acc, val_acc))\n\n                # Keep track of the best model\n                if val_acc > self.best_val_acc:\n                    self.best_val_acc = val_acc\n                    self.best_params = {}\n                    for k, v in self.model.params.items():\n                        self.best_params[k] = v.copy()\n\n        # At the end of training swap the best params into the model\n        self.model.params = self.best_params\n'"
assignment2/cs231n/vis_utils.py,0,"b'from builtins import range\nfrom past.builtins import xrange\n\nfrom math import sqrt, ceil\nimport numpy as np\n\ndef visualize_grid(Xs, ubound=255.0, padding=1):\n    """"""\n    Reshape a 4D tensor of image data to a grid for easy visualization.\n\n    Inputs:\n    - Xs: Data of shape (N, H, W, C)\n    - ubound: Output grid will have values scaled to the range [0, ubound]\n    - padding: The number of blank pixels between elements of the grid\n    """"""\n    (N, H, W, C) = Xs.shape\n    grid_size = int(ceil(sqrt(N)))\n    grid_height = H * grid_size + padding * (grid_size - 1)\n    grid_width = W * grid_size + padding * (grid_size - 1)\n    grid = np.zeros((grid_height, grid_width, C))\n    next_idx = 0\n    y0, y1 = 0, H\n    for y in range(grid_size):\n        x0, x1 = 0, W\n        for x in range(grid_size):\n            if next_idx < N:\n                img = Xs[next_idx]\n                low, high = np.min(img), np.max(img)\n                grid[y0:y1, x0:x1] = ubound * (img - low) / (high - low)\n                # grid[y0:y1, x0:x1] = Xs[next_idx]\n                next_idx += 1\n            x0 += W + padding\n            x1 += W + padding\n        y0 += H + padding\n        y1 += H + padding\n    # grid_max = np.max(grid)\n    # grid_min = np.min(grid)\n    # grid = ubound * (grid - grid_min) / (grid_max - grid_min)\n    return grid\n\ndef vis_grid(Xs):\n    """""" visualize a grid of images """"""\n    (N, H, W, C) = Xs.shape\n    A = int(ceil(sqrt(N)))\n    G = np.ones((A*H+A, A*W+A, C), Xs.dtype)\n    G *= np.min(Xs)\n    n = 0\n    for y in range(A):\n        for x in range(A):\n            if n < N:\n                G[y*H+y:(y+1)*H+y, x*W+x:(x+1)*W+x, :] = Xs[n,:,:,:]\n                n += 1\n    # normalize to [0,1]\n    maxg = G.max()\n    ming = G.min()\n    G = (G - ming)/(maxg-ming)\n    return G\n\ndef vis_nn(rows):\n    """""" visualize array of arrays of images """"""\n    N = len(rows)\n    D = len(rows[0])\n    H,W,C = rows[0][0].shape\n    Xs = rows[0][0]\n    G = np.ones((N*H+N, D*W+D, C), Xs.dtype)\n    for y in range(N):\n        for x in range(D):\n            G[y*H+y:(y+1)*H+y, x*W+x:(x+1)*W+x, :] = rows[y][x]\n    # normalize to [0,1]\n    maxg = G.max()\n    ming = G.min()\n    G = (G - ming)/(maxg-ming)\n    return G\n'"
assignment3/cs231n/captioning_solver.py,0,"b'from __future__ import print_function, division\nfrom builtins import range\nfrom builtins import object\nimport numpy as np\n\nfrom cs231n import optim\nfrom cs231n.coco_utils import sample_coco_minibatch\n\n\nclass CaptioningSolver(object):\n    """"""\n    A CaptioningSolver encapsulates all the logic necessary for training\n    image captioning models. The CaptioningSolver performs stochastic gradient\n    descent using different update rules defined in optim.py.\n\n    The solver accepts both training and validataion data and labels so it can\n    periodically check classification accuracy on both training and validation\n    data to watch out for overfitting.\n\n    To train a model, you will first construct a CaptioningSolver instance,\n    passing the model, dataset, and various options (learning rate, batch size,\n    etc) to the constructor. You will then call the train() method to run the\n    optimization procedure and train the model.\n\n    After the train() method returns, model.params will contain the parameters\n    that performed best on the validation set over the course of training.\n    In addition, the instance variable solver.loss_history will contain a list\n    of all losses encountered during training and the instance variables\n    solver.train_acc_history and solver.val_acc_history will be lists containing\n    the accuracies of the model on the training and validation set at each epoch.\n\n    Example usage might look something like this:\n\n    data = load_coco_data()\n    model = MyAwesomeModel(hidden_dim=100)\n    solver = CaptioningSolver(model, data,\n                    update_rule=\'sgd\',\n                    optim_config={\n                      \'learning_rate\': 1e-3,\n                    },\n                    lr_decay=0.95,\n                    num_epochs=10, batch_size=100,\n                    print_every=100)\n    solver.train()\n\n\n    A CaptioningSolver works on a model object that must conform to the following\n    API:\n\n    - model.params must be a dictionary mapping string parameter names to numpy\n      arrays containing parameter values.\n\n    - model.loss(features, captions) must be a function that computes\n      training-time loss and gradients, with the following inputs and outputs:\n\n      Inputs:\n      - features: Array giving a minibatch of features for images, of shape (N, D)\n      - captions: Array of captions for those images, of shape (N, T) where\n        each element is in the range (0, V].\n\n      Returns:\n      - loss: Scalar giving the loss\n      - grads: Dictionary with the same keys as self.params mapping parameter\n        names to gradients of the loss with respect to those parameters.\n    """"""\n\n    def __init__(self, model, data, **kwargs):\n        """"""\n        Construct a new CaptioningSolver instance.\n\n        Required arguments:\n        - model: A model object conforming to the API described above\n        - data: A dictionary of training and validation data from load_coco_data\n\n        Optional arguments:\n        - update_rule: A string giving the name of an update rule in optim.py.\n          Default is \'sgd\'.\n        - optim_config: A dictionary containing hyperparameters that will be\n          passed to the chosen update rule. Each update rule requires different\n          hyperparameters (see optim.py) but all update rules require a\n          \'learning_rate\' parameter so that should always be present.\n        - lr_decay: A scalar for learning rate decay; after each epoch the learning\n          rate is multiplied by this value.\n        - batch_size: Size of minibatches used to compute loss and gradient during\n          training.\n        - num_epochs: The number of epochs to run for during training.\n        - print_every: Integer; training losses will be printed every print_every\n          iterations.\n        - verbose: Boolean; if set to false then no output will be printed during\n          training.\n        """"""\n        self.model = model\n        self.data = data\n\n        # Unpack keyword arguments\n        self.update_rule = kwargs.pop(\'update_rule\', \'sgd\')\n        self.optim_config = kwargs.pop(\'optim_config\', {})\n        self.lr_decay = kwargs.pop(\'lr_decay\', 1.0)\n        self.batch_size = kwargs.pop(\'batch_size\', 100)\n        self.num_epochs = kwargs.pop(\'num_epochs\', 10)\n\n        self.print_every = kwargs.pop(\'print_every\', 10)\n        self.verbose = kwargs.pop(\'verbose\', True)\n\n        # Throw an error if there are extra keyword arguments\n        if len(kwargs) > 0:\n            extra = \', \'.join(\'""%s""\' % k for k in list(kwargs.keys()))\n            raise ValueError(\'Unrecognized arguments %s\' % extra)\n\n        # Make sure the update rule exists, then replace the string\n        # name with the actual function\n        if not hasattr(optim, self.update_rule):\n            raise ValueError(\'Invalid update_rule ""%s""\' % self.update_rule)\n        self.update_rule = getattr(optim, self.update_rule)\n\n        self._reset()\n\n\n    def _reset(self):\n        """"""\n        Set up some book-keeping variables for optimization. Don\'t call this\n        manually.\n        """"""\n        # Set up some variables for book-keeping\n        self.epoch = 0\n        self.best_val_acc = 0\n        self.best_params = {}\n        self.loss_history = []\n        self.train_acc_history = []\n        self.val_acc_history = []\n\n        # Make a deep copy of the optim_config for each parameter\n        self.optim_configs = {}\n        for p in self.model.params:\n            d = {k: v for k, v in self.optim_config.items()}\n            self.optim_configs[p] = d\n\n\n    def _step(self):\n        """"""\n        Make a single gradient update. This is called by train() and should not\n        be called manually.\n        """"""\n        # Make a minibatch of training data\n        minibatch = sample_coco_minibatch(self.data,\n                      batch_size=self.batch_size,\n                      split=\'train\')\n        captions, features, urls = minibatch\n\n        # Compute loss and gradient\n        loss, grads = self.model.loss(features, captions)\n        self.loss_history.append(loss)\n\n        # Perform a parameter update\n        for p, w in self.model.params.items():\n            dw = grads[p]\n            config = self.optim_configs[p]\n            next_w, next_config = self.update_rule(w, dw, config)\n            self.model.params[p] = next_w\n            self.optim_configs[p] = next_config\n\n\n    # TODO: This does nothing right now; maybe implement BLEU?\n    def check_accuracy(self, X, y, num_samples=None, batch_size=100):\n        """"""\n        Check accuracy of the model on the provided data.\n\n        Inputs:\n        - X: Array of data, of shape (N, d_1, ..., d_k)\n        - y: Array of labels, of shape (N,)\n        - num_samples: If not None, subsample the data and only test the model\n          on num_samples datapoints.\n        - batch_size: Split X and y into batches of this size to avoid using too\n          much memory.\n\n        Returns:\n        - acc: Scalar giving the fraction of instances that were correctly\n          classified by the model.\n        """"""\n        return 0.0\n\n        # Maybe subsample the data\n        N = X.shape[0]\n        if num_samples is not None and N > num_samples:\n            mask = np.random.choice(N, num_samples)\n            N = num_samples\n            X = X[mask]\n            y = y[mask]\n\n        # Compute predictions in batches\n        num_batches = N / batch_size\n        if N % batch_size != 0:\n            num_batches += 1\n        y_pred = []\n        for i in range(num_batches):\n            start = i * batch_size\n            end = (i + 1) * batch_size\n            scores = self.model.loss(X[start:end])\n            y_pred.append(np.argmax(scores, axis=1))\n        y_pred = np.hstack(y_pred)\n        acc = np.mean(y_pred == y)\n\n        return acc\n\n\n    def train(self):\n        """"""\n        Run optimization to train the model.\n        """"""\n        num_train = self.data[\'train_captions\'].shape[0]\n        iterations_per_epoch = max(num_train // self.batch_size, 1)\n        num_iterations = self.num_epochs * iterations_per_epoch\n\n        for t in range(num_iterations):\n            self._step()\n\n            # Maybe print training loss\n            if self.verbose and t % self.print_every == 0:\n                print(\'(Iteration %d / %d) loss: %f\' % (\n                       t + 1, num_iterations, self.loss_history[-1]))\n\n            # At the end of every epoch, increment the epoch counter and decay the\n            # learning rate.\n            epoch_end = (t + 1) % iterations_per_epoch == 0\n            if epoch_end:\n                self.epoch += 1\n                for k in self.optim_configs:\n                    self.optim_configs[k][\'learning_rate\'] *= self.lr_decay\n\n            # Check train and val accuracy on the first iteration, the last\n            # iteration, and at the end of each epoch.\n            # TODO: Implement some logic to check Bleu on validation set periodically\n\n        # At the end of training swap the best params into the model\n        # self.model.params = self.best_params\n'"
assignment3/cs231n/coco_utils.py,0,"b""from builtins import range\nimport os, json\nimport numpy as np\nimport h5py\n\nBASE_DIR = 'cs231n/datasets/coco_captioning'\n\ndef load_coco_data(base_dir=BASE_DIR,\n                   max_train=None,\n                   pca_features=True):\n    data = {}\n    caption_file = os.path.join(base_dir, 'coco2014_captions.h5')\n    with h5py.File(caption_file, 'r') as f:\n        for k, v in f.items():\n            data[k] = np.asarray(v)\n\n    if pca_features:\n        train_feat_file = os.path.join(base_dir, 'train2014_vgg16_fc7_pca.h5')\n    else:\n        train_feat_file = os.path.join(base_dir, 'train2014_vgg16_fc7.h5')\n    with h5py.File(train_feat_file, 'r') as f:\n        data['train_features'] = np.asarray(f['features'])\n\n    if pca_features:\n        val_feat_file = os.path.join(base_dir, 'val2014_vgg16_fc7_pca.h5')\n    else:\n        val_feat_file = os.path.join(base_dir, 'val2014_vgg16_fc7.h5')\n    with h5py.File(val_feat_file, 'r') as f:\n        data['val_features'] = np.asarray(f['features'])\n\n    dict_file = os.path.join(base_dir, 'coco2014_vocab.json')\n    with open(dict_file, 'r') as f:\n        dict_data = json.load(f)\n        for k, v in dict_data.items():\n            data[k] = v\n\n    train_url_file = os.path.join(base_dir, 'train2014_urls.txt')\n    with open(train_url_file, 'r') as f:\n        train_urls = np.asarray([line.strip() for line in f])\n    data['train_urls'] = train_urls\n\n    val_url_file = os.path.join(base_dir, 'val2014_urls.txt')\n    with open(val_url_file, 'r') as f:\n        val_urls = np.asarray([line.strip() for line in f])\n    data['val_urls'] = val_urls\n\n    # Maybe subsample the training data\n    if max_train is not None:\n        num_train = data['train_captions'].shape[0]\n        mask = np.random.randint(num_train, size=max_train)\n        data['train_captions'] = data['train_captions'][mask]\n        data['train_image_idxs'] = data['train_image_idxs'][mask]\n\n    return data\n\n\ndef decode_captions(captions, idx_to_word):\n    singleton = False\n    if captions.ndim == 1:\n        singleton = True\n        captions = captions[None]\n    decoded = []\n    N, T = captions.shape\n    for i in range(N):\n        words = []\n        for t in range(T):\n            word = idx_to_word[captions[i, t]]\n            if word != '<NULL>':\n                words.append(word)\n            if word == '<END>':\n                break\n        decoded.append(' '.join(words))\n    if singleton:\n        decoded = decoded[0]\n    return decoded\n\n\ndef sample_coco_minibatch(data, batch_size=100, split='train'):\n    split_size = data['%s_captions' % split].shape[0]\n    mask = np.random.choice(split_size, batch_size)\n    captions = data['%s_captions' % split][mask]\n    image_idxs = data['%s_image_idxs' % split][mask]\n    image_features = data['%s_features' % split][image_idxs]\n    urls = data['%s_urls' % split][image_idxs]\n    return captions, image_features, urls\n"""
assignment3/cs231n/data_utils.py,0,"b'from __future__ import print_function\n\nfrom builtins import range\nfrom six.moves import cPickle as pickle\nimport numpy as np\nimport os\nfrom scipy.misc import imread\nimport platform\n\ndef load_pickle(f):\n    version = platform.python_version_tuple()\n    if version[0] == \'2\':\n        return  pickle.load(f)\n    elif version[0] == \'3\':\n        return  pickle.load(f, encoding=\'latin1\')\n    raise ValueError(""invalid python version: {}"".format(version))\n\ndef load_CIFAR_batch(filename):\n    """""" load single batch of cifar """"""\n    with open(filename, \'rb\') as f:\n        datadict = load_pickle(f)\n        X = datadict[\'data\']\n        Y = datadict[\'labels\']\n        X = X.reshape(10000, 3, 32, 32).transpose(0,2,3,1).astype(""float"")\n        Y = np.array(Y)\n        return X, Y\n\ndef load_CIFAR10(ROOT):\n    """""" load all of cifar """"""\n    xs = []\n    ys = []\n    for b in range(1,6):\n        f = os.path.join(ROOT, \'data_batch_%d\' % (b, ))\n        X, Y = load_CIFAR_batch(f)\n        xs.append(X)\n        ys.append(Y)\n    Xtr = np.concatenate(xs)\n    Ytr = np.concatenate(ys)\n    del X, Y\n    Xte, Yte = load_CIFAR_batch(os.path.join(ROOT, \'test_batch\'))\n    return Xtr, Ytr, Xte, Yte\n\n\ndef get_CIFAR10_data(num_training=49000, num_validation=1000, num_test=1000,\n                     subtract_mean=True):\n    """"""\n    Load the CIFAR-10 dataset from disk and perform preprocessing to prepare\n    it for classifiers. These are the same steps as we used for the SVM, but\n    condensed to a single function.\n    """"""\n    # Load the raw CIFAR-10 data\n    cifar10_dir = \'cs231n/datasets/cifar-10-batches-py\'\n    X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)\n\n    # Subsample the data\n    mask = list(range(num_training, num_training + num_validation))\n    X_val = X_train[mask]\n    y_val = y_train[mask]\n    mask = list(range(num_training))\n    X_train = X_train[mask]\n    y_train = y_train[mask]\n    mask = list(range(num_test))\n    X_test = X_test[mask]\n    y_test = y_test[mask]\n\n    # Normalize the data: subtract the mean image\n    if subtract_mean:\n        mean_image = np.mean(X_train, axis=0)\n        X_train -= mean_image\n        X_val -= mean_image\n        X_test -= mean_image\n\n    # Transpose so that channels come first\n    X_train = X_train.transpose(0, 3, 1, 2).copy()\n    X_val = X_val.transpose(0, 3, 1, 2).copy()\n    X_test = X_test.transpose(0, 3, 1, 2).copy()\n\n    # Package data into a dictionary\n    return {\n      \'X_train\': X_train, \'y_train\': y_train,\n      \'X_val\': X_val, \'y_val\': y_val,\n      \'X_test\': X_test, \'y_test\': y_test,\n    }\n\n\ndef load_tiny_imagenet(path, dtype=np.float32, subtract_mean=True):\n    """"""\n    Load TinyImageNet. Each of TinyImageNet-100-A, TinyImageNet-100-B, and\n    TinyImageNet-200 have the same directory structure, so this can be used\n    to load any of them.\n\n    Inputs:\n    - path: String giving path to the directory to load.\n    - dtype: numpy datatype used to load the data.\n    - subtract_mean: Whether to subtract the mean training image.\n\n    Returns: A dictionary with the following entries:\n    - class_names: A list where class_names[i] is a list of strings giving the\n      WordNet names for class i in the loaded dataset.\n    - X_train: (N_tr, 3, 64, 64) array of training images\n    - y_train: (N_tr,) array of training labels\n    - X_val: (N_val, 3, 64, 64) array of validation images\n    - y_val: (N_val,) array of validation labels\n    - X_test: (N_test, 3, 64, 64) array of testing images.\n    - y_test: (N_test,) array of test labels; if test labels are not available\n      (such as in student code) then y_test will be None.\n    - mean_image: (3, 64, 64) array giving mean training image\n    """"""\n    # First load wnids\n    with open(os.path.join(path, \'wnids.txt\'), \'r\') as f:\n        wnids = [x.strip() for x in f]\n\n    # Map wnids to integer labels\n    wnid_to_label = {wnid: i for i, wnid in enumerate(wnids)}\n\n    # Use words.txt to get names for each class\n    with open(os.path.join(path, \'words.txt\'), \'r\') as f:\n        wnid_to_words = dict(line.split(\'\\t\') for line in f)\n        for wnid, words in wnid_to_words.items():\n            wnid_to_words[wnid] = [w.strip() for w in words.split(\',\')]\n    class_names = [wnid_to_words[wnid] for wnid in wnids]\n\n    # Next load training data.\n    X_train = []\n    y_train = []\n    for i, wnid in enumerate(wnids):\n        if (i + 1) % 20 == 0:\n            print(\'loading training data for synset %d / %d\'\n                  % (i + 1, len(wnids)))\n        # To figure out the filenames we need to open the boxes file\n        boxes_file = os.path.join(path, \'train\', wnid, \'%s_boxes.txt\' % wnid)\n        with open(boxes_file, \'r\') as f:\n            filenames = [x.split(\'\\t\')[0] for x in f]\n        num_images = len(filenames)\n\n        X_train_block = np.zeros((num_images, 3, 64, 64), dtype=dtype)\n        y_train_block = wnid_to_label[wnid] * \\\n                        np.ones(num_images, dtype=np.int64)\n        for j, img_file in enumerate(filenames):\n            img_file = os.path.join(path, \'train\', wnid, \'images\', img_file)\n            img = imread(img_file)\n            if img.ndim == 2:\n        ## grayscale file\n                img.shape = (64, 64, 1)\n            X_train_block[j] = img.transpose(2, 0, 1)\n        X_train.append(X_train_block)\n        y_train.append(y_train_block)\n\n    # We need to concatenate all training data\n    X_train = np.concatenate(X_train, axis=0)\n    y_train = np.concatenate(y_train, axis=0)\n\n    # Next load validation data\n    with open(os.path.join(path, \'val\', \'val_annotations.txt\'), \'r\') as f:\n        img_files = []\n        val_wnids = []\n        for line in f:\n            img_file, wnid = line.split(\'\\t\')[:2]\n            img_files.append(img_file)\n            val_wnids.append(wnid)\n        num_val = len(img_files)\n        y_val = np.array([wnid_to_label[wnid] for wnid in val_wnids])\n        X_val = np.zeros((num_val, 3, 64, 64), dtype=dtype)\n        for i, img_file in enumerate(img_files):\n            img_file = os.path.join(path, \'val\', \'images\', img_file)\n            img = imread(img_file)\n            if img.ndim == 2:\n                img.shape = (64, 64, 1)\n            X_val[i] = img.transpose(2, 0, 1)\n\n    # Next load test images\n    # Students won\'t have test labels, so we need to iterate over files in the\n    # images directory.\n    img_files = os.listdir(os.path.join(path, \'test\', \'images\'))\n    X_test = np.zeros((len(img_files), 3, 64, 64), dtype=dtype)\n    for i, img_file in enumerate(img_files):\n        img_file = os.path.join(path, \'test\', \'images\', img_file)\n        img = imread(img_file)\n        if img.ndim == 2:\n            img.shape = (64, 64, 1)\n        X_test[i] = img.transpose(2, 0, 1)\n\n    y_test = None\n    y_test_file = os.path.join(path, \'test\', \'test_annotations.txt\')\n    if os.path.isfile(y_test_file):\n        with open(y_test_file, \'r\') as f:\n            img_file_to_wnid = {}\n            for line in f:\n                line = line.split(\'\\t\')\n                img_file_to_wnid[line[0]] = line[1]\n        y_test = [wnid_to_label[img_file_to_wnid[img_file]]\n                  for img_file in img_files]\n        y_test = np.array(y_test)\n\n    mean_image = X_train.mean(axis=0)\n    if subtract_mean:\n        X_train -= mean_image[None]\n        X_val -= mean_image[None]\n        X_test -= mean_image[None]\n\n    return {\n      \'class_names\': class_names,\n      \'X_train\': X_train,\n      \'y_train\': y_train,\n      \'X_val\': X_val,\n      \'y_val\': y_val,\n      \'X_test\': X_test,\n      \'y_test\': y_test,\n      \'class_names\': class_names,\n      \'mean_image\': mean_image,\n    }\n\n\ndef load_models(models_dir):\n    """"""\n    Load saved models from disk. This will attempt to unpickle all files in a\n    directory; any files that give errors on unpickling (such as README.txt)\n    will be skipped.\n\n    Inputs:\n    - models_dir: String giving the path to a directory containing model files.\n      Each model file is a pickled dictionary with a \'model\' field.\n\n    Returns:\n    A dictionary mapping model file names to models.\n    """"""\n    models = {}\n    for model_file in os.listdir(models_dir):\n        with open(os.path.join(models_dir, model_file), \'rb\') as f:\n            try:\n                models[model_file] = load_pickle(f)[\'model\']\n            except pickle.UnpicklingError:\n                continue\n    return models\n\n\ndef load_imagenet_val(num=None):\n    """"""Load a handful of validation images from ImageNet.\n\n    Inputs:\n    - num: Number of images to load (max of 25)\n\n    Returns:\n    - X: numpy array with shape [num, 224, 224, 3]\n    - y: numpy array of integer image labels, shape [num]\n    - class_names: dict mapping integer label to class name\n    """"""\n    imagenet_fn = \'cs231n/datasets/imagenet_val_25.npz\'\n    if not os.path.isfile(imagenet_fn):\n      print(\'file %s not found\' % imagenet_fn)\n      print(\'Run the following:\')\n      print(\'cd cs231n/datasets\')\n      print(\'bash get_imagenet_val.sh\')\n      assert False, \'Need to download imagenet_val_25.npz\'\n    f = np.load(imagenet_fn)\n    X = f[\'X\']\n    y = f[\'y\']\n    class_names = f[\'label_map\'].item()\n    if num is not None:\n        X = X[:num]\n        y = y[:num]\n    return X, y, class_names\n'"
assignment3/cs231n/fast_layers.py,0,"b'from __future__ import print_function\nimport numpy as np\ntry:\n    from cs231n.im2col_cython import col2im_cython, im2col_cython\n    from cs231n.im2col_cython import col2im_6d_cython\nexcept ImportError:\n    print(\'run the following from the cs231n directory and try again:\')\n    print(\'python setup.py build_ext --inplace\')\n    print(\'You may also need to restart your iPython kernel\')\n\nfrom cs231n.im2col import *\n\n\ndef conv_forward_im2col(x, w, b, conv_param):\n    """"""\n    A fast implementation of the forward pass for a convolutional layer\n    based on im2col and col2im.\n    """"""\n    N, C, H, W = x.shape\n    num_filters, _, filter_height, filter_width = w.shape\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    # Check dimensions\n    assert (W + 2 * pad - filter_width) % stride == 0, \'width does not work\'\n    assert (H + 2 * pad - filter_height) % stride == 0, \'height does not work\'\n\n    # Create output\n    out_height = (H + 2 * pad - filter_height) // stride + 1\n    out_width = (W + 2 * pad - filter_width) // stride + 1\n    out = np.zeros((N, num_filters, out_height, out_width), dtype=x.dtype)\n\n    # x_cols = im2col_indices(x, w.shape[2], w.shape[3], pad, stride)\n    x_cols = im2col_cython(x, w.shape[2], w.shape[3], pad, stride)\n    res = w.reshape((w.shape[0], -1)).dot(x_cols) + b.reshape(-1, 1)\n\n    out = res.reshape(w.shape[0], out.shape[2], out.shape[3], x.shape[0])\n    out = out.transpose(3, 0, 1, 2)\n\n    cache = (x, w, b, conv_param, x_cols)\n    return out, cache\n\n\ndef conv_forward_strides(x, w, b, conv_param):\n    N, C, H, W = x.shape\n    F, _, HH, WW = w.shape\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    # Check dimensions\n    #assert (W + 2 * pad - WW) % stride == 0, \'width does not work\'\n    #assert (H + 2 * pad - HH) % stride == 0, \'height does not work\'\n\n    # Pad the input\n    p = pad\n    x_padded = np.pad(x, ((0, 0), (0, 0), (p, p), (p, p)), mode=\'constant\')\n\n    # Figure out output dimensions\n    H += 2 * pad\n    W += 2 * pad\n    out_h = (H - HH) // stride + 1\n    out_w = (W - WW) // stride + 1\n\n    # Perform an im2col operation by picking clever strides\n    shape = (C, HH, WW, N, out_h, out_w)\n    strides = (H * W, W, 1, C * H * W, stride * W, stride)\n    strides = x.itemsize * np.array(strides)\n    x_stride = np.lib.stride_tricks.as_strided(x_padded,\n                  shape=shape, strides=strides)\n    x_cols = np.ascontiguousarray(x_stride)\n    x_cols.shape = (C * HH * WW, N * out_h * out_w)\n\n    # Now all our convolutions are a big matrix multiply\n    res = w.reshape(F, -1).dot(x_cols) + b.reshape(-1, 1)\n\n    # Reshape the output\n    res.shape = (F, N, out_h, out_w)\n    out = res.transpose(1, 0, 2, 3)\n\n    # Be nice and return a contiguous array\n    # The old version of conv_forward_fast doesn\'t do this, so for a fair\n    # comparison we won\'t either\n    out = np.ascontiguousarray(out)\n\n    cache = (x, w, b, conv_param, x_cols)\n    return out, cache\n\n\ndef conv_backward_strides(dout, cache):\n    x, w, b, conv_param, x_cols = cache\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    N, C, H, W = x.shape\n    F, _, HH, WW = w.shape\n    _, _, out_h, out_w = dout.shape\n\n    db = np.sum(dout, axis=(0, 2, 3))\n\n    dout_reshaped = dout.transpose(1, 0, 2, 3).reshape(F, -1)\n    dw = dout_reshaped.dot(x_cols.T).reshape(w.shape)\n\n    dx_cols = w.reshape(F, -1).T.dot(dout_reshaped)\n    dx_cols.shape = (C, HH, WW, N, out_h, out_w)\n    dx = col2im_6d_cython(dx_cols, N, C, H, W, HH, WW, pad, stride)\n\n    return dx, dw, db\n\n\ndef conv_backward_im2col(dout, cache):\n    """"""\n    A fast implementation of the backward pass for a convolutional layer\n    based on im2col and col2im.\n    """"""\n    x, w, b, conv_param, x_cols = cache\n    stride, pad = conv_param[\'stride\'], conv_param[\'pad\']\n\n    db = np.sum(dout, axis=(0, 2, 3))\n\n    num_filters, _, filter_height, filter_width = w.shape\n    dout_reshaped = dout.transpose(1, 2, 3, 0).reshape(num_filters, -1)\n    dw = dout_reshaped.dot(x_cols.T).reshape(w.shape)\n\n    dx_cols = w.reshape(num_filters, -1).T.dot(dout_reshaped)\n    # dx = col2im_indices(dx_cols, x.shape, filter_height, filter_width, pad, stride)\n    dx = col2im_cython(dx_cols, x.shape[0], x.shape[1], x.shape[2], x.shape[3],\n                       filter_height, filter_width, pad, stride)\n\n    return dx, dw, db\n\n\nconv_forward_fast = conv_forward_strides\nconv_backward_fast = conv_backward_strides\n\n\ndef max_pool_forward_fast(x, pool_param):\n    """"""\n    A fast implementation of the forward pass for a max pooling layer.\n\n    This chooses between the reshape method and the im2col method. If the pooling\n    regions are square and tile the input image, then we can use the reshape\n    method which is very fast. Otherwise we fall back on the im2col method, which\n    is not much faster than the naive method.\n    """"""\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n\n    same_size = pool_height == pool_width == stride\n    tiles = H % pool_height == 0 and W % pool_width == 0\n    if same_size and tiles:\n        out, reshape_cache = max_pool_forward_reshape(x, pool_param)\n        cache = (\'reshape\', reshape_cache)\n    else:\n        out, im2col_cache = max_pool_forward_im2col(x, pool_param)\n        cache = (\'im2col\', im2col_cache)\n    return out, cache\n\n\ndef max_pool_backward_fast(dout, cache):\n    """"""\n    A fast implementation of the backward pass for a max pooling layer.\n\n    This switches between the reshape method an the im2col method depending on\n    which method was used to generate the cache.\n    """"""\n    method, real_cache = cache\n    if method == \'reshape\':\n        return max_pool_backward_reshape(dout, real_cache)\n    elif method == \'im2col\':\n        return max_pool_backward_im2col(dout, real_cache)\n    else:\n        raise ValueError(\'Unrecognized method ""%s""\' % method)\n\n\ndef max_pool_forward_reshape(x, pool_param):\n    """"""\n    A fast implementation of the forward pass for the max pooling layer that uses\n    some clever reshaping.\n\n    This can only be used for square pooling regions that tile the input.\n    """"""\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n    assert pool_height == pool_width == stride, \'Invalid pool params\'\n    assert H % pool_height == 0\n    assert W % pool_height == 0\n    x_reshaped = x.reshape(N, C, H // pool_height, pool_height,\n                           W // pool_width, pool_width)\n    out = x_reshaped.max(axis=3).max(axis=4)\n\n    cache = (x, x_reshaped, out)\n    return out, cache\n\n\ndef max_pool_backward_reshape(dout, cache):\n    """"""\n    A fast implementation of the backward pass for the max pooling layer that\n    uses some clever broadcasting and reshaping.\n\n    This can only be used if the forward pass was computed using\n    max_pool_forward_reshape.\n\n    NOTE: If there are multiple argmaxes, this method will assign gradient to\n    ALL argmax elements of the input rather than picking one. In this case the\n    gradient will actually be incorrect. However this is unlikely to occur in\n    practice, so it shouldn\'t matter much. One possible solution is to split the\n    upstream gradient equally among all argmax elements; this should result in a\n    valid subgradient. You can make this happen by uncommenting the line below;\n    however this results in a significant performance penalty (about 40% slower)\n    and is unlikely to matter in practice so we don\'t do it.\n    """"""\n    x, x_reshaped, out = cache\n\n    dx_reshaped = np.zeros_like(x_reshaped)\n    out_newaxis = out[:, :, :, np.newaxis, :, np.newaxis]\n    mask = (x_reshaped == out_newaxis)\n    dout_newaxis = dout[:, :, :, np.newaxis, :, np.newaxis]\n    dout_broadcast, _ = np.broadcast_arrays(dout_newaxis, dx_reshaped)\n    dx_reshaped[mask] = dout_broadcast[mask]\n    dx_reshaped /= np.sum(mask, axis=(3, 5), keepdims=True)\n    dx = dx_reshaped.reshape(x.shape)\n\n    return dx\n\n\ndef max_pool_forward_im2col(x, pool_param):\n    """"""\n    An implementation of the forward pass for max pooling based on im2col.\n\n    This isn\'t much faster than the naive version, so it should be avoided if\n    possible.\n    """"""\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n\n    assert (H - pool_height) % stride == 0, \'Invalid height\'\n    assert (W - pool_width) % stride == 0, \'Invalid width\'\n\n    out_height = (H - pool_height) // stride + 1\n    out_width = (W - pool_width) // stride + 1\n\n    x_split = x.reshape(N * C, 1, H, W)\n    x_cols = im2col(x_split, pool_height, pool_width, padding=0, stride=stride)\n    x_cols_argmax = np.argmax(x_cols, axis=0)\n    x_cols_max = x_cols[x_cols_argmax, np.arange(x_cols.shape[1])]\n    out = x_cols_max.reshape(out_height, out_width, N, C).transpose(2, 3, 0, 1)\n\n    cache = (x, x_cols, x_cols_argmax, pool_param)\n    return out, cache\n\n\ndef max_pool_backward_im2col(dout, cache):\n    """"""\n    An implementation of the backward pass for max pooling based on im2col.\n\n    This isn\'t much faster than the naive version, so it should be avoided if\n    possible.\n    """"""\n    x, x_cols, x_cols_argmax, pool_param = cache\n    N, C, H, W = x.shape\n    pool_height, pool_width = pool_param[\'pool_height\'], pool_param[\'pool_width\']\n    stride = pool_param[\'stride\']\n\n    dout_reshaped = dout.transpose(2, 3, 0, 1).flatten()\n    dx_cols = np.zeros_like(x_cols)\n    dx_cols[x_cols_argmax, np.arange(dx_cols.shape[1])] = dout_reshaped\n    dx = col2im_indices(dx_cols, (N * C, 1, H, W), pool_height, pool_width,\n                padding=0, stride=stride)\n    dx = dx.reshape(x.shape)\n\n    return dx\n'"
assignment3/cs231n/gradient_check.py,0,"b'from __future__ import print_function\nfrom builtins import range\nfrom past.builtins import xrange\n\nimport numpy as np\nfrom random import randrange\n\ndef eval_numerical_gradient(f, x, verbose=True, h=0.00001):\n    """"""\n    a naive implementation of numerical gradient of f at x\n    - f should be a function that takes a single argument\n    - x is the point (numpy array) to evaluate the gradient at\n    """"""\n\n    fx = f(x) # evaluate function value at original point\n    grad = np.zeros_like(x)\n    # iterate over all indexes in x\n    it = np.nditer(x, flags=[\'multi_index\'], op_flags=[\'readwrite\'])\n    while not it.finished:\n\n        # evaluate function at x+h\n        ix = it.multi_index\n        oldval = x[ix]\n        x[ix] = oldval + h # increment by h\n        fxph = f(x) # evalute f(x + h)\n        x[ix] = oldval - h\n        fxmh = f(x) # evaluate f(x - h)\n        x[ix] = oldval # restore\n\n        # compute the partial derivative with centered formula\n        grad[ix] = (fxph - fxmh) / (2 * h) # the slope\n        if verbose:\n            print(ix, grad[ix])\n        it.iternext() # step to next dimension\n\n    return grad\n\n\ndef eval_numerical_gradient_array(f, x, df, h=1e-5):\n    """"""\n    Evaluate a numeric gradient for a function that accepts a numpy\n    array and returns a numpy array.\n    """"""\n    grad = np.zeros_like(x)\n    it = np.nditer(x, flags=[\'multi_index\'], op_flags=[\'readwrite\'])\n    while not it.finished:\n        ix = it.multi_index\n\n        oldval = x[ix]\n        x[ix] = oldval + h\n        pos = f(x).copy()\n        x[ix] = oldval - h\n        neg = f(x).copy()\n        x[ix] = oldval\n\n        grad[ix] = np.sum((pos - neg) * df) / (2 * h)\n        it.iternext()\n    return grad\n\n\ndef eval_numerical_gradient_blobs(f, inputs, output, h=1e-5):\n    """"""\n    Compute numeric gradients for a function that operates on input\n    and output blobs.\n\n    We assume that f accepts several input blobs as arguments, followed by a\n    blob where outputs will be written. For example, f might be called like:\n\n    f(x, w, out)\n\n    where x and w are input Blobs, and the result of f will be written to out.\n\n    Inputs:\n    - f: function\n    - inputs: tuple of input blobs\n    - output: output blob\n    - h: step size\n    """"""\n    numeric_diffs = []\n    for input_blob in inputs:\n        diff = np.zeros_like(input_blob.diffs)\n        it = np.nditer(input_blob.vals, flags=[\'multi_index\'],\n                       op_flags=[\'readwrite\'])\n        while not it.finished:\n            idx = it.multi_index\n            orig = input_blob.vals[idx]\n\n            input_blob.vals[idx] = orig + h\n            f(*(inputs + (output,)))\n            pos = np.copy(output.vals)\n            input_blob.vals[idx] = orig - h\n            f(*(inputs + (output,)))\n            neg = np.copy(output.vals)\n            input_blob.vals[idx] = orig\n\n            diff[idx] = np.sum((pos - neg) * output.diffs) / (2.0 * h)\n\n            it.iternext()\n        numeric_diffs.append(diff)\n    return numeric_diffs\n\n\ndef eval_numerical_gradient_net(net, inputs, output, h=1e-5):\n    return eval_numerical_gradient_blobs(lambda *args: net.forward(),\n                inputs, output, h=h)\n\n\ndef grad_check_sparse(f, x, analytic_grad, num_checks=10, h=1e-5):\n    """"""\n    sample a few random elements and only return numerical\n    in this dimensions.\n    """"""\n\n    for i in range(num_checks):\n        ix = tuple([randrange(m) for m in x.shape])\n\n        oldval = x[ix]\n        x[ix] = oldval + h # increment by h\n        fxph = f(x) # evaluate f(x + h)\n        x[ix] = oldval - h # increment by h\n        fxmh = f(x) # evaluate f(x - h)\n        x[ix] = oldval # reset\n\n        grad_numerical = (fxph - fxmh) / (2 * h)\n        grad_analytic = analytic_grad[ix]\n        rel_error = (abs(grad_numerical - grad_analytic) /\n                    (abs(grad_numerical) + abs(grad_analytic)))\n        print(\'numerical: %f analytic: %f, relative error: %e\'\n              %(grad_numerical, grad_analytic, rel_error))\n'"
assignment3/cs231n/im2col.py,0,"b'from builtins import range\nimport numpy as np\n\n\ndef get_im2col_indices(x_shape, field_height, field_width, padding=1, stride=1):\n    # First figure out what the size of the output should be\n    N, C, H, W = x_shape\n    assert (H + 2 * padding - field_height) % stride == 0\n    assert (W + 2 * padding - field_height) % stride == 0\n    out_height = (H + 2 * padding - field_height) / stride + 1\n    out_width = (W + 2 * padding - field_width) / stride + 1\n\n    i0 = np.repeat(np.arange(field_height), field_width)\n    i0 = np.tile(i0, C)\n    i1 = stride * np.repeat(np.arange(out_height), out_width)\n    j0 = np.tile(np.arange(field_width), field_height * C)\n    j1 = stride * np.tile(np.arange(out_width), out_height)\n    i = i0.reshape(-1, 1) + i1.reshape(1, -1)\n    j = j0.reshape(-1, 1) + j1.reshape(1, -1)\n\n    k = np.repeat(np.arange(C), field_height * field_width).reshape(-1, 1)\n\n    return (k, i, j)\n\n\ndef im2col_indices(x, field_height, field_width, padding=1, stride=1):\n    """""" An implementation of im2col based on some fancy indexing """"""\n    # Zero-pad the input\n    p = padding\n    x_padded = np.pad(x, ((0, 0), (0, 0), (p, p), (p, p)), mode=\'constant\')\n\n    k, i, j = get_im2col_indices(x.shape, field_height, field_width, padding,\n                                 stride)\n\n    cols = x_padded[:, k, i, j]\n    C = x.shape[1]\n    cols = cols.transpose(1, 2, 0).reshape(field_height * field_width * C, -1)\n    return cols\n\n\ndef col2im_indices(cols, x_shape, field_height=3, field_width=3, padding=1,\n                   stride=1):\n    """""" An implementation of col2im based on fancy indexing and np.add.at """"""\n    N, C, H, W = x_shape\n    H_padded, W_padded = H + 2 * padding, W + 2 * padding\n    x_padded = np.zeros((N, C, H_padded, W_padded), dtype=cols.dtype)\n    k, i, j = get_im2col_indices(x_shape, field_height, field_width, padding,\n                                 stride)\n    cols_reshaped = cols.reshape(C * field_height * field_width, -1, N)\n    cols_reshaped = cols_reshaped.transpose(2, 0, 1)\n    np.add.at(x_padded, (slice(None), k, i, j), cols_reshaped)\n    if padding == 0:\n        return x_padded\n    return x_padded[:, :, padding:-padding, padding:-padding]\n\npass\n'"
assignment3/cs231n/image_utils.py,0,"b'from __future__ import print_function\nfrom future import standard_library\nstandard_library.install_aliases()\nfrom builtins import range\nimport urllib.request, urllib.error, urllib.parse, os, tempfile\n\nimport numpy as np\nfrom scipy.misc import imread, imresize\n\n""""""\nUtility functions used for viewing and processing images.\n""""""\n\ndef blur_image(X):\n    """"""\n    A very gentle image blurring operation, to be used as a regularizer for\n    image generation.\n\n    Inputs:\n    - X: Image data of shape (N, 3, H, W)\n\n    Returns:\n    - X_blur: Blurred version of X, of shape (N, 3, H, W)\n    """"""\n    from cs231n.fast_layers import conv_forward_fast\n    w_blur = np.zeros((3, 3, 3, 3))\n    b_blur = np.zeros(3)\n    blur_param = {\'stride\': 1, \'pad\': 1}\n    for i in range(3):\n        w_blur[i, i] = np.asarray([[1, 2, 1], [2, 188, 2], [1, 2, 1]],\n                                  dtype=np.float32)\n    w_blur /= 200.0\n    return conv_forward_fast(X, w_blur, b_blur, blur_param)[0]\n\n\nSQUEEZENET_MEAN = np.array([0.485, 0.456, 0.406], dtype=np.float32)\nSQUEEZENET_STD = np.array([0.229, 0.224, 0.225], dtype=np.float32)\n\ndef preprocess_image(img):\n    """"""Preprocess an image for squeezenet.\n    \n    Subtracts the pixel mean and divides by the standard deviation.\n    """"""\n    return (img.astype(np.float32)/255.0 - SQUEEZENET_MEAN) / SQUEEZENET_STD\n\n\ndef deprocess_image(img, rescale=False):\n    """"""Undo preprocessing on an image and convert back to uint8.""""""\n    img = (img * SQUEEZENET_STD + SQUEEZENET_MEAN)\n    if rescale:\n        vmin, vmax = img.min(), img.max()\n        img = (img - vmin) / (vmax - vmin)\n    return np.clip(255 * img, 0.0, 255.0).astype(np.uint8)\n\n\ndef image_from_url(url):\n    """"""\n    Read an image from a URL. Returns a numpy array with the pixel data.\n    We write the image to a temporary file then read it back. Kinda gross.\n    """"""\n    try:\n        f = urllib.request.urlopen(url)\n        _, fname = tempfile.mkstemp()\n        with open(fname, \'wb\') as ff:\n            ff.write(f.read())\n        img = imread(fname)\n        os.remove(fname)\n        return img\n    except urllib.error.URLError as e:\n        print(\'URL Error: \', e.reason, url)\n    except urllib.error.HTTPError as e:\n        print(\'HTTP Error: \', e.code, url)\n\n\ndef load_image(filename, size=None):\n    """"""Load and resize an image from disk.\n\n    Inputs:\n    - filename: path to file\n    - size: size of shortest dimension after rescaling\n    """"""\n    img = imread(filename)\n    if size is not None:\n        orig_shape = np.array(img.shape[:2])\n        min_idx = np.argmin(orig_shape)\n        scale_factor = float(size) / orig_shape[min_idx]\n        new_shape = (orig_shape * scale_factor).astype(int)\n        img = imresize(img, scale_factor)\n    return img\n'"
assignment3/cs231n/layer_utils.py,0,"b'from cs231n.layers import *\nfrom cs231n.fast_layers import *\n\n\ndef affine_relu_forward(x, w, b):\n    """"""\n    Convenience layer that perorms an affine transform followed by a ReLU\n\n    Inputs:\n    - x: Input to the affine layer\n    - w, b: Weights for the affine layer\n\n    Returns a tuple of:\n    - out: Output from the ReLU\n    - cache: Object to give to the backward pass\n    """"""\n    a, fc_cache = affine_forward(x, w, b)\n    out, relu_cache = relu_forward(a)\n    cache = (fc_cache, relu_cache)\n    return out, cache\n\n\ndef affine_relu_backward(dout, cache):\n    """"""\n    Backward pass for the affine-relu convenience layer\n    """"""\n    fc_cache, relu_cache = cache\n    da = relu_backward(dout, relu_cache)\n    dx, dw, db = affine_backward(da, fc_cache)\n    return dx, dw, db\n\n\ndef affine_bn_relu_forward(x, w, b, gamma, beta, bn_param):\n    """"""\n    Convenience layer that performs an affine transform, batch normalization,\n    and ReLU.\n\n    Inputs:\n    - x: Array of shape (N, D1); input to the affine layer\n    - w, b: Arrays of shape (D2, D2) and (D2,) giving the weight and bias for\n      the affine transform.\n    - gamma, beta: Arrays of shape (D2,) and (D2,) giving scale and shift\n      parameters for batch normalization.\n    - bn_param: Dictionary of parameters for batch normalization.\n\n    Returns:\n    - out: Output from ReLU, of shape (N, D2)\n    - cache: Object to give to the backward pass.\n    """"""\n    a, fc_cache = affine_forward(x, w, b)\n    a_bn, bn_cache = batchnorm_forward(a, gamma, beta, bn_param)\n    out, relu_cache = relu_forward(a_bn)\n    cache = (fc_cache, bn_cache, relu_cache)\n    return out, cache\n\n\ndef affine_bn_relu_backward(dout, cache):\n    """"""\n    Backward pass for the affine-batchnorm-relu convenience layer.\n    """"""\n    fc_cache, bn_cache, relu_cache = cache\n    da_bn = relu_backward(dout, relu_cache)\n    da, dgamma, dbeta = batchnorm_backward(da_bn, bn_cache)\n    dx, dw, db = affine_backward(da, fc_cache)\n    return dx, dw, db, dgamma, dbeta\n\n\ndef conv_relu_forward(x, w, b, conv_param):\n    """"""\n    A convenience layer that performs a convolution followed by a ReLU.\n\n    Inputs:\n    - x: Input to the convolutional layer\n    - w, b, conv_param: Weights and parameters for the convolutional layer\n\n    Returns a tuple of:\n    - out: Output from the ReLU\n    - cache: Object to give to the backward pass\n    """"""\n    a, conv_cache = conv_forward_fast(x, w, b, conv_param)\n    out, relu_cache = relu_forward(a)\n    cache = (conv_cache, relu_cache)\n    return out, cache\n\n\ndef conv_relu_backward(dout, cache):\n    """"""\n    Backward pass for the conv-relu convenience layer.\n    """"""\n    conv_cache, relu_cache = cache\n    da = relu_backward(dout, relu_cache)\n    dx, dw, db = conv_backward_fast(da, conv_cache)\n    return dx, dw, db\n\n\ndef conv_bn_relu_forward(x, w, b, gamma, beta, conv_param, bn_param):\n    a, conv_cache = conv_forward_fast(x, w, b, conv_param)\n    an, bn_cache = spatial_batchnorm_forward(a, gamma, beta, bn_param)\n    out, relu_cache = relu_forward(an)\n    cache = (conv_cache, bn_cache, relu_cache)\n    return out, cache\n\n\ndef conv_bn_relu_backward(dout, cache):\n    conv_cache, bn_cache, relu_cache = cache\n    dan = relu_backward(dout, relu_cache)\n    da, dgamma, dbeta = spatial_batchnorm_backward(dan, bn_cache)\n    dx, dw, db = conv_backward_fast(da, conv_cache)\n    return dx, dw, db, dgamma, dbeta\n\n\ndef conv_relu_pool_forward(x, w, b, conv_param, pool_param):\n    """"""\n    Convenience layer that performs a convolution, a ReLU, and a pool.\n\n    Inputs:\n    - x: Input to the convolutional layer\n    - w, b, conv_param: Weights and parameters for the convolutional layer\n    - pool_param: Parameters for the pooling layer\n\n    Returns a tuple of:\n    - out: Output from the pooling layer\n    - cache: Object to give to the backward pass\n    """"""\n    a, conv_cache = conv_forward_fast(x, w, b, conv_param)\n    s, relu_cache = relu_forward(a)\n    out, pool_cache = max_pool_forward_fast(s, pool_param)\n    cache = (conv_cache, relu_cache, pool_cache)\n    return out, cache\n\n\ndef conv_relu_pool_backward(dout, cache):\n    """"""\n    Backward pass for the conv-relu-pool convenience layer\n    """"""\n    conv_cache, relu_cache, pool_cache = cache\n    ds = max_pool_backward_fast(dout, pool_cache)\n    da = relu_backward(ds, relu_cache)\n    dx, dw, db = conv_backward_fast(da, conv_cache)\n    return dx, dw, db\n'"
assignment3/cs231n/layers.py,0,"b'import numpy as np\n\n\ndef affine_forward(x, w, b):\n    """"""\n    Computes the forward pass for an affine (fully-connected) layer.\n\n    The input x has shape (N, d_1, ..., d_k) where x[i] is the ith input.\n    We multiply this against a weight matrix of shape (D, M) where\n    D = \\prod_i d_i\n\n    Inputs:\n    x - Input data, of shape (N, d_1, ..., d_k)\n    w - Weights, of shape (D, M)\n    b - Biases, of shape (M,)\n\n    Returns a tuple of:\n    - out: output, of shape (N, M)\n    - cache: (x, w, b)\n    """"""\n    out = x.reshape(x.shape[0], -1).dot(w) + b\n    cache = (x, w, b)\n    return out, cache\n\n\ndef affine_backward(dout, cache):\n    """"""\n    Computes the backward pass for an affine layer.\n\n    Inputs:\n    - dout: Upstream derivative, of shape (N, M)\n    - cache: Tuple of:\n      - x: Input data, of shape (N, d_1, ... d_k)\n      - w: Weights, of shape (D, M)\n\n    Returns a tuple of:\n    - dx: Gradient with respect to x, of shape (N, d1, ..., d_k)\n    - dw: Gradient with respect to w, of shape (D, M)\n    - db: Gradient with respect to b, of shape (M,)\n    """"""\n    x, w, b = cache\n    dx = dout.dot(w.T).reshape(x.shape)\n    dw = x.reshape(x.shape[0], -1).T.dot(dout)\n    db = np.sum(dout, axis=0)\n    return dx, dw, db\n\n\ndef relu_forward(x):\n    """"""\n    Computes the forward pass for a layer of rectified linear units (ReLUs).\n\n    Input:\n    - x: Inputs, of any shape\n\n    Returns a tuple of:\n    - out: Output, of the same shape as x\n    - cache: x\n    """"""\n    out = np.maximum(0, x)\n    cache = x\n    return out, cache\n\n\ndef relu_backward(dout, cache):\n    """"""\n    Computes the backward pass for a layer of rectified linear units (ReLUs).\n\n    Input:\n    - dout: Upstream derivatives, of any shape\n    - cache: Input x, of same shape as dout\n\n    Returns:\n    - dx: Gradient with respect to x\n    """"""\n    x = cache\n    dx = np.where(x > 0, dout, 0)\n    return dx\n\n\ndef batchnorm_forward(x, gamma, beta, bn_param):\n    """"""\n    Forward pass for batch normalization.\n\n    During training the sample mean and (uncorrected) sample variance are\n    computed from minibatch statistics and used to normalize the incoming data.\n    During training we also keep an exponentially decaying running mean of the mean\n    and variance of each feature, and these averages are used to normalize data\n    at test-time.\n\n    At each timestep we update the running averages for mean and variance using\n    an exponential decay based on the momentum parameter:\n\n    running_mean = momentum * running_mean + (1 - momentum) * sample_mean\n    running_var = momentum * running_var + (1 - momentum) * sample_var\n\n    Note that the batch normalization paper suggests a different test-time\n    behavior: they compute sample mean and variance for each feature using a\n    large number of training images rather than using a running average. For\n    this implementation we have chosen to use running averages instead since\n    they do not require an additional estimation step; the torch7 implementation\n    of batch normalization also uses running averages.\n\n    Input:\n    - x: Data of shape (N, D)\n    - gamma: Scale parameter of shape (D,)\n    - beta: Shift paremeter of shape (D,)\n    - bn_param: Dictionary with the following keys:\n      - mode: \'train\' or \'test\'; required\n      - eps: Constant for numeric stability\n      - momentum: Constant for running mean / variance.\n      - running_mean: Array of shape (D,) giving running mean of features\n      - running_var Array of shape (D,) giving running variance of features\n\n    Returns a tuple of:\n    - out: of shape (N, D)\n    - cache: A tuple of values needed in the backward pass\n    """"""\n    mode = bn_param[\'mode\']\n    eps = bn_param.get(\'eps\', 1e-5)\n    momentum = bn_param.get(\'momentum\', 0.9)\n\n    N, D = x.shape\n    running_mean = bn_param.get(\'running_mean\', np.zeros(D, dtype=x.dtype))\n    running_var = bn_param.get(\'running_var\', np.zeros(D, dtype=x.dtype))\n\n    out, cache = None, None\n    if mode == \'train\':\n        # Compute output\n        mu = x.mean(axis=0)\n        xc = x - mu\n        var = np.mean(xc ** 2, axis=0)\n        std = np.sqrt(var + eps)\n        xn = xc / std\n        out = gamma * xn + beta\n\n        cache = (mode, x, gamma, xc, std, xn, out)\n\n        # Update running average of mean\n        running_mean *= momentum\n        running_mean += (1 - momentum) * mu\n\n        # Update running average of variance\n        running_var *= momentum\n        running_var += (1 - momentum) * var\n    elif mode == \'test\':\n        # Using running mean and variance to normalize\n        std = np.sqrt(running_var + eps)\n        xn = (x - running_mean) / std\n        out = gamma * xn + beta\n        cache = (mode, x, xn, gamma, beta, std)\n    else:\n        raise ValueError(\'Invalid forward batchnorm mode ""%s""\' % mode)\n\n    # Store the updated running means back into bn_param\n    bn_param[\'running_mean\'] = running_mean\n    bn_param[\'running_var\'] = running_var\n\n    return out, cache\n\n\ndef batchnorm_backward(dout, cache):\n    """"""\n    Backward pass for batch normalization.\n\n    For this implementation, you should write out a computation graph for\n    batch normalization on paper and propagate gradients backward through\n    intermediate nodes.\n\n    Inputs:\n    - dout: Upstream derivatives, of shape (N, D)\n    - cache: Variable of intermediates from batchnorm_forward.\n\n    Returns a tuple of:\n    - dx: Gradient with respect to inputs x, of shape (N, D)\n    - dgamma: Gradient with respect to scale parameter gamma, of shape (D,)\n    - dbeta: Gradient with respect to shift parameter beta, of shape (D,)\n    """"""\n    mode = cache[0]\n    if mode == \'train\':\n        mode, x, gamma, xc, std, xn, out = cache\n\n        N = x.shape[0]\n        dbeta = dout.sum(axis=0)\n        dgamma = np.sum(xn * dout, axis=0)\n        dxn = gamma * dout\n        dxc = dxn / std\n        dstd = -np.sum((dxn * xc) / (std * std), axis=0)\n        dvar = 0.5 * dstd / std\n        dxc += (2.0 / N) * xc * dvar\n        dmu = np.sum(dxc, axis=0)\n        dx = dxc - dmu / N\n    elif mode == \'test\':\n        mode, x, xn, gamma, beta, std = cache\n        dbeta = dout.sum(axis=0)\n        dgamma = np.sum(xn * dout, axis=0)\n        dxn = gamma * dout\n        dx = dxn / std\n    else:\n        raise ValueError(mode)\n\n    return dx, dgamma, dbeta\n\n\ndef spatial_batchnorm_forward(x, gamma, beta, bn_param):\n    """"""\n    Computes the forward pass for spatial batch normalization.\n\n    Inputs:\n    - x: Input data of shape (N, C, H, W)\n    - gamma: Scale parameter, of shape (C,)\n    - beta: Shift parameter, of shape (C,)\n    - bn_param: Dictionary with the following keys:\n      - mode: \'train\' or \'test\'; required\n      - eps: Constant for numeric stability\n      - momentum: Constant for running mean / variance. momentum=0 means that\n        old information is discarded completely at every time step, while\n        momentum=1 means that new information is never incorporated. The\n        default of momentum=0.9 should work well in most situations.\n      - running_mean: Array of shape (D,) giving running mean of features\n      - running_var Array of shape (D,) giving running variance of features\n\n    Returns a tuple of:\n    - out: Output data, of shape (N, C, H, W)\n    - cache: Values needed for the backward pass\n    """"""\n    N, C, H, W = x.shape\n    x_flat = x.transpose(0, 2, 3, 1).reshape(-1, C)\n    out_flat, cache = batchnorm_forward(x_flat, gamma, beta, bn_param)\n    out = out_flat.reshape(N, H, W, C).transpose(0, 3, 1, 2)\n    return out, cache\n\n\ndef spatial_batchnorm_backward(dout, cache):\n    """"""\n    Computes the backward pass for spatial batch normalization.\n\n    Inputs:\n    - dout: Upstream derivatives, of shape (N, C, H, W)\n    - cache: Values from the forward pass\n\n    Returns a tuple of:\n    - dx: Gradient with respect to inputs, of shape (N, C, H, W)\n    - dgamma: Gradient with respect to scale parameter, of shape (C,)\n    - dbeta: Gradient with respect to shift parameter, of shape (C,)\n    """"""\n    N, C, H, W = dout.shape\n    dout_flat = dout.transpose(0, 2, 3, 1).reshape(-1, C)\n    dx_flat, dgamma, dbeta = batchnorm_backward(dout_flat, cache)\n    dx = dx_flat.reshape(N, H, W, C).transpose(0, 3, 1, 2)\n    return dx, dgamma, dbeta\n\n\ndef svm_loss(x, y):\n    """"""\n    Computes the loss and gradient using for multiclass SVM classification.\n\n    Inputs:\n    - x: Input data, of shape (N, C) where x[i, j] is the score for the jth class\n      for the ith input.\n    - y: Vector of labels, of shape (N,) where y[i] is the label for x[i] and\n      0 <= y[i] < C\n\n    Returns a tuple of:\n    - loss: Scalar giving the loss\n    - dx: Gradient of the loss with respect to x\n    """"""\n    N = x.shape[0]\n    correct_class_scores = x[np.arange(N), y]\n    margins = np.maximum(0, x - correct_class_scores[:, np.newaxis] + 1.0)\n    margins[np.arange(N), y] = 0\n    loss = np.sum(margins) / N\n    num_pos = np.sum(margins > 0, axis=1)\n    dx = np.zeros_like(x)\n    dx[margins > 0] = 1\n    dx[np.arange(N), y] -= num_pos\n    dx /= N\n    return loss, dx\n\n\ndef softmax_loss(x, y):\n    """"""\n    Computes the loss and gradient for softmax classification.\n\n    Inputs:\n    - x: Input data, of shape (N, C) where x[i, j] is the score for the jth class\n      for the ith input.\n    - y: Vector of labels, of shape (N,) where y[i] is the label for x[i] and\n      0 <= y[i] < C\n\n    Returns a tuple of:\n    - loss: Scalar giving the loss\n    - dx: Gradient of the loss with respect to x\n    """"""\n    probs = np.exp(x - np.max(x, axis=1, keepdims=True))\n    probs /= np.sum(probs, axis=1, keepdims=True)\n    N = x.shape[0]\n    loss = -np.sum(np.log(probs[np.arange(N), y])) / N\n    dx = probs.copy()\n    dx[np.arange(N), y] -= 1\n    dx /= N\n    return loss, dx\n'"
assignment3/cs231n/optim.py,0,"b'import numpy as np\n\n""""""\nThis file implements various first-order update rules that are commonly used for\ntraining neural networks. Each update rule accepts current weights and the\ngradient of the loss with respect to those weights and produces the next set of\nweights. Each update rule has the same interface:\n\ndef update(w, dw, config=None):\n\nInputs:\n  - w: A numpy array giving the current weights.\n  - dw: A numpy array of the same shape as w giving the gradient of the\n    loss with respect to w.\n  - config: A dictionary containing hyperparameter values such as learning rate,\n    momentum, etc. If the update rule requires caching values over many\n    iterations, then config will also hold these cached values.\n\nReturns:\n  - next_w: The next point after the update.\n  - config: The config dictionary to be passed to the next iteration of the\n    update rule.\n\nNOTE: For most update rules, the default learning rate will probably not perform\nwell; however the default values of the other hyperparameters should work well\nfor a variety of different problems.\n\nFor efficiency, update rules may perform in-place updates, mutating w and\nsetting next_w equal to w.\n""""""\n\n\ndef sgd(w, dw, config=None):\n    """"""\n    Performs vanilla stochastic gradient descent.\n\n    config format:\n    - learning_rate: Scalar learning rate.\n    """"""\n    if config is None: config = {}\n    config.setdefault(\'learning_rate\', 1e-2)\n\n    w -= config[\'learning_rate\'] * dw\n    return w, config\n\n\ndef adam(x, dx, config=None):\n    """"""\n    Uses the Adam update rule, which incorporates moving averages of both the\n    gradient and its square and a bias correction term.\n\n    config format:\n    - learning_rate: Scalar learning rate.\n    - beta1: Decay rate for moving average of first moment of gradient.\n    - beta2: Decay rate for moving average of second moment of gradient.\n    - epsilon: Small scalar used for smoothing to avoid dividing by zero.\n    - m: Moving average of gradient.\n    - v: Moving average of squared gradient.\n    - t: Iteration number.\n    """"""\n    if config is None: config = {}\n    config.setdefault(\'learning_rate\', 1e-3)\n    config.setdefault(\'beta1\', 0.9)\n    config.setdefault(\'beta2\', 0.999)\n    config.setdefault(\'epsilon\', 1e-8)\n    config.setdefault(\'m\', np.zeros_like(x))\n    config.setdefault(\'v\', np.zeros_like(x))\n    config.setdefault(\'t\', 0)\n\n    next_x = None\n    beta1, beta2, eps = config[\'beta1\'], config[\'beta2\'], config[\'epsilon\']\n    t, m, v = config[\'t\'], config[\'m\'], config[\'v\']\n    m = beta1 * m + (1 - beta1) * dx\n    v = beta2 * v + (1 - beta2) * (dx * dx)\n    t += 1\n    alpha = config[\'learning_rate\'] * np.sqrt(1 - beta2 ** t) / (1 - beta1 ** t)\n    x -= alpha * (m / (np.sqrt(v) + eps))\n    config[\'t\'] = t\n    config[\'m\'] = m\n    config[\'v\'] = v\n    next_x = x\n\n    return next_x, config\n'"
assignment3/cs231n/rnn_layers.py,0,"b'from __future__ import print_function, division\nfrom builtins import range\nimport numpy as np\n\n\n""""""\nThis file defines layer types that are commonly used for recurrent neural\nnetworks.\n""""""\n\n\ndef rnn_step_forward(x, prev_h, Wx, Wh, b):\n    """"""\n    Run the forward pass for a single timestep of a vanilla RNN that uses a tanh\n    activation function.\n\n    The input data has dimension D, the hidden state has dimension H, and we use\n    a minibatch size of N.\n\n    Inputs:\n    - x: Input data for this timestep, of shape (N, D).\n    - prev_h: Hidden state from previous timestep, of shape (N, H)\n    - Wx: Weight matrix for input-to-hidden connections, of shape (D, H)\n    - Wh: Weight matrix for hidden-to-hidden connections, of shape (H, H)\n    - b: Biases of shape (H,)\n\n    Returns a tuple of:\n    - next_h: Next hidden state, of shape (N, H)\n    - cache: Tuple of values needed for the backward pass.\n    """"""\n\n    ##############################################################################\n    # TODO: Implement a single forward step for the vanilla RNN. Store the next  #\n    # hidden state and any values you need for the backward pass in the next_h   #\n    # and cache variables respectively.                                          #\n    ##############################################################################\n\n    h_raw = np.dot(x, Wx) + np.dot(prev_h, Wh) + b\n    next_h = np.tanh(h_raw)\n\n    cache = (Wx, Wh, x, prev_h, h_raw)\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n    return next_h, cache\n\n\ndef rnn_step_backward(dnext_h, cache):\n    """"""\n    Backward pass for a single timestep of a vanilla RNN.\n\n    Inputs:\n    - dnext_h: Gradient of loss with respect to next hidden state\n    - cache: Cache object from the forward pass\n\n    Returns a tuple of:\n    - dx: Gradients of input data, of shape (N, D)\n    - dprev_h: Gradients of previous hidden state, of shape (N, H)\n    - dWx: Gradients of input-to-hidden weights, of shape (D, H)\n    - dWh: Gradients of hidden-to-hidden weights, of shape (H, H)\n    - db: Gradients of bias vector, of shape (H,)\n    """"""\n\n    ##############################################################################\n    # TODO: Implement the backward pass for a single step of a vanilla RNN.      #\n    #                                                                            #\n    # HINT: For the tanh function, you can compute the local derivative in terms #\n    # of the output value from tanh.                                             #\n    ##############################################################################\n\n    Wx, Wh, x, prev_h, h_raw = cache\n\n    dh_raw = (1 - np.tanh(h_raw) ** 2) * dnext_h\n    dx = np.dot(dh_raw, Wx.T)\n    dprev_h = np.dot(dh_raw, Wh.T)\n    dWx = np.dot(x.T, dh_raw)\n    dWh = np.dot(prev_h.T, dh_raw)\n    db = np.sum(dh_raw, axis=0)\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n    return dx, dprev_h, dWx, dWh, db\n\n\ndef rnn_forward(x, h0, Wx, Wh, b):\n    """"""\n    Run a vanilla RNN forward on an entire sequence of data. We assume an input\n    sequence composed of T vectors, each of dimension D. The RNN uses a hidden\n    size of H, and we work over a minibatch containing N sequences. After running\n    the RNN forward, we return the hidden states for all timesteps.\n\n    Inputs:\n    - x: Input data for the entire timeseries, of shape (N, T, D).\n    - h0: Initial hidden state, of shape (N, H)\n    - Wx: Weight matrix for input-to-hidden connections, of shape (D, H)\n    - Wh: Weight matrix for hidden-to-hidden connections, of shape (H, H)\n    - b: Biases of shape (H,)\n\n    Returns a tuple of:\n    - h: Hidden states for the entire timeseries, of shape (N, T, H).\n    - cache: Values needed in the backward pass\n    """"""\n    h, cache = None, None\n    ##############################################################################\n    # TODO: Implement forward pass for a vanilla RNN running on a sequence of    #\n    # input data. You should use the rnn_step_forward function that you defined  #\n    # above. You can use a for loop to help compute the forward pass.            #\n    ##############################################################################\n\n    N, T, D = x.shape\n    H = Wh.shape[0]\n\n    forward_steps_cache = {}\n    h = np.zeros([N, T, H])\n\n    for t in range(T):\n        if t == 0:\n            h[:, t, :], forward_steps_cache[t] = rnn_step_forward(x[:, t, :], h0, Wx, Wh, b)\n        else:\n            h[:, t, :], forward_steps_cache[t] = rnn_step_forward(x[:, t, :], h[:, t-1, :], Wx, Wh, b)\n\n    cache = (h0, forward_steps_cache, N, T, D, H)\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n    return h, cache\n\n\ndef rnn_backward(dh, cache):\n    """"""\n    Compute the backward pass for a vanilla RNN over an entire sequence of data.\n\n    Inputs:\n    - dh: Upstream gradients of all hidden states, of shape (N, T, H)\n\n    Returns a tuple of:\n    - dx: Gradient of inputs, of shape (N, T, D)\n    - dh0: Gradient of initial hidden state, of shape (N, H)\n    - dWx: Gradient of input-to-hidden weights, of shape (D, H)\n    - dWh: Gradient of hidden-to-hidden weights, of shape (H, H)\n    - db: Gradient of biases, of shape (H,)\n    """"""\n    dx, dh0, dWx, dWh, db = None, None, None, None, None\n    ##############################################################################\n    # TODO: Implement the backward pass for a vanilla RNN running an entire      #\n    # sequence of data. You should use the rnn_step_backward function that you   #\n    # defined above. You can use a for loop to help compute the backward pass.   #\n    ##############################################################################\n\n    h0, forward_steps_cache, N, T, D, H = cache\n    dx = np.zeros([N, T, D])\n    dWx = np.zeros([D, H])\n    dWh = np.zeros([H, H])\n    db = np.zeros([H])\n\n    dprev_h = 0\n    for t in reversed(range(T)):\n        dh_ag = dh[:, t, :] + dprev_h\n        dx_step, dprev_h, dWx_step, dWh_step, db_step = rnn_step_backward(dh_ag, forward_steps_cache[t])\n        dWx += dWx_step\n        dWh += dWh_step\n        db += db_step\n        dx[:, t, :] = dx_step\n\n    dh0 = dprev_h\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n    return dx, dh0, dWx, dWh, db\n\n\ndef word_embedding_forward(x, W):\n    """"""\n    Forward pass for word embeddings. We operate on minibatches of size N where\n    each sequence has length T. We assume a vocabulary of V words, assigning each\n    to a vector of dimension D.\n\n    Inputs:\n    - x: Integer array of shape (N, T) giving indices of words. Each element idx\n      of x must be in the range 0 <= idx < V.\n    - W: Weight matrix of shape (V, D) giving word vectors for all words.\n\n    Returns a tuple of:\n    - out: Array of shape (N, T, D) giving word vectors for all input words.\n    - cache: Values needed for the backward pass\n    """"""\n    out, cache = None, None\n    ##############################################################################\n    # TODO: Implement the forward pass for word embeddings.                      #\n    #                                                                            #\n    # HINT: This can be done in one line using NumPy\'s array indexing.           #\n    ##############################################################################\n\n    out = W[x, :]\n    cache = x, W\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n    return out, cache\n\n\ndef word_embedding_backward(dout, cache):\n    """"""\n    Backward pass for word embeddings. We cannot back-propagate into the words\n    since they are integers, so we only return gradient for the word embedding\n    matrix.\n\n    HINT: Look up the function np.add.at\n\n    Inputs:\n    - dout: Upstream gradients of shape (N, T, D)\n    - cache: Values from the forward pass\n\n    Returns:\n    - dW: Gradient of word embedding matrix, of shape (V, D).\n    """"""\n    dW = None\n    ##############################################################################\n    # TODO: Implement the backward pass for word embeddings.                     #\n    #                                                                            #\n    # Note that Words can appear more than once in a sequence.                   #\n    # HINT: Look up the function np.add.at                                       #\n    ##############################################################################\n\n    x, W = cache\n    dW = np.zeros_like(W)\n    np.add.at(dW, x, dout)\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n    return dW\n\n\ndef sigmoid(x):\n    """"""\n    A numerically stable version of the logistic sigmoid function.\n    """"""\n    pos_mask = (x >= 0)\n    neg_mask = (x < 0)\n    z = np.zeros_like(x)\n    z[pos_mask] = np.exp(-x[pos_mask])\n    z[neg_mask] = np.exp(x[neg_mask])\n    top = np.ones_like(x)\n    top[neg_mask] = z[neg_mask]\n    return top / (1 + z)\n\n\ndef lstm_step_forward(x, prev_h, prev_c, Wx, Wh, b):\n    """"""\n    Forward pass for a single timestep of an LSTM.\n\n    The input data has dimension D, the hidden state has dimension H, and we use\n    a minibatch size of N.\n\n    Inputs:\n    - x: Input data, of shape (N, D)\n    - prev_h: Previous hidden state, of shape (N, H)\n    - prev_c: previous cell state, of shape (N, H)\n    - Wx: Input-to-hidden weights, of shape (D, 4H)\n    - Wh: Hidden-to-hidden weights, of shape (H, 4H)\n    - b: Biases, of shape (4H,)\n\n    Returns a tuple of:\n    - next_h: Next hidden state, of shape (N, H)\n    - next_c: Next cell state, of shape (N, H)\n    - cache: Tuple of values needed for backward pass.\n    """"""\n    cache = None\n    #############################################################################\n    # TODO: Implement the forward pass for a single timestep of an LSTM.        #\n    # You may want to use the numerically stable sigmoid implementation above.  #\n    #############################################################################\n\n    H = prev_h.shape[1]\n    a = np.dot(x, Wx) + np.dot(prev_h, Wh) + b\n    a_i = a[:, 0*H:1*H]\n    a_f = a[:, 1*H:2*H]\n    a_o = a[:, 2*H:3*H]\n    a_g = a[:, 3*H:4*H]\n    i = sigmoid(a_i)\n    f = sigmoid(a_f)\n    o = sigmoid(a_o)\n    g = np.tanh(a_g)\n    next_c = f * prev_c + i * g\n    next_h = o * np.tanh(next_c)\n\n    cache = (H, x, Wx, Wh, a, i, f, o, g, prev_c, prev_h, next_c, prev_h)\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n\n    return next_h, next_c, cache\n\n\ndef lstm_step_backward(dnext_h, dnext_c, cache):\n    """"""\n    Backward pass for a single timestep of an LSTM.\n\n    Inputs:\n    - dnext_h: Gradients of next hidden state, of shape (N, H)\n    - dnext_c: Gradients of next cell state, of shape (N, H)\n    - cache: Values from the forward pass\n\n    Returns a tuple of:\n    - dx: Gradient of input data, of shape (N, D)\n    - dprev_h: Gradient of previous hidden state, of shape (N, H)\n    - dprev_c: Gradient of previous cell state, of shape (N, H)\n    - dWx: Gradient of input-to-hidden weights, of shape (D, 4H)\n    - dWh: Gradient of hidden-to-hidden weights, of shape (H, 4H)\n    - db: Gradient of biases, of shape (4H,)\n    """"""\n    dx, dh, dc, dWx, dWh, db, dprev_h, dprev_c = None, None, None, None, None, None, None, None\n    #############################################################################\n    # TODO: Implement the backward pass for a single timestep of an LSTM.       #\n    #                                                                           #\n    # HINT: For sigmoid and tanh you can compute local derivatives in terms of  #\n    # the output value from the nonlinearity.                                   #\n    #############################################################################\n\n    H, x, Wx, Wh, a, i, f, o, g, prev_c, prev_h, next_c, prev_h = cache\n    do = dnext_h * np.tanh(next_c)\n    dc = (1 - np.tanh(next_c) ** 2) * dnext_h * o\n    dc += dnext_c\n    df = dc * prev_c\n    dprev_c = dc * f\n    di = g * dc\n    dg = i * dc\n    a_i = a[:, 0 * H:1 * H]\n    a_f = a[:, 1 * H:2 * H]\n    a_o = a[:, 2 * H:3 * H]\n    a_g = a[:, 3 * H:4 * H]\n    da_i = di * (1 - sigmoid(a_i)) * sigmoid(a_i)\n    da_f = df * (1 - sigmoid(a_f)) * sigmoid(a_f)\n    da_o = do * (1 - sigmoid(a_o)) * sigmoid(a_o)\n    da_g = dg * (1 - np.tanh(a_g) ** 2)\n    da = np.hstack((da_i, da_f, da_o, da_g))\n    dx = np.dot(da, Wx.T)\n    dprev_h = np.dot(da, Wh.T)\n    db = np.sum(da, axis=0, keepdims=False)\n    dWx = np.dot(x.T, da)\n    dWh = np.dot(prev_h.T, da)\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n\n    return dx, dprev_h, dprev_c, dWx, dWh, db\n\n\ndef lstm_forward(x, h0, Wx, Wh, b):\n    """"""\n    Forward pass for an LSTM over an entire sequence of data. We assume an input\n    sequence composed of T vectors, each of dimension D. The LSTM uses a hidden\n    size of H, and we work over a minibatch containing N sequences. After running\n    the LSTM forward, we return the hidden states for all timesteps.\n\n    Note that the initial cell state is passed as input, but the initial cell\n    state is set to zero. Also note that the cell state is not returned; it is\n    an internal variable to the LSTM and is not accessed from outside.\n\n    Inputs:\n    - x: Input data of shape (N, T, D)\n    - h0: Initial hidden state of shape (N, H)\n    - Wx: Weights for input-to-hidden connections, of shape (D, 4H)\n    - Wh: Weights for hidden-to-hidden connections, of shape (H, 4H)\n    - b: Biases of shape (4H,)\n\n    Returns a tuple of:\n    - h: Hidden states for all timesteps of all sequences, of shape (N, T, H)\n    - cache: Values needed for the backward pass.\n    """"""\n    h, cache = None, None\n    #############################################################################\n    # TODO: Implement the forward pass for an LSTM over an entire timeseries.   #\n    # You should use the lstm_step_forward function that you just defined.      #\n    #############################################################################\n\n    N, T, D = x.shape\n    H = Wh.shape[0]\n\n    forward_steps_cache = {}\n    h = np.zeros([N, T, H])\n\n    for t in range(T):\n        if t == 0:\n            h[:, t, :], c, forward_steps_cache[t] = lstm_step_forward(x[:, t, :], h0, np.zeros_like(h0), Wx, Wh, b)\n        else:\n            h[:, t, :], c, forward_steps_cache[t] = lstm_step_forward(x[:, t, :], h[:, t - 1, :], c, Wx, Wh, b)\n\n    cache = (h0, forward_steps_cache, N, T, D, H)\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n\n    return h, cache\n\n\ndef lstm_backward(dh, cache):\n    """"""\n    Backward pass for an LSTM over an entire sequence of data.]\n\n    Inputs:\n    - dh: Upstream gradients of hidden states, of shape (N, T, H)\n    - cache: Values from the forward pass\n\n    Returns a tuple of:\n    - dx: Gradient of input data of shape (N, T, D)\n    - dh0: Gradient of initial hidden state of shape (N, H)\n    - dWx: Gradient of input-to-hidden weight matrix of shape (D, 4H)\n    - dWh: Gradient of hidden-to-hidden weight matrix of shape (H, 4H)\n    - db: Gradient of biases, of shape (4H,)\n    """"""\n    dx, dh0, dWx, dWh, db = None, None, None, None, None\n    #############################################################################\n    # TODO: Implement the backward pass for an LSTM over an entire timeseries.  #\n    # You should use the lstm_step_backward function that you just defined.     #\n    #############################################################################\n\n    h0, forward_steps_cache, N, T, D, H = cache\n    dx = np.zeros([N, T, D])\n    dWx = np.zeros([D, 4 * H])\n    dWh = np.zeros([H, 4 * H])\n    db = np.zeros([4 * H])\n\n    dprev_h = np.zeros([N, H])\n    dprev_c = np.zeros([N, H])\n    for t in reversed(range(T)):\n        dh_ag = dh[:, t, :] + dprev_h\n        dx_step, dprev_h, dprev_c, dWx_step, dWh_step, db_step = lstm_step_backward(dh_ag, dprev_c, forward_steps_cache[t])\n        dWx += dWx_step\n        dWh += dWh_step\n        db += db_step\n        dx[:, t, :] = dx_step\n\n    dh0 = dprev_h\n\n\n    ##############################################################################\n    #                               END OF YOUR CODE                             #\n    ##############################################################################\n\n    return dx, dh0, dWx, dWh, db\n\n\ndef temporal_affine_forward(x, w, b):\n    """"""\n    Forward pass for a temporal affine layer. The input is a set of D-dimensional\n    vectors arranged into a minibatch of N timeseries, each of length T. We use\n    an affine function to transform each of those vectors into a new vector of\n    dimension M.\n\n    Inputs:\n    - x: Input data of shape (N, T, D)\n    - w: Weights of shape (D, M)\n    - b: Biases of shape (M,)\n\n    Returns a tuple of:\n    - out: Output data of shape (N, T, M)\n    - cache: Values needed for the backward pass\n    """"""\n    N, T, D = x.shape\n    M = b.shape[0]\n    out = x.reshape(N * T, D).dot(w).reshape(N, T, M) + b\n    cache = x, w, b, out\n    return out, cache\n\n\ndef temporal_affine_backward(dout, cache):\n    """"""\n    Backward pass for temporal affine layer.\n\n    Input:\n    - dout: Upstream gradients of shape (N, T, M)\n    - cache: Values from forward pass\n\n    Returns a tuple of:\n    - dx: Gradient of input, of shape (N, T, D)\n    - dw: Gradient of weights, of shape (D, M)\n    - db: Gradient of biases, of shape (M,)\n    """"""\n    x, w, b, out = cache\n    N, T, D = x.shape\n    M = b.shape[0]\n\n    dx = dout.reshape(N * T, M).dot(w.T).reshape(N, T, D)\n    dw = dout.reshape(N * T, M).T.dot(x.reshape(N * T, D)).T\n    db = dout.sum(axis=(0, 1))\n\n    return dx, dw, db\n\n\ndef temporal_softmax_loss(x, y, mask, verbose=False):\n    """"""\n    A temporal version of softmax loss for use in RNNs. We assume that we are\n    making predictions over a vocabulary of size V for each timestep of a\n    timeseries of length T, over a minibatch of size N. The input x gives scores\n    for all vocabulary elements at all timesteps, and y gives the indices of the\n    ground-truth element at each timestep. We use a cross-entropy loss at each\n    timestep, summing the loss over all timesteps and averaging across the\n    minibatch.\n\n    As an additional complication, we may want to ignore the model output at some\n    timesteps, since sequences of different length may have been combined into a\n    minibatch and padded with NULL tokens. The optional mask argument tells us\n    which elements should contribute to the loss.\n\n    Inputs:\n    - x: Input scores, of shape (N, T, V)\n    - y: Ground-truth indices, of shape (N, T) where each element is in the range\n         0 <= y[i, t] < V\n    - mask: Boolean array of shape (N, T) where mask[i, t] tells whether or not\n      the scores at x[i, t] should contribute to the loss.\n\n    Returns a tuple of:\n    - loss: Scalar giving loss\n    - dx: Gradient of loss with respect to scores x.\n    """"""\n\n    N, T, V = x.shape\n\n    x_flat = x.reshape(N * T, V)\n    y_flat = y.reshape(N * T)\n    mask_flat = mask.reshape(N * T)\n\n    probs = np.exp(x_flat - np.max(x_flat, axis=1, keepdims=True))\n    probs /= np.sum(probs, axis=1, keepdims=True)\n    loss = -np.sum(mask_flat * np.log(probs[np.arange(N * T), y_flat])) / N\n    dx_flat = probs.copy()\n    dx_flat[np.arange(N * T), y_flat] -= 1\n    dx_flat /= N\n    dx_flat *= mask_flat[:, None]\n\n    if verbose: print(\'dx_flat: \', dx_flat.shape)\n\n    dx = dx_flat.reshape(N, T, V)\n\n    return loss, dx\n'"
assignment3/cs231n/setup.py,0,"b""from distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Build import cythonize\nimport numpy\n\nextensions = [\n  Extension('im2col_cython', ['im2col_cython.pyx'],\n            include_dirs = [numpy.get_include()]\n  ),\n]\n\nsetup(\n    ext_modules = cythonize(extensions),\n)\n"""
assignment1/cs231n/classifiers/__init__.py,0,b'from cs231n.classifiers.k_nearest_neighbor import *\nfrom cs231n.classifiers.linear_classifier import *\n'
assignment1/cs231n/classifiers/k_nearest_neighbor.py,0,"b'import numpy as np\n#from past.builtins import xrange\nimport sys\nfrom collections import Counter\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\nclass KNearestNeighbor(object):\n  """""" a kNN classifier with L2 distance """"""\n\n  def __init__(self):\n    pass\n\n  def train(self, X, y):\n    """"""\n    Train the classifier. For k-nearest neighbors this is just \n    memorizing the training data.\n\n    Inputs:\n    - X: A numpy array of shape (num_train, D) containing the training data\n      consisting of num_train samples each of dimension D.\n    - y: A numpy array of shape (N,) containing the training labels, where\n         y[i] is the label for X[i].\n    """"""\n    self.X_train = X\n    self.y_train = y\n    \n  def predict(self, X, k=1, num_loops=0):\n    """"""\n    Predict labels for test data using this classifier.\n\n    Inputs:\n    - X: A numpy array of shape (num_test, D) containing test data consisting\n         of num_test samples each of dimension D.\n    - k: The number of nearest neighbors that vote for the predicted labels.\n    - num_loops: Determines which implementation to use to compute distances\n      between training points and testing points.\n\n    Returns:\n    - y: A numpy array of shape (num_test,) containing predicted labels for the\n      test data, where y[i] is the predicted label for the test point X[i].  \n    """"""\n    if num_loops == 0:\n      dists = self.compute_distances_no_loops(X)\n    elif num_loops == 1:\n      dists = self.compute_distances_one_loop(X)\n    elif num_loops == 2:\n      dists = self.compute_distances_two_loops(X)\n    else:\n      raise ValueError(\'Invalid value %d for num_loops\' % num_loops)\n\n    return self.predict_labels(dists, k=k)\n\n  def compute_distances_two_loops(self, X):\n    """"""\n    Compute the distance between each test point in X and each training point\n    in self.X_train using a nested loop over both the training data and the \n    test data.\n\n    Inputs:\n    - X: A numpy array of shape (num_test, D) containing test data.\n\n    Returns:\n    - dists: A numpy array of shape (num_test, num_train) where dists[i, j]\n      is the Euclidean distance between the ith test point and the jth training\n      point.\n    """"""\n    num_test = X.shape[0]\n    num_train = self.X_train.shape[0]\n    dists = np.zeros((num_test, num_train))\n    for i in xrange(num_test):\n      for j in xrange(num_train):\n        #####################################################################\n        # TODO:                                                             #\n        # Compute the l2 distance between the ith test point and the jth    #\n        # training point, and store the result in dists[i, j]. You should   #\n        # not use a loop over dimension.                                    #\n        #####################################################################\n\n        dists[i, j] = np.linalg.norm(self.X_train[j] - X[i])\n\n        #####################################################################\n        #                       END OF YOUR CODE                            #\n        #####################################################################\n    return dists\n\n  def compute_distances_one_loop(self, X):\n    """"""\n    Compute the distance between each test point in X and each training point\n    in self.X_train using a single loop over the test data.\n\n    Input / Output: Same as compute_distances_two_loops\n    """"""\n    num_test = X.shape[0]\n    num_train = self.X_train.shape[0]\n    dists = np.zeros((num_test, num_train))\n    for i in xrange(num_test):\n      #######################################################################\n      # TODO:                                                               #\n      # Compute the l2 distance between the ith test point and all training #\n      # points, and store the result in dists[i, :].                        #\n      #######################################################################\n\n      dists[i, :] = np.linalg.norm((self.X_train - X[i]), axis=-1)\n\n      #######################################################################\n      #                         END OF YOUR CODE                            #\n      #######################################################################\n    return dists\n\n  def compute_distances_no_loops(self, X):\n    """"""\n    Compute the distance between each test point in X and each training point\n    in self.X_train using no explicit loops.\n\n    Input / Output: Same as compute_distances_two_loops\n    """"""\n    num_test = X.shape[0]\n    num_train = self.X_train.shape[0]\n    dists = np.zeros((num_test, num_train)) \n    #########################################################################\n    # TODO:                                                                 #\n    # Compute the l2 distance between all test points and all training      #\n    # points without using any explicit loops, and store the result in      #\n    # dists.                                                                #\n    #                                                                       #\n    # You should implement this function using only basic array operations; #\n    # in particular you should not use functions from scipy.                #\n    #                                                                       #\n    # HINT: Try to formulate the l2 distance using matrix multiplication    #\n    #       and two broadcast sums.                                         #\n    #########################################################################\n\n    dists = np.sqrt(np.sum(X**2, axis=1).reshape(num_test, 1) + np.sum(self.X_train**2, axis=1) - 2 * X.dot(self.X_train.T))\n\n    #########################################################################\n    #                         END OF YOUR CODE                              #\n    #########################################################################\n    return dists\n\n  def predict_labels(self, dists, k=1):\n    """"""\n    Given a matrix of distances between test points and training points,\n    predict a label for each test point.\n\n    Inputs:\n    - dists: A numpy array of shape (num_test, num_train) where dists[i, j]\n      gives the distance betwen the ith test point and the jth training point.\n\n    Returns:\n    - y: A numpy array of shape (num_test,) containing predicted labels for the\n      test data, where y[i] is the predicted label for the test point X[i].  \n    """"""\n    num_test = dists.shape[0]\n    y_pred = np.zeros(num_test)\n    for i in xrange(num_test):\n      # A list of length k storing the labels of the k nearest neighbors to\n      # the ith test point.\n\n      closest_y = []\n\n      #########################################################################\n      # TODO:                                                                 #\n      # Use the distance matrix to find the k nearest neighbors of the ith    #\n      # testing point, and use self.y_train to find the labels of these       #\n      # neighbors. Store these labels in closest_y.                           #\n      # Hint: Look up the function numpy.argsort.                             #\n      #########################################################################\n\n      top_k_indx = np.argsort(dists[i])[:k]\n      closest_y = self.y_train[top_k_indx]\n\n      #########################################################################\n      # TODO:                                                                 #\n      # Now that you have found the labels of the k nearest neighbors, you    #\n      # need to find the most common label in the list closest_y of labels.   #\n      # Store this label in y_pred[i]. Break ties by choosing the smaller     #\n      # label.                                                                #\n      #########################################################################\n\n      vote = Counter(closest_y)\n      count = vote.most_common()\n      y_pred[i] = count[0][0]\n\n      #########################################################################\n      #                           END OF YOUR CODE                            #\n      #########################################################################\n\n    return y_pred\n\n'"
assignment1/cs231n/classifiers/linear_classifier.py,0,"b'from __future__ import print_function\n\nimport numpy as np\nfrom cs231n.classifiers.linear_svm import *\nfrom cs231n.classifiers.softmax import *\n# from past.builtins import xrange\nimport sys\n\n\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\n\nclass LinearClassifier(object):\n    def __init__(self):\n        self.W = None\n\n    def train(self, X, y, learning_rate=1e-3, reg=1e-5, num_iters=100,\n              batch_size=128, verbose=False):\n        """"""\n    Train this linear classifier using stochastic gradient descent.\n\n    Inputs:\n    - X: A numpy array of shape (N, D) containing training data; there are N\n      training samples each of dimension D.\n    - y: A numpy array of shape (N,) containing training labels; y[i] = c\n      means that X[i] has label 0 <= c < C for C classes.\n    - learning_rate: (float) learning rate for optimization.\n    - reg: (float) regularization strength.\n    - num_iters: (integer) number of steps to take when optimizing\n    - batch_size: (integer) number of training examples to use at each step.\n    - verbose: (boolean) If true, print progress during optimization.\n\n    Outputs:\n    A list containing the value of the loss function at each training iteration.\n    """"""\n        num_train, dim = X.shape\n        num_classes = np.max(y) + 1  # assume y takes values 0...K-1 where K is number of classes\n        if self.W is None:\n            # lazily initialize W\n            self.W = 0.001 * np.random.randn(dim, num_classes)\n\n        # Run stochastic gradient descent to optimize W\n        loss_history = []\n        for it in xrange(num_iters):\n            # X_batch = None\n            # y_batch = None\n\n            #########################################################################\n            # TODO:                                                                 #\n            # Sample batch_size elements from the training data and their           #\n            # corresponding labels to use in this round of gradient descent.        #\n            # Store the data in X_batch and their corresponding labels in           #\n            # y_batch; after sampling X_batch should have shape (dim, batch_size)   #\n            # and y_batch should have shape (batch_size,)                           #\n            #                                                                       #\n            # Hint: Use np.random.choice to generate indices. Sampling with         #\n            # replacement is faster than sampling without replacement.              #\n            #########################################################################\n\n            # randomize indices\n            batch_ind = np.random.choice(num_train, batch_size)\n            X_batch = X[batch_ind]\n            y_batch = y[batch_ind]\n\n            #########################################################################\n            #                       END OF YOUR CODE                                #\n            #########################################################################\n\n            # evaluate loss and gradient\n            loss, grad = self.loss(X_batch, y_batch, reg)\n            loss_history.append(loss)\n\n            # perform parameter update\n            #########################################################################\n            # TODO:                                                                 #\n            # Update the weights using the gradient and the learning rate.          #\n            #########################################################################\n\n            self.W += - learning_rate * grad\n\n            #########################################################################\n            #                       END OF YOUR CODE                                #\n            #########################################################################\n\n            if verbose and it % 100 == 0:\n                print(\'iteration %d / %d: loss %f\' % (it, num_iters, loss))\n\n        return loss_history\n\n    def predict(self, X):\n        """"""\n    Use the trained weights of this linear classifier to predict labels for\n    data points.\n\n    Inputs:\n    - X: A numpy array of shape (N, D) containing training data; there are N\n      training samples each of dimension D.\n\n    Returns:\n    - y_pred: Predicted labels for the data in X. y_pred is a 1-dimensional\n      array of length N, and each element is an integer giving the predicted\n      class.\n    """"""\n        y_pred = np.zeros(X.shape[0])\n        ###########################################################################\n        # TODO:                                                                   #\n        # Implement this method. Store the predicted labels in y_pred.            #\n        ###########################################################################\n\n        scores = X.dot(self.W)\n        y_pred = np.argmax(scores, axis=1)\n\n        ###########################################################################\n        #                           END OF YOUR CODE                              #\n        ###########################################################################\n        return y_pred\n\n    def loss(self, X_batch, y_batch, reg):\n        """"""\n    Compute the loss function and its derivative. \n    Subclasses will override this.\n\n    Inputs:\n    - X_batch: A numpy array of shape (N, D) containing a minibatch of N\n      data points; each point has dimension D.\n    - y_batch: A numpy array of shape (N,) containing labels for the minibatch.\n    - reg: (float) regularization strength.\n\n    Returns: A tuple containing:\n    - loss as a single float\n    - gradient with respect to self.W; an array of the same shape as W\n    """"""\n\n        pass\n\n\nclass LinearSVM(LinearClassifier):\n    """""" A subclass that uses the Multiclass SVM loss function """"""\n\n    def loss(self, X_batch, y_batch, reg):\n        return svm_loss_vectorized(self.W, X_batch, y_batch, reg)\n\n\nclass Softmax(LinearClassifier):\n    """""" A subclass that uses the Softmax + Cross-entropy loss function """"""\n\n    def loss(self, X_batch, y_batch, reg):\n        return softmax_loss_vectorized(self.W, X_batch, y_batch, reg)\n'"
assignment1/cs231n/classifiers/linear_svm.py,0,"b'import numpy as np\nfrom random import shuffle\n# from past.builtins import xrange\nimport sys\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\n\ndef svm_loss_naive(W, X, y, reg):\n    """"""\n  Structured SVM loss function, naive implementation (with loops).\n\n  Inputs have dimension D, there are C classes, and we operate on minibatches\n  of N examples.\n\n  Inputs:\n  - W: A numpy array of shape (D, C) containing weights.\n  - X: A numpy array of shape (N, D) containing a minibatch of data.\n  - y: A numpy array of shape (N,) containing training labels; y[i] = c means\n    that X[i] has label c, where 0 <= c < C.\n  - reg: (float) regularization strength\n\n  Returns a tuple of:\n  - loss as single float\n  - gradient with respect to weights W; an array of same shape as W\n  """"""\n    dW = np.zeros(W.shape)  # initialize the gradient as zero\n\n    # compute the loss and the gradient\n    num_classes = W.shape[1]\n    num_train = X.shape[0]\n    loss = 0.0\n    for i in xrange(num_train):\n        scores = X[i].dot(W)\n        correct_class_score = scores[y[i]]\n        loss_contributors_count = 0\n        for j in xrange(num_classes):\n            if j == y[i]:\n                continue\n            margin = scores[j] - correct_class_score + 1  # note delta = 1\n            if margin > 0:\n                loss += margin\n                # incorrect class gradient part\n                dW[:, j] += X[i]\n                # count contributor terms to loss function\n                loss_contributors_count += 1\n        # correct class gradient part\n        dW[:, y[i]] += (-1) * loss_contributors_count * X[i]\n\n    # Right now the loss is a sum over all training examples, but we want it\n    # to be an average instead so we divide by num_train.\n    loss /= num_train\n    dW /= num_train\n\n    # Add regularization to the loss.\n    loss += reg * np.sum(W * W)\n    # Add regularization to the gradient\n    dW += 2 * reg * W\n\n    #############################################################################\n    # TODO:                                                                     #\n    # Compute the gradient of the loss function and store it dW.                #\n    # Rather that first computing the loss and then computing the derivative,   #\n    # it may be simpler to compute the derivative at the same time that the     #\n    # loss is being computed. As a result you may need to modify some of the    #\n    # code above to compute the gradient.                                       #\n    #############################################################################\n\n\n    return loss, dW\n\n\ndef svm_loss_vectorized(W, X, y, reg):\n    """"""\n  Structured SVM loss function, vectorized implementation.\n\n  Inputs and outputs are the same as svm_loss_naive.\n  """"""\n    loss = 0.0\n    dW = np.zeros(W.shape)  # initialize the gradient as zero\n    num_train = X.shape[0]\n\n    #############################################################################\n    # TODO:                                                                     #\n    # Implement a vectorized version of the structured SVM loss, storing the    #\n    # result in loss.                                                           #\n    #############################################################################\n\n    # s: A numpy array of shape (N, C) containing scores\n    s = X.dot(W)\n    # read correct scores into a column array of height N\n    correct_score = s[list(range(num_train)), y]\n    correct_score = correct_score.reshape(num_train, -1)\n    # subtract correct scores from score matrix and add margin\n    s += 1 - correct_score\n    # make sure correct scores themselves don\'t contribute to loss function\n    s[list(range(num_train)), y] = 0\n    # construct loss function\n    loss = np.sum(np.fmax(s, 0)) / num_train\n    loss += reg * np.sum(W * W)\n\n    #############################################################################\n    #                             END OF YOUR CODE                              #\n    #############################################################################\n\n\n    #############################################################################\n    # TODO:                                                                     #\n    # Implement a vectorized version of the gradient for the structured SVM     #\n    # loss, storing the result in dW.                                           #\n    #                                                                           #\n    # Hint: Instead of computing the gradient from scratch, it may be easier    #\n    # to reuse some of the intermediate values that you used to compute the     #\n    # loss.                                                                     #\n    #############################################################################\n\n    X_mask = np.zeros(s.shape)\n    X_mask[s > 0] = 1\n    X_mask[np.arange(num_train), y] = -np.sum(X_mask, axis=1)\n    dW = X.T.dot(X_mask)\n    dW /= num_train\n    dW += 2 * reg * W\n\n    #############################################################################\n    #                             END OF YOUR CODE                              #\n    #############################################################################\n\n    return loss, dW\n'"
assignment1/cs231n/classifiers/neural_net.py,0,"b'from __future__ import print_function\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# from past.builtins import xrange\nimport sys\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\nclass TwoLayerNet(object):\n  """"""\n  A two-layer fully-connected neural network. The net has an input dimension of\n  N, a hidden layer dimension of H, and performs classification over C classes.\n  We train the network with a softmax loss function and L2 regularization on the\n  weight matrices. The network uses a ReLU nonlinearity after the first fully\n  connected layer.\n\n  In other words, the network has the following architecture:\n\n  input - fully connected layer - ReLU - fully connected layer - softmax\n\n  The outputs of the second fully-connected layer are the scores for each class.\n  """"""\n\n  def __init__(self, input_size, hidden_size, output_size, std=1e-4):\n    """"""\n    Initialize the model. Weights are initialized to small random values and\n    biases are initialized to zero. Weights and biases are stored in the\n    variable self.params, which is a dictionary with the following keys:\n\n    W1: First layer weights; has shape (D, H)\n    b1: First layer biases; has shape (H,)\n    W2: Second layer weights; has shape (H, C)\n    b2: Second layer biases; has shape (C,)\n\n    Inputs:\n    - input_size: The dimension D of the input data.\n    - hidden_size: The number of neurons H in the hidden layer.\n    - output_size: The number of classes C.\n    """"""\n    self.params = {}\n    self.params[\'W1\'] = std * np.random.randn(input_size, hidden_size)\n    self.params[\'b1\'] = np.zeros(hidden_size)\n    self.params[\'W2\'] = std * np.random.randn(hidden_size, output_size)\n    self.params[\'b2\'] = np.zeros(output_size)\n\n  def loss(self, X, y=None, reg=0.0):\n    """"""\n    Compute the loss and gradients for a two layer fully connected neural\n    network.\n\n    Inputs:\n    - X: Input data of shape (N, D). Each X[i] is a training sample.\n    - y: Vector of training labels. y[i] is the label for X[i], and each y[i] is\n      an integer in the range 0 <= y[i] < C. This parameter is optional; if it\n      is not passed then we only return scores, and if it is passed then we\n      instead return the loss and gradients.\n    - reg: Regularization strength.\n\n    Returns:\n    If y is None, return a matrix scores of shape (N, C) where scores[i, c] is\n    the score for class c on input X[i].\n\n    If y is not None, instead return a tuple of:\n    - loss: Loss (data loss and regularization loss) for this batch of training\n      samples.\n    - grads: Dictionary mapping parameter names to gradients of those parameters\n      with respect to the loss function; has the same keys as self.params.\n    """"""\n    # Unpack variables from the params dictionary\n    W1, b1 = self.params[\'W1\'], self.params[\'b1\']\n    W2, b2 = self.params[\'W2\'], self.params[\'b2\']\n    N, D = X.shape\n\n    # Compute the forward pass\n    scores = None\n    #############################################################################\n    # TODO: Perform the forward pass, computing the class scores for the input. #\n    # Store the result in the scores variable, which should be an array of      #\n    # shape (N, C).                                                             #\n    #############################################################################\n\n    # Using ReLUs as the Activation Function\n    H1 = np.maximum(0, np.dot(X, W1) + b1)\n    H2 = np.dot(H1, W2) + b2\n    scores = H2\n\n    #############################################################################\n    #                              END OF YOUR CODE                             #\n    #############################################################################\n\n    # If the targets are not given then jump out, we\'re done\n    if y is None:\n      return scores\n\n    # Compute the loss\n    loss = None\n    #############################################################################\n    # TODO: Finish the forward pass, and compute the loss. This should include  #\n    # both the data loss and L2 regularization for W1 and W2. Store the result  #\n    # in the variable loss, which should be a scalar. Use the Softmax           #\n    # classifier loss.                                                          #\n    #############################################################################\n\n    num_train = X.shape[0]\n\n    scores -= scores.max()\n    scores = np.exp(scores)\n    scores_sums = np.sum(scores, axis=1)\n    cors = scores[range(num_train), y]\n    loss = cors / scores_sums\n    loss = -np.sum(np.log(loss)) / num_train + reg * (np.sum(W1 * W1) + np.sum(W2 * W2))\n\n    #############################################################################\n    #                              END OF YOUR CODE                             #\n    #############################################################################\n\n    # Backward pass: compute gradients\n    grads = {}\n    #############################################################################\n    # TODO: Compute the backward pass, computing the derivatives of the weights #\n    # and biases. Store the results in the grads dictionary. For example,       #\n    # grads[\'W1\'] should store the gradient on W1, and be a matrix of same size #\n    #############################################################################\n\n    s = np.divide(scores, scores_sums.reshape(num_train, 1))\n    s[range(num_train), y] = - (scores_sums - cors) / scores_sums\n    s /= num_train\n    dW2 = H1.T.dot(s)\n    # db2 = np.ones((1, num_train)).dot(s)\n    db2 = np.sum(s, axis=0)\n    hidden = s.dot(W2.T)\n    hidden[H1 == 0] = 0\n    dW1 = X.T.dot(hidden)\n    # db1 = np.ones((1, num_train)).dot(hidden)\n    db1 = np.sum(hidden, axis=0)\n    grads[\'W2\'] = dW2 + 2 * reg * W2\n    grads[\'b2\'] = db2\n    grads[\'W1\'] = dW1 + 2 * reg * W1\n    grads[\'b1\'] = db1\n\n    #############################################################################\n    #                              END OF YOUR CODE                             #\n    #############################################################################\n\n    return loss, grads\n\n  def train(self, X, y, X_val, y_val,\n            learning_rate=1e-3, learning_rate_decay=0.95,\n            reg=5e-6, num_iters=100,\n            batch_size=200, verbose=False):\n    """"""\n    Train this neural network using stochastic gradient descent.\n\n    Inputs:\n    - X: A numpy array of shape (N, D) giving training data.\n    - y: A numpy array f shape (N,) giving training labels; y[i] = c means that\n      X[i] has label c, where 0 <= c < C.\n    - X_val: A numpy array of shape (N_val, D) giving validation data.\n    - y_val: A numpy array of shape (N_val,) giving validation labels.\n    - learning_rate: Scalar giving learning rate for optimization.\n    - learning_rate_decay: Scalar giving factor used to decay the learning rate\n      after each epoch.\n    - reg: Scalar giving regularization strength.\n    - num_iters: Number of steps to take when optimizing.\n    - batch_size: Number of training examples to use per step.\n    - verbose: boolean; if true print progress during optimization.\n    """"""\n    num_train = X.shape[0]\n    iterations_per_epoch = max(num_train / batch_size, 1)\n\n    # Use SGD to optimize the parameters in self.model\n    loss_history = []\n    train_acc_history = []\n    val_acc_history = []\n\n    for it in xrange(num_iters):\n      # X_batch = None\n      # y_batch = None\n\n      #########################################################################\n      # TODO: Create a random minibatch of training data and labels, storing  #\n      # them in X_batch and y_batch respectively.                             #\n      #########################################################################\n\n      # randomize indices\n      batch_ind = np.random.choice(num_train, batch_size)\n      X_batch = X[batch_ind]\n      y_batch = y[batch_ind]\n\n      #########################################################################\n      #                             END OF YOUR CODE                          #\n      #########################################################################\n\n      # Compute loss and gradients using the current minibatch\n      loss, grads = self.loss(X_batch, y=y_batch, reg=reg)\n      loss_history.append(loss)\n\n      #########################################################################\n      # TODO: Use the gradients in the grads dictionary to update the         #\n      # parameters of the network (stored in the dictionary self.params)      #\n      # using stochastic gradient descent. You\'ll need to use the gradients   #\n      # stored in the grads dictionary defined above.                         #\n      #########################################################################\n\n      self.params[\'W1\'] -= learning_rate * grads[\'W1\']\n      self.params[\'W2\'] -= learning_rate * grads[\'W2\']\n      self.params[\'b1\'] -= learning_rate * grads[\'b1\']\n      self.params[\'b2\'] -= learning_rate * grads[\'b2\']\n\n      #########################################################################\n      #                             END OF YOUR CODE                          #\n      #########################################################################\n\n      if verbose and it % 100 == 0:\n        print(\'iteration %d / %d: loss %f\' % (it, num_iters, loss))\n\n      # Every epoch, check train and val accuracy and decay learning rate.\n      if it % iterations_per_epoch == 0:\n        # Check accuracy\n        train_acc = (self.predict(X_batch) == y_batch).mean()\n        val_acc = (self.predict(X_val) == y_val).mean()\n        train_acc_history.append(train_acc)\n        val_acc_history.append(val_acc)\n\n        # Decay learning rate\n        learning_rate *= learning_rate_decay\n\n    return {\n      \'loss_history\': loss_history,\n      \'train_acc_history\': train_acc_history,\n      \'val_acc_history\': val_acc_history,\n    }\n\n  def predict(self, X):\n    """"""\n    Use the trained weights of this two-layer network to predict labels for\n    data points. For each data point we predict scores for each of the C\n    classes, and assign each data point to the class with the highest score.\n\n    Inputs:\n    - X: A numpy array of shape (N, D) giving N D-dimensional data points to\n      classify.\n\n    Returns:\n    - y_pred: A numpy array of shape (N,) giving predicted labels for each of\n      the elements of X. For all i, y_pred[i] = c means that X[i] is predicted\n      to have class c, where 0 <= c < C.\n    """"""\n    # y_pred = None\n\n    ###########################################################################\n    # TODO: Implement this function; it should be VERY simple!                #\n    ###########################################################################\n\n    y_pred = np.argmax(np.dot(np.maximum(0, X.dot(self.params[\'W1\']) + self.params[\'b1\']), self.params[\'W2\']) + self.params[\'b2\'], axis=1)\n\n    ###########################################################################\n    #                              END OF YOUR CODE                           #\n    ###########################################################################\n\n    return y_pred\n\n\n'"
assignment1/cs231n/classifiers/softmax.py,0,"b'import numpy as np\nfrom random import shuffle\n# from past.builtins import xrange\nimport sys\n\nif sys.version_info >= (3, 0):\n    def xrange(*args, **kwargs):\n        return iter(range(*args, **kwargs))\n\ndef softmax_loss_naive(W, X, y, reg):\n  """"""\n  Softmax loss function, naive implementation (with loops)\n\n  Inputs have dimension D, there are C classes, and we operate on minibatches\n  of N examples.\n\n  Inputs:\n  - W: A numpy array of shape (D, C) containing weights.\n  - X: A numpy array of shape (N, D) containing a minibatch of data.\n  - y: A numpy array of shape (N,) containing training labels; y[i] = c means\n    that X[i] has label c, where 0 <= c < C.\n  - reg: (float) regularization strength\n\n  Returns a tuple of:\n  - loss as single float\n  - gradient with respect to weights W; an array of same shape as W\n  """"""\n  # Initialize the loss and gradient to zero.\n  loss = 0.0\n  dW = np.zeros_like(W)\n\n  #############################################################################\n  # TODO: Compute the softmax loss and its gradient using explicit loops.     #\n  # Store the loss in loss and the gradient in dW. If you are not careful     #\n  # here, it is easy to run into numeric instability. Don\'t forget the        #\n  # regularization!                                                           #\n  #############################################################################\n\n  num_classes = W.shape[1]\n  num_train = X.shape[0]\n\n  for i in xrange(num_train):\n\n      # loss\n      scores = X[i].dot(W)\n      # shift values for \'scores\' for numeric reasons (over-flow cautious)\n      scores -= scores.max()\n      scores_expsum = np.sum(np.exp(scores))\n      cor_ex = np.exp(scores[y[i]])\n      loss += - np.log( cor_ex / scores_expsum)\n\n      # grad\n      # for correct class\n      dW[:, y[i]] += (-1) * (scores_expsum - cor_ex) / scores_expsum * X[i]\n      for j in xrange(num_classes):\n          # pass correct class gradient\n          if j == y[i]:\n              continue\n          # for incorrect classes\n          dW[:, j] += np.exp(scores[j]) / scores_expsum * X[i]\n\n  loss /= num_train\n  loss += reg * np.sum(W * W)\n  dW /= num_train\n  dW += 2 * reg * W\n\n  #############################################################################\n  #                          END OF YOUR CODE                                 #\n  #############################################################################\n\n  return loss, dW\n\n\ndef softmax_loss_vectorized(W, X, y, reg):\n  """"""\n  Softmax loss function, vectorized version.\n\n  Inputs and outputs are the same as softmax_loss_naive.\n  """"""\n  # Initialize the loss and gradient to zero.\n  loss = 0.0\n  dW = np.zeros_like(W)\n  num_classes = W.shape[1]\n  num_train = X.shape[0]\n\n  #############################################################################\n  # TODO: Compute the softmax loss and its gradient using no explicit loops.  #\n  # Store the loss in loss and the gradient in dW. If you are not careful     #\n  # here, it is easy to run into numeric instability. Don\'t forget the        #\n  # regularization!                                                           #\n  #############################################################################\n\n  # loss\n  # score: N by C matrix containing class scores\n  scores = X.dot(W)\n  scores -= scores.max()\n  scores = np.exp(scores)\n  scores_sums = np.sum(scores, axis=1)\n  cors = scores[range(num_train), y]\n  loss = cors / scores_sums\n  loss = -np.sum(np.log(loss))/num_train + reg * np.sum(W * W)\n\n  # grad\n  s = np.divide(scores, scores_sums.reshape(num_train, 1))\n  s[range(num_train), y] = - (scores_sums - cors) / scores_sums\n  dW = X.T.dot(s)\n  dW /= num_train\n  dW += 2 * reg * W\n\n  #############################################################################\n  #                          END OF YOUR CODE                                 #\n  #############################################################################\n\n  return loss, dW\n'"
assignment2/cs231n/classifiers/cnn.py,0,"b'from builtins import object\nimport numpy as np\n\nfrom cs231n.layers import *\nfrom cs231n.fast_layers import *\nfrom cs231n.layer_utils import *\n\n\nclass ThreeLayerConvNet(object):\n    """"""\n    A three-layer convolutional network with the following architecture:\n\n    conv - relu - 2x2 max pool - affine - relu - affine - softmax\n\n    The network operates on minibatches of data that have shape (N, C, H, W)\n    consisting of N images, each with height H and width W and with C input\n    channels.\n    """"""\n\n    def __init__(self, input_dim=(3, 32, 32), num_filters=32, filter_size=7,\n                 hidden_dim=100, num_classes=10, weight_scale=1e-3, reg=0.0,\n                 dtype=np.float32):\n        """"""\n        Initialize a new network.\n\n        Inputs:\n        - input_dim: Tuple (C, H, W) giving size of input data\n        - num_filters: Number of filters to use in the convolutional layer\n        - filter_size: Size of filters to use in the convolutional layer\n        - hidden_dim: Number of units to use in the fully-connected hidden layer\n        - num_classes: Number of scores to produce from the final affine layer.\n        - weight_scale: Scalar giving standard deviation for random initialization\n          of weights.\n        - reg: Scalar giving L2 regularization strength\n        - dtype: numpy datatype to use for computation.\n        """"""\n        self.params = {}\n        self.reg = reg\n        self.dtype = dtype\n\n        ############################################################################\n        # TODO: Initialize weights and biases for the three-layer convolutional    #\n        # network. Weights should be initialized from a Gaussian with standard     #\n        # deviation equal to weight_scale; biases should be initialized to zero.   #\n        # All weights and biases should be stored in the dictionary self.params.   #\n        # Store weights and biases for the convolutional layer using the keys \'W1\' #\n        # and \'b1\'; use keys \'W2\' and \'b2\' for the weights and biases of the       #\n        # hidden affine layer, and keys \'W3\' and \'b3\' for the weights and biases   #\n        # of the output affine layer.                                              #\n        ############################################################################\n\n        # Initialize Weights and Biases\n        C, H, W = input_dim\n        self.params[\'W1\'] = weight_scale * np.random.randn(num_filters, C, filter_size, filter_size)\n        self.params[\'b1\'] = np.zeros(num_filters)\n        # Assuming a shape identical to the input image for the conv layer output\n        self.params[\'W2\'] = weight_scale * np.random.randn(num_filters * H * W // 4, hidden_dim)\n        self.params[\'b2\'] = np.zeros(hidden_dim)\n        self.params[\'W3\'] = weight_scale * np.random.randn(hidden_dim, num_classes)\n        self.params[\'b3\'] = np.zeros(num_classes)\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        for k, v in self.params.items():\n            self.params[k] = v.astype(dtype)\n\n\n    def loss(self, X, y=None):\n        """"""\n        Evaluate loss and gradient for the three-layer convolutional network.\n\n        Input / output: Same API as TwoLayerNet in fc_net.py.\n        """"""\n        W1, b1 = self.params[\'W1\'], self.params[\'b1\']\n        W2, b2 = self.params[\'W2\'], self.params[\'b2\']\n        W3, b3 = self.params[\'W3\'], self.params[\'b3\']\n\n        # pass conv_param to the forward pass for the convolutional layer\n        filter_size = W1.shape[2]\n        conv_param = {\'stride\': 1, \'pad\': (filter_size - 1) // 2}\n\n        # pass pool_param to the forward pass for the max-pooling layer\n        pool_param = {\'pool_height\': 2, \'pool_width\': 2, \'stride\': 2}\n\n        scores = None\n        ############################################################################\n        # TODO: Implement the forward pass for the three-layer convolutional net,  #\n        # computing the class scores for X and storing them in the scores          #\n        # variable.                                                                #\n        ############################################################################\n\n        # Forward Pass: conv - relu - 2x2 max pool - affine - relu - affine - softmax\n        out1, cache1 = conv_relu_pool_forward(X, self.params[\'W1\'], self.params[\'b1\'], conv_param, pool_param)\n        out2, cache2 = affine_relu_forward(out1, self.params[\'W2\'], self.params[\'b2\'])\n        out3, cache3 = affine_forward(out2, self.params[\'W3\'], self.params[\'b3\'])\n        scores = out3\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        if y is None:\n            return scores\n\n        loss, grads = 0, {}\n        ############################################################################\n        # TODO: Implement the backward pass for the three-layer convolutional net, #\n        # storing the loss and gradients in the loss and grads variables. Compute  #\n        # data loss using softmax, and make sure that grads[k] holds the gradients #\n        # for self.params[k]. Don\'t forget to add L2 regularization!               #\n        ############################################################################\n\n        loss, dout = softmax_loss(out3, y)\n        loss += self.reg * np.sum([np.sum(self.params[\'W%d\' % i] ** 2) for i in [1, 2, 3]])\n        dout, grads[\'W3\'], grads[\'b3\'] = affine_backward(dout, cache3)\n        grads[\'W3\'] += 2 * self.reg * self.params[\'W3\']\n        dout, grads[\'W2\'], grads[\'b2\'] = affine_relu_backward(dout, cache2)\n        grads[\'W2\'] += 2 * self.reg * self.params[\'W2\']\n        _, grads[\'W1\'], grads[\'b1\'] = conv_relu_pool_backward(dout, cache1)\n        grads[\'W1\'] += 2 * self.reg * self.params[\'W1\']\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        return loss, grads\n'"
assignment2/cs231n/classifiers/fc_net.py,0,"b'from builtins import range\nfrom builtins import object\nimport numpy as np\n\nfrom cs231n.layers import *\nfrom cs231n.layer_utils import *\n\n\nclass TwoLayerNet(object):\n    """"""\n    A two-layer fully-connected neural network with ReLU nonlinearity and\n    softmax loss that uses a modular layer design. We assume an input dimension\n    of D, a hidden dimension of H, and perform classification over C classes.\n\n    The architecure should be affine - relu - affine - softmax.\n\n    Note that this class does not implement gradient descent; instead, it\n    will interact with a separate Solver object that is responsible for running\n    optimization.\n\n    The learnable parameters of the model are stored in the dictionary\n    self.params that maps parameter names to numpy arrays.\n    """"""\n\n    def __init__(self, input_dim=3*32*32, hidden_dim=100, num_classes=10,\n                 weight_scale=1e-3, reg=0.0):\n        """"""\n        Initialize a new network.\n\n        Inputs:\n        - input_dim: An integer giving the size of the input\n        - hidden_dim: An integer giving the size of the hidden layer\n        - num_classes: An integer giving the number of classes to classify\n        - dropout: Scalar between 0 and 1 giving dropout strength.\n        - weight_scale: Scalar giving the standard deviation for random\n          initialization of the weights.\n        - reg: Scalar giving L2 regularization strength.\n        """"""\n        self.params = {}\n        self.reg = reg\n\n        ############################################################################\n        # TODO: Initialize the weights and biases of the two-layer net. Weights    #\n        # should be initialized from a Gaussian with standard deviation equal to   #\n        # weight_scale, and biases should be initialized to zero. All weights and  #\n        # biases should be stored in the dictionary self.params, with first layer  #\n        # weights and biases using the keys \'W1\' and \'b1\' and second layer weights #\n        # and biases using the keys \'W2\' and \'b2\'.                                 #\n        ############################################################################\n\n        self.params[\'W1\'] = weight_scale * np.random.randn(input_dim, hidden_dim)\n        self.params[\'W2\'] = weight_scale * np.random.randn(hidden_dim, num_classes)\n        self.params[\'b1\'] = np.zeros(hidden_dim)\n        self.params[\'b2\'] = np.zeros(num_classes)\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n\n    def loss(self, X, y=None):\n        """"""\n        Compute loss and gradient for a minibatch of data.\n\n        Inputs:\n        - X: Array of input data of shape (N, d_1, ..., d_k)\n        - y: Array of labels, of shape (N,). y[i] gives the label for X[i].\n\n        Returns:\n        If y is None, then run a test-time forward pass of the model and return:\n        - scores: Array of shape (N, C) giving classification scores, where\n          scores[i, c] is the classification score for X[i] and class c.\n\n        If y is not None, then run a training-time forward and backward pass and\n        return a tuple of:\n        - loss: Scalar value giving the loss\n        - grads: Dictionary with the same keys as self.params, mapping parameter\n          names to gradients of the loss with respect to those parameters.\n        """"""\n        scores = None\n        ############################################################################\n        # TODO: Implement the forward pass for the two-layer net, computing the    #\n        # class scores for X and storing them in the scores variable.              #\n        ############################################################################\n\n        mid, cache1 = affine_relu_forward(X, self.params[\'W1\'], self.params[\'b1\'])\n        out, cache2 = affine_forward(mid, self.params[\'W2\'], self.params[\'b2\'])\n        scores = out\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        # If y is None then we are in test mode so just return scores\n        if y is None:\n            return scores\n\n        loss, grads = 0, {}\n        ############################################################################\n        # TODO: Implement the backward pass for the two-layer net. Store the loss  #\n        # in the loss variable and gradients in the grads dictionary. Compute data #\n        # loss using softmax, and make sure that grads[k] holds the gradients for  #\n        # self.params[k]. Don\'t forget to add L2 regularization!                   #\n        #                                                                          #\n        # NOTE: To ensure that your implementation matches ours and you pass the   #\n        # automated tests, make sure that your L2 regularization includes a factor #\n        # of 0.5 to simplify the expression for the gradient.                      #\n        ############################################################################\n\n        loss, dout = softmax_loss(scores, y)\n        loss += 0.5 * self.reg * (np.sum( self.params[\'W1\'] ** 2)) + \\\n                0.5 * self.reg * (np.sum( self.params[\'W2\'] ** 2))\n\n        dout, grads[\'W2\'], grads[\'b2\'] = affine_backward(dout, cache2)\n        _   , grads[\'W1\'], grads[\'b1\'] = affine_relu_backward(dout, cache1)\n        grads[\'W2\'] += self.reg * self.params[\'W2\']\n        grads[\'W1\'] += self.reg * self.params[\'W1\']\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        return loss, grads\n\n\nclass FullyConnectedNet(object):\n    """"""\n    A fully-connected neural network with an arbitrary number of hidden layers,\n    ReLU nonlinearities, and a softmax loss function. This will also implement\n    dropout and batch normalization as options. For a network with L layers,\n    the architecture will be\n\n    {affine - [batch norm] - relu - [dropout]} x (L - 1) - affine - softmax\n\n    where batch normalization and dropout are optional, and the {...} block is\n    repeated L - 1 times.\n\n    Similar to the TwoLayerNet above, learnable parameters are stored in the\n    self.params dictionary and will be learned using the Solver class.\n    """"""\n\n    def __init__(self, hidden_dims, input_dim=3*32*32, num_classes=10,\n                 dropout=0, use_batchnorm=False, reg=0.0,\n                 weight_scale=1e-2, dtype=np.float32, seed=None):\n        """"""\n        Initialize a new FullyConnectedNet.\n\n        Inputs:\n        - hidden_dims: A list of integers giving the size of each hidden layer.\n        - input_dim: An integer giving the size of the input.\n        - num_classes: An integer giving the number of classes to classify.\n        - dropout: Scalar between 0 and 1 giving dropout strength. If dropout=0 then\n          the network should not use dropout at all.\n        - use_batchnorm: Whether or not the network should use batch normalization.\n        - reg: Scalar giving L2 regularization strength.\n        - weight_scale: Scalar giving the standard deviation for random\n          initialization of the weights.\n        - dtype: A numpy datatype object; all computations will be performed using\n          this datatype. float32 is faster but less accurate, so you should use\n          float64 for numeric gradient checking.\n        - seed: If not None, then pass this random seed to the dropout layers. This\n          will make the dropout layers deteriminstic so we can gradient check the\n          model.\n        """"""\n        self.use_batchnorm = use_batchnorm\n        self.use_dropout = dropout > 0\n        self.reg = reg\n        self.num_layers = 1 + len(hidden_dims)\n        self.dtype = dtype\n        self.params = {}\n\n        ############################################################################\n        # TODO: Initialize the parameters of the network, storing all values in    #\n        # the self.params dictionary. Store weights and biases for the first layer #\n        # in W1 and b1; for the second layer use W2 and b2, etc. Weights should be #\n        # initialized from a normal distribution with standard deviation equal to  #\n        # weight_scale and biases should be initialized to zero.                   #\n        #                                                                          #\n        # When using batch normalization, store scale and shift parameters for the #\n        # first layer in gamma1 and beta1; for the second layer use gamma2 and     #\n        # beta2, etc. Scale parameters should be initialized to one and shift      #\n        # parameters should be initialized to zero.                                #\n        ############################################################################\n\n        dims = np.hstack((input_dim, hidden_dims, num_classes))\n\n        for i in range(self.num_layers):\n            self.params[\'W%d\' % (i + 1)] = weight_scale * np.random.randn(dims[i], dims[i+1])\n            self.params[\'b%d\' % (i + 1)] = np.zeros(dims[i+1])\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        # When using dropout we need to pass a dropout_param dictionary to each\n        # dropout layer so that the layer knows the dropout probability and the mode\n        # (train / test). You can pass the same dropout_param to each dropout layer.\n        self.dropout_param = {}\n        if self.use_dropout:\n            self.dropout_param = {\'mode\': \'train\', \'p\': dropout}\n            if seed is not None:\n                self.dropout_param[\'seed\'] = seed\n\n        # With batch normalization we need to keep track of running means and\n        # variances, so we need to pass a special bn_param object to each batch\n        # normalization layer. You should pass self.bn_params[0] to the forward pass\n        # of the first batch normalization layer, self.bn_params[1] to the forward\n        # pass of the second batch normalization layer, etc.\n        self.bn_params = []\n        if self.use_batchnorm:\n            self.bn_params = [{\'mode\': \'train\'} for i in range(self.num_layers - 1)]\n            for i in range(self.num_layers - 1):\n                self.params[\'gamma%d\' % (i + 1)] = np.ones(dims[i+1])\n                self.params[\'beta%d\' % (i + 1)] = np.zeros(dims[i+1])\n\n\n        # Cast all parameters to the correct datatype\n        for k, v in self.params.items():\n            self.params[k] = v.astype(dtype)\n\n\n    def loss(self, X, y=None):\n        """"""\n        Compute loss and gradient for the fully-connected net.\n\n        Input / output: Same as TwoLayerNet above.\n        """"""\n        X = X.astype(self.dtype)\n        mode = \'test\' if y is None else \'train\'\n\n        # Set train/test mode for batchnorm params and dropout param since they\n        # behave differently during training and testing.\n        if self.use_dropout:\n            self.dropout_param[\'mode\'] = mode\n        if self.use_batchnorm:\n            for bn_param in self.bn_params:\n                bn_param[\'mode\'] = mode\n\n        scores = None\n        ############################################################################\n        # TODO: Implement the forward pass for the fully-connected net, computing  #\n        # the class scores for X and storing them in the scores variable.          #\n        #                                                                          #\n        # When using dropout, you\'ll need to pass self.dropout_param to each       #\n        # dropout forward pass.                                                    #\n        #                                                                          #\n        # When using batch normalization, you\'ll need to pass self.bn_params[0] to #\n        # the forward pass for the first batch normalization layer, pass           #\n        # self.bn_params[1] to the forward pass for the second batch normalization #\n        # layer, etc.                                                              #\n        ############################################################################\n\n        hidden_num = self.num_layers - 1\n        scores = X\n        cache_history = []\n        L2reg = 0\n        for i in range(hidden_num):\n            if self.use_batchnorm:\n                scores, cache = affine_bn_relu_forward(scores,\n                                                      self.params[\'W%d\' % (i + 1)],\n                                                      self.params[\'b%d\' % (i + 1)],\n                                                      self.params[\'gamma%d\' % (i + 1)],\n                                                      self.params[\'beta%d\' % (i + 1)],\n                                                      self.bn_params[i])\n            else:\n                scores, cache = affine_relu_forward(scores, self.params[\'W%d\' % (i + 1)],\n                                                            self.params[\'b%d\' % (i + 1)])\n            cache_history.append(cache)\n            if self.use_dropout:\n                scores, cache = dropout_forward(scores, self.dropout_param)\n                cache_history.append(cache)\n            L2reg += np.sum(self.params[\'W%d\' % (i + 1)] ** 2)\n        i += 1\n        scores, cache = affine_forward(scores, self.params[\'W%d\' % (i + 1)],\n                                               self.params[\'b%d\' % (i + 1)])\n        cache_history.append(cache)\n        L2reg += np.sum(self.params[\'W%d\' % (i + 1)] ** 2)\n        L2reg *= 0.5 * self.reg\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        # If test mode return early\n        if mode == \'test\':\n            return scores\n\n        loss, grads = 0.0, {}\n        ############################################################################\n        # TODO: Implement the backward pass for the fully-connected net. Store the #\n        # loss in the loss variable and gradients in the grads dictionary. Compute #\n        # data loss using softmax, and make sure that grads[k] holds the gradients #\n        # for self.params[k]. Don\'t forget to add L2 regularization!               #\n        #                                                                          #\n        # When using batch normalization, you don\'t need to regularize the scale   #\n        # and shift parameters.                                                    #\n        #                                                                          #\n        # NOTE: To ensure that your implementation matches ours and you pass the   #\n        # automated tests, make sure that your L2 regularization includes a factor #\n        # of 0.5 to simplify the expression for the gradient.                      #\n        ############################################################################\n\n        loss, dout = softmax_loss(scores, y)\n        loss += L2reg\n\n        dout, grads[\'W%d\' % (i + 1)], grads[\'b%d\' % (i + 1)] = affine_backward(dout, cache_history.pop())\n        grads[\'W%d\' % (i + 1)] += self.reg * self.params[\'W%d\' % (i + 1)]\n        i -= 1\n        while i >= 0:\n            if self.use_dropout:\n                dout = dropout_backward(dout, cache_history.pop())\n            if self.use_batchnorm:\n                dout, grads[\'W%d\' % (i + 1)], grads[\'b%d\' % (i + 1)], grads[\'gamma%d\' % (i + 1)], grads[\'beta%d\' % (i + 1)] = affine_bn_relu_backward(dout, cache_history.pop())\n            else:\n                dout, grads[\'W%d\' % (i + 1)], grads[\'b%d\' % (i + 1)] = affine_relu_backward(dout, cache_history.pop())\n            grads[\'W%d\' % (i + 1)] += self.reg * self.params[\'W%d\' % (i + 1)]\n            i -= 1\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        return loss, grads\n\n\n# Batch-Normalization Layer Utilities\ndef affine_bn_relu_forward(x, w, b, gamma, beta, bn_param):\n    """"""\n    Convenience layer that performs an affine transform, batch normalization and ReLU\n    """"""\n    out1, fc_cache = affine_forward(x, w, b)\n    out2, bn_cache = batchnorm_forward(out1, gamma, beta, bn_param)\n    out3, relu_cache = relu_forward(out2)\n    cache = (fc_cache, bn_cache, relu_cache)\n    return out3, cache\n\ndef affine_bn_relu_backward(dout, cache):\n    """"""\n        Backward pass for the affine-bn-relu convenience layer\n    """"""\n    fc_cache, bn_cache, relu_cache = cache\n    d1 = relu_backward(dout, relu_cache)\n    d2, dgamma, dbeta = batchnorm_backward(d1, bn_cache)\n    d3, dw, db = affine_backward(d2, fc_cache)\n    return d3, dw, db, dgamma, dbeta'"
assignment3/cs231n/classifiers/rnn.py,0,"b'from builtins import range\nfrom builtins import object\nimport numpy as np\n\nfrom cs231n.layers import *\nfrom cs231n.rnn_layers import *\n\n\nclass CaptioningRNN(object):\n    """"""\n    A CaptioningRNN produces captions from image features using a recurrent\n    neural network.\n\n    The RNN receives input vectors of size D, has a vocab size of V, works on\n    sequences of length T, has an RNN hidden dimension of H, uses word vectors\n    of dimension W, and operates on minibatches of size N.\n\n    Note that we don\'t use any regularization for the CaptioningRNN.\n    """"""\n\n    def __init__(self, word_to_idx, input_dim=512, wordvec_dim=128,\n                 hidden_dim=128, cell_type=\'rnn\', dtype=np.float32):\n        """"""\n        Construct a new CaptioningRNN instance.\n\n        Inputs:\n        - word_to_idx: A dictionary giving the vocabulary. It contains V entries,\n          and maps each string to a unique integer in the range [0, V).\n        - input_dim: Dimension D of input image feature vectors.\n        - wordvec_dim: Dimension W of word vectors.\n        - hidden_dim: Dimension H for the hidden state of the RNN.\n        - cell_type: What type of RNN to use; either \'rnn\' or \'lstm\'.\n        - dtype: numpy datatype to use; use float32 for training and float64 for\n          numeric gradient checking.\n        """"""\n        if cell_type not in {\'rnn\', \'lstm\'}:\n            raise ValueError(\'Invalid cell_type ""%s""\' % cell_type)\n\n        self.cell_type = cell_type\n        self.dtype = dtype\n        self.word_to_idx = word_to_idx\n        self.idx_to_word = {i: w for w, i in word_to_idx.items()}\n        self.params = {}\n\n        vocab_size = len(word_to_idx)\n\n        self._null = word_to_idx[\'<NULL>\']\n        self._start = word_to_idx.get(\'<START>\', None)\n        self._end = word_to_idx.get(\'<END>\', None)\n\n        # Initialize word vectors\n        self.params[\'W_embed\'] = np.random.randn(vocab_size, wordvec_dim)\n        self.params[\'W_embed\'] /= 100\n\n        # Initialize CNN -> hidden state projection parameters\n        self.params[\'W_proj\'] = np.random.randn(input_dim, hidden_dim)\n        self.params[\'W_proj\'] /= np.sqrt(input_dim)\n        self.params[\'b_proj\'] = np.zeros(hidden_dim)\n\n        # Initialize parameters for the RNN\n        dim_mul = {\'lstm\': 4, \'rnn\': 1}[cell_type]\n        self.params[\'Wx\'] = np.random.randn(wordvec_dim, dim_mul * hidden_dim)\n        self.params[\'Wx\'] /= np.sqrt(wordvec_dim)\n        self.params[\'Wh\'] = np.random.randn(hidden_dim, dim_mul * hidden_dim)\n        self.params[\'Wh\'] /= np.sqrt(hidden_dim)\n        self.params[\'b\'] = np.zeros(dim_mul * hidden_dim)\n\n        # Initialize output to vocab weights\n        self.params[\'W_vocab\'] = np.random.randn(hidden_dim, vocab_size)\n        self.params[\'W_vocab\'] /= np.sqrt(hidden_dim)\n        self.params[\'b_vocab\'] = np.zeros(vocab_size)\n\n        # Cast parameters to correct dtype\n        for k, v in self.params.items():\n            self.params[k] = v.astype(self.dtype)\n\n\n    def loss(self, features, captions):\n        """"""\n        Compute training-time loss for the RNN. We input image features and\n        ground-truth captions for those images, and use an RNN (or LSTM) to compute\n        loss and gradients on all parameters.\n\n        Inputs:\n        - features: Input image features, of shape (N, D)\n        - captions: Ground-truth captions; an integer array of shape (N, T) where\n          each element is in the range 0 <= y[i, t] < V\n\n        Returns a tuple of:\n        - loss: Scalar loss\n        - grads: Dictionary of gradients parallel to self.params\n        """"""\n        # Cut captions into two pieces: captions_in has everything but the last word\n        # and will be input to the RNN; captions_out has everything but the first\n        # word and this is what we will expect the RNN to generate. These are offset\n        # by one relative to each other because the RNN should produce word (t+1)\n        # after receiving word t. The first element of captions_in will be the START\n        # token, and the first element of captions_out will be the first word.\n        captions_in = captions[:, :-1]\n        captions_out = captions[:, 1:]\n\n        # You\'ll need this\n        mask = (captions_out != self._null)\n\n        # Weight and bias for the affine transform from image features to initial\n        # hidden state\n        W_proj, b_proj = self.params[\'W_proj\'], self.params[\'b_proj\']\n\n        # Word embedding matrix\n        W_embed = self.params[\'W_embed\']\n\n        # Input-to-hidden, hidden-to-hidden, and biases for the RNN\n        Wx, Wh, b = self.params[\'Wx\'], self.params[\'Wh\'], self.params[\'b\']\n\n        # Weight and bias for the hidden-to-vocab transformation.\n        W_vocab, b_vocab = self.params[\'W_vocab\'], self.params[\'b_vocab\']\n\n        loss, grads = 0.0, {}\n        ############################################################################\n        # TODO: Implement the forward and backward passes for the CaptioningRNN.   #\n        # In the forward pass you will need to do the following:                   #\n        # (1) Use an affine transformation to compute the initial hidden state     #\n        #     from the image features. This should produce an array of shape (N, H)#\n        # (2) Use a word embedding layer to transform the words in captions_in     #\n        #     from indices to vectors, giving an array of shape (N, T, W).         #\n        # (3) Use either a vanilla RNN or LSTM (depending on self.cell_type) to    #\n        #     process the sequence of input word vectors and produce hidden state  #\n        #     vectors for all timesteps, producing an array of shape (N, T, H).    #\n        # (4) Use a (temporal) affine transformation to compute scores over the    #\n        #     vocabulary at every timestep using the hidden states, giving an      #\n        #     array of shape (N, T, V).                                            #\n        # (5) Use (temporal) softmax to compute loss using captions_out, ignoring  #\n        #     the points where the output word is <NULL> using the mask above.     #\n        #                                                                          #\n        # In the backward pass you will need to compute the gradient of the loss   #\n        # with respect to all model parameters. Use the loss and grads variables   #\n        # defined above to store loss and gradients; grads[k] should give the      #\n        # gradients for self.params[k].                                            #\n        ############################################################################\n\n        # Forward Pass\n        # (1)\n        h0, cache_affine = affine_forward(features, W_proj, b_proj)\n        # (2)\n        embedded_captions_in, cache_embed_in = word_embedding_forward(captions_in, W_embed)\n        # (3)\n        forward_net = {\'lstm\': lstm_forward, \'rnn\': rnn_forward}[self.cell_type]\n        h, cache_rnn = forward_net(embedded_captions_in, h0, Wx, Wh, b)\n        # (4)\n        y, cache_temporal = temporal_affine_forward(h, W_vocab, b_vocab)\n        # (5)\n        loss, dout = temporal_softmax_loss(y, captions_out, mask)\n\n        # Gradients\n        # (4)\n        dout, grads[\'W_vocab\'], grads[\'b_vocab\'] = temporal_affine_backward(dout, cache_temporal)\n        # (3)\n        backward_net = {\'lstm\': lstm_backward, \'rnn\': rnn_backward}[self.cell_type]\n        dout, dh0, grads[\'Wx\'], grads[\'Wh\'], grads[\'b\'] = backward_net(dout, cache_rnn)\n        # (2)\n        grads[\'W_embed\'] = word_embedding_backward(dout, cache_embed_in)\n        # (1)\n        _, grads[\'W_proj\'], grads[\'b_proj\'] = affine_backward(dh0, cache_affine)\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n\n        return loss, grads\n\n\n    def sample(self, features, max_length=30):\n        """"""\n        Run a test-time forward pass for the model, sampling captions for input\n        feature vectors.\n\n        At each timestep, we embed the current word, pass it and the previous hidden\n        state to the RNN to get the next hidden state, use the hidden state to get\n        scores for all vocab words, and choose the word with the highest score as\n        the next word. The initial hidden state is computed by applying an affine\n        transform to the input image features, and the initial word is the <START>\n        token.\n\n        For LSTMs you will also have to keep track of the cell state; in that case\n        the initial cell state should be zero.\n\n        Inputs:\n        - features: Array of input image features of shape (N, D).\n        - max_length: Maximum length T of generated captions.\n\n        Returns:\n        - captions: Array of shape (N, max_length) giving sampled captions,\n          where each element is an integer in the range [0, V). The first element\n          of captions should be the first sampled word, not the <START> token.\n        """"""\n        N = features.shape[0]\n        captions = self._null * np.ones((N, max_length), dtype=np.int32)\n\n        # Unpack parameters\n        W_proj, b_proj = self.params[\'W_proj\'], self.params[\'b_proj\']\n        W_embed = self.params[\'W_embed\']\n        Wx, Wh, b = self.params[\'Wx\'], self.params[\'Wh\'], self.params[\'b\']\n        W_vocab, b_vocab = self.params[\'W_vocab\'], self.params[\'b_vocab\']\n\n        ###########################################################################\n        # TODO: Implement test-time sampling for the model. You will need to      #\n        # initialize the hidden state of the RNN by applying the learned affine   #\n        # transform to the input image features. The first word that you feed to  #\n        # the RNN should be the <START> token; its value is stored in the         #\n        # variable self._start. At each timestep you will need to do to:          #\n        # (1) Embed the previous word using the learned word embeddings           #\n        # (2) Make an RNN step using the previous hidden state and the embedded   #\n        #     current word to get the next hidden state.                          #\n        # (3) Apply the learned affine transformation to the next hidden state to #\n        #     get scores for all words in the vocabulary                          #\n        # (4) Select the word with the highest score as the next word, writing it #\n        #     to the appropriate slot in the captions variable                    #\n        #                                                                         #\n        # For simplicity, you do not need to stop generating after an <END> token #\n        # is sampled, but you can if you want to.                                 #\n        #                                                                         #\n        # HINT: You will not be able to use the rnn_forward or lstm_forward       #\n        # functions; you\'ll need to call rnn_step_forward or lstm_step_forward in #\n        # a loop.                                                                 #\n        ###########################################################################\n\n        h0 = features.dot(W_proj) + b_proj\n        start = (self._start * np.ones(N)).astype(np.int32)\n        x = W_embed[start, :]\n\n        forward_step = {\'lstm\': lstm_step_forward, \'rnn\': rnn_step_forward}[self.cell_type]\n\n        h = h0\n        c = 0\n        for t in range(max_length):\n            h, c, _ = forward_step(x, h, c, Wx, Wh, b)\n            y = h.dot(W_vocab) + b_vocab\n            captions[:, t] = np.argmax(y, axis=1)\n            x = W_embed[captions[:, t], :]\n\n\n        ############################################################################\n        #                             END OF YOUR CODE                             #\n        ############################################################################\n        return captions\n'"
assignment3/cs231n/classifiers/squeezenet.py,55,"b'import tensorflow as tf\n\nNUM_CLASSES = 1000\n\ndef fire_module(x,inp,sp,e11p,e33p):\n    with tf.variable_scope(""fire""):\n        with tf.variable_scope(""squeeze""):\n            W = tf.get_variable(""weights"",shape=[1,1,inp,sp])\n            b = tf.get_variable(""bias"",shape=[sp])\n            s = tf.nn.conv2d(x,W,[1,1,1,1],""VALID"")+b\n            s = tf.nn.relu(s)\n        with tf.variable_scope(""e11""):\n            W = tf.get_variable(""weights"",shape=[1,1,sp,e11p])\n            b = tf.get_variable(""bias"",shape=[e11p])\n            e11 = tf.nn.conv2d(s,W,[1,1,1,1],""VALID"")+b\n            e11 = tf.nn.relu(e11)\n        with tf.variable_scope(""e33""):\n            W = tf.get_variable(""weights"",shape=[3,3,sp,e33p])\n            b = tf.get_variable(""bias"",shape=[e33p])\n            e33 = tf.nn.conv2d(s,W,[1,1,1,1],""SAME"")+b\n            e33 = tf.nn.relu(e33)\n        return tf.concat([e11,e33],3)\n\n\nclass SqueezeNet(object):\n    def extract_features(self, input=None, reuse=True):\n        if input is None:\n            input = self.image\n        x = input\n        layers = []\n        with tf.variable_scope(\'features\', reuse=reuse):\n            with tf.variable_scope(\'layer0\'):\n                W = tf.get_variable(""weights"",shape=[3,3,3,64])\n                b = tf.get_variable(""bias"",shape=[64])\n                x = tf.nn.conv2d(x,W,[1,2,2,1],""VALID"")\n                x = tf.nn.bias_add(x,b)\n                layers.append(x)\n            with tf.variable_scope(\'layer1\'):\n                x = tf.nn.relu(x)\n                layers.append(x)\n            with tf.variable_scope(\'layer2\'):\n                x = tf.nn.max_pool(x,[1,3,3,1],strides=[1,2,2,1],padding=\'VALID\')\n                layers.append(x)\n            with tf.variable_scope(\'layer3\'):\n                x = fire_module(x,64,16,64,64)\n                layers.append(x)\n            with tf.variable_scope(\'layer4\'):\n                x = fire_module(x,128,16,64,64)\n                layers.append(x)\n            with tf.variable_scope(\'layer5\'):\n                x = tf.nn.max_pool(x,[1,3,3,1],strides=[1,2,2,1],padding=\'VALID\')\n                layers.append(x)\n            with tf.variable_scope(\'layer6\'):\n                x = fire_module(x,128,32,128,128)\n                layers.append(x)\n            with tf.variable_scope(\'layer7\'):\n                x = fire_module(x,256,32,128,128)\n                layers.append(x)\n            with tf.variable_scope(\'layer8\'):\n                x = tf.nn.max_pool(x,[1,3,3,1],strides=[1,2,2,1],padding=\'VALID\')\n                layers.append(x)\n            with tf.variable_scope(\'layer9\'):\n                x = fire_module(x,256,48,192,192)\n                layers.append(x)\n            with tf.variable_scope(\'layer10\'):\n                x = fire_module(x,384,48,192,192)\n                layers.append(x)\n            with tf.variable_scope(\'layer11\'):\n                x = fire_module(x,384,64,256,256)\n                layers.append(x)\n            with tf.variable_scope(\'layer12\'):\n                x = fire_module(x,512,64,256,256)\n                layers.append(x)\n        return layers\n\n    def __init__(self, save_path=None, sess=None):\n        """"""Create a SqueezeNet model.\n        Inputs:\n        - save_path: path to TensorFlow checkpoint\n        - sess: TensorFlow session\n        - input: optional input to the model. If None, will use placeholder for input.\n        """"""\n        self.image = tf.placeholder(\'float\',shape=[None,None,None,3],name=\'input_image\')\n        self.labels = tf.placeholder(\'int32\', shape=[None], name=\'labels\')\n        self.layers = []\n        x = self.image\n        self.layers = self.extract_features(x, reuse=False)\n        self.features = self.layers[-1]\n        with tf.variable_scope(\'classifier\'):\n            with tf.variable_scope(\'layer0\'):\n                x = self.features\n                self.layers.append(x)\n            with tf.variable_scope(\'layer1\'):\n                W = tf.get_variable(""weights"",shape=[1,1,512,1000])\n                b = tf.get_variable(""bias"",shape=[1000])\n                x = tf.nn.conv2d(x,W,[1,1,1,1],""VALID"")\n                x = tf.nn.bias_add(x,b)\n                self.layers.append(x)\n            with tf.variable_scope(\'layer2\'):\n                x = tf.nn.relu(x)\n                self.layers.append(x)\n            with tf.variable_scope(\'layer3\'):\n                x = tf.nn.avg_pool(x,[1,13,13,1],strides=[1,13,13,1],padding=\'VALID\')\n                self.layers.append(x)\n        self.classifier = tf.reshape(x,[-1, NUM_CLASSES])\n\n        if save_path is not None:\n            saver = tf.train.Saver()\n            saver.restore(sess, save_path)\n        self.loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=tf.one_hot(self.labels, NUM_CLASSES), logits=self.classifier))\n'"
