file_path,api_count,code
test.py,0,"b""keep_prob = 0.5\nlearning_rate = 0.0001\nnb_epoch = 100\nsamples_per_epoch = 3000\nbatch_size = 40\n\nprint('keep_prob = ', keep_prob)\nprint('learning_rate = ', learning_rate)\nprint('nb_epoch = ', nb_epoch)\nprint('samples_per_epoch = ', samples_per_epoch)\nprint('batch_size = ', batch_size)\nprint('-' * 30)"""
zth_car_control.py,0,"b""import RPi.GPIO as GPIO\nimport time\n\n# \xe8\xae\xbe\xe5\xae\x9a\xe9\x80\x9f\xe5\xba\xa6\xef\xbc\x8c\xe6\xbb\xa1\xe7\x94\xb5\xe6\x97\xb6\xe9\x80\x9f\xe5\xba\xa6\xe5\xa4\xaa\xe5\xbf\xab\xef\xbc\x8c\xe5\x9b\xbe\xe5\x83\x8f\xe5\xa4\x84\xe7\x90\x86\xe9\x80\x9f\xe5\xba\xa6\xe8\xb7\x9f\xe4\xb8\x8d\xe4\xb8\x8a\n# \xe7\x9b\xb4\xe8\xa1\x8c\xe5\xbf\xab\xe4\xb8\x80\xe7\x82\xb9\xef\xbc\x8c\xe8\xbd\xac\xe5\x90\x91\xe6\x85\xa2\xe4\xb8\x80\xe7\x82\xb9\nspeed1 = 60          # \xe7\x9b\xb4\xe8\xa1\x8c\xe9\x80\x9f\xe5\xba\xa6\nspeed2 = 50          # \xe6\x8b\x90\xe5\xbc\xaf\xe9\x80\x9f\xe5\xba\xa6\n# \xe8\xbd\xae\xe5\xad\x90\xe5\xae\x9a\xe4\xb9\x89\nbackMotorinput1 = 7   #\xe5\x90\x8e\xe8\xbd\xae1\nbackMotorinput2 = 11   #\xe5\x90\x8e\xe8\xbd\xae2\n\nfrontMotorinput1 = 15    #\xe5\x89\x8d\xe8\xbd\xae1\nfrontMotorinput2 = 13    #\xe5\x89\x8d\xe8\xbd\xae2\n\nbackMotorEn = 12    #\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa31\nfrontMotorEn = 16    #\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa32\n\nGPIO.setmode(GPIO.BOARD)                         # \xe8\xae\xbe\xe7\xbd\xae\xe6\xa8\xa1\xe5\xbc\x8f\nGPIO.setup(backMotorinput1,GPIO.OUT)             # \xe6\xad\xa4\xe7\xab\xaf\xe5\x8f\xa3\xe4\xb8\xba\xe8\xbe\x93\xe5\x87\xba\xe6\xa8\xa1\xe5\xbc\x8f\nGPIO.setup(backMotorinput2,GPIO.OUT)             # \xe6\xad\xa4\xe7\xab\xaf\xe5\x8f\xa3\xe4\xb8\xba\xe8\xbe\x93\xe5\x87\xba\xe6\xa8\xa1\xe5\xbc\x8f\nGPIO.setup(frontMotorinput1,GPIO.OUT)            # \xe6\xad\xa4\xe7\xab\xaf\xe5\x8f\xa3\xe4\xb8\xba\xe8\xbe\x93\xe5\x87\xba\xe6\xa8\xa1\xe5\xbc\x8f\nGPIO.setup(frontMotorinput2,GPIO.OUT)            # \xe6\xad\xa4\xe7\xab\xaf\xe5\x8f\xa3\xe4\xb8\xba\xe8\xbe\x93\xe5\x87\xba\xe6\xa8\xa1\xe5\xbc\x8f\nGPIO.setup(backMotorEn,GPIO.OUT)\nGPIO.setup(frontMotorEn,GPIO.OUT)\n# \xe5\xb0\x86\xe6\x8e\xa7\xe5\x88\xb6\xe5\xb0\x8f\xe8\xbd\xa6\xe8\xbf\x90\xe5\x8a\xa8\xe5\xb0\x81\xe8\xa3\x85\xe4\xb8\xba\xe5\x87\xbd\xe6\x95\xb0\nbackMotorPwm = GPIO.PWM(backMotorEn,100)         # \xe9\x85\x8d\xe7\xbd\xaePWM\nbackMotorPwm.start(0)                            # \xe5\xbc\x80\xe5\xa7\x8b\xe8\xbe\x93\xe5\x87\xbaPWM\n# \xe5\xbd\x93\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa3\xe8\xbe\x93\xe5\x85\xa5\xe4\xbd\x8e\xe7\x94\xb5\xe5\x8e\x8b\xe6\x97\xb6\xef\xbc\x8c\xe7\x94\xb5\xe6\x9c\xba\xe9\xa9\xb1\xe5\x8a\xa8\xe6\x9d\xbf\xe5\xb0\x86\xe4\xb8\x8d\xe5\xaf\xb9\xe7\x94\xb5\xe6\x9c\xba\xe8\xbe\x93\xe5\x87\xba\xe7\x94\xb5\xe6\xb5\x81\xef\xbc\x8c\xe7\x94\xb5\xe6\x9c\xba\xe5\xb0\x86\xe4\xb8\x8d\xe5\xb7\xa5\xe4\xbd\x9c\xe3\x80\x82\n# \xe5\xbd\x93\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa3\xe8\xbe\x93\xe5\x85\xa5\xe9\xab\x98\xe7\x94\xb5\xe5\x8e\x8b\xe6\x97\xb6\xef\xbc\x8c\xe8\xae\xa9\xe5\x89\x8d\xe8\xbd\xae\xe8\xbd\xac\xe5\x90\x91\xe7\x94\xb5\xe6\x9c\xba\xe6\xad\xa3\xe5\xb8\xb8\xe5\xb7\xa5\xe4\xbd\x9c\xe3\x80\x82\n# \xe5\x90\x91\xe5\x89\x8d\xe8\xb5\xb0\ndef car_move_forward():\n\tGPIO.output(backMotorinput1,GPIO.HIGH)\n\tGPIO.output(backMotorinput2,GPIO.LOW)\n\tbackMotorPwm.ChangeDutyCycle(speed1)         # \xe6\x94\xb9\xe5\x8f\x98PWM\xe5\x8d\xa0\xe7\xa9\xba\xe6\xaf\x94\xef\xbc\x8c\xe5\x8f\x82\xe6\x95\xb0\xe4\xb8\xba\xe5\x8d\xa0\xe7\xa9\xba\xe6\xaf\x94\n# \xe5\x90\x91\xe5\x90\x8e\xe9\x80\x80\ndef car_move_backward():\n\tGPIO.output(backMotorinput1,GPIO.LOW)\n\tGPIO.output(backMotorinput2,GPIO.HIGH)\n\tbackMotorPwm.ChangeDutyCycle(speed2)\n# \xe5\xb7\xa6\xe6\x8b\x90\ndef car_turn_left():\n\tGPIO.output(frontMotorEn,GPIO.HIGH)    # \xe5\xbd\x93\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa3\xe8\xbe\x93\xe5\x85\xa5\xe9\xab\x98\xe7\x94\xb5\xe5\x8e\x8b\xe6\x97\xb6\xef\xbc\x8c\xe8\xae\xa9\xe5\x89\x8d\xe8\xbd\xae\xe8\xbd\xac\xe5\x90\x91\xe7\x94\xb5\xe6\x9c\xba\xe6\xad\xa3\xe5\xb8\xb8\xe5\xb7\xa5\xe4\xbd\x9c\xe3\x80\x82\n\tGPIO.output(frontMotorinput1,GPIO.HIGH)\n\tGPIO.output(frontMotorinput2,GPIO.LOW)\n\tGPIO.output(backMotorinput1,GPIO.HIGH)\n\tGPIO.output(backMotorinput2,GPIO.LOW)\n\tbackMotorPwm.ChangeDutyCycle(speed2)\n# \xe5\x8f\xb3\xe6\x8b\x90\t\ndef car_turn_right():\n\tGPIO.output(frontMotorEn,GPIO.HIGH)    # \xe5\xbd\x93\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa3\xe8\xbe\x93\xe5\x85\xa5\xe9\xab\x98\xe7\x94\xb5\xe5\x8e\x8b\xe6\x97\xb6\xef\xbc\x8c\xe8\xae\xa9\xe5\x89\x8d\xe8\xbd\xae\xe8\xbd\xac\xe5\x90\x91\xe7\x94\xb5\xe6\x9c\xba\xe6\xad\xa3\xe5\xb8\xb8\xe5\xb7\xa5\xe4\xbd\x9c\xe3\x80\x82\n\tGPIO.output(frontMotorinput1,GPIO.LOW)\n\tGPIO.output(frontMotorinput2,GPIO.HIGH)\n\tGPIO.output(backMotorinput1,GPIO.HIGH)\n\tGPIO.output(backMotorinput2,GPIO.LOW)\n\tbackMotorPwm.ChangeDutyCycle(speed2)\n# \ndef carbackleft():\n\tGPIO.output(frontMotorEn,GPIO.HIGH)    # \xe5\xbd\x93\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa3\xe8\xbe\x93\xe5\x85\xa5\xe9\xab\x98\xe7\x94\xb5\xe5\x8e\x8b\xe6\x97\xb6\xef\xbc\x8c\xe8\xae\xa9\xe5\x89\x8d\xe8\xbd\xae\xe8\xbd\xac\xe5\x90\x91\xe7\x94\xb5\xe6\x9c\xba\xe6\xad\xa3\xe5\xb8\xb8\xe5\xb7\xa5\xe4\xbd\x9c\xe3\x80\x82\n\tGPIO.output(frontMotorinput1,GPIO.HIGH)\n\tGPIO.output(frontMotorinput2,GPIO.LOW)\n\tGPIO.output(backMotorinput1,GPIO.LOW)\n\tGPIO.output(backMotorinput2,GPIO.HIGH)\n\tbackMotorPwm.ChangeDutyCycle(speed2)\n# \ndef carbackRight():\n\tGPIO.output(frontMotorEn,GPIO.HIGH)    # \xe5\xbd\x93\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa3\xe8\xbe\x93\xe5\x85\xa5\xe9\xab\x98\xe7\x94\xb5\xe5\x8e\x8b\xe6\x97\xb6\xef\xbc\x8c\xe8\xae\xa9\xe5\x89\x8d\xe8\xbd\xae\xe8\xbd\xac\xe5\x90\x91\xe7\x94\xb5\xe6\x9c\xba\xe6\xad\xa3\xe5\xb8\xb8\xe5\xb7\xa5\xe4\xbd\x9c\xe3\x80\x82\n\tGPIO.output(frontMotorinput1,GPIO.LOW)\n\tGPIO.output(frontMotorinput2,GPIO.HIGH)\n\tGPIO.output(backMotorinput1,GPIO.LOW)\n\tGPIO.output(backMotorinput2,GPIO.HIGH)\n\tbackMotorPwm.ChangeDutyCycle(speed2)\n# \xe6\xb8\x85\xe9\x99\xa4\ndef clean_GPIO():\n\tGPIO.cleanup()\n\tbackMotorPwm.stop()                          # \xe5\x81\x9c\xe6\xad\xa2\xe8\xbe\x93\xe5\x87\xbaPWM\n# \xe5\x89\x8d\xe8\xbd\xae\xe5\x9b\x9e\xe6\xad\xa3\xe5\x87\xbd\xe6\x95\xb0\ndef car_turn_straight():\n\tGPIO.output(frontMotorEn,GPIO.LOW)    # \xe5\xbd\x93\xe4\xbd\xbf\xe8\x83\xbd\xe7\xab\xaf\xe5\x8f\xa3\xe8\xbe\x93\xe5\x85\xa5\xe4\xbd\x8e\xe7\x94\xb5\xe5\x8e\x8b\xe6\x97\xb6\xef\xbc\x8c\xe7\x94\xb5\xe6\x9c\xba\xe9\xa9\xb1\xe5\x8a\xa8\xe6\x9d\xbf\xe5\xb0\x86\xe4\xb8\x8d\xe5\xaf\xb9\xe7\x94\xb5\xe6\x9c\xba\xe8\xbe\x93\xe5\x87\xba\xe7\x94\xb5\xe6\xb5\x81\xef\xbc\x8c\xe7\x94\xb5\xe6\x9c\xba\xe5\xb0\x86\xe4\xb8\x8d\xe5\xb7\xa5\xe4\xbd\x9c\xe3\x80\x82\n\ttime.sleep(0.05)\n# \xe5\x81\x9c\xe6\xad\xa2\ndef car_stop():\n\tGPIO.output(backMotorinput1,GPIO.LOW)\n\tGPIO.output(backMotorinput2,GPIO.LOW)\n\tGPIO.output(frontMotorEn,GPIO.LOW)\n\nif __name__ == '__main__':\n\tcar_turn_straight()\n\tcar_move_forward()\n\ttime.sleep(10)\n\tclean_GPIO()\n"""
zth_collect_data.py,0,"b'# \xe6\x94\xb6\xe9\x9b\x86\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x8c\xe8\xb5\x9b\xe9\x81\x93\xe7\x85\xa7\xe7\x89\x87\xe5\x92\x8c\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe5\x89\x8d\xe3\x80\x81\xe5\x90\x8e\xe3\x80\x81\xe5\xb7\xa6\xe3\x80\x81\xe5\x8f\xb3\xe3\x80\x814\xe5\x81\x9c\n# \xe5\xaf\xb9\xe5\xba\x94\xe5\x9b\xbe\xe7\x89\x87\xe5\x92\x8c\xe7\x9b\xb8\xe5\xba\x94\xe7\x9a\x84\xe6\xa0\x87\xe7\xad\xbe\xe5\x80\xbc\nimport io\nimport zth_car_control\nimport os\nos.environ[\'SDL_VIDEODRIVE\'] = \'x11\'\nimport pygame     # \xe6\xa3\x80\xe6\xb5\x8b\xe6\xa8\xa1\xe5\x9d\x97\nfrom time import ctime,sleep,time\nimport threading\nimport numpy as np\nimport picamera\nimport picamera.array\n\nglobal train_labels, train_img, is_capture_running, key\n\nclass SplitFrames(object):\n    \n    def __init__(self):\n        self.frame_num = 0\n        self.output = None\n# \xe5\xa4\x84\xe7\x90\x86\xe5\x9b\xbe\xe5\x83\x8f\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0write\n# \xe5\xaf\xb9\xe8\xa7\x86\xe9\xa2\x91\xe6\x8b\x8d\xe6\x91\x84\xe7\x9a\x84\xe6\xaf\x8f\xe4\xb8\x80\xe5\xb8\xa7\xe8\xbf\x9b\xe8\xa1\x8c\xe5\xa4\x84\xe7\x90\x86\xef\xbc\x8c\xe6\x9e\x84\xe9\x80\xa0\xe4\xb8\x80\xe4\xb8\xaa\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe8\xbe\x93\xe5\x87\xba\xe7\xb1\xbb\xef\xbc\x8c\xe6\xaf\x8f\xe6\x8b\x8d\xe6\x91\x84\xe4\xb8\x80\xe5\xb8\xa7\xe9\x83\xbd\xe4\xbc\x9a\xe8\xbf\x9b\xe6\x9d\xa5write\xe5\xa4\x84\xe7\x90\x86\n    def write(self, buf):\n        global key\n        if buf.startswith(b\'\\xff\\xd8\'):                            # \xe4\xbb\xa3\xe8\xa1\xa8\xe4\xb8\x80\xe4\xb8\xaaJPG\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84\xe5\xbc\x80\xe5\xa7\x8b\xef\xbc\x8c\xe6\x96\xb0\xe7\x85\xa7\xe7\x89\x87\xe7\x9a\x84\xe5\xbc\x80\xe5\xa4\xb4\n            # Start of new frame; close the old one (if any) and\n            # open a new output\n            if self.output:\n                self.output.close()\n            self.frame_num += 1\n            self.output = io.open(\'%s_image%s.jpg\' % (key,time()), \'wb\')           # \xe6\x94\xb9\xe5\x8f\x98\xe6\xa0\xbc\xe5\xbc\x8f\xe4\xb8\xbajpg\n        self.output.write(buf)\n    \n \ndef pi_capture():\n    global train_img, is_capture_running,train_labels,key\n    \n    #init the train_label array\n    print(""Start capture"")        \n    is_capture_running = True\n\n    with picamera.PiCamera(resolution=(160, 120), framerate=30) as camera:\n        # \xe6\xa0\xb9\xe6\x8d\xae\xe6\x91\x84\xe5\x83\x8f\xe5\xa4\xb4\xe5\xae\x9e\xe9\x99\x85\xe6\x83\x85\xe5\x86\xb5\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe8\xa6\x81\xe5\x8a\xa0\xe8\xbf\x99\xe5\x8f\xa5\xe4\xb8\x8a\xe4\xb8\x8b\xe7\xbf\xbb\xe8\xbd\xac\n        # camera.vflip = True\n        # Give the camera some warm-up time\n        sleep(2)\n        output = SplitFrames()\n        start = time()\n        camera.start_recording(output, format=\'mjpeg\')\n        camera.wait_recording(120)\n        camera.stop_recording()\n        finish = time()\n    print(\'Captured %d frames at %.2ffps\' % (\n        output.frame_num,\n        output.frame_num / (finish - start)))\n    \n    print(""quit pi capture"")\n    is_capture_running = False\n\ndef my_car_control(): \n    global is_capture_running, key\n    key = 4\n    pygame.init()\n    pygame.display.set_mode((1,1))            # \xe7\xaa\x97\xe5\x8f\xa3\n    zth_car_control.car_stop()\n    sleep(0.1)\n    print(""Start control!"")\n \n    while is_capture_running:\n        # get input from human driver\n        # \n        for event in pygame.event.get():\n            # \xe5\x88\xa4\xe6\x96\xad\xe4\xba\x8b\xe4\xbb\xb6\xe6\x98\xaf\xe4\xb8\x8d\xe6\x98\xaf\xe6\x8c\x89\xe9\x94\xae\xe6\x8c\x89\xe4\xb8\x8b\xe7\x9a\x84\xe4\xba\x8b\xe4\xbb\xb6\n            if event.type == pygame.KEYDOWN:  \n                key_input = pygame.key.get_pressed()     # \xe5\x8f\xaf\xe4\xbb\xa5\xe5\x90\x8c\xe6\x97\xb6\xe6\xa3\x80\xe6\xb5\x8b\xe5\xa4\x9a\xe4\xb8\xaa\xe6\x8c\x89\xe9\x94\xae\n                print(key_input[pygame.K_w], key_input[pygame.K_a], key_input[pygame.K_d])\n                # \xe6\x8c\x89\xe4\xb8\x8b\xe5\x89\x8d\xe8\xbf\x9b\xef\xbc\x8c\xe4\xbf\x9d\xe5\xad\x98\xe5\x9b\xbe\xe7\x89\x87\xe4\xbb\xa52\xe5\xbc\x80\xe5\xa4\xb4\n                if key_input[pygame.K_w] and not key_input[pygame.K_a] and not key_input[pygame.K_d]:\n                    print(""Forward"")\n                    key = 2 \n                    zth_car_control.car_move_forward()\n                # \xe6\x8c\x89\xe4\xb8\x8b\xe5\xb7\xa6\xe9\x94\xae\xef\xbc\x8c\xe4\xbf\x9d\xe5\xad\x98\xe5\x9b\xbe\xe7\x89\x87\xe4\xbb\xa50\xe5\xbc\x80\xe5\xa4\xb4\n                elif key_input[pygame.K_a]:\n                    print(""Left"")\n                    zth_car_control.car_turn_left()\n                    sleep(0.1)\n                    key = 0\n                # \xe6\x8c\x89\xe4\xb8\x8bd\xe5\x8f\xb3\xe9\x94\xae\xef\xbc\x8c\xe4\xbf\x9d\xe5\xad\x98\xe5\x9b\xbe\xe7\x89\x87\xe4\xbb\xa51\xe5\xbc\x80\xe5\xa4\xb4\n                elif key_input[pygame.K_d]:\n                    print(""Right"")\n                    zth_car_control.car_turn_right()\n                    sleep(0.1)\n                    key = 1\n                # \xe6\x8c\x89\xe4\xb8\x8bs\xe5\x90\x8e\xe9\x80\x80\xe9\x94\xae\xef\xbc\x8c\xe4\xbf\x9d\xe5\xad\x98\xe5\x9b\xbe\xe7\x89\x87\xe4\xb8\xba3\xe5\xbc\x80\xe5\xa4\xb4\n                elif key_input[pygame.K_s]:\n                    print(""Backward"")\n                    zth_car_control.car_move_backward()\n                    key = 3\n                # \xe6\x8c\x89\xe4\xb8\x8bk\xe5\x81\x9c\xe6\xad\xa2\xe9\x94\xae\xef\xbc\x8c\xe5\x81\x9c\xe6\xad\xa2\n                elif key_input[pygame.K_k]:\n                    zth_car_control.car_stop()\n            # \xe6\xa3\x80\xe6\xb5\x8b\xe6\x8c\x89\xe9\x94\xae\xe6\x98\xaf\xe4\xb8\x8d\xe6\x98\xaf\xe6\x8a\xac\xe8\xb5\xb7\n            elif event.type == pygame.KEYUP:\n                key_input = pygame.key.get_pressed()\n                # w\xe9\x94\xae\xe6\x8a\xac\xe8\xb5\xb7\xef\xbc\x8c\xe8\xbd\xae\xe5\xad\x90\xe5\x9b\x9e\xe6\xad\xa3\n                if key_input[pygame.K_w] and not key_input[pygame.K_a] and not key_input[pygame.K_d]:\n                    print(""Forward"")\n                    key = 2\n                    zth_car_control.car_turn_straight()\n                    zth_car_control.car_move_forward()\n                # s\xe9\x94\xae\xe6\x8a\xac\xe8\xb5\xb7\n                elif key_input[pygame.K_s] and not key_input[pygame.K_a] and not key_input[pygame.K_d]:\n                    print(""Backward"")\n                    key = 3\n                    zth_car_control.car_move_backward()\n                else:\n                    print(""Stop"")\n                    zth_car_control.car_stop()\n                #car_control.cleanGPIO()\n    zth_car_control.clean_GPIO()\n\nif __name__ == \'__main__\':\n    global train_labels, train_img, key\n\n    print(""capture thread"")\n    print(\'-\' * 50)\n    capture_thread = threading.Thread(target=pi_capture,args=())   # \xe5\xbc\x80\xe5\x90\xaf\xe7\xba\xbf\xe7\xa8\x8b\n    capture_thread.setDaemon(True)\n    capture_thread.start()\n    \n    my_car_control()\n\n    while is_capture_running:\n        pass\n\n    print(""Done!"")\n    zth_car_control.car_stop()\n    zth_car_control.clean_GPIO()\n'"
zth_drive.py,1,"b'# \xe5\x88\xa9\xe7\x94\xa8\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x93\x8d\xe4\xbd\x9c\xe5\xb0\x8f\xe8\xbd\xa6\xef\xbc\x8c\xe5\xae\x9e\xe7\x8e\xb0\xe8\x87\xaa\xe5\x8a\xa8\xe9\xa9\xbe\xe9\xa9\xb6\n# \xe6\xa0\x91\xe8\x8e\x93\xe6\xb4\xbe\xe4\xb8\x8a\xe8\xb7\x91\xef\xbc\x8c\xe5\x8a\xa0\xe4\xb8\x8a\xe8\xae\xad\xe7\xbb\x83\xe5\x87\xba\xe6\x9d\xa5\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x8c\xe4\xb8\x8d\xe4\xbc\x9a\xe7\xab\x8b\xe5\x88\xbb\xe8\x83\xbd\xe8\xb7\x91\xe8\xb5\xb7\xe6\x9d\xa5\xef\xbc\x8c\xe9\x9c\x80\xe8\xa6\x81\xe6\x97\xb6\xe9\x97\xb4\xe8\xaf\xbb\xe5\x85\xa5\xe6\xa8\xa1\xe5\x9e\x8b\n# \xe8\x87\xaa\xe5\x8a\xa8\xe9\xa9\xbe\xe9\xa9\xb6\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9c\x9f\xe5\xae\x9e\xe9\x81\x93\xe8\xb7\xaf\xe6\xa8\xa1\xe6\x8b\x9f\xe8\xa1\x8c\xe9\xa9\xb6\n# \xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b\xe5\xa4\x84\xe7\x90\x86\nimport os\nimport io\nimport glob\nimport time\nimport threading\nimport picamera.array\nimport picamera\nfrom PIL import Image\nimport numpy as np\n\nimport zth_car_control\nfrom keras.models import load_model\nimport tensorflow as tf\n\n# \xe6\x89\xbe\xe5\x88\xb0\xe6\x9c\x80\xe5\xa4\xa7\xe7\x9a\x84\xe5\x8f\xaf\xe8\x83\xbd\xe6\x80\xa7\ndef get_max_prob_num(predictions_array):\n    prediction_edit = np.zeros([1, 5])\n    for i in range(0, 5):\n        if predictions_array[0][i] == predictions_array.max():\n            prediction_edit[0][i] = 1\n            return i\n    return 2\n# \xe6\xa0\xb9\xe6\x8d\xae\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe9\xa2\x84\xe6\xb5\x8b\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c\xe6\x9d\xa5\xe6\x8e\xa7\xe5\x88\xb6\xe5\xb0\x8f\xe8\xbd\xa6\ndef control_car(action_num):\n    if action_num == 0:\n        print(""Left"")\n        zth_car_control.car_turn_left()\n        time.sleep(0.25)\n    elif action_num == 1:\n        print(""Right"")\n        zth_car_control.car_turn_right()\n        time.sleep(0.25)\n    elif action_num == 2:\n        print(""Forward"")\n        zth_car_control.car_move_forward()\n    elif action_num == 3:\n        zth_car_control.car_move_backward()\n        print(""Backward"")\n    else:\n        zth_car_control.car_stop()\n        print(\'stop\')\n\n\n# \xe5\x88\xa9\xe7\x94\xa8\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe9\xa2\x84\xe6\xb5\x8b\xe5\x9b\xbe\xe5\x83\x8f\n# \xe7\xbb\xa7\xe6\x89\xbf\xe7\x88\xb6\xe7\xb1\xbbthreading.Thread\nclass ImageProcessor(threading.Thread):\n    def __init__(self, owner):\n        super(ImageProcessor, self).__init__()\n        self.stream = io.BytesIO()\n        self.event = threading.Event()\n        self.terminated = False\n        self.owner = owner\n        self.start()\n    # \xe8\xa6\x81\xe6\x89\xa7\xe8\xa1\x8c\xe7\x9a\x84\xe4\xbb\xa3\xe7\xa0\x81\xe5\x86\x99\xe5\x9c\xa8run\xe5\x87\xbd\xe6\x95\xb0\xe9\x87\x8c\xe9\x9d\xa2\xef\xbc\x8c\xe7\xba\xbf\xe7\xa8\x8b\xe5\x88\x9b\xe5\xbb\xba\xe5\x90\x8e\xe4\xbc\x9a\xe7\x9b\xb4\xe6\x8e\xa5\xe8\xbf\x90\xe8\xa1\x8crun\xe5\x87\xbd\xe6\x95\xb0\n    def run(self):\n        global latest_time, model, graph\n        while not self.terminated:\n            if self.event.wait(1):\n                try:\n                    self.stream.seek(0)\n                    image = Image.open(self.stream)\n                    image_np = np.array(image)\n                    camera_data_array = np.expand_dims(image_np, axis=0)\n                    current_time = time.time()\n                    if current_time > latest_time:\n                        if current_time - latest_time > 1:\n                            print(""*""*30)\n                            print(current_time-latest_time)\n                            print(""*""*30)\n                        latest_time = current_time\n                        with graph.as_default():\n                            prediction_array = model.predict(camera_data_array, batch_size=20, verbode=1)\n                            # \xe8\xbe\x93\xe5\x87\xba\xe7\x9a\x84\xe6\x98\xaf\xe6\xa6\x82\xe7\x8e\x87\xef\xbc\x8c\xe6\xaf\x94\xe5\xa6\x82[0.1,0.1,0.8,0.05,0.04]\n                        print(prediction_array)\n                        action_num = get_max_prob_num(prediction_array)\n                        control_car(action_num)\n                finally:\n                    self.stream.seek(0)\n                    self.stream.truncate()\n                    self.event.clear()\n                    with self.owner.lock:\n                        self.owner.pool.append(self)\n\n# \xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b\xe5\xa4\x84\xe7\x90\x86\nclass ProcessOutput(object):\n    def __init__(self):\n        self.done = False\n        self.lock = threading.Lock()\n        self.pool = [ImageProcessor(self) for i in range(4)]\n        self.processor = None\n    def write(self, buf):\n        if buf.startswith(b\'\\xff\\xd8\'):\n            if self.processor:\n                self.processor.event.set()\n            with self.lock:\n                if self.pool:\n                    self.processor = self.pool.pop()\n                else:\n                    self.processor = None\n        if self.processor:\n            self.processor.stream.write(buf)\n\n    def flush(self):\n        if self.processor:\n            with self.lock:\n                self.pool.append(self.processor)\n                self.processor = None\n        while True:\n            with self.lock:\n                try:\n                    proc = self.pool.pop()\n                except IndexError:\n                    pass\n            proc.terminated = True\n            proc.join()\n\n\n\n\ndef main():\n    """"""\xe8\x8e\xb7\xe5\x8f\x96\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x8c\xe7\x84\xb6\xe5\x90\x8e\xe9\xa2\x84\xe6\xb5\x8b\xe8\x8e\xb7\xe5\xbe\x97\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x8c\xe7\xbc\x96\xe8\xbe\x91\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x8c\xe6\x8e\xa7\xe5\x88\xb6\xe8\xbd\xa6\xe8\xa1\x8c\xe9\xa9\xb6""""""\n    global model, graph\n    model_loaded = glob.glob(\'model/*.h5\')    # glob.glob()\xe5\x8c\xb9\xe9\x85\x8d\xe6\x8c\x87\xe5\xae\x9a\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6\n    for single_mod in model_loaded:\n        model = load_model(single_mod)\n    graph = tf.get_default_graph()\n\n    try:\n        with picamera.PiCamera(resolution=(160, 120)) as camera:\n            time.sleep(2)\n            output = ProcessOutput()\n            camera.start_recording(output, format=\'mjpeg\')\n            while not output.done:\n                camera.wait_recording(1)\n            camera.stop_recording()\n    finally:\n        zth_car_control.clean_GPIO()\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == \'__main__\':\n    global latest_time\n    latest_time = time.time()\n    main()'"
zth_process2.py,7,"b'# coding=utf-8\n# \xe5\xb0\x86\xe5\x8e\x9f\xe5\xa7\x8b\xe7\x9a\x84jpg\xe5\x9b\xbe\xe7\x89\x87\xe5\xa4\x84\xe7\x90\x86\xe6\x88\x90Inception-v3\xe6\xa8\xa1\xe5\x9e\x8b\xe9\x9c\x80\xe8\xa6\x81\xe7\x9a\x84299\xc3\x97299\xc3\x973\xe7\x9a\x84\xe6\x95\xb0\xe5\xad\x97\xe7\x9f\xa9\xe9\x98\xb5\n# \xe5\xb0\x86\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe5\x88\x86\xe4\xb8\xba\xe8\xae\xad\xe7\xbb\x83/\xe9\xaa\x8c\xe8\xaf\x81/\xe6\xb5\x8b\xe8\xaf\x953\xe4\xb8\xaa\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\nimport glob\nimport os.path\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.python.platform import gfile\nimport os\n\n#####################################1.\xe5\xae\x9a\xe4\xb9\x89\xe9\x9c\x80\xe8\xa6\x81\xe4\xbd\xbf\xe7\x94\xa8\xe5\x88\xb0\xe7\x9a\x84\xe5\xb8\xb8\xe9\x87\x8f###########################\n\n# \xe5\x8e\x9f\xe5\xa7\x8b\xe8\xbe\x93\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\xe7\x9a\x84\xe7\x9b\xae\xe5\xbd\x95\nINPUT_DATA = \'datasets/training_data\'\n# \xe8\xbe\x93\xe5\x87\xba\xe6\x96\x87\xe4\xbb\xb6\xe7\x9a\x84\xe5\x9c\xb0\xe5\x9d\x80\xe3\x80\x82\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe6\x95\xb4\xe7\x90\x86\xe5\x90\x8e\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe6\x95\xb0\xe6\x8d\xae\xe9\x80\x9a\xe8\xbf\x87numpy\xe6\xa0\xbc\xe5\xbc\x8f\xe4\xbf\x9d\xe5\xad\x98\nOUTPUT_FILE = \'datasets/processed_data.npy\'\n# \xe6\xb5\x8b\xe8\xaf\x95\xe6\x95\xb0\xe6\x8d\xae\xe5\x92\x8c\xe9\xaa\x8c\xe8\xaf\x81\xe6\x95\xb0\xe6\x8d\xae\xe7\x9a\x84\xe6\xaf\x94\xe4\xbe\x8b\nVALIDATION_PRECENTAGE = 10\nTEST_PRECENTAGE = 10\n#####################################2.\xe5\xae\x9a\xe4\xb9\x89\xe6\x95\xb0\xe6\x8d\xae\xe5\xa4\x84\xe7\x90\x86\xe8\xbf\x87\xe7\xa8\x8b###############################\n\n# \xe8\xaf\xbb\xe5\x8f\x96\xe6\x95\xb0\xe6\x8d\xae\xe5\xb9\xb6\xe5\xb0\x86\xe6\x95\xb0\xe6\x8d\xae\xe5\x88\x86\xe5\x89\xb2\xe6\x88\x90\xe8\xae\xad\xe7\xbb\x83\xe6\x95\xb0\xe6\x8d\xae/\xe9\xaa\x8c\xe8\xaf\x81\xe6\x95\xb0\xe6\x8d\xae/\xe6\xb5\x8b\xe8\xaf\x95\xe6\x95\xb0\xe6\x8d\xae\ndef create_image_lists(sess, testing_percentage, validation_percentage):\n    sub_dirs = [x[0] for x in os.walk(INPUT_DATA)]\n    is_root_dir = True\n\n    # \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe5\x90\x84\xe4\xb8\xaa\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe3\x80\x82\n    training_images = []\n    training_labels = []\n    testing_images = []\n    testing_labels = []\n    validation_images = []\n    validation_labels = []\n    current_label = 0\n\n    # \xe8\xaf\xbb\xe5\x8f\x96\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe5\xad\x90\xe7\x9b\xae\xe5\xbd\x95\xe3\x80\x82\n    for sub_dir in sub_dirs:\n        if is_root_dir:\n            is_root_dir = False\n            continue\n\n        # \xe8\x8e\xb7\xe5\x8f\x96\xe4\xb8\x80\xe4\xb8\xaa\xe5\xad\x90\xe7\x9b\xae\xe5\xbd\x95\xe4\xb8\xad\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe6\x96\x87\xe4\xbb\xb6\xe3\x80\x82\n        extensions = [\'jpg\', \'jpeg\', \'JPG\', \'JPEG\']\n        file_list = []\n        dir_name = os.path.basename(sub_dir)\n        for extension in extensions:\n            file_glob = os.path.join(INPUT_DATA, dir_name, \'*.\' + extension)\n            file_list.extend(glob.glob(file_glob))\n        if not file_list: continue\n        print(""processing:"", dir_name)\n\n        i = 0\n        # \xe5\xa4\x84\xe7\x90\x86\xe5\x9b\xbe\xe7\x89\x87\xe6\x95\xb0\xe6\x8d\xae\xe3\x80\x82\n        for file_name in file_list:\n            i += 1\n            # \xe8\xaf\xbb\xe5\x8f\x96\xe5\xb9\xb6\xe8\xa7\xa3\xe6\x9e\x90\xe5\x9b\xbe\xe7\x89\x87\xef\xbc\x8c\xe5\xb0\x86\xe5\x9b\xbe\xe7\x89\x87\xe8\xbd\xac\xe5\x8c\x96\xe4\xb8\xba299*299\xe4\xbb\xa5\xe6\x96\xb9\xe4\xbe\xbfinception-v3\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x9d\xa5\xe5\xa4\x84\xe7\x90\x86\xe3\x80\x82\n            image_raw_data = gfile.FastGFile(file_name, \'rb\').read()\n            image = tf.image.decode_jpeg(image_raw_data)\n            if image.dtype != tf.float32:\n                image = tf.image.convert_image_dtype(image, dtype=tf.float32)\n            image = tf.image.resize_images(image, [299, 299])\n            image_value = sess.run(image)\n\n            # \xe9\x9a\x8f\xe6\x9c\xba\xe5\x88\x92\xe5\x88\x86\xe6\x95\xb0\xe6\x8d\xae\xe8\x81\x9a\xe3\x80\x82\n            chance = np.random.randint(100)\n            if chance < validation_percentage:\n                validation_images.append(image_value)\n                validation_labels.append(current_label)\n            elif chance < (testing_percentage + validation_percentage):\n                testing_images.append(image_value)\n                testing_labels.append(current_label)\n            else:\n                training_images.append(image_value)\n                training_labels.append(current_label)\n            if i % 200 == 0:\n                print(i, ""images processed."")\n        current_label += 1\n\n    # \xe5\xb0\x86\xe8\xae\xad\xe7\xbb\x83\xe6\x95\xb0\xe6\x8d\xae\xe9\x9a\x8f\xe6\x9c\xba\xe6\x89\x93\xe4\xb9\xb1\xe4\xbb\xa5\xe8\x8e\xb7\xe5\xbe\x97\xe6\x9b\xb4\xe5\xa5\xbd\xe7\x9a\x84\xe8\xae\xad\xe7\xbb\x83\xe6\x95\x88\xe6\x9e\x9c\xe3\x80\x82\n    state = np.random.get_state()\n    np.random.shuffle(training_images)\n    np.random.set_state(state)\n    np.random.shuffle(training_labels)\n\n    return np.asarray([training_images, training_labels,\n                       validation_images, validation_labels,\n                       testing_images, testing_labels])\n\ndef main():\n    #config = tf.ConfigProto(allow_soft_placement = True)\n    gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=0.7)\n    #config.gpu_options.allow_growth = True\n    with tf.Session(config=tf.ConfigProto(log_device_placement=False,gpu_options=gpu_options)) as sess:\n        processed_data = create_image_lists(sess, TEST_PRECENTAGE, VALIDATION_PRECENTAGE)\n        # \xe9\x80\x9a\xe8\xbf\x87numpy\xe6\xa0\xbc\xe5\xbc\x8f\xe5\x82\xa8\xe5\xad\x98\xe5\xa4\x84\xe7\x90\x86\xe8\xbf\x87\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\n        np.save(OUTPUT_FILE, processed_data)\nif __name__ == \'__main__\':\n    main()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'"
zth_process_img.py,0,"b'# \xe5\xb0\x86\xe5\x9b\xbe\xe7\x89\x87\xe5\xa4\x84\xe7\x90\x86\xe4\xb8\xbanpz\xe6\xa0\xbc\xe5\xbc\x8f\n# \xe8\x87\xaa\xe5\x8a\xa8\xe9\xa9\xbe\xe9\xa9\xb6\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9c\x9f\xe5\xae\x9e\xe9\x81\x93\xe8\xb7\xaf\xe6\xa8\xa1\xe6\x8b\x9f\xe8\xa1\x8c\xe9\xa9\xb6\nimport os\nimport numpy as np\nimport matplotlib.image as mpimg\nfrom time import time\nimport math\nfrom PIL import Image\n\nCHUNK_SIZE = 128    # \xe5\xb0\x86\xe5\x9b\xbe\xe7\x89\x87\xe5\x8e\x8b\xe7\xbc\xa9\xef\xbc\x8c\xe6\xaf\x8f256\xe4\xb8\xaa\xe5\x81\x9a\xe4\xb8\x80\xe6\xac\xa1\xe5\xa4\x84\xe7\x90\x86\n\n\n\n# \xe6\x9c\xac\xe6\xae\xb5\xe4\xb8\x8d\xe4\xb8\x80\xe6\xa0\xb7\ndef process_img(img_path, key):\n\n    print(img_path, key)\n    image = Image.open(img_path)\n    image_array = np.array(image)\n    image_array = np.expand_dims(image_array, axis=0)  # \xe5\xa2\x9e\xe5\x8a\xa0\xe4\xb8\x80\xe4\xb8\xaa\xe7\xbb\xb4\xe5\xba\xa6\n\n\n    #image_array = mpimg.imread(img_path)\n    #image_array = np.expand_dims(image_array, axis=0)\n\n    print(image_array.shape)\n\n    if key == 2:\n        label_array = [0., 0., 1., 0., 0.]\n    elif key == 3:\n        label_array = [0., 0., 0., 1., 0.]\n    elif key == 0:\n        label_array = [1., 0., 0., 0., 0.]\n    elif key == 1:\n        label_array = [0., 1., 0., 0., 0.]\n    elif key == 4:\n        label_array = [0., 0., 0., 0., 1.]\n\n    return (image_array, label_array)\n    # \xe8\xbf\x94\xe5\x9b\x9e\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x88\xe7\x9f\xa9\xe9\x98\xb5\xef\xbc\x89\xef\xbc\x8c\xe5\x92\x8c\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe6\xa0\x87\xe7\xad\xbe\xe5\x80\xbc\n\n\nif __name__ == \'__main__\':\n    path = ""training_data""\n    files = os.listdir(path)                             # \xe5\xb0\x86\xe8\xaf\xa5\xe8\xb7\xaf\xe5\xbe\x84\xe4\xb8\x8b\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6\xe5\x90\x8d\xe9\x83\xbd\xe5\xad\x98\xe5\x85\xa5\xe5\x88\x97\xe8\xa1\xa8\n    turns = int(math.ceil(len(files) / CHUNK_SIZE))      # \xe5\x8f\x96\xe6\x95\xb4\xef\xbc\x8c\xe6\x8a\x8a\xe6\x89\x80\xe6\x9c\x89\xe5\x9b\xbe\xe7\x89\x87\xe5\x88\x86\xe4\xb8\xba\xe8\xbf\x99\xe4\xb9\x88\xe5\xa4\x9a\xe8\xbd\xae\xef\xbc\x8c\xe6\xaf\x8fCHUNK_SIZE\xe5\xbc\xa0\xe4\xb8\x80\xe8\xbd\xae\n    print(""number of files: {}"".format(len(files)))\n    print(""turns: {}"".format(turns))\n\n    for turn in range(0, turns):\n        train_labels = np.zeros((1, 5), \'float\')           # \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe6\xa0\x87\xe7\xad\xbe\xe6\x95\xb0\xe7\xbb\x84\n        train_imgs = np.zeros([1, 120, 160, 3])            # \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe5\x9b\xbe\xe5\x83\x8f\xe6\x95\xb0\xe7\xbb\x84\n\n        CHUNK_files = files[turn * CHUNK_SIZE: (turn + 1) * CHUNK_SIZE] # \xe5\x8f\x96\xe5\x87\xba\xe5\xbd\x93\xe5\x89\x8d\xe8\xbf\x99\xe4\xb8\x80\xe8\xbd\xae\xe5\x9b\xbe\xe7\x89\x87\n        print(""number of CHUNK files: {}"".format(len(CHUNK_files)))\n        for file in CHUNK_files:\n            # \xe4\xb8\x8d\xe6\x98\xaf\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xb9\xef\xbc\x8c\xe5\xb9\xb6\xe4\xb8\x94\xe6\x98\xafjpg\xe6\x96\x87\xe4\xbb\xb6\n            if not os.path.isdir(file) and file[len(file) - 3:len(file)] == \'jpg\':\n                try:\n                    key = int(file[0])                     # \xe5\x8f\x96\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xbakey\n                    image_array, label_array = process_img(path + ""/"" + file, key)\n                    train_imgs = np.vstack((train_imgs, image_array))\n                    train_labels = np.vstack((train_labels, label_array))\n                except:\n                    print(\'prcess error\')\n\n        # \xe5\x8e\xbb\xe6\x8e\x89\xe7\xac\xac0\xe4\xbd\x8d\xe7\x9a\x84\xe5\x85\xa8\xe9\x9b\xb6\xe5\x9b\xbe\xe5\x83\x8f\xe6\x95\xb0\xe7\xbb\x84\xef\xbc\x8c\xe5\x85\xa8\xe9\x9b\xb6\xe5\x9b\xbe\xe5\x83\x8f\xe6\x95\xb0\xe7\xbb\x84\xe6\x98\xaf train_imgs = np.zeros([1,120,160,3]) \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe7\x94\x9f\xe6\x88\x90\xe7\x9a\x84\n        train_imgs = train_imgs[1:, :]\n        train_labels = train_labels[1:, :]\n        file_name = str(int(time()))\n        directory = ""training_data_npz""\n\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n        try:\n            np.savez(directory + \'/\' + file_name + \'.npz\', train_imgs=train_imgs, train_labels=train_labels)\n        except IOError as e:\n            print(e)\n\n\n'"
zth_train.py,0,"b'# \xe6\x90\xad\xe5\xbb\xba\xe6\xb7\xb1\xe5\xba\xa6\xe5\xad\xa6\xe4\xb9\xa0\xe6\xa8\xa1\xe5\x9e\x8b\n# \xe5\xaf\xbc\xe5\x85\xa5\xe5\xba\x93\n# \xe8\x87\xaa\xe5\x8a\xa8\xe9\xa9\xbe\xe9\xa9\xb6\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9c\x9f\xe5\xae\x9e\xe9\x81\x93\xe8\xb7\xaf\xe6\xa8\xa1\xe6\x8b\x9f\xe8\xa1\x8c\xe9\xa9\xb6\nimport keras\nimport tensorflow\nimport sys\nimport os\nimport h5py\nimport numpy as np\nimport glob\nfrom sklearn.model_selection import train_test_split\nfrom keras.models import Sequential\nfrom keras.layers import Lambda, Conv2D, MaxPooling2D, Dropout, Dense, Flatten\nfrom keras.models import load_model, Model, Input\nfrom keras.callbacks import ModelCheckpoint, EarlyStopping, TensorBoard\nfrom keras.optimizers import Adam, SGD\n\nnp.random.seed(0)\n\n# \xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f\nIMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS = 120, 160, 3\nINPUT_SHAPE = (IMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS)\n\n\n\n# step1,\xe8\xbd\xbd\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x8c\xe5\xb9\xb6\xe4\xb8\x94\xe5\x88\x86\xe5\x89\xb2\xe4\xb8\xba\xe8\xae\xad\xe7\xbb\x83\xe5\x92\x8c\xe9\xaa\x8c\xe8\xaf\x81\xe9\x9b\x86\n# \xe9\x97\xae\xe9\xa2\x98\xef\xbc\x8c\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe5\xa4\xaa\xe5\xa4\xa7\xe4\xba\x86\xef\xbc\x8c\xe5\xb7\xb2\xe7\xbb\x8f\xe8\xb6\x85\xe8\xbf\x87\xe8\xae\xa1\xe7\xae\x97\xe6\x9c\xba\xe5\x86\x85\xe5\xad\x98\ndef load_data():\n    # load\n    image_array = np.zeros((1, 120, 160, 3))               # \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\n    label_array = np.zeros((1, 5), \'float\')\n    training_data = glob.glob(\'training_data_npz/*.npz\')\n    # \xe5\x8c\xb9\xe9\x85\x8d\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe7\xac\xa6\xe5\x90\x88\xe6\x9d\xa1\xe4\xbb\xb6\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6\xef\xbc\x8c\xe5\xb9\xb6\xe5\xb0\x86\xe5\x85\xb6\xe4\xbb\xa5list\xe7\x9a\x84\xe5\xbd\xa2\xe5\xbc\x8f\xe8\xbf\x94\xe5\x9b\x9e\xe3\x80\x82\n    print(""\xe5\x8c\xb9\xe9\x85\x8d\xe5\xae\x8c\xe6\x88\x90\xe3\x80\x82\xe5\xbc\x80\xe5\xa7\x8b\xe8\xaf\xbb\xe5\x85\xa5"")\n    print(""\xe4\xb8\x80\xe5\x85\xb1%d\xe8\xbd\xae"", len(training_data))\n\n    # if no data, exit\xef\xbc\x8c\xe5\xae\xb9\xe9\x94\x99\xe5\x88\xa4\xe6\x96\xad\n    if not training_data:\n        print(""No training data in directory, exit"")\n        sys.exit()\n    i = 0\n    for single_npz in training_data:\n        with np.load(single_npz) as data:\n            print(data.keys())\n            i = i + 1\n            print(""\xe5\x9c\xa8\xe6\x89\x93\xe5\x8d\xb0\xe5\x85\xb3\xe9\x94\xae\xe5\x80\xbc"", i)\n            train_temp = data[\'train_imgs\']\n            train_labels_temp = data[\'train_labels\']\n        image_array = np.vstack((image_array, train_temp)) # \xe6\x8a\x8a\xe6\x96\x87\xe4\xbb\xb6\xe8\xaf\xbb\xe5\x8f\x96\xe9\x83\xbd\xe6\x94\xbe\xe5\x85\xa5\xef\xbc\x8c\xe5\x86\x85\xe5\xad\x98\n        label_array = np.vstack((label_array, train_labels_temp))\n        print(""\xe7\xac\xac%d\xe8\xbd\xae\xe5\xae\x8c\xe6\x88\x90"", i)\n    print(""\xe5\xbe\xaa\xe7\x8e\xaf\xe5\xae\x8c\xe4\xba\x86"")\n    X = image_array[1:, :]\n    y = label_array[1:, :]\n    print(\'Image array shape: \' + str(X.shape))\n    print(\'Label array shape: \' + str(y.shape))\n    print(np.mean(X))\n    print(np.var(X))\n\n    # now we can split the data into a training (80), testing(20), and validation set\n    X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, random_state=0)\n\n    return X_train, X_valid, y_train, y_valid\n\n\n# step2 \xe5\xbb\xba\xe7\xab\x8b\xe6\xa8\xa1\xe5\x9e\x8b\ndef build_model(keep_prob):\n    print(""\xe5\xbc\x80\xe5\xa7\x8b\xe7\xbc\x96\xe8\xaf\x91\xe6\xa8\xa1\xe5\x9e\x8b"")\n    model = Sequential()\n    model.add(Lambda(lambda x: (x/102.83 - 1), input_shape = INPUT_SHAPE))\n    model.add(Conv2D(24, (5, 5), activation=\'elu\', strides=(2, 2)))\n    model.add(Conv2D(36, (5, 5), activation=\'elu\', strides=(2, 2)))\n    model.add(Conv2D(48, (5, 5), activation=\'elu\', strides=(2, 2)))\n    model.add(Conv2D(64, (3, 3),activation=\'elu\'))\n    model.add(Conv2D(64, (3, 3),activation=\'elu\'))\n    model.add(Dropout(keep_prob))  # Dropout\xe5\xb0\x86\xe5\x9c\xa8\xe8\xae\xad\xe7\xbb\x83\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe6\xaf\x8f\xe6\xac\xa1\xe6\x9b\xb4\xe6\x96\xb0\xe5\x8f\x82\xe6\x95\xb0\xe6\x97\xb6\xe9\x9a\x8f\xe6\x9c\xba\xe6\x96\xad\xe5\xbc\x80\xe4\xb8\x80\xe5\xae\x9a\xe7\x99\xbe\xe5\x88\x86\xe6\xaf\x94\xef\xbc\x88p\xef\xbc\x89\xe7\x9a\x84\xe8\xbe\x93\xe5\x85\xa5\xe7\xa5\x9e\xe7\xbb\x8f\xe5\x85\x83\xe8\xbf\x9e\xe6\x8e\xa5\n    model.add(Flatten())\n    #model.add(Dense(500, activation=\'elu\'))\n    model.add(Dense(250, activation=\'elu\'))\n    #model.add(Dense(50, activation=\'elu\'))\n    model.add(Dense(5, activation=\'softmax\'))\n    model.summary()\n\n    return model\n\n# step3 \xe8\xae\xad\xe7\xbb\x83\xe6\xa8\xa1\xe5\x9e\x8b\ndef train_model(model, learning_rate, nb_epoch, samples_per_epoch,\n                batch_size, X_train, X_valid, y_train, y_valid):\n    # \xe5\x80\xbc\xe4\xbf\x9d\xe5\xad\x98\xe6\x9c\x80\xe5\xa5\xbd\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe5\xad\x98\xe4\xb8\x8b\xe6\x9d\xa5\n    checkpoint = ModelCheckpoint(\'model-{epoch:03d}.h5\',\n                                 monitor=\'val_loss\',\n                                 verbose=0,\n                                 save_best_only=True,\n                                 mode=\'min\')\n    # EarlyStopping patience\xef\xbc\x9a\xe5\xbd\x93earlystop\xe8\xa2\xab\xe6\xbf\x80\xe6\xb4\xbb\xef\xbc\x88\xe5\xa6\x82\xe5\x8f\x91\xe7\x8e\xb0loss\xe7\x9b\xb8\xe6\xaf\x94\xe4\xb8\x8a\xe4\xb8\x80\xe4\xb8\xaaepoch\xe8\xae\xad\xe7\xbb\x83\xe6\xb2\xa1\xe6\x9c\x89\xe4\xb8\x8b\xe9\x99\x8d\xef\xbc\x89\xef\xbc\x8c\n    # \xe5\x88\x99\xe7\xbb\x8f\xe8\xbf\x87patience\xe4\xb8\xaaepoch\xe5\x90\x8e\xe5\x81\x9c\xe6\xad\xa2\xe8\xae\xad\xe7\xbb\x83\xe3\x80\x82\n    # mode\xef\xbc\x9a\xe2\x80\x98auto\xe2\x80\x99\xef\xbc\x8c\xe2\x80\x98min\xe2\x80\x99\xef\xbc\x8c\xe2\x80\x98max\xe2\x80\x99\xe4\xb9\x8b\xe4\xb8\x80\xef\xbc\x8c\xe5\x9c\xa8min\xe6\xa8\xa1\xe5\xbc\x8f\xe4\xb8\x8b\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe6\xa3\x80\xe6\xb5\x8b\xe5\x80\xbc\xe5\x81\x9c\xe6\xad\xa2\xe4\xb8\x8b\xe9\x99\x8d\xe5\x88\x99\xe4\xb8\xad\xe6\xad\xa2\xe8\xae\xad\xe7\xbb\x83\xe3\x80\x82\xe5\x9c\xa8max\xe6\xa8\xa1\xe5\xbc\x8f\xe4\xb8\x8b\xef\xbc\x8c\xe5\xbd\x93\xe6\xa3\x80\xe6\xb5\x8b\xe5\x80\xbc\xe4\xb8\x8d\xe5\x86\x8d\xe4\xb8\x8a\xe5\x8d\x87\xe5\x88\x99\xe5\x81\x9c\xe6\xad\xa2\xe8\xae\xad\xe7\xbb\x83\xe3\x80\x82\n    early_stop = EarlyStopping(monitor=\'loss\', min_delta=.0005, patience=10,\n                               verbose=1, mode=\'min\')\n    tensorboard = TensorBoard(log_dir=\'./logs\', histogram_freq=0, batch_size=20, write_graph=True,write_grads=True,\n                              write_images=True, embeddings_freq=0, embeddings_layer_names=None,\n                              embeddings_metadata=None)\n    # \xe7\xbc\x96\xe8\xaf\x91\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x8closs\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8coptimizer\xe4\xbc\x98\xe5\x8c\x96\xe5\x99\xa8\xef\xbc\x8c metrics\xe5\x88\x97\xe8\xa1\xa8\xef\xbc\x8c\xe5\x8c\x85\xe5\x90\xab\xe8\xaf\x84\xe4\xbc\xb0\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x9c\xa8\xe8\xae\xad\xe7\xbb\x83\xe5\x92\x8c\xe6\xb5\x8b\xe8\xaf\x95\xe6\x97\xb6\xe7\xbd\x91\xe7\xbb\x9c\xe6\x80\xa7\xe8\x83\xbd\xe7\x9a\x84\xe6\x8c\x87\xe6\xa0\x87\n    model.compile(loss=\'mean_squared_error\', optimizer=keras.optimizers.Adam(lr=learning_rate), metrics=[\'accuracy\'])\n    # \xe8\xae\xad\xe7\xbb\x83\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x8cbatch_size\xe6\xa2\xaf\xe5\xba\xa6\xe4\xb8\x8b\xe9\x99\x8d\xe6\x97\xb6\xe6\xaf\x8f\xe4\xb8\xaabatch\xe5\x8c\x85\xe5\x90\xab\xe7\x9a\x84\xe6\xa0\xb7\xe6\x9c\xac\xe6\x95\xb0\xef\xbc\x8cepochs\xe8\xae\xad\xe7\xbb\x83\xe5\xa4\x9a\xe5\xb0\x91\xe8\xbd\xae\xe7\xbb\x93\xe6\x9d\x9f\xef\xbc\x8c\n    # verbose\xe6\x98\xaf\xe5\x90\xa6\xe6\x98\xbe\xe7\xa4\xba\xe6\x97\xa5\xe5\xbf\x97\xe4\xbf\xa1\xe6\x81\xaf\xef\xbc\x8cvalidation_data\xe7\x94\xa8\xe6\x9d\xa5\xe9\xaa\x8c\xe8\xaf\x81\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\n    model.fit_generator(batch_generator(X_train, y_train, batch_size),\n                        steps_per_epoch=samples_per_epoch/batch_size,\n                        epochs = nb_epoch,\n                        max_queue_size=1,\n                        validation_data=batch_generator(X_valid, y_valid, batch_size),\n                        validation_steps=len(X_valid)/batch_size,\n                        callbacks=[tensorboard, checkpoint, early_stop],\n                        verbose=2)\n\n# step4\n# \xe5\x8f\xaf\xe4\xbb\xa5\xe4\xb8\x80\xe4\xb8\xaabatch\xe4\xb8\x80\xe4\xb8\xaabatch\xe8\xbf\x9b\xe8\xa1\x8c\xe8\xae\xad\xe7\xbb\x83\xef\xbc\x8cCPU\xe5\x92\x8cGPU\xe5\x90\x8c\xe6\x97\xb6\xe5\xbc\x80\xe5\xb7\xa5\ndef batch_generator(X, y, batch_size):\n    images = np.empty([batch_size, IMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS])\n    steers = np.empty([batch_size, 5])\n    while True:\n        i = 0\n        for index in np.random.permutation(X.shape[0]):\n            images[i] = X[index]\n            steers[i] = y[index]\n            i += 1\n            if i == batch_size:\n                break\n        yield (images, steers)\n\n\n# step5 \xe8\xaf\x84\xe4\xbc\xb0\xe6\xa8\xa1\xe5\x9e\x8b\n#def evaluate(x_test, y_test):\n    #score = model.evaluate(x_test, y_test, verbose=0)\n    #print(\'Test loss:\', score[0])\n    #print(\'Test accuracy:\', score[1])\n\n\ndef main():\n    # \xe6\x89\x93\xe5\x8d\xb0\xe5\x87\xba\xe8\xb6\x85\xe5\x8f\x82\xe6\x95\xb0\n\n    print(\'-\'*30)\n    print(\'parameters\')\n    print(\'-\'*30)\n\n\n    keep_prob = 0.5\n    learning_rate = 0.0001\n    nb_epoch = 100\n    samples_per_epoch = 3000\n    batch_size = 30\n\n    print(\'keep_prob = \', keep_prob)\n    print(\'learning_rate = \', learning_rate)\n    print(\'nb_epoch = \', nb_epoch)\n    print(\'samples_per_epoch = \', samples_per_epoch)\n    print(\'batch_size = \', batch_size)\n    print(\'-\' * 30)\n\n    # \xe5\xbc\x80\xe5\xa7\x8b\xe8\xbd\xbd\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\n    data = load_data()\n    print(""\xe6\x95\xb0\xe6\x8d\xae\xe5\x8a\xa0\xe8\xbd\xbd\xe5\xae\x8c\xe6\xaf\x95"")\n    # \xe7\xbc\x96\xe8\xaf\x91\xe6\xa8\xa1\xe5\x9e\x8b\n    model = build_model(keep_prob)\n    # \xe5\x9c\xa8\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe4\xb8\x8a\xe8\xae\xad\xe7\xbb\x83\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x8c\xe4\xbf\x9d\xe5\xad\x98\xe6\x88\x90model.h5\n    train_model(model, learning_rate, nb_epoch, samples_per_epoch, batch_size, *data)\n    print(""\xe6\xa8\xa1\xe5\x9e\x8b\xe8\xae\xad\xe7\xbb\x83\xe5\xae\x8c\xe6\xaf\x95"")\n\n\nif __name__ == \'__main__\':\n    main()\n\n\n\n\n\n\n'"
zth_train2.py,13,"b'# coding=utf-8\n# \xe6\x90\xad\xe5\xbb\xba\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x8c\xe8\xae\xad\xe7\xbb\x83\xef\xbc\x8c\xe9\xa2\x84\xe6\xb5\x8b\n# \xe4\xbd\xbf\xe7\x94\xa8Inception-v3\xe6\xa8\xa1\xe5\x9e\x8b\xe8\xbf\x9b\xe8\xa1\x8c\xe8\xbf\x81\xe7\xa7\xbb\xe5\xad\xa6\xe4\xb9\xa0\nimport tensorflow as tf\nimport glob\nimport os.path\nimport numpy as np\nfrom tensorflow.python.platform import gfile\nimport tensorflow.contrib.slim as slim\n##########################1.  \xe5\xae\x9a\xe4\xb9\x89\xe8\xae\xad\xe7\xbb\x83\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\xb0\x86\xe8\xa6\x81\xe4\xbd\xbf\xe7\x94\xa8\xe5\x88\xb0\xe7\x9a\x84\xe5\xb8\xb8\xe9\x87\x8f################################\n# \xe5\x8a\xa0\xe8\xbd\xbd\xe9\x80\x9a\xe8\xbf\x87tensorflow-slim\xe5\xae\x9a\xe4\xb9\x89\xe5\xa5\xbd\xe7\x9a\x84inception\xe2\x80\x94\xe2\x80\x94v3\xe6\xa8\xa1\xe5\x9e\x8b\nimport tensorflow.contrib.slim.python.slim.nets.inception_v3 as inception_v3\n# \xe5\xa4\x84\xe7\x90\x86\xe5\xa5\xbd\xe7\x9a\x84\xe7\xa8\x8b\xe5\xba\x8f\xe6\x96\x87\xe4\xbb\xb6\nINPUT_DATA = \'datasets/processed_data.npy\'\n#  \xe4\xbf\x9d\xe5\xad\x98\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9a\x84\xe8\xb7\xaf\xe5\xbe\x84\nTRAIN_FILE = \'save_model\'\n# \xe8\xb0\xb7\xe6\xad\x8c\xe6\x8f\x90\xe4\xbe\x9b\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9a\x84\xe8\xb7\xaf\xe5\xbe\x84\nCKPT_FILE = \'inception_v3/inception_v3.ckpt\'\n# \xe5\xae\x9a\xe4\xb9\x89\xe8\xae\xad\xe7\xbb\x83\xe4\xbd\xbf\xe7\x94\xa8\xe5\x88\xb0\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\nLEARNING_RATE = 0.0001\nSTEPS = 300\nBATCH = 20\nN_CLASSES = 5\n\n# \xe4\xb8\x8d\xe9\x9c\x80\xe8\xa6\x81\xe4\xbb\x8e\xe8\xb0\xb7\xe6\xad\x8c\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe4\xb8\xad\xe5\x8a\xa0\xe8\xbd\xbd\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8c\xe6\x8c\x87\xe7\x9a\x84\xe6\x9c\x80\xe5\x90\x8e\xe7\x9a\x84\xe5\x85\xa8\xe8\xbf\x9e\xe6\x8e\xa5\xe5\xb1\x82\xef\xbc\x8c\xe7\xbb\x99\xe5\x87\xba\xe7\x9a\x84\xe6\x98\xaf\xe5\x8f\x82\xe6\x95\xb0\xe7\x9a\x84\xe5\x89\x8d\xe7\xbc\x80\nCHECKPOINT_EXCLUDE_SCOPES = \'InceptionV3/Logits,InceptionV3/AuxLogits\'\n# \xe9\x9c\x80\xe8\xa6\x81\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe7\xbd\x91\xe7\xbb\x9c\xe5\xb1\x82\xe5\x8f\x82\xe6\x95\xb0\xe5\x90\x8d\xe7\xa7\xb0\xef\xbc\x8c\xe5\x9c\xa8fine-tuning\xe7\x9a\x84\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\xb0\xb1\xe6\x98\xaf\xe6\x9c\x80\xe5\x90\x8e\xe7\x9a\x84\xe5\x85\xa8\xe8\xbf\x9e\xe6\x8e\xa5\xe5\xb1\x82\xef\xbc\x8c\xe8\xbf\x99\xe9\x87\x8c\xe7\xbb\x99\xe5\x87\xba\xe7\x9a\x84\xe6\x98\xaf\xe5\x8f\x82\xe6\x95\xb0\xe7\x9a\x84\xe5\x89\x8d\xe7\xbc\x80\nTRAINABLE_SCOPES=\'InceptionV3/Logits, InceptionV3/AuxLogit\'\n\n##########################2.\xe8\x8e\xb7\xe5\x8f\x96\xe6\x89\x80\xe6\x9c\x89\xe9\x9c\x80\xe8\xa6\x81\xe4\xbb\x8e\xe8\xb0\xb7\xe6\xad\x8c\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe4\xb8\xad\xe5\x8a\xa0\xe8\xbd\xbd\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0######################\ndef get_tuned_variables():\n    exclusions = [scope.strip() for scope in CHECKPOINT_EXCLUDE_SCOPES.split(\',\')]\n    variables_to_restore = []\n    # \xe6\x9e\x9a\xe4\xb8\xbeinception-v3\xe6\xa8\xa1\xe5\x9e\x8b\xe4\xb8\xad\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8c\xe7\x84\xb6\xe5\x90\x8e\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe9\x9c\x80\xe8\xa6\x81\xe4\xbb\x8e\xe5\x8a\xa0\xe8\xbd\xbd\xe5\x88\x97\xe8\xa1\xa8\xe4\xb8\xad\xe7\xa7\xbb\xe9\x99\xa4\xe3\x80\x82\n    for var in slim.get_model_variables():\n        excluded = False\n        for exclusion in exclusions:\n            if var.op.name.startswith(exclusion):\n                excluded = True\n                break\n        if not excluded:\n            variables_to_restore.append(var)\n    return variables_to_restore\n##############################3.\xe8\x8e\xb7\xe5\x8f\x96\xe6\x89\x80\xe6\x9c\x89\xe9\x9c\x80\xe8\xa6\x81\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe5\x8f\x98\xe9\x87\x8f\xe5\x88\x97\xe8\xa1\xa8##################################\ndef get_trainable_variables():\n    scopes = [scope.strip() for scope in TRAINABLE_SCOPES.split(\',\')]\n    variables_to_train = []\n    # \xe6\x9e\x9a\xe4\xb8\xbe\xe6\x89\x80\xe6\x9c\x89\xe9\x9c\x80\xe8\xa6\x81\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xe5\x89\x8d\xe7\xbc\x80\xef\xbc\x8c\xe5\xb9\xb6\xe9\x80\x9a\xe8\xbf\x87\xe8\xbf\x99\xe4\xba\x9b\xe5\x89\x8d\xe7\xbc\x80\xe6\x89\xbe\xe5\x88\xb0\xe6\x89\x80\xe6\x9c\x89\xe9\x9c\x80\xe8\xa6\x81\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xe3\x80\x82\n    for scope in scopes:\n        variables = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope)\n        variables_to_train.extend(variables)\n    return variables_to_train\n###################################4.\xe5\xae\x9a\xe4\xb9\x89\xe8\xae\xad\xe7\xbb\x83\xe8\xbf\x87\xe7\xa8\x8b#############################\ndef main():\n    # \xe5\x8a\xa0\xe8\xbd\xbd\xe9\xa2\x84\xe5\xa4\x84\xe7\x90\x86\xe5\xa5\xbd\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xe3\x80\x82\n    processed_data = np.load(INPUT_DATA)\n    training_images = processed_data[0]\n    n_training_example = len(training_images)\n    training_labels = processed_data[1]\n\n    validation_images = processed_data[2]\n    validation_labels = processed_data[3]\n\n    testing_images = processed_data[4]\n    testing_labels = processed_data[5]\n    print(""%d training examples, %d validation examples and %d testing examples."" % (\n        n_training_example, len(validation_labels), len(testing_labels)))\n\n    # \xe5\xae\x9a\xe4\xb9\x89inception-v3\xe7\x9a\x84\xe8\xbe\x93\xe5\x85\xa5\xef\xbc\x8cimages\xe4\xb8\xba\xe8\xbe\x93\xe5\x85\xa5\xe5\x9b\xbe\xe7\x89\x87\xef\xbc\x8clabels\xe4\xb8\xba\xe6\xaf\x8f\xe4\xb8\x80\xe5\xbc\xa0\xe5\x9b\xbe\xe7\x89\x87\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe6\xa0\x87\xe7\xad\xbe\xe3\x80\x82\n    images = tf.placeholder(tf.float32, [None, 299, 299, 3], name=\'input_images\')\n    labels = tf.placeholder(tf.int64, [None], name=\'labels\')\n\n    # \xe5\xae\x9a\xe4\xb9\x89inception-v3\xe6\xa8\xa1\xe5\x9e\x8b\xe3\x80\x82\xe5\x9b\xa0\xe4\xb8\xba\xe8\xb0\xb7\xe6\xad\x8c\xe7\xbb\x99\xe5\x87\xba\xe7\x9a\x84\xe5\x8f\xaa\xe6\x9c\x89\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x8f\x82\xe6\x95\xb0\xe5\x8f\x96\xe5\x80\xbc\xef\xbc\x8c\xe6\x89\x80\xe4\xbb\xa5\xe8\xbf\x99\xe9\x87\x8c\n    # \xe9\x9c\x80\xe8\xa6\x81\xe5\x9c\xa8\xe8\xbf\x99\xe4\xb8\xaa\xe4\xbb\xa3\xe7\xa0\x81\xe4\xb8\xad\xe5\xae\x9a\xe4\xb9\x89inception-v3\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe7\xbb\x93\xe6\x9e\x84\xe3\x80\x82\xe8\x99\xbd\xe7\x84\xb6\xe7\x90\x86\xe8\xae\xba\xe4\xb8\x8a\xe9\x9c\x80\xe8\xa6\x81\xe5\x8c\xba\xe5\x88\x86\xe8\xae\xad\xe7\xbb\x83\xe5\x92\x8c\n    # \xe6\xb5\x8b\xe8\xaf\x95\xe4\xb8\xad\xe4\xbd\xbf\xe7\x94\xa8\xe5\x88\xb0\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x8c\xe4\xb9\x9f\xe5\xb0\xb1\xe6\x98\xaf\xe8\xaf\xb4\xe5\x9c\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe6\x97\xb6\xe5\xba\x94\xe8\xaf\xa5\xe4\xbd\xbf\xe7\x94\xa8is_training=False\xef\xbc\x8c\xe4\xbd\x86\xe6\x98\xaf\n    # \xe5\x9b\xa0\xe4\xb8\xba\xe9\xa2\x84\xe5\x85\x88\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe7\x9a\x84inception-v3\xe6\xa8\xa1\xe5\x9e\x8b\xe4\xb8\xad\xe4\xbd\xbf\xe7\x94\xa8\xe7\x9a\x84batch normalization\xe5\x8f\x82\xe6\x95\xb0\xe4\xb8\x8e\n    # \xe6\x96\xb0\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xe4\xbc\x9a\xe6\x9c\x89\xe5\x87\xba\xe5\x85\xa5\xef\xbc\x8c\xe6\x89\x80\xe4\xbb\xa5\xe8\xbf\x99\xe9\x87\x8c\xe7\x9b\xb4\xe6\x8e\xa5\xe4\xbd\xbf\xe7\x94\xa8\xe5\x90\x8c\xe4\xb8\x80\xe4\xb8\xaa\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x9d\xa5\xe5\x81\x9a\xe6\xb5\x8b\xe8\xaf\x95\xe3\x80\x82\n    with slim.arg_scope(inception_v3.inception_v3_arg_scope()):\n        logits, _ = inception_v3.inception_v3(\n            images, num_classes=N_CLASSES, is_training=True)\n\n    trainable_variables = get_trainable_variables()\n    # \xe5\xae\x9a\xe4\xb9\x89\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\xe5\x92\x8c\xe8\xae\xad\xe7\xbb\x83\xe8\xbf\x87\xe7\xa8\x8b\xe3\x80\x82\n    tf.losses.softmax_cross_entropy(\n        tf.one_hot(labels, N_CLASSES), logits, weights=1.0)\n    total_loss = tf.losses.get_total_loss()\n    train_step = tf.train.RMSPropOptimizer(LEARNING_RATE).minimize(total_loss)\n\n    # \xe8\xae\xa1\xe7\xae\x97\xe6\xad\xa3\xe7\xa1\xae\xe7\x8e\x87\xe3\x80\x82\n    with tf.name_scope(\'evaluation\'):\n        correct_prediction = tf.equal(tf.argmax(logits, 1), labels)\n        evaluation_step = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n\n    # \xe5\xae\x9a\xe4\xb9\x89\xe5\x8a\xa0\xe8\xbd\xbdGoogle\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe7\x9a\x84Inception-v3\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9a\x84Saver\xe3\x80\x82\n    load_fn = slim.assign_from_checkpoint_fn(\n        CKPT_FILE,\n        get_tuned_variables(),\n        ignore_missing_vars=True)\n\n    # \xe5\xae\x9a\xe4\xb9\x89\xe4\xbf\x9d\xe5\xad\x98\xe6\x96\xb0\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9a\x84Saver\xe3\x80\x82\n    saver = tf.train.Saver()\n\n    with tf.Session() as sess:\n        # \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe6\xb2\xa1\xe6\x9c\x89\xe5\x8a\xa0\xe8\xbd\xbd\xe8\xbf\x9b\xe6\x9d\xa5\xe7\x9a\x84\xe5\x8f\x98\xe9\x87\x8f\xe3\x80\x82\n        init = tf.global_variables_initializer()\n        sess.run(init)\n        # \xe5\x8a\xa0\xe8\xbd\xbd\xe8\xb0\xb7\xe6\xad\x8c\xe5\xb7\xb2\xe7\xbb\x8f\xe8\xae\xad\xe7\xbb\x83\xe5\xa5\xbd\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe3\x80\x82\n        print(\'Loading tuned variables from %s\' % CKPT_FILE)\n        load_fn(sess)\n        start = 0\n        end = BATCH\n        for i in range(STEPS):\n            _, loss = sess.run([train_step, total_loss], feed_dict={\n                images: training_images[start:end],\n                labels: training_labels[start:end]})\n\n            if i % 30 == 0 or i + 1 == STEPS:\n                saver.save(sess, TRAIN_FILE, global_step=i)\n                validation_accuracy = sess.run(evaluation_step, feed_dict={\n                    images: validation_images, labels: validation_labels})\n                print(\'Step %d: Training loss is %.1f Validation accuracy = %.1f%%\' % (\n                    i, loss, validation_accuracy * 100.0))\n            start = end\n            if start == n_training_example:\n                start = 0\n            end = start + BATCH\n            if end > n_training_example:\n                end = n_training_example\n        # \xe5\x9c\xa8\xe6\x9c\x80\xe5\x90\x8e\xe7\x9a\x84\xe6\xb5\x8b\xe8\xaf\x95\xe6\x95\xb0\xe6\x8d\xae\xe4\xb8\x8a\xe6\xb5\x8b\xe8\xaf\x95\xe6\xad\xa3\xe7\xa1\xae\xe7\x8e\x87\xe3\x80\x82\n        test_accuracy = sess.run(evaluation_step, feed_dict={\n            images: testing_images, labels: testing_labels})\n        print(\'Final test accuracy = %.1f%%\' % (test_accuracy * 100))\n\nif __name__ == \'__main__\':\n        main()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'"
