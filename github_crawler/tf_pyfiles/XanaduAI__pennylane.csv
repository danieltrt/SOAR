file_path,api_count,code
setup.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom setuptools import setup, find_packages\n\nwith open(""pennylane/_version.py"") as f:\n    version = f.readlines()[-1].split()[-1].strip(""\\""\'"")\n\nrequirements = [\n    ""numpy"",\n    ""scipy"",\n    ""networkx"",\n    ""autograd"",\n    ""toml"",\n    ""appdirs"",\n    ""semantic_version==2.6"",\n]\n\ninfo = {\n    \'name\': \'PennyLane\',\n    \'version\': version,\n    \'maintainer\': \'Xanadu Inc.\',\n    \'maintainer_email\': \'software@xanadu.ai\',\n    \'url\': \'https://github.com/XanaduAI/pennylane\',\n    \'license\': \'Apache License 2.0\',\n    \'packages\': find_packages(where="".""),\n    \'entry_points\': {\n        \'pennylane.plugins\': [\n            \'default.qubit = pennylane.plugins:DefaultQubit\',\n            \'default.gaussian = pennylane.plugins:DefaultGaussian\',\n            \'default.qubit.tf = pennylane.plugins.default_qubit_tf:DefaultQubitTF\',\n            \'default.tensor = pennylane.beta.plugins.default_tensor:DefaultTensor\',\n            \'default.tensor.tf = pennylane.beta.plugins.default_tensor_tf:DefaultTensorTF\',\n            ],\n        },\n    \'description\': \'PennyLane is a Python quantum machine learning library by Xanadu Inc.\',\n    \'long_description\': open(\'README.rst\').read(),\n    \'provides\': [""pennylane""],\n    \'install_requires\': requirements,\n    \'command_options\': {\n        \'build_sphinx\': {\n            \'version\': (\'setup.py\', version),\n            \'release\': (\'setup.py\', version)}}\n}\n\nclassifiers = [\n    ""Development Status :: 4 - Beta"",\n    ""Environment :: Console"",\n    ""Intended Audience :: Science/Research"",\n    ""License :: OSI Approved :: Apache Software License"",\n    ""Natural Language :: English"",\n    ""Operating System :: POSIX"",\n    ""Operating System :: MacOS :: MacOS X"",\n    ""Operating System :: POSIX :: Linux"",\n    ""Operating System :: Microsoft :: Windows"",\n    ""Programming Language :: Python"",\n    \'Programming Language :: Python :: 3\',\n    \'Programming Language :: Python :: 3.6\',\n    \'Programming Language :: Python :: 3.7\',\n    \'Programming Language :: Python :: 3.8\',\n    \'Programming Language :: Python :: 3 :: Only\',\n    ""Topic :: Scientific/Engineering :: Physics""\n]\n\nsetup(classifiers=classifiers, **(info))\n'"
benchmark/benchmark.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nBenchmarking tool for PennyLane.\n""""""\n# pylint: disable=import-outside-toplevel,invalid-name\nimport argparse\nimport importlib\nimport subprocess\nimport time\n\nimport numpy as np\n\nimport pennylane as qml\n\n\n# benchmarking tool version\n__version__ = ""0.1.0""\n\n\n# ANSI escape sequences for terminal colors\nColors = {\n    ""red"": ""\\033[31m"",\n    ""yellow"": ""\\033[33m"",\n    ""blue"": ""\\033[34m"",\n    ""magenta"": ""\\033[95m"",\n}\nRESET = ""\\033[0m""\n\n\ndef col(text, color):\n    """"""Wraps the given text in color ANSI sequences.\n\n    Args:\n        text  (str): text to print\n        color (str): ANSI color code\n\n    Returns:\n        str: text wrapped with ANSI codes\n    """"""\n    return Colors[color] + text + RESET\n\n\ndef timing(func, *, number=10, repeat=5):\n    """"""Time the given function.\n\n    Args:\n        func (Callable[[], Any]): function to time\n        number (int): number of loops per test\n        repeat (int): the number of times the timing test is run\n    """"""\n    import timeit\n\n    print(""{} loops, {} runs"".format(number, repeat))\n    res = timeit.repeat(func, number=number, repeat=repeat, globals=globals())\n    print(""Timing per loop:"", col(str(np.array(res) / number), ""yellow""))\n\n\ndef plot(title, kernels, labels, n_vals):\n    """"""Plot timings as a function of the parameter n.\n\n    Args:\n        title (str): plot title\n        kernels (Sequence[Callable[[Any], Any]]): parametrized benchmarks to time\n        labels (Sequence[str]): names of the kernels\n        n_vals (Sequence[Any]): values the benchmark parameter n takes\n    """"""\n    import perfplot\n\n    perfplot.show(\n        setup=lambda n: n, kernels=kernels, labels=labels, n_range=n_vals, xlabel=""n"", title=title,\n    )\n\n\ndef profile(func, identifier, *, min_time=5):\n    """"""Profile the given function.\n\n    Args:\n        func (Callable[[], Any]): function to profile\n        identifier (str): identifying part of the name of the file containing the results\n        min_time (float): func is called repeatedly until at least this many seconds have elapsed\n    """"""\n    import cProfile\n    import pstats\n\n    print(""Minimum duration: {} seconds."".format(min_time))\n    pr = cProfile.Profile()\n    pr.enable()\n\n    t0 = time.process_time()\n    repeats = 0\n    while time.process_time() - t0 < min_time:\n        func()\n        repeats += 1\n\n    pr.disable()\n    pr.dump_stats(""pennylane_{}.pstats"".format(identifier))\n    ps = pstats.Stats(pr).strip_dirs().sort_stats(""tottime"")  # ""cumulative"")\n    ps.print_stats()\n    print(""{} repeats."".format(repeats))\n\n\ndef cli():\n    """"""Parse the command line arguments, perform the requested action.\n    """"""\n    parser = argparse.ArgumentParser(description=""PennyLane benchmarking tool"")\n    parser.add_argument(""--noinfo"", action=""store_true"", help=""suppress information output"")\n    parser.add_argument(""--version"", action=""version"", version=__version__)\n    parser.add_argument(""-v"", ""--verbose"", action=""store_true"", help=""verbose mode"")\n    parser.add_argument(\n        ""-d"",\n        ""--device"",\n        type=lambda x: x.split("",""),\n        default=""default.qubit"",\n        help=""comma-separated list of devices to run the benchmark on (default: %(default)s)"",\n    )\n    parser.add_argument(\n        ""-w"",\n        ""--wires"",\n        type=int,\n        default=3,\n        help=""number of wires to run the benchmark on (default: %(default)s)"",\n    )\n    parser.add_argument(""cmd"", choices=[""time"", ""plot"", ""profile""], help=""function to perform"")\n    parser.add_argument(""benchmark"", help=""benchmark module name (without .py)"")\n\n    args = parser.parse_args()\n\n    # look up information about the current HEAD Git commit\n    res = subprocess.run(\n        [""git"", ""log"", ""-1"", ""--pretty=%h %s""],\n        stdout=subprocess.PIPE,\n        encoding=""utf-8"",\n        check=True,\n    )\n    title = res.stdout\n    short_hash = title.split("" "", maxsplit=1)[0]\n\n    print(""Benchmarking PennyLane"", qml.version())\n\n    if args.verbose:\n        print(""Verbose mode on, results may not be representative."")\n\n    if not args.noinfo:\n        print(""Commit:"", col(title, ""red""))\n        qml.about()\n        print()\n\n    # import the requested benchmark module\n    mod = importlib.import_module(args.benchmark)\n\n    # execute the command\n    if args.cmd == ""plot"":\n        print(""Performance plot: \'{}\' benchmark on {}"".format(mod.Benchmark.name, args.device))\n        bms = [mod.Benchmark(qml.device(d, wires=args.wires), args.verbose) for d in args.device]\n        for k in bms:\n            k.setup()\n        plot(\n            title,\n            [k.benchmark for k in bms],\n            [args.benchmark + "" "" + k.device.short_name for k in bms],\n            mod.Benchmark.n_vals,\n        )\n        for k in bms:\n            k.teardown()\n        return\n\n    for d in args.device:\n        dev = qml.device(d, wires=args.wires)\n        bm = mod.Benchmark(dev, args.verbose)\n        bm.setup()\n        text = col(f""\'{bm.name}\'"", ""blue"") + "" benchmark on "" + col(f""{d}"", ""magenta"")\n        if args.cmd == ""time"":\n            print(""Timing:"", text)\n            timing(bm.benchmark)\n        elif args.cmd == ""profile"":\n            print(""Profiling:"", text)\n            profile(bm.benchmark, identifier=short_hash + ""_"" + d)\n        else:\n            raise ValueError(""Unknown command."")\n        bm.teardown()\n\n\nif __name__ == ""__main__"":\n    cli()\n'"
benchmark/benchmark_revisions.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nBenchmarking tool for different commits\n""""""\n# pylint: disable=subprocess-run-check\nimport argparse\nimport locale\nimport os\nimport subprocess\nfrom pathlib import Path\n\nfrom benchmark import col\n\n\nclass cd:\n    """"""Context manager for changing the current working directory""""""\n\n    def __init__(self, newPath):\n        self.newPath = newPath\n        self.savedPath = None\n\n    def __enter__(self):\n        self.savedPath = Path.cwd()\n        os.chdir(str(self.newPath))\n\n    def __exit__(self, etype, value, traceback):\n        os.chdir(str(self.savedPath))\n\n\ndef get_current_git_toplevel():\n    """"""Finds the current git toplevel.\n\n    Returns:\n        Union[Path,NoneType]: The current git toplevel\'s path or None.\n    """"""\n    res = subprocess.run([""git"", ""rev-parse"", ""--show-toplevel"", ""-q""], stdout=subprocess.PIPE)\n\n    if res.returncode == 0:\n        return Path(res.stdout.decode(locale.getpreferredencoding()).strip())\n\n    return None\n\n\ndef cli():\n    """"""Parse the command line arguments, perform the requested action.\n    """"""\n    parser = argparse.ArgumentParser(description=""PennyLane benchmarking tool for revisions"")\n    parser.add_argument(\n        ""-r"",\n        ""--revisions"",\n        type=lambda x: x.split("",""),\n        help=\'Comma-separated list of revisions to run the benchmark on. Use ""here"" for the current git toplevel.\',\n    )\n\n    # Only parse revisions, other args will go to the benchmarking script\n    args, unknown_args = parser.parse_known_args()\n\n    revisions_directory = Path.home() / "".pennylane"" / ""benchmarks"" / ""revisions""\n\n    toplevel = get_current_git_toplevel()\n\n    if revisions_directory.exists():\n        with cd(revisions_directory):\n            # Make really sure we don\'t reset the current git\n            if toplevel == Path.cwd():\n                raise Exception(\n                    ""Git accidently ended up in the current directory. Stopping to not cause any harm.""\n                )\n\n            subprocess.run([""git"", ""fetch"", ""origin"", ""-q""], check=True)\n            subprocess.run([""git"", ""reset"", ""--hard"", ""origin/master"", ""-q""], check=True)\n    else:\n        revisions_directory.mkdir(parents=True)\n\n        subprocess.run(\n            [\n                ""git"",\n                ""clone"",\n                ""https://www.github.com/xanaduai/pennylane"",\n                str(revisions_directory),\n            ],\n            check=True,\n        )\n\n    toplevel = get_current_git_toplevel()\n\n    for revision in args.revisions:\n        print("">>> Running benchmark for revision {}"".format(col(revision, ""red"")))\n\n        if revision == ""here"":\n            if not toplevel:\n                print(\n                    col("">>> Wasn\'t able to determine the current git toplevel, skipping..."", ""red"")\n                )\n\n                continue\n\n            pl_directory = toplevel\n        else:\n            pl_directory = revisions_directory\n\n            with cd(pl_directory):\n                # Make really sure we don\'t reset the current git\n                if toplevel == Path.cwd():\n                    raise Exception(\n                        ""Git accidently ended up in the current directory. Stopping to not cause any harm.""\n                    )\n\n                subprocess.run([""git"", ""fetch"", ""origin"", ""-q""], check=True)\n                subprocess.run([""git"", ""reset"", ""--hard"", revision, ""-q""], check=True)\n\n        benchmark_file_path = Path(__file__).parent / ""benchmark.py""\n        benchmark_env = os.environ.copy()\n        benchmark_env[""PYTHONPATH""] = str(pl_directory) + "";"" + benchmark_env[""PATH""]\n\n        subprocess.run(\n            [""python3"", str(benchmark_file_path)] + unknown_args + [""--noinfo""],\n            env=benchmark_env,\n            check=True,\n        )\n\n\nif __name__ == ""__main__"":\n    cli()\n'"
benchmark/benchmark_utils.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nBenchmarking utilities.\n""""""\nimport abc\n\nimport pennylane as qml\n\n\nclass BaseBenchmark(abc.ABC):\n    """"""ABC for benchmarks.\n\n    Args:\n        device (~pennylane.Device): device for executing the benchmark (if needed)\n        verbose (bool): If True, print debugging info during the benchmark. Note that this\n            may invalidate the benchmark due to printing latency that should be irrelevant.\n    """"""\n\n    name = None  #: str: benchmark name\n    min_wires = 1  #: int: minimum number of quantum wires required by the benchmark\n    n_vals = None  #: Sequence[Any]: range of benchmark parameter values for perfplot\n\n    def __init__(self, device=None, verbose=False):\n        self.device = device\n        if device is not None:\n            if device.num_wires < self.min_wires:\n                raise ValueError(\n                    ""\'{}\' requires at least {} wires."".format(self.name, self.min_wires)\n                )\n            self.n_wires = device.num_wires\n        else:\n            self.n_wires = None\n        self.verbose = verbose\n\n    def setup(self):\n        """"""Set up the benchmark.\n\n        This method contains the initial part of the benchmark that should not be timed.\n        """"""\n\n    def teardown(self):\n        """"""Tear down the benchmark.\n\n        This method contains the final part of the benchmark that should not be timed.\n        """"""\n\n    @abc.abstractmethod\n    def benchmark(self, n):\n        """"""The benchmark test itself.\n\n        Args:\n            n (int): benchmark size parameter\n\n        Returns:\n            Any: Result of the benchmark. Must not return None.\n        """"""\n\n\ndef create_qnode(qfunc, device, mutable=True, interface=""autograd""):\n    """"""Utility function for creating a quantum node.\n\n    Takes care of the backwards compatibility of the benchmarks.\n\n    Implicitly uses the parameter-shift method for computing Jacobians.\n\n    Args:\n        qfunc (Callable): quantum function defining a circuit\n        device (~pennylane.Device): device for executing the circuit\n        mutable (bool): whether the QNode should mutable\n        interface (str, None): interface used for classical backpropagation,\n            in (\'autograd\', \'torch, \'tf\', None)\n\n    Returns:\n        BaseQNode: constructed QNode\n    """"""\n    try:\n        qnode = qml.qnodes.QNode(\n            qfunc, device, mutable=mutable, diff_method=""parameter-shift"", interface=interface,\n        )\n    except AttributeError:\n        # versions before the ""new-style"" QNodes\n        qnode = qml.QNode(qfunc, device, cache=not mutable)\n        if interface == ""torch"":\n            return qnode.to_torch()\n        if interface == ""tf"":\n            return qnode.to_tf()\n\n    return qnode\n'"
benchmark/bm_entangling_layers.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nEntangling layers benchmark.\n""""""\n# pylint: disable=invalid-name\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.templates.layers import StronglyEntanglingLayers\nfrom pennylane.templates.embeddings import AngleEmbedding\nfrom pennylane.init import strong_ent_layers_uniform\n\nimport benchmark_utils as bu\n\n\ndef circuit(weights, *, features=None):\n    """"""Mutable quantum circuit.""""""\n\n    n_wires = len(features)\n    AngleEmbedding(features, wires=range(n_wires))\n    StronglyEntanglingLayers(weights, wires=range(n_wires))\n    return qml.expval(qml.PauliZ(0))\n\n\nclass Benchmark(bu.BaseBenchmark):\n    """"""Entangling layers benchmark.\n\n    Creates a mutable QNode using the StronglyEntanglingLayers template,\n    then evaluates it and its Jacobian.\n    """"""\n\n    name = ""Entangling layers""\n    min_wires = 2\n    n_vals = range(1, 5)\n\n    def benchmark(self, n=3):\n        # n is the number of layers in the circuit\n        if self.verbose:\n            print(""circuit: {} layers, {} wires"".format(n, self.n_wires))\n\n        features = np.arange(self.n_wires)\n        init_weights = strong_ent_layers_uniform(n_layers=n, n_wires=self.n_wires)\n\n        qnode = bu.create_qnode(circuit, self.device, mutable=True)\n        qnode(init_weights, features=features)\n        qnode.jacobian((init_weights,), {""features"": features})\n        return True\n'"
benchmark/bm_iqp_circuit.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nBenchmark for a circuit of the Instantaneous Quantum Polynomial-time (IQP) complexity class.\n""""""\n# pylint: disable=invalid-name\nimport math\nimport random\n\nimport numpy as np\nimport pennylane as qml\n\nimport benchmark_utils as bu\n\nCCZ_diag = np.array([1, 1, 1, 1, 1, 1, 1, -1])\nCCZ_matrix = np.diag(CCZ_diag)\n\nif hasattr(qml, ""DiagonalQubitUnitary""):\n    CCZ = lambda wires: qml.DiagonalQubitUnitary(CCZ_diag, wires=wires)\nelse:\n    CCZ = lambda wires: qml.QubitUnitary(CCZ_matrix, wires=wires)\n\n\ndef random_iqp_wires(n_wires):\n    """"""Create a random set of IQP wires.\n\n    Returns a list of either 1, 2, or 3 distinct integers\n    in the range of n_wires.\n\n    Args:\n        n_wires (int): Number of wires of the device.\n\n    Returns:\n        List[int]: The IQP wires.\n    """"""\n    # The global seed was fixed during benchmark construction\n    # so this is actually deterministic\n    a = random.random()\n    return random.sample(range(n_wires), math.ceil(3 * a))\n\n\ndef circuit(n=10, n_wires=3):\n    """"""Mutable IQP quantum circuit.""""""\n\n    for i in range(n_wires):\n        qml.Hadamard(i)\n\n    for i in range(n * n_wires):\n        wires = random_iqp_wires(n_wires)\n\n        if len(wires) == 1:\n            qml.PauliZ(wires=wires)\n        elif len(wires) == 2:\n            qml.CZ(wires=wires)\n        elif len(wires) == 3:\n            CCZ(wires)\n\n    for i in range(n_wires):\n        qml.Hadamard(i)\n\n    return qml.expval(qml.PauliZ(0))\n\n\nclass Benchmark(bu.BaseBenchmark):\n    """"""IQP circuit benchmark.\n\n    Creates an immutable QNode using an example IQP circuit.\n    """"""\n\n    name = ""IQP circuit""\n    min_wires = 3\n    n_vals = range(3, 27, 3)\n\n    def benchmark(self, n=10):\n        # Set seed to make iqp circuits deterministic\n        random.seed(135)\n\n        # n is the number of layers in the circuit\n        if self.verbose:\n            print(""circuit: {} IQP gates, {} wires"".format(n * self.n_wires, self.n_wires))\n\n        qnode = bu.create_qnode(circuit, self.device, mutable=True)\n        qnode(n=n, n_wires=self.n_wires)\n\n        return True\n'"
benchmark/bm_mutable_complicated_params.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nMutable QNode, complicated primary parameters benchmark.\n""""""\n# pylint: disable=invalid-name\nimport numpy as np\n\nimport pennylane as qml\nimport benchmark_utils as bu\n\n\ndef circuit(p, *, aux=0):\n    """"""A very simple, lightweight mutable quantum circuit.""""""\n    qml.RX(p[aux][2], wires=[0])\n    return qml.expval(qml.PauliZ(0))\n\n\nclass Benchmark(bu.BaseBenchmark):\n    """"""\n    This benchmark attempts to measure the efficiency of :meth:`JacobianQNode._construct` for\n    mutable QNodes, using an extreme case where the QNode has lots of primary parameters with\n    a complicated nested structure, but relatively few auxiliary parameters, and only a few\n    of the primary parameters are actually used in the circuit.\n\n    When the QNode is constructed, a VariableRef is built for each primary parameter,\n    and the qfunc re-evaluated. In this test this is meant to be time-consuming, but it is only\n    strictly necessary if the auxiliary parameters change.\n    The main reasons why there are significant differences in the execution speed of this test\n    between different PL commits:\n\n      * :meth:`BaseQNode._construct` should only reconstruct the QNode if the auxiliary params\n        have changed.\n      * Most of the primary params are not used in the circuit, hence\n        :meth:`JacobianQNode._construct` should efficiently figure out that partial derivatives\n        wrt. them are always zero.\n    """"""\n\n    name = ""mutable qnode, complicated primary params""\n    min_wires = 1\n    n_vals = range(6, 13, 1)\n\n    def __init__(self, device=None, verbose=False):\n        super().__init__(device, verbose)\n        self.qnode = None\n\n    def setup(self):\n        self.qnode = bu.create_qnode(circuit, self.device, mutable=True, interface=None)\n\n    def benchmark(self, n=8):\n        # n is the number of levels in the primary parameter tree.\n        # Hence the number of primary parameters depends exponentially on n.\n\n        def create_params(n):\n            """"""Recursively builds a tree structure with n levels.""""""\n            if n <= 0:\n                # the leaves are arrays\n                return np.random.randn(2)\n            # the other nodes have two branches and a scalar\n            return [create_params(n - 1), create_params(n - 1), np.random.randn()]\n\n        p = create_params(n)\n\n        def evaluate(aux):\n            """"""Evaluates the qnode using the given auxiliary params.""""""\n            res = self.qnode(p, aux=aux)\n            # check the result\n            assert np.allclose(res, np.cos(p[aux][2]))\n\n        # first evaluation and construction\n        evaluate(0)\n        # evaluate the node several times more with a different auxiliary argument\n        # (it does not matter if p changes or not, the VariableRefs handle it)\n        for _ in range(1, 10):\n            # If we had evaluate(i % 2) here instead the auxiliary arguments would change\n            # every time, which would negate most possible speedups.\n            evaluate(1)\n\n        return True\n'"
benchmark/bm_mutable_rotations.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nMutable sequence of rotations benchmark.\n""""""\n# pylint: disable=invalid-name\nimport numpy as np\n\nimport pennylane as qml\nimport benchmark_utils as bu\n\n\ndef circuit(a, *, b=1):\n    """"""Mutable quantum circuit.""""""\n    for idx in range(b):\n        qml.RY(a[idx], wires=[0])\n    return qml.expval(qml.PauliX(0))\n\n\nclass Benchmark(bu.BaseBenchmark):\n    """"""Mutable sequence of rotations benchmark.\n\n    The benchmark consists of a single mutable QNode evaluated several times,\n    each evaluation having a larger number of rotations in the circuit.\n    """"""\n\n    name = ""mutable sequence of rotations""\n    min_wires = 1\n    n_vals = range(10, 60, 10)\n\n    def __init__(self, device=None, verbose=False):\n        super().__init__(device, verbose)\n        self.qnode = None\n\n    def setup(self):\n        self.qnode = bu.create_qnode(circuit, self.device, mutable=True)\n\n    def benchmark(self, n=30):\n        # n is the number of circuit evaluations.\n        # Execution time should grow quadratically in n as\n        # the circuit size grows linearly with evaluation number.\n\n        # PL commits 3862206f and earlier suffer from a bug which accidentally\n        # makes this benchmark very fast, but return nonsense results.\n        wrong_results = 0\n        for i in range(n):\n            params = np.random.rand(i)\n            res = self.qnode(params, b=i)\n\n            expected = np.sin(np.sum(params))\n            if np.abs(res - expected) > 1e-6:\n                wrong_results += 1\n\n        if self.verbose:\n            print(""Wrong results: {}/{}"".format(wrong_results, n))\n        return True\n'"
doc/conf.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# PennyLane documentation build configuration file, created by\n# sphinx-quickstart on Tue Apr 17 11:43:51 2018.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\nimport pyscf\nimport sys, os, re\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\'..\'))\nsys.path.insert(0, os.path.abspath(\'_ext\'))\nsys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(\'.\')), \'doc\'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \'1.6\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.autosummary\',\n    \'sphinx.ext.todo\',\n    \'sphinx.ext.coverage\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.napoleon\',\n    \'sphinx.ext.inheritance_diagram\',\n    \'sphinx.ext.viewcode\',\n    \'sphinxcontrib.bibtex\',\n    \'edit_on_github\',\n    \'sphinx.ext.graphviz\',\n    # \'sphinx_gallery.gen_gallery\',\n    ""sphinx.ext.intersphinx"",\n    ""sphinx_automodapi.automodapi"",\n    \'sphinx_copybutton\',\n    ""m2r""\n]\n\nsource_suffix = [\'.rst\', \'.md\']\n\nautosummary_generate = True\nautosummary_imported_members = False\nautomodapi_toctreedirnm = ""code/api""\nautomodsumm_inherited_members = True\n\n\nintersphinx_mapping = {""https://pennylane.ai/qml/"": None}\nmathjax_path = ""https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML""\n\nfrom glob import glob\nimport shutil\nimport os\nimport warnings\n\n# sphinx_gallery_conf = {\n#     # path to your example scripts\n#     \'examples_dirs\': \'../examples\',\n#     # path where to save gallery generated examples\n#     \'gallery_dirs\': \'tutorials\',\n#     # build files that start \'pennylane_run\'\n#     \'filename_pattern\': r\'pennylane_run\',\n#     # first notebook cell in generated Jupyter notebooks\n#     \'first_notebook_cell\': ""%matplotlib inline"",\n#     # thumbnail size\n#     \'thumbnail_size\': (400, 400),\n# }\n\n# Remove warnings that occur when generating the the tutorials\nwarnings.filterwarnings(""ignore"", category=UserWarning, message=r""Matplotlib is currently using agg"")\nwarnings.filterwarnings(""ignore"", category=FutureWarning, message=r""Passing \\(type, 1\\) or \'1type\' as a synonym of type is deprecated.+"")\nwarnings.filterwarnings(""ignore"", category=UserWarning, message=r"".+?Compilation using quilc will not be available\\."")\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\', \'xanadu_theme\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = \'PennyLane\'\ncopyright = """"""\\\nVille Bergholm, Josh Izaac, Maria Schuld, Christian Gogolin, M. Sohaib Alam, Shahnawaz Ahmed,\nJuan Miguel Arrazola, Carsten Blank, Alain Delgado, Soran Jahangiri, Keri McKiernan, Johannes Jakob Meyer,\nZeyue Niu, Antal Sz\xc3\xa1va, and Nathan Killoran. <br>\nPennyLane: Automatic differentiation of hybrid quantum-classical computations. arXiv:1811.04968, 2018.<br>\n&copy; Copyright 2018-2020, Xanadu Quantum Technologies Inc.""""""\nauthor = \'Xanadu Inc.\'\n\nadd_module_names = False\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n\nimport pennylane\n\ntry:\n    import pennylane_qchem\nexcept ImportError:\n    from unittest.mock import MagicMock\n\n    class Mock(MagicMock):\n        __name__ = \'foo\'\n        __repr__ = lambda self: __name__\n\n        @classmethod\n        def __getattr__(cls, name):\n            return MagicMock()\n\n    MOCK_MODULES = [\n        \'pennylane_qchem\',\n        \'pennylane_qchem.qchem\',\n        ]\n\n    mock_fn = Mock(__name__=\'foo\')\n    mock_fns = {""__all__"": list(), ""__dir__"": list(), ""__dict__"": dict()}\n\n    mock = Mock(**mock_fns)\n    for mod_name in MOCK_MODULES:\n        sys.modules[mod_name] = mock\n\n# The full version, including alpha/beta/rc tags.\nrelease = pennylane.__version__\n\n# The short X.Y version.\nversion = re.match(r\'^(\\d+\\.\\d+)\', release).expand(r\'\\1\')\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# today_fmt is used as the format for a strftime call.\ntoday_fmt = \'%Y-%m-%d\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\nshow_authors = True\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n# html_theme = \'nature\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\nhtml_favicon = \'_static/favicon.ico\'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# This is required for the alabaster theme\n# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars\n#html_sidebars = {\n#    \'**\': [\n#        \'about.html\',\n#        \'navigation.html\',\n#        \'relations.html\',  # needs \'show_related\': True theme option to display\n#        \'searchbox.html\',\n#        \'donate.html\',\n#    ]\n#}\nhtml_sidebars = {\n    \'**\' : [\n        \'logo-text.html\',\n        \'searchbox.html\',\n        \'globaltoc.html\',\n        # \'sourcelink.html\'\n    ]\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g., "".xhtml"").\n#html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'h\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'r\', \'sv\', \'tr\'\n#html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only \'ja\' uses this config value\n#html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'PennyLanedoc\'\n\n# # -- Xanadu theme ---------------------------------------------------------\nhtml_theme = \'xanadu_theme\'\nhtml_theme_path = [\'.\']\n\n# Register the theme as an extension to generate a sitemap.xml\n# extensions.append(""guzzle_sphinx_theme"")\n\n# xanadu theme options (see theme.conf for more information)\nhtml_theme_options = {\n\n    # Set the path to a special layout to include for the homepage\n    # ""index_template"": ""special_index.html"",\n\n    # Set the name of the project to appear in the left sidebar.\n    ""project_nav_name"": ""PennyLane"",\n\n    # Set your Disqus short name to enable comments\n    # ""disqus_comments_shortname"": ""pennylane-1"",\n\n    # Set you GA account ID to enable tracking\n    ""google_analytics_account"": ""UA-130507810-2"",\n\n    # Path to a touch icon\n    ""touch_icon"": ""logo_new.png"",\n\n    # Specify a base_url used to generate sitemap.xml links. If not\n    # specified, then no sitemap will be built.\n    # ""base_url"": """"\n\n    # Allow a separate homepage from the master_doc\n    # ""homepage"": ""index"",\n\n    # Allow the project link to be overriden to a custom URL.\n    # ""projectlink"": ""http://myproject.url"",\n\n    ""large_toc"": True,\n    # colors\n    ""navigation_button"": ""#19b37b"",\n    ""navigation_button_hover"": ""#0e714d"",\n    ""toc_caption"": ""#19b37b"",\n    ""toc_hover"": ""#19b37b"",\n    ""table_header_bg"": ""#edf7f4"",\n    ""table_header_border"": ""#19b37b"",\n    ""download_button"": ""#19b37b"",\n    # gallery options\n    # ""github_repo"": ""XanaduAI/PennyLane"",\n    # ""gallery_dirs"": ""tutorials"",\n}\n\nedit_on_github_project = \'XanaduAI/pennylane\'\nedit_on_github_branch = \'master/doc\'\n\n# -- Options for HTMLHelp output ------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'PennyLanedoc\'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\nlatex_additional_files = [\'macros.tex\']\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'PennyLane.tex\', \'PennyLane Documentation\',\n     \'Xanadu Inc.\', \'manual\'),\n]\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'pennylane\', \'PennyLane Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'PennyLane\', \'PennyLane Documentation\',\n     author, \'PennyLane\', \'Xanadu quantum machine learning library.\',\n     \'Miscellaneous\'),\n]\n\n\n#============================================================\n\n# the order in which autodoc lists the documented members\nautodoc_member_order = \'bysource\'\n\n# inheritance_diagram graphviz attributes\ninheritance_node_attrs = dict(color=\'lightskyblue1\', style=\'filled\')\n\nfrom directives import UsageDetails, CustomGalleryItemDirective, TitleCardDirective\n\ndef setup(app):\n    app.add_directive(\'customgalleryitem\', CustomGalleryItemDirective)\n    app.add_directive(\'titlecard\', TitleCardDirective)\n    app.add_directive(""usagedetails"", UsageDetails)\n    app.add_stylesheet(\'xanadu_gallery.css\')\n'"
doc/directives.py,0,"b'# Copyright 2018-2019 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nCustom sphinx directives\n""""""\nfrom docutils.parsers.rst import Directive, directives\nfrom docutils.statemachine import StringList\nfrom docutils import nodes\n\nUSAGE_DETAILS_TEMPLATE = """"""\n.. raw:: html\n\n    <a class=""usage-details-header collapse-header"" data-toggle=""collapse"" href=""#usageDetails"" aria-expanded=""false"" aria-controls=""usageDetails"">\n        <h2 style=""font-size: 24px;"">\n            <i class=""fas fa-angle-down rotate"" style=""float: right;""></i> Usage Details\n        </h2>\n    </a>\n    <div class=""collapse"" id=""usageDetails"">\n\n{content}\n\n.. raw:: html\n\n    </div>\n""""""\n\n\nclass UsageDetails(Directive):\n    """"""Create a collapsed Usage Details section in the documentation.""""""\n\n    # defines the parameter the directive expects\n    # directives.unchanged means you get the raw value from RST\n    required_arguments = 0\n    optional_arguments = 0\n    final_argument_whitespace = False\n    has_content = True\n\n    def run(self):\n        rst = USAGE_DETAILS_TEMPLATE.format(content=""\\n"".join(self.content))\n        string_list = StringList(rst.split(\'\\n\'))\n        node = nodes.section()\n        self.state.nested_parse(string_list, self.content_offset, node)\n        return [node]\n\n\nGALLERY_TEMPLATE = """"""\n.. raw:: html\n\n    <div class=""card"" style=""width: 13rem; float:left; margin: 10px;"">\n        <a href={link}>\n            <img class=""card-img-top"" src={thumbnail} alt=""image not found"" style=""width: 13rem; height: 6rem;"">\n            <div class=""card-body"">\n                <p class=""card-text""> {description} </p>\n            </div>\n        </a>\n    </div>\n""""""\n\n\nclass CustomGalleryItemDirective(Directive):\n    """"""Create a sphinx gallery style thumbnail.\n    tooltip and figure are self explanatory. Description could be a link to\n    a document like in below example.\n    Example usage:\n\n    .. customgalleryitem::\n        :figure: /_static/img/thumbnails/babel.jpg\n        :description: This is a tutorial\n        :link: /beginner/deep_learning_nlp_tutorial\n\n    If figure is specified, a thumbnail will be made out of it and stored in\n    _static/thumbs. Therefore, consider _static/thumbs as a \'built\' directory.\n\n    """"""\n\n    required_arguments = 0\n    optional_arguments = 4\n    final_argument_whitespace = True\n    option_spec = {\'figure\': directives.unchanged,\n                   \'description\': directives.unchanged,\n                   \'link\': directives.unchanged}\n\n    has_content = False\n    add_index = False\n\n    def run(self):\n        try:\n            if \'figure\' in self.options:\n                thumbnail = self.options[\'figure\']\n            else:\n                thumbnail = \'_static/thumbs/code.png\'\n\n            if \'description\' in self.options:\n                description = self.options[\'description\']\n            else:\n                raise ValueError(\'description not found\')\n\n            if \'link\' in self.options:\n                link = self.options[\'link\']\n            else:\n                link = ""code/qml_templates""\n\n        except FileNotFoundError as e:\n            print(e)\n            return []\n        except ValueError as e:\n            print(e)\n            raise\n            return []\n\n        thumbnail_rst = GALLERY_TEMPLATE.format(thumbnail=thumbnail,\n                                                description=description,\n                                                link=link)\n        thumbnail = StringList(thumbnail_rst.split(\'\\n\'))\n        thumb = nodes.paragraph()\n        self.state.nested_parse(thumbnail, self.content_offset, thumb)\n        return [thumb]\n\n\nTITLE_CARD_TEMPLATE = """"""\n.. raw:: html\n\n    <div class=""card"" style=""width: 15rem; float:left; margin: 10px;"">\n        <a href={link}>\n            <div class=""card-header"">\n                <b>{name}</b>\n            </div>\n            <div class=""card-body"">\n                <p class=""card-text""> {description} </p>\n            </div>\n        </a>\n    </div>\n""""""\n\n\nclass TitleCardDirective(Directive):\n    """"""Create a sphinx gallery style thumbnail.\n    tooltip and figure are self explanatory. Description could be a link to\n    a document like in below example.\n    Example usage:\n\n    .. customgalleryitem::\n        :name: Installation\n        :description: Description of page\n        :link: /path/to/page\n\n    """"""\n\n    required_arguments = 0\n    optional_arguments = 4\n    final_argument_whitespace = True\n    option_spec = {\'name\': directives.unchanged,\n                   \'description\': directives.unchanged,\n                   \'link\': directives.unchanged}\n\n    has_content = False\n    add_index = False\n\n    def run(self):\n        try:\n            if \'name\' in self.options:\n                name = self.options[\'name\']\n\n            if \'description\' in self.options:\n                description = self.options[\'description\']\n            else:\n                raise ValueError(\'description not found\')\n\n            if \'link\' in self.options:\n                link = self.options[\'link\']\n            else:\n                link = ""code/qml_templates""\n\n        except FileNotFoundError as e:\n            print(e)\n            return []\n        except ValueError as e:\n            print(e)\n            raise\n            return []\n\n        thumbnail_rst = TITLE_CARD_TEMPLATE.format(name=name,\n                                                   description=description,\n                                                   link=link)\n        thumbnail = StringList(thumbnail_rst.split(\'\\n\'))\n        thumb = nodes.paragraph()\n        self.state.nested_parse(thumbnail, self.content_offset, thumb)\n        return [thumb]\n'"
pennylane/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis is the top level module from which all basic functions and classes of\nPennyLane can be directly imported.\n""""""\nimport pkg_resources\n\nimport numpy as _np\nfrom autograd import grad as _grad\nfrom autograd import jacobian as _jacobian\n\nfrom semantic_version import Version, Spec\n\n# QueuingContext needs to be imported before all other pennylane imports\nfrom ._queuing_context import QueuingContext  # pylint: disable=wrong-import-order\nimport pennylane.operation\n\nimport pennylane.init\nimport pennylane.templates\nimport pennylane.qnn\nfrom pennylane.templates import template, broadcast\nfrom pennylane.about import about\nfrom pennylane.vqe import Hamiltonian, VQECost\n\nfrom .circuit_graph import CircuitGraph\nfrom .configuration import Configuration\nfrom ._device import Device, DeviceError\nfrom .collections import apply, map, sum, dot, QNodeCollection\nfrom ._qubit_device import QubitDevice\nfrom .measure import expval, var, sample, probs\nfrom .ops import *\nfrom .optimize import *\nfrom .qnodes import qnode, QNode, QuantumFunctionError\nfrom .utils import inv\nfrom ._version import __version__\nfrom .io import *\n\n\n# Look for an existing configuration file\ndefault_config = Configuration(""config.toml"")\n\n\n# get list of installed plugin devices\nplugin_devices = {\n    entry.name: entry for entry in pkg_resources.iter_entry_points(""pennylane.plugins"")\n}\n\n# get chemistry plugin\nclass NestedAttrError:\n    """"""This class mocks out the qchem module in case\n    it is not installed. Any attempt to print an instance\n    of this class, or to access an attribute of this class,\n    results in an import error, directing the user to the installation\n    instructions for PennyLane Qchem""""""\n\n    error_msg = (\n        ""PennyLane-QChem not installed. \\n\\nTo access the qchem ""\n        ""module, you can install PennyLane-QChem via pip:""\n        ""\\n\\npip install pennylane-qchem""\n        ""\\n\\nFor more details, see the quantum chemistry documentation:""\n        ""\\nhttps://pennylane.readthedocs.io/en/stable/introduction/chemistry.html""\n    )\n\n    def __str__(self):\n        raise ImportError(self.error_msg) from None\n\n    def __getattr__(self, name):\n        raise ImportError(self.error_msg) from None\n\n    __repr__ = __str__\n\n\nqchem = NestedAttrError()\n\nfor entry in pkg_resources.iter_entry_points(""pennylane.qchem""):\n    if entry.name == ""OpenFermion"":\n        qchem = entry.load()\n\n\ndef device(name, *args, **kwargs):\n    r""""""device(name, wires=1, *args, **kwargs)\n    Load a plugin :class:`~.Device` and return the instance.\n\n    This function is used to load a particular quantum device,\n    which can then be used to construct QNodes.\n\n    PennyLane comes with support for the following two devices:\n\n    * :mod:`\'default.qubit\' <pennylane.plugins.default_qubit>`: a simple pure\n      state simulator of qubit-based quantum circuit architectures.\n\n    * :mod:`\'default.gaussian\' <pennylane.plugins.default_gaussian>`: a simple simulator\n      of Gaussian states and operations on continuous-variable circuit architectures.\n\n    In addition, additional devices are supported through plugins \xe2\x80\x94 see\n    the  `available plugins <https://pennylane.ai/plugins.html>`_ for more\n    details.\n\n    All devices must be loaded by specifying their **short-name** as listed above,\n    followed by the number of *wires* (subsystems) you wish to initialize.\n\n    Some devices may accept additional arguments. For instance,\n    ``default.gaussian`` accepts the keyword argument ``hbar``, to set\n    the convention used in the commutation relation :math:`[\\x,\\p]=i\\hbar`\n    (by default set to 2).\n\n    Please refer to the documentation for the individual devices to see any\n    additional arguments that might be required or supported.\n\n    Args:\n        name (str): the name of the device to load\n        wires (int): the number of wires (subsystems) to initialise\n            the device with\n\n    Keyword Args:\n        config (pennylane.Configuration): a PennyLane configuration object\n            that contains global and/or device specific configurations.\n    """"""\n    if name in plugin_devices:\n        options = {}\n\n        # load global configuration settings if available\n        config = kwargs.get(""config"", default_config)\n\n        if config:\n            # combine configuration options with keyword arguments.\n            # Keyword arguments take preference, followed by device options,\n            # followed by plugin options, followed by global options.\n            options.update(config[""main""])\n            options.update(config[name.split(""."")[0] + "".global""])\n            options.update(config[name])\n\n        kwargs.pop(""config"", None)\n        options.update(kwargs)\n\n        # loads the plugin device class\n        plugin_device_class = plugin_devices[name].load()\n\n        if Version(version()) not in Spec(plugin_device_class.pennylane_requires):\n            raise DeviceError(\n                ""The {} plugin requires PennyLane versions {}, however PennyLane ""\n                ""version {} is installed."".format(\n                    name, plugin_device_class.pennylane_requires, __version__\n                )\n            )\n\n        # load plugin device\n        return plugin_device_class(*args, **options)\n\n    raise DeviceError(""Device does not exist. Make sure the required plugin is installed."")\n\n\ndef grad(func, argnum=None):\n    """"""Returns the gradient as a callable function of (functions of) QNodes.\n\n    This is a wrapper around the :mod:`autograd.grad` function.\n    Function arguments with the property ``requires_grad`` set to ``False``\n    will automatically be excluded from the gradient computation, unless\n    the ``argnum`` keyword argument is passed.\n\n    Args:\n        func (function): a Python function or QNode that contains\n            a combination of quantum and classical nodes\n\n    Keyword Args:\n        argnum (int, list(int), None): Which argument(s) to take the gradient\n            with respect to. By default, the arguments themselves are used\n            to determine differentiability, by examining the ``requires_grad``\n            property. Providing this keyword argument overrides this behaviour,\n            allowing argument differentiability to be defined manually for the returned gradient function.\n\n    Returns:\n        function: The function that returns the gradient of the input\n        function with respect to the differentiable arguments, or, if specified,\n        the arguments in ``argnum``.\n    """"""\n    # pylint: disable=no-value-for-parameter\n    if argnum is not None:\n        # for backwards compatibility with existing code\n        # that manually specifies argnum\n        return _grad(func, argnum)\n\n    def _gradient_function(*args, **kwargs):\n        """"""Inspect the arguments for differentiability, and\n        compute the autograd gradient function with required argnums\n        dynamically.\n\n        This wrapper function is returned to the user instead of autograd.grad,\n        so that we can take into account cases where the user computes the\n        gradient function once, but then calls it with arguments that change\n        in differentiability.\n        """"""\n        argnum = []\n\n        for idx, arg in enumerate(args):\n            if getattr(arg, ""requires_grad"", True):\n                argnum.append(idx)\n\n        return _grad(func, argnum)(*args, **kwargs)\n\n    return _gradient_function\n\n\ndef jacobian(func, argnum):\n    """"""Returns the Jacobian as a callable function of vector-valued\n    (functions of) QNodes.\n\n    This is a wrapper around the :mod:`autograd.jacobian` function.\n\n    Args:\n        func (function): a vector-valued Python function or QNode that contains\n            a combination of quantum and classical nodes. The output of the computation\n            must consist of a single NumPy array (if classical) or a tuple of\n            expectation values (if a quantum node)\n        argnum (int or Sequence[int]): which argument to take the gradient\n            with respect to. If a sequence is given, the Jacobian matrix\n            corresponding to all input elements and all output elements is returned.\n\n    Returns:\n        function: the function that returns the Jacobian of the input\n        function with respect to the arguments in argnum\n    """"""\n    # pylint: disable=no-value-for-parameter\n    if isinstance(argnum, int):\n        return _jacobian(func, argnum)\n    return lambda *args, **kwargs: _np.stack(\n        [_jacobian(func, arg)(*args, **kwargs) for arg in argnum]\n    ).T\n\n\ndef version():\n    """"""Returns the PennyLane version number.""""""\n    return __version__\n'"
pennylane/_device.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the :class:`Device` abstract base class.\n""""""\n# pylint: disable=too-many-format-args\nimport abc\n\nimport numpy as np\n\nfrom pennylane.operation import (\n    Operation,\n    Observable,\n    Sample,\n    Variance,\n    Expectation,\n    Probability,\n    Tensor,\n)\nfrom pennylane.qnodes import QuantumFunctionError\n\n\nclass DeviceError(Exception):\n    """"""Exception raised by a :class:`~.pennylane._device.Device` when it encounters an illegal\n    operation in the quantum circuit.\n    """"""\n\n\nclass Device(abc.ABC):\n    """"""Abstract base class for PennyLane devices.\n\n    Args:\n        wires (int): number of subsystems in the quantum state represented by the device.\n            Default 1 if not specified.\n        shots (int): Number of circuit evaluations/random samples used to estimate\n            expectation values of observables. Defaults to 1000 if not specified.\n    """"""\n\n    # pylint: disable=too-many-public-methods\n    _capabilities = {}  #: dict[str->*]: plugin capabilities\n    _circuits = {}  #: dict[str->Circuit]: circuit templates associated with this API class\n    _asarray = staticmethod(np.asarray)\n\n    def __init__(self, wires=1, shots=1000):\n        self.num_wires = wires\n        self.shots = shots\n\n        self._op_queue = None\n        self._obs_queue = None\n        self._parameters = None\n\n    def __repr__(self):\n        """"""String representation.""""""\n        return ""<{} device (wires={}, shots={}) at {}>"".format(\n            self.__class__.__name__, self.num_wires, self.shots, hex(id(self))\n        )\n\n    def __str__(self):\n        """"""Verbose string representation.""""""\n        return ""{}\\nShort name: {}\\nPackage: {}\\nPlugin version: {}\\nAuthor: {}\\nWires: {}\\nShots: {}"".format(\n            self.name,\n            self.short_name,\n            self.__module__.split(""."")[0],\n            self.version,\n            self.author,\n            self.num_wires,\n            self.shots,\n        )\n\n    @property\n    @abc.abstractmethod\n    def name(self):\n        """"""The full name of the device.""""""\n\n    @property\n    @abc.abstractmethod\n    def short_name(self):\n        """"""Returns the string used to load the device.""""""\n\n    @property\n    @abc.abstractmethod\n    def pennylane_requires(self):\n        """"""The current API version that the device plugin was made for.""""""\n\n    @property\n    @abc.abstractmethod\n    def version(self):\n        """"""The current version of the plugin.""""""\n\n    @property\n    @abc.abstractmethod\n    def author(self):\n        """"""The author(s) of the plugin.""""""\n\n    @property\n    @abc.abstractmethod\n    def operations(self):\n        """"""Get the supported set of operations.\n\n        Returns:\n            set[str]: the set of PennyLane operation names the device supports\n        """"""\n\n    @property\n    @abc.abstractmethod\n    def observables(self):\n        """"""Get the supported set of observables.\n\n        Returns:\n            set[str]: the set of PennyLane observable names the device supports\n        """"""\n\n    @property\n    def shots(self):\n        """"""Number of circuit evaluations/random samples used to estimate\n        expectation values of observables""""""\n        return self._shots\n\n    @shots.setter\n    def shots(self, shots):\n        """"""Changes the number of shots.\n\n        Args:\n            shots (int): number of circuit evaluations/random samples used to estimate\n                expectation values of observables\n\n        Raises:\n            DeviceError: if number of shots is less than 1\n        """"""\n        if shots < 1:\n            raise DeviceError(\n                ""The specified number of shots needs to be at least 1. Got {}."".format(shots)\n            )\n\n        self._shots = int(shots)\n\n    @classmethod\n    def capabilities(cls):\n        """"""Get the other capabilities of the plugin.\n\n        Measurements, batching etc.\n\n        Returns:\n            dict[str->*]: results\n        """"""\n        return cls._capabilities\n\n    def execute(self, queue, observables, parameters={}, **kwargs):\n        """"""Execute a queue of quantum operations on the device and then measure the given observables.\n\n        For plugin developers: Instead of overwriting this, consider implementing a suitable subset of\n        :meth:`pre_apply`, :meth:`apply`, :meth:`post_apply`, :meth:`pre_measure`,\n        :meth:`expval`, :meth:`var`, :meth:`sample`, :meth:`post_measure`, and :meth:`execution_context`.\n\n        Args:\n            queue (Iterable[~.operation.Operation]): operations to execute on the device\n            observables (Iterable[~.operation.Observable]): observables to measure and return\n            parameters (dict[int, list[ParameterDependency]]): Mapping from free parameter index to the list of\n                :class:`Operations <pennylane.operation.Operation>` (in the queue) that depend on it.\n\n        Keyword Args:\n            return_native_type (bool): If True, return the result in whatever type the device uses\n                internally, otherwise convert it into array[float]. Default: False.\n\n        Raises:\n            QuantumFunctionError: if the value of :attr:`~.Observable.return_type` is not supported\n\n        Returns:\n            array[float]: measured value(s)\n        """"""\n        self.check_validity(queue, observables)\n        self._op_queue = queue\n        self._obs_queue = observables\n        self._parameters = {}\n        self._parameters.update(parameters)\n\n        results = []\n\n        with self.execution_context():\n            self.pre_apply()\n\n            for operation in queue:\n                self.apply(operation.name, operation.wires.tolist(), operation.parameters)\n\n            self.post_apply()\n\n            self.pre_measure()\n\n            for obs in observables:\n\n                if isinstance(obs, Tensor):\n                    # if obs is a tensor observable, use a list of individual wires\n                    wires = [ob.wires.tolist() for ob in obs.obs]\n                else:\n                    wires = obs.wires.tolist()\n\n                if obs.return_type is Expectation:\n                    results.append(self.expval(obs.name, wires, obs.parameters))\n\n                elif obs.return_type is Variance:\n                    results.append(self.var(obs.name, wires, obs.parameters))\n\n                elif obs.return_type is Sample:\n                    results.append(np.array(self.sample(obs.name, wires, obs.parameters)))\n\n                elif obs.return_type is Probability:\n                    results.append(list(self.probability(wires=wires).values()))\n\n                elif obs.return_type is not None:\n                    raise QuantumFunctionError(\n                        ""Unsupported return type specified for observable {}"".format(obs.name)\n                    )\n\n            self.post_measure()\n\n            self._op_queue = None\n            self._obs_queue = None\n            self._parameters = None\n\n            # Ensures that a combination with sample does not put\n            # expvals and vars in superfluous arrays\n            if all(obs.return_type is Sample for obs in observables):\n                return self._asarray(results)\n            if any(obs.return_type is Sample for obs in observables):\n                return self._asarray(results, dtype=""object"")\n\n            return self._asarray(results)\n\n    @property\n    def op_queue(self):\n        """"""The operation queue to be applied.\n\n        Note that this property can only be accessed within the execution context\n        of :meth:`~.execute`.\n\n        Raises:\n            ValueError: if outside of the execution context\n\n        Returns:\n            list[~.operation.Operation]\n        """"""\n        if self._op_queue is None:\n            raise ValueError(""Cannot access the operation queue outside of the execution context!"")\n\n        return self._op_queue\n\n    @property\n    def obs_queue(self):\n        """"""The observables to be measured and returned.\n\n        Note that this property can only be accessed within the execution context\n        of :meth:`~.execute`.\n\n        Raises:\n            ValueError: if outside of the execution context\n\n        Returns:\n            list[~.operation.Observable]\n        """"""\n        if self._obs_queue is None:\n            raise ValueError(\n                ""Cannot access the observable value queue outside of the execution context!""\n            )\n\n        return self._obs_queue\n\n    @property\n    def parameters(self):\n        """"""Mapping from free parameter index to the list of\n        :class:`Operations <~.Operation>` in the device queue that depend on it.\n\n        Note that this property can only be accessed within the execution context\n        of :meth:`~.execute`.\n\n        Raises:\n            ValueError: if outside of the execution context\n\n        Returns:\n            dict[int->list[ParameterDependency]]: the mapping\n        """"""\n        if self._parameters is None:\n            raise ValueError(\n                ""Cannot access the free parameter mapping outside of the execution context!""\n            )\n\n        return self._parameters\n\n    def pre_apply(self):\n        """"""Called during :meth:`execute` before the individual operations are executed.""""""\n\n    def post_apply(self):\n        """"""Called during :meth:`execute` after the individual operations have been executed.""""""\n\n    def pre_measure(self):\n        """"""Called during :meth:`execute` before the individual observables are measured.""""""\n\n    def post_measure(self):\n        """"""Called during :meth:`execute` after the individual observables have been measured.""""""\n\n    def execution_context(self):\n        """"""The device execution context used during calls to :meth:`execute`.\n\n        You can overwrite this function to return a context manager in case your\n        quantum library requires that;\n        all operations and method calls (including :meth:`apply` and :meth:`expval`)\n        are then evaluated within the context of this context manager (see the\n        source of :meth:`.Device.execute` for more details).\n        """"""\n        # pylint: disable=no-self-use\n        class MockContext:  # pylint: disable=too-few-public-methods\n            """"""Mock class as a default for the with statement in execute().""""""\n\n            def __enter__(self):\n                pass\n\n            def __exit__(self, type, value, traceback):\n                pass\n\n        return MockContext()\n\n    def supports_operation(self, operation):\n        """"""Checks if an operation is supported by this device.\n\n        Args:\n            operation (type or str): operation to be checked\n\n        Raises:\n            ValueError: if `operation` is not a :class:`~.Operation` class or string\n\n        Returns:\n            bool: ``True`` iff supplied operation is supported\n        """"""\n        if isinstance(operation, type) and issubclass(operation, Operation):\n            return operation.__name__ in self.operations\n        if isinstance(operation, str):\n\n            if operation.endswith(Operation.string_for_inverse):\n                return operation[\n                    : -len(Operation.string_for_inverse)\n                ] in self.operations and self.capabilities().get(""inverse_operations"", False)\n\n            return operation in self.operations\n\n        raise ValueError(\n            ""The given operation must either be a pennylane.Operation class or a string.""\n        )\n\n    def supports_observable(self, observable):\n        """"""Checks if an observable is supported by this device. Raises a ValueError,\n         if not a subclass or string of an Observable was passed.\n\n        Args:\n            observable (type or str): observable to be checked\n\n        Raises:\n            ValueError: if `observable` is not a :class:`~.Observable` class or string\n\n        Returns:\n            bool: ``True`` iff supplied observable is supported\n        """"""\n        if isinstance(observable, type) and issubclass(observable, Observable):\n            return observable.__name__ in self.observables\n        if isinstance(observable, str):\n\n            # This check regards observables that are also operations\n            if observable.endswith(Operation.string_for_inverse):\n                return self.supports_operation(observable[: -len(Operation.string_for_inverse)])\n\n            return observable in self.observables\n\n        raise ValueError(\n            ""The given observable must either be a pennylane.Observable class or a string.""\n        )\n\n    def check_validity(self, queue, observables):\n        """"""Checks whether the operations and observables in queue are all supported by the device.\n        Includes checks for inverse operations.\n\n        Args:\n            queue (Iterable[~.operation.Operation]): quantum operation objects which are intended\n                to be applied on the device\n            observables (Iterable[~.operation.Observable]): observables which are intended\n                to be evaluated on the device\n\n        Raises:\n            DeviceError: if there are operations in the queue or observables that the device does\n                not support\n        """"""\n\n        for o in queue:\n\n            operation_name = o.name\n\n            if o.inverse:\n                if not self.capabilities().get(""inverse_operations"", False):\n                    raise DeviceError(\n                        ""The inverse of gates are not supported on device {}"".format(\n                            self.short_name\n                        )\n                    )\n                operation_name = o.base_name\n\n            if not self.supports_operation(operation_name):\n                raise DeviceError(\n                    ""Gate {} not supported on device {}"".format(operation_name, self.short_name)\n                )\n\n        for o in observables:\n\n            if isinstance(o, Tensor):\n                if not self.capabilities().get(""tensor_observables"", False):\n                    raise DeviceError(\n                        ""Tensor observables not supported on device {}"".format(self.short_name)\n                    )\n\n                for i in o.obs:\n                    if not self.supports_observable(i.name):\n                        raise DeviceError(\n                            ""Observable {} not supported on device {}"".format(\n                                i.name, self.short_name\n                            )\n                        )\n            else:\n\n                observable_name = o.name\n\n                if issubclass(o.__class__, Operation) and o.inverse:\n                    if not self.capabilities().get(""inverse_operations"", False):\n                        raise DeviceError(\n                            ""The inverse of gates are not supported on device {}"".format(\n                                self.short_name\n                            )\n                        )\n                    observable_name = o.base_name\n\n                if not self.supports_observable(observable_name):\n                    raise DeviceError(\n                        ""Observable {} not supported on device {}"".format(\n                            observable_name, self.short_name\n                        )\n                    )\n\n    @abc.abstractmethod\n    def apply(self, operation, wires, par):\n        """"""Apply a quantum operation.\n\n        For plugin developers: this function should apply the operation on the device.\n\n        Args:\n            operation (str): name of the operation\n            wires (Sequence[int]): subsystems the operation is applied on\n            par (tuple): parameters for the operation\n        """"""\n\n    @abc.abstractmethod\n    def expval(self, observable, wires, par):\n        r""""""Returns the expectation value of observable on specified wires.\n\n        Note: all arguments accept _lists_, which indicate a tensor\n        product of observables.\n\n        Args:\n            observable (str or list[str]): name of the observable(s)\n            wires (List[int] or List[List[int]]): subsystems the observable(s) is to be measured on\n            par (tuple or list[tuple]]): parameters for the observable(s)\n\n        Returns:\n            float: expectation value :math:`\\expect{A} = \\bra{\\psi}A\\ket{\\psi}`\n        """"""\n\n    def var(self, observable, wires, par):\n        r""""""Returns the variance of observable on specified wires.\n\n        Note: all arguments support _lists_, which indicate a tensor\n        product of observables.\n\n        Args:\n            observable (str or list[str]): name of the observable(s)\n            wires (List[int] or List[List[int]]): subsystems the observable(s) is to be measured on\n            par (tuple or list[tuple]]): parameters for the observable(s)\n\n        Raises:\n            NotImplementedError: if the device does not support variance computation\n\n        Returns:\n            float: variance :math:`\\mathrm{var}(A) = \\bra{\\psi}A^2\\ket{\\psi} - \\bra{\\psi}A\\ket{\\psi}^2`\n        """"""\n        raise NotImplementedError(\n            ""Returning variances from QNodes not currently supported by {}"".format(self.short_name)\n        )\n\n    def sample(self, observable, wires, par):\n        """"""Return a sample of an observable.\n\n        The number of samples is determined by the value of ``Device.shots``,\n        which can be directly modified.\n\n        Note: all arguments support _lists_, which indicate a tensor\n        product of observables.\n\n        Args:\n            observable (str or list[str]): name of the observable(s)\n            wires (List[int] or List[List[int]]): subsystems the observable(s) is to be measured on\n            par (tuple or list[tuple]]): parameters for the observable(s)\n\n        Raises:\n            NotImplementedError: if the device does not support sampling\n\n        Returns:\n            array[float]: samples in an array of dimension ``(n, num_wires)``\n        """"""\n        raise NotImplementedError(\n            ""Returning samples from QNodes not currently supported by {}"".format(self.short_name)\n        )\n\n    def probability(self, wires=None):\n        """"""Return the (marginal) probability of each computational basis\n        state from the last run of the device.\n\n        Args:\n            wires (Sequence[int]): Sequence of wires to return\n                marginal probabilities for. Wires not provided\n                are traced out of the system.\n\n        Returns:\n            OrderedDict[tuple, float]: Dictionary mapping a tuple representing the state\n            to the resulting probability. The dictionary should be sorted such that the\n            state tuples are in lexicographical order.\n        """"""\n        raise NotImplementedError(\n            ""Returning probability not currently supported by {}"".format(self.short_name)\n        )\n\n    @abc.abstractmethod\n    def reset(self):\n        """"""Reset the backend state.\n\n        After the reset, the backend should be as if it was just constructed.\n        Most importantly the quantum state is reset to its initial value.\n        """"""\n'"
pennylane/_qubit_device.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the :class:`QubitDevice` abstract base class.\n""""""\n\n# For now, arguments may be different from the signatures provided in Device\n# e.g. instead of expval(self, observable, wires, par) have expval(self, observable)\n# pylint: disable=arguments-differ, abstract-method, no-value-for-parameter,too-many-instance-attributes\nimport abc\nimport itertools\n\nimport numpy as np\n\nfrom pennylane.operation import Sample, Variance, Expectation, Probability\nfrom pennylane.qnodes import QuantumFunctionError\nfrom pennylane import Device\nfrom pennylane.wires import Wires\n\n\nclass QubitDevice(Device):\n    """"""Abstract base class for PennyLane qubit devices.\n\n    The following abstract method **must** be defined:\n\n    * :meth:`~.apply`: append circuit operations, compile the circuit (if applicable),\n      and perform the quantum computation.\n\n    Devices that generate their own samples (such as hardware) may optionally\n    overwrite :meth:`~.probabilty`. This method otherwise automatically\n    computes the probabilities from the generated samples, and **must**\n    overwrite the following method:\n\n    * :meth:`~.generate_samples`: Generate samples from the device from the\n      exact or approximate probability distribution.\n\n    Analytic devices **must** overwrite the following method:\n\n    * :meth:`~.analytic_probability`: returns the probability or marginal probability from the\n      device after circuit execution. :meth:`~.marginal_prob` may be used here.\n\n    This device contains common utility methods for qubit-based devices. These\n    do not need to be overwritten. Utility methods include:\n\n    * :meth:`~.expval`, :meth:`~.var`, :meth:`~.sample`: return expectation values,\n      variances, and samples of observables after the circuit has been rotated\n      into the observable eigenbasis.\n\n    Args:\n        wires (int): number of subsystems in the quantum state represented by the device\n        shots (int): number of circuit evaluations/random samples used to estimate\n            expectation values of observables\n        analytic (bool): If ``True``, the device calculates probability, expectation values,\n            and variances analytically. If ``False``, a finite number of samples set by\n            the argument ``shots`` are used to estimate these quantities.\n    """"""\n\n    # pylint: disable=too-many-public-methods\n    C_DTYPE = np.complex128\n    R_DTYPE = np.float64\n    _asarray = staticmethod(np.asarray)\n    _dot = staticmethod(np.dot)\n    _abs = staticmethod(np.abs)\n    _reduce_sum = staticmethod(lambda array, axes: np.apply_over_axes(np.sum, array, axes))\n    _reshape = staticmethod(np.reshape)\n    _flatten = staticmethod(lambda array: array.flatten())\n    _gather = staticmethod(lambda array, indices: array[indices])\n    _einsum = staticmethod(np.einsum)\n    _cast = staticmethod(np.asarray)\n    _transpose = staticmethod(np.transpose)\n    _tensordot = staticmethod(np.tensordot)\n\n    @staticmethod\n    def _scatter(indices, array, new_dimensions):\n        new_array = np.zeros(new_dimensions, dtype=array.dtype.type)\n        new_array[indices] = array\n        return new_array\n\n    observables = {""PauliX"", ""PauliY"", ""PauliZ"", ""Hadamard"", ""Hermitian"", ""Identity""}\n\n    def __init__(self, wires=1, shots=1000, analytic=True):\n        super().__init__(wires=wires, shots=shots)\n\n        self.analytic = analytic\n        """"""bool: If ``True``, the device supports exact calculation of expectation\n        values, variances, and probabilities. If ``False``, samples are used\n        to estimate the statistical quantities above.""""""\n\n        self._samples = None\n        """"""None or array[int]: stores the samples generated by the device\n        *after* rotation to diagonalize the observables.""""""\n\n        self._circuit_hash = None\n        """"""None or int: stores the hash of the circuit from the last execution which\n        can be used by devices in :meth:`apply` for parametric compilation.""""""\n\n    @classmethod\n    def capabilities(cls):\n        """"""Get the capabilities of the plugin.\n\n        Capabilities include:\n\n        * ``""model""`` (*str*): either ``""qubit""`` or ``""CV""``.\n\n        * ``""inverse_operations""`` (*bool*): ``True`` if the device supports\n          applying the inverse of operations. Operations which should be inverted\n          have ``operation.inverse == True``.\n\n        * ``""tensor_observables"" (*bool*): ``True`` if the device supports\n          expectation values/variance/samples of :class:`~.Tensor` observables.\n\n        The qubit device class has built-in support for tensor observables. As a\n        result, devices that inherit from this class automatically\n        have the following items in their capabilities\n        dictionary:\n\n        * ``""model"": ""qubit""``\n        * ``""tensor_observables"": True``\n\n        Returns:\n            dict[str->*]: results\n        """"""\n        capabilities = cls._capabilities\n        capabilities.update(model=""qubit"", tensor_observables=True)\n        return capabilities\n\n    def reset(self):\n        """"""Reset the backend state.\n\n        After the reset, the backend should be as if it was just constructed.\n        Most importantly the quantum state is reset to its initial value.\n        """"""\n        self._samples = None\n        self._circuit_hash = None\n\n    def execute(self, circuit, **kwargs):\n        """"""Execute a queue of quantum operations on the device and then\n        measure the given observables.\n\n        For plugin developers: instead of overwriting this, consider\n        implementing a suitable subset of\n\n        * :meth:`apply`\n\n        * :meth:`~.generate_samples`\n\n        * :meth:`~.probability`\n\n        Additional keyword arguments may be passed to the this method\n        that can be utilised by :meth:`apply`. An example would be passing\n        the ``QNode`` hash that can be used later for parametric compilation.\n\n        Args:\n            circuit (~.CircuitGraph): circuit to execute on the device\n\n        Raises:\n            QuantumFunctionError: if the value of :attr:`~.Observable.return_type` is not supported\n\n        Returns:\n            array[float]: measured value(s)\n        """"""\n        self.check_validity(circuit.operations, circuit.observables)\n\n        self._circuit_hash = circuit.hash\n\n        # apply all circuit operations\n        self.apply(circuit.operations, rotations=circuit.diagonalizing_gates, **kwargs)\n\n        # generate computational basis samples\n        if (not self.analytic) or circuit.is_sampled:\n            self._samples = self.generate_samples()\n\n        # compute the required statistics\n        results = self.statistics(circuit.observables)\n\n        # Ensures that a combination with sample does not put\n        # expvals and vars in superfluous arrays\n        all_sampled = all(obs.return_type is Sample for obs in circuit.observables)\n        if circuit.is_sampled and not all_sampled:\n            return self._asarray(results, dtype=""object"")\n\n        return self._asarray(results)\n\n    @abc.abstractmethod\n    def apply(self, operations, **kwargs):\n        """"""Apply quantum operations, rotate the circuit into the measurement\n        basis, and compile and execute the quantum circuit.\n\n        This method receives a list of quantum operations queued by the QNode,\n        and should be responsible for:\n\n        * Constructing the quantum program\n        * (Optional) Rotating the quantum circuit using the rotation\n          operations provided. This diagonalizes the circuit so that arbitrary\n          observables can be measured in the computational basis.\n        * Compile the circuit\n        * Execute the quantum circuit\n\n        Both arguments are provided as lists of PennyLane :class:`~.Operation`\n        instances. Useful properties include :attr:`~.Operation.name`,\n        :attr:`~.Operation.wires`, and :attr:`~.Operation.parameters`,\n        and :attr:`~.Operation.inverse`:\n\n        >>> op = qml.RX(0.2, wires=[0])\n        >>> op.name # returns the operation name\n        ""RX""\n        >>> op.wires # returns a Wires object representing the wires that the operation acts on\n        Wires([0])\n        >>> op.parameters # returns a list of parameters\n        [0.2]\n        >>> op.inverse # check if the operation should be inverted\n        False\n        >>> op = qml.RX(0.2, wires=[0]).inv\n        >>> op.inverse\n        True\n\n        Args:\n            operations (list[~.Operation]): operations to apply to the device\n\n        Keyword args:\n            rotations (list[~.Operation]): operations that rotate the circuit\n                pre-measurement into the eigenbasis of the observables.\n            hash (int): the hash value of the circuit constructed by `CircuitGraph.hash`\n        """"""\n\n    @staticmethod\n    def active_wires(operators):\n        """"""Returns the wires acted on by a set of operators.\n\n        Args:\n            operators (list[~.Operation]): operators for which\n                we are gathering the active wires\n\n        Returns:\n            Wires: all wires activated by the specified operators\n        """"""\n        list_of_wires = [op.wires for op in operators]\n\n        return Wires.all_wires(list_of_wires)\n\n    def statistics(self, observables):\n        """"""Process measurement results from circuit execution and return statistics.\n\n        This includes returning expectation values, variance, samples and probabilities.\n\n        Args:\n            observables (List[:class:`Observable`]): the observables to be measured\n\n        Raises:\n            QuantumFunctionError: if the value of :attr:`~.Observable.return_type` is not supported\n\n        Returns:\n            Union[float, List[float]]: the corresponding statistics\n        """"""\n        results = []\n\n        for obs in observables:\n            # Pass instances directly\n            if obs.return_type is Expectation:\n                results.append(self.expval(obs))\n\n            elif obs.return_type is Variance:\n                results.append(self.var(obs))\n\n            elif obs.return_type is Sample:\n                results.append(np.array(self.sample(obs)))\n\n            elif obs.return_type is Probability:\n                results.append(self.probability(wires=obs.wires.tolist()))\n\n            elif obs.return_type is not None:\n                raise QuantumFunctionError(\n                    ""Unsupported return type specified for observable {}"".format(obs.name)\n                )\n\n        return results\n\n    def generate_samples(self):\n        r""""""Returns the computational basis samples generated for all wires.\n\n        Note that PennyLane uses the convention :math:`|q_0,q_1,\\dots,q_{N-1}\\rangle` where\n        :math:`q_0` is the most significant bit.\n\n        .. warning::\n\n            This method should be overwritten on devices that\n            generate their own computational basis samples, with the resulting\n            computational basis samples stored as ``self._samples``.\n\n        Returns:\n             array[complex]: array of samples in the shape ``(dev.shots, dev.num_wires)``\n        """"""\n        number_of_states = 2 ** self.num_wires\n\n        rotated_prob = self.analytic_probability()\n\n        samples = self.sample_basis_states(number_of_states, rotated_prob)\n        return QubitDevice.states_to_binary(samples, self.num_wires)\n\n    def sample_basis_states(self, number_of_states, state_probability):\n        """"""Sample from the computational basis states based on the state\n        probability.\n\n        This is an auxiliary method to the generate_samples method.\n\n        Args:\n            number_of_states (int): the number of basis states to sample from\n\n        Returns:\n            List[int]: the sampled basis states\n        """"""\n        basis_states = np.arange(number_of_states)\n        return np.random.choice(basis_states, self.shots, p=state_probability)\n\n    @staticmethod\n    def states_to_binary(samples, num_wires):\n        """"""Convert basis states from base 10 to binary representation.\n\n        This is an auxiliary method to the generate_samples method.\n\n        Args:\n            samples (List[int]): samples of basis states in base 10 representation\n            number_of_states (int): the number of basis states to sample from\n\n        Returns:\n            List[int]: basis states in binary representation\n        """"""\n        powers_of_two = 1 << np.arange(num_wires)\n        states_sampled_base_ten = samples[:, None] & powers_of_two\n        return (states_sampled_base_ten > 0).astype(int)[:, ::-1]\n\n    @property\n    def circuit_hash(self):\n        """"""The hash of the circuit upon the last execution.\n\n        This can be used by devices in :meth:`~.apply` for parametric compilation.\n        """"""\n        return self._circuit_hash\n\n    @property\n    def state(self):\n        """"""Returns the state vector of the circuit prior to measurement.\n\n        .. note::\n\n            Only state vector simulators support this property. Please see the\n            plugin documentation for more details.\n        """"""\n        raise NotImplementedError\n\n    def analytic_probability(self, wires=None):\n        r""""""Return the (marginal) probability of each computational basis\n        state from the last run of the device.\n\n        PennyLane uses the convention\n        :math:`|q_0,q_1,\\dots,q_{N-1}\\rangle` where :math:`q_0` is the most\n        significant bit.\n\n        If no wires are specified, then all the basis states representable by\n        the device are considered and no marginalization takes place.\n\n        .. note::\n\n            :meth:`marginal_prob` may be used as a utility method\n            to calculate the marginal probability distribution.\n\n        Args:\n            wires (Sequence[int]): Sequence of wires to return\n                marginal probabilities for. Wires not provided\n                are traced out of the system.\n\n        Returns:\n            List[float]: list of the probabilities\n        """"""\n        raise NotImplementedError\n\n    def estimate_probability(self, wires=None):\n        """"""Return the estimated probability of each computational basis state\n        using the generated samples.\n\n        Args:\n            wires (Sequence[int]): Sequence of wires to return\n                marginal probabilities for. Wires not provided\n                are traced out of the system.\n\n        Returns:\n            List[float]: list of the probabilities\n        """"""\n        # consider only the requested wires\n        wires = np.hstack(wires)\n\n        samples = self._samples[:, np.array(wires)]  # TODO: Use indices for nonconsec wires\n\n        # convert samples from a list of 0, 1 integers, to base 10 representation\n        unraveled_indices = [2] * len(wires)\n        indices = np.ravel_multi_index(samples.T, unraveled_indices)\n\n        # count the basis state occurrences, and construct the probability vector\n        basis_states, counts = np.unique(indices, return_counts=True)\n        prob = np.zeros([2 ** len(wires)], dtype=np.float64)\n        prob[basis_states] = counts / self.shots\n        return self._asarray(prob, dtype=self.R_DTYPE)\n\n    def probability(self, wires=None):\n        """"""Return either the analytic probability or estimated probability of\n        each computational basis state.\n\n        If no :attr:`~.analytic` attributes exists for the device, then return the\n        estimated probability.\n\n        Args:\n            wires (Sequence[int]): Sequence of wires to return\n                marginal probabilities for. Wires not provided\n                are traced out of the system.\n\n        Returns:\n            List[float]: list of the probabilities\n        """"""\n        wires = wires or range(self.num_wires)\n\n        if hasattr(self, ""analytic"") and self.analytic:\n            return self.analytic_probability(wires=wires)\n\n        return self.estimate_probability(wires=wires)\n\n    def marginal_prob(self, prob, wires=None):\n        r""""""Return the marginal probability of the computational basis\n        states by summing the probabiliites on the non-specified wires.\n\n        If no wires are specified, then all the basis states representable by\n        the device are considered and no marginalization takes place.\n\n        .. note::\n\n            If the provided wires are not strictly increasing, the returned marginal\n            probabilities take this permuation into account.\n\n            For example, if ``wires=[2, 0]``, then the returned marginal\n            probability vector will take this \'reversal\' of the two wires\n            into account:\n\n            .. math::\n\n                \\mathbb{P}^{(2, 0)}\n                            = \\left[\n                               |00\\rangle, |10\\rangle, |01\\rangle, |11\\rangle\n                              \\right]\n\n        Args:\n            prob: The probabilities to return the marginal probabilities\n                for\n            wires (Sequence[int]): Sequence of wires to return\n                marginal probabilities for. Wires not provided\n                are traced out of the system.\n\n        Returns:\n            array[float]: array of the resulting marginal probabilities.\n        """"""\n        if wires is None:\n            # no need to marginalize\n            return prob\n\n        wires = np.hstack(wires)  # TODO: re-asses for nonconsecutive wires\n\n        # determine which wires are to be summed over\n        inactive_wires = list(set(range(self.num_wires)) - set(wires))\n\n        # reshape the probability so that each axis corresponds to a wire\n        prob = self._reshape(prob, [2] * self.num_wires)\n\n        # sum over all inactive wires\n        prob = self._flatten(self._reduce_sum(prob, inactive_wires))\n\n        # The wires provided might not be in consecutive order (i.e., wires might be [2, 0]).\n        # If this is the case, we must permute the marginalized probability so that\n        # it corresponds to the orders of the wires passed.\n        basis_states = np.array(list(itertools.product([0, 1], repeat=len(wires))))\n        perm = np.ravel_multi_index(\n            basis_states[:, np.argsort(np.argsort(wires))].T, [2] * len(wires)\n        )\n        return self._gather(prob, perm)\n\n    def expval(self, observable):\n        wires = observable.wires.tolist()  # TODO: re-asses for nonconsecutive wires\n\n        if self.analytic:\n            # exact expectation value\n            eigvals = self._asarray(observable.eigvals, dtype=self.R_DTYPE)\n            prob = self.probability(wires=wires)\n            return self._dot(eigvals, prob)\n\n        # estimate the ev\n        return np.mean(self.sample(observable))\n\n    def var(self, observable):\n        wires = observable.wires.tolist()  # TODO: re-asses for nonconsecutive wires\n\n        if self.analytic:\n            # exact variance value\n            eigvals = self._asarray(observable.eigvals, dtype=self.R_DTYPE)\n            prob = self.probability(wires=wires)\n            return self._dot((eigvals ** 2), prob) - self._dot(eigvals, prob) ** 2\n\n        # estimate the variance\n        return np.var(self.sample(observable))\n\n    def sample(self, observable):\n        wires = observable.wires.tolist()  # TODO: re-asses for nonconsecutive wires\n        name = observable.name\n\n        if isinstance(name, str) and name in {""PauliX"", ""PauliY"", ""PauliZ"", ""Hadamard""}:\n            # Process samples for observables with eigenvalues {1, -1}\n            return 1 - 2 * self._samples[:, wires[0]]\n\n        # Replace the basis state in the computational basis with the correct eigenvalue.\n        # Extract only the columns of the basis samples required based on ``wires``.\n        wires = np.hstack(wires)\n        samples = self._samples[:, np.array(wires)]\n        unraveled_indices = [2] * len(wires)\n        indices = np.ravel_multi_index(samples.T, unraveled_indices)\n        return observable.eigvals[indices]\n'"
pennylane/_queuing_context.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the :class:`QueuingContext` abstract base class.\n""""""\nimport abc\n\n\nclass QueuingContext(abc.ABC):\n    """"""Abstract base class for classes that exposes a queue for Operations.\n\n    In PennyLane, the construction of quantum gates is separated from the\n    specific quantum node (:class:`BaseQNode`) that they belong to. However,\n    including logic for this when creating an instance of :class:`Operator`\n    does not align with the current architecture. Therefore, there is a need to\n    use a high level object that holds information about the relationship\n    between quantum gates and a quantum node.\n\n    The ``QueuingContext`` class realizes this by providing access to the\n    current QNode.  Furthermore, it provides the flexibility to have multiple\n    objects record the creation of quantum gates.\n\n    The QueuingContext class both acts as the abstract base class for all\n    classes that expose a queue for Operations (so-called contexts), as well\n    as the interface to said queues. The active contexts contain maximally one QNode\n    and an arbitrary number of other contexts like the OperationRecorder.\n    """"""\n\n    _active_contexts = []\n    """"""The list of contexts that are currently active.""""""\n\n    def __enter__(self):\n        """"""Adds this instance to the global list of active contexts.\n\n        Returns:\n            QueuingContext: This instance\n        """"""\n        QueuingContext._active_contexts.append(self)\n\n        return self\n\n    def __exit__(self, exception_type, exception_value, traceback):\n        """"""Remove this instance from the global list of active contexts.\n        """"""\n        QueuingContext._active_contexts.remove(self)\n\n    @abc.abstractmethod\n    def _append_operator(self, operator):\n        """"""Append an operator to this QueuingContext instance.\n\n        Args:\n            operator (Operator): The Operator instance to be appended\n        """"""\n\n    @classmethod\n    def append_operator(cls, operator):\n        """"""Append an operator to the global queue(s).\n\n        Args:\n            operator (Operator): The Operator instance to be appended\n        """"""\n        for context in cls._active_contexts:\n            context._append_operator(operator)  # pylint: disable=protected-access\n\n    @abc.abstractmethod\n    def _remove_operator(self, operator):\n        """"""Remove an operator from this QueuingContext instance.\n\n        Args:\n            operator (Operator): The Operator instance to be removed\n        """"""\n\n    @classmethod\n    def remove_operator(cls, operator):\n        """"""Remove an operator from the global queue(s) if it is in the queue(s).\n\n        Args:\n            operator (Operator): The Operator instance to be removed\n        """"""\n        for context in cls._active_contexts:\n            # We use the duck-typing approach to assume that the underlying remove\n            # behaves like list.remove and throws a ValueError if the operator\n            # is not in the list\n            try:\n                context._remove_operator(operator)  # pylint: disable=protected-access\n            except ValueError:\n                pass\n'"
pennylane/_version.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""\nVersion number (major.minor.patch[-label])\n""""""\n\n__version__ = ""0.10.0-dev""\n'"
pennylane/about.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nThis module contains the :func:`about` function to display all the details of the PennyLane installation,\ne.g., OS, version, `Numpy` and `Scipy` versions, installation method.\n""""""\nimport platform\nimport importlib\nimport sys\nfrom pkg_resources import iter_entry_points\nimport numpy\nimport scipy\n\n# The following if/else block enables support for pip versions 19.3.x\n_parent_module = importlib.util.find_spec(""pip._internal.main"") or importlib.util.find_spec(\n    ""pip._internal""\n)\n_internal_main = importlib.util.module_from_spec(_parent_module)\n_parent_module.loader.exec_module(_internal_main)\n\n\ndef about():\n    """"""\n    Prints the information for pennylane installation.\n    """"""\n    plugin_devices = iter_entry_points(""pennylane.plugins"")\n    _internal_main.main([""show"", ""pennylane""])\n    print(""Platform info:           {}"".format(platform.platform(aliased=True)))\n    print(""Python version:          {0}.{1}.{2}"".format(*sys.version_info[0:3]))\n    print(""Numpy version:           {}"".format(numpy.__version__))\n    print(""Scipy version:           {}"".format(scipy.__version__))\n\n    print(""Installed devices:"")\n\n    for d in plugin_devices:\n        print(""- {} ({}-{})"".format(d.name, d.dist.project_name, d.dist.version))\n\n\nif __name__ == ""__main__"":\n    about()\n'"
pennylane/circuit_graph.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the CircuitGraph class which is used to generate a DAG (directed acyclic graph)\nrepresentation of a quantum circuit from an Operator queue.\n""""""\nfrom collections import Counter, OrderedDict, namedtuple\n\nimport networkx as nx\n\nimport pennylane as qml\nfrom pennylane.operation import Sample\n\nfrom .circuit_drawer import CHARSETS, CircuitDrawer\nfrom .utils import _flatten\nfrom .variable import Variable\n\n\nOPENQASM_GATES = {\n    ""CNOT"": ""cx"",\n    ""CZ"": ""cz"",\n    ""U3"": ""u3"",\n    ""U2"": ""u2"",\n    ""U1"": ""u1"",\n    ""Identity"": ""id"",\n    ""PauliX"": ""x"",\n    ""PauliY"": ""y"",\n    ""PauliZ"": ""z"",\n    ""Hadamard"": ""h"",\n    ""S"": ""s"",\n    ""S.inv"": ""sdg"",\n    ""T"": ""t"",\n    ""T.inv"": ""tdg"",\n    ""RX"": ""rx"",\n    ""RY"": ""ry"",\n    ""RZ"": ""rz"",\n    ""CRX"": ""crx"",\n    ""CRY"": ""cry"",\n    ""CRZ"": ""crz"",\n    ""SWAP"": ""swap"",\n    ""Toffoli"": ""ccx"",\n    ""CSWAP"": ""cswap"",\n    ""PhaseShift"": ""u1"",\n}\n""""""\ndict[str, str]: Maps PennyLane gate names to equivalent QASM gate names.\n\nNote that QASM has two native gates:\n\n- ``U`` (equivalent to :class:`~.U3`)\n- ``CX`` (equivalent to :class:`~.CNOT`)\n\nAll other gates are defined in the file qelib1.inc:\nhttps://github.com/Qiskit/openqasm/blob/master/examples/generic/qelib1.inc\n""""""\n\n\ndef _by_idx(x):\n    """"""Sorting key for Operators: queue index aka temporal order.\n\n    Args:\n        x (Operator): node in the circuit graph\n    Returns:\n        int: sorting key for the node\n    """"""\n    return x.queue_idx\n\n\ndef _is_observable(x):\n    """"""Predicate for deciding if an Operator instance is an observable.\n\n    .. note::\n       Currently some :class:`Observable` instances are not observables in this sense,\n       since they can be used as gates as well.\n\n    Args:\n        x (Operator): node in the circuit graph\n    Returns:\n        bool: True iff x is an observable\n    """"""\n    return getattr(x, ""return_type"", None) is not None\n\n\ndef _list_at_index_or_none(list, idx):\n    """"""Return the element of a list at the given index if it exists, return None otherwise.\n\n    Args:\n        list (list[object]): The target list\n        idx (int): The target index\n\n    Returns:\n        Union[object,NoneType]: The element at the target index or None\n    """"""\n    if len(list) > idx:\n        return list[idx]\n\n    return None\n\n\nLayer = namedtuple(""Layer"", [""ops"", ""param_inds""])\n""""""Parametrized layer of the circuit.\n\nArgs:\n\n    ops (list[Operator]): parametrized operators in the layer\n    param_inds (list[int]): corresponding free parameter indices\n""""""\n# TODO define what a layer is\n\nLayerData = namedtuple(""LayerData"", [""pre_ops"", ""ops"", ""param_inds"", ""post_ops""])\n""""""Parametrized layer of the circuit.\n\nArgs:\n    pre_ops (list[Operator]): operators that precede the layer\n    ops (list[Operator]): parametrized operators in the layer\n    param_inds (tuple[int]): corresponding free parameter indices\n    post_ops (list[Operator]): operators that succeed the layer\n""""""\n\n\nclass CircuitGraph:\n    """"""Represents a quantum circuit as a directed acyclic graph.\n\n    In this representation the :class:`~.Operator` instances are the nodes of the graph,\n    and each directed edge represent a subsystem (or a group of subsystems) on which the two\n    Operators act subsequently. This representation can describe the causal relationships\n    between arbitrary quantum channels and measurements, not just unitary gates.\n\n    Args:\n        ops (Iterable[Operator]): quantum operators constituting the circuit, in temporal order\n        variable_deps (dict[int, list[ParameterDependency]]): Free parameters of the quantum circuit.\n            The dictionary key is the parameter index.\n    """"""\n\n    # pylint: disable=too-many-public-methods\n\n    def __init__(self, ops, variable_deps):\n        self.variable_deps = variable_deps\n\n        self._grid = {}\n        """"""dict[int, list[Operator]]: dictionary representing the quantum circuit as a grid.\n        Here, the key is the wire number, and the value is a list containing the operators on that wire.\n        """"""\n        self.num_wires = 0\n        """"""int: number of wires the circuit contains""""""\n        for k, op in enumerate(ops):\n            self.num_wires = max(self.num_wires, max(op.wires.tolist()) + 1)\n            op.queue_idx = k  # store the queue index in the Operator\n            for w in set(op.wires.tolist()):\n                # Add op to the grid, to the end of wire w\n                self._grid.setdefault(w, []).append(op)\n\n        # TODO: State preparations demolish the incoming state entirely, and therefore should have no incoming edges.\n\n        self._graph = nx.DiGraph()  #: nx.DiGraph: DAG representation of the quantum circuit\n        # Iterate over each (populated) wire in the grid\n        for wire in self._grid.values():\n            # Add the first operator on the wire to the graph\n            # This operator does not depend on any others\n            self._graph.add_node(wire[0])\n\n            for i in range(1, len(wire)):\n                # For subsequent operators on the wire:\n                if wire[i] not in self._graph:\n                    # Add them to the graph if they are not already\n                    # in the graph (multi-qubit operators might already have been placed)\n                    self._graph.add_node(wire[i])\n\n                # Create an edge between this and the previous operator\n                self._graph.add_edge(wire[i - 1], wire[i])\n\n    def print_contents(self):\n        """"""Prints the contents of the quantum circuit.""""""\n\n        print(""Operations"")\n        print(""=========="")\n        for op in self.operations:\n            print(repr(op))\n\n        print(""\\nObservables"")\n        print(""==========="")\n        for op in self.observables:\n            print(repr(op))\n\n    def serialize(self):\n        """"""Serialize the quantum circuit graph based on the operations and\n        observables in the circuit graph and the index of the variables\n        used by them.\n\n        The string that is produced can be later hashed to assign a unique value to the circuit graph.\n\n        Returns:\n            string: serialized quantum circuit graph\n        """"""\n        serialization_string = """"\n        delimiter = ""!""\n        variable_delimiter = ""V""\n\n        for op in self.operations_in_order:\n            serialization_string += op.name\n\n            for param in op.params:\n                if isinstance(param, Variable):\n                    serialization_string += delimiter\n                    serialization_string += variable_delimiter\n                    serialization_string += str(param.idx)\n                    serialization_string += delimiter\n\n                else:\n                    serialization_string += delimiter\n                    serialization_string += str(param)\n                    serialization_string += delimiter\n\n            serialization_string += str(op.wires.tolist())\n\n        # Adding a distinct separating string that could not occur by any combination of the\n        # name of the operation and wires\n        serialization_string += ""|||""\n\n        for obs in self.observables_in_order:\n            serialization_string += str(obs.name)\n            for param in obs.params:\n                serialization_string += delimiter\n                serialization_string += str(param)\n                serialization_string += delimiter\n\n            serialization_string += str(obs.wires.tolist())\n\n        return serialization_string\n\n    @property\n    def hash(self):\n        """"""Creating a hash for the circuit graph based on the string generated by serialize.\n\n        Returns:\n            int: the hash of the serialized quantum circuit graph\n        """"""\n        return hash(self.serialize())\n\n    def to_openqasm(self, rotations=True):\n        """"""Serialize the circuit as an OpenQASM 2.0 program.\n\n        Only operations are serialized; all measurements\n        are assumed to take place in the computational basis.\n\n        .. note::\n\n            The serialized OpenQASM program assumes that gate definitions\n            in ``qelib1.inc`` are available.\n\n        Args:\n            rotations (bool): in addition to serializing user-specified\n                operations, also include the gates that diagonalize the\n                measured wires such that they are in the eigenbasis of the circuit observables.\n\n        Returns:\n            str: OpenQASM serialization of the circuit\n        """"""\n        # We import decompose_queue here to avoid a circular import\n        from pennylane.qnodes.base import decompose_queue  # pylint: disable=import-outside-toplevel\n\n        class QASMSerializerDevice:\n            """"""A mock device, to be used when performing the decomposition.\n            The short_name is used in error messages if the decomposition fails.\n            """"""\n\n            # pylint: disable=too-few-public-methods\n            short_name = ""QASM serializer""\n            supports_operation = staticmethod(lambda x: x in OPENQASM_GATES)\n\n        # add the QASM headers\n        qasm_str = ""OPENQASM 2.0;\\n""\n        qasm_str += \'include ""qelib1.inc"";\\n\'\n\n        if self.num_wires == 0:\n            # empty circuit\n            return qasm_str\n\n        # create the quantum and classical registers\n        qasm_str += ""qreg q[{}];\\n"".format(self.num_wires)\n        qasm_str += ""creg c[{}];\\n"".format(self.num_wires)\n\n        # get the user applied circuit operations\n        operations = self.operations\n\n        if rotations:\n            # if requested, append diagonalizing gates corresponding\n            # to circuit observables\n            operations += self.diagonalizing_gates\n\n        # decompose the queue\n        decomposed_ops = decompose_queue(operations, QASMSerializerDevice)\n\n        # create the QASM code representing the operations\n        for op in decomposed_ops:\n            gate = OPENQASM_GATES[op.name]\n            wires = "","".join([""q[{}]"".format(w) for w in op.wires.tolist()])\n            params = """"\n\n            if op.num_params > 0:\n                # If the operation takes parameters, construct a string\n                # with parameter values.\n                params = ""("" + "","".join([str(p) for p in op.parameters]) + "")""\n\n            qasm_str += ""{name}{params} {wires};\\n"".format(name=gate, params=params, wires=wires)\n\n        # apply computational basis measurements to each quantum register\n        # NOTE: This is not strictly necessary, we could inspect self.observables,\n        # and then only measure wires which are requested by the user. However,\n        # some devices which consume QASM require all registers be measured, so\n        # measure all wires to be safe.\n        for wire in range(self.num_wires):\n            qasm_str += ""measure q[{wire}] -> c[{wire}];\\n"".format(wire=wire)\n\n        return qasm_str\n\n    @property\n    def observables_in_order(self):\n        """"""Observables in the circuit, in a fixed topological order.\n\n        The topological order used by this method is guaranteed to be the same\n        as the order in which the measured observables are returned by the quantum function.\n        Currently the topological order is determined by the queue index.\n\n        Returns:\n            list[Observable]: observables\n        """"""\n        nodes = [node for node in self._graph.nodes if _is_observable(node)]\n        return sorted(nodes, key=_by_idx)\n\n    observables = observables_in_order\n\n    @property\n    def operations_in_order(self):\n        """"""Operations in the circuit, in a fixed topological order.\n\n        Currently the topological order is determined by the queue index.\n\n        The complement of :meth:`QNode.observables`. Together they return every :class:`Operator`\n        instance in the circuit.\n\n        Returns:\n            list[Operation]: operations\n        """"""\n        nodes = [node for node in self._graph.nodes if not _is_observable(node)]\n        return sorted(nodes, key=_by_idx)\n\n    operations = operations_in_order\n\n    @property\n    def graph(self):\n        """"""The graph representation of the quantum circuit.\n\n        The graph has nodes representing :class:`.Operator` instances,\n        and directed edges pointing from nodes to their immediate dependents/successors.\n\n        Returns:\n            networkx.DiGraph: the directed acyclic graph representing the quantum circuit\n        """"""\n        return self._graph\n\n    def wire_indices(self, wire):\n        """"""Operator indices on the given wire.\n\n        Args:\n            wire (int): wire to examine\n\n        Returns:\n            list[int]: indices of operators on the wire, in temporal order\n        """"""\n        return [op.queue_idx for op in self._grid[wire]]\n\n    def ancestors(self, ops):\n        """"""Ancestors of a given set of operators.\n\n        Args:\n            ops (Iterable[Operator]): set of operators in the circuit\n\n        Returns:\n            set[Operator]: ancestors of the given operators\n        """"""\n        return set().union(*(nx.dag.ancestors(self._graph, o) for o in ops)) - set(ops)\n\n    def descendants(self, ops):\n        """"""Descendants of a given set of operators.\n\n        Args:\n            ops (Iterable[Operator]): set of operators in the circuit\n\n        Returns:\n            set[Operator]: descendants of the given operators\n        """"""\n        return set().union(*(nx.dag.descendants(self._graph, o) for o in ops)) - set(ops)\n\n    def _in_topological_order(self, ops):\n        """"""Sorts a set of operators in the circuit in a topological order.\n\n        Args:\n            ops (Iterable[Operator]): set of operators in the circuit\n\n        Returns:\n            Iterable[Operator]: same set of operators, topologically ordered\n        """"""\n        G = nx.DiGraph(self._graph.subgraph(ops))\n        return nx.dag.topological_sort(G)\n\n    def ancestors_in_order(self, ops):\n        """"""Operator ancestors in a topological order.\n\n        Currently the topological order is determined by the queue index.\n\n        Args:\n            ops (Iterable[Operator]): set of operators in the circuit\n\n        Returns:\n            list[Operator]: ancestors of the given operators, topologically ordered\n        """"""\n        # return self._in_topological_order(self.ancestors(ops))  # an abitrary topological order\n        return sorted(self.ancestors(ops), key=_by_idx)\n\n    def descendants_in_order(self, ops):\n        """"""Operator descendants in a topological order.\n\n        Currently the topological order is determined by the queue index.\n\n        Args:\n            ops (Iterable[Operator]): set of operators in the circuit\n\n        Returns:\n            list[Operator]: descendants of the given operators, topologically ordered\n        """"""\n        return sorted(self.descendants(ops), key=_by_idx)\n\n    def nodes_between(self, a, b):\n        r""""""Nodes on all the directed paths between the two given nodes.\n\n        Returns the set of all nodes ``s`` that fulfill :math:`a \\le s \\le b`.\n        There is a directed path from ``a`` via ``s`` to ``b`` iff the set is nonempty.\n        The endpoints belong to the path.\n\n        Args:\n            a (Operator): initial node\n            b (Operator): final node\n\n        Returns:\n            set[Operator]: nodes on all the directed paths between a and b\n        """"""\n        A = self.descendants([a])\n        A.add(a)\n        B = self.ancestors([b])\n        B.add(b)\n        return A & B\n\n    def invisible_operations(self):\n        """"""Operations that cannot affect the circuit output.\n\n        An :class:`Operation` instance in a quantum circuit is *invisible* if is not an ancestor\n        of an observable. Such an operation cannot affect the circuit output, and usually indicates\n        there is something wrong with the circuit.\n\n        Returns:\n            set[Operator]: operations that cannot affect the output\n        """"""\n        visible = self.ancestors(self.observables)\n        invisible = set(self.operations) - visible\n        return invisible\n\n    @property\n    def parametrized_layers(self):\n        """"""Identify the parametrized layer structure of the circuit.\n\n        Returns:\n            list[Layer]: layers of the circuit\n        """"""\n        # FIXME maybe layering should be greedier, for example [a0 b0 c1 d1] should layer as [a0 c1], [b0, d1] and not [a0], [b0 c1], [d1]\n        # keep track of the current layer\n        current = Layer([], [])\n        layers = [current]\n\n        # sort vars by first occurrence of the var in the ops queue\n        variable_ops_sorted = sorted(self.variable_deps.items(), key=lambda x: x[1][0].op.queue_idx)\n\n        # iterate over all parameters\n        for param_idx, gate_param_tuple in variable_ops_sorted:\n            # iterate over ops depending on that param\n            for op, _ in gate_param_tuple:\n                # get all predecessor ops of the op\n                sub = self.ancestors((op,))\n\n                # check if any of the dependents are in the\n                # currently assembled layer\n                if set(current.ops) & sub:\n                    # operator depends on current layer, start a new layer\n                    current = Layer([], [])\n                    layers.append(current)\n\n                # store the parameters and ops indices for the layer\n                current.ops.append(op)\n                current.param_inds.append(param_idx)\n\n        return layers\n\n    def iterate_parametrized_layers(self):\n        """"""Parametrized layers of the circuit.\n\n        Returns:\n            Iterable[LayerData]: layers with extra metadata\n        """"""\n        # iterate through each layer\n        for ops, param_inds in self.parametrized_layers:\n            pre_queue = self.ancestors_in_order(ops)\n            post_queue = self.descendants_in_order(ops)\n            yield LayerData(pre_queue, ops, tuple(param_inds), post_queue)\n\n    def greedy_layers(self):\n        """"""Greedily collected layers of the circuit. Empty slots are filled with ``None``.\n\n        Layers are built by pushing back gates in the circuit as far as possible, so that\n        every Gate is at the lower possible layer.\n\n        Returns:\n            Tuple[list[list[~.Operation]], list[list[~.Observable]]]:\n            Tuple of the circuits operations and the circuits observables, both indexed\n            by wires.\n        """"""\n        l = 0\n\n        operations = OrderedDict()\n        for key in sorted(self._grid):\n            operations[key] = self._grid[key]\n\n        for wire in operations:\n            operations[wire] = list(\n                filter(\n                    lambda op: not (\n                        isinstance(op, qml.operation.Observable) and op.return_type is not None\n                    ),\n                    operations[wire],\n                )\n            )\n\n        while True:\n            layer_ops = {wire: _list_at_index_or_none(operations[wire], l) for wire in operations}\n            num_ops = Counter(layer_ops.values())\n\n            if None in num_ops and num_ops[None] == len(operations):\n                break\n\n            for (wire, op) in layer_ops.items():\n                if op is None:\n                    operations[wire].append(None)\n                    continue\n\n                # push back to next layer if not all args wires are there yet\n                if len(op.wires) > num_ops[op]:\n                    operations[wire].insert(l, None)\n\n            l += 1\n\n        observables = OrderedDict()\n        for wire in sorted(self._grid):\n            observables[wire] = list(\n                filter(\n                    lambda op: isinstance(op, qml.operation.Observable)\n                    and op.return_type is not None,\n                    self._grid[wire],\n                )\n            )\n\n            if not observables[wire]:\n                observables[wire] = [None]\n\n        return (\n            [operations[wire] for wire in operations],\n            [observables[wire] for wire in observables],\n        )\n\n    def update_node(self, old, new):\n        """"""Replaces the given circuit graph node with a new one.\n\n        Args:\n            old (Operator): node to replace\n            new (Operator): replacement\n\n        Raises:\n            ValueError: if the new :class:`~.Operator` does not act on the same wires as the old one\n        """"""\n        # NOTE Does not alter the graph edges in any way. variable_deps is not changed, _grid is not changed. Dangerous!\n        if new.wires != old.wires:\n            raise ValueError(""The new Operator must act on the same wires as the old one."")\n        new.queue_idx = old.queue_idx\n        nx.relabel_nodes(self._graph, {old: new}, copy=False)  # change the graph in place\n\n    def draw(self, charset=""unicode"", show_variable_names=False):\n        """"""Draw the CircuitGraph as a circuit diagram.\n\n        Args:\n            charset (str, optional): The charset that should be used. Currently, ""unicode"" and ""ascii"" are supported.\n            show_variable_names (bool, optional): Show variable names instead of variable values.\n\n        Raises:\n            ValueError: If the given charset is not supported\n\n        Returns:\n            str: The circuit diagram representation of the ``CircuitGraph``\n        """"""\n        grid, obs = self.greedy_layers()\n\n        if charset not in CHARSETS:\n            raise ValueError(\n                ""Charset {} is not supported. Supported charsets: {}."".format(\n                    charset, "", "".join(CHARSETS.keys())\n                )\n            )\n\n        drawer = CircuitDrawer(\n            grid, obs, charset=CHARSETS[charset], show_variable_names=show_variable_names\n        )\n\n        return drawer.draw()\n\n    @property\n    def diagonalizing_gates(self):\n        """"""Returns the gates that diagonalize the measured wires such that they\n        are in the eigenbasis of the circuit observables.\n\n        Returns:\n            List[~.Operation]: the operations that diagonalize the observables\n        """"""\n        rotation_gates = []\n\n        for observable in self.observables_in_order:\n            rotation_gates.extend(observable.diagonalizing_gates())\n\n        return rotation_gates\n\n    @property\n    def is_sampled(self):\n        """"""Returns ``True`` if the circuit graph contains observables\n        which are sampled.""""""\n        return any(obs.return_type == Sample for obs in self.observables_in_order)\n'"
pennylane/configuration.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nThis module contains the :class:`Configuration` class, which is used to\nload, store, save, and modify configuration options for PennyLane and all\nsupported plugins and devices.\n""""""\nimport os\nimport logging as log\n\nimport toml\nfrom appdirs import user_config_dir\n\nlog.getLogger()\n\n\nclass Configuration:\n    """"""Configuration class.\n\n    This class is responsible for loading, saving, and storing PennyLane\n    and plugin/device configurations.\n\n    Args:\n        name (str): filename of the configuration file.\n        This should be a valid TOML file. You may also pass an absolute\n        or a relative file path to the configuration file.\n    """"""\n\n    def __init__(self, name):\n        # Look for an existing configuration file\n        self._config = {}\n        self._filepath = None\n        self._name = name\n        self._user_config_dir = user_config_dir(""pennylane"", ""Xanadu"")\n        self._env_config_dir = os.environ.get(""PENNYLANE_CONF"", """")\n\n        # search the current directory the directory under environment\n        # variable PENNYLANE_CONF, and default user config directory, in that order.\n        directories = [os.curdir, self._env_config_dir, self._user_config_dir, """"]\n        for idx, directory in enumerate(directories):\n            try:\n                self._filepath = os.path.join(directory, self._name)\n                self.load(self._filepath)\n                break\n            except FileNotFoundError:\n                if idx == len(directories) - 1:\n                    log.info(""No PennyLane configuration file found."")\n\n    def __str__(self):\n        if self._config:\n            return ""{}"".format(self._config)\n        return """"\n\n    def __repr__(self):\n        return ""PennyLane Configuration <{}>"".format(self._filepath)\n\n    @property\n    def path(self):\n        """"""Return the path of the loaded configuration file.\n\n        Returns:\n            str: If no configuration is loaded, this returns ``None``.""""""\n        return self._filepath\n\n    def load(self, filepath):\n        """"""Load a configuration file.\n\n        Args:\n            filepath (str): path to the configuration file.\n        """"""\n        with open(filepath, ""r"") as f:\n            self._config = toml.load(f)\n\n    def save(self, filepath):\n        """"""Save a configuration file.\n\n        Args:\n            filepath (str): path to the configuration file.\n        """"""\n        with open(filepath, ""w"") as f:\n            toml.dump(self._config, f)\n\n    def __getitem__(self, key):\n        keys = key.split(""."")\n        return self.safe_get(self._config, *keys)\n\n    def __setitem__(self, key, value):\n        keys = key.split(""."")\n        self.safe_set(self._config, value, *keys)\n\n    def __bool__(self):\n        return bool(self._config)\n\n    @staticmethod\n    def safe_set(dct, value, *keys):\n        """"""Safely set the value of a key from a nested dictionary.\n\n        If any key provided does not exist, a dictionary containing the\n        remaining keys is dynamically created and set to the required value.\n\n        Args:\n            dct (dict): the dictionary to set the value of.\n            value: the value to set. Can be any valid type.\n            *keys: each additional argument corresponds to a nested key.\n        """"""\n        for key in keys[:-1]:\n            dct = dct.setdefault(key, {})\n\n        dct[keys[-1]] = value\n\n    @staticmethod\n    def safe_get(dct, *keys):\n        """"""Safely return value from a nested dictionary.\n\n        If any key provided does not exist, an empty dictionary is returned.\n\n        Args:\n            dct (dict): the dictionary to set the value of.\n            *keys: each additional argument corresponds to a nested key.\n\n        Returns:\n            value corresponding to ``dct[keys[0]][keys[1]]`` etc.\n        """"""\n        for key in keys:\n            try:\n                dct = dct[key]\n            except KeyError:\n                return {}\n        return dct\n'"
pennylane/init.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nThis module contains functions that generate initial parameters, for example\nto use in templates.\n""""""\n# pylint: disable=too-many-arguments\nfrom math import pi\nfrom pennylane import numpy as np\n\n\ndef qaoa_embedding_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for :func:`~.QAOAEmbedding`, drawn from a uniform\n    distribution.\n\n    Each parameter is drawn uniformly at random\n    from between ``low`` and ``high``. The parameters define the trainable angles of \'ZZ interactions\' and\n    the \'local fields\'.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    if n_wires == 1:\n        shp = (n_layers, 1)\n    elif n_wires == 2:\n        shp = (n_layers, 3)\n    else:\n        shp = (n_layers, 2 * n_wires)\n\n    params = np.random.uniform(low=low, high=high, size=shp)\n    return params\n\n\ndef qaoa_embedding_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for :func:`~.QAOAEmbedding`, drawn from a normal\n    distribution.\n\n    Each parameter is drawn from a normal\n    distribution with ``mean`` and ``variance``. The parameters define the the trainable angles of\n    \'ZZ interactions\' and the \'local fields\' in the template.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n        mean (float): mean of parameters\n        std (float): standard deviation of parameters\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    if n_wires == 1:\n        shp = (n_layers, 1)\n    elif n_wires == 2:\n        shp = (n_layers, 3)\n    else:\n        shp = (n_layers, 2 * n_wires)\n\n    params = np.random.normal(loc=mean, scale=std, size=shp)\n    return params\n\n\ndef strong_ent_layers_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for :func:`~.StronglyEntanglingLayers`, drawn from a uniform\n    distribution.\n\n    The shape of the parameter array is ``(n_layers, n_wires, 3)`` and each parameter is drawn uniformly at random \\\n    from between ``low`` and ``high``. The parameters define the three rotation angles\n    applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n\n    Keyword Args:\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    params = np.random.uniform(low=low, high=high, size=(n_layers, n_wires, 3))\n    return params\n\n\ndef strong_ent_layers_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for :func:`~.StronglyEntanglingLayers`, drawn from a normal\n    distribution.\n\n    The shape of the parameter array is ``(n_layers, n_wires, 3)`` and each parameter is drawn\n    from a normal distribution with mean ``mean`` and standard deviation ``std``.\n    The parameters define the three rotation angles applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n\n    Keyword Args:\n        mean (float): mean of parameters\n        std (float): standard deviation of parameters\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    params = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires, 3))\n    return params\n\n\ndef random_layers_uniform(n_layers, n_wires, n_rots=None, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for :func:`~.RandomLayers`, drawn from a uniform distribution.\n\n    The shape of the parameter array is ``(n_layers, n_rots)`` and each parameter is drawn uniformly at random \\\n    from between ``low`` and ``high``. The parameters define the rotation angles of the randomly \\\n    positioned rotations applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n\n    Keyword Args:\n        n_rots (int): number of rotations, if ``None``, ``n_rots=n_wires``\n        low (float): minimum value of non-angle gate parameters\n        high (float): maximum value of non-angle gate parameters\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    # set default\n    if n_rots is None:\n        n_rots = n_wires\n\n    # no circuit if there are no wires\n    if n_wires == 0:\n        n_rots = 0\n\n    params = np.random.uniform(low=low, high=high, size=(n_layers, n_rots))\n    return params\n\n\ndef random_layers_normal(n_layers, n_wires, n_rots=None, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for :func:`~.RandomLayers`, drawn from a normal distribution.\n\n    The shape of the parameter array is ``(n_layers, n_rots)`` and each parameter is drawn\n    from a normal distribution with mean ``mean`` and standard deviation ``std``.\n    The parameters define the rotation angles of the randomly positioned rotations applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n\n    Keyword Args:\n        n_rots (int): number of rotations, if ``None``, ``n_rots=n_wires``\n        mean (float): mean of parameters\n        std (float): standard deviation of parameters\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    # set default\n    if n_rots is None:\n        n_rots = n_wires\n\n    # no circuit if there are no wires\n    if n_wires == 0:\n        n_rots = 0\n\n    params = np.random.normal(loc=mean, scale=std, size=(n_layers, n_rots))\n    return params\n\n\ndef cvqnn_layers_all(n_layers, n_wires, seed=None):\n    r""""""Creates a list of all eleven parameter arrays for :func:`~.CVNeuralNetLayers`.\n\n    The template contains active gates (``Squeezing``, ``Displacement`` and ``Kerr`` gates), while\n    all other gates are passive.\n    Active gates change the photon number (and hence the energy) of the system, and are\n    therefore drawn from a normal distribution with mean :math:`0` and a small\n    standard deviation of :math:`0.1`.\n    Non-active gate parameters are angles and drawn from a uniform distribution with interval :math:`[0, 2\\pi]`.\n\n    Args:\n        n_layers (int): number of layers of the CV Neural Net\n        n_wires (int): number of modes of the CV Neural Net\n\n    Keyword Args:\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        list of parameter arrays\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    kwargs = {""n_layers"": n_layers, ""n_wires"": n_wires, ""seed"": seed}\n\n    theta_1 = cvqnn_layers_theta_uniform(**kwargs)\n    phi_1 = cvqnn_layers_phi_uniform(**kwargs)\n    varphi_1 = cvqnn_layers_varphi_uniform(**kwargs)\n    r = cvqnn_layers_r_normal(**kwargs)\n    phi_r = cvqnn_layers_phi_r_uniform(**kwargs)\n    theta_2 = cvqnn_layers_theta_uniform(**kwargs)\n    phi_2 = cvqnn_layers_phi_uniform(**kwargs)\n    varphi_2 = cvqnn_layers_varphi_uniform(**kwargs)\n    a = cvqnn_layers_a_normal(**kwargs)\n    phi_a = cvqnn_layers_phi_a_uniform(**kwargs)\n    k = cvqnn_layers_kappa_normal(**kwargs)\n\n    return [theta_1, phi_1, varphi_1, r, phi_r, theta_2, phi_2, varphi_2, a, phi_a, k]\n\n\ndef cvqnn_layers_theta_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``theta`` input to the interferometers of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires*(n_wires-1)/2)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    n_if = n_wires * (n_wires - 1) // 2\n    theta = np.random.uniform(low=low, high=high, size=(n_layers, n_if))\n    return theta\n\n\ndef cvqnn_layers_theta_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``theta`` input to the interferometers of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the array is ``(n_layers, n_wires*(n_wires-1)/2)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean (float): mean of normal distribution\n            std (float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    n_if = n_wires * (n_wires - 1) // 2\n    theta = np.random.normal(loc=mean, scale=std, size=(n_layers, n_if))\n    return theta\n\n\ndef cvqnn_layers_phi_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``phi`` input to the interferometers of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires*(n_wires-1)/2)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    n_if = n_wires * (n_wires - 1) // 2\n    phi = np.random.uniform(low=low, high=high, size=(n_layers, n_if))\n    return phi\n\n\ndef cvqnn_layers_phi_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``phi`` input to the interferometers of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the array is ``(n_layers, n_wires*(n_wires-1)/2)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean (float): mean of normal distribution\n            std (float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    n_if = n_wires * (n_wires - 1) // 2\n    phi = np.random.normal(loc=mean, scale=std, size=(n_layers, n_if))\n    return phi\n\n\ndef cvqnn_layers_varphi_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``varphi`` input to the interferometers of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    varphi = np.random.uniform(low=low, high=high, size=(n_layers, n_wires))\n    return varphi\n\n\ndef cvqnn_layers_varphi_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``varphi`` input to the interferometers of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean(float): mean of normal distribution\n            std(float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    varphi = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires))\n    return varphi\n\n\ndef cvqnn_layers_r_uniform(n_layers, n_wires, low=0, high=0.1, seed=None):\n    r""""""Creates a parameter array for the squeezing amplitude ``r`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    r = np.random.uniform(low=low, high=high, size=(n_layers, n_wires))\n    return r\n\n\ndef cvqnn_layers_r_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the squeezing amplitude ``r`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean(float): mean of normal distribution\n            std(float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    r = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires))\n    return r\n\n\ndef cvqnn_layers_phi_r_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the squeezing phase ``phi_r`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    phi_r = np.random.uniform(low=low, high=high, size=(n_layers, n_wires))\n    return phi_r\n\n\ndef cvqnn_layers_phi_r_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the squeezing phase ``phi_r`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean(float): mean of normal distribution\n            std(float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    phi_r = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires))\n    return phi_r\n\n\ndef cvqnn_layers_a_uniform(n_layers, n_wires, low=0, high=0.1, seed=None):\n    r""""""Creates a parameter array for the displacement amplitude ``a`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    a = np.random.uniform(low=low, high=high, size=(n_layers, n_wires))\n    return a\n\n\ndef cvqnn_layers_a_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the displacement amplitude ``a`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean(float): mean of normal distribution\n            std(float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    a = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires))\n    return a\n\n\ndef cvqnn_layers_phi_a_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the displacement phase ``phi_a`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    phi_a = np.random.uniform(low=low, high=high, size=(n_layers, n_wires))\n    return phi_a\n\n\ndef cvqnn_layers_phi_a_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the displacement phase ``phi_a`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean(float): mean of normal distribution\n            std(float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    phi_a = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires))\n    return phi_a\n\n\ndef cvqnn_layers_kappa_uniform(n_layers, n_wires, low=0, high=0.1, seed=None):\n    r""""""Creates a parameter array for the kerr parameter ``kappa`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a uniform distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            low (float): minimum value of uniform distribution\n            high (float): maximum value of uniform distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    kappa = np.random.uniform(low=low, high=high, size=(n_layers, n_wires))\n    return kappa\n\n\ndef cvqnn_layers_kappa_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the kerr parameter ``kappa`` of :func:`~.CVNeuralNetLayers`.\n\n        The parameters are drawn from a normal distribution.\n\n        The shape of the arrays is ``(n_layers, n_wires)``.\n\n        Args:\n            n_layers (int): number of layers of the CV Neural Net\n            n_wires (int): number of modes of the CV Neural Net\n\n        Keyword Args:\n            mean(float): mean of normal distribution\n            std(float): standard deviation of normal distribution\n            seed (int): seed used in sampling the parameters, makes function call deterministic\n\n        Returns:\n            array: parameter array\n        """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    kappa = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires))\n    return kappa\n\n\ndef interferometer_all(n_wires, seed=None):\n    r""""""Creates a list of arrays for the three initial parameters of :func:`Interferometer`, all drawn from a uniform\n    distribution with interval :math:`[0, 2\\pi]`.\n\n    * ``theta`` is the array of beamsplitter transmittivity angles, of size ``(n_wires*(n_wires-1)/2, )``\n\n    * ``phi`` is the array of beamsplitter phases, of size ``(n_wires*(n_wires-1)/2, )``\n\n    * ``varphi`` is the array of local angles for the final rotation gates, of size ``(n_wires, )``\n\n    Args:\n        n_wires (int): number of modes that the interferometer acts on\n\n    Keyword Args:\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        list of parameter arrays\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    kwargs = {""n_wires"": n_wires, ""seed"": seed}\n\n    theta = interferometer_theta_uniform(**kwargs)\n    phi = interferometer_phi_uniform(**kwargs)\n    varphi = interferometer_varphi_uniform(**kwargs)\n\n    return [theta, phi, varphi]\n\n\ndef interferometer_theta_uniform(n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``theta`` input of :func:`Interferometer`, drawn from a uniform\n    distribution.\n\n    The array has shape ``(n_wires*(n_wires-1)/2, )``.\n\n    Args:\n        n_wires (int): number of modes that the interferometer acts on\n\n    Keyword Args:\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n    n_if = n_wires * (n_wires - 1) // 2\n\n    theta = np.random.uniform(low=low, high=high, size=(n_if,))\n    return theta\n\n\ndef interferometer_phi_uniform(n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``phi`` input of :func:`Interferometer`, drawn from a uniform\n    distribution.\n\n    The array has shape ``(n_wires*(n_wires-1)/2, )``.\n\n    Args:\n        n_wires (int): number of modes that the interferometer acts on\n\n    Keyword Args:\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n    n_if = n_wires * (n_wires - 1) // 2\n\n    phi = np.random.uniform(low=low, high=high, size=(n_if,))\n    return phi\n\n\ndef interferometer_varphi_uniform(n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``varphi`` input of :func:`Interferometer`, drawn from a uniform\n    distribution.\n\n    The array has shape ``(n_wires, )``.\n\n    Args:\n        n_wires (int): number of modes that the interferometer acts on\n\n    Keyword Args:\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    varphi = np.random.uniform(low=low, high=high, size=(n_wires,))\n    return varphi\n\n\ndef interferometer_theta_normal(n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``theta`` input of :func:`Interferometer`, drawn from a normal\n    distribution.\n\n    The array has shape ``(n_wires*(n_wires-1)/2, )``.\n\n    Args:\n        n_wires (int): number of modes that the interferometer acts on\n\n    Keyword Args:\n        mean(float): mean of normal distribution\n        std(float): standard deviation of normal distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n    n_if = n_wires * (n_wires - 1) // 2\n\n    theta = np.random.normal(loc=mean, scale=std, size=(n_if,))\n    return theta\n\n\ndef interferometer_phi_normal(n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``phi`` input of :func:`Interferometer`, drawn from a normal\n    distribution.\n\n    The array has shape ``(n_wires*(n_wires-1)/2, )``.\n\n    Args:\n        n_wires (int): number of modes that the interferometer acts on\n\n    Keyword Args:\n        mean(float): mean of normal distribution\n        std(float): standard deviation of normal distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n    n_if = n_wires * (n_wires - 1) // 2\n\n    phi = np.random.normal(loc=mean, scale=std, size=(n_if,))\n    return phi\n\n\ndef interferometer_varphi_normal(n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``varphi`` input of :func:`Interferometer`, drawn from a normal\n    distribution.\n\n    The array has shape ``(n_wires, )``.\n\n    Args:\n        n_wires (int): number of modes that the interferometer acts on\n\n    Keyword Args:\n        mean(float): mean of normal distribution\n        std(float): standard deviation of normal distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    varphi = np.random.normal(loc=mean, scale=std, size=(n_wires,))\n    return varphi\n\n\ndef simplified_two_design_initial_layer_uniform(n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``initial_layer`` argument of :func:`~.SimplifiedTwoDesign`,\n    drawn from a uniform distribution.\n\n    The shape of the parameter array is ``(n_wires,)`` and each parameter is drawn uniformly at random \\\n    from between ``low`` and ``high``. The parameters define the Pauli-Y rotation angles\n    applied in the initial layer.\n\n    Args:\n        n_wires (int): number of qubits\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    params = np.random.uniform(low=low, high=high, size=(n_wires,))\n    return params\n\n\ndef simplified_two_design_initial_layer_normal(n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``initial_layer`` argument of :func:`~.SimplifiedTwoDesign`,\n    drawn from a uniform distribution.\n\n    The shape of the parameter array is ``(n_wires,)`` and each parameter is drawn\n    from a normal distribution with mean ``mean`` and standard deviation ``std``.\n    The parameters define the Pauli-Y rotation angles\n    applied in the initial layer.\n\n    Args:\n        n_wires (int): number of qubits\n        mean (float): mean of parameters\n        std (float): standard deviation of parameters\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    params = np.random.normal(loc=mean, scale=std, size=(n_wires,))\n    return params\n\n\ndef simplified_two_design_weights_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for the ``weights`` argument of :func:`~.SimplifiedTwoDesign`,\n    drawn from a uniform distribution.\n\n    The shape of the parameter array is ``(n_layers, n_wires - 1, 2)``\n    and each parameter is drawn uniformly at random \\\n    from between ``low`` and ``high``. The parameters define the Pauli-Y rotation angles\n    applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    n_unitaries_per_layer = n_wires - 1\n\n    if n_unitaries_per_layer in [0, -1]:\n        params = np.array([])\n    else:\n        params = np.random.uniform(low=low, high=high, size=(n_layers, n_unitaries_per_layer, 2))\n\n    return params\n\n\ndef simplified_two_design_weights_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for the ``weights`` argument of :func:`~.SimplifiedTwoDesign`,\n    drawn from a uniform distribution.\n\n    The shape of the parameter array is ``(n_layers, n_wires - 1, 2)``\n    and each parameter is drawn\n    from a normal distribution with mean ``mean`` and standard deviation ``std``.\n    The parameters define the Pauli-Y rotation angles\n    applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n        mean (float): mean of parameters\n        std (float): standard deviation of parameters\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    n_unitaries_per_layer = n_wires - 1\n\n    if n_unitaries_per_layer in [0, -1]:\n        params = np.array([])\n    else:\n        params = np.random.normal(loc=mean, scale=std, size=(n_layers, n_unitaries_per_layer, 2))\n\n    return params\n\n\ndef basic_entangler_layers_normal(n_layers, n_wires, mean=0, std=0.1, seed=None):\n    r""""""Creates a parameter array for :func:`~.BasicEntanglerLayers`, drawn from a normal\n    distribution.\n\n    The shape of the parameter array is ``(n_layers, n_wires)`` and each parameter is drawn\n    from a normal distribution with mean ``mean`` and standard deviation ``std``.\n    The parameters define the rotation angles applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n        mean (float): mean of parameters\n        std (float): standard deviation of parameters\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    params = np.random.normal(loc=mean, scale=std, size=(n_layers, n_wires))\n\n    return params\n\n\ndef basic_entangler_layers_uniform(n_layers, n_wires, low=0, high=2 * pi, seed=None):\n    r""""""Creates a parameter array for :func:`~.BasicEntanglerLayers`, drawn from a uniform\n    distribution.\n\n    The shape of the parameter array is ``(n_layers, n_wires)`` and each parameter is drawn uniformly at random\n    from between ``low`` and ``high``. The parameters define the rotation angles\n    applied in each layer.\n\n    Args:\n        n_layers (int): number of layers\n        n_wires (int): number of qubits\n        low (float): minimum value of uniform distribution\n        high (float): maximum value of uniform distribution\n        seed (int): seed used in sampling the parameters, makes function call deterministic\n\n    Returns:\n        array: parameter array\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    params = np.random.uniform(low=low, high=high, size=(n_layers, n_wires))\n\n    return params\n'"
pennylane/io.py,0,"b'# Copyright 2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains functions to load circuits from other frameworks as\nPennyLane templates.\n""""""\nfrom pkg_resources import iter_entry_points\n\n# get list of installed plugin converters\nplugin_converters = {entry.name: entry for entry in iter_entry_points(""pennylane.io"")}\n\n\ndef load(quantum_circuit_object, format: str):\n    """"""Load external quantum assembly and quantum circuits from supported frameworks\n    into PennyLane templates.\n\n    .. note::\n\n        For more details on which formats are supported\n        please consult the corresponding plugin documentation:\n        https://pennylane.ai/plugins.html\n\n    **Example:**\n\n    >>> qc = qiskit.QuantumCircuit(2)\n    >>> qc.rz(0.543, [0])\n    >>> qc.cx(0, 1)\n    >>> my_circuit = qml.load(qc, format=\'qiskit\')\n\n    The ``my_circuit`` template can now be used within QNodes, as a\n    two-wire quantum template.\n\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=1)\n    >>>     my_circuit(wires=(1, 0))\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        quantum_circuit_object: the quantum circuit that will be converted\n            to a PennyLane template\n        format (str): the format of the quantum circuit object to convert from\n\n    Returns:\n        function: the PennyLane template created from the quantum circuit\n        object\n    """"""\n\n    if format in plugin_converters:\n\n        # loads the plugin load function\n        plugin_converter = plugin_converters[format].load()\n\n        # calls the load function of the converter on the quantum circuit object\n        return plugin_converter(quantum_circuit_object)\n\n    raise ValueError(\n        ""Converter does not exist. Make sure the required plugin is installed ""\n        ""and supports conversion.""\n    )\n\n\ndef from_qiskit(quantum_circuit):\n    """"""Loads Qiskit QuantumCircuit objects by using the converter in the\n    PennyLane-Qiskit plugin.\n\n    **Example:**\n\n    >>> qc = qiskit.QuantumCircuit(2)\n    >>> qc.rz(0.543, [0])\n    >>> qc.cx(0, 1)\n    >>> my_circuit = qml.from_qiskit(qc)\n\n    The ``my_circuit`` template can now be used within QNodes, as a\n    two-wire quantum template.\n\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=1)\n    >>>     my_circuit(wires=(1, 0))\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        quantum_circuit (qiskit.QuantumCircuit): a quantum circuit created in qiskit\n\n    Returns:\n        function: the PennyLane template created based on the QuantumCircuit\n        object\n    """"""\n    return load(quantum_circuit, format=""qiskit"")\n\n\ndef from_qasm(quantum_circuit: str):\n    """"""Loads quantum circuits from a QASM string using the converter in the\n    PennyLane-Qiskit plugin.\n\n    **Example:**\n\n    .. code-block:: python\n\n        >>> hadamard_qasm = \'OPENQASM 2.0;\' \\\\\n        ...                 \'include ""qelib1.inc"";\' \\\\\n        ...                 \'qreg q[1];\' \\\\\n        ...                 \'h q[0];\'\n        >>> my_circuit = qml.from_qasm(hadamard_qasm)\n\n    The ``my_circuit`` template can now be used within QNodes, as a\n    two-wire quantum template.\n\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=1)\n    >>>     my_circuit(wires=(1, 0))\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        quantum_circuit (str): a QASM string containing a valid quantum circuit\n\n    Returns:\n        function: the PennyLane template created based on the QASM string\n    """"""\n    return load(quantum_circuit, format=""qasm"")\n\n\ndef from_qasm_file(qasm_filename: str):\n    """"""Loads quantum circuits from a QASM file using the converter in the\n    PennyLane-Qiskit plugin.\n\n    **Example:**\n\n    >>> my_circuit = qml.from_qasm(""hadamard_circuit.qasm"")\n\n    The ``my_circuit`` template can now be used within QNodes, as a\n    two-wire quantum template.\n\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=1)\n    >>>     my_circuit(wires=(1, 0))\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        qasm_filename (str): path to a QASM file containing a valid quantum circuit\n\n    Returns:\n        function: the PennyLane template created based on the QASM file\n    """"""\n    return load(qasm_filename, format=""qasm_file"")\n\n\ndef from_pyquil(pyquil_program):\n    """"""Loads pyQuil Program objects by using the converter in the\n    PennyLane-Forest plugin.\n\n    **Example:**\n\n    >>> program = pyquil.Program()\n    >>> program += pyquil.gates.H(0)\n    >>> program += pyquil.gates.CNOT(0, 1)\n    >>> my_circuit = qml.from_pyquil(program)\n\n    The ``my_circuit`` template can now be used within QNodes, as a\n    two-wire quantum template.\n\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=1)\n    >>>     my_circuit(wires=[1, 0])\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        pyquil_program (pyquil.Program): a program created in pyQuil\n\n    Returns:\n        pennylane_forest.ProgramLoader: a ``pennylane_forest.ProgramLoader`` instance that can\n        be used like a PennyLane template and that contains additional inspection properties\n    """"""\n    return load(pyquil_program, format=""pyquil_program"")\n\n\ndef from_quil(quil: str):\n    """"""Loads quantum circuits from a Quil string using the converter in the\n    PennyLane-Forest plugin.\n\n    **Example:**\n\n    .. code-block:: python\n\n        >>> quil_str = \'H 0\\\\n\'\n        ...            \'CNOT 0 1\'\n        >>> my_circuit = qml.from_quil(quil_str)\n\n    The ``my_circuit`` template can now be used within QNodes, as a\n    two-wire quantum template.\n\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=1)\n    >>>     my_circuit(wires=(1, 0))\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        quil (str): a Quil string containing a valid quantum circuit\n\n    Returns:\n        pennylane_forest.ProgramLoader: a ``pennylane_forest.ProgramLoader`` instance that can\n        be used like a PennyLane template and that contains additional inspection properties\n    """"""\n    return load(quil, format=""quil"")\n\n\ndef from_quil_file(quil_filename: str):\n    """"""Loads quantum circuits from a Quil file using the converter in the\n    PennyLane-Forest plugin.\n\n    **Example:**\n\n    >>> my_circuit = qml.from_quil_file(""teleportation.quil"")\n\n    The ``my_circuit`` template can now be used within QNodes, as a\n    two-wire quantum template.\n\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=1)\n    >>>     my_circuit(wires=(1, 0))\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        quil_filename (str): path to a Quil file containing a valid quantum circuit\n\n    Returns:\n        pennylane_forest.ProgramLoader: a ``pennylane_forest.ProgramLoader`` instance that can\n        be used like a PennyLane template and that contains additional inspection properties\n    """"""\n    return load(quil_filename, format=""quil_file"")\n'"
pennylane/measure.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# pylint: disable=protected-access\n""""""\nThis module contains the functions for computing different types of measurement\noutcomes from quantum observables - expectation values, variances of expectations,\nand measurement samples.\n""""""\nimport pennylane as qml\nfrom pennylane.operation import Observable, Sample, Variance, Expectation, Probability, Tensor\nfrom pennylane.qnodes import QuantumFunctionError\n\n\ndef expval(op):\n    r""""""Expectation value of the supplied observable.\n\n    **Example:**\n\n    .. code-block:: python3\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            qml.Hadamard(wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliY(0))\n\n    Executing this QNode:\n\n    >>> circuit(0.5)\n    -0.4794255386042029\n\n    Args:\n        op (Observable): a quantum observable object\n\n    Raises:\n        QuantumFunctionError: `op` is not an instance of :class:`~.Observable`\n    """"""\n    if not isinstance(op, Observable):\n        raise QuantumFunctionError(\n            ""{} is not an observable: cannot be used with expval"".format(op.name)\n        )\n\n    if isinstance(op, Tensor):\n        for o in op.obs:\n            qml.QueuingContext.remove_operator(o)\n    else:\n        qml.QueuingContext.remove_operator(op)\n\n    op.return_type = Expectation\n\n    qml.QueuingContext.append_operator(op)\n\n    return op\n\n\ndef var(op):\n    r""""""Variance of the supplied observable.\n\n    **Example:**\n\n    .. code-block:: python3\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            qml.Hadamard(wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.var(qml.PauliY(0))\n\n    Executing this QNode:\n\n    >>> circuit(0.5)\n    0.7701511529340698\n\n    Args:\n        op (Observable): a quantum observable object\n\n    Raises:\n        QuantumFunctionError: `op` is not an instance of :class:`~.Observable`\n    """"""\n    if not isinstance(op, Observable):\n        raise QuantumFunctionError(\n            ""{} is not an observable: cannot be used with var"".format(op.name)\n        )\n\n    if isinstance(op, Tensor):\n        for o in op.obs:\n            qml.QueuingContext.remove_operator(o)\n    else:\n        qml.QueuingContext.remove_operator(op)\n\n    op.return_type = Variance\n\n    qml.QueuingContext.append_operator(op)\n\n    return op\n\n\ndef sample(op):\n    r""""""Sample from the supplied observable, with the number of shots\n    determined from the ``dev.shots`` attribute of the corresponding device.\n\n    **Example:**\n\n    .. code-block:: python3\n\n        dev = qml.device(""default.qubit"", wires=2, shots=4)\n\n        @qml.qnode(dev)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            qml.Hadamard(wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.sample(qml.PauliY(0))\n\n    Executing this QNode:\n\n    >>> circuit(0.5)\n    array([ 1.,  1.,  1., -1.])\n\n    Args:\n        op (Observable): a quantum observable object\n\n    Raises:\n        QuantumFunctionError: `op` is not an instance of :class:`~.Observable`\n    """"""\n    if not isinstance(op, Observable):\n        raise QuantumFunctionError(\n            ""{} is not an observable: cannot be used with sample"".format(op.name)\n        )\n\n    if isinstance(op, Tensor):\n        for o in op.obs:\n            qml.QueuingContext.remove_operator(o)\n    else:\n        qml.QueuingContext.remove_operator(op)\n\n    op.return_type = Sample\n\n    qml.QueuingContext.append_operator(op)\n\n    return op\n\n\ndef probs(wires):\n    r""""""Probability of each computational basis state.\n\n    This measurement function accepts no observables, and instead\n    instructs the QNode to return a flat array containing the\n    probabilities of each quantum state.\n\n    Marginal probabilities may also be requested by restricting\n    the wires to a subset of the full system; the size of the\n    returned array will be ``[2**len(wires)]``.\n\n    **Example:**\n\n    .. code-block:: python3\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.Hadamard(wires=1)\n            return qml.probs(wires=[0, 1])\n\n    Executing this QNode:\n\n    >>> circuit()\n    array([0.5, 0.5, 0. , 0. ])\n\n    The returned array is in lexicographic order, so corresponds\n    to a :math:`50\\%` chance of measuring either :math:`|00\\rangle`\n    or :math:`|01\\rangle`.\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    # pylint: disable=protected-access\n    op = qml.Identity(wires=wires, do_queue=False)\n    op.return_type = Probability\n\n    qml.QueuingContext.append_operator(op)\n\n    return op\n'"
pennylane/operation.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# pylint: disable=protected-access\nr""""""\nThis module contains the abstract base classes for defining PennyLane\noperations and observables.\n\nDescription\n-----------\n\nQubit Operations\n~~~~~~~~~~~~~~~~\nThe :class:`Operator` class serves as a base class for operators,\nand is inherited by both the :class:`Observable` class and the\n:class:`Operation` class. These classes are subclassed to implement quantum operations\nand measure observables in PennyLane.\n\n* Each :class:`~.Operator` subclass represents a general type of\n  map between physical states. Each instance of these subclasses\n  represents either\n\n  - an application of the operator or\n  - an instruction to measure and return the respective result.\n\n  Operators act on a sequence of wires (subsystems) using given parameter values.\n\n* Each :class:`~.Operation` subclass represents a type of quantum operation,\n  for example a unitary quantum gate. Each instance of these subclasses\n  represents an application of the operation with given parameter values to\n  a given sequence of wires (subsystems).\n\n* Each  :class:`~.Observable` subclass represents a type of physical observable.\n  Each instance of these subclasses represents an instruction to measure and\n  return the respective result for the given parameter values on a\n  sequence of wires (subsystems).\n\nDifferentiation\n^^^^^^^^^^^^^^^\n\nIn general, an :class:`Operation` is differentiable (at least using the finite-difference\nmethod) with respect to a parameter iff\n\n* the domain of that parameter is continuous.\n\nFor an :class:`Operation` to be differentiable with respect to a parameter using the\nanalytic method of differentiation, it must satisfy an additional constraint:\n\n* the parameter domain must be real.\n\n.. note::\n\n    These conditions are *not* sufficient for analytic differentiation. For example,\n    CV gates must also define a matrix representing their Heisenberg linear\n    transformation on the quadrature operators.\n\nFor gates that *are* supported via the analytic method, the gradient recipe\n(with multiplier :math:`c_k`, parameter shift :math:`s_k` for parameter :math:`\\phi_k`)\nworks as follows:\n\n.. math:: \\frac{\\partial}{\\partial\\phi_k}O = c_k\\left[O(\\phi_k+s_k)-O(\\phi_k-s_k)\\right].\n\nCV Operation base classes\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDue to additional requirements, continuous-variable (CV) operations must subclass the\n:class:`~.CVOperation` or :class:`~.CVObservable` classes instead of :class:`~.Operation`\nand :class:`~.Observable`.\n\nDifferentiation\n^^^^^^^^^^^^^^^\n\nTo enable gradient computation using the analytic method for Gaussian CV operations, in addition, you need to\nprovide the static class method :meth:`~.CV._heisenberg_rep` that returns the Heisenberg representation of\nthe operation given its list of parameters, namely:\n\n* For Gaussian CV Operations this method should return the matrix of the linear transformation carried out by the\n  operation on the vector of quadrature operators :math:`\\mathbf{r}` for the given parameter\n  values.\n\n* For Gaussian CV Observables this method should return a real vector (first-order observables)\n  or symmetric matrix (second-order observables) of coefficients of the quadrature\n  operators :math:`\\x` and :math:`\\p`.\n\nPennyLane uses the convention :math:`\\mathbf{r} = (\\I, \\x, \\p)` for single-mode operations and observables\nand :math:`\\mathbf{r} = (\\I, \\x_0, \\p_0, \\x_1, \\p_1, \\ldots)` for multi-mode operations and observables.\n\n.. note::\n    Non-Gaussian CV operations and observables are currently only supported via\n    the finite-difference method of gradient computation.\n""""""\nimport abc\nimport itertools\nimport functools\nimport numbers\nfrom collections.abc import Sequence\nfrom enum import Enum, IntEnum\nfrom pennylane.wires import Wires\n\nimport numpy as np\nfrom numpy.linalg import multi_dot\n\nimport pennylane as qml\n\nfrom .utils import _flatten, pauli_eigs\nfrom .variable import Variable\n\n# =============================================================================\n# Wire types\n# =============================================================================\n\n\nclass ActsOn(IntEnum):\n    """"""Integer enumeration class\n    to represent the number of wires\n    an operation acts on""""""\n\n    AnyWires = -1\n    AllWires = 0\n\n\nAllWires = ActsOn.AllWires\n""""""IntEnum: An enumeration which represents all wires in the\nsubsystem. It is equivalent to an integer with value 0.""""""\n\nAnyWires = ActsOn.AnyWires\n""""""IntEnum: An enumeration which represents any wires in the\nsubsystem. It is equivalent to an integer with value -1.""""""\n\n\n# =============================================================================\n# ObservableReturnTypes types\n# =============================================================================\n\n\nclass ObservableReturnTypes(Enum):\n    """"""Enumeration class to represent the return types of an observable.""""""\n\n    Sample = ""sample""\n    Variance = ""var""\n    Expectation = ""expval""\n    Probability = ""probs""\n\n    def __repr__(self):\n        """"""String representation of the return types.""""""\n        return str(self.value)\n\n\nSample = ObservableReturnTypes.Sample\n""""""Enum: An enumeration which represents sampling an observable.""""""\n\nVariance = ObservableReturnTypes.Variance\n""""""Enum: An enumeration which represents returning the variance of\nan observable on specified wires.""""""\n\nExpectation = ObservableReturnTypes.Expectation\n""""""Enum: An enumeration which represents returning the expectation\nvalue of an observable on specified wires.""""""\n\nProbability = ObservableReturnTypes.Probability\n""""""Enum: An enumeration which represents returning probabilities\nof all computational basis states.""""""\n\n\n# =============================================================================\n# Class property\n# =============================================================================\n\n\nclass ClassPropertyDescriptor:  # pragma: no cover\n    """"""Allows a class property to be defined""""""\n\n    # pylint: disable=too-few-public-methods\n    def __init__(self, fget, fset=None):\n        self.fget = fget\n        self.fset = fset\n\n    def __get__(self, obj, klass=None):\n        if klass is None:\n            klass = type(obj)\n        return self.fget.__get__(obj, klass)()\n\n    def __set__(self, obj, value):\n        if not self.fset:\n            raise AttributeError(""can\'t set attribute"")\n        type_ = type(obj)\n        return self.fset.__get__(obj, type_)(value)\n\n    def setter(self, func):\n        """"""Set the function as a class method, and store as an attribute.""""""\n        if not isinstance(func, (classmethod, staticmethod)):\n            func = classmethod(func)\n        self.fset = func\n        return self\n\n\ndef classproperty(func):\n    """"""The class property decorator""""""\n    if not isinstance(func, (classmethod, staticmethod)):\n        func = classmethod(func)\n\n    return ClassPropertyDescriptor(func)\n\n\n# =============================================================================\n# Base Operator class\n# =============================================================================\n\n\nclass Operator(abc.ABC):\n    r""""""Base class for quantum operators supported by a device.\n\n    The following class attributes must be defined for all Operators:\n\n    * :attr:`~.Operator.num_params`\n    * :attr:`~.Operator.num_wires`\n    * :attr:`~.Operator.par_domain`\n\n    Args:\n        params (tuple[float, int, array, Variable]): operator parameters\n\n    Keyword Args:\n        wires (Iterable, Number, str, Wires): Iterable containing representations of the wires that the operator acts\n            on, or Wires object. If not given, args[-1] is interpreted as wires.\n        do_queue (bool): Indicates whether the operator should be\n            immediately pushed into the Operator queue.\n    """"""\n    do_check_domain = True  #: bool: flag: should we perform a domain check for the parameters?\n\n    @classmethod\n    def _matrix(cls, *params):\n        """"""Matrix representation of the operator\n        in the computational basis.\n\n        This is a *class method* that should be defined for all\n        new operations and observables, that returns the matrix representing\n        the operator in the computational basis.\n\n        This private method allows matrices to be computed\n        directly without instantiating the operators first.\n\n        To return the matrices of *instantiated* operators,\n        please use the :attr:`~.Operator.matrix` property instead.\n\n        **Example:**\n\n        >>> qml.RY._matrix(0.5)\n        >>> array([[ 0.96891242+0.j, -0.24740396+0.j],\n                   [ 0.24740396+0.j,  0.96891242+0.j]])\n\n        Returns:\n            array: matrix representation\n        """"""\n        raise NotImplementedError\n\n    @property\n    def matrix(self):\n        r""""""Matrix representation of an instantiated operator\n        in the computational basis.\n\n        **Example:**\n\n        >>> U = qml.RY(0.5, wires=1)\n        >>> U.matrix\n        >>> array([[ 0.96891242+0.j, -0.24740396+0.j],\n                   [ 0.24740396+0.j,  0.96891242+0.j]])\n\n        Returns:\n            array: matrix representation\n        """"""\n        return self._matrix(*self.parameters)\n\n    @classmethod\n    def _eigvals(cls, *params):\n        """"""Eigenvalues of the operator.\n\n        This is a *class method* that should be defined for all\n        new operations and observables that returns the eigenvalues\n        of the operator. Note that the eigenvalues are not guaranteed\n        to be in any particular order.\n\n        This private method allows eigenvalues to be computed\n        directly without instantiating the operators first.\n\n        The default implementation relies on the presence of the\n        :attr:`_matrix` method.\n\n        To return the eigenvalues of *instantiated* operators,\n        please use the :attr:`~.Operator.eigvals` property instead.\n\n        **Example:**\n\n        >>> qml.RZ._eigvals(0.5)\n        >>> array([0.96891242-0.24740396j, 0.96891242+0.24740396j])\n\n        Returns:\n            array: eigenvalue representation\n        """"""\n        return np.linalg.eigvals(cls._matrix(*params))\n\n    @property\n    def eigvals(self):\n        r""""""Eigenvalues of an instantiated operator.\n\n        Note that the eigenvalues are not guaranteed to be in any\n        particular order.\n\n        **Example:**\n\n        >>> U = qml.RZ(0.5, wires=1)\n        >>> U.eigvals\n        >>> array([0.96891242-0.24740396j, 0.96891242+0.24740396j])\n\n        Returns:\n            array: eigvals representation\n        """"""\n        return self._eigvals(*self.parameters)\n\n    @property\n    @abc.abstractmethod\n    def num_params(self):\n        """"""Number of parameters the operator takes.""""""\n\n    @property\n    @abc.abstractmethod\n    def num_wires(self):\n        """"""Number of wires the operator acts on.""""""\n\n    @property\n    @abc.abstractmethod\n    def par_domain(self):\n        """"""Domain of the gate parameters.\n\n        * ``\'N\'``: natural numbers (including zero).\n        * ``\'R\'``: floats.\n        * ``\'A\'``: arrays of real or complex values.\n        * ``None``: if there are no parameters.\n        """"""\n\n    @property\n    def name(self):\n        """"""String for the name of the operator.\n        """"""\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        self._name = value\n\n    def __init__(self, *params, wires=None, do_queue=True):\n        # pylint: disable=too-many-branches\n        self._name = self.__class__.__name__  #: str: name of the operator\n        self.queue_idx = None  #: int, None: index of the Operator in the circuit queue, or None if not in a queue\n\n        if wires is None:\n            raise ValueError(""Must specify the wires that {} acts on"".format(self.name))\n\n        # turn wires into Wires object\n        self._wires = Wires(wires)  #: Wires: wires on which the operator acts\n\n        # check that the number of wires given corresponds to required number\n        if (\n            self.num_wires != AllWires\n            and self.num_wires != AnyWires\n            and len(self._wires) != self.num_wires\n        ):\n            raise ValueError(\n                ""{}: wrong number of wires. ""\n                ""{} wires given, {} expected."".format(self.name, len(self._wires), self.num_wires)\n            )\n\n        if len(params) != self.num_params:\n            raise ValueError(\n                ""{}: wrong number of parameters. ""\n                ""{} parameters passed, {} expected."".format(self.name, len(params), self.num_params)\n            )\n\n        # check the validity of the params\n        if self.do_check_domain:\n            for p in params:\n                self.check_domain(p)\n        self.params = list(params)  #: list[Any]: parameters of the operator\n\n        if do_queue:\n            self.queue()\n\n    def __str__(self):\n        """"""Operator name and some information.""""""\n        return ""{}: {} params, wires {}"".format(self.name, len(self.params), self.wires.tolist())\n\n    def __repr__(self):\n        """"""Constructor-call-like representation.""""""\n        # FIXME using self.parameters here instead of self.params is dangerous, it assumes the params can be evaluated\n        # which is only true if something suitable happens to remain in VariableRef.positional_arg_values etc. after\n        # the last evaluation.\n        if self.parameters:\n            params = "", "".join([repr(p) for p in self.parameters])\n            return ""{}({}, wires={})"".format(self.name, params, self.wires.tolist())\n        return ""{}(wires={})"".format(self.name, self.wires.tolist())\n\n    def check_domain(self, p, flattened=False):\n        """"""Check the validity of a parameter.\n\n        :class:`.Variable` instances can represent any real scalars (but not arrays).\n\n        Args:\n            p (Number, array, Variable): parameter to check\n            flattened (bool): True means p is an element of a flattened parameter\n                sequence (affects the handling of \'A\' parameters)\n        Raises:\n            TypeError: parameter is not an element of the expected domain\n            ValueError: parameter is an element of an unknown domain\n        Returns:\n            Number, array, Variable: p\n        """"""\n        # pylint: disable=too-many-branches\n        # If parameter is a NumPy scalar, convert it into a Python scalar.\n        if isinstance(p, np.ndarray) and p.ndim == 0:\n            p = p.item()\n\n        if isinstance(p, Variable):\n            if self.par_domain == ""A"":\n                raise TypeError(\n                    ""{}: Array parameter expected, got a Variable, ""\n                    ""which can only represent real scalars."".format(self.name)\n                )\n            return p\n\n        # p is not a Variable\n        if self.par_domain == ""A"":\n            if flattened:\n                if isinstance(p, np.ndarray):\n                    raise TypeError(\n                        ""{}: Flattened array parameter expected, got {}."".format(self.name, type(p))\n                    )\n            else:\n                if not isinstance(p, np.ndarray):\n                    raise TypeError(\n                        ""{}: Array parameter expected, got {}."".format(self.name, type(p))\n                    )\n        elif self.par_domain in (""R"", ""N""):\n            if not isinstance(p, numbers.Real):\n                raise TypeError(\n                    ""{}: Real scalar parameter expected, got {}."".format(self.name, type(p))\n                )\n\n            if self.par_domain == ""N"":\n                if not isinstance(p, numbers.Integral):\n                    raise TypeError(\n                        ""{}: Natural number parameter expected, got {}."".format(self.name, type(p))\n                    )\n                if p < 0:\n                    raise TypeError(\n                        ""{}: Natural number parameter expected, got {}."".format(self.name, p)\n                    )\n        else:\n            raise ValueError(\n                ""{}: Unknown parameter domain \'{}\'."".format(self.name, self.par_domain)\n            )\n        return p\n\n    @property\n    def wires(self):\n        """"""Wires of this operator.\n\n        Returns:\n            Wires: wires\n        """"""\n        return self._wires\n\n    @property\n    def parameters(self):\n        """"""Current parameter values.\n\n        Fixed parameters are returned as is, free parameters represented by\n        :class:`.Variable` instances are replaced by their\n        current numerical value.\n\n        Returns:\n            list[Any]: parameter values\n        """"""\n        # TODO profiling\n        def evaluate(p):\n            """"""Evaluate a single parameter.""""""\n            if isinstance(p, np.ndarray):\n                # object arrays may have Variables inside them\n                if p.dtype == object:\n                    temp = np.array([x.val if isinstance(x, Variable) else x for x in p.flat])\n                    return temp.reshape(p.shape)\n                return p\n            if isinstance(p, Variable):\n                p = self.check_domain(p.val)\n            return p\n\n        return [evaluate(p) for p in self.params]\n\n    def queue(self):\n        """"""Append the operator to the Operator queue.""""""\n        qml.QueuingContext.append_operator(self)\n\n        return self  # so pre-constructed Observable instances can be queued and returned in a single statement\n\n\n# =============================================================================\n# Base Operation class\n# =============================================================================\n\n\nclass Operation(Operator):\n    r""""""Base class for quantum operations supported by a device.\n\n    As with :class:`~.Operator`, the following class attributes must be\n    defined for all operations:\n\n    * :attr:`~.Operator.num_params`\n    * :attr:`~.Operator.num_wires`\n    * :attr:`~.Operator.par_domain`\n\n    The following two class attributes are optional, but in most cases\n    should be clearly defined to avoid unexpected behavior during\n    differentiation.\n\n    * :attr:`~.Operation.grad_method`\n    * :attr:`~.Operation.grad_recipe`\n\n    Finally, there are some additional optional class attributes\n    that may be set, and used by certain quantum optimizers:\n\n    * :attr:`~.Operation.generator`\n\n    Args:\n        params (tuple[float, int, array, Variable]): operation parameters\n\n    Keyword Args:\n        wires (Sequence[int]): Subsystems it acts on. If not given, args[-1]\n            is interpreted as wires.\n        do_queue (bool): Indicates whether the operation should be\n            immediately pushed into a :class:`BaseQNode` circuit queue.\n            This flag is useful if there is some reason to run an Operation\n            outside of a BaseQNode context.\n    """"""\n    # pylint: disable=abstract-method\n    string_for_inverse = "".inv""\n\n    @property\n    def grad_method(self):\n        """"""Gradient computation method.\n\n        * ``\'A\'``: analytic differentiation using the parameter-shift method.\n        * ``\'F\'``: finite difference numerical differentiation.\n        * ``None``: the operation may not be differentiated.\n\n        Default is ``\'F\'``, or ``None`` if the Operation has zero parameters.\n        """"""\n        return None if self.num_params == 0 else ""F""\n\n    grad_recipe = None\n    r""""""list[tuple[float]] or None: Gradient recipe for the parameter-shift method.\n\n        This is a list with one tuple per operation parameter. For parameter\n        :math:`k`, the tuple is of the form :math:`(c_k, s_k)`, resulting in\n        a gradient recipe of\n\n        .. math:: \\frac{\\partial}{\\partial\\phi_k}O = c_k\\left[O(\\phi_k+s_k)-O(\\phi_k-s_k)\\right].\n\n        If ``None``, the default gradient recipe\n        :math:`(c_k, s_k)=(1/2, \\pi/2)` is assumed for every parameter.\n    """"""\n\n    def get_parameter_shift(self, idx):\n        """"""Multiplier and shift for the given parameter, based on its gradient recipe.\n\n        Args:\n            idx (int): parameter index\n\n        Returns:\n            float, float: multiplier, shift\n        """"""\n        # get the gradient recipe for this parameter\n        recipe = self.grad_recipe[idx]\n        multiplier, shift = (0.5, np.pi / 2) if recipe is None else recipe\n\n        # internal multiplier in the Variable\n        var_mult = self.params[idx].mult\n\n        multiplier *= var_mult\n        if var_mult != 0:\n            # zero multiplier means the shift is unimportant\n            shift /= var_mult\n        return multiplier, shift\n\n    @property\n    def generator(self):\n        r""""""Generator of the operation.\n\n        A length-2 list ``[generator, scaling_factor]``, where\n\n        * ``generator`` is an existing PennyLane\n          operation class or :math:`2\\times 2` Hermitian array\n          that acts as the generator of the current operation\n\n        * ``scaling_factor`` represents a scaling factor applied\n          to the generator operation\n\n        For example, if :math:`U(\\theta)=e^{i0.7\\theta \\sigma_x}`, then\n        :math:`\\sigma_x`, with scaling factor :math:`s`, is the generator\n        of operator :math:`U(\\theta)`:\n\n        .. code-block:: python\n\n            generator = [PauliX, 0.7]\n\n        Default is ``[None, 1]``, indicating the operation has no generator.\n        """"""\n        return [None, 1]\n\n    @property\n    def inverse(self):\n        """"""Boolean determining if the inverse of the operation was requested.\n        """"""\n        return self._inverse\n\n    @inverse.setter\n    def inverse(self, boolean):\n        self._inverse = boolean\n\n    @staticmethod\n    def decomposition(*params, wires):\n        """"""Returns a template decomposing the operation into other\n        quantum operations.""""""\n        raise NotImplementedError\n\n    def inv(self):\n        """"""Inverts the operation, such that the inverse will\n        be used for the computations by the specific device.\n\n        This method concatenates a string to the name of the operation,\n        to indicate that the inverse will be used for computations.\n\n        Any subsequent call of this method will toggle between the original\n        operation and the inverse of the operation.\n\n        Returns:\n            :class:`Operator`: operation to be inverted\n        """"""\n        self.inverse = not self._inverse\n        return self\n\n    @property\n    def matrix(self):\n        op_matrix = self._matrix(*self.parameters)\n\n        if self.inverse:\n            return op_matrix.conj().T\n\n        return op_matrix\n\n    @property\n    def eigvals(self):\n        op_eigvals = self._eigvals(*self.parameters)\n\n        if self.inverse:\n            return op_eigvals.conj()\n\n        return op_eigvals\n\n    @property\n    def base_name(self):\n        """"""Get base name of the operator.\n        """"""\n        return self.__class__.__name__\n\n    @property\n    def name(self):\n        """"""Get and set the name of the operator.\n        """"""\n        return self._name + Operation.string_for_inverse if self.inverse else self._name\n\n    def __init__(self, *params, wires=None, do_queue=True):\n\n        self._inverse = False\n\n        # check the grad_method validity\n        if self.par_domain == ""N"":\n            assert (\n                self.grad_method is None\n            ), ""An operation may only be differentiated with respect to real scalar parameters.""\n        elif self.par_domain == ""A"":\n            assert self.grad_method in (\n                None,\n                ""F"",\n            ), ""Operations that depend on arrays containing free variables may only be differentiated using the F method.""\n\n        # check the grad_recipe validity\n        if self.grad_method == ""A"":\n            if self.grad_recipe is None:\n                # default recipe for every parameter\n                self.grad_recipe = [None] * self.num_params\n            else:\n                assert (\n                    len(self.grad_recipe) == self.num_params\n                ), ""Gradient recipe must have one entry for each parameter!""\n        else:\n            assert self.grad_recipe is None, ""Gradient recipe is only used by the A method!""\n\n        super().__init__(*params, wires=wires, do_queue=do_queue)\n\n\nclass DiagonalOperation(Operation):\n    r""""""Base class for diagonal quantum operations supported by a device.\n\n    As with :class:`~.Operation`, the following class attributes must be\n    defined for all operations:\n\n    * :attr:`~.Operator.num_params`\n    * :attr:`~.Operator.num_wires`\n    * :attr:`~.Operator.par_domain`\n\n    The following two class attributes are optional, but in most cases\n    should be clearly defined to avoid unexpected behavior during\n    differentiation.\n\n    * :attr:`~.Operation.grad_method`\n    * :attr:`~.Operation.grad_recipe`\n\n    Finally, there are some additional optional class attributes\n    that may be set, and used by certain quantum optimizers:\n\n    * :attr:`~.Operation.generator`\n\n    Args:\n        params (tuple[float, int, array, Variable]): operation parameters\n\n    Keyword Args:\n        wires (Sequence[int]): Subsystems it acts on. If not given, args[-1]\n            is interpreted as wires.\n        do_queue (bool): Indicates whether the operation should be\n            immediately pushed into a :class:`BaseQNode` circuit queue.\n            This flag is useful if there is some reason to run an Operation\n            outside of a BaseQNode context.\n    """"""\n    # pylint: disable=abstract-method\n\n    @classmethod\n    def _eigvals(cls, *params):\n        """"""Eigenvalues of the operator.\n\n        The order of the eigenvalues needs to match the order of\n        the computational basis vectors.\n\n        This is a *class method* that must be defined for all\n        new diagonal operations, that returns the eigenvalues\n        of the operator in the computational basis.\n\n        This private method allows eigenvalues to be computed\n        directly without instantiating the operators first.\n\n        To return the eigenvalues of *instantiated* operators,\n        please use the :attr:`~.Operator.eigvals` property instead.\n\n        **Example:**\n\n        >>> qml.RZ._eigvals(0.5)\n        >>> array([0.96891242-0.24740396j, 0.96891242+0.24740396j])\n\n        Returns:\n            array: eigenvalue representation\n        """"""\n        raise NotImplementedError\n\n    @property\n    def eigvals(self):\n        r""""""Eigenvalues of an instantiated diagonal operation.\n\n        The order of the eigenvalues needs to match the order of\n        the computational basis vectors.\n\n        **Example:**\n\n        >>> U = qml.RZ(0.5, wires=1)\n        >>> U.eigvals\n        >>> array([0.96891242-0.24740396j, 0.96891242+0.24740396j])\n\n        Returns:\n            array: eigvals representation\n        """"""\n        return super().eigvals\n\n    @classmethod\n    def _matrix(cls, *params):\n        return np.diag(cls._eigvals(*params))\n\n\n# =============================================================================\n# Base Observable class\n# =============================================================================\n\n\nclass Observable(Operator):\n    """"""Base class for observables supported by a device.\n\n    :class:`Observable` is used to describe Hermitian quantum observables.\n\n    As with :class:`~.Operator`, the following class attributes must be\n    defined for all observables:\n\n    * :attr:`~.Operator.num_params`\n    * :attr:`~.Operator.num_wires`\n    * :attr:`~.Operator.par_domain`\n\n    Args:\n        params (tuple[float, int, array, Variable]): observable parameters\n\n    Keyword Args:\n        wires (Sequence[int]): subsystems it acts on.\n            Currently, only one subsystem is supported.\n        do_queue (bool): Indicates whether the operation should be\n            immediately pushed into the Operator queue.\n    """"""\n\n    # pylint: disable=abstract-method\n    return_type = None\n\n    @classmethod\n    def _eigvals(cls, *params):\n        """"""Eigenvalues of the observable.\n\n        The order of the eigenvalues needs to match the order of\n        the computational basis vectors when the observable is\n        diagonalized using :attr:`diagonalizing_gates`.\n\n        This is a *class method* that must be defined for all\n        new diagonal operations, that returns the eigenvalues\n        of the operator in the computational basis.\n\n        This private method allows eigenvalues to be computed\n        directly without instantiating the operators first.\n\n        To return the eigenvalues of *instantiated* operators,\n        please use the :attr:`~.Operator.eigvals` property instead.\n\n        **Example:**\n\n        >>> qml.PauliZ._eigvals()\n        >>> array([1, -1])\n\n        Returns:\n            array: eigenvalue representation\n        """"""\n        raise NotImplementedError\n\n    @property\n    def eigvals(self):\n        r""""""Eigenvalues of an instantiated observable.\n\n        The order of the eigenvalues needs to match the order of\n        the computational basis vectors when the observable is\n        diagonalized using :attr:`diagonalizing_gates`. This is a requirement for using qubit observables in quantum functions.\n\n        **Example:**\n\n        >>> U = qml.PauliZ(wires=1)\n        >>> U.eigvals\n        >>> array([1, -1])\n\n        Returns:\n            array: eigvals representation\n        """"""\n        return super().eigvals\n\n    def __init__(self, *params, wires=None, do_queue=True):\n        # extract the arguments\n        if wires is None:\n            wires = params[-1]\n            params = params[:-1]\n\n        super().__init__(*params, wires=wires, do_queue=do_queue)\n\n    def __repr__(self):\n        """"""Constructor-call-like representation.""""""\n        temp = super().__repr__()\n\n        if self.return_type is None:\n            return temp\n\n        if self.return_type is Probability:\n            return repr(self.return_type) + ""(wires={})"".format(self.wires.tolist())\n\n        return repr(self.return_type) + ""("" + temp + "")""\n\n    def __matmul__(self, other):\n        if isinstance(other, Tensor):\n            return other.__rmatmul__(self)\n\n        if isinstance(other, Observable):\n            return Tensor(self, other)\n\n        raise ValueError(""Can only perform tensor products between observables."")\n\n    def diagonalizing_gates(self):\n        r""""""Returns the list of operations such that they\n        diagonalize the observable in the computational basis.\n\n        Returns:\n            list(qml.Operation): A list of gates that diagonalize\n            the observable in the computational basis.\n        """"""\n        raise NotImplementedError\n\n\nclass Tensor(Observable):\n    """"""Container class representing tensor products of observables.\n\n    To create a tensor, simply initiate it like so:\n\n    >>> T = Tensor(qml.PauliX(0), qml.Hermitian(A, [1, 2]))\n\n    You can also create a tensor from other Tensors:\n\n    >>> T = Tensor(T, qml.PauliZ(4))\n\n    The ``@`` symbol can be used as a tensor product operation:\n\n    >>> T = qml.PauliX(0) @ qml.Hadamard(2)\n    """"""\n\n    # pylint: disable=abstract-method\n    return_type = None\n    tensor = True\n    par_domain = None\n\n    def __init__(self, *args):  # pylint: disable=super-init-not-called\n\n        self._eigvals_cache = None\n        self.obs = []\n\n        for o in args:\n            if isinstance(o, Tensor):\n                self.obs.extend(o.obs)\n            elif isinstance(o, Observable):\n                self.obs.append(o)\n            else:\n                raise ValueError(""Can only perform tensor products between observables."")\n\n    def __str__(self):\n        """"""Print the tensor product and some information.""""""\n        return ""Tensor product {}: {} params, wires {}"".format(\n            [i.name for i in self.obs], len(self.params), self.wires\n        )\n\n    def __repr__(self):\n        """"""Constructor-call-like representation.""""""\n        return ""Tensor("" + "", "".join([repr(o) for o in self.obs]) + "")""\n\n    @property\n    def name(self):\n        """"""All constituent observable names making up the tensor product.\n\n        Returns:\n            list[str]: list containing all observable names\n        """"""\n        return [o.name for o in self.obs]\n\n    @property\n    def num_wires(self):\n        """"""Number of wires the tensor product acts on.\n\n        Returns:\n            int: number of wires\n        """"""\n        return len(self.wires)\n\n    @property\n    def wires(self):\n        """"""All wires in the system the tensor product acts on.\n\n        Returns:\n            Wires: wires addressed by the observables in the tensor product\n        """"""\n        return Wires([o.wires for o in self.obs])\n\n    @property\n    def params(self):\n        """"""Raw parameters of all constituent observables in the tensor product.\n\n        Returns:\n            list[Any]: flattened list containing all dependent parameters\n        """"""\n        return [p for sublist in [o.params for o in self.obs] for p in sublist]\n\n    @property\n    def num_params(self):\n        """"""Raw parameters of all constituent observables in the tensor product.\n\n        Returns:\n            list[Any]: flattened list containing all dependent parameters\n        """"""\n        return len(self.params)\n\n    @property\n    def parameters(self):\n        """"""Evaluated parameter values of all constituent observables in the tensor product.\n\n        Returns:\n            list[list[Any]]: nested list containing the parameters per observable\n            in the tensor product\n        """"""\n        return [o.parameters for o in self.obs]\n\n    @property\n    def non_identity_obs(self):\n        """"""Returns the non-identity observables contained in the tensor product.\n\n        Returns:\n            list[:class:`~.Observable`]: list containing the non-identity observables\n            in the tensor product\n        """"""\n        return [obs for obs in self.obs if not isinstance(obs, qml.Identity)]\n\n    def __matmul__(self, other):\n        if isinstance(other, Tensor):\n            self.obs.extend(other.obs)\n            return self\n\n        if isinstance(other, Observable):\n            self.obs.append(other)\n            return self\n\n        raise ValueError(""Can only perform tensor products between observables."")\n\n    def __rmatmul__(self, other):\n        if isinstance(other, Observable):\n            self.obs[:0] = [other]\n            return self\n\n        raise ValueError(""Can only perform tensor products between observables."")\n\n    __imatmul__ = __matmul__\n\n    @property\n    def eigvals(self):\n        """"""Return the eigenvalues of the specified tensor product observable.\n\n        This method uses pre-stored eigenvalues for standard observables where\n        possible.\n\n        Returns:\n            array[float]: array containing the eigenvalues of the tensor product\n            observable\n        """"""\n        if self._eigvals_cache is not None:\n            return self._eigvals_cache\n\n        standard_observables = {""PauliX"", ""PauliY"", ""PauliZ"", ""Hadamard""}\n\n        # observable should be Z^{\\otimes n}\n        self._eigvals_cache = pauli_eigs(len(self.wires))\n\n        # TODO: check for edge cases of the sorting, e.g. Tensor(Hermitian(obs, wires=[0, 2]),\n        # Hermitian(obs, wires=[1, 3, 4])\n        # Sorting the observables based on wires, so that the order of\n        # the eigenvalues is correct\n        obs_sorted = sorted(self.obs, key=lambda x: x.wires.tolist())\n\n        # check if there are any non-standard observables (such as Identity)\n        if set(self.name) - standard_observables:\n            # Tensor product of observables contains a mixture\n            # of standard and non-standard observables\n            self._eigvals_cache = np.array([1])\n            for k, g in itertools.groupby(obs_sorted, lambda x: x.name in standard_observables):\n                if k:\n                    # Subgroup g contains only standard observables.\n                    self._eigvals_cache = np.kron(self._eigvals_cache, pauli_eigs(len(list(g))))\n                else:\n                    # Subgroup g contains only non-standard observables.\n                    for ns_ob in g:\n                        # loop through all non-standard observables\n                        self._eigvals_cache = np.kron(self._eigvals_cache, ns_ob.eigvals)\n\n        return self._eigvals_cache\n\n    def diagonalizing_gates(self):\n        """"""Return the gate set that diagonalizes a circuit according to the\n        specified tensor observable.\n\n        This method uses pre-stored eigenvalues for standard observables where\n        possible and stores the corresponding eigenvectors from the eigendecomposition.\n\n        Returns:\n            list: list containing the gates diagonalizing the tensor observable\n        """"""\n        diag_gates = []\n        for o in self.obs:\n            diag_gates.extend(o.diagonalizing_gates())\n\n        return diag_gates\n\n    @property\n    def matrix(self):\n        r""""""Matrix representation of the tensor operator\n        in the computational basis.\n\n        **Example:**\n\n        Note that the returned matrix *only includes explicitly\n        declared observables* making up the tensor product;\n        that is, it only returns the matrix for the specified\n        subsystem it is defined for.\n\n        >>> O = qml.PauliZ(0) @ qml.PauliZ(2)\n        >>> O.matrix\n        array([[ 1,  0,  0,  0],\n               [ 0, -1,  0,  0],\n               [ 0,  0, -1,  0],\n               [ 0,  0,  0,  1]])\n\n        To get the full :math:`2^3\\times 2^3` Hermitian matrix\n        acting on the 3-qubit system, the identity on wire 1\n        must be explicitly included:\n\n        >>> O = qml.PauliZ(0) @ qml.Identity(1) @ qml.PauliZ(2)\n        >>> O.matrix\n        array([[ 1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n               [ 0., -1.,  0., -0.,  0., -0.,  0., -0.],\n               [ 0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.],\n               [ 0., -0.,  0., -1.,  0., -0.,  0., -0.],\n               [ 0.,  0.,  0.,  0., -1., -0., -0., -0.],\n               [ 0., -0.,  0., -0., -0.,  1., -0.,  0.],\n               [ 0.,  0.,  0.,  0., -0., -0., -1., -0.],\n               [ 0., -0.,  0., -0., -0.,  0., -0.,  1.]])\n\n        Returns:\n            array: matrix representation\n        """"""\n        # group the observables based on what wires they act on\n        U_list = []\n        for _, g in itertools.groupby(self.obs, lambda x: x.wires.tolist()):\n            # extract the matrices of each diagonalizing gate\n            mats = [i.matrix for i in g]\n\n            if len(mats) > 1:\n                # multiply all unitaries together before appending\n                mats = [multi_dot(mats)]\n\n            # append diagonalizing unitary for specific wire to U_list\n            U_list.append(mats[0])\n\n        # Return the Hermitian matrix representing the observable\n        # over the defined wires.\n        return functools.reduce(np.kron, U_list)\n\n    def prune(self):\n        """"""Returns a pruned tensor product of observables by removing :class:`~.Identity` instances from\n        the observables building up the :class:`~.Tensor`.\n\n        The ``return_type`` attribute is preserved while pruning.\n\n        If the tensor product only contains one observable, then this observable instance is\n        returned.\n\n        Note that, as a result, this method can return observables that are not a :class:`~.Tensor`\n        instance.\n\n        **Example:**\n\n        Pruning that returns a :class:`~.Tensor`:\n\n        >>> O = qml.PauliZ(0) @ qml.Identity(1) @ qml.PauliZ(2)\n        >>> O.prune()\n        <pennylane.operation.Tensor at 0x7fc1642d1590\n        >>> [(o.name, o.wires) for o in O.prune().obs]\n        [(\'PauliZ\', [0]), (\'PauliZ\', [2])]\n\n        Pruning that returns a single observable:\n\n        >>> O = qml.PauliZ(0) @ qml.Identity(1)\n        >>> O_pruned = O.prune()\n        >>> (O_pruned.name, O_pruned.wires)\n        (\'PauliZ\', [0])\n\n        Returns:\n            ~.Observable: the pruned tensor product of observables\n        """"""\n        if len(self.non_identity_obs) == 0:\n            # Return a single Identity as the tensor only contains Identities\n            obs = qml.Identity(0)\n        elif len(self.non_identity_obs) == 1:\n            obs = self.non_identity_obs[0]\n        else:\n            obs = Tensor(*self.non_identity_obs)\n\n        obs.return_type = self.return_type\n        return obs\n\n\n# =============================================================================\n# CV Operations and observables\n# =============================================================================\n\n\nclass CV:\n    """"""A mixin base class denoting a continuous-variable operation.""""""\n\n    # pylint: disable=no-member\n\n    def heisenberg_expand(self, U, num_wires):\n        """"""Expand the given local Heisenberg-picture array into a full-system one.\n\n        Args:\n            U (array[float]): array to expand (expected to be of the dimension ``1+2*self.num_wires``)\n            num_wires (int): total number of wires in the quantum circuit. If zero, return ``U`` as is.\n\n        Raises:\n            ValueError: if the size of the input matrix is invalid or `num_wires` is incorrect\n\n        Returns:\n            array[float]: expanded array, dimension ``1+2*num_wires``\n        """"""\n\n        # TODO: re-assess this function for non-consec wires\n        U_dim = len(U)\n        nw = len(self.wires)\n\n        if U.ndim > 2:\n            raise ValueError(""Only order-1 and order-2 arrays supported."")\n\n        if U_dim != 1 + 2 * nw:\n            raise ValueError(""{}: Heisenberg matrix is the wrong size {}."".format(self.name, U_dim))\n\n        if num_wires == 0 or self.wires.tolist() == list(range(num_wires)):\n            # no expansion necessary (U is a full-system matrix in the correct order)\n            return U\n\n        if num_wires < len(self.wires):\n            raise ValueError(\n                ""{}: Number of wires {} is too small to fit Heisenberg matrix"".format(\n                    self.name, num_wires\n                )\n            )\n\n        # expand U into the I, x_0, p_0, x_1, p_1, ... basis\n        dim = 1 + num_wires * 2\n\n        def loc(w):\n            ""Returns the slice denoting the location of (x_w, p_w) in the basis.""\n            ind = 2 * w + 1\n            return slice(ind, ind + 2)\n\n        if U.ndim == 1:\n            W = np.zeros(dim)\n            W[0] = U[0]\n            for k, w in enumerate(self.wires.tolist()):\n                W[loc(w)] = U[loc(k)]\n        elif U.ndim == 2:\n            if isinstance(self, Observable):\n                W = np.zeros((dim, dim))\n            else:\n                W = np.eye(dim)\n\n            W[0, 0] = U[0, 0]\n\n            for k1, w1 in enumerate(self.wires.tolist()):\n                s1 = loc(k1)\n                d1 = loc(w1)\n\n                # first column\n                W[d1, 0] = U[s1, 0]\n                # first row (for gates, the first row is always (1, 0, 0, ...), but not for observables!)\n                W[0, d1] = U[0, s1]\n\n                for k2, w2 in enumerate(self.wires.tolist()):\n                    W[d1, loc(w2)] = U[s1, loc(k2)]  # block k1, k2 in U goes to w1, w2 in W.\n        return W\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        r""""""Heisenberg picture representation of the operation.\n\n        * For Gaussian CV gates, this method returns the matrix of the linear\n          transformation carried out by the gate for the given parameter values.\n          The method is not defined for non-Gaussian gates.\n\n          **The existence of this method is equivalent to setting** ``grad_method = \'A\'``.\n\n        * For observables, returns a real vector (first-order observables) or\n          symmetric matrix (second-order observables) of expansion coefficients\n          of the observable.\n\n        For single-mode Operations we use the basis :math:`\\mathbf{r} = (\\I, \\x, \\p)`.\n        For multi-mode Operations we use the basis :math:`\\mathbf{r} = (\\I, \\x_0, \\p_0, \\x_1, \\p_1, \\ldots)`.\n\n        .. note::\n\n            For gates, we assume that the inverse transformation is obtained\n            by negating the first parameter.\n\n        Args:\n            p (Sequence[float]): parameter values for the transformation\n\n        Returns:\n            array[float]: :math:`\\tilde{U}` or :math:`q`\n        """"""\n        # pylint: disable=unused-argument\n        return None\n\n    @classproperty\n    def supports_heisenberg(self):\n        """"""Returns True iff the CV Operation has overridden the :meth:`~.CV._heisenberg_rep`\n        static method, thereby indicating that it is Gaussian and does not block the use\n        of the parameter-shift differentiation method if found between the differentiated gate\n        and an observable.\n        """"""\n        return CV._heisenberg_rep != self._heisenberg_rep\n\n\nclass CVOperation(CV, Operation):\n    """"""Base class for continuous-variable quantum operations.""""""\n\n    # pylint: disable=abstract-method\n\n    @classproperty\n    def supports_parameter_shift(self):\n        """"""Returns True iff the CV Operation supports the parameter-shift differentiation method.\n        This means that it has ``grad_method=\'A\'`` and\n        has overridden the :meth:`~.CV._heisenberg_rep` static method.\n        """"""\n        return self.grad_method == ""A"" and self.supports_heisenberg\n\n    def heisenberg_pd(self, idx):\n        """"""Partial derivative of the Heisenberg picture transform matrix.\n\n        Computed using grad_recipe.\n\n        Args:\n            idx (int): index of the parameter with respect to which the\n                partial derivative is computed.\n        Returns:\n            array[float]: partial derivative\n        """"""\n        # get the gradient recipe for this parameter\n        recipe = self.grad_recipe[idx]\n        multiplier = 0.5 if recipe is None else recipe[0]\n        shift = np.pi / 2 if recipe is None else recipe[1]\n\n        p = self.parameters\n        # evaluate the transform at the shifted parameter values\n        p[idx] += shift\n        U2 = self._heisenberg_rep(p)  # pylint: disable=assignment-from-none\n        p[idx] -= 2 * shift\n        U1 = self._heisenberg_rep(p)  # pylint: disable=assignment-from-none\n        return (U2 - U1) * multiplier  # partial derivative of the transformation\n\n    def heisenberg_tr(self, num_wires, inverse=False):\n        r""""""Heisenberg picture representation of the linear transformation carried\n        out by the gate at current parameter values.\n\n        Given a unitary quantum gate :math:`U`, we may consider its linear\n        transformation in the Heisenberg picture, :math:`U^\\dagger(\\cdot) U`.\n\n        If the gate is Gaussian, this linear transformation preserves the polynomial order\n        of any observables that are polynomials in :math:`\\mathbf{r} = (\\I, \\x_0, \\p_0, \\x_1, \\p_1, \\ldots)`.\n        This also means it maps :math:`\\text{span}(\\mathbf{r})` into itself:\n\n        .. math:: U^\\dagger \\mathbf{r}_i U = \\sum_j \\tilde{U}_{ij} \\mathbf{r}_j\n\n        For Gaussian CV gates, this method returns the transformation matrix for\n        the current parameter values of the Operation. The method is not defined\n        for non-Gaussian (and non-CV) gates.\n\n        Args:\n            num_wires (int): total number of wires in the quantum circuit\n            inverse  (bool): if True, return the inverse transformation instead\n\n        Raises:\n            RuntimeError: if the specified operation is not Gaussian or is missing the `_heisenberg_rep` method\n\n        Returns:\n            array[float]: :math:`\\tilde{U}`, the Heisenberg picture representation of the linear transformation\n        """"""\n        p = self.parameters\n        if inverse:\n            if self.par_domain == ""A"":\n                # TODO: expand this for the new par domain class, for non-unitary matrices.\n                p[0] = np.linalg.inv(p[0])\n            else:\n                p[0] = -p[0]  # negate first parameter\n        U = self._heisenberg_rep(p)  # pylint: disable=assignment-from-none\n\n        # not defined?\n        if U is None:\n            raise RuntimeError(\n                ""{} is not a Gaussian operation, or is missing the _heisenberg_rep method."".format(\n                    self.name\n                )\n            )\n\n        return self.heisenberg_expand(U, num_wires)\n\n\nclass CVObservable(CV, Observable):\n    r""""""Base class for continuous-variable observables.\n\n    The class attribute :attr:`~.ev_order` can be defined to indicate\n    to PennyLane whether the corresponding CV observable is a polynomial in the\n    quadrature operators. If so,\n\n    * ``ev_order = 1`` indicates a first order polynomial in quadrature\n      operators :math:`(\\x, \\p)`.\n\n    * ``ev_order = 2`` indicates a second order polynomial in quadrature\n      operators :math:`(\\x, \\p)`.\n\n    If :attr:`~.ev_order` is not ``None``, then the Heisenberg representation\n    of the observable should be defined in the static method :meth:`~.CV._heisenberg_rep`,\n    returning an array of the correct dimension.\n    """"""\n    # pylint: disable=abstract-method\n    ev_order = None  #: None, int: if not None, the observable is a polynomial of the given order in `(x, p)`.\n\n    def heisenberg_obs(self, num_wires):\n        r""""""Representation of the observable in the position/momentum operator basis.\n\n        Returns the expansion :math:`q` of the observable, :math:`Q`, in the\n        basis :math:`\\mathbf{r} = (\\I, \\x_0, \\p_0, \\x_1, \\p_1, \\ldots)`.\n\n        * For first-order observables returns a real vector such\n          that :math:`Q = \\sum_i q_i \\mathbf{r}_i`.\n\n        * For second-order observables returns a real symmetric matrix\n          such that :math:`Q = \\sum_{ij} q_{ij} \\mathbf{r}_i \\mathbf{r}_j`.\n\n        Args:\n            num_wires (int): total number of wires in the quantum circuit\n        Returns:\n            array[float]: :math:`q`\n        """"""\n        p = self.parameters\n        U = self._heisenberg_rep(p)  # pylint: disable=assignment-from-none\n        return self.heisenberg_expand(U, num_wires)\n'"
pennylane/utils.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains utilities and auxiliary functions which are shared\nacross the PennyLane submodules.\n""""""\n# pylint: disable=protected-access\nfrom collections.abc import Iterable\nfrom collections import OrderedDict\nimport copy\nimport numbers\nimport functools\nimport inspect\n\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.variable import Variable\n\n\ndef _flatten(x):\n    """"""Iterate recursively through an arbitrarily nested structure in depth-first order.\n\n    See also :func:`_unflatten`.\n\n    Args:\n        x (array, Iterable, Any): each element of an array or an Iterable may itself be any of these types\n\n    Yields:\n        Any: elements of x in depth-first order\n    """"""\n    if isinstance(x, np.ndarray):\n        yield from _flatten(x.flat)  # should we allow object arrays? or just ""yield from x.flat""?\n    elif isinstance(x, Iterable) and not isinstance(x, (str, bytes)):\n        for item in x:\n            yield from _flatten(item)\n    else:\n        yield x\n\n\ndef _unflatten(flat, model):\n    """"""Restores an arbitrary nested structure to a flattened iterable.\n\n    See also :func:`_flatten`.\n\n    Args:\n        flat (array): 1D array of items\n        model (array, Iterable, Number): model nested structure\n\n    Raises:\n        TypeError: if ``model`` contains an object of unsupported type\n\n    Returns:\n        Union[array, list, Any], array: first elements of flat arranged into the nested\n        structure of model, unused elements of flat\n    """"""\n    if isinstance(model, (numbers.Number, Variable, str)):\n        return flat[0], flat[1:]\n\n    if isinstance(model, np.ndarray):\n        idx = model.size\n        res = np.array(flat)[:idx].reshape(model.shape)\n        return res, flat[idx:]\n\n    if isinstance(model, Iterable):\n        res = []\n        for x in model:\n            val, flat = _unflatten(flat, x)\n            res.append(val)\n        return res, flat\n\n    raise TypeError(""Unsupported type in the model: {}"".format(type(model)))\n\n\ndef unflatten(flat, model):\n    """"""Wrapper for :func:`_unflatten`.\n\n    Args:\n        flat (array): 1D array of items\n        model (array, Iterable, Number): model nested structure\n\n    Raises:\n        ValueError: if ``flat`` has more elements than ``model``\n    """"""\n    # pylint:disable=len-as-condition\n    res, tail = _unflatten(np.asarray(flat), model)\n    if len(tail) != 0:\n        raise ValueError(""Flattened iterable has more elements than the model."")\n    return res\n\n\ndef _inv_dict(d):\n    """"""Reverse a dictionary mapping.\n\n    Returns multimap where the keys are the former values,\n    and values are sets of the former keys.\n\n    Args:\n        d (dict[a->b]): mapping to reverse\n\n    Returns:\n        dict[b->set[a]]: reversed mapping\n    """"""\n    ret = {}\n    for k, v in d.items():\n        ret.setdefault(v, set()).add(k)\n    return ret\n\n\ndef _get_default_args(func):\n    """"""Get the default arguments of a function.\n\n    Args:\n        func (callable): a function\n\n    Returns:\n        dict[str, tuple]: mapping from argument name to (positional idx, default value)\n    """"""\n    signature = inspect.signature(func)\n    return {\n        k: (idx, v.default)\n        for idx, (k, v) in enumerate(signature.parameters.items())\n        if v.default is not inspect.Parameter.empty\n    }\n\n\n@functools.lru_cache()\ndef pauli_eigs(n):\n    r""""""Eigenvalues for :math:`A^{\\otimes n}`, where :math:`A` is\n    Pauli operator, or shares its eigenvalues.\n\n    As an example if n==2, then the eigenvalues of a tensor product consisting\n    of two matrices sharing the eigenvalues with Pauli matrices is returned.\n\n    Args:\n        n (int): the number of qubits the matrix acts on\n    Returns:\n        list: the eigenvalues of the specified observable\n    """"""\n    if n == 1:\n        return np.array([1, -1])\n    return np.concatenate([pauli_eigs(n - 1), -pauli_eigs(n - 1)])\n\n\nclass OperationRecorder(qml.QueuingContext):\n    """"""A template and quantum function inspector,\n    allowing easy introspection of operators that have been\n    applied without requiring a QNode.\n\n    **Example**:\n\n    The OperationRecorder is a context manager. Executing templates\n    or quantum functions stores resulting applied operators in the\n    recorder, which can then be printed.\n\n    >>> weights = qml.init.strong_ent_layers_normal(n_layers=1, n_wires=2)\n    >>>\n    >>> with qml.utils.OperationRecorder() as rec:\n    >>>    qml.templates.layers.StronglyEntanglingLayers(*weights, wires=[0, 1])\n    >>>\n    >>> print(rec)\n    Operations\n    ==========\n    Rot(-0.10832656163640327, 0.14429091013664083, -0.010835826725765343, wires=[0])\n    Rot(-0.11254523669444501, 0.0947222564914006, -0.09139600968423377, wires=[1])\n    CNOT(wires=[0, 1])\n    CNOT(wires=[1, 0])\n\n    Alternatively, the :attr:`~.OperationRecorder.queue` attribute can be used\n    to directly accessed the applied :class:`~.Operation` and :class:`~.Observable`\n    objects.\n\n    Attributes:\n        queue (List[~.Operators]): list of operators applied within\n            the OperatorRecorder context, includes operations and observables\n        operations (List[~.Operations]): list of operations applied within\n            the OperatorRecorder context\n        observables (List[~.Observables]): list of observables applied within\n            the OperatorRecorder context\n    """"""\n\n    def __init__(self):\n        self.queue = []\n        self.operations = None\n        self.observables = None\n\n    def _append_operator(self, operator):\n        self.queue.append(operator)\n\n    def _remove_operator(self, operator):\n        self.queue.remove(operator)\n\n    def __exit__(self, exception_type, exception_value, traceback):\n        super().__exit__(exception_type, exception_value, traceback)\n\n        # Remove duplicates that might have arisen from measurements\n        self.queue = list(OrderedDict.fromkeys(self.queue))\n        self.operations = list(\n            filter(\n                lambda op: not (\n                    isinstance(op, qml.operation.Observable) and not op.return_type is None\n                ),\n                self.queue,\n            )\n        )\n        self.observables = list(\n            filter(\n                lambda op: isinstance(op, qml.operation.Observable) and not op.return_type is None,\n                self.queue,\n            )\n        )\n\n    def __str__(self):\n        output = """"\n        output += ""Operations\\n""\n        output += ""==========\\n""\n        for op in self.operations:\n            output += repr(op) + ""\\n""\n\n        output += ""\\n""\n        output += ""Observables\\n""\n        output += ""==========\\n""\n        for op in self.observables:\n            output += repr(op) + ""\\n""\n\n        return output\n\n\ndef inv(operation_list):\n    """"""Invert a list of operations or a :doc:`template </introduction/templates>`.\n\n    If the inversion happens inside a QNode, the operations are removed and requeued\n    in the reversed order for proper inversion.\n\n    **Example:**\n\n    The following example illuminates the inversion of a template:\n\n    .. code-block:: python3\n\n        @qml.template\n        def ansatz(weights, wires):\n            for idx, wire in enumerate(wires):\n                qml.RX(weights[idx], wires=[wire])\n\n            for idx in range(len(wires) - 1):\n                qml.CNOT(wires=[wires[idx], wires[idx + 1]])\n\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(weights):\n            qml.inv(ansatz(weights, wires=[0, 1]))\n            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n    We may also invert an operation sequence:\n\n    .. code-block:: python3\n\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit1():\n            qml.T(wires=[0]).inv()\n            qml.Hadamard(wires=[0]).inv()\n            qml.S(wires=[0]).inv()\n            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n        @qml.qnode(dev)\n        def circuit2():\n            qml.inv([qml.S(wires=[0]), qml.Hadamard(wires=[0]), qml.T(wires=[0])])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n    Double checking that both circuits produce the same output:\n\n    >>> ZZ1 = circuit1()\n    >>> ZZ2 = circuit2()\n    >>> assert ZZ1 == ZZ2\n    True\n\n    Args:\n        operation_list (Iterable[~.Operation]): An iterable of operations\n\n    Returns:\n        List[~.Operation]: The inverted list of operations\n    """"""\n    if isinstance(operation_list, qml.operation.Operation):\n        operation_list = [operation_list]\n    elif operation_list is None:\n        raise ValueError(\n            ""None was passed as an argument to inv. ""\n            ""This could happen if inversion of a template without the template decorator is attempted.""\n        )\n    elif callable(operation_list):\n        raise ValueError(\n            ""A function was passed as an argument to inv. ""\n            ""This could happen if inversion of a template function is attempted. ""\n            ""Please use inv on the function including its arguments, as in inv(template(args)).""\n        )\n    elif not isinstance(operation_list, Iterable):\n        raise ValueError(""The provided operation_list is not iterable."")\n\n    non_ops = [\n        (idx, op)\n        for idx, op in enumerate(operation_list)\n        if not isinstance(op, qml.operation.Operation)\n    ]\n\n    if non_ops:\n        string_reps = ["" operation_list[{}] = {}"".format(idx, op) for idx, op in non_ops]\n        raise ValueError(\n            ""The given operation_list does not only contain Operations.""\n            + ""The following elements of the iterable were not Operations:""\n            + "","".join(string_reps)\n        )\n\n    inv_ops = [op.inv() for op in reversed(copy.deepcopy(operation_list))]\n\n    for op in operation_list:\n        qml.QueuingContext.remove_operator(op)\n\n    for inv_op in inv_ops:\n        qml.QueuingContext.append_operator(inv_op)\n\n    return inv_ops\n\n\ndef expand(matrix, original_wires, expanded_wires):\n    r""""""Expand a an operator matrix to more wires.\n\n    Args:\n        matrix (array): :math:`2^n \\times 2^n` matrix where n = len(original_wires).\n        original_wires (Sequence[int]): original wires of matrix\n        expanded_wires (Union[Sequence[int], int]): expanded wires of matrix, can be shuffled.\n            If a single int m is given, corresponds to list(range(m))\n\n    Returns:\n        array: :math:`2^m \\times 2^m` matrix where m = len(expanded_wires).\n    """"""\n    if isinstance(expanded_wires, numbers.Integral):\n        expanded_wires = list(range(expanded_wires))\n\n    N = len(original_wires)\n    M = len(expanded_wires)\n    D = M - N\n\n    if not set(expanded_wires).issuperset(original_wires):\n        raise ValueError(""Invalid target subsystems provided in \'original_wires\' argument."")\n\n    if matrix.shape != (2 ** N, 2 ** N):\n        raise ValueError(\n            ""Matrix parameter must be of size (2**len(original_wires), 2**len(original_wires))""\n        )\n\n    dims = [2] * (2 * N)\n    tensor = matrix.reshape(dims)\n\n    if D > 0:\n        extra_dims = [2] * (2 * D)\n        identity = np.eye(2 ** D).reshape(extra_dims)\n        expanded_tensor = np.tensordot(tensor, identity, axes=0)\n        # Fix order of tensor factors\n        expanded_tensor = np.moveaxis(expanded_tensor, range(2 * N, 2 * N + D), range(N, N + D))\n    else:\n        expanded_tensor = tensor\n\n    wire_indices = []\n    for wire in original_wires:\n        wire_indices.append(expanded_wires.index(wire))\n\n    wire_indices = np.array(wire_indices)\n\n    # Order tensor factors according to wires\n    original_indices = np.array(range(N))\n    expanded_tensor = np.moveaxis(expanded_tensor, original_indices, wire_indices)\n    expanded_tensor = np.moveaxis(expanded_tensor, original_indices + M, wire_indices + M)\n\n    return expanded_tensor.reshape((2 ** M, 2 ** M))\n\n\ndef expand_vector(vector, original_wires, expanded_wires):\n    r""""""Expand a vector to more wires.\n\n    Args:\n        vector (array): :math:`2^n` vector where n = len(original_wires).\n        original_wires (Sequence[int]): original wires of vector\n        expanded_wires (Union[Sequence[int], int]): expanded wires of vector, can be shuffled\n            If a single int m is given, corresponds to list(range(m))\n\n    Returns:\n        array: :math:`2^m` vector where m = len(expanded_wires).\n    """"""\n    if isinstance(expanded_wires, numbers.Integral):\n        expanded_wires = list(range(expanded_wires))\n\n    N = len(original_wires)\n    M = len(expanded_wires)\n    D = M - N\n\n    if not set(expanded_wires).issuperset(original_wires):\n        raise ValueError(""Invalid target subsystems provided in \'original_wires\' argument."")\n\n    if vector.shape != (2 ** N,):\n        raise ValueError(""Vector parameter must be of length 2**len(original_wires)"")\n\n    dims = [2] * N\n    tensor = vector.reshape(dims)\n\n    if D > 0:\n        extra_dims = [2] * D\n        ones = np.ones(2 ** D).reshape(extra_dims)\n        expanded_tensor = np.tensordot(tensor, ones, axes=0)\n    else:\n        expanded_tensor = tensor\n\n    wire_indices = []\n    for wire in original_wires:\n        wire_indices.append(expanded_wires.index(wire))\n\n    wire_indices = np.array(wire_indices)\n\n    # Order tensor factors according to wires\n    original_indices = np.array(range(N))\n    expanded_tensor = np.moveaxis(expanded_tensor, original_indices, wire_indices)\n\n    return expanded_tensor.reshape(2 ** M)\n'"
pennylane/variable.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the :class:`Variable` class, which is used to track\nand identify :class:`~pennylane.qnode.QNode` parameters.\n\nDescription\n-----------\n\nThe first time a QNode is evaluated (either by calling :meth:`~.QNode.evaluate`,\n:meth:`~.QNode.__call__`, or :meth:`~.QNode.jacobian`), the :meth:`~.QNode.construct`\nmethod is called, which performs a \'just-in-time\' circuit construction\non the :mod:`~pennylane._device.Device`. As part of this construction, all arguments\nand keyword arguments are wrapped in a `Variable` as follows:\n\n* All positional arguments in ``*args``, including those with multiple dimensions, are\n  flattened to a single list, and each element wrapped as a Variable instance,\n  indexed by its position in the list.\n\n  This allows PennyLane to inspect the shape and type of arguments\n  the user wishes to pass. The list can then be unflattened back to the original\n  shape of ``*args``.\n\n\n* The same is done for each keyword argument in ``**kwargs``, the only\n  difference being that the name of each contained Variable corresponds\n  with the keyword name.\n\nAs a result, the device stores a list of operations and expectations, with all\nfree parameters stored as Variable instances.\n\n.. note::\n    The QNode can be differentiated with respect to positional arguments,\n    but *not* with respect to keyword arguments. This makes keyword arguments\n    a natural location for data placeholders.\n\n.. important::\n    If the user defines a keyword argument, then they always have to pass the\n    corresponding variable as a keyword argument, otherwise it won\'t register.\n\nFor each successive QNode execution, the user-provided values for the positional and keyword\narguments are stored in :attr:`Variable.positional_arg_values` and\n:attr:`Variable.kwarg_values` respectively; the values are\nthen returned by :meth:`Variable.val`, using the Variable\'s ``idx`` attribute, and, for\nkeyword arguments, its ``name``, to return the correct value to the operation.\n\n.. note::\n    The :meth:`Operation.parameters() <pennylane.operation.Operation.parameters>`\n    property automates the process of unpacking the Variable value.\n    The attribute :meth:`Variable.val` should not need to be accessed outside of advanced usage.\n""""""\nimport copy\n\n\nclass Variable:\n    """"""A reference to dynamically track and update circuit parameters.\n\n    Represents a free quantum circuit parameter (with a non-fixed value),\n    or a placeholder for data/other hard-coded data.\n\n    Each time the circuit is executed, it is given a vector of flattened positional argument values,\n    and a dictionary mapping keyword-only argument names to vectors of their flattened values.\n    Each element of these vectors corresponds to a Variable instance.\n    Positional arguments are represented by nameless Variables, whereas for keyword-only\n    arguments :attr:`Variable.name` contains the argument name.\n    In both cases :attr:`Variable.idx` is an index into the argument value vector.\n\n    The Variable has an optional scalar multiplier for the argument it represents.\n\n    .. note:: Variables currently do not implement any arithmetic\n        operations other than scalar multiplication.\n\n    Args:\n        idx  (int): index into the value vector, >= 0\n        name (None, str): name of the argument\n    """"""\n\n    # pylint: disable=too-few-public-methods\n\n    #: array[float]: current positional parameter values, set in :meth:`.BaseQNode._set_variables`\n    positional_arg_values = None\n\n    #: dict[str->array[float]]: current auxiliary parameter values, set in :meth:`.BaseQNode._set_variables`\n    kwarg_values = None\n\n    def __init__(self, idx, name=None, is_kwarg=False):\n        self.idx = idx  #: int: parameter index\n        self.name = name  #: str: parameter name\n        self.idx = idx  #: int: parameter index\n        self.mult = 1  #: int, float: parameter scalar multiplier\n        self.is_kwarg = is_kwarg\n\n    def __repr__(self):\n        temp = "" * {}"".format(self.mult) if self.mult != 1.0 else """"\n        return ""<Variable({}:{}{})>"".format(self.name, self.idx, temp)\n\n    def __str__(self):\n        temp = "", * {}"".format(self.mult) if self.mult != 1.0 else """"\n        return ""Variable: name = {}, idx = {}{}"".format(self.name, self.idx, temp)\n\n    def __eq__(self, other):\n        if not isinstance(other, Variable):\n            return False\n\n        return (\n            self.name == other.name\n            and self.idx == other.idx\n            and self.is_kwarg == other.is_kwarg\n            and self.mult == other.mult\n        )\n\n    def __neg__(self):\n        """"""Unary negation.""""""\n        temp = copy.copy(self)\n        temp.mult = -temp.mult\n        return temp\n\n    def __mul__(self, scalar):\n        """"""Right multiplication by scalars.""""""\n        temp = copy.copy(self)\n        temp.mult *= scalar\n        return temp\n\n    def __truediv__(self, scalar):\n        """"""Right division by scalars. Left division is not allowed.""""""\n        temp = copy.copy(self)\n        temp.mult /= scalar\n        return temp\n\n    __rmul__ = __mul__  # Left multiplication by scalars.\n\n    @property\n    def val(self):\n        """"""Current numerical value of the Variable.\n\n        Returns:\n            float: current value of the Variable\n        """"""\n        # pylint: disable=unsubscriptable-object\n        if not self.is_kwarg:\n            # The variable is a placeholder for a positional argument\n            return Variable.positional_arg_values[self.idx] * self.mult\n\n        # The variable is a placeholder for a keyword argument\n        values = Variable.kwarg_values[self.name]\n        return values[self.idx] * self.mult\n\n    def render(self, show_name_only=False):\n        """"""Returns a string representation of the Variable.\n\n        Args:\n            show_name_only (bool, optional): Render the name instead of the value.\n\n        Returns:\n            str: A string representation of the Variable\n        """"""\n        if not show_name_only:\n            if self.is_kwarg and Variable.kwarg_values and self.name in Variable.kwarg_values:\n                return str(round(self.val, 3))\n\n            if (\n                not self.is_kwarg\n                and Variable.positional_arg_values is not None\n                and len(Variable.positional_arg_values) > self.idx\n            ):\n                return str(round(self.val, 3))\n\n        if self.mult != 1:\n            return ""{}*{}"".format(str(round(self.mult, 3)), self.name)\n\n        return self.name\n'"
pennylane/wires.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the :class:`Wires` class, which takes care of wire bookkeeping.\n""""""\nfrom collections import Sequence, Iterable\nimport numpy as np\nfrom numbers import Number\n\n\nclass WireError(Exception):\n    """"""Exception raised by a :class:`~.pennylane.wires.Wire` object when it is unable to process wires.\n    """"""\n\n\ndef _process(wires):\n    """"""Converts the input to a tuple of numbers or strings.""""""\n\n    if isinstance(wires, Wires):\n        # if input is already a Wires object, just return its wire tuple\n        return wires.wire_tuple\n\n    elif isinstance(wires, Iterable) and all(isinstance(w, Wires) for w in wires):\n        # if the elements are themselves Wires objects, merge them to a new one\n        return tuple(w for wires_ in wires for w in wires_.tolist())\n\n    elif isinstance(wires, Iterable) and all(\n        isinstance(w, str) or isinstance(w, Number) for w in wires\n    ):\n        # if the elements are strings or numbers, turn iterable into tuple\n        return tuple(wires)\n\n    elif isinstance(wires, Number):\n        # if the input is a single number, interpret as a single wire\n        return (wires,)\n\n    else:\n        raise WireError(\n            ""Wires must be represented by a number or string; got {} of type {}."".format(\n                wires, type(wires)\n            )\n        )\n\n\nclass Wires(Sequence):\n    r""""""\n    A bookkeeping class for wires, which are ordered collections of unique objects. The :math:`i\\mathrm{th}` object\n    addresses the :math:`i\\mathrm{th}` quantum subsystem.\n\n    There is no conceptual difference between registers of multiple wires and single wires,\n    which are just wire registers of length one.\n\n    Indexing and slicing this sequence will return another ``Wires`` object.\n\n    Args:\n         wires (Iterable[Number,str], Number): If iterable, interpreted as an ordered collection of unique objects\n            representing wires. If a Number, the input is converted into an iterable of a single entry,\n            and hence interpreted as a single wire.\n    """"""\n\n    def __init__(self, wires):\n\n        self.wire_tuple = _process(wires)\n\n        # check that all wires are unique\n        if len(set(self.wire_tuple)) != len(self.wire_tuple):\n            raise WireError(""Wires must be unique; got {}."".format(wires))\n\n    def __getitem__(self, idx):\n        """"""Method to support indexing. Returns a Wires object representing a register with a single wire.""""""\n        return Wires(self.wire_tuple[idx])\n\n    def __len__(self):\n        """"""Method to support ``len()``.""""""\n        return len(self.wire_tuple)\n\n    def __contains__(self, item):\n        """"""Method checking if Wires object contains an object.""""""\n        if isinstance(item, Wires):\n            item = item.tolist()\n        # if all wires can be found in tuple, return True, else False\n        return all(wire in self.wire_tuple for wire in item)\n\n    def __repr__(self):\n        """"""Method defining the string representation of this class.""""""\n        return ""<Wires = {}>"".format(list(self.wire_tuple))\n\n    def __eq__(self, other):\n        """"""Method to support the \'==\' operator. This will also implicitly define the \'!=\' operator.""""""\n        # The order is respected in comparison, so that ``assert Wires([0, 1]) != Wires([1,0])``\n        if isinstance(other, self.__class__):\n            return self.wire_tuple == other.wire_tuple\n        return False\n\n    def __hash__(self):\n        """"""Implements the hash function.""""""\n        return hash(repr(self.wire_tuple))\n\n    def toarray(self):\n        """"""Returns a numpy array representation of the Wires object.\n\n        Returns:\n            ndarray: array representing Wires object\n        """"""\n        return np.array(self.wire_tuple)\n\n    def tolist(self):\n        """"""Returns a list representation of the Wires object.\n\n        Returns:\n            List: list representing Wires object\n        """"""\n        return list(self.wire_tuple)\n\n    def index(self, wire):\n        """"""Overwrites a Sequence\'s ``index()`` function which returns the index of ``wire``.\n\n        Args:\n            wire (Any): Object whose index is to be found. If this is a Wires object of length 1, look for the object\n                representing the wire.\n\n        Returns:\n            int: index of the input\n        """"""\n\n        if isinstance(wire, Wires):\n            if len(wire) != 1:\n                raise WireError(""Can only retrieve index of a Wires object of length 1."")\n\n            return self.wire_tuple.index(wire.wire_tuple[0])\n\n        return self.wire_tuple.index(wire)\n\n    def indices(self, wires):\n        """"""\n        Return the indices of the wires in this Wires object.\n\n        For example,\n\n        >>> wires1 =  Wires([4, 0, 1])\n        >>> wires2 = Wires([1, 4])\n        >>> wires1.indices(wires2)\n        [2, 0]\n        >>> wires1.indices([1, 4])\n        [2, 0]\n\n        Args:\n            wires (Wires or Iterable[Any]): Iterable containing the wires whose indices are to be found\n\n        Returns:\n            List: index list\n        """"""\n\n        return [self.index(w) for w in wires]\n\n    def subset(self, indices, periodic_boundary=False):\n        """"""\n        Returns a new Wires object which is a subset of this Wires object. The wires of the new\n        object are the wires at positions specified by \'indices\'. Also accepts a single index as input.\n\n        For example:\n\n        >>> wires = Wires([4, 0, 1, 5, 6])\n        >>> wires.subset([2, 3, 0])\n        <Wires = [1, 5, 4]>\n        >>> wires.subset(1)\n        <Wires = [0]>\n\n        If ``periodic_boundary`` is True, the modulo of the number of wires of an index is used instead of an index,\n        so that  ``wires.subset(i) == wires.subset(i % n_wires)`` where ``n_wires`` is the number of wires of this\n        object.\n\n        For example:\n\n        >>> wires = Wires([4, 0, 1, 5, 6])\n        >>> wires.subset([5, 1, 7])\n        <Wires = [4, 0, 1]>\n\n        Args:\n            indices (List[int] or int): indices or index of the wires we want to select\n            periodic_boundary (bool): controls periodic boundary conditions in the indexing\n\n        Returns:\n            Wires: subset of wires\n        """"""\n\n        if isinstance(indices, int):\n            indices = [indices]\n\n        if periodic_boundary:\n            # replace indices by their modulo\n            indices = [i % len(self.wire_tuple) for i in indices]\n\n        for i in indices:\n            if i > len(self.wire_tuple):\n                raise WireError(\n                    ""Cannot subset wire at index {} from {} wires."".format(i, len(self.wire_tuple))\n                )\n\n        subset = [self.wire_tuple[i] for i in indices]\n        return Wires(subset)\n\n    def select_random(self, n_samples, seed=None):\n        """"""\n        Returns a randomly sampled subset of Wires of length \'n_samples\'.\n\n        Args:\n            n_samples (int): number of subsampled wires\n            seed (int): optional random seed used for selecting the wires\n\n        Returns:\n            Wires: random subset of wires\n        """"""\n\n        if n_samples > len(self.wire_tuple):\n            raise WireError(\n                ""Cannot sample {} wires from {} wires."".format(n_samples, len(self.wire_tuple))\n            )\n\n        if seed is not None:\n            np.random.seed(seed)\n\n        indices = np.random.choice(len(self.wire_tuple), size=n_samples, replace=False)\n        subset = [self.wire_tuple[i] for i in indices]\n        return Wires(subset)\n\n    @staticmethod\n    def shared_wires(list_of_wires):\n        """"""Return only the wires that appear in each Wires object in the list.\n\n        This is similar to a set intersection method, but keeps the order of wires as they appear in the list.\n\n        For example:\n\n        >>> wires1 =  Wires([4, 0, 1])\n        >>> wires2 = Wires([3, 0, 4])\n        >>> wires3 = Wires([4, 0])\n        >>> Wires.shared_wires([wires1, wires2, wires3])\n        <Wires = [4, 0]>\n        >>> Wires.shared_wires([wires2, wires1, wires3])\n        <Wires = [0, 4]>\n\n        Args:\n            list_of_wires (List[Wires]): list of Wires objects\n\n        Returns:\n            Wires: shared wires\n        """"""\n\n        for wires in list_of_wires:\n            if not isinstance(wires, Wires):\n                raise WireError(\n                    ""Expected a Wires object; got {} of type {}."".format(wires, type(wires))\n                )\n\n        shared = []\n        # only need to iterate through the first object,\n        # since any wire not in this object will also not be shared\n        for wire in list_of_wires[0]:\n            if all(wire in wires_ for wires_ in list_of_wires):\n                shared.append(wire)\n\n        return Wires(shared)\n\n    @staticmethod\n    def all_wires(list_of_wires):\n        """"""Return the wires that appear in any of the Wires objects in the list.\n\n        This is similar to a set combine method, but keeps the order of wires as they appear in the list.\n\n        For example:\n\n        >>> wires1 = Wires([4, 0, 1])\n        >>> wires2 = Wires([3, 0, 4])\n        >>> wires3 = Wires([5, 3])\n        >>> list_of_wires = [wires1, wires2, wires3]\n        >>> Wires.all_wires(list_of_wires)\n        <Wires = [4, 0, 1, 3, 5]>\n\n        Args:\n            list_of_wires (List[Wires]): List of Wires objects\n\n        Returns:\n            Wires: combined wires\n        """"""\n\n        combined = []\n        for wires in list_of_wires:\n            if not isinstance(wires, Wires):\n                raise WireError(\n                    ""Expected a Wires object; got {} of type {}"".format(wires, type(wires))\n                )\n\n            combined.extend(wire for wire in wires.wire_tuple if wire not in combined)\n\n        return Wires(combined)\n\n    @staticmethod\n    def unique_wires(list_of_wires):\n        """"""Return the wires that are unique to any Wire object in the list.\n\n        For example:\n\n        >>> wires1 = Wires([4, 0, 1])\n        >>> wires2 = Wires([0, 2, 3])\n        >>> wires3 = Wires([5, 3])\n        >>> Wires.unique_wires([wires1, wires2, wires3])\n        <Wires = [4, 2, 5]>\n\n        Args:\n            list_of_wires (List[Wires]): list of Wires objects\n\n        Returns:\n            Wires: unique wires\n        """"""\n\n        for wires in list_of_wires:\n            if not isinstance(wires, Wires):\n                raise WireError(\n                    ""Expected a Wires object; got {} of type {}."".format(wires, type(wires))\n                )\n\n        unique = []\n        for wires in list_of_wires:\n            for wire in wires:\n                # check that wire is only contained in one of the Wires objects\n                if sum([1 for wires_ in list_of_wires if wire in wires_]) == 1:\n                    unique.append(wire)\n\n        return Wires(unique)\n'"
qchem/setup.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom setuptools import setup\n\nwith open(""pennylane_qchem/_version.py"") as f:\n    version = f.readlines()[-1].split()[-1].strip(""\\""\'"")\n\nrequirements = [""pennylane"", ""openfermion"", ""openfermionpyscf"",\n        ""openfermionpsi4"", ""pyscf<=1.7.1""]\n\ninfo = {\n    ""name"": ""PennyLane-Qchem"",\n    ""version"": version,\n    ""maintainer"": ""Xanadu Inc."",\n    ""maintainer_email"": ""software@xanadu.ai"",\n    ""url"": ""http://xanadu.ai"",\n    ""packages"": [""pennylane_qchem""],\n    ""description"": ""Package for quantum chemistry applications"",\n    ""long_description"": open(""README.rst"").read(),\n    ""provides"": [""pennylane_qchem""],\n    ""install_requires"": requirements,\n    ""entry_points"": {""pennylane.qchem"": [""OpenFermion = pennylane_qchem.qchem""]},\n}\n\nclassifiers = [\n    ""Development Status :: 1 - Planning"",\n    ""Environment :: Console"",\n    ""Intended Audience :: Science/Research"",\n    ""Natural Language :: English"",\n    ""Operating System :: POSIX"",\n    ""Operating System :: MacOS :: MacOS X"",\n    ""Operating System :: POSIX :: Linux"",\n    ""Operating System :: Microsoft :: Windows"",\n    ""Programming Language :: Python"",\n    ""Programming Language :: Python :: 3"",\n    ""Programming Language :: Python :: 3.6"",\n    ""Programming Language :: Python :: 3.7"",\n    ""Programming Language :: Python :: 3.8"",\n    ""Programming Language :: Python :: 3 :: Only"",\n    ""Topic :: Scientific/Engineering :: Physics"",\n]\n\nsetup(classifiers=classifiers, **info)\n'"
tests/conftest.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nPytest configuration file for PennyLane test suite.\n""""""\nimport os\n\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.plugins import DefaultGaussian\n\n# defaults\nTOL = 1e-3\nTF_TOL = 2e-2\n\nclass DummyDevice(DefaultGaussian):\n    """"""Dummy device to allow Kerr operations""""""\n    _operation_map = DefaultGaussian._operation_map.copy()\n    _operation_map[\'Kerr\'] = lambda *x, **y: np.identity(2)\n\n\n@pytest.fixture(scope=""session"")\ndef tol():\n    """"""Numerical tolerance for equality tests.""""""\n    return float(os.environ.get(""TOL"", TOL))\n\n@pytest.fixture(scope=""session"")\ndef tf_tol():\n    """"""Numerical tolerance for equality tests.""""""\n    return float(os.environ.get(""TF_TOL"", TF_TOL))\n\n@pytest.fixture(scope=""session"", params=[1, 2])\ndef n_layers(request):\n    """"""Number of layers.""""""\n    return request.param\n\n\n@pytest.fixture(scope=""session"", params=[2, 3])\ndef n_subsystems(request):\n    """"""Number of qubits or qumodes.""""""\n    return request.param\n\n\n@pytest.fixture(scope=""session"")\ndef qubit_device(n_subsystems):\n    return qml.device(\'default.qubit\', wires=n_subsystems)\n\n\n@pytest.fixture(scope=""function"")\ndef qubit_device_1_wire():\n    return qml.device(\'default.qubit\', wires=1)\n\n\n@pytest.fixture(scope=""function"")\ndef qubit_device_2_wires():\n    return qml.device(\'default.qubit\', wires=2)\n\n\n@pytest.fixture(scope=""function"")\ndef qubit_device_3_wires():\n    return qml.device(\'default.qubit\', wires=3)\n\n\n@pytest.fixture(scope=""session"")\ndef tensornet_device(n_subsystems):\n    return qml.device(\'default.tensor\', wires=n_subsystems)\n\n\n@pytest.fixture(scope=""function"")\ndef tensornet_device_1_wire():\n    return qml.device(\'default.tensor\', wires=1)\n\n\n@pytest.fixture(scope=""function"")\ndef tensornet_device_2_wires():\n    return qml.device(\'default.tensor\', wires=2)\n\n\n@pytest.fixture(scope=""function"")\ndef tensornet_device_3_wires():\n    return qml.device(\'default.tensor\', wires=3)\n\n\n@pytest.fixture(scope=""session"")\ndef gaussian_device(n_subsystems):\n    """"""Number of qubits or modes.""""""\n    return DummyDevice(wires=n_subsystems)\n\n@pytest.fixture(scope=""session"")\ndef gaussian_dummy():\n    """"""Number of qubits or modes.""""""\n    return DummyDevice\n\n@pytest.fixture(scope=""session"")\ndef gaussian_device_2_wires():\n    """"""A 2-mode Gaussian device.""""""\n    return DummyDevice(wires=2)\n\n\n@pytest.fixture(scope=""session"")\ndef gaussian_device_4modes():\n    """"""A 4 mode Gaussian device.""""""\n    return DummyDevice(wires=4)\n\n\n@pytest.fixture(scope=\'session\')\ndef torch_support():\n    """"""Boolean fixture for PyTorch support""""""\n    try:\n        import torch\n        from torch.autograd import Variable\n        torch_support = True\n    except ImportError as e:\n        torch_support = False\n\n    return torch_support\n\n\n@pytest.fixture()\ndef skip_if_no_torch_support(torch_support):\n    if not torch_support:\n        pytest.skip(""Skipped, no torch support"")\n\n\n@pytest.fixture(scope=\'module\')\ndef tf_support():\n    """"""Boolean fixture for TensorFlow support""""""\n    try:\n        import tensorflow as tf\n        tf_support = True\n\n    except ImportError as e:\n        tf_support = False\n\n    return tf_support\n\n\n@pytest.fixture()\ndef skip_if_no_tf_support(tf_support):\n    if not tf_support:\n        pytest.skip(""Skipped, no tf support"")\n\n\n@pytest.fixture(scope=""module"",\n                params=[1, 2, 3])\ndef seed(request):\n    """"""Different seeds.""""""\n    return request.param\n\n\n@pytest.fixture(scope=""function"")\ndef mock_device(monkeypatch):\n    """"""A mock instance of the abstract Device class""""""\n\n    with monkeypatch.context() as m:\n        dev = qml.Device\n        m.setattr(dev, \'__abstractmethods__\', frozenset())\n        m.setattr(dev, \'short_name\', \'mock_device\')\n        m.setattr(dev, \'capabilities\', lambda cls: {""model"": ""qubit""})\n        yield qml.Device(wires=2)\n\n@pytest.fixture\ndef tear_down_hermitian():\n    yield None\n    qml.Hermitian._eigs = {}\n\n'"
tests/gate_data.py,0,"b'""""""Convenience gate representations for testing""""""\nimport math\nimport cmath\nimport numpy as np\n\n# ========================================================\n#  fixed gates\n# ========================================================\n\nI = np.eye(2)\n# Pauli matrices\nX = np.array([[0, 1], [1, 0]])  #: Pauli-X matrix\nY = np.array([[0, -1j], [1j, 0]])  #: Pauli-Y matrix\nZ = np.array([[1, 0], [0, -1]])  #: Pauli-Z matrix\n\nH = np.array([[1, 1], [1, -1]]) / math.sqrt(2)  #: Hadamard gate\n# Two qubit gates\nCNOT = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])  #: CNOT gate\nSWAP = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])  #: SWAP gate\nCZ = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]])  #: CZ gate\nS = np.array([[1, 0], [0, 1j]])  #: Phase Gate\nT = np.array([[1, 0], [0, cmath.exp(1j * np.pi / 4)]])  #: T Gate\n# Three qubit gates\nCSWAP = np.array(\n    [\n        [1, 0, 0, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 1, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 1],\n    ]\n)  #: CSWAP gate\n\nToffoli = np.diag([1 for i in range(8)])\nToffoli[6:8, 6:8] = np.array([[0, 1], [1, 0]])\n\n# ========================================================\n#  parametrized gates\n# ========================================================\n\n\ndef Rphi(phi):\n    r""""""One-qubit phase shift.\n\n    Args:\n        phi (float): phase shift angle\n    Returns:\n        array: unitary 2x2 phase shift matrix\n    """"""\n    return np.array([[1, 0], [0, cmath.exp(1j * phi)]])\n\n\ndef Rotx(theta):\n    r""""""One-qubit rotation about the x axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_x \\theta/2}`\n    """"""\n    return math.cos(theta / 2) * I + 1j * math.sin(-theta / 2) * X\n\n\ndef Roty(theta):\n    r""""""One-qubit rotation about the y axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_y \\theta/2}`\n    """"""\n    return math.cos(theta / 2) * I + 1j * math.sin(-theta / 2) * Y\n\n\ndef Rotz(theta):\n    r""""""One-qubit rotation about the z axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_z \\theta/2}`\n    """"""\n    return math.cos(theta / 2) * I + 1j * math.sin(-theta / 2) * Z\n\n\ndef Rot3(a, b, c):\n    r""""""Arbitrary one-qubit rotation using three Euler angles.\n\n    Args:\n        a,b,c (float): rotation angles\n    Returns:\n        array: unitary 2x2 rotation matrix ``rz(c) @ ry(b) @ rz(a)``\n    """"""\n    return Rotz(c) @ (Roty(b) @ Rotz(a))\n\n\ndef CRotx(theta):\n    r""""""Two-qubit controlled rotation about the x axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_x(\\theta)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, math.cos(theta / 2), -1j * math.sin(theta / 2)],\n            [0, 0, -1j * math.sin(theta / 2), math.cos(theta / 2)],\n        ]\n    )\n\n\ndef CRoty(theta):\n    r""""""Two-qubit controlled rotation about the y axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_y(\\theta)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, math.cos(theta / 2), -math.sin(theta / 2)],\n            [0, 0, math.sin(theta / 2), math.cos(theta / 2)],\n        ]\n    )\n\n\ndef CRotz(theta):\n    r""""""Two-qubit controlled rotation about the z axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_z(\\theta)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, cmath.exp(-1j * theta / 2), 0],\n            [0, 0, 0, cmath.exp(1j * theta / 2)],\n        ]\n    )\n\n\ndef CRot3(a, b, c):\n    r""""""Arbitrary two-qubit controlled rotation using three Euler angles.\n\n    Args:\n        a,b,c (float): rotation angles\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R(a,b,c)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [\n                0,\n                0,\n                cmath.exp(-1j * (a + c) / 2) * math.cos(b / 2),\n                -cmath.exp(1j * (a - c) / 2) * math.sin(b / 2),\n            ],\n            [\n                0,\n                0,\n                cmath.exp(-1j * (a - c) / 2) * math.sin(b / 2),\n                cmath.exp(1j * (a + c) / 2) * math.cos(b / 2),\n            ],\n        ]\n    )\n'"
tests/test_about.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` configuration classe :class:`Configuration`.\n""""""\n# pylint: disable=protected-access\n\nimport contextlib\nimport io\nimport importlib\nimport re\nimport pkg_resources\n\nimport pytest\n\nimport pennylane as qml\n\n\ndef test_about():\n    """"""\n    about: Tests if the about string prints correct.\n    """"""\n    f = io.StringIO()\n    with contextlib.redirect_stdout(f):\n        qml.about()\n    out = f.getvalue().strip()\n\n    assert ""Version:"" in out\n    pl_version_match = re.search(r""Version:\\s+([\\S]+)\\n"", out).group(1)\n    assert qml.version().replace(""-"", ""."") in pl_version_match\n    assert ""Numpy version"" in out\n    assert ""Scipy version"" in out\n    assert ""default.qubit"" in out\n    assert ""default.gaussian"" in out\n\n\ndef test_qchem_not_installed_error(monkeypatch):\n    """"""Test QChem causes an import error on access\n    if not installed""""""\n\n    class Entry:\n        """"""Dummy entry point for mocking""""""\n        name = None\n\n    with monkeypatch.context() as m:\n        m.setattr(pkg_resources, ""iter_entry_points"", lambda name: [Entry()])\n\n        importlib.reload(qml)\n\n        with pytest.raises(ImportError, match=""PennyLane-QChem not installed.""):\n            print(qml.qchem)\n\n        with pytest.raises(ImportError, match=""PennyLane-QChem not installed.""):\n            qml.qchem.generate_hamiltonian()\n\n    importlib.reload(qml)\n'"
tests/test_classical_gradients.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nSanity checks for classical automatic gradient formulas (without QNodes).\n""""""\n\nimport pytest\n\nimport pennylane as qml\nfrom pennylane import numpy as np\n\n\nnp.random.seed(42)\n\n\nclass TestGradientUnivar:\n    """"""Tests gradients of univariate unidimensional functions.""""""\n\n    def test_sin(self, tol):\n        """"""Tests with sin function.""""""\n        x_vals = np.linspace(-10, 10, 16, endpoint=False)\n        g = qml.grad(np.sin, 0)\n        auto_grad = [g(x) for x in x_vals]\n        correct_grad = np.cos(x_vals)\n\n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n    def test_exp(self, tol):\n        """"""Tests exp function.""""""\n        x_vals = np.linspace(-10, 10, 16, endpoint=False)\n        func = lambda x: np.exp(x / 10.0) / 10.0\n        g = qml.grad(func, 0)\n        auto_grad = [g(x) for x in x_vals]\n        correct_grad = np.exp(x_vals / 10.0) / 100.0\n\n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n    def test_poly(self, tol):\n        """"""Tests a polynomial function.""""""\n        x_vals = np.linspace(-10, 10, 16, endpoint=False)\n        func = lambda x: 2 * x**2 + 3 * x + 4\n        g = qml.grad(func, 0)\n        auto_grad = [g(x) for x in x_vals]\n        correct_grad = 4 * x_vals + 3\n        \n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n\nclass TestGradientMultiVar:\n    """"""Tests gradients of multivariate unidimensional functions.""""""\n\n    def test_sin(self, tol):\n        """"""Tests gradients with multivariate sin and cosine.""""""\n        multi_var = lambda x: np.sin(x[0]) + np.cos(x[1])\n        grad_multi_var = lambda x: np.array([np.cos(x[0]), -np.sin(x[1])])\n\n        x_vec = [1.5, -2.5]\n        g = qml.grad(multi_var, 0)\n        auto_grad = g(x_vec)\n        correct_grad = grad_multi_var(x_vec)\n        \n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n    def test_exp(self, tol):\n        """"""Tests gradients with a multivariate exp and tanh.""""""\n        multi_var = lambda x: np.exp(x[0] / 3) * np.tanh(x[1])\n        grad_multi_var = lambda x: np.array(\n            [\n                np.exp(x[0] / 3) / 3 * np.tanh(x[1]),\n                np.exp(x[0] / 3) * (1 - np.tanh(x[1]) ** 2),\n            ]\n        )\n        x_vec = np.random.uniform(-5, 5, size=(2))\n        g = qml.grad(multi_var, 0)\n        auto_grad = g(x_vec)\n        correct_grad = grad_multi_var(x_vec)\n\n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n    def test_quadratic(self, tol):\n        """"""Tests gradients with a quadratic function.""""""\n        multi_var = lambda x: np.sum([x_ ** 2 for x_ in x])\n        grad_multi_var = lambda x: np.array([2 * x_ for x_ in x])\n        x_vec = np.random.uniform(-5, 5, size=(2))\n        g = qml.grad(multi_var, 0)\n        auto_grad = g(x_vec)\n        correct_grad = grad_multi_var(x_vec)\n\n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n\nclass TestGradientMultiargs:\n    """"""Tests gradients of univariate functions with multiple arguments in signature.""""""\n\n    def test_sin(self, tol):\n        """"""Tests multiarg gradients with sin and cos functions.""""""\n        x = -2.5\n        y = 1.5\n        gradf = lambda x, y: (np.cos(x), -np.sin(y))\n        f = lambda x, y: np.sin(x) + np.cos(y)\n\n        # gradient wrt first argument\n        gx = qml.grad(f, 0)\n\n        auto_gradx = gx(x, y)\n        correct_gradx = gradf(x, y)[0]\n        assert np.allclose(auto_gradx, correct_gradx, atol=tol, rtol=0)\n\n        # gradient wrt second argument\n        gy = qml.grad(f, 1)\n        auto_grady = gy(x, y)\n        correct_grady = gradf(x, y)[1]\n        assert np.allclose(auto_grady, correct_grady, atol=tol, rtol=0)\n\n        # gradient wrt both arguments\n        gxy = qml.grad(f, [0, 1])\n        auto_gradxy = gxy(x, y)\n        correct_gradxy = gradf(x, y)\n        assert np.allclose(auto_gradxy, correct_gradxy, atol=tol, rtol=0)\n\n    def test_exp(self, tol):\n        """"""Tests multiarg gradients with exp and tanh functions.""""""\n        x = -2.5\n        y = 1.5\n        gradf = lambda x, y: (\n            np.exp(x / 3) / 3 * np.tanh(y),\n            np.exp(x / 3) * (1 - np.tanh(y) ** 2),\n        )\n        f = lambda x, y: np.exp(x / 3) * np.tanh(y)\n\n        # gradient wrt first argument\n        gx = qml.grad(f, 0)\n        auto_gradx = gx(x, y)\n        correct_gradx = gradf(x, y)[0]\n        assert np.allclose(auto_gradx, correct_gradx, atol=tol, rtol=0)\n\n        # gradient wrt second argument\n        gy = qml.grad(f, 1)\n        auto_grady = gy(x, y)\n        correct_grady = gradf(x, y)[1]\n        assert np.allclose(auto_grady, correct_grady, atol=tol, rtol=0)\n\n        # gradient wrt both arguments\n        gxy = qml.grad(f, [0, 1])\n        auto_gradxy = gxy(x, y)\n        correct_gradxy = gradf(x, y)\n        assert np.allclose(auto_gradxy, correct_gradxy, atol=tol, rtol=0)\n\n    def test_linear(self, tol):\n        """"""Tests multiarg gradients with a linear function.""""""\n        x = -2.5\n        y = 1.5\n        gradf = lambda x, y: (2 * x, 2 * y)\n        f = lambda x, y: np.sum([x_ ** 2 for x_ in [x, y]])\n\n        # gradient wrt first argument\n        gx = qml.grad(f, 0)\n        auto_gradx = gx(x, y)\n        correct_gradx = gradf(x, y)[0]\n        assert np.allclose(auto_gradx, correct_gradx, atol=tol, rtol=0)\n\n        # gradient wrt second argument\n        gy = qml.grad(f, 1)\n        auto_grady = gy(x, y)\n        correct_grady = gradf(x, y)[1]\n        assert np.allclose(auto_grady, correct_grady, atol=tol, rtol=0)\n\n        # gradient wrt both arguments\n        gxy = qml.grad(f, [0, 1])\n        auto_gradxy = gxy(x, y)\n        correct_gradxy = gradf(x, y)\n        assert np.allclose(auto_gradxy, correct_gradxy, atol=tol, rtol=0)\n\n\nclass TestGradientMultivarMultidim:\n    """"""Tests gradients of multivariate multidimensional functions.""""""\n\n    def test_sin(self, tol):\n        """"""Tests gradients with multivariate multidimensional sin and cos.""""""\n        x_vec = np.random.uniform(-5, 5, size=(2))\n        x_vec_multidim = np.expand_dims(x_vec, axis=1)\n\n        gradf = lambda x: np.array([[np.cos(x[0, 0])], [-np.sin(x[[1]])]], dtype=np.float64)\n        f = lambda x: np.sin(x[0, 0]) + np.cos(x[1, 0])\n\n        g = qml.grad(f, 0)\n        auto_grad = g(x_vec_multidim)\n        correct_grad = gradf(x_vec_multidim)\n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n    def test_exp(self, tol):\n        """"""Tests gradients with multivariate multidimensional exp and tanh.""""""\n        x_vec = np.random.uniform(-5, 5, size=(2))\n        x_vec_multidim = np.expand_dims(x_vec, axis=1)\n\n        gradf = lambda x: np.array(\n            [\n                [np.exp(x[0, 0] / 3) / 3 * np.tanh(x[1, 0])],\n                [np.exp(x[0, 0] / 3) * (1 - np.tanh(x[1, 0]) ** 2)],\n            ]\n        )\n        f = lambda x: np.exp(x[0, 0] / 3) * np.tanh(x[1, 0])\n\n        g = qml.grad(f, 0)\n        auto_grad = g(x_vec_multidim)\n        correct_grad = gradf(x_vec_multidim)\n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n\n    def test_linear(self, tol):\n        """"""Tests gradients with multivariate multidimensional linear func.""""""\n        x_vec = np.random.uniform(-5, 5, size=(2))\n        x_vec_multidim = np.expand_dims(x_vec, axis=1)\n\n        gradf = lambda x: np.array([[2 * x_[0]] for x_ in x])\n        f = lambda x: np.sum([x_[0] ** 2 for x_ in x])\n\n        g = qml.grad(f, 0)\n        auto_grad = g(x_vec_multidim)\n        correct_grad = gradf(x_vec_multidim)\n        assert np.allclose(auto_grad, correct_grad, atol=tol, rtol=0)\n'"
tests/test_configuration.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` configuration classe :class:`Configuration`.\n""""""\nimport pytest\nimport os\nimport logging as log\nimport sys\n\nimport toml\n\nimport pennylane as qml\nfrom pennylane import Configuration\n\n\nlog.getLogger(\'defaults\')\n\n\nconfig_filename = ""default_config.toml""\n\n\ntest_config = """"""\\\n[main]\nshots = 1000\n\n[default.gaussian]\nhbar = 2\n\n[strawberryfields.global]\nhbar = 1\nshots = 1000\nanalytic = true\n\n    [strawberryfields.fock]\n    cutoff_dim = 10\n\n    [strawberryfields.gaussian]\n    shots = 1000\n    hbar = 1\n\n[qiskit.global]\nbackend = ""qasm_simulator""\n\n    [qiskit.aer]\n    backend = ""unitary_simulator""\n    backend_options = {""validation_threshold"" = 1e-6}\n\n    [qiskit.ibmq]\n    ibmqx_token = ""XXX""\n    backend = ""ibmq_rome""\n    hub = ""MYHUB""\n    group = ""MYGROUP""\n    project = ""MYPROJECT""\n""""""\n\n\n@pytest.fixture(scope=""function"")\ndef default_config(tmpdir):\n    config_path = os.path.join(tmpdir, config_filename)\n\n    with open(config_path, ""w"") as f:\n        f.write(test_config)\n\n    return Configuration(name=config_path)\n\n\n@pytest.fixture(scope=""function"")\ndef default_config_toml(tmpdir):\n    config_path = os.path.join(tmpdir, config_filename)\n\n    with open(config_path, ""w"") as f:\n        f.write(test_config)\n\n    return toml.load(config_path), config_path\n\n\nclass TestConfigurationFileInteraction:\n    """"""Test the interaction with the configuration file.""""""\n\n    def test_loading_current_directory(self, monkeypatch, default_config_toml):\n        """"""Test that the default configuration file can be loaded\n        from the current directory.""""""\n        config_toml, config_path = default_config_toml\n\n        monkeypatch.chdir(""."")\n        monkeypatch.setenv(""PENNYLANE_CONF"", """")\n        config = Configuration(name=config_path)\n\n        assert config.path == os.path.join(os.curdir, config_path)\n        assert config._config == config_toml\n\n    def test_loading_environment_variable(self, monkeypatch, default_config_toml):\n        """"""Test that the default configuration file can be loaded\n        from an environment variable.""""""\n        config_toml, config_path = default_config_toml\n\n        os.curdir = ""None""\n        monkeypatch.setenv(""PENNYLANE_CONF"", os.getcwd())\n\n        config = Configuration(name=config_path)\n\n        assert config._config == config_toml\n        assert config._env_config_dir == os.environ[""PENNYLANE_CONF""]\n        assert config.path == os.path.join(os.environ[""PENNYLANE_CONF""], config_path)\n\n    def test_loading_absolute_path(self, monkeypatch, default_config_toml):\n        """"""Test that the default configuration file can be loaded\n        from an absolute path.""""""\n        config_toml, config_path = default_config_toml\n\n        os.curdir = ""None""\n        monkeypatch.setenv(""PENNYLANE_CONF"", """")\n\n        config = Configuration(name=os.path.join(os.getcwd(), config_path))\n\n        assert config._config == config_toml\n        assert config.path == os.path.join(os.getcwd(), config_path)\n\n    def test_not_found_warning(self, caplog):\n        """"""Test that a warning is raised if no configuration file found.""""""\n\n        caplog.clear()\n        caplog.set_level(log.INFO)\n\n        Configuration(""noconfig"")\n\n        assert len(caplog.records) == 1\n        assert caplog.records[0].message == ""No PennyLane configuration file found.""\n\n    def test_save(self, tmp_path):\n        """"""Test saving a configuration file.""""""\n        config = Configuration(name=config_filename)\n\n        # make a change\n        config[\'strawberryfields.global\'][\'shots\'] = 10\n\n        temp_config_path = tmp_path / \'test_config.toml\'\n        config.save(temp_config_path)\n\n        result = toml.load(temp_config_path)\n        config._config == result\n\nclass TestProperties:\n    """"""Test that the configuration class works as expected""""""\n\n    def test_get_item(self, default_config):\n        """"""Test getting items.""""""\n        # get existing options\n        assert default_config[\'main.shots\'] == 1000\n        assert default_config[\'main\'][\'shots\'] == 1000\n        assert default_config[\'strawberryfields.global.hbar\'] == 1\n        assert default_config[\'strawberryfields.global\'][\'hbar\'] == 1\n\n        # get nested dictionaries\n        assert default_config[\'strawberryfields.fock\'] == {\'cutoff_dim\': 10}\n\n        # get key that doesn\'t exist\n        assert default_config[\'qiskit.ibmq.idonotexist\'] == {}\n\n    def test_set_item(self, default_config):\n        """"""Test setting items.""""""\n\n        # set existing options\n        default_config[\'main.shots\'] = 10\n        assert default_config[\'main.shots\'] == 10\n        assert default_config[\'main\'][\'shots\'] == 10\n\n        default_config[\'strawberryfields.global\'][\'hbar\'] = 5\n        assert default_config[\'strawberryfields.global.hbar\'] == 5\n        assert default_config[\'strawberryfields.global\'][\'hbar\'] == 5\n\n        # set new options\n        default_config[\'qiskit.ibmq\'][\'backend\'] = \'ibmq_rome\'\n        assert default_config[\'qiskit.ibmq.backend\'] == \'ibmq_rome\'\n\n        # set nested dictionaries\n        default_config[\'strawberryfields.tf\'] = {\'batched\': True, \'cutoff_dim\': 6}\n        assert default_config[\'strawberryfields.tf\'] == {\'batched\': True, \'cutoff_dim\': 6}\n\n        # set nested keys that don\'t exist dictionaries\n        default_config[\'strawberryfields.another.hello.world\'] = 5\n        assert default_config[\'strawberryfields.another\'] == {\'hello\': {\'world\': 5}}\n\n    def test_bool(self, default_config):\n        """"""Test boolean value of the Configuration object.""""""\n\n        # test false if no config is loaded\n        config = Configuration(\'noconfig\')\n\n        assert not config\n        assert default_config\n\nclass TestPennyLaneInit:\n    """"""Tests to ensure that the code in PennyLane/__init__.py\n    correctly knows how to load and use configuration data""""""\n\n    def test_device_load(self, default_config):\n        """"""Test loading a device with a configuration.""""""\n        dev = qml.device(\'default.gaussian\', wires=2, config=default_config)\n\n        assert dev.hbar == 2\n        assert dev.shots == 1000\n'"
tests/test_device.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`Device` class.\n""""""\n\nimport pytest\nimport pennylane as qml\nfrom pennylane import Device, DeviceError\nfrom pennylane.qnodes import QuantumFunctionError\n\nmock_device_paulis = [""PauliX"", ""PauliY"", ""PauliZ""]\n\n# pylint: disable=abstract-class-instantiated, no-self-use, redefined-outer-name, invalid-name\n\n@pytest.fixture(scope=""function"")\ndef mock_device_with_operations(monkeypatch):\n    """"""A mock instance of the abstract Device class with non-empty operations""""""\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'operations\', mock_device_paulis)\n        m.setattr(Device, \'observables\', mock_device_paulis)\n        m.setattr(Device, \'short_name\', \'MockDevice\')\n        yield Device()\n\n\n@pytest.fixture(scope=""function"")\ndef mock_device_with_observables(monkeypatch):\n    """"""A mock instance of the abstract Device class with non-empty observables""""""\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'operations\', mock_device_paulis)\n        m.setattr(Device, \'observables\', mock_device_paulis)\n        m.setattr(Device, \'short_name\', \'MockDevice\')\n        yield Device()\n\n\n@pytest.fixture(scope=""function"")\ndef mock_device_supporting_paulis(monkeypatch):\n    """"""A mock instance of the abstract Device class with non-empty observables""""""\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'operations\', mock_device_paulis)\n        m.setattr(Device, \'observables\', mock_device_paulis)\n        m.setattr(Device, \'short_name\', \'MockDevice\')\n        yield Device()\n\n\n@pytest.fixture(scope=""function"")\ndef mock_device_supporting_paulis_and_inverse(monkeypatch):\n    """"""A mock instance of the abstract Device class with non-empty operations\n    and supporting inverses""""""\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'operations\', mock_device_paulis)\n        m.setattr(Device, \'observables\', mock_device_paulis)\n        m.setattr(Device, \'short_name\', \'MockDevice\')\n        m.setattr(Device, \'_capabilities\', {""inverse_operations"": True})\n        yield Device()\n\n@pytest.fixture(scope=""function"")\ndef mock_device_supporting_observables_and_inverse(monkeypatch):\n    """"""A mock instance of the abstract Device class with non-empty operations\n    and supporting inverses""""""\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'operations\', mock_device_paulis)\n        m.setattr(Device, \'observables\', mock_device_paulis + [\'Hermitian\'])\n        m.setattr(Device, \'short_name\', \'MockDevice\')\n        m.setattr(Device, \'_capabilities\', {""inverse_operations"": True})\n        yield Device()\n\nmock_device_capabilities = {\n    ""measurements"": ""everything"",\n    ""noise_models"": [""depolarizing"", ""bitflip""],\n}\n\n\n@pytest.fixture(scope=""function"")\ndef mock_device_with_capabilities(monkeypatch):\n    """"""A mock instance of the abstract Device class with non-empty observables""""""\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'_capabilities\', mock_device_capabilities)\n        yield Device()\n\n\n@pytest.fixture(scope=""function"")\ndef mock_device_with_paulis_and_methods(monkeypatch):\n    """"""A mock instance of the abstract Device class with non-empty observables""""""\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'_capabilities\', mock_device_capabilities)\n        m.setattr(Device, \'operations\', mock_device_paulis)\n        m.setattr(Device, \'observables\', mock_device_paulis)\n        m.setattr(Device, \'short_name\', \'MockDevice\')\n        m.setattr(Device, \'expval\', lambda self, x, y, z: 0)\n        m.setattr(Device, \'var\', lambda self, x, y, z: 0)\n        m.setattr(Device, \'sample\', lambda self, x, y, z: 0)\n        m.setattr(Device, \'apply\', lambda self, x, y, z: None)\n        yield Device()\n\n\n@pytest.fixture(scope=""function"")\ndef mock_device(monkeypatch):\n    with monkeypatch.context() as m:\n        m.setattr(Device, \'__abstractmethods__\', frozenset())\n        m.setattr(Device, \'_capabilities\', mock_device_capabilities)\n        m.setattr(Device, \'operations\', [""PauliY"", ""RX"", ""Rot""])\n        m.setattr(Device, \'observables\', [""PauliZ""])\n        m.setattr(Device, \'short_name\', \'MockDevice\')\n        m.setattr(Device, \'expval\', lambda self, x, y, z: 0)\n        m.setattr(Device, \'var\', lambda self, x, y, z: 0)\n        m.setattr(Device, \'sample\', lambda self, x, y, z: 0)\n        m.setattr(Device, \'apply\', lambda self, x, y, z: None)\n        yield Device()\n\n\nclass TestDeviceSupportedLogic:\n    """"""Test the logic associated with the supported operations and observables""""""\n\n    # pylint: disable=no-self-use, redefined-outer-name\n\n    def test_supports_operation_argument_types(self, mock_device_with_operations):\n        """"""Checks that device.supports_operations returns the correct result\n           when passed both string and Operation class arguments""""""\n\n        assert mock_device_with_operations.supports_operation(""PauliX"")\n        assert mock_device_with_operations.supports_operation(qml.PauliX)\n\n        assert not mock_device_with_operations.supports_operation(""S"")\n        assert not mock_device_with_operations.supports_operation(qml.CNOT)\n\n    def test_supports_observable_argument_types(self, mock_device_with_observables):\n        """"""Checks that device.supports_observable returns the correct result\n           when passed both string and Operation class arguments""""""\n\n        assert mock_device_with_observables.supports_observable(""PauliX"")\n        assert mock_device_with_observables.supports_observable(qml.PauliX)\n\n        assert not mock_device_with_observables.supports_observable(""Identity"")\n        assert not mock_device_with_observables.supports_observable(qml.Identity)\n\n    def test_supports_obeservable_inverse(self, mock_device_supporting_paulis_and_inverse):\n\n        assert mock_device_supporting_paulis_and_inverse.supports_observable(""PauliX.inv"")\n        assert not mock_device_supporting_paulis_and_inverse.supports_observable(""Identity.inv"")\n\n    def test_supports_obeservable_raise_error_hermitian_inverse(self, mock_device_supporting_observables_and_inverse):\n\n        assert mock_device_supporting_observables_and_inverse.supports_observable(""PauliX"")\n        assert mock_device_supporting_observables_and_inverse.supports_observable(""PauliX.inv"")\n        assert mock_device_supporting_observables_and_inverse.supports_observable(""Hermitian"")\n\n        assert not mock_device_supporting_observables_and_inverse.supports_observable(""Hermitian.inv"")\n\n    def test_supports_operation_exception(self, mock_device):\n        """"""check that device.supports_operation raises proper errors\n           if the argument is of the wrong type""""""\n\n        with pytest.raises(\n                ValueError,\n                match=""The given operation must either be a pennylane.Operation class or a string."",\n        ):\n            mock_device.supports_operation(3)\n\n        with pytest.raises(\n                ValueError,\n                match=""The given operation must either be a pennylane.Operation class or a string."",\n        ):\n            mock_device.supports_operation(Device)\n\n    def test_supports_observable_exception(self, mock_device):\n        """"""check that device.supports_observable raises proper errors\n           if the argument is of the wrong type""""""\n\n        with pytest.raises(\n                ValueError,\n                match=""The given observable must either be a pennylane.Observable class or a string."",\n        ):\n            mock_device.supports_observable(3)\n\n        operation = qml.CNOT\n\n        with pytest.raises(\n                ValueError,\n                match=""The given observable must either be a pennylane.Observable class or a string."",\n        ):\n            mock_device.supports_observable(operation)\n\n\nclass TestInternalFunctions:\n    """"""Test the internal functions of the abstract Device class""""""\n\n    def test_check_validity_on_valid_queue(self, mock_device_supporting_paulis):\n        """"""Tests the function Device.check_validity with valid queue and observables""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [qml.expval(qml.PauliZ(0))]\n\n        # Raises an error if queue or observables are invalid\n        mock_device_supporting_paulis.check_validity(queue, observables)\n\n    def test_check_validity_on_valid_queue_with_inverses(self,\n                                                         mock_device_supporting_paulis_and_inverse):\n        """"""Tests the function Device.check_validity with valid queue\n        and the inverse of operations""""""\n        queue = [\n            qml.PauliX(wires=0).inv(),\n            qml.PauliY(wires=1).inv(),\n            qml.PauliZ(wires=2).inv(),\n\n            qml.PauliX(wires=0).inv().inv(),\n            qml.PauliY(wires=1).inv().inv(),\n            qml.PauliZ(wires=2).inv().inv(),\n        ]\n\n        observables = [qml.expval(qml.PauliZ(0))]\n\n        # Raises an error if queue or observables are invalid\n        mock_device_supporting_paulis_and_inverse.check_validity(queue, observables)\n\n    def test_check_validity_with_not_supported_operation_inverse(self, mock_device_supporting_paulis_and_inverse):\n        """"""Tests the function Device.check_validity with an valid queue\n        and the inverse of not supported operations""""""\n        queue = [\n            qml.CNOT(wires=[0, 1]).inv(),\n        ]\n\n        observables = [qml.expval(qml.PauliZ(0))]\n\n        with pytest.raises(\n                DeviceError,\n                match=""Gate {} not supported on device {}"".format(""CNOT"", \'MockDevice\'),\n        ):\n            mock_device_supporting_paulis_and_inverse.check_validity(queue, observables)\n\n    def test_check_validity_on_tensor_support(self, mock_device_supporting_paulis):\n        """"""Tests the function Device.check_validity with tensor support capability""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [qml.expval(qml.PauliZ(0) @ qml.PauliX(1))]\n\n        # mock device does not support Tensor product\n        with pytest.raises(DeviceError, match=""Tensor observables not supported""):\n            mock_device_supporting_paulis.check_validity(queue, observables)\n\n    def test_check_validity_on_invalid_observable_with_tensor_support(self, monkeypatch):\n        """"""Tests the function Device.check_validity with tensor support capability\n        but with an invalid observable""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [qml.expval(qml.PauliZ(0) @ qml.Hadamard(1))]\n\n        D = Device\n        with monkeypatch.context() as m:\n            m.setattr(D, \'__abstractmethods__\', frozenset())\n            m.setattr(D, \'operations\', [""PauliX"", ""PauliY"", ""PauliZ""])\n            m.setattr(D, \'observables\', [""PauliX"", ""PauliY"", ""PauliZ""])\n            m.setattr(D, \'capabilities\', lambda self: {""tensor_observables"": True})\n            m.setattr(D, \'short_name\', ""Dummy"")\n\n            dev = D()\n\n            # mock device supports Tensor products but not hadamard\n            with pytest.raises(DeviceError, match=""Observable Hadamard not supported""):\n                dev.check_validity(queue, observables)\n\n    def test_check_validity_on_invalid_queue(self, mock_device_supporting_paulis):\n        """"""Tests the function Device.check_validity with invalid queue and valid observables""""""\n        queue = [\n            qml.RX(1.0, wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [qml.expval(qml.PauliZ(0))]\n\n        with pytest.raises(DeviceError, match=""Gate RX not supported on device""):\n            mock_device_supporting_paulis.check_validity(queue, observables)\n\n    def test_check_validity_on_invalid_observable(self, mock_device_supporting_paulis):\n        """"""Tests the function Device.check_validity with valid queue and invalid observables""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [qml.expval(qml.Hadamard(0))]\n\n        with pytest.raises(DeviceError, match=""Observable Hadamard not supported on device""):\n            mock_device_supporting_paulis.check_validity(queue, observables)\n\n    def test_check_validity_on_invalid_queue_of_inverses(self, mock_device_supporting_paulis_and_inverse):\n        """"""Tests the function Device.check_validity with invalid queue and valid inverses of operations""""""\n        queue = [\n            qml.PauliY(wires=1).inv(),\n            qml.PauliZ(wires=2).inv(),\n            qml.RX(1.0, wires=0).inv(),\n        ]\n\n        observables = [qml.expval(qml.PauliZ(0))]\n\n        with pytest.raises(DeviceError, match=""Gate RX not supported on device""):\n            mock_device_supporting_paulis_and_inverse.check_validity(queue, observables)\n\n    def test_supports_inverse(self, mock_device_supporting_paulis_and_inverse):\n        """"""Tests the function Device.supports_inverse on device which supports inverses""""""\n        assert mock_device_supporting_paulis_and_inverse.check_validity([qml.PauliZ(0).inv()], []) is None\n        assert mock_device_supporting_paulis_and_inverse.check_validity([], [qml.PauliZ(0).inv()]) is None\n\n    def test_supports_inverse_device_does_not_support_inverses(self, mock_device_supporting_paulis):\n        """"""Tests the function Device.supports_inverse on device which does not support inverses""""""\n        with pytest.raises(DeviceError, match=""The inverse of gates are not supported on device {}"".\n                format(mock_device_supporting_paulis.short_name)):\n            mock_device_supporting_paulis.check_validity([qml.PauliZ(0).inv()], [])\n\n        with pytest.raises(DeviceError, match=""The inverse of gates are not supported on device {}"".\n                format(mock_device_supporting_paulis.short_name)):\n            mock_device_supporting_paulis.check_validity([], [qml.PauliZ(0).inv()])\n\n    def test_args(self, mock_device):\n        """"""Test that the device requires correct arguments""""""\n        with pytest.raises(qml.DeviceError, match=""specified number of shots needs to be at least 1""):\n            Device(mock_device, shots=0)\n\nclass TestClassmethods:\n    """"""Test the classmethods of Device""""""\n\n    def test_capabilities(self, mock_device_with_capabilities):\n        """"""check that device can give a dict of further capabilities""""""\n\n        assert mock_device_with_capabilities.capabilities() == mock_device_capabilities\n\n\nclass TestOperations:\n    """"""Tests the logic related to operations""""""\n\n    def test_shots_setter(self, mock_device):\n        """"""Tests that the property setter of shots changes the number of shots.""""""\n\n        assert mock_device._shots == 1000\n\n        mock_device.shots = 10\n\n        assert mock_device._shots == 10\n\n    @pytest.mark.parametrize(""shots"", [-10, 0])\n    def test_shots_setter_error(self, mock_device, shots):\n        """"""Tests that the property setter of shots raises an error if the requested number of shots\n        is erroneous.""""""\n\n        with pytest.raises(qml.DeviceError, match=""The specified number of shots needs to be at least 1""):\n            mock_device.shots = shots\n\n    def test_op_queue_accessed_outside_execution_context(self, mock_device):\n        """"""Tests that a call to op_queue outside the execution context raises the correct error""""""\n\n        with pytest.raises(\n                ValueError, match=""Cannot access the operation queue outside of the execution context!""\n        ):\n            mock_device.op_queue\n\n    def test_op_queue_is_filled_at_pre_measure(self, mock_device_with_paulis_and_methods, monkeypatch):\n        """"""Tests that the op_queue is correctly filled when pre_measure is called and that accessing\n           op_queue raises no error""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [\n            qml.expval(qml.PauliZ(0)),\n            qml.var(qml.PauliZ(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        queue_at_pre_measure = []\n\n        with monkeypatch.context() as m:\n            m.setattr(Device, \'pre_measure\', lambda self: queue_at_pre_measure.extend(self.op_queue))\n            mock_device_with_paulis_and_methods.execute(queue, observables)\n\n        assert queue_at_pre_measure == queue\n\n    def test_op_queue_is_filled_during_execution(self, mock_device_with_paulis_and_methods, monkeypatch):\n        """"""Tests that the operations are properly applied and queued""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [\n            qml.expval(qml.PauliZ(0)),\n            qml.var(qml.PauliZ(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        call_history = []\n        with monkeypatch.context() as m:\n            m.setattr(Device, \'apply\', lambda self, op, wires, params: call_history.append([op, wires, params]))\n            mock_device_with_paulis_and_methods.execute(queue, observables)\n\n        assert call_history[0] == [""PauliX"", [0], []]\n        assert call_history[1] == [""PauliY"", [1], []]\n        assert call_history[2] == [""PauliZ"", [2], []]\n\n    def test_unsupported_operations_raise_error(self, mock_device_with_paulis_and_methods):\n        """"""Tests that the operations are properly applied and queued""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.Hadamard(wires=2),\n        ]\n\n        observables = [\n            qml.expval(qml.PauliZ(0)),\n            qml.var(qml.PauliZ(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        with pytest.raises(DeviceError, match=""Gate Hadamard not supported on device""):\n            mock_device_with_paulis_and_methods.execute(queue, observables)\n\n\nclass TestObservables:\n    """"""Tests the logic related to observables""""""\n\n    # pylint: disable=no-self-use, redefined-outer-name\n\n    def test_obs_queue_accessed_outside_execution_context(self, mock_device):\n        """"""Tests that a call to op_queue outside the execution context raises the correct error""""""\n\n        with pytest.raises(\n                ValueError,\n                match=""Cannot access the observable value queue outside of the execution context!"",\n        ):\n            mock_device.obs_queue\n\n    def test_obs_queue_is_filled_at_pre_measure(self, mock_device_with_paulis_and_methods, monkeypatch):\n        """"""Tests that the op_queue is correctly filled when pre_measure is called and that accessing\n           op_queue raises no error""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [\n            qml.expval(qml.PauliZ(0)),\n            qml.var(qml.PauliZ(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        queue_at_pre_measure = []\n\n        with monkeypatch.context() as m:\n            m.setattr(Device, \'pre_measure\', lambda self: queue_at_pre_measure.extend(self.obs_queue))\n            mock_device_with_paulis_and_methods.execute(queue, observables)\n\n        assert queue_at_pre_measure == observables\n\n    def test_obs_queue_is_filled_during_execution(self, monkeypatch, mock_device_with_paulis_and_methods):\n        """"""Tests that the operations are properly applied and queued""""""\n        observables = [\n            qml.expval(qml.PauliX(0)),\n            qml.var(qml.PauliY(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        # capture the arguments passed to dev methods\n        expval_args = []\n        var_args = []\n        sample_args = []\n        with monkeypatch.context() as m:\n            m.setattr(Device, \'expval\', lambda self, *args: expval_args.extend(args))\n            m.setattr(Device, \'var\', lambda self, *args: var_args.extend(args))\n            m.setattr(Device, \'sample\', lambda self, *args: sample_args.extend(args))\n            mock_device_with_paulis_and_methods.execute([], observables)\n\n        assert expval_args == [""PauliX"", [0], []]\n        assert var_args == [""PauliY"", [1], []]\n        assert sample_args == [""PauliZ"", [2], []]\n\n    def test_unsupported_observables_raise_error(self, mock_device_with_paulis_and_methods):\n        """"""Tests that the operations are properly applied and queued""""""\n        queue = [\n            qml.PauliX(wires=0),\n            qml.PauliY(wires=1),\n            qml.PauliZ(wires=2),\n        ]\n\n        observables = [\n            qml.expval(qml.Hadamard(0)),\n            qml.var(qml.PauliZ(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        with pytest.raises(DeviceError, match=""Observable Hadamard not supported on device""):\n            mock_device_with_paulis_and_methods.execute(queue, observables)\n\n    def test_unsupported_observable_return_type_raise_error(self, mock_device_with_paulis_and_methods):\n        """"""Check that an error is raised if the return type of an observable is unsupported""""""\n\n        queue = [qml.PauliX(wires=0)]\n\n        # Make a observable without specifying a return operation upon measuring\n        obs = qml.PauliZ(0)\n        obs.return_type = ""SomeUnsupportedReturnType""\n        observables = [obs]\n\n        with pytest.raises(QuantumFunctionError, match=""Unsupported return type specified for observable""):\n            mock_device_with_paulis_and_methods.execute(queue, observables)\n\n\nclass TestParameters:\n    """"""Test for checking device parameter mappings""""""\n\n    def test_parameters_accessed_outside_execution_context(self, mock_device):\n        """"""Tests that a call to parameters outside the execution context raises the correct error""""""\n\n        with pytest.raises(\n                ValueError,\n                match=""Cannot access the free parameter mapping outside of the execution context!"",\n        ):\n            mock_device.parameters\n\n    def test_parameters_available_at_pre_measure(self, mock_device, monkeypatch):\n        """"""Tests that the parameter mapping is available when pre_measure is called and that accessing\n           Device.parameters raises no error""""""\n\n        p0 = 0.54\n        p1 = -0.32\n\n        queue = [\n            qml.RX(p0, wires=0),\n            qml.PauliY(wires=1),\n            qml.Rot(0.432, 0.123, p1, wires=2),\n        ]\n\n        parameters = {0: (0, 0), 1: (2, 3)}\n\n        observables = [\n            qml.expval(qml.PauliZ(0)),\n            qml.var(qml.PauliZ(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        p_mapping = {}\n\n        with monkeypatch.context() as m:\n            m.setattr(Device, ""pre_measure"", lambda self: p_mapping.update(self.parameters))\n            mock_device.execute(queue, observables, parameters=parameters)\n\n        assert p_mapping == parameters\n\n\nclass TestDeviceInit:\n    """"""Tests for device loader in __init__.py""""""\n\n    def test_no_device(self):\n        """"""Test that an exception is raised for a device that doesn\'t exist""""""\n\n        with pytest.raises(DeviceError, match=""Device does not exist""):\n            qml.device(""None"", wires=0)\n\n    def test_outdated_API(self, monkeypatch):\n        """"""Test that an exception is raised if plugin that targets an old API is loaded""""""\n\n        with monkeypatch.context() as m:\n            m.setattr(qml, ""version"", lambda: ""0.0.1"")\n            with pytest.raises(DeviceError, match=""plugin requires PennyLane versions""):\n                qml.device(""default.qubit"", wires=0)\n'"
tests/test_hermitian_edge_cases.py,0,"b'import itertools\nimport pytest\nimport numpy as np\nfrom scipy.linalg import block_diag\n\nimport pennylane as qml\nfrom pennylane.qnodes.qubit import QubitQNode\nfrom pennylane.qnodes.base import QuantumFunctionError\nfrom gate_data import Y, Z\n\n\nTHETA = np.linspace(0.11, 1, 3)\nPHI = np.linspace(0.32, 1, 3)\nVARPHI = np.linspace(0.02, 1, 3)\n\n\n@pytest.mark.parametrize(""analytic"", [True, False])\n@pytest.mark.parametrize(""theta,phi,varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestEdgeHermitian:\n    def test_hermitian_two_wires_identity_expectation_only_hermitian(\n        self, analytic, theta, phi, varphi\n    ):\n        """"""Test that a tensor product involving an Hermitian matrix for two wires and the identity works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=1000000)\n\n        A = np.array(\n            [[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]]\n        )\n\n        Identity = np.array([[1, 0], [0, 1]])\n        obs = np.kron(np.kron(Identity, Identity), A)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RY(theta, wires=[0])\n            qml.RY(phi, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.Hermitian(obs, wires=[2, 1, 0]))\n\n        res = circuit()\n\n        a = A[0, 0]\n        re_b = A[0, 1].real\n        d = A[1, 1]\n\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\n        assert np.allclose(res, expected, atol=0.01, rtol=0)\n\n    def test_hermitian_two_wires_identity_expectation_with_tensor(\n        self, analytic, theta, phi, varphi\n    ):\n        """"""Test that a tensor product involving an Hermitian matrix for two wires and the identity works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=1000000)\n\n        A = np.array(\n            [[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]]\n        )\n\n        Identity = np.array([[1, 0], [0, 1]])\n        obs = np.kron(Identity, A)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RY(theta, wires=[0])\n            qml.RY(phi, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.Hermitian(obs, wires=[2, 0]) @ qml.Identity(1))\n\n        res = circuit()\n\n        a = A[0, 0]\n        re_b = A[0, 1].real\n        d = A[1, 1]\n\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\n        assert np.allclose(res, expected, atol=0.01, rtol=0)\n\n    @pytest.mark.parametrize(""w1, w2"", list(itertools.permutations(range(4), 2)))\n    def test_hermitian_two_wires_permuted(self, w1, w2, analytic, theta, phi, varphi):\n        """"""Test that an hermitian expectation with various wires permuted works""""""\n        dev = qml.device(""default.qubit"", wires=4, shots=1000000, analytic=analytic)\n        theta = 0.543\n\n        A = np.array(\n            [\n                [1, 2j, 1 - 2j, 0.5j],\n                [-2j, 0, 3 + 4j, 1],\n                [1 + 2j, 3 - 4j, 0.75, 1.5 - 2j],\n                [-0.5j, 1, 1.5 + 2j, -1],\n            ]\n        )\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RX(theta, wires=[w1])\n            qml.RY(2 * theta, wires=[w2])\n            qml.CNOT(wires=[w1, w2])\n            return qml.expval(qml.Hermitian(A, wires=[w1, w2]))\n\n        res = circuit()\n\n        # make sure the mean matches the analytic mean\n        expected = (\n            88 * np.sin(theta)\n            + 24 * np.sin(2 * theta)\n            - 40 * np.sin(3 * theta)\n            + 5 * np.cos(theta)\n            - 6 * np.cos(2 * theta)\n            + 27 * np.cos(3 * theta)\n            + 6\n        ) / 32\n\n        assert np.allclose(res, expected, atol=0.01, rtol=0)\n'"
tests/test_init.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.init` module.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport pytest\nimport numpy as np\nimport pennylane as qml\n\n\n#######################################\n# Functions and their signatures\n\n# Functions returning a single parameter array\n# function name, kwargs and target shape\nINIT_KWARGS_SHAPES = [(qml.init.random_layers_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'n_rots\': 10, \'mean\': 0, \'std\': 1},\n                       (2, 10)),\n                      (qml.init.random_layers_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'n_rots\': 10, \'mean\': 0, \'std\': 1},\n                       (2, 10)),\n                      (qml.init.random_layers_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'n_rots\': None, \'mean\': 0, \'std\': 1},\n                       (2, 3)),\n                      (qml.init.strong_ent_layers_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3, 3)),\n                      (qml.init.strong_ent_layers_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1, 3)),\n                      (qml.init.cvqnn_layers_theta_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_theta_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 0)),\n                      (qml.init.cvqnn_layers_phi_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_phi_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 0)),\n                      (qml.init.cvqnn_layers_varphi_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3),),\n                      (qml.init.cvqnn_layers_varphi_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1),),\n                      (qml.init.cvqnn_layers_r_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3),),\n                      (qml.init.cvqnn_layers_r_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1),),\n                      (qml.init.cvqnn_layers_phi_r_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3),),\n                      (qml.init.cvqnn_layers_phi_r_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1),),\n                      (qml.init.cvqnn_layers_a_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3),),\n                      (qml.init.cvqnn_layers_a_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1),),\n                      (qml.init.cvqnn_layers_phi_a_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3),),\n                      (qml.init.cvqnn_layers_phi_a_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1),),\n                      (qml.init.cvqnn_layers_kappa_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 3),),\n                      (qml.init.cvqnn_layers_kappa_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1),),\n                      (qml.init.interferometer_theta_normal,\n                       {\'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (3,)),\n                      (qml.init.interferometer_theta_normal,\n                       {\'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (0,)),\n                      (qml.init.interferometer_phi_normal,\n                       {\'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (3,)),\n                      (qml.init.interferometer_phi_normal,\n                       {\'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (0,)),\n                      (qml.init.interferometer_varphi_normal,\n                       {\'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (3,)),\n                      (qml.init.interferometer_varphi_normal,\n                       {\'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (1,)),\n                      (qml.init.random_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'n_rots\': 10, \'low\': 0, \'high\': 1},\n                       (2, 10)),\n                      (qml.init.random_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'n_rots\': None, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                       (qml.init.random_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'n_rots\': None, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.random_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'n_rots\': 10, \'low\': 0, \'high\': 1},\n                       (2, 10)),\n                      (qml.init.strong_ent_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3, 3)),\n                      (qml.init.strong_ent_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1, 3)),\n                      (qml.init.cvqnn_layers_theta_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_theta_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 0)),\n                      (qml.init.cvqnn_layers_phi_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_phi_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 0)),\n                      (qml.init.cvqnn_layers_varphi_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_varphi_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.cvqnn_layers_r_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_r_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.cvqnn_layers_phi_r_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_phi_r_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.cvqnn_layers_a_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_a_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.cvqnn_layers_phi_a_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_phi_a_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.cvqnn_layers_kappa_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.cvqnn_layers_kappa_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.interferometer_theta_uniform,\n                       {\'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (3,)),\n                      (qml.init.interferometer_theta_uniform,\n                       {\'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (0,)),\n                      (qml.init.interferometer_phi_uniform,\n                       {\'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (3,)),\n                      (qml.init.interferometer_phi_uniform,\n                       {\'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (0,)),\n                      (qml.init.interferometer_varphi_uniform,\n                       {\'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (3,)),\n                      (qml.init.interferometer_varphi_uniform,\n                       {\'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (1,)),\n                      (qml.init.qaoa_embedding_normal,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (2, 2*3)),\n                      (qml.init.qaoa_embedding_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (2, 2*3)),\n                      (qml.init.qaoa_embedding_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.qaoa_embedding_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 2, \'low\': 0, \'high\': 1},\n                       (2, 3)),\n                      (qml.init.qaoa_embedding_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1)),\n                      (qml.init.qaoa_embedding_normal,\n                       {\'n_layers\': 2, \'n_wires\': 2, \'mean\': 0, \'std\': 1},\n                       (2, 3)),\n                      (qml.init.simplified_two_design_initial_layer_uniform,\n                       {\'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (1,)),\n                      (qml.init.simplified_two_design_initial_layer_uniform,\n                       {\'n_wires\': 3, \'low\': 0, \'high\': 1},\n                       (3,)),\n                      (qml.init.simplified_two_design_initial_layer_normal,\n                       {\'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (1,)),\n                      (qml.init.simplified_two_design_initial_layer_normal,\n                       {\'n_wires\': 3, \'mean\': 0, \'std\': 1},\n                       (3,)),\n                      (qml.init.simplified_two_design_weights_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (0,)),\n                      (qml.init.simplified_two_design_weights_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 2, \'low\': 0, \'high\': 1},\n                       (2, 1, 2)),\n                      (qml.init.simplified_two_design_weights_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 4, \'low\': 0, \'high\': 1},\n                       (2, 3, 2)),\n                      (qml.init.simplified_two_design_weights_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (0, )),\n                      (qml.init.simplified_two_design_weights_normal,\n                       {\'n_layers\': 2, \'n_wires\': 2, \'mean\': 0, \'std\': 1},\n                       (2, 1, 2)),\n                      (qml.init.simplified_two_design_weights_normal,\n                       {\'n_layers\': 2, \'n_wires\': 4, \'mean\': 0, \'std\': 1},\n                       (2, 3, 2)),\n                      (qml.init.basic_entangler_layers_normal,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'mean\': 0, \'std\': 1},\n                       (2, 1)),\n                      (qml.init.basic_entangler_layers_normal,\n                       {\'n_layers\': 2, \'n_wires\': 2, \'mean\': 0, \'std\': 1},\n                       (2, 2)),\n                      (qml.init.basic_entangler_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 1, \'low\': 0, \'high\': 1},\n                       (2, 1)),\n                      (qml.init.basic_entangler_layers_uniform,\n                       {\'n_layers\': 2, \'n_wires\': 2, \'low\': 0, \'high\': 1},\n                       (2, 2)),\n                      ]\n# Functions returning a list of parameter arrays\nINITALL_KWARGS_SHAPES = [(qml.init.cvqnn_layers_all, {\'n_layers\': 2, \'n_wires\': 3},\n                          [(2, 3)]*11),\n                         (qml.init.interferometer_all, {\'n_wires\': 3}, [(3,), (3,), (3,)])]\n\n# Without target shapes\nINIT_KWARGS = [i[0:2] for i in INIT_KWARGS_SHAPES]\n\n#################\n\n\nclass TestInit:\n    """"""Tests the initialization functions from the ``init`` module.""""""\n\n    @pytest.mark.parametrize(""init, sgntr, shp"", INIT_KWARGS_SHAPES)\n    def test_shape(self, init, sgntr, shp, seed):\n        """"""Confirm that initialization functions\n         return an array with the correct shape.""""""\n        s = {**sgntr, \'seed\': seed}\n        p = init(**s)\n        assert p.shape == shp\n\n    @pytest.mark.parametrize(""init, sgntr, shp"", INITALL_KWARGS_SHAPES)\n    def test_all_shape(self, init, sgntr, shp, seed):\n        """"""Confirm that ``all`` initialization functions\n         return an array with the correct shape.""""""\n\n        s = {**sgntr, \'seed\': seed}\n        p = init(**s)\n        shapes = [p_.shape for p_ in p]\n        assert shapes == shp\n\n    @pytest.mark.parametrize(""init, sgntr"", INIT_KWARGS)\n    def test_same_output_for_same_seed(self, init, sgntr, seed, tol):\n        """"""Confirm that initialization functions return a deterministic output\n        for a fixed seed.""""""\n\n        # exclude case of empty parameter list\n        if len(init(**sgntr).flatten()) == 0:\n            pytest.skip(""test is skipped for empty parameter array"")\n\n        s = {**sgntr, \'seed\': seed}\n        p1 = init(**s)\n        p2 = init(**s)\n        assert np.allclose(p1, p2, atol=tol)\n\n    @pytest.mark.parametrize(""init, sgntr"", INIT_KWARGS)\n    def test_diff_output_for_diff_seed(self, init, sgntr, seed, tol):\n        """"""Confirm that initialization function returns a different output for\n        different seeds.""""""\n\n        # exclude case of empty parameter list\n        if len(init(**sgntr).flatten()) == 0:\n            pytest.skip(""test is skipped for empty parameter array"")\n\n        s = {**sgntr, \'seed\': seed}\n        p1 = init(**s)\n        s = {**s, \'seed\': seed + 1}\n        p2 = init(**s)\n\n        if p1.shape != (0,):\n            assert not np.allclose(p1, p2, atol=tol)\n\n    @pytest.mark.parametrize(""init, sgntr"", INIT_KWARGS)\n    def test_interval(self, init, sgntr, seed, tol):\n        """"""Test that sampled parameters lie in correct interval.""""""\n\n        # exclude case of empty parameter list\n        if len(init(**sgntr).flatten()) == 0:\n            pytest.skip(""test is skipped for empty parameter array"")\n\n        s = {**sgntr, \'seed\': seed}\n\n        # Case A: Uniformly distributed parameters\n        if \'low\' in s.keys() and \'high\' in s.keys():\n            s[\'low\'] = 1\n            s[\'high\'] = 1\n            p = init(**s)\n            p_mean = np.mean(p)\n            assert np.isclose(p_mean, 1, atol=tol)\n\n        # Case B: Normally distributed parameters\n        if \'mean\' in s.keys() and \'std\' in s.keys():\n            s[\'mean\'] = 1\n            s[\'std\'] = 0\n\n        p = init(**s)\n        p_mean = np.mean(p)\n        assert np.isclose(p_mean, 1, atol=tol)\n\n    @pytest.mark.parametrize(""init, sgntr"", INIT_KWARGS)\n    def test_zero_wires(self, init, sgntr):\n        """"""Test that edge case of zero wires returns empty parameter array.""""""\n\n        if ""n_wires"" in sgntr:\n            sgntr[""n_wires""] = 0\n\n        p = init(**sgntr)\n\n        assert p.flatten().shape == (0,)\n'"
tests/test_io.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.io` module.\n""""""\nimport pytest\nfrom unittest.mock import Mock\n\nimport pennylane as qml\n\n\nclass MockPluginConverter:\n    """"""Mocks a real plugin converter entry point.""""""\n\n    def __init__(self, name):\n        self.name = name\n        self.mock_loader = Mock()\n\n    def load(self):\n        """"""Return the mocked loader function.""""""\n        return self.mock_loader\n\n    @property\n    def called(self):\n        """"""True if the mocked loader was called.""""""\n        return self.mock_loader.called\n\n    @property\n    def last_args(self):\n        """"""The last call arguments of the mocked loader.""""""\n        return self.mock_loader.call_args[0]\n\n\nload_entry_points = [""qiskit"", ""qasm"", ""qasm_file"", ""pyquil_program"", ""quil"", ""quil_file""]\n\n\n@pytest.fixture\ndef mock_plugin_converters(monkeypatch):\n    mock_plugin_converter_dict = {\n        entry_point: MockPluginConverter(entry_point) for entry_point in load_entry_points\n    }\n    monkeypatch.setattr(qml.io, ""plugin_converters"", mock_plugin_converter_dict)\n\n    yield mock_plugin_converter_dict\n\n\nclass TestLoad:\n    """"""Test that the convenience load functions access the correct entrypoint.""""""\n\n    def test_converter_does_not_exist(self):\n        """"""Test that the proper error is raised if the converter does not exist.""""""\n        with pytest.raises(\n            ValueError, match=""Converter does not exist. Make sure the required plugin is installed""\n        ):\n            qml.load(""Test"", format=""some_non_existing_format"")\n\n    @pytest.mark.parametrize(\n        ""method,entry_point_name"",\n        [\n            (qml.from_qiskit, ""qiskit""),\n            (qml.from_qasm, ""qasm""),\n            (qml.from_qasm_file, ""qasm_file""),\n            (qml.from_pyquil, ""pyquil_program""),\n            (qml.from_quil, ""quil""),\n            (qml.from_quil_file, ""quil_file""),\n        ],\n    )\n    def test_convenience_functions(self, method, entry_point_name, mock_plugin_converters):\n        """"""Test that the convenience load functions access the correct entrypoint.""""""\n\n        res = method(""Test"")\n\n        assert mock_plugin_converters[entry_point_name].called\n        assert mock_plugin_converters[entry_point_name].last_args == (""Test"",)\n\n        for plugin_converter in mock_plugin_converters:\n            if plugin_converter == entry_point_name:\n                continue\n\n            if mock_plugin_converters[plugin_converter].called:\n                raise Exception(\n                    ""The other plugin converter {} was called."".format(plugin_converter)\n                )\n'"
tests/test_measure.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Unit tests for the measure module""""""\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.qnodes import QuantumFunctionError\nfrom pennylane.operation import Sample, Variance, Expectation\n\n\ndef test_no_measure(tol):\n    """"""Test that failing to specify a measurement\n    raises an exception""""""\n    dev = qml.device(""default.qubit"", wires=2)\n\n    @qml.qnode(dev)\n    def circuit(x):\n        qml.RX(x, wires=0)\n        return qml.PauliY(0)\n\n    with pytest.raises(QuantumFunctionError, match=""does not have the measurement""):\n        res = circuit(0.65)\n\n\nclass TestExpval:\n    """"""Tests for the expval function""""""\n\n    def test_value(self, tol):\n        """"""Test that the expval interface works""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliY(0))\n\n        x = 0.54\n        res = circuit(x)\n        expected = -np.sin(x)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_not_an_observable(self):\n        """"""Test that a QuantumFunctionError is raised if the provided\n        argument is not an observable""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RX(0.52, wires=0)\n            return qml.expval(qml.CNOT(wires=[0, 1]))\n\n        with pytest.raises(QuantumFunctionError, match=""CNOT is not an observable""):\n            res = circuit()\n\n    def test_observable_return_type_is_expectation(self):\n        """"""Test that the return type of the observable is :attr:`ObservableReturnTypes.Expectation`""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            res = qml.expval(qml.PauliZ(0))\n            assert res.return_type is Expectation\n            return res\n\n        circuit()\n\n\nclass TestVar:\n    """"""Tests for the var function""""""\n\n    def test_value(self, tol):\n        """"""Test that the var function works""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.var(qml.PauliZ(0))\n\n        x = 0.54\n        res = circuit(x)\n        expected = np.sin(x)**2\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_not_an_observable(self):\n        """"""Test that a QuantumFunctionError is raised if the provided\n        argument is not an observable""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RX(0.52, wires=0)\n            return qml.var(qml.CNOT(wires=[0, 1]))\n\n        with pytest.raises(QuantumFunctionError, match=""CNOT is not an observable""):\n            res = circuit()\n\n    def test_observable_return_type_is_variance(self):\n        """"""Test that the return type of the observable is :attr:`ObservableReturnTypes.Variance`""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            res = qml.var(qml.PauliZ(0))\n            assert res.return_type is Variance\n            return res\n\n        circuit()\n\n\nclass TestSample:\n    """"""Tests for the sample function""""""\n\n    def test_sample_dimension(self, tol):\n        """"""Test that the sample function outputs samples of the right size""""""\n        n_sample = 10\n\n        dev = qml.device(""default.qubit"", wires=2, shots=n_sample)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RX(0.54, wires=0)\n            return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliX(1))\n\n        sample = circuit()\n\n        assert np.array_equal(sample.shape, (2,n_sample))\n\n    def test_sample_combination(self, tol):\n        """"""Test the output of combining expval, var and sample""""""\n        n_sample = 10\n\n        dev = qml.device(""default.qubit"", wires=3, shots=n_sample)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RX(0.54, wires=0)\n\n            return qml.sample(qml.PauliZ(0)), qml.expval(qml.PauliX(1)), qml.var(qml.PauliY(2))\n\n        result = circuit()\n\n        assert np.array_equal(result.shape, (3,))\n        assert np.array_equal(result[0].shape, (n_sample,))\n        assert isinstance(result[1], float)\n        assert isinstance(result[2], float)\n\n    def test_single_wire_sample(self, tol):\n        """"""Test the return type and shape of sampling a single wire""""""\n        n_sample = 10\n\n        dev = qml.device(""default.qubit"", wires=1, shots=n_sample)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RX(0.54, wires=0)\n\n            return qml.sample(qml.PauliZ(0))\n\n        result = circuit()\n\n        assert isinstance(result, np.ndarray)\n        assert np.array_equal(result.shape, (n_sample,))\n\n    def test_multi_wire_sample_regular_shape(self, tol):\n        """"""Test the return type and shape of sampling multiple wires\n           where a rectangular array is expected""""""\n        n_sample = 10\n\n        dev = qml.device(""default.qubit"", wires=3, shots=n_sample)\n\n        @qml.qnode(dev)\n        def circuit():\n            return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliZ(1)), qml.sample(qml.PauliZ(2))\n\n        result = circuit()\n\n        # If all the dimensions are equal the result will end up to be a proper rectangular array\n        assert isinstance(result, np.ndarray)\n        assert np.array_equal(result.shape, (3, n_sample))\n        assert result.dtype == np.dtype(""int"")\n\n    def test_sample_output_type_in_combination(self, tol):\n        """"""Test the return type and shape of sampling multiple works\n           in combination with expvals and vars""""""\n        n_sample = 10\n\n        dev = qml.device(""default.qubit"", wires=3, shots=n_sample)\n\n        @qml.qnode(dev)\n        def circuit():\n            return qml.expval(qml.PauliZ(0)), qml.var(qml.PauliZ(1)), qml.sample(qml.PauliZ(2))\n\n        result = circuit()\n\n        # If all the dimensions are equal the result will end up to be a proper rectangular array\n        assert isinstance(result, np.ndarray)\n        assert result.dtype == np.dtype(""object"")\n        assert np.array_equal(result.shape, (3,))\n        assert isinstance(result[0], float)\n        assert isinstance(result[1], float)\n        assert result[2].dtype == np.dtype(""int"")\n        assert np.array_equal(result[2].shape, (n_sample,))\n\n    def test_not_an_observable(self):\n        """"""Test that a QuantumFunctionError is raised if the provided\n        argument is not an observable""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.RX(0.52, wires=0)\n            return qml.sample(qml.CNOT(wires=[0, 1]))\n\n        with pytest.raises(QuantumFunctionError, match=""CNOT is not an observable""):\n            sample = circuit()\n\n    def test_observable_return_type_is_sample(self):\n        """"""Test that the return type of the observable is :attr:`ObservableReturnTypes.Sample`""""""\n        n_shots = 10\n        dev = qml.device(""default.qubit"", wires=1, shots=n_shots)\n\n        @qml.qnode(dev)\n        def circuit():\n            res = qml.sample(qml.PauliZ(0))\n            assert res.return_type is Sample\n            return res\n\n        circuit()\n'"
tests/test_numpy_wrapper.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nTests for the ``autograd.numpy`` wrapping functionality. This functionality\r\nmodifies Autograd NumPy arrays so that they have an additional property,\r\n``requires_grad``, that marks them as trainable/non-trainable.\r\n""""""\r\nimport numpy as onp\r\nimport pytest\r\n\r\nimport pennylane as qml\r\nfrom pennylane import numpy as np\r\n\r\n\r\nclass TestExtractTensors:\r\n    """"""Tests for the extract_tensors function""""""\r\n\r\n    def test_empty_terable(self):\r\n        """"""Test that an empty iterable returns nothing""""""\r\n        res = list(np.extract_tensors([]))\r\n        assert res == []\r\n\r\n    def test_iterable_with_strings(self):\r\n        """"""Test that strings are not treated as a sequence""""""\r\n        arr1 = np.array([0.4, 0.1])\r\n        arr2 = np.array([1])\r\n\r\n        res = list(np.extract_tensors([arr1, [""abc"", [arr2]]]))\r\n\r\n        assert len(res) == 2\r\n        assert res[0] is arr1\r\n        assert res[1] is arr2\r\n\r\n    def test_iterable_with_unpatched_numpy_arrays(self):\r\n        """"""Test that the extraction ignores unpatched numpy arrays""""""\r\n        arr1 = np.array([0.4, 0.1])\r\n        arr2 = np.array([1])\r\n\r\n        res = list(np.extract_tensors([arr1, [onp.array([1, 2]), [arr2]]]))\r\n\r\n        assert len(res) == 2\r\n        assert res[0] is arr1\r\n        assert res[1] is arr2\r\n\r\n\r\nclass TestTensor:\r\n    """"""Tests for the Tensor(ndarray) subclass""""""\r\n\r\n    def test_passing_requires_grad_arg(self):\r\n        """"""Test that you can instantiate the Tensor class with the\r\n        requires_grad argument""""""\r\n        # default value is true\r\n        x = np.tensor([0, 1, 2])\r\n        assert x.requires_grad\r\n\r\n        x = np.tensor([0, 1, 2], requires_grad=True)\r\n        assert x.requires_grad\r\n\r\n        x = np.tensor([0, 1, 2], requires_grad=False)\r\n        assert not x.requires_grad\r\n\r\n    def test_requires_grad_setter(self):\r\n        """"""Test that the value of requires_grad can be changed\r\n        on an instantiated object""""""\r\n        # default value is true\r\n        x = np.tensor([0, 1, 2])\r\n        assert x.requires_grad\r\n\r\n        x.requires_grad = False\r\n        assert not x.requires_grad\r\n\r\n    def test_string_representation(self, capsys):\r\n        """"""Test the string representation is correct""""""\r\n        x = np.tensor([0, 1, 2])\r\n        print(x.__repr__())\r\n        captured = capsys.readouterr()\r\n        assert ""tensor([0, 1, 2], requires_grad=True)"" in captured.out\r\n\r\n        x.requires_grad = False\r\n        print(x.__repr__())\r\n        captured = capsys.readouterr()\r\n        assert ""tensor([0, 1, 2], requires_grad=False)"" in captured.out\r\n\r\n\r\n# The following NumPy functions all create\r\n# arrays based on list input. Additional keyword\r\n# arguments required for the function are provided\r\n# as an optional dictionary.\r\nARRAY_CREATION_FNS = [\r\n    [np.array, {}],\r\n    [np.asarray, {}],\r\n    [np.fromiter, {""dtype"": np.int64}],\r\n    [np.empty_like, {}],\r\n    [np.ones_like, {}],\r\n    [np.zeros_like, {}],\r\n    [np.full_like, {""fill_value"": 5}]\r\n]\r\n\r\n# The following NumPy functions all create\r\n# arrays based on shape input.\r\nARRAY_SHAPE_FNS = [\r\n    [np.empty, {}],\r\n    [np.identity, {}],\r\n    [np.ones, {}],\r\n    [np.zeros, {}],\r\n    [np.full, {""fill_value"": 5}],\r\n    [np.arange, {}],\r\n    [np.eye, {}]\r\n]\r\n\r\n\r\nclass TestNumpyIntegration:\r\n    """"""Test that the wrapped NumPy functionality integrates well\r\n    with standard NumPy functions.""""""\r\n\r\n    @pytest.mark.parametrize(""fn, kwargs"", ARRAY_CREATION_FNS)\r\n    def test_tensor_creation_from_list(self, fn, kwargs):\r\n        """"""Test that you can create the tensor class from NumPy functions\r\n        instantiated via lists with the requires_grad argument""""""\r\n        # default value is true\r\n        x = fn([1, 1, 2], **kwargs)\r\n\r\n        assert isinstance(x, np.tensor)\r\n        assert x.requires_grad\r\n\r\n        x = fn([1, 1, 2], requires_grad=True, **kwargs)\r\n        assert x.requires_grad\r\n\r\n        x.requires_grad = False\r\n        assert not x.requires_grad\r\n\r\n        x = fn([1, 1, 2], requires_grad=False, **kwargs)\r\n        assert not x.requires_grad\r\n\r\n    @pytest.mark.parametrize(""fn, kwargs"", ARRAY_SHAPE_FNS)\r\n    def test_tensor_creation_from_shape(self, fn, kwargs):\r\n        """"""Test that you can create the tensor class from NumPy functions\r\n        instantiated via shapes with the requires_grad argument""""""\r\n        # default value is true\r\n        shape = 4\r\n        x = fn(shape, **kwargs)\r\n\r\n        assert isinstance(x, np.tensor)\r\n        assert x.requires_grad\r\n\r\n        x = fn(shape, requires_grad=True, **kwargs)\r\n        assert x.requires_grad\r\n\r\n        x.requires_grad = False\r\n        assert not x.requires_grad\r\n\r\n        x = fn(shape, requires_grad=False, **kwargs)\r\n        assert not x.requires_grad\r\n\r\n    def test_tensor_creation_from_string(self):\r\n        """"""Test that a tensor is properly created from a string.""""""\r\n        string = ""5, 4, 1, 2""\r\n        x = np.fromstring(string, dtype=int, sep=\',\')\r\n\r\n        assert isinstance(x, np.tensor)\r\n        assert x.requires_grad\r\n\r\n        x = np.fromstring(string, requires_grad=True, dtype=int, sep=\',\')\r\n        assert x.requires_grad\r\n\r\n        x.requires_grad = False\r\n        assert not x.requires_grad\r\n\r\n        x = np.fromstring(string, requires_grad=False, dtype=int, sep=\',\')\r\n        assert not x.requires_grad\r\n\r\n    def test_wrapped_docstring(self, capsys):\r\n        """"""Test that wrapped NumPy functions retains the original\r\n        docstring.""""""\r\n        print(np.sin.__doc__)\r\n        captured = capsys.readouterr()\r\n        assert ""Trigonometric sine, element-wise."" in captured.out\r\n\r\n    def test_wrapped_function_on_tensor(self):\r\n        """"""Test that wrapped functions work correctly""""""\r\n        x = np.array([0, 1, 2], requires_grad=True)\r\n        res = np.sin(x)\r\n        expected = onp.sin(onp.array([0, 1, 2]))\r\n        assert np.all(res == expected)\r\n        assert res.requires_grad\r\n\r\n        # since the wrapping is dynamic, even ``sin`` will\r\n        # now accept the requires_grad keyword argument.\r\n        x = np.array([0, 1, 2], requires_grad=True)\r\n        res = np.sin(x, requires_grad=False)\r\n        expected = onp.sin(onp.array([0, 1, 2]))\r\n        assert np.all(res == expected)\r\n        assert not res.requires_grad\r\n\r\n    def test_wrapped_function_nontrainable_list_input(self):\r\n        """"""Test that a wrapped function with signature of the form\r\n        func([arr1, arr2, ...]) acting on non-trainable input returns non-trainable output""""""\r\n        arr1 = np.array([0, 1], requires_grad=False)\r\n        arr2 = np.array([2, 3], requires_grad=False)\r\n        arr3 = np.array([4, 5], requires_grad=False)\r\n\r\n        res = np.vstack([arr1, arr2, arr3])\r\n        assert not res.requires_grad\r\n\r\n        # If one of the inputs is trainable, the output always is.\r\n        arr1.requires_grad = True\r\n        res = np.vstack([arr1, arr2, arr3])\r\n        assert res.requires_grad\r\n\r\n    def test_wrapped_function_nontrainable_variable_args(self):\r\n        """"""Test that a wrapped function with signature of the form\r\n        func(arr1, arr2, ...) acting on non-trainable input returns non-trainable output""""""\r\n        arr1 = np.array([0, 1], requires_grad=False)\r\n        arr2 = np.array([2, 3], requires_grad=False)\r\n\r\n        res = np.arctan2(arr1, arr2)\r\n        assert not res.requires_grad\r\n\r\n        # If one of the inputs is trainable, the output always is.\r\n        arr1.requires_grad = True\r\n        res = np.arctan2(arr1, arr2)\r\n        assert res.requires_grad\r\n\r\n    def test_wrapped_function_on_array(self):\r\n        """"""Test behaviour of a wrapped function on a vanilla NumPy\r\n        array.""""""\r\n        res = np.sin(onp.array([0, 1, 2]))\r\n        expected = onp.sin(onp.array([0, 1, 2]))\r\n        assert np.all(res == expected)\r\n\r\n        # the result has been converted into a tensor\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n    def test_classes_not_wrapped(self):\r\n        """"""Test that NumPy classes are not wrapped""""""\r\n        x = np.ndarray([0, 1, 2])\r\n        assert not isinstance(x, np.tensor)\r\n        assert not hasattr(x, ""requires_grad"")\r\n\r\n    def test_random_subpackage(self):\r\n        """"""Test that the random subpackage is correctly wrapped""""""\r\n        x = np.random.normal(size=[2, 3])\r\n        assert isinstance(x, np.tensor)\r\n\r\n    def test_linalg_subpackage(self):\r\n        """"""Test that the linalg subpackage is correctly wrapped""""""\r\n        x = np.linalg.eigvals([[1, 1], [1, 1]])\r\n        assert isinstance(x, np.tensor)\r\n\r\n    def test_fft_subpackage(self):\r\n        """"""Test that the fft subpackage is correctly wrapped""""""\r\n        x = np.fft.fft(np.arange(8))\r\n        assert isinstance(x, np.tensor)\r\n\r\n    def test_unary_operators(self):\r\n        """"""Test that unary operators (negate, power)\r\n        correctly work on tensors.""""""\r\n        x = np.array([[1, 2], [3, 4]])\r\n        res = -x\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n        x = np.array([[1, 2], [3, 4]], requires_grad=False)\r\n        res = -x\r\n        assert isinstance(res, np.tensor)\r\n        assert not res.requires_grad\r\n\r\n        x = np.array([[1, 2], [3, 4]])\r\n        res = x ** 2\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n        x = np.array([[1, 2], [3, 4]], requires_grad=False)\r\n        res = x ** 2\r\n        assert isinstance(res, np.tensor)\r\n        assert not res.requires_grad\r\n\r\n\r\n    def test_binary_operators(self):\r\n        """"""Test that binary operators (add, subtract, divide, multiply, matmul)\r\n        correctly work on tensors.""""""\r\n        x = np.array([[1, 2], [3, 4]])\r\n        y = np.array([[5, 6], [7, 8]])\r\n        res = x + y\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n        res = x - y\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n        res = x / y\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n        res = x * y\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n        res = x @ y\r\n        assert isinstance(res, np.tensor)\r\n        assert res.requires_grad\r\n\r\n    def test_binary_operator_nontrainable(self):\r\n        """"""Test that binary operators on two non-trainable\r\n        arrays result in non-trainable output.""""""\r\n        x = np.array([[1, 2], [3, 4]], requires_grad=False)\r\n        y = np.array([[5, 6], [7, 8]], requires_grad=False)\r\n        res = x + y\r\n        assert isinstance(res, np.tensor)\r\n        assert not res.requires_grad\r\n\r\n        res = x - y\r\n        assert isinstance(res, np.tensor)\r\n        assert not res.requires_grad\r\n\r\n        res = x / y\r\n        assert isinstance(res, np.tensor)\r\n        assert not res.requires_grad\r\n\r\n        res = x * y\r\n        assert isinstance(res, np.tensor)\r\n        assert not res.requires_grad\r\n\r\n        res = x @ y\r\n        assert isinstance(res, np.tensor)\r\n        assert not res.requires_grad\r\n\r\n\r\nclass TestAutogradIntegration:\r\n    """"""Test autograd works with the new tensor subclass""""""\r\n\r\n    def test_gradient(self):\r\n        """"""Test gradient computations continue to work""""""\r\n        def cost(x):\r\n            return np.sum(np.sin(x))\r\n\r\n        grad_fn = qml.grad(cost, argnum=[0])\r\n        arr1 = np.array([0., 1., 2.])\r\n\r\n        res = grad_fn(arr1)\r\n        expected = np.cos(arr1)\r\n\r\n        assert np.all(res == expected)\r\n\r\n    def test_non_differentiable_gradient(self):\r\n        """"""Test gradient computation with requires_grad=False raises an error""""""\r\n        def cost(x):\r\n            return np.sum(np.sin(x))\r\n\r\n        grad_fn = qml.grad(cost, argnum=[0])\r\n        arr1 = np.array([0., 1., 2.], requires_grad=False)\r\n\r\n        with pytest.raises(np.NonDifferentiableError, match=""non-differentiable""):\r\n            grad_fn(arr1)\r\n'"
tests/test_observable.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.plugin.DefaultGaussian` device.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nfrom pennylane import numpy as np\nfrom scipy.linalg import block_diag\n\nimport pennylane as qml\nfrom pennylane.qnodes import QuantumFunctionError\nfrom pennylane.plugins import DefaultQubit\n\nimport pytest\n\n\ndef test_pass_positional_wires_to_observable():\n    """"""Tests whether the ability to pass wires as positional argument is retained""""""\n    dev = qml.device(""default.qubit"", wires=1)\n\n    obs = qml.Identity(0)\n\n    @qml.qnode(dev)\n    def circuit():\n        return qml.expval(obs)\n\n    circuit()\n    assert obs in circuit.ops\n'"
tests/test_operation.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for :mod:`pennylane.operation`.\n""""""\nimport itertools\nimport functools\nfrom unittest.mock import patch\n\nimport pytest\nimport numpy as np\nfrom numpy.linalg import multi_dot\n\nimport pennylane as qml\nfrom pennylane.operation import Tensor\n\nfrom gate_data import I, X, Y, Rotx, Roty, Rotz, CRotx, CRoty, CRotz, CNOT, Rot3, Rphi\nfrom pennylane.wires import Wires\n\n\n# pylint: disable=no-self-use, no-member, protected-access, pointless-statement\n\n# Operation subclasses to test\nop_classes = [getattr(qml.ops, cls) for cls in qml.ops.__all__]\nop_classes_cv = [getattr(qml.ops, cls) for cls in qml.ops._cv__all__]\nop_classes_gaussian = [cls for cls in op_classes_cv if cls.supports_heisenberg]\n\nop_classes_param_testable = op_classes.copy()\nop_classes_param_testable.remove(qml.ops.PauliRot)\n\ndef U3(theta, phi, lam):\n    return Rphi(phi) @ Rphi(lam) @ Rot3(lam, theta, -lam)\n\n\nclass TestOperation:\n    """"""Operation class tests.""""""\n\n    @pytest.mark.parametrize(""test_class"", op_classes_gaussian)\n    def test_heisenberg(self, test_class, tol):\n        ""Heisenberg picture adjoint actions of CV Operations.""\n\n        ww = list(range(test_class.num_wires))\n\n        # fixed parameter values\n        if test_class.par_domain == \'A\':\n            if test_class.__name__ == ""Interferometer"":\n                ww = list(range(2))\n                par = [np.array([[0.83645892-0.40533293j, -0.20215326+0.30850569j],\n                                 [-0.23889780-0.28101519j, -0.88031770-0.29832709j]])]\n            else:\n                par = [np.array([[-1.82624687]])] * test_class.num_params\n        else:\n            par = [-0.069125, 0.51778, 0.91133, 0.95904][:test_class.num_params]\n\n        op = test_class(*par, wires=ww)\n\n        if issubclass(test_class, qml.operation.Observable):\n            Q = op.heisenberg_obs(0)\n            # ev_order equals the number of dimensions of the H-rep array\n            assert Q.ndim == test_class.ev_order\n            return\n\n        # not an Expectation\n\n        U = op.heisenberg_tr(num_wires=2)\n        I = np.eye(*U.shape)\n        # first row is always (1,0,0...)\n        assert np.all(U[0, :] == I[:, 0])\n\n        # check the inverse transform\n        V = op.heisenberg_tr(num_wires=2, inverse=True)\n        assert np.linalg.norm(U @ V -I) == pytest.approx(0, abs=tol)\n        assert np.linalg.norm(V @ U -I) == pytest.approx(0, abs=tol)\n\n        if op.grad_recipe is not None:\n            # compare gradient recipe to numerical gradient\n            h = 1e-7\n            U = op.heisenberg_tr(0)\n            for k in range(test_class.num_params):\n                D = op.heisenberg_pd(k)  # using the recipe\n                # using finite difference\n                op.params[k] += h\n                Up = op.heisenberg_tr(0)\n                op.params = par\n                G = (Up-U) / h\n                assert D == pytest.approx(G, abs=tol)\n\n        # make sure that `heisenberg_expand` method receives enough wires to actually expand\n        # when supplied `wires` value is zero, returns unexpanded matrix instead of raising Error\n        # so only check multimode ops\n        if len(op.wires) > 1:\n            with pytest.raises(ValueError, match=\'is too small to fit Heisenberg matrix\'):\n                op.heisenberg_expand(U, len(op.wires) - 1)\n\n        # validate size of input for `heisenberg_expand` method\n        with pytest.raises(ValueError, match=\'Heisenberg matrix is the wrong size\'):\n            U_wrong_size = U[1:, 1:]\n            op.heisenberg_expand(U_wrong_size, len(op.wires))\n\n        # ensure that `heisenberg_expand` raises exception if it receives an array with order > 2\n        with pytest.raises(ValueError, match=\'Only order-1 and order-2 arrays supported\'):\n            U_high_order = np.array([U] * 3)\n            op.heisenberg_expand(U_high_order, len(op.wires))\n\n    @pytest.mark.parametrize(""test_class"", op_classes_param_testable)\n    def test_operation_init(self, test_class, monkeypatch):\n        ""Operation subclass initialization.""\n\n        n = test_class.num_params\n        w = test_class.num_wires\n        ww = list(range(w))\n        # valid pars\n        if test_class.par_domain == \'A\':\n            pars = [np.eye(2)] * n\n        elif test_class.par_domain == \'N\':\n            pars = [0] * n\n        else:\n            pars = [0.0] * n\n\n        # valid call\n        op = test_class(*pars, wires=ww)\n        assert op.name == test_class.__name__\n        assert op.params == pars\n        assert op._wires == Wires(ww)\n\n        # too many parameters\n        with pytest.raises(ValueError, match=\'wrong number of parameters\'):\n            test_class(*(n+1)*[0], wires=ww)\n\n        # too few parameters\n        if n > 0:\n            with pytest.raises(ValueError, match=\'wrong number of parameters\'):\n                test_class(*(n-1)*[0], wires=ww)\n\n        if w > 0:\n            # too many or too few wires\n            with pytest.raises(ValueError, match=\'wrong number of wires\'):\n                test_class(*pars, wires=list(range(w+1)))\n            with pytest.raises(ValueError, match=\'wrong number of wires\'):\n                test_class(*pars, wires=list(range(w-1)))\n            # repeated wires\n            if w > 1:\n                with pytest.raises(qml.wires.WireError, match=\'Wires must be unique\'):\n                    test_class(*pars, wires=w*[0])\n\n        if n == 0:\n            return\n\n        # wrong parameter types\n        if test_class.do_check_domain:\n            if test_class.par_domain == \'A\':\n                # params must be arrays\n                with pytest.raises(TypeError, match=\'Array parameter expected\'):\n                    test_class(*n*[0.0], wires=ww)\n                # params must not be Variables\n                with pytest.raises(TypeError, match=\'Array parameter expected\'):\n                    test_class(*n*[qml.variable.Variable(0)], wires=ww)\n            elif test_class.par_domain == \'N\':\n                # params must be natural numbers\n                with pytest.raises(TypeError, match=\'Natural number\'):\n                    test_class(*n*[0.7], wires=ww)\n                with pytest.raises(TypeError, match=\'Natural number\'):\n                    test_class(*n*[-1], wires=ww)\n            elif test_class.par_domain == \'R\':\n                # params must be real numbers\n                with pytest.raises(TypeError, match=\'Real scalar parameter expected\'):\n                    test_class(*n*[1j], wires=ww)\n\n            # if par_domain ever gets overridden to an unsupported value, should raise exception\n            monkeypatch.setattr(test_class, \'par_domain\', \'junk\')\n            with pytest.raises(ValueError, match=\'Unknown parameter domain\'):\n                test_class(*pars, wires=ww)\n\n            monkeypatch.setattr(test_class, \'par_domain\', 7)\n            with pytest.raises(ValueError, match=\'Unknown parameter domain\'):\n                test_class(*pars, wires=ww)\n\n    @pytest.fixture(scope=""function"")\n    def qnode(self, mock_device):\n        """"""Provides a QNode for the subsequent tests of do_queue""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1], do_queue=False)\n            qml.RY(0.4, wires=[0])\n            qml.RZ(-0.2, wires=[1], do_queue=False)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliZ(1))\n\n        node = qml.QNode(circuit, mock_device)\n        node._construct([1.0], {})\n\n        return node\n\n    def test_operation_inside_context_do_queue_false(self, qnode):\n        """"""Test that an operation does not get added to the QNode queue when do_queue=False""""""\n        assert len(qnode.ops) == 4\n        assert qnode.ops[0].name == ""RX""\n        assert qnode.ops[1].name == ""RY""\n        assert qnode.ops[2].name == ""PauliX""\n        assert qnode.ops[3].name == ""PauliZ""\n\n    @pytest.fixture(scope=""function"")\n    def qnode_for_inverse(self, mock_device):\n        """"""Provides a QNode for the subsequent tests of inv""""""\n\n        def circuit(x):\n            qml.RZ(x, wires=[1]).inv()\n            qml.RZ(x, wires=[1]).inv().inv()\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliZ(1))\n\n        node = qml.QNode(circuit, mock_device)\n        node._construct([1.0], {})\n\n        return node\n\n    def test_operation_inverse_defined(self, qnode_for_inverse):\n        """"""Test that the inverse of an operation is added to the QNode queue and the operation is an instance\n        of the original class""""""\n        assert qnode_for_inverse.ops[0].name == ""RZ.inv""\n        assert qnode_for_inverse.ops[0].inverse\n        assert issubclass(qnode_for_inverse.ops[0].__class__, qml.operation.Operation)\n        assert qnode_for_inverse.ops[1].name == ""RZ""\n        assert not qnode_for_inverse.ops[1].inverse\n        assert issubclass(qnode_for_inverse.ops[1].__class__, qml.operation.Operation)\n\n    def test_operation_inverse_using_dummy_operation(self):\n\n        some_param = 0.5\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom Operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'R\'\n\n        # Check that the name of the Operation is initialized fine\n        dummy_op = DummyOp(some_param, wires=[1])\n\n        assert not dummy_op.inverse\n\n        dummy_op_class_name = dummy_op.name\n\n        # Check that the name of the Operation was modified when applying the inverse\n        assert dummy_op.inv().name == dummy_op_class_name + "".inv""\n        assert dummy_op.inverse\n\n        # Check that the name of the Operation is the original again, once applying the inverse a second time\n        assert dummy_op.inv().name == dummy_op_class_name\n        assert not dummy_op.inverse\n\n    def test_operation_outside_context(self):\n        """"""Test that an operation can be instantiated outside a QNode context, and that do_queue is ignored""""""\n        op = qml.ops.CNOT(wires=[0, 1], do_queue=False)\n        assert isinstance(op, qml.operation.Operation)\n\n        op = qml.ops.RX(0.5, wires=0, do_queue=True)\n        assert isinstance(op, qml.operation.Operation)\n\n        op = qml.ops.Hadamard(wires=0)\n        assert isinstance(op, qml.operation.Operation)\n\n\nclass TestOperatorConstruction:\n    """"""Test custom operators construction.""""""\n\n    def test_incorrect_num_wires(self):\n        """"""Test that an exception is raised if called with wrong number of wires""""""\n\n        class DummyOp(qml.operation.Operator):\n            r""""""Dummy custom operator""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'R\'\n\n        with pytest.raises(ValueError, match=""wrong number of wires""):\n            DummyOp(0.5, wires=[0, 1])\n\n    def test_non_unique_wires(self):\n        """"""Test that an exception is raised if called with identical wires""""""\n\n        class DummyOp(qml.operation.Operator):\n            r""""""Dummy custom operator""""""\n            num_wires = 2\n            num_params = 1\n            par_domain = \'R\'\n\n        with pytest.raises(qml.wires.WireError, match=""Wires must be unique""):\n            DummyOp(0.5, wires=[1, 1], do_queue=False)\n\n    def test_incorrect_num_params(self):\n        """"""Test that an exception is raised if called with wrong number of parameters""""""\n\n        class DummyOp(qml.operation.Operator):\n            r""""""Dummy custom operator""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'R\'\n            grad_method = \'A\'\n\n        with pytest.raises(ValueError, match=""wrong number of parameters""):\n            DummyOp(0.5, 0.6, wires=0)\n\n    def test_incorrect_param_domain(self):\n        """"""Test that an exception is raised if an incorrect parameter domain is requested""""""\n\n        class DummyOp(qml.operation.Operator):\n            r""""""Dummy custom operator""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'J\'\n            grad_method = \'A\'\n\n        with pytest.raises(ValueError, match=""Unknown parameter domain""):\n            DummyOp(0.5, wires=0)\n\n\nclass TestOperationConstruction:\n    """"""Test custom operations construction.""""""\n\n    def test_incorrect_grad_recipe_length(self):\n        """"""Test that an exception is raised if len(grad_recipe)!=len(num_params)""""""\n\n        class DummyOp(qml.operation.CVOperation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'R\'\n            grad_method = \'A\'\n            grad_recipe = [(0.5, 0.1), (0.43, 0.1)]\n\n        with pytest.raises(AssertionError, match=""Gradient recipe must have one entry for each parameter""):\n            DummyOp(0.5, wires=[0, 1])\n\n    def test_grad_method_with_integer_params(self):\n        """"""Test that an exception is raised if a non-None grad-method is provided for natural number params""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'N\'\n            grad_method = \'A\'\n\n        with pytest.raises(AssertionError, match=""An operation may only be differentiated with respect to real scalar parameters""):\n            DummyOp(5, wires=[0, 1])\n\n    def test_analytic_grad_with_array_param(self):\n        """"""Test that an exception is raised if an analytic gradient is requested with an array param""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'A\'\n            grad_method = \'A\'\n\n        with pytest.raises(AssertionError, match=""Operations that depend on arrays containing free variables may only be differentiated using the F method""):\n            DummyOp(np.array([1.]), wires=[0, 1])\n\n    def test_numerical_grad_with_grad_recipe(self):\n        """"""Test that an exception is raised if a numerical gradient is requested with a grad recipe""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'R\'\n            grad_method = \'F\'\n            grad_recipe = [(0.5, 0.1)]\n\n        with pytest.raises(AssertionError, match=""Gradient recipe is only used by the A method""):\n            DummyOp(0.5, wires=[0, 1])\n\n    def test_variable_instead_of_array(self):\n        """"""Test that an exception is raised if an array is expected but a variable is passed""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'A\'\n            grad_method = \'F\'\n\n        with pytest.raises(TypeError, match=""Array parameter expected, got a Variable""):\n            DummyOp(qml.variable.Variable(0), wires=[0])\n\n    def test_array_instead_of_flattened_array(self):\n        """"""Test that an exception is raised if an array is expected, but an array is passed\n        to check_domain when flattened=True. In the initial release of the library, this is not\n        accessible by the developer or the user, but is kept in case it will be used in the future.""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'A\'\n            grad_method = \'F\'\n\n        with pytest.raises(TypeError, match=""Flattened array parameter expected""):\n            op = DummyOp(np.array([1]), wires=[0])\n            op.check_domain(np.array([1]), True)\n\n    def test_scalar_instead_of_array(self):\n        """"""Test that an exception is raised if an array is expected but a scalar is passed""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'A\'\n            grad_method = \'F\'\n\n        with pytest.raises(TypeError, match=""Array parameter expected, got""):\n            DummyOp(0.5, wires=[0])\n\n    def test_array_instead_of_real(self):\n        """"""Test that an exception is raised if a real number is expected but an array is passed""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'R\'\n            grad_method = \'F\'\n\n        with pytest.raises(TypeError, match=""Real scalar parameter expected, got""):\n            DummyOp(np.array([1.]), wires=[0])\n\n    def test_not_natural_param(self):\n        """"""Test that an exception is raised if a natural number is expected but not passed""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'N\'\n            grad_method = None\n\n        with pytest.raises(TypeError, match=""Natural number parameter expected, got""):\n            DummyOp(0.5, wires=[0])\n\n        with pytest.raises(TypeError, match=""Natural number parameter expected, got""):\n            DummyOp(-2, wires=[0])\n\n    def test_no_wires_passed(self):\n        """"""Test exception raised if no wires are passed""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'N\'\n            grad_method = None\n\n        with pytest.raises(ValueError, match=""Must specify the wires""):\n            DummyOp(0.54)\n\n    def test_wire_passed_positionally(self):\n        """"""Test exception raised if wire is passed as a positional arg""""""\n\n        class DummyOp(qml.operation.Operation):\n            r""""""Dummy custom operation""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'N\'\n            grad_method = None\n\n        with pytest.raises(ValueError, match=""Must specify the wires""):\n            DummyOp(0.54, 0)\n\n\nclass TestObservableConstruction:\n    """"""Test custom observables construction.""""""\n\n    def test_observable_return_type_none(self):\n        """"""Check that the return_type of an observable is initially None""""""\n\n        class DummyObserv(qml.operation.Observable):\n            r""""""Dummy custom observable""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'N\'\n            grad_method = None\n\n        assert DummyObserv(0, wires=[1]).return_type is None\n\n    def test_observable_is_not_operation_but_operator(self):\n        """"""Check that the Observable class inherits from an Operator, not from an Operation""""""\n\n        assert issubclass(qml.operation.Observable, qml.operation.Operator)\n        assert not issubclass(qml.operation.Observable, qml.operation.Operation)\n\n    def test_observable_is_operation_as_well(self):\n        """"""Check that the Observable class inherits from an Operator class as well""""""\n\n        class DummyObserv(qml.operation.Observable, qml.operation.Operation):\n            r""""""Dummy custom observable""""""\n            num_wires = 1\n            num_params = 1\n            par_domain = \'N\'\n            grad_method = None\n\n        assert issubclass(DummyObserv, qml.operation.Operator)\n        assert issubclass(DummyObserv, qml.operation.Observable)\n        assert issubclass(DummyObserv, qml.operation.Operation)\n\n    def test_tensor_n_multiple_modes(self):\n        """"""Checks that the TensorN operator was constructed correctly when\n        multiple modes were specified.""""""\n        cv_obs = qml.TensorN(wires=[0, 1])\n\n        assert isinstance(cv_obs, qml.TensorN)\n        assert cv_obs.wires == Wires([0, 1])\n        assert cv_obs.ev_order is None\n\n    def test_tensor_n_single_mode_wires_explicit(self):\n        """"""Checks that instantiating a TensorN when passing a single mode as a\n        keyword argument returns a NumberOperator.""""""\n        cv_obs = qml.TensorN(wires=[0])\n\n        assert isinstance(cv_obs, qml.NumberOperator)\n        assert cv_obs.wires == Wires([0])\n        assert cv_obs.ev_order == 2\n\n    def test_tensor_n_single_mode_wires_implicit(self):\n        """"""Checks that instantiating TensorN when passing a single mode as a\n        positional argument returns a NumberOperator.""""""\n        cv_obs = qml.TensorN(1)\n\n        assert isinstance(cv_obs, qml.NumberOperator)\n        assert cv_obs.wires == Wires([1])\n        assert cv_obs.ev_order == 2\n\n\nclass TestOperatorIntegration:\n    """""" Integration tests for the Operator class""""""\n\n    def test_all_wires_defined_but_init_with_one(self):\n        """"""Test that an exception is raised if the class is defined with ALL wires,\n        but then instantiated with only one""""""\n\n        dev1 = qml.device(""default.qubit"", wires=2)\n\n        class DummyOp(qml.operation.Operator):\n            r""""""Dummy custom operator""""""\n            num_wires = qml.operation.ActsOn.AllWires\n            num_params = 0\n            par_domain = \'R\'\n\n        @qml.qnode(dev1)\n        def circuit():\n            DummyOp(wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(qml.QuantumFunctionError, match=""Operator {} must act on all wires"".format(DummyOp.__name__)):\n            circuit()\n\n\nclass TestOperationIntegration:\n    """""" Integration tests for the Operation class""""""\n\n    def test_inverse_of_operation(self):\n        """"""Test the inverse of an operation""""""\n\n        dev1 = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev1)\n        def circuit():\n            qml.PauliZ(wires=[0])\n            qml.PauliZ(wires=[0]).inv()\n            return qml.expval(qml.PauliZ(0))\n\n        assert circuit() == 1\n\n    def test_inverse_operations_not_supported(self):\n        """"""Test that the inverse of operations is not currently\n        supported on the default gaussian device""""""\n\n        dev1 = qml.device(""default.gaussian"", wires=2)\n\n        @qml.qnode(dev1)\n        def mean_photon_gaussian(mag_alpha, phase_alpha, phi):\n            qml.Displacement(mag_alpha, phase_alpha, wires=0)\n            qml.Rotation(phi, wires=0).inv()\n            return qml.expval(qml.NumberOperator(0))\n\n        with pytest.raises(qml.DeviceError, match=""Gate Rotation.inv not supported on device {}""\n                .format(dev1.short_name)):\n            mean_photon_gaussian(0.015, 0.02, 0.005)\n\n\nclass TestTensor:\n    """"""Unit tests for the Tensor class""""""\n\n    def test_construct(self):\n        """"""Test construction of a tensor product""""""\n        X = qml.PauliX(0)\n        Y = qml.PauliY(2)\n        T = Tensor(X, Y)\n        assert T.obs == [X, Y]\n\n        T = Tensor(T, Y)\n        assert T.obs == [X, Y, Y]\n\n        with pytest.raises(ValueError, match=""Can only perform tensor products between observables""):\n            Tensor(T, qml.CNOT(wires=[0, 1]))\n\n    def test_name(self):\n        """"""Test that the names of the observables are\n        returned as expected""""""\n        X = qml.PauliX(0)\n        Y = qml.PauliY(2)\n        t = Tensor(X, Y)\n        assert t.name == [X.name, Y.name]\n\n    def test_num_wires(self):\n        """"""Test that the correct number of wires is returned""""""\n        p = np.array([0.5])\n        X = qml.PauliX(0)\n        Y = qml.Hermitian(p, wires=[1, 2])\n        t = Tensor(X, Y)\n        assert t.num_wires == 3\n\n    def test_wires(self):\n        """"""Test that the correct nested list of wires is returned""""""\n        p = np.array([0.5])\n        X = qml.PauliX(0)\n        Y = qml.Hermitian(p, wires=[1, 2])\n        t = Tensor(X, Y)\n        assert t.wires == Wires([0, 1, 2])\n\n    def test_params(self):\n        """"""Test that the correct flattened list of parameters is returned""""""\n        p = np.array([0.5])\n        X = qml.PauliX(0)\n        Y = qml.Hermitian(p, wires=[1, 2])\n        t = Tensor(X, Y)\n        assert t.params == [p]\n\n    def test_num_params(self):\n        """"""Test that the correct number of parameters is returned""""""\n        p = np.array([0.5])\n        X = qml.PauliX(0)\n        Y = qml.Hermitian(p, wires=[1, 2])\n        Z = qml.Hermitian(p, wires=[1, 2])\n        t = Tensor(X, Y, Z)\n        assert t.num_params == 2\n\n    def test_parameters(self):\n        """"""Test that the correct nested list of parameters is returned""""""\n        p = np.array([0.5])\n        X = qml.PauliX(0)\n        Y = qml.Hermitian(p, wires=[1, 2])\n        t = Tensor(X, Y)\n        assert t.parameters == [[], [p]]\n\n    def test_multiply_obs(self):\n        """"""Test that multiplying two observables\n        produces a tensor""""""\n        X = qml.PauliX(0)\n        Y = qml.Hadamard(2)\n        t = X @ Y\n        assert isinstance(t, Tensor)\n        assert t.obs == [X, Y]\n\n    def test_multiply_obs_tensor(self):\n        """"""Test that multiplying an observable by a tensor\n        produces a tensor""""""\n        X = qml.PauliX(0)\n        Y = qml.Hadamard(2)\n        Z = qml.PauliZ(1)\n\n        t = X @ Y\n        t = Z @ t\n\n        assert isinstance(t, Tensor)\n        assert t.obs == [Z, X, Y]\n\n    def test_multiply_tensor_obs(self):\n        """"""Test that multiplying a tensor by an observable\n        produces a tensor""""""\n        X = qml.PauliX(0)\n        Y = qml.Hadamard(2)\n        Z = qml.PauliZ(1)\n\n        t = X @ Y\n        t = t @ Z\n\n        assert isinstance(t, Tensor)\n        assert t.obs == [X, Y, Z]\n\n    def test_multiply_tensor_tensor(self):\n        """"""Test that multiplying a tensor by a tensor\n        produces a tensor""""""\n        X = qml.PauliX(0)\n        Y = qml.PauliY(2)\n        Z = qml.PauliZ(1)\n        H = qml.Hadamard(3)\n\n        t1 = X @ Y\n        t2 = Z @ H\n        t = t2 @ t1\n\n        assert isinstance(t, Tensor)\n        assert t.obs == [Z, H, X, Y]\n\n    def test_multiply_tensor_in_place(self):\n        """"""Test that multiplying a tensor in-place\n        produces a tensor""""""\n        X = qml.PauliX(0)\n        Y = qml.PauliY(2)\n        Z = qml.PauliZ(1)\n        H = qml.Hadamard(3)\n\n        t = X\n        t @= Y\n        t @= Z @ H\n\n        assert isinstance(t, Tensor)\n        assert t.obs == [X, Y, Z, H]\n\n    def test_operation_multiply_invalid(self):\n        """"""Test that an exception is raised if an observable\n        is multiplied by an operation""""""\n        X = qml.PauliX(0)\n        Y = qml.CNOT(wires=[0, 1])\n        Z = qml.PauliZ(0)\n\n        with pytest.raises(ValueError, match=""Can only perform tensor products between observables""):\n            X @ Y\n\n        with pytest.raises(ValueError, match=""Can only perform tensor products between observables""):\n            T = X @ Z\n            T @ Y\n\n        with pytest.raises(ValueError, match=""Can only perform tensor products between observables""):\n            T = X @ Z\n            Y @ T\n\n    def test_eigvals(self):\n        """"""Test that the correct eigenvalues are returned for the Tensor""""""\n        X = qml.PauliX(0)\n        Y = qml.PauliY(2)\n        t = Tensor(X, Y)\n        assert np.array_equal(t.eigvals, np.kron([1, -1], [1, -1]))\n\n        # test that the eigvals are now cached and not recalculated\n        assert np.array_equal(t._eigvals_cache, t.eigvals)\n\n    @pytest.mark.usefixtures(""tear_down_hermitian"")\n    def test_eigvals_hermitian(self, tol):\n        """"""Test that the correct eigenvalues are returned for the Tensor containing an Hermitian observable""""""\n        X = qml.PauliX(0)\n        hamiltonian = np.array([[1,0,0,0], [0,1,0,0], [0,0,0,1], [0,0,1,0]])\n        Herm = qml.Hermitian(hamiltonian, wires=[1, 2])\n        t = Tensor(X, Herm)\n        d = np.kron(np.array([1., -1.]), np.array([-1.,  1.,  1.,  1.]))\n        t = t.eigvals\n        assert np.allclose(t, d, atol=tol, rtol=0)\n\n    def test_eigvals_identity(self, tol):\n        """"""Test that the correct eigenvalues are returned for the Tensor containing an Identity""""""\n        X = qml.PauliX(0)\n        Iden = qml.Identity(1)\n        t = Tensor(X, Iden)\n        d = np.kron(np.array([1., -1.]), np.array([1.,  1.]))\n        t = t.eigvals\n        assert np.allclose(t, d, atol=tol, rtol=0)\n\n    def test_eigvals_identity_and_hermitian(self, tol):\n        """"""Test that the correct eigenvalues are returned for the Tensor containing\n        multiple types of observables""""""\n        H = np.diag([1, 2, 3, 4])\n        O = qml.PauliX(0) @ qml.Identity(2) @ qml.Hermitian(H, wires=[4,5])\n        res = O.eigvals\n        expected = np.kron(np.array([1., -1.]), np.kron(np.array([1.,  1.]), np.arange(1, 5)))\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_diagonalizing_gates(self, tol):\n        """"""Test that the correct diagonalizing gate set is returned for a Tensor of observables""""""\n        H = np.diag([1, 2, 3, 4])\n        O = qml.PauliX(0) @ qml.Identity(2)  @ qml.PauliY(1) @ qml.Hermitian(H, [5, 6])\n\n        res = O.diagonalizing_gates()\n\n        # diagonalize the PauliX on wire 0 (H.X.H = Z)\n        assert isinstance(res[0], qml.Hadamard)\n        assert res[0].wires == Wires([0])\n\n        # diagonalize the PauliY on wire 1 (U.Y.U^\\dagger = Z\n        # where U = HSZ).\n        assert isinstance(res[1], qml.PauliZ)\n        assert res[1].wires == Wires([1])\n        assert isinstance(res[2], qml.S)\n        assert res[2].wires == Wires([1])\n        assert isinstance(res[3], qml.Hadamard)\n        assert res[3].wires == Wires([1])\n\n        # diagonalize the Hermitian observable on wires 5, 6\n        assert isinstance(res[4], qml.QubitUnitary)\n        assert res[4].wires == Wires([5, 6])\n\n        O = O @ qml.Hadamard(4)\n        res = O.diagonalizing_gates()\n\n        # diagonalize the Hadamard observable on wire 4\n        # (RY(-pi/4).H.RY(pi/4) = Z)\n        assert isinstance(res[-1], qml.RY)\n        assert res[-1].wires == Wires([4])\n        assert np.allclose(res[-1].parameters, -np.pi/4, atol=tol, rtol=0)\n\n    def test_diagonalizing_gates_numerically_diagonalizes(self, tol):\n        """"""Test that the diagonalizing gate set numerically\n        diagonalizes the tensor observable""""""\n\n        # create a tensor observable acting on consecutive wires\n        H = np.diag([1, 2, 3, 4])\n        O = qml.PauliX(0) @ qml.PauliY(1) @ qml.Hermitian(H, [2, 3])\n\n        O_mat = O.matrix\n        diag_gates = O.diagonalizing_gates()\n\n        # group the diagonalizing gates based on what wires they act on\n        U_list = []\n        for _, g in itertools.groupby(diag_gates, lambda x: x.wires.tolist()):\n            # extract the matrices of each diagonalizing gate\n            mats = [i.matrix for i in g]\n\n            # Need to revert the order in which the matrices are applied such that they adhere to the order\n            # of matrix multiplication\n            # E.g. for PauliY: [PauliZ(wires=self.wires), S(wires=self.wires), Hadamard(wires=self.wires)]\n            # becomes Hadamard @ S @ PauliZ, where @ stands for matrix multiplication\n            mats = mats[::-1]\n\n            if len(mats) > 1:\n                # multiply all unitaries together before appending\n                mats = [multi_dot(mats)]\n\n            # append diagonalizing unitary for specific wire to U_list\n            U_list.append(mats[0])\n\n        # since the test is assuming consecutive wires for each observable\n        # in the tensor product, it is sufficient to Kronecker product\n        # the entire list.\n        U = functools.reduce(np.kron, U_list)\n\n\n        res = U @ O_mat @ U.conj().T\n        expected = np.diag(O.eigvals)\n\n        # once diagonalized by U, the result should be a diagonal\n        # matrix of the eigenvalues.\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_tensor_matrix(self, tol):\n        """"""Test that the tensor product matrix method returns\n        the correct result""""""\n        H = np.diag([1, 2, 3, 4])\n        O = qml.PauliX(0) @ qml.PauliY(1) @ qml.Hermitian(H, [2, 3])\n\n        res = O.matrix\n        expected = np.kron(qml.PauliY._matrix(), H)\n        expected = np.kron(qml.PauliX._matrix(), expected)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_multiplication_matrix(self, tol):\n        """"""If using the ``@`` operator on two observables acting on the\n        same wire, the tensor class should treat this as matrix multiplication.""""""\n        O = qml.PauliX(0) @ qml.PauliX(0)\n\n        res = O.matrix\n        expected = qml.PauliX._matrix() @ qml.PauliX._matrix()\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    herm_matrix = np.array([\n                            [1, 0, 0, 0],\n                            [0, 1, 0, 0],\n                            [0, 0, 1, 0],\n                            [0, 0, 0, 1]\n                            ])\n\n    tensor_obs = [\n                    (\n                    qml.PauliZ(0) @ qml.Identity(1) @ qml.PauliZ(2),\n                    [qml.PauliZ(0), qml.PauliZ(2)]\n                    ),\n                    (\n                    qml.Identity(0) @ qml.PauliX(1) @ qml.Identity(2) @ qml.PauliZ(3) @  qml.PauliZ(4) @ qml.Identity(5),\n                    [qml.PauliX(1), qml.PauliZ(3), qml.PauliZ(4)]\n                    ),\n\n                    # List containing single observable is returned\n                    (\n                    qml.PauliZ(0) @ qml.Identity(1),\n                    [qml.PauliZ(0)]\n                    ),\n                    (\n                    qml.Identity(0) @ qml.PauliX(1) @ qml.Identity(2),\n                    [qml.PauliX(1)]\n                    ),\n                    (\n                    qml.Identity(0) @ qml.Identity(1),\n                    [qml.Identity(0)]\n                    ),\n                    (\n                    qml.Identity(0) @ qml.Identity(1) @ qml.Hermitian(herm_matrix, wires=[2,3]),\n                    [qml.Hermitian(herm_matrix, wires=[2,3])]\n                    )\n                ]\n\n    @pytest.mark.parametrize(""tensor_observable, expected"", tensor_obs)\n    def test_non_identity_obs(self, tensor_observable, expected):\n        """"""Tests that the non_identity_obs property returns a list that contains no Identity instances.""""""\n\n        O = tensor_observable\n        for idx, obs in enumerate(O.non_identity_obs):\n            assert type(obs) == type(expected[idx])\n            assert obs.wires == expected[idx].wires\n\n    tensor_obs_pruning = [\n                            (\n                            qml.PauliZ(0) @ qml.Identity(1) @ qml.PauliZ(2),\n                            qml.PauliZ(0) @ qml.PauliZ(2)\n                            ),\n                            (\n                            qml.Identity(0) @ qml.PauliX(1) @ qml.Identity(2) @ qml.PauliZ(3) @  qml.PauliZ(4) @ qml.Identity(5),\n                            qml.PauliX(1) @ qml.PauliZ(3) @ qml.PauliZ(4)\n                            ),\n                            # Single observable is returned\n                            (\n                            qml.PauliZ(0) @ qml.Identity(1),\n                            qml.PauliZ(0)\n                            ),\n                            (\n                            qml.Identity(0) @ qml.PauliX(1) @ qml.Identity(2),\n                            qml.PauliX(1)\n                            ),\n                            (\n                            qml.Identity(0) @ qml.Identity(1),\n                            qml.Identity(0)\n                            ),\n                            (\n                            qml.Identity(0) @ qml.Identity(1),\n                            qml.Identity(0)\n                            ),\n                            (\n                            qml.Identity(0) @ qml.Identity(1) @ qml.Hermitian(herm_matrix, wires=[2,3]),\n                            qml.Hermitian(herm_matrix, wires=[2,3])\n                            )\n                         ]\n\n    @pytest.mark.parametrize(""tensor_observable, expected"", tensor_obs_pruning)\n    @pytest.mark.parametrize(""statistics"", [qml.expval, qml.var, qml.sample])\n    def test_prune(self, tensor_observable, expected, statistics):\n        """"""Tests that the prune method returns the expected Tensor or single non-Tensor Observable.""""""\n        O = statistics(tensor_observable)\n        O_expected = statistics(expected)\n\n        O_pruned = O.prune()\n        assert type(O_pruned) == type(expected)\n        assert O_pruned.wires == expected.wires\n        assert O_pruned.return_type == O_expected.return_type\n\nclass TestDecomposition:\n    """"""Test for operation decomposition""""""\n\n    def test_U1_decomposition(self):\n        """"""Test the decomposition of the U1 gate provides the equivalent phase shift gate""""""\n        phi = 0.432\n        res = qml.U1.decomposition(phi, wires=0)\n\n        assert len(res) == 1\n        assert res[0].name == ""PhaseShift""\n        assert res[0].parameters == [phi]\n\n    def test_rotation_decomposition(self):\n        """"""Test the decomposition of the abritrary single\n        qubit rotation""""""\n        phi = 0.432\n        theta = 0.654\n        omega = -5.43\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.Rot.decomposition(phi, theta, omega, wires=0)\n\n        assert len(rec.queue) == 3\n\n        assert rec.queue[0].name == ""RZ""\n        assert rec.queue[0].parameters == [phi]\n\n        assert rec.queue[1].name == ""RY""\n        assert rec.queue[1].parameters == [theta]\n\n        assert rec.queue[2].name == ""RZ""\n        assert rec.queue[2].parameters == [omega]\n\n    def test_crx_decomposition(self):\n        """"""Test the decomposition of the controlled X\n        qubit rotation""""""\n        phi = 0.432\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.CRX.decomposition(phi, wires=[0, 1])\n\n        assert len(rec.queue) == 6\n\n        assert rec.queue[0].name == ""RZ""\n        assert rec.queue[0].parameters == [np.pi/2]\n        assert rec.queue[0].wires == Wires([1])\n\n        assert rec.queue[1].name == ""RY""\n        assert rec.queue[1].parameters == [phi/2]\n        assert rec.queue[1].wires == Wires([1])\n\n        assert rec.queue[2].name == ""CNOT""\n        assert rec.queue[2].parameters == []\n        assert rec.queue[2].wires == Wires([0, 1])\n\n        assert rec.queue[3].name == ""RY""\n        assert rec.queue[3].parameters == [-phi/2]\n        assert rec.queue[3].wires == Wires([1])\n\n        assert rec.queue[4].name == ""CNOT""\n        assert rec.queue[4].parameters == []\n        assert rec.queue[4].wires == Wires([0, 1])\n\n        assert rec.queue[5].name == ""RZ""\n        assert rec.queue[5].parameters == [-np.pi/2]\n        assert rec.queue[5].wires == Wires([1])\n\n    @pytest.mark.parametrize(""phi"", [0.03236*i for i in range(5)])\n    def test_crx_decomposition_correctness(self, phi, tol):\n        """"""Test that the decomposition of the controlled X\n        qubit rotation is correct""""""\n\n        expected = CRotx(phi)\n\n        obtained = np.kron(I, Rotz(-np.pi/2)) @ CNOT @ np.kron(I, Roty(-phi/2)) @ CNOT @ np.kron(I, Roty(phi/2)) @ np.kron(I, Rotz(np.pi/2))\n        assert np.allclose(expected, obtained, atol=tol, rtol=0)\n\n\n    def test_cry_decomposition(self):\n        """"""Test the decomposition of the controlled Y\n        qubit rotation""""""\n        phi = 0.432\n\n        operation_wires = [0, 1]\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.CRY.decomposition(phi, wires=operation_wires)\n\n        assert len(rec.queue) == 4\n\n        assert rec.queue[0].name == ""RY""\n        assert rec.queue[0].parameters == [phi/2]\n        assert rec.queue[0].wires == Wires([1])\n\n        assert rec.queue[1].name == ""CNOT""\n        assert rec.queue[1].parameters == []\n        assert rec.queue[1].wires == Wires(operation_wires)\n\n        assert rec.queue[2].name == ""RY""\n        assert rec.queue[2].parameters == [-phi/2]\n        assert rec.queue[2].wires == Wires([1])\n\n        assert rec.queue[3].name == ""CNOT""\n        assert rec.queue[3].parameters == []\n        assert rec.queue[3].wires == Wires(operation_wires)\n\n    @pytest.mark.parametrize(""phi"", [0.03236*i for i in range(5)])\n    def test_cry_decomposition_correctness(self, phi, tol):\n        """"""Test that the decomposition of the controlled Y\n        qubit rotation is correct""""""\n\n        expected = CRoty(phi)\n\n        obtained = CNOT @ np.kron(I, U3(-phi / 2, 0, 0)) @ CNOT @ np.kron(I, U3(phi / 2, 0, 0))\n        assert np.allclose(expected, obtained, atol=tol, rtol=0)\n\n    def test_crz_decomposition(self):\n        """"""Test the decomposition of the controlled Z\n        qubit rotation""""""\n        phi = 0.432\n\n        operation_wires = [0, 1]\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.CRZ.decomposition(phi, wires=operation_wires)\n\n        assert len(rec.queue) == 4\n\n        assert rec.queue[0].name == ""PhaseShift""\n        assert rec.queue[0].parameters == [phi/2]\n        assert rec.queue[0].wires == Wires([1])\n\n        assert rec.queue[1].name == ""CNOT""\n        assert rec.queue[1].parameters == []\n        assert rec.queue[1].wires == Wires(operation_wires)\n\n        assert rec.queue[2].name == ""PhaseShift""\n        assert rec.queue[2].parameters == [-phi/2]\n        assert rec.queue[2].wires == Wires([1])\n\n        assert rec.queue[3].name == ""CNOT""\n        assert rec.queue[3].parameters == []\n        assert rec.queue[3].wires == Wires(operation_wires)\n\n    @pytest.mark.parametrize(""phi"", [0.03236*i for i in range(5)])\n    def test_crz_decomposition_correctness(self, phi, tol):\n        """"""Test that the decomposition of the controlled Z\n        qubit rotation is correct""""""\n\n        expected = CRotz(phi)\n\n        obtained = CNOT @ np.kron(I, Rphi(-phi / 2)) @ CNOT @ np.kron(I, Rphi(phi / 2))\n        assert np.allclose(expected, obtained, atol=tol, rtol=0)\n\n    def test_U2_decomposition(self):\n        """"""Test the U2 decomposition is correct""""""\n        phi = 0.432\n        lam = 0.654\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.U2.decomposition(phi, lam, wires=0)\n\n        assert len(rec.queue) == 3\n\n        assert rec.queue[0].name == ""Rot""\n        assert rec.queue[0].parameters == [lam, np.pi/2, -lam]\n\n        assert rec.queue[1].name == ""PhaseShift""\n        assert rec.queue[1].parameters == [lam]\n\n        assert rec.queue[2].name == ""PhaseShift""\n        assert rec.queue[2].parameters == [phi]\n\n    def test_U3_decomposition(self):\n        """"""Test the U3 decomposition is correct""""""\n        theta = 0.654\n        phi = 0.432\n        lam = 0.654\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.U3.decomposition(theta, phi, lam, wires=0)\n\n        assert len(rec.queue) == 3\n\n        assert rec.queue[0].name == ""Rot""\n        assert rec.queue[0].parameters == [lam, theta, -lam]\n\n        assert rec.queue[1].name == ""PhaseShift""\n        assert rec.queue[1].parameters == [lam]\n\n        assert rec.queue[2].name == ""PhaseShift""\n        assert rec.queue[2].parameters == [phi]\n\n    def test_basis_state_decomposition(self, monkeypatch):\n        """"""Test the decomposition of BasisState calls the\n        BasisStatePreparation template""""""\n        n = np.array([1, 0, 1, 1])\n        wires=[0, 1, 2, 3]\n        call_args = []\n\n        # We have to patch BasisStatePreparation where it is loaded\n        monkeypatch.setattr(qml.ops.qubit, ""BasisStatePreparation"", lambda *args: call_args.append(args))\n        qml.BasisState.decomposition(n, wires=wires)\n\n        assert len(call_args) == 1\n        assert np.array_equal(call_args[0][0], n)\n        assert np.array_equal(call_args[0][1], wires)\n\n    def test_qubit_state_vector_decomposition(self, monkeypatch):\n        """"""Test the decomposition of QubitStateVector calls the\n        MottonenStatePreparation template""""""\n        state = np.array([1/2, 1j/np.sqrt(2), 0, -1/2])\n        wires = [0, 1]\n        call_args = []\n\n        # We have to patch MottonenStatePreparation where it is loaded\n        monkeypatch.setattr(qml.ops.qubit, ""MottonenStatePreparation"", lambda *args: call_args.append(args))\n        qml.QubitStateVector.decomposition(state, wires=wires)\n\n        assert len(call_args) == 1\n        assert np.array_equal(call_args[0][0], state)\n        assert np.array_equal(call_args[0][1], wires)\n'"
tests/test_optimize.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` optimizers.\n""""""\n# pylint: disable=redefined-outer-name\nimport itertools as it\n\nimport numpy as onp\nimport pytest\n\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom pennylane.utils import _flatten\nfrom pennylane.optimize import (GradientDescentOptimizer,\n                                MomentumOptimizer,\n                                NesterovMomentumOptimizer,\n                                AdagradOptimizer,\n                                RMSPropOptimizer,\n                                AdamOptimizer,\n                                RotoselectOptimizer,\n                                RotosolveOptimizer)\n\nx_vals = np.linspace(-10, 10, 16, endpoint=False)\n\n# Hyperparameters for optimizers\nstepsize = 0.1\ngamma = 0.5\ndelta = 0.8\n\n\n# function arguments in various formats\nmixed_list = [(0.2, 0.3), np.array([0.4, 0.2, 0.4]), 0.1]\nmixed_tuple = (np.array([0.2, 0.3]), [0.4, 0.2, 0.4], 0.1)\nnested_list = [[[0.2], 0.3], [0.1, [0.4]], -0.1]\nflat_list = [0.2, 0.3, 0.1, 0.4, -0.1]\nmultid_array = np.array([[0.1, 0.2], [-0.1, -0.4]])\nmultid_list = [[0.1, 0.2], [-0.1, -0.4]]\n\n\n# functions and their gradients\nfnames = [\'test_function_1\', \'test_function_2\', \'test_function_3\']\nunivariate_funcs = [np.sin,\n                    lambda x: np.exp(x / 10.),\n                    lambda x: x ** 2]\ngrad_uni_fns = [np.cos,\n                lambda x: np.exp(x / 10.) / 10.,\n                lambda x: 2 * x]\nmultivariate_funcs = [lambda x: np.sin(x[0]) + np.cos(x[1]),\n                      lambda x: np.exp(x[0] / 3) * np.tanh(x[1]),\n                      lambda x: np.sum([x_ ** 2 for x_ in x])]\ngrad_multi_funcs = [lambda x: np.array([np.cos(x[0]), -np.sin(x[1])]),\n                    lambda x: np.array([np.exp(x[0] / 3) / 3 * np.tanh(x[1]),\n                                        np.exp(x[0] / 3) * (1 - np.tanh(x[1]) ** 2)]),\n                    lambda x: np.array([2 * x_ for x_ in x])]\nmvar_mdim_funcs = [lambda x: np.sin(x[0, 0]) + np.cos(x[1, 0]) - np.sin(x[0, 1]) + x[1, 1],\n                   lambda x: np.exp(x[0, 0] / 3) * np.tanh(x[0, 1]),\n                   lambda x: np.sum([x_[0] ** 2 for x_ in x])]\ngrad_mvar_mdim_funcs = [lambda x: np.array([[np.cos(x[0, 0]), -np.cos(x[0, 1])],\n                                            [-np.sin(x[1, 0]), 1.]]),\n                        lambda x: np.array([[np.exp(x[0, 0] / 3) / 3 * np.tanh(x[0, 1]),\n                                             np.exp(x[0, 0] / 3) * (1 - np.tanh(x[0, 1]) ** 2)],\n                                            [0., 0.]]),\n                        lambda x: np.array([[2 * x_[0], 0.] for x_ in x])]\n\n\n\n@qml.qnode(qml.device(\'default.qubit\', wires=1))\ndef quant_fun(variables):\n    qml.RX(variables[0][1], wires=[0])\n    qml.RY(variables[1][2], wires=[0])\n    qml.RY(variables[2], wires=[0])\n    return qml.expval(qml.PauliZ(0))\n\n\n@qml.qnode(qml.device(\'default.qubit\', wires=1))\ndef quant_fun_nested(var):\n    qml.RX(var[0][0][0], wires=[0])\n    qml.RY(var[0][1], wires=[0])\n    qml.RY(var[1][0], wires=[0])\n    qml.RX(var[1][1][0], wires=[0])\n    return qml.expval(qml.PauliZ(0))\n\n\n@qml.qnode(qml.device(\'default.qubit\', wires=1))\ndef quant_fun_flat(var):\n    qml.RX(var[0], wires=[0])\n    qml.RY(var[1], wires=[0])\n    qml.RY(var[2], wires=[0])\n    qml.RX(var[3], wires=[0])\n    return qml.expval(qml.PauliZ(0))\n\n\n@qml.qnode(qml.device(\'default.qubit\', wires=1))\ndef quant_fun_mdarr(var):\n    qml.RX(var[0, 1], wires=[0])\n    qml.RY(var[1, 0], wires=[0])\n    qml.RY(var[1, 1], wires=[0])\n    return qml.expval(qml.PauliZ(0))\n\n\n@qml.qnode(qml.device(\'default.qubit\', wires=1))\ndef quant_fun_mdlist(var):\n    qml.RX(var[0][1], wires=[0])\n    qml.RY(var[1][0], wires=[0])\n    qml.RY(var[1][1], wires=[0])\n    return qml.expval(qml.PauliZ(0))\n\n\n@pytest.fixture(scope=""function"")\ndef bunch():\n    class A:\n        sgd_opt = GradientDescentOptimizer(stepsize)\n        mom_opt = MomentumOptimizer(stepsize, momentum=gamma)\n        nesmom_opt = NesterovMomentumOptimizer(stepsize, momentum=gamma)\n        adag_opt = AdagradOptimizer(stepsize)\n        rms_opt = RMSPropOptimizer(stepsize, decay=gamma)\n        adam_opt = AdamOptimizer(stepsize, beta1=gamma, beta2=delta)\n        rotosolve_opt = RotosolveOptimizer()\n        rotoselect_opt = RotoselectOptimizer()\n\n    return A()\n\n\nclass TestOptimizer:\n    """"""Basic optimizer tests.\n    """"""\n    def test_mixed_inputs_for_hybrid_optimization(self, bunch, tol):\n        """"""Tests that gradient descent optimizer treats parameters of mixed types the same\n        for hybrid optimization tasks.""""""\n\n        def hybrid_fun(variables):\n            return quant_fun(variables) + variables[0][1]\n\n        hybrid_list = bunch.sgd_opt.step(hybrid_fun, mixed_list)\n        hybrid_tuple = bunch.sgd_opt.step(hybrid_fun, mixed_tuple)\n\n        assert hybrid_list[0] == pytest.approx(hybrid_tuple[0], abs=tol)\n        assert hybrid_list[1] == pytest.approx(hybrid_tuple[1], abs=tol)\n        assert hybrid_list[2] == pytest.approx(hybrid_tuple[2], abs=tol)\n\n    def test_mixed_inputs_for_classical_optimization(self, bunch, tol):\n        """"""Tests that gradient descent optimizer treats parameters of mixed types the same\n        for purely classical optimization tasks.""""""\n\n        def class_fun(var):\n            return var[0][1] * 2. + var[1][2] + var[2]\n\n        class_list = bunch.sgd_opt.step(class_fun, mixed_list)\n        class_tuple = bunch.sgd_opt.step(class_fun, mixed_tuple)\n\n        assert class_list[0] == pytest.approx(class_tuple[0], abs=tol)\n        assert class_list[1] == pytest.approx(class_tuple[1], abs=tol)\n        assert class_list[2] == pytest.approx(class_tuple[2], abs=tol)\n\n    def test_mixed_inputs_for_quantum_optimization(self, bunch, tol):\n        """"""Tests that gradient descent optimizer treats parameters of mixed types the same\n        for purely quantum optimization tasks.""""""\n\n        quant_list = bunch.sgd_opt.step(quant_fun, mixed_list)\n        quant_tuple = bunch.sgd_opt.step(quant_fun, mixed_tuple)\n\n        assert quant_list[0] == pytest.approx(quant_tuple[0], abs=tol)\n        assert quant_list[1] == pytest.approx(quant_tuple[1], abs=tol)\n        assert quant_list[2] == pytest.approx(quant_tuple[2], abs=tol)\n\n    def test_nested_and_flat_returns_same_update(self, bunch, tol):\n        """"""Tests that gradient descent optimizer has the same output for\n         nested and flat lists.""""""\n\n        def hybrid_fun_flat(var):\n            return quant_fun_flat(var) + var[4]\n\n        def hybrid_fun_nested(var):\n            return quant_fun_nested(var) + var[2]\n\n        nested = bunch.sgd_opt.step(hybrid_fun_nested, nested_list)\n        flat = bunch.sgd_opt.step(hybrid_fun_flat, flat_list)\n\n        assert flat == pytest.approx(list(_flatten(nested)), abs=tol)\n\n    def test_array_and_list_return_same_update(self, bunch, tol):\n        """"""Tests that gradient descent optimizer has the same output for\n         lists and arrays.""""""\n\n        def hybrid_fun_mdarr(var):\n            return quant_fun_mdarr(var) + var[0, 0]\n\n        def hybrid_fun_mdlist(var):\n            return quant_fun_mdlist(var) + var[0][0]\n\n        array = bunch.sgd_opt.step(hybrid_fun_mdarr, multid_array)\n        list = bunch.sgd_opt.step(hybrid_fun_mdlist, multid_list)\n\n        assert array == pytest.approx(np.asarray(list), abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_gradient_descent_optimizer_univar(self, x_start, bunch, tol):\n        """"""Tests that basic stochastic gradient descent takes gradient-descent steps correctly\n        for uni-variate functions.""""""\n\n        # TODO parametrize this for also\n        for gradf, f, name in zip(grad_uni_fns, univariate_funcs, fnames):\n            x_new = bunch.sgd_opt.step(f, x_start)\n            x_correct = x_start - gradf(x_start) * stepsize\n            assert x_new == pytest.approx(x_correct, abs=tol)\n\n    def test_gradient_descent_optimizer_multivar(self, bunch, tol):\n        """"""Tests that basic stochastic gradient descent takes gradient-descent steps correctly\n        for multi-variate functions.""""""\n\n        for gradf, f, name in zip(grad_multi_funcs, multivariate_funcs, fnames):\n            for jdx in range(len(x_vals[:-1])):\n                x_vec = x_vals[jdx:jdx+2]\n                x_new = bunch.sgd_opt.step(f, x_vec)\n                x_correct = x_vec - gradf(x_vec) * stepsize\n                assert x_new == pytest.approx(x_correct, abs=tol)\n\n    def test_gradient_descent_optimizer_multivar_multidim(self, bunch, tol):\n        """"""Tests that basic stochastic gradient descent takes gradient-descent steps correctly\n        for multi-variate functions and with higher dimensional inputs.""""""\n\n        for gradf, f, name in zip(grad_mvar_mdim_funcs, mvar_mdim_funcs, fnames):\n            for jdx in range(len(x_vals[:-3])):\n                x_vec = x_vals[jdx:jdx+4]\n                x_vec_multidim = np.reshape(x_vec, (2, 2))\n                x_new = bunch.sgd_opt.step(f, x_vec_multidim)\n                x_correct = x_vec_multidim - gradf(x_vec_multidim) * stepsize\n                x_new_flat = x_new.flatten()\n                x_correct_flat = x_correct.flatten()\n                assert x_new_flat == pytest.approx(x_correct_flat, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_gradient_descent_optimizer_usergrad(self, x_start, bunch, tol):\n        """"""Tests that basic stochastic gradient descent takes gradient-descent steps correctly\n        using user-provided gradients.""""""\n\n        for gradf, f, name in zip(grad_uni_fns[::-1], univariate_funcs, fnames):\n            x_new = bunch.sgd_opt.step(f, x_start, grad_fn=gradf)\n            x_correct = x_start - gradf(x_start) * stepsize\n            assert x_new == pytest.approx(x_correct, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_momentum_optimizer_univar(self, x_start, bunch, tol):\n        """"""Tests that momentum optimizer takes one and two steps correctly\n        for uni-variate functions.""""""\n\n        for gradf, f, name in zip(grad_uni_fns, univariate_funcs, fnames):\n            bunch.mom_opt.reset()\n\n            x_onestep = bunch.mom_opt.step(f, x_start)\n            x_onestep_target = x_start - gradf(x_start) * stepsize\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.mom_opt.step(f, x_onestep)\n            momentum_term = gamma * gradf(x_start)\n            x_twosteps_target = x_onestep - (gradf(x_onestep) + momentum_term) * stepsize\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    def test_momentum_optimizer_multivar(self, bunch, tol):\n        """"""Tests that momentum optimizer takes one and two steps correctly\n        for multi-variate functions.""""""\n\n        for gradf, f, name in zip(grad_multi_funcs, multivariate_funcs, fnames):\n            for jdx in range(len(x_vals[:-1])):\n                bunch.mom_opt.reset()\n\n                x_vec = x_vals[jdx:jdx + 2]\n                x_onestep = bunch.mom_opt.step(f, x_vec)\n                x_onestep_target = x_vec - gradf(x_vec) * stepsize\n                assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n                x_twosteps = bunch.mom_opt.step(f, x_onestep)\n                momentum_term = gamma * gradf(x_vec)\n                x_twosteps_target = x_onestep - (gradf(x_onestep) + momentum_term) * stepsize\n                assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_nesterovmomentum_optimizer_univar(self, x_start, bunch, tol):\n        """"""Tests that nesterov momentum optimizer takes one and two steps correctly\n        for uni-variate functions.""""""\n\n        for gradf, f, name in zip(grad_uni_fns, univariate_funcs, fnames):\n            bunch.nesmom_opt.reset()\n\n            x_onestep = bunch.nesmom_opt.step(f, x_start)\n            x_onestep_target = x_start - gradf(x_start) * stepsize\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.nesmom_opt.step(f, x_onestep)\n            momentum_term = gamma * gradf(x_start)\n            shifted_grad_term = gradf(x_onestep - stepsize * momentum_term)\n            x_twosteps_target = x_onestep - (shifted_grad_term + momentum_term) * stepsize\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    def test_nesterovmomentum_optimizer_multivar(self, bunch, tol):\n        """"""Tests that nesterov momentum optimizer takes one and two steps correctly\n        for multi-variate functions.""""""\n\n        for gradf, f, name in zip(grad_multi_funcs, multivariate_funcs, fnames):\n            for jdx in range(len(x_vals[:-1])):\n                bunch.nesmom_opt.reset()\n\n                x_vec = x_vals[jdx:jdx + 2]\n                x_onestep = bunch.nesmom_opt.step(f, x_vec)\n                x_onestep_target = x_vec - gradf(x_vec) * stepsize\n                assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n                x_twosteps = bunch.nesmom_opt.step(f, x_onestep)\n                momentum_term = gamma * gradf(x_vec)\n                shifted_grad_term = gradf(x_onestep - stepsize * momentum_term)\n                x_twosteps_target = x_onestep - (shifted_grad_term + momentum_term) * stepsize\n                assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_nesterovmomentum_optimizer_usergrad(self, x_start, bunch, tol):\n        """"""Tests that nesterov momentum optimizer takes gradient-descent steps correctly\n        using user-provided gradients.""""""\n\n        for gradf, f, name in zip(grad_uni_fns[::-1], univariate_funcs, fnames):\n            bunch.nesmom_opt.reset()\n\n            x_onestep = bunch.nesmom_opt.step(f, x_start, grad_fn=gradf)\n            x_onestep_target = x_start - gradf(x_start) * stepsize\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.nesmom_opt.step(f, x_onestep, grad_fn=gradf)\n            momentum_term = gamma * gradf(x_start)\n            shifted_grad_term = gradf(x_onestep - stepsize * momentum_term)\n            x_twosteps_target = x_onestep - (shifted_grad_term + momentum_term) * stepsize\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_adagrad_optimizer_univar(self, x_start, bunch, tol):\n        """"""Tests that adagrad optimizer takes one and two steps correctly\n        for uni-variate functions.""""""\n\n        for gradf, f, name in zip(grad_uni_fns, univariate_funcs, fnames):\n            bunch.adag_opt.reset()\n\n            x_onestep = bunch.adag_opt.step(f, x_start)\n            past_grads = gradf(x_start)*gradf(x_start)\n            adapt_stepsize = stepsize/np.sqrt(past_grads + 1e-8)\n            x_onestep_target = x_start - gradf(x_start) * adapt_stepsize\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.adag_opt.step(f, x_onestep)\n            past_grads = gradf(x_start)*gradf(x_start) + gradf(x_onestep)*gradf(x_onestep)\n            adapt_stepsize = stepsize/np.sqrt(past_grads + 1e-8)\n            x_twosteps_target = x_onestep - gradf(x_onestep) * adapt_stepsize\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    def test_adagrad_optimizer_multivar(self, bunch, tol):\n        """"""Tests that adagrad optimizer takes one and two steps correctly\n        for multi-variate functions.""""""\n\n        for gradf, f, name in zip(grad_multi_funcs, multivariate_funcs, fnames):\n            for jdx in range(len(x_vals[:-1])):\n                bunch.adag_opt.reset()\n\n                x_vec = x_vals[jdx:jdx + 2]\n                x_onestep = bunch.adag_opt.step(f, x_vec)\n                past_grads = gradf(x_vec)*gradf(x_vec)\n                adapt_stepsize = stepsize/np.sqrt(past_grads + 1e-8)\n                x_onestep_target = x_vec - gradf(x_vec) * adapt_stepsize\n                assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n                x_twosteps = bunch.adag_opt.step(f, x_onestep)\n                past_grads = gradf(x_vec) * gradf(x_vec) + gradf(x_onestep) * gradf(x_onestep)\n                adapt_stepsize = stepsize / np.sqrt(past_grads + 1e-8)\n                x_twosteps_target = x_onestep - gradf(x_onestep) * adapt_stepsize\n                assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_rmsprop_optimizer_univar(self, x_start, bunch, tol):\n        """"""Tests that rmsprop optimizer takes one and two steps correctly\n        for uni-variate functions.""""""\n\n        for gradf, f, name in zip(grad_uni_fns, univariate_funcs, fnames):\n            bunch.rms_opt.reset()\n\n            x_onestep = bunch.rms_opt.step(f, x_start)\n            past_grads = (1 - gamma) * gradf(x_start)*gradf(x_start)\n            adapt_stepsize = stepsize/np.sqrt(past_grads + 1e-8)\n            x_onestep_target = x_start - gradf(x_start) * adapt_stepsize\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.rms_opt.step(f, x_onestep)\n            past_grads = (1 - gamma) * gamma * gradf(x_start)*gradf(x_start) \\\n                         + (1 - gamma) * gradf(x_onestep)*gradf(x_onestep)\n            adapt_stepsize = stepsize/np.sqrt(past_grads + 1e-8)\n            x_twosteps_target = x_onestep - gradf(x_onestep) * adapt_stepsize\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    def test_rmsprop_optimizer_multivar(self, bunch, tol):\n        """"""Tests that rmsprop optimizer takes one and two steps correctly\n        for multi-variate functions.""""""\n\n        for gradf, f, name in zip(grad_multi_funcs, multivariate_funcs, fnames):\n            for jdx in range(len(x_vals[:-1])):\n                bunch.rms_opt.reset()\n\n                x_vec = x_vals[jdx:jdx + 2]\n                x_onestep = bunch.rms_opt.step(f, x_vec)\n                past_grads = (1 - gamma) * gradf(x_vec)*gradf(x_vec)\n                adapt_stepsize = stepsize/np.sqrt(past_grads + 1e-8)\n                x_onestep_target = x_vec - gradf(x_vec) * adapt_stepsize\n                assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n                x_twosteps = bunch.rms_opt.step(f, x_onestep)\n                past_grads = (1 - gamma) * gamma * gradf(x_vec) * gradf(x_vec) \\\n                             + (1 - gamma) * gradf(x_onestep) * gradf(x_onestep)\n                adapt_stepsize = stepsize / np.sqrt(past_grads + 1e-8)\n                x_twosteps_target = x_onestep - gradf(x_onestep) * adapt_stepsize\n                assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_adam_optimizer_univar(self, x_start, bunch, tol):\n        """"""Tests that adam optimizer takes one and two steps correctly\n        for uni-variate functions.""""""\n\n        for gradf, f, name in zip(grad_uni_fns, univariate_funcs, fnames):\n            bunch.adam_opt.reset()\n\n            x_onestep = bunch.adam_opt.step(f, x_start)\n            adapted_stepsize = stepsize * np.sqrt(1 - delta)/(1 - gamma)\n            firstmoment = gradf(x_start)\n            secondmoment = gradf(x_start) * gradf(x_start)\n            x_onestep_target = x_start - adapted_stepsize * firstmoment / (np.sqrt(secondmoment) + 1e-8)\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.adam_opt.step(f, x_onestep)\n            adapted_stepsize = stepsize * np.sqrt(1 - delta**2) / (1 - gamma**2)\n            firstmoment = (gamma * gradf(x_start) + (1 - gamma) * gradf(x_onestep))\n            secondmoment = (delta * gradf(x_start) * gradf(x_start) + (1 - delta) * gradf(x_onestep) * gradf(x_onestep))\n            x_twosteps_target = x_onestep - adapted_stepsize * firstmoment / (np.sqrt(secondmoment) + 1e-8)\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    def test_adam_optimizer_multivar(self, bunch, tol):\n        """"""Tests that adam optimizer takes one and two steps correctly\n        for multi-variate functions.""""""\n\n        for gradf, f, name in zip(grad_multi_funcs, multivariate_funcs, fnames):\n            for jdx in range(len(x_vals[:-1])):\n                bunch.adam_opt.reset()\n\n                x_vec = x_vals[jdx:jdx + 2]\n                x_onestep = bunch.adam_opt.step(f, x_vec)\n                adapted_stepsize = stepsize * np.sqrt(1 - delta) / (1 - gamma)\n                firstmoment = gradf(x_vec)\n                secondmoment = gradf(x_vec) * gradf(x_vec)\n                x_onestep_target = x_vec - adapted_stepsize * firstmoment / (np.sqrt(secondmoment) + 1e-8)\n                assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n                x_twosteps = bunch.adam_opt.step(f, x_onestep)\n                adapted_stepsize = stepsize * np.sqrt(1 - delta**2) / (1 - gamma**2)\n                firstmoment = (gamma * gradf(x_vec) + (1 - gamma) * gradf(x_onestep))\n                secondmoment = (delta * gradf(x_vec) * gradf(x_vec) + (1 - delta) * gradf(x_onestep) * gradf(x_onestep))\n                x_twosteps_target = x_onestep - adapted_stepsize * firstmoment / (np.sqrt(secondmoment) + 1e-8)\n                assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @staticmethod\n    def rotosolve_step(f, x):\n        """"""Helper function to test the Rotosolve and Rotoselect optimizers""""""\n        # make sure that x is an array\n        if np.ndim(x) == 0:\n            x = np.array([x])\n\n        # helper function for x[d] = theta\n        def insert(xf, d, theta):\n            xf[d] = theta\n            return xf\n\n        for d, _ in enumerate(x):\n            H_0 = float(f(insert(x, d, 0)))\n            H_p = float(f(insert(x, d, np.pi / 2)))\n            H_m = float(f(insert(x, d, -np.pi / 2)))\n            a = onp.arctan2(2 * H_0 - H_p - H_m, H_p - H_m)\n\n            x[d] = -np.pi / 2 - a\n\n            if x[d] <= -np.pi:\n                x[d] += 2 * np.pi\n        return x\n\n    @pytest.mark.parametrize(\'x_start\', x_vals)\n    def test_rotosolve_optimizer_univar(self, x_start, bunch, tol):\n        """"""Tests that rotosolve optimizer takes one and two steps correctly\n        for uni-variate functions.""""""\n\n        for f in univariate_funcs:\n            x_onestep = bunch.rotosolve_opt.step(f, x_start)\n            x_onestep_target = self.rotosolve_step(f, x_start)\n\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.rotosolve_opt.step(f, x_onestep)\n            x_twosteps_target = self.rotosolve_step(f, x_onestep_target)\n\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', [[1.2, 0.2],\n                                         [-0.62, -2.1],\n                                         [0.05, 0.8],\n                                         [[0.3], [0.25]],\n                                         [[-0.6], [0.45]],\n                                         [[1.3], [-0.9]]])\n    def test_rotosolve_optimizer_multivar(self, x_start, bunch, tol):\n        """"""Tests that rotosolve optimizer takes one and two steps correctly\n        for multi-variate functions.""""""\n\n        for func in multivariate_funcs:\n            # alter multivariate_func to accept nested lists of parameters\n            f = lambda x: func(np.ravel(x))\n\n            x_onestep = bunch.rotosolve_opt.step(f, x_start)\n            x_onestep_target = self.rotosolve_step(f, x_start)\n\n            assert x_onestep == pytest.approx(x_onestep_target, abs=tol)\n\n            x_twosteps = bunch.rotosolve_opt.step(f, x_onestep)\n            x_twosteps_target = self.rotosolve_step(f, x_onestep_target)\n\n            assert x_twosteps == pytest.approx(x_twosteps_target, abs=tol)\n\n    @pytest.mark.parametrize(\'x_start\', [[1.2, 0.2],\n                                         [-0.62, -2.1],\n                                         [0.05, 0.8]])\n    @pytest.mark.parametrize(\'generators\', [list(tup) for tup in it.product([qml.RX, qml.RY, qml.RZ], repeat=2)])\n    def test_rotoselect_optimizer(self, x_start, generators, bunch, tol):\n        """"""Tests that rotoselect optimizer finds the optimal generators and parameters for the VQE circuit\n        defined in `this rotoselect tutorial <https://pennylane.ai/qml/demos/tutorial_rotoselect.html>`_.""""""\n\n        # the optimal generators for the 2-qubit VQE circuit\n        # H = 0.5 * Y_2 + 0.8 * Z_1 - 0.2 * X_1\n        optimal_generators = [qml.RY, qml.RX]\n        possible_generators = [qml.RX, qml.RY, qml.RZ]\n        bunch.rotoselect_opt.possible_generators = possible_generators\n\n        dev = qml.device(""default.qubit"", analytic=True, wires=2)\n\n        def ansatz(params, generators):\n            generators[0](params[0], wires=0)\n            generators[1](params[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n\n        @qml.qnode(dev)\n        def circuit_1(params, generators=None):  # generators will be passed as a keyword arg\n            ansatz(params, generators)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        @qml.qnode(dev)\n        def circuit_2(params, generators=None):  # generators will be passed as a keyword arg\n            ansatz(params, generators)\n            return qml.expval(qml.PauliX(0))\n\n        def cost_fn(params, generators):\n            Z_1, Y_2 = circuit_1(params, generators=generators)\n            X_1 = circuit_2(params, generators=generators)\n            return 0.5 * Y_2 + 0.8 * Z_1 - 0.2 * X_1\n\n        f_best_gen = lambda x: cost_fn(x, optimal_generators)\n        optimal_x_start = x_start.copy()\n\n        # after four steps the optimzer should find the optimal generators/x_start values\n        for _ in range(4):\n            x_start, generators = bunch.rotoselect_opt.step(cost_fn, x_start, generators)\n            optimal_x_start = self.rotosolve_step(f_best_gen, optimal_x_start)\n\n        assert x_start == pytest.approx(optimal_x_start, abs=tol)\n        assert generators == optimal_generators\n\n\n    def test_update_stepsize(self):\n        """"""Tests that the stepsize correctly updates""""""\n\n        eta = 0.5\n        opt = AdamOptimizer(eta)\n        assert opt._stepsize == eta\n\n        eta2 = 0.1\n        opt.update_stepsize(eta2)\n        assert opt._stepsize == eta2\n'"
tests/test_optimize_qng.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tests for the QNG optimizer""""""\nimport pytest\nimport scipy as sp\n\nimport pennylane as qml\nfrom pennylane import numpy as np\n\n\nclass TestExceptions:\n    """"""Test exceptions are raised for incorrect usage""""""\n\n    def test_obj_func_not_a_qnode(self):\n        """"""Test that if the objective function is not a\n        QNode, an error is raised.""""""\n\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        def cost(a):\n            return circuit(a)\n\n        opt = qml.QNGOptimizer()\n        params = 0.5\n\n        with pytest.raises(\n            ValueError, match=""The objective function must either be encoded as a single QNode or a VQECost object""\n        ):\n            opt.step(cost, params)\n\n\nclass TestOptimize:\n    """"""Test basic optimization integration""""""\n\n    def test_qubit_rotation(self, tol):\n        """"""Test qubit rotation has the correct QNG value\n        every step, the correct parameter updates,\n        and correct cost after 200 steps""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def circuit(params):\n            qml.RX(params[0], wires=0)\n            qml.RY(params[1], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        def gradient(params):\n            """"""Returns the gradient of the above circuit""""""\n            da = -np.sin(params[0]) * np.cos(params[1])\n            db = -np.cos(params[0]) * np.sin(params[1])\n            return np.array([da, db])\n\n        eta = 0.01\n        init_params = np.array([0.011, 0.012])\n        num_steps = 200\n\n        opt = qml.QNGOptimizer(eta)\n        theta = init_params\n\n        # optimization for 200 steps total\n        for t in range(num_steps):\n            theta_new = opt.step(circuit, theta)\n\n            # check metric tensor\n            res = opt.metric_tensor\n            exp = np.diag([0.25, (np.cos(theta[0]) ** 2)/4])\n            assert np.allclose(res, exp, atol=tol, rtol=0)\n\n            # check parameter update\n            dtheta = eta * sp.linalg.pinvh(exp) @ gradient(theta)\n            assert np.allclose(dtheta, theta - theta_new, atol=tol, rtol=0)\n\n            theta = theta_new\n\n        # check final cost\n        assert np.allclose(circuit(theta), -0.9963791, atol=tol, rtol=0)\n\n    def test_single_qubit_vqe(self, tol):\n        """"""Test single-qubit VQE has the correct QNG value\n        every step, the correct parameter updates,\n        and correct cost after 200 steps""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def circuit(params, wires=0):\n            qml.RX(params[0], wires=wires)\n            qml.RY(params[1], wires=wires)\n\n        coeffs = [1, 1]\n        obs_list = [\n            qml.PauliX(0),\n            qml.PauliZ(0)\n        ]\n\n        qnodes = qml.map(circuit, obs_list, dev, measure=\'expval\')\n        cost_fn = qml.dot(coeffs, qnodes)\n\n        def gradient(params):\n            """"""Returns the gradient""""""\n            da = -np.sin(params[0]) * (np.cos(params[1]) + np.sin(params[1]))\n            db = np.cos(params[0]) * (np.cos(params[1]) - np.sin(params[1]))\n            return np.array([da, db])\n\n        eta = 0.01\n        init_params = np.array([0.011, 0.012])\n        num_steps = 200\n\n        opt = qml.QNGOptimizer(eta)\n        theta = init_params\n\n        # optimization for 200 steps total\n        for t in range(num_steps):\n            theta_new = opt.step(cost_fn, theta,\n                                 metric_tensor_fn=qnodes.qnodes[0].metric_tensor)\n\n            # check metric tensor\n            res = opt.metric_tensor\n            exp = np.diag([0.25, (np.cos(theta[0]) ** 2)/4])\n            assert np.allclose(res, exp, atol=tol, rtol=0)\n\n            # check parameter update\n            dtheta = eta * sp.linalg.pinvh(exp) @ gradient(theta)\n            assert np.allclose(dtheta, theta - theta_new, atol=tol, rtol=0)\n\n            theta = theta_new\n\n        # check final cost\n        assert np.allclose(cost_fn(theta), -1.41421356, atol=tol, rtol=0)\n\n    def test_single_qubit_vqe_using_vqecost(self, tol):\n        """"""Test single-qubit VQE using VQECost \n        has the correct QNG value every step, the correct parameter updates,\n        and correct cost after 200 steps""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def circuit(params, wires=0):\n            qml.RX(params[0], wires=wires)\n            qml.RY(params[1], wires=wires)\n\n        coeffs = [1, 1]\n        obs_list = [\n            qml.PauliX(0),\n            qml.PauliZ(0)\n        ]\n\n        h = qml.Hamiltonian(coeffs=coeffs, observables=obs_list)\n\n        cost_fn = qml.VQECost(ansatz=circuit, hamiltonian=h, device=dev)\n\n        def gradient(params):\n            """"""Returns the gradient""""""\n            da = -np.sin(params[0]) * (np.cos(params[1]) + np.sin(params[1]))\n            db = np.cos(params[0]) * (np.cos(params[1]) - np.sin(params[1]))\n            return np.array([da, db])\n\n        eta = 0.01\n        init_params = np.array([0.011, 0.012])\n        num_steps = 200\n\n        opt = qml.QNGOptimizer(eta)\n        theta = init_params\n\n        # optimization for 200 steps total\n        for t in range(num_steps):\n            theta_new = opt.step(cost_fn, theta)\n\n            # check metric tensor\n            res = opt.metric_tensor\n            exp = np.diag([0.25, (np.cos(theta[0]) ** 2)/4])\n            assert np.allclose(res, exp, atol=tol, rtol=0)\n\n            # check parameter update\n            dtheta = eta * sp.linalg.pinvh(exp) @ gradient(theta)\n            assert np.allclose(dtheta, theta - theta_new, atol=tol, rtol=0)\n\n            theta = theta_new\n\n        # check final cost\n        assert np.allclose(cost_fn(theta), -1.41421356, atol=tol, rtol=0)\n'"
tests/test_prob.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the PennyLane qml.probs() measurement function.\n""""""\nimport pytest\n\nimport numpy as np\nimport pennylane as qml\n\n\n# make the test deterministic\nnp.random.seed(42)\n\n\n@pytest.fixture\ndef init_state(scope=""session""):\n    """"""Fixture that creates an initial state""""""\n    def _init_state(n):\n        """"""An initial state over n wires""""""\n        state = np.random.random([2 ** n]) + np.random.random([2 ** n]) * 1j\n        state /= np.linalg.norm(state)\n        return state\n\n    return _init_state\n\n\ndef test_full_prob(init_state, tol):\n    """"""Test that the correct probability is returned.""""""\n    dev = qml.device(""default.qubit"", wires=4)\n    state = init_state(4)\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.QubitStateVector(state, wires=list(range(4)))\n        return qml.probs(wires=range(4))\n\n    res = circuit()\n    expected = np.abs(state)**2\n    assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\ndef test_marginal_prob(init_state, tol):\n    """"""Test that the correct marginal probability is returned.""""""\n    dev = qml.device(""default.qubit"", wires=4)\n    state = init_state(4)\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.QubitStateVector(state, wires=list(range(4)))\n        return qml.probs(wires=[1, 3])\n\n    res = circuit()\n    expected = np.reshape(np.abs(state)**2, [2]*4)\n    expected = np.einsum(""ijkl->jl"", expected).flatten()\n    assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\ndef test_integration(tol):\n    """"""Test the probability is correct for a known state preparation.""""""\n    dev = qml.device(""default.qubit"", wires=2)\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.Hadamard(wires=1)\n        qml.CNOT(wires=[0, 1])\n        return qml.probs(wires=[0, 1])\n\n    # expected probability, using [00, 01, 10, 11]\n    # ordering, is [0.5, 0.5, 0, 0]\n\n    res = circuit()\n    expected = np.array([0.5, 0.5, 0, 0])\n    assert np.allclose(res, expected, atol=tol, rtol=0)\n\ndef test_integration_analytic_false(tol):\n    """"""Test the probability is correct for a known state preparation when the\n    analytic attribute is set to False.""""""\n    dev = qml.device(\'default.qubit\', wires=3, analytic=False)\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.PauliX(0)\n        return qml.probs(wires=[0])\n\n    res = circuit()\n    expected = np.array([0, 1])\n    assert np.allclose(res, expected, atol=tol, rtol=0)\n\ndef test_numerical_analytic_diff_agree(init_state, tol):\n    """"""Test that the finite difference and parameter shift rule\n    provide the same Jacobian.""""""\n    w = 4\n    dev = qml.device(""default.qubit"", wires=w)\n    state = init_state(w)\n\n    def circuit(x, y, z):\n        for i in range(w):\n            qml.RX(x, wires=i)\n            qml.PhaseShift(z, wires=i)\n            qml.RY(y, wires=i)\n\n        qml.CNOT(wires=[0, 1])\n        qml.CNOT(wires=[1, 2])\n        qml.CNOT(wires=[2, 3])\n\n        return qml.probs(wires=[1, 3])\n\n    circuit = qml.QNode(circuit, dev)\n\n    params = [0.543, -0.765, -0.3]\n    res_F = circuit.jacobian(params, method=""F"")\n    res_A = circuit.jacobian(params, method=""A"")\n\n    # Both jacobians should be of shape (2**prob.wires, num_params)\n    assert res_F.shape == (2**2, 3)\n    assert res_F.shape == (2**2, 3)\n\n    # Check that they agree up to numeric tolerance\n    assert np.allclose(res_F, res_A, atol=tol, rtol=0)\n'"
tests/test_quantum_gradients.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for computing Autograd gradients of quantum functions.\n""""""\n\nimport pytest\nimport autograd\nimport pennylane.numpy as anp  # only to be used inside classical computational nodes\nimport numpy as np\n\nimport pennylane as qml\nfrom gate_data import Rotx as Rx, Roty as Ry, Rotz as Rz\n\n\nalpha = 0.5  # displacement in tests\nhbar = 2\nmag_alphas = np.linspace(0, 1.5, 5)\nthetas = np.linspace(-2*np.pi, 2*np.pi, 8)\nsqz_vals = np.linspace(0., 1., 5)\n\ncv_ops = [getattr(qml.ops, name) for name in qml.ops._cv__ops__]\nanalytic_cv_ops = [cls for cls in cv_ops if cls.supports_parameter_shift]\n\n\nclass PolyN(qml.ops.PolyXP):\n    ""Mimics NumberOperator using the arbitrary 2nd order observable interface. Results should be identical.""\n    def __init__(self, wires):\n        hbar = 2\n        q = np.diag([-0.5, 0.5/hbar, 0.5/hbar])\n        super().__init__(q, wires=wires)\n        self.name = \'PolyXP\'\n\n\n@pytest.fixture(scope=""module"")\ndef gaussian_dev():\n    return qml.device(\'default.gaussian\', wires=2)\n\n\n@pytest.fixture(scope=""module"")\ndef grad_fn_R(gaussian_dev):\n    @qml.qnode(gaussian_dev)\n    def circuit(y):\n        qml.Displacement(alpha, 0., wires=[0])\n        qml.Rotation(y, wires=[0])\n        return qml.expval(qml.X(0))\n    return autograd.grad(circuit)\n\n\n@pytest.fixture(scope=""module"")\ndef grad_fn_BS(gaussian_dev):\n    @qml.qnode(gaussian_dev)\n    def circuit(y):\n        qml.Displacement(alpha, 0., wires=[0])\n        qml.Beamsplitter(y, 0, wires=[0, 1])\n        return qml.expval(qml.X(0))\n    return autograd.grad(circuit)\n\n\n@pytest.fixture(scope=""module"")\ndef grad_fn_D(gaussian_dev):\n    @qml.qnode(gaussian_dev)\n    def circuit(r, phi):\n        qml.Displacement(r, phi, wires=[0])\n        return qml.expval(qml.X(0))\n    return autograd.grad(circuit)\n\n\n@pytest.fixture(scope=""module"")\ndef grad_fn_S(gaussian_dev):\n    @qml.qnode(gaussian_dev)\n    def circuit(y):\n        qml.Displacement(alpha, 0., wires=[0])\n        qml.Squeezing(y, 0., wires=[0])\n        return qml.expval(qml.X(0))\n    return autograd.grad(circuit)\n\n\n@pytest.fixture(scope=""module"")\ndef grad_fn_S_Fock(gaussian_dev):\n    @qml.qnode(gaussian_dev)\n    def circuit(y):\n        qml.Squeezing(y, 0., wires=[0])\n        return qml.expval(qml.FockStateProjector(np.array([2, 0]), wires=[0, 1]))\n    return autograd.grad(circuit)\n\n\nclass TestCVGradient:\n    """"""Tests of the automatic gradient method for CV circuits.""""""\n\n    @pytest.mark.parametrize(\'theta\', thetas)\n    def test_rotation_gradient(self, theta, grad_fn_R, tol):\n        ""Tests that the automatic gradient of a phase space rotation is correct.""\n\n        autograd_val = grad_fn_R(theta)\n        # qfunc evalutes to hbar * alpha * cos(theta)\n        manualgrad_val = - hbar * alpha * np.sin(theta)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'theta\', thetas)\n    def test_beamsplitter_gradient(self, theta, grad_fn_BS, tol):\n        ""Tests that the automatic gradient of a beamsplitter is correct.""\n\n        autograd_val = grad_fn_BS(theta)\n        # qfunc evalutes to hbar * alpha * cos(theta)\n        manualgrad_val = - hbar * alpha * np.sin(theta)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'mag\', mag_alphas)\n    @pytest.mark.parametrize(\'theta\', thetas)\n    def test_displacement_gradient(self, mag, theta, grad_fn_D, tol):\n        ""Tests that the automatic gradient of a phase space displacement is correct.""\n\n        #alpha = mag * np.exp(1j * theta)\n        autograd_val = grad_fn_D(mag, theta)\n        # qfunc evalutes to hbar * Re(alpha)\n        manualgrad_val = hbar * np.cos(theta)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'r\', sqz_vals)\n    def test_squeeze_gradient(self, r, grad_fn_S, tol):\n        ""Tests that the automatic gradient of a phase space squeezing is correct.""\n\n        autograd_val = grad_fn_S(r)\n        # qfunc evaluates to -exp(-r) * hbar * Re(alpha)\n        manualgrad_val = -np.exp(-r) * hbar * alpha\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'r\', sqz_vals[1:])  # formula is not valid for r=0\n    def test_number_state_gradient(self, r, grad_fn_S_Fock, tol):\n        ""Tests that the automatic gradient of a squeezed state with number state expectation is correct.""\n\n        # (d/dr) |<2|S(r)>|^2 = 0.5 tanh(r)^3 (2 csch(r)^2 - 1) sech(r)\n        autograd_val = grad_fn_S_Fock(r)\n        manualgrad_val = 0.5*np.tanh(r)**3 * (2/(np.sinh(r)**2)-1) / np.cosh(r)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'O\', [qml.ops.X, qml.ops.NumberOperator, PolyN])\n    @pytest.mark.parametrize(\'G\', analytic_cv_ops)\n    def test_cv_gradients_gaussian_circuit(self, G, O, gaussian_dev, tol):\n        """"""Tests that the gradients of circuits of gaussian gates match between the finite difference and analytic methods.""""""\n\n        tol = 1e-5\n        par = [0.4]\n        def circuit(x):\n            args = [0.3] * G.num_params\n            args[0] = x\n            qml.Displacement(0.5, 0, wires=0)\n            G(*args, wires=range(G.num_wires))\n            qml.Beamsplitter(1.3, -2.3, wires=[0, 1])\n            qml.Displacement(-0.5, 0.1, wires=0)\n            qml.Squeezing(0.5, -1.5, wires=0)\n            qml.Rotation(-1.1, wires=0)\n            return qml.expval(O(wires=0))\n\n        q = qml.QNode(circuit, gaussian_dev)\n        val = q.evaluate(par, {})\n\n        grad_F  = q.jacobian(par, method=\'F\')\n        grad_A2 = q.jacobian(par, method=\'A\', options={""force_order2"": True})\n        if O.ev_order == 1:\n            grad_A = q.jacobian(par, method=\'A\')\n            # the different methods agree\n            assert grad_A == pytest.approx(grad_F, abs=tol)\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {0:\'A\'}\n        # the different methods agree\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n\n    def test_cv_gradients_multiple_gate_parameters(self, gaussian_dev, tol):\n        ""Tests that gates with multiple free parameters yield correct gradients.""\n        par = [0.4, -0.3, -0.7, 0.2]\n\n        def qf(r0, phi0, r1, phi1):\n            qml.Squeezing(r0, phi0, wires=[0])\n            qml.Squeezing(r1, phi1, wires=[0])\n            return qml.expval(qml.NumberOperator(0))\n\n        q = qml.QNode(qf, gaussian_dev)\n        grad_F = q.jacobian(par, method=\'F\')\n        grad_A = q.jacobian(par, method=\'A\')\n        grad_A2 = q.jacobian(par, method=\'A\', options={""force_order2"": True})\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {i:\'A\' for i in range(4)}\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n        # check against the known analytic formula\n        r0, phi0, r1, phi1 = par\n        dn = np.zeros([4])\n        dn[0] = np.cosh(2 * r1) * np.sinh(2 * r0) + np.cos(phi0 - phi1) * np.cosh(2 * r0) * np.sinh(2 * r1)\n        dn[1] = -0.5 * np.sin(phi0 - phi1) * np.sinh(2 * r0) * np.sinh(2 * r1)\n        dn[2] = np.cos(phi0 - phi1) * np.cosh(2 * r1) * np.sinh(2 * r0) + np.cosh(2 * r0) * np.sinh(2 * r1)\n        dn[3] = 0.5 * np.sin(phi0 - phi1) * np.sinh(2 * r0) * np.sinh(2 * r1)\n\n        assert dn[np.newaxis, :] == pytest.approx(grad_F, abs=tol)\n\n    def test_cv_gradients_repeated_gate_parameters(self, gaussian_dev, tol):\n        ""Tests that repeated use of a free parameter in a multi-parameter gate yield correct gradients.""\n        par = [0.2, 0.3]\n\n        def qf(x, y):\n            qml.Displacement(x, 0, wires=[0])\n            qml.Squeezing(y, -1.3*y, wires=[0])\n            return qml.expval(qml.X(0))\n\n        q = qml.QNode(qf, gaussian_dev)\n        grad_F = q.jacobian(par, method=\'F\')\n        grad_A = q.jacobian(par, method=\'A\')\n        grad_A2 = q.jacobian(par, method=\'A\', options={""force_order2"": True})\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {0:\'A\', 1:\'A\'}\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n\n    def test_cv_gradients_parameters_inside_array(self, gaussian_dev, tol):\n        ""Tests that free parameters inside an array passed to an Operation yield correct gradients.""\n        par = [0.4, 1.3]\n\n        def qf(x, y):\n            qml.Displacement(0.5, 0, wires=[0])\n            qml.Squeezing(x, 0, wires=[0])\n            M = np.zeros((5, 5), dtype=object)\n            M[1,1] = y\n            M[1,2] = 1.0\n            M[2,1] = 1.0\n            return qml.expval(qml.PolyXP(M, [0, 1]))\n\n        q = qml.QNode(qf, gaussian_dev)\n        grad = q.jacobian(par)\n        grad_F = q.jacobian(par, method=\'F\')\n        grad_A = q.jacobian(par, method=""best"")\n        grad_A2 = q.jacobian(par, method=""best"", options={""force_order2"": True})\n\n        # par[0] can use the \'A\' method, par[1] cannot\n        assert q.par_to_grad_method == {0:\'A\', 1:\'F\'}\n        # the different methods agree\n        assert grad == pytest.approx(grad_F, abs=tol)\n\n\n    def test_cv_gradient_fanout(self, gaussian_dev, tol):\n        ""Tests that qnodes can compute the correct gradient when the same parameter is used in multiple gates.""\n        par = [0.5, 1.3]\n\n        def circuit(x, y):\n            qml.Displacement(x, 0, wires=[0])\n            qml.Rotation(y, wires=[0])\n            qml.Displacement(0, x, wires=[0])\n            return qml.expval(qml.X(0))\n\n        q = qml.QNode(circuit, gaussian_dev)\n        grad_F = q.jacobian(par, method=\'F\')\n        grad_A = q.jacobian(par, method=\'A\')\n        grad_A2 = q.jacobian(par, method=\'A\', options={""force_order2"": True})\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {0:\'A\', 1:\'A\'}\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n\n    @pytest.mark.parametrize(\'name\', qml.ops._cv__ops__)\n    def test_CVOperation_with_heisenberg_and_no_params(self, name, gaussian_dev, tol):\n        """"""An integration test for CV gates that support analytic differentiation\n        if succeeding the gate to be differentiated, but cannot be differentiated\n        themselves (for example, they may be Gaussian but accept no parameters).\n\n        This ensures that, assuming their _heisenberg_rep is defined, the quantum\n        gradient analytic method can still be used, and returns the correct result.\n        """"""\n\n        cls = getattr(qml.ops, name)\n        if cls.supports_heisenberg and (not cls.supports_parameter_shift):\n            U = np.array([[0.51310276+0.81702166j, 0.13649626+0.22487759j],\n                          [0.26300233+0.00556194j, -0.96414101-0.03508489j]])\n\n            if cls.num_wires <= 0:\n                w = list(range(2))\n            else:\n                w = list(range(cls.num_wires))\n\n            def circuit(x):\n                qml.Displacement(x, 0, wires=0)\n\n                if cls.par_domain == \'A\':\n                    cls(U, wires=w)\n                else:\n                    cls(wires=w)\n                return qml.expval(qml.X(0))\n\n            qnode = qml.QNode(circuit, gaussian_dev)\n            grad_F = qnode.jacobian(0.5, method=\'F\')\n            grad_A = qnode.jacobian(0.5, method=\'A\')\n            grad_A2 = qnode.jacobian(0.5, method=\'A\', options={""force_order2"": True})\n\n            # par[0] can use the \'A\' method\n            assert qnode.par_to_grad_method == {0: \'A\'}\n\n            # the different methods agree\n            assert grad_A == pytest.approx(grad_F, abs=tol)\n            assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n\nclass TestQubitGradient:\n    """"""Tests of the automatic gradient method for qubit gates.\n    """"""\n    def test_RX_gradient(self, qubit_device_1_wire, tol):\n        ""Tests that the automatic gradient of a Pauli X-rotation is correct.""\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        grad_fn = autograd.grad(circuit)\n\n        for theta in thetas:\n            autograd_val = grad_fn(theta)\n            manualgrad_val = (circuit(theta + np.pi / 2) - circuit(theta - np.pi / 2)) / 2\n            assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    def test_RY_gradient(self, qubit_device_1_wire, tol):\n        ""Tests that the automatic gradient of a Pauli Y-rotation is correct.""\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit(x):\n            qml.RY(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        grad_fn = autograd.grad(circuit)\n\n        for theta in thetas:\n            autograd_val = grad_fn(theta)\n            manualgrad_val = (circuit(theta + np.pi / 2) - circuit(theta - np.pi / 2)) / 2\n            assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    def test_RZ_gradient(self, qubit_device_1_wire, tol):\n        ""Tests that the automatic gradient of a Pauli Z-rotation is correct.""\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit(x):\n            qml.RZ(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        grad_fn = autograd.grad(circuit)\n\n        for theta in thetas:\n            autograd_val = grad_fn(theta)\n            manualgrad_val = (circuit(theta + np.pi / 2) - circuit(theta - np.pi / 2)) / 2\n            assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    def test_Rot(self, qubit_device_1_wire, tol):\n        ""Tests that the automatic gradient of a arbitrary Euler-angle-parameterized gate is correct.""\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit(x,y,z):\n            qml.Rot(x,y,z, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        grad_fn = autograd.grad(circuit, argnum=[0,1,2])\n\n        eye = np.eye(3)\n        for theta in thetas:\n            angle_inputs = np.array([theta, theta ** 3, np.sqrt(2) * theta])\n            autograd_val = grad_fn(*angle_inputs)\n            for idx in range(3):\n                onehot_idx = eye[idx]\n                param1 = angle_inputs + np.pi / 2 * onehot_idx\n                param2 = angle_inputs - np.pi / 2 * onehot_idx\n                manualgrad_val = (circuit(*param1) - circuit(*param2)) / 2\n                assert autograd_val[idx] == pytest.approx(manualgrad_val, abs=tol)\n\n    def test_U2(self, tol):\n        """"""Tests that the gradient of an arbitrary U2 gate is correct""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def circuit(x, y):\n            qml.QubitStateVector(1j*np.array([1, -1])/np.sqrt(2), wires=[0])\n            qml.U2(x, y, wires=[0])\n            return qml.expval(qml.PauliX(0))\n\n        phi = -0.234\n        lam = 0.654\n\n        res = circuit(phi, lam)\n        expected = np.sin(lam)*np.sin(phi)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        grad_fn = autograd.grad(circuit, argnum=[0, 1])\n        res = grad_fn(phi, lam)\n        expected = np.array([\n            np.sin(lam)*np.cos(phi),\n            np.cos(lam)*np.sin(phi)\n        ])\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_U3(self, tol):\n        """"""Tests that the gradient of an arbitrary U3 gate is correct""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def circuit(x, y ,z):\n            qml.QubitStateVector(1j*np.array([1, -1])/np.sqrt(2), wires=[0])\n            qml.U3(x, y, z, wires=[0])\n            return qml.expval(qml.PauliX(0))\n\n        theta = 0.543\n        phi = -0.234\n        lam = 0.654\n\n        res = circuit(theta, phi, lam)\n        expected = np.sin(lam)*np.sin(phi) - np.cos(theta)*np.cos(lam)*np.cos(phi)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        grad_fn = autograd.grad(circuit, argnum=[0, 1, 2])\n        res = grad_fn(theta, phi, lam)\n        expected = np.array([\n            np.sin(theta)*np.cos(lam)*np.cos(phi),\n            np.cos(theta)*np.cos(lam)*np.sin(phi) + np.sin(lam)*np.cos(phi),\n            np.cos(theta)*np.sin(lam)*np.cos(phi) + np.cos(lam)*np.sin(phi)\n        ])\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_qfunc_gradients(self, qubit_device_2_wires, tol):\n        ""Tests that the various ways of computing the gradient of a qfunc all agree.""\n\n        def circuit(x, y, z):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(-1.6, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[1, 0])\n            qml.RX(z, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = qml.QNode(circuit, qubit_device_2_wires)\n        params = np.array([0.1, -1.6, np.pi / 5])\n\n        # manual gradients\n        grad_fd1 = qnode.jacobian(params, method=\'F\', options={""order"": 1})\n        grad_fd2 = qnode.jacobian(params, method=\'F\', options={""order"": 2})\n        grad_angle = qnode.jacobian(params, method=\'A\')\n\n        # automatic gradient\n        # Note: the lambda function is required as evaluate now receives a required `kwargs` argument\n        # that cannot be differentiated by autograd.\n        grad_fn = autograd.grad(lambda x: qnode.evaluate(x, {}))\n        grad_auto = grad_fn(params)[np.newaxis, :]  # so shapes will match\n\n        # gradients computed with different methods must agree\n        assert grad_fd1 == pytest.approx(grad_fd2, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_angle, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_auto, abs=tol)\n\n    def test_hybrid_gradients(self, qubit_device_2_wires, tol):\n        ""Tests that the various ways of computing the gradient of a hybrid computation all agree.""\n\n        # input data is the first parameter\n        def classifier_circuit(in_data, x):\n            qml.RX(in_data, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(-1.6, wires=[0])\n            qml.RY(in_data, wires=[1])\n            qml.CNOT(wires=[1, 0])\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        classifier = qml.QNode(classifier_circuit, qubit_device_2_wires)\n\n        param = -0.1259\n        in_data = np.array([-0.1, -0.88, np.exp(0.5)])\n        out_data = np.array([1.5, np.pi / 3, 0.0])\n\n        def error(p):\n            ""Total square error of classifier predictions.""\n            ret = 0\n            for d_in, d_out in zip(in_data, out_data):\n                square_diff = (classifier(d_in, p) - d_out) ** 2\n                ret = ret + square_diff\n            return ret\n\n        def d_error(p, grad_method):\n            ""Gradient of error, computed manually.""\n            ret = 0\n            for d_in, d_out in zip(in_data, out_data):\n                args = (d_in, p)\n                diff = (classifier(*args) - d_out)\n                ret = ret + 2 * diff * classifier.jacobian(args, wrt=[1], method=grad_method)\n            return ret\n\n        y0 = error(param)\n        grad = autograd.grad(error)\n        grad_auto = grad(param)\n\n        grad_fd1 = d_error(param, \'F\')\n        grad_angle = d_error(param, \'A\')\n\n        # gradients computed with different methods must agree\n        assert grad_fd1 == pytest.approx(grad_angle, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_auto, abs=tol)\n        assert grad_angle == pytest.approx(grad_auto, abs=tol)\n\n\n    def test_hybrid_gradients_autograd_numpy(self, qubit_device_2_wires, tol):\n        ""Test the gradient of a hybrid computation requiring autograd.numpy functions.""\n\n        def circuit(x, y):\n            ""Quantum node.""\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(y, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        quantum = qml.QNode(circuit, qubit_device_2_wires)\n\n        def classical(p):\n            ""Classical node, requires autograd.numpy functions.""\n            return anp.exp(anp.sum(quantum(p[0], anp.log(p[1]))))\n\n        def d_classical(a, b, method):\n            ""Gradient of classical computed symbolically, can use normal numpy functions.""\n            val = classical((a, b))\n            J = quantum.jacobian((a, np.log(b)), method=method)\n            return val * np.array([J[0, 0] + J[1, 0], (J[0, 1] + J[1, 1]) / b])\n\n        param = np.array([-0.1259, 1.53])\n        y0 = classical(param)\n        grad_classical = autograd.jacobian(classical)\n        grad_auto = grad_classical(param)\n\n        grad_fd1 = d_classical(*param, \'F\')\n        grad_angle = d_classical(*param, \'A\')\n\n        # gradients computed with different methods must agree\n        assert grad_fd1 == pytest.approx(grad_angle, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_auto, abs=tol)\n        assert grad_angle == pytest.approx(grad_auto, abs=tol)\n\n\n    def test_qnode_gradient_fanout(self, qubit_device_1_wire, tol):\n        ""Tests that the correct gradient is computed for qnodes which use the same parameter in multiple gates.""\n\n        def expZ(state):\n            return np.abs(state[0]) ** 2 - np.abs(state[1]) ** 2\n\n        extra_param = 0.31\n        def circuit(reused_param, other_param):\n            qml.RX(extra_param, wires=[0])\n            qml.RY(reused_param, wires=[0])\n            qml.RZ(other_param, wires=[0])\n            qml.RX(reused_param, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        f = qml.QNode(circuit, qubit_device_1_wire)\n        zero_state = np.array([1., 0.])\n\n        for reused_p in thetas:\n            reused_p = reused_p ** 3 / 19\n            for other_p in thetas:\n                other_p = other_p ** 2 / 11\n\n                # autograd gradient\n                grad = autograd.grad(f)\n                grad_eval = grad(reused_p, other_p)\n\n                # manual gradient\n                grad_true0 = (expZ(Rx(reused_p) @ Rz(other_p) @ Ry(reused_p + np.pi / 2) @ Rx(extra_param) @ zero_state) \\\n                             -expZ(Rx(reused_p) @ Rz(other_p) @ Ry(reused_p - np.pi / 2) @ Rx(extra_param) @ zero_state)) / 2\n                grad_true1 = (expZ(Rx(reused_p + np.pi / 2) @ Rz(other_p) @ Ry(reused_p) @ Rx(extra_param) @ zero_state) \\\n                             -expZ(Rx(reused_p - np.pi / 2) @ Rz(other_p) @ Ry(reused_p) @ Rx(extra_param) @ zero_state)) / 2\n                grad_true = grad_true0 + grad_true1 # product rule\n\n                assert grad_eval == pytest.approx(grad_true, abs=tol)\n\n    def test_gradient_exception_on_sample(self, qubit_device_2_wires):\n        """"""Tests that the proper exception is raised if differentiation of sampling is attempted.""""""\n\n        @qml.qnode(qubit_device_2_wires)\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliX(1))\n\n        with pytest.raises(qml.QuantumFunctionError,\n                           match=""Circuits that include sampling can not be differentiated.""):\n            grad_fn = autograd.jacobian(circuit)\n            grad_fn(1.0)\n'"
tests/test_qubit_device.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`QubitDevice` class.\n""""""\nimport pytest\nimport numpy as np\nfrom random import random\n\nimport pennylane as qml\nfrom pennylane import QubitDevice, DeviceError\nfrom pennylane.qnodes import QuantumFunctionError\nfrom pennylane import expval, var, sample\nfrom pennylane.operation import Sample, Variance, Expectation, Probability\nfrom pennylane.circuit_graph import CircuitGraph\nfrom pennylane.variable import Variable\nfrom pennylane.wires import Wires\n\nmock_qubit_device_paulis = [""PauliX"", ""PauliY"", ""PauliZ""]\nmock_qubit_device_rotations = [""RX"", ""RY"", ""RZ""]\n\n# pylint: disable=abstract-class-instantiated, no-self-use, redefined-outer-name, invalid-name\n\n\n@pytest.fixture(scope=""function"")\ndef mock_qubit_device(monkeypatch):\n    """""" A mock device that mocks most of the methods except for e.g. probability()""""""\n    with monkeypatch.context() as m:\n        m.setattr(QubitDevice, ""__abstractmethods__"", frozenset())\n        m.setattr(QubitDevice, ""_capabilities"", mock_qubit_device_capabilities)\n        m.setattr(QubitDevice, ""operations"", [""PauliY"", ""RX"", ""Rot""])\n        m.setattr(QubitDevice, ""observables"", [""PauliZ""])\n        m.setattr(QubitDevice, ""short_name"", ""MockDevice"")\n        m.setattr(QubitDevice, ""expval"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""var"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""sample"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""apply"", lambda self, x: None)\n        yield QubitDevice()\n\n\n@pytest.fixture(scope=""function"")\ndef mock_qubit_device_extract_stats(monkeypatch):\n    """""" A mock device that mocks the methods related to statistics (expval, var, sample, probability)""""""\n    with monkeypatch.context() as m:\n        m.setattr(QubitDevice, ""__abstractmethods__"", frozenset())\n        m.setattr(QubitDevice, ""_capabilities"", mock_qubit_device_capabilities)\n        m.setattr(QubitDevice, ""operations"", [""PauliY"", ""RX"", ""Rot""])\n        m.setattr(QubitDevice, ""observables"", [""PauliZ""])\n        m.setattr(QubitDevice, ""short_name"", ""MockDevice"")\n        m.setattr(QubitDevice, ""expval"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""var"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""sample"", lambda self, x: 0)\n        m.setattr(\n            QubitDevice, ""probability"", lambda self, wires=None: 0 if wires is None else wires\n        )\n        m.setattr(QubitDevice, ""apply"", lambda self, x: x)\n        yield QubitDevice()\n\n\n@pytest.fixture(scope=""function"")\ndef mock_qubit_device_with_original_statistics(monkeypatch):\n    """""" A mock device that mocks only basis methods and uses the original statistics related methods""""""\n    with monkeypatch.context() as m:\n        m.setattr(QubitDevice, ""__abstractmethods__"", frozenset())\n        m.setattr(QubitDevice, ""_capabilities"", mock_qubit_device_capabilities)\n        m.setattr(QubitDevice, ""operations"", [""PauliY"", ""RX"", ""Rot""])\n        m.setattr(QubitDevice, ""observables"", [""PauliZ""])\n        m.setattr(QubitDevice, ""short_name"", ""MockDevice"")\n        yield QubitDevice()\n\n\nmock_qubit_device_capabilities = {\n    ""measurements"": ""everything"",\n    ""noise_models"": [""depolarizing"", ""bitflip""],\n}\n\n\n@pytest.fixture(scope=""function"")\ndef mock_qubit_device_with_paulis_and_methods(monkeypatch):\n    """"""A mock instance of the abstract QubitDevice class that supports Paulis in its capabilities""""""\n    with monkeypatch.context() as m:\n        m.setattr(QubitDevice, ""__abstractmethods__"", frozenset())\n        m.setattr(QubitDevice, ""_capabilities"", mock_qubit_device_capabilities)\n        m.setattr(QubitDevice, ""operations"", mock_qubit_device_paulis)\n        m.setattr(QubitDevice, ""observables"", mock_qubit_device_paulis)\n        m.setattr(QubitDevice, ""short_name"", ""MockDevice"")\n        m.setattr(QubitDevice, ""expval"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""var"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""sample"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""apply"", lambda self, x: None)\n        yield QubitDevice()\n\n@pytest.fixture(scope=""function"")\ndef mock_qubit_device_with_paulis_rotations_and_methods(monkeypatch):\n    """"""A mock instance of the abstract QubitDevice class that supports Paulis in its capabilities""""""\n    with monkeypatch.context() as m:\n        m.setattr(QubitDevice, ""__abstractmethods__"", frozenset())\n        m.setattr(QubitDevice, ""_capabilities"", mock_qubit_device_capabilities)\n        m.setattr(QubitDevice, ""operations"", mock_qubit_device_paulis + mock_qubit_device_rotations)\n        m.setattr(QubitDevice, ""observables"", mock_qubit_device_paulis)\n        m.setattr(QubitDevice, ""short_name"", ""MockDevice"")\n        m.setattr(QubitDevice, ""expval"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""var"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""sample"", lambda self, x: 0)\n        m.setattr(QubitDevice, ""apply"", lambda self, x: None)\n        yield QubitDevice()\n\nclass TestOperations:\n    """"""Tests the logic related to operations""""""\n\n    def test_op_queue_accessed_outside_execution_context(self, mock_qubit_device):\n        """"""Tests that a call to op_queue outside the execution context raises the correct error""""""\n\n        with pytest.raises(\n            ValueError, match=""Cannot access the operation queue outside of the execution context!""\n        ):\n            mock_qubit_device.op_queue\n\n    def test_op_queue_is_filled_during_execution(\n        self, mock_qubit_device_with_paulis_and_methods, monkeypatch\n    ):\n        """"""Tests that the op_queue is correctly filled when apply is called and that accessing\n           op_queue raises no error""""""\n        queue = [qml.PauliX(wires=0), qml.PauliY(wires=1), qml.PauliZ(wires=2)]\n\n        observables = [qml.expval(qml.PauliZ(0)), qml.var(qml.PauliZ(1)), qml.sample(qml.PauliZ(2))]\n\n        circuit_graph = CircuitGraph(queue + observables, {})\n\n        call_history = []\n\n        with monkeypatch.context() as m:\n            m.setattr(QubitDevice, ""apply"", lambda self, x, **kwargs: call_history.extend(x + kwargs.get(\'rotations\', [])))\n            m.setattr(QubitDevice, ""analytic_probability"", lambda *args: None)\n            mock_qubit_device_with_paulis_and_methods.execute(circuit_graph)\n\n        assert call_history == queue\n\n        assert len(call_history) == 3\n        assert isinstance(call_history[0], qml.PauliX)\n        assert call_history[0].wires == Wires([0])\n\n        assert isinstance(call_history[1], qml.PauliY)\n        assert call_history[1].wires == Wires([1])\n\n        assert isinstance(call_history[2], qml.PauliZ)\n        assert call_history[2].wires == Wires([2])\n\n    def test_unsupported_operations_raise_error(self, mock_qubit_device_with_paulis_and_methods):\n        """"""Tests that the operations are properly applied and queued""""""\n        queue = [qml.PauliX(wires=0), qml.PauliY(wires=1), qml.Hadamard(wires=2)]\n\n        observables = [qml.expval(qml.PauliZ(0)), qml.var(qml.PauliZ(1)), qml.sample(qml.PauliZ(2))]\n\n        circuit_graph = CircuitGraph(queue + observables, {})\n\n        with pytest.raises(DeviceError, match=""Gate Hadamard not supported on device""):\n            mock_qubit_device_with_paulis_and_methods.execute(circuit_graph)\n\n    numeric_queues = [\n                        [\n                            qml.RX(0.3, wires=[0])\n                        ],\n                        [\n                            qml.RX(0.3, wires=[0]),\n                            qml.RX(0.4, wires=[1]),\n                            qml.RX(0.5, wires=[2]),\n                        ]\n                     ]\n\n    variable = Variable(1)\n    symbolic_queue = [\n                        [qml.RX(variable, wires=[0])],\n                    ]\n\n\n    observables = [\n                    [qml.PauliZ(0)],\n                    [qml.PauliX(0)],\n                    [qml.PauliY(0)]\n                 ]\n\n    @pytest.mark.parametrize(""observables"", observables)\n    @pytest.mark.parametrize(""queue"", numeric_queues + symbolic_queue)\n    def test_passing_keyword_arguments_to_execute(self, mock_qubit_device_with_paulis_rotations_and_methods, monkeypatch, queue, observables):\n        """"""Tests that passing keyword arguments to execute propagates those kwargs to the apply()\n        method""""""\n        circuit_graph = CircuitGraph(queue + observables, {})\n\n        call_history = {}\n\n        with monkeypatch.context() as m:\n            m.setattr(QubitDevice, ""apply"", lambda self, x, **kwargs: call_history.update(kwargs))\n            mock_qubit_device_with_paulis_rotations_and_methods.execute(circuit_graph, hash=circuit_graph.hash)\n\n        len(call_history.items()) == 1\n        call_history[""hash""] = circuit_graph.hash\n\nclass TestObservables:\n    """"""Tests the logic related to observables""""""\n\n    # pylint: disable=no-self-use, redefined-outer-name\n\n    def test_obs_queue_accessed_outside_execution_context(self, mock_qubit_device):\n        """"""Tests that a call to op_queue outside the execution context raises the correct error""""""\n\n        with pytest.raises(\n            ValueError,\n            match=""Cannot access the observable value queue outside of the execution context!"",\n        ):\n            mock_qubit_device.obs_queue\n\n    def test_unsupported_observables_raise_error(self, mock_qubit_device_with_paulis_and_methods):\n        """"""Tests that the operations are properly applied and queued""""""\n        queue = [qml.PauliX(wires=0), qml.PauliY(wires=1), qml.PauliZ(wires=2)]\n\n        observables = [\n            qml.expval(qml.Hadamard(0)),\n            qml.var(qml.PauliZ(1)),\n            qml.sample(qml.PauliZ(2)),\n        ]\n\n        circuit_graph = CircuitGraph(queue + observables, {})\n\n        with pytest.raises(DeviceError, match=""Observable Hadamard not supported on device""):\n            mock_qubit_device_with_paulis_and_methods.execute(circuit_graph)\n\n    def test_unsupported_observable_return_type_raise_error(\n        self, mock_qubit_device_with_paulis_and_methods, monkeypatch\n    ):\n        """"""Check that an error is raised if the return type of an observable is unsupported""""""\n\n        queue = [qml.PauliX(wires=0)]\n\n        # Make a observable without specifying a return operation upon measuring\n        obs = qml.PauliZ(0)\n        obs.return_type = ""SomeUnsupportedReturnType""\n        observables = [obs]\n\n        circuit_graph = CircuitGraph(queue + observables, {})\n\n        with monkeypatch.context() as m:\n            m.setattr(QubitDevice, ""apply"", lambda self, x, **kwargs: None)\n            with pytest.raises(\n                QuantumFunctionError, match=""Unsupported return type specified for observable""\n            ):\n                mock_qubit_device_with_paulis_and_methods.execute(circuit_graph)\n\n\nclass TestParameters:\n    """"""Test for checking device parameter mappings""""""\n\n    def test_parameters_accessed_outside_execution_context(self, mock_qubit_device):\n        """"""Tests that a call to parameters outside the execution context raises the correct error""""""\n\n        with pytest.raises(\n            ValueError,\n            match=""Cannot access the free parameter mapping outside of the execution context!"",\n        ):\n            mock_qubit_device.parameters\n\n\nclass TestExtractStatistics:\n    """"""Test the statistics method""""""\n\n    @pytest.mark.parametrize(""returntype"", [Expectation, Variance, Sample, Probability])\n    def test_results_created(self, mock_qubit_device_extract_stats, monkeypatch, returntype):\n        """"""Tests that the statistics method simply builds a results list without any side-effects""""""\n\n        class SomeObservable(qml.operation.Observable):\n            num_params = 0\n            num_wires = 1\n            par_domain = ""F""\n            return_type = returntype\n\n        obs = SomeObservable(wires=0)\n\n        with monkeypatch.context() as m:\n            results = mock_qubit_device_extract_stats.statistics([obs])\n\n        assert results == [0]\n\n    @pytest.mark.parametrize(""returntype"", [None])\n    def test_results_created(self, mock_qubit_device_extract_stats, monkeypatch, returntype):\n        """"""Tests that the statistics method returns an empty list if the return type is None""""""\n\n        class SomeObservable(qml.operation.Observable):\n            num_params = 0\n            num_wires = 1\n            par_domain = ""F""\n            return_type = returntype\n\n        obs = SomeObservable(wires=0)\n\n        with monkeypatch.context() as m:\n            results = mock_qubit_device_extract_stats.statistics([obs])\n\n        assert results == []\n\n    @pytest.mark.parametrize(""returntype"", [""not None""])\n    def test_error_return_type_none(self, mock_qubit_device_extract_stats, monkeypatch, returntype):\n        """"""Tests that the statistics method raises an error if the return type is not well-defined and is not None""""""\n\n        assert returntype not in [Expectation, Variance, Sample, Probability, None]\n\n        class SomeObservable(qml.operation.Observable):\n            num_params = 0\n            num_wires = 1\n            par_domain = ""F""\n            return_type = returntype\n\n        obs = SomeObservable(wires=0)\n\n        with pytest.raises(QuantumFunctionError, match=""Unsupported return type""):\n            results = mock_qubit_device_extract_stats.statistics([obs])\n\n\nclass TestGenerateSamples:\n    """"""Test the generate_samples method""""""\n\n    def test_auxiliary_methods_called_correctly(self, mock_qubit_device, monkeypatch):\n        """"""Tests that the generate_samples method calls on its auxiliary methods correctly""""""\n\n        number_of_states = 2 ** mock_qubit_device.num_wires\n\n        with monkeypatch.context() as m:\n            # Mock the auxiliary methods such that they return the expected values\n            m.setattr(QubitDevice, ""sample_basis_states"", lambda self, wires, b: wires)\n            m.setattr(QubitDevice, ""states_to_binary"", lambda a, b: (a, b))\n            m.setattr(QubitDevice, ""analytic_probability"", lambda *args: None)\n            mock_qubit_device._samples = mock_qubit_device.generate_samples()\n\n        assert mock_qubit_device._samples == (number_of_states, mock_qubit_device.num_wires)\n\n\nclass TestSampleBasisStates:\n    """"""Test the sample_basis_states method""""""\n\n    def test_sampling_with_correct_arguments(self, mock_qubit_device, monkeypatch):\n        """"""Tests that the sample_basis_states method samples with the correct arguments""""""\n\n        shots = 1000\n\n        number_of_states = 4\n        mock_qubit_device.shots = shots\n        state_probs = [0.1, 0.2, 0.3, 0.4]\n\n        with monkeypatch.context() as m:\n            # Mock the numpy.random.choice method such that it returns the expected values\n            m.setattr(""numpy.random.choice"", lambda x, y, p: (x, y, p))\n            res = mock_qubit_device.sample_basis_states(number_of_states, state_probs)\n\n        assert np.array_equal(res[0], np.array([0, 1, 2, 3]))\n        assert res[1] == shots\n        assert res[2] == state_probs\n\n\nclass TestStatesToBinary:\n    """"""Test the states_to_binary method""""""\n\n    def test_correct_conversion_two_states(self, mock_qubit_device):\n        """"""Tests that the sample_basis_states method converts samples to binary correctly""""""\n        wires = 4\n        shots = 10\n\n        number_of_states = 2 ** wires\n        basis_states = np.arange(number_of_states)\n        samples = np.random.choice(basis_states, shots)\n\n        res = mock_qubit_device.states_to_binary(samples, wires)\n\n        format_smt = ""{{:0{}b}}"".format(wires)\n        expected = np.array([[int(x) for x in list(format_smt.format(i))] for i in samples])\n\n        assert np.all(res == expected)\n\n    test_binary_conversion_data = [\n        (np.array([2, 3, 2, 0, 0]), np.array([[1, 0], [1, 1], [1, 0], [0, 0], [0, 0]])),\n        (np.array([2, 3, 1, 3, 1]), np.array([[1, 0], [1, 1], [0, 1], [1, 1], [0, 1]])),\n        (\n            np.array([7, 7, 1, 5, 2]),\n            np.array([[1, 1, 1], [1, 1, 1], [0, 0, 1], [1, 0, 1], [0, 1, 0]]),\n        ),\n    ]\n\n    @pytest.mark.parametrize(""samples, binary_states"", test_binary_conversion_data)\n    def test_correct_conversion(self, mock_qubit_device, samples, binary_states, tol):\n        """"""Tests that the states_to_binary method converts samples to binary correctly""""""\n        mock_qubit_device.shots = 5\n        wires = binary_states.shape[1]\n        res = mock_qubit_device.states_to_binary(samples, wires)\n        assert np.allclose(res, binary_states, atol=tol, rtol=0)\n\n\nclass TestExpval:\n    """"""Test the expval method""""""\n\n    def test_analytic_expval(self, mock_qubit_device_with_original_statistics, monkeypatch):\n        """"""Tests that expval method when the analytic attribute is True\n\n        Additional QubitDevice methods that are mocked:\n        -rotate_basis\n        -probability\n        """"""\n        obs = qml.PauliX(0)\n        probs = [0.5, 0.5]\n\n        assert mock_qubit_device_with_original_statistics.analytic\n\n        call_history = []\n        with monkeypatch.context() as m:\n            m.setattr(QubitDevice, ""probability"", lambda self, wires=None: probs)\n            res = mock_qubit_device_with_original_statistics.expval(obs)\n\n        assert res == (obs.eigvals @ probs).real\n\n    def test_non_analytic_expval(self, mock_qubit_device_with_original_statistics, monkeypatch):\n        """"""Tests that expval method when the analytic attribute is False\n\n        Additional QubitDevice methods that are mocked:\n        -rotate_basis\n        -sample\n        -numpy.mean\n        """"""\n        obs = qml.PauliX(0)\n\n        assert mock_qubit_device_with_original_statistics.analytic\n        mock_qubit_device_with_original_statistics.analytic = False\n\n        assert not mock_qubit_device_with_original_statistics.analytic\n\n        call_history = []\n        with monkeypatch.context() as m:\n            m.setattr(QubitDevice, ""sample"", lambda self, obs: obs)\n            m.setattr(""numpy.mean"", lambda obs: obs)\n            res = mock_qubit_device_with_original_statistics.expval(obs)\n\n        assert res == obs\n\n\nclass TestVar:\n    """"""Test the var method""""""\n\n    def test_analytic_var(self, mock_qubit_device_with_original_statistics, monkeypatch):\n        """"""Tests that var method when the analytic attribute is True\n\n        Additional QubitDevice methods that are mocked:\n        -rotate_basis\n        -probability\n        """"""\n        obs = qml.PauliX(0)\n        probs = [0.5, 0.5]\n\n        assert mock_qubit_device_with_original_statistics.analytic\n\n        call_history = []\n        with monkeypatch.context() as m:\n            m.setattr(QubitDevice, ""probability"", lambda self, wires=None: probs)\n            res = mock_qubit_device_with_original_statistics.var(obs)\n\n        assert res == (obs.eigvals ** 2) @ probs - (obs.eigvals @ probs).real ** 2\n\n    def test_non_analytic_var(self, mock_qubit_device_with_original_statistics, monkeypatch):\n        """"""Tests that var method when the analytic attribute is False\n\n        Additional QubitDevice methods that are mocked:\n        -rotate_basis\n        -sample\n        -numpy.var\n        """"""\n        obs = qml.PauliX(0)\n\n        assert mock_qubit_device_with_original_statistics.analytic\n        mock_qubit_device_with_original_statistics.analytic = False\n\n        assert not mock_qubit_device_with_original_statistics.analytic\n\n        call_history = []\n        with monkeypatch.context() as m:\n            m.setattr(QubitDevice, ""sample"", lambda self, obs: obs)\n            m.setattr(""numpy.var"", lambda obs: obs)\n            res = mock_qubit_device_with_original_statistics.var(obs)\n\n        assert res == obs\n\n\nclass TestSample:\n    """"""Test the sample method""""""\n\n    def test_only_ones_minus_ones(\n        self, mock_qubit_device_with_original_statistics, monkeypatch, tol\n    ):\n        """"""Test that pauli_eigvals_as_samples method only produces -1 and 1 samples""""""\n        obs = qml.PauliX(0)\n\n        mock_qubit_device_with_original_statistics._samples = np.array([[1, 0], [0, 0]])\n\n        with monkeypatch.context() as m:\n            res = mock_qubit_device_with_original_statistics.sample(obs)\n\n        assert np.allclose(res ** 2, 1, atol=tol, rtol=0)\n\n    def test_correct_custom_eigenvalues(\n        self, mock_qubit_device_with_original_statistics, monkeypatch, tol\n    ):\n        """"""Test that pauli_eigvals_as_samples method only produces samples of eigenvalues""""""\n        obs = qml.PauliX(0) @ qml.PauliZ(1)\n\n        mock_qubit_device_with_original_statistics._samples = np.array([[1, 0], [0, 0]])\n\n        with monkeypatch.context() as m:\n            res = mock_qubit_device_with_original_statistics.sample(obs)\n\n        assert np.array_equal(res, np.array([-1, 1]))\n\n\nclass TestMarginalProb:\n    """"""Test the marginal_prob method""""""\n\n    @pytest.mark.parametrize(\n        ""wires, inactive_wires"",\n        [\n            ([0], [1, 2]),\n            ([1], [0, 2]),\n            ([2], [0, 1]),\n            ([0, 1], [2]),\n            ([0, 2], [1]),\n            ([1, 2], [0]),\n            ([0, 1, 2], []),\n        ],\n    )\n    def test_correct_arguments_for_marginals(\n        self, mock_qubit_device_with_original_statistics, monkeypatch, wires, inactive_wires, tol\n    ):\n        """"""Test that the correct arguments are passed to the marginal_prob method""""""\n\n        mock_qubit_device_with_original_statistics.num_wires = 3\n\n        # Generate probabilities\n        probs = np.array([random() for i in range(2 ** 3)])\n        probs /= sum(probs)\n\n        def apply_over_axes_mock(x, y, p):\n            arguments_apply_over_axes.append((y, p))\n            return np.zeros([2 ** len(wires)])\n\n        arguments_apply_over_axes = []\n        with monkeypatch.context() as m:\n            m.setattr(""numpy.apply_over_axes"", apply_over_axes_mock)\n            res = mock_qubit_device_with_original_statistics.marginal_prob(probs, wires=wires)\n\n        assert np.array_equal(arguments_apply_over_axes[0][0].flatten(), probs)\n        assert np.array_equal(arguments_apply_over_axes[0][1], inactive_wires)\n\n    marginal_test_data = [\n        (np.array([0.1, 0.2, 0.3, 0.4]), np.array([0.4, 0.6]), [1]),\n        (np.array([0.1, 0.2, 0.3, 0.4]), np.array([0.3, 0.7]), [0]),\n        (\n            np.array(\n                [\n                    0.17794671,\n                    0.06184147,\n                    0.21909549,\n                    0.04932204,\n                    0.19595214,\n                    0.19176834,\n                    0.08495311,\n                    0.0191207,\n                ]\n            ),\n            np.array([0.3970422, 0.28090525, 0.11116351, 0.21088904]),\n            [2, 0],\n        ),\n    ]\n\n    @pytest.mark.parametrize(""probs, marginals, wires"", marginal_test_data)\n    def test_correct_marginals_returned(\n        self, mock_qubit_device_with_original_statistics, probs, marginals, wires, tol\n    ):\n        """"""Test that the correct marginals are returned by the marginal_prob method""""""\n        mock_qubit_device_with_original_statistics.num_wires = int(np.log2(len(probs)))\n        res = mock_qubit_device_with_original_statistics.marginal_prob(probs, wires=wires)\n        assert np.allclose(res, marginals, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""probs, marginals, wires"", marginal_test_data)\n    def test_correct_marginals_returned_wires_none(\n        self, mock_qubit_device_with_original_statistics, probs, marginals, wires, tol\n    ):\n        """"""Test that passing wires=None simply returns the original probability.""""""\n        num_wires = int(np.log2(len(probs)))\n        mock_qubit_device_with_original_statistics.num_wires = num_wires\n\n        res = mock_qubit_device_with_original_statistics.marginal_prob(probs, wires=None)\n        assert np.allclose(res, probs, atol=tol, rtol=0)\n\n\nclass TestActiveWires:\n    """"""Test that the active_wires static method works as required.""""""\n\n    def test_active_wires_from_queue(self, mock_qubit_device):\n        queue = [\n            qml.CNOT(wires=[0, 2]),\n            qml.RX(0.2, wires=0),\n            qml.expval(qml.PauliX(wires=5))\n        ]\n\n        res = mock_qubit_device.active_wires(queue)\n        assert res == Wires([0, 2, 5])\n'"
tests/test_queuing_context.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`QueuingContext` class.\n""""""\n\nimport pytest\nimport pennylane as qml\nfrom pennylane import QueuingContext\n\n\n@pytest.fixture(scope=""function"")\ndef mock_queuing_context(monkeypatch):\n    """"""A mock instance of the abstract QueuingContext class.""""""\n    with monkeypatch.context() as m:\n        m.setattr(QueuingContext, ""__abstractmethods__"", frozenset())\n        m.setattr(\n            QueuingContext, ""_append_operator"", lambda self, operator: self.queue.append(operator)\n        )\n        m.setattr(\n            QueuingContext, ""_remove_operator"", lambda self, operator: self.queue.remove(operator)\n        )\n        context = QueuingContext()\n        context.queue = []\n\n        yield context\n\n\n@pytest.fixture(scope=""function"")\ndef three_mock_queuing_contexts(monkeypatch):\n    """"""A list of three mock instances of the abstract QueuingContext class.""""""\n    with monkeypatch.context() as m:\n        m.setattr(QueuingContext, ""__abstractmethods__"", frozenset())\n        m.setattr(\n            QueuingContext, ""_append_operator"", lambda self, operator: self.queue.append(operator)\n        )\n        m.setattr(\n            QueuingContext, ""_remove_operator"", lambda self, operator: self.queue.remove(operator)\n        )\n\n        contexts = [QueuingContext() for _ in range(3)]\n        for context in contexts:\n            context.queue = []\n\n        yield contexts\n\n\nclass TestQueuingContext:\n    """"""Test the logic associated with the QueuingContext class.""""""\n\n    def test_context_activation(self, mock_queuing_context):\n        """"""Test that the QueuingContext is properly activated and deactivated.""""""\n\n        # Assert that the list of active contexts is empty\n        assert not QueuingContext._active_contexts\n\n        with mock_queuing_context:\n            assert len(QueuingContext._active_contexts) == 1\n            assert mock_queuing_context in QueuingContext._active_contexts\n\n        assert not QueuingContext._active_contexts\n\n    def test_multiple_context_activation(self, three_mock_queuing_contexts):\n        """"""Test that multiple QueuingContexts are properly activated and deactivated.""""""\n\n        # Assert that the list of active contexts is empty\n        assert not QueuingContext._active_contexts\n\n        with three_mock_queuing_contexts[0]:\n            with three_mock_queuing_contexts[1]:\n                with three_mock_queuing_contexts[2]:\n                    assert len(QueuingContext._active_contexts) == 3\n                    assert three_mock_queuing_contexts[0] in QueuingContext._active_contexts\n                    assert three_mock_queuing_contexts[1] in QueuingContext._active_contexts\n                    assert three_mock_queuing_contexts[2] in QueuingContext._active_contexts\n\n        assert not QueuingContext._active_contexts\n\n    def test_append_operator_no_context(self):\n        """"""Test that append_operator does not fail when no context is present.""""""\n\n        QueuingContext.append_operator(qml.PauliZ(0))\n\n    def test_remove_operator_no_context(self):\n        """"""Test that remove_operator does not fail when no context is present.""""""\n\n        QueuingContext.remove_operator(qml.PauliZ(0))\n\n    def test_append_operator(self, mock_queuing_context):\n        """"""Test that append_operator appends the operator to the queue.""""""\n\n        op = qml.PauliZ(0)\n        assert not mock_queuing_context.queue\n\n        with mock_queuing_context:\n            QueuingContext.append_operator(op)\n\n        assert len(mock_queuing_context.queue) == 1\n        assert op in mock_queuing_context.queue\n\n    def test_remove_operator(self, mock_queuing_context):\n        """"""Test that remove_operator removes the operator from the queue.""""""\n\n        op = qml.PauliZ(0)\n        assert not mock_queuing_context.queue\n\n        with mock_queuing_context:\n            QueuingContext.append_operator(op)\n\n            assert len(mock_queuing_context.queue) == 1\n            assert op in mock_queuing_context.queue\n\n            QueuingContext.remove_operator(op)\n\n        assert not mock_queuing_context.queue\n\n    def test_remove_operator_not_in_list(self, mock_queuing_context):\n        """"""Test that remove_operator does not fail when the operator to be removed is not in the queue.""""""\n\n        op1 = qml.PauliZ(0)\n        op2 = qml.PauliZ(1)\n        assert not mock_queuing_context.queue\n\n        with mock_queuing_context:\n            QueuingContext.append_operator(op1)\n\n            assert len(mock_queuing_context.queue) == 1\n            assert op1 in mock_queuing_context.queue\n\n            QueuingContext.remove_operator(op2)\n\n        assert len(mock_queuing_context.queue) == 1\n        assert op1 in mock_queuing_context.queue\n\n    def test_append_operator_multiple_queues(self, three_mock_queuing_contexts):\n        """"""Test that append_operator appends the operator to multiple queues.""""""\n\n        op = qml.PauliZ(0)\n        assert not three_mock_queuing_contexts[0].queue\n        assert not three_mock_queuing_contexts[1].queue\n        assert not three_mock_queuing_contexts[2].queue\n\n        with three_mock_queuing_contexts[0]:\n            with three_mock_queuing_contexts[1]:\n                with three_mock_queuing_contexts[2]:\n                    QueuingContext.append_operator(op)\n\n        assert len(three_mock_queuing_contexts[0].queue) == 1\n        assert op in three_mock_queuing_contexts[0].queue\n\n        assert len(three_mock_queuing_contexts[1].queue) == 1\n        assert op in three_mock_queuing_contexts[1].queue\n\n        assert len(three_mock_queuing_contexts[1].queue) == 1\n        assert op in three_mock_queuing_contexts[1].queue\n\n    def test_remove_operator_multiple_queues(self, three_mock_queuing_contexts):\n        """"""Test that remove_operator removes the operator from the queue.""""""\n\n        op = qml.PauliZ(0)\n        assert not three_mock_queuing_contexts[0].queue\n        assert not three_mock_queuing_contexts[1].queue\n        assert not three_mock_queuing_contexts[2].queue\n\n        with three_mock_queuing_contexts[0]:\n            with three_mock_queuing_contexts[1]:\n                with three_mock_queuing_contexts[2]:\n                    QueuingContext.append_operator(op)\n\n                    assert len(three_mock_queuing_contexts[0].queue) == 1\n                    assert op in three_mock_queuing_contexts[0].queue\n\n                    assert len(three_mock_queuing_contexts[1].queue) == 1\n                    assert op in three_mock_queuing_contexts[1].queue\n\n                    assert len(three_mock_queuing_contexts[2].queue) == 1\n                    assert op in three_mock_queuing_contexts[2].queue\n\n                    QueuingContext.remove_operator(op)\n\n        assert not three_mock_queuing_contexts[0].queue\n        assert not three_mock_queuing_contexts[1].queue\n        assert not three_mock_queuing_contexts[2].queue\n'"
tests/test_tensor_measurements.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nIntegration tests to ensure that tensor observables return the correct result.\n""""""\nimport pytest\n\nimport numpy as np\nimport itertools\nimport functools\nimport pennylane as qml\nfrom pennylane import expval, var, sample\nfrom gate_data import I, X, Y, Z, S, Rotx, Roty, H, CNOT\n\n\nZ = np.array([[1, 0], [0, -1]])\nTHETA = np.linspace(0.11, 3, 5)\nPHI = np.linspace(0.32, 3, 5)\nVARPHI = np.linspace(0.02, 3, 5)\n\n\ndef ansatz(a, b, c):\n    qml.RX(a, wires=0)\n    qml.RX(b, wires=1)\n    qml.RX(c, wires=2)\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[1, 2])\n\n\n@pytest.mark.parametrize(""analytic"", [True, False])\n@pytest.mark.parametrize(""theta,phi,varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorExpval:\n    """"""Test tensor expectation values""""""\n\n    @pytest.fixture\n    def tolerance(self, analytic, tol):\n        if not analytic:\n            return {""atol"": 0.01, ""rtol"": 0.1}\n\n        return {""atol"": tol, ""rtol"": 0}\n\n    def test_tensor_product(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product ZxZ gives the same result as simply\n        using an Hermitian matrix""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit1(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliZ(0) @ qml.PauliZ(2))\n\n        @qml.qnode(dev)\n        def circuit2(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.Hermitian(np.kron(Z, Z), wires=[0, 2]))\n\n        res1 = circuit1(theta, phi, varphi)\n        res2 = circuit2(theta, phi, varphi)\n\n        assert np.allclose(res1, res2, **tolerance)\n\n    def test_combine_tensor_with_non_tensor(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product along with a non-tensor product\n        continues to function correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit1(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliZ(0) @ qml.PauliZ(2)), expval(qml.PauliZ(1))\n\n        @qml.qnode(dev)\n        def circuit2(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.Hermitian(np.kron(Z, Z), wires=[0, 2]))\n\n        @qml.qnode(dev)\n        def circuit3(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliZ(1))\n\n        res1 = circuit1(theta, phi, varphi)\n        res2 = circuit2(theta, phi, varphi), circuit3(theta, phi, varphi)\n\n        assert np.allclose(res1, res2, **tolerance)\n\n    def test_paulix_tensor_pauliy(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliX(0) @ qml.PauliY(2))\n\n        res = circuit(theta, phi, varphi)\n        expected = np.sin(theta) * np.sin(phi) * np.sin(varphi)\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_paulix_tensor_pauliy_gradient(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliX(0) @ qml.PauliY(2))\n\n        dcircuit = qml.grad(circuit, 0)\n        res = dcircuit(theta, phi, varphi)\n        expected = np.cos(theta) * np.sin(phi) * np.sin(varphi)\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_pauliz_tensor_identity(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving PauliZ and Identity works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliZ(0) @ qml.Identity(1) @ qml.PauliZ(2))\n\n        res = circuit(theta, phi, varphi)\n        expected = np.cos(varphi) * np.cos(phi)\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_pauliz_tensor_hadamard(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving PauliZ and hadamard works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2))\n\n        res = circuit(theta, phi, varphi)\n        expected = -(np.cos(varphi) * np.sin(phi) + np.sin(varphi) * np.cos(theta)) / np.sqrt(2)\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_hermitian(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving an Hermitian matrix works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.PauliZ(0) @ qml.Hermitian(A, [1, 2]))\n\n        res = circuit(theta, phi, varphi)\n        expected = 0.5 * (\n            -6 * np.cos(theta) * (np.cos(varphi) + 1)\n            - 2 * np.sin(varphi) * (np.cos(theta) + np.sin(phi) - 2 * np.cos(phi))\n            + 3 * np.cos(varphi) * np.sin(phi)\n            + np.sin(phi)\n        )\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_hermitian_tensor_hermitian(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving two Hermitian matrices works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        A1 = np.array([[1, 2], [2, 4]])\n\n        A2 = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return expval(qml.Hermitian(A1, 0) @ qml.Hermitian(A2, [1, 2]))\n\n        res = circuit(theta, phi, varphi)\n        expected = 0.25 * (\n            -30\n            + 4 * np.cos(phi) * np.sin(theta)\n            + 3 * np.cos(varphi) * (-10 + 4 * np.cos(phi) * np.sin(theta) - 3 * np.sin(phi))\n            - 3 * np.sin(phi)\n            - 2\n            * (5 + np.cos(phi) * (6 + 4 * np.sin(theta)) + (-3 + 8 * np.sin(theta)) * np.sin(phi))\n            * np.sin(varphi)\n            + np.cos(theta)\n            * (\n                18\n                + 5 * np.sin(phi)\n                + 3 * np.cos(varphi) * (6 + 5 * np.sin(phi))\n                + 2 * (3 + 10 * np.cos(phi) - 5 * np.sin(phi)) * np.sin(varphi)\n            )\n        )\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_hermitian_tensor_identity_expectation(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving an Hermitian matrix and the identity works correctly""""""\n        dev = qml.device(""default.qubit"", wires=2, analytic=analytic, shots=int(1e6))\n\n        A = np.array(\n            [[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]]\n        )\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            qml.RY(a, wires=0)\n            qml.RY(b, wires=1)\n            qml.CNOT(wires=[0, 1])\n            return expval(qml.Hermitian(A, 0) @ qml.Identity(1))\n\n        res = circuit(theta, phi, varphi)\n\n        a = A[0, 0]\n        re_b = A[0, 1].real\n        d = A[1, 1]\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\n\n        assert np.allclose(res, expected, **tolerance)\n\n\n@pytest.mark.parametrize(""analytic"", [True, False])\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorVar:\n    """"""Tests for variance of tensor observables""""""\n\n    @pytest.fixture\n    def tolerance(self, analytic, tol):\n        if not analytic:\n            return {""atol"": 0.01, ""rtol"": 0.2}\n\n        return {""atol"": tol, ""rtol"": 0}\n\n    def test_paulix_tensor_pauliy(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return var(qml.PauliX(0) @ qml.PauliY(2))\n\n        res = circuit(theta, phi, varphi)\n        expected = (\n            8 * np.sin(theta) ** 2 * np.cos(2 * varphi) * np.sin(phi) ** 2\n            - np.cos(2 * (theta - phi))\n            - np.cos(2 * (theta + phi))\n            + 2 * np.cos(2 * theta)\n            + 2 * np.cos(2 * phi)\n            + 14\n        ) / 16\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_pauliz_tensor_hadamard(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving PauliZ and hadamard works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return var(qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2))\n\n        res = circuit(theta, phi, varphi)\n        expected = (\n            3\n            + np.cos(2 * phi) * np.cos(varphi) ** 2\n            - np.cos(2 * theta) * np.sin(varphi) ** 2\n            - 2 * np.cos(theta) * np.sin(phi) * np.sin(2 * varphi)\n        ) / 4\n\n        assert np.allclose(res, expected, **tolerance)\n\n    def test_tensor_hermitian(self, analytic, theta, phi, varphi, tolerance):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=analytic, shots=int(1e6))\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return var(qml.PauliZ(0) @ qml.Hermitian(A, [1, 2]))\n\n        res = circuit(theta, phi, varphi)\n        expected = (\n            1057\n            - np.cos(2 * phi)\n            + 12 * (27 + np.cos(2 * phi)) * np.cos(varphi)\n            - 2 * np.cos(2 * varphi) * np.sin(phi) * (16 * np.cos(phi) + 21 * np.sin(phi))\n            + 16 * np.sin(2 * phi)\n            - 8 * (-17 + np.cos(2 * phi) + 2 * np.sin(2 * phi)) * np.sin(varphi)\n            - 8 * np.cos(2 * theta) * (3 + 3 * np.cos(varphi) + np.sin(varphi)) ** 2\n            - 24 * np.cos(phi) * (np.cos(phi) + 2 * np.sin(phi)) * np.sin(2 * varphi)\n            - 8\n            * np.cos(theta)\n            * (\n                4 * np.cos(phi)\n                * (4 + 8 * np.cos(varphi) + np.cos(2 * varphi) - (1 + 6 * np.cos(varphi)) * np.sin(varphi))\n                + np.sin(phi) * (15 + 8 * np.cos(varphi) - 11 * np.cos(2 * varphi) + 42 * np.sin(varphi) + 3 * np.sin(2 * varphi))\n            )\n        ) / 16\n\n        assert np.allclose(res, expected, **tolerance)\n\n\ndef tensor_product(observables):\n    return functools.reduce(np.kron, observables)\n\n\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorSample:\n    """"""Tests for samples of tensor observables""""""\n\n    def test_paulix_tensor_pauliz(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliX and PauliZ works correctly""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.Hadamard(wires=0)\n            return sample(qml.PauliX(0) @ qml.PauliZ(1))\n\n        s1 = circuit()\n\n        # s1 should only contain 1\n        assert np.allclose(s1, 1, atol=tol, rtol=0)\n\n    def test_paulix_tensor_pauliy(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return sample(qml.PauliX(0) @ qml.PauliY(2))\n\n        s1 = circuit(theta, phi, varphi)\n\n        # s1 should only contain 1 and -1\n        assert np.allclose(s1 ** 2, 1, atol=tol, rtol=0)\n\n        zero_state = np.zeros(2 ** 3)\n        zero_state[0] = 1\n        psi = zero_state\n        psi = tensor_product([Rotx(theta), I, I]) @ zero_state\n        psi = tensor_product([I, Rotx(phi), I]) @ psi\n        psi = tensor_product([I, I, Rotx(varphi)]) @ psi\n        psi = tensor_product([CNOT, I]) @ psi\n        psi = tensor_product([I, CNOT]) @ psi\n\n        # Diagonalize according to the observable\n        psi = tensor_product([H, I, I]) @ psi\n        psi = tensor_product([I, I, Z]) @ psi\n        psi = tensor_product([I, I, S]) @ psi\n        psi = tensor_product([I, I, H]) @ psi\n\n        expected_probabilities = np.abs(psi) ** 2\n\n        assert np.allclose(dev.probability(), expected_probabilities, atol=tol, rtol=0)\n\n    def test_pauliz_tensor_hadamard(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliZ and hadamard works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return sample(qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2))\n\n        s1 = circuit(theta, phi, varphi)\n\n        zero_state = np.zeros(2 ** 3)\n        zero_state[0] = 1\n        psi = zero_state\n        psi = tensor_product([Rotx(theta), I, I]) @ zero_state\n        psi = tensor_product([I, Rotx(phi), I]) @ psi\n        psi = tensor_product([I, I, Rotx(varphi)]) @ psi\n        psi = tensor_product([CNOT, I]) @ psi\n        psi = tensor_product([I, CNOT]) @ psi\n\n        # Diagonalize according to the observable\n        psi = tensor_product([I, Roty(-np.pi/4), I]) @ psi\n        psi = tensor_product([I, I, Z]) @ psi\n        psi = tensor_product([I, I, S]) @ psi\n        psi = tensor_product([I, I, H]) @ psi\n\n        expected_probabilities = np.abs(psi) ** 2\n\n        assert np.allclose(dev.probability(), expected_probabilities, atol=tol, rtol=0)\n\n        # s1 should only contain 1 and -1\n        assert np.allclose(s1 ** 2, 1, atol=tol, rtol=0)\n\n    def test_tensor_hermitian(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            ansatz(a, b, c)\n            return sample(qml.PauliZ(0) @ qml.Hermitian(A, [1, 2]))\n\n        s1 = circuit(theta, phi, varphi)\n\n        # s1 should only contain the eigenvalues of\n        # the hermitian matrix tensor product Z\n        Z = np.diag([1, -1])\n        eigvals = np.linalg.eigvalsh(np.kron(Z, A))\n        assert set(np.round(s1, 8)).issubset(set(np.round(eigvals, 8)))\n\n        zero_state = np.zeros(2 ** 3)\n        zero_state[0] = 1\n        psi = zero_state\n        psi = tensor_product([Rotx(theta), I, I]) @ zero_state\n        psi = tensor_product([I, Rotx(phi), I]) @ psi\n        psi = tensor_product([I, I, Rotx(varphi)]) @ psi\n        psi = tensor_product([CNOT, I]) @ psi\n        psi = tensor_product([I, CNOT]) @ psi\n\n        # Diagonalize according to the observable\n        eigvals, eigvecs = np.linalg.eigh(A)\n        psi = tensor_product([I, eigvecs.conj().T]) @ psi\n\n        expected_probabilities = np.abs(psi) ** 2\n\n        assert np.allclose(dev.probability(), expected_probabilities, atol=tol, rtol=0)\n'"
tests/test_utils.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.utils` module.\n""""""\n# pylint: disable=no-self-use,too-many-arguments,protected-access\nimport pytest\nfrom unittest.mock import MagicMock\n\nimport numpy as np\n\nimport pennylane as qml\nimport pennylane.utils as pu\nimport functools\nimport itertools\n\nflat_dummy_array = np.linspace(-1, 1, 64)\ntest_shapes = [\n    (64,),\n    (64, 1),\n    (32, 2),\n    (16, 4),\n    (8, 8),\n    (16, 2, 2),\n    (8, 2, 2, 2),\n    (4, 2, 2, 2, 2),\n    (2, 2, 2, 2, 2, 2),\n]\n\n# global variables and functions\nI = np.identity(2)\nX = np.array([[0, 1], [1, 0]])\nY = np.array([[0, -1j], [1j, 0]])\nZ = np.array([[1, 0], [0, -1]])\n\n\nSWAP = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\nCNOT = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])\n\n\nU = np.array(\n    [\n        [0.83645892 - 0.40533293j, -0.20215326 + 0.30850569j],\n        [-0.23889780 - 0.28101519j, -0.88031770 - 0.29832709j],\n    ]\n)\n\nU2 = np.array([[0, 1, 1, 1], [1, 0, 1, -1], [1, -1, 0, 1], [1, 1, -1, 0]]) / np.sqrt(3)\n\n\nU_toffoli = np.diag([1 for i in range(8)])\nU_toffoli[6:8, 6:8] = np.array([[0, 1], [1, 0]])\n\n\nclass TestFlatten:\n    """"""Tests the flatten and unflatten functions""""""\n\n    @pytest.mark.parametrize(""shape"", test_shapes)\n    def test_flatten(self, shape):\n        """"""Tests that _flatten successfully flattens multidimensional arrays.""""""\n\n        reshaped = np.reshape(flat_dummy_array, shape)\n        flattened = np.array([x for x in pu._flatten(reshaped)])\n\n        assert flattened.shape == flat_dummy_array.shape\n        assert np.array_equal(flattened, flat_dummy_array)\n\n    @pytest.mark.parametrize(""shape"", test_shapes)\n    def test_unflatten(self, shape):\n        """"""Tests that _unflatten successfully unflattens multidimensional arrays.""""""\n\n        reshaped = np.reshape(flat_dummy_array, shape)\n        unflattened = np.array([x for x in pu.unflatten(flat_dummy_array, reshaped)])\n\n        assert unflattened.shape == reshaped.shape\n        assert np.array_equal(unflattened, reshaped)\n\n    def test_unflatten_error_unsupported_model(self):\n        """"""Tests that unflatten raises an error if the given model is not supported""""""\n\n        with pytest.raises(TypeError, match=""Unsupported type in the model""):\n            model = lambda x: x  # not a valid model for unflatten\n            pu.unflatten(flat_dummy_array, model)\n\n    def test_unflatten_error_too_many_elements(self):\n        """"""Tests that unflatten raises an error if the given iterable has\n           more elements than the model""""""\n\n        reshaped = np.reshape(flat_dummy_array, (16, 2, 2))\n\n        with pytest.raises(ValueError, match=""Flattened iterable has more elements than the model""):\n            pu.unflatten(np.concatenate([flat_dummy_array, flat_dummy_array]), reshaped)\n\n\nclass TestPauliEigs:\n    """"""Tests for the auxiliary function to return the eigenvalues for Paulis""""""\n\n    paulix = np.array([[0, 1], [1, 0]])\n    pauliy = np.array([[0, -1j], [1j, 0]])\n    pauliz = np.array([[1, 0], [0, -1]])\n    hadamard = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])\n\n    standard_observables = [paulix, pauliy, pauliz, hadamard]\n\n    matrix_pairs = [\n        np.kron(x, y)\n        for x, y in list(itertools.product(standard_observables, standard_observables))\n    ]\n\n    @pytest.mark.parametrize(""pauli"", standard_observables)\n    def test_correct_eigenvalues_paulis(self, pauli):\n        """"""Test the paulieigs function for one qubit""""""\n        assert np.array_equal(pu.pauli_eigs(1), np.diag(self.pauliz))\n\n    @pytest.mark.parametrize(""pauli_product"", matrix_pairs)\n    def test_correct_eigenvalues_pauli_kronecker_products_two_qubits(self, pauli_product):\n        """"""Test the paulieigs function for two qubits""""""\n        assert np.array_equal(pu.pauli_eigs(2), np.diag(np.kron(self.pauliz, self.pauliz)))\n\n    @pytest.mark.parametrize(""pauli_product"", matrix_pairs)\n    def test_correct_eigenvalues_pauli_kronecker_products_three_qubits(self, pauli_product):\n        """"""Test the paulieigs function for three qubits""""""\n        assert np.array_equal(\n            pu.pauli_eigs(3), np.diag(np.kron(self.pauliz, np.kron(self.pauliz, self.pauliz)))\n        )\n\n    @pytest.mark.parametrize(""depth"", list(range(1, 6)))\n    def test_cache_usage(self, depth):\n        """"""Test that the right number of cachings have been executed after clearing the cache""""""\n        pu.pauli_eigs.cache_clear()\n        pu.pauli_eigs(depth)\n        total_runs = sum([2 ** x for x in range(depth)])\n        assert functools._CacheInfo(depth - 1, depth, 128, depth) == pu.pauli_eigs.cache_info()\n\n\nclass TestArgumentHelpers:\n    """"""Tests for auxiliary functions to help with parsing\n    Python function arguments""""""\n\n    def test_no_default_args(self):\n        """"""Test that empty dict is returned if function has\n        no default arguments""""""\n\n        def dummy_func(a, b):  # pylint: disable=unused-argument\n            pass\n\n        res = pu._get_default_args(dummy_func)\n        assert not res\n\n    def test_get_default_args(self):\n        """"""Test that default arguments are correctly extracted""""""\n\n        def dummy_func(\n            a, b, c=8, d=[0, 0.65], e=np.array([4]), f=None\n        ):  # pylint: disable=unused-argument,dangerous-default-value\n            pass\n\n        res = pu._get_default_args(dummy_func)\n        expected = {""c"": (2, 8), ""d"": (3, [0, 0.65]), ""e"": (4, np.array([4])), ""f"": (5, None)}\n\n        assert res == expected\n\n    def test_inv_dict(self):\n        """"""Test _inv_dict correctly inverts a dictionary""""""\n        test_data = {""c"": 8, ""d"": (0, 0.65), ""e"": ""hi"", ""f"": None, ""g"": 8}\n        res = pu._inv_dict(test_data)\n        expected = {8: {""g"", ""c""}, (0, 0.65): {""d""}, ""hi"": {""e""}, None: {""f""}}\n\n        assert res == expected\n\n    def test_inv_dict_unhashable_key(self):\n        """"""Test _inv_dict raises an exception if a dictionary value is unhashable""""""\n        test_data = {""c"": 8, ""d"": [0, 0.65], ""e"": ""hi"", ""f"": None, ""g"": 8}\n\n        with pytest.raises(TypeError, match=""unhashable type""):\n            pu._inv_dict(test_data)\n\n\nclass TestExpand:\n    """"""Tests multi-qubit operator expansion""""""\n\n    def test_expand_one(self, tol):\n        """"""Test that a 1 qubit gate correctly expands to 3 qubits.""""""\n        # test applied to wire 0\n        res = pu.expand(U, [0], 3)\n        expected = np.kron(np.kron(U, I), I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 1\n        res = pu.expand(U, [1], 3)\n        expected = np.kron(np.kron(I, U), I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 2\n        res = pu.expand(U, [2], 3)\n        expected = np.kron(np.kron(I, I), U)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_expand_one_wires_list(self, tol):\n        """"""Test that a 1 qubit gate correctly expands to 3 qubits.""""""\n        # test applied to wire 0\n        res = pu.expand(U, [0], [0, 4, 9])\n        expected = np.kron(np.kron(U, I), I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 4\n        res = pu.expand(U, [4], [0, 4, 9])\n        expected = np.kron(np.kron(I, U), I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 9\n        res = pu.expand(U, [9], [0, 4, 9])\n        expected = np.kron(np.kron(I, I), U)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_expand_two_consecutive_wires(self, tol):\n        """"""Test that a 2 qubit gate on consecutive wires correctly\n        expands to 4 qubits.""""""\n\n        # test applied to wire 0+1\n        res = pu.expand(U2, [0, 1], 4)\n        expected = np.kron(np.kron(U2, I), I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 1+2\n        res = pu.expand(U2, [1, 2], 4)\n        expected = np.kron(np.kron(I, U2), I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 2+3\n        res = pu.expand(U2, [2, 3], 4)\n        expected = np.kron(np.kron(I, I), U2)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_expand_two_reversed_wires(self, tol):\n        """"""Test that a 2 qubit gate on reversed consecutive wires correctly\n        expands to 4 qubits.""""""\n\n        # CNOT with target on wire 1\n        res = pu.expand(CNOT, [1, 0], 4)\n        rows = np.array([0, 2, 1, 3])\n        expected = np.kron(np.kron(CNOT[:, rows][rows], I), I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_expand_invalid_wires(self):\n        """"""test exception raised if unphysical subsystems provided.""""""\n        with pytest.raises(\n            ValueError, match=""Invalid target subsystems provided in \'original_wires\' argument""\n        ):\n            pu.expand(U2, [-1, 5], 4)\n\n    def test_expand_invalid_matrix(self):\n        """"""test exception raised if incorrect sized matrix provided/""""""\n        with pytest.raises(ValueError, match=""Matrix parameter must be of size""):\n            pu.expand(U, [0, 1], 4)\n\n    def test_expand_three_consecutive_wires(self, tol):\n        """"""Test that a 3 qubit gate on consecutive\n        wires correctly expands to 4 qubits.""""""\n\n        # test applied to wire 0,1,2\n        res = pu.expand(U_toffoli, [0, 1, 2], 4)\n        expected = np.kron(U_toffoli, I)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 1,2,3\n        res = pu.expand(U_toffoli, [1, 2, 3], 4)\n        expected = np.kron(I, U_toffoli)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_expand_three_nonconsecutive_ascending_wires(self, tol):\n        """"""Test that a 3 qubit gate on non-consecutive but ascending\n        wires correctly expands to 4 qubits.""""""\n\n        # test applied to wire 0,2,3\n        res = pu.expand(U_toffoli, [0, 2, 3], 4)\n        expected = (\n            np.kron(SWAP, np.kron(I, I)) @ np.kron(I, U_toffoli) @ np.kron(SWAP, np.kron(I, I))\n        )\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 0,1,3\n        res = pu.expand(U_toffoli, [0, 1, 3], 4)\n        expected = (\n            np.kron(np.kron(I, I), SWAP) @ np.kron(U_toffoli, I) @ np.kron(np.kron(I, I), SWAP)\n        )\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_expand_three_nonconsecutive_nonascending_wires(self, tol):\n        """"""Test that a 3 qubit gate on non-consecutive non-ascending\n        wires correctly expands to 4 qubits""""""\n\n        # test applied to wire 3, 1, 2\n        res = pu.expand(U_toffoli, [3, 1, 2], 4)\n        # change the control qubit on the Toffoli gate\n        rows = np.array([0, 4, 1, 5, 2, 6, 3, 7])\n        expected = np.kron(I, U_toffoli[:, rows][rows])\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # test applied to wire 3, 0, 2\n        res = pu.expand(U_toffoli, [3, 0, 2], 4)\n        # change the control qubit on the Toffoli gate\n        rows = np.array([0, 4, 1, 5, 2, 6, 3, 7])\n        expected = (\n            np.kron(SWAP, np.kron(I, I))\n            @ np.kron(I, U_toffoli[:, rows][rows])\n            @ np.kron(SWAP, np.kron(I, I))\n        )\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    VECTOR1 = np.array([1, -1])\n    ONES = np.array([1, 1])\n\n    @pytest.mark.parametrize(\n        ""original_wires,expanded_wires,expected"",\n        [\n            ([0], 3, np.kron(np.kron(VECTOR1, ONES), ONES)),\n            ([1], 3, np.kron(np.kron(ONES, VECTOR1), ONES)),\n            ([2], 3, np.kron(np.kron(ONES, ONES), VECTOR1)),\n            ([0], [0, 4, 7], np.kron(np.kron(VECTOR1, ONES), ONES)),\n            ([4], [0, 4, 7], np.kron(np.kron(ONES, VECTOR1), ONES)),\n            ([7], [0, 4, 7], np.kron(np.kron(ONES, ONES), VECTOR1)),\n            ([0], [0, 4, 7], np.kron(np.kron(VECTOR1, ONES), ONES)),\n            ([4], [4, 0, 7], np.kron(np.kron(VECTOR1, ONES), ONES)),\n            ([7], [7, 4, 0], np.kron(np.kron(VECTOR1, ONES), ONES)),\n        ],\n    )\n    def test_expand_vector_single_wire(self, original_wires, expanded_wires, expected, tol):\n        """"""Test that expand_vector works with a single-wire vector.""""""\n\n        res = pu.expand_vector(TestExpand.VECTOR1, original_wires, expanded_wires)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    VECTOR2 = np.array([1, 2, 3, 4])\n    ONES = np.array([1, 1])\n\n    @pytest.mark.parametrize(\n        ""original_wires,expanded_wires,expected"",\n        [\n            ([0, 1], 3, np.kron(VECTOR2, ONES)),\n            ([1, 2], 3, np.kron(ONES, VECTOR2)),\n            ([0, 2], 3, np.array([1, 2, 1, 2, 3, 4, 3, 4])),\n            ([0, 5], [0, 5, 9], np.kron(VECTOR2, ONES)),\n            ([5, 9], [0, 5, 9], np.kron(ONES, VECTOR2)),\n            ([0, 9], [0, 5, 9], np.array([1, 2, 1, 2, 3, 4, 3, 4])),\n            ([9, 0], [0, 5, 9], np.array([1, 3, 1, 3, 2, 4, 2, 4])),\n        ],\n    )\n    def test_expand_vector_two_wires(self, original_wires, expanded_wires, expected, tol):\n        """"""Test that expand_vector works with a single-wire vector.""""""\n\n        res = pu.expand_vector(TestExpand.VECTOR2, original_wires, expanded_wires)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_expand_vector_invalid_wires(self):\n        """"""Test exception raised if unphysical subsystems provided.""""""\n        with pytest.raises(\n            ValueError, match=""Invalid target subsystems provided in \'original_wires\' argument""\n        ):\n            pu.expand_vector(TestExpand.VECTOR2, [-1, 5], 4)\n\n    def test_expand_vector_invalid_vector(self):\n        """"""Test exception raised if incorrect sized vector provided.""""""\n        with pytest.raises(ValueError, match=""Vector parameter must be of length""):\n            pu.expand_vector(TestExpand.VECTOR1, [0, 1], 4)\n\n\nclass TestOperationRecorder:\n    """"""Test the OperationRecorder class.""""""\n\n    def test_context_adding(self, monkeypatch):\n        """"""Test that the OperationRecorder is added to the list of contexts.""""""\n        with pu.OperationRecorder() as recorder:\n            assert recorder in qml.QueuingContext._active_contexts\n\n        assert recorder not in qml.QueuingContext._active_contexts\n\n    def test_circuit_integration(self):\n        """"""Tests that the OperationRecorder integrates well with the\n        core behaviour of PennyLane.""""""\n        expected_output = (\n            ""Operations\\n""\n            + ""==========\\n""\n            + ""PauliY(wires=[0])\\n""\n            + ""PauliY(wires=[1])\\n""\n            + ""RZ(0.4, wires=[0])\\n""\n            + ""RZ(0.4, wires=[1])\\n""\n            + ""CNOT(wires=[0, 1])\\n""\n            + ""\\n""\n            + ""Observables\\n""\n            + ""==========\\n""\n        )\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RY(b, wires=1)\n\n            with pu.OperationRecorder() as recorder:\n                ops = [\n                    qml.PauliY(0),\n                    qml.PauliY(1),\n                    qml.RZ(c, wires=0),\n                    qml.RZ(c, wires=1),\n                    qml.CNOT(wires=[0, 1]),\n                ]\n\n            assert str(recorder) == expected_output\n            assert recorder.queue == ops\n\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        circuit(0.1, 0.2, 0.4)\n\n    def test_template_integration(self):\n        """"""Tests that the OperationRecorder integrates well with the\n        core behaviour of PennyLane.""""""\n        expected_output = (\n            ""Operations\\n""\n            + ""==========\\n""\n            + ""RZ(0, wires=[0])\\n""\n            + ""RZ(3, wires=[0])\\n""\n            + ""RZ(6, wires=[0])\\n""\n            + ""RZ(9, wires=[0])\\n""\n            + ""RZ(12, wires=[0])\\n""\n            + ""\\n""\n            + ""Observables\\n""\n            + ""==========\\n""\n        )\n\n        def template(x):\n            for i in range(5):\n                qml.RZ(i * x, wires=0)\n\n        with pu.OperationRecorder() as recorder:\n            template(3)\n\n        assert str(recorder) == expected_output\n\n    def test_template_with_return_integration(self):\n        """"""Tests that the OperationRecorder integrates well with the\n        core behaviour of PennyLane.""""""\n        expected_output = (\n            ""Operations\\n""\n            + ""==========\\n""\n            + ""RZ(0, wires=[0])\\n""\n            + ""RZ(3, wires=[0])\\n""\n            + ""RZ(6, wires=[0])\\n""\n            + ""RZ(9, wires=[0])\\n""\n            + ""RZ(12, wires=[0])\\n""\n            + ""\\n""\n            + ""Observables\\n""\n            + ""==========\\n""\n            + ""var(PauliZ(wires=[0]))\\n""\n            + ""sample(PauliX(wires=[1]))\\n""\n        )\n\n        def template(x):\n            for i in range(5):\n                qml.RZ(i * x, wires=0)\n\n            return qml.var(qml.PauliZ(0)), qml.sample(qml.PauliX(1))\n\n        with pu.OperationRecorder() as recorder:\n            template(3)\n\n        assert str(recorder) == expected_output\n\n\n@qml.template\ndef dummy_template(wires):\n    """"""Dummy template for inv tests.""""""\n    for wire in wires:\n        qml.RX(1, wires=[wire])\n        qml.RY(-1, wires=[wire])\n\n\ndef inverted_dummy_template_operations(wires):\n    """"""The expected inverted operations for the dummy template.""""""\n    ops = []\n\n    for wire in reversed(wires):\n        ops.append(qml.RY(-1, wires=[wire]).inv())\n        ops.append(qml.RX(1, wires=[wire]).inv())\n\n    return ops\n\n\nclass TestInv:\n    """"""Test the template inversion function.""""""\n\n    def test_inversion_without_context(self):\n        """"""Test that a sequence of operations is properly inverted.""""""\n        op_queue = [qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0)]\n        inv_queue = [qml.PauliZ(0).inv(), qml.PauliY(0).inv(), qml.PauliX(0).inv()]\n\n        inv_ops = pu.inv(op_queue)\n\n        for inv_op, exp_op in zip(inv_ops, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_template_inversion_without_context(self):\n        """"""Test that a template is properly inverted.""""""\n        inv_queue = inverted_dummy_template_operations([0, 1, 2])\n\n        inv_ops = pu.inv(dummy_template([0, 1, 2]))\n\n        for inv_op, exp_op in zip(inv_ops, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_double_inversion(self):\n        """"""Test that inverting twice changes nothing.""""""\n        op_queue = [qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0)]\n\n        inv_inv_ops = pu.inv(pu.inv(op_queue))\n\n        for inv_inv_op, exp_op in zip(inv_inv_ops, op_queue):\n            assert inv_inv_op.name == exp_op.name\n            assert inv_inv_op.wires == exp_op.wires\n            assert inv_inv_op.params == exp_op.params\n\n    def test_template_double_inversion(self):\n        """"""Test that inverting twice changes nothing for a template.""""""\n        inv_inv_ops = pu.inv(pu.inv(dummy_template([0, 1, 2])))\n\n        for inv_inv_op, exp_op in zip(inv_inv_ops, dummy_template([0, 1, 2])):\n            assert inv_inv_op.name == exp_op.name\n            assert inv_inv_op.wires == exp_op.wires\n            assert inv_inv_op.params == exp_op.params\n\n    def test_inversion_with_context(self):\n        """"""Test that a sequence of operations is properly inverted when a context is present.""""""\n        with pu.OperationRecorder() as rec:\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv([qml.RX(1, wires=[0]), qml.RY(2, wires=[0]), qml.RZ(3, wires=[0])])\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            qml.RZ(3, wires=[0]).inv(),\n            qml.RY(2, wires=[0]).inv(),\n            qml.RX(1, wires=[0]).inv(),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        for inv_op, exp_op in zip(rec.queue, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_non_queued_inversion_with_context(self):\n        """"""Test that a sequence of operations is properly inverted when a context is present.\n        Test that this also works for operations that were not queued.""""""\n        inv_ops = [qml.RX(1, wires=[0]), qml.RY(2, wires=[0]), qml.RZ(3, wires=[0])]\n\n        with pu.OperationRecorder() as rec:\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv(inv_ops)\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            qml.RZ(3, wires=[0]).inv(),\n            qml.RY(2, wires=[0]).inv(),\n            qml.RX(1, wires=[0]).inv(),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        for inv_op, exp_op in zip(rec.queue, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_mixed_inversion_with_context(self):\n        """"""Test that a sequence of operations is properly inverted when a context is present.\n        Test that this also works for operations that were not queued.""""""\n        X0 = qml.PauliX(0)\n        Z0 = qml.PauliZ(0)\n\n        with pu.OperationRecorder() as rec:\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv([X0, qml.RX(1, wires=[0]), Z0, qml.RY(2, wires=[0])])\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            qml.RY(2, wires=[0]).inv(),\n            qml.PauliZ(0).inv(),\n            qml.RX(1, wires=[0]).inv(),\n            qml.PauliX(0).inv(),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        for inv_op, exp_op in zip(rec.queue, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_mixed_inversion_with_nested_context(self):\n        """"""Test that a sequence of operations is properly inverted when a nested context is present.\n        Test that this also works for operations that were not queued.""""""\n        X0 = qml.PauliX(0)\n        Z0 = qml.PauliZ(0)\n\n        with pu.OperationRecorder() as rec1:\n            with pu.OperationRecorder() as rec2:\n                qml.Hadamard(wires=[0])\n                qml.CNOT(wires=[0, 1])\n                pu.inv([X0, qml.RX(1, wires=[0]), Z0, qml.RY(2, wires=[0])])\n                qml.CNOT(wires=[0, 1])\n                qml.Hadamard(wires=[0])\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            qml.RY(2, wires=[0]).inv(),\n            qml.PauliZ(0).inv(),\n            qml.RX(1, wires=[0]).inv(),\n            qml.PauliX(0).inv(),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        for inv_op, exp_op in zip(rec1.queue, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n        for inv_op, exp_op in zip(rec2.queue, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_template_inversion_with_context(self):\n        """"""Test that a template is properly inverted when a context is present.""""""\n        with pu.OperationRecorder() as rec:\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv(dummy_template([0, 1, 2]))\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            *inverted_dummy_template_operations([0, 1, 2]),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        for inv_op, exp_op in zip(rec.queue, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_inversion_with_qnode(self):\n        """"""Test that a sequence of operations is properly inverted when inside a QNode.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def qfunc():\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv([qml.RX(1, wires=[0]), qml.RY(2, wires=[0]), qml.RZ(3, wires=[0])])\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n            return qml.expval(qml.PauliZ(0))\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            qml.RZ(3, wires=[0]).inv(),\n            qml.RY(2, wires=[0]).inv(),\n            qml.RX(1, wires=[0]).inv(),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        qfunc()\n\n        for inv_op, exp_op in zip(qfunc.ops, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_non_queued_inversion_with_qnode(self):\n        """"""Test that a sequence of operations is properly inverted inside a QNode.\n        Test that this also works for operations that were not queued.""""""\n        inv_ops = [qml.RX(1, wires=[0]), qml.RY(2, wires=[0]), qml.RZ(3, wires=[0])]\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def qfunc():\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv(inv_ops)\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n            return qml.expval(qml.PauliZ(0))\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            qml.RZ(3, wires=[0]).inv(),\n            qml.RY(2, wires=[0]).inv(),\n            qml.RX(1, wires=[0]).inv(),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        qfunc()\n\n        for inv_op, exp_op in zip(qfunc.ops, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_mixed_inversion_with_qnode(self):\n        """"""Test that a sequence of operations is properly inverted inside a QNode.\n        Test that this also works for operations of queued and non-queued operations.""""""\n        X0 = qml.PauliX(0)\n        Z0 = qml.PauliZ(0)\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def qfunc():\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv([X0, qml.RX(1, wires=[0]), Z0, qml.RY(2, wires=[0])])\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n            return qml.expval(qml.PauliZ(0))\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            qml.RY(2, wires=[0]).inv(),\n            qml.PauliZ(0).inv(),\n            qml.RX(1, wires=[0]).inv(),\n            qml.PauliX(0).inv(),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        qfunc()\n\n        for inv_op, exp_op in zip(qfunc.ops, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_template_inversion_with_qnode(self):\n        """"""Test that a template is properly inverted when inside a QNode.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def qfunc():\n            qml.Hadamard(wires=[0])\n            qml.CNOT(wires=[0, 1])\n            pu.inv(dummy_template([0, 1]))\n            qml.CNOT(wires=[0, 1])\n            qml.Hadamard(wires=[0])\n\n            return qml.expval(qml.PauliZ(0))\n\n        inv_queue = [\n            qml.Hadamard(wires=[0]),\n            qml.CNOT(wires=[0, 1]),\n            *inverted_dummy_template_operations([0, 1]),\n            qml.CNOT(wires=[0, 1]),\n            qml.Hadamard(wires=[0]),\n        ]\n\n        qfunc()\n\n        for inv_op, exp_op in zip(qfunc.ops, inv_queue):\n            assert inv_op.name == exp_op.name\n            assert inv_op.wires == exp_op.wires\n            assert inv_op.params == exp_op.params\n\n    def test_argument_wrapping(self):\n        """"""Test that a single operation can be given to inv and is properly inverted.""""""\n        op = qml.PauliX(0)\n        exp_op = qml.PauliX(0).inv()\n\n        inv_ops = pu.inv(op)\n\n        assert inv_ops[0].name == exp_op.name\n        assert inv_ops[0].wires == exp_op.wires\n        assert inv_ops[0].params == exp_op.params\n\n    @pytest.mark.parametrize(""arg"", [2.3, object()])\n    def test_argument_type_error(self, arg):\n        """"""Test that the proper error is raised when the argument type is wrong.""""""\n        with pytest.raises(ValueError, match=""The provided operation_list is not iterable""):\n            pu.inv(arg)\n\n    def test_argument_none_error(self):\n        """"""Test that the proper error is raised when the argument type is wrong.""""""\n        with pytest.raises(\n            ValueError,\n            match=""None was passed as an argument to inv. ""\n            + ""This could happen if inversion of a template without the template decorator is attempted"",\n        ):\n            pu.inv(None)\n\n    def test_callable_argument_error(self):\n        """"""Test that the proper error is raised when the argument is a function.""""""\n\n        def func(x):\n            return x\n\n        with pytest.raises(\n            ValueError, match=""A function was passed as an argument to inv. "",\n        ):\n            pu.inv(func)\n\n    @pytest.mark.parametrize(""arg"", [[1, 2, 3], [qml.PauliX(0), qml.PauliY(1), ""Test""], ""Test"",])\n    def test_non_operations_in_list(self, arg):\n        """"""Test that the proper error is raised when the argument does not only contain operations.""""""\n        with pytest.raises(\n            ValueError, match=""The given operation_list does not only contain Operations""\n        ):\n            pu.inv(arg)\n'"
tests/test_variable.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for :mod:`pennylane.variable`.\n""""""\nimport pytest\nimport numpy.random as nr\n\nfrom pennylane.variable import Variable\n\n\n# make test deterministic\nnr.seed(42)\n\nn = 10\nkeyword_par_names = [\'foo\', \'bar\']\npar_inds = [0, 9]\npar_mults = [1, 0.4, -2.7]\n\n\n@pytest.fixture(scope=""function"")\ndef par_positional():\n    ""QNode: positional parameters""\n    temp = nr.randn(n)\n    Variable.positional_arg_values = temp  # set the values\n    return temp\n\n@pytest.fixture(scope=""function"")\ndef par_keyword():\n    ""QNode: keyword parameters""\n    temp = {name: nr.randn(n) for name in keyword_par_names}\n    Variable.kwarg_values = temp  # set the values\n    return temp\n\n\ndef test_variable_repr():\n    """"""Variable string rep.""""""\n    p = Variable(0)\n    assert repr(p) == ""<Variable(None:0)>""\n    assert repr(-p) == ""<Variable(None:0 * -1)>""\n    assert repr(1.2 * p * 0.4) == ""<Variable(None:0 * 0.48)>""\n    assert repr(1.2 * p / 2.5) == ""<Variable(None:0 * 0.48)>""\n\n    p = Variable(0, name=""kw1"")\n    assert repr(p) == ""<Variable(kw1:0)>""\n    assert repr(-p) == ""<Variable(kw1:0 * -1)>""\n    assert repr(1.2 * p * 0.4) == ""<Variable(kw1:0 * 0.48)>""\n    assert repr(1.2 * p / 2.5) == ""<Variable(kw1:0 * 0.48)>""\n\ndef test_variable_str():\n    """"""Variable informal string rep.""""""\n    p = Variable(0)\n    assert str(p) == ""Variable: name = None, idx = 0""\n    assert str(-p) == ""Variable: name = None, idx = 0, * -1""\n\n    p = Variable(0, name=""kw1"")\n    assert str(p) == ""Variable: name = kw1, idx = 0""\n    assert str(2.1 * p) == ""Variable: name = kw1, idx = 0, * 2.1""\n\ndef variable_eval_asserts(v, p, m, tol):\n    """"""Check that variable evaluation (with scalar multiplication) yields the expected results.""""""\n    assert v.val == p  # normal evaluation\n    assert (m * v).val == m * p  # left scalar mul\n    assert (v * m).val == m * p  # right scalar mul\n    assert (v / m).val == pytest.approx(p / m, abs=tol)  # right scalar div\n    assert (-v).val == -p   # unary minus\n    assert (m * -v * m).val == -m**2 * p  # compound expression\n\n\n@pytest.mark.parametrize(""ind"", par_inds)\n@pytest.mark.parametrize(""mult"", par_mults)\ndef test_variable_val(par_positional, ind, mult, tol):\n    """"""Positional variable evaluation.""""""\n    v = Variable(ind)\n\n    assert v.name is None\n    assert v.mult == 1\n    assert v.idx == ind\n    variable_eval_asserts(v, par_positional[ind], mult, tol)\n\n\n@pytest.mark.parametrize(""ind"", par_inds)\n@pytest.mark.parametrize(""mult"", par_mults)\n@pytest.mark.parametrize(""name"", keyword_par_names)\ndef test_keyword_variable(par_keyword, name, ind, mult, tol):\n    """"""Keyword variable evaluation.""""""\n    v = Variable(ind, name, is_kwarg=True)\n\n    assert v.name == name\n    assert v.mult == 1\n    assert v.idx == ind\n    variable_eval_asserts(v, par_keyword[name][ind], mult, tol)\n'"
tests/test_vqe.py,6,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.vqe` submodule.\n""""""\nimport pytest\nimport pennylane as qml\nimport numpy as np\n\n\ntry:\n    import torch\nexcept ImportError as e:\n    pass\n\n\ntry:\n    import tensorflow as tf\n\n    if tf.__version__[0] == ""1"":\n        tf.enable_eager_execution()\n\n    from tensorflow import Variable\nexcept ImportError as e:\n    pass\n\n\n@pytest.fixture(scope=""function"")\ndef seed():\n    """"""Resets the random seed with every test""""""\n    np.random.seed(0)\n\n\n#####################################################\n# Hamiltonians\n\n\nH_ONE_QUBIT = np.array([[1.0, 0.5j], [-0.5j, 2.5]])\n\nH_TWO_QUBITS = np.array(\n    [[0.5, 1.0j, 0.0, -3j], [-1.0j, -1.1, 0.0, -0.1], [0.0, 0.0, -0.9, 12.0], [3j, -0.1, 12.0, 0.0]]\n)\n\nCOEFFS = [(0.5, 1.2, -0.7), (2.2, -0.2, 0.0), (0.33,)]\n\nOBSERVABLES = [\n    (qml.PauliZ(0), qml.PauliY(0), qml.PauliZ(1)),\n    (qml.PauliX(0) @ qml.PauliZ(1), qml.PauliY(0) @ qml.PauliZ(1), qml.PauliZ(1)),\n    (qml.Hermitian(H_TWO_QUBITS, [0, 1]),),\n]\n\nJUNK_INPUTS = [None, [], tuple(), 5.0, {""junk"": -1}]\n\nvalid_hamiltonians = [\n    ((1.0,), (qml.Hermitian(H_TWO_QUBITS, [0, 1]),)),\n    ((-0.8,), (qml.PauliZ(0),)),\n    ((0.5, -1.6), (qml.PauliX(0), qml.PauliY(1))),\n    ((0.5, -1.6), (qml.PauliX(1), qml.PauliY(1))),\n    ((1.1, -0.4, 0.333), (qml.PauliX(0), qml.Hermitian(H_ONE_QUBIT, 2), qml.PauliZ(2))),\n    ((-0.4, 0.15), (qml.Hermitian(H_TWO_QUBITS, [0, 2]), qml.PauliZ(1))),\n    ([1.5, 2.0], [qml.PauliZ(0), qml.PauliY(2)]),\n    (np.array([-0.1, 0.5]), [qml.Hermitian(H_TWO_QUBITS, [0, 1]), qml.PauliY(0)]),\n    ((0.5, 1.2), (qml.PauliX(0), qml.PauliX(0) @ qml.PauliX(1))),\n]\n\ninvalid_hamiltonians = [\n    ((), (qml.PauliZ(0),)),\n    ((), (qml.PauliZ(0), qml.PauliY(1))),\n    ((3.5,), ()),\n    ((1.2, -0.4), ()),\n    ((0.5, 1.2), (qml.PauliZ(0),)),\n    ((1.0,), (qml.PauliZ(0), qml.PauliY(0))),\n]\n\n\nhamiltonians_with_expvals = [\n    ((-0.6,), (qml.PauliZ(0),), [-0.6 * 1.0]),\n    ((1.0,), (qml.PauliX(0),), [0.0]),\n    ((0.5, 1.2), (qml.PauliZ(0), qml.PauliX(0)), [0.5 * 1.0, 0]),\n    ((0.5, 1.2), (qml.PauliZ(0), qml.PauliX(1)), [0.5 * 1.0, 0]),\n    ((0.5, 1.2), (qml.PauliZ(0), qml.PauliZ(0)), [0.5 * 1.0, 1.2 * 1.0]),\n    ((0.5, 1.2), (qml.PauliZ(0), qml.PauliZ(1)), [0.5 * 1.0, 1.2 * 1.0]),\n]\n\n#####################################################\n# Ansatz\n\ndef custom_fixed_ansatz(params, wires=None):\n    """"""Custom fixed ansatz""""""\n    qml.RX(0.5, wires=0)\n    qml.RX(-1.2, wires=1)\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.Hadamard(wires=1)\n    qml.CNOT(wires=[0, 1])\n\n\ndef custom_var_ansatz(params, wires=None):\n    """"""Custom parametrized ansatz""""""\n    for p in params:\n        qml.RX(p, wires=wires[0])\n\n    qml.CNOT(wires=[wires[0], wires[1]])\n\n    for p in params:\n        qml.RX(-p, wires=wires[1])\n\n    qml.CNOT(wires=[wires[0], wires[1]])\n\n\ndef amp_embed_and_strong_ent_layer(params, wires=None):\n    """"""Ansatz combining amplitude embedding and\n    strongly entangling layers""""""\n    qml.templates.embeddings.AmplitudeEmbedding(params[0], wires=wires)\n    qml.templates.layers.StronglyEntanglingLayers(params[1], wires=wires)\n\n\nANSAETZE = [\n    lambda params, wires=None: None,\n    custom_fixed_ansatz,\n    custom_var_ansatz,\n    qml.templates.embeddings.AmplitudeEmbedding,\n    qml.templates.layers.StronglyEntanglingLayers,\n    amp_embed_and_strong_ent_layer,\n]\n\n#####################################################\n# Parameters\n\nEMPTY_PARAMS = []\nVAR_PARAMS = [0.5]\nEMBED_PARAMS = np.array([1 / np.sqrt(2 ** 3)] * 2 ** 3)\nLAYER_PARAMS = qml.init.strong_ent_layers_uniform(n_layers=2, n_wires=3)\n\nCIRCUITS = [\n    (lambda params, wires=None: None, EMPTY_PARAMS),\n    (custom_fixed_ansatz, EMPTY_PARAMS),\n    (custom_var_ansatz, VAR_PARAMS),\n    (qml.templates.layers.StronglyEntanglingLayers, LAYER_PARAMS),\n    (qml.templates.embeddings.AmplitudeEmbedding, EMBED_PARAMS),\n    (amp_embed_and_strong_ent_layer, (EMBED_PARAMS, LAYER_PARAMS)),\n]\n\n#####################################################\n# Device\n\n@pytest.fixture(scope=""function"")\ndef mock_device(monkeypatch):\n    with monkeypatch.context() as m:\n        m.setattr(qml.Device, ""__abstractmethods__"", frozenset())\n        m.setattr(qml.Device, ""_capabilities"", {""tensor_observables"": True, ""model"": ""qubit""})\n        m.setattr(qml.Device, ""operations"", [""RX"", ""Rot"", ""CNOT"", ""Hadamard"", ""QubitStateVector""])\n        m.setattr(\n            qml.Device, ""observables"", [""PauliX"", ""PauliY"", ""PauliZ"", ""Hadamard"", ""Hermitian""]\n        )\n        m.setattr(qml.Device, ""short_name"", ""MockDevice"")\n        m.setattr(qml.Device, ""expval"", lambda self, x, y, z: 1)\n        m.setattr(qml.Device, ""var"", lambda self, x, y, z: 2)\n        m.setattr(qml.Device, ""sample"", lambda self, x, y, z: 3)\n        m.setattr(qml.Device, ""apply"", lambda self, x, y, z: None)\n        yield qml.Device()\n\n#####################################################\n# Tests\n\nclass TestHamiltonian:\n    """"""Test the Hamiltonian class""""""\n\n    @pytest.mark.parametrize(""coeffs, ops"", valid_hamiltonians)\n    def test_hamiltonian_valid_init(self, coeffs, ops):\n        """"""Tests that the Hamiltonian object is created with\n        the correct attributes""""""\n        H = qml.vqe.Hamiltonian(coeffs, ops)\n        assert H.terms == (coeffs, ops)\n\n    @pytest.mark.parametrize(""coeffs, ops"", invalid_hamiltonians)\n    def test_hamiltonian_invalid_init_exception(self, coeffs, ops):\n        """"""Tests that an exception is raised when giving an invalid\n        combination of coefficients and ops""""""\n        with pytest.raises(ValueError, match=""number of coefficients and operators does not match""):\n            H = qml.vqe.Hamiltonian(coeffs, ops)\n\n    @pytest.mark.parametrize(""coeffs"", [[0.2, -1j], [0.5j, 2-1j]])\n    def test_hamiltonian_complex(self, coeffs):\n        """"""Tests that an exception is raised when\n        a complex Hamiltonian is given""""""\n        obs = [qml.PauliX(0), qml.PauliZ(1)]\n\n        with pytest.raises(ValueError, match=""coefficients are not real-valued""):\n            H = qml.vqe.Hamiltonian(coeffs, obs)\n\n    @pytest.mark.parametrize(""obs"", [[qml.PauliX(0), qml.CNOT(wires=[0, 1])], [qml.PauliZ, qml.PauliZ(0)]])\n    def test_hamiltonian_invalid_observables(self, obs):\n        """"""Tests that an exception is raised when\n        a complex Hamiltonian is given""""""\n        coeffs = [0.1, 0.2]\n\n        with pytest.raises(ValueError, match=""observables are not valid""):\n            H = qml.vqe.Hamiltonian(coeffs, obs)\n\n\nclass TestVQE:\n    """"""Test the core functionality of the VQE module""""""\n\n    @pytest.mark.parametrize(""ansatz"", ANSAETZE)\n    @pytest.mark.parametrize(""observables"", OBSERVABLES)\n    def test_circuits_valid_init(self, ansatz, observables, mock_device):\n        """"""Tests that a collection of circuits is properly created by vqe.circuits""""""\n        circuits = qml.map(ansatz, observables, device=mock_device)\n\n        assert len(circuits) == len(observables)\n        assert all(callable(c) for c in circuits)\n        assert all(c.device == mock_device for c in circuits)\n        assert all(hasattr(c, ""jacobian"") for c in circuits)\n\n    @pytest.mark.parametrize(""ansatz, params"", CIRCUITS)\n    @pytest.mark.parametrize(""observables"", OBSERVABLES)\n    def test_circuits_evaluate(self, ansatz, observables, params, mock_device, seed):\n        """"""Tests that the circuits returned by ``vqe.circuits`` evaluate properly""""""\n        mock_device.num_wires = 3\n        circuits = qml.map(ansatz, observables, device=mock_device)\n        res = circuits(params)\n        assert all(val == 1.0 for val in res)\n\n    @pytest.mark.parametrize(""coeffs, observables, expected"", hamiltonians_with_expvals)\n    def test_circuits_expvals(self, coeffs, observables, expected):\n        """"""Tests that the vqe.circuits function returns correct expectation values""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        circuits = qml.map(lambda params, **kwargs: None, observables, dev)\n        res = [a * c([]) for a, c in zip(coeffs, circuits)]\n        assert np.all(res == expected)\n\n    @pytest.mark.parametrize(""ansatz"", ANSAETZE)\n    @pytest.mark.parametrize(""observables"", JUNK_INPUTS)\n    def test_circuits_no_observables(self, ansatz, observables, mock_device):\n        """"""Tests that an exception is raised when no observables are supplied to vqe.circuits""""""\n        with pytest.raises(ValueError, match=""observables are not valid""):\n            obs = (observables,)\n            circuits = qml.map(ansatz, obs, device=mock_device)\n\n    @pytest.mark.parametrize(""ansatz"", JUNK_INPUTS)\n    @pytest.mark.parametrize(""observables"", OBSERVABLES)\n    def test_circuits_no_ansatz(self, ansatz, observables, mock_device):\n        """"""Tests that an exception is raised when no valid ansatz is supplied to vqe.circuits""""""\n        with pytest.raises(ValueError, match=""not a callable function""):\n            circuits = qml.map(ansatz, observables, device=mock_device)\n\n    @pytest.mark.parametrize(""coeffs, observables, expected"", hamiltonians_with_expvals)\n    def test_aggregate_expval(self, coeffs, observables, expected):\n        """"""Tests that the aggregate function returns correct expectation values""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        qnodes = qml.map(lambda params, **kwargs: None, observables, dev)\n        expval = qml.dot(coeffs, qnodes)\n        assert expval([]) == sum(expected)\n\n    @pytest.mark.parametrize(""ansatz, params"", CIRCUITS)\n    @pytest.mark.parametrize(""coeffs, observables"", [z for z in zip(COEFFS, OBSERVABLES)])\n    def test_cost_evaluate(self, params, ansatz, coeffs, observables):\n        """"""Tests that the cost function evaluates properly""""""\n        hamiltonian = qml.vqe.Hamiltonian(coeffs, observables)\n        dev = qml.device(""default.qubit"", wires=3)\n        expval = qml.VQECost(ansatz, hamiltonian, dev)\n        assert type(expval(params)) == np.float64\n        assert np.shape(expval(params)) == ()  # expval should be scalar\n\n    @pytest.mark.parametrize(""coeffs, observables, expected"", hamiltonians_with_expvals)\n    def test_cost_expvals(self, coeffs, observables, expected):\n        """"""Tests that the cost function returns correct expectation values""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        hamiltonian = qml.vqe.Hamiltonian(coeffs, observables)\n        cost = qml.VQECost(lambda params, **kwargs: None, hamiltonian, dev)\n        assert cost([]) == sum(expected)\n\n    @pytest.mark.parametrize(""ansatz"", JUNK_INPUTS)\n    def test_cost_invalid_ansatz(self, ansatz, mock_device):\n        """"""Tests that the cost function raises an exception if the ansatz is not valid""""""\n        hamiltonian = qml.vqe.Hamiltonian((1.0,), [qml.PauliZ(0)])\n        with pytest.raises(ValueError, match=""not a callable function.""):\n            cost = qml.VQECost(4, hamiltonian, mock_device)\n\n    @pytest.mark.parametrize(""coeffs, observables, expected"", hamiltonians_with_expvals)\n    def test_passing_kwargs(self, coeffs, observables, expected):\n        """"""Test that the step size and order used for the finite differences\n        differentiation method were passed to the QNode instances using the\n        keyword arguments.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        hamiltonian = qml.vqe.Hamiltonian(coeffs, observables)\n        cost = qml.VQECost(lambda params, **kwargs: None, hamiltonian, dev, h=123, order=2)\n\n        # Checking that the qnodes contain the step size and order\n        for qnode in cost.qnodes:\n            assert qnode.h == 123\n            assert qnode.order == 2\n\n\nclass TestAutogradInterface:\n    """"""Tests for the Autograd interface (and the NumPy interface for backward compatibility)""""""\n\n    @pytest.mark.parametrize(""ansatz, params"", CIRCUITS)\n    @pytest.mark.parametrize(""observables"", OBSERVABLES)\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy""])\n    def test_QNodes_have_right_interface(self, ansatz, observables, params, mock_device, interface):\n        """"""Test that QNodes have the Autograd interface""""""\n        mock_device.num_wires = 3\n        circuits = qml.map(ansatz, observables, device=mock_device, interface=interface)\n\n        assert all(c.interface == ""autograd"" for c in circuits)\n        assert all(c.__class__.__name__ == ""AutogradQNode"" for c in circuits)\n\n        res = [c(params) for c in circuits]\n        assert all(isinstance(val, float) for val in res)\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy""])\n    def test_gradient(self, tol, interface):\n        """"""Test differentiation works""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def ansatz(params, **kwargs):\n            qml.RX(params[0], wires=0)\n            qml.RY(params[1], wires=0)\n\n        coeffs = [0.2, 0.5]\n        observables = [qml.PauliX(0), qml.PauliY(0)]\n\n        H = qml.vqe.Hamiltonian(coeffs, observables)\n        a, b = 0.54, 0.123\n        params = np.array([a, b])\n\n        cost = qml.VQECost(ansatz, H, dev, interface=interface)\n        dcost = qml.grad(cost, argnum=[0])\n        res = dcost(params)\n\n        expected = [\n            -coeffs[0]*np.sin(a)*np.sin(b) - coeffs[1]*np.cos(a),\n            coeffs[0]*np.cos(a)*np.cos(b)\n        ]\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\n@pytest.mark.usefixtures(""skip_if_no_torch_support"")\nclass TestTorchInterface:\n    """"""Tests for the PyTorch interface""""""\n\n    @pytest.mark.parametrize(""ansatz, params"", CIRCUITS)\n    @pytest.mark.parametrize(""observables"", OBSERVABLES)\n    def test_QNodes_have_right_interface(self, ansatz, observables, params, mock_device):\n        """"""Test that QNodes have the torch interface""""""\n        mock_device.num_wires = 3\n        circuits = qml.map(ansatz, observables, device=mock_device, interface=""torch"")\n        assert all(c.interface == ""torch"" for c in circuits)\n\n        res = [c(params) for c in circuits]\n        assert all(isinstance(val, torch.Tensor) for val in res)\n\n    def test_gradient(self, tol):\n        """"""Test differentiation works""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def ansatz(params, **kwargs):\n            qml.RX(params[0], wires=0)\n            qml.RY(params[1], wires=0)\n\n        coeffs = [0.2, 0.5]\n        observables = [qml.PauliX(0), qml.PauliY(0)]\n\n        H = qml.vqe.Hamiltonian(coeffs, observables)\n        a, b = 0.54, 0.123\n        params = torch.autograd.Variable(torch.tensor([a, b]), requires_grad=True)\n\n        cost = qml.VQECost(ansatz, H, dev, interface=""torch"")\n        loss = cost(params)\n        loss.backward()\n\n        res = params.grad.numpy()\n\n        expected = [\n            -coeffs[0]*np.sin(a)*np.sin(b) - coeffs[1]*np.cos(a),\n            coeffs[0]*np.cos(a)*np.cos(b)\n        ]\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\n\n@pytest.mark.usefixtures(""skip_if_no_tf_support"")\nclass TestTFInterface:\n    """"""Tests for the TF interface""""""\n\n    @pytest.mark.parametrize(""ansatz, params"", CIRCUITS)\n    @pytest.mark.parametrize(""observables"", OBSERVABLES)\n    def test_QNodes_have_right_interface(self, ansatz, observables, params, mock_device):\n        """"""Test that QNodes have the tf interface""""""\n        if ansatz == amp_embed_and_strong_ent_layer:\n            pytest.skip(""TF doesn\'t work with ragged arrays"")\n\n        mock_device.num_wires = 3\n        circuits = qml.map(ansatz, observables, device=mock_device, interface=""tf"")\n        assert all(c.interface == ""tf"" for c in circuits)\n\n        res = [c(params) for c in circuits]\n        assert all(isinstance(val, (Variable, tf.Tensor)) for val in res)\n\n    def test_gradient(self, tol):\n        """"""Test differentiation works""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def ansatz(params, **kwargs):\n            qml.RX(params[0], wires=0)\n            qml.RY(params[1], wires=0)\n\n        coeffs = [0.2, 0.5]\n        observables = [qml.PauliX(0), qml.PauliY(0)]\n\n        H = qml.vqe.Hamiltonian(coeffs, observables)\n        a, b = 0.54, 0.123\n        params = Variable([a, b], dtype=tf.float64)\n        cost = qml.VQECost(ansatz, H, dev, interface=""tf"")\n\n        with tf.GradientTape() as tape:\n            loss = cost(params)\n            res = np.array(tape.gradient(loss, params))\n\n        expected = [\n            -coeffs[0]*np.sin(a)*np.sin(b) - coeffs[1]*np.cos(a),\n            coeffs[0]*np.cos(a)*np.cos(b)\n        ]\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\n@pytest.mark.usefixtures(""skip_if_no_tf_support"")\n@pytest.mark.usefixtures(""skip_if_no_torch_support"")\nclass TestMultipleInterfaceIntegration:\n    """"""Tests to ensure that interfaces agree and integrate correctly""""""\n\n    def test_all_interfaces_gradient_agree(self, tol):\n        """"""Test the gradient agrees across all interfaces""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        coeffs = [0.2, 0.5]\n        observables = [qml.PauliX(0)@qml.PauliZ(1), qml.PauliY(0)]\n\n        H = qml.vqe.Hamiltonian(coeffs, observables)\n\n        # TensorFlow interface\n        params = Variable(qml.init.strong_ent_layers_normal(n_layers=3, n_wires=2, seed=1))\n        ansatz = qml.templates.layers.StronglyEntanglingLayers\n\n        cost = qml.VQECost(ansatz, H, dev, interface=""tf"")\n\n        with tf.GradientTape() as tape:\n            loss = cost(params)\n            res_tf = np.array(tape.gradient(loss, params))\n\n        # Torch interface\n        params = torch.tensor(qml.init.strong_ent_layers_normal(n_layers=3, n_wires=2, seed=1))\n        params = torch.autograd.Variable(params, requires_grad=True)\n        ansatz = qml.templates.layers.StronglyEntanglingLayers\n\n        cost = qml.VQECost(ansatz, H, dev, interface=""torch"")\n        loss = cost(params)\n        loss.backward()\n        res_torch = params.grad.numpy()\n\n        # NumPy interface\n        params = qml.init.strong_ent_layers_normal(n_layers=3, n_wires=2, seed=1)\n        ansatz = qml.templates.layers.StronglyEntanglingLayers\n        cost = qml.VQECost(ansatz, H, dev, interface=""numpy"")\n        dcost = qml.grad(cost, argnum=[0])\n        res = dcost(params)\n\n        assert np.allclose(res, res_tf, atol=tol, rtol=0)\n        assert np.allclose(res, res_torch, atol=tol, rtol=0)\n'"
tests/test_wires.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for :mod:`pennylane.wires`.\n""""""\nimport pytest\nimport numpy as np\nimport pennylane as qml\nfrom pennylane.wires import Wires, WireError\n\n\nclass TestWires:\n    """"""Tests for the ``Wires`` class.""""""\n\n    @pytest.mark.parametrize(""iterable"", [np.array([0, 1, 2]),\n                                          [0, 1, 2],\n                                          (0, 1, 2),\n                                          range(3)\n                                          ])\n    def test_creation_from_common_iterables(self, iterable):\n        """"""Tests that a Wires object can be created from standard iterable inputs.""""""\n\n        wires = Wires(iterable)\n        assert wires.wire_tuple == (0, 1, 2)\n\n    @pytest.mark.parametrize(""iterable"", [Wires([0, 1, 2])])\n    def test_creation_from_wires_object(self, iterable):\n        """"""Tests that a Wires object can be created from another Wires object.""""""\n\n        wires = Wires(iterable)\n        assert wires.wire_tuple == (0, 1, 2)\n\n    @pytest.mark.parametrize(""iterable"", [[Wires([0, 1]), Wires([2])],\n                                          [Wires([0]), Wires([1]), Wires([2])]])\n    def test_creation_from_wires_object(self, iterable):\n        """"""Tests that a Wires object can be created from a list of Wires.""""""\n\n        wires = Wires(iterable)\n        assert wires.wire_tuple == (0, 1, 2)\n\n    @pytest.mark.parametrize(""iterable"", [[1, 0, 4],\n                                          [\'a\', \'b\', \'c\'],\n                                          [\'a\', 1, ""ancilla""]])\n    def test_creation_from_different_wire_types(self, iterable):\n        """"""Tests that a Wires object can be created from iterables of different\n        objects representing a single wire index.""""""\n\n        wires = Wires(iterable)\n        assert wires.wire_tuple == tuple(iterable)\n\n    @pytest.mark.parametrize(""wire"", [1, \'a\', -1.4])\n    def test_creation_from_single_object(self, wire):\n        """"""Tests that a Wires object can be created from a non-iterable object\n        representing a single wire index.""""""\n\n        wires = Wires(wire)\n        assert wires.wire_tuple == (wire,)\n\n    @pytest.mark.parametrize(""iterable"", [[0, 1, None],\n                                          [qml.RX],\n                                          None,\n                                          qml.RX])\n    def test_error_for_incorrect_wire_types(self, iterable):\n        """"""Tests that a Wires object cannot be created from wire types that are not allowed.""""""\n\n        with pytest.raises(WireError, match=""Wires must be represented""):\n            Wires(iterable)\n            \n    @pytest.mark.parametrize(""iterable"", [np.array([4, 1, 1, 3]),\n                                          [4, 1, 1, 3],\n                                          (4, 1, 1, 3),\n                                          [\'a\', \'a\', \'b\'],\n                                          [Wires([1, 0]), Wires([1, 2]), Wires([3])]])\n    def test_error_for_repeated_wires(self, iterable):\n        """"""Tests that a Wires object cannot be created from iterables with repeated indices.""""""\n\n        with pytest.raises(WireError, match=""Wires must be unique""):\n            Wires(iterable)\n\n    @pytest.mark.parametrize(""iterable"", [[4, 1, 0, 3],\n                                          [\'a\', \'b\', \'c\']])\n    def test_indexing_and_slicing(self, iterable):\n        """"""Tests the indexing and slicing of Wires objects.""""""\n\n        wires = Wires(iterable)\n\n        # check single index\n        for i in range(len(iterable)):\n            assert wires[i] == Wires(iterable[i])\n        # check slicing\n        assert wires[:2] == Wires(iterable[:2])\n\n    def test_equality(self):\n        """"""Tests that we can compare Wires objects with the \'==\' and \'!=\' operators.""""""\n\n        wires1 = Wires([1, 2, 3])\n        wires2 = Wires([3, 2, 1])\n        wires3 = Wires([1, 2, 3])\n        assert wires1 != wires2\n        assert wires1 == wires3\n\n    @pytest.mark.parametrize(""iterable"", [[4, 1, 0, 3],\n                                          [\'a\', \'b\', \'c\']])\n    def test_length(self, iterable):\n        """"""Tests that a Wires object returns the correct length.""""""\n\n        wires = Wires(iterable)\n        assert len(wires) == len(iterable)\n\n    def test_contains(self, ):\n        """"""Tests the __contains__() method.""""""\n\n        wires = Wires([0, 1, 2, 3])\n\n        assert Wires([0, 3]) in wires\n        assert Wires([1]) in wires\n        assert not Wires([0, 4]) in wires\n        assert not Wires([4]) in wires\n\n        assert [0, 3] in wires\n        assert [1] in wires\n        assert not [0, 4] in wires\n        assert not [4] in wires\n\n        assert (0, 3) in wires\n\n    def test_representation(self):\n        """"""Tests the string representation.""""""\n\n        wires_str = str(Wires([1, 2, 3]))\n        assert wires_str == ""<Wires = [1, 2, 3]>""\n\n    def test_set_of_wires(self):\n        """"""Tests that a set() of wires is formed correctly.""""""\n\n        wires = Wires([0, 1, 2])\n        list_of_wires = [Wires([1]), Wires([1]), Wires([1, 2, 3]), Wires([4])]\n\n        assert set(wires) == {Wires([0]), Wires([1]), Wires([2])}\n        assert set(list_of_wires) == {Wires([1]), Wires([1, 2, 3]), Wires([4])}\n\n    def test_convert_to_numpy_array(self):\n        """"""Tests that Wires object can be converted to a numpy array.""""""\n\n        wires = Wires([4, 0, 1])\n        array = wires.toarray()\n        assert isinstance(array, np.ndarray)\n        assert array.shape == (3,)\n        for w1, w2 in zip(array, np.array([4, 0, 1])):\n            assert w1 == w2\n\n    def test_convert_to_list(self):\n        """"""Tests that Wires object can be converted to a list.""""""\n\n        wires = Wires([4, 0, 1])\n        list_ = wires.tolist()\n        assert isinstance(list_, list)\n        assert list_ == [4, 0, 1]\n\n    @pytest.mark.parametrize(""iterable"", [[4, 1, 0, 3],\n                                          [\'a\', \'b\', \'c\']])\n    def test_index_method(self, iterable):\n        """"""Tests the ``index()`` method.""""""\n\n        wires = Wires(iterable)\n        element = iterable[1]\n        # check for non-Wires inputs\n        assert wires.index(element) == 1\n        # check for Wires inputs\n        assert wires.index(Wires([element])) == 1\n        # check that Wires of length >1 produce an error\n        with pytest.raises(WireError, match=""Can only retrieve index""):\n            wires.index(Wires([1, 2]))\n\n    def test_indices_method(self):\n        """"""Tests the ``indices()`` method.""""""\n\n        wires = Wires([4, 0, 1])\n        # for Wires inputs\n        assert wires.indices(Wires([1, 4])) == [2, 0]\n        # for non-Wires inputs\n        assert wires.indices([1, 4]) == [2, 0]\n\n    def test_select_random_method(self):\n        """"""Tests the ``select_random()`` method.""""""\n\n        wires = Wires([4, 0, 1, 5, 6])\n\n        assert len(wires.select_random(2)) == 2\n        # check that seed makes call deterministic\n        assert wires.select_random(4, seed=1) == wires.select_random(4, seed=1)\n\n        with pytest.raises(WireError, match=""Cannot sample""):\n            wires.select_random(6)\n\n    def test_subset_method(self):\n        """"""Tests the ``subset()`` method.""""""\n\n        wires = Wires([4, 0, 1, 5, 6])\n\n        assert wires.subset([2, 3, 0]) == Wires([1, 5, 4])\n        assert wires.subset(1) == Wires([0])\n        assert wires.subset([4, 5, 7], periodic_boundary=True) == Wires([6, 4, 1])\n        # if index does not exist\n        with pytest.raises(WireError, match=""Cannot subset wire at index""):\n            wires.subset([10])\n\n    def test_all_wires_method(self):\n        """"""Tests the ``all_wires()`` method.""""""\n\n        wires1 = Wires([1, 2, 3])\n        wires2 = Wires([1, 4, 5, 2])\n        wires3 = Wires([6, 5])\n\n        new_wires = Wires.all_wires([wires1, wires2, wires3])\n        assert new_wires.wire_tuple == (1, 2, 3, 4, 5, 6)\n\n        with pytest.raises(WireError, match=""Expected a Wires object""):\n            Wires.all_wires([[3, 4], [8, 5]])\n\n    def test_shared_wires_method(self):\n        """"""Tests the ``shared_wires()`` method.""""""\n\n        wires1 = Wires([4, 0, 1])\n        wires2 = Wires([3, 0, 4])\n        wires3 = Wires([4, 0])\n        res = Wires.shared_wires([wires1, wires2, wires3])\n        assert res == Wires([4, 0])\n\n        res = Wires.shared_wires([wires2, wires1, wires3])\n        assert res == Wires([0, 4])\n\n        with pytest.raises(WireError, match=""Expected a Wires object""):\n            Wires.shared_wires([[3, 4], [8, 5]])\n\n    def test_unique_wires_method(self):\n        """"""Tests the ``unique_wires()`` method.""""""\n\n        wires1 = Wires([4, 0, 1])\n        wires2 = Wires([3, 0, 4])\n        wires3 = Wires([4, 0])\n        res = Wires.unique_wires([wires1, wires2, wires3])\n        assert res == Wires([1, 3])\n\n        res = Wires.unique_wires([wires2, wires1, wires3])\n        assert res == Wires([3, 1])\n\n        with pytest.raises(WireError, match=""Expected a Wires object""):\n            Wires.unique_wires([[2, 1], [8, 5]])\n'"
doc/_ext/edit_on_github.py,0,"b'""""""\nSphinx extension to add ReadTheDocs-style ""Edit on GitHub"" links to the\nsidebar.\nLoosely based on https://github.com/astropy/astropy/pull/347\n""""""\n\nimport os\nimport warnings\n\n\n__licence__ = \'BSD (3 clause)\'\n\n\ndef get_github_url(app, view, path):\n    return \'https://github.com/{project}/{view}/{branch}/{path}\'.format(\n        project=app.config.edit_on_github_project,\n        view=view,\n        branch=app.config.edit_on_github_branch,\n        path=path)\n\n\ndef html_page_context(app, pagename, templatename, context, doctree):\n    if templatename != \'page.html\':\n        return\n\n    if not app.config.edit_on_github_project:\n        warnings.warn(""edit_on_github_project not specified"")\n        return\n\n    if not doctree:\n        return\n    \n    path = os.path.relpath(doctree.get(\'source\'), app.builder.srcdir)\n    show_url = get_github_url(app, \'blob\', path)\n    edit_url = get_github_url(app, \'edit\', path)\n\n    context[\'show_on_github_url\'] = show_url\n    context[\'edit_on_github_url\'] = edit_url\n\n\ndef setup(app):\n    app.add_config_value(\'edit_on_github_project\', \'\', True)\n    app.add_config_value(\'edit_on_github_branch\', \'master\', True)\n    app.connect(\'html-page-context\', html_page_context)'"
pennylane/beta/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains experimental, contributed, and beta code.\n""""""\n'"
pennylane/circuit_drawer/__init__.py,0,"b'# Copyright 2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis subpackage provides the circuit drawing functionality used to render QNodes\nas circuit diagrams.\n\n.. currentmodule:: pennylane.circuit_drawer\n.. autosummary::\n    :toctree: api\n\n    circuit_drawer\n    charsets\n""""""\nfrom .circuit_drawer import *\nfrom .charsets import *\n'"
pennylane/circuit_drawer/charsets.py,0,"b'# Copyright 2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the different character set classes supported by PennyLane\'s CircuitDrawer.\n""""""\nimport abc\n\n\nclass CharSet(abc.ABC):\n    """"""Charset base class.""""""\n\n    # pylint: disable=too-few-public-methods\n\n    @property\n    @abc.abstractmethod\n    def WIRE(self):\n        """"""The string used to represent a wire.""""""\n\n    @property\n    @abc.abstractmethod\n    def MEASUREMENT(self):\n        """"""The string used to represent a measurement at the end of a circuit.""""""\n\n    @property\n    @abc.abstractmethod\n    def TOP_MULTI_LINE_GATE_CONNECTOR(self):\n        """"""The string used to connect to the topmost wire of a multi-wire gate.""""""\n\n    @property\n    @abc.abstractmethod\n    def MIDDLE_MULTI_LINE_GATE_CONNECTOR(self):\n        """"""The string used to connect to the a wire of a multi-wire gate that is neither topmost nor bottommost.""""""\n\n    @property\n    @abc.abstractmethod\n    def BOTTOM_MULTI_LINE_GATE_CONNECTOR(self):\n        """"""The string used to connect to the bottommost wire of a multi-wire gate.""""""\n\n    @property\n    @abc.abstractmethod\n    def EMPTY_MULTI_LINE_GATE_CONNECTOR(self):\n        """"""The string used to symbolize unaffected wires when connecting multi-wire gates.""""""\n\n    @property\n    @abc.abstractmethod\n    def CONTROL(self):\n        """"""The string used to represent the controlling wires of an operation.""""""\n\n    @property\n    @abc.abstractmethod\n    def LANGLE(self):\n        """"""The string used to represent a left angle bracket.""""""\n\n    @property\n    @abc.abstractmethod\n    def RANGLE(self):\n        """"""The string used to represent a right angle bracket.""""""\n\n    @property\n    @abc.abstractmethod\n    def VERTICAL_LINE(self):\n        """"""The string used to represent a vertical line.""""""\n\n    @property\n    @abc.abstractmethod\n    def CROSSED_LINES(self):\n        """"""The string used to represent crossed lines.""""""\n\n    @property\n    @abc.abstractmethod\n    def PIPE(self):\n        """"""The string used to represent a vertical line of text height.""""""\n\n    @property\n    @abc.abstractmethod\n    def OTIMES(self):\n        """"""The string used to represent a tensor product operation.""""""\n\n    @staticmethod\n    @abc.abstractmethod\n    def to_superscript(num):\n        """"""Convert the given number to a superscripted string.""""""\n\n    @staticmethod\n    @abc.abstractmethod\n    def to_subscript(num):\n        """"""Convert the given number to a subscripted string.""""""\n\n\nclass UnicodeCharSet(CharSet):\n    """"""Charset for CircuitDrawing made of Unicode characters.""""""\n\n    # pylint: disable=too-few-public-methods\n\n    WIRE = ""\xe2\x94\x80""\n    MEASUREMENT = ""\xe2\x94\xa4""\n    TOP_MULTI_LINE_GATE_CONNECTOR = ""\xe2\x95\xad""\n    MIDDLE_MULTI_LINE_GATE_CONNECTOR = ""\xe2\x94\x9c""\n    BOTTOM_MULTI_LINE_GATE_CONNECTOR = ""\xe2\x95\xb0""\n    EMPTY_MULTI_LINE_GATE_CONNECTOR = ""\xe2\x94\x82""\n    CONTROL = ""C""\n    LANGLE = ""\xe2\x9f\xa8""\n    RANGLE = ""\xe2\x9f\xa9""\n    VERTICAL_LINE = ""\xe2\x94\x82""\n    CROSSED_LINES = ""\xe2\x95\xb3""\n    PIPE = ""|""\n    OTIMES = ""\xe2\x8a\x97""\n\n    _superscript_dict = {\n        ""0"": ""\xe2\x81\xb0"",\n        ""1"": ""\xc2\xb9"",\n        ""2"": ""\xc2\xb2"",\n        ""3"": ""\xc2\xb3"",\n        ""4"": ""\xe2\x81\xb4"",\n        ""5"": ""\xe2\x81\xb5"",\n        ""6"": ""\xe2\x81\xb6"",\n        ""7"": ""\xe2\x81\xb7"",\n        ""8"": ""\xe2\x81\xb8"",\n        ""9"": ""\xe2\x81\xb9"",\n        ""-"": ""\xe2\x81\xbb"",\n    }\n\n    _subscript_dict = {\n        ""0"": ""\xe2\x82\x80"",\n        ""1"": ""\xe2\x82\x81"",\n        ""2"": ""\xe2\x82\x82"",\n        ""3"": ""\xe2\x82\x83"",\n        ""4"": ""\xe2\x82\x85"",\n        ""5"": ""\xe2\x81\xb5"",\n        ""6"": ""\xe2\x82\x86"",\n        ""7"": ""\xe2\x82\x87"",\n        ""8"": ""\xe2\x82\x88"",\n        ""9"": ""\xe2\x82\x89"",\n        ""-"": ""\xe2\x82\x8b"",\n    }\n\n    @staticmethod\n    def to_superscript(num):\n        """"""Convert the given number to a superscripted string.""""""\n        ret = str(num)\n        for old, new in UnicodeCharSet._superscript_dict.items():\n            ret = ret.replace(old, new)\n\n        return ret\n\n    @staticmethod\n    def to_subscript(num):\n        """"""Convert the given number to a subscripted string.""""""\n        ret = str(num)\n        for old, new in UnicodeCharSet._subscript_dict.items():\n            ret = ret.replace(old, new)\n\n        return ret\n\n\nclass AsciiCharSet(CharSet):\n    """"""Charset for CircuitDrawing made of ASCII characters.""""""\n\n    # pylint: disable=too-few-public-methods\n\n    WIRE = ""-""\n    MEASUREMENT = ""|""\n    TOP_MULTI_LINE_GATE_CONNECTOR = ""+""\n    MIDDLE_MULTI_LINE_GATE_CONNECTOR = ""+""\n    BOTTOM_MULTI_LINE_GATE_CONNECTOR = ""+""\n    EMPTY_MULTI_LINE_GATE_CONNECTOR = ""|""\n    CONTROL = ""C""\n    LANGLE = ""<""\n    RANGLE = "">""\n    VERTICAL_LINE = ""|""\n    CROSSED_LINES = ""X""\n    PIPE = ""|""\n    OTIMES = ""@""\n\n    @staticmethod\n    def to_superscript(num):\n        """"""Convert the given number to a superscripted string.""""""\n        return ""^"" + str(num)\n\n    @staticmethod\n    def to_subscript(num):\n        """"""Convert the given number to a subscripted string.""""""\n        return ""_"" + str(num)\n\n\nCHARSETS = {""unicode"": UnicodeCharSet, ""ascii"": AsciiCharSet}\n""""""Dict[str, CharSet]: Dictionary mapping character sets to all available :class:`~.CharSet` classes.""""""\n'"
pennylane/circuit_drawer/circuit_drawer.py,0,"b'# Copyright 2019-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the CircuitDrawer class which is used to draw CircuitGraph instances.\n""""""\nfrom collections import OrderedDict, Iterable\n\nimport pennylane as qml\n\nfrom .charsets import UnicodeCharSet\nfrom .representation_resolver import RepresentationResolver\nfrom .grid import Grid\n\n# pylint: disable=too-many-branches,too-many-arguments,too-many-return-statements,too-many-statements,consider-using-enumerate,too-many-instance-attributes\n\n\ndef _remove_duplicates(input_list):\n    """"""Remove duplicate entries from a list.\n\n    This operation preserves the order of the list\'s elements.\n\n    Args:\n        input_list (list[Hashable]): The list whose duplicate entries shall be removed\n\n    Returns:\n        list[Hashable]: The input list without duplicate entries\n    """"""\n    return list(OrderedDict.fromkeys(input_list))\n\n\nclass CircuitDrawer:\n    """"""Creates a circuit diagram from the operators of a CircuitGraph in grid form.\n\n    Args:\n        raw_operation_grid (list[list[~.Operation]]): The CircuitGraph\'s operations\n        raw_observable_grid (list[list[qml.operation.Observable]]): The CircuitGraph\'s observables\n        charset (pennylane.circuit_drawer.CharSet, optional): The CharSet that shall be used for drawing.\n        show_variable_names (bool, optional): Show variable names instead of variable values.\n    """"""\n\n    def __init__(\n        self,\n        raw_operation_grid,\n        raw_observable_grid,\n        charset=UnicodeCharSet,\n        show_variable_names=False,\n    ):\n        self.operation_grid = Grid(raw_operation_grid)\n        self.observable_grid = Grid(raw_observable_grid)\n        self.charset = charset\n        self.show_variable_names = show_variable_names\n\n        self.make_wire_conversion_dicts(raw_operation_grid, raw_observable_grid)\n        self.representation_resolver = RepresentationResolver(charset, show_variable_names)\n        self.operation_representation_grid = Grid()\n        self.observable_representation_grid = Grid()\n        self.operation_decoration_indices = []\n        self.observable_decoration_indices = []\n\n        CircuitDrawer.move_multi_wire_gates(self.operation_grid)\n\n        # Resolve operator names\n        self.resolve_representation(self.operation_grid, self.operation_representation_grid)\n        self.resolve_representation(self.observable_grid, self.observable_representation_grid)\n\n        # Add multi-wire gate lines\n        self.operation_decoration_indices = self.resolve_decorations(\n            self.operation_grid, self.operation_representation_grid\n        )\n        self.observable_decoration_indices = self.resolve_decorations(\n            self.observable_grid, self.observable_representation_grid\n        )\n\n        CircuitDrawer.pad_representation(\n            self.operation_representation_grid,\n            charset.WIRE,\n            """",\n            2 * charset.WIRE,\n            self.operation_decoration_indices,\n        )\n\n        CircuitDrawer.pad_representation(\n            self.operation_representation_grid,\n            charset.WIRE,\n            """",\n            """",\n            set(range(self.operation_grid.num_layers)) - set(self.operation_decoration_indices),\n        )\n\n        CircuitDrawer.pad_representation(\n            self.observable_representation_grid,\n            "" "",\n            charset.MEASUREMENT + "" "",\n            "" "",\n            self.observable_decoration_indices,\n        )\n\n        CircuitDrawer.pad_representation(\n            self.observable_representation_grid,\n            charset.WIRE,\n            """",\n            """",\n            set(range(self.observable_grid.num_layers)) - set(self.observable_decoration_indices),\n        )\n\n        self.full_representation_grid = self.operation_representation_grid.copy()\n        self.full_representation_grid.append_grid_by_layers(self.observable_representation_grid)\n\n    def make_wire_conversion_dicts(self, raw_operation_grid, raw_observable_grid):\n        """"""Prepare the dictionaries used to convert between internal and device wires.\n\n        This conversion is necessary due to the fact that the circuit drawer internally uses\n        ascending wires that have to be matched to the actual wires of the Operations inside\n        the circuit.\n\n        Args:\n            raw_operation_grid (Iterable[~.Operator]): The raw grid of operations\n            raw_observable_grid (Iterable[~.Operator]): The raw  grid of observables\n        """"""\n        # pylint: disable=protected-access\n        all_operators = list(qml.utils._flatten(raw_operation_grid)) + list(\n            qml.utils._flatten(raw_observable_grid)\n        )\n        all_wires = [op.wires.tolist() for op in all_operators if op is not None]\n        circuit_wires = sorted(set(qml.utils._flatten(all_wires)))\n        internal_wires = list(range(len(circuit_wires)))\n\n        self._cicuit_wire_to_internal_wire = dict(zip(circuit_wires, internal_wires))\n        self._internal_wire_to_circuit_wire = dict(zip(internal_wires, circuit_wires))\n\n    def circuit_wires_to_internal_wires(self, wires):\n        """"""Convert one or multiple device wires to internal wires.\n\n        Args:\n            wires (Union[Iterable[int],int]): One or multiple device wires\n\n        Returns:\n            Union[Iterable[int],int]: The corresponding internal wires\n        """"""\n        if isinstance(wires, Iterable):\n            return [self._cicuit_wire_to_internal_wire[wire] for wire in wires]\n\n        return self._cicuit_wire_to_internal_wire[wires]\n\n    def internal_wires_to_circuit_wires(self, wires):\n        """"""Convert one or multiple internal wires to device wires.\n\n        Args:\n            wires (Union[Iterable[int],int]): One or multiple internal wires\n\n        Returns:\n            Union[Iterable[int],int]: The corresponding device wires\n        """"""\n        if isinstance(wires, Iterable):\n            return [self._internal_wire_to_circuit_wire[wire] for wire in wires]\n\n        return self._internal_wire_to_circuit_wire[wires]\n\n    def resolve_representation(self, grid, representation_grid):\n        """"""Resolve the string representation of the given Grid.\n\n        Args:\n            grid (pennylane.circuit_drawer.Grid): Grid that holds the circuit information\n            representation_grid (pennylane.circuit_drawer.Grid): Grid that is used to store the string representations\n        """"""\n        for i in range(grid.num_layers):\n            representation_layer = [""""] * grid.num_wires\n\n            for wire, operator in enumerate(grid.layer(i)):\n                representation_layer[wire] = self.representation_resolver.element_representation(\n                    operator, self.internal_wires_to_circuit_wires(wire)\n                )\n\n            representation_grid.append_layer(representation_layer)\n\n    def add_multi_wire_connectors_to_layer(self, internal_wires, decoration_layer):\n        """"""Add multi wire connectors for the given wires to a layer.\n\n        Args:\n            internal_wires (list[int]): The internal wires that are to be connected\n            decoration_layer (list[str]): The decoration layer to which the wires will be added\n        """"""\n        min_wire = min(internal_wires)\n        max_wire = max(internal_wires)\n\n        decoration_layer[min_wire] = self.charset.TOP_MULTI_LINE_GATE_CONNECTOR\n\n        for k in range(min_wire + 1, max_wire):\n            if k in internal_wires:\n                decoration_layer[k] = self.charset.MIDDLE_MULTI_LINE_GATE_CONNECTOR\n            else:\n                decoration_layer[k] = self.charset.EMPTY_MULTI_LINE_GATE_CONNECTOR\n\n        decoration_layer[max_wire] = self.charset.BOTTOM_MULTI_LINE_GATE_CONNECTOR\n\n    def resolve_decorations(self, grid, representation_grid):\n        """"""Resolve the decorations of the given Grid.\n\n        If decorations are in conflict, they are automatically spread over multiple layers.\n\n        Args:\n            grid (pennylane.circuit_drawer.Grid): Grid that holds the circuit information\n            representation_grid (pennylane.circuit_drawer.Grid): Grid that holds the string representations and into\n                which the decorations will be inserted\n\n        Returns:\n            list[int]: List with indices of inserted decoration layers\n        """"""\n        j = 0\n        inserted_indices = []\n\n        for i in range(grid.num_layers):\n            layer_operators = _remove_duplicates(grid.layer(i))\n\n            decoration_layer = [""""] * grid.num_wires\n\n            for op in layer_operators:\n                if op is None:\n                    continue\n\n                wires = op.wires.tolist()\n\n                if len(wires) > 1:\n                    internal_wires = self.circuit_wires_to_internal_wires(wires)\n                    min_wire = min(internal_wires)\n                    max_wire = max(internal_wires)\n\n                    # If there is a conflict between decorations, we start a new decoration_layer\n                    if any(\n                        [decoration_layer[wire] != """" for wire in range(min_wire, max_wire + 1)]\n                    ):\n                        representation_grid.insert_layer(i + j, decoration_layer)\n                        inserted_indices.append(i + j)\n                        j += 1\n\n                        decoration_layer = [""""] * grid.num_wires\n\n                    self.add_multi_wire_connectors_to_layer(internal_wires, decoration_layer)\n\n            representation_grid.insert_layer(i + j, decoration_layer)\n            inserted_indices.append(i + j)\n            j += 1\n\n        return inserted_indices\n\n    @staticmethod\n    def pad_representation(representation_grid, pad_str, prepend_str, suffix_str, skip_indices):\n        """"""Pads the given representation so that width inside layers is constant.\n\n        Args:\n            representation_grid (pennylane.circuit_drawer.Grid): Grid that holds the string representations that will be padded\n            pad_str (str): String that shall be used for padding\n            prepend_str (str): String that is prepended to all representations that are not skipped\n            suffix_str (str): String that is appended to all representations\n            skip_indices (list[int]): Indices of layers that should be skipped\n        """"""\n        for i in range(representation_grid.num_layers):\n            layer = representation_grid.layer(i)\n            max_width = max(map(len, layer))\n\n            if i in skip_indices:\n                continue\n\n            # Take the current layer and pad it with the pad_str\n            # and also prepend with prepend_str and append the suffix_str\n            # pylint: disable=cell-var-from-loop\n            representation_grid.replace_layer(\n                i,\n                list(\n                    map(\n                        lambda x: prepend_str + str.ljust(x, max_width, pad_str) + suffix_str, layer\n                    )\n                ),\n            )\n\n    @staticmethod\n    def move_multi_wire_gates(operator_grid):\n        """"""Move multi-wire gates so that there are no interlocking multi-wire gates in the same layer.\n\n        Args:\n            operator_grid (pennylane.circuit_drawer.Grid): Grid that holds the circuit information and that will be edited.\n        """"""\n        n = operator_grid.num_layers\n        i = -1\n        while i < n - 1:\n            i += 1\n\n            this_layer = operator_grid.layer(i)\n            layer_ops = _remove_duplicates(this_layer)\n            other_layer = [None] * operator_grid.num_wires\n\n            for j in range(len(layer_ops)):\n                op = layer_ops[j]\n\n                if op is None:\n                    continue\n\n                if len(op.wires) > 1:\n                    sorted_wires = op.wires.tolist().copy()\n                    sorted_wires.sort()\n\n                    blocked_wires = list(range(sorted_wires[0], sorted_wires[-1] + 1))\n\n                    for k in range(j + 1, len(layer_ops)):\n                        other_op = layer_ops[k]\n\n                        if other_op is None:\n                            continue\n\n                        other_sorted_wires = other_op.wires.tolist().copy()\n                        other_sorted_wires.sort()\n                        other_blocked_wires = list(\n                            range(other_sorted_wires[0], other_sorted_wires[-1] + 1)\n                        )\n\n                        if not set(other_blocked_wires).isdisjoint(set(blocked_wires)):\n                            op_indices = [\n                                idx for idx, layer_op in enumerate(this_layer) if layer_op == op\n                            ]\n\n                            for l in op_indices:\n                                other_layer[l] = op\n                                this_layer[l] = None\n\n                            break\n\n            if not all([item is None for item in other_layer]):\n                operator_grid.insert_layer(i + 1, other_layer)\n                n += 1\n\n    def draw(self):\n        """"""Draw the circuit diagram.\n\n        Returns:\n            str: The circuit diagram\n        """"""\n        rendered_string = """"\n\n        for i in range(self.full_representation_grid.num_wires):\n            wire = self.full_representation_grid.wire(i)\n\n            rendered_string += ""{:2d}: {}"".format(\n                self.internal_wires_to_circuit_wires(i), 2 * self.charset.WIRE\n            )\n\n            for s in wire:\n                rendered_string += s\n\n            rendered_string += ""\\n""\n\n        for symbol, cache in [\n            (""U"", self.representation_resolver.unitary_matrix_cache),\n            (""H"", self.representation_resolver.hermitian_matrix_cache),\n            (""M"", self.representation_resolver.matrix_cache),\n        ]:\n            for idx, matrix in enumerate(cache):\n                rendered_string += ""{}{} =\\n{}\\n"".format(symbol, idx, matrix)\n\n        return rendered_string\n'"
pennylane/circuit_drawer/grid.py,0,"b'# Copyright 2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the Grid class which emulates a 2D array.\n""""""\nimport numpy as np\n\n\ndef _transpose(target_list):\n    """"""Transpose the given list of lists.\n\n    Args:\n        target_list (list[list[object]]): List of list that will be transposed\n\n    Returns:\n        list[list[object]]: Transposed list of lists\n    """"""\n    return list(map(list, zip(*target_list)))\n\n\nclass Grid:\n    """"""Helper class to manage Gates aligned in a grid.\n\n    The rows of the Grid are referred to as ""wires"",\n    whereas the columns of the Grid are reffered to as ""layers"".\n\n    Args:\n        raw_grid (list, optional): Raw grid from which the Grid instance is built.\n    """"""\n\n    def __init__(self, raw_grid=None):\n        if raw_grid is None:\n            # Let initialization pend until first data is entered\n            self.raw_grid = None\n        else:\n            self.raw_grid = np.array(raw_grid, dtype=object)\n\n    def insert_layer(self, idx, layer):\n        """"""Insert a layer into the Grid at the specified index.\n\n        If the Grid is empty, the index is ignored and the layer inserted.\n\n        Args:\n            idx (int): Index at which to insert the new layer\n            layer (list): Layer that will be inserted\n        """"""\n        if self.raw_grid is not None:\n            self.raw_grid = np.insert(self.raw_grid, idx, np.array([layer], dtype=object), axis=1)\n        else:\n            self.raw_grid = np.array([layer], dtype=object).T\n\n        return self\n\n    def append_layer(self, layer):\n        """"""Append a layer to the Grid.\n\n        Args:\n            layer (list): Layer that will be appended\n        """"""\n        if self.raw_grid is not None:\n            self.raw_grid = np.append(self.raw_grid, np.array([layer], dtype=object).T, axis=1)\n        else:\n            self.raw_grid = np.array([layer], dtype=object).T\n\n        return self\n\n    def replace_layer(self, idx, layer):\n        """"""Replace a layer in the Grid at the specified index.\n\n        Args:\n            idx (int): Index of the layer to be replaced\n            layer (list): Layer that replaces the old layer\n        """"""\n        if self.raw_grid is not None:\n            self.raw_grid[:, idx] = np.array(layer, dtype=object)\n        else:\n            raise AttributeError(""Can\'t replace layer. The Grid has not yet been initialized."")\n\n        return self\n\n    def insert_wire(self, idx, wire):\n        """"""Insert a wire into the Grid at the specified index.\n\n        If the Grid is empty, the index is ignored and the wire inserted.\n\n        Args:\n            idx (int): Index at which to insert the new wire\n            wire (list): Wire that will be inserted\n        """"""\n        if self.raw_grid is not None:\n            self.raw_grid = np.insert(self.raw_grid, idx, np.array([wire], dtype=object), axis=0)\n        else:\n            self.raw_grid = np.array([wire], dtype=object)\n\n        return self\n\n    def append_wire(self, wire):\n        """"""Append a wire to the Grid.\n\n        Args:\n            wire (list): Wire that will be appended\n        """"""\n        if self.raw_grid is not None:\n            self.raw_grid = np.append(self.raw_grid, np.array([wire], dtype=object), axis=0)\n        else:\n            self.raw_grid = np.array([wire], dtype=object)\n\n        return self\n\n    @property\n    def num_layers(self):\n        """"""Number of layers in the Grid.\n\n        Returns:\n            int: Number of layers in the Grid\n        """"""\n        if self.raw_grid is not None:\n            return self.raw_grid.shape[1]\n\n        return 0\n\n    def layer(self, idx):\n        """"""Return the layer at the specified index.\n\n        Args:\n            idx (int): Index of the layer to be retrieved\n\n        Returns:\n            list: The layer at the specified index\n        """"""\n        return self.raw_grid[:, idx]\n\n    @property\n    def num_wires(self):\n        """"""Number of wires in the Grid.\n\n        Returns:\n            int: Number of wires in the Grid\n        """"""\n        if self.raw_grid is not None:\n            return self.raw_grid.shape[0]\n\n        return 0\n\n    def wire(self, idx):\n        """"""Return the wire at the specified index.\n\n        Args:\n            idx (int): Index of the wire to be retrieved\n\n        Returns:\n            list: The wire at the specified index\n        """"""\n        return self.raw_grid[idx]\n\n    def copy(self):\n        """"""Create a copy of the Grid.\n\n        Returns:\n            Grid: A copy of the Grid\n        """"""\n        return Grid(self.raw_grid.copy())\n\n    def append_grid_by_layers(self, other_grid):\n        """"""Append the layers of another Grid to this Grid.\n\n        Args:\n            other_grid (pennylane.circuit_drawer.Grid): Grid whose layers will be appended\n        """"""\n        for i in range(other_grid.num_layers):\n            self.append_layer(other_grid.layer(i))\n\n        return self\n\n    def __str__(self):\n        """"""String representation""""""\n        ret = """"\n        for wire in self.raw_grid:\n            ret += str(wire)\n            ret += ""\\n""\n\n        return ret\n'"
pennylane/circuit_drawer/representation_resolver.py,0,"b'# Copyright 2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the RepresentationResolver class which is used to map\nOperations to their string representations.\n""""""\nimport numpy as np\nimport pennylane as qml\n\nfrom .charsets import UnicodeCharSet\n\n\nclass RepresentationResolver:\n    """"""Resolves the string representation of PennyLane objects.\n\n    Args:\n        charset (CharSet, optional): The CharSet to be used for representation resolution.\n        show_variable_names (bool, optional): Show variable names instead of variable values.\n    """"""\n\n    def __init__(self, charset=UnicodeCharSet, show_variable_names=False):\n        self.charset = charset\n        self.show_variable_names = show_variable_names\n        self.matrix_cache = []\n        self.unitary_matrix_cache = []\n        self.hermitian_matrix_cache = []\n\n    # Symbol for uncontrolled wires\n    resolution_dict = {\n        ""PauliX"": ""X"",\n        ""CNOT"": ""X"",\n        ""Toffoli"": ""X"",\n        ""CSWAP"": ""SWAP"",\n        ""PauliY"": ""Y"",\n        ""PauliZ"": ""Z"",\n        ""CZ"": ""Z"",\n        ""Identity"": ""I"",\n        ""Hadamard"": ""H"",\n        ""MultiRZ"": ""RZ"",\n        ""CRX"": ""RX"",\n        ""CRY"": ""RY"",\n        ""CRZ"": ""RZ"",\n        ""CRot"": ""Rot"",\n        ""PhaseShift"": ""R\xcf\x95"",\n        ""Beamsplitter"": ""BS"",\n        ""Squeezing"": ""S"",\n        ""TwoModeSqueezing"": ""S"",\n        ""Displacement"": ""D"",\n        ""NumberOperator"": ""n"",\n        ""Rotation"": ""R"",\n        ""ControlledAddition"": ""X"",\n        ""ControlledPhase"": ""Z"",\n        ""ThermalState"": ""Thermal"",\n        ""GaussianState"": ""Gaussian"",\n        ""QuadraticPhase"": ""P"",\n        ""CubicPhase"": ""V"",\n        ""X"": ""x"",\n        ""P"": ""p"",\n    }\n    """"""Symbol used for uncontrolled wires.""""""\n\n    control_wire_dict = {\n        ""CNOT"": [0],\n        ""Toffoli"": [0, 1],\n        ""CSWAP"": [0],\n        ""CRX"": [0],\n        ""CRY"": [0],\n        ""CRZ"": [0],\n        ""CRot"": [0],\n        ""CZ"": [0],\n        ""ControlledAddition"": [0],\n        ""ControlledPhase"": [0],\n    }\n    """"""Indices of control wires.""""""\n\n    @staticmethod\n    def index_of_array_or_append(target_element, target_list):\n        """"""Returns the first index of an appearance of the target element in the target list.\n        If the target element is not in the list it will be added to the list.\n\n        Args:\n            target_element (np.ndarray): The object whose index is to be returned\n            target_list (list[np.ndarray]): The list which shall be searched\n\n        Returns:\n            int: Index of the target element in the list.\n        """"""\n        for idx, target in enumerate(target_list):\n            if np.array_equal(target, target_element):\n                return idx\n\n        target_list.append(target_element)\n\n        return len(target_list) - 1\n\n    def single_parameter_representation(self, par):\n        """"""Resolve the representation of an Operator\'s parameter.\n\n        Args:\n            par (Union[~.variable.Variable, int, float, str]): The parameter to be rendered\n\n        Returns:\n            str: String representation of the parameter\n        """"""\n        if isinstance(par, qml.variable.Variable):\n            return par.render(self.show_variable_names)\n\n        if isinstance(par, str):\n            return par\n\n        return str(round(par, 3))\n\n    @staticmethod\n    def _format_matrix_operation(operation, symbol, cache):\n        """"""Format an operation that corresponds to a single matrix.\n\n        Args:\n            operation (~.Operation): Operation that shall be formatted\n            symbol (str): The symbol that should be used to identify matrices\n            cache (List[numpy.ndarray]): The cache of already known matrices\n\n        Returns:\n            str: The formatted operation\n        """"""\n        mat = operation.params[0]\n        idx = RepresentationResolver.index_of_array_or_append(mat, cache)\n\n        return ""{}{}"".format(symbol, idx)\n\n    @staticmethod\n    def _format_matrix_arguments(params, symbol, cache):\n        """"""Format a sequence of matrix parameters.\n\n        Args:\n            params (List[numpy.ndarray]): List of matrix parameters\n            symbol (str): The symbol that should be used to identify matrices\n            cache (List[numpy.ndarray]): The cache of already known matrices\n\n        Returns:\n            str: The formatted matrix arguments\n        """"""\n        param_strings = []\n        for param in params:\n            idx = RepresentationResolver.index_of_array_or_append(param, cache)\n\n            param_strings.append(""{}{}"".format(symbol, idx))\n\n        return ""("" + "","".join(param_strings) + "")""\n\n    @staticmethod\n    def _format_poly_term(coefficient, variable):\n        """"""Format a term in a polynomial.\n\n        Args:\n            coefficient (float): The polynomial term\'s coefficient\n            variable (str): The polynomial term\'s variable\n\n        Returns:\n            str: The formatted term\n        """"""\n        if coefficient == 0:\n            return """"\n\n        if coefficient == 1.0:\n            return str(variable)\n\n        if coefficient == -1.0:\n            return ""-"" + str(variable)\n\n        return ""{:+.3g}{}"".format(coefficient, variable)\n\n    def _format_polyxp_order1(self, coefficients):\n        """"""Format a first-order polynomial of x and p operators.\n\n        Args:\n            coefficients (array[float]): The polynomial coefficients as a vector\n\n        Returns:\n            str: A string representing the polynomial\n        """"""\n        poly_str = """"\n\n        if coefficients[0] != 0:\n            poly_str += ""{:.3g}"".format(coefficients[0])\n\n        for idx in range(0, coefficients.shape[0] // 2):\n            x = 2 * idx + 1\n            y = 2 * idx + 2\n            poly_str += RepresentationResolver._format_poly_term(\n                coefficients[x], ""x{}"".format(self.charset.to_subscript(idx))\n            )\n            poly_str += RepresentationResolver._format_poly_term(\n                coefficients[y], ""p{}"".format(self.charset.to_subscript(idx))\n            )\n\n        return poly_str\n\n    def _format_polyxp_order2(self, coefficients):\n        """"""Format a second-order polynomial of x and p operators.\n\n        Args:\n            coefficients (array[float]): The polynomial coefficients as a matrix\n\n        Returns:\n            str: A string representing the polynomial\n        """"""\n        poly_str = str(coefficients[0, 0])\n\n        for idx in range(0, coefficients.shape[0] // 2):\n            x = 2 * idx + 1\n            p = 2 * idx + 2\n            poly_str += RepresentationResolver._format_poly_term(\n                coefficients[0, x] + coefficients[x, 0],\n                ""x{}"".format(self.charset.to_subscript(idx)),\n            )\n            poly_str += RepresentationResolver._format_poly_term(\n                coefficients[0, p] + coefficients[p, 0],\n                ""p{}"".format(self.charset.to_subscript(idx)),\n            )\n\n        for idx1 in range(0, coefficients.shape[0] // 2):\n            for idx2 in range(idx1, coefficients.shape[0] // 2):\n                x1 = 2 * idx1 + 1\n                p1 = 2 * idx1 + 2\n                x2 = 2 * idx2 + 1\n                p2 = 2 * idx2 + 2\n\n                if idx1 == idx2:\n                    poly_str += RepresentationResolver._format_poly_term(\n                        coefficients[x1, x1],\n                        ""x{}{}"".format(\n                            self.charset.to_subscript(idx1), self.charset.to_superscript(2)\n                        ),\n                    )\n                    poly_str += RepresentationResolver._format_poly_term(\n                        coefficients[p1, p1],\n                        ""p{}{}"".format(\n                            self.charset.to_subscript(idx1), self.charset.to_superscript(2)\n                        ),\n                    )\n                    poly_str += RepresentationResolver._format_poly_term(\n                        coefficients[x1, p1] + coefficients[p1, x1],\n                        ""x{}p{}"".format(\n                            self.charset.to_subscript(idx1), self.charset.to_subscript(idx1)\n                        ),\n                    )\n                else:\n                    poly_str += RepresentationResolver._format_poly_term(\n                        coefficients[x1, x2] + coefficients[x2, x1],\n                        ""x{}x{}"".format(\n                            self.charset.to_subscript(idx1), self.charset.to_subscript(idx2)\n                        ),\n                    )\n\n                    poly_str += RepresentationResolver._format_poly_term(\n                        coefficients[p1, p2] + coefficients[p2, p1],\n                        ""p{}p{}"".format(\n                            self.charset.to_subscript(idx1), self.charset.to_subscript(idx2)\n                        ),\n                    )\n\n                    poly_str += RepresentationResolver._format_poly_term(\n                        coefficients[x1, p2] + coefficients[p2, x1],\n                        ""x{}p{}"".format(\n                            self.charset.to_subscript(idx1), self.charset.to_subscript(idx2)\n                        ),\n                    )\n\n                    poly_str += RepresentationResolver._format_poly_term(\n                        coefficients[p1, x2] + coefficients[x2, p1],\n                        ""x{}p{}"".format(\n                            self.charset.to_subscript(idx2), self.charset.to_subscript(idx1)\n                        ),\n                    )\n\n        return poly_str\n\n    def _format_polyxp(self, operation):\n        """"""Format a polynomial of x and p operators.\n\n        Theses operators appear as observables in CV quantum computing.\n\n        Args:\n            operation (~.PolyXP): The PolyXP observable that shall be formatted.\n\n        Returns:\n            str: A string representing the polynomial\n        """"""\n        coefficients = operation.params[0]\n        order = len(coefficients.shape)\n\n        if order == 1:\n            return self._format_polyxp_order1(coefficients)\n\n        return self._format_polyxp_order2(coefficients)\n\n    # pylint: disable=too-many-branches\n    def operator_representation(self, op, wire):\n        """"""Return the string representation of an Operator.\n\n        Args:\n            op (pennylane.operation.Operator): The Operator instance whose representation shall be returned\n            wire (int): The Operator\'s wire for which the string representation shall be returned\n\n        Returns:\n            str: String representation of the Operator\n        """"""\n        if isinstance(op, qml.operation.Tensor):\n            constituent_representations = [\n                self.operator_representation(tensor_obs, wire) for tensor_obs in op.obs\n            ]\n\n            return ("" "" + self.charset.OTIMES + "" "").join(constituent_representations)\n\n        representation = """"\n        base_name = getattr(op, ""base_name"", op.name)\n        name = base_name\n\n        # Use a shorter name if applicable\n        if name in RepresentationResolver.resolution_dict:\n            name = RepresentationResolver.resolution_dict[name]\n\n        # Display a control symbol for all controlling qubits of a controlled Operation\n        if base_name in self.control_wire_dict and wire in [\n            op.wires.tolist()[control_idx] for control_idx in self.control_wire_dict[base_name]\n        ]:\n            # No need to add a -1 for inverse here\n            return self.charset.CONTROL\n\n        if op.num_params == 0:\n            representation = name\n\n        elif base_name == ""PauliRot"":\n            representation = ""R{0}({1})"".format(\n                op.params[1][op.wires.tolist().index(wire)],\n                self.single_parameter_representation(op.params[0]),\n            )\n\n        elif base_name == ""QubitUnitary"":\n            representation = RepresentationResolver._format_matrix_operation(\n                op, ""U"", self.unitary_matrix_cache\n            )\n\n        elif base_name == ""Hermitian"":\n            representation = RepresentationResolver._format_matrix_operation(\n                op, ""H"", self.hermitian_matrix_cache\n            )\n\n        elif base_name == ""QuadOperator"":\n            par_rep = self.single_parameter_representation(op.params[0])\n\n            representation = ""cos({0})x+sin({0})p"".format(par_rep)\n\n        elif base_name == ""FockStateProjector"":\n            n_str = "","".join([str(n) for n in op.params[0]])\n\n            representation = (\n                self.charset.PIPE + n_str + self.charset.CROSSED_LINES + n_str + self.charset.PIPE\n            )\n\n        elif base_name == ""PolyXP"":\n            representation = self._format_polyxp(op)\n\n        elif base_name == ""FockState"":\n            representation = self.charset.PIPE + str(op.params[0]) + self.charset.RANGLE\n\n        elif base_name in {""BasisState"", ""FockStateVector""}:\n            representation = (\n                self.charset.PIPE\n                + str(op.params[0][op.wires.tolist().index(wire)])\n                + self.charset.RANGLE\n            )\n\n        # Operations that only have matrix arguments\n        elif base_name in {\n            ""GaussianState"",\n            ""FockDensityMatrix"",\n            ""FockStateVector"",\n            ""QubitStateVector"",\n            ""Interferometer"",\n        }:\n            representation = name + RepresentationResolver._format_matrix_arguments(\n                op.params, ""M"", self.matrix_cache\n            )\n\n        else:\n            representation = ""{}({})"".format(\n                name, "", "".join([self.single_parameter_representation(par) for par in op.params])\n            )\n\n        if getattr(op, ""inverse"", False):\n            representation += self.charset.to_superscript(""-1"")\n\n        return representation\n\n    def output_representation(self, obs, wire):\n        """"""Return the string representation of a circuit\'s output.\n\n        Args:\n            obs (pennylane.ops.Observable): The Observable instance whose representation shall be returned\n            wire (int): The Observable\'s wire for which the string representation shall be returned\n\n        Returns:\n            str: String representation of the Observable\n        """"""\n        # pylint: disable=inconsistent-return-statements\n        if obs.return_type == qml.operation.Expectation:\n            return (\n                self.charset.LANGLE\n                + ""{}"".format(self.operator_representation(obs, wire))\n                + self.charset.RANGLE\n            )\n\n        if obs.return_type == qml.operation.Variance:\n            return ""Var[{}]"".format(self.operator_representation(obs, wire))\n\n        if obs.return_type == qml.operation.Sample:\n            return ""Sample[{}]"".format(self.operator_representation(obs, wire))\n\n        if obs.return_type == qml.operation.Probability:\n            return ""Probs""\n\n        # Unknown return_type\n        return ""{}[{}]"".format(str(obs.return_type), self.operator_representation(obs, wire))\n\n    def element_representation(self, element, wire):\n        """"""Return the string representation of an element in the circuit\'s Grid.\n\n        Args:\n            element (Union[NoneType,str,qml.operation.Operator]): The circuit element whose representation shall be returned\n            wire (int): The element\'s wire for which the string representation shall be returned\n\n        Returns:\n            str: String representation of the element\n        """"""\n        if element is None:\n            return """"\n        if isinstance(element, str):\n            return element\n        if isinstance(element, qml.operation.Observable) and element.return_type is not None:\n            return self.output_representation(element, wire)\n\n        return self.operator_representation(element, wire)\n'"
pennylane/collections/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThe collections module. Contains the QNodeCollection and functions\nthat process them.\n""""""\nfrom .qnode_collection import QNodeCollection\n\nfrom .apply import apply\nfrom .dot import dot\nfrom .map import map\nfrom .sum import sum\n'"
pennylane/collections/apply.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nContains the apply function\n""""""\n\n\ndef apply(func, qnode_collection):\n    """"""Apply a function to the constituent QNodes of a :class:`QNodeCollection`.\n\n    Args:\n        func (callable): A function to be applied to the QNodeCollection results.\n            This function must be supported by the corresponding QNodeCollection\n            interface; i.e., a ``torch`` QNodeCollection can only be acted on functions\n            that accept ``torch.tensor`` objects.\n        qnode_collection (QNodeCollection): a QNode collection.\n\n    **Example:**\n\n    We can create a QNodeCollection using :func:`~.map`:\n\n    >>> dev = qml.device(""default.qubit"", wires=2)\n    >>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliZ(1)]\n    >>> qnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev, interface=""torch"")\n\n    As we are using the ``\'torch\'`` interface, we now apply ``torch.sum``\n    to the QNodeCollection:\n\n    >>> cost = qml.apply(torch.sum, qnodes)\n\n    This is a lazy composition --- no QNode evaluation has yet occured. Evaluation\n    only occurs when the returned function ``cost`` is evaluated:\n\n    >>> x = qml.init.strong_ent_layers_normal(3, 2)\n    >>> cost(x)\n    tensor(0.9092, dtype=torch.float64, grad_fn=<SumBackward0>)\n    """"""\n    new_func = lambda params, **kwargs: func(qnode_collection(params, **kwargs))\n    new_func.interface = qnode_collection.interface\n    return new_func\n'"
pennylane/collections/dot.py,4,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nContains functions to implement the dot product between QNode collections\n""""""\n# pylint: disable=too-many-arguments,import-outside-toplevel\n\n\ndef _get_dot_func(interface, x=None):\n    """"""Helper function for :func:`~.dot` to determine\n    the correct dot product function depending on the QNodeCollection\n    interface.\n\n    Args:\n        interface (str): the interface to get the dot product function for\n        x (Sequence): A non-QNodeCollection sequence. If it isn\'t the correct\n            type for the interface, it is automatically converted.\n\n    Returns:\n        tuple[callable, Sequence or torch.Tensor or tf.Variable]: a tuple\n        containing the required dot product function, as well as the\n        (potentially converted) sequence.\n    """"""\n    if interface == ""tf"":\n        import tensorflow as tf\n\n        if x is not None and not isinstance(x, (tf.Tensor, tf.Variable)):\n            x = tf.Variable(x, dtype=tf.float64)\n\n        return lambda a, b: tf.tensordot(a, b, 1), x\n\n    if interface == ""torch"":\n        import torch\n\n        if x is not None and not isinstance(x, torch.Tensor):\n            x = torch.tensor(x, dtype=torch.float64)\n\n        return torch.matmul, x\n\n    if interface in (""autograd"", ""numpy""):\n        from autograd import numpy as np\n\n        if x is not None and not isinstance(x, np.ndarray):\n            x = np.array(x)\n\n        return np.dot, x\n\n    if interface is None:\n        import numpy as np\n\n        return np.dot, x\n\n    raise ValueError(""Unknown interface {}"".format(interface))\n\n\ndef dot(x, y):\n    r""""""Lazily perform the dot product between arrays, tensors, and :class:`QNodeCollection`.\n\n    Using this function, lazy dot products can be computed between two :class:`QNodeCollection`\n    objects, or a :class:`QNodeCollection` object and an array/tensor object. In the latter\n    case, only one-dimensional arrays/tensors are supported.\n\n    Args:\n        x (array or tensor or QNodeCollection): A QNode collection of independent QNodes,\n            or an array/tensor object.\n        y (array or tensor or QNodeCollection): A QNode collection of independent QNodes,\n            or an array/tensor object.\n\n    .. seealso:: :func:`~.apply`, :func:`~.sum`\n\n    **Example:**\n\n    We can create a QNodeCollection using :func:`~.map`:\n\n    >>> dev = qml.device(""default.qubit"", wires=2)\n    >>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliZ(1)]\n    >>> qnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev, interface=""torch"")\n\n    The returned QNodeCollection contains 2 QNodes, as we mapped the :func:`~.StronglyEntanglingLayers`\n    over a list of two observables:\n\n    >>> len(qnodes)\n    2\n\n    For the cost function, we now perform the dot product between a vector of coefficients\n    and the QNodeCollection:\n\n    >>> coeffs = torch.tensor([0.32, -0.2], dtype=torch.double)\n    >>> cost = qml.dot(coeffs, qnodes)\n\n    .. note::\n\n        The ``cost`` function is equivalent to computing :math:`\\langle 0 | U(\\theta)^\\dagger H U(\\theta) | 0\\rangle`\n        where\n\n        * :math:`U(\\theta)` is the unitary applied by the strongly entangling layers, and\n        * :math:`H = 0.32 X\\otimes Z - 0.2 Z \\otimes Z`.\n\n    This is a lazy dot product --- no QNode evaluation has yet occured. Evaluation\n    only occurs when the returned function ``cost`` is evaluated:\n\n    >>> x = qml.init.strong_ent_layers_normal(3, 2) # generate random parameters\n    >>> cost(x)\n    tensor(-0.2183, dtype=torch.float64, grad_fn=<DotBackward>)\n    """"""\n    if hasattr(x, ""interface"") and hasattr(y, ""interface""):\n\n        if x.interface != y.interface:\n            raise ValueError(""QNodeCollections have non-matching interfaces"")\n\n        interface = x.interface\n        fn, _ = _get_dot_func(interface)\n        func = lambda params, **kwargs: fn(x(params, **kwargs), y(params, **kwargs))\n\n    elif hasattr(x, ""interface""):\n        interface = x.interface\n        fn, y = _get_dot_func(interface, y)\n        func = lambda params, **kwargs: fn(x(params, **kwargs), y)\n\n    elif hasattr(y, ""interface""):\n        interface = y.interface\n        fn, x = _get_dot_func(interface, x)\n        func = lambda params, **kwargs: fn(x, y(params, **kwargs))\n\n    else:\n        raise ValueError(""At least one argument must be a QNodeCollection"")\n\n    func.interface = interface\n    return func\n'"
pennylane/collections/map.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nContains the map function, for mapping templates over observables and devices.\n""""""\n# pylint: disable=too-many-arguments\nfrom collections.abc import Sequence\n\nfrom pennylane.qnodes import QNode\nfrom pennylane.measure import expval, var, sample\nfrom pennylane.operation import Observable\n\nfrom .qnode_collection import QNodeCollection\n\n\nMEASURE_MAP = {""expval"": expval, ""var"": var, ""sample"": sample}\n\n\ndef map(\n    template,\n    observables,\n    device,\n    measure=""expval"",\n    interface=""autograd"",\n    diff_method=""best"",\n    **kwargs\n):\n    """"""Map a quantum template over a list of observables to create\n    a :class:`QNodeCollection`.\n\n    The number of QNodes within the created QNode collection will match the number\n    of observables passed. The device and the measurement type will either be\n    applied to all QNodes in the collection, or can be provided as a list for more\n    fine-grained control.\n\n    Args:\n        template (callable): the ansatz for the circuit before the final measurement step\n            Note that the template **must** have the following signature:\n\n            .. code-block:: python\n\n                template(params, wires, **kwargs)\n\n            where ``params`` are the trainable weights of the variational circuit,\n            ``wires`` is a list of integers representing the wires of the device, and\n            ``kwargs`` are any additional keyword arguments that need to be passed\n            to the template.\n        observables (Iterable[:class:`~.Observable`]): observables to measure during the\n            final step of each circuit\n        device (Device, Sequence[Device]): Corresponding device(s) where the resulting\n            QNodeCollection should be executed. This can either be a single device, or a list\n            of devices of length ``len(observables)``.\n        measure (str, Union(List[str], Tuple[str])): Measurement(s) to perform. Options include\n            :func:`\'expval\' <pennylane.expval>`, :func:`\'var\' <pennylane.var>`,\n            and :func:`\'sample\' <pennylane.sample>`.\n            This can either be a single measurement type, in which case it is applied\n            to all observables, or a list of measurements of length ``len(observables)``.\n        interface (str, None): which interface to use for the returned QNode collection.\n            This affects the types of objects that can be passed to/returned from the QNode.\n            Supports all interfaces supported by the :func:`~.qnode` decorator.\n        diff_method (str, None): the method of differentiation to use in the created QNodeCollection.\n            Supports all differentiation methods supported by the :func:`~.qnode` decorator.\n\n    Returns:\n        QNodeCollection: a collection of QNodes executing the circuit template with\n        the specified measurements\n\n    **Example:**\n\n    Let\'s define a custom two-wire template:\n\n    .. code-block:: python\n\n        def my_template(params, wires, **kwargs):\n            qml.RX(params[0], wires=wires[0])\n            qml.RX(params[1], wires=wires[1])\n            qml.CNOT(wires=wires)\n\n    We want to compute the expectation values over the following list\n    of two-qubit observables:\n\n    >>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliX(1)]\n\n    This can be easily done with the ``map`` function:\n\n    >>> dev = qml.device(""default.qubit"", wires=2)\n    >>> qnodes = qml.map(my_template, obs_list, dev, measure=""expval"")\n\n    The returned :class:`~.QNodeCollection` can be evaluated, returning the results from each\n    mapped QNode as an array:\n\n    >>> params = [0.54, 0.12]\n    >>> qnodes(params)\n    array([-0.06154835  0.99280864])\n    """"""\n    if not callable(template):\n        raise ValueError(""Could not create QNodes. The template is not a callable function."")\n\n    qnodes = QNodeCollection()\n\n    if not isinstance(device, Sequence):\n        # broadcast the single device over all observables\n        device = [device] * len(observables)\n\n    if not isinstance(measure, (list, tuple)):\n        # broadcast the single measurement over all observables\n        measure = [measure] * len(observables)\n\n    for obs, m, dev in zip(observables, measure, device):\n        # Generate QNodes from all pairs of observables, measurements, and devices.\n        if not isinstance(obs, Observable):\n            raise ValueError(""Could not create QNodes. Some or all observables are not valid."")\n\n        wires = list(range(dev.num_wires))\n\n        # Note: in the following template definition, we pass the observable, measurement,\n        # and wires as *default arguments* to named parameters. This is to avoid\n        # Python\'s late binding closure behaviour\n        # (see https://docs.python-guide.org/writing/gotchas/#late-binding-closures)\n        def circuit(\n            params, _obs=obs, _m=m, _wires=wires, **circuit_kwargs\n        ):  # pylint: disable=dangerous-default-value, function-redefined\n            template(params, wires=_wires, **circuit_kwargs)\n            return MEASURE_MAP[_m](_obs)\n\n        qnode = QNode(circuit, dev, interface=interface, diff_method=diff_method, **kwargs)\n        qnodes.append(qnode)\n\n    return qnodes\n'"
pennylane/collections/qnode_collection.py,3,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nContains the QNodeCollection class.\n""""""\n# pylint: disable=too-many-arguments,import-outside-toplevel\nfrom collections.abc import Sequence\nimport warnings\n\n\nclass QNodeCollection(Sequence):\n    """"""Represents a sequence of independent QNodes that all share the same signature.\n    When the collection is evaluated, all QNodes are simultaneously evaluated\n    with the same parameters.\n\n    All QNodes within a QNodeCollection **must** use the same interface.\n\n    .. note:: the recommended method of creating a QNodeCollection is via :func:`~.map`.\n\n    Args:\n        qnodes (None or List[QNode]): A list of QNodes sharing the same signature.\n            If not provided, an empty QNode collection is instantiated.\n\n    .. seealso:: :func:`~.map`, :func:`~.apply`, :func:`~.sum`, :func:`~.dot`\n\n    **Example:**\n\n    A QNodeCollection can be created using a list of existing QNodes:\n\n    >>> qnode = qml.QNodeCollection([qnode1, qnode2])\n\n    Instantiating a QNode collection with no arguments creates an empty collection:\n\n    >>> qnodes = qml.QNodeCollection()\n    >>> len(qnodes)\n    0\n\n    QNodes can be appended:\n\n    >>> qnodes.append(qnode1)\n    >>> len(qnodes)\n    1\n\n    or extended:\n\n    >>> qnodes.extend([qnode2, qnode3])\n    >>> len(qnodes)\n    3\n\n    They can also be indexed:\n\n    >>> qnodes[0]\n    <QNode: device=\'default.qubit\', func=circuit, wires=2, interface=torch>\n\n    or looped over:\n\n    >>> [i.num_wires for i in qnodes]\n    [2, 2, 2]\n\n    To evaluate a QNodeCollection, simply call the collection, passing the parameters\n    as required by the constituent QNode. For example, consider the\n    following two QNodes with the same signature:\n\n    .. code-block:: python3\n\n        dev1 = qml.device(""default.qubit"", wires=1)\n        dev2 = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev1)\n        def qnode1(x, y):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(dev2)\n        def qnode2(x, y):\n            qml.Hadamard(wires=0)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.var(qml.PauliZ(1))\n\n    Creating a QNodeCollection,\n\n    >>> qnodes = qml.QNodeCollection([qnode1, qnode2])\n\n    We can evaluate this QNode collection directly:\n\n    >>> qnodes(0.5643, -0.45)\n    [ 7.60844651e-01 -5.55111512e-17  1.00000000e+00]\n\n    where the results from each QNode have been flattened and concatenated\n    into a single one-dimensional list.\n\n    .. raw:: html\n\n        <h2>Asynchronous evaluation</h2>\n\n    .. warning::\n\n        You will find the best speedups when using asynchronous mode when QNodes are to\n        be evaluated on external hardware devices or external simulators. **It is not\n        advised at this point to use asynchronous mode with** ``default.qubit`` **.**\n\n    .. warning::\n\n        Asynchronous evaluation is experimental --- please report all bugs and issues\n        to our GitHub page. It currently works with all interfaces, however backpropagation\n        and gradient computation is limited to Autograd and PyTorch. **Quantum gradients\n        using TensorFlow in asynchronous mode is currently not supported**.\n\n    By default, the QNodes within the QNodeCollection are executed sequentially.\n\n    However, experimental asynchronous support is now available using the\n    `Dask <https://dask.org/>`_ parallelism library. This can be activated\n    by passing the ``parallel=True`` keyword argument when evaluating the\n    QNodeCollection.\n\n    For example, let\'s create the following two QVM simulation devices:\n\n    >>> qpu1 = qml.device(""forest.qvm"", device=""Aspen-4-4Q-D"")\n    >>> qpu2 = qml.device(""forest.qvm"", device=""Aspen-7-4Q-B"")\n\n    We can create a collection of QNodes with different observables by mapping\n    an ansatz over these devices using :func:`~.map`:\n\n    >>> obs_list = [qml.PauliX(0), qml.PauliZ(0) @ qml.PauliZ(1)]\n    >>> qnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, [qpu1, qpu2])\n\n    We can now create some parameters and evaluate the collection:\n\n    >>> params = qml.init.strong_ent_layers_normal(n_layers=4, n_wires=4)\n    >>> qnodes(params)\n    array([0.046875  , 0.93164062])\n\n    The above collection was executed sequentially. Executing it in parallel:\n\n    >>> qnodes(params, parallel=True)\n    array([0.0234375 , 0.92578125])\n\n    We can time both approaches from within IPython or a Jupyter notebook:\n\n    >>> %timeit qnodes(params)\n    5.16 s \xc2\xb1 162 ms per loop (mean \xc2\xb1 std. dev. of 7 runs, 1 loop each)\n    >>> %timeit qnodes(params, parallel=True)\n    2.99 s \xc2\xb1 40.7 ms per loop (mean \xc2\xb1 std. dev. of 7 runs, 1 loop each)\n    """"""\n\n    def __init__(self, qnodes=None):\n        self.qnodes = []\n        self.extend(qnodes or [])\n\n    @property\n    def interface(self):\n        """"""str, None: automatic differentiation interface used by the collection, if any""""""\n        if not self.qnodes:\n            return None\n\n        return self.qnodes[0].interface\n\n    def append(self, qnode):\n        """"""Appends a QNode to the collection. The appended QNode *must* have the same\n        interface as the QNode collection.""""""\n        self.extend([qnode])\n\n    def extend(self, qnodes):\n        """"""Extends the collection by a list of QNodes. The appended QNodes *must* have the same\n        interface as the QNode collection.""""""\n        if not all(i.interface == qnodes[0].interface for i in qnodes):\n            raise ValueError(""Provided QNodes do not all use the same interface"")\n\n        if self.qnodes and (qnodes[0].interface != self.interface):\n            raise ValueError(\n                ""Interface mismatch. Provided QNodes use the {} interface, ""\n                ""QNode collection uses the {} interface"".format(qnodes[0].interface, self.interface)\n            )\n\n        self.qnodes.extend(qnodes)\n\n    def evaluate(self, args, kwargs):\n        """"""Evaluate all QNodes in the collection.\n\n        Args:\n            args (list): list containing the arguments\n                to pass to all internal QNodes\n            kwargs (dict): dictionary containing the keyword\n                arguments to pass to all internal QNodes\n\n        Returns:\n            list: the results from each QNode\n        """"""\n        results = []\n        parallel = kwargs.pop(""parallel"", False)\n        _scheduler = kwargs.pop(""scheduler"", ""threads"")\n\n        if parallel:\n            try:\n                import dask\n            except:\n                raise ImportError(\n                    ""Dask must be installed for parallel evaluation. ""\n                    ""\\nDask can be installed using pip:""\n                    ""\\n\\npip install dask[delayed]""\n                )\n\n            if self.interface == ""tf"":\n                warnings.warn(\n                    ""Parallel execution of QNodeCollections is ""\n                    ""an experimental feature, and currently doesn\'t ""\n                    ""work with TensorFlow backpropagation. Please use ""\n                    ""the PyTorch or Autograd interfaces instead."",\n                    UserWarning,\n                )\n\n            for q in self.qnodes:\n                results.append(dask.delayed(q)(*args, **kwargs))\n\n            return dask.compute(*results, scheduler=_scheduler)\n\n        for q in self.qnodes:\n            results.append(q(*args, **kwargs))\n\n        return results\n\n    @staticmethod\n    def convert_results(results, interface):\n        """"""Convert a list of results coming from multiple QNodes\n        to the object required by each interface for auto-differentiation.\n\n        Internally, this method makes use of ``tf.stack``, ``torch.stack``,\n        and ``np.vstack``.\n\n        Args:\n            results (list): list containing the results from\n                multiple QNodes\n            interface (str): the interfaces of the underlying QNodes\n\n        Returns:\n            list or array or torch.Tensor or tf.Tensor: the converted\n            and stacked results.\n        """"""\n        if interface == ""tf"":\n            import tensorflow as tf\n\n            return tf.stack(results)\n\n        if interface == ""torch"":\n            import torch\n\n            return torch.stack(results, dim=0)\n\n        if interface in (""autograd"", ""numpy""):\n            from autograd import numpy as np\n\n            return np.stack(results)\n\n        return results\n\n    def __call__(self, *args, **kwargs):\n        results = self.evaluate(args, kwargs)\n        return self.convert_results(results, self.interface)\n\n    def __len__(self):\n        return len(self.qnodes)\n\n    def __getitem__(self, idx):\n        return self.qnodes[idx]\n'"
pennylane/collections/sum.py,1,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nContains the sum function, for summing QNode collections.\n""""""\n# pylint: disable=too-many-arguments,import-outside-toplevel\n\nfrom .apply import apply\n\n\ndef sum(x):\n    """"""Lazily sum the constituent QNodes of a :class:`QNodeCollection`.\n\n    Args:\n        x (QNodeCollection): a QNode collection of independent QNodes.\n\n    .. seealso:: :func:`~.apply`, :func:`~.dot`\n\n    **Example:**\n\n    We can create a QNodeCollection using :func:`~.map`:\n\n    >>> dev = qml.device(""default.qubit"", wires=2)\n    >>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliZ(1)]\n    >>> qnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev, interface=""torch"")\n\n    For the cost function, we now sum the results of all QNodes in the collection:\n\n    >>> cost = qml.sum(qnodes)\n\n    This is a lazy summation --- no QNode evaluation has yet occured. Evaluation\n    only occurs when the returned function ``cost`` is evaluated:\n\n    >>> x = qml.init.strong_ent_layers_normal(3, 2)\n    >>> cost(x)\n    tensor(0.9092, dtype=torch.float64, grad_fn=<SumBackward0>)\n    """"""\n    if hasattr(x, ""interface"") and x.interface is not None:\n        if x.interface == ""tf"":\n            import tensorflow as tf\n\n            return apply(tf.reduce_sum, x)\n\n        if x.interface == ""torch"":\n            import torch\n\n            return apply(torch.sum, x)\n\n        if x.interface in (""autograd"", ""numpy""):\n            from autograd import numpy as np\n\n            return apply(np.sum, x)\n\n        raise ValueError(""Unknown interface {}"".format(x.interface))\n\n    import numpy as np\n\n    return apply(np.sum, x)\n'"
pennylane/interfaces/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis subpackage defines functions convert QNodes to interface with different machine\nlearning libraries.\n\n.. currentmodule:: pennylane.interfaces\n.. autosummary::\n    :toctree: api\n\n    tf\n    torch\n    autograd\n""""""\n'"
pennylane/interfaces/autograd.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nDifferentiable quantum nodes with Autograd interface.\n""""""\nimport autograd.extend\nimport autograd.builtins\n\nfrom pennylane.utils import unflatten\n\n\ndef to_autograd(qnode):\n    """"""Function that accepts a :class:`~.QNode`, and returns an Autograd-compatible QNode.\n\n    Args:\n        qnode (~pennylane.qnode.QNode): a PennyLane QNode\n\n    Returns:\n        AutogradQNode: an Autograd-compatible QNode\n    """"""\n\n    class AutogradQNode(qnode.__class__):\n        """"""QNode that works with Autograd.""""""\n\n        @property\n        def interface(self):\n            """"""str, None: automatic differentiation interface used by the node, if any""""""\n            return ""autograd""\n\n        # mark the evaluate method as an Autograd primitive\n        evaluate = autograd.extend.primitive(qnode.__class__.evaluate)\n\n        def set_trainable(self, args):\n            """"""Given input arguments to the AutogradQNode, determine which arguments\n            are trainable and which aren\'t.\n\n            This method calls the underlying :meth:`set_trainable_args` method of the QNode.\n            """"""\n            trainable_args = set()\n\n            for idx, arg in enumerate(args):\n                if getattr(arg, ""requires_grad"", True):\n                    trainable_args.add(idx)\n\n            self.set_trainable_args(trainable_args)\n\n        def __call__(self, *args, **kwargs):\n            # prevents autograd boxed arguments from going through to evaluate\n            self.set_trainable(args)\n            args = autograd.builtins.tuple(args)  # pylint: disable=no-member\n            return self.evaluate(args, kwargs)\n\n        @staticmethod\n        def QNode_vjp(ans, self, args, kwargs):\n            """"""Returns the vector-Jacobian product operator for the QNode.\n\n            Takes the same arguments as :meth:`evaluate`, plus ``ans``.\n\n            Returns:\n                function[array[float], array[float]]: vector-Jacobian product operator\n            """"""\n            # pylint: disable=unused-argument\n            def gradient_product(g):\n                """"""Vector-Jacobian product operator.\n\n                Args:\n                    g (array[float]): scalar or vector multiplying the Jacobian\n                        from the left (output side)\n\n                Returns:\n                    nested Sequence[float]: vector-Jacobian product, arranged\n                    into the nested structure of the input arguments in ``args``\n                """"""\n                # Jacobian matrix of the circuit\n                self.set_trainable(args)\n                jac = self.jacobian(args, kwargs)\n\n                if not g.shape:\n                    vjp = g * jac  # numpy treats 0d arrays as scalars, hence @ cannot be used\n                else:\n                    vjp = g @ jac\n\n                # Restore the nested structure of the input args.\n                vjp = unflatten(vjp.flat, args)\n                return vjp\n\n            return gradient_product\n\n    # define the vector-Jacobian product function for AutogradQNode.evaluate\n    autograd.extend.defvjp(AutogradQNode.evaluate, AutogradQNode.QNode_vjp, argnums=[1])\n    qnode.__class__ = AutogradQNode\n    return qnode\n'"
pennylane/interfaces/tf.py,16,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the :func:`to_tf` function to convert Numpy-interfacing quantum nodes to TensorFlow\ncompatible quantum nodes.\n""""""\n# pylint: disable=redefined-outer-name\nimport numbers\nfrom collections import Iterable\nfrom functools import partial\n\nimport numpy as np\nimport tensorflow as tf\n\nfrom tensorflow import Variable  # pylint: disable=unused-import,ungrouped-imports\n\ntry:\n    from tensorflow.python.eager.tape import should_record_backprop\nexcept ImportError:\n    from tensorflow.python.eager.tape import should_record as should_record_backprop\n\n\ndef unflatten_tf(flat, model):\n    """"""Restores an arbitrary nested structure to a flattened TF tensor.\n\n    See also :func:`~.unflatten`.\n\n    Args:\n        flat (tf.Tensor): 1D tensor of items\n        model (array, Iterable, Number): model nested structure\n\n    Returns:\n        Union[tf.Tensor, list], array: first elements of flat arranged into the nested\n        structure of model, unused elements of flat\n\n    Raises:\n        TypeError: if ``model`` contains an object of unsupported type\n    """"""\n    if isinstance(model, (numbers.Number, str)):\n        return flat[0], flat[1:]\n\n    if isinstance(model, (tf.Tensor, tf.Variable)):\n        idx = tf.size(model)\n        res = tf.reshape(flat[:idx], model.shape)\n        return res, flat[idx:]\n\n    if isinstance(model, Iterable):\n        res = []\n        for x in model:\n            val, flat = unflatten_tf(flat, x)\n            res.append(val)\n        return res, flat\n\n    raise TypeError(""Unsupported type in the model: {}"".format(type(model)))\n\n\ndef to_tf(qnode, dtype=None):\n    """"""Function that accepts a :class:`~.QNode`, and returns a TensorFlow eager-execution-compatible QNode.\n\n    Args:\n        qnode (~pennylane.qnode.QNode): a PennyLane QNode\n        dtype (tf.DType): target output type of QNode; uses the TensorFlow equivalent of the\n            QNode output type if ``dtype`` is not specified\n\n    Returns:\n        function: the QNode as a TensorFlow function\n    """"""\n\n    class TFQNode(partial):\n        """"""TensorFlow QNode""""""\n\n        # pylint: disable=too-few-public-methods\n\n        # Here, we are making use of functools.partial to dynamically add\n        # methods and attributes to the custom gradient function defined below.\n        # This allows us to provide more useful __str__ and __repr__ methods\n        # for the decorated function (so it would still look like a QNode to end-users),\n        # as well as making QNode attributes and methods available.\n\n        @property\n        def interface(self):\n            """"""String representing the QNode interface""""""\n            return ""tf""\n\n        def __str__(self):\n            """"""String representation""""""\n            detail = ""<QNode: device=\'{}\', func={}, wires={}, interface={}>""\n            return detail.format(\n                qnode.device.short_name, qnode.func.__name__, qnode.num_wires, self.interface\n            )\n\n        def __repr__(self):\n            """"""REPL representation""""""\n            return self.__str__()\n\n        # Bind QNode methods\n        print_applied = qnode.print_applied\n        jacobian = qnode.jacobian\n        metric_tensor = qnode.metric_tensor\n        draw = qnode.draw\n        func = qnode.func\n        set_trainable_args = qnode.set_trainable_args\n        get_trainable_args = qnode.get_trainable_args\n\n        # Bind QNode attributes. Note that attributes must be\n        # bound as properties; by making use of closure, we ensure\n        # that updates to the wrapped QNode attributes are reflected\n        # by the wrapper class.\n        num_variables = property(lambda self: qnode.num_variables)\n        arg_vars = property(lambda self: qnode.arg_vars)\n        par_to_grad_method = property(lambda self: qnode.par_to_grad_method)\n\n    @TFQNode\n    @tf.custom_gradient\n    def _TFQNode(*input_, **input_kwargs):\n        # Determine which input tensors/Variables are being recorded for backpropagation.\n        # The function should_record_backprop, documented here:\n        # https://github.com/tensorflow/tensorflow/tree/master/tensorflow/python/eager/tape.py#L163\n        # accepts lists of *tensors* (not Variables), returning True if all are being watched by one or more\n        # existing gradient tape, False if not.\n        trainable_args = {\n            idx\n            for idx, i in enumerate(input_)\n            if isinstance(i, (Variable, tf.Tensor))\n            and should_record_backprop([tf.convert_to_tensor(i)])\n        }\n\n        # detach all input Tensors, convert to NumPy array\n        args = [i.numpy() if isinstance(i, (Variable, tf.Tensor)) else i for i in input_]\n        kwargs = {\n            k: v.numpy() if isinstance(v, (Variable, tf.Tensor)) else v\n            for k, v in input_kwargs.items()\n        }\n\n        # if NumPy array is scalar, convert to a Python float\n        args = [i.tolist() if (isinstance(i, np.ndarray) and not i.shape) else i for i in args]\n        kwargs = {\n            k: v.tolist() if (isinstance(v, np.ndarray) and not v.shape) else v\n            for k, v in kwargs.items()\n        }\n\n        # evaluate the QNode\n        qnode.set_trainable_args(trainable_args)\n        res = qnode(*args, **kwargs)\n\n        if not isinstance(res, np.ndarray):\n            # scalar result, cast to NumPy scalar\n            res = np.array(res)\n\n        def grad(grad_output, **tfkwargs):\n            """"""Returns the vector-Jacobian product""""""\n            # evaluate the Jacobian matrix of the QNode\n            variables = tfkwargs.get(""variables"", None)\n            qnode.set_trainable_args(trainable_args)\n            jacobian = qnode.jacobian(args, kwargs)\n            jacobian = tf.constant(jacobian, dtype=dtype)\n\n            # Reshape gradient output array as a 2D row-vector.\n            grad_output_row = tf.transpose(tf.reshape(grad_output, [-1, 1]))\n\n            # Calculate the vector-Jacobian matrix product, and flatten the output.\n            grad_input = tf.matmul(grad_output_row, jacobian)\n            grad_input = tf.reshape(grad_input, [-1])\n\n            grad_input_unflattened = unflatten_tf(grad_input, input_)[0]\n\n            for idx in set(range(len(args))) - trainable_args:\n                # If a particular input argument is non-differentiable,\n                # replace the corresponding position in the gradient with None.\n                grad_input_unflattened[idx] = None\n\n            if variables is not None:\n                return grad_input_unflattened, variables\n\n            return grad_input_unflattened\n\n        return tf.convert_to_tensor(res, dtype=dtype), grad\n\n    return _TFQNode\n'"
pennylane/interfaces/torch.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the :func:`to_torch` function to convert Numpy-interfacing quantum nodes to PyTorch\ncompatible quantum nodes.\n""""""\n# pylint: disable=redefined-outer-name,arguments-differ\nfrom collections import Iterable\nimport inspect\nfrom functools import partial\nimport numbers\n\nimport numpy as np\nimport torch\nfrom torch.autograd.function import once_differentiable\n\n\ndef unflatten_torch(flat, model):\n    """"""Restores an arbitrary nested structure to a flattened Torch tensor.\n\n    Args:\n        flat (torch.Tensor): 1D tensor of items\n        model (array, Iterable, Number): model nested structure\n\n    Returns:\n        Tuple[list[torch.Tensor], torch.Tensor]: tuple containing elements of ``flat`` arranged\n        into the nested structure of model, as well as the unused elements of ``flat``.\n\n    Raises:\n        TypeError: if ``model`` contains an object of unsupported type\n    """"""\n    if isinstance(model, (numbers.Number, str)):\n        return flat[0], flat[1:]\n\n    if isinstance(model, (torch.Tensor, np.ndarray)):\n        try:\n            idx = model.numel()\n        except AttributeError:\n            idx = model.size\n\n        res = flat[:idx].reshape(model.shape)\n        return res, flat[idx:]\n\n    if isinstance(model, Iterable):\n        res = []\n        for x in model:\n            val, flat = unflatten_torch(flat, x)\n            res.append(val)\n        return res, flat\n\n    raise TypeError(""Unsupported type in the model: {}"".format(type(model)))\n\n\ndef _get_default_args(func):\n    """"""Get the default arguments of a function.\n\n    Args:\n        func (function): a valid Python function\n\n    Returns:\n        dict: dictionary containing the argument name and tuple\n        (positional idx, default value)\n    """"""\n    signature = inspect.signature(func)\n    return {\n        k: (idx, v.default)\n        for idx, (k, v) in enumerate(signature.parameters.items())\n        if v.default is not inspect.Parameter.empty\n    }\n\n\ndef args_to_numpy(args):\n    """"""Converts all Torch tensors in a list to NumPy arrays\n\n    Args:\n        args (list): list containing QNode arguments, including Torch tensors\n\n    Returns:\n        list: returns the same list, with all Torch tensors converted to NumPy arrays\n    """"""\n    res = []\n\n    for i in args:\n        if isinstance(i, torch.Tensor):\n            if i.is_cuda:  # pragma: no cover\n                res.append(i.cpu().detach().numpy())\n            else:\n                res.append(i.detach().numpy())\n        else:\n            res.append(i)\n\n    # if NumPy array is scalar, convert to a Python float\n    res = [i.tolist() if (isinstance(i, np.ndarray) and not i.shape) else i for i in res]\n\n    return res\n\n\ndef kwargs_to_numpy(kwargs):\n    """"""Converts all Torch tensors in a dictionary to NumPy arrays\n\n    Args:\n        args (dict): dictionary containing QNode keyword arguments, including Torch tensors\n\n    Returns:\n        dict: returns the same dictionary, with all Torch tensors converted to NumPy arrays\n    """"""\n    res = {}\n\n    for key, val in kwargs.items():\n        if isinstance(val, torch.Tensor):\n            if val.is_cuda:  # pragma: no cover\n                res[key] = val.cpu().detach().numpy()\n            else:\n                res[key] = val.detach().numpy()\n        else:\n            res[key] = val\n\n    # if NumPy array is scalar, convert to a Python float\n    res = {\n        k: v.tolist() if (isinstance(v, np.ndarray) and not v.shape) else v for k, v in res.items()\n    }\n\n    return res\n\n\ndef to_torch(qnode):\n    """"""Function that accepts a :class:`~.QNode`, and returns a PyTorch-compatible QNode.\n\n    Args:\n        qnode (~pennylane.qnode.QNode): a PennyLane QNode\n\n    Returns:\n        torch.autograd.Function: the QNode as a PyTorch autograd function\n    """"""\n\n    class _TorchQNode(torch.autograd.Function):\n        """"""The TorchQNode""""""\n\n        @staticmethod\n        def set_trainable(args):\n            """"""Given input arguments to the TorchQNode, determine which arguments\n            are trainable and which aren\'t.\n\n            Currently, all arguments are assumed to be nondifferentiable by default,\n            unless the ``torch.tensor`` attribute ``requires_grad`` is set to True.\n\n            This method calls the underlying :meth:`set_trainable_args` method of the QNode.\n            """"""\n            trainable_args = set()\n\n            for idx, arg in enumerate(args):\n                if getattr(arg, ""requires_grad"", False):\n                    trainable_args.add(idx)\n\n            qnode.set_trainable_args(trainable_args)\n\n        @staticmethod\n        def forward(ctx, input_kwargs, *input_):\n            """"""Implements the forward pass QNode evaluation""""""\n            # detach all input tensors, convert to NumPy array\n            ctx.args = args_to_numpy(input_)\n            ctx.kwargs = kwargs_to_numpy(input_kwargs)\n            ctx.save_for_backward(*input_)\n\n            # Determine which QNode input tensors require gradients,\n            # and thus communicate to the QNode which ones must\n            # be wrapped as PennyLane variables.\n            _TorchQNode.set_trainable(input_)\n\n            # evaluate the QNode\n            res = qnode(*ctx.args, **ctx.kwargs)\n\n            if not isinstance(res, np.ndarray):\n                # scalar result, cast to NumPy scalar\n                res = np.array(res)\n\n            # if any input tensor uses the GPU, the output should as well\n            for i in input_:\n                if isinstance(i, torch.Tensor):\n                    if i.is_cuda:  # pragma: no cover\n                        cuda_device = i.get_device()\n                        return torch.as_tensor(torch.from_numpy(res), device=cuda_device)\n\n            return torch.from_numpy(res)\n\n        @staticmethod\n        @once_differentiable\n        def backward(ctx, grad_output):  # pragma: no cover\n            """"""Implements the backwards pass QNode vector-Jacobian product""""""\n            # NOTE: This method is definitely tested by the `test_torch.py` test suite,\n            # however does not show up in the coverage. This is likely due to\n            # subtleties in the torch.autograd.FunctionMeta metaclass, specifically\n            # the way in which the backward class is created on the fly\n\n            # evaluate the Jacobian matrix of the QNode\n            jacobian = qnode.jacobian(ctx.args, ctx.kwargs)\n            jacobian = torch.as_tensor(jacobian, dtype=grad_output.dtype)\n\n            vjp = torch.transpose(grad_output.view(-1, 1), 0, 1) @ jacobian\n            vjp = vjp.flatten()\n\n            # restore the nested structure of the input args\n            grad_input_list = unflatten_torch(vjp, ctx.saved_tensors)[0]\n            grad_input = []\n\n            # match the type and device of the input tensors\n            for i, j in zip(grad_input_list, ctx.saved_tensors):\n                res = torch.as_tensor(i, dtype=j.dtype)\n                if j.is_cuda:  # pragma: no cover\n                    cuda_device = j.get_device()\n                    res = torch.as_tensor(res, device=cuda_device)\n                grad_input.append(res)\n\n            return (None,) + tuple(grad_input)\n\n    class TorchQNode(partial):\n        """"""Torch QNode""""""\n\n        # pylint: disable=too-few-public-methods\n\n        # Here, we are making use of functools.partial to dynamically add\n        # methods and attributes to the custom gradient method defined below.\n        # This allows us to provide more useful __str__ and __repr__ methods\n        # for the decorated function (so it would still look like a QNode to end-users),\n        # as well as making QNode attributes and methods available.\n\n        @property\n        def interface(self):\n            """"""String representing the QNode interface""""""\n            return ""torch""\n\n        def __str__(self):\n            """"""String representation""""""\n            detail = ""<QNode: device=\'{}\', func={}, wires={}, interface={}>""\n            return detail.format(\n                qnode.device.short_name, qnode.func.__name__, qnode.num_wires, self.interface\n            )\n\n        def __repr__(self):\n            """"""REPL representation""""""\n            return self.__str__()\n\n        # Bind QNode methods\n        print_applied = qnode.print_applied\n        jacobian = qnode.jacobian\n        metric_tensor = qnode.metric_tensor\n        draw = qnode.draw\n        func = qnode.func\n        set_trainable_args = qnode.set_trainable_args\n        get_trainable_args = qnode.get_trainable_args\n\n        # Bind QNode attributes. Note that attributes must be\n        # bound as properties; by making use of closure, we ensure\n        # that updates to the wrapped QNode attributes are reflected\n        # by the wrapper class.\n        arg_vars = property(lambda self: qnode.arg_vars)\n        num_variables = property(lambda self: qnode.num_variables)\n        par_to_grad_method = property(lambda self: qnode.par_to_grad_method)\n\n    @TorchQNode\n    def custom_apply(*args, **kwargs):\n        """"""Custom apply wrapper, to allow passing kwargs to the TorchQNode""""""\n\n        # get default kwargs that weren\'t passed\n        keyword_sig = _get_default_args(qnode.func)\n        keyword_defaults = {k: v[1] for k, v in keyword_sig.items()}\n        # keyword_positions = {v[0]: k for k, v in keyword_sig.items()}\n\n        # create a keyword_values dict, that contains defaults\n        # and any user-passed kwargs\n        keyword_values = {}\n        keyword_values.update(keyword_defaults)\n        keyword_values.update(kwargs)\n\n        # sort keyword values into a list of args, using their position\n        # [keyword_values[k] for k in sorted(keyword_positions, key=keyword_positions.get)]\n\n        return _TorchQNode.apply(keyword_values, *args)\n\n    return custom_apply\n'"
pennylane/numpy/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nThis package provides a wrapped version of autograd.numpy, such that\r\nit works with the PennyLane :class:`~.tensor` class.\r\n""""""\r\n# pylint: disable=wrong-import-position,wildcard-import,undefined-variable\r\nfrom autograd import numpy as _np\r\nfrom autograd.numpy import *\r\n\r\nfrom .wrapper import wrap_arrays, extract_tensors\r\n\r\nwrap_arrays(_np.__dict__, globals())\r\n\r\n# Delete the unwrapped fft, linalg, random modules\r\n# so that we can re-import our wrapped versions.\r\ndel fft\r\ndel linalg\r\ndel random\r\n\r\nfrom . import fft\r\nfrom . import linalg\r\nfrom . import random\r\n\r\nfrom .tensor import tensor, NonDifferentiableError\r\n\r\n__doc__ = ""NumPy with automatic differentiation support, provided by Autograd and PennyLane.""\r\n'"
pennylane/numpy/fft.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nThis package provides a wrapped version of autograd.numpy.fft, such that\r\nit works with the PennyLane :class:`~.tensor` class.\r\n""""""\r\nfrom autograd.numpy import fft as _fft\r\nfrom .wrapper import wrap_arrays\r\n\r\nwrap_arrays(_fft.__dict__, globals())\r\n'"
pennylane/numpy/linalg.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nThis package provides a wrapped version of autograd.numpy.linalg, such that\r\nit works with the PennyLane :class:`~.tensor` class.\r\n""""""\r\nfrom autograd.numpy import linalg as _linalg\r\nfrom .wrapper import wrap_arrays\r\n\r\nwrap_arrays(_linalg.__dict__, globals())\r\n'"
pennylane/numpy/random.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nThis package provides a wrapped version of autograd.numpy.random, such that\r\nit works with the PennyLane :class:`~.tensor` class.\r\n""""""\r\nfrom autograd.numpy import random as _random\r\nfrom .wrapper import wrap_arrays\r\n\r\nwrap_arrays(_random.__dict__, globals())\r\n'"
pennylane/numpy/tensor.py,1,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nThis module provides the PennyLane :class:`~.tensor` class.\r\n""""""\r\nimport numpy as onp\r\n\r\nfrom autograd import numpy as _np\r\n\r\nfrom autograd.tracer import Box\r\nfrom autograd.numpy.numpy_boxes import ArrayBox\r\nfrom autograd.numpy.numpy_vspaces import ComplexArrayVSpace, ArrayVSpace\r\nfrom autograd.core import VSpace\r\n\r\n\r\n__doc__ = ""NumPy with automatic differentiation support, provided by Autograd and PennyLane.""\r\n\r\n\r\nclass tensor(_np.ndarray):\r\n    """"""Constructs a PennyLane tensor for use with Autograd QNodes.\r\n\r\n    The ``tensor`` class is a subclass of ``numpy.ndarray``,\r\n    providing the same multidimensional, homogeneous data-structure\r\n    of fixed-size items, with an additional flag to indicate to PennyLane\r\n    whether the contained data is differentiable or not.\r\n\r\n    .. warning::\r\n\r\n        PennyLane ``tensor`` objects are only used as part of the Autograd QNode\r\n        interface. If using another machine learning library such as PyTorch or\r\n        TensorFlow, use their built-in ``tf.Variable`` and ``torch.tensor`` classes\r\n        instead.\r\n\r\n    .. warning::\r\n\r\n        Tensors should be constructed using standard array construction functions\r\n        provided as part of PennyLane\'s NumPy implementation, including\r\n        ``np.array``, ``np.zeros`` or ``np.empty``.\r\n\r\n        The parameters given here refer to a low-level class\r\n        for instantiating tensors.\r\n\r\n\r\n    Args:\r\n        input_array (array_like): Any data structure in any form that can be converted to\r\n            an array. This includes lists, lists of tuples, tuples, tuples of tuples,\r\n            tuples of lists and ndarrays.\r\n        requires_grad (bool): whether the tensor supports differentiation\r\n\r\n    **Example**\r\n\r\n    The trainability of a tensor can be set on construction via the\r\n    ``requires_grad`` keyword argument,\r\n\r\n    >>> from pennylane import numpy as np\r\n    >>> x = np.array([0, 1, 2], requires_grad=True)\r\n    >>> x\r\n    tensor([0, 1, 2], requires_grad=True)\r\n\r\n    or in-place by modifying the ``requires_grad`` attribute:\r\n\r\n    >>> x.requires_grad = False\r\n    tensor([0, 1, 2], requires_grad=False)\r\n\r\n    Since tensors are subclasses of ``np.ndarray``, they can be provided as arguments\r\n    to any PennyLane-wrapped NumPy function:\r\n\r\n    >>> np.sin(x)\r\n    tensor([0.        , 0.84147098, 0.90929743], requires_grad=True)\r\n\r\n    When composing functions of multiple tensors, if at least one input tensor is differentiable,\r\n    then the output will also be differentiable:\r\n\r\n    >>> x = np.array([0, 1, 2], requires_grad=False)\r\n    >>> y = np.zeros([3], requires_grad=True)\r\n    >>> np.vstack([x, y])\r\n    tensor([[0., 1., 2.],\r\n        [0., 0., 0.]], requires_grad=True)\r\n    """"""\r\n\r\n    def __new__(cls, input_array, *args, requires_grad=True, **kwargs):\r\n        obj = _np.array(input_array, *args, **kwargs)\r\n\r\n        if isinstance(obj, _np.ndarray):\r\n            obj = obj.view(cls)\r\n            obj.requires_grad = requires_grad\r\n\r\n        return obj\r\n\r\n    def __array_finalize__(self, obj):\r\n        # pylint: disable=attribute-defined-outside-init\r\n        if obj is None:\r\n            return\r\n\r\n        self.requires_grad = getattr(obj, ""requires_grad"", None)\r\n\r\n    def __repr__(self):\r\n        string = super().__repr__()\r\n        return string[:-1] + "", requires_grad={})"".format(self.requires_grad)\r\n\r\n\r\nclass NonDifferentiableError(Exception):\r\n    """"""Exception raised if attempting to differentiate non-trainable\r\n    :class:`~.tensor` using Autograd.""""""\r\n\r\n\r\ndef tensor_to_arraybox(x, *args):\r\n    """"""Convert a :class:`~.tensor` to an Autograd ``ArrayBox``.\r\n\r\n    Args:\r\n        x (array_like): Any data structure in any form that can be converted to\r\n            an array. This includes lists, lists of tuples, tuples, tuples of tuples,\r\n            tuples of lists and ndarrays.\r\n\r\n    Returns:\r\n        autograd.numpy.numpy_boxes.ArrayBox: Autograd ArrayBox instance of the array\r\n\r\n    Raises:\r\n        NonDifferentiableError: if the provided tensor is non-differentiable\r\n    """"""\r\n    if isinstance(x, tensor):\r\n        if x.requires_grad:\r\n            return ArrayBox(x, *args)\r\n\r\n        raise NonDifferentiableError(\r\n            ""{} is non-differentiable. Set the requires_grad attribute to True."".format(x)\r\n        )\r\n\r\n    return ArrayBox(x, *args)\r\n\r\n\r\nBox.type_mappings[tensor] = tensor_to_arraybox\r\nVSpace.mappings[tensor] = lambda x: ComplexArrayVSpace(x) if onp.iscomplexobj(x) else ArrayVSpace(x)\r\n'"
pennylane/numpy/wrapper.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nThis module provides the PennyLane wrapper functions for modifying NumPy,\r\nsuch that it accepts the PennyLane :class:`~.tensor` class.\r\n""""""\r\nfrom collections import Sequence\r\nimport functools\r\n\r\nfrom autograd import numpy as _np\r\n\r\nfrom .tensor import tensor\r\n\r\n\r\ndef extract_tensors(x):\r\n    """"""Iterate through an iterable, and extract any PennyLane\r\n    tensors that appear.\r\n    """"""\r\n    if isinstance(x, tensor):\r\n        # If the item is a tensor, return it\r\n        yield x\r\n    elif isinstance(x, Sequence) and not isinstance(x, (str, bytes)):\r\n        # If the item is a sequence, recursively look through its\r\n        # elements for tensors.\r\n        # NOTE: we choose to branch on Sequence here and not Iterable,\r\n        # as NumPy arrays are not Sequences.\r\n        for item in x:\r\n            yield from extract_tensors(item)\r\n\r\n\r\ndef tensor_wrapper(obj):\r\n    """"""Decorator that wraps callable objects and classes so that they both accept\r\n    a ``requires_grad`` keyword argument, as well as returning a PennyLane\r\n    :class:`~.tensor`.\r\n\r\n    Only if the decorated object returns an ``ndarray`` is the\r\n    output converted to a :class:`~.tensor`; this avoids superfluous conversion\r\n    of scalars and other native-Python types.\r\n\r\n    Args:\r\n        obj: a callable object or class\r\n    """"""\r\n\r\n    @functools.wraps(obj)\r\n    def _wrapped(*args, **kwargs):\r\n        """"""Wrapped NumPy function""""""\r\n\r\n        tensor_kwargs = {}\r\n\r\n        if ""requires_grad"" in kwargs:\r\n            tensor_kwargs[""requires_grad""] = kwargs.pop(""requires_grad"")\r\n        else:\r\n            tensor_args = list(extract_tensors(args))\r\n\r\n            if tensor_args:\r\n                # Unless the user specifies otherwise, if all tensors in the argument\r\n                # list are non-trainable, the output is also non-trainable.\r\n                # Equivalently: if any tensor is trainable, the output is also trainable.\r\n                # NOTE: Use of Python\'s ``any`` results in an infinite recursion,\r\n                # and I\'m not sure why. Using ``np.any`` works fine.\r\n                tensor_kwargs[""requires_grad""] = _np.any([i.requires_grad for i in tensor_args])\r\n\r\n        # evaluate the original object\r\n        res = obj(*args, **kwargs)\r\n\r\n        if isinstance(res, _np.ndarray):\r\n            # only if the output of the object is a ndarray,\r\n            # then convert to a PennyLane tensor\r\n            res = tensor(res, **tensor_kwargs)\r\n\r\n        return res\r\n\r\n    return _wrapped\r\n\r\n\r\ndef wrap_arrays(old, new):\r\n    """"""Loop through an object\'s symbol table,\r\n\r\n    wrapping each function with :func:`~.tensor_wrapper`.\r\n\r\n    Args:\r\n        old (dict): The symbol table to be wrapped. Note that\r\n            callable classes are ignored; only function are wrapped.\r\n        new (dict): The symbol table that contains the wrapped values.\r\n    """"""\r\n    for name, obj in old.items():\r\n        if callable(obj) and not isinstance(obj, type):\r\n            new[name] = tensor_wrapper(obj)\r\n'"
pennylane/ops/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=too-few-public-methods,function-redefined\n\n""""""\nThis module contains core quantum operations supported by PennyLane -\nsuch as gates, state preparations and observables.\n""""""\nimport numpy as np\n\nfrom pennylane.operation import AnyWires, Observable, CVObservable\n\nfrom .cv import *\nfrom .qubit import *\n\nfrom .cv import __all__ as _cv__all__\nfrom .cv import ops as _cv__ops__\nfrom .cv import obs as _cv__obs__\n\nfrom .qubit import __all__ as _qubit__all__\nfrom .qubit import ops as _qubit__ops__\nfrom .qubit import obs as _qubit__obs__\n\n\nclass Identity(CVObservable):\n    r""""""pennylane.Identity(wires)\n    The identity observable :math:`\\I`.\n\n    The expectation of this observable\n\n    .. math::\n        E[\\I] = \\text{Tr}(\\I \\rho)\n\n    corresponds to the trace of the quantum state, which in exact\n    simulators should always be equal to 1.\n    """"""\n    num_wires = AnyWires\n    num_params = 0\n    par_domain = None\n    grad_method = None\n\n    ev_order = 1\n    eigvals = np.array([1, 1])\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return cls.eigvals\n\n    @classmethod\n    def _matrix(cls, *params):\n        return np.eye(2)\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        return np.array([1, 0, 0])\n\n    def diagonalizing_gates(self):\n        return []\n\n\n__all__ = _cv__all__ + _qubit__all__ + [""Identity""]\n__all_ops__ = list(_cv__ops__ | _qubit__ops__)\n__all_obs__ = list(_cv__obs__ | _qubit__obs__) + [""Identity""]\n'"
pennylane/ops/cv.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nThis module contains the available built-in continuous-variable\nquantum operations supported by PennyLane, as well as their conventions.\n\n.. todo:: Add gradient recipes for Gaussian state preparations\n\n.. todo::\n\n   The gradient computation assumes all parameters are real (floats), some\n   docstrings here allow complex or even array parameter values. This includes\n   :class:`~.DisplacedSqueezedState` and :class:`~.CatState`.\n\n   Possible solution: disallow such operations to depend on free parameters,\n   this way they won\'t be differentiated.\n\n.. note::\n\n   For the Heisenberg matrix representation of CV operations, we use the ordering\n   :math:`(\\hat{\\mathbb{1}}, \\hat{x}, \\hat{p})` for single modes\n   and :math:`(\\hat{\\mathbb{1}}, \\hat{x}_1, \\hat{p}_2, \\hat{x}_1,\\hat{p}_2)` for two modes .\n""""""\n# As the qubit based ``decomposition``, ``_matrix``, ``diagonalizing_gates``\n# abstract methods are not defined in the CV case, disabling the related check\n# pylint: disable=abstract-method\nimport math\nimport numpy as np\nfrom scipy.linalg import block_diag\n\nfrom pennylane.operation import AnyWires, CVOperation, CVObservable\n\n\ndef _rotation(phi, bare=False):\n    r""""""Utility function, returns the Heisenberg transformation of a phase rotation gate.\n\n    The transformation matrix returned is:\n\n    .. math:: M = \\begin{bmatrix}\n        1 & 0 & 0\\\\\n        0 & \\cos\\phi & -\\sin\\phi\\\\\n        0 & \\sin\\phi & \\cos\\phi\n        \\end{bmatrix}\n\n    Args:\n        phi (float): rotation angle.\n        bare (bool): if True, return a simple 2d rotation matrix\n\n    Returns:\n        array[float]: transformation matrix\n    """"""\n    c = math.cos(phi)\n    s = math.sin(phi)\n    temp = np.array([[c, -s], [s, c]])\n    if bare:\n        return temp\n    return block_diag(1, temp)  # pylint: disable=no-member\n\n\nclass Rotation(CVOperation):\n    r""""""pennylane.Rotation(phi, wires)\n    Phase space rotation.\n\n    .. math::\n        R(\\phi) = \\exp\\left(i \\phi \\ad \\a\\right)=\\exp\\left(i \\frac{\\phi}{2}\n        \\left(\\frac{\\x^2+  \\p^2}{\\hbar}-\\I\\right)\\right).\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{dr}f(R(r)) = \\frac{1}{2} \\left[f(R(\\phi+\\pi/2)) - f(R(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`R(r)`.\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n        1 & 0 & 0\\\\\n        0 & \\cos\\phi & -\\sin\\phi\\\\\n        0 & \\sin\\phi & \\cos\\phi\n        \\end{bmatrix}\n\n    Args:\n        phi (float): the rotation angle\n    """"""\n    num_wires = 1\n    num_params = 1\n    par_domain = ""R""\n    grad_method = ""A""\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        return _rotation(p[0])\n\n\nclass Squeezing(CVOperation):\n    r""""""pennylane.Squeezing(r, phi, wires)\n    Phase space squeezing.\n\n    .. math::\n        S(z) = \\exp\\left(\\frac{1}{2}(z^* \\a^2 -z {\\a^\\dagger}^2)\\right).\n\n    where :math:`z = r e^{i\\phi}`.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 2\n    * Gradient recipe: :math:`\\frac{d}{dr}f(S(r,\\phi)) = \\frac{1}{2\\sinh s} \\left[f(S(r+s, \\phi)) - f(S(r-s, \\phi))\\right]`,\n      where :math:`s` is an arbitrary real number (:math:`0.1` by default) and\n      :math:`f` is an expectation value depending on :math:`S(r,\\phi)`.\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n        1 & 0 & 0 \\\\\n        0 & \\cosh r - \\cos\\phi \\sinh r & -\\sin\\phi\\sinh r \\\\\n        0 & -\\sin\\phi\\sinh r & \\cosh r+\\cos\\phi\\sinh r\n        \\end{bmatrix}\n\n    Args:\n        r (float): squeezing amount\n        phi (float): squeezing phase angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 2\n    par_domain = ""R""\n    grad_method = ""A""\n\n    shift = 0.1\n    grad_recipe = [(0.5 / math.sinh(shift), shift), None]\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        R = _rotation(p[1] / 2)\n        return R @ np.diag([1, math.exp(-p[0]), math.exp(p[0])]) @ R.T\n\n\nclass Displacement(CVOperation):\n    r""""""pennylane.Displacement(a, phi, wires)\n    Phase space displacement.\n\n    .. math::\n       D(a,\\phi) = D(\\alpha) = \\exp(\\alpha \\ad -\\alpha^* \\a)\n       = \\exp\\left(-i\\sqrt{\\frac{2}{\\hbar}}(\\re(\\alpha) \\hat{p} -\\im(\\alpha) \\hat{x})\\right).\n\n    where :math:`\\alpha = ae^{i\\phi}` has magnitude :math:`a\\geq 0` and phase :math:`\\phi`.\n    The result of applying a displacement to the vacuum is a coherent state\n    :math:`D(\\alpha)\\ket{0} = \\ket{\\alpha}`.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 2\n    * Gradient recipe: :math:`\\frac{d}{da}f(D(a,\\phi)) = \\frac{1}{2s} \\left[f(D(a+s, \\phi)) - f(D(a-s, \\phi))\\right]`,\n      where :math:`s` is an arbitrary real number (:math:`0.1` by default) and\n      :math:`f` is an expectation value depending on :math:`D(a,\\phi)`.\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix} 1 & 0 & 0 \\\\ 2a\\cos\\phi & 1 & 0 \\\\ 2a\\sin\\phi & 0 & 1\\end{bmatrix}\n\n    Args:\n        a (float): displacement magnitude :math:`a=|\\alpha|`\n        phi (float): phase angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 2\n    par_domain = ""R""\n    grad_method = ""A""\n\n    shift = 0.1\n    grad_recipe = [(0.5 / shift, shift), None]\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        c = math.cos(p[1])\n        s = math.sin(p[1])\n        scale = 2  # sqrt(2 * hbar)\n        return np.array([[1, 0, 0], [scale * c * p[0], 1, 0], [scale * s * p[0], 0, 1]])\n\n\nclass Beamsplitter(CVOperation):\n    r""""""pennylane.Beamsplitter(theta, phi, wires)\n    Beamsplitter interaction.\n\n    .. math::\n        B(\\theta,\\phi) = \\exp\\left(\\theta (e^{i \\phi} \\a \\hat{b}^\\dagger -e^{-i \\phi}\\ad \\hat{b}) \\right).\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 2\n    * Gradient recipe: :math:`\\frac{d}{d \\theta}f(B(\\theta,\\phi)) = \\frac{1}{2} \\left[f(B(\\theta+\\pi/2, \\phi)) - f(B(\\theta-\\pi/2, \\phi))\\right]`\n      where :math:`f` is an expectation value depending on :math:`B(\\theta,\\phi)`.\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n            1 & 0 & 0 & 0 & 0\\\\\n            0 & \\cos\\theta & 0 & -\\cos\\phi\\sin\\theta & -\\sin\\phi\\sin\\theta \\\\\n            0 & 0 & \\cos\\theta & \\sin\\phi\\sin\\theta & -\\cos\\phi\\sin\\theta\\\\\n            0 & \\cos\\phi\\sin\\theta & -\\sin\\phi\\sin\\theta & \\cos\\theta & 0\\\\\n            0 & \\sin\\phi\\sin\\theta & \\cos\\phi\\sin\\theta & 0 & \\cos\\theta\n        \\end{bmatrix}\n\n    Args:\n        theta (float): Transmittivity angle :math:`\\theta`. The transmission amplitude\n            of the beamsplitter is :math:`t = \\cos(\\theta)`.\n            The value :math:`\\theta=\\pi/4` gives the 50-50 beamsplitter.\n        phi (float): Phase angle :math:`\\phi`. The reflection amplitude of the\n            beamsplitter is :math:`r = e^{i\\phi}\\sin(\\theta)`.\n            The value :math:`\\phi = \\pi/2` gives the symmetric beamsplitter.\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 2\n    num_wires = 2\n    par_domain = ""R""\n    grad_method = ""A""\n\n    # For the beamsplitter, both parameters are rotation-like\n    @staticmethod\n    def _heisenberg_rep(p):\n        R = _rotation(p[1], bare=True)\n        c = math.cos(p[0])\n        s = math.sin(p[0])\n        U = c * np.eye(5)\n        U[0, 0] = 1\n        U[1:3, 3:5] = -s * R.T\n        U[3:5, 1:3] = s * R\n        return U\n\n\nclass TwoModeSqueezing(CVOperation):\n    r""""""pennylane.TwoModeSqueezing(r, phi, wires)\n    Phase space two-mode squeezing.\n\n    .. math::\n        S_2(z) = \\exp\\left(z^* \\a \\hat{b} -z \\ad \\hat{b}^\\dagger \\right)\n        = \\exp\\left(r (e^{-i\\phi} \\a\\hat{b} -e^{i\\phi} \\ad \\hat{b}^\\dagger \\right).\n\n    where :math:`z = r e^{i\\phi}`.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 2\n    * Gradient recipe: :math:`\\frac{d}{dr}f(S_2(r,\\phi)) = \\frac{1}{2\\sinh s} \\left[f(S_2(r+s, \\phi)) - f(S_2(r-s, \\phi))\\right]`,\n      where :math:`s` is an arbitrary real number (:math:`0.1` by default) and\n      :math:`f` is an expectation value depending on :math:`S_2(r,\\phi)`.\n\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n            1 & 0 & 0 & 0 & 0 \\\\\n            0 & \\cosh r & 0 & \\sinh r \\cos \\phi & \\sinh r \\sin \\phi\\\\\n            0 & 0 & \\cosh r & \\sinh r \\sin \\phi & -\\sinh r \\cos \\phi\\\\\n            0 & \\sinh r \\cos \\phi & \\sinh r \\sin \\phi & \\cosh r & 0\\\\\n            0 & \\sinh r \\sin \\phi & -\\sinh r \\cos \\phi & 0 & \\cosh r\n        \\end{bmatrix}\n\n    Args:\n        r (float): squeezing amount\n        phi (float): squeezing phase angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 2\n    num_wires = 2\n    par_domain = ""R""\n\n    grad_method = ""A""\n    shift = 0.1\n    grad_recipe = [(0.5 / math.sinh(shift), shift), None]\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        R = _rotation(p[1], bare=True)\n\n        S = math.sinh(p[0]) * np.diag([1, -1])\n        U = math.cosh(p[0]) * np.identity(5)\n\n        U[0, 0] = 1\n        U[1:3, 3:5] = S @ R.T\n        U[3:5, 1:3] = S @ R.T\n        return U\n\n\nclass QuadraticPhase(CVOperation):\n    r""""""pennylane.QuadraticPhase(s, wires)\n    Quadratic phase shift.\n\n    .. math::\n        P(s) = e^{i \\frac{s}{2} \\hat{x}^2/\\hbar}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{ds}f(P(s)) = \\frac{1}{2 a} \\left[f(P(s+a)) - f(P(s-a))\\right]`,\n      where :math:`a` is an arbitrary real number (:math:`0.1` by default) and\n      :math:`f` is an expectation value depending on :math:`P(s)`.\n\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n            1 & 0 & 0 \\\\\n            0 & 1 & 0 \\\\\n            0 & s & 1 \\\\\n        \\end{bmatrix}\n\n    Args:\n        s (float): parameter\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n\n    grad_method = ""A""\n    shift = 0.1\n    grad_recipe = [(0.5 / shift, shift)]\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        U = np.identity(3)\n        U[2, 1] = p[0]\n        return U\n\n\nclass ControlledAddition(CVOperation):\n    r""""""pennylane.ControlledAddition(s, wires)\n    Controlled addition operation.\n\n    .. math::\n           \\text{CX}(s) = \\int dx \\ket{x}\\bra{x} \\otimes D\\left({\\frac{1}{\\sqrt{2\\hbar}}}s x\\right)\n           = e^{-i s \\: \\hat{x} \\otimes \\hat{p}/\\hbar}.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{ds}f(\\text{CX}(s)) = \\frac{1}{2 a} \\left[f(\\text{CX}(s+a)) - f(\\text{CX}(s-a))\\right]`,\n      where :math:`a` is an arbitrary real number (:math:`0.1` by default) and\n      :math:`f` is an expectation value depending on :math:`\\text{CX}(s)`.\n\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n            1 & 0 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0 & 0 \\\\\n            0 & 0 & 1 & 0 & -s \\\\\n            0 & s & 0 & 1 & 0 \\\\\n            0 & 0 & 0 & 0 & 1\n        \\end{bmatrix}\n\n    Args:\n        s (float): addition multiplier\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 2\n    num_params = 1\n    par_domain = ""R""\n\n    grad_method = ""A""\n    shift = 0.1\n    grad_recipe = [(0.5 / shift, shift)]\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        U = np.identity(5)\n        U[2, 4] = -p[0]\n        U[3, 1] = p[0]\n        return U\n\n\nclass ControlledPhase(CVOperation):\n    r""""""pennylane.ControlledPhase(s, wires)\n    Controlled phase operation.\n\n    .. math::\n           \\text{CZ}(s) =  \\iint dx dy \\: e^{i sxy/\\hbar} \\ket{x,y}\\bra{x,y}\n           = e^{i s \\: \\hat{x} \\otimes \\hat{x}/\\hbar}.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{ds}f(\\text{CZ}(s)) = \\frac{1}{2 a} \\left[f(\\text{CZ}(s+a)) - f(\\text{CZ}(s-a))\\right]`,\n      where :math:`a` is an arbitrary real number (:math:`0.1` by default) and\n      :math:`f` is an expectation value depending on :math:`\\text{CZ}(s)`.\n\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n            1 & 0 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0 & 0 \\\\\n            0 & 0 & 1 & s & 0 \\\\\n            0 & 0 & 0 & 1 & 0 \\\\\n            0 & s & 0 & 0 & 1\n        \\end{bmatrix}\n\n    Args:\n        s (float):  phase shift multiplier\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 2\n    num_params = 1\n    par_domain = ""R""\n\n    grad_method = ""A""\n    shift = 0.1\n    grad_recipe = [(0.5 / shift, shift)]\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        U = np.identity(5)\n        U[2, 3] = p[0]\n        U[4, 1] = p[0]\n        return U\n\n\nclass Kerr(CVOperation):\n    r""""""pennylane.Kerr(kappa, wires)\n    Kerr interaction.\n\n    .. math::\n        K(\\kappa) = e^{i \\kappa \\hat{n}^2}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        kappa (float): parameter\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""F""\n\n\nclass CrossKerr(CVOperation):\n    r""""""pennylane.CrossKerr(kappa, wires)\n    Cross-Kerr interaction.\n\n    .. math::\n        CK(\\kappa) = e^{i \\kappa \\hat{n}_1\\hat{n}_2}.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 1\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        kappa (float): parameter\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 2\n    par_domain = ""R""\n    grad_method = ""F""\n\n\nclass CubicPhase(CVOperation):\n    r""""""pennylane.CubicPhase(gamma, wires)\n    Cubic phase shift.\n\n    .. math::\n        V(\\gamma) = e^{i \\frac{\\gamma}{3} \\hat{x}^3/\\hbar}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        gamma (float): parameter\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""F""\n\n\nclass Interferometer(CVOperation):\n    r""""""pennylane.Interferometer(U, wires)\n    A linear interferometer transforming the bosonic operators according to\n    the unitary matrix :math:`U`.\n\n    .. note::\n\n        This operation implements a **fixed** linear interferometer given a known\n        unitary matrix.\n\n        If you instead wish to parameterize the interferometer,\n        and calculate the gradient/optimize with respect to these parameters,\n        consider instead the :func:`pennylane.template.Interferometer` template,\n        which constructs an interferometer from a combination of beamsplitters\n        and rotation gates.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 1\n    * Gradient recipe: None\n    * Heisenberg representation:\n\n      .. math:: M = \\begin{bmatrix}\n        1 & 0\\\\\n        0 & S\\\\\n        \\end{bmatrix}\n\n    where :math:`S` is the Gaussian symplectic transformation representing the interferometer.\n\n    Args:\n        U (array): A shape ``(len(wires), len(wires))`` complex unitary matrix\n        wires (Sequence[int] or int): the wires the operation acts on\n    """"""\n    num_params = 1\n    num_wires = AnyWires\n    par_domain = ""A""\n    grad_method = None\n    grad_recipe = None\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        N = len(p[0])\n        A = p[0].real\n        B = p[0].imag\n\n        rows = np.arange(2 * N).reshape(2, -1).T.flatten()\n        S = np.vstack([np.hstack([A, -B]), np.hstack([B, A])])[:, rows][rows]\n\n        M = np.eye(2 * N + 1)\n        M[1 : 2 * N + 1, 1 : 2 * N + 1] = S\n        return M\n\n\n# =============================================================================\n# State preparation\n# =============================================================================\n\n# TODO: put Heisenberg reps of state preparations in docstrings?\n\n\nclass CoherentState(CVOperation):\n    r""""""pennylane.CoherentState(a, phi, wires)\n    Prepares a coherent state.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 2\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        a (float): displacement magnitude :math:`r=|\\alpha|`\n        phi (float): phase angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 2\n    par_domain = ""R""\n    grad_method = ""F""\n\n\nclass SqueezedState(CVOperation):\n    r""""""pennylane.SqueezedState(r, phi, wires)\n    Prepares a squeezed vacuum state.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 2\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        r (float): squeezing magnitude\n        phi (float): squeezing angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 2\n    par_domain = ""R""\n    grad_method = ""F""\n\n\nclass DisplacedSqueezedState(CVOperation):\n    r""""""pennylane.DisplacedSqueezedState(a, phi_a, r, phi_r, wires)\n    Prepares a displaced squeezed vacuum state.\n\n    A displaced squeezed state is prepared by squeezing a vacuum state, and\n    then applying a displacement operator,\n\n    .. math::\n       \\ket{\\alpha,z} = D(\\alpha)\\ket{0,z} = D(\\alpha)S(z)\\ket{0},\n\n    with the displacement parameter :math:`\\alpha=ae^{i\\phi_a}` and the squeezing parameter :math:`z=re^{i\\phi_r}`.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 4\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        a (float): displacement magnitude :math:`a=|\\alpha|`\n        phi_a (float): displacement angle :math:`\\phi_a`\n        r (float): squeezing magnitude :math:`r=|z|`\n        phi_r (float): squeezing angle :math:`\\phi_r`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 4\n    par_domain = ""R""\n    grad_method = ""F""\n\n\nclass ThermalState(CVOperation):\n    r""""""pennylane.ThermalState(nbar, wires)\n    Prepares a thermal state.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        nbar (float): mean thermal population of the mode\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 1\n    par_domain = ""R""\n    grad_method = ""F""\n\n\nclass GaussianState(CVOperation):\n    r""""""pennylane.GaussianState(r, V, wires)\n    Prepare subsystems in a given Gaussian state.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 2\n    * Gradient recipe: None\n\n    Args:\n        r (array): a length :math:`2N` vector of means, of the\n            form :math:`(\\x_0,\\dots,\\x_{N-1},\\p_0,\\dots,\\p_{N-1})`\n        V (array): the :math:`2N\\times 2N` (real and positive definite) covariance matrix\n    """"""\n    num_wires = AnyWires\n    num_params = 2\n    par_domain = ""A""\n    grad_method = ""F""\n\n\nclass FockState(CVOperation):\n    r""""""pennylane.FockState(n, wires)\n    Prepares a single Fock state.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: None (not differentiable)\n\n    Args:\n        n (int): Fock state to prepare\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 1\n    par_domain = ""N""\n    grad_method = None\n\n\nclass FockStateVector(CVOperation):\n    r""""""pennylane.FockStateVector(state, wires)\n    Prepare subsystems using the given ket vector in the Fock basis.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 1\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        state (array): a single ket vector, for single mode state preparation,\n            or a multimode ket, with one array dimension per mode\n    """"""\n    num_wires = AnyWires\n    num_params = 1\n    par_domain = ""A""\n    grad_method = ""F""\n\n\nclass FockDensityMatrix(CVOperation):\n    r""""""pennylane.FockDensityMatrix(state, wires)\n    Prepare subsystems using the given density matrix in the Fock basis.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 1\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        state (array): a single mode matrix :math:`\\rho_{ij}`, or\n            a multimode tensor :math:`\\rho_{ij,kl,\\dots,mn}`, with two indices per mode\n    """"""\n    num_wires = AnyWires\n    num_params = 1\n    par_domain = ""A""\n    grad_method = ""F""\n\n\nclass CatState(CVOperation):\n    r""""""pennylane.CatState(a, phi, p, wires)\n    Prepares a cat state.\n\n    A cat state is the coherent superposition of two coherent states,\n\n    .. math::\n       \\ket{\\text{cat}(\\alpha)} = \\frac{1}{N} (\\ket{\\alpha} +e^{ip\\pi} \\ket{-\\alpha}),\n\n    where :math:`\\ket{\\pm\\alpha} = D(\\pm\\alpha)\\ket{0}` are coherent states with displacement\n    parameters :math:`\\pm\\alpha=\\pm ae^{i\\phi}` and\n    :math:`N = \\sqrt{2 (1+\\cos(p\\pi)e^{-2|\\alpha|^2})}` is the normalization factor.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 3\n    * Gradient recipe: None (uses finite difference)\n\n    Args:\n        a (float): displacement magnitude :math:`a=|\\alpha|`\n        phi (float): displacement angle :math:`\\phi`\n        p (float): parity, where :math:`p=0` corresponds to an even\n            cat state, and :math:`p=1` an odd cat state.\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 3\n    par_domain = ""R""\n    grad_method = ""F""\n\n\n# =============================================================================\n# Observables\n# =============================================================================\n\n\nclass NumberOperator(CVObservable):\n    r""""""pennylane.ops.NumberOperator(wires)\n    The photon number observable :math:`\\langle \\hat{n}\\rangle`.\n\n    The number operator is defined as\n    :math:`\\hat{n} = \\a^\\dagger \\a = \\frac{1}{2\\hbar}(\\x^2 +\\p^2) -\\I/2`.\n\n    When used with the :func:`~.expval` function, the mean\n    photon number :math:`\\braket{\\hat{n}}` is returned.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n    * Observable order: 2nd order in the quadrature operators\n    * Heisenberg representation:\n\n      .. math:: M = \\frac{1}{2\\hbar}\\begin{bmatrix}\n            -\\hbar & 0 & 0\\\\\n            0 & 1 & 0\\\\\n            0 & 0 & 1\n        \\end{bmatrix}\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 0\n    par_domain = None\n\n    ev_order = 2\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        hbar = 2\n        return np.diag([-0.5, 0.5 / hbar, 0.5 / hbar])\n\n\nclass TensorN(CVObservable):\n    r""""""pennylane.ops.TensorN(wires)\n    The tensor product of the :class:`~.NumberOperator` acting on different wires.\n\n    If a single wire is defined, returns a :class:`~.NumberOperator` instance for convenient gradient computations.\n\n    When used with the :func:`~.expval` function, the expectation value\n    :math:`\\langle \\hat{n}_{i_0} \\hat{n}_{i_1}\\dots \\hat{n}_{i_{N-1}}\\rangle`\n    for a (sub)set of modes :math:`[i_0, i_1, \\dots, i_{N-1}]` of the system is\n    returned.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n\n    .. UsageDetails::\n\n        Example for multiple modes:\n\n        >>> cv_obs = qml.TensorN(wires=[0, 1])\n        >>> cv_obs\n        TensorN(wires=[0, 1])\n        >>> cv_obs.ev_order is None\n        True\n\n        Example for a single mode (yields a :class:`~.NumberOperator`):\n\n        >>> cv_obs = qml.TensorN(wires=[1])\n        >>> cv_obs\n        NumberOperator(wires=[1])\n        >>> cv_obs.ev_order\n        2\n    """"""\n    num_wires = AnyWires\n    num_params = 0\n    par_domain = None\n    ev_order = None\n\n    def __new__(cls, *params, wires=None, do_queue=True):\n        # Custom definition for __new__ needed such that a NumberOperator can\n        # be returned when a single mode is defined\n\n        if wires is None:\n            wires = params[-1]\n            params = params[:-1]\n\n        if isinstance(wires, int) or len(wires) == 1:\n            return NumberOperator(*params, wires=wires, do_queue=do_queue)\n\n        return super().__new__(cls)\n\n\nclass X(CVObservable):\n    r""""""pennylane.ops.X(wires)\n    The position quadrature observable :math:`\\hat{x}`.\n\n    When used with the :func:`~.expval` function, the position expectation\n    value :math:`\\braket{\\hat{n}}` is returned. This corresponds to\n    the mean displacement in the phase space along the :math:`x` axis.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n    * Observable order: 1st order in the quadrature operators\n    * Heisenberg representation:\n\n      .. math:: d = [0, 1, 0]\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 0\n    par_domain = None\n\n    ev_order = 1\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        return np.array([0, 1, 0])\n\n\nclass P(CVObservable):\n    r""""""pennylane.ops.P(wires)\n    The momentum quadrature observable :math:`\\hat{p}`.\n\n    When used with the :func:`~.expval` function, the momentum expectation\n    value :math:`\\braket{\\hat{p}}` is returned. This corresponds to\n    the mean displacement in the phase space along the :math:`p` axis.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n    * Observable order: 1st order in the quadrature operators\n    * Heisenberg representation:\n\n      .. math:: d = [0, 0, 1]\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 0\n    par_domain = None\n\n    ev_order = 1\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        return np.array([0, 0, 1])\n\n\nclass QuadOperator(CVObservable):\n    r""""""pennylane.ops.QuadOperator(phi, wires)\n    The generalized quadrature observable :math:`\\x_\\phi = \\x cos\\phi+\\p\\sin\\phi`.\n\n    When used with the :func:`~.expval` function, the expectation\n    value :math:`\\braket{\\hat{\\x_\\phi}}` is returned. This corresponds to\n    the mean displacement in the phase space along axis at angle :math:`\\phi`.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Observable order: 1st order in the quadrature operators\n    * Heisenberg representation:\n\n      .. math:: d = [0, \\cos\\phi, \\sin\\phi]\n\n    Args:\n        phi (float): axis in the phase space at which to calculate\n            the generalized quadrature observable\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_wires = 1\n    num_params = 1\n    par_domain = ""R""\n\n    grad_method = ""A""\n    ev_order = 1\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        phi = p[0]\n        return np.array([0, math.cos(phi), math.sin(phi)])  # TODO check\n\n\nclass PolyXP(CVObservable):\n    r""""""pennylane.ops.PolyXP(q, wires)\n    An arbitrary second-order polynomial observable.\n\n    Represents an arbitrary observable :math:`P(\\x,\\p)` that is a second order\n    polynomial in the basis :math:`\\mathbf{r} = (\\I, \\x_0, \\p_0, \\x_1, \\p_1, \\ldots)`.\n\n    For first-order observables the representation is a real vector\n    :math:`\\mathbf{d}` such that :math:`P(\\x,\\p) = \\mathbf{d}^T \\mathbf{r}`.\n\n    For second-order observables the representation is a real symmetric\n    matrix :math:`A` such that :math:`P(\\x,\\p) = \\mathbf{r}^T A \\mathbf{r}`.\n\n    Used by :meth:`QNode._pd_analytic` for evaluating arbitrary order-2 CV expectation values.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 1\n    * Observable order: 2nd order in the quadrature operators\n    * Heisenberg representation: :math:`A`\n\n    Args:\n        q (array[float]): expansion coefficients\n    """"""\n    num_wires = AnyWires\n    num_params = 1\n    par_domain = ""A""\n\n    grad_method = ""F""\n    ev_order = 2\n\n    @staticmethod\n    def _heisenberg_rep(p):\n        return p[0]\n\n\nclass FockStateProjector(CVObservable):\n    r""""""pennylane.ops.FockStateProjector(n, wires)\n    The number state observable :math:`\\ket{n}\\bra{n}`.\n\n    Represents the non-Gaussian number state observable\n\n    .. math:: \\ket{n}\\bra{n} = \\ket{n_0, n_1, \\dots, n_P}\\bra{n_0, n_1, \\dots, n_P}\n\n    where :math:`n_i` is the occupation number of the :math:`i` th wire.\n\n    The expectation of this observable is\n\n    .. math::\n        E[\\ket{n}\\bra{n}] = \\text{Tr}(\\ket{n}\\bra{n}\\rho)\n        = \\text{Tr}(\\braketT{n}{\\rho}{n})\n        = \\braketT{n}{\\rho}{n}\n\n    corresponding to the probability of measuring the quantum state in the state\n    :math:`\\ket{n}=\\ket{n_0, n_1, \\dots, n_P}`.\n\n    .. note::\n\n        If ``expval(FockStateProjector)`` is applied to a subset of wires,\n        the unaffected wires are traced out prior to the expectation value\n        calculation.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 1\n    * Observable order: None (non-Gaussian)\n\n    Args:\n        n (array): Array of non-negative integers representing the number state\n            observable :math:`\\ket{n}\\bra{n}=\\ket{n_0, n_1, \\dots, n_P}\\bra{n_0, n_1, \\dots, n_P}`.\n\n            For example, to return the observable :math:`\\ket{0,4,2}\\bra{0,4,2}` acting on\n            wires 0, 1, and 3 of a QNode, you would call ``FockStateProjector(np.array([0, 4, 2], wires=[0, 1, 3]))``.\n\n            Note that ``len(n)==len(wires)``, and that ``len(n)`` cannot exceed the\n            total number of wires in the QNode.\n    """"""\n    num_wires = AnyWires\n    num_params = 1\n    par_domain = ""A""\n\n    grad_method = None\n    ev_order = None\n\n\nops = {\n    ""Beamsplitter"",\n    ""ControlledAddition"",\n    ""ControlledPhase"",\n    ""Displacement"",\n    ""Kerr"",\n    ""CrossKerr"",\n    ""QuadraticPhase"",\n    ""Rotation"",\n    ""Squeezing"",\n    ""TwoModeSqueezing"",\n    ""CubicPhase"",\n    ""Interferometer"",\n    ""CatState"",\n    ""CoherentState"",\n    ""FockDensityMatrix"",\n    ""DisplacedSqueezedState"",\n    ""FockState"",\n    ""FockStateVector"",\n    ""SqueezedState"",\n    ""ThermalState"",\n    ""GaussianState"",\n}\n\n\nobs = {\n    ""QuadOperator"",\n    ""NumberOperator"",\n    ""TensorN"",\n    ""P"",\n    ""X"",\n    ""PolyXP"",\n    ""FockStateProjector"",\n}\n\n\n__all__ = list(ops | obs)\n'"
pennylane/ops/qubit.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the available built-in discrete-variable\nquantum operations supported by PennyLane, as well as their conventions.\n""""""\n# pylint:disable=abstract-method,arguments-differ,protected-access\nimport math\nimport cmath\nimport functools\nimport numpy as np\n\nfrom pennylane.templates import template\nfrom pennylane.operation import AnyWires, Observable, Operation, DiagonalOperation\nfrom pennylane.templates.state_preparations import BasisStatePreparation, MottonenStatePreparation\nfrom pennylane.utils import OperationRecorder, pauli_eigs, expand\n\nINV_SQRT2 = 1 / math.sqrt(2)\n\n\nclass Hadamard(Observable, Operation):\n    r""""""Hadamard(wires)\n    The Hadamard operator\n\n    .. math:: H = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1\\\\ 1 & -1\\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 1\n    par_domain = None\n    eigvals = pauli_eigs(1)\n    matrix = np.array([[INV_SQRT2, INV_SQRT2], [INV_SQRT2, -INV_SQRT2]])\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return cls.eigvals\n\n    def diagonalizing_gates(self):\n        r""""""Rotates the specified wires such that they\n        are in the eigenbasis of the Hadamard operator.\n\n        For the Hadamard operator,\n\n        .. math:: H = U^\\dagger Z U\n\n        where :math:`U = R_y(-\\pi/4)`.\n\n        Returns:\n            list(~.Operation): A list of gates that diagonalize Hadamard in\n            the computational basis.\n        """"""\n        return [RY(-np.pi / 4, wires=self.wires)]\n\n    @staticmethod\n    def decomposition(wires):\n        decomp_ops = [\n            PhaseShift(np.pi / 2, wires=wires),\n            RX(np.pi / 2, wires=wires),\n            PhaseShift(np.pi / 2, wires=wires),\n        ]\n        return decomp_ops\n\n\nclass PauliX(Observable, Operation):\n    r""""""PauliX(wires)\n    The Pauli X operator\n\n    .. math:: \\sigma_x = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0\\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 1\n    par_domain = None\n    eigvals = pauli_eigs(1)\n    matrix = np.array([[0, 1], [1, 0]])\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return cls.eigvals\n\n    def diagonalizing_gates(self):\n        r""""""Rotates the specified wires such that they\n        are in the eigenbasis of the Pauli-X operator.\n\n        For the Pauli-X operator,\n\n        .. math:: X = H^\\dagger Z H.\n\n        Returns:\n            list(qml.Operation): A list of gates that diagonalize PauliY in the\n            computational basis.\n        """"""\n        return [Hadamard(wires=self.wires)]\n\n    @staticmethod\n    def decomposition(wires):\n        decomp_ops = [\n            PhaseShift(np.pi / 2, wires=wires),\n            RX(np.pi, wires=wires),\n            PhaseShift(np.pi / 2, wires=wires),\n        ]\n        return decomp_ops\n\n\nclass PauliY(Observable, Operation):\n    r""""""PauliY(wires)\n    The Pauli Y operator\n\n    .. math:: \\sigma_y = \\begin{bmatrix} 0 & -i \\\\ i & 0\\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 1\n    par_domain = None\n    eigvals = pauli_eigs(1)\n    matrix = np.array([[0, -1j], [1j, 0]])\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return cls.eigvals\n\n    def diagonalizing_gates(self):\n        r""""""Rotates the specified wires such that they\n        are in the eigenbasis of PauliY.\n\n        For the Pauli-Y observable,\n\n        .. math:: Y = U^\\dagger Z U\n\n        where :math:`U=HSZ`.\n\n        Returns:\n            list(~.Operation): A list of gates that diagonalize PauliY in the\n                computational basis.\n        """"""\n        return [PauliZ(wires=self.wires), S(wires=self.wires), Hadamard(wires=self.wires)]\n\n    @staticmethod\n    def decomposition(wires):\n        decomp_ops = [\n            PhaseShift(np.pi / 2, wires=wires),\n            RY(np.pi, wires=wires),\n            PhaseShift(np.pi / 2, wires=wires),\n        ]\n        return decomp_ops\n\n\nclass PauliZ(Observable, DiagonalOperation):\n    r""""""PauliZ(wires)\n    The Pauli Z operator\n\n    .. math:: \\sigma_z = \\begin{bmatrix} 1 & 0 \\\\ 0 & -1\\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 1\n    par_domain = None\n    eigvals = pauli_eigs(1)\n    matrix = np.array([[1, 0], [0, -1]])\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return cls.eigvals\n\n    def diagonalizing_gates(self):\n        return []\n\n    @staticmethod\n    def decomposition(wires):\n        decomp_ops = [PhaseShift(np.pi, wires=wires)]\n        return decomp_ops\n\n\nclass S(DiagonalOperation):\n    r""""""S(wires)\n    The single-qubit phase gate\n\n    .. math:: S = \\begin{bmatrix}\n                1 & 0 \\\\\n                0 & i\n            \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 1\n    par_domain = None\n\n    @classmethod\n    def _matrix(cls, *params):\n        return np.array([[1, 0], [0, 1j]])\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return np.array([1, 1j])\n\n    @staticmethod\n    def decomposition(wires):\n        decomp_ops = [PhaseShift(np.pi / 2, wires=wires)]\n        return decomp_ops\n\n\nclass T(DiagonalOperation):\n    r""""""T(wires)\n    The single-qubit T gate\n\n    .. math:: T = \\begin{bmatrix}\n                1 & 0 \\\\\n                0 & e^{\\frac{i\\pi}{4}}\n            \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 1\n    par_domain = None\n\n    @classmethod\n    def _matrix(cls, *params):\n        return np.array([[1, 0], [0, cmath.exp(1j * np.pi / 4)]])\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return np.array([1, cmath.exp(1j * np.pi / 4)])\n\n    @staticmethod\n    def decomposition(wires):\n        decomp_ops = [PhaseShift(np.pi / 4, wires=wires)]\n        return decomp_ops\n\n\nclass CNOT(Operation):\n    r""""""CNOT(wires)\n    The controlled-NOT operator\n\n    .. math:: CNOT = \\begin{bmatrix}\n            1 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0\\\\\n            0 & 0 & 0 & 1\\\\\n            0 & 0 & 1 & 0\n        \\end{bmatrix}.\n\n    .. note:: The first wire provided corresponds to the **control qubit**.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wires the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 2\n    par_domain = None\n    matrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])\n\n    @classmethod\n    def _matrix(cls, *params):\n        return CNOT.matrix\n\n\nclass CZ(DiagonalOperation):\n    r""""""CZ(wires)\n    The controlled-Z operator\n\n    .. math:: CZ = \\begin{bmatrix}\n            1 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0\\\\\n            0 & 0 & 1 & 0\\\\\n            0 & 0 & 0 & -1\n        \\end{bmatrix}.\n\n    .. note:: The first wire provided corresponds to the **control qubit**.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wires the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 2\n    par_domain = None\n    eigvals = np.array([1, 1, 1, -1])\n    matrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]])\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n    @classmethod\n    def _eigvals(cls, *params):\n        return cls.eigvals\n\n\nclass SWAP(Operation):\n    r""""""SWAP(wires)\n    The swap operator\n\n    .. math:: SWAP = \\begin{bmatrix}\n            1 & 0 & 0 & 0 \\\\\n            0 & 0 & 1 & 0\\\\\n            0 & 1 & 0 & 0\\\\\n            0 & 0 & 0 & 1\n        \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wires the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 2\n    par_domain = None\n    matrix = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n\nclass CSWAP(Operation):\n    r""""""CSWAP(wires)\n    The controlled-swap operator\n\n    .. math:: CSWAP = \\begin{bmatrix}\n            1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n            0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n            0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n            0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\\n            0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n            0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n            0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n        \\end{bmatrix}.\n\n    .. note:: The first wire provided corresponds to the **control qubit**.\n\n    **Details:**\n\n    * Number of wires: 3\n    * Number of parameters: 0\n\n    Args:\n        wires (Sequence[int] or int): the wires the operation acts on\n    """"""\n    num_params = 0\n    num_wires = 3\n    par_domain = None\n    matrix = np.array(\n        [\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0, 0, 0, 0],\n            [0, 0, 1, 0, 0, 0, 0, 0],\n            [0, 0, 0, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 0, 1, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n        ]\n    )\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n\nclass Toffoli(Operation):\n    r""""""Toffoli(wires)\n    Toffoli (controlled-controlled-X) gate.\n\n    .. math::\n\n        Toffoli =\n        \\begin{pmatrix}\n        1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n        0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n        0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n        0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n        0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n        0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n        0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n        0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\n        \\end{pmatrix}\n\n    **Details:**\n\n    * Number of wires: 3\n    * Number of parameters: 0\n\n    Args:\n        wires (int): the subsystem the gate acts on\n    """"""\n    num_params = 0\n    num_wires = 3\n    par_domain = None\n    matrix = np.array(\n        [\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0, 0, 0, 0],\n            [0, 0, 1, 0, 0, 0, 0, 0],\n            [0, 0, 0, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1, 0, 0, 0],\n            [0, 0, 0, 0, 0, 1, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 1, 0],\n        ]\n    )\n\n    @classmethod\n    def _matrix(cls, *params):\n        return cls.matrix\n\n\nclass RX(Operation):\n    r""""""RX(phi, wires)\n    The single qubit X rotation\n\n    .. math:: R_x(\\phi) = e^{-i\\phi\\sigma_x/2} = \\begin{bmatrix}\n                \\cos(\\phi/2) & -i\\sin(\\phi/2) \\\\\n                -i\\sin(\\phi/2) & \\cos(\\phi/2)\n            \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(R_x(\\phi)) = \\frac{1}{2}\\left[f(R_x(\\phi+\\pi/2)) - f(R_x(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`R_x(\\phi)`.\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [PauliX, -1 / 2]\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta = params[0]\n        c = math.cos(theta / 2)\n        js = 1j * math.sin(-theta / 2)\n\n        return np.array([[c, js], [js, c]])\n\n\nclass RY(Operation):\n    r""""""RY(phi, wires)\n    The single qubit Y rotation\n\n    .. math:: R_y(\\phi) = e^{-i\\phi\\sigma_y/2} = \\begin{bmatrix}\n                \\cos(\\phi/2) & -\\sin(\\phi/2) \\\\\n                \\sin(\\phi/2) & \\cos(\\phi/2)\n            \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(R_y(\\phi)) = \\frac{1}{2}\\left[f(R_y(\\phi+\\pi/2)) - f(R_y(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`R_y(\\phi)`.\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [PauliY, -1 / 2]\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta = params[0]\n        c = math.cos(theta / 2)\n        s = math.sin(theta / 2)\n\n        return np.array([[c, -s], [s, c]])\n\n\nclass RZ(DiagonalOperation):\n    r""""""RZ(phi, wires)\n    The single qubit Z rotation\n\n    .. math:: R_z(\\phi) = e^{-i\\phi\\sigma_z/2} = \\begin{bmatrix}\n                e^{-i\\phi/2} & 0 \\\\\n                0 & e^{i\\phi/2}\n            \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(R_z(\\phi)) = \\frac{1}{2}\\left[f(R_z(\\phi+\\pi/2)) - f(R_z(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`R_z(\\phi)`.\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [PauliZ, -1 / 2]\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta = params[0]\n        p = cmath.exp(-0.5j * theta)\n\n        return np.array([[p, 0], [0, p.conjugate()]])\n\n    @classmethod\n    def _eigvals(cls, *params):\n        theta = params[0]\n        p = cmath.exp(-0.5j * theta)\n\n        return np.array([p, p.conjugate()])\n\n\nclass PhaseShift(DiagonalOperation):\n    r""""""PhaseShift(phi, wires)\n    Arbitrary single qubit local phase shift\n\n    .. math:: R_\\phi(\\phi) = e^{i\\phi/2}R_z(\\phi) = \\begin{bmatrix}\n                1 & 0 \\\\\n                0 & e^{i\\phi}\n            \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(R_\\phi(\\phi)) = \\frac{1}{2}\\left[f(R_\\phi(\\phi+\\pi/2)) - f(R_\\phi(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`R_{\\phi}(\\phi)`.\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [np.array([[0, 0], [0, 1]]), 1]\n\n    @classmethod\n    def _matrix(cls, *params):\n        phi = params[0]\n        return np.array([[1, 0], [0, cmath.exp(1j * phi)]])\n\n    @classmethod\n    def _eigvals(cls, *params):\n        phi = params[0]\n        return np.array([1, cmath.exp(1j * phi)])\n\n    @staticmethod\n    def decomposition(phi, wires):\n        decomp_ops = [RZ(phi, wires=wires)]\n        return decomp_ops\n\n\nclass Rot(Operation):\n    r""""""Rot(phi, theta, omega, wires)\n    Arbitrary single qubit rotation\n\n    .. math::\n\n        R(\\phi,\\theta,\\omega) = RZ(\\omega)RY(\\theta)RZ(\\phi)= \\begin{bmatrix}\n        e^{-i(\\phi+\\omega)/2}\\cos(\\theta/2) & -e^{i(\\phi-\\omega)/2}\\sin(\\theta/2) \\\\\n        e^{-i(\\phi-\\omega)/2}\\sin(\\theta/2) & e^{i(\\phi+\\omega)/2}\\cos(\\theta/2)\n        \\end{bmatrix}.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 3\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(R(\\phi, \\theta, \\omega)) = \\frac{1}{2}\\left[f(R(\\phi+\\pi/2, \\theta, \\omega)) - f(R(\\phi-\\pi/2, \\theta, \\omega))\\right]`\n      where :math:`f` is an expectation value depending on :math:`R(\\phi, \\theta, \\omega)`.\n      This gradient recipe applies for each angle argument :math:`\\{\\phi, \\theta, \\omega\\}`.\n\n    .. note::\n\n        If the ``Rot`` gate is not supported on the targeted device, PennyLane\n        will attempt to decompose the gate into :class:`~.RZ` and :class:`~.RY` gates.\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        theta (float): rotation angle :math:`\\theta`\n        omega (float): rotation angle :math:`\\omega`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 3\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n\n    @classmethod\n    def _matrix(cls, *params):\n        phi, theta, omega = params\n        c = math.cos(theta / 2)\n        s = math.sin(theta / 2)\n\n        return np.array(\n            [\n                [cmath.exp(-0.5j * (phi + omega)) * c, -cmath.exp(0.5j * (phi - omega)) * s],\n                [cmath.exp(-0.5j * (phi - omega)) * s, cmath.exp(0.5j * (phi + omega)) * c],\n            ]\n        )\n\n    @staticmethod\n    def decomposition(phi, theta, omega, wires):\n        decomp_ops = [RZ(phi, wires=wires), RY(theta, wires=wires), RZ(omega, wires=wires)]\n        return decomp_ops\n\n\nclass MultiRZ(DiagonalOperation):\n    r""""""MultiRZ(theta, wires)\n    Arbitrary multi Z rotation.\n\n    .. math::\n\n        MultiRZ(\\theta) = \\exp(-i \\frac{\\theta}{2} Z^{\\otimes n})\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\theta}f(MultiRZ(\\theta)) = \\frac{1}{2}\\left[f(MultiRZ(\\theta +\\pi/2)) - f(MultiRZ(\\theta-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`MultiRZ(\\theta)`.\n\n    .. note::\n\n        If the ``MultiRZ`` gate is not supported on the targeted device, PennyLane\n        will decompose the gate using :class:`~.RZ` and :class:`~.CNOT` gates.\n\n    Args:\n        theta (float): rotation angle :math:`\\theta`\n        wires (Sequence[int] or int): the wires the operation acts on\n    """"""\n    num_params = 1\n    num_wires = AnyWires\n    par_domain = ""R""\n    grad_method = ""A""\n\n    @classmethod\n    def _matrix(cls, theta, n):\n        """"""Matrix representation of a MultiRZ gate.\n\n        Args:\n            theta (float): Rotation angle.\n            n (int): Number of wires the rotation acts on. This has\n                to be given explicitly in the static method as the\n                wires object is not available.\n\n        Returns:\n            array[complex]: The matrix representation\n        """"""\n        multi_Z_rot_eigs = MultiRZ._eigvals(theta, n)\n        multi_Z_rot_matrix = np.diag(multi_Z_rot_eigs)\n\n        return multi_Z_rot_matrix\n\n    @property\n    def matrix(self):\n        # Redefine the property here to pass additionally the number of wires to the ``_matrix`` method\n        if self.inverse:\n            # The matrix is diagonal, so there is no need to transpose\n            return self._matrix(*self.parameters, len(self.wires)).conj()\n\n        return self._matrix(*self.parameters, len(self.wires))\n\n    @classmethod\n    def _eigvals(cls, theta, n):\n        return np.exp(-1j * theta / 2 * pauli_eigs(n))\n\n    @property\n    def eigvals(self):\n        # Redefine the property here to pass additionally the number of wires to the ``_eigvals`` method\n        if self.inverse:\n            return self._eigvals(*self.parameters, len(self.wires)).conj()\n\n        return self._eigvals(*self.parameters, len(self.wires))\n\n    @staticmethod\n    @template\n    def decomposition(theta, wires):\n        for i in range(len(wires) - 1, 0, -1):\n            CNOT(wires=[wires[i], wires[i - 1]])\n\n        RZ(theta, wires=wires[0])\n\n        for i in range(len(wires) - 1):\n            CNOT(wires=[wires[i + 1], wires[i]])\n\n\nclass PauliRot(Operation):\n    r""""""PauliRot(theta, pauli_word, wires)\n    Arbitrary Pauli word rotation.\n\n    .. math::\n\n        RP(\\theta, P) = \\exp(-i \\frac{\\theta}{2} P)\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 2 (1 differentiable parameter)\n    * Gradient recipe: :math:`\\frac{d}{d\\theta}f(RP(\\theta)) = \\frac{1}{2}\\left[f(RP(\\theta +\\pi/2)) - f(RP(\\theta-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`RP(\\theta)`.\n\n    .. note::\n\n        If the ``PauliRot`` gate is not supported on the targeted device, PennyLane\n        will decompose the gate using :class:`~.RX`, :class:`~.Hadamard`, :class:`~.RZ`\n        and :class:`~.CNOT` gates.\n\n    Args:\n        theta (float): rotation angle :math:`\\theta`\n        pauli_word (string): the Pauli word defining the rotation\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 2\n    num_wires = AnyWires\n    do_check_domain = False\n    par_domain = ""R""\n    grad_method = ""A""\n\n    _ALLOWED_CHARACTERS = ""IXYZ""\n\n    _PAULI_CONJUGATION_MATRICES = {\n        ""X"": Hadamard._matrix(),\n        ""Y"": RX._matrix(np.pi / 2),\n        ""Z"": np.array([[1, 0], [0, 1]]),\n    }\n\n    def __init__(self, *params, wires=None, do_queue=True):\n        super().__init__(*params, wires=wires, do_queue=True)\n\n        pauli_word = params[1]\n\n        if not PauliRot._check_pauli_word(pauli_word):\n            raise ValueError(\n                \'The given Pauli word ""{}"" contains characters that are not allowed.\'\n                "" Allowed characters are I, X, Y and Z"".format(pauli_word)\n            )\n\n        if not len(pauli_word) == len(wires):\n            raise ValueError(\n                ""The given Pauli word has length {}, length {} was expected for wires {}"".format(\n                    len(pauli_word), len(wires), wires\n                )\n            )\n\n    @staticmethod\n    def _check_pauli_word(pauli_word):\n        """"""Check that the given Pauli word has correct structure.\n\n        Args:\n            pauli_word (str): Pauli word to be checked\n\n        Returns:\n            bool: Whether the Pauli word has correct structure.\n        """"""\n        return all(pauli in PauliRot._ALLOWED_CHARACTERS for pauli in pauli_word)\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta = params[0]\n        pauli_word = params[1]\n\n        if not PauliRot._check_pauli_word(pauli_word):\n            raise ValueError(\n                \'The given Pauli word ""{}"" contains characters that are not allowed.\'\n                "" Allowed characters are I, X, Y and Z"".format(pauli_word)\n            )\n\n        # We first generate the matrix excluding the identity parts and expand it afterwards.\n        # To this end, we have to store on which wires the non-identity parts act\n        non_identity_wires, non_identity_gates = zip(\n            *[(wire, gate) for wire, gate in enumerate(pauli_word) if gate != ""I""]\n        )\n\n        multi_Z_rot_matrix = MultiRZ._matrix(theta, len(non_identity_gates))\n\n        # now we conjugate with Hadamard and RX to create the Pauli string\n        conjugation_matrix = functools.reduce(\n            np.kron, [PauliRot._PAULI_CONJUGATION_MATRICES[gate] for gate in non_identity_gates],\n        )\n\n        return expand(\n            conjugation_matrix.T.conj() @ multi_Z_rot_matrix @ conjugation_matrix,\n            non_identity_wires,\n            list(range(len(pauli_word))),\n        )\n\n    @classmethod\n    def _eigvals(cls, theta, pauli_word):\n        return MultiRZ._eigvals(theta, len(pauli_word))\n\n    @staticmethod\n    @template\n    def decomposition(theta, pauli_word, wires):\n        active_wires, active_gates = zip(\n            *[(wire, gate) for wire, gate in zip(wires, pauli_word) if gate != ""I""]\n        )\n\n        for wire, gate in zip(active_wires, active_gates):\n            if gate == ""X"":\n                Hadamard(wires=[wire])\n            elif gate == ""Y"":\n                RX(np.pi / 2, wires=[wire])\n\n        MultiRZ(theta, wires=list(active_wires))\n\n        for wire, gate in zip(active_wires, active_gates):\n            if gate == ""X"":\n                Hadamard(wires=[wire])\n            elif gate == ""Y"":\n                RX(-np.pi / 2, wires=[wire])\n\n\nclass CRX(Operation):\n    r""""""CRX(phi, wires)\n    The controlled-RX operator\n\n    .. math::\n\n        \\begin{align}\n            CRX(\\phi) &= I_{1}\\otimes RZ_{2}(\\pi / 2) ~\\cdot~ I_{1}\\otimes RY_{2}(\\phi/2) ~\\cdot~ CNOT_{12} ~\\cdot~ RY_{2}(-\\phi/2) ~\\cdot~ CNOT_{12} ~\\cdot~ I_{1}\\otimes RZ_{2}(-\\pi / 2)\\notag \\\\[10pt]\n            &=\n            \\begin{bmatrix}\n            & 1 & 0 & 0 & 0 \\\\\n            & 0 & 1 & 0 & 0\\\\\n            & 0 & 0 & \\cos(\\phi/2) & -i\\sin(\\phi/2)\\\\\n            & 0 & 0 & -i\\sin(\\phi/2) & \\cos(\\phi/2)\n            \\end{bmatrix}.\n        \\end{align}\n\n    .. note:: The subscripts of the operations in the formula refer to the wires they act on, e.g., 1 corresponds to the first element in ``wires`` that is the **control qubit**.\n\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(CR_x(\\phi)) = \\frac{1}{2}\\left[f(CR_x(\\phi+\\pi/2)) - f(CR_x(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`CR_x(\\phi)`.\n\n    **Decomposition**\n\n    If the ``CRX`` gate is not supported on the targeted device, PennyLane\n    will attempt to decompose the gate into :class:`~.RZ`, :class:`~.RY`\n    and :class:`~.CNOT` gates the following way:\n\n\n    .. image:: ../../_static/crx_circuit.png\n        :align: center\n        :width: 800px\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 2\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [np.array([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]), -1 / 2]\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta = params[0]\n        c = math.cos(theta / 2)\n        js = 1j * math.sin(-theta / 2)\n\n        return np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, c, js], [0, 0, js, c]])\n\n    @staticmethod\n    def decomposition(theta, wires):\n        decomp_ops = [\n            RZ(np.pi / 2, wires=wires[1]),\n            RY(theta / 2, wires=wires[1]),\n            CNOT(wires=wires),\n            RY(-theta / 2, wires=wires[1]),\n            CNOT(wires=wires),\n            RZ(-np.pi / 2, wires=wires[1]),\n        ]\n        return decomp_ops\n\n\nclass CRY(Operation):\n    r""""""CRY(phi, wires)\n    The controlled-RY operator\n\n    .. math::\n\n        \\begin{align}\n             CRY(\\phi) &= I_{1}\\otimes RY_{2}(\\pi / 2) ~\\cdot~ CNOT_{12} ~\\cdot~ I_{1}\\otimes RY_{2}(-\\pi / 2) ~\\cdot~ CNOT_{12} \\notag \\\\[10pt]\n            &=\n        \\begin{bmatrix}\n            1 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0\\\\\n            0 & 0 & \\cos(\\phi/2) & -\\sin(\\phi/2)\\\\\n            0 & 0 & \\sin(\\phi/2) & \\cos(\\phi/2)\n        \\end{bmatrix}.\n        \\end{align}\n\n    .. note:: The subscripts of the operations in the formula refer to the wires they act on, e.g. 1 corresponds to the first element in ``wires`` that is the **control qubit**.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(CR_y(\\phi)) = \\frac{1}{2}\\left[f(CR_y(\\phi+\\pi/2)) - f(CR_y(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`CR_y(\\phi)`.\n\n    **Decomposition**\n\n    If the ``CRY`` gate is not supported on the targeted device, PennyLane\n    will attempt to decompose the gate into :class:`~.RY` and :class:`~.CNOT` gates the following way:\n\n    .. image:: ../../_static/cry_circuit.png\n        :align: center\n        :width: 650px\n\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 2\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [np.array([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, -1j], [0, 0, 1j, 0]]), -1 / 2]\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta = params[0]\n        c = math.cos(theta / 2)\n        s = math.sin(theta / 2)\n\n        return np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, c, -s], [0, 0, s, c]])\n\n    @staticmethod\n    def decomposition(theta, wires):\n        decomp_ops = [\n            RY(theta / 2, wires=wires[1]),\n            CNOT(wires=wires),\n            RY(-theta / 2, wires=wires[1]),\n            CNOT(wires=wires),\n        ]\n        return decomp_ops\n\n\nclass CRZ(DiagonalOperation):\n    r""""""CRZ(phi, wires)\n    The controlled-RZ operator\n\n    .. math::\n\n        \\begin{align}\n             CRZ(\\phi) &= I_{1}\\otimes PhaseShift_{2}(\\pi / 2) ~\\cdot~ CNOT_{12} ~\\cdot~ I_{1}\\otimes PhaseShift_{2}(-\\pi / 2) ~\\cdot~ CNOT_{12} \\notag \\\\[10pt]\n            &=\n         \\begin{bmatrix}\n            1 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0\\\\\n            0 & 0 & e^{-i\\phi/2} & 0\\\\\n            0 & 0 & 0 & e^{i\\phi/2}\n        \\end{bmatrix}.\n        \\end{align}\n\n\n    .. note:: The subscripts of the operations in the formula refer to the wires they act on, e.g. 1 corresponds to the first element in ``wires`` that is the **control qubit**.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(CR_z(\\phi)) = \\frac{1}{2}\\left[f(CR_z(\\phi+\\pi/2)) - f(CR_z(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`CR_z(\\phi)`.\n\n    **Decomposition**\n\n    If the ``CRZ`` gate is not supported on the targeted device, PennyLane\n    will attempt to decompose the gate into :class:`~.PhaseShift` and :class:`~.CNOT` gates the following way:\n\n    .. image:: ../../_static/crz_circuit.png\n        :align: center\n        :width: 650px\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 2\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [np.array([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]]), -1 / 2]\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta = params[0]\n        return np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, cmath.exp(-0.5j * theta), 0],\n                [0, 0, 0, cmath.exp(0.5j * theta)],\n            ]\n        )\n\n    @classmethod\n    def _eigvals(cls, *params):\n        theta = params[0]\n        return np.array([1, 1, cmath.exp(-0.5j * theta), cmath.exp(0.5j * theta),])\n\n    @staticmethod\n    def decomposition(lam, wires):\n        decomp_ops = [\n            PhaseShift(lam / 2, wires=wires[1]),\n            CNOT(wires=wires),\n            PhaseShift(-lam / 2, wires=wires[1]),\n            CNOT(wires=wires),\n        ]\n        return decomp_ops\n\n\nclass CRot(Operation):\n    r""""""CRot(phi, theta, omega, wires)\n    The controlled-Rot operator\n\n    .. math:: CR(\\phi, \\theta, \\omega) = \\begin{bmatrix}\n            1 & 0 & 0 & 0 \\\\\n            0 & 1 & 0 & 0\\\\\n            0 & 0 & e^{-i(\\phi+\\omega)/2}\\cos(\\theta/2) & -e^{i(\\phi-\\omega)/2}\\sin(\\theta/2)\\\\\n            0 & 0 & e^{-i(\\phi-\\omega)/2}\\sin(\\theta/2) & e^{i(\\phi+\\omega)/2}\\cos(\\theta/2)\n        \\end{bmatrix}.\n\n    .. note:: The first wire provided corresponds to the **control qubit**.\n\n    **Details:**\n\n    * Number of wires: 2\n    * Number of parameters: 3\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(CR(\\phi, \\theta, \\omega)) = \\frac{1}{2}\\left[f(CR(\\phi+\\pi/2, \\theta, \\omega)) - f(CR(\\phi-\\pi/2, \\theta, \\omega))\\right]`\n      where :math:`f` is an expectation value depending on :math:`CR(\\phi, \\theta, \\omega)`.\n      This gradient recipe applies for each angle argument :math:`\\{\\phi, \\theta, \\omega\\}`.\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        theta (float): rotation angle :math:`\\theta`\n        omega (float): rotation angle :math:`\\omega`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 3\n    num_wires = 2\n    par_domain = ""R""\n    grad_method = ""A""\n\n    @classmethod\n    def _matrix(cls, *params):\n        phi, theta, omega = params\n        c = math.cos(theta / 2)\n        s = math.sin(theta / 2)\n\n        return np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, cmath.exp(-0.5j * (phi + omega)) * c, -cmath.exp(0.5j * (phi - omega)) * s],\n                [0, 0, cmath.exp(-0.5j * (phi - omega)) * s, cmath.exp(0.5j * (phi + omega)) * c],\n            ]\n        )\n\n\nclass U1(Operation):\n    r""""""U1(phi)\n    U1 gate.\n\n    .. math:: U_1(\\phi) = e^{i\\phi/2}R_z(\\phi) = \\begin{bmatrix}\n                1 & 0 \\\\\n                0 & e^{i\\phi}\n            \\end{bmatrix}.\n\n    .. note::\n\n        The ``U1`` gate is an alias for the phase shift operation :class:`~.PhaseShift`.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 1\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(U_1(\\phi)) = \\frac{1}{2}\\left[f(U_1(\\phi+\\pi/2)) - f(U_1(\\phi-\\pi/2))\\right]`\n      where :math:`f` is an expectation value depending on :math:`U_1(\\phi)`.\n\n    Args:\n        phi (float): rotation angle :math:`\\phi`\n        wires (Sequence[int] or int): the wire the operation acts on\n    """"""\n    num_params = 1\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n    generator = [np.array([[0, 0], [0, 1]]), 1]\n\n    @classmethod\n    def _matrix(cls, *params):\n        phi = params[0]\n        return np.array([[1, 0], [0, cmath.exp(1j * phi)]])\n\n    @staticmethod\n    def decomposition(phi, wires):\n        return [PhaseShift(phi, wires=wires)]\n\n\nclass U2(Operation):\n    r""""""U2(phi, lambda, wires)\n    U2 gate.\n\n    .. math::\n\n        U_2(\\phi, \\lambda) = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & -\\exp(i \\lambda)\n        \\\\ \\exp(i \\phi) & \\exp(i (\\phi + \\lambda)) \\end{bmatrix}\n\n    The :math:`U_2` gate is related to the single-qubit rotation :math:`R` (:class:`Rot`) and the\n    :math:`R_\\phi` (:class:`PhaseShift`) gates via the following relation:\n\n    .. math::\n\n        U_2(\\phi, \\lambda) = R_\\phi(\\phi+\\lambda) R(\\lambda,\\pi/2,-\\lambda)\n\n    .. note::\n\n        If the ``U2`` gate is not supported on the targeted device, PennyLane\n        will attempt to decompose the gate into :class:`~.Rot` and :class:`~.PhaseShift` gates.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 2\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(U_2(\\phi, \\lambda)) = \\frac{1}{2}\\left[f(U_2(\\phi+\\pi/2, \\lambda)) - f(U_2(\\phi-\\pi/2, \\lambda))\\right]`\n      where :math:`f` is an expectation value depending on :math:`U_2(\\phi, \\lambda)`.\n      This gradient recipe applies for each angle argument :math:`\\{\\phi, \\lambda\\}`.\n\n    Args:\n        phi (float): azimuthal angle :math:`\\phi`\n        lambda (float): quantum phase :math:`\\lambda`\n        wires (Sequence[int] or int): the subsystem the gate acts on\n    """"""\n    num_params = 2\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n\n    @classmethod\n    def _matrix(cls, *params):\n        phi, lam = params\n        return INV_SQRT2 * np.array(\n            [[1, -cmath.exp(1j * lam)], [cmath.exp(1j * phi), cmath.exp(1j * (phi + lam))]]\n        )\n\n    @staticmethod\n    def decomposition(phi, lam, wires):\n        decomp_ops = [\n            Rot(lam, np.pi / 2, -lam, wires=wires),\n            PhaseShift(lam, wires=wires),\n            PhaseShift(phi, wires=wires),\n        ]\n        return decomp_ops\n\n\nclass U3(Operation):\n    r""""""U3(theta, phi, lambda, wires)\n    Arbitrary single qubit unitary.\n\n    .. math::\n\n        U_3(\\theta, \\phi, \\lambda) = \\begin{bmatrix} \\cos(\\theta/2) & -\\exp(i \\lambda)\\sin(\\theta/2) \\\\\n        \\exp(i \\phi)\\sin(\\theta/2) & \\exp(i (\\phi + \\lambda))\\cos(\\theta/2) \\end{bmatrix}\n\n    The :math:`U_3` gate is related to the single-qubit rotation :math:`R` (:class:`Rot`) and the\n    :math:`R_\\phi` (:class:`PhaseShift`) gates via the following relation:\n\n    .. math::\n\n        U_3(\\theta, \\phi, \\lambda) = R_\\phi(\\phi+\\lambda) R(\\lambda,\\theta,-\\lambda)\n\n    .. note::\n\n        If the ``U3`` gate is not supported on the targeted device, PennyLane\n        will attempt to decompose the gate into :class:`~.PhaseShift` and :class:`~.Rot` gates.\n\n    **Details:**\n\n    * Number of wires: 1\n    * Number of parameters: 3\n    * Gradient recipe: :math:`\\frac{d}{d\\phi}f(U_3(\\theta, \\phi, \\lambda)) = \\frac{1}{2}\\left[f(U_3(\\theta+\\pi/2, \\phi, \\lambda)) - f(U_3(\\theta-\\pi/2, \\phi, \\lambda))\\right]`\n      where :math:`f` is an expectation value depending on :math:`U_3(\\theta, \\phi, \\lambda)`.\n      This gradient recipe applies for each angle argument :math:`\\{\\theta, \\phi, \\lambda\\}`.\n\n    Args:\n        theta (float): polar angle :math:`\\theta`\n        phi (float): azimuthal angle :math:`\\phi`\n        lambda (float): quantum phase :math:`\\lambda`\n        wires (Sequence[int] or int): the subsystem the gate acts on\n    """"""\n    num_params = 3\n    num_wires = 1\n    par_domain = ""R""\n    grad_method = ""A""\n\n    @classmethod\n    def _matrix(cls, *params):\n        theta, phi, lam = params\n        c = math.cos(theta / 2)\n        s = math.sin(theta / 2)\n\n        return np.array(\n            [\n                [c, -s * cmath.exp(1j * lam)],\n                [s * cmath.exp(1j * phi), c * cmath.exp(1j * (phi + lam))],\n            ]\n        )\n\n    @staticmethod\n    def decomposition(theta, phi, lam, wires):\n        decomp_ops = [\n            Rot(lam, theta, -lam, wires=wires),\n            PhaseShift(lam, wires=wires),\n            PhaseShift(phi, wires=wires),\n        ]\n        return decomp_ops\n\n\n# =============================================================================\n# Arbitrary operations\n# =============================================================================\n\n\nclass QubitUnitary(Operation):\n    r""""""QubitUnitary(U, wires)\n    Apply an arbitrary fixed unitary matrix.\n\n    **Details:**\n\n    * Number of wires: Any (the operation can act on any number of wires)\n    * Number of parameters: 1\n    * Gradient recipe: None\n\n    Args:\n        U (array[complex]): square unitary matrix\n        wires (Sequence[int] or int): the wire(s) the operation acts on\n    """"""\n    num_params = 1\n    num_wires = AnyWires\n    par_domain = ""A""\n    grad_method = None\n\n    @classmethod\n    def _matrix(cls, *params):\n        U = np.asarray(params[0])\n\n        if U.shape[0] != U.shape[1]:\n            raise ValueError(""Operator must be a square matrix."")\n\n        if not np.allclose(U @ U.conj().T, np.identity(U.shape[0])):\n            raise ValueError(""Operator must be unitary."")\n\n        return U\n\n\nclass DiagonalQubitUnitary(DiagonalOperation):\n    r""""""DiagonalQubitUnitary(D, wires)\n    Apply an arbitrary fixed diagonal unitary matrix.\n\n    **Details:**\n\n    * Number of wires: Any (the operation can act on any number of wires)\n    * Number of parameters: 1\n    * Gradient recipe: None\n\n    Args:\n        D (array[complex]): diagonal of unitary matrix\n        wires (Sequence[int] or int): the wire(s) the operation acts on\n    """"""\n    num_params = 1\n    num_wires = AnyWires\n    par_domain = ""A""\n    grad_method = None\n\n    @classmethod\n    def _eigvals(cls, *params):\n        D = np.asarray(params[0])\n\n        if not np.allclose(D * D.conj(), np.ones_like(D)):\n            raise ValueError(""Operator must be unitary."")\n\n        return D\n\n    @staticmethod\n    def decomposition(D, wires):\n        return [QubitUnitary(np.diag(D), wires=wires)]\n\n\n# =============================================================================\n# State preparation\n# =============================================================================\n\n\nclass BasisState(Operation):\n    r""""""BasisState(n, wires)\n    Prepares a single computational basis state.\n\n    **Details:**\n\n    * Number of wires: Any (the operation can act on any number of wires)\n    * Number of parameters: 1\n    * Gradient recipe: None (integer parameters not supported)\n\n    .. note::\n\n        If the ``BasisState`` operation is not supported natively on the\n        target device, PennyLane will attempt to decompose the operation\n        into :class:`~.PauliX` operations.\n\n    Args:\n        n (array): prepares the basis state :math:`\\ket{n}`, where ``n`` is an\n            array of integers from the set :math:`\\{0, 1\\}`, i.e.,\n            if ``n = np.array([0, 1, 0])``, prepares the state :math:`|010\\rangle`.\n        wires (Sequence[int] or int): the wire(s) the operation acts on\n    """"""\n    num_params = 1\n    num_wires = AnyWires\n    par_domain = ""A""\n    grad_method = None\n\n    @staticmethod\n    def decomposition(n, wires):\n        with OperationRecorder() as rec:\n            BasisStatePreparation(n, wires)\n\n        return rec.queue\n\n\nclass QubitStateVector(Operation):\n    r""""""QubitStateVector(state, wires)\n    Prepare subsystems using the given ket vector in the computational basis.\n\n    **Details:**\n\n    * Number of wires: Any (the operation can act on any number of wires)\n    * Number of parameters: 1\n    * Gradient recipe: None\n\n    .. note::\n\n        If the ``QubitStateVector`` operation is not supported natively on the\n        target device, PennyLane will attempt to decompose the operation\n        using the method developed by M\xc3\xb6tt\xc3\xb6nen et al. (Quantum Info. Comput.,\n        2005).\n\n    Args:\n        state (array[complex]): a state vector of size 2**len(wires)\n        wires (Sequence[int] or int): the wire(s) the operation acts on\n    """"""\n    num_params = 1\n    num_wires = AnyWires\n    par_domain = ""A""\n    grad_method = None\n\n    @staticmethod\n    def decomposition(state, wires):\n        with OperationRecorder() as rec:\n            MottonenStatePreparation(state, wires)\n\n        return rec.queue\n\n\n# =============================================================================\n# Observables\n# =============================================================================\n\n\nclass Hermitian(Observable):\n    r""""""Hermitian(A, wires)\n    An arbitrary Hermitian observable.\n\n    For a Hermitian matrix :math:`A`, the expectation command returns the value\n\n    .. math::\n        \\braket{A} = \\braketT{\\psi}{\\cdots \\otimes I\\otimes A\\otimes I\\cdots}{\\psi}\n\n    where :math:`A` acts on the requested wires.\n\n    If acting on :math:`N` wires, then the matrix :math:`A` must be of size\n    :math:`2^N\\times 2^N`.\n\n    **Details:**\n\n    * Number of wires: Any\n    * Number of parameters: 1\n    * Gradient recipe: None\n\n    Args:\n        A (array): square hermitian matrix\n        wires (Sequence[int] or int): the wire(s) the operation acts on\n    """"""\n    num_wires = AnyWires\n    num_params = 1\n    par_domain = ""A""\n    grad_method = ""F""\n    _eigs = {}\n\n    @classmethod\n    def _matrix(cls, *params):\n        A = np.asarray(params[0])\n\n        if A.shape[0] != A.shape[1]:\n            raise ValueError(""Observable must be a square matrix."")\n\n        if not np.allclose(A, A.conj().T):\n            raise ValueError(""Observable must be Hermitian."")\n\n        return A\n\n    @property\n    def eigendecomposition(self):\n        """"""Return the eigendecomposition of the matrix specified by the Hermitian observable.\n\n        This method uses pre-stored eigenvalues for standard observables where\n        possible and stores the corresponding eigenvectors from the eigendecomposition.\n\n        It transforms the input operator according to the wires specified.\n\n        Returns:\n            dict[str, array]: dictionary containing the eigenvalues and the eigenvectors of the Hermitian observable\n        """"""\n        Hmat = self.matrix\n        Hkey = tuple(Hmat.flatten().tolist())\n        if Hkey not in Hermitian._eigs:\n            w, U = np.linalg.eigh(Hmat)\n            Hermitian._eigs[Hkey] = {""eigvec"": U, ""eigval"": w}\n\n        return Hermitian._eigs[Hkey]\n\n    @property\n    def eigvals(self):\n        """"""Return the eigenvalues of the specified Hermitian observable.\n\n        This method uses pre-stored eigenvalues for standard observables where\n        possible and stores the corresponding eigenvectors from the eigendecomposition.\n\n        Returns:\n            array: array containing the eigenvalues of the Hermitian observable\n        """"""\n        return self.eigendecomposition[""eigval""]\n\n    def diagonalizing_gates(self):\n        """"""Return the gate set that diagonalizes a circuit according to the\n        specified Hermitian observable.\n\n        This method uses pre-stored eigenvalues for standard observables where\n        possible and stores the corresponding eigenvectors from the eigendecomposition.\n\n        Returns:\n            list: list containing the gates diagonalizing the Hermitian observable\n        """"""\n        return [QubitUnitary(self.eigendecomposition[""eigvec""].conj().T, wires=list(self.wires))]\n\n\nops = {\n    ""Hadamard"",\n    ""PauliX"",\n    ""PauliY"",\n    ""PauliZ"",\n    ""PauliRot"",\n    ""MultiRZ"",\n    ""S"",\n    ""T"",\n    ""CNOT"",\n    ""CZ"",\n    ""SWAP"",\n    ""CSWAP"",\n    ""Toffoli"",\n    ""RX"",\n    ""RY"",\n    ""RZ"",\n    ""PhaseShift"",\n    ""Rot"",\n    ""CRX"",\n    ""CRY"",\n    ""CRZ"",\n    ""CRot"",\n    ""U1"",\n    ""U2"",\n    ""U3"",\n    ""BasisState"",\n    ""QubitStateVector"",\n    ""QubitUnitary"",\n    ""DiagonalQubitUnitary"",\n}\n\n\nobs = {""Hadamard"", ""PauliX"", ""PauliY"", ""PauliZ"", ""Hermitian""}\n\n\n__all__ = list(ops | obs)\n'"
pennylane/optimize/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nThis module contains optimizers for the standard :mod:`QNode` class, which uses the NumPy interface.\n""""""\n\n# Python optimizers that are available in PennyLane\n# listed in alphabetical order to avoid circular imports\nfrom .adagrad import AdagradOptimizer\nfrom .adam import AdamOptimizer\nfrom .gradient_descent import GradientDescentOptimizer\nfrom .momentum import MomentumOptimizer\nfrom .nesterov_momentum import NesterovMomentumOptimizer\nfrom .rms_prop import RMSPropOptimizer\nfrom .qng import QNGOptimizer\nfrom .rotosolve import RotosolveOptimizer\nfrom .rotoselect import RotoselectOptimizer\n\n\n# Optimizers to display in the docs\n__all__ = [\n    ""AdagradOptimizer"",\n    ""AdamOptimizer"",\n    ""GradientDescentOptimizer"",\n    ""MomentumOptimizer"",\n    ""NesterovMomentumOptimizer"",\n    ""RMSPropOptimizer"",\n    ""QNGOptimizer"",\n    ""RotosolveOptimizer"",\n    ""RotoselectOptimizer"",\n]\n'"
pennylane/optimize/adagrad.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Adagrad optimizer""""""\nimport math\n\nfrom pennylane.utils import _flatten, unflatten\nfrom .gradient_descent import GradientDescentOptimizer\n\n\nclass AdagradOptimizer(GradientDescentOptimizer):\n    r""""""Gradient-descent optimizer with past-gradient-dependent\n    learning rate in each dimension.\n\n    Adagrad adjusts the learning rate for each parameter :math:`x_i`\n    in :math:`x` based on past gradients. We therefore have to consider\n    each parameter update individually,\n\n    .. math::\n        x^{(t+1)}_i = x^{(t)}_i - \\eta_i^{(t+1)} \\partial_{w_i} f(x^{(t)}),\n\n    where the gradient is replaced by a (scalar) partial derivative.\n\n    The learning rate in step :math:`t` is given by\n\n    .. math::\n        \\eta_i^{(t+1)} = \\frac{ \\eta_{\\mathrm{init}} }{ \\sqrt{a_i^{(t+1)} + \\epsilon } },\n        ~~~ a_i^{(t+1)} = \\sum_{k=1}^t (\\partial_{x_i} f(x^{(k)}))^2.\n\n    The offset :math:`\\epsilon` avoids division by zero.\n\n    :math:`\\eta` is the step size, a user defined parameter.\n\n    Args:\n        stepsize (float): the user-defined hyperparameter :math:`\\eta`\n        eps (float): offset :math:`\\epsilon` added for numerical stability\n    """"""\n\n    def __init__(self, stepsize=0.01, eps=1e-8):\n        super().__init__(stepsize)\n        self.eps = eps\n        self.accumulation = None\n\n    def apply_grad(self, grad, x):\n        r""""""Update the variables x to take a single optimization step. Flattens and unflattens\n        the inputs to maintain nested iterables as the parameters of the optimization.\n\n        Args:\n            grad (array): The gradient of the objective\n                function at point :math:`x^{(t)}`: :math:`\\nabla f(x^{(t)})`\n            x (array): the current value of the variables :math:`x^{(t)}`\n\n        Returns:\n            array: the new values :math:`x^{(t+1)}`\n        """"""\n\n        x_flat = _flatten(x)\n        grad_flat = list(_flatten(grad))\n\n        if self.accumulation is None:\n            self.accumulation = [g * g for g in grad_flat]\n        else:\n            self.accumulation = [a + g * g for a, g in zip(self.accumulation, grad_flat)]\n\n        x_new_flat = [\n            e - (self._stepsize / math.sqrt(a + self.eps)) * g\n            for a, g, e in zip(self.accumulation, grad_flat, x_flat)\n        ]\n\n        return unflatten(x_new_flat, x)\n\n    def reset(self):\n        """"""Reset optimizer by erasing memory of past steps.""""""\n        self.accumulation = None\n'"
pennylane/optimize/adam.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Adam optimizer""""""\nimport math\n\nfrom pennylane.utils import _flatten, unflatten\nfrom .gradient_descent import GradientDescentOptimizer\n\n\nclass AdamOptimizer(GradientDescentOptimizer):\n    r""""""Gradient-descent optimizer with adaptive learning rate, first and second moment.\n\n    Adaptive Moment Estimation uses a step-dependent learning rate,\n    a first moment :math:`a` and a second moment :math:`b`, reminiscent of\n    the momentum and velocity of a particle:\n\n    .. math::\n        x^{(t+1)} = x^{(t)} - \\eta^{(t+1)} \\frac{a^{(t+1)}}{\\sqrt{b^{(t+1)}} + \\epsilon },\n\n    where the update rules for the three values are given by\n\n    .. math::\n        a^{(t+1)} &= \\frac{\\beta_1 a^{(t)} + (1-\\beta_1)\\nabla f(x^{(t)})}{(1- \\beta_1)},\\\\\n        b^{(t+1)} &= \\frac{\\beta_2 b^{(t)} + (1-\\beta_2) ( \\nabla f(x^{(t)}))^{\\odot 2} }{(1- \\beta_2)},\\\\\n        \\eta^{(t+1)} &= \\eta^{(t)} \\frac{\\sqrt{(1-\\beta_2)}}{(1-\\beta_1)}.\n\n    Above, :math:`( \\nabla f(x^{(t-1)}))^{\\odot 2}` denotes the element-wise square operation,\n    which means that each element in the gradient is multiplied by itself. The\n    hyperparameters :math:`\\beta_1` and :math:`\\beta_2` can also be step-dependent.\n    Initially, the first and second moment are zero.\n\n    The shift :math:`\\epsilon` avoids division by zero.\n\n    For more details, see `arXiv:1412.6980 <https://arxiv.org/abs/1412.6980>`_.\n\n    Args:\n        stepsize (float): the user-defined hyperparameter :math:`\\eta`\n        beta1 (float): hyperparameter governing the update of the first and second moment\n        beta2 (float): hyperparameter governing the update of the first and second moment\n        eps (float): offset :math:`\\epsilon` added for numerical stability\n\n    """"""\n\n    def __init__(self, stepsize=0.01, beta1=0.9, beta2=0.99, eps=1e-8):\n        super().__init__(stepsize)\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.eps = eps\n        self.fm = None\n        self.sm = None\n        self.t = 0\n\n    def apply_grad(self, grad, x):\n        r""""""Update the variables x to take a single optimization step. Flattens and unflattens\n        the inputs to maintain nested iterables as the parameters of the optimization.\n\n        Args:\n            grad (array): The gradient of the objective\n                function at point :math:`x^{(t)}`: :math:`\\nabla f(x^{(t)})`\n            x (array): the current value of the variables :math:`x^{(t)}`\n\n        Returns:\n            array: the new values :math:`x^{(t+1)}`\n        """"""\n\n        self.t += 1\n\n        grad_flat = list(_flatten(grad))\n        x_flat = _flatten(x)\n\n        # Update first moment\n        if self.fm is None:\n            self.fm = grad_flat\n        else:\n            self.fm = [self.beta1 * f + (1 - self.beta1) * g for f, g in zip(self.fm, grad_flat)]\n\n        # Update second moment\n        if self.sm is None:\n            self.sm = [g * g for g in grad_flat]\n        else:\n            self.sm = [\n                self.beta2 * f + (1 - self.beta2) * g * g for f, g in zip(self.sm, grad_flat)\n            ]\n\n        # Update step size (instead of correcting for bias)\n        new_stepsize = (\n            self._stepsize * math.sqrt(1 - self.beta2 ** self.t) / (1 - self.beta1 ** self.t)\n        )\n\n        x_new_flat = [\n            e - new_stepsize * f / (math.sqrt(s) + self.eps)\n            for f, s, e in zip(self.fm, self.sm, x_flat)\n        ]\n\n        return unflatten(x_new_flat, x)\n\n    def reset(self):\n        """"""Reset optimizer by erasing memory of past steps.""""""\n        self.fm = None\n        self.sm = None\n        self.t = 0\n'"
pennylane/optimize/gradient_descent.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Gradient descent optimizer""""""\n\nimport autograd\nfrom pennylane.utils import _flatten, unflatten\n\n\nclass GradientDescentOptimizer:\n    r""""""Basic gradient-descent optimizer.\n\n    Base class for other gradient-descent-based optimizers.\n\n    A step of the gradient descent optimizer computes the new values via the rule\n\n    .. math::\n\n        x^{(t+1)} = x^{(t)} - \\eta \\nabla f(x^{(t)}).\n\n    where :math:`\\eta` is a user-defined hyperparameter corresponding to step size.\n\n    Args:\n        stepsize (float): the user-defined hyperparameter :math:`\\eta`\n    """"""\n\n    def __init__(self, stepsize=0.01):\n        self._stepsize = stepsize\n\n    def update_stepsize(self, stepsize):\n        r""""""Update the initialized stepsize value :math:`\\eta`.\n\n        This allows for techniques such as learning rate scheduling.\n\n        Args:\n            stepsize (float): the user-defined hyperparameter :math:`\\eta`\n        """"""\n        self._stepsize = stepsize\n\n    def step(self, objective_fn, x, grad_fn=None):\n        """"""Update x with one step of the optimizer.\n\n        Args:\n            objective_fn (function): the objective function for optimization\n            x (array): NumPy array containing the current values of the variables to be updated\n            grad_fn (function): Optional gradient function of the\n                objective function with respect to the variables ``x``.\n                If ``None``, the gradient function is computed automatically.\n\n        Returns:\n            array: the new variable values :math:`x^{(t+1)}`\n        """"""\n\n        g = self.compute_grad(objective_fn, x, grad_fn=grad_fn)\n\n        x_out = self.apply_grad(g, x)\n\n        return x_out\n\n    @staticmethod\n    def compute_grad(objective_fn, x, grad_fn=None):\n        r""""""Compute gradient of the objective_fn at the point x.\n\n        Args:\n            objective_fn (function): the objective function for optimization\n            x (array): NumPy array containing the current values of the variables to be updated\n            grad_fn (function): Optional gradient function of the\n                objective function with respect to the variables ``x``.\n                If ``None``, the gradient function is computed automatically.\n\n        Returns:\n            array: NumPy array containing the gradient :math:`\\nabla f(x^{(t)})`\n        """"""\n        if grad_fn is not None:\n            g = grad_fn(x)  # just call the supplied grad function\n        else:\n            # default is autograd\n            g = autograd.grad(objective_fn)(x)  # pylint: disable=no-value-for-parameter\n        return g\n\n    def apply_grad(self, grad, x):\n        r""""""Update the variables x to take a single optimization step. Flattens and unflattens\n        the inputs to maintain nested iterables as the parameters of the optimization.\n\n        Args:\n            grad (array): The gradient of the objective\n                function at point :math:`x^{(t)}`: :math:`\\nabla f(x^{(t)})`\n            x (array): the current value of the variables :math:`x^{(t)}`\n\n        Returns:\n            array: the new values :math:`x^{(t+1)}`\n        """"""\n\n        x_flat = _flatten(x)\n        grad_flat = _flatten(grad)\n\n        x_new_flat = [e - self._stepsize * g for g, e in zip(grad_flat, x_flat)]\n\n        return unflatten(x_new_flat, x)\n'"
pennylane/optimize/momentum.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Momentum optimizer""""""\nfrom pennylane.utils import _flatten, unflatten\nfrom .gradient_descent import GradientDescentOptimizer\n\n\nclass MomentumOptimizer(GradientDescentOptimizer):\n    r""""""Gradient-descent optimizer with momentum.\n\n    The momentum optimizer adds a ""momentum"" term to gradient descent\n    which considers the past gradients:\n\n    .. math:: x^{(t+1)} = x^{(t)} - a^{(t+1)}.\n\n    The accumulator term :math:`a` is updated as follows:\n\n    .. math:: a^{(t+1)} = m a^{(t)} + \\eta \\nabla f(x^{(t)}),\n\n    with user defined parameters:\n\n    * :math:`\\eta`: the step size\n    * :math:`m`: the momentum\n\n    Args:\n        stepsize (float): user-defined hyperparameter :math:`\\eta`\n        momentum (float): user-defined hyperparameter :math:`m`\n    """"""\n\n    def __init__(self, stepsize=0.01, momentum=0.9):\n        super().__init__(stepsize)\n        self.momentum = momentum\n        self.accumulation = None\n\n    def apply_grad(self, grad, x):\n        r""""""Update the variables x to take a single optimization step. Flattens and unflattens\n        the inputs to maintain nested iterables as the parameters of the optimization.\n\n        Args:\n            grad (array): The gradient of the objective\n                function at point :math:`x^{(t)}`: :math:`\\nabla f(x^{(t)})`\n            x (array): the current value of the variables :math:`x^{(t)}`\n\n        Returns:\n            array: the new values :math:`x^{(t+1)}`\n        """"""\n\n        grad_flat = _flatten(grad)\n        x_flat = _flatten(x)\n\n        if self.accumulation is None:\n            self.accumulation = [self._stepsize * g for g in grad_flat]\n        else:\n            self.accumulation = [\n                self.momentum * a + self._stepsize * g for a, g in zip(self.accumulation, grad_flat)\n            ]\n\n        x_new_flat = [e - a for a, e in zip(self.accumulation, x_flat)]\n\n        return unflatten(x_new_flat, x)\n\n    def reset(self):\n        """"""Reset optimizer by erasing memory of past steps.""""""\n        self.accumulation = None\n'"
pennylane/optimize/nesterov_momentum.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Nesterov momentum optimizer""""""\nimport autograd\nfrom pennylane.utils import _flatten, unflatten\nfrom .momentum import MomentumOptimizer\n\n\nclass NesterovMomentumOptimizer(MomentumOptimizer):\n    r""""""Gradient-descent optimizer with Nesterov momentum.\n\n    Nesterov Momentum works like the :class:`Momentum optimizer <.pennylane.optimize.MomentumOptimizer>`,\n    but shifts the current input by the momentum term when computing the gradient of the objective function:\n\n    .. math:: a^{(t+1)} = m a^{(t)} + \\eta \\nabla f(x^{(t)} - m a^{(t)}).\n\n    The user defined parameters are:\n\n    * :math:`\\eta`: the step size\n    * :math:`m`: the momentum\n\n    Args:\n        stepsize (float): user-defined hyperparameter :math:`\\eta`\n        momentum (float): user-defined hyperparameter :math:`m`\n    """"""\n\n    def compute_grad(self, objective_fn, x, grad_fn=None):\n        r""""""Compute gradient of the objective_fn at at\n        the shifted point :math:`(x - m\\times\\text{accumulation})`.\n\n        Args:\n            objective_fn (function): the objective function for optimization\n            x (array): NumPy array containing the current values of the variables to be updated\n            grad_fn (function): Optional gradient function of the\n                objective function with respect to the variables ``x``.\n                If ``None``, the gradient function is computed automatically.\n\n        Returns:\n            array: NumPy array containing the gradient :math:`\\nabla f(x^{(t)})`\n        """"""\n\n        x_flat = _flatten(x)\n\n        if self.accumulation is None:\n            shifted_x_flat = list(x_flat)\n        else:\n            shifted_x_flat = [e - self.momentum * a for a, e in zip(self.accumulation, x_flat)]\n\n        shifted_x = unflatten(shifted_x_flat, x)\n\n        if grad_fn is not None:\n            g = grad_fn(shifted_x)  # just call the supplied grad function\n        else:\n            # default is autograd\n            g = autograd.grad(objective_fn)(shifted_x)  # pylint: disable=no-value-for-parameter\n        return g\n'"
pennylane/optimize/qng.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Quantum natural gradient optimizer""""""\n# pylint: disable=too-many-branches\n\nimport numpy as np\n\nfrom pennylane.utils import _flatten, unflatten\nfrom .gradient_descent import GradientDescentOptimizer\n\n\nclass QNGOptimizer(GradientDescentOptimizer):\n    r""""""Optimizer with adaptive learning rate, via calculation\n    of the diagonal or block-diagonal approximation to the Fubini-Study metric tensor.\n    A quantum generalization of natural gradient descent.\n\n    The QNG optimizer uses a step- and parameter-dependent learning rate,\n    with the learning rate dependent on the pseudo-inverse\n    of the Fubini-Study metric tensor :math:`g`:\n\n    .. math::\n        x^{(t+1)} = x^{(t)} - \\eta g(f(x^{(t)}))^{-1} \\nabla f(x^{(t)}),\n\n    where :math:`f(x^{(t)}) = \\langle 0 | U(x^{(t)})^\\dagger \\hat{B} U(x^{(t)}) | 0 \\rangle`\n    is an expectation value of some observable measured on the variational\n    quantum circuit :math:`U(x^{(t)})`.\n\n    Consider a quantum node represented by the variational quantum circuit\n\n    .. math::\n\n        U(\\mathbf{\\theta}) = W(\\theta_{i+1}, \\dots, \\theta_{N})X(\\theta_{i})\n        V(\\theta_1, \\dots, \\theta_{i-1}),\n\n    where all parametrized gates can be written of the form :math:`X(\\theta_{i}) = e^{i\\theta_i K_i}`.\n    That is, the gate :math:`K_i` is the *generator* of the parametrized operation :math:`X(\\theta_i)`\n    corresponding to the :math:`i`-th parameter.\n\n    For each parametric layer :math:`\\ell` in the variational quantum circuit\n    containing :math:`n` parameters, the :math:`n\\times n` block-diagonal submatrix\n    of the Fubini-Study tensor :math:`g_{ij}^{(\\ell)}` is calculated directly on the\n    quantum device in a single evaluation:\n\n    .. math::\n\n        g_{ij}^{(\\ell)} = \\langle \\psi_\\ell | K_i K_j | \\psi_\\ell \\rangle\n        - \\langle \\psi_\\ell | K_i | \\psi_\\ell\\rangle\n        \\langle \\psi_\\ell |K_j | \\psi_\\ell\\rangle\n\n    where :math:`|\\psi_\\ell\\rangle =  V(\\theta_1, \\dots, \\theta_{i-1})|0\\rangle`\n    (that is, :math:`|\\psi_\\ell\\rangle` is the quantum state prior to the application\n    of parameterized layer :math:`\\ell`).\n\n    Combining the quantum natural gradient optimizer with the analytic parameter-shift\n    rule to optimize a variational circuit with :math:`d` parameters and :math:`L` layers,\n    a total of :math:`2d+L` quantum evaluations are required per optimization step.\n\n    For more details, see:\n\n        James Stokes, Josh Izaac, Nathan Killoran, Giuseppe Carleo.\n        ""Quantum Natural Gradient."" `arXiv:1909.02108 <https://arxiv.org/abs/1909.02108>`_, 2019.\n\n    .. note::\n\n        The QNG optimizer supports single QNodes or :class:`~.VQECost` objects as objective functions.\n        Alternatively, the metric tensor can directly be provided to the :func:`step` method of the optimizer,\n        using the ``metric_tensor_fn`` argument.\n\n        For the following cases, providing metric_tensor_fn may be useful:\n\n        * For hybrid classical-quantum models, the ""mixed geometry"" of the model\n          makes it unclear which metric should be used for which parameter.\n          For example, parameters of quantum nodes are better suited to\n          one metric (such as the QNG), whereas others (e.g., parameters of classical nodes)\n          are likely better suited to another metric.\n\n        * For multi-QNode models, we don\'t know what geometry is appropriate\n          if a parameter is shared amongst several QNodes.\n\n        If the objective function is VQE/VQE-like, i.e., a function of a group\n        of QNodes that share an ansatz, there are two ways to use the optimizer:\n\n        * Realize the objective function as a :class:`~.VQECost` object, which has\n          a ``metric_tensor`` method.\n\n        * Manually provide the ``metric_tensor_fn`` corresponding to the metric tensor of\n          of the QNode(s) involved in the objective function.\n\n    **Examples:**\n\n    For VQE/VQE-like problems, the objective function for the optimizer can be\n    realized as a VQECost object.\n\n    >>> dev = qml.device(""default.qubit"", wires=1)\n    >>> def circuit(params, wires=0):\n    ...     qml.RX(params[0], wires=wires)\n    ...     qml.RY(params[1], wires=wires)\n    >>> coeffs = [1, 1]\n    >>> obs = [qml.PauliX(0), qml.PauliZ(0)]\n    >>> H = qml.Hamiltonian(coeffs, obs)\n    >>> cost_fn = qml.VQECost(circuit, H, dev)\n\n    Once constructed, the cost function can be passed directly to the\n    optimizer\'s ``step`` function:\n\n    >>> eta = 0.01\n    >>> init_params = [0.011, 0.012]\n    >>> opt = qml.QNGOptimizer(eta)\n    >>> theta_new = opt.step(cost_fn, init_params)\n    >>> print(theta_new)\n    [0.011445239214543481, -0.027519522461477233]\n\n    Alternatively, the same objective function can be used for the optimizer\n    by manually providing the ``metric_tensor_fn``.\n\n    >>> qnodes = qml.map(circuit, obs, dev, \'expval\')\n    >>> cost_fn = qml.dot(coeffs, qnodes)\n    >>> eta = 0.01\n    >>> init_params = [0.011, 0.012]\n    >>> opt = qml.QNGOptimizer(eta)\n    >>> theta_new = opt.step(cost_fn, init_params, metric_tensor_fn=qnodes.qnodes[0].metric_tensor)\n    >>> print(theta_new)\n    [0.011445239214543481, -0.027519522461477233]\n\n    .. seealso::\n\n        See the :ref:`quantum natural gradient example <quantum_natural_gradient>`\n        for more details on Fubini-Study metric tensor and this optimization class.\n\n    Args:\n        stepsize (float): the user-defined hyperparameter :math:`\\eta`\n        diag_approx (bool): If ``True``, forces a diagonal approximation\n            where the calculated metric tensor only contains diagonal\n            elements :math:`G_{ii}`. In some cases, this may reduce the\n            time taken per optimization step.\n        lam (float): metric tensor regularization :math:`G_{ij}+\\lambda I`\n            to be applied at each optimization step\n    """"""\n\n    def __init__(self, stepsize=0.01, diag_approx=False, lam=0):\n        super().__init__(stepsize)\n        self.diag_approx = diag_approx\n        self.metric_tensor = None\n        self.lam = lam\n\n    def step(self, qnode, x, recompute_tensor=True, metric_tensor_fn=None):\n        """"""Update x with one step of the optimizer.\n\n        Args:\n            qnode (QNode): the QNode for optimization\n            x (array): NumPy array containing the current values of the variables to be updated\n            recompute_tensor (bool): Whether or not the metric tensor should\n                be recomputed. If not, the metric tensor from the previous\n                optimization step is used.\n            metric_tensor_fn (function): Optional metric tensor function\n                with respect to the variables ``x``.\n                If ``None``, the metric tensor function is computed automatically.\n\n        Returns:\n            array: the new variable values :math:`x^{(t+1)}`\n        """"""\n        # pylint: disable=arguments-differ\n        if not hasattr(qnode, ""metric_tensor"") and not metric_tensor_fn:\n            raise ValueError(\n                ""The objective function must either be encoded as a single QNode or ""\n                ""a VQECost object for the natural gradient to be automatically computed. ""\n                ""Otherwise, metric_tensor_fn must be explicitly provided to the optimizer.""\n            )\n\n        if recompute_tensor or self.metric_tensor is None:\n            if not metric_tensor_fn:\n                # pseudo-inverse metric tensor\n                self.metric_tensor = qnode.metric_tensor([x], diag_approx=self.diag_approx)\n            else:\n                self.metric_tensor = metric_tensor_fn([x], diag_approx=self.diag_approx)\n            self.metric_tensor += self.lam * np.identity(self.metric_tensor.shape[0])\n\n        g = self.compute_grad(qnode, x)\n        x_out = self.apply_grad(g, x)\n        return x_out\n\n    def apply_grad(self, grad, x):\n        r""""""Update the variables x to take a single optimization step. Flattens and unflattens\n        the inputs to maintain nested iterables as the parameters of the optimization.\n\n        Args:\n            grad (array): The gradient of the objective\n                function at point :math:`x^{(t)}`: :math:`\\nabla f(x^{(t)})`\n            x (array): the current value of the variables :math:`x^{(t)}`\n\n        Returns:\n            array: the new values :math:`x^{(t+1)}`\n        """"""\n        grad_flat = np.array(list(_flatten(grad)))\n        x_flat = np.array(list(_flatten(x)))\n        x_new_flat = x_flat - self._stepsize * np.linalg.solve(self.metric_tensor, grad_flat)\n        return unflatten(x_new_flat, x)\n'"
pennylane/optimize/rms_prop.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Root mean square propagation optimizer""""""\nimport math\n\nfrom pennylane.utils import _flatten, unflatten\nfrom .adagrad import AdagradOptimizer\n\n\nclass RMSPropOptimizer(AdagradOptimizer):\n    r""""""Root mean squared propagation optimizer.\n\n    The root mean square progation optimizer is a modified\n    :class:`Adagrad optimizer <pennylane.optmimize.AdagradOptimizer>`,\n    with a decay of learning rate adaptation.\n\n    Extensions of the Adagrad optimization method generally\n    start the sum :math:`a` over past gradients in the denominator\n    of the learning rate at a finite :math:`t\'` with :math:`0 < t\' < t`,\n    or decay past gradients to avoid an ever-decreasing learning rate.\n\n    Root Mean Square propagation is such an adaptation, where\n\n    .. math::\n        a_i^{(t+1)} = \\gamma a_i^{(t)} + (1-\\gamma) (\\partial_{x_i} f(x^{(t)}))^2.\n\n    Args:\n        stepsize (float): the user-defined hyperparameter :math:`\\eta`\n            used in the Adagrad optmization\n        decay (float): the learning rate decay :math:`\\gamma`\n        eps (float): offset :math:`\\epsilon` added for numerical stability (see :class:`Adagrad <pennylane.optmimize.AdagradOptimizer>`)\n\n    """"""\n\n    def __init__(self, stepsize=0.01, decay=0.9, eps=1e-8):\n        super().__init__(stepsize)\n        self.decay = decay\n        self.eps = eps\n\n    def apply_grad(self, grad, x):\n        r""""""Update the variables x to take a single optimization step. Flattens and unflattens\n        the inputs to maintain nested iterables as the parameters of the optimization.\n\n        Args:\n            grad (array): The gradient of the objective\n                function at point :math:`x^{(t)}`: :math:`\\nabla f(x^{(t)})`\n            x (array): the current value of the variables :math:`x^{(t)}`\n\n        Returns:\n            array: the new values :math:`x^{(t+1)}`\n        """"""\n\n        grad_flat = list(_flatten(grad))\n        x_flat = _flatten(x)\n\n        if self.accumulation is None:\n            self.accumulation = [(1 - self.decay) * g * g for g in grad_flat]\n        else:\n            self.accumulation = [\n                self.decay * a + (1 - self.decay) * g * g\n                for a, g in zip(self.accumulation, grad_flat)\n            ]\n\n        x_new_flat = [\n            e - (self._stepsize / math.sqrt(a + self.eps)) * g\n            for a, g, e in zip(self.accumulation, grad_flat, x_flat)\n        ]\n\n        return unflatten(x_new_flat, x)\n'"
pennylane/optimize/rotoselect.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Rotoselect gradient free optimizer""""""\n\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.utils import _flatten, unflatten\n\n\nclass RotoselectOptimizer:\n    r""""""Rotoselect gradient-free optimizer.\n\n    The Rotoselect optimizer minimizes an objective function with respect to the rotation gates and\n    parameters of a quantum circuit without the need for calculating the gradient of the function.\n    The algorithm works by updating the parameters :math:`\\theta = \\theta_1, \\dots, \\theta_D`\n    and rotation gate choices :math:`R = R_1,\\dots,R_D` one at a time according to a closed-form\n    expression for the optimal value of the :math:`d^{th}` parameter :math:`\\theta^*_d` when the\n    other parameters and gate choices are fixed:\n\n    .. math:: \\theta^*_d = \\underset{\\theta_d}{\\text{argmin}}\\left<H\\right>_{\\theta_d}\n              = -\\frac{\\pi}{2} - \\text{arctan2}\\left(2\\left<H\\right>_{\\theta_d=0}\n              - \\left<H\\right>_{\\theta_d=\\pi/2} - \\left<H\\right>_{\\theta_d=-\\pi/2},\n              \\left<H\\right>_{\\theta_d=\\pi/2} - \\left<H\\right>_{\\theta_d=-\\pi/2}\\right),\n\n    where :math:`\\left<H\\right>_{\\theta_d}` is the expectation value of the objective function\n    optimized over the parameter :math:`\\theta_d`. :math:`\\text{arctan2}(x, y)` computes the\n    element-wise arc tangent of :math:`x/y` choosing the quadrant correctly, avoiding, in\n    particular, division-by-zero when :math:`y = 0`.\n\n    Which parameters and gates that should be optimized over is decided in the user-defined cost\n    function, where :math:`R` is a list of parametrized rotation gates in a quantum circuit, along\n    with their respective parameters :math:`\\theta` for the circuit and its gates. Note that the\n    number of generators should match the number of parameters.\n\n    The algorithm is described in further detail in `Ostaszewski et al. (2019) <https://arxiv.org/abs/1905.09692>`_.\n\n    Args:\n        possible_generators (list[~.Operation]): List containing the possible ``pennylane.ops.qubit``\n            operators that are allowed in the circuit. Default is the set of Pauli rotations\n            :math:`\\{R_x, R_y, R_z\\}`.\n\n    **Example:**\n\n    Initialize the Rotoselect optimizer, set the initial values of  the weights ``x``,\n    choose the initial generators, and set the number of steps to optimize over.\n\n    >>> opt = qml.optimize.RotoselectOptimizer()\n    >>> x = [0.3, 0.7]\n    >>> generators = [qml.RX, qml.RY]\n    >>> n_steps = 10\n\n    Set up the PennyLane circuit using the ``default.qubit`` simulator device.\n\n    >>> dev = qml.device(""default.qubit"", analytic=True, wires=2)\n    >>> @qml.qnode(dev)\n    ... def circuit(params, generators=None):  # generators will be passed as a keyword arg\n    ...     generators[0](params[0], wires=0)\n    ...     generators[1](params[1], wires=1)\n    ...     qml.CNOT(wires=[0, 1])\n    ...     return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliX(1))\n\n    Define a cost function based on the above circuit.\n\n    >>> def cost(x, generators):\n    ...     Z_1, X_2 = circuit(x, generators=generators)\n    ...     return 0.2 * Z_1 + 0.5 * X_2\n\n    Run the optimization step-by-step for ``n_steps`` steps.\n\n    >>> cost_rotosel = []\n    >>> for _ in range(n_steps):\n    ...     cost_rotosel.append(cost(x, generators))\n    ...     x, generators = opt.step(cost, x, generators)\n\n    The optimized values for x should now be stored in ``x`` together with the optimal gates for\n    the circuit, while steps-vs-cost can be seen by plotting ``cost_rotosel``.\n    """"""\n    # pylint: disable=too-few-public-methods\n\n    def __init__(self, possible_generators=None):\n        self.possible_generators = possible_generators or [qml.RX, qml.RY, qml.RZ]\n\n    def step(self, objective_fn, x, generators):\n        r""""""Update x with one step of the optimizer.\n\n        Args:\n            objective_fn (function): The objective function for optimization. It must have the\n                signature ``objective_fn(x, generators=None)`` with a sequence of the values ``x``\n                and a list of the gates ``generators`` as inputs, returning a single value.\n            x (Union[Sequence[float], float]): sequence containing the initial values of the\n                variables to be optimized over or a single float with the initial value\n            generators (list[~.Operation]): list containing the initial ``pennylane.ops.qubit``\n                operators to be used in the circuit and optimized over\n\n        Returns:\n            array: The new variable values :math:`x^{(t+1)}` as well as the new generators.\n        """"""\n        x_flat = np.fromiter(_flatten(x), dtype=float)\n        # wrap the objective function so that it accepts the flattened parameter array\n        objective_fn_flat = lambda x_flat, gen: objective_fn(unflatten(x_flat, x), generators=gen)\n\n        try:\n            assert len(x_flat) == len(generators)\n        except AssertionError:\n            raise ValueError(\n                ""Number of parameters {} must be equal to the number of generators."".format(x)\n            )\n\n        for d, _ in enumerate(x_flat):\n            x_flat[d], generators[d] = self._find_optimal_generators(\n                objective_fn_flat, x_flat, generators, d\n            )\n\n        return unflatten(x_flat, x), generators\n\n    def _find_optimal_generators(self, objective_fn, x, generators, d):\n        r""""""Optimizer for the generators.\n\n        Optimizes for the best generator at position ``d``.\n\n        Args:\n            objective_fn (function): The objective function for optimization. It must have the\n                signature ``objective_fn(x, generators=None)`` with a sequence of the values ``x``\n                and a list of the gates ``generators`` as inputs, returning a single value.\n            x (Union[Sequence[float], float]): sequence containing the initial values of the\n                variables to be optimized over or a single float with the initial value\n            generators (list[~.Operation]): list containing the initial ``pennylane.ops.qubit``\n                operators to be used in the circuit and optimized over\n            d (int): the position in the input sequence ``x`` containing the value to be optimized\n\n        Returns:\n            tuple: tuple containing the parameter value and generator that, at position ``d`` in\n            ``x`` and ``generators``, optimizes the objective function\n        """"""\n        params_opt_d = x[d]\n        generators_opt_d = generators[d]\n        params_opt_cost = objective_fn(x, generators)\n\n        for generator in self.possible_generators:\n            generators[d] = generator\n\n            x = self._rotosolve(objective_fn, x, generators, d)\n            params_cost = objective_fn(x, generators)\n\n            # save the best paramter and generator for position d\n            if params_cost <= params_opt_cost:\n                params_opt_d = x[d]\n                params_opt_cost = params_cost\n                generators_opt_d = generator\n        return params_opt_d, generators_opt_d\n\n    @staticmethod\n    def _rotosolve(objective_fn, x, generators, d):\n        r""""""The rotosolve step for one parameter and one set of generators.\n\n        Updates the parameter :math:`\\theta_d` based on Equation 1 in\n        `Ostaszewski et al. (2019) <https://arxiv.org/abs/1905.09692>`_.\n\n        Args:\n            objective_fn (function): The objective function for optimization. It must have the\n                signature ``objective_fn(x, generators=None)`` with a sequence of the values ``x``\n                and a list of the gates ``generators`` as inputs, returning a single value.\n            x (Union[Sequence[float], float]): sequence containing the initial values of the\n                variables to be optimized overs or a single float with the initial value\n            generators (list[~.Operation]): list containing the initial ``pennylane.ops.qubit``\n                operators to be used in the circuit and optimized over\n            d (int): the position in the input sequence ``x`` containing the value to be optimized\n\n        Returns:\n            array: the input sequence ``x`` with the value at position ``d`` optimized\n        """"""\n        # helper function for x[d] = theta\n        def insert(x, d, theta):\n            x[d] = theta\n            return x\n\n        H_0 = float(objective_fn(insert(x, d, 0), generators))\n        H_p = float(objective_fn(insert(x, d, np.pi / 2), generators))\n        H_m = float(objective_fn(insert(x, d, -np.pi / 2), generators))\n\n        a = np.arctan2(2 * H_0 - H_p - H_m, H_p - H_m)\n\n        x[d] = -np.pi / 2 - a\n\n        if x[d] <= -np.pi:\n            x[d] += 2 * np.pi\n        return x\n'"
pennylane/optimize/rotosolve.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Rotosolve gradient free optimizer""""""\n\nimport numpy as np\nfrom pennylane.utils import _flatten, unflatten\n\n\nclass RotosolveOptimizer:\n    r""""""Rotosolve gradient free optimizer.\n\n    The Rotosolve optimizer minimizes an objective function with respect to the parameters of a\n    quantum circuit without the need for calculating the gradient of the function. The algorithm\n    works by updating the parameters :math:`\\theta = \\theta_1, \\dots, \\theta_D` one at a time\n    according to a closed-form expression for the optimal value of the :math:`d^{th}` parameter\n    :math:`\\theta^*_d` when the other parameters are fixed:\n\n    .. math:: \\theta^*_d = \\underset{\\theta_d}{\\text{argmin}}\\left<H\\right>_{\\theta_d}\n              = -\\frac{\\pi}{2} - \\text{arctan2}\\left(2\\left<H\\right>_{\\theta_d=0}\n              - \\left<H\\right>_{\\theta_d=\\pi/2} - \\left<H\\right>_{\\theta_d=-\\pi/2},\n              \\left<H\\right>_{\\theta_d=\\pi/2} - \\left<H\\right>_{\\theta_d=-\\pi/2}\\right),\n\n    where :math:`\\left<H\\right>_{\\theta_d}` is the expectation value of the objective function\n    optimized over the parameter :math:`\\theta_d`. :math:`\\text{arctan2}(x, y)` computes the\n    element-wise arc tangent of :math:`x/y` choosing the quadrant correctly, avoiding, in\n    particular, division-by-zero when :math:`y = 0`.\n\n    The algorithm is described in further detail in `Ostaszewski et al. (2019) <https://arxiv.org/abs/1905.09692>`_\n\n    **Example:**\n\n    Initialize the optimizer, set the initial values of ``x`` to be used and set the number of\n    steps to optimize over.\n\n    >>> opt = qml.optimize.RotosolveOptimizer()\n    >>> x = [0.3, 0.7]\n    >>> n_steps = 10\n\n    Set up the PennyLane circuit using the ``default.qubit`` as simulator device.\n\n    >>> dev = qml.device(""default.qubit"", analytic=True, wires=2)\n    ... @qml.qnode(dev)\n    ... def circuit(params):\n    ...     qml.RX(params[0], wires=0)\n    ...     qml.RY(params[1], wires=1)\n    ...     qml.CNOT(wires=[0, 1])\n    ...     return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliX(1))\n\n    Define a cost function (that takes a list of values as input and return a single value) based\n    on the above circuit.\n\n    >>> def cost(x):\n    ...     Z_1, X_2 = circuit(x)\n    ...     return 0.2 * Z_1 + 0.5 * X_2\n\n    Run the optimization step-by-step for ``n_steps`` steps.\n\n    >>> cost_rotosolve = []\n    >>> for _ in range(n_steps):\n    ...     cost_rotosolve.append(cost(x))\n    ...     x = opt.step(cost, x)\n\n    The optimized values for x should now be stored in ``x`` and steps-vs-cost can be seen by\n    plotting ``cost_rotosel``.\n    """"""\n    # pylint: disable=too-few-public-methods\n\n    def step(self, objective_fn, x):\n        r""""""Update x with one step of the optimizer.\n\n        Args:\n            objective_fn (function): The objective function for optimization. It should take a\n                sequence of the values ``x`` and a list of the gates ``generators`` as inputs, and\n                return a single value.\n            x (Union[Sequence[float], float]): sequence containing the initial values of the\n                variables to be optimized over or a single float with the initial value\n\n        Returns:\n            array: the new variable values :math:`x^{(t+1)}`\n        """"""\n        x_flat = np.fromiter(_flatten(x), dtype=float)\n        objective_fn_flat = lambda x_flat: objective_fn(unflatten(x_flat, x))\n\n        for d, _ in enumerate(x_flat):\n            x_flat = self._rotosolve(objective_fn_flat, x_flat, d)\n\n        return unflatten(x_flat, x)\n\n    @staticmethod\n    def _rotosolve(objective_fn, x, d):\n        r""""""The rotosolve step for one parameter.\n\n        Updates the parameter :math:`\\theta_d` based on Equation 1 in\n        `Ostaszewski et al. (2019) <https://arxiv.org/abs/1905.09692>`_.\n\n        Args:\n            objective_fn (function): The objective function for optimization. It should take a\n                sequence of the values ``x`` and a list of the gates ``generators`` as inputs, and\n                return a single value.\n            x (Union[Sequence[float], float]): sequence containing the initial values of the\n                variables to be optimized over or a single float with the initial value\n            d (int): the position in the input sequence ``x`` containing the value to be optimized\n\n        Returns:\n            array: the input sequence ``x`` with the value at position ``d`` optimized\n        """"""\n        # helper function for x[d] = theta\n        def insert(x, d, theta):\n            x[d] = theta\n            return x\n\n        H_0 = float(objective_fn(insert(x, d, 0)))\n        H_p = float(objective_fn(insert(x, d, np.pi / 2)))\n        H_m = float(objective_fn(insert(x, d, -np.pi / 2)))\n\n        a = np.arctan2(2 * H_0 - H_p - H_m, H_p - H_m)\n\n        x[d] = -np.pi / 2 - a\n\n        if x[d] <= -np.pi:\n            x[d] += 2 * np.pi\n        return x\n'"
pennylane/plugins/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis subpackage provides reference plugin implementations. The reference plugins provide basic built-in qubit\nand CV circuit simulators that can be used with PennyLane without the need for additional\ndependencies. They may also be used in the PennyLane test suite in order\nto verify and test quantum gradient computations.\n\n.. currentmodule:: pennylane.plugins\n.. autosummary::\n    :toctree: api\n\n    default_qubit\n    default_qubit_tf\n    default_gaussian\n    tf_ops\n""""""\nfrom .default_qubit import DefaultQubit\nfrom .default_gaussian import DefaultGaussian\n'"
pennylane/plugins/default_gaussian.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# pylint: disable=inconsistent-return-statements\n""""""\nThe :code:`default.gaussian` plugin is meant to be used as a template for writing PennyLane\ndevice plugins for new CV backends.\n\nIt implements the necessary :class:`~pennylane._device.Device` methods as well as all built-in\n:mod:`continuous-variable Gaussian operations <pennylane.ops.cv>`, and provides a very simple simulation of a\nGaussian-based quantum circuit architecture.\n""""""\n# pylint: disable=attribute-defined-outside-init,too-many-arguments\nimport math\nimport cmath\nimport numpy as np\n\nfrom scipy.special import factorial as fac\n\nimport pennylane as qml\nfrom pennylane import Device\n\n# tolerance for numerical errors\ntolerance = 1e-10\n\n\n# ========================================================\n#  auxillary functions\n# ========================================================\n\n\ndef partitions(s, include_singles=True):\n    """"""Partitions a sequence into all groupings of pairs and singles of elements.\n\n    Args:\n        s (sequence): the sequence to partition\n        include_singles (bool): if False, only partitions into pairs\n            is returned.\n\n    Returns:\n        tuple: returns a nested tuple, containing all partitions of the sequence.\n    """"""\n    # pylint: disable=too-many-branches\n    if len(s) == 2:\n        if include_singles:\n            yield (s[0],), (s[1],)\n\n        yield tuple(s),\n    else:\n        # pull off a single item and partition the rest\n        if include_singles:\n            if len(s) > 1:\n                item_partition = (s[0],)\n                rest = s[1:]\n                rest_partitions = partitions(rest, include_singles)\n                for p in rest_partitions:\n                    yield ((item_partition),) + p\n            else:\n                yield tuple(s),\n\n        # pull off a pair of items and partition the rest\n        for idx1 in range(1, len(s)):\n            item_partition = (s[0], s[idx1])\n            rest = s[1:idx1] + s[idx1 + 1 :]\n            rest_partitions = partitions(rest, include_singles)\n            for p in rest_partitions:\n                yield ((item_partition),) + p\n\n\ndef fock_prob(mu, cov, event, hbar=2.0):\n    r""""""Returns the probability of detection of a particular PNR detection event.\n\n    For more details, see:\n\n    * Kruse, R., Hamilton, C. S., Sansoni, L., Barkhofen, S., Silberhorn, C., & Jex, I.\n      ""A detailed study of Gaussian Boson Sampling."" `arXiv:1801.07488. (2018).\n      <https://arxiv.org/abs/1801.07488>`_\n\n    * Hamilton, C. S., Kruse, R., Sansoni, L., Barkhofen, S., Silberhorn, C., & Jex, I.\n      ""Gaussian boson sampling."" `Physical review letters, 119(17), 170501. (2017).\n      <https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.170501>`_\n\n    Args:\n        mu (array): length-:math:`2N` means vector\n        cov (array): :math:`2N\\times 2N` covariance matrix\n        event (array): length-:math:`N` array of non-negative integers representing the\n            PNR detection event of the multi-mode system.\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`.\n\n    Returns:\n        float: probability of detecting the event\n    """"""\n    # number of modes\n    N = len(mu) // 2\n    I = np.identity(N)\n\n    # mean displacement of each mode\n    alpha = (mu[:N] + 1j * mu[N:]) / math.sqrt(2 * hbar)\n    # the expectation values (<a_1>, <a_2>,...,<a_N>, <a^\\dagger_1>, ..., <a^\\dagger_N>)\n    beta = np.concatenate([alpha, alpha.conj()])\n\n    x = cov[:N, :N] * 2 / hbar\n    xp = cov[:N, N:] * 2 / hbar\n    p = cov[N:, N:] * 2 / hbar\n    # the (Hermitian) matrix elements <a_i^\\dagger a_j>\n    aidaj = (x + p + 1j * (xp - xp.T) - 2 * I) / 4\n    # the (symmetric) matrix elements <a_i a_j>\n    aiaj = (x - p + 1j * (xp + xp.T)) / 4\n\n    # calculate the covariance matrix sigma_Q appearing in the Q function:\n    # Q(alpha) = exp[-(alpha-beta).sigma_Q^{-1}.(alpha-beta)/2]/|sigma_Q|\n    Q = np.block([[aidaj, aiaj.conj()], [aiaj, aidaj.conj()]]) + np.identity(2 * N)\n\n    # inverse Q matrix\n    Qinv = np.linalg.inv(Q)\n    # 1/sqrt(|Q|)\n    sqrt_Qdet = 1 / math.sqrt(np.linalg.det(Q).real)\n\n    prefactor = cmath.exp(-beta @ Qinv @ beta.conj() / 2)\n\n    if np.all(np.array(event) == 0):\n        # all PNRs detect the vacuum state\n        return (prefactor * sqrt_Qdet).real / np.prod(fac(event))\n\n    # the matrix X_n = [[0, I_n], [I_n, 0]]\n    O = np.zeros_like(I)\n    X = np.block([[O, I], [I, O]])\n\n    gamma = X @ Qinv.conj() @ beta\n\n    # For each mode, repeat the mode number event[i] times\n    ind = [i for sublist in [[idx] * j for idx, j in enumerate(event)] for i in sublist]\n    # extend the indices for xp-ordering of the Gaussian state\n    ind += [i + N for i in ind]\n\n    if np.linalg.norm(beta) < tolerance:\n        # state has no displacement\n        part = partitions(ind, include_singles=False)\n    else:\n        part = partitions(ind, include_singles=True)\n\n    # calculate Hamilton\'s A matrix: A = X.(I-Q^{-1})*\n    A = X @ (np.identity(2 * N) - Qinv).conj()\n    summation = np.sum([np.prod([gamma[i[0]] if len(i) == 1 else A[i] for i in p]) for p in part])\n\n    return (prefactor * sqrt_Qdet * summation).real / np.prod(fac(event))\n\n\n# ========================================================\n#  parametrized gates\n# ========================================================\n\n\ndef rotation(phi):\n    """"""Rotation in the phase space.\n\n    Args:\n        phi (float): rotation parameter\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    return np.array([[math.cos(phi), -math.sin(phi)], [math.sin(phi), math.cos(phi)]])\n\n\ndef displacement(state, wire, alpha, hbar=2):\n    """"""Displacement in the phase space.\n\n    Args:\n        state (tuple): contains means vector and covariance matrix\n        wire (int): wire that the displacement acts on\n        alpha (float): complex displacement\n\n    Returns:\n        tuple: contains the vector of means and covariance matrix\n    """"""\n    mu = state[0]\n    mu[wire] += alpha.real * math.sqrt(2 * hbar)\n    mu[wire + len(mu) // 2] += alpha.imag * math.sqrt(2 * hbar)\n    return mu, state[1]\n\n\ndef squeezing(r, phi):\n    """"""Squeezing in the phase space.\n\n    Args:\n        r (float): squeezing magnitude\n        phi (float): rotation parameter\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    cp = math.cos(phi)\n    sp = math.sin(phi)\n    ch = math.cosh(r)\n    sh = math.sinh(r)\n    return np.array([[ch - cp * sh, -sp * sh], [-sp * sh, ch + cp * sh]])\n\n\ndef quadratic_phase(s):\n    """"""Quadratic phase shift.\n\n    Args:\n        s (float): gate parameter\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    return np.array([[1, 0], [s, 1]])\n\n\ndef beamsplitter(theta, phi):\n    r""""""Beamsplitter.\n\n    Args:\n        theta (float): transmittivity angle (:math:`t=\\cos\\theta`)\n        phi (float): phase angle (:math:`r=e^{i\\phi}\\sin\\theta`)\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    cp = math.cos(phi)\n    sp = math.sin(phi)\n    ct = math.cos(theta)\n    st = math.sin(theta)\n\n    S = np.array(\n        [\n            [ct, -cp * st, 0, -st * sp],\n            [cp * st, ct, -st * sp, 0],\n            [0, st * sp, ct, -cp * st],\n            [st * sp, 0, cp * st, ct],\n        ]\n    )\n\n    return S\n\n\ndef two_mode_squeezing(r, phi):\n\n    """"""Two-mode squeezing.\n\n    Args:\n        r (float): squeezing magnitude\n        phi (float): rotation parameter\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    cp = math.cos(phi)\n    sp = math.sin(phi)\n    ch = math.cosh(r)\n    sh = math.sinh(r)\n\n    S = np.array(\n        [\n            [ch, cp * sh, 0, sp * sh],\n            [cp * sh, ch, sp * sh, 0],\n            [0, sp * sh, ch, -cp * sh],\n            [sp * sh, 0, -cp * sh, ch],\n        ]\n    )\n\n    return S\n\n\ndef controlled_addition(s):\n    """"""CX gate.\n\n    Args:\n        s (float): gate parameter\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    S = np.array([[1, 0, 0, 0], [s, 1, 0, 0], [0, 0, 1, -s], [0, 0, 0, 1]])\n\n    return S\n\n\ndef controlled_phase(s):\n    """"""CZ gate.\n\n    Args:\n        s (float): gate parameter\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    S = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, s, 1, 0], [s, 0, 0, 1]])\n\n    return S\n\n\ndef interferometer(U):\n    """"""Interferometer\n\n    Args:\n        U (array): unitary matrix\n\n    Returns:\n        array: symplectic transformation matrix\n    """"""\n    N = 2 * len(U)\n    X = U.real\n    Y = U.imag\n    rows = np.arange(N).reshape(2, -1).T.flatten()\n    S = np.vstack([np.hstack([X, -Y]), np.hstack([Y, X])])[:, rows][rows]\n\n    return S\n\n\n# ========================================================\n#  Arbitrary states and operators\n# ========================================================\n\n\ndef squeezed_cov(r, phi, hbar=2):\n    r""""""Returns the squeezed covariance matrix of a squeezed state.\n\n    Args:\n        r (float): the squeezing magnitude\n        p (float): the squeezing phase :math:`\\phi`\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n    Returns:\n        array: the squeezed state\n    """"""\n    cov = np.array([[math.exp(-2 * r), 0], [0, math.exp(2 * r)]]) * hbar / 2\n\n    R = rotation(phi / 2)\n\n    return R @ cov @ R.T\n\n\ndef vacuum_state(wires, hbar=2.0):\n    r""""""Returns the vacuum state.\n\n    Args:\n        basis (str): Returns the vector of means and the covariance matrix\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n    Returns:\n        array: the vacuum state\n    """"""\n    means = np.zeros((2 * wires))\n    cov = np.identity(2 * wires) * hbar / 2\n    state = [means, cov]\n    return state\n\n\ndef coherent_state(a, phi=0, hbar=2.0):\n    r""""""Returns a coherent state.\n\n    Args:\n        a (complex) : the displacement\n        phi (float): the phase\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n    Returns:\n        array: the coherent state\n    """"""\n    alpha = a * cmath.exp(1j * phi)\n    means = np.array([alpha.real, alpha.imag]) * math.sqrt(2 * hbar)\n    cov = np.identity(2) * hbar / 2\n    state = [means, cov]\n    return state\n\n\ndef squeezed_state(r, phi, hbar=2.0):\n    r""""""Returns a squeezed state.\n\n    Args:\n        r (float): the squeezing magnitude\n        phi (float): the squeezing phase :math:`\\phi`\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n\n    Returns:\n        array: the squeezed state\n    """"""\n    means = np.zeros((2))\n    state = [means, squeezed_cov(r, phi, hbar)]\n    return state\n\n\ndef displaced_squeezed_state(a, phi_a, r, phi_r, hbar=2.0):\n    r""""""Returns a squeezed coherent state\n\n    Args:\n        a (real): the displacement magnitude\n        phi_a (real): the displacement phase\n        r (float): the squeezing magnitude\n        phi_r (float): the squeezing phase :math:`\\phi_r`\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n\n    Returns:\n        array: the squeezed coherent state\n    """"""\n    alpha = a * cmath.exp(1j * phi_a)\n    means = np.array([alpha.real, alpha.imag]) * math.sqrt(2 * hbar)\n    state = [means, squeezed_cov(r, phi_r, hbar)]\n    return state\n\n\ndef thermal_state(nbar, hbar=2.0):\n    r""""""Returns a thermal state.\n\n    Args:\n        nbar (float): the mean photon number\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n\n    Returns:\n        array: the thermal state\n    """"""\n    means = np.zeros([2])\n    state = [means, (2 * nbar + 1) * np.identity(2) * hbar / 2]\n    return state\n\n\ndef gaussian_state(mu, cov, hbar=2.0):\n    r""""""Returns a Gaussian state.\n\n    This is simply a bare wrapper function,\n    since the means vector and covariance matrix\n    can be passed via the parameters unchanged.\n\n    Note that both the means vector and covariance\n    matrix should be in :math:`(\\x_1,\\dots, \\x_N, \\p_1, \\dots, \\p_N)`\n    ordering.\n\n    Args:\n        mu (array): vector means. Must be length-:math:`2N`,\n            where N is the number of modes\n        cov (array): covariance matrix. Must be dimension :math:`2N\\times 2N`,\n            where N is the number of modes\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n\n    Returns:\n        tuple: the mean and covariance matrix of the Gaussian state\n    """"""\n    # pylint: disable=unused-argument\n    return mu, cov\n\n\ndef set_state(state, wire, mu, cov):\n    r""""""Inserts a single mode Gaussian into the\n    state representation of the complete system.\n\n    Args:\n        state (tuple): contains means vector\n            and covariance matrix of existing state\n        wire (int): wire corresponding to the new Gaussian state\n        mu (array): vector of means to insert\n        cov (array): covariance matrix to insert\n\n    Returns:\n        tuple: contains the vector of means and covariance matrix.\n    """"""\n    mu0 = state[0]\n    cov0 = state[1]\n    N = len(mu0) // 2\n\n    # insert the new state into the means vector\n    mu0[[wire, wire + N]] = mu\n\n    # insert the new state into the covariance matrix\n    ind = np.concatenate([np.array([wire]), np.array([wire]) + N])\n    rows = ind.reshape(-1, 1)\n    cols = ind.reshape(1, -1)\n    cov0[rows, cols] = cov\n\n    return mu0, cov0\n\n\n# ========================================================\n#  expectations\n# ========================================================\n\n\ndef photon_number(mu, cov, wires, params, total_wires, hbar=2.0):\n    r""""""Calculates the mean photon number for a given one-mode state.\n\n    Args:\n        mu (array): length-2 vector of means\n        cov (array): :math:`2\\times 2` covariance matrix\n        wires (Sequence[int]): wires to calculate the expectation for\n        params (None): no parameters are used for this expectation value\n        total_wires (int): total number of wires in the system\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n\n    Returns:\n        tuple: contains the photon number expectation and variance\n    """"""\n    # pylint: disable=unused-argument\n    ex = (np.trace(cov) + mu.T @ mu) / (2 * hbar) - 1 / 2\n    var = (np.trace(cov @ cov) + 2 * mu.T @ cov @ mu) / (2 * hbar ** 2) - 1 / 4\n    return ex, var\n\n\ndef homodyne(phi=None):\n    """"""Function factory that returns the Homodyne expectation of a one mode state.\n\n    Args:\n        phi (float): the default phase space axis to perform the Homodyne measurement\n\n    Returns:\n        function: A function that accepts a single mode means vector, covariance matrix,\n        and phase space angle phi, and returns the quadrature expectation\n        value and variance.\n    """"""\n    if phi is not None:\n\n        def _homodyne(mu, cov, wires, params, total_wires, hbar=2.0):\n            """"""Arbitrary angle homodyne expectation.""""""\n            # pylint: disable=unused-argument\n            rot = rotation(phi)\n            muphi = rot.T @ mu\n            covphi = rot.T @ cov @ rot\n            return muphi[0], covphi[0, 0]\n\n        return _homodyne\n\n    def _homodyne(mu, cov, wires, params, total_wires, hbar=2.0):\n        """"""Arbitrary angle homodyne expectation.""""""\n        # pylint: disable=unused-argument\n        rot = rotation(params[0])\n        muphi = rot.T @ mu\n        covphi = rot.T @ cov @ rot\n        return muphi[0], covphi[0, 0]\n\n    return _homodyne\n\n\ndef poly_quad_expectations(mu, cov, wires, params, total_wires, hbar=2.0):\n    r""""""Calculates the expectation and variance for an arbitrary\n    polynomial of quadrature operators.\n\n    Args:\n        mu (array): vector of means\n        cov (array): covariance matrix\n        wires (Sequence[int]): wires to calculate the expectation for\n        params (array): a :math:`(2N+1)\\times (2N+1)` array containing the linear\n            and quadratic coefficients of the quadrature operators\n            :math:`(\\I, \\x_0, \\p_0, \\x_1, \\p_1,\\dots)`\n        total_wires (int): total number of wires in the system\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n\n    Returns:\n        tuple: the mean and variance of the quadrature-polynomial observable\n    """"""\n    Q = params[0]\n\n    # HACK, we need access to the Poly instance in order to expand the matrix!\n    # TODO: maybe we should make heisenberg_obs a class method or a static method to avoid this being a \'hack\'?\n    op = qml.ops.PolyXP(Q, wires=wires)\n    Q = op.heisenberg_obs(total_wires)\n\n    if Q.ndim == 1:\n        d = np.r_[Q[1::2], Q[2::2]]\n        return d.T @ mu + Q[0], d.T @ cov @ d\n\n    # convert to the (I, x1,x2,..., p1,p2...) ordering\n    M = np.vstack((Q[0:1, :], Q[1::2, :], Q[2::2, :]))\n    M = np.hstack((M[:, 0:1], M[:, 1::2], M[:, 2::2]))\n    d1 = M[1:, 0]\n    d2 = M[0, 1:]\n\n    A = M[1:, 1:]\n    d = d1 + d2\n    k = M[0, 0]\n\n    d2 = 2 * A @ mu + d\n    k2 = mu.T @ A @ mu + mu.T @ d + k\n\n    ex = np.trace(A @ cov) + k2\n    var = 2 * np.trace(A @ cov @ A @ cov) + d2.T @ cov @ d2\n\n    modes = np.arange(2 * total_wires).reshape(2, -1).T\n    groenewald_correction = np.sum([np.linalg.det(hbar * A[:, m][n]) for m in modes for n in modes])\n    var -= groenewald_correction\n\n    return ex, var\n\n\ndef fock_expectation(mu, cov, wires, params, total_wires, hbar=2.0):\n    r""""""Calculates the expectation and variance of a Fock state probability.\n\n    Args:\n        mu (array): length-:math:`2N` vector of means\n        cov (array): :math:`2N\\times 2N` covariance matrix\n        wires (Sequence[int]): wires to calculate the expectation for\n        params (Sequence[int]): the Fock state to return the expectation value for\n        total_wires (int): total number of wires in the system\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n\n    Returns:\n        tuple: the Fock state expectation and variance\n    """"""\n    # pylint: disable=unused-argument\n    ex = fock_prob(mu, cov, params[0], hbar=hbar)\n\n    # var[|n><n|] = E[|n><n|^2] -  E[|n><n|]^2 = E[|n><n|] -  E[|n><n|]^2\n    var = ex - ex ** 2\n    return ex, var\n\n\ndef identity(*_, **__):\n    r""""""Returns 1.\n\n    Returns:\n        tuple: the Fock state expectation and variance\n    """"""\n    return 1, 0\n\n\n# ========================================================\n#  device\n# ========================================================\n\n\nclass DefaultGaussian(Device):\n    r""""""Default Gaussian device for PennyLane.\n\n    Args:\n        wires (int): the number of modes to initialize the device in\n        shots (int): How many times the circuit should be evaluated (or sampled) to estimate\n            the expectation values.\n            If ``analytic == True``, then the number of shots is ignored\n            in the calculation of expectation values and variances, and only controls the number\n            of samples returned by ``sample``.\n        hbar (float): (default 2) the value of :math:`\\hbar` in the commutation\n            relation :math:`[\\x,\\p]=i\\hbar`\n        analytic (bool): indicates if the device should calculate expectations\n            and variances analytically\n    """"""\n    name = ""Default Gaussian PennyLane plugin""\n    short_name = ""default.gaussian""\n    pennylane_requires = ""0.10""\n    version = ""0.10.0""\n    author = ""Xanadu Inc.""\n\n    _capabilities = {""model"": ""cv""}\n\n    _operation_map = {\n        ""Beamsplitter"": beamsplitter,\n        ""ControlledAddition"": controlled_addition,\n        ""ControlledPhase"": controlled_phase,\n        ""Displacement"": displacement,\n        ""QuadraticPhase"": quadratic_phase,\n        ""Rotation"": rotation,\n        ""Squeezing"": squeezing,\n        ""TwoModeSqueezing"": two_mode_squeezing,\n        ""CoherentState"": coherent_state,\n        ""DisplacedSqueezedState"": displaced_squeezed_state,\n        ""SqueezedState"": squeezed_state,\n        ""ThermalState"": thermal_state,\n        ""GaussianState"": gaussian_state,\n        ""Interferometer"": interferometer,\n    }\n\n    _observable_map = {\n        ""NumberOperator"": photon_number,\n        ""X"": homodyne(0),\n        ""P"": homodyne(np.pi / 2),\n        ""QuadOperator"": homodyne(None),\n        ""PolyXP"": poly_quad_expectations,\n        ""FockStateProjector"": fock_expectation,\n        ""Identity"": identity,\n    }\n\n    _circuits = {}\n\n    def __init__(self, wires, *, shots=1000, hbar=2, analytic=True):\n        super().__init__(wires, shots)\n        self.eng = None\n        self.hbar = hbar\n        self.analytic = analytic\n\n        self.reset()\n\n    def pre_apply(self):\n        self.reset()\n\n    def apply(self, operation, wires, par):\n        if operation == ""Displacement"":\n            self._state = displacement(self._state, wires[0], par[0] * cmath.exp(1j * par[1]))\n            return  # we are done here\n\n        if operation == ""GaussianState"":\n            if wires != list(range(self.num_wires)):\n                raise ValueError(\n                    ""GaussianState means vector or covariance matrix is ""\n                    ""the incorrect size for the number of subsystems.""\n                )\n            self._state = self._operation_map[operation](*par, hbar=self.hbar)\n            return  # we are done here\n\n        if ""State"" in operation:\n            # set the new device state\n            mu, cov = self._operation_map[operation](*par, hbar=self.hbar)\n            # state preparations only act on at most 1 subsystem\n            self._state = set_state(self._state, wires[0], mu, cov)\n            return  # we are done here\n\n        # get the symplectic matrix\n        S = self._operation_map[operation](*par)\n\n        # expand the symplectic to act on the proper subsystem\n        S = self.expand(S, wires)\n\n        # apply symplectic matrix to the means vector\n        means = S @ self._state[0]\n        # apply symplectic matrix to the covariance matrix\n        cov = S @ self._state[1] @ S.T\n\n        self._state = [means, cov]\n\n    def expand(self, S, wires):\n        r""""""Expands a Symplectic matrix S to act on the entire subsystem.\n\n        Args:\n            S (array): a :math:`2M\\times 2M` Symplectic matrix\n            wires (Sequence[int]): the wires of the modes that S acts on\n\n        Returns:\n            array: the resulting :math:`2N\\times 2N` Symplectic matrix\n        """"""\n        if self.num_wires == 1:\n            # total number of wires is 1, simply return the matrix\n            return S\n\n        N = self.num_wires\n        w = np.asarray(wires)\n\n        if np.any(w < 0) or np.any(w >= N) or len(set(w)) != len(w):\n            raise ValueError(""Invalid target subsystems provided in \'wires\' argument."")\n\n        M = len(S) // 2\n        S2 = np.identity(2 * N)\n\n        if M != len(wires):\n            raise ValueError(""Incorrect number of subsystems for provided operation."")\n\n        S2[w.reshape(-1, 1), w.reshape(1, -1)] = S[:M, :M].copy()  # XX\n        S2[(w + N).reshape(-1, 1), (w + N).reshape(1, -1)] = S[M:, M:].copy()  # PP\n        S2[w.reshape(-1, 1), (w + N).reshape(1, -1)] = S[:M, M:].copy()  # XP\n        S2[(w + N).reshape(-1, 1), w.reshape(1, -1)] = S[M:, :M].copy()  # PX\n\n        return S2\n\n    def expval(self, observable, wires, par):\n        if observable == ""PolyXP"":\n            mu, cov = self._state\n        else:\n            mu, cov = self.reduced_state(wires)\n\n        ev, var = self._observable_map[observable](\n            mu, cov, wires, par, self.num_wires, hbar=self.hbar\n        )\n\n        if not self.analytic:\n            # estimate the ev\n            # use central limit theorem, sample normal distribution once, only ok if n_eval is large\n            # (see https://en.wikipedia.org/wiki/Berry%E2%80%93Esseen_theorem)\n            ev = np.random.normal(ev, math.sqrt(var / self.shots))\n\n        return ev\n\n    def var(self, observable, wires, par):\n        mu, cov = self.reduced_state(wires)\n        _, var = self._observable_map[observable](\n            mu, cov, wires, par, hbar=self.hbar, total_wires=self.num_wires\n        )\n        return var\n\n    def sample(self, observable, wires, par):\n        """"""Return a sample of an observable.\n\n        .. note::\n\n            The ``default.gaussian`` plugin only supports sampling\n            from :class:`~.X`, :class:`~.P`, and :class:`~.QuadOperator`\n            observables.\n\n        Args:\n            observable (str): name of the observable\n            wires (Sequence[int]): subsystems the observable is to be measured on\n            par (tuple): parameters for the observable\n\n        Returns:\n            array[float]: samples in an array of dimension ``(n, num_wires)``\n        """"""\n        if len(wires) != 1:\n            raise ValueError(""Only one mode can be measured in homodyne."")\n\n        if observable == ""X"":\n            phi = 0.0\n        elif observable == ""P"":\n            phi = np.pi / 2\n        elif observable == ""QuadOperator"":\n            phi = par[0]\n        else:\n            raise NotImplementedError(\n                ""default.gaussian does not support sampling {}"".format(observable)\n            )\n\n        mu, cov = self.reduced_state(wires)\n        rot = rotation(phi)\n\n        muphi = rot.T @ mu\n        covphi = rot.T @ cov @ rot\n\n        stdphi = math.sqrt(covphi[0, 0])\n        meanphi = muphi[0]\n        return np.random.normal(meanphi, stdphi, self.shots)\n\n    def reset(self):\n        """"""Reset the device""""""\n        # init the state vector to |00..0>\n        self._state = vacuum_state(self.num_wires, self.hbar)\n\n    def reduced_state(self, wires):\n        r"""""" Returns the vector of means and the covariance matrix of the specified wires.\n\n        Args:\n            wires (Iterable[int] or int): indices of the requested wires\n\n        Returns:\n            tuple (means, cov): means is an array containing the vector of means,\n            and cov is a square array containing the covariance matrix\n        """"""\n        if wires == list(range(self.num_wires)):\n            # reduced state is full state\n            return self._state\n\n        # reduce rho down to specified subsystems\n        if isinstance(wires, int):\n            wires = [wires]\n\n        if np.any(np.array(wires) > self.num_wires):\n            raise ValueError(\n                ""The specified wires cannot "" ""be larger than the number of subsystems.""\n            )\n\n        ind = np.concatenate([np.array(wires), np.array(wires) + self.num_wires])\n        rows = ind.reshape(-1, 1)\n        cols = ind.reshape(1, -1)\n\n        return self._state[0][ind], self._state[1][rows, cols]\n\n    @property\n    def operations(self):\n        return set(self._operation_map.keys())\n\n    @property\n    def observables(self):\n        return set(self._observable_map.keys())\n'"
pennylane/plugins/default_qubit.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nThe default plugin is meant to be used as a template for writing PennyLane device\nplugins for new qubit-based backends.\n\nIt implements the necessary :class:`~pennylane._device.Device` methods as well as some built-in\n:mod:`qubit operations <pennylane.ops.qubit>`, and provides a very simple pure state\nsimulation of a qubit-based quantum circuit architecture.\n""""""\nimport itertools\nimport functools\nfrom string import ascii_letters as ABC\n\nimport numpy as np\n\nfrom pennylane import QubitDevice, DeviceError, QubitStateVector, BasisState\nfrom pennylane.operation import DiagonalOperation\n\nABC_ARRAY = np.array(list(ABC))\n\n# tolerance for numerical errors\ntolerance = 1e-10\n\n\nclass DefaultQubit(QubitDevice):\n    """"""Default qubit device for PennyLane.\n\n    Args:\n        wires (int): the number of modes to initialize the device in\n        shots (int): How many times the circuit should be evaluated (or sampled) to estimate\n            the expectation values. Defaults to 1000 if not specified.\n            If ``analytic == True``, then the number of shots is ignored\n            in the calculation of expectation values and variances, and only controls the number\n            of samples returned by ``sample``.\n        analytic (bool): indicates if the device should calculate expectations\n            and variances analytically\n    """"""\n\n    name = ""Default qubit PennyLane plugin""\n    short_name = ""default.qubit""\n    pennylane_requires = ""0.10""\n    version = ""0.10.0""\n    author = ""Xanadu Inc.""\n    _capabilities = {""inverse_operations"": True}\n\n    operations = {\n        ""BasisState"",\n        ""QubitStateVector"",\n        ""QubitUnitary"",\n        ""DiagonalQubitUnitary"",\n        ""PauliX"",\n        ""PauliY"",\n        ""PauliZ"",\n        ""MultiRZ"",\n        ""Hadamard"",\n        ""S"",\n        ""T"",\n        ""CNOT"",\n        ""SWAP"",\n        ""CSWAP"",\n        ""Toffoli"",\n        ""CZ"",\n        ""PhaseShift"",\n        ""RX"",\n        ""RY"",\n        ""RZ"",\n        ""Rot"",\n        ""CRX"",\n        ""CRY"",\n        ""CRZ"",\n        ""CRot"",\n    }\n\n    observables = {""PauliX"", ""PauliY"", ""PauliZ"", ""Hadamard"", ""Hermitian"", ""Identity""}\n\n    def __init__(self, wires, *, shots=1000, analytic=True):\n        # call QubitDevice init\n        super().__init__(wires, shots, analytic)\n\n        # Create the initial state. Internally, we store the\n        # state as an array of dimension [2]*wires.\n        self._state = self._create_basis_state(0)\n        self._pre_rotated_state = self._state\n\n    def apply(self, operations, rotations=None, **kwargs):\n        rotations = rotations or []\n\n        # apply the circuit operations\n        for i, operation in enumerate(operations):\n\n            if i > 0 and isinstance(operation, (QubitStateVector, BasisState)):\n                raise DeviceError(\n                    ""Operation {} cannot be used after other Operations have already been applied ""\n                    ""on a {} device."".format(operation.name, self.short_name)\n                )\n\n            self._apply_operation(operation)\n\n        # store the pre-rotated state\n        self._pre_rotated_state = self._state\n\n        # apply the circuit rotations\n        for operation in rotations:\n            self._apply_operation(operation)\n\n    def _apply_operation(self, operation):\n        """"""Applies operations to the internal device state.\n\n        Args:\n            operation (~.Operation): operation to apply on the device\n        """"""\n        wires = operation.wires.tolist()  # TODO: translation to nonconsec wires indices\n\n        if isinstance(operation, QubitStateVector):\n            self._apply_state_vector(operation.parameters[0], wires)\n            return\n\n        if isinstance(operation, BasisState):\n            self._apply_basis_state(operation.parameters[0], wires)\n            return\n\n        matrix = self._get_unitary_matrix(operation)\n\n        if isinstance(operation, DiagonalOperation):\n            self._apply_diagonal_unitary(matrix, wires)\n        elif len(operation.wires) <= 2:\n            # Einsum is faster for small gates\n            self._apply_unitary_einsum(matrix, wires)\n        else:\n            self._apply_unitary(matrix, wires)\n\n    def _get_unitary_matrix(self, unitary):  # pylint: disable=no-self-use\n        """"""Return the matrix representing a unitary operation.\n\n        Args:\n            unitary (~.Operation): a PennyLane unitary operation\n\n        Returns:\n            array[complex]: Returns a 2D matrix representation of\n            the unitary in the computational basis, or, in the case of a diagonal unitary,\n            a 1D array representing the matrix diagonal.\n        """"""\n        if isinstance(unitary, DiagonalOperation):\n            return unitary.eigvals\n\n        return unitary.matrix\n\n    def _create_basis_state(self, index):\n        """"""Return a computational basis state over all wires.\n\n        Args:\n            index (int): integer representing the computational basis state\n\n        Returns:\n            array[complex]: complex array of shape ``[2]*self.num_wires``\n            representing the statevector of the basis state\n        """"""\n        state = np.zeros(2 ** self.num_wires, dtype=np.complex128)\n        state[index] = 1\n        state = self._asarray(state, dtype=self.C_DTYPE)\n        return self._reshape(state, [2] * self.num_wires)\n\n    @property\n    def state(self):\n        return self._flatten(self._pre_rotated_state)\n\n    def _apply_state_vector(self, state, wires):\n        """"""Initialize the internal state vector in a specified state.\n\n        Args:\n            state (array[complex]): normalized input state of length\n                ``2**len(wires)``\n            wires (list[int]): list of wires where the provided state should\n                be initialized\n        """"""\n        state = self._asarray(state, dtype=self.C_DTYPE)\n        n_state_vector = state.shape[0]\n\n        if state.ndim != 1 or n_state_vector != 2 ** len(wires):\n            raise ValueError(""State vector must be of length 2**wires."")\n\n        if not np.allclose(np.linalg.norm(state, ord=2), 1.0, atol=tolerance):\n            raise ValueError(""Sum of amplitudes-squared does not equal one."")\n\n        if len(wires) == self.num_wires and sorted(wires) == wires:\n            # Initialize the entire register with the state\n            self._state = self._reshape(state, [2] * self.num_wires)\n            return\n\n        # generate basis states on subset of qubits via the cartesian product\n        basis_states = np.array(list(itertools.product([0, 1], repeat=len(wires))))\n\n        # get basis states to alter on full set of qubits\n        unravelled_indices = np.zeros((2 ** len(wires), self.num_wires), dtype=int)\n        unravelled_indices[:, wires] = basis_states\n\n        # get indices for which the state is changed to input state vector elements\n        ravelled_indices = np.ravel_multi_index(unravelled_indices.T, [2] * self.num_wires)\n\n        state = self._scatter(ravelled_indices, state, [2 ** self.num_wires])\n        state = self._reshape(state, [2] * self.num_wires)\n        self._state = self._asarray(state, dtype=self.C_DTYPE)\n\n    def _apply_basis_state(self, state, wires):\n        """"""Initialize the state vector in a specified computational basis state.\n\n        Args:\n            state (array[int]): computational basis state of shape ``(wires,)``\n                consisting of 0s and 1s.\n            wires (list[int]): list of wires where the provided computational state should\n                be initialized\n        """"""\n        # length of basis state parameter\n        n_basis_state = len(state)\n\n        if not set(state).issubset({0, 1}):\n            raise ValueError(""BasisState parameter must consist of 0 or 1 integers."")\n\n        if n_basis_state != len(wires):\n            raise ValueError(""BasisState parameter and wires must be of equal length."")\n\n        # get computational basis state number\n        basis_states = 2 ** (self.num_wires - 1 - np.array(wires))\n        num = int(np.dot(state, basis_states))\n\n        self._state = self._create_basis_state(num)\n\n    def _apply_unitary(self, mat, wires):\n        r""""""Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            wires (Sequence[int]): target subsystems\n        """"""\n        mat = self._cast(self._reshape(mat, [2] * len(wires) * 2), dtype=self.C_DTYPE)\n        axes = (np.arange(len(wires), 2 * len(wires)), wires)\n        tdot = self._tensordot(mat, self._state, axes=axes)\n\n        # tensordot causes the axes given in `wires` to end up in the first positions\n        # of the resulting tensor. This corresponds to a (partial) transpose of\n        # the correct output state\n        # We\'ll need to invert this permutation to put the indices in the correct place\n        unused_idxs = [idx for idx in range(self.num_wires) if idx not in wires]\n        perm = list(wires) + unused_idxs\n        inv_perm = np.argsort(perm)  # argsort gives inverse permutation\n        self._state = self._transpose(tdot, inv_perm)\n\n    def _apply_unitary_einsum(self, mat, wires):\n        r""""""Apply multiplication of a matrix to subsystems of the quantum state.\n\n        This function uses einsum instead of tensordot. This approach is only\n        faster for single- and two-qubit gates.\n\n        Args:\n            mat (array): matrix to multiply\n            wires (Sequence[int]): target subsystems\n        """"""\n        mat = self._cast(self._reshape(mat, [2] * len(wires) * 2), dtype=self.C_DTYPE)\n\n        # Tensor indices of the quantum state\n        state_indices = ABC[: self.num_wires]\n\n        # Indices of the quantum state affected by this operation\n        affected_indices = """".join(ABC_ARRAY[wires].tolist())\n\n        # All affected indices will be summed over, so we need the same number of new indices\n        new_indices = ABC[self.num_wires : self.num_wires + len(wires)]\n\n        # The new indices of the state are given by the old ones with the affected indices\n        # replaced by the new_indices\n        new_state_indices = functools.reduce(\n            lambda old_string, idx_pair: old_string.replace(idx_pair[0], idx_pair[1]),\n            zip(affected_indices, new_indices),\n            state_indices,\n        )\n\n        # We now put together the indices in the notation numpy\'s einsum requires\n        einsum_indices = ""{new_indices}{affected_indices},{state_indices}->{new_state_indices}"".format(\n            affected_indices=affected_indices,\n            state_indices=state_indices,\n            new_indices=new_indices,\n            new_state_indices=new_state_indices,\n        )\n\n        self._state = self._einsum(einsum_indices, mat, self._state)\n\n    def _apply_diagonal_unitary(self, phases, wires):\n        r""""""Apply multiplication of a phase vector to subsystems of the quantum state.\n\n        This represents the multiplication with diagonal gates in a more efficient manner.\n\n        Args:\n            phases (array): vector to multiply\n            wires (Sequence[int]): target subsystems\n        """"""\n        # reshape vectors\n        phases = self._cast(self._reshape(phases, [2] * len(wires)), dtype=self.C_DTYPE)\n\n        state_indices = ABC[: self.num_wires]\n        affected_indices = """".join(ABC_ARRAY[wires].tolist())\n\n        einsum_indices = ""{affected_indices},{state_indices}->{state_indices}"".format(\n            affected_indices=affected_indices, state_indices=state_indices\n        )\n\n        self._state = self._einsum(einsum_indices, phases, self._state)\n\n    def reset(self):\n        """"""Reset the device""""""\n        super().reset()\n\n        # init the state vector to |00..0>\n        self._state = self._create_basis_state(0)\n        self._pre_rotated_state = self._state\n\n    def analytic_probability(self, wires=None):\n        """"""Return the (marginal) analytic probability of each computational basis state.""""""\n        if self._state is None:\n            return None\n\n        wires = wires or range(self.num_wires)\n        prob = self.marginal_prob(self._abs(self._flatten(self._state)) ** 2, wires)\n        return prob\n'"
pennylane/plugins/default_qubit_tf.py,27,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""This module contains a TensorFlow implementation of the :class:`~.DefaultQubit`\r\nreference plugin.\r\n""""""\r\nimport numpy as np\r\n\r\nfrom pennylane.operation import DiagonalOperation\r\n\r\ntry:\r\n    import tensorflow as tf\r\n\r\n    if tf.__version__[0] == ""1"":\r\n        raise ImportError(""default.tensor.tf device requires TensorFlow>=2.0"")\r\n\r\nexcept ImportError as e:\r\n    raise ImportError(""default.tensor.tf device requires TensorFlow>=2.0"")\r\n\r\n\r\n# With TF 2.1+, the legacy tf.einsum was renamed to _einsum_v1, while\r\n# the replacement tf.einsum introduced the bug. This try-except block\r\n# will dynamically patch TensorFlow versions where _einsum_v1 exists, to make it the\r\n# default einsum implementation.\r\n#\r\n# For more details, see https://github.com/tensorflow/tensorflow/issues/37307\r\ntry:\r\n    from tensorflow.python.ops.special_math_ops import _einsum_v1\r\n\r\n    tf.einsum = _einsum_v1\r\nexcept ImportError:\r\n    pass\r\n\r\nfrom . import DefaultQubit\r\nfrom . import tf_ops\r\n\r\n\r\nclass DefaultQubitTF(DefaultQubit):\r\n    """"""Simulator plugin based on ``""default.qubit""``, written using TensorFlow.\r\n\r\n    **Short name:** ``default.qubit.tf``\r\n\r\n    This device provides a pure-state qubit simulator written using TensorFlow.\r\n    As a result, it supports classical backpropagation as a means to compute the Jacobian. This can\r\n    be faster than the parameter-shift rule for analytic quantum gradients\r\n    when the number of parameters to be optimized is large.\r\n\r\n    To use this device, you will need to install TensorFlow:\r\n\r\n    .. code-block:: console\r\n\r\n        pip install tensorflow>=2.0\r\n\r\n    **Example**\r\n\r\n    The ``default.qubit.tf`` is designed to be used with end-to-end classical backpropagation\r\n    (``diff_method=""backprop""``) with the TensorFlow interface. This is the default method\r\n    of differentiation when creating a QNode with this device.\r\n\r\n    Using this method, the created QNode is a \'white-box\', and is\r\n    tightly integrated with your TensorFlow computation:\r\n\r\n    >>> dev = qml.device(""default.qubit.tf"", wires=1)\r\n    >>> @qml.qnode(dev, interface=""tf"", diff_method=""backprop"")\r\n    ... def circuit(x):\r\n    ...     qml.RX(x[1], wires=0)\r\n    ...     qml.Rot(x[0], x[1], x[2], wires=0)\r\n    ...     return qml.expval(qml.PauliZ(0))\r\n    >>> weights = tf.Variable([0.2, 0.5, 0.1])\r\n    >>> with tf.GradientTape() as tape:\r\n    ...     res = circuit(weights)\r\n    >>> print(tape.gradient(res, weights))\r\n    tf.Tensor([-2.2526717e-01 -1.0086454e+00  1.3877788e-17], shape=(3,), dtype=float32)\r\n\r\n    Autograph mode will also work when using classical backpropagation:\r\n\r\n    >>> @tf.function\r\n    ... def cost(weights):\r\n    ...     return tf.reduce_sum(circuit(weights)**3) - 1\r\n    >>> with tf.GradientTape() as tape:\r\n    ...     res = cost(weights)\r\n    >>> print(tape.gradient(res, weights))\r\n    tf.Tensor([-3.5471588e-01 -1.5882589e+00  3.4694470e-17], shape=(3,), dtype=float32)\r\n\r\n    There are a couple of things to keep in mind when using the ``""backprop""``\r\n    differentiation method for QNodes:\r\n\r\n    * You must use the ``""tf""`` interface for classical backpropagation, as TensorFlow is\r\n      used as the device backend.\r\n\r\n    * Only exact expectation values, variances, and probabilities are differentiable.\r\n      When instantiating the device with ``analytic=False``, differentiating QNode\r\n      outputs will result in ``None``.\r\n\r\n\r\n    If you wish to use a different machine-learning interface, or prefer to calculate quantum\r\n    gradients using the ``parameter-shift`` or ``finite-diff`` differentiation methods,\r\n    consider using the ``default.qubit`` device instead.\r\n\r\n\r\n    Args:\r\n        wires (int): the number of wires to initialize the device with\r\n\r\n        shots (int): How many times the circuit should be evaluated (or sampled) to estimate\r\n            the expectation values. Defaults to 1000 if not specified.\r\n            If ``analytic == True``, then the number of shots is ignored\r\n            in the calculation of expectation values and variances, and only controls the number\r\n            of samples returned by ``sample``.\r\n        analytic (bool): indicates if the device should calculate expectations\r\n            and variances analytically\r\n    """"""\r\n\r\n    name = ""Default qubit (TensorFlow) PennyLane plugin""\r\n    short_name = ""default.qubit.tf""\r\n\r\n    _capabilities = {\r\n        ""model"": ""qubit"",\r\n        ""provides_jacobian"": False,\r\n        ""passthru_interface"": ""tf"",\r\n    }\r\n\r\n    parametric_ops = {\r\n        ""PhaseShift"": tf_ops.PhaseShift,\r\n        ""RX"": tf_ops.RX,\r\n        ""RY"": tf_ops.RY,\r\n        ""RZ"": tf_ops.RZ,\r\n        ""Rot"": tf_ops.Rot,\r\n        ""CRX"": tf_ops.CRX,\r\n        ""CRY"": tf_ops.CRY,\r\n        ""CRZ"": tf_ops.CRZ,\r\n    }\r\n\r\n    C_DTYPE = tf.complex128\r\n    R_DTYPE = tf.float64\r\n    _asarray = staticmethod(tf.convert_to_tensor)\r\n    _dot = staticmethod(lambda x, y: tf.tensordot(x, y, axes=1))\r\n    _abs = staticmethod(tf.abs)\r\n    _reduce_sum = staticmethod(tf.reduce_sum)\r\n    _reshape = staticmethod(tf.reshape)\r\n    _flatten = staticmethod(lambda tensor: tf.reshape(tensor, [-1]))\r\n    _gather = staticmethod(tf.gather)\r\n    _einsum = staticmethod(tf.einsum)\r\n    _cast = staticmethod(tf.cast)\r\n    _transpose = staticmethod(tf.transpose)\r\n    _tensordot = staticmethod(tf.tensordot)\r\n\r\n    @staticmethod\r\n    def _scatter(indices, array, new_dimensions):\r\n        indices = np.expand_dims(indices, 1)\r\n        return tf.scatter_nd(indices, array, new_dimensions)\r\n\r\n    def _get_unitary_matrix(self, unitary):\r\n        """"""Return the matrix representing a unitary operation.\r\n\r\n        Args:\r\n            unitary (~.Operation): a PennyLane unitary operation\r\n\r\n        Returns:\r\n            tf.Tensor[complex] or array[complex]: Returns a 2D matrix representation of\r\n            the unitary in the computational basis, or, in the case of a diagonal unitary,\r\n            a 1D array representing the matrix diagonal. For non-parametric unitaries,\r\n            the return type will be a ``np.ndarray``. For parametric unitaries, a ``tf.Tensor``\r\n            object will be returned.\r\n        """"""\r\n        if unitary.name in self.parametric_ops:\r\n            return self.parametric_ops[unitary.name](*unitary.parameters)\r\n\r\n        if isinstance(unitary, DiagonalOperation):\r\n            return unitary.eigvals\r\n\r\n        return unitary.matrix\r\n'"
pennylane/plugins/tf_ops.py,47,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\nr""""""\r\nUtility functions and numerical implementations of quantum operations TensorFlow devices.\r\n""""""\r\nimport tensorflow as tf\r\nfrom numpy import kron\r\n\r\nC_DTYPE = tf.complex128\r\nR_DTYPE = tf.float64\r\n\r\nI = tf.constant([[1, 0], [0, 1]], dtype=C_DTYPE)\r\nX = tf.constant([[0, 1], [1, 0]], dtype=C_DTYPE)\r\nY = tf.constant([[0j, -1j], [1j, 0j]], dtype=C_DTYPE)\r\nZ = tf.constant([[1, 0], [0, -1]], dtype=C_DTYPE)\r\n\r\nII = tf.eye(4, dtype=C_DTYPE)\r\nZZ = tf.constant(kron(Z, Z), dtype=C_DTYPE)\r\n\r\nIX = tf.constant(kron(I, X), dtype=C_DTYPE)\r\nIY = tf.constant(kron(I, Y), dtype=C_DTYPE)\r\nIZ = tf.constant(kron(I, Z), dtype=C_DTYPE)\r\n\r\nZI = tf.constant(kron(Z, I), dtype=C_DTYPE)\r\nZX = tf.constant(kron(Z, X), dtype=C_DTYPE)\r\nZY = tf.constant(kron(Z, Y), dtype=C_DTYPE)\r\n\r\n\r\ndef PhaseShift(phi):\r\n    r""""""One-qubit phase shift.\r\n\r\n    Args:\r\n        phi (float): phase shift angle\r\n\r\n    Returns:\r\n        tf.Tensor[complex]: diagonal part of the phase shift matrix\r\n    """"""\r\n    phi = tf.cast(phi, dtype=C_DTYPE)\r\n    return tf.convert_to_tensor([1.0, tf.exp(1j * phi)])\r\n\r\n\r\ndef RX(theta):\r\n    r""""""One-qubit rotation about the x axis.\r\n\r\n    Args:\r\n        theta (float): rotation angle\r\n\r\n    Returns:\r\n        tf.Tensor[complex]: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_x \\theta/2}`\r\n    """"""\r\n    theta = tf.cast(theta, dtype=C_DTYPE)\r\n    return tf.cos(theta / 2) * I + 1j * tf.sin(-theta / 2) * X\r\n\r\n\r\ndef RY(theta):\r\n    r""""""One-qubit rotation about the y axis.\r\n\r\n    Args:\r\n        theta (float): rotation angle\r\n\r\n    Returns:\r\n        tf.Tensor[complex]: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_y \\theta/2}`\r\n    """"""\r\n    theta = tf.cast(theta, dtype=C_DTYPE)\r\n    return tf.cos(theta / 2) * I + 1j * tf.sin(-theta / 2) * Y\r\n\r\n\r\ndef RZ(theta):\r\n    r""""""One-qubit rotation about the z axis.\r\n\r\n    Args:\r\n        theta (float): rotation angle\r\n\r\n    Returns:\r\n        tf.Tensor[complex]: the diagonal part of the rotation matrix :math:`e^{-i \\sigma_z \\theta/2}`\r\n    """"""\r\n    theta = tf.cast(theta, dtype=C_DTYPE)\r\n    p = tf.exp(-0.5j * theta)\r\n    return tf.convert_to_tensor([p, tf.math.conj(p)])\r\n\r\n\r\ndef Rot(a, b, c):\r\n    r""""""Arbitrary one-qubit rotation using three Euler angles.\r\n\r\n    Args:\r\n        a,b,c (float): rotation angles\r\n\r\n    Returns:\r\n        tf.Tensor[complex]: unitary 2x2 rotation matrix ``rz(c) @ ry(b) @ rz(a)``\r\n    """"""\r\n    return tf.linalg.diag(RZ(c)) @ RY(b) @ tf.linalg.diag(RZ(a))\r\n\r\n\r\ndef CRX(theta):\r\n    r""""""Two-qubit controlled rotation about the x axis.\r\n\r\n    Args:\r\n        theta (float): rotation angle\r\n\r\n    Returns:\r\n        tf.Tensor[complex]: unitary 4x4 rotation matrix\r\n        :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_x(\\theta)`\r\n    """"""\r\n    theta = tf.cast(theta, dtype=C_DTYPE)\r\n    return (\r\n        tf.cos(theta / 4) ** 2 * II\r\n        - 1j * tf.sin(theta / 2) / 2 * IX\r\n        + tf.sin(theta / 4) ** 2 * ZI\r\n        + 1j * tf.sin(theta / 2) / 2 * ZX\r\n    )\r\n\r\n\r\ndef CRY(theta):\r\n    r""""""Two-qubit controlled rotation about the y axis.\r\n\r\n    Args:\r\n        theta (float): rotation angle\r\n    Returns:\r\n        tf.Tensor[complex]: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_y(\\theta)`\r\n    """"""\r\n    theta = tf.cast(theta, dtype=C_DTYPE)\r\n    return (\r\n        tf.cos(theta / 4) ** 2 * II\r\n        - 1j * tf.sin(theta / 2) / 2 * IY\r\n        + tf.sin(theta / 4) ** 2 * ZI\r\n        + 1j * tf.sin(theta / 2) / 2 * ZY\r\n    )\r\n\r\n\r\ndef CRZ(theta):\r\n    r""""""Two-qubit controlled rotation about the z axis.\r\n\r\n    Args:\r\n        theta (float): rotation angle\r\n    Returns:\r\n        tf.Tensor[complex]: diagonal part of the 4x4 rotation matrix\r\n        :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_z(\\theta)`\r\n    """"""\r\n    theta = tf.cast(theta, dtype=C_DTYPE)\r\n    p = tf.exp(-0.5j * theta)\r\n    return tf.convert_to_tensor([1.0, 1.0, p, tf.math.conj(p)])\r\n\r\n\r\ndef CRot(a, b, c):\r\n    r""""""Arbitrary two-qubit controlled rotation using three Euler angles.\r\n\r\n    Args:\r\n        a,b,c (float): rotation angles\r\n    Returns:\r\n        tf.Tensor[complex]: unitary 4x4 rotation matrix\r\n        :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R(a,b,c)`\r\n    """"""\r\n    return tf.linalg.diag(CRZ(c)) @ (CRY(b) @ tf.linalg.diag(CRZ(a)))\r\n'"
pennylane/qnn/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""This module contains classes and functions for constructing quantum neural networks from QNodes.""""""\n\nimport pennylane.qnn.cost\n\nfrom .keras import KerasLayer\nfrom .torch import TorchLayer\n'"
pennylane/qnn/cost.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis submodule contains frequently used loss and cost functions.\n""""""\n# pylint: disable=too-many-arguments\nimport pennylane as qml\n\n\nclass SquaredErrorLoss:\n    r""""""Squared error loss function for circuits with trainable parameters.\n\n    Combines an ansatz circuit with some target observables and calculates\n    the squared error between their expectation values and a target.\n\n    Args:\n        ansatz (callable): The ansatz for the circuit before the final measurement step.\n            Note that the ansatz **must** have the following signature:\n\n            .. code-block:: python\n\n                ansatz(params, **kwargs)\n\n            where ``params`` are the trainable weights of the variational circuit, and\n            ``kwargs`` are any additional keyword arguments that need to be passed\n            to the template.\n        observables (Iterable[.Observable]): observables to measure during the\n            final step of each circuit\n        device (Device, Sequence[Device]): Corresponding device(s) where the resulting\n            function should be executed. This can either be a single device, or a list\n            of devices of length matching the number of observables.\n        interface (str, None): Which interface to use.\n            This affects the types of objects that can be passed to/returned to the function.\n            Supports all interfaces supported by the :func:`~.qnode` decorator.\n        diff_method (str, None): The method of differentiation to use with the created function.\n            Supports all differentiation methods supported by the :func:`~.qnode` decorator.\n\n    Returns:\n        callable: a loss function with signature ``loss(*args, target=None, **kwargs)`` that calculates\n        the squared error loss between the observables\' expectation values and a target.\n\n    .. seealso:: :func:`~.map`\n\n    **Example:**\n\n    First, we create a device and design an ansatz:\n\n    .. code-block:: python\n\n        dev = qml.device(\'default.qubit\', wires=3)\n\n        def ansatz(phis, **kwargs):\n            for w, phi in enumerate(phis):\n                qml.RX(phi, wires=w)\n\n    Now we can create the observables:\n\n    .. code-block:: python3\n\n        obs = [\n            qml.PauliZ(0),\n            qml.PauliX(0),\n            qml.PauliZ(1) @ qml.PauliZ(2)\n        ]\n\n    Next, we can define the loss function:\n\n    >>> loss = qml.qnn.SquaredErrorLoss(ansatz, observables, dev, interface=""torch"")\n    >>> phis = np.ones(num_qubits)\n    >>> loss(phis, target=np.array([1.0, 0.5, 0.1]))\n    tensor([0.2113, 0.2500, 0.0368], dtype=torch.float64)\n\n    The loss function can be minimized using any gradient descent-based\n    :doc:`optimizer </introduction/optimizers>`.\n    """"""\n\n    def __init__(\n        self,\n        ansatz,\n        observables,\n        device,\n        measure=""expval"",\n        interface=""autograd"",\n        diff_method=""best"",\n        **kwargs,\n    ):\n        self.qnodes = qml.map(\n            ansatz,\n            observables,\n            device,\n            measure=measure,\n            interface=interface,\n            diff_method=diff_method,\n            **kwargs,\n        )\n\n    def loss(self, *args, target=None, **kwargs):\n        r""""""Calculates the squared error loss between the observables\'\n        expectation values and a target.\n\n        Keyword Args:\n            target (tensor): target values\n\n        Returns:\n            array[float]: squared error values\n        """"""\n\n        if target is None:\n            raise ValueError(""The target cannot be None"")\n\n        input_ = self.qnodes(*args, **kwargs)\n\n        if len(target) != len(input_):\n            raise ValueError(\n                f""Input target of incorrect length {len(target)} instead of {len(input_)}""\n            )\n\n        return (input_ - target) ** 2\n\n    def __call__(self, *args, **kwargs):\n        return self.loss(*args, **kwargs)\n'"
pennylane/qnn/keras.py,16,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""This module contains the classes and functions for integrating QNodes with the Keras Layer\nAPI.""""""\nimport functools\nimport inspect\nfrom collections.abc import Iterable\nfrom typing import Optional\n\ntry:\n    import tensorflow as tf\n    from tensorflow.keras.layers import Layer\n    from pennylane.interfaces.tf import to_tf\n\n    CORRECT_TF_VERSION = int(tf.__version__.split(""."")[0]) > 1\nexcept ImportError:\n    # The following allows this module to be imported even if TensorFlow is not installed. Users\n    # will instead see an ImportError when instantiating the KerasLayer.\n    from abc import ABC\n\n    Layer = ABC\n    CORRECT_TF_VERSION = False\n\n\nclass KerasLayer(Layer):\n    """"""Converts a :func:`~.QNode` to a Keras\n    `Layer <https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer>`__.\n\n    The result can be used within the Keras\n    `Sequential <https://www.tensorflow.org/api_docs/python/tf/keras/Sequential>`__ or\n    `Model <https://www.tensorflow.org/api_docs/python/tf/keras/Model>`__ classes for\n    creating quantum and hybrid models.\n\n    Args:\n        qnode (qml.QNode): the PennyLane QNode to be converted into a Keras Layer_\n        weight_shapes (dict[str, tuple]): a dictionary mapping from all weights used in the QNode to\n            their corresponding shapes\n        output_dim (int): the output dimension of the QNode\n        weight_specs (dict[str, dict]): An optional dictionary for users to provide additional\n            specifications for weights used in the QNode, such as the method of parameter\n            initialization. This specification is provided as a dictionary with keys given by the\n            arguments of the `add_weight()\n            <https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer#add_weight>`__.\n            method and values being the corresponding specification.\n        **kwargs: additional keyword arguments passed to the Layer_ base class\n\n    **Example**\n\n    First let\'s define the QNode that we want to convert into a Keras Layer_:\n\n    .. code-block:: python\n\n        n_qubits = 2\n        dev = qml.device(""default.qubit"", wires=n_qubits)\n\n        @qml.qnode(dev)\n        def qnode(inputs, weights_0, weight_1):\n            qml.RX(inputs[0], wires=0)\n            qml.RX(inputs[1], wires=1)\n            qml.Rot(*weights_0, wires=0)\n            qml.RY(weight_1, wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n    The signature of the QNode **must** contain an ``inputs`` named argument for input data,\n    with all other arguments to be treated as internal weights. We can then convert to a Keras\n    Layer_ with:\n\n    >>> weight_shapes = {""weights_0"": 3, ""weight_1"": 1}\n    >>> qlayer = qml.qnn.KerasLayer(qnode, weight_shapes, output_dim=2)\n\n    The internal weights of the QNode are automatically initialized within the\n    :class:`~.KerasLayer` and must have their shapes specified in a ``weight_shapes`` dictionary.\n    It is then easy to combine with other neural network layers from the\n    `tensorflow.keras.layers <https://www.tensorflow.org/api_docs/python/tf/keras/layers>`__ module\n    and create a hybrid:\n\n    >>> clayer = tf.keras.layers.Dense(2)\n    >>> model = tf.keras.models.Sequential([qlayer, clayer])\n\n    .. UsageDetails::\n\n        **QNode signature**\n\n        The QNode must have a signature that satisfies the following conditions:\n\n        - Contain an ``inputs`` named argument for input data.\n        - All other arguments must accept an array or tensor and are treated as internal\n          weights of the QNode.\n        - All other arguments must have no default value.\n        - The ``inputs`` argument is permitted to have a default value provided the gradient with\n          respect to ``inputs`` is not required.\n        - There cannot be a variable number of positional or keyword arguments, e.g., no ``*args``\n          or ``**kwargs`` present in the signature.\n\n        **Initializing weights**\n\n        The optional ``weight_specs`` argument of :class:`~.KerasLayer` allows for a more\n        fine-grained specification of the QNode weights, such as the method of initialization and\n        any regularization or constraints. For example, the initialization method of the ``weights``\n        argument in the example above could be specified by:\n\n        .. code-block::\n\n            weight_specs = {""weights"": {""initializer"": ""random_uniform""}}\n\n        The values of ``weight_specs`` are dictionaries with keys given by arguments of\n        the Keras\n        `add_weight() <https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer#add_weight>`__\n        method. For the ``""initializer""`` argument, one can specify a string such as\n        ``""random_uniform""`` or an instance of an `Initializer\n        <https://www.tensorflow.org/api_docs/python/tf/keras/initializers>`__ class, such as\n        `tf.keras.initializers.RandomUniform <https://www.tensorflow.org/api_docs/python/tf/random_uniform_initializer>`__.\n\n        If ``weight_specs`` is not specified, weights will be added using the Keras default\n        initialization and without any regularization or constraints.\n\n        **Additional example**\n\n        The code block below shows how a circuit composed of templates from the\n        :doc:`/code/qml_templates` module can be combined with classical\n        `Dense <https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dense>`__ layers to learn\n        the two-dimensional `moons <https://scikit-learn.org/stable/modules/generated/sklearn\n        .datasets.make_moons.html>`__ dataset.\n\n        .. code-block:: python\n\n            import pennylane as qml\n            import tensorflow as tf\n            import sklearn.datasets\n\n            n_qubits = 2\n            dev = qml.device(""default.qubit"", wires=n_qubits)\n\n            @qml.qnode(dev)\n            def qnode(inputs, weights):\n                qml.templates.AngleEmbedding(inputs, wires=range(n_qubits))\n                qml.templates.StronglyEntanglingLayers(weights, wires=range(n_qubits))\n                return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n            weight_shapes = {""weights"": (3, n_qubits, 3)}\n\n            qlayer = qml.qnn.KerasLayer(qnode, weight_shapes, output_dim=2)\n            clayer1 = tf.keras.layers.Dense(2)\n            clayer2 = tf.keras.layers.Dense(2, activation=""softmax"")\n            model = tf.keras.models.Sequential([clayer1, qlayer, clayer2])\n\n            data = sklearn.datasets.make_moons()\n            X = tf.constant(data[0])\n            Y = tf.one_hot(data[1], depth=2)\n\n            opt = tf.keras.optimizers.SGD(learning_rate=0.5)\n            model.compile(opt, loss=\'mae\')\n\n        The model can be trained using:\n\n        >>> model.fit(X, Y, epochs=8, batch_size=5)\n        Train on 100 samples\n        Epoch 1/8\n        100/100 [==============================] - 9s 90ms/sample - loss: 0.3524\n        Epoch 2/8\n        100/100 [==============================] - 9s 87ms/sample - loss: 0.2441\n        Epoch 3/8\n        100/100 [==============================] - 9s 87ms/sample - loss: 0.1908\n        Epoch 4/8\n        100/100 [==============================] - 9s 87ms/sample - loss: 0.1832\n        Epoch 5/8\n        100/100 [==============================] - 9s 88ms/sample - loss: 0.1596\n        Epoch 6/8\n        100/100 [==============================] - 9s 87ms/sample - loss: 0.1637\n        Epoch 7/8\n        100/100 [==============================] - 9s 86ms/sample - loss: 0.1613\n        Epoch 8/8\n        100/100 [==============================] - 9s 87ms/sample - loss: 0.1474\n\n    .. _Layer: https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer\n    """"""\n\n    def __init__(\n        self, qnode, weight_shapes: dict, output_dim, weight_specs: Optional[dict] = None, **kwargs\n    ):\n        if not CORRECT_TF_VERSION:\n            raise ImportError(\n                ""KerasLayer requires TensorFlow version 2 or above. The latest ""\n                ""version of TensorFlow can be installed using:\\n""\n                ""pip install tensorflow --upgrade\\nAlternatively, visit ""\n                ""https://www.tensorflow.org/install for detailed instructions.""\n            )\n\n        self.sig = qnode.func.sig\n\n        if self.input_arg not in self.sig:\n            raise TypeError(\n                ""QNode must include an argument with name {} for inputting data"".format(\n                    self.input_arg\n                )\n            )\n\n        if self.input_arg in set(weight_shapes.keys()):\n            raise ValueError(\n                ""{} argument should not have its dimension specified in ""\n                ""weight_shapes"".format(self.input_arg)\n            )\n\n        if set(weight_shapes.keys()) | {self.input_arg} != set(self.sig.keys()):\n            raise ValueError(""Must specify a shape for every non-input parameter in the QNode"")\n\n        if qnode.func.var_pos:\n            raise TypeError(""Cannot have a variable number of positional arguments"")\n\n        if qnode.func.var_keyword:\n            raise TypeError(""Cannot have a variable number of keyword arguments"")\n\n        self.qnode = to_tf(qnode, dtype=tf.keras.backend.floatx())\n        self.weight_shapes = {\n            weight: (tuple(size) if isinstance(size, Iterable) else (size,) if size > 1 else ())\n            for weight, size in weight_shapes.items()\n        }\n\n        # Allows output_dim to be specified as an int, e.g., 5, or as a length-1 tuple, e.g., (5,)\n        self.output_dim = output_dim[0] if isinstance(output_dim, Iterable) else output_dim\n\n        defaults = {\n            name for name, sig in self.sig.items() if sig.par.default != inspect.Parameter.empty\n        }\n        self.input_is_default = self.input_arg in defaults\n        if defaults - {self.input_arg} != set():\n            raise TypeError(\n                ""Only the argument {} is permitted to have a default"".format(self.input_arg)\n            )\n\n        self.weight_specs = weight_specs if weight_specs is not None else {}\n\n        self.qnode_weights = {}\n\n        super().__init__(dynamic=True, **kwargs)\n\n    def build(self, input_shape):\n        """"""Initializes the QNode weights.\n\n        Args:\n            input_shape (tuple or tf.TensorShape): shape of input data\n        """"""\n        for weight, size in self.weight_shapes.items():\n            spec = self.weight_specs.get(weight, {})\n            self.qnode_weights[weight] = self.add_weight(name=weight, shape=size, **spec)\n\n        super().build(input_shape)\n\n    def call(self, inputs):\n        """"""Evaluates the QNode on input data using the initialized weights.\n\n        Args:\n            inputs (tensor): data to be processed\n\n        Returns:\n            tensor: output data\n        """"""\n        outputs = []\n        for x in inputs:  # iterate over batch\n\n            # The QNode can require some passed arguments to be positional and others to be keyword.\n            # The following loops through input arguments in order and uses functools.partial to\n            # bind the argument to the QNode.\n            qnode = self.qnode\n\n            for arg in self.sig:\n                if arg is not self.input_arg:  # Non-input arguments must always be positional\n                    w = self.qnode_weights[arg]\n                    qnode = functools.partial(qnode, w)\n                else:\n                    if self.input_is_default:  # The input argument can be positional or keyword\n                        qnode = functools.partial(qnode, **{self.input_arg: x})\n                    else:\n                        qnode = functools.partial(qnode, x)\n            outputs.append(qnode())\n\n        return tf.stack(outputs)\n\n    def compute_output_shape(self, input_shape):\n        """"""Computes the output shape after passing data of shape ``input_shape`` through the\n        QNode.\n\n        Args:\n            input_shape (tuple or tf.TensorShape): shape of input data\n\n        Returns:\n            tf.TensorShape: shape of output data\n        """"""\n        return tf.TensorShape([input_shape[0], self.output_dim])\n\n    def __str__(self):\n        detail = ""<Quantum Keras Layer: func={}>""\n        return detail.format(self.qnode.func.__name__)\n\n    __repr__ = __str__\n\n    _input_arg = ""inputs""\n\n    @property\n    def input_arg(self):\n        """"""Name of the argument to be used as the input to the Keras\n        `Layer <https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer>`__. Set to\n        ``""inputs""``.""""""\n        return self._input_arg\n'"
pennylane/qnn/torch.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""This module contains the classes and functions for integrating QNodes with the Torch Module\nAPI.""""""\nimport functools\nimport inspect\nimport math\nfrom collections.abc import Iterable\nfrom typing import Callable, Optional\n\ntry:\n    import torch\n    from torch.nn import Module\n    from pennylane.interfaces.torch import to_torch\n\n    TORCH_IMPORTED = True\nexcept ImportError:\n    # The following allows this module to be imported even if PyTorch is not installed. Users\n    # will instead see an ImportError when instantiating the TorchLayer.\n    from unittest.mock import Mock\n\n    Module = Mock\n    TORCH_IMPORTED = False\n\n\nclass TorchLayer(Module):\n    r""""""Converts a :func:`~.QNode` to a Torch layer.\n\n    The result can be used within the ``torch.nn``\n    `Sequential <https://pytorch.org/docs/stable/nn.html#sequential>`__ or\n    `Module <https://pytorch.org/docs/stable/nn.html#module>`__ classes for\n    creating quantum and hybrid models.\n\n    Args:\n        qnode (qml.QNode): the PennyLane QNode to be converted into a Torch layer\n        weight_shapes (dict[str, tuple]): a dictionary mapping from all weights used in the QNode to\n            their corresponding shapes\n        init_method (callable): a `torch.nn.init <https://pytorch.org/docs/stable/nn.init.html>`__\n            function for initializing the QNode weights. If not specified, weights are randomly\n            initialized using the uniform distribution over :math:`[0, 2 \\pi]`.\n\n    **Example**\n\n    First let\'s define the QNode that we want to convert into a Torch layer:\n\n    .. code-block:: python\n\n        n_qubits = 2\n        dev = qml.device(""default.qubit"", wires=n_qubits)\n\n        @qml.qnode(dev)\n        def qnode(inputs, weights_0, weight_1):\n            qml.RX(inputs[0], wires=0)\n            qml.RX(inputs[1], wires=1)\n            qml.Rot(*weights_0, wires=0)\n            qml.RY(weight_1, wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n    The signature of the QNode **must** contain an ``inputs`` named argument for input data,\n    with all other arguments to be treated as internal weights. We can then convert to a Torch\n    layer with:\n\n    >>> weight_shapes = {""weights_0"": 3, ""weight_1"": 1}\n    >>> qlayer = qml.qnn.TorchLayer(qnode, weight_shapes)\n\n    The internal weights of the QNode are automatically initialized within the\n    :class:`~.TorchLayer` and must have their shapes specified in a ``weight_shapes`` dictionary.\n    It is then easy to combine with other neural network layers from the\n    `torch.nn <https://pytorch.org/docs/stable/nn.html>`__ module and create a hybrid:\n\n    >>> clayer = torch.nn.Linear(2, 2)\n    >>> model = torch.nn.Sequential(qlayer, clayer)\n\n    .. UsageDetails::\n\n        **QNode signature**\n\n        The QNode must have a signature that satisfies the following conditions:\n\n        - Contain an ``inputs`` named argument for input data.\n        - All other arguments must accept an array or tensor and are treated as internal\n          weights of the QNode.\n        - All other arguments must have no default value.\n        - The ``inputs`` argument is permitted to have a default value provided the gradient with\n          respect to ``inputs`` is not required.\n        - There cannot be a variable number of positional or keyword arguments, e.g., no ``*args``\n          or ``**kwargs`` present in the signature.\n\n        **Initializing weights**\n\n        The optional ``init_method`` argument of :class:`~.TorchLayer` allows for the initialization\n        method of the QNode weights to be specified. The function passed to the argument must be\n        from the `torch.nn.init <https://pytorch.org/docs/stable/nn.init.html>`__ module. For\n        example, weights can be randomly initialized from the normal distribution by passing:\n\n        .. code-block::\n\n            init_method = torch.nn.init.normal_\n\n        If ``init_method`` is not specified, weights are randomly initialized from the uniform\n        distribution on the interval :math:`[0, 2 \\pi]`.\n\n        **Full code example**\n\n        The code block below shows how a circuit composed of templates from the\n        :doc:`/code/qml_templates` module can be combined with classical\n        `Linear <https://pytorch.org/docs/stable/nn.html#linear>`__ layers to learn\n        the two-dimensional `moons <https://scikit-learn.org/stable/modules/generated/sklearn\n        .datasets.make_moons.html>`__ dataset.\n\n        .. code-block:: python\n\n            import numpy as np\n            import pennylane as qml\n            import torch\n            import sklearn.datasets\n\n            n_qubits = 2\n            dev = qml.device(""default.qubit"", wires=n_qubits)\n\n            @qml.qnode(dev)\n            def qnode(inputs, weights):\n                qml.templates.AngleEmbedding(inputs, wires=range(n_qubits))\n                qml.templates.StronglyEntanglingLayers(weights, wires=range(n_qubits))\n                return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n            weight_shapes = {""weights"": (3, n_qubits, 3)}\n\n            qlayer = qml.qnn.TorchLayer(qnode, weight_shapes)\n            clayer1 = torch.nn.Linear(2, 2)\n            clayer2 = torch.nn.Linear(2, 2)\n            softmax = torch.nn.Softmax(dim=1)\n            model = torch.nn.Sequential(clayer1, qlayer, clayer2, softmax)\n\n            samples = 100\n            x, y = sklearn.datasets.make_moons(samples)\n            y_hot = np.zeros((samples, 2))\n            y_hot[np.arange(samples), y] = 1\n\n            X = torch.tensor(x).float()\n            Y = torch.tensor(y_hot).float()\n\n            opt = torch.optim.SGD(model.parameters(), lr=0.5)\n            loss = torch.nn.L1Loss()\n\n        The model can be trained using:\n\n        .. code-block:: python\n\n            epochs = 8\n            batch_size = 5\n            batches = samples // batch_size\n\n            data_loader = torch.utils.data.DataLoader(list(zip(X, Y)), batch_size=batch_size,\n                                                      shuffle=True, drop_last=True)\n\n            for epoch in range(epochs):\n\n                running_loss = 0\n\n                for x, y in data_loader:\n                    opt.zero_grad()\n\n                    loss_evaluated = loss(model(x), y)\n                    loss_evaluated.backward()\n\n                    opt.step()\n\n                    running_loss += loss_evaluated\n\n                avg_loss = running_loss / batches\n                print(""Average loss over epoch {}: {:.4f}"".format(epoch + 1, avg_loss))\n\n        An example output is shown below:\n\n        .. code-block:: rst\n\n            Average loss over epoch 1: 0.5089\n            Average loss over epoch 2: 0.4765\n            Average loss over epoch 3: 0.2710\n            Average loss over epoch 4: 0.1865\n            Average loss over epoch 5: 0.1670\n            Average loss over epoch 6: 0.1635\n            Average loss over epoch 7: 0.1528\n            Average loss over epoch 8: 0.1528\n    """"""\n\n    def __init__(self, qnode, weight_shapes: dict, init_method: Optional[Callable] = None):\n        if not TORCH_IMPORTED:\n            raise ImportError(\n                ""TorchLayer requires PyTorch. PyTorch can be installed using:\\n""\n                ""pip install torch\\nAlternatively, ""\n                ""visit https://pytorch.org/get-started/locally/ for detailed ""\n                ""instructions.""\n            )\n        super().__init__()\n\n        self.sig = qnode.func.sig\n\n        if self.input_arg not in self.sig:\n            raise TypeError(\n                ""QNode must include an argument with name {} for inputting data"".format(\n                    self.input_arg\n                )\n            )\n\n        if self.input_arg in set(weight_shapes.keys()):\n            raise ValueError(\n                ""{} argument should not have its dimension specified in ""\n                ""weight_shapes"".format(self.input_arg)\n            )\n\n        if set(weight_shapes.keys()) | {self.input_arg} != set(self.sig.keys()):\n            raise ValueError(""Must specify a shape for every non-input parameter in the QNode"")\n\n        if qnode.func.var_pos:\n            raise TypeError(""Cannot have a variable number of positional arguments"")\n\n        if qnode.func.var_keyword:\n            raise TypeError(""Cannot have a variable number of keyword arguments"")\n\n        self.qnode = to_torch(qnode)\n        weight_shapes = {\n            weight: (tuple(size) if isinstance(size, Iterable) else (size,) if size > 1 else ())\n            for weight, size in weight_shapes.items()\n        }\n\n        defaults = {\n            name for name, sig in self.sig.items() if sig.par.default != inspect.Parameter.empty\n        }\n        self.input_is_default = self.input_arg in defaults\n        if defaults - {self.input_arg} != set():\n            raise TypeError(\n                ""Only the argument {} is permitted to have a default"".format(self.input_arg)\n            )\n\n        if not init_method:\n            init_method = functools.partial(torch.nn.init.uniform_, b=2 * math.pi)\n\n        self.qnode_weights = {}\n        for name, size in weight_shapes.items():\n            if len(size) == 0:\n                self.qnode_weights[name] = torch.nn.Parameter(init_method(torch.Tensor(1))[0])\n            else:\n                self.qnode_weights[name] = torch.nn.Parameter(init_method(torch.Tensor(*size)))\n            self.register_parameter(name, self.qnode_weights[name])\n\n    def forward(self, inputs):  # pylint: disable=arguments-differ\n        """"""Evaluates a forward pass through the QNode based upon input data and the initialized\n        weights.\n\n        Args:\n            inputs (tensor): data to be processed\n\n        Returns:\n            tensor: output data\n        """"""\n        if len(inputs.shape) == 1:\n            return self._evaluate_qnode(inputs)\n\n        return torch.stack([self._evaluate_qnode(x) for x in inputs])\n\n    def _evaluate_qnode(self, x):\n        """"""Evaluates the QNode for a single input datapoint.\n\n        Args:\n            x (tensor): the datapoint\n\n        Returns:\n            tensor: output datapoint\n        """"""\n        qnode = self.qnode\n\n        for arg in self.sig:\n            if arg is not self.input_arg:  # Non-input arguments must always be positional\n                w = self.qnode_weights[arg]\n\n                qnode = functools.partial(qnode, w)\n            else:\n                if self.input_is_default:  # The input argument can be positional or keyword\n                    qnode = functools.partial(qnode, **{self.input_arg: x})\n                else:\n                    qnode = functools.partial(qnode, x)\n        return qnode().type(x.dtype)\n\n    def __str__(self):\n        detail = ""<Quantum Torch Layer: func={}>""\n        return detail.format(self.qnode.func.__name__)\n\n    __repr__ = __str__\n\n    _input_arg = ""inputs""\n\n    @property\n    def input_arg(self):\n        """"""Name of the argument to be used as the input to the Torch layer. Set to ``""inputs""``.""""""\n        return self._input_arg\n'"
pennylane/qnodes/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis subpackage contains the supported types of QNodes.\n\n.. currentmodule:: pennylane.qnodes\n""""""\nfrom .base import BaseQNode, QuantumFunctionError\nfrom .cv import CVQNode\nfrom .decorator import qnode, QNode\nfrom .jacobian import JacobianQNode\nfrom .qubit import QubitQNode\nfrom .passthru import PassthruQNode\n'"
pennylane/qnodes/base.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nBase QNode class and utilities\n""""""\nfrom collections.abc import Sequence\nfrom collections import namedtuple, OrderedDict\nimport inspect\nimport itertools\n\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.operation import Observable, CV, ActsOn, ObservableReturnTypes\nfrom pennylane.utils import _flatten, unflatten\nfrom pennylane.circuit_graph import CircuitGraph, _is_observable\nfrom pennylane.variable import Variable\n\n\nParameterDependency = namedtuple(""ParameterDependency"", [""op"", ""par_idx""])\n""""""Represents the dependence of an Operator on a positional parameter of the quantum function.\n\nArgs:\n    op (Operator): operator depending on the positional parameter in question\n    par_idx (int): flattened operator parameter index of the corresponding\n        :class:`~.Variable` instance\n""""""\n\n\nSignatureParameter = namedtuple(""SignatureParameter"", [""idx"", ""par""])\n""""""Describes a single parameter in a function signature.\n\nArgs:\n    idx (int): positional index of the parameter in the function signature\n    par (inspect.Parameter): parameter description\n""""""\n\n\nclass QuantumFunctionError(Exception):\n    """"""Exception raised when an illegal operation is defined in a quantum function.""""""\n\n\ndef _get_signature(func):\n    """"""Introspect the parameter signature of a function.\n\n    Adds the following attributes to func:\n\n    * :attr:`func.sig`: OrderedDict[str, SignatureParameter]: mapping from parameters\' names to their descriptions\n    * :attr:`func.n_pos`: int: number of required positional arguments\n    * :attr:`func.var_pos`: bool: can take a variable number of positional arguments (``*args``)\n    * :attr:`func.var_keyword`: bool: can take a variable number of keyword arguments (``**kwargs``)\n\n    Args:\n        func (callable): function to introspect\n    """"""\n    sig = inspect.signature(func)\n    # count positional args, see if VAR_ args are present\n    n_pos = 0\n    func.var_pos = False\n    func.var_keyword = False\n    for p in sig.parameters.values():\n        if p.kind <= inspect.Parameter.POSITIONAL_OR_KEYWORD:\n            n_pos += 1\n        elif p.kind == inspect.Parameter.VAR_POSITIONAL:\n            func.var_pos = True\n        elif p.kind == inspect.Parameter.VAR_KEYWORD:\n            func.var_keyword = True\n\n    func.sig = OrderedDict(\n        [(p.name, SignatureParameter(idx, p)) for idx, p in enumerate(sig.parameters.values())]\n    )\n    func.n_pos = n_pos\n\n\ndef _decompose_queue(ops, device):\n    """"""Recursively loop through a queue and decompose\n    operations that are not supported by a device.\n\n    Args:\n        ops (List[~.Operation]): operation queue\n        device (~.Device): a PennyLane device\n    """"""\n    new_ops = []\n\n    for op in ops:\n        if device.supports_operation(op.name):\n            new_ops.append(op)\n        else:\n            decomposed_ops = op.decomposition(*op.params, wires=op.wires.tolist())\n            if op.inverse:\n                decomposed_ops = qml.inv(decomposed_ops)\n\n            decomposition = _decompose_queue(decomposed_ops, device)\n            new_ops.extend(decomposition)\n\n    return new_ops\n\n\ndef decompose_queue(ops, device):\n    """"""Decompose operations in a queue that are not supported by a device.\n\n    This is a wrapper function for :func:`~._decompose_queue`,\n    which raises an error if an operation or its decomposition\n    is not supported by the device.\n\n    Args:\n        ops (List[~.Operation]): operation queue\n        device (~.Device): a PennyLane device\n    """"""\n    new_ops = []\n\n    for op in ops:\n        try:\n            new_ops.extend(_decompose_queue([op], device))\n        except NotImplementedError:\n            raise qml.DeviceError(\n                ""Gate {} not supported on device {}"".format(op.name, device.short_name)\n            )\n\n    return new_ops\n\n\nclass BaseQNode(qml.QueuingContext):\n    """"""Base class for quantum nodes in the hybrid computational graph.\n\n    A *quantum node* encapsulates a :ref:`quantum function <intro_vcirc_qfunc>`\n    (corresponding to a :ref:`variational circuit <glossary_variational_circuit>`)\n    and the computational device it is executed on.\n\n    The QNode calls the quantum function to construct a :class:`.CircuitGraph` instance represeting\n    the quantum circuit. The circuit can be either\n\n    * *mutable*, which means the quantum function is called each time the QNode is evaluated, or\n    * *immutable*, which means the quantum function is called only once, on first evaluation,\n      to construct the circuit representation.\n\n    If the circuit is mutable, its **auxiliary** parameters can undergo any kind of classical\n    processing inside the quantum function. It can also contain classical flow control structures\n    that depend on the auxiliary parameters, potentially resulting in a different circuit\n    on each call. The auxiliary parameters may also determine the wires on which operators act.\n\n    For immutable circuits the quantum function must build the same circuit graph consisting of the same\n    :class:`.Operator` instances regardless of its parameters; they can only appear as the\n    arguments of the Operators in the circuit. Immutable circuits are slightly faster to execute, and\n    can be optimized, but require that the layout of the circuit is fixed.\n\n    Args:\n        func (callable): The *quantum function* of the QNode.\n            A Python function containing :class:`~.operation.Operation` constructor calls,\n            and returning a tuple of measured :class:`~.operation.Observable` instances.\n        device (~pennylane._device.Device): computational device to execute the function on\n        mutable (bool): whether the circuit is mutable, see above\n\n    Keyword Args:\n        vis_check (bool): whether to check for operations that cannot affect the output\n        par_check (bool): whether to check for unused positional params\n    """"""\n\n    # pylint: disable=too-many-instance-attributes\n    def __init__(self, func, device, *, mutable=True, **kwargs):\n        self.func = func  #: callable: quantum function\n        self.device = device  #: Device: device that executes the circuit\n        self.num_wires = device.num_wires  #: int: number of subsystems (wires) in the circuit\n        #: int: number of flattened differentiable parameters in the circuit\n        self.num_variables = None\n        self.arg_vars = None\n        self.kwarg_vars = None\n\n        #: List[Operator]: quantum circuit, in the order the quantum function defines it\n        self.ops = []\n\n        self.circuit = None  #: CircuitGraph: DAG representation of the quantum circuit\n\n        self.mutable = mutable  #: bool: whether the circuit is mutable\n        #: dict[str, Any]: additional keyword kwargs for adjusting the QNode behavior\n        self.kwargs = kwargs or {}\n\n        self.variable_deps = {}\n        """"""dict[int, list[ParameterDependency]]: Mapping from flattened qfunc positional parameter\n        index to the list of :class:`~pennylane.operation.Operator` instances (in this circuit)\n        that depend on it.\n        """"""\n\n        self._trainable_args = None\n\n        self._metric_tensor_subcircuits = None\n        """"""dict[tuple[int], dict[str, Any]]: circuit descriptions for computing the metric tensor""""""\n\n        # introspect the quantum function signature\n        _get_signature(self.func)\n\n        self.output_conversion = None  #: callable: for transforming the output of :meth:`.Device.execute` to QNode output\n        self.output_dim = None  #: int: dimension of the QNode output vector\n        self.model = self.device.capabilities()[""model""]  #: str: circuit type, in {\'cv\', \'qubit\'}\n\n    def __repr__(self):\n        """"""String representation.""""""\n        detail = ""<QNode: device=\'{}\', func={}, wires={}>""\n        return detail.format(self.device.short_name, self.func.__name__, self.num_wires)\n\n    def print_applied(self):\n        """"""Prints the most recently applied operations from the QNode.\n        """"""\n        if self.circuit is None:\n            print(""QNode has not yet been executed."")\n            return\n        self.circuit.print_contents()\n\n    def draw(self, charset=""unicode"", show_variable_names=False):\n        """"""Draw the QNode as a circuit diagram.\n\n        Consider the following circuit as an example:\n\n        .. code-block:: python3\n\n            @qml.qnode(dev)\n            def qfunc(a, w):\n                qml.Hadamard(0)\n                qml.CRX(a, wires=[0, 1])\n                qml.Rot(w[0], w[1], w[2], wires=[1])\n                qml.CRX(-a, wires=[0, 1])\n\n                return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n        We can draw the circuit after it has been executed:\n\n        .. code-block:: python\n\n            >>> result = qfunc(2.3, [1.2, 3.2, 0.7])\n            >>> print(qfunc.draw())\n            0: \xe2\x94\x80\xe2\x94\x80H\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9\n            1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(2.3)\xe2\x94\x80\xe2\x94\x80Rot(1.2, 3.2, 0.7)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(-2.3)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9\n            >>> print(qfunc.draw(charset=""ascii""))\n            0: --H--+C----------------------------+C---------+| <Z @ Z>\n            1: -----+RX(2.3)--Rot(1.2, 3.2, 0.7)--+RX(-2.3)--+| <Z @ Z>\n            >>> print(qfunc.draw(show_variable_names=True))\n            0: \xe2\x94\x80\xe2\x94\x80H\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9\n            1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(a)\xe2\x94\x80\xe2\x94\x80Rot(w[0], w[1], w[2])\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(-1*a)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9\n\n        Args:\n            charset (str, optional): The charset that should be used. Currently, ""unicode"" and ""ascii"" are supported.\n            show_variable_names (bool, optional): Show variable names instead of values.\n\n        Raises:\n            ValueError: If the given charset is not supported\n            pennylane.QuantumFunctionError: Drawing is impossible because the underlying CircuitGraph has not yet been constructed\n\n        Returns:\n            str: The circuit representation of the QNode\n        """"""\n        if self.circuit:\n            return self.circuit.draw(charset=charset, show_variable_names=show_variable_names)\n\n        raise RuntimeError(\n            ""The QNode can only be drawn after its CircuitGraph has been constructed.""\n        )\n\n    def set_trainable_args(self, arg_indices):\n        """"""Store the indices of quantum function positional arguments\n        that support differentiability.\n\n        Args:\n            args (None or Set[int]): Differentiable positional argument indices. A\n                value of ``None`` means that all argument indices are differentiable.\n        """"""\n        if not self.mutable and self.circuit is not None:\n\n            if self.get_trainable_args() == arg_indices:\n                return\n\n            raise QuantumFunctionError(\n                ""The trainability of arguments on immutable QNodes cannot be modified after the first evaluation.""\n            )\n\n        if arg_indices is None:\n            # all arguments are differentiable\n            self._trainable_args = None\n            return\n\n        if not arg_indices:\n            # The provided arg_indices are an empty set;\n            # no arguments are differentiable.\n            self._trainable_args = set()\n            return\n\n        # Perform validation\n        if not self.func.var_pos and max(arg_indices) > self.func.n_pos:\n            # QNode does not allow variable positional arguments (*args), and\n            # the provided index set contains a value larger than the number\n            # of positional arguments.\n            raise ValueError(\n                f""Argument index not available. QNode has at most {self.func.n_pos} arguments.""\n            )\n\n        if any(not isinstance(i, int) or i < 0 for i in arg_indices):\n            raise ValueError(""Argument indices must be positive integers."")\n\n        self._trainable_args = arg_indices\n\n    def get_trainable_args(self):\n        """"""Returns the indices of quantum function positional arguments\n        that support differentiability.\n\n        Returns:\n            None or Set[int]: Differentiable positional argument indices. A\n                value of ``None`` means that all argument indices are differentiable.\n        """"""\n        return self._trainable_args\n\n    def _set_variables(self, args, kwargs):\n        """"""Store the current values of the quantum function parameters in the Variable class\n        so the Operators may access them.\n\n        Args:\n            args (tuple[Any]): positional (differentiable) arguments\n            kwargs (dict[str, Any]): auxiliary arguments\n        """"""\n        Variable.positional_arg_values = np.array(list(_flatten(args)))\n        if not self.mutable:\n            # only immutable circuits access auxiliary arguments through Variables\n            Variable.kwarg_values = {k: np.array(list(_flatten(v))) for k, v in kwargs.items()}\n\n    def _op_descendants(self, op, only):\n        """"""Descendants of the given operator in the quantum circuit.\n\n        Args:\n            op (Operator): operator in the quantum circuit\n            only (str, None): the type of descendants to return.\n\n                - ``\'G\'``: only return non-observables (default)\n                - ``\'O\'``: only return observables\n                - ``None``: return all descendants\n\n        Returns:\n            list[Operator]: descendants in a topological order\n        """"""\n        succ = self.circuit.descendants_in_order((op,))\n        if only == ""O"":\n            return list(filter(_is_observable, succ))\n        if only == ""G"":\n            return list(itertools.filterfalse(_is_observable, succ))\n        return succ\n\n    def _remove_operator(self, operator):\n        if isinstance(operator, Observable) and operator.return_type is not None:\n            self.obs_queue.remove(operator)\n        else:\n            self.queue.remove(operator)\n\n    def _append_operator(self, operator):\n        if operator.num_wires == ActsOn.AllWires:  # TODO: re-assess for nonconsec wires\n            if set(operator.wires.tolist()) != set(range(self.num_wires)):\n                raise QuantumFunctionError(\n                    ""Operator {} must act on all wires"".format(operator.name)\n                )\n\n        # Make sure only existing wires are used.\n        for w in operator.wires.tolist():  # TODO: re-assess for for nonconsec wires\n            if w < 0 or w >= self.num_wires:\n                raise QuantumFunctionError(\n                    ""Operation {} applied to invalid wire {} ""\n                    ""on device with {} wires."".format(operator.name, w, self.num_wires)\n                )\n\n        # observables go to their own, temporary queue\n        if isinstance(operator, Observable):\n            if operator.return_type is None:\n                self.queue.append(operator)\n            else:\n                self.obs_queue.append(operator)\n        else:\n            if self.obs_queue:\n                raise QuantumFunctionError(\n                    ""State preparations and gates must precede measured observables.""\n                )\n            self.queue.append(operator)\n\n    def _determine_structured_variable_name(self, parameter_value, prefix):\n        """"""Determine the variable names corresponding to a parameter.\n\n        This method unrolls the parameter value if it has an array\n        or list structure.\n\n        Args:\n            parameter_value (Union[Number, Sequence[Any], array[Any]]): The value of the parameter. This will be used as a blueprint for the returned variable name(s).\n            prefix (str): Prefix that will be added to the variable name(s), usually the parameter name\n\n        Returns:\n            Union[str,Sequence[str],array[str]]: The variable name(s) in the same structure as the parameter value\n        """"""\n        if isinstance(parameter_value, np.ndarray):\n            variable_name_string = np.empty_like(parameter_value, dtype=object)\n\n            for index in np.ndindex(*variable_name_string.shape):\n                variable_name_string[index] = ""{}[{}]"".format(\n                    prefix, "","".join([str(i) for i in index])\n                )\n        elif isinstance(parameter_value, Sequence):\n            variable_name_string = []\n\n            for idx, val in enumerate(parameter_value):\n                variable_name_string.append(\n                    self._determine_structured_variable_name(val, ""{}[{}]"".format(prefix, idx))\n                )\n        else:\n            variable_name_string = prefix\n\n        return variable_name_string\n\n    def _make_variables(self, args, kwargs):\n        """"""Create the :class:`~.variable.Variable` instances representing the QNode\'s arguments.\n\n        The created :class:`~.variable.Variable` instances are given in the same nested structure\n        as the original arguments. The :class:`~.variable.Variable` instances are named according\n        to the argument names given in the QNode definition. Consider the following example:\n\n        .. code-block:: python3\n\n            @qml.qnode(dev)\n            def qfunc(a, w):\n                qml.Hadamard(0)\n                qml.CRX(a, wires=[0, 1])\n                qml.Rot(w[0], w[1], w[2], wires=[1])\n                qml.CRX(-a, wires=[0, 1])\n\n                return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n        In this example, ``_make_variables`` will return the following :class:`~.variable.Variable` instances\n\n        .. code-block:: python3\n\n            >>> qfunc(3.4, [1.2, 3.4, 5.6])\n            -0.031664133410566786\n            >>> qfunc._make_variables([3.4, [1.2, 3.4, 5.6]], {})\n            [""a"", [""w[0]"", ""w[1]"", ""w[2]""]], {}\n\n        where the Variable instances are replaced with their name for readability.\n\n        Args:\n            args (tuple[Any]): Positional arguments passed to the quantum function.\n                During the construction we are not concerned with the numerical values, but with\n                the nesting structure.\n                Each positional argument is replaced with a :class:`~.variable.Variable` instance.\n            kwargs (dict[str, Any]): Auxiliary arguments passed to the quantum function.\n        """"""\n        # Get the name of the qfunc\'s arguments\n        full_argspec = inspect.getfullargspec(self.func)\n\n        # args\n        variable_name_strings = []\n        for variable_name, variable_value in zip(full_argspec.args, args):\n            variable_name_strings.append(\n                self._determine_structured_variable_name(variable_value, variable_name)\n            )\n\n        # varargs\n        len_diff = len(args) - len(full_argspec.args)\n        if len_diff > 0:\n            for idx, variable_value in enumerate(args[-len_diff:]):\n                variable_name = ""{}[{}]"".format(full_argspec.varargs, idx)\n\n                variable_name_strings.append(\n                    self._determine_structured_variable_name(variable_value, variable_name)\n                )\n\n        arg_vars = [Variable(idx, name) for idx, name in enumerate(_flatten(variable_name_strings))]\n        self.num_variables = len(arg_vars)\n\n        # Arrange the newly created Variables in the nested structure of args.\n        # Make sure that NumPy scalars are converted into Python scalars.\n        arg_vars = [\n            i.item() if isinstance(i, np.ndarray) and i.ndim == 0 else i\n            for i in unflatten(arg_vars, args)\n        ]\n\n        if self._trainable_args is not None and len(self._trainable_args) != len(args):\n            # If some of the input arguments are marked as non-differentiable,\n            # then replace the variable instances in arg_vars back with the\n            # original objects.\n            for a, _ in enumerate(args):\n                if a not in self._trainable_args:\n                    arg_vars[a] = args[a]\n\n        # kwargs\n        # if not mutable: must convert auxiliary arguments to named Variables so they can be updated without re-constructing the circuit\n        # kwarg_vars = {}\n        # for key, val in kwargs.items():\n        #    temp = [Variable(idx, name=key) for idx, _ in enumerate(_flatten(val))]\n        #    kwarg_vars[key] = unflatten(temp, val)\n\n        variable_name_strings = {}\n        kwarg_vars = {}\n        for variable_name in full_argspec.kwonlyargs:\n            if variable_name in kwargs:\n                variable_value = kwargs[variable_name]\n            else:\n                variable_value = full_argspec.kwonlydefaults[variable_name]\n\n            if isinstance(variable_value, np.ndarray):\n                variable_name_string = np.empty_like(variable_value, dtype=object)\n\n                for index in np.ndindex(*variable_name_string.shape):\n                    variable_name_string[index] = ""{}[{}]"".format(\n                        variable_name, "","".join([str(i) for i in index])\n                    )\n\n                kwarg_variable = [\n                    Variable(idx, name=name, is_kwarg=True)\n                    for idx, name in enumerate(_flatten(variable_name_string))\n                ]\n            else:\n                kwarg_variable = Variable(0, name=variable_name, is_kwarg=True)\n\n            kwarg_vars[variable_name] = kwarg_variable\n\n        return arg_vars, kwarg_vars\n\n    def _construct(self, args, kwargs):\n        """"""Construct the quantum circuit graph by calling the quantum function.\n\n        For immutable nodes this method is called the first time :meth:`BaseQNode.evaluate`\n        or :meth:`.JacobianQNode.jacobian` is called, and for mutable nodes *each time*\n        they are called. It executes the quantum function,\n        stores the resulting sequence of :class:`.Operator` instances,\n        converts it into a circuit graph, and creates the Variable mapping.\n\n        .. note::\n           The Variables are only required for analytic differentiation,\n           for evaluation we could simply reconstruct the circuit each time.\n\n        Args:\n            args (tuple[Any]): Positional arguments passed to the quantum function.\n                During the construction we are not concerned with the numerical values, but with\n                the nesting structure.\n                Each positional argument is replaced with a :class:`~.Variable` instance.\n            kwargs (dict[str, Any]): Auxiliary arguments passed to the quantum function.\n        """"""\n        # TODO: Update the docstring to reflect the kwargs and the raising conditions\n        # pylint: disable=attribute-defined-outside-init, too-many-branches, too-many-statements\n\n        self.arg_vars, self.kwarg_vars = self._make_variables(args, kwargs)\n\n        # temporary queues for operations and observables\n        # TODO rename self.queue to self.op_queue\n        self.queue = []  #: list[Operation]: applied operations\n        self.obs_queue = []  #: list[Observable]: applied observables\n\n        # set up the context for Operator entry\n        with self:\n            try:\n                # generate the program queue by executing the quantum circuit function\n                if self.mutable:\n                    # it\'s ok to directly pass auxiliary arguments since the circuit is re-constructed each time\n                    # (positional args must be replaced because parameter-shift differentiation requires Variables)\n                    res = self.func(*self.arg_vars, **kwargs)\n                else:\n                    # TODO: Maybe we should only convert the kwarg_vars that were actually given\n                    res = self.func(*self.arg_vars, **self.kwarg_vars)\n            except:\n                # The qfunc call may have failed because the user supplied bad parameters, which is why we must wipe the created Variables.\n                self.arg_vars = None\n                self.kwarg_vars = None\n                raise\n\n        # check the validity of the circuit\n        self._check_circuit(res)\n        del self.queue\n        del self.obs_queue\n\n        # Prune all the Tensor objects that have been used in the circuit\n        self.ops = self._prune_tensors(self.ops)\n\n        # map each free variable to the operators which depend on it\n        self.variable_deps = {k: [] for k in range(self.num_variables)}\n        for op in self.ops:\n            for j, p in enumerate(_flatten(op.params)):\n                if isinstance(p, Variable):\n                    if not p.is_kwarg:  # ignore auxiliary arguments\n                        self.variable_deps[p.idx].append(ParameterDependency(op, j))\n\n        # generate the DAG\n        self.circuit = CircuitGraph(self.ops, self.variable_deps)\n\n        # check for unused positional params\n        if self.kwargs.get(""par_check"", False):\n            unused = [k for k, v in self.variable_deps.items() if not v]\n            if unused:\n                raise QuantumFunctionError(\n                    ""The positional parameters {} are unused."".format(unused)\n                )\n\n        # check for operations that cannot affect the output\n        if self.kwargs.get(""vis_check"", False):\n            invisible = self.circuit.invisible_operations()\n            if invisible:\n                raise QuantumFunctionError(\n                    ""The operations {} cannot affect the circuit output."".format(invisible)\n                )\n\n    @staticmethod\n    def _prune_tensors(res):\n        """"""Prune the tensors that have been passed by the quantum function.\n\n        .. seealso:: :meth:`~.Tensor.prune`\n\n        Args:\n            res (Sequence[Observable], Observable): output returned by the quantum function\n\n        Returns:\n            res (Sequence[Observable], Observable): pruned output returned by the quantum function\n        """"""\n        if isinstance(res, qml.operation.Tensor):\n            return res.prune()\n\n        if isinstance(res, Sequence):\n            ops = []\n            for o in res:\n                if isinstance(o, qml.operation.Tensor):\n                    ops.append(o.prune())\n                else:\n                    ops.append(o)\n            return ops\n\n        return res\n\n    def _check_circuit(self, res):\n        """"""Check that the generated Operator queue corresponds to a valid quantum circuit.\n\n        .. note:: The validity of individual Operators is checked already in :meth:`_append_op`.\n\n        Args:\n            res (Sequence[Observable], Observable): output returned by the quantum function\n\n        Raises:\n            QuantumFunctionError: an error was discovered in the circuit\n        """"""\n        # pylint: disable=too-many-branches\n\n        # check the return value\n        if isinstance(res, Observable):\n            self.output_dim = 1\n\n            if res.return_type is ObservableReturnTypes.Sample:\n                # Squeezing ensures that there is only one array of values returned\n                # when only a single-mode sample is requested\n                self.output_conversion = np.squeeze\n            elif res.return_type is ObservableReturnTypes.Probability:\n                self.output_conversion = np.squeeze\n                self.output_dim = 2 ** len(res.wires)\n            else:\n                self.output_conversion = float\n\n            res = (res,)\n\n        elif isinstance(res, Sequence) and res and all(isinstance(x, Observable) for x in res):\n            # for multiple observables values, any valid Python sequence of observables\n            # (i.e., lists, tuples, etc) are supported in the QNode return statement.\n\n            # Device already returns the correct numpy array, so no further conversion is required\n            self.output_conversion = np.asarray\n            self.output_dim = len(res)\n            res = tuple(res)\n        else:\n            raise QuantumFunctionError(\n                ""A quantum function must return either a single measured observable ""\n                ""or a nonempty sequence of measured observables.""\n            )\n\n        # check that all returned observables have a return_type specified\n        for x in res:\n            if x.return_type is None:\n                raise QuantumFunctionError(\n                    ""Observable \'{}\' does not have the measurement type specified."".format(x)\n                )\n\n        # check that all ev\'s are returned, in the correct order\n        if res != tuple(self.obs_queue):\n            raise QuantumFunctionError(\n                ""All measured observables must be returned in the order they are measured.""\n            )\n\n        # check that no wires are measured more than once\n        m_wires = list(w for ob in res for w in ob.wires)\n        if len(m_wires) != len(set(m_wires)):\n            raise QuantumFunctionError(\n                ""Each wire in the quantum circuit can only be measured once.""\n            )\n\n        # True if op is a CV, False if it is a discrete variable (Identity could be either)\n        are_cvs = [\n            isinstance(op, CV) for op in self.queue + list(res) if not isinstance(op, qml.Identity)\n        ]\n\n        if not all(are_cvs) and any(are_cvs):\n            raise QuantumFunctionError(\n                ""Continuous and discrete operations are not allowed in the same quantum circuit.""\n            )\n\n        if any(are_cvs) and self.model == ""qubit"":\n            raise QuantumFunctionError(\n                ""Device {} is a qubit device; CV operations are not allowed."".format(\n                    self.device.short_name\n                )\n            )\n\n        if not all(are_cvs) and self.model == ""cv"":\n            raise QuantumFunctionError(\n                ""Device {} is a CV device; qubit operations are not allowed."".format(\n                    self.device.short_name\n                )\n            )\n\n        queue = self.queue\n        if self.device.operations:\n            # replace operations in the queue with any decompositions if required\n            queue = decompose_queue(self.queue, self.device)\n\n        self.ops = queue + list(res)\n\n    def _default_args(self, kwargs):\n        """"""Validate the quantum function arguments, apply defaults.\n\n        Here we apply default values for the auxiliary parameters of :attr:`BaseQNode.func`.\n\n        Args:\n            kwargs (dict[str, Any]): auxiliary arguments (given using the keyword syntax)\n\n        Raises:\n            QuantumFunctionError: some of the arguments are invalid\n\n        Returns:\n            dict[str, Any]: all auxiliary arguments (with defaults)\n        """"""\n        forbidden_kinds = (\n            inspect.Parameter.POSITIONAL_ONLY,\n            inspect.Parameter.VAR_POSITIONAL,\n            inspect.Parameter.VAR_KEYWORD,\n        )\n\n        # check the validity of kwargs items\n        for name in kwargs:\n            s = self.func.sig.get(name)\n            if s is None:\n                if self.func.var_keyword:\n                    continue  # unknown parameter, but **kwargs will take it TODO should it?\n                raise QuantumFunctionError(""Unknown quantum function parameter \'{}\'."".format(name))\n\n            default_parameter = s.par.default\n\n            # The following is a check of the default parameter which works for numpy\n            # arrays as well (if it is a numpy array, each element is checked separately).\n            # FIXME why are numpy array default values not good automatically?\n            correct_default_parameter = (\n                any(d == inspect.Parameter.empty for d in default_parameter)\n                if isinstance(default_parameter, np.ndarray)\n                else default_parameter == inspect.Parameter.empty\n            )\n            if s.par.kind in forbidden_kinds or correct_default_parameter:\n                raise QuantumFunctionError(\n                    ""Quantum function parameter \'{}\' cannot be given using the keyword syntax."".format(\n                        name\n                    )\n                )\n\n        # apply defaults\n        for name, s in self.func.sig.items():\n            default = s.par.default\n            correct_default = (\n                all(d != inspect.Parameter.empty for d in default)\n                if isinstance(default, np.ndarray)\n                else default != inspect.Parameter.empty\n            )\n\n            if correct_default:\n                # meant to be given using keyword syntax\n                kwargs.setdefault(name, default)\n\n        return kwargs\n\n    def __call__(self, *args, **kwargs):\n        """"""Wrapper for :meth:`BaseQNode.evaluate`.\n        """"""\n        return self.evaluate(args, kwargs)\n\n    def evaluate(self, args, kwargs):\n        """"""Evaluate the quantum function on the specified device.\n\n        Args:\n            args (tuple[Any]): positional arguments to the quantum function (differentiable)\n            kwargs (dict[str, Any]): auxiliary arguments (not differentiable)\n\n        Keyword Args:\n            use_native_type (bool): If True, return the result in whatever type the device uses\n                internally, otherwise convert it into array[float]. Default: False.\n\n        Returns:\n            float or array[float]: output measured value(s)\n        """"""\n        kwargs = self._default_args(kwargs)\n        self._set_variables(args, kwargs)\n\n        if self.circuit is None or self.mutable:\n            self._construct(args, kwargs)\n\n        self.device.reset()\n\n        temp = self.kwargs.get(""use_native_type"", False)\n        if isinstance(self.device, qml.QubitDevice):\n            # TODO: remove this if statement once all devices are ported to the QubitDevice API\n            ret = self.device.execute(self.circuit, return_native_type=temp)\n        else:\n            ret = self.device.execute(\n                self.circuit.operations,\n                self.circuit.observables,\n                self.variable_deps,\n                return_native_type=temp,\n            )\n        return self.output_conversion(ret)\n\n    def evaluate_obs(self, obs, args, kwargs):\n        """"""Evaluate the value of the given observables.\n\n        Assumes :meth:`construct` has already been called.\n\n        Args:\n            obs  (Iterable[Observable]): observables to measure\n            args (tuple[Any]): positional arguments to the quantum function (differentiable)\n            kwargs (dict[str, Any]): auxiliary arguments (not differentiable)\n\n        Returns:\n            array[float]: measured values\n        """"""\n        kwargs = self._default_args(kwargs)\n        self._set_variables(args, kwargs)\n\n        self.device.reset()\n\n        if isinstance(self.device, qml.QubitDevice):\n            # create a circuit graph containing the existing operations, and the\n            # observables to be evaluated.\n            circuit_graph = CircuitGraph(\n                self.circuit.operations + list(obs), self.circuit.variable_deps\n            )\n            ret = self.device.execute(circuit_graph)\n        else:\n            ret = self.device.execute(self.circuit.operations, obs, self.circuit.variable_deps)\n        return ret\n'"
pennylane/qnodes/cv.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nCV parameter shift quantum node.\r\n\r\nProvides analytic differentiation for Gaussian operations succeeded by\r\nfirst and second order observables.\r\n""""""\r\nimport copy\r\n\r\nimport numpy as np\r\n\r\nimport pennylane as qml\r\nfrom pennylane.operation import ObservableReturnTypes\r\n\r\nfrom .base import QuantumFunctionError\r\nfrom .jacobian import JacobianQNode\r\n\r\n\r\nclass CVQNode(JacobianQNode):\r\n    """"""Quantum node for CV parameter shift analytic differentiation""""""\r\n\r\n    def _best_method(self, idx):\r\n        """"""Determine the correct partial derivative computation method for a free parameter.\r\n\r\n        Use the parameter-shift analytic method iff every gate that depends on the parameter supports it.\r\n        If not, use the finite difference method only (one would have to use it anyway).\r\n\r\n        Note that if even one dependent Operation does not support differentiation,\r\n        we cannot differentiate with respect to this parameter at all.\r\n\r\n        Args:\r\n            idx (int): free parameter index\r\n\r\n        Returns:\r\n            str: partial derivative method to be used\r\n        """"""\r\n        # pylint: disable=too-many-branches\r\n        # operations that depend on this free parameter\r\n        ops = [d.op for d in self.variable_deps[idx]]\r\n\r\n        # Observables in the circuit\r\n        # (the topological order is the queue order)\r\n        observables = self.circuit.observables_in_order\r\n\r\n        # an empty list to store the \'best\' partial derivative method\r\n        # for each operator/observable pair\r\n        best = np.empty((len(ops), len(observables)), dtype=object)\r\n\r\n        # find the best supported partial derivative method for each operator\r\n        for k_op, op in enumerate(ops):\r\n            if op.grad_method is None:\r\n                # one nondifferentiable item makes the whole nondifferentiable\r\n                op.use_method = None\r\n                continue\r\n\r\n            # loop over all observables\r\n            for k_ob, ob in enumerate(observables):\r\n                # get the set of operations betweens the\r\n                # operation and the observable\r\n                S = self.circuit.nodes_between(op, ob)\r\n                x = op.grad_method\r\n\r\n                if op.grad_method == ""A"":\r\n                    # for parameter-shift compatible CV gates we need to check both the\r\n                    # intervening gates, and the type of the observable\r\n                    if any(not k.supports_heisenberg for k in S):\r\n                        # non-Gaussian operators present\r\n                        x = ""F""\r\n                    elif ob.return_type == ObservableReturnTypes.Variance:\r\n                        if ob.ev_order is None or ob.ev_order >= 2:\r\n                            x = ""F""\r\n                    elif ob.ev_order is None or ob.ev_order >= 2:\r\n                        x = ""B""\r\n                    else:\r\n                        x = ""A""\r\n\r\n                # If there is no path between them, p.d. is zero\r\n                # Otherwise, use finite differences\r\n                best[k_op, k_ob] = ""0"" if not S else x\r\n\r\n            if all(k == ""0"" for k in best[k_op, :]):\r\n                op.use_method = ""0""\r\n            elif ""F"" in best[k_op, :]:\r\n                # one non-analytic item makes the whole numeric\r\n                op.use_method = ""F""\r\n            elif ""B"" in best[k_op, :]:\r\n                op.use_method = ""B""\r\n            else:\r\n                op.use_method = ""A""\r\n\r\n        # if all ops that depend on the free parameter have a best method\r\n        # of ""0"", then we can skip the partial derivative altogether\r\n        if all(o.use_method == ""0"" for o in ops):\r\n            return ""0""\r\n\r\n        # one nondifferentiable item makes the whole nondifferentiable\r\n        if any(o.use_method is None for o in ops):\r\n            return None\r\n\r\n        # one non-analytic item makes the whole numeric\r\n        if any(o.use_method == ""F"" for o in ops):\r\n            return ""F""\r\n\r\n        return ""A""\r\n\r\n    @staticmethod\r\n    def _transform_observable(obs, w, Z):\r\n        """"""Apply a Gaussian linear transformation to each index of an observable.\r\n\r\n        Args:\r\n            obs (Observable): observable to transform\r\n            w (int): number of wires in the circuit\r\n            Z (array[float]): Heisenberg picture representation of the linear transformation\r\n\r\n        Returns:\r\n            Observable: transformed observable\r\n        """"""\r\n        q = obs.heisenberg_obs(w)\r\n\r\n        if q.ndim != obs.ev_order:\r\n            raise QuantumFunctionError(\r\n                ""Mismatch between the polynomial order of observable and its Heisenberg representation""\r\n            )\r\n\r\n        qp = q @ Z\r\n        if q.ndim == 2:\r\n            # 2nd order observable\r\n            qp = qp + qp.T\r\n        elif q.ndim > 2:\r\n            raise NotImplementedError(""Transforming observables of order > 2 not implemented."")\r\n        return qml.expval(qml.PolyXP(qp, wires=range(w), do_queue=False))\r\n\r\n    def _pd_analytic(self, idx, args, kwargs, **options):\r\n        """"""Partial derivative of the node using the analytic parameter shift method.\r\n\r\n        The 2nd order method can handle also first order observables, but\r\n        1st order method may be more efficient unless it\'s really easy to\r\n        experimentally measure arbitrary 2nd order observables.\r\n\r\n        Args:\r\n            idx (int): flattened index of the parameter wrt. which the p.d. is computed\r\n            args (array[float]): flattened positional arguments at which to evaluate the p.d.\r\n            kwargs (dict[str, Any]): auxiliary arguments\r\n\r\n        Keyword Args:\r\n            force_order2 (bool): iff True, use the order-2 method even if not necessary\r\n\r\n        Returns:\r\n            array[float]: partial derivative of the node\r\n        """"""\r\n        force_order2 = options.get(""force_order2"", False)\r\n\r\n        n = self.num_variables\r\n        w = self.num_wires\r\n        pd = np.zeros(self.output_dim)\r\n        # find the Operators in which the free parameter appears, use the product rule\r\n        for op, p_idx in self.variable_deps[idx]:\r\n\r\n            # We temporarily edit the Operator such that parameter p_idx is replaced by a new one,\r\n            # which we can modify without affecting other Operators depending on the original.\r\n            orig = op.params[p_idx]\r\n            assert orig.idx == idx\r\n\r\n            # reference to a new, temporary parameter with index n, otherwise identical with orig\r\n            temp_var = copy.copy(orig)\r\n            temp_var.idx = n\r\n            op.params[p_idx] = temp_var\r\n\r\n            multiplier, shift = op.get_parameter_shift(p_idx)\r\n\r\n            # shifted parameter values\r\n            shift_p1 = np.r_[args, args[idx] + shift]\r\n            shift_p2 = np.r_[args, args[idx] - shift]\r\n\r\n            if not force_order2 and op.use_method != ""B"":\r\n                # basic parameter-shift method, for Gaussian CV gates\r\n                # succeeded by order-1 observables\r\n                # evaluate the circuit at two points with shifted parameter values\r\n                y2 = np.asarray(self.evaluate(shift_p1, kwargs))\r\n                y1 = np.asarray(self.evaluate(shift_p2, kwargs))\r\n                pd += (y2 - y1) * multiplier\r\n            else:\r\n                # order-2 parameter-shift method, for gaussian CV gates\r\n                # succeeded by order-2 observables\r\n                # evaluate transformed observables at the original parameter point\r\n                # first build the Heisenberg picture transformation matrix Z\r\n                self._set_variables(shift_p1, kwargs)\r\n                Z2 = op.heisenberg_tr(w)\r\n                self._set_variables(shift_p2, kwargs)\r\n                Z1 = op.heisenberg_tr(w)\r\n                Z = (Z2 - Z1) * multiplier  # derivative of the operation\r\n\r\n                unshifted_args = np.r_[args, args[idx]]\r\n                self._set_variables(unshifted_args, kwargs)\r\n                Z0 = op.heisenberg_tr(w, inverse=True)\r\n                Z = Z @ Z0\r\n\r\n                # conjugate Z with all the descendant operations\r\n                B = np.eye(1 + 2 * w)\r\n                B_inv = B.copy()\r\n                for BB in self._op_descendants(op, ""G""):\r\n                    if not BB.supports_heisenberg:\r\n                        # if the descendant gate is non-Gaussian in parameter-shift differentiation\r\n                        # mode, then there must be no observable following it.\r\n                        continue\r\n                    B = BB.heisenberg_tr(w) @ B\r\n                    B_inv = B_inv @ BB.heisenberg_tr(w, inverse=True)\r\n                Z = B @ Z @ B_inv  # conjugation\r\n\r\n                # transform the descendant observables into their derivatives using Z\r\n                desc = self._op_descendants(op, ""O"")\r\n                obs = [self._transform_observable(x, w, Z) for x in desc]\r\n                # Measure the transformed observables.\r\n                # The other observables do not depend on this parameter instance,\r\n                # hence their partial derivatives are zero.\r\n                res = self.evaluate_obs(obs, unshifted_args, kwargs)\r\n\r\n                # add the measured pd\'s to the correct locations\r\n                inds = [self.circuit.observables.index(x) for x in desc]\r\n                pd[inds] += res\r\n\r\n            # restore the original parameter\r\n            op.params[p_idx] = orig\r\n\r\n        return pd\r\n\r\n    def _pd_analytic_var(self, idx, args, kwargs, **options):\r\n        """"""Partial derivative of the variance of an observable using the parameter-shift method.\r\n\r\n        Args:\r\n            idx (int): flattened index of the parameter wrt. which the p.d. is computed\r\n            args (array[float]): flattened positional arguments at which to evaluate the p.d.\r\n            kwargs (dict[str, Any]): auxiliary arguments\r\n\r\n        Returns:\r\n            array[float]: partial derivative of the node\r\n        """"""\r\n        # boolean mask: elements are True where the return type is a variance, False for expectations\r\n        where_var = [\r\n            e.return_type is ObservableReturnTypes.Variance for e in self.circuit.observables\r\n        ]\r\n        var_observables = [\r\n            e for e in self.circuit.observables if e.return_type == ObservableReturnTypes.Variance\r\n        ]\r\n\r\n        # first, replace each var(A) with <A^2>\r\n        new_observables = []\r\n        for e in var_observables:\r\n            # need to calculate d<A^2>/dp\r\n            w = e.wires\r\n\r\n            # CV first order observable\r\n            # get the heisenberg representation\r\n            # This will be a real 1D vector representing the\r\n            # first order observable in the basis [I, x, p]\r\n            A = e._heisenberg_rep(e.parameters)  # pylint: disable=protected-access\r\n\r\n            # take the outer product of the heisenberg representation\r\n            # with itself, to get a square symmetric matrix representing\r\n            # the square of the observable\r\n            A = np.outer(A, A)\r\n            new = qml.expval(qml.PolyXP(A, w, do_queue=False))\r\n\r\n            # replace the var(A) observable with <A^2>\r\n            self.circuit.update_node(e, new)\r\n            new_observables.append(new)\r\n\r\n        # calculate the analytic derivatives of the <A^2> observables\r\n        pdA2 = self._pd_analytic(idx, args, kwargs, force_order2=True)\r\n\r\n        # restore the original observables, but convert their return types to expectation\r\n        for e, new in zip(var_observables, new_observables):\r\n            self.circuit.update_node(new, e)\r\n            e.return_type = ObservableReturnTypes.Expectation\r\n\r\n        # evaluate <A>\r\n        evA = np.asarray(self.evaluate(args, kwargs))\r\n\r\n        # evaluate the analytic derivative of <A>\r\n        pdA = self._pd_analytic(idx, args, kwargs)\r\n\r\n        # restore return types\r\n        for e in var_observables:\r\n            e.return_type = ObservableReturnTypes.Variance\r\n\r\n        # return d(var(A))/dp = d<A^2>/dp -2 * <A> * d<A>/dp for the variances,\r\n        # d<A>/dp for plain expectations\r\n        return np.where(where_var, pdA2 - 2 * evA * pdA, pdA)\r\n'"
pennylane/qnodes/decorator.py,2,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nQNode decorator.\n""""""\nfrom functools import lru_cache\n\nfrom .base import BaseQNode\nfrom .cv import CVQNode\nfrom .device_jacobian import DeviceJacobianQNode\nfrom .jacobian import JacobianQNode\nfrom .qubit import QubitQNode\nfrom .passthru import PassthruQNode\n\n\nPARAMETER_SHIFT_QNODES = {""qubit"": QubitQNode, ""cv"": CVQNode}\nALLOWED_DIFF_METHODS = (""best"", ""backprop"", ""device"", ""parameter-shift"", ""finite-diff"")\nALLOWED_INTERFACES = (""autograd"", ""numpy"", ""torch"", ""tf"")\n\n\ndef _get_qnode_class(device, interface, diff_method):\n    """"""Returns the class for the specified QNode.\n\n    Args:\n        device (~.Device): a PennyLane-compatible device\n        interface (str): the interface that will be used for classical backpropagation\n        diff_method (str, None): the method of differentiation to use in the created QNode\n\n    Raises:\n        ValueError: if an unrecognized ``diff_method`` is provided\n\n    Returns:\n        ~.BaseQNode: the QNode class object that is compatible with the provided device and\n        differentiation method\n    """"""\n    # pylint: disable=too-many-return-statements,too-many-branches\n    model = device.capabilities().get(""model"", ""qubit"")\n    passthru_interface = device.capabilities().get(""passthru_interface"", None)\n    device_provides_jacobian = device.capabilities().get(""provides_jacobian"", False)\n\n    allows_passthru = passthru_interface is not None\n\n    if diff_method is None:\n        # QNode is not differentiable\n        return BaseQNode\n\n    if diff_method == ""best"":\n\n        if allows_passthru and interface == passthru_interface:\n            # hand off differentiation to the device without type conversion\n            return PassthruQNode\n\n        if device_provides_jacobian:\n            # hand off differentiation to the device\n            return DeviceJacobianQNode\n\n        if model in PARAMETER_SHIFT_QNODES:\n            # parameter-shift analytic differentiation\n            return PARAMETER_SHIFT_QNODES[model]\n\n    if diff_method == ""backprop"":\n        if allows_passthru:\n            if interface != passthru_interface:\n                raise ValueError(\n                    ""Device {} only supports diff_method=\'backprop\' when using the ""\n                    ""{} interface."".format(device.short_name, passthru_interface)\n                )\n            return PassthruQNode\n\n        raise ValueError(\n            ""The {} device does not support native computations with ""\n            ""autodifferentiation frameworks."".format(device.short_name)\n        )\n\n    if diff_method == ""device"":\n        if device_provides_jacobian:\n            return DeviceJacobianQNode\n\n        raise ValueError(\n            ""The {} device does not provide a native method ""\n            ""for computing the jacobian."".format(device.short_name)\n        )\n\n    if diff_method == ""parameter-shift"":\n        if model in PARAMETER_SHIFT_QNODES:\n            # parameter-shift analytic differentiation\n            return PARAMETER_SHIFT_QNODES[model]\n\n        raise ValueError(\n            ""The parameter shift rule is not available for devices with model {}."".format(model)\n        )\n\n    if diff_method in ALLOWED_DIFF_METHODS:\n        # finite differences\n        return JacobianQNode\n\n    raise ValueError(\n        ""Differentiation method {} not recognized. Allowed ""\n        ""options are {}"".format(diff_method, ALLOWED_DIFF_METHODS)\n    )\n\n\ndef _apply_interface(qnode_, interface, diff_method):\n    """"""Applies an interface to a specified QNode.\n\n    Args:\n        qnode_ (~.BaseQNode): the QNode to which the interface is applied\n        interface (str): the interface that will be used for classical backpropagation\n        diff_method (str, None): the method of differentiation to use in the created QNode\n\n    Raises:\n        ValueError: if an unrecognized or invalid ``interface`` is provided\n\n    Returns:\n        callable: the QNode method that creates the interface\n    """"""\n    if interface is None:\n        # if no interface is specified, return the \'bare\' QNode\n        return qnode_\n\n    if interface == ""torch"":\n        return qnode_.to_torch()\n\n    if interface == ""tf"":\n        return qnode_.to_tf()\n\n    if interface in (""autograd"", ""numpy""):\n        # keep ""numpy"" for backwards compatibility\n        return qnode_.to_autograd()\n\n    raise ValueError(\n        ""Interface {} not recognized. Allowed ""\n        ""interfaces are {}"".format(diff_method, ALLOWED_INTERFACES)\n    )\n\n\ndef QNode(func, device, *, interface=""autograd"", mutable=True, diff_method=""best"", **kwargs):\n    """"""QNode constructor for creating QNodes.\n\n    When applied to a quantum function and device, converts it into\n    a :class:`QNode` instance.\n\n    **Example**\n\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=0)\n    >>>     return qml.expval(qml.PauliZ(0))\n    >>> dev = qml.device(""default.qubit"", wires=1)\n    >>> qnode = QNode(circuit, dev)\n\n    Args:\n        func (callable): a quantum function\n        device (~.Device): a PennyLane-compatible device\n        interface (str): The interface that will be used for classical backpropagation.\n            This affects the types of objects that can be passed to/returned from the QNode:\n\n            * ``interface=\'autograd\'``: Allows autograd to backpropogate\n              through the QNode. The QNode accepts default Python types\n              (floats, ints, lists) as well as NumPy array arguments,\n              and returns NumPy arrays.\n\n            * ``interface=\'torch\'``: Allows PyTorch to backpropogate\n              through the QNode. The QNode accepts and returns Torch tensors.\n\n            * ``interface=\'tf\'``: Allows TensorFlow in eager mode to backpropogate\n              through the QNode. The QNode accepts and returns\n              TensorFlow ``tf.Variable`` and ``tf.tensor`` objects.\n\n            * ``None``: The QNode accepts default Python types\n              (floats, ints, lists) as well as NumPy array arguments,\n              and returns NumPy arrays. It does not connect to any\n              machine learning library automatically for backpropagation.\n\n        mutable (bool): whether the QNode circuit is mutable\n        diff_method (str, None): the method of differentiation to use in the created QNode.\n\n            * ``""best""``: Best available method. Uses classical backpropagation or the\n              device directly to compute the gradient if supported, otherwise will use\n              the analytic parameter-shift rule where possible with finite-difference as a fallback.\n\n            * ``""backprop""``: Use classical backpropagation. Only allowed on simulator\n              devices that are classically end-to-end differentiable, for example\n              :class:`default.tensor.tf <~.DefaultTensorTF>`. Note that the returned\n              QNode can only be used with the machine learning framework supported\n              by the device; a separate ``interface`` argument should not be passed.\n\n            * ``""device""``: Queries the device directly for the gradient.\n              Only allowed on devices that provide their own gradient rules.\n\n            * ``""parameter-shift""``: Use the analytic parameter-shift\n              rule where possible, with finite-difference as a fallback.\n\n            * ``""finite-diff""``: Uses numerical finite-differences for all parameters.\n\n            * ``None``: a non-differentiable QNode is returned.\n\n    Keyword Args:\n        h (float): Step size for the finite difference method. Default is ``1e-7`` for analytic devices, or\n            ``0.3`` for non-analytic devices (those that estimate expectation values with a finite number of shots).\n        order (int): order for the finite-difference method, must be 1 (default) or 2\n    """"""\n    qnode_class = _get_qnode_class(device, interface, diff_method)\n    qnode_ = qnode_class(func, device, mutable=mutable, **kwargs)\n\n    if isinstance(qnode_, PassthruQNode):\n        qnode_.interface = interface\n    else:\n        # PassthruQNode\'s do not support interface conversions\n        qnode_ = _apply_interface(qnode_, interface, diff_method)\n\n    return qnode_\n\n\ndef qnode(device, *, interface=""autograd"", mutable=True, diff_method=""best"", **kwargs):\n    """"""Decorator for creating QNodes.\n\n    When applied to a quantum function, this decorator converts it into\n    a :class:`QNode` instance.\n\n    **Example**\n\n    >>> dev = qml.device(""default.qubit"", wires=1)\n    >>> @qml.qnode(dev)\n    >>> def circuit(x):\n    >>>     qml.RX(x, wires=0)\n    >>>     return qml.expval(qml.PauliZ(0))\n\n    Args:\n        device (~.Device): a PennyLane-compatible device\n        interface (str): The interface that will be used for classical backpropagation.\n            This affects the types of objects that can be passed to/returned from the QNode:\n\n            * ``interface=\'autograd\'``: Allows autograd to backpropogate\n              through the QNode. The QNode accepts default Python types\n              (floats, ints, lists) as well as NumPy array arguments,\n              and returns NumPy arrays.\n\n            * ``interface=\'torch\'``: Allows PyTorch to backpropogate\n              through the QNode. The QNode accepts and returns Torch tensors.\n\n            * ``interface=\'tf\'``: Allows TensorFlow in eager mode to backpropogate\n              through the QNode. The QNode accepts and returns\n              TensorFlow ``tf.Variable`` and ``tf.tensor`` objects.\n\n            * ``None``: The QNode accepts default Python types\n              (floats, ints, lists) as well as NumPy array arguments,\n              and returns NumPy arrays. It does not connect to any\n              machine learning library automatically for backpropagation.\n\n        mutable (bool): whether the QNode circuit is mutable\n        diff_method (str, None): the method of differentiation to use in the created QNode.\n\n            * ``""best""``: Best available method. Uses classical backpropagation or the\n              device directly to compute the gradient if supported, otherwise will use\n              the analytic parameter-shift rule where possible with finite-difference as a fallback.\n\n            * ``""backprop""``: Use classical backpropagation. Only allowed on simulator\n              devices that are classically end-to-end differentiable, for example\n              :class:`default.tensor.tf <~.DefaultTensorTF>`. Note that the returned\n              QNode can only be used with the machine learning framework supported\n              by the device; a separate ``interface`` argument should not be passed.\n\n            * ``""device""``: Queries the device directly for the gradient.\n              Only allowed on devices that provide their own gradient rules.\n\n            * ``""parameter-shift""``: Use the analytic parameter-shift\n              rule where possible, with finite-difference as a fallback.\n\n            * ``""finite-diff""``: Uses numerical finite-differences for all parameters.\n\n            * ``None``: a non-differentiable QNode is returned.\n\n    Keyword Args:\n        h (float): Step size for the finite difference method. Default is ``1e-7`` for analytic devices, or\n            ``0.3`` for non-analytic devices (those that estimate expectation values with a finite number of shots).\n        order (int): order for the finite-difference method, must be 1 (default) or 2\n   """"""\n\n    @lru_cache()\n    def qfunc_decorator(func):\n        """"""The actual decorator""""""\n        return QNode(\n            func, device, interface=interface, mutable=mutable, diff_method=diff_method, **kwargs\n        )\n\n    return qfunc_decorator\n'"
pennylane/qnodes/device_jacobian.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nDevice Jacobian QNode.\n\nA QNode that delegates all gradient computations directly to the device.\n""""""\nfrom .jacobian import JacobianQNode\n\n\nclass DeviceJacobianQNode(JacobianQNode):\n    """"""Quantum node that delegates gradient computation to the device""""""\n\n    # pylint: disable=abstract-method\n\n    def _best_method(self, idx):\n        """"""Determine the correct partial derivative computation method for a positional parameter.\n\n        For this QNode, the partial derivative of every free parameter will be\n        computed using the device; only parameters used in operations with\n        ``grad_method=None`` will be marked as non-differentiable.\n\n        Args:\n            idx (int): free parameter index\n\n        Returns:\n            str: partial derivative method to be used\n        """"""\n        # operations that depend on this free parameter\n        ops = [d.op for d in self.variable_deps[idx]]\n        methods = [op.grad_method for op in ops]\n\n        # one nondifferentiable item makes the whole nondifferentiable\n        if None in methods:\n            return None\n\n        return ""A""\n\n    def jacobian(\n        self, args, kwargs=None, *, wrt=None, options=None\n    ):  # pylint: disable=arguments-differ\n        return super().jacobian(args, kwargs=kwargs, wrt=wrt, method=""device"", options=options)\n'"
pennylane/qnodes/jacobian.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nDifferentiable quantum nodes.\n""""""\nfrom collections.abc import Iterable\n\nimport numpy as np\n\nfrom pennylane.operation import ObservableReturnTypes\nfrom pennylane.utils import _flatten, _inv_dict\n\nfrom .base import BaseQNode, QuantumFunctionError\n\nDEFAULT_STEP_SIZE = 0.3\nDEFAULT_STEP_SIZE_ANALYTIC = 1e-7\n\n\nclass JacobianQNode(BaseQNode):\n    """"""Quantum node that can be differentiated with respect to its positional parameters.\n    """"""\n\n    def __init__(self, func, device, mutable=True, **kwargs):\n        super().__init__(func, device, mutable=mutable, **kwargs)\n\n        self.par_to_grad_method = None\n        """"""dict[int, str]: map from flattened quantum function positional parameter index\n        to the gradient method to be used with that parameter""""""\n\n        analytic = getattr(self.device, ""analytic"", False)\n        """"""bool: whether the device runs in analytic mode; this attribute is\n        not defined for hardware devices so set to False in such cases""""""\n\n        default_step_size = DEFAULT_STEP_SIZE_ANALYTIC if analytic else DEFAULT_STEP_SIZE\n        self._h = kwargs.get(""h"", default_step_size)\n        """"""float: step size for the finite difference method""""""\n\n        self._order = kwargs.get(""order"", 1)\n        """"""float: order for the finite difference method""""""\n\n    metric_tensor = None\n\n    @property\n    def interface(self):\n        """"""str, None: automatic differentiation interface used by the node, if any""""""\n        return None\n\n    @property\n    def h(self):\n        """"""float: step size for the finite difference method""""""\n        return self._h\n\n    @h.setter\n    def h(self, value):\n        self._h = value\n\n    @property\n    def order(self):\n        """"""float: order for the finite difference method""""""\n        return self._order\n\n    @order.setter\n    def order(self, value):\n        self._order = value\n\n    def __repr__(self):\n        """"""String representation.""""""\n        detail = ""<QNode (differentiable): device=\'{}\', func={}, wires={}, interface={}>""\n        return detail.format(\n            self.device.short_name, self.func.__name__, self.num_wires, self.interface\n        )\n\n    def _construct(self, args, kwargs):\n        """"""Constructs the quantum circuit graph by calling the quantum function.\n\n        Like :meth:`.QNode._construct`, additionally determines the best gradient computation method\n        for each positional parameter.\n        """"""\n        super()._construct(args, kwargs)\n        self.par_to_grad_method = {k: self._best_method(k) for k in self.variable_deps}\n\n    def _best_method(self, idx):\n        """"""Determine the correct partial derivative computation method for a free parameter.\n\n        Note that if even one dependent Operation does not support differentiation,\n        we cannot differentiate with respect to this parameter at all.\n\n        .. note::\n\n            The ``JacobianQNode`` only supports numerical differentiation, so\n            this method will always return either ``""F""`` or ``None``. If an inheriting\n            QNode supports analytic differentiation for certain operations, make sure\n            that this method is overwritten appropriately to return ``""A""`` where\n            required.\n\n        Args:\n            idx (int): free parameter index\n\n        Returns:\n            str: partial derivative method to be used\n        """"""\n        # operations that depend on this free parameter\n        ops = [d.op for d in self.variable_deps[idx]]\n\n        # Observables in the circuit\n        # (the topological order is the queue order)\n        observables = self.circuit.observables_in_order\n\n        # an empty list to store the \'best\' partial derivative method\n        # for each operator/observable pair\n        best = np.empty((len(ops), len(observables)), dtype=object)\n\n        # find the best supported partial derivative method for each operator\n        for k_op, op in enumerate(ops):\n            if op.grad_method is None:\n                # one nondifferentiable item makes the whole nondifferentiable\n                op.use_method = None\n                continue\n\n            # loop over all observables\n            for k_ob, ob in enumerate(observables):\n                # get the set of operations betweens the\n                # operation and the observable\n                S = self.circuit.nodes_between(op, ob)\n\n                # If there is no path between them, p.d. is zero\n                # Otherwise, use finite differences\n                best[k_op, k_ob] = ""0"" if not S else ""F""\n\n            if all(k == ""0"" for k in best[k_op, :]):\n                op.use_method = ""0""\n            else:\n                op.use_method = ""F""\n\n        # if all ops that depend on the free parameter have a best method\n        # of ""0"", then we can skip the partial derivative altogether\n        if all(o.use_method == ""0"" for o in ops):\n            return ""0""\n\n        # one nondifferentiable item makes the whole nondifferentiable\n        if any(o.use_method is None for o in ops):\n            return None\n\n        return ""F""\n\n    def jacobian(self, args, kwargs=None, *, wrt=None, method=""best"", options=None):\n        r""""""Compute the Jacobian of the QNode.\n\n        Returns the Jacobian of the parametrized quantum circuit encapsulated in the QNode.\n        The Jacobian is returned as a two-dimensional array. The (possibly nested) input arguments\n        of the QNode are :func:`flattened <_flatten>` so the QNode can be interpreted as a simple\n        :math:`\\mathbb{R}^m \\to \\mathbb{R}^n` function.\n\n        The Jacobian can be computed using several methods:\n\n        * Finite differences (``\'F\'``). The first-order method evaluates the circuit at\n          :math:`n+1` points of the parameter space, the second-order method at :math:`2n` points,\n          where ``n = len(wrt)``.\n\n        * Analytic method (``\'A\'``). Analytic, if implemented by the inheriting QNode.\n\n        * Best known method for each parameter (``\'best\'``): uses the analytic method if\n          possible, otherwise finite difference.\n\n        * Device method (``\'device\'``): Delegates the computation of the Jacobian to the\n          device executing the circuit. Only supported by devices that provide their\n          own method for computing derivatives; support can be checked by\n          querying the device capabilities: ``dev.capabilities()[\'provides_jacobian\']`` must\n          return ``True``. Examples of supported devices include the experimental\n          :class:`""default.tensor.tf"" <~.DefaultTensorTF>` device.\n\n        .. note::\n           The finite difference method is sensitive to statistical noise in the circuit output,\n           since it compares the output at two points infinitesimally close to each other. Hence the\n           \'F\' method requires exact expectation values, i.e., ``analytic=True`` in simulation plugins.\n\n        Args:\n            args (nested Iterable[float] or float): positional arguments to the quantum function (differentiable)\n            kwargs (dict[str, Any]): auxiliary arguments to the quantum function (not differentiable)\n            wrt (Sequence[int] or None): Indices of the flattened positional parameters with respect\n                to which to compute the Jacobian. None means all the parameters.\n                Note that you cannot compute the Jacobian with respect to the kwargs.\n            method (str): Jacobian computation method, in ``{\'F\', \'A\', \'best\', \'device\'}``, see above\n            options (dict[str, Any]): additional options for the computation methods\n\n                * h (float): finite difference method step size\n                * order (int): finite difference method order, 1 or 2\n\n        Returns:\n            array[float]: Jacobian, shape ``(n, len(wrt))``, where ``n`` is the number of outputs returned by the QNode\n        """"""\n        # pylint: disable=too-many-branches,too-many-statements\n        if not isinstance(args, Iterable):\n            args = (args,)\n        kwargs = kwargs or {}\n\n        # apply defaults\n        kwargs = self._default_args(kwargs)\n\n        options = options or {}\n\n        # Add the step size into the options, if it was not there already\n        if ""h"" not in options.keys():\n            options = {""h"": self.h, **options}\n        if ""order"" not in options.keys():\n            options = {""order"": self._order, **options}\n\n        # (re-)construct the circuit if necessary\n        if self.circuit is None or self.mutable:\n            self._construct(args, kwargs)\n\n        returns_samples = [\n            str(ob)\n            for ob in self.circuit.observables\n            if ob.return_type is ObservableReturnTypes.Sample\n        ]\n        if returns_samples:\n            raise QuantumFunctionError(\n                ""Circuits that include sampling can not be differentiated. ""\n                ""The following observables include sampling: {}"".format(""; "".join(returns_samples))\n            )\n\n        # check that the wrt parameters are ok\n        if wrt is None:\n            wrt = range(self.num_variables)\n        else:\n            if min(wrt) < 0 or max(wrt) >= self.num_variables:\n                raise ValueError(\n                    ""Tried to compute the gradient with respect to parameters {} ""\n                    ""(this node has {} parameters)."".format(wrt, self.num_variables)\n                )\n            if len(wrt) != len(set(wrt)):  # set removes duplicates\n                raise ValueError(""Parameter indices must be unique."")\n\n        # check if the method can be used on the requested parameters\n        method_map = _inv_dict(self.par_to_grad_method)\n\n        def inds_using(m):\n            """"""Intersection of ``wrt`` with free params indices whose best grad method is m.""""""\n            return method_map.get(m, set()).intersection(wrt)\n\n        # are we trying to differentiate wrt. params that don\'t support any method?\n        bad = inds_using(None)\n        if bad:\n            # get bad argument name\n            bad_var_names = {\n                v.name for v in _flatten(self.arg_vars) if hasattr(v, ""idx"") and v.idx in bad\n            }\n            raise ValueError(\n                ""Cannot differentiate with respect to argument(s) {}."".format(bad_var_names)\n            )\n\n        if method == ""device"":\n            self._set_variables(args, kwargs)\n            return self.device.jacobian(\n                self.circuit.operations, self.circuit.observables, self.variable_deps\n            )\n\n        if method == ""A"":\n            bad = inds_using(""F"")\n\n            # get bad argument name\n            bad_var_names = {\n                v.name for v in _flatten(self.arg_vars) if hasattr(v, ""idx"") and v.idx in bad\n            }\n\n            if bad:\n                raise ValueError(\n                    ""The analytic gradient method cannot be ""\n                    ""used with the argument(s) {}."".format(bad_var_names)\n                )\n            # only variants of the analytic method remain\n            method = self.par_to_grad_method\n        elif method == ""F"":\n            # use the requested method for every parameter\n            method = {k: ""F"" for k in wrt}\n        elif method == ""best"":\n            # use best known method for each parameter\n            method = self.par_to_grad_method\n        else:\n            raise ValueError(""Unknown gradient method."")\n\n        if ""F"" in method.values():\n            if options.get(""order"", 1) == 1:\n                # the value of the circuit at args, computed only once here\n                options[""y0""] = np.asarray(self.evaluate(args, kwargs))\n\n        # In the following, to evaluate the Jacobian we call self.evaluate several times using\n        # modified args (and possibly modified circuit Operators).\n        # We do not want evaluate to call _construct again. This would only be necessary if the\n        # auxiliary args changed, since only they can change the structure of the circuit,\n        # and we do not modify them. To achieve this, we temporarily make the circuit immutable.\n        mutable = self.mutable\n        self.mutable = False\n\n        # flatten the nested Sequence of input arguments\n        flat_args = np.array(list(_flatten(args)), dtype=float)\n        variances_required = any(\n            ob.return_type is ObservableReturnTypes.Variance for ob in self.circuit.observables\n        )\n\n        # compute the partial derivative wrt. each parameter using the appropriate method\n        grad = np.zeros((self.output_dim, len(wrt)), dtype=float)\n        for i, k in enumerate(wrt):\n            par_method = method[k]\n\n            if par_method == ""0"":\n                # unused/invisible, partial derivatives wrt. this param are zero\n                continue\n\n            if par_method == ""A"":\n                if variances_required:\n                    grad[:, i] = self._pd_analytic_var(k, flat_args, kwargs, **options)\n                else:\n                    grad[:, i] = self._pd_analytic(k, flat_args, kwargs, **options)\n            elif par_method == ""F"":\n                grad[:, i] = self._pd_finite_diff(k, flat_args, kwargs, **options)\n            else:\n                raise ValueError(""Unknown gradient method."")\n\n        self.mutable = mutable  # restore original mutability\n        return grad\n\n    def _pd_finite_diff(self, idx, args, kwargs, **options):\n        """"""Partial derivative of the node using the finite difference method.\n\n        Args:\n            idx (int): flattened index of the parameter wrt. which the p.d. is computed\n            args (array[float]): flattened positional arguments at which to evaluate the p.d.\n            kwargs (dict[str, Any]): auxiliary arguments\n\n        Keyword Args:\n            y0 (array[float], None): value of the circuit at the given arguments\n            h (float): step size\n            order (int): finite difference method order, 1 or 2\n\n        Returns:\n            array[float]: partial derivative of the node\n        """"""\n        h = options.get(""h"", self.h)\n        order = options.get(""order"", self.order)\n\n        shift_args = args.copy()\n        if order == 1:\n            y0 = options.get(""y0"", None)\n            # shift the parameter by h\n            shift_args[idx] += h\n            y = np.asarray(self.evaluate(shift_args, kwargs))\n            return (y - y0) / h\n\n        if order == 2:\n            # symmetric difference\n            # shift the parameter by +-h/2\n            shift_args[idx] += 0.5 * h\n            y2 = np.asarray(self.evaluate(shift_args, kwargs))\n            shift_args[idx] = args[idx] - 0.5 * h\n            y1 = np.asarray(self.evaluate(shift_args, kwargs))\n            return (y2 - y1) / h\n\n        raise ValueError(""Order must be 1 or 2."")\n\n    def _pd_analytic(self, idx, args, kwargs, **options):\n        """"""Partial derivative of the node using an analytic method.\n\n        Args:\n            idx (int): flattened index of the parameter wrt. which the p.d. is computed\n            args (array[float]): flattened positional arguments at which to evaluate the p.d.\n            kwargs (dict[str, Any]): auxiliary arguments\n\n        Returns:\n            array[float]: partial derivative of the node\n        """"""\n        raise NotImplementedError\n\n    def _pd_analytic_var(self, idx, args, kwargs, **options):\n        """"""Partial derivative of the variance of an observable using an analytic method.\n\n        Args:\n            idx (int): flattened index of the parameter wrt. which the p.d. is computed\n            args (array[float]): flattened positional arguments at which to evaluate the p.d.\n            kwargs (dict[str, Any]): auxiliary arguments\n\n        Returns:\n            array[float]: partial derivative of the node\n        """"""\n        raise NotImplementedError\n\n    def to_torch(self):\n        """"""Attach the Torch interface to the Jacobian QNode.\n\n        Raises:\n            QuantumFunctionError: if PyTorch is not installed\n        """"""\n        # Placing slow imports here, in case the user does not use the Torch interface\n        # pylint: disable=import-outside-toplevel\n        try:  # pragma: no cover\n            from pennylane.interfaces.torch import to_torch as _to_torch\n        except ImportError:  # pragma: no cover\n            raise QuantumFunctionError(\n                ""PyTorch not found. Please install "" ""PyTorch to enable the \'torch\' interface.""\n            ) from None\n\n        return _to_torch(self)\n\n    def to_tf(self):\n        """"""Attach the TensorFlow interface to the Jacobian QNode.\n\n        Raises:\n            QuantumFunctionError: if TensorFlow >= 1.12 is not installed\n        """"""\n        # Placing slow imports here, in case the user does not use the TF interface\n        # pylint: disable=import-outside-toplevel\n        try:  # pragma: no cover\n            from pennylane.interfaces.tf import to_tf as _to_tf\n        except ImportError:  # pragma: no cover\n            raise QuantumFunctionError(\n                ""TensorFlow not found. Please install ""\n                ""the latest version of TensorFlow to enable the \'tf\' interface.""\n            ) from None\n\n        return _to_tf(self)\n\n    def to_autograd(self):\n        """"""Attach the TensorFlow interface to the Jacobian QNode.\n\n        Raises:\n            QuantumFunctionError: if Autograd is not installed\n        """"""\n        # Placing slow imports here, in case the user does not use the TF interface\n        # pylint: disable=import-outside-toplevel\n        try:  # pragma: no cover\n            from pennylane.interfaces.autograd import to_autograd as _to_autograd\n        except ImportError:  # pragma: no cover\n            raise QuantumFunctionError(\n                ""Autograd not found. Please install ""\n                ""the latest version of Autograd to enable the \'autograd\' interface.""\n            ) from None\n\n        return _to_autograd(self)\n'"
pennylane/qnodes/passthru.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nPassthruQNode class\n""""""\nimport pennylane.operation\nimport pennylane.circuit_graph\nfrom .base import BaseQNode, QuantumFunctionError\n\n\n""""""\nDesign notes\n------------\n\nPassthruQNode requires some changes to the way other PennyLane components work:\n\n1. :class:`Operator` must not do domain checking for its parameters, or it must let the ADT pass the check.\n2. The simulator device must return the result as the ADT instead of plain Python/NumPy types.\n3. Any output_conversion in :meth:`BaseQNode.evaluate` must be skipped.\n\nAdditionally, any array-like ADT needs to be able to handle (1) scalar multiplication,\n(2) indexing/slicing, and possibly (3) iteration, as these are the things qfuncs expect of\narray-like parameters.\n\nPassthruQNode does not have a Jacobian method, so it does not HAVE to use Variables or scalar linear indexing of input parameters.\nTwo options:\n1. Use Variables anyway, re-use most BaseQNode methods.\n   Problem: after evaluating the Variables, stacking sliced/indexed Tensors in Operation.parameters should somehow result in a Tensor, not an object array.\n2. Do not use Variables, call the qfunc each time :meth:`PassthruQNode.evaluate` is called (always mutable).\n   Problem: tensornet_tf requires variable_deps?\n\nTODO rethink output_conversion? should require device to return things in a fixed form, but either as arrays or as AD Tensors, do conversion in interface (if necessary...)\n""""""\n\n\nclass PassthruQNode(BaseQNode):\n    """"""Differentiable quantum node that appears as a white box to an external autodiff framework.\n\n    In PennyLane, the QNode classes work as black box functions with respect to any\n    autodiff (AD) framework (such as TensorFlow or PyTorch). This means that the QNode\n    converts all its inputs (which may come in data types specific to the\n    AD framework used, which we denote *ADT* here) into plain Python/NumPy types,\n    computes the required :ref:`quantum function <intro_vcirc_qfunc>` value or Jacobian,\n    and converts the result back into the ADT if necessary.\n\n    In contrast, PassthruQNode works as a white box: it preserves the ADT\n    throughout the computation. This requires that the quantum function is computed\n    using a simulator device that is compatible with the AD framework used (typically\n    implemented using that same framework), and returns the result as the ADT instead\n    of plain Python/NumPy types.\n\n    The advantages of this approach are that the qfunc can be differentiated using its AD framework\n    without requiring a separate method for computing the Jacobian, and that the internals\n    of the simulation are visible in the computational graph.\n\n    Args:\n        func (callable): The *quantum function* of the QNode.\n            A Python function containing :class:`~.operation.Operation` constructor calls,\n            and returning a tuple of measured :class:`~.operation.Observable` instances.\n        device (~pennylane._device.Device): computational device to execute the function on\n\n    Keyword Args:\n        use_native_type (bool): If True, return the result in whatever type the device uses\n            internally, otherwise convert it into array[float]. Default: True.\n    """"""\n\n    def __init__(self, func, device, **kwargs):\n        # make the device return the result in its native type\n        kwargs = kwargs or {}\n        kwargs.setdefault(""use_native_type"", True)\n        kwargs.setdefault(""mutable"", True)\n\n        if not kwargs.get(""mutable""):\n            raise ValueError(""PassthruQNode does not support immutable mode."")\n\n        super().__init__(func, device, **kwargs)\n\n    def __repr__(self):\n        """"""String representation.""""""\n        detail = ""<PassthruQNode: device=\'{}\', func={}, wires={}>""\n        return detail.format(self.device.short_name, self.func.__name__, self.num_wires)\n\n    def _set_variables(self, args, kwargs):\n        # do nothing, since we do not use Variables\n        pass\n\n    def _construct(self, args, kwargs):\n        """"""Construct the quantum circuit graph by calling the quantum function.\n\n        Like :class:`.BaseQNode._construct`, but does not use Variables.\n        """"""\n        # temporary queues for operations and observables\n        self.queue = []  #: list[Operation]: applied operations\n        self.obs_queue = []  #: list[Observable]: applied observables\n\n        # set up the context for Operator entry\n        with self:\n            # use a try/finally block such that if any errors arise during\n            # checking, and the user manually catches the exception, the class\n            # attribute pennylane.operation.Operator.do_check_domain is\n            # properly reset to True\n            try:\n                # turn off domain checking since PassthruQNode qfuncs can take any class as input\n                pennylane.operation.Operator.do_check_domain = False\n                # generate the program queue by executing the quantum circuit function\n                res = self.func(*args, **kwargs)\n            finally:\n                pennylane.operation.Operator.do_check_domain = True\n\n        # use a try/finally block here too\n        try:\n            # check the validity of the circuit\n            # turn off domain checking, but outside of the context such that no\n            # queuing takes place (e.g. from decompositions)\n            pennylane.operation.Operator.do_check_domain = False\n            self._check_circuit(res)\n        finally:\n            pennylane.operation.Operator.do_check_domain = True\n\n        del self.queue\n        del self.obs_queue\n\n        # no output conversion\n        self.output_conversion = lambda x: x\n\n        # no Variables, self.variable_deps is empty!\n        # generate the DAG\n        self.circuit = pennylane.circuit_graph.CircuitGraph(self.ops, self.variable_deps)\n\n        # check for operations that cannot affect the output\n        if self.kwargs.get(""vis_check"", False):\n            invisible = self.circuit.invisible_operations()\n            if invisible:\n                raise QuantumFunctionError(\n                    ""The operations {} cannot affect the circuit output."".format(invisible)\n                )\n'"
pennylane/qnodes/qubit.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nQubit parameter shift quantum node.\r\n\r\nProvides analytic differentiation for all one-parameter gates where the generator\r\nonly has two unique eigenvalues; this includes one-parameter single-qubit gates.\r\n""""""\r\nimport itertools\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom scipy import linalg\r\n\r\nimport pennylane as qml\r\nfrom pennylane.measure import var\r\nfrom pennylane.utils import expand\r\n\r\nfrom pennylane.operation import Observable, ObservableReturnTypes\r\n\r\nfrom .base import QuantumFunctionError\r\nfrom .jacobian import JacobianQNode\r\n\r\n\r\nclass QubitQNode(JacobianQNode):\r\n    """"""Quantum node for qubit parameter shift analytic differentiation""""""\r\n\r\n    def _best_method(self, idx):\r\n        """"""Determine the correct partial derivative computation method for a free parameter.\r\n\r\n        Use the parameter-shift analytic method iff every gate that depends on the parameter supports it.\r\n        If not, use the finite difference method only.\r\n\r\n        Note that if even one dependent Operation does not support differentiation,\r\n        we cannot differentiate with respect to this parameter at all.\r\n\r\n        Args:\r\n            idx (int): free parameter index\r\n\r\n        Returns:\r\n            str: partial derivative method to be used\r\n        """"""\r\n        # operations that depend on this free parameter\r\n        ops = [d.op for d in self.variable_deps[idx]]\r\n\r\n        # Observables in the circuit\r\n        # (the topological order is the queue order)\r\n        observables = self.circuit.observables_in_order\r\n\r\n        # an empty list to store the \'best\' partial derivative method\r\n        # for each operator/observable pair\r\n        best = np.empty((len(ops), len(observables)), dtype=object)\r\n\r\n        # find the best supported partial derivative method for each operator\r\n        for k_op, op in enumerate(ops):\r\n            if op.grad_method is None:\r\n                # one nondifferentiable item makes the whole nondifferentiable\r\n                op.use_method = None\r\n                continue\r\n\r\n            # loop over all observables\r\n            for k_ob, ob in enumerate(observables):\r\n                # get the set of operations betweens the\r\n                # operation and the observable\r\n                S = self.circuit.nodes_between(op, ob)\r\n\r\n                # If there is no path between them, p.d. is zero\r\n                # Otherwise, use finite differences\r\n                best[k_op, k_ob] = ""0"" if not S else op.grad_method\r\n\r\n            if all(k == ""0"" for k in best[k_op, :]):\r\n                # one nondifferentiable item makes the whole nondifferentiable\r\n                op.use_method = ""0""\r\n            elif ""F"" in best[k_op, :]:\r\n                # one non-analytic item makes the whole numeric\r\n                op.use_method = ""F""\r\n            else:\r\n                op.use_method = ""A""\r\n\r\n        # if all ops that depend on the free parameter have a best method\r\n        # of ""0"", then we can skip the partial derivative altogether\r\n        if all(o.use_method == ""0"" for o in ops):\r\n            return ""0""\r\n\r\n        # one nondifferentiable item makes the whole nondifferentiable\r\n        if any(o.use_method is None for o in ops):\r\n            return None\r\n\r\n        # one non-analytic item makes the whole numeric\r\n        if any(o.use_method == ""F"" for o in ops):\r\n            return ""F""\r\n\r\n        return ""A""\r\n\r\n    def _pd_analytic(self, idx, args, kwargs, **options):\r\n        """"""Partial derivative of the node using the analytic parameter shift method.\r\n        Args:\r\n            idx (int): flattened index of the parameter wrt. which the p.d. is computed\r\n            args (array[float]): flattened positional arguments at which to evaluate the p.d.\r\n            kwargs (dict[str, Any]): auxiliary arguments\r\n\r\n        Returns:\r\n            array[float]: partial derivative of the node\r\n        """"""\r\n        n = self.num_variables\r\n        pd = 0.0\r\n        # find the Operators in which the free parameter appears, use the product rule\r\n        for op, p_idx in self.variable_deps[idx]:\r\n\r\n            # We temporarily edit the Operator such that parameter p_idx is replaced by a new one,\r\n            # which we can modify without affecting other Operators depending on the original.\r\n            orig = op.params[p_idx]\r\n            assert orig.idx == idx\r\n\r\n            # reference to a new, temporary parameter with index n, otherwise identical with orig\r\n            temp_var = copy.copy(orig)\r\n            temp_var.idx = n\r\n            op.params[p_idx] = temp_var\r\n\r\n            multiplier, shift = op.get_parameter_shift(p_idx)\r\n\r\n            # shifted parameter values\r\n            shift_p1 = np.r_[args, args[idx] + shift]\r\n            shift_p2 = np.r_[args, args[idx] - shift]\r\n\r\n            # evaluate the circuit at two points with shifted parameter values\r\n            y2 = np.asarray(self.evaluate(shift_p1, kwargs))\r\n            y1 = np.asarray(self.evaluate(shift_p2, kwargs))\r\n            pd += (y2 - y1) * multiplier\r\n\r\n            # restore the original parameter\r\n            op.params[p_idx] = orig\r\n\r\n        return pd\r\n\r\n    def _pd_analytic_var(self, idx, args, kwargs, **options):\r\n        """"""Partial derivative of the variance of an observable using the parameter-shift method.\r\n\r\n        Args:\r\n            idx (int): flattened index of the parameter wrt. which the p.d. is computed\r\n            args (array[float]): flattened positional arguments at which to evaluate the p.d.\r\n            kwargs (dict[str, Any]): auxiliary arguments\r\n\r\n        Returns:\r\n            array[float]: partial derivative of the node\r\n        """"""\r\n        # boolean mask: elements are True where the return type is a variance, False for expectations\r\n        where_var = [\r\n            e.return_type is ObservableReturnTypes.Variance for e in self.circuit.observables\r\n        ]\r\n        var_observables = [\r\n            e for e in self.circuit.observables if e.return_type == ObservableReturnTypes.Variance\r\n        ]\r\n\r\n        # first, replace each var(A) with <A^2>\r\n        new_observables = []\r\n        for e in var_observables:\r\n            # need to calculate d<A^2>/dp\r\n            w = e.wires\r\n\r\n            if e.name == ""Hermitian"":\r\n                # since arbitrary Hermitian observables\r\n                # are not guaranteed to be involutory, need to take them into\r\n                # account separately to calculate d<A^2>/dp\r\n\r\n                A = e.params[0]  # Hermitian matrix\r\n                # if not np.allclose(A @ A, np.identity(A.shape[0])):\r\n                new = qml.expval(qml.Hermitian(A @ A, w, do_queue=False))\r\n            else:\r\n                # involutory, A^2 = I\r\n                # For involutory observables (A^2 = I) we have d<A^2>/dp = 0\r\n                new = qml.expval(qml.Hermitian(np.identity(2 ** len(w)), w, do_queue=False))\r\n\r\n            # replace the var(A) observable with <A^2>\r\n            self.circuit.update_node(e, new)\r\n            new_observables.append(new)\r\n\r\n        # calculate the analytic derivatives of the <A^2> observables\r\n        pdA2 = self._pd_analytic(idx, args, kwargs)\r\n\r\n        # restore the original observables, but convert their return types to expectation\r\n        for e, new in zip(var_observables, new_observables):\r\n            self.circuit.update_node(new, e)\r\n            e.return_type = ObservableReturnTypes.Expectation\r\n\r\n        # evaluate <A>\r\n        evA = np.asarray(self.evaluate(args, kwargs))\r\n\r\n        # evaluate the analytic derivative of <A>\r\n        pdA = self._pd_analytic(idx, args, kwargs)\r\n\r\n        # restore return types\r\n        for e in var_observables:\r\n            e.return_type = ObservableReturnTypes.Variance\r\n\r\n        # return d(var(A))/dp = d<A^2>/dp -2 * <A> * d<A>/dp for the variances,\r\n        # d<A>/dp for plain expectations\r\n        return np.where(where_var, pdA2 - 2 * evA * pdA, pdA)\r\n\r\n    def _construct_metric_tensor(self, *, diag_approx=False):\r\n        """"""Construct metric tensor subcircuits for qubit circuits.\r\n\r\n        Constructs a set of quantum circuits for computing a block-diagonal approximation of the\r\n        Fubini-Study metric tensor on the parameter space of the variational circuit represented\r\n        by the QNode, using the Quantum Geometric Tensor.\r\n\r\n        If the parameter appears in a gate :math:`G`, the subcircuit contains\r\n        all gates which precede :math:`G`, and :math:`G` is replaced by the variance\r\n        value of its generator.\r\n\r\n        Args:\r\n            diag_approx (bool): iff True, use the diagonal approximation\r\n\r\n        Raises:\r\n            QuantumFunctionError: if a metric tensor cannot be generated because no generator\r\n                was defined\r\n\r\n        """"""\r\n        # pylint: disable=too-many-statements, too-many-branches\r\n\r\n        self._metric_tensor_subcircuits = {}\r\n        for queue, curr_ops, param_idx, _ in self.circuit.iterate_parametrized_layers():\r\n            obs = []\r\n            scale = []\r\n\r\n            Ki_matrices = []\r\n            KiKj_matrices = []\r\n            Ki_ev = []\r\n            KiKj_ev = []\r\n            V = None\r\n\r\n            # for each operation in the layer, get the generator and convert it to a variance\r\n            for n, op in enumerate(curr_ops):\r\n                gen, s = op.generator\r\n                w = op.wires.tolist()\r\n\r\n                if gen is None:\r\n                    raise QuantumFunctionError(\r\n                        ""Can\'t generate metric tensor, operation {}""\r\n                        ""has no defined generator"".format(op)\r\n                    )\r\n\r\n                # get the observable corresponding to the generator of the current operation\r\n                if isinstance(gen, np.ndarray):\r\n                    # generator is a Hermitian matrix\r\n                    variance = var(qml.Hermitian(gen, w, do_queue=False))\r\n\r\n                    if not diag_approx:\r\n                        Ki_matrices.append((n, expand(gen, w, self.num_wires)))\r\n\r\n                elif issubclass(gen, Observable):\r\n                    # generator is an existing PennyLane operation\r\n                    variance = var(gen(w, do_queue=False))\r\n\r\n                    if not diag_approx:\r\n                        if issubclass(gen, qml.PauliX):\r\n                            mat = np.array([[0, 1], [1, 0]])\r\n                        elif issubclass(gen, qml.PauliY):\r\n                            mat = np.array([[0, -1j], [1j, 0]])\r\n                        elif issubclass(gen, qml.PauliZ):\r\n                            mat = np.array([[1, 0], [0, -1]])\r\n\r\n                        Ki_matrices.append((n, expand(mat, w, self.num_wires)))\r\n\r\n                else:\r\n                    raise QuantumFunctionError(\r\n                        ""Can\'t generate metric tensor, generator {}""\r\n                        ""has no corresponding observable"".format(gen)\r\n                    )\r\n\r\n                obs.append(variance)\r\n                scale.append(s)\r\n\r\n            if not diag_approx:\r\n                # In order to compute the block diagonal portion of the metric tensor,\r\n                # we need to compute \'second order\' <psi|K_i K_j|psi> terms.\r\n\r\n                for i, j in itertools.product(range(len(Ki_matrices)), repeat=2):\r\n                    # compute the matrices representing all K_i K_j terms\r\n                    obs1 = Ki_matrices[i]\r\n                    obs2 = Ki_matrices[j]\r\n                    KiKj_matrices.append(((obs1[0], obs2[0]), obs1[1] @ obs2[1]))\r\n\r\n                V = np.identity(2 ** self.num_wires, dtype=np.complex128)\r\n\r\n                # generate the unitary operation to rotate to\r\n                # the shared eigenbasis of all observables\r\n                for _, term in Ki_matrices:\r\n                    _, S = linalg.eigh(V.conj().T @ term @ V)\r\n                    V = np.round(V @ S, 15)\r\n\r\n                V = V.conj().T\r\n\r\n                # calculate the eigenvalues for\r\n                # each observable in the shared eigenbasis\r\n                for idx, term in Ki_matrices:\r\n                    eigs = np.diag(V @ term @ V.conj().T).real\r\n                    Ki_ev.append((idx, eigs))\r\n\r\n                for idx, term in KiKj_matrices:\r\n                    eigs = np.diag(V @ term @ V.conj().T).real\r\n                    KiKj_ev.append((idx, eigs))\r\n\r\n            self._metric_tensor_subcircuits[param_idx] = {\r\n                ""queue"": queue,\r\n                ""observable"": obs,\r\n                ""Ki_expectations"": Ki_ev,\r\n                ""KiKj_expectations"": KiKj_ev,\r\n                ""eigenbasis_matrix"": V,\r\n                ""result"": None,\r\n                ""scale"": scale,\r\n            }\r\n\r\n    def metric_tensor(self, args, kwargs=None, *, diag_approx=False, only_construct=False):\r\n        """"""Evaluate the value of the metric tensor.\r\n\r\n        Args:\r\n            args (tuple[Any]): positional (differentiable) arguments\r\n            kwargs (dict[str, Any]): auxiliary arguments\r\n            diag_approx (bool): iff True, use the diagonal approximation\r\n            only_construct (bool): Iff True, construct the circuits used for computing\r\n                the metric tensor but do not execute them, and return None.\r\n\r\n        Returns:\r\n            array[float]: metric tensor\r\n        """"""\r\n        # pylint:disable=too-many-branches\r\n        kwargs = kwargs or {}\r\n        kwargs = self._default_args(kwargs)\r\n\r\n        if self.circuit is None or self.mutable:\r\n            # construct the circuit\r\n            self._construct(args, kwargs)\r\n\r\n        if self._metric_tensor_subcircuits is None:\r\n            self._construct_metric_tensor(diag_approx=diag_approx)\r\n\r\n        if only_construct:\r\n            return None\r\n\r\n        # temporarily store the parameter values in the Variable class\r\n        self._set_variables(args, kwargs)\r\n\r\n        tensor = np.zeros([self.num_variables, self.num_variables])\r\n\r\n        # execute constructed metric tensor subcircuits\r\n        for params, circuit in self._metric_tensor_subcircuits.items():\r\n            self.device.reset()\r\n\r\n            s = np.array(circuit[""scale""])\r\n            V = circuit[""eigenbasis_matrix""]\r\n\r\n            if not diag_approx:\r\n                # block diagonal approximation\r\n\r\n                unitary_op = qml.QubitUnitary(V, wires=list(range(self.num_wires)), do_queue=False)\r\n\r\n                if isinstance(self.device, qml.QubitDevice):\r\n                    ops = circuit[""queue""] + [unitary_op] + [qml.expval(qml.PauliZ(0))]\r\n                    circuit_graph = qml.CircuitGraph(ops, self.variable_deps)\r\n                    self.device.execute(circuit_graph)\r\n                else:\r\n                    self.device.execute(\r\n                        circuit[""queue""] + [unitary_op],\r\n                        [\r\n                            qml.expval(qml.PauliZ(wire))\r\n                            for wire in list(range(self.device.num_wires))\r\n                        ],\r\n                    )\r\n\r\n                probs = list(self.device.probability())\r\n\r\n                first_order_ev = np.zeros([len(params)])\r\n                second_order_ev = np.zeros([len(params), len(params)])\r\n\r\n                for idx, ev in circuit[""Ki_expectations""]:\r\n                    first_order_ev[idx] = ev @ probs\r\n\r\n                for idx, ev in circuit[""KiKj_expectations""]:\r\n                    # idx is a 2-tuple (i, j), representing\r\n                    # generators K_i, K_j\r\n                    second_order_ev[idx] = ev @ probs\r\n\r\n                    # since K_i and K_j are assumed to commute,\r\n                    # <psi|K_j K_i|psi> = <psi|K_i K_j|psi>,\r\n                    # and thus the matrix of second-order expectations\r\n                    # is symmetric\r\n                    second_order_ev[idx[1], idx[0]] = second_order_ev[idx]\r\n\r\n                g = np.zeros([len(params), len(params)])\r\n\r\n                for i, j in itertools.product(range(len(params)), repeat=2):\r\n                    g[i, j] = (\r\n                        s[i]\r\n                        * s[j]\r\n                        * (second_order_ev[i, j] - first_order_ev[i] * first_order_ev[j])\r\n                    )\r\n\r\n                row = np.array(params).reshape(-1, 1)\r\n                col = np.array(params).reshape(1, -1)\r\n                circuit[""result""] = np.diag(g)\r\n                tensor[row, col] = g\r\n\r\n            else:\r\n                # diagonal approximation\r\n                if isinstance(self.device, qml.QubitDevice):\r\n                    circuit_graph = qml.CircuitGraph(\r\n                        circuit[""queue""] + circuit[""observable""], self.variable_deps\r\n                    )\r\n                    variances = self.device.execute(circuit_graph)\r\n                else:\r\n                    variances = self.device.execute(circuit[""queue""], circuit[""observable""])\r\n\r\n                circuit[""result""] = s ** 2 * variances\r\n                tensor[np.array(params), np.array(params)] = circuit[""result""]\r\n\r\n        return tensor\r\n'"
pennylane/templates/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains templates, which are pre-coded routines that can be used in a quantum node.\n""""""\n\nfrom .broadcast import *\nfrom .decorator import *\nfrom .layers import *\nfrom .embeddings import *\nfrom .subroutines import *\nfrom .state_preparations import *\n'"
pennylane/templates/broadcast.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``broadcast`` template constructor.\nTo add a new pattern:\n* extend the variables ``OPTIONS``, ``n_parameters`` and ``wire_sequence``,\n* update the list in the docstring and add a usage example at the end of the docstring\'s\n  ``UsageDetails`` section,\n* add tests to parametrizations in :func:`test_templates_broadcast`.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom collections import Iterable\n\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import check_type, get_shape, check_is_in_options\nfrom pennylane.wires import Wires\n\n\n###################\n# helpers to define pattern wire sequences\n\n\ndef wires_ring(wires):\n    """"""Wire sequence for the ring pattern""""""\n\n    if len(wires) in [0, 1]:\n        return []\n    elif len(wires) == 2:\n        # deviation from the rule: for 2 wires ring is set equal to chain,\n        # to avoid duplication of single gate\n        return [wires.subset([0, 1])]\n    else:\n        sequence = [wires.subset([i, i + 1], periodic_boundary=True) for i in range(len(wires))]\n        return sequence\n\n\ndef wires_pyramid(wires):\n    """"""Wire sequence for the pyramid pattern.""""""\n    sequence = []\n    for layer in range(len(wires) // 2):\n        block = wires[layer : len(wires) - layer]\n        sequence += [block.subset([i, i + 1]) for i in range(0, len(block) - 1, 2)]\n    return sequence\n\n\ndef wires_all_to_all(wires):\n    """"""Wire sequence for the all-to-all pattern""""""\n    sequence = []\n    for i in range(len(wires)):\n        for j in range(i + 1, len(wires)):\n            sequence += [wires.subset([i, j])]\n    return sequence\n\n\n###################\n\n\n@template\ndef broadcast(unitary, wires, pattern, parameters=None, kwargs=None):\n    r""""""Applies a unitary multiple times to a specific pattern of wires.\n\n    The unitary, defined by the argument ``unitary``, is either a quantum operation\n    (such as :meth:`~.pennylane.ops.RX`), or a\n    user-supplied template. Depending on the chosen pattern, ``unitary`` is applied to a wire or a subset of wires:\n\n    * ``pattern=""single""`` applies a single-wire unitary to each one of the :math:`M` wires:\n\n      .. figure:: ../../_static/templates/broadcast_single.png\n            :align: center\n            :width: 20%\n            :target: javascript:void(0);\n\n    * ``pattern=""double""`` applies a two-wire unitary to :math:`\\lfloor \\frac{M}{2} \\rfloor`\n      subsequent pairs of wires:\n\n      .. figure:: ../../_static/templates/broadcast_double.png\n          :align: center\n          :width: 20%\n          :target: javascript:void(0);\n\n    * ``pattern=""double_odd""`` applies a two-wire unitary to :math:`\\lfloor \\frac{M-1}{2} \\rfloor`\n      subsequent pairs of wires, starting with the second wire:\n\n      .. figure:: ../../_static/templates/broadcast_double_odd.png\n          :align: center\n          :width: 20%\n          :target: javascript:void(0);\n\n    * ``pattern=""chain""`` applies a two-wire unitary to all :math:`M-1` neighbouring pairs of wires:\n\n      .. figure:: ../../_static/templates/broadcast_chain.png\n          :align: center\n          :width: 20%\n          :target: javascript:void(0);\n\n    * ``pattern=""ring""`` applies a two-wire unitary to all :math:`M` neighbouring pairs of wires,\n      where the last wire is considered to be a neighbour to the first one:\n\n      .. figure:: ../../_static/templates/broadcast_ring.png\n          :align: center\n          :width: 20%\n          :target: javascript:void(0);\n\n      .. note:: For 2 wires, the ring pattern is automatically replaced by ``pattern = \'chain\'`` to avoid\n                a mere repetition of the unitary.\n\n    * ``pattern=""pyramid""`` applies a two-wire unitary to wire pairs shaped in a pyramid declining to the right:\n\n      .. figure:: ../../_static/templates/broadcast_pyramid.png\n          :align: center\n          :width: 20%\n          :target: javascript:void(0);\n\n    * ``pattern=""all_to_all""`` applies a two-wire unitary to wire pairs that connect all wires to each other:\n\n      .. figure:: ../../_static/templates/broadcast_alltoall.png\n          :align: center\n          :width: 20%\n          :target: javascript:void(0);\n\n    * A custom pattern can be passed by provding a list of wire lists to ``pattern``. The ``unitary`` is applied\n      to each set of wires specified in the list.\n\n      .. figure:: ../../_static/templates/broadcast_custom.png\n          :align: center\n          :width: 20%\n          :target: javascript:void(0);\n\n    Each ``unitary`` may depend on a different set of parameters. These are passed as a list by the ``parameters``\n    argument.\n\n    For more details, see *Usage Details* below.\n\n    Args:\n        unitary (func): quantum gate or template\n        pattern (str): specifies the wire pattern of the broadcast\n        parameters (list): sequence of parameters for each gate applied\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        kwargs (dict): dictionary of auxilliary parameters for ``unitary``\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        **Broadcasting single gates**\n\n        In the simplest case the unitary is typically an :meth:`~.pennylane.operation.Operation` object\n        implementing a quantum gate.\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane import broadcast\n\n            dev = qml.device(\'default.qubit\', wires=3)\n\n            @qml.qnode(dev)\n            def circuit(pars):\n                broadcast(unitary=qml.RX, pattern=""single"", wires=[0,1,2], parameters=pars)\n                return qml.expval(qml.PauliZ(0))\n\n            circuit([1, 1, 2])\n\n        This is equivalent to the following circuit:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit(pars):\n                qml.RX(pars[0], wires=[0])\n                qml.RX(pars[1], wires=[1])\n                qml.RX(pars[2], wires=[2])\n                return qml.expval(qml.PauliZ(0))\n\n            circuit([1, 1, 2])\n\n        **Broadcasting templates**\n\n        Alternatively, one can broadcast a built-in or user-defined template:\n\n        .. code-block:: python\n\n            from pennylane.templates import template\n\n            @template\n            def mytemplate(pars, wires):\n                qml.Hadamard(wires=wires)\n                qml.RY(pars, wires=wires)\n\n            dev = qml.device(\'default.qubit\', wires=3)\n\n            @qml.qnode(dev)\n            def circuit(pars):\n                broadcast(unitary=mytemplate, pattern=""single"", wires=[0,1,2], parameters=pars)\n                return qml.expval(qml.PauliZ(0))\n\n            print(circuit([1, 1, 0.1]))\n\n        **Constant unitaries**\n\n        If the ``unitary`` argument does not take parameters, no ``parameters`` argument is passed to\n        :func:`~.pennylane.broadcast`:\n\n        .. code-block:: python\n\n            dev = qml.device(\'default.qubit\', wires=3)\n\n            @qml.qnode(dev)\n            def circuit():\n                broadcast(unitary=qml.Hadamard, pattern=""single"", wires=[0,1,2])\n                return qml.expval(qml.PauliZ(0))\n\n            circuit()\n\n        **Multiple parameters in unitary**\n\n        The unitary, whether it is a single gate or a user-defined template,\n        can take multiple parameters. For example:\n\n        .. code-block:: python\n\n            from pennylane.templates import template\n\n            @template\n            def mytemplate(pars1, pars2, wires):\n                qml.Hadamard(wires=wires)\n                qml.RY(pars1, wires=wires)\n                qml.RX(pars2, wires=wires)\n\n            @qml.qnode(dev)\n            def circuit(pars):\n                broadcast(unitary=mytemplate, pattern=""single"", wires=[0,1,2], parameters=pars)\n                return qml.expval(qml.PauliZ(0))\n\n            circuit([[1, 1], [2, 1], [0.1, 1]])\n\n        In general, the unitary takes D parameters and **must** have the following signature:\n\n        .. code-block:: python\n\n            unitary(parameter1, parameter2, ... parameterD, wires, **kwargs)\n\n        If ``unitary`` does not depend on parameters (:math:`D=0`), the signature is\n\n        .. code-block:: python\n\n            unitary(wires, **kwargs)\n\n        As a result, ``parameters`` must be a list or array of length-:math:`D` lists or arrays.\n\n        If :math:`D` becomes large, the signature can be simplified by wrapping each entry in ``parameters``:\n\n        .. code-block:: python\n\n            @template\n            def mytemplate(pars, wires):\n                qml.Hadamard(wires=wires)\n                qml.RY(pars[0], wires=wires)\n                qml.RX(pars[1], wires=wires)\n\n            @qml.qnode(dev)\n            def circuit(pars):\n                broadcast(unitary=mytemplate, pattern=""single"", wires=[0,1,2], parameters=pars)\n                return qml.expval(qml.PauliZ(0))\n\n            print(circuit([[[1, 1]], [[2, 1]], [[0.1, 1]]]))\n\n        If the number of parameters for each wire does not match the unitary, an error gets thrown:\n\n        .. code-block:: python\n\n            @template\n            def mytemplate(pars1, pars2, wires):\n                qml.Hadamard(wires=wires)\n                qml.RY(pars1, wires=wires)\n                qml.RX(pars2, wires=wires)\n\n            @qml.qnode(dev)\n            def circuit(pars):\n                broadcast(unitary=mytemplate, pattern=""single"", wires=[0, 1, 2], parameters=pars)\n                return qml.expval(qml.PauliZ(0))\n\n        >>> circuit([1, 2, 3]))\n        TypeError: mytemplate() missing 1 required positional argument: \'pars2\'\n\n        **Keyword arguments**\n\n        The unitary can be a template that takes additional keyword arguments.\n\n        .. code-block:: python\n\n            @template\n            def mytemplate(wires, h=True):\n                if h:\n                    qml.Hadamard(wires=wires)\n                qml.T(wires=wires)\n\n            @qml.qnode(dev)\n            def circuit(hadamard=None):\n                broadcast(unitary=mytemplate, pattern=""single"", wires=[0, 1, 2], kwargs={\'h\': hadamard})\n                return qml.expval(qml.PauliZ(0))\n\n            circuit(hadamard=False)\n\n        **Different patterns**\n\n        The basic usage of the different patterns works as follows:\n\n        * Double pattern\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=4)\n\n              @qml.qnode(dev)\n              def circuit(pars):\n                  broadcast(unitary=qml.CRot, pattern=\'double\',\n                            wires=[0,1,2,3], parameters=pars)\n                  return qml.expval(qml.PauliZ(0))\n\n              pars1 = [-1, 2.5, 3]\n              pars2 = [-1, 4, 2]\n\n              circuit([pars1, pars2])\n\n        * Double-odd pattern\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=4)\n\n              @qml.qnode(dev)\n              def circuit(pars):\n                  broadcast(unitary=qml.CRot, pattern=\'double_odd\',\n                            wires=[0,1,2,3], parameters=pars)\n                  return qml.expval(qml.PauliZ(0))\n\n              pars1 = [-5.3, 2.3, 3]\n\n              circuit([pars1])\n\n        * Chain pattern\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=4)\n\n              @qml.qnode(dev)\n              def circuit(pars):\n                  broadcast(unitary=qml.CRot, pattern=\'chain\',\n                            wires=[0,1,2,3], parameters=pars)\n                  return qml.expval(qml.PauliZ(0))\n\n              pars1 = [1.8, 2, 3]\n              pars2 = [-1, 3, 1]\n              pars3 = [2, -1.2, 4]\n\n              circuit([pars1, pars2, pars3])\n\n        * Ring pattern\n\n          In general, the number of parameter sequences has to match\n          the number of wires:\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=3)\n\n              @qml.qnode(dev)\n              def circuit(pars):\n                  broadcast(unitary=qml.CRot, pattern=\'ring\',\n                            wires=[0,1,2], parameters=pars)\n                  return qml.expval(qml.PauliZ(0))\n\n              pars1 = [1, -2.2, 3]\n              pars2 = [-1, 3, 1]\n              pars3 = [2.6, 1, 4]\n\n              circuit([pars1, pars2, pars3])\n\n          However, there is an exception for 2 wires, where only one set of parameters is needed.\n          This avoids repeating a gate over the\n          same wires twice:\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=2)\n\n              @qml.qnode(dev)\n              def circuit(pars):\n                  broadcast(unitary=qml.CRot, pattern=\'ring\',\n                            wires=[0,1], parameters=pars)\n                  return qml.expval(qml.PauliZ(0))\n\n              pars1 = [-3.2, 2, 1.2]\n\n              circuit([pars1])\n\n        * Pyramid pattern\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=4)\n\n              @qml.qnode(dev)\n              def circuit(pars):\n                  broadcast(unitary=qml.CRot, pattern=\'pyramid\',\n                            wires=[0,1,2,3], parameters=pars)\n                  return qml.expval(qml.PauliZ(0))\n\n              pars1 = [1.1, 2, 3]\n              pars2 = [-1, 3, 1]\n              pars3 = [2, 1, 4.2]\n\n              circuit([pars1, pars2, pars3])\n\n        * All-to-all pattern\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=4)\n\n              @qml.qnode(dev)\n              def circuit(pars):\n                  broadcast(unitary=qml.CRot, pattern=\'ring\',\n                            wires=[0,1,2,3], parameters=pars)\n                  return qml.expval(qml.PauliZ(0))\n\n              pars1 = [1, 2, 3]\n              pars2 = [-1, 3, 1]\n              pars3 = [2, 1, 4]\n              pars4 = [-1, -2, -3]\n              pars5 = [2, 1, 4]\n              pars6 = [3, -2, -3]\n\n              circuit([pars1, pars2, pars3, pars4, pars5, pars6])\n\n        * Custom pattern\n\n          For a custom pattern, the wire lists for each application of the unitary is\n          passed to ``pattern``:\n\n          .. code-block:: python\n\n              dev = qml.device(\'default.qubit\', wires=5)\n\n              pattern = [[0, 1], [3, 4]]\n\n              @qml.qnode(dev)\n              def circuit():\n                  broadcast(unitary=qml.CNOT, pattern=pattern,\n                            wires=range(5))\n                  return qml.expval(qml.PauliZ(0))\n\n              circuit()\n\n          When using a parametrized unitary, make sure that the number of wire lists in ``pattern`` corresponds to the\n          number of parameters in ``parameters``.\n\n          .. code-block:: python\n\n                pattern = [[0, 1], [3, 4]]\n\n                @qml.qnode(dev)\n                def circuit(pars):\n                    broadcast(unitary=qml.CRot, pattern=pattern,\n                              wires=range(5), parameters=pars)\n                    return qml.expval(qml.PauliZ(0))\n\n                pars1 = [1, 2, 3]\n                pars2 = [-1, 3, 1]\n                pars = [pars1, pars2]\n\n                assert len(pars) == len(pattern)\n\n                circuit(pars)\n    """"""\n\n    OPTIONS = [""single"", ""double"", ""double_odd"", ""chain"", ""ring"", ""pyramid"", ""all_to_all"", ""custom""]\n\n    #########\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_type(\n        parameters,\n        [Iterable, type(None)],\n        msg=""\'parameters\' must be either of type None or ""\n        ""Iterable; got {}"".format(type(parameters)),\n    )\n\n    if kwargs is None:\n        kwargs = {}\n\n    check_type(\n        kwargs, [dict], msg=""\'kwargs\' must be a dictionary; got {}"".format(type(kwargs)),\n    )\n\n    custom_pattern = None\n\n    if isinstance(pattern, str):\n        check_is_in_options(\n            pattern, OPTIONS, msg=""did not recognize option {} for \'pattern\'"".format(pattern),\n        )\n    else:\n        # turn custom pattern into list of Wires objects\n        custom_pattern = [Wires(w) for w in pattern]\n        # set ""pattern"" to ""custom"", indicating that custom settings have to be used\n        pattern = ""custom""\n\n    n_parameters = {\n        ""single"": len(wires),\n        ""double"": 0 if len(wires) in [0, 1] else len(wires) // 2,\n        ""double_odd"": 0 if len(wires) in [0, 1] else (len(wires) - 1) // 2,\n        ""chain"": 0 if len(wires) in [0, 1] else len(wires) - 1,\n        ""ring"": 0 if len(wires) in [0, 1] else (1 if len(wires) == 2 else len(wires)),\n        ""pyramid"": 0 if len(wires) in [0, 1] else sum(i + 1 for i in range(len(wires) // 2)),\n        ""all_to_all"": 0 if len(wires) in [0, 1] else len(wires) * (len(wires) - 1) // 2,\n        ""custom"": len(custom_pattern) if custom_pattern is not None else None,\n    }\n\n    # check that there are enough parameters for pattern\n    if parameters is not None:\n        shape = get_shape(parameters)\n\n        # specific error message for ring edge case of 2 wires\n        if (pattern == ""ring"") and (len(wires) == 2) and (shape[0] != 1):\n            raise ValueError(\n                ""the ring pattern with 2 wires is an exception and only applies one unitary""\n            )\n\n        if shape[0] != n_parameters[pattern]:\n            raise ValueError(\n                ""\'parameters\' must contain entries for {} unitaries; got {} entries"".format(\n                    n_parameters[pattern], shape[0]\n                )\n            )\n\n        # repackage for consistent unpacking\n        if len(shape) == 1:\n            parameters = [[p] for p in parameters]\n    else:\n        parameters = [[] for _ in range(n_parameters[pattern])]\n\n    #########\n\n    # define wire sequences for patterns\n    wire_sequence = {\n        ""single"": [wires[i] for i in range(len(wires))],\n        ""double"": [wires.subset([i, i + 1]) for i in range(0, len(wires) - 1, 2)],\n        ""double_odd"": [wires.subset([i, i + 1]) for i in range(1, len(wires) - 1, 2)],\n        ""chain"": [wires.subset([i, i + 1]) for i in range(len(wires) - 1)],\n        ""ring"": wires_ring(wires),\n        ""pyramid"": wires_pyramid(wires),\n        ""all_to_all"": wires_all_to_all(wires),\n        ""custom"": custom_pattern,\n    }\n\n    # broadcast the unitary\n    for wires, pars in zip(wire_sequence[pattern], parameters):\n        unitary(*pars, wires=wires, **kwargs)\n'"
pennylane/templates/decorator.py,0,"b'# Copyright 2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis module contains the template decorator.\n""""""\nfrom functools import wraps\n\nfrom pennylane.utils import OperationRecorder\n\n\ndef template(func):\n    """"""Register a quantum template with PennyLane.\n\n    This decorator wraps the given function and makes it return a list of all queued Operations.\n\n    **Example:**\n\n    When defining a :doc:`template </introduction/templates>`, simply decorate\n    the template function with this decorator.\n\n    .. code-block:: python3\n\n        @qml.template\n        def bell_state_preparation(wires):\n            qml.Hadamard(wires=wires[0])\n            qml.CNOT(wires=wires)\n\n    This registers the template with PennyLane, making it compatible with\n    functions that act on templates, such as :func:`pennylane.inv`:\n\n    .. code-block:: python3\n\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.inv(bell_state_preparation(wires=[0, 1]))\n            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n    Args:\n        func (callable): A template function\n\n    Returns:\n        callable: The wrapper function\n    """"""\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        with OperationRecorder() as rec:\n            func(*args, **kwargs)\n\n        return rec.queue\n\n    return wrapper\n'"
pennylane/templates/utils.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nUtility functions provided for the templates. These are useful for standard input checks,\nfor example to make sure that arguments have the right shape, range or type.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom collections.abc import Iterable\n\nimport numpy as np\nfrom pennylane.variable import Variable\n\n\ndef check_no_variable(arg, msg):\n    """"""Checks that ``arg`` does not represent or contain a :func:`~.pennylane.Variable` object.\n\n    This ensures that the user has not passed ``arg`` to the qnode as a\n    primary argument.\n\n    Args:\n        arg: argument to check\n        msg (str): error message to display\n    """"""\n\n    if isinstance(arg, Variable):\n        raise ValueError(msg)\n\n    if isinstance(arg, Iterable):\n        if any([isinstance(a_, Variable) for a_ in arg]):\n            raise ValueError(msg)\n\n\ndef check_wires(wires):\n    """"""Checks that ``wires`` is either a non-negative integer or a list of non-negative integers.\n\n    If ``wires`` is an integer, wrap it by a list.\n\n    Args:\n        wires (int or list[int]): (subset of) wires of a quantum node\n\n    Return:\n        list: list of wire indices\n\n    Raises:\n        ValueError: if the wires argument is invalid\n    """"""\n    if isinstance(wires, int):\n        wires = [wires]\n\n    msg = ""wires must be a positive integer or a "" ""list of positive integers; got {}."".format(\n        wires\n    )\n    if not isinstance(wires, Iterable):\n        raise ValueError(msg)\n    if not all([isinstance(w, int) for w in wires]):\n        raise ValueError(msg)\n    if any([w < 0 for w in wires]):\n        raise ValueError(msg)\n    return wires\n\n\ndef get_shape(inpt):\n    """"""Turn ``inpt`` into an array and return its shape.\n\n    Args:\n        inpt (scalar, list or array): input to a qnode\n\n    Returns:\n        tuple: shape of ``inpt``\n    """"""\n\n    # avoids incorrect assignment of shape\n    if isinstance(inpt, (float, int, complex, Variable)):\n        shape = ()\n\n    else:\n        # turn lists into array to get shape\n        if isinstance(inpt, list):\n            inpt = np.array(inpt)\n\n        try:\n            shape = inpt.shape\n        except AttributeError:\n            raise ValueError(""could not extract shape of object of type {}"".format(type(inpt)))\n\n        # turn result into tuple to avoid type TensorShape\n        shape = tuple(shape)\n\n    return shape\n\n\ndef check_shape(inpt, target_shape, msg, bound=None):\n    """"""Check that the shape of ``inpt`` is equal to ``target_shape``.\n\n    Args:\n        inpt (list): input to a qnode\n        target_shape (tuple[int]): expected shape of inpt\n        msg (str): error message to display if the shapes are different\n        bound (str): If \'max\' or \'min\', the target shape is merely required to be a bound on the input shape\n\n    Raises:\n        ValueError\n    """"""\n\n    shape = get_shape(inpt)\n\n    if bound == ""max"":\n        if shape > target_shape:\n            raise ValueError(msg)\n    elif bound == ""min"":\n        if shape < target_shape:\n            raise ValueError(msg)\n    else:\n        if shape != target_shape:\n            raise ValueError(msg)\n\n    return shape\n\n\ndef check_shapes(inpt_list, target_shapes, msg, bounds=None):\n    """"""Check that the shape of elements in the ``inpt`` list are equal to the shapes of elements\n    in the ``target_shapes`` list.\n\n    Args:\n        inpt_list (list): list of elements of which to check the shape\n        target_shapes (list): list of target shapes, of same length as ``inpt_list``\n        msg (str): error message to display\n        bounds (list): list of \'max\' or \'min\', indicating the bound that the target shape imposes on the input\n            shape\n\n    Raises:\n        ValueError\n    """"""\n\n    if bounds is None:\n        bounds = [None] * len(inpt_list)\n\n    shape_list = [\n        check_shape(l, t, bound=b, msg=msg) for l, t, b in zip(inpt_list, target_shapes, bounds)\n    ]\n    return shape_list\n\n\ndef check_is_in_options(element, options, msg):\n    """"""Check that the value of ``element`` is in ``options``.\n\n    Args:\n        element: arbitraty variable\n        options: possible options for ``element``\n        msg (str): error message to display\n    """"""\n\n    if element not in options:\n        raise ValueError(msg)\n\n\ndef check_type(element, types, msg):\n    """"""Check that the type of ``element`` is one of ``types``.\n\n    Args:\n        element: variable to check\n        types (list): possible types for ``element``\n         msg (str): error message to display\n    """"""\n\n    if not any([isinstance(element, t) for t in types]):\n        raise ValueError(msg)\n\n\ndef check_number_of_layers(list_of_weights):\n    """"""Check that all sequences in ``list_of_weights`` have the same first dimension.\n\n    Args:\n        list_of_weights (list): list of all weights to the template\n\n    Returns:\n        int: number of layers\n\n    Raises:\n        ValueError\n    """"""\n\n    shapes = [get_shape(weight) for weight in list_of_weights]\n\n    if any(len(s) == 0 for s in shapes):\n        raise ValueError(\n            ""the first dimension of the weight parameters must be the number of layers in the ""\n            ""template; got scalar weights.""\n        )\n\n    first_dimensions = [s[0] for s in shapes]\n    different_first_dims = set(first_dimensions)\n    n_different_first_dims = len(different_first_dims)\n\n    if n_different_first_dims > 1:\n        raise ValueError(\n            ""the first dimension of the weight parameters must be the number of layers in the ""\n            ""template; got differing first dimensions: {}."".format(*different_first_dims)\n        )\n\n    return first_dimensions[0]\n'"
pennylane/vqe/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis package contains functionality for running Variational Quantum Eigensolver (VQE)\ncomputations using PennyLane.\n""""""\nfrom .vqe import Hamiltonian, VQECost\n'"
pennylane/vqe/vqe.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nThis submodule contains functionality for running Variational Quantum Eigensolver (VQE)\ncomputations using PennyLane.\n""""""\n# pylint: disable=too-many-arguments, too-few-public-methods\nimport numpy as np\nimport pennylane as qml\nfrom pennylane.operation import Observable, Tensor\n\n\nOBS_MAP = {""PauliX"": ""X"", ""PauliY"": ""Y"", ""PauliZ"": ""Z"", ""Hadamard"": ""H"", ""Identity"": ""I""}\n\n\nclass Hamiltonian:\n    r""""""Lightweight class for representing Hamiltonians for Variational Quantum\n    Eigensolver problems.\n\n    Hamiltonians can be expressed as linear combinations of observables, e.g.,\n    :math:`\\sum_{k=0}^{N-1} c_k O_k`.\n\n    This class keeps track of the terms (coefficients and observables) separately.\n\n    Args:\n        coeffs (Iterable[float]): coefficients of the Hamiltonian expression\n        observables (Iterable[Observable]): observables in the Hamiltonian expression\n\n    .. seealso:: :class:`~.VQECost`, :func:`~.generate_hamiltonian`\n\n    **Example:**\n\n    A Hamiltonian can be created by simply passing the list of coefficients\n    as well as the list of observables:\n\n    >>> coeffs = [0.2, -0.543]\n    >>> obs = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.Hadamard(2)]\n    >>> H = qml.Hamiltonian(coeffs, obs)\n    >>> print(H)\n    (0.2) [X0 Z1] + (-0.543) [Z0 H2]\n\n    Alternatively, the :func:`~.generate_hamiltonian` function from the\n    :doc:`/introduction/chemistry` module can be used to generate a molecular\n    Hamiltonian.\n    """"""\n\n    def __init__(self, coeffs, observables):\n\n        if len(coeffs) != len(observables):\n            raise ValueError(\n                ""Could not create valid Hamiltonian; ""\n                ""number of coefficients and operators does not match.""\n            )\n\n        if any(np.imag(coeffs) != 0):\n            raise ValueError(\n                ""Could not create valid Hamiltonian; "" ""coefficients are not real-valued.""\n            )\n\n        for obs in observables:\n            if not isinstance(obs, Observable):\n                raise ValueError(\n                    ""Could not create circuits. Some or all observables are not valid.""\n                )\n\n        self._coeffs = coeffs\n        self._ops = observables\n\n    @property\n    def coeffs(self):\n        """"""Return the coefficients defining the Hamiltonian.\n\n        Returns:\n            Iterable[float]): coefficients in the Hamiltonian expression\n        """"""\n        return self._coeffs\n\n    @property\n    def ops(self):\n        """"""Return the operators defining the Hamiltonian.\n\n        Returns:\n            Iterable[Observable]): observables in the Hamiltonian expression\n        """"""\n        return self._ops\n\n    @property\n    def terms(self):\n        r""""""The terms of the Hamiltonian expression :math:`\\sum_{k=0}^{N-1}` c_k O_k`\n\n        Returns:\n            (tuple, tuple): tuples of coefficients and operations, each of length N\n        """"""\n        return self.coeffs, self.ops\n\n    def __str__(self):\n        terms = []\n\n        for i, obs in enumerate(self.ops):\n            coeff = ""({}) [{{}}]"".format(self.coeffs[i])\n\n            if isinstance(obs, Tensor):\n                obs_strs = [""{}{}"".format(OBS_MAP[i.name], i.wires[0]) for i in obs.obs]\n                term = "" "".join(obs_strs)\n            elif isinstance(obs, Observable):\n                term = ""{}{}"".format(OBS_MAP[obs.name], obs.wires.tolist()[0])\n\n            terms.append(coeff.format(term))\n\n        return ""\\n+ "".join(terms)\n\n\nclass VQECost:\n    """"""Create a VQE cost function, i.e., a cost function returning the\n    expectation value of a Hamiltonian.\n\n    Args:\n        ansatz (callable): The ansatz for the circuit before the final measurement step.\n            Note that the ansatz **must** have the following signature:\n\n            .. code-block:: python\n\n                ansatz(params, **kwargs)\n\n            where ``params`` are the trainable weights of the variational circuit, and\n            ``kwargs`` are any additional keyword arguments that need to be passed\n            to the template.\n        hamiltonian (~.Hamiltonian): Hamiltonian operator whose expectation value should be measured\n        device (Device, Sequence[Device]): Corresponding device(s) where the resulting\n            cost function should be executed. This can either be a single device, or a list\n            of devices of length matching the number of terms in the Hamiltonian.\n        interface (str, None): Which interface to use.\n            This affects the types of objects that can be passed to/returned to the cost function.\n            Supports all interfaces supported by the :func:`~.qnode` decorator.\n        diff_method (str, None): The method of differentiation to use with the created cost function.\n            Supports all differentiation methods supported by the :func:`~.qnode` decorator.\n\n    Returns:\n        callable: a cost function with signature ``cost_fn(params, **kwargs)`` that evaluates\n        the expectation of the Hamiltonian on the provided device(s)\n\n    .. seealso:: :class:`~.Hamiltonian`, :func:`~.generate_hamiltonian`, :func:`~.map`, :func:`~.dot`\n\n    **Example:**\n\n    First, we create a device and design an ansatz:\n\n    .. code-block:: python\n\n        dev = qml.device(\'default.qubit\', wires=4)\n\n        def ansatz(params, **kwargs):\n            qml.BasisState(np.array([1, 1, 0, 0]), wires=[0, 1, 2, 3])\n            for i in range(4):\n                qml.Rot(*params[i], wires=i)\n            qml.CNOT(wires=[2, 3])\n            qml.CNOT(wires=[2, 0])\n            qml.CNOT(wires=[3, 1])\n\n    Now we can create the Hamiltonian that defines the VQE problem:\n\n    .. code-block:: python3\n\n        coeffs = [0.2, -0.543]\n        obs = [\n            qml.PauliX(0) @ qml.PauliZ(1) @ qml.PauliY(3),\n            qml.PauliZ(0) @ qml.Hadamard(2)\n        ]\n        H = qml.vqe.Hamiltonian(coeffs, obs)\n\n    Alternatively, the :func:`~.generate_hamiltonian` function from the\n    :doc:`/introduction/chemistry` module can be used to generate a molecular\n    Hamiltonian.\n\n    Next, we can define the cost function:\n\n    >>> cost = qml.VQECost(ansatz, hamiltonian, dev, interface=""torch"")\n    >>> params = torch.rand([4, 3])\n    >>> cost(params)\n    tensor(0.0245, dtype=torch.float64)\n\n    The cost function can be minimized using any gradient descent-based\n    :doc:`optimizer </introduction/optimizers>`.\n    """"""\n\n    def __init__(\n        self, ansatz, hamiltonian, device, interface=""autograd"", diff_method=""best"", **kwargs\n    ):\n        coeffs, observables = hamiltonian.terms\n        self.hamiltonian = hamiltonian\n        """"""Hamiltonian: the hamiltonian defining the VQE problem.""""""\n\n        self.qnodes = qml.map(\n            ansatz, observables, device, interface=interface, diff_method=diff_method, **kwargs\n        )\n        """"""QNodeCollection: The QNodes to be evaluated. Each QNode corresponds to the\n        the expectation value of each observable term after applying the circuit ansatz.\n        """"""\n\n        self.cost_fn = qml.dot(coeffs, self.qnodes)\n\n    def __call__(self, *args, **kwargs):\n        return self.cost_fn(*args, **kwargs)\n\n    def metric_tensor(self, args, kwargs=None, diag_approx=False, only_construct=False):\n        """"""Evaluate the value of the metric tensor.\n\n        Args:\n            args (tuple[Any]): positional (differentiable) arguments\n            kwargs (dict[str, Any]): auxiliary arguments\n            diag_approx (bool): iff True, use the diagonal approximation\n            only_construct (bool): Iff True, construct the circuits used for computing\n                the metric tensor but do not execute them, and return None.\n\n        Returns:\n            array[float]: metric tensor\n        """"""\n        # We know that for VQE, all the qnodes share the same ansatz so we select the first\n        return self.qnodes.qnodes[0].metric_tensor(\n            args=args, kwargs=kwargs, diag_approx=diag_approx, only_construct=only_construct\n        )\n'"
qchem/pennylane_qchem/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The PennyLane Qchem package.""""""\nimport pennylane_qchem.qchem\nfrom pennylane_qchem._version import __version__\n'"
qchem/pennylane_qchem/_version.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""\nVersion number (major.minor.patch[-label])\n""""""\n\n__version__ = ""0.10.0-dev""\n'"
qchem/pennylane_qchem/qchem.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""The PennyLane quantum chemistry package. Supports OpenFermion, PySCF,\nand Psi4 for quantum chemistry calculations using PennyLane.""""""\nimport os\nimport subprocess\nfrom shutil import copyfile\n\nimport numpy as np\nfrom openfermion.hamiltonians import MolecularData\nfrom openfermion.ops._qubit_operator import QubitOperator\nfrom openfermion.transforms import bravyi_kitaev, get_fermion_operator, jordan_wigner\nfrom openfermionpsi4 import run_psi4\nfrom openfermionpyscf import run_pyscf\n\nimport pennylane as qml\nfrom pennylane import Hamiltonian\n\n\ndef _exec_exists(prog):\n    r""""""Checks whether the executable program ``prog`` exists in any of the directories\n    set in the ``PATH`` environment variable.\n\n    Args:\n        prog (str): name of the executable program\n\n    Returns:\n        boolean: ``True`` if the executable ``prog`` is found; ``False`` otherwise\n    """"""\n    for dir_in_path in os.environ[""PATH""].split(os.pathsep):\n        path_to_prog = os.path.join(dir_in_path, prog)\n        if os.path.exists(path_to_prog):\n            try:\n                subprocess.call([path_to_prog], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n            except OSError:\n                return False\n            return True\n    return False\n\n\ndef read_structure(filepath, outpath="".""):\n    r""""""Reads the molecular structure from a file and creates a list containing the\n    symbol and Cartesian coordinates of the atomic species.\n\n    The `xyz <https://en.wikipedia.org/wiki/XYZ_file_format>`_ format is supported out of the box.\n    If `Open Babel <https://openbabel.org/>`_ is installed,\n    `any format recognized by Open Babel <https://openbabel.org/wiki/Category:Formats>`_\n    is also supported. Additionally, the new file ``structure.xyz``,\n    containing the geometry of the molecule, is created in a directory with path given by\n    ``outpath``.\n\n\n    Open Babel can be installed using ``apt`` if on Ubuntu:\n\n    .. code-block:: bash\n\n        sudo apt install openbabel\n\n    or using Anaconda:\n\n    .. code-block:: bash\n\n        conda install -c conda-forge openbabel\n\n    See the Open Babel documentation for more details on installation.\n\n    **Example usage:**\n\n    >>> read_structure(\'h2_ref.xyz\')\n    [[\'H\', (0.0, 0.0, -0.35)], [\'H\', (0.0, 0.0, 0.35)]]\n\n    Args:\n        filepath (str): name of the molecular structure file in the working directory\n            or the full path to the file if it is located in a different folder\n        outpath (str): path to the output directory\n\n    Returns:\n        list: for each atomic species, a list containing the symbol and the Cartesian coordinates\n    """"""\n\n    obabel_error_message = (\n        ""Open Babel converter not found:\\n""\n        ""If using Ubuntu or Debian, try: \'sudo apt install openbabel\' \\n""\n        ""If using openSUSE, try: \'sudo zypper install openbabel\' \\n""\n        ""If using CentOS or Fedora, try: \'sudo snap install openbabel\' ""\n        ""Open Babel can also be downloaded from http://openbabel.org/wiki/Main_Page, \\n""\n        ""make sure you add it to the PATH environment variable. \\n""\n        ""If Anaconda is installed, try: \'conda install -c conda-forge openbabel\'""\n    )\n\n    extension = filepath.split(""."")[-1].strip().lower()\n\n    file_in = filepath.strip()\n    file_out = os.path.join(outpath, ""structure.xyz"")\n\n    if extension != ""xyz"":\n        if not _exec_exists(""obabel""):\n            raise TypeError(obabel_error_message)\n        try:\n            subprocess.run(\n                [""obabel"", ""-i"" + extension, file_in, ""-oxyz"", ""-O"", file_out], check=True\n            )\n        except subprocess.CalledProcessError as e:\n            raise RuntimeError(\n                ""Open Babel error. See the following Open Babel ""\n                ""output for details:\\n\\n {}\\n{}"".format(e.stdout, e.stderr)\n            )\n    else:\n        copyfile(file_in, file_out)\n\n    geometry = []\n    with open(file_out) as f:\n        for line in f.readlines()[2:]:\n            species, x, y, z = line.split()\n            geometry.append([species, (float(x), float(y), float(z))])\n    return geometry\n\n\ndef meanfield_data(\n    mol_name, geometry, charge, multiplicity, basis, qc_package=""pyscf"", outpath="".""\n):  # pylint: disable=too-many-arguments\n    r""""""Launches the meanfield (Hartree-Fock) electronic structure calculation.\n\n    Also builds the path to the directory containing the input data file for quantum simulations.\n    The path to the hdf5-formatted file is ``os.path.join(outpath, qc_package, basis)``.\n\n    **Example usage:**\n\n    >>> geometry = read_structure(\'h2_ref.xyz\')\n    >>> meanfield_data(\'h2\', geometry, 0, 1, \'sto-3g\', qc_package=\'pyscf\')\n    ./pyscf/sto-3g\n\n    Args:\n        mol_name (str): name of the molecule\n        geometry (list): list containing the symbol and Cartesian coordinates for each atom\n        charge (int): net charge of the molecule\n        multiplicity (int): spin multiplicity based on the number of unpaired electrons\n            in the Hartree-Fock state\n        basis (str): atomic basis set. Basis set availability per element can be found\n            `here <www.psicode.org/psi4manual/master/basissets_byelement.html#apdx\n            -basiselement>`_\n        qc_package (str): quantum chemistry package used to solve Hartree-Fock equations.\n            Either ``\'pyscf\'`` or ``\'psi4\'`` can be used\n        outpath (str): path to ouput directory\n\n    Returns:\n        str: path to the directory containing the file with the Hartree-Fock electronic structure\n    """"""\n\n    qc_package = qc_package.strip().lower()\n\n    if qc_package not in (""psi4"", ""pyscf""):\n        qc_package_error_message = (\n            ""Integration with quantum chemistry package \'{}\' is not available. \\n Please set""\n            "" \'qc_package\' to \'pyscf\' or \'psi4\'."".format(qc_package)\n        )\n        raise TypeError(qc_package_error_message)\n\n    qcp_dir = os.path.join(outpath.strip(), qc_package)\n    path_to_hf_data = os.path.join(qcp_dir, basis.strip())\n\n    if not os.path.isdir(qcp_dir):\n        os.mkdir(qcp_dir)\n        os.mkdir(path_to_hf_data)\n    elif not os.path.isdir(path_to_hf_data):\n        os.mkdir(path_to_hf_data)\n\n    molecule = MolecularData(\n        geometry,\n        basis,\n        multiplicity,\n        charge,\n        filename=os.path.join(path_to_hf_data, mol_name.strip()),\n    )\n\n    if qc_package == ""psi4"":\n        run_psi4(molecule, run_scf=1, verbose=0, tolerate_error=1)\n\n    if qc_package == ""pyscf"":\n        run_pyscf(molecule, run_scf=1, verbose=0)\n\n    return path_to_hf_data\n\n\ndef active_space(mol_name, hf_data, n_active_electrons=None, n_active_orbitals=None):\n    r""""""Builds the active space by partitioning the set of Hartree-Fock molecular orbitals.\n\n    **Example usage:**\n\n    >>> d_occ_orbitals, active_orbitals = active_space(\'lih\', \'./pyscf/sto-3g\',\n    n_active_electrons=2, n_active_orbitals=2)\n    >>> d_occ_indices  # doubly-occupied molecular orbitals\n    [0]\n    >>> active_indices # active molecular orbitals\n    [1, 2]\n    >>> 2*len(active_indices) # number of qubits required for simulation\n    4\n\n    .. note::\n        The number of active *spin*-orbitals ``2*n_active_orbitals`` determines the number of\n        qubits to perform quantum simulations of the electronic structure of the molecule.\n\n    Args:\n        mol_name (str): name of the molecule\n        hf_data (str): path to the directory containing the file with the Hartree-Fock electronic\n            structure\n        n_active_electrons (int): Optional argument to specify the number of active electrons.\n            If not specified, all electrons are treated as active\n        n_active_orbitals (int): Optional argument to specify the number of active orbitals.\n            If not specified, all orbitals considered active\n\n    Returns:\n        tuple: lists of indices for doubly-occupied and active orbitals\n    """"""\n    # pylint: disable=too-many-branches\n    molecule = MolecularData(filename=os.path.join(hf_data.strip(), mol_name.strip()))\n\n    if n_active_electrons is None:\n        n_docc_orbitals = 0\n        docc_indices = []\n    else:\n        if n_active_electrons <= 0:\n            raise ValueError(\n                ""The number of active electrons ({}) ""\n                ""has to be greater than 0."".format(n_active_electrons)\n            )\n\n        if n_active_electrons > molecule.n_electrons:\n            raise ValueError(\n                ""The number of active electrons ({}) ""\n                ""can not be greater than the total ""\n                ""number of electrons ({})."".format(n_active_electrons, molecule.n_electrons)\n            )\n\n        if n_active_electrons < molecule.multiplicity - 1:\n            raise ValueError(\n                ""For a reference state with multiplicity {}, ""\n                ""the number of active electrons ({}) should be ""\n                ""greater than or equal to {}."".format(\n                    molecule.multiplicity, n_active_electrons, molecule.multiplicity - 1\n                )\n            )\n\n        if molecule.multiplicity % 2 == 1:\n            if n_active_electrons % 2 != 0:\n                raise ValueError(\n                    ""For a reference state with multiplicity {}, ""\n                    ""the number of active electrons ({}) should be even."".format(\n                        molecule.multiplicity, n_active_electrons\n                    )\n                )\n        else:\n            if n_active_electrons % 2 != 1:\n                raise ValueError(\n                    ""For a reference state with multiplicity {}, ""\n                    ""the number of active electrons ({}) should be odd."".format(\n                        molecule.multiplicity, n_active_electrons\n                    )\n                )\n\n        n_docc_orbitals = (molecule.n_electrons - n_active_electrons) // 2\n        docc_indices = list(range(n_docc_orbitals))\n\n    if n_active_orbitals is None:\n        active_indices = list(range(n_docc_orbitals, molecule.n_orbitals))\n    else:\n        if n_active_orbitals <= 0:\n            raise ValueError(\n                ""The number of active orbitals ({}) ""\n                ""has to be greater than 0."".format(n_active_orbitals)\n            )\n\n        if n_docc_orbitals + n_active_orbitals > molecule.n_orbitals:\n            raise ValueError(\n                ""The number of doubly occupied orbitals ({}) + ""\n                ""the number of active orbitals ({}) can not be ""\n                ""greater than the number of molecular orbitals ({})"".format(\n                    n_docc_orbitals, n_active_orbitals, molecule.n_orbitals\n                )\n            )\n\n        homo = (molecule.n_electrons + molecule.multiplicity - 1) / 2\n        if n_docc_orbitals + n_active_orbitals <= homo:\n            raise ValueError(\n                ""For n_active_orbitals={}, there are no virtual orbitals ""\n                ""in the active space."".format(n_active_orbitals)\n            )\n\n        active_indices = list(range(n_docc_orbitals, n_docc_orbitals + n_active_orbitals))\n\n    return docc_indices, active_indices\n\n\ndef decompose_hamiltonian(\n    mol_name, hf_data, mapping=""jordan_wigner"", docc_mo_indices=None, active_mo_indices=None\n):\n    r""""""Decomposes the electronic Hamiltonian into a linear combination of Pauli operators using\n    OpenFermion tools.\n\n    **Example usage:**\n\n    >>> decompose_hamiltonian(\'h2\', \'./pyscf/sto-3g/\', mapping=\'bravyi_kitaev\')\n    (-0.04207897696293986+0j) [] + (0.04475014401986122+0j) [X0 Z1 X2] +\n    (0.04475014401986122+0j) [X0 Z1 X2 Z3] +(0.04475014401986122+0j) [Y0 Z1 Y2] +\n    (0.04475014401986122+0j) [Y0 Z1 Y2 Z3] +(0.17771287459806262+0j) [Z0] +\n    (0.17771287459806265+0j) [Z0 Z1] +(0.1676831945625423+0j) [Z0 Z1 Z2] +\n    (0.1676831945625423+0j) [Z0 Z1 Z2 Z3] +(0.12293305054268105+0j) [Z0 Z2] +\n    (0.12293305054268105+0j) [Z0 Z2 Z3] +(0.1705973832722409+0j) [Z1] +\n    (-0.2427428049645989+0j) [Z1 Z2 Z3] +(0.1762764080276107+0j) [Z1 Z3] +\n    (-0.2427428049645989+0j) [Z2]\n\n    Args:\n        mol_name (str): name of the molecule\n        hf_data (str): path to the directory containing the file with the Hartree-Fock\n            electronic structure\n        mapping (str): optional argument to specify the fermion-to-qubit mapping\n            Input values can be ``\'jordan_wigner\'`` or ``\'bravyi_kitaev\'``\n        docc_mo_indices (list): indices of doubly-occupied molecular orbitals, i.e.,\n            the orbitals that are not correlated in the many-body wave function\n        active_mo_indices (list): indices of active molecular orbitals, i.e., the orbitals used to\n            build the correlated many-body wave function\n\n    Returns:\n        transformed_operator: instance of the QubitOperator class representing the electronic\n        Hamiltonian\n    """"""\n\n    # loading HF data from a hdf5 file\n    molecule = MolecularData(filename=os.path.join(hf_data.strip(), mol_name.strip()))\n\n    # getting the terms entering the second-quantized Hamiltonian\n    terms_molecular_hamiltonian = molecule.get_molecular_hamiltonian(\n        occupied_indices=docc_mo_indices, active_indices=active_mo_indices\n    )\n\n    # generating the fermionic Hamiltonian\n    fermionic_hamiltonian = get_fermion_operator(terms_molecular_hamiltonian)\n\n    mapping = mapping.strip().lower()\n\n    if mapping not in (""jordan_wigner"", ""bravyi_kitaev""):\n        raise TypeError(\n            ""The \'{}\' transformation is not available. \\n ""\n            ""Please set \'mapping\' to \'jordan_wigner\' or \'bravyi_kitaev\'."".format(mapping)\n        )\n\n    # fermionic-to-qubit transformation of the Hamiltonian\n    if mapping == ""bravyi_kitaev"":\n        return bravyi_kitaev(fermionic_hamiltonian)\n\n    return jordan_wigner(fermionic_hamiltonian)\n\n\ndef _qubit_operator_to_terms(qubit_operator):\n    r""""""Converts OpenFermion ``QubitOperator`` to a 2-tuple of coefficients and\n    PennyLane Pauli observables.\n\n    Args:\n        qubit_operator (QubitOperator): fermionic-to-qubit transformed operator in terms of\n            Pauli matrices\n\n    Returns:\n        tuple[array[float], Iterable[pennylane.operation.Observable]]: coefficients and their\n        corresponding PennyLane observables in the Pauli basis\n    """"""\n    if not qubit_operator.terms:  # added since can\'t unpack empty zip to (coeffs, ops) below\n        return np.array([0.0]), [qml.operation.Tensor(qml.Identity(0))]\n\n    xyz2pauli = {""X"": qml.PauliX, ""Y"": qml.PauliY, ""Z"": qml.PauliZ}\n\n    coeffs, ops = zip(\n        *[\n            (\n                coef,\n                qml.operation.Tensor(*[xyz2pauli[q[1]](wires=q[0]) for q in term])\n                if term\n                else qml.operation.Tensor(qml.Identity(0))\n                # example term: ((0,\'X\'), (2,\'Z\'), (3,\'Y\'))\n            )\n            for term, coef in qubit_operator.terms.items()\n        ]\n    )\n\n    return np.real(np.array(coeffs)), list(ops)\n\n\ndef _terms_to_qubit_operator(coeffs, ops):\n    r""""""Converts a 2-tuple of complex coefficients and PennyLane operations to\n    OpenFermion ``QubitOperator``.\n\n    This function is the inverse of ``_qubit_operator_to_terms``.\n\n    Args:\n        coeffs (array[complex]):\n            coefficients for each observable, same length as ops\n        ops (Iterable[pennylane.operation.Observable]): List of PennyLane observables as\n            Tensor products of Pauli observables\n\n    Returns:\n        QubitOperator: an instance of OpenFermion\'s ``QubitOperator``.\n    """"""\n    q_op = QubitOperator()\n    for coeff, op in zip(coeffs, ops):\n\n        # wire ids\n        wires = op.wires.tolist()\n\n        # Pauli axis names, note s[-1] expects only \'Pauli{X,Y,Z}\'\n        pauli_names = [s[-1] for s in op.name]\n\n        extra_obsvbs = set(op.name) - {""PauliX"", ""PauliY"", ""PauliZ"", ""Identity""}\n        if extra_obsvbs != set():\n            raise ValueError(\n                ""Expected only PennyLane observables PauliX/Y/Z or Identity, ""\n                + ""but also got {}."".format(extra_obsvbs)\n            )\n\n        if op.name == [""Identity""] and wires == [0]:\n            term_str = """"\n        else:\n            term_str = "" "".join(\n                [""{}{}"".format(pauli, wire) for pauli, wire in zip(pauli_names, wires)]\n            )\n\n        # This is how one makes QubitOperator in OpenFermion\n        q_op += coeff * QubitOperator(term_str)\n\n    return q_op\n\n\ndef _qubit_operators_equivalent(openfermion_qubit_operator, pennylane_qubit_operator):\n    r""""""Checks equivalence between OpenFermion :class:`~.QubitOperator` and Pennylane  VQE\n    ``Hamiltonian`` (Tensor product of Pauli matrices).\n\n    Equality is based on OpenFermion :class:`~.QubitOperator`\'s equality.\n\n    Args:\n        openfermion_qubit_operator (QubitOperator): OpenFermion qubit operator represented as\n            a Pauli summation\n        pennylane_qubit_operator (pennylane.Hamiltonian): PennyLane\n            Hamiltonian object\n\n    Returns:\n        (bool): True if equivalent\n    """"""\n    coeffs, ops = pennylane_qubit_operator.terms\n    return openfermion_qubit_operator == _terms_to_qubit_operator(coeffs, ops)\n\n\ndef convert_hamiltonian(qubit_hamiltonian):\n    r""""""Converts OpenFermion :class:`~.QubitOperator` Hamiltonian to Pennylane VQE Hamiltonian\n\n    **Example usage**\n\n    >>> h_of = decompose_hamiltonian(\'h2\', \'./pyscf/sto-3g/\')\n    >>> h_pl = convert_hamiltonian(h_of)\n    >>> h_pl.coeffs\n    [-0.04207898+0.j  0.17771287+0.j  0.17771287+0.j -0.2427428 +0.j -0.2427428 +0.j  0.17059738+0.j\n    0.04475014+0.j  0.04475014+0.j  0.04475014+0.j  0.04475014+0.j  0.12293305+0.j  0.16768319+0.j\n    0.16768319+0.j  0.12293305+0.j  0.17627641+0.j]\n\n    Args:\n        qubit_hamiltonian (QubitOperator): Hamiltonian represented as an OpenFermion `QubitOperator`\n\n    Returns:\n        (pennylane.Hamiltonian): Pennylane VQE Hamiltonian\n    """"""\n\n    # The `_qubit_operator_to_terms` function is separated out from this function\n    # in case there could be other observables, apart from the electronic Hamiltonian,\n    # to be converted in the future.\n\n    return Hamiltonian(*_qubit_operator_to_terms(qubit_hamiltonian))\n\n\ndef generate_hamiltonian(\n    mol_name,\n    mol_geo_file,\n    mol_charge,\n    multiplicity,\n    basis_set,\n    qc_package=""pyscf"",\n    n_active_electrons=None,\n    n_active_orbitals=None,\n    mapping=""jordan_wigner"",\n    outpath=""."",\n):  # pylint:disable=too-many-arguments\n    r""""""Generates the qubit Hamiltonian based on geometry and mean field electronic structure.\n\n    An active space can be defined, otherwise the Hamiltonian is expanded in the full basis of\n    Hartree-Fock (HF) molecular orbitals.\n\n    **Example usage:**\n\n    >>> H, n_qubits = generate_hamiltonian(\'h2\', \'h2.xyz\', 0, 1, \'sto-3g\')\n    >>> print(n_qubits)\n    4\n    >>> print(H)\n    (-0.04207897647782188) [I0]\n    + (0.17771287465139934) [Z0]\n    + (0.1777128746513993) [Z1]\n    + (-0.24274280513140484) [Z2]\n    + (-0.24274280513140484) [Z3]\n    + (0.17059738328801055) [Z0 Z1]\n    + (0.04475014401535161) [Y0 X1 X2 Y3]\n    + (-0.04475014401535161) [Y0 Y1 X2 X3]\n    + (-0.04475014401535161) [X0 X1 Y2 Y3]\n    + (0.04475014401535161) [X0 Y1 Y2 X3]\n    + (0.12293305056183801) [Z0 Z2]\n    + (0.1676831945771896) [Z0 Z3]\n    + (0.1676831945771896) [Z1 Z2]\n    + (0.12293305056183801) [Z1 Z3]\n    + (0.176276408043196) [Z2 Z3]\n\n    Args:\n        mol_name (str): name of the molecule\n        mol_geo_file (str): name of the file containing the geometry of the molecule\n        mol_charge (int): net charge of the molecule\n        multiplicity (int): multiplicity of the Hartree-Fock reference state\n        basis_set (str): atomic Gaussian-type orbitals basis set. Basis set availability per\n                element can be found `here\n                <www.psicode.org/psi4manual/master/basissets_byelement.html>`_\n        qc_package (str): quantum chemistry package (pyscf or psi4) used to solve the\n                mean field electronic structure problem\n        n_active_electrons (int): number of active electrons. If not specified, all electrons\n                are considered to be active\n        n_active_orbitals (int): number of active orbitals. If not specified, all orbitals\n                are considered to be active\n        mapping (str): the transformation (``\'jordan_wigner\'`` or ``\'bravyi_kitaev\'``) used to\n                map the second-quantized electronic Hamiltonian to the qubit Hamiltonian\n        outpath (str): path to the directory containing output files\n    Returns:\n        tuple[pennylane.Hamiltonian, int]: the fermionic-to-qubit transformed\n        Hamiltonian and the number of qubits\n\n     """"""\n\n    geometry = read_structure(mol_geo_file, outpath)\n\n    hf_data = meanfield_data(\n        mol_name, geometry, mol_charge, multiplicity, basis_set, qc_package, outpath\n    )\n\n    docc_indices, active_indices = active_space(\n        mol_name, hf_data, n_active_electrons, n_active_orbitals\n    )\n\n    h_of, nr_qubits = (\n        decompose_hamiltonian(mol_name, hf_data, mapping, docc_indices, active_indices),\n        2 * len(active_indices),\n    )\n\n    return convert_hamiltonian(h_of), nr_qubits\n\n\ndef sd_excitations(n_electrons, n_orbitals, delta_sz=0):\n    r""""""Generates single and double excitations from a Hartree-Fock (HF) reference state.\n\n    The singly- and doubly-excited configurations are generated by acting with the operators\n    :math:`\\hat T_1` and :math:`\\hat T_2` on the HF state:\n\n    .. math: \n        && \\vert \\Phi_\\mathrm{S} \\rangle = \\hat{T}_1 \\vert \\mathrm{HF} \\rangle = \\sum_{r \\in\n        \\mathrm{occ} \\\\ p \\in \\mathrm{virt}} \\hat{c}_p^\\dagger \\hat{c}_r \\vert \\mathrm{HF} \n        \\rangle \\\\ \n        && \\vert \\Phi_\\mathrm{D} \\rangle = \\hat{T}_2 \\vert \\mathrm{HF} \\rangle = \\sum_{r>s \\in \n        \\mathrm{occ} \\\\ p>q \\in \\mathrm{virt}} \\hat{c}_p^\\dagger \\hat{c}_q^\\dagger \n        \\hat{c}_r \\hat{c}_s \\vert \\mathrm{HF} \\rangle\n\n\twhere the indices :math:`r, s` and :math:`p, q` run over the occupied (occ) and unoccupied, \n\treferred to as virtual (virt), molecular orbitals and :math:`\\hat c` and \n\t:math:`\\hat c^\\dagger` are the electron annihilation and creation operators, respectively. \n\n    **Example**\n\n    >>> ph, pphh = sd_configs(2, 4, 0)\n    >>> print(ph)\n    [[0, 2], [1, 3]]\n    >>> print(pphh)\n    [[0, 1, 2, 3]]\n\n    Args: \n        n_electrons (int): number of active electrons \n        n_orbitals (int): number of active orbitals\n        delta_sz (int): optional argument to specify the spin-projection selection rule. \n            For single excitations ``sz[p] - sz[r] = delta_sz``.\n            For double excitations ``sz[p] + sz[p] - sz[r] - sz[s] = delta_sz``.\n            ``sz`` is the single-particle state spin quantum number and ``delta_sz``, in the \n            case of singles and doubles, can take the values :math:`0`, :math:`\\pm 1` \n            and :math:`\\pm 2`.\n\n    Returns:\n        tuple(list, list): lists with the indices of the molecular orbitals\n        involved in the single and double excitations\n    """"""\n\n    if not n_electrons > 0:\n        raise ValueError(\n            ""The number of active electrons has to be greater than 0 \\n""\n            ""Got n_electrons = {}"".format(n_electrons)\n        )\n\n    if n_orbitals <= n_electrons:\n        raise ValueError(\n            ""The number of active orbitals ({}) ""\n            ""has to be greater than the number of active electrons ({})."".format(\n                n_orbitals, n_electrons\n            )\n        )\n\n    if delta_sz not in (0, 1, -1, 2, -2):\n        raise ValueError(\n            ""Expected values for \'delta_sz\' are 0, +/- 1 and +/- 2 but got ({})."".format(delta_sz)\n        )\n\n    # define the single-particle state spin quantum number \'sz\'\n    sz = np.array([0.5 if (i % 2 == 0) else -0.5 for i in range(n_orbitals)])\n\n    # nested list with the indices \'p, r\' for each 1particle-1hole (ph) configuration\n    ph = [\n        [r, p]\n        for r in range(n_electrons)\n        for p in range(n_electrons, n_orbitals)\n        if sz[p] - sz[r] == delta_sz\n    ]\n\n    # nested list with the indices \'s, r, q, p\' for each 2particle-2hole (pphh) configuration\n    pphh = [\n        [s, r, q, p]\n        for s in range(n_electrons - 1)\n        for r in range(s + 1, n_electrons)\n        for q in range(n_electrons, n_orbitals - 1)\n        for p in range(q + 1, n_orbitals)\n        if (sz[p] + sz[q] - sz[r] - sz[s]) == delta_sz\n    ]\n\n    return ph, pphh\n\n\ndef hf_state(n_electrons, m_spin_orbitals):\n    r""""""Generates the occupation-number vector representing the Hartree-Fock (HF)\n    state of :math:`N` electrons in a basis of :math:`M` spin orbitals.\n\n    The many-particle wave function in the HF approximation is a `Slater determinant\n    <https://en.wikipedia.org/wiki/Slater_determinant>`_. In Fock space, a Slater determinant\n    is represented by the occupation-number vector:\n\n    .. math:\n        \\vert {\\bf n} \\rangle = \\vert n_1, n_2, \\dots, n_M \\rangle,\n        n_i = \\left\\lbrace \\begin{array}{ll} 1 & i \\leq N \\\\ 0 & i > N \\end{array} \\right.\n\n    **Example**\n\n    >>> init_state = hf_state(2, 6)\n    >>> print(init_state)\n    [1 1 0 0 0 0]\n\n    Args:\n        n_electrons (int): number of active electrons\n        m_spin_orbitals (int): number of active **spin-orbitals**\n\n    Returns:\n        array: NumPy array containing the vector :math:`\\vert {\\bf n} \\rangle`\n    """"""\n\n    if n_electrons <= 0:\n        raise ValueError(\n            ""The number of active electrons has to be larger than zero; got \'n_electrons\' = {}"".format(\n                n_electrons\n            )\n        )\n\n    if n_electrons > m_spin_orbitals:\n        raise ValueError(\n            ""The number of active orbitals cannot be smaller than the number of active electrons;""\n            "" got \'m_spin_orbitals\'={} < \'n_electrons\'={}"".format(m_spin_orbitals, n_electrons)\n        )\n\n    hf_state_on = np.where(np.arange(m_spin_orbitals) < n_electrons, 1, 0)\n\n    return np.array(hf_state_on)\n\n\n__all__ = [\n    ""read_structure"",\n    ""meanfield_data"",\n    ""active_space"",\n    ""decompose_hamiltonian"",\n    ""_qubit_operator_to_terms"",\n    ""_terms_to_qubit_operator"",\n    ""_qubit_operators_equivalent"",\n    ""convert_hamiltonian"",\n    ""generate_hamiltonian"",\n    ""sd_excitations"",\n    ""hf_state"",\n]\n'"
qchem/tests/__init__.py,0,b'\n'
qchem/tests/conftest.py,0,"b'import shutil\nimport subprocess\nimport pytest\n\n\ndef cmd_exists(cmd):\n    """"""Returns True if a binary exists on\n    the system path""""""\n    return shutil.which(cmd) is not None\n\n\n@pytest.fixture(scope=""session"")\ndef tol():\n    """"""Numerical tolerance for equality tests.""""""\n    return {""rtol"": 0, ""atol"": 1e-8}\n\n\n@pytest.fixture(scope=""module"")\ndef psi4_support():\n    """"""Boolean fixture for Psi4 support""""""\n    if not cmd_exists(""psi4""):\n        return False\n\n    res = subprocess.call([""psi4"", ""--version""], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    if res == 1:\n        return False\n\n    try:\n        import psi4\n\n        support = True\n    except ImportError as e:\n        support = False\n\n    return support\n\n\n@pytest.fixture(scope=""module"")\ndef babel_support():\n    """"""Boolean fixture for Babel support""""""\n    if cmd_exists(""obabel""):\n        return True\n\n    return False\n\n\n@pytest.fixture()\ndef requires_babel(babel_support):\n    if not babel_support:\n        pytest.skip(""Skipped, no Babel support"")\n'"
qchem/tests/test_active_space.py,0,"b'import os\n\nimport pytest\n\nfrom pennylane import qchem\n\nref_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), ""test_ref_files"")\n\n\n@pytest.mark.parametrize(\n    (""mol_name"", ""n_act_electrons"", ""n_act_orbitals"", ""docc_indices_ref"", ""act_indices_ref""),\n    [\n        (""lih"", None, None, [], list(range(6))),\n        (""lih"", 4, None, [], list(range(6))),\n        (""lih"", 2, None, [0], list(range(1, 6))),\n        (""lih"", None, 4, [], list(range(4))),\n        (""lih"", 2, 3, [0], list(range(1, 4))),\n        (""lih_anion"", 3, 4, [0], list(range(1, 5))),\n        (""lih_anion"", 1, 4, [0, 1], list(range(2, 6))),\n    ],\n)\ndef test_active_spaces(\n    mol_name, n_act_electrons, n_act_orbitals, docc_indices_ref, act_indices_ref\n):\n\n    r""""""Test the correctness of the generated active spaces""""""\n\n    docc_indices, active_indices = qchem.active_space(\n        mol_name, ref_dir, n_act_electrons, n_act_orbitals\n    )\n\n    assert docc_indices == docc_indices_ref\n    assert active_indices == act_indices_ref\n\n\n@pytest.mark.parametrize(\n    (""mol_name"", ""n_act_electrons"", ""n_act_orbitals"", ""message_match""),\n    [\n        (""lih"", 6, 5, ""greater than the total number of electrons""),\n        (""lih"", 1, 5, ""should be even""),\n        (""lih"", -1, 5, ""has to be greater than 0.""),\n        (""lih"", 2, 6, ""can not be greater than the number "" ""of molecular orbitals""),\n        (""lih"", 2, 1, ""there are no virtual orbitals""),\n        (""lih_anion"", 2, 5, ""should be odd""),\n        (""lih_anion"", 3, -2, ""has to be greater than 0.""),\n        (""lih_anion"", 3, 6, ""can not be greater than the number "" ""of molecular orbitals""),\n        (""lih_anion"", 3, 2, ""there are no virtual orbitals""),\n        (""lih_anion_2"", 1, 2, ""greater than or equal to""),\n    ],\n)\ndef test_inconsistent_active_spaces(mol_name, n_act_electrons, n_act_orbitals, message_match):\n\n    r""""""Test that an error is raised if an inconsistent active space is generated""""""\n\n    with pytest.raises(ValueError, match=message_match):\n        qchem.active_space(mol_name, ref_dir, n_act_electrons, n_act_orbitals)\n'"
qchem/tests/test_convert_hamiltonian.py,0,"b'import os\n\nimport numpy as np\nimport pennylane as qml\nimport pytest\nfrom openfermion.ops._qubit_operator import QubitOperator\n\nfrom pennylane import qchem\n\n\n@pytest.mark.parametrize(\n    (""mol_name"", ""terms_ref""),\n    [\n        (""empty"", None),\n        (\n            ""lih [jordan_WIGNER]"",\n            {\n                (): (-7.50915719389077 + 0j),\n                ((0, ""Z""),): (0.155924093421341 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")): (0.01401593800246412 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")): (0.01401593800246412 + 0j),\n                ((1, ""Z""),): (0.1559240934213409 + 0j),\n                ((1, ""Y""), (2, ""Z""), (3, ""Y"")): (0.014015938002464118 + 0j),\n                ((1, ""X""), (2, ""Z""), (3, ""X"")): (0.014015938002464118 + 0j),\n                ((2, ""Z""),): (-0.01503982573626933 + 0j),\n                ((3, ""Z""),): (-0.015039825736269333 + 0j),\n                ((0, ""Z""), (1, ""Z"")): (0.12182774218528421 + 0j),\n                ((0, ""Y""), (2, ""Y"")): (0.012144893851836855 + 0j),\n                ((0, ""X""), (2, ""X"")): (0.012144893851836855 + 0j),\n                ((0, ""Z""), (1, ""Y""), (2, ""Z""), (3, ""Y"")): (0.012144893851836855 + 0j),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""X"")): (0.012144893851836855 + 0j),\n                ((0, ""Y""), (1, ""X""), (2, ""X""), (3, ""Y"")): (0.00326599398593671 + 0j),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X"")): (-0.00326599398593671 + 0j),\n                ((0, ""X""), (1, ""X""), (2, ""Y""), (3, ""Y"")): (-0.00326599398593671 + 0j),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X"")): (0.00326599398593671 + 0j),\n                ((0, ""Z""), (2, ""Z"")): (0.052636515240899254 + 0j),\n                ((0, ""Z""), (3, ""Z"")): (0.05590250922683597 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")): (-0.0018710418360866883 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")): (-0.0018710418360866883 + 0j),\n                ((1, ""Z""), (2, ""Z"")): (0.05590250922683597 + 0j),\n                ((1, ""Y""), (3, ""Y"")): (-0.0018710418360866883 + 0j),\n                ((1, ""X""), (3, ""X"")): (-0.0018710418360866883 + 0j),\n                ((1, ""Z""), (3, ""Z"")): (0.052636515240899254 + 0j),\n                ((2, ""Z""), (3, ""Z"")): (0.08447056917218312 + 0j),\n            },\n        ),\n        (\n            ""lih [BRAVYI_kitaev]"",\n            {\n                (): (-7.50915719389077 + 0j),\n                ((0, ""Z""),): (0.155924093421341 + 0j),\n                ((0, ""X""), (1, ""Y""), (2, ""Y"")): (0.01401593800246412 + 0j),\n                ((0, ""Y""), (1, ""Y""), (2, ""X"")): (-0.01401593800246412 + 0j),\n                ((0, ""Z""), (1, ""Z"")): (0.1559240934213409 + 0j),\n                ((0, ""Z""), (1, ""X""), (3, ""Z"")): (-0.014015938002464118 + 0j),\n                ((1, ""X""), (2, ""Z"")): (0.014015938002464118 + 0j),\n                ((2, ""Z""),): (-0.01503982573626933 + 0j),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z"")): (-0.015039825736269333 + 0j),\n                ((1, ""Z""),): (0.12182774218528421 + 0j),\n                ((0, ""Y""), (1, ""X""), (2, ""Y"")): (0.012144893851836855 + 0j),\n                ((0, ""X""), (1, ""X""), (2, ""X"")): (0.012144893851836855 + 0j),\n                ((1, ""X""), (3, ""Z"")): (-0.012144893851836855 + 0j),\n                ((0, ""Z""), (1, ""X""), (2, ""Z"")): (0.012144893851836855 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")): (0.00326599398593671 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")): (0.00326599398593671 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")): (0.00326599398593671 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")): (0.00326599398593671 + 0j),\n                ((0, ""Z""), (2, ""Z"")): (0.052636515240899254 + 0j),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z""), (3, ""Z"")): (0.05590250922683597 + 0j),\n                ((0, ""X""), (1, ""X""), (2, ""X""), (3, ""Z"")): (0.0018710418360866883 + 0j),\n                ((0, ""Y""), (1, ""X""), (2, ""Y""), (3, ""Z"")): (0.0018710418360866883 + 0j),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z"")): (0.05590250922683597 + 0j),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""Z"")): (0.0018710418360866883 + 0j),\n                ((1, ""X""),): (-0.0018710418360866883 + 0j),\n                ((0, ""Z""), (2, ""Z""), (3, ""Z"")): (0.052636515240899254 + 0j),\n                ((1, ""Z""), (3, ""Z"")): (0.08447056917218312 + 0j),\n            },\n        ),\n        (\n            ""h2_psycf [jordan_WIGNER]"",\n            {\n                (): (-0.04207897647782188 + 0j),\n                ((0, ""Z""),): (0.17771287465139934 + 0j),\n                ((1, ""Z""),): (0.1777128746513993 + 0j),\n                ((2, ""Z""),): (-0.24274280513140484 + 0j),\n                ((3, ""Z""),): (-0.24274280513140484 + 0j),\n                ((0, ""Z""), (1, ""Z"")): (0.17059738328801055 + 0j),\n                ((0, ""Y""), (1, ""X""), (2, ""X""), (3, ""Y"")): (0.04475014401535161 + 0j),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X"")): (-0.04475014401535161 + 0j),\n                ((0, ""X""), (1, ""X""), (2, ""Y""), (3, ""Y"")): (-0.04475014401535161 + 0j),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X"")): (0.04475014401535161 + 0j),\n                ((0, ""Z""), (2, ""Z"")): (0.12293305056183801 + 0j),\n                ((0, ""Z""), (3, ""Z"")): (0.1676831945771896 + 0j),\n                ((1, ""Z""), (2, ""Z"")): (0.1676831945771896 + 0j),\n                ((1, ""Z""), (3, ""Z"")): (0.12293305056183801 + 0j),\n                ((2, ""Z""), (3, ""Z"")): (0.176276408043196 + 0j),\n            },\n        ),\n        (\n            ""h2_psycf [BRAVYI_kitaev]"",\n            {\n                (): (-0.04207897647782188 + 0j),\n                ((0, ""Z""),): (0.17771287465139934 + 0j),\n                ((0, ""Z""), (1, ""Z"")): (0.1777128746513993 + 0j),\n                ((2, ""Z""),): (-0.24274280513140484 + 0j),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z"")): (-0.24274280513140484 + 0j),\n                ((1, ""Z""),): (0.17059738328801055 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")): (0.04475014401535161 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")): (0.04475014401535161 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")): (0.04475014401535161 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")): (0.04475014401535161 + 0j),\n                ((0, ""Z""), (2, ""Z"")): (0.12293305056183801 + 0j),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z""), (3, ""Z"")): (0.1676831945771896 + 0j),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z"")): (0.1676831945771896 + 0j),\n                ((0, ""Z""), (2, ""Z""), (3, ""Z"")): (0.12293305056183801 + 0j),\n                ((1, ""Z""), (3, ""Z"")): (0.176276408043196 + 0j),\n            },\n        ),\n        (\n            ""h2o_psi4 [jordan_WIGNER]"",\n            {\n                (): (-73.3320453921657 + 0j),\n                ((0, ""Z""),): (0.5152794751801038 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Y"")): (0.07778754984633934 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""X"")): (0.07778754984633934 + 0j),\n                ((1, ""Z""),): (0.515279475180104 + 0j),\n                ((1, ""Y""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""Y"")): (0.07778754984633934 + 0j),\n                ((1, ""X""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""X"")): (0.07778754984633934 + 0j),\n                ((2, ""Z""),): (0.4812925883672432 + 0j),\n                ((3, ""Z""),): (0.48129258836724326 + 0j),\n                ((4, ""Z""),): (0.09030949181042286 + 0j),\n                ((5, ""Z""),): (0.09030949181042283 + 0j),\n                ((0, ""Z""), (1, ""Z"")): (0.1956590715408106 + 0j),\n                ((0, ""Y""), (2, ""Z""), (3, ""Z""), (4, ""Y"")): (0.030346614024840804 + 0j),\n                ((0, ""X""), (2, ""Z""), (3, ""Z""), (4, ""X"")): (0.030346614024840804 + 0j),\n                ((0, ""Y""), (1, ""X""), (2, ""X""), (3, ""Y"")): (0.013977596555816168 + 0j),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X"")): (-0.013977596555816168 + 0j),\n                ((0, ""X""), (1, ""X""), (2, ""Y""), (3, ""Y"")): (-0.013977596555816168 + 0j),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X"")): (0.013977596555816168 + 0j),\n                ((0, ""Z""), (1, ""Y""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""Y"")): (\n                    0.030346614024840804 + 0j\n                ),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""X"")): (\n                    0.030346614024840804 + 0j\n                ),\n                ((0, ""Y""), (1, ""X""), (4, ""X""), (5, ""Y"")): (0.01718525123891425 + 0j),\n                ((0, ""Y""), (1, ""Y""), (4, ""X""), (5, ""X"")): (-0.01718525123891425 + 0j),\n                ((0, ""X""), (1, ""X""), (4, ""Y""), (5, ""Y"")): (-0.01718525123891425 + 0j),\n                ((0, ""X""), (1, ""Y""), (4, ""Y""), (5, ""X"")): (0.01718525123891425 + 0j),\n                ((0, ""Z""), (2, ""Z"")): (0.16824174504299702 + 0j),\n                ((0, ""Y""), (1, ""Z""), (3, ""Z""), (4, ""Y"")): (0.029512711807110188 + 0j),\n                ((0, ""X""), (1, ""Z""), (3, ""Z""), (4, ""X"")): (0.029512711807110188 + 0j),\n                ((0, ""Z""), (3, ""Z"")): (0.18221934159881317 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Z""), (4, ""Y"")): (0.029077593893863385 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""Z""), (4, ""X"")): (0.029077593893863385 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Y""), (4, ""Z""), (5, ""Y"")): (\n                    0.00043511791324680473 + 0j\n                ),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""X""), (4, ""Z""), (5, ""X"")): (\n                    0.00043511791324680473 + 0j\n                ),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Y""), (4, ""Z""), (5, ""Y"")): (\n                    0.00043511791324680473 + 0j\n                ),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""X""), (4, ""Z""), (5, ""X"")): (\n                    0.00043511791324680473 + 0j\n                ),\n                ((0, ""Z""), (4, ""Z"")): (0.12008313883007578 + 0j),\n                ((0, ""Z""), (5, ""Z"")): (0.13726839006899005 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Y""), (5, ""Z"")): (\n                    0.011149373109704066 + 0j\n                ),\n                ((0, ""X""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""X""), (5, ""Z"")): (\n                    0.011149373109704066 + 0j\n                ),\n                ((1, ""Z""), (2, ""Z"")): (0.18221934159881317 + 0j),\n                ((1, ""Y""), (3, ""Z""), (4, ""Z""), (5, ""Y"")): (0.029077593893863385 + 0j),\n                ((1, ""X""), (3, ""Z""), (4, ""Z""), (5, ""X"")): (0.029077593893863385 + 0j),\n                ((1, ""Y""), (2, ""X""), (3, ""X""), (4, ""Y"")): (0.00043511791324680484 + 0j),\n                ((1, ""Y""), (2, ""Y""), (3, ""X""), (4, ""X"")): (-0.00043511791324680484 + 0j),\n                ((1, ""X""), (2, ""X""), (3, ""Y""), (4, ""Y"")): (-0.00043511791324680484 + 0j),\n                ((1, ""X""), (2, ""Y""), (3, ""Y""), (4, ""X"")): (0.00043511791324680484 + 0j),\n                ((1, ""Z""), (3, ""Z"")): (0.16824174504299702 + 0j),\n                ((1, ""Y""), (2, ""Z""), (4, ""Z""), (5, ""Y"")): (0.029512711807110188 + 0j),\n                ((1, ""X""), (2, ""Z""), (4, ""Z""), (5, ""X"")): (0.029512711807110188 + 0j),\n                ((1, ""Z""), (4, ""Z"")): (0.13726839006899005 + 0j),\n                ((1, ""Y""), (2, ""Z""), (3, ""Z""), (5, ""Y"")): (0.011149373109704066 + 0j),\n                ((1, ""X""), (2, ""Z""), (3, ""Z""), (5, ""X"")): (0.011149373109704066 + 0j),\n                ((1, ""Z""), (5, ""Z"")): (0.12008313883007578 + 0j),\n                ((2, ""Z""), (3, ""Z"")): (0.22003977334376118 + 0j),\n                ((2, ""Y""), (3, ""X""), (4, ""X""), (5, ""Y"")): (0.009647475282106617 + 0j),\n                ((2, ""Y""), (3, ""Y""), (4, ""X""), (5, ""X"")): (-0.009647475282106617 + 0j),\n                ((2, ""X""), (3, ""X""), (4, ""Y""), (5, ""Y"")): (-0.009647475282106617 + 0j),\n                ((2, ""X""), (3, ""Y""), (4, ""Y""), (5, ""X"")): (0.009647475282106617 + 0j),\n                ((2, ""Z""), (4, ""Z"")): (0.13758959215600186 + 0j),\n                ((2, ""Z""), (5, ""Z"")): (0.1472370674381085 + 0j),\n                ((3, ""Z""), (4, ""Z"")): (0.1472370674381085 + 0j),\n                ((3, ""Z""), (5, ""Z"")): (0.13758959215600186 + 0j),\n                ((4, ""Z""), (5, ""Z"")): (0.1492827559305538 + 0j),\n            },\n        ),\n        (\n            ""h2o_psi4 [BRAVYI_kitaev]"",\n            {\n                (): (-73.3320453921657 + 0j),\n                ((0, ""Z""),): (0.5152794751801038 + 0j),\n                ((0, ""X""), (1, ""X""), (3, ""Y""), (4, ""Y""), (5, ""X"")): (0.07778754984633934 + 0j),\n                ((0, ""Y""), (1, ""X""), (3, ""Y""), (4, ""X""), (5, ""X"")): (-0.07778754984633934 + 0j),\n                ((0, ""Z""), (1, ""Z"")): (0.515279475180104 + 0j),\n                ((0, ""Z""), (1, ""X""), (3, ""Y""), (5, ""Y"")): (0.07778754984633934 + 0j),\n                ((1, ""Y""), (3, ""Y""), (4, ""Z""), (5, ""X"")): (-0.07778754984633934 + 0j),\n                ((2, ""Z""),): (0.4812925883672432 + 0j),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z"")): (0.48129258836724326 + 0j),\n                ((4, ""Z""),): (0.09030949181042286 + 0j),\n                ((4, ""Z""), (5, ""Z"")): (0.09030949181042283 + 0j),\n                ((1, ""Z""),): (0.1956590715408106 + 0j),\n                ((0, ""Y""), (1, ""Y""), (3, ""Y""), (4, ""Y""), (5, ""X"")): (-0.030346614024840804 + 0j),\n                ((0, ""X""), (1, ""Y""), (3, ""Y""), (4, ""X""), (5, ""X"")): (-0.030346614024840804 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")): (0.013977596555816168 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")): (0.013977596555816168 + 0j),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")): (0.013977596555816168 + 0j),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")): (0.013977596555816168 + 0j),\n                ((1, ""X""), (3, ""Y""), (5, ""Y"")): (0.030346614024840804 + 0j),\n                ((0, ""Z""), (1, ""Y""), (3, ""Y""), (4, ""Z""), (5, ""X"")): (-0.030346614024840804 + 0j),\n                ((0, ""Y""), (4, ""Y""), (5, ""Z"")): (0.01718525123891425 + 0j),\n                ((0, ""X""), (1, ""Z""), (4, ""X"")): (0.01718525123891425 + 0j),\n                ((0, ""X""), (4, ""X""), (5, ""Z"")): (0.01718525123891425 + 0j),\n                ((0, ""Y""), (1, ""Z""), (4, ""Y"")): (0.01718525123891425 + 0j),\n                ((0, ""Z""), (2, ""Z"")): (0.16824174504299702 + 0j),\n                ((0, ""X""), (1, ""X""), (2, ""Z""), (3, ""Y""), (4, ""Y""), (5, ""X"")): (\n                    0.029512711807110188 + 0j\n                ),\n                ((0, ""Y""), (1, ""X""), (2, ""Z""), (3, ""Y""), (4, ""X""), (5, ""X"")): (\n                    -0.029512711807110188 + 0j\n                ),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z""), (3, ""Z"")): (0.18221934159881317 + 0j),\n                ((0, ""X""), (1, ""Y""), (2, ""Z""), (3, ""X""), (4, ""Y""), (5, ""X"")): (\n                    0.029077593893863385 + 0j\n                ),\n                ((0, ""Y""), (1, ""Y""), (2, ""Z""), (3, ""X""), (4, ""X""), (5, ""X"")): (\n                    -0.029077593893863385 + 0j\n                ),\n                ((0, ""X""), (1, ""X""), (2, ""X""), (3, ""Y""), (5, ""Y"")): (-0.00043511791324680473 + 0j),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X""), (4, ""Z""), (5, ""X"")): (\n                    0.00043511791324680473 + 0j\n                ),\n                ((0, ""Y""), (1, ""X""), (2, ""Y""), (3, ""Y""), (5, ""Y"")): (-0.00043511791324680473 + 0j),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X""), (4, ""Z""), (5, ""X"")): (\n                    -0.00043511791324680473 + 0j\n                ),\n                ((0, ""Z""), (4, ""Z"")): (0.12008313883007578 + 0j),\n                ((0, ""Z""), (4, ""Z""), (5, ""Z"")): (0.13726839006899005 + 0j),\n                ((0, ""X""), (1, ""X""), (3, ""Y""), (4, ""X""), (5, ""Y"")): (0.011149373109704066 + 0j),\n                ((0, ""Y""), (1, ""X""), (3, ""Y""), (4, ""Y""), (5, ""Y"")): (0.011149373109704066 + 0j),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z"")): (0.18221934159881317 + 0j),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""Y""), (5, ""Y"")): (0.029077593893863385 + 0j),\n                ((1, ""Y""), (2, ""Z""), (3, ""Y""), (4, ""Z""), (5, ""X"")): (-0.029077593893863385 + 0j),\n                ((0, ""Z""), (1, ""Y""), (2, ""X""), (3, ""X""), (4, ""Y""), (5, ""X"")): (\n                    0.00043511791324680484 + 0j\n                ),\n                ((0, ""Z""), (1, ""Y""), (2, ""Y""), (3, ""X""), (4, ""X""), (5, ""X"")): (\n                    -0.00043511791324680484 + 0j\n                ),\n                ((1, ""Y""), (2, ""Y""), (3, ""Y""), (4, ""Y""), (5, ""X"")): (0.00043511791324680484 + 0j),\n                ((1, ""Y""), (2, ""X""), (3, ""Y""), (4, ""X""), (5, ""X"")): (0.00043511791324680484 + 0j),\n                ((0, ""Z""), (2, ""Z""), (3, ""Z"")): (0.16824174504299702 + 0j),\n                ((0, ""Z""), (1, ""Y""), (2, ""Z""), (3, ""X""), (5, ""Y"")): (0.029512711807110188 + 0j),\n                ((1, ""X""), (2, ""Z""), (3, ""X""), (4, ""Z""), (5, ""X"")): (0.029512711807110188 + 0j),\n                ((0, ""Z""), (1, ""Z""), (4, ""Z"")): (0.13726839006899005 + 0j),\n                ((0, ""Z""), (1, ""X""), (3, ""Y""), (4, ""Z""), (5, ""Y"")): (0.011149373109704066 + 0j),\n                ((1, ""Y""), (3, ""Y""), (5, ""X"")): (-0.011149373109704066 + 0j),\n                ((0, ""Z""), (1, ""Z""), (4, ""Z""), (5, ""Z"")): (0.12008313883007578 + 0j),\n                ((1, ""Z""), (3, ""Z"")): (0.22003977334376118 + 0j),\n                ((2, ""Y""), (4, ""Y""), (5, ""Z"")): (0.009647475282106617 + 0j),\n                ((1, ""Z""), (2, ""X""), (3, ""Z""), (4, ""X"")): (0.009647475282106617 + 0j),\n                ((2, ""X""), (4, ""X""), (5, ""Z"")): (0.009647475282106617 + 0j),\n                ((1, ""Z""), (2, ""Y""), (3, ""Z""), (4, ""Y"")): (0.009647475282106617 + 0j),\n                ((2, ""Z""), (4, ""Z"")): (0.13758959215600186 + 0j),\n                ((2, ""Z""), (4, ""Z""), (5, ""Z"")): (0.1472370674381085 + 0j),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Z"")): (0.1472370674381085 + 0j),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""Z"")): (0.13758959215600186 + 0j),\n                ((5, ""Z""),): (0.1492827559305538 + 0j),\n            },\n        ),\n    ],\n)\ndef test_hamiltonian_conversion(mol_name, terms_ref, monkeypatch):\n\n    r""""""Test the correctness of the QubitOperator Hamiltonian conversion from\n    OpenFermion to Pennylane.\n\n    The parametrized inputs are `.terms` attribute of the output `QubitOperator`s based on\n    the same set of test molecules as `test_gen_hamiltonian_pauli_basis`.\n\n    The equality checking is implemented in the `qchem` module itself as it could be\n    something useful to the users as well.\n    """"""\n    qOp = QubitOperator()\n    if terms_ref is not None:\n        monkeypatch.setattr(qOp, ""terms"", terms_ref)\n\n    vqe_hamiltonian = qchem.convert_hamiltonian(qOp)\n\n    assert qchem._qubit_operators_equivalent(qOp, vqe_hamiltonian)\n\n\ndef test_not_xyz_terms_to_qubit_operator():\n    r""""""Test if the conversion complains about non Pauli matrix observables""""""\n    with pytest.raises(\n        ValueError,\n        match=""Expected only PennyLane observables PauliX/Y/Z or Identity, but also got {""\n        ""\'QuadOperator\'}."",\n    ):\n        qchem._terms_to_qubit_operator(\n            np.array([0.1 + 0.0j, 0.0]),\n            [\n                qml.operation.Tensor(qml.PauliX(0)),\n                qml.operation.Tensor(qml.PauliZ(0), qml.QuadOperator(0.1, wires=1)),\n            ],\n        )\n\n\n@pytest.mark.parametrize(\n    (""mol_name"", ""terms_ref"", ""expected_cost""),\n    [\n        (""empty"", None, 0),\n        (\n            ""h2_psycf [jordan_WIGNER]"",\n            {\n                (): (-0.04207897647782188 + 0j),\n                ((0, ""Z""),): (0.17771287465139934 + 0j),\n                ((1, ""Z""),): (0.1777128746513993 + 0j),\n                ((2, ""Z""),): (-0.24274280513140484 + 0j),\n                ((3, ""Z""),): (-0.24274280513140484 + 0j),\n                ((0, ""Z""), (1, ""Z"")): (0.17059738328801055 + 0j),\n                ((0, ""Y""), (1, ""X""), (2, ""X""), (3, ""Y"")): (0.04475014401535161 + 0j),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X"")): (-0.04475014401535161 + 0j),\n                ((0, ""X""), (1, ""X""), (2, ""Y""), (3, ""Y"")): (-0.04475014401535161 + 0j),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X"")): (0.04475014401535161 + 0j),\n                ((0, ""Z""), (2, ""Z"")): (0.12293305056183801 + 0j),\n                ((0, ""Z""), (3, ""Z"")): (0.1676831945771896 + 0j),\n                ((1, ""Z""), (2, ""Z"")): (0.1676831945771896 + 0j),\n                ((1, ""Z""), (3, ""Z"")): (0.12293305056183801 + 0j),\n                ((2, ""Z""), (3, ""Z"")): (0.176276408043196 + 0j),\n            },\n            (0.7384971473437577 + 0j),\n        ),\n    ],\n)\ndef test_integration_hamiltonian_to_vqe_cost(monkeypatch, mol_name, terms_ref, expected_cost, tol):\n    r""""""Test if `convert_hamiltonian()` in qchem integrates with `VQECost()` in pennylane""""""\n\n    qOp = QubitOperator()\n    if terms_ref is not None:\n        monkeypatch.setattr(qOp, ""terms"", terms_ref)\n    vqe_hamiltonian = qchem.convert_hamiltonian(qOp)\n\n    # maybe make num_qubits a @property of the Hamiltonian class?\n    num_qubits = max(1, len(set([w for op in vqe_hamiltonian.ops for w in op.wires])))\n\n    dev = qml.device(""default.qubit"", wires=num_qubits)\n    print(vqe_hamiltonian.terms)\n\n    # can replace the ansatz with more suitable ones later.\n    def dummy_ansatz(phis, wires):\n        for phi, w in zip(phis, wires):\n            qml.RX(phi, wires=w)\n\n    dummy_cost = qml.VQECost(dummy_ansatz, vqe_hamiltonian, dev)\n    params = [0.1 * i for i in range(num_qubits)]\n    res = dummy_cost(params)\n\n    assert np.allclose(res, expected_cost, **tol)\n\n\n@pytest.mark.parametrize(\n    (""hf_filename"", ""docc_mo"", ""act_mo"", ""type_of_transformation"", ""expected_cost""),\n    [\n        (""lih"", [0], [1, 2], ""jordan_WIGNER"", -7.255500051039507),\n        (""lih"", [0], [1, 2], ""BRAVYI_kitaev"", -7.246409364088741),\n        (""h2_pyscf"", list(range(0)), list(range(2)), ""jordan_WIGNER"", 0.19364907363263958),\n        (""h2_pyscf"", list(range(0)), list(range(2)), ""BRAVYI_kitaev"", 0.16518000728327564),\n        (""gdb3"", list(range(11)), [11, 12], ""jordan_WIGNER"", -130.59816885313248),\n        (""gdb3"", list(range(11)), [11, 12], ""BRAVYI_kitaev"", -130.6156540164148),\n    ],\n)\ndef test_integration_mol_file_to_vqe_cost(\n    hf_filename, docc_mo, act_mo, type_of_transformation, expected_cost, tol\n):\n    r""""""Test if the output of `decompose_hamiltonian()` works with `convert_hamiltonian()`\n    to generate `VQECost()`""""""\n    ref_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), ""test_ref_files"")\n\n    transformed_hamiltonian = qchem.decompose_hamiltonian(\n        hf_filename,\n        ref_dir,\n        mapping=type_of_transformation,\n        docc_mo_indices=docc_mo,\n        active_mo_indices=act_mo,\n    )\n\n    vqe_hamiltonian = qchem.convert_hamiltonian(transformed_hamiltonian)\n    assert len(vqe_hamiltonian.ops) > 1  # just to check if this runs\n\n    num_qubits = max(1, len(set([w for op in vqe_hamiltonian.ops for w in op.wires])))\n    assert num_qubits == 2 * len(act_mo)\n\n    dev = qml.device(""default.qubit"", wires=num_qubits)\n\n    # can replace the ansatz with more suitable ones later.\n    def dummy_ansatz(phis, wires):\n        for phi, w in zip(phis, wires):\n            qml.RX(phi, wires=w)\n\n    phis = np.load(os.path.join(ref_dir, ""dummy_ansatz_parameters.npy""))\n\n    dummy_cost = qml.VQECost(dummy_ansatz, vqe_hamiltonian, dev)\n    res = dummy_cost(phis)\n\n    assert np.abs(res - expected_cost) < tol[""atol""]\n'"
qchem/tests/test_decompose_hamiltonian.py,0,"b'import os\n\nimport numpy as np\n\nimport pytest\n\nfrom pennylane import qchem\n\nref_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), ""test_ref_files"")\n\n\n@pytest.mark.parametrize(\n    (\n        ""hf_filename"",\n        ""docc_mo"",\n        ""act_mo"",\n        ""type_of_transformation"",\n        ""coeffs_ref"",\n        ""pauli_strings_ref"",\n    ),\n    [\n        (\n            ""lih"",\n            [0],\n            [1, 2],\n            ""jordan_WIGNER"",\n            np.array(\n                [\n                    -7.50915719e00 + 0.0j,\n                    1.55924093e-01 + 0.0j,\n                    1.40159380e-02 + 0.0j,\n                    1.40159380e-02 + 0.0j,\n                    1.55924093e-01 + 0.0j,\n                    1.40159380e-02 + 0.0j,\n                    1.40159380e-02 + 0.0j,\n                    -1.50398257e-02 + 0.0j,\n                    -1.50398257e-02 + 0.0j,\n                    1.21827742e-01 + 0.0j,\n                    1.21448939e-02 + 0.0j,\n                    1.21448939e-02 + 0.0j,\n                    1.21448939e-02 + 0.0j,\n                    1.21448939e-02 + 0.0j,\n                    3.26599399e-03 + 0.0j,\n                    -3.26599399e-03 + 0.0j,\n                    -3.26599399e-03 + 0.0j,\n                    3.26599399e-03 + 0.0j,\n                    5.26365152e-02 + 0.0j,\n                    5.59025092e-02 + 0.0j,\n                    -1.87104184e-03 + 0.0j,\n                    -1.87104184e-03 + 0.0j,\n                    5.59025092e-02 + 0.0j,\n                    -1.87104184e-03 + 0.0j,\n                    -1.87104184e-03 + 0.0j,\n                    5.26365152e-02 + 0.0j,\n                    8.44705692e-02 + 0.0j,\n                ]\n            ),\n            [\n                (),\n                ((0, ""Z""),),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")),\n                ((1, ""Z""),),\n                ((1, ""Y""), (2, ""Z""), (3, ""Y"")),\n                ((1, ""X""), (2, ""Z""), (3, ""X"")),\n                ((2, ""Z""),),\n                ((3, ""Z""),),\n                ((0, ""Z""), (1, ""Z"")),\n                ((0, ""Y""), (2, ""Y"")),\n                ((0, ""X""), (2, ""X"")),\n                ((0, ""Z""), (1, ""Y""), (2, ""Z""), (3, ""Y"")),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""X"")),\n                ((0, ""Y""), (1, ""X""), (2, ""X""), (3, ""Y"")),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X"")),\n                ((0, ""X""), (1, ""X""), (2, ""Y""), (3, ""Y"")),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X"")),\n                ((0, ""Z""), (2, ""Z"")),\n                ((0, ""Z""), (3, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")),\n                ((1, ""Z""), (2, ""Z"")),\n                ((1, ""Y""), (3, ""Y"")),\n                ((1, ""X""), (3, ""X"")),\n                ((1, ""Z""), (3, ""Z"")),\n                ((2, ""Z""), (3, ""Z"")),\n            ],\n        ),\n        (\n            ""lih"",\n            [0],\n            [1, 2],\n            ""BRAVYI_kitaev"",\n            np.array(\n                [\n                    -7.50915719e00 + 0.0j,\n                    1.55924093e-01 + 0.0j,\n                    1.40159380e-02 + 0.0j,\n                    -1.40159380e-02 + 0.0j,\n                    1.55924093e-01 + 0.0j,\n                    -1.40159380e-02 + 0.0j,\n                    1.40159380e-02 + 0.0j,\n                    -1.50398257e-02 + 0.0j,\n                    -1.50398257e-02 + 0.0j,\n                    1.21827742e-01 + 0.0j,\n                    1.21448939e-02 + 0.0j,\n                    1.21448939e-02 + 0.0j,\n                    -1.21448939e-02 + 0.0j,\n                    1.21448939e-02 + 0.0j,\n                    3.26599399e-03 + 0.0j,\n                    3.26599399e-03 + 0.0j,\n                    3.26599399e-03 + 0.0j,\n                    3.26599399e-03 + 0.0j,\n                    5.26365152e-02 + 0.0j,\n                    5.59025092e-02 + 0.0j,\n                    1.87104184e-03 + 0.0j,\n                    1.87104184e-03 + 0.0j,\n                    5.59025092e-02 + 0.0j,\n                    1.87104184e-03 + 0.0j,\n                    -1.87104184e-03 + 0.0j,\n                    5.26365152e-02 + 0.0j,\n                    8.44705692e-02 + 0.0j,\n                ]\n            ),\n            [\n                (),\n                ((0, ""Z""),),\n                ((0, ""X""), (1, ""Y""), (2, ""Y"")),\n                ((0, ""Y""), (1, ""Y""), (2, ""X"")),\n                ((0, ""Z""), (1, ""Z"")),\n                ((0, ""Z""), (1, ""X""), (3, ""Z"")),\n                ((1, ""X""), (2, ""Z"")),\n                ((2, ""Z""),),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((1, ""Z""),),\n                ((0, ""Y""), (1, ""X""), (2, ""Y"")),\n                ((0, ""X""), (1, ""X""), (2, ""X"")),\n                ((1, ""X""), (3, ""Z"")),\n                ((0, ""Z""), (1, ""X""), (2, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")),\n                ((0, ""Z""), (2, ""Z"")),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((0, ""X""), (1, ""X""), (2, ""X""), (3, ""Z"")),\n                ((0, ""Y""), (1, ""X""), (2, ""Y""), (3, ""Z"")),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z"")),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""Z"")),\n                ((1, ""X""),),\n                ((0, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((1, ""Z""), (3, ""Z"")),\n            ],\n        ),\n        (\n            ""h2_pyscf"",\n            list(range(0)),\n            list(range(2)),\n            ""jordan_WIGNER"",\n            np.array(\n                [\n                    -0.04207898 + 0.0j,\n                    0.17771287 + 0.0j,\n                    0.17771287 + 0.0j,\n                    -0.24274281 + 0.0j,\n                    -0.24274281 + 0.0j,\n                    0.17059738 + 0.0j,\n                    0.04475014 + 0.0j,\n                    -0.04475014 + 0.0j,\n                    -0.04475014 + 0.0j,\n                    0.04475014 + 0.0j,\n                    0.12293305 + 0.0j,\n                    0.16768319 + 0.0j,\n                    0.16768319 + 0.0j,\n                    0.12293305 + 0.0j,\n                    0.17627641 + 0.0j,\n                ]\n            ),\n            [\n                (),\n                ((0, ""Z""),),\n                ((1, ""Z""),),\n                ((2, ""Z""),),\n                ((3, ""Z""),),\n                ((0, ""Z""), (1, ""Z"")),\n                ((0, ""Y""), (1, ""X""), (2, ""X""), (3, ""Y"")),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X"")),\n                ((0, ""X""), (1, ""X""), (2, ""Y""), (3, ""Y"")),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X"")),\n                ((0, ""Z""), (2, ""Z"")),\n                ((0, ""Z""), (3, ""Z"")),\n                ((1, ""Z""), (2, ""Z"")),\n                ((1, ""Z""), (3, ""Z"")),\n                ((2, ""Z""), (3, ""Z"")),\n            ],\n        ),\n        (\n            ""h2_pyscf"",\n            list(range(0)),\n            list(range(2)),\n            ""BRAVYI_kitaev"",\n            np.array(\n                [\n                    -0.04207898 + 0.0j,\n                    0.17771287 + 0.0j,\n                    0.17771287 + 0.0j,\n                    -0.24274281 + 0.0j,\n                    -0.24274281 + 0.0j,\n                    0.17059738 + 0.0j,\n                    0.04475014 + 0.0j,\n                    0.04475014 + 0.0j,\n                    0.04475014 + 0.0j,\n                    0.04475014 + 0.0j,\n                    0.12293305 + 0.0j,\n                    0.16768319 + 0.0j,\n                    0.16768319 + 0.0j,\n                    0.12293305 + 0.0j,\n                    0.17627641 + 0.0j,\n                ]\n            ),\n            [\n                (),\n                ((0, ""Z""),),\n                ((0, ""Z""), (1, ""Z"")),\n                ((2, ""Z""),),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((1, ""Z""),),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")),\n                ((0, ""Z""), (2, ""Z"")),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z"")),\n                ((0, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((1, ""Z""), (3, ""Z"")),\n            ],\n        ),\n        (\n            ""h2o_psi4"",\n            list(range(3)),\n            list(range(3, 6)),\n            ""jordan_WIGNER"",\n            np.array(\n                [\n                    -7.33320454e01 + 0.0j,\n                    5.15279475e-01 + 0.0j,\n                    7.77875498e-02 + 0.0j,\n                    7.77875498e-02 + 0.0j,\n                    5.15279475e-01 + 0.0j,\n                    7.77875498e-02 + 0.0j,\n                    7.77875498e-02 + 0.0j,\n                    4.81292588e-01 + 0.0j,\n                    4.81292588e-01 + 0.0j,\n                    9.03094918e-02 + 0.0j,\n                    9.03094918e-02 + 0.0j,\n                    1.95659072e-01 + 0.0j,\n                    3.03466140e-02 + 0.0j,\n                    3.03466140e-02 + 0.0j,\n                    1.39775966e-02 + 0.0j,\n                    -1.39775966e-02 + 0.0j,\n                    -1.39775966e-02 + 0.0j,\n                    1.39775966e-02 + 0.0j,\n                    3.03466140e-02 + 0.0j,\n                    3.03466140e-02 + 0.0j,\n                    1.71852512e-02 + 0.0j,\n                    -1.71852512e-02 + 0.0j,\n                    -1.71852512e-02 + 0.0j,\n                    1.71852512e-02 + 0.0j,\n                    1.68241745e-01 + 0.0j,\n                    2.95127118e-02 + 0.0j,\n                    2.95127118e-02 + 0.0j,\n                    1.82219342e-01 + 0.0j,\n                    2.90775939e-02 + 0.0j,\n                    2.90775939e-02 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    1.20083139e-01 + 0.0j,\n                    1.37268390e-01 + 0.0j,\n                    1.11493731e-02 + 0.0j,\n                    1.11493731e-02 + 0.0j,\n                    1.82219342e-01 + 0.0j,\n                    2.90775939e-02 + 0.0j,\n                    2.90775939e-02 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    -4.35117913e-04 + 0.0j,\n                    -4.35117913e-04 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    1.68241745e-01 + 0.0j,\n                    2.95127118e-02 + 0.0j,\n                    2.95127118e-02 + 0.0j,\n                    1.37268390e-01 + 0.0j,\n                    1.11493731e-02 + 0.0j,\n                    1.11493731e-02 + 0.0j,\n                    1.20083139e-01 + 0.0j,\n                    2.20039773e-01 + 0.0j,\n                    9.64747528e-03 + 0.0j,\n                    -9.64747528e-03 + 0.0j,\n                    -9.64747528e-03 + 0.0j,\n                    9.64747528e-03 + 0.0j,\n                    1.37589592e-01 + 0.0j,\n                    1.47237067e-01 + 0.0j,\n                    1.47237067e-01 + 0.0j,\n                    1.37589592e-01 + 0.0j,\n                    1.49282756e-01 + 0.0j,\n                ]\n            ),\n            [\n                (),\n                ((0, ""Z""),),\n                ((0, ""Y""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Y"")),\n                ((0, ""X""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""X"")),\n                ((1, ""Z""),),\n                ((1, ""Y""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""Y"")),\n                ((1, ""X""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""X"")),\n                ((2, ""Z""),),\n                ((3, ""Z""),),\n                ((4, ""Z""),),\n                ((5, ""Z""),),\n                ((0, ""Z""), (1, ""Z"")),\n                ((0, ""Y""), (2, ""Z""), (3, ""Z""), (4, ""Y"")),\n                ((0, ""X""), (2, ""Z""), (3, ""Z""), (4, ""X"")),\n                ((0, ""Y""), (1, ""X""), (2, ""X""), (3, ""Y"")),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X"")),\n                ((0, ""X""), (1, ""X""), (2, ""Y""), (3, ""Y"")),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X"")),\n                ((0, ""Z""), (1, ""Y""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""Y"")),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""X"")),\n                ((0, ""Y""), (1, ""X""), (4, ""X""), (5, ""Y"")),\n                ((0, ""Y""), (1, ""Y""), (4, ""X""), (5, ""X"")),\n                ((0, ""X""), (1, ""X""), (4, ""Y""), (5, ""Y"")),\n                ((0, ""X""), (1, ""Y""), (4, ""Y""), (5, ""X"")),\n                ((0, ""Z""), (2, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (3, ""Z""), (4, ""Y"")),\n                ((0, ""X""), (1, ""Z""), (3, ""Z""), (4, ""X"")),\n                ((0, ""Z""), (3, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Z""), (4, ""Y"")),\n                ((0, ""X""), (1, ""Z""), (2, ""Z""), (4, ""X"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Y""), (4, ""Z""), (5, ""Y"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""X""), (4, ""Z""), (5, ""X"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Y""), (4, ""Z""), (5, ""Y"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""X""), (4, ""Z""), (5, ""X"")),\n                ((0, ""Z""), (4, ""Z"")),\n                ((0, ""Z""), (5, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Y""), (5, ""Z"")),\n                ((0, ""X""), (1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""X""), (5, ""Z"")),\n                ((1, ""Z""), (2, ""Z"")),\n                ((1, ""Y""), (3, ""Z""), (4, ""Z""), (5, ""Y"")),\n                ((1, ""X""), (3, ""Z""), (4, ""Z""), (5, ""X"")),\n                ((1, ""Y""), (2, ""X""), (3, ""X""), (4, ""Y"")),\n                ((1, ""Y""), (2, ""Y""), (3, ""X""), (4, ""X"")),\n                ((1, ""X""), (2, ""X""), (3, ""Y""), (4, ""Y"")),\n                ((1, ""X""), (2, ""Y""), (3, ""Y""), (4, ""X"")),\n                ((1, ""Z""), (3, ""Z"")),\n                ((1, ""Y""), (2, ""Z""), (4, ""Z""), (5, ""Y"")),\n                ((1, ""X""), (2, ""Z""), (4, ""Z""), (5, ""X"")),\n                ((1, ""Z""), (4, ""Z"")),\n                ((1, ""Y""), (2, ""Z""), (3, ""Z""), (5, ""Y"")),\n                ((1, ""X""), (2, ""Z""), (3, ""Z""), (5, ""X"")),\n                ((1, ""Z""), (5, ""Z"")),\n                ((2, ""Z""), (3, ""Z"")),\n                ((2, ""Y""), (3, ""X""), (4, ""X""), (5, ""Y"")),\n                ((2, ""Y""), (3, ""Y""), (4, ""X""), (5, ""X"")),\n                ((2, ""X""), (3, ""X""), (4, ""Y""), (5, ""Y"")),\n                ((2, ""X""), (3, ""Y""), (4, ""Y""), (5, ""X"")),\n                ((2, ""Z""), (4, ""Z"")),\n                ((2, ""Z""), (5, ""Z"")),\n                ((3, ""Z""), (4, ""Z"")),\n                ((3, ""Z""), (5, ""Z"")),\n                ((4, ""Z""), (5, ""Z"")),\n            ],\n        ),\n        (\n            ""h2o_psi4"",\n            list(range(3)),\n            list(range(3, 6)),\n            ""BRAVYI_kitaev"",\n            np.array(\n                [\n                    -7.33320454e01 + 0.0j,\n                    5.15279475e-01 + 0.0j,\n                    7.77875498e-02 + 0.0j,\n                    -7.77875498e-02 + 0.0j,\n                    5.15279475e-01 + 0.0j,\n                    7.77875498e-02 + 0.0j,\n                    -7.77875498e-02 + 0.0j,\n                    4.81292588e-01 + 0.0j,\n                    4.81292588e-01 + 0.0j,\n                    9.03094918e-02 + 0.0j,\n                    9.03094918e-02 + 0.0j,\n                    1.95659072e-01 + 0.0j,\n                    -3.03466140e-02 + 0.0j,\n                    -3.03466140e-02 + 0.0j,\n                    1.39775966e-02 + 0.0j,\n                    1.39775966e-02 + 0.0j,\n                    1.39775966e-02 + 0.0j,\n                    1.39775966e-02 + 0.0j,\n                    3.03466140e-02 + 0.0j,\n                    -3.03466140e-02 + 0.0j,\n                    1.71852512e-02 + 0.0j,\n                    1.71852512e-02 + 0.0j,\n                    1.71852512e-02 + 0.0j,\n                    1.71852512e-02 + 0.0j,\n                    1.68241745e-01 + 0.0j,\n                    2.95127118e-02 + 0.0j,\n                    -2.95127118e-02 + 0.0j,\n                    1.82219342e-01 + 0.0j,\n                    2.90775939e-02 + 0.0j,\n                    -2.90775939e-02 + 0.0j,\n                    -4.35117913e-04 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    -4.35117913e-04 + 0.0j,\n                    -4.35117913e-04 + 0.0j,\n                    1.20083139e-01 + 0.0j,\n                    1.37268390e-01 + 0.0j,\n                    1.11493731e-02 + 0.0j,\n                    1.11493731e-02 + 0.0j,\n                    1.82219342e-01 + 0.0j,\n                    2.90775939e-02 + 0.0j,\n                    -2.90775939e-02 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    -4.35117913e-04 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    4.35117913e-04 + 0.0j,\n                    1.68241745e-01 + 0.0j,\n                    2.95127118e-02 + 0.0j,\n                    2.95127118e-02 + 0.0j,\n                    1.37268390e-01 + 0.0j,\n                    1.11493731e-02 + 0.0j,\n                    -1.11493731e-02 + 0.0j,\n                    1.20083139e-01 + 0.0j,\n                    2.20039773e-01 + 0.0j,\n                    9.64747528e-03 + 0.0j,\n                    9.64747528e-03 + 0.0j,\n                    9.64747528e-03 + 0.0j,\n                    9.64747528e-03 + 0.0j,\n                    1.37589592e-01 + 0.0j,\n                    1.47237067e-01 + 0.0j,\n                    1.47237067e-01 + 0.0j,\n                    1.37589592e-01 + 0.0j,\n                    1.49282756e-01 + 0.0j,\n                ]\n            ),\n            [\n                (),\n                ((0, ""Z""),),\n                ((0, ""X""), (1, ""X""), (3, ""Y""), (4, ""Y""), (5, ""X"")),\n                ((0, ""Y""), (1, ""X""), (3, ""Y""), (4, ""X""), (5, ""X"")),\n                ((0, ""Z""), (1, ""Z"")),\n                ((0, ""Z""), (1, ""X""), (3, ""Y""), (5, ""Y"")),\n                ((1, ""Y""), (3, ""Y""), (4, ""Z""), (5, ""X"")),\n                ((2, ""Z""),),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((4, ""Z""),),\n                ((4, ""Z""), (5, ""Z"")),\n                ((1, ""Z""),),\n                ((0, ""Y""), (1, ""Y""), (3, ""Y""), (4, ""Y""), (5, ""X"")),\n                ((0, ""X""), (1, ""Y""), (3, ""Y""), (4, ""X""), (5, ""X"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y""), (3, ""Z"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X"")),\n                ((0, ""X""), (1, ""Z""), (2, ""X""), (3, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (2, ""Y"")),\n                ((1, ""X""), (3, ""Y""), (5, ""Y"")),\n                ((0, ""Z""), (1, ""Y""), (3, ""Y""), (4, ""Z""), (5, ""X"")),\n                ((0, ""Y""), (4, ""Y""), (5, ""Z"")),\n                ((0, ""X""), (1, ""Z""), (4, ""X"")),\n                ((0, ""X""), (4, ""X""), (5, ""Z"")),\n                ((0, ""Y""), (1, ""Z""), (4, ""Y"")),\n                ((0, ""Z""), (2, ""Z"")),\n                ((0, ""X""), (1, ""X""), (2, ""Z""), (3, ""Y""), (4, ""Y""), (5, ""X"")),\n                ((0, ""Y""), (1, ""X""), (2, ""Z""), (3, ""Y""), (4, ""X""), (5, ""X"")),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((0, ""X""), (1, ""Y""), (2, ""Z""), (3, ""X""), (4, ""Y""), (5, ""X"")),\n                ((0, ""Y""), (1, ""Y""), (2, ""Z""), (3, ""X""), (4, ""X""), (5, ""X"")),\n                ((0, ""X""), (1, ""X""), (2, ""X""), (3, ""Y""), (5, ""Y"")),\n                ((0, ""X""), (1, ""Y""), (2, ""Y""), (3, ""X""), (4, ""Z""), (5, ""X"")),\n                ((0, ""Y""), (1, ""X""), (2, ""Y""), (3, ""Y""), (5, ""Y"")),\n                ((0, ""Y""), (1, ""Y""), (2, ""X""), (3, ""X""), (4, ""Z""), (5, ""X"")),\n                ((0, ""Z""), (4, ""Z"")),\n                ((0, ""Z""), (4, ""Z""), (5, ""Z"")),\n                ((0, ""X""), (1, ""X""), (3, ""Y""), (4, ""X""), (5, ""Y"")),\n                ((0, ""Y""), (1, ""X""), (3, ""Y""), (4, ""Y""), (5, ""Y"")),\n                ((0, ""Z""), (1, ""Z""), (2, ""Z"")),\n                ((0, ""Z""), (1, ""X""), (2, ""Z""), (3, ""Y""), (5, ""Y"")),\n                ((1, ""Y""), (2, ""Z""), (3, ""Y""), (4, ""Z""), (5, ""X"")),\n                ((0, ""Z""), (1, ""Y""), (2, ""X""), (3, ""X""), (4, ""Y""), (5, ""X"")),\n                ((0, ""Z""), (1, ""Y""), (2, ""Y""), (3, ""X""), (4, ""X""), (5, ""X"")),\n                ((1, ""Y""), (2, ""Y""), (3, ""Y""), (4, ""Y""), (5, ""X"")),\n                ((1, ""Y""), (2, ""X""), (3, ""Y""), (4, ""X""), (5, ""X"")),\n                ((0, ""Z""), (2, ""Z""), (3, ""Z"")),\n                ((0, ""Z""), (1, ""Y""), (2, ""Z""), (3, ""X""), (5, ""Y"")),\n                ((1, ""X""), (2, ""Z""), (3, ""X""), (4, ""Z""), (5, ""X"")),\n                ((0, ""Z""), (1, ""Z""), (4, ""Z"")),\n                ((0, ""Z""), (1, ""X""), (3, ""Y""), (4, ""Z""), (5, ""Y"")),\n                ((1, ""Y""), (3, ""Y""), (5, ""X"")),\n                ((0, ""Z""), (1, ""Z""), (4, ""Z""), (5, ""Z"")),\n                ((1, ""Z""), (3, ""Z"")),\n                ((2, ""Y""), (4, ""Y""), (5, ""Z"")),\n                ((1, ""Z""), (2, ""X""), (3, ""Z""), (4, ""X"")),\n                ((2, ""X""), (4, ""X""), (5, ""Z"")),\n                ((1, ""Z""), (2, ""Y""), (3, ""Z""), (4, ""Y"")),\n                ((2, ""Z""), (4, ""Z"")),\n                ((2, ""Z""), (4, ""Z""), (5, ""Z"")),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Z"")),\n                ((1, ""Z""), (2, ""Z""), (3, ""Z""), (4, ""Z""), (5, ""Z"")),\n                ((5, ""Z""),),\n            ],\n        ),\n    ],\n)\ndef test_transformation(\n    hf_filename, docc_mo, act_mo, type_of_transformation, coeffs_ref, pauli_strings_ref, tol\n):\n\n    r""""""Test the correctness of the Jordan-Wigner and Bravyi-Kitaev transformations\n    of the electronic Hamiltonian of different molecules (:math: `H_2, H_2O, LiH`) represented\n    in different active spaces.""""""\n\n    transformed_hamiltonian = qchem.decompose_hamiltonian(\n        hf_filename,\n        ref_dir,\n        mapping=type_of_transformation,\n        docc_mo_indices=docc_mo,\n        active_mo_indices=act_mo,\n    )\n\n    coeffs = np.array(list(transformed_hamiltonian.terms.values()))\n    pauli_strings = list(transformed_hamiltonian.terms.keys())\n\n    assert np.allclose(coeffs, coeffs_ref, **tol)\n    assert pauli_strings == pauli_strings_ref\n\n\ndef test_not_available_transformation():\n\n    r""""""Test that an error is raised if the chosen fermionic-to-qubit transformation\n    is neither \'jordan_wigner\' nor \'bravyi_kitaev\'.""""""\n\n    with pytest.raises(TypeError, match=""transformation is not available""):\n        qchem.decompose_hamiltonian(\n            ""lih"",\n            ref_dir,\n            mapping=""not_available_transformation"",\n            docc_mo_indices=[0],\n            active_mo_indices=[1, 2],\n        )\n'"
qchem/tests/test_generate_hamiltonian.py,0,"b'import os\n\nimport pytest\n\nfrom pennylane import qchem\n\nfrom pennylane.vqe import Hamiltonian\n\nref_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), ""test_ref_files"")\n\n\n@pytest.mark.parametrize(\n    (\n        ""mol_name"",\n        ""geo_file"",\n        ""charge"",\n        ""multiplicity"",\n        ""qc_prog"",\n        ""n_act_electrons"",\n        ""n_act_orbitals"",\n        ""transformation"",\n    ),\n    [\n        (""gdb3"", ""gdb3.mol5.PDB"", 0, 1, ""psi4"", 2, 2, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 0, 1, ""psi4"", 2, 2, ""BRAVYI_kitaev""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 1, 2, ""psi4"", 3, 4, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 1, 2, ""psi4"", 3, 4, ""BRAVYI_kitaev""),\n        (""gdb3"", ""gdb3.mol5.PDB"", -1, 2, ""psi4"", 1, 2, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", -1, 2, ""psi4"", 1, 2, ""BRAVYI_kitaev""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 2, 1, ""psi4"", 2, 2, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 2, 1, ""psi4"", 2, 2, ""BRAVYI_kitaev""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 0, 1, ""pyscf"", 2, 2, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 0, 1, ""pyscf"", 2, 2, ""BRAVYI_kitaev""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 1, 2, ""pyscf"", 3, 4, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 1, 2, ""pyscf"", 3, 4, ""BRAVYI_kitaev""),\n        (""gdb3"", ""gdb3.mol5.PDB"", -1, 2, ""pyscf"", 1, 2, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", -1, 2, ""pyscf"", 1, 2, ""BRAVYI_kitaev""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 2, 1, ""pyscf"", 2, 2, ""jordan_WIGNER""),\n        (""gdb3"", ""gdb3.mol5.PDB"", 2, 1, ""pyscf"", 2, 2, ""BRAVYI_kitaev""),\n    ],\n)\ndef test_building_hamiltonian(\n    mol_name,\n    geo_file,\n    charge,\n    multiplicity,\n    qc_prog,\n    n_act_electrons,\n    n_act_orbitals,\n    transformation,\n    psi4_support,\n    requires_babel,\n    tmpdir,\n):\n    r""""""Test that the generated Hamiltonian `built_hamiltonian` is an instance of the PennyLane\n    Hamiltonian class and the correctness of the total number of qubits required to run the\n    quantum simulation. The latter is tested for different values of the molecule\'s charge and\n    for active spaces with different size""""""\n\n    if qc_prog == ""psi4"" and not psi4_support:\n        pytest.skip(""Skipped, no Psi4 support"")\n\n    geo_file = os.path.join(ref_dir, geo_file)\n\n    built_hamiltonian, n_qubits = qchem.generate_hamiltonian(\n        mol_name,\n        geo_file,\n        charge,\n        multiplicity,\n        ""sto-3g"",\n        qc_package=qc_prog,\n        n_active_electrons=n_act_electrons,\n        n_active_orbitals=n_act_orbitals,\n        mapping=transformation,\n        outpath=tmpdir.strpath,\n    )\n\n    assert isinstance(built_hamiltonian, Hamiltonian)\n    assert n_qubits == 2 * n_act_orbitals\n'"
qchem/tests/test_hf_state.py,0,"b'import numpy as np\nimport pytest\n\nfrom pennylane import qchem\n\n\n@pytest.mark.parametrize(\n    (""n_electrons"", ""m_spin_orbitals"", ""exp_init_state""),\n    [\n        (2, 5, np.array([1, 1, 0, 0, 0])),\n        (1, 5, np.array([1, 0, 0, 0, 0])),\n        (5, 5, np.array([1, 1, 1, 1, 1]))\n    ]\n)\ndef test_hf_state(n_electrons, m_spin_orbitals, exp_init_state):\n\n    r""""""Test the correctness of the generated occupation-number vector""""""\n\n    res_init_state = qchem.hf_state(n_electrons, m_spin_orbitals)\n\n    assert len(res_init_state) == len(exp_init_state)\n    assert np.allclose(res_init_state, exp_init_state)\n\n\n@pytest.mark.parametrize(\n    (""n_electrons"", ""m_spin_orbitals"", ""msg_match""),\n    [\n        (0, 5, ""number of active electrons has to be larger than zero""),\n        (-1, 5, ""number of active electrons has to be larger than zero""),\n        (6, 5, ""number of active orbitals cannot be smaller than the number of active""),\n    ]\n)\ndef test_inconsistent_input(n_electrons, m_spin_orbitals, msg_match):\n\n    r""""""Test that an error is raised if a set of inconsistent arguments is input""""""\n\n    with pytest.raises(ValueError, match=msg_match):\n        qchem.hf_state(n_electrons, m_spin_orbitals)\n'"
qchem/tests/test_meanfield_data.py,0,"b'import os\n\nimport numpy as np\nimport pytest\nfrom openfermion.hamiltonians import MolecularData\n\nfrom pennylane import qchem\n\nmol_name = ""h2""\ngeometry = [(""H"", [0.0, 0.0, -0.35]), (""H"", [0.0, 0.0, 0.35])]\ncharge = 0\nmultiplicity = 1\nbasis = ""sto-3g""\n\n\n@pytest.mark.parametrize(""names"", [""Psi4"", ""PySCF""])\ndef test_path_to_hf_data(names, tmpdir, psi4_support):\n    r""""""Test the construction of the path to the directory containing the output files of\n    HF electronic structure calculations""""""\n\n    if names == ""Psi4"" and not psi4_support:\n        pytest.skip(""Skipped, no Psi4 support"")\n\n    path_to_hf_data_ref = os.path.join(tmpdir.strpath, names.lower(), basis.strip())\n\n    path_to_hf_data = qchem.meanfield_data(\n        mol_name, geometry, charge, multiplicity, basis, qc_package=names, outpath=tmpdir.strpath\n    )\n\n    assert path_to_hf_data == path_to_hf_data_ref\n\n\n@pytest.mark.parametrize(""names"", [""Psi4"", ""PySCF""])\ndef test_hf_calculations(names, tmpdir, psi4_support, tol):\n    r""""""Test the correctness of the HF calculation""""""\n\n    if names == ""Psi4"" and not psi4_support:\n        pytest.skip(""Skipped, no Psi4 support"")\n\n    n_atoms = 2\n    n_electrons = 2\n    n_orbitals = 2\n    hf_energy = -1.1173490350703152\n    orbital_energies = np.array([-0.59546347, 0.71416528])\n\n    one_body_integrals = np.array(\n        [[-1.27785300e00, 1.11022302e-16], [0.00000000e00, -4.48299698e-01]]\n    )\n\n    two_body_integrals = np.array(\n        [\n            [\n                [[6.82389533e-01, 0.00000000e00], [6.93889390e-17, 1.79000576e-01]],\n                [[4.16333634e-17, 1.79000576e-01], [6.70732778e-01, 0.00000000e00]],\n            ],\n            [\n                [[5.55111512e-17, 6.70732778e-01], [1.79000576e-01, 1.11022302e-16]],\n                [[1.79000576e-01, 0.00000000e00], [2.77555756e-17, 7.05105632e-01]],\n            ],\n        ]\n    )\n\n    path_to_hf_data = qchem.meanfield_data(\n        mol_name, geometry, charge, multiplicity, basis, qc_package=names, outpath=tmpdir.strpath\n    )\n\n    molecule = MolecularData(filename=os.path.join(path_to_hf_data, mol_name))\n\n    assert molecule.n_atoms == n_atoms\n    assert molecule.n_electrons == n_electrons\n    assert molecule.n_orbitals == n_orbitals\n    assert np.allclose(molecule.hf_energy, hf_energy, **tol)\n    assert np.allclose(molecule.orbital_energies, orbital_energies, **tol)\n    assert np.allclose(molecule.one_body_integrals, one_body_integrals, **tol)\n    assert np.allclose(molecule.two_body_integrals, two_body_integrals, **tol)\n\n\n@pytest.mark.parametrize(""names"", [""not_available_package""])\ndef test_not_available_qc_package(names, tmpdir):\n    r""""""Test that an error is raised if the chosen quantum chemistry package is neither Psi4 nor PySCF""""""\n\n    with pytest.raises(TypeError, match=""Integration with quantum chemistry package""):\n        qchem.meanfield_data(\n            mol_name,\n            geometry,\n            charge,\n            multiplicity,\n            basis,\n            qc_package=names,\n            outpath=tmpdir.strpath,\n        )\n'"
qchem/tests/test_read_structure.py,0,"b'import pytest\nfrom pennylane import qchem\nimport os\nimport subprocess\n\nref_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), ""test_ref_files"")\n\n\n@pytest.mark.parametrize(\n    ""names"",\n    [\n        [""h2.SDF"", ""h2_ref.xyz""],\n        [""gdb3.mol5.PDB"", ""gdb3.mol5_ref.xyz""],\n        [""gdb3.mol5.XYZ"", ""gdb3.mol5_ref.xyz""],\n    ],\n)\ndef test_conversion_from_folder(names, tmpdir, requires_babel):\n    r""""""Test the conversion of molecular structure file with different formats""""""\n\n    filename = os.path.join(ref_dir, names[0])\n    qchem.read_structure(filename, outpath=tmpdir)\n\n    with open(tmpdir.join(""structure.xyz"")) as g:\n        gen_file = g.readlines()[2:]\n\n    with open(os.path.join(ref_dir, names[1])) as f:\n        ref_file = f.readlines()[2:]\n\n    assert gen_file == ref_file\n\n\ndef test_reading_xyz_file(tmpdir):\n    r""""""Test reading of the generated file \'structure.xyz\'""""""\n\n    ref_geometry = [\n        [""C"", (0.361, -0.452, -0.551)],\n        [""C"", (-0.714, 0.125, 0.327)],\n        [""N"", (0.683, 0.133, 0.745)],\n        [""H"", (0.442, -1.529, -0.619)],\n        [""H"", (0.672, 0.102, -1.428)],\n        [""H"", (-1.364, -0.56, 0.857)],\n        [""H"", (-1.149, 1.08, 0.060)],\n        [""H"", (1.093, 1.063, 0.636)],\n    ]\n\n    name = os.path.join(ref_dir, ""gdb3.mol5.XYZ"")\n    geometry = qchem.read_structure(name, outpath=tmpdir)\n\n    assert geometry == ref_geometry\n\n\ndef test_subprocess_run(monkeypatch, requires_babel):\n    r""""""Test \'subprocess.run\' function running babel to convert the molecular structure\n     file to xyz format""""""\n\n    with monkeypatch.context() as m:\n\n        def fake_run(*args, **kwargs):\n            raise subprocess.CalledProcessError(1, ""obabel"")\n\n        m.setattr(subprocess, ""run"", fake_run)\n\n        with pytest.raises(\n            RuntimeError, match=""Open Babel error. See the following Open Babel output for details""\n        ):\n            qchem.read_structure(""fake_mol_geo.SDF"")\n'"
qchem/tests/test_sd_excitations.py,0,"b'import os\n\nimport pytest\n\nfrom pennylane import qchem\n\n@pytest.mark.parametrize(\n    (""n_electrons"", ""n_orbitals"", ""delta_sz"", ""n_singles"", ""n_doubles"", ""ph_ref"", ""pphh_ref""),\n    [\n        (1, 5,  0, 2, 0, [[0, 2], [0, 4]]                , []),\n        (1, 5,  1, 0, 0, []                              , []),\n        (1, 5, -1, 2, 0, [[0, 1], [0, 3]]                , []),\n        (2, 5,  0, 3, 2, [[0, 2], [0, 4], [1, 3]]        , [[0, 1, 2, 3], [0, 1, 3, 4]]),\n        (2, 5,  1, 2, 1, [[1, 2], [1, 4]]                , [[0, 1, 2, 4]]),\n        (2, 5, -1, 1, 0, [[0, 3]]                        , []),\n        (2, 5,  2, 0, 0, []                              , []),\n        (3, 6,  1, 1, 0, [[1, 4]]                        , []),\n        (3, 6, -1, 4, 4, [[0, 3], [0, 5], [2, 3], [2, 5]], [[0, 1, 3, 5], [0, 2, 3, 4], \\\n                                                            [0, 2, 4, 5], [1, 2, 3, 5]]),\n        (3, 6, -2, 0, 1, []                              , [[0, 2, 3, 5]]),\n        (3, 4,  0, 1, 0, [[1, 3]]                        , []),\n        (3, 4,  1, 0, 0, []                              , []),\n        (3, 4, -1, 2, 0, [[0, 3], [2, 3]]                , []),\n        (3, 4,  2, 0, 0, []                              , []),\n    ]\n)\ndef test_sd_excitations(\n    n_electrons, n_orbitals, delta_sz, n_singles, n_doubles, ph_ref, pphh_ref\n):\n\n    r""""""Test the correctness of the generated configurations""""""\n\n    ph, pphh = qchem.sd_excitations(n_electrons, n_orbitals, delta_sz)\n\n    assert len(ph) == len(ph_ref)\n    assert len(pphh) == len(pphh_ref)\n    assert ph == ph_ref\n    assert pphh == pphh_ref\n\n\n@pytest.mark.parametrize(\n    (""n_electrons"", ""n_orbitals"", ""delta_sz"", ""message_match""),\n    [\n        (0, 4, 0  , ""number of active electrons has to be greater than 0""),\n        (3, 2, 0  , ""has to be greater than the number of active electrons""),\n        (2, 4, 3  , ""Expected values for \'delta_sz\'""),\n        (2, 4, 1.5, ""Expected values for \'delta_sz\'"")\n    ]\n)\ndef test_inconsistent_excitations(n_electrons, n_orbitals, delta_sz, message_match):\n\n    r""""""Test that an error is raised if a set of inconsistent arguments is input""""""\n\n    with pytest.raises(ValueError, match=message_match):\n        qchem.sd_excitations(n_electrons, n_orbitals, delta_sz)\n'"
tests/beta/test_default_tensor.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.plugin.Tensornet` device.\n""""""\nimport cmath\n# pylint: disable=protected-access,cell-var-from-loop\nimport math\n\nimport pytest\n\n# TODO: remove the following skip when Tensornet has been ported to\n# Qubit device, and the gate imports above are removed.\ntensorflow = pytest.importorskip(""tensorflow"", minversion=""2.0"")\n\nimport pennylane as qml\nfrom pennylane import numpy as np, QuantumFunctionError\nfrom pennylane.beta.plugins.default_tensor import (\n    CNOT,\n    CSWAP,\n    CZ,\n    SWAP,\n    CRot3,\n    CRotx,\n    CRoty,\n    CRotz,\n    H,\n    Rot3,\n    Rotx,\n    Roty,\n    Rotz,\n    Rphi,\n    S,\n    T,\n    X,\n    Y,\n    Z,\n    hermitian,\n    identity,\n    Toffoli,\n    spectral_decomposition,\n    unitary,\n)\n\ntensornetwork = pytest.importorskip(""tensornetwork"", minversion=""0.1"")\n\n\nU = np.array(\n    [\n        [0.83645892 - 0.40533293j, -0.20215326 + 0.30850569j],\n        [-0.23889780 - 0.28101519j, -0.88031770 - 0.29832709j],\n    ]\n)\n\n\nU2 = np.array(\n    [\n        [\n            -0.07843244 - 3.57825948e-01j,\n            0.71447295 - 5.38069384e-02j,\n            0.20949966 + 6.59100734e-05j,\n            -0.50297381 + 2.35731613e-01j,\n        ],\n        [\n            -0.26626692 + 4.53837083e-01j,\n            0.27771991 - 2.40717436e-01j,\n            0.41228017 - 1.30198687e-01j,\n            0.01384490 - 6.33200028e-01j,\n        ],\n        [\n            -0.69254712 - 2.56963068e-02j,\n            -0.15484858 + 6.57298384e-02j,\n            -0.53082141 + 7.18073414e-02j,\n            -0.41060450 - 1.89462315e-01j,\n        ],\n        [\n            -0.09686189 - 3.15085273e-01j,\n            -0.53241387 - 1.99491763e-01j,\n            0.56928622 + 3.97704398e-01j,\n            -0.28671074 - 6.01574497e-02j,\n        ],\n    ]\n)\n\n\nU_toffoli = np.diag([1 for i in range(8)])\nU_toffoli[6:8, 6:8] = np.array([[0, 1], [1, 0]])\n\nU_swap = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\n\nU_cswap = np.array([[1, 0, 0, 0, 0, 0, 0, 0],\n                    [0, 1, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 1, 0, 0, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0, 0, 0],\n                    [0, 0, 0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 1, 0],\n                    [0, 0, 0, 0, 0, 1, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 0, 1]])\n\n\nH = np.array(\n    [[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]]\n)\n\n\nTHETA = np.linspace(0.11, 1, 3)\nPHI = np.linspace(0.32, 1, 3)\nVARPHI = np.linspace(0.02, 1, 3)\n\n\ndef prep_par(par, op):\n    ""Convert par into a list of parameters that op expects.""\n    if op.par_domain == ""A"":\n        return [np.diag([x, 1]) for x in par]\n    return par\n\n\nclass TestAuxillaryFunctions:\n    """"""Test auxillary functions.""""""\n\n    def test_spectral_decomposition(self, tol):\n        """"""Test that the correct spectral decomposition is returned.""""""\n\n        a, P = spectral_decomposition(H)\n\n        # verify that H = \\sum_k a_k P_k\n        assert np.allclose(H, np.einsum(""i,ijk->jk"", a, P), atol=tol, rtol=0)\n\n    def test_phase_shift(self, tol):\n        """"""Test phase shift is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(Rphi(0), np.identity(2), atol=tol, rtol=0)\n\n        # test arbitrary phase shift\n        phi = 0.5432\n        expected = np.array([[1, 0], [0, np.exp(1j * phi)]])\n        assert np.allclose(Rphi(phi), expected, atol=tol, rtol=0)\n\n    def test_x_rotation(self, tol):\n        """"""Test x rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(Rotx(0), np.identity(2), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array([[1, -1j], [-1j, 1]]) / np.sqrt(2)\n        assert np.allclose(Rotx(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = -1j * np.array([[0, 1], [1, 0]])\n        assert np.allclose(Rotx(np.pi), expected, atol=tol, rtol=0)\n\n    def test_y_rotation(self, tol):\n        """"""Test y rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(Roty(0), np.identity(2), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array([[1, -1], [1, 1]]) / np.sqrt(2)\n        assert np.allclose(Roty(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[0, -1], [1, 0]])\n        assert np.allclose(Roty(np.pi), expected, atol=tol, rtol=0)\n\n    def test_z_rotation(self, tol):\n        """"""Test z rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(Rotz(0), np.identity(2), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.diag(np.exp([-1j * np.pi / 4, 1j * np.pi / 4]))\n        assert np.allclose(Rotz(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        assert np.allclose(Rotz(np.pi), -1j * Z, atol=tol, rtol=0)\n\n    def test_arbitrary_rotation(self, tol):\n        """"""Test arbitrary single qubit rotation is correct""""""\n\n        # test identity for phi,theta,omega=0\n        assert np.allclose(Rot3(0, 0, 0), np.identity(2), atol=tol, rtol=0)\n\n        # expected result\n        def arbitrary_rotation(x, y, z):\n            """"""arbitrary single qubit rotation""""""\n            c = np.cos(y / 2)\n            s = np.sin(y / 2)\n            return np.array(\n                [\n                    [np.exp(-0.5j * (x + z)) * c, -np.exp(0.5j * (x - z)) * s],\n                    [np.exp(-0.5j * (x - z)) * s, np.exp(0.5j * (x + z)) * c],\n                ]\n            )\n\n        a, b, c = 0.432, -0.152, 0.9234\n        assert np.allclose(Rot3(a, b, c), arbitrary_rotation(a, b, c), atol=tol, rtol=0)\n\n    def test_C_x_rotation(self, tol):\n        """"""Test controlled x rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(CRotx(0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1/np.sqrt(2), -1j/np.sqrt(2)], [0, 0, -1j/np.sqrt(2), 1/np.sqrt(2)]])\n        assert np.allclose(CRotx(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1j], [0, 0, -1j, 0]])\n        assert np.allclose(CRotx(np.pi), expected, atol=tol, rtol=0)\n\n    def test_C_y_rotation(self, tol):\n        """"""Test controlled y rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(CRoty(0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1/np.sqrt(2), -1/np.sqrt(2)], [0, 0, 1/np.sqrt(2), 1/np.sqrt(2)]])\n        assert np.allclose(CRoty(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1], [0, 0, 1, 0]])\n        assert np.allclose(CRoty(np.pi), expected, atol=tol, rtol=0)\n\n    def test_C_z_rotation(self, tol):\n        """"""Test controlled z rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(CRotz(0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, np.exp(-1j * np.pi / 4), 0], [0, 0, 0, np.exp(1j * np.pi / 4)]])\n        assert np.allclose(CRotz(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1j, 0], [0, 0, 0, 1j]])\n        assert np.allclose(CRotz(np.pi), expected, atol=tol, rtol=0)\n\n    def test_controlled_arbitrary_rotation(self, tol):\n        """"""Test controlled arbitrary rotation is correct""""""\n\n        # test identity for phi,theta,omega=0\n        assert np.allclose(CRot3(0, 0, 0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for phi,theta,omega=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1], [0, 0, 1, 0]])\n        assert np.allclose(CRot3(np.pi, np.pi, np.pi), expected, atol=tol, rtol=0)\n\n        def arbitrary_Crotation(x, y, z):\n            """"""controlled arbitrary single qubit rotation""""""\n            c = np.cos(y / 2)\n            s = np.sin(y / 2)\n            return np.array(\n                [\n                    [1, 0, 0, 0],\n                    [0, 1, 0, 0],\n                    [0, 0, np.exp(-0.5j * (x + z)) * c, -np.exp(0.5j * (x - z)) * s],\n                    [0, 0, np.exp(-0.5j * (x - z)) * s, np.exp(0.5j * (x + z)) * c]\n                ]\n            )\n\n        a, b, c = 0.432, -0.152, 0.9234\n        assert np.allclose(CRot3(a, b, c), arbitrary_Crotation(a, b, c), atol=tol, rtol=0)\n\n\nclass TestStateFunctions:\n    """"""Arbitrary state and operator tests.""""""\n\n    def test_unitary(self, tol):\n        """"""Test that the unitary function produces the correct output.""""""\n\n        out = unitary(U)\n\n        # verify output type\n        assert isinstance(out, np.ndarray)\n\n        # verify equivalent to input state\n        assert np.allclose(out, U, atol=tol, rtol=0)\n\n    def test_unitary_exceptions(self):\n        """"""Tests that the unitary function raises the proper errors.""""""\n\n        # test non-square matrix\n        with pytest.raises(ValueError, match=""must be a square matrix""):\n            unitary(U[1:])\n\n        # test non-unitary matrix\n        U3 = U.copy()\n        U3[0, 0] += 0.5\n        with pytest.raises(ValueError, match=""must be unitary""):\n            unitary(U3)\n\n    def test_hermitian(self, tol):\n        """"""Test that the hermitian function produces the correct output.""""""\n\n        out = hermitian(H)\n\n        # verify output type\n        assert isinstance(out, np.ndarray)\n\n        # verify equivalent to input state\n        assert np.allclose(out, H, atol=tol, rtol=0)\n\n    def test_hermitian_exceptions(self):\n        """"""Tests that the hermitian function raises the proper errors.""""""\n\n        # test non-square matrix\n        with pytest.raises(ValueError, match=""must be a square matrix""):\n            hermitian(H[1:])\n\n        # test non-Hermitian matrix\n        H2 = H.copy()\n        H2[0, 1] = H2[0, 1].conj()\n        with pytest.raises(ValueError, match=""must be Hermitian""):\n            hermitian(H2)\n \n\nclass TestDefaultTensorIntegration:\n    """"""Integration tests for default.tensor. This test ensures it integrates\n    properly with the PennyLane interface, in particular QNode.""""""\n\n    def test_load_tensornet_device(self):\n        """"""Test that the tensor network plugin loads correctly""""""\n\n        dev = qml.device(""default.tensor"", wires=2)\n        assert dev.num_wires == 2\n        assert dev.shots == 1000\n        assert dev.analytic\n        assert dev.short_name == ""default.tensor""\n\n    def test_args(self):\n        """"""Test that the plugin requires correct arguments""""""\n\n        with pytest.raises(\n            TypeError, match=""missing 1 required positional argument: \'wires\'""\n        ):\n            qml.device(""default.tensor"")\n\n    @pytest.mark.parametrize(""gate"", set(qml.ops.cv.ops))\n    def test_unsupported_gate_error(self, tensornet_device_3_wires, gate):\n        """"""Tests that an error is raised if an unsupported gate is applied""""""\n        op = getattr(qml.ops, gate)\n\n        if op.num_wires is qml.operation.ActsOn.AnyWires or qml.operation.ActsOn.AllWires:\n            wires = [0]\n        else:\n            wires = list(range(op.num_wires))\n\n        @qml.qnode(tensornet_device_3_wires)\n        def circuit(*x):\n            """"""Test quantum function""""""\n            x = prep_par(x, op)\n            op(*x, wires=wires)\n\n            return qml.expval(qml.X(0))\n\n        with pytest.raises(\n            QuantumFunctionError, match=""Device default.tensor is a qubit device; CV operations are not allowed.""\n        ):\n            x = np.random.random([op.num_params])\n            circuit(*x)\n\n    @pytest.mark.parametrize(""observable"", set(qml.ops.cv.obs))\n    def test_unsupported_observable_error(self, tensornet_device_3_wires, observable):\n        """"""Test error is raised with unsupported observables""""""\n\n        op = getattr(qml.ops, observable)\n\n        if op.num_wires is qml.operation.ActsOn.AnyWires or qml.operation.ActsOn.AllWires:\n            wires = [0]\n        else:\n            wires = list(range(op.num_wires))\n\n        @qml.qnode(tensornet_device_3_wires)\n        def circuit(*x):\n            """"""Test quantum function""""""\n            x = prep_par(x, op)\n            return qml.expval(op(*x, wires=wires))\n\n        with pytest.raises(\n            QuantumFunctionError, match=""Device default.tensor is a qubit device; CV operations are not allowed.""\n        ):\n            x = np.random.random([op.num_params])\n            circuit(*x)\n\n    def test_qubit_circuit(self, tensornet_device_1_wire, tol):\n        """"""Test that the tensor network plugin provides correct result for a simple circuit""""""\n\n        p = 0.543\n\n        @qml.qnode(tensornet_device_1_wire)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliY(0))\n\n        expected = -np.sin(p)\n\n        assert np.isclose(circuit(p), expected, atol=tol, rtol=0)\n\n    def test_qubit_identity(self, tensornet_device_1_wire, tol):\n        """"""Test that the tensor network plugin provides correct result for the Identity expectation""""""\n\n        p = 0.543\n\n        @qml.qnode(tensornet_device_1_wire)\n        def circuit(x):\n            """"""Test quantum function""""""\n            qml.RX(x, wires=0)\n            return qml.expval(qml.Identity(0))\n\n        assert np.isclose(circuit(p), 1, atol=tol, rtol=0)\n\n    # This test is ran against the state |0> with one Z expval\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""PauliX"", -1),\n        (""PauliY"", -1),\n        (""PauliZ"", 1),\n        (""Hadamard"", 0),\n    ])\n    def test_supported_gate_single_wire_no_parameters(self, tensornet_device_1_wire, tol, name, expected_output):\n        """"""Tests supported gates that act on a single wire that are not parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert tensornet_device_1_wire.supports_operation(name)\n\n        @qml.qnode(tensornet_device_1_wire)\n        def circuit():\n            op(wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran against the state |Phi+> with two Z expvals\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""CNOT"", [-1/2, 1]),\n        (""SWAP"", [-1/2, -1/2]),\n        (""CZ"", [-1/2, -1/2]),\n    ])\n    def test_supported_gate_two_wires_no_parameters(self, tensornet_device_2_wires, tol, name, expected_output):\n        """"""Tests supported gates that act on two wires that are not parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert tensornet_device_2_wires.supports_operation(name)\n\n        @qml.qnode(tensornet_device_2_wires)\n        def circuit():\n            qml.QubitStateVector(np.array([1/2, 0, 0, math.sqrt(3)/2]), wires=[0, 1])\n            op(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""CSWAP"", [-1, -1, 1]),\n    ])\n    def test_supported_gate_three_wires_no_parameters(self, tensornet_device_3_wires, tol, name, expected_output):\n        """"""Tests supported gates that act on three wires that are not parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert tensornet_device_3_wires.supports_operation(name)\n\n        @qml.qnode(tensornet_device_3_wires)\n        def circuit():\n            qml.BasisState(np.array([1, 0, 1]), wires=[0, 1, 2])\n            op(wires=[0, 1, 2])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliZ(2))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran with two Z expvals\n    @pytest.mark.parametrize(""name,par,expected_output"", [\n        (""BasisState"", [0, 0], [1, 1]),\n        (""BasisState"", [1, 0], [-1, 1]),\n        (""BasisState"", [0, 1], [1, -1]),\n        (""QubitStateVector"", [1, 0, 0, 0], [1, 1]),\n        (""QubitStateVector"", [0, 0, 1, 0], [-1, 1]),\n        (""QubitStateVector"", [0, 1, 0, 0], [1, -1]),\n    ])\n    def test_supported_state_preparation(self, tensornet_device_2_wires, tol, name, par, expected_output):\n        """"""Tests supported state preparations""""""\n\n        op = getattr(qml.ops, name)\n\n        assert tensornet_device_2_wires.supports_operation(name)\n\n        @qml.qnode(tensornet_device_2_wires)\n        def circuit():\n            op(np.array(par), wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran on the state |0> with one Z expvals\n    @pytest.mark.parametrize(""name,par,expected_output"", [\n        (""PhaseShift"", [math.pi/2], 1),\n        (""PhaseShift"", [-math.pi/4], 1),\n        (""RX"", [math.pi/2], 0),\n        (""RX"", [-math.pi/4], 1/math.sqrt(2)),\n        (""RY"", [math.pi/2], 0),\n        (""RY"", [-math.pi/4], 1/math.sqrt(2)),\n        (""RZ"", [math.pi/2], 1),\n        (""RZ"", [-math.pi/4], 1),\n        (""Rot"", [math.pi/2, 0, 0], 1),\n        (""Rot"", [0, math.pi/2, 0], 0),\n        (""Rot"", [0, 0, math.pi/2], 1),\n        (""Rot"", [math.pi/2, -math.pi/4, -math.pi/4], 1/math.sqrt(2)),\n        (""Rot"", [-math.pi/4, math.pi/2, math.pi/4], 0),\n        (""Rot"", [-math.pi/4, math.pi/4, math.pi/2], 1/math.sqrt(2)),\n        (""QubitUnitary"", [np.array([[1j/math.sqrt(2), 1j/math.sqrt(2)], [1j/math.sqrt(2), -1j/math.sqrt(2)]])], 0),\n        (""QubitUnitary"", [np.array([[-1j/math.sqrt(2), 1j/math.sqrt(2)], [1j/math.sqrt(2), 1j/math.sqrt(2)]])], 0),\n    ])\n    def test_supported_gate_single_wire_with_parameters(self, tensornet_device_1_wire, tol, name, par, expected_output):\n        """"""Tests supported gates that act on a single wire that are parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert tensornet_device_1_wire.supports_operation(name)\n\n        @qml.qnode(tensornet_device_1_wire)\n        def circuit():\n            op(*par, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran against the state 1/2|00>+sqrt(3)/2|11> with two Z expvals\n    @pytest.mark.parametrize(""name,par,expected_output"", [\n        (""CRX"", [0], [-1/2, -1/2]),\n        (""CRX"", [-math.pi], [-1/2, 1]),\n        (""CRX"", [math.pi/2], [-1/2, 1/4]),\n        (""CRY"", [0], [-1/2, -1/2]),\n        (""CRY"", [-math.pi], [-1/2, 1]),\n        (""CRY"", [math.pi/2], [-1/2, 1/4]),\n        (""CRZ"", [0], [-1/2, -1/2]),\n        (""CRZ"", [-math.pi], [-1/2, -1/2]),\n        (""CRZ"", [math.pi/2], [-1/2, -1/2]),\n        (""CRot"", [math.pi/2, 0, 0], [-1/2, -1/2]),\n        (""CRot"", [0, math.pi/2, 0], [-1/2, 1/4]),\n        (""CRot"", [0, 0, math.pi/2], [-1/2, -1/2]),\n        (""CRot"", [math.pi/2, 0, -math.pi], [-1/2, -1/2]),\n        (""CRot"", [0, math.pi/2, -math.pi], [-1/2, 1/4]),\n        (""CRot"", [-math.pi, 0, math.pi/2], [-1/2, -1/2]),\n        (""QubitUnitary"", [np.array([[1, 0, 0, 0], [0, 1/math.sqrt(2), 1/math.sqrt(2), 0], [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], [0, 0, 0, 1]])], [-1/2, -1/2]),\n        (""QubitUnitary"", [np.array([[-1, 0, 0, 0], [0, 1/math.sqrt(2), 1/math.sqrt(2), 0], [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], [0, 0, 0, -1]])], [-1/2, -1/2]),\n    ])\n    def test_supported_gate_two_wires_with_parameters(self, tensornet_device_2_wires, tol, name, par, expected_output):\n        """"""Tests supported gates that act on two wires wires that are parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert tensornet_device_2_wires.supports_operation(name)\n\n        @qml.qnode(tensornet_device_2_wires)\n        def circuit():\n            qml.QubitStateVector(np.array([1/2, 0, 0, math.sqrt(3)/2]), wires=[0, 1])\n            op(*par, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,state,expected_output"", [\n        (""PauliX"", [1/math.sqrt(2), 1/math.sqrt(2)], 1),\n        (""PauliX"", [1/math.sqrt(2), -1/math.sqrt(2)], -1),\n        (""PauliX"", [1, 0], 0),\n        (""PauliY"", [1/math.sqrt(2), 1j/math.sqrt(2)], 1),\n        (""PauliY"", [1/math.sqrt(2), -1j/math.sqrt(2)], -1),\n        (""PauliY"", [1, 0], 0),\n        (""PauliZ"", [1, 0], 1),\n        (""PauliZ"", [0, 1], -1),\n        (""PauliZ"", [1/math.sqrt(2), 1/math.sqrt(2)], 0),\n        (""Hadamard"", [1, 0], 1/math.sqrt(2)),\n        (""Hadamard"", [0, 1], -1/math.sqrt(2)),\n        (""Hadamard"", [1/math.sqrt(2), 1/math.sqrt(2)], 1/math.sqrt(2)),\n    ])\n    def test_supported_observable_single_wire_no_parameters(self, tensornet_device_1_wire, tol, name, state, expected_output):\n        """"""Tests supported observables on single wires without parameters.""""""\n\n        obs = getattr(qml.ops, name)\n\n        assert tensornet_device_1_wire.supports_observable(name)\n\n        @qml.qnode(tensornet_device_1_wire)\n        def circuit():\n            qml.QubitStateVector(np.array(state), wires=[0])\n            return qml.expval(obs(wires=[0]))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,state,expected_output,par"", [\n        (""Identity"", [1, 0], 1, []),\n        (""Identity"", [0, 1], 1, []),\n        (""Identity"", [1/math.sqrt(2), -1/math.sqrt(2)], 1, []),\n        (""Hermitian"", [1, 0], 1, [np.array([[1, 1j], [-1j, 1]])]),\n        (""Hermitian"", [0, 1], 1, [np.array([[1, 1j], [-1j, 1]])]),\n        (""Hermitian"", [1/math.sqrt(2), -1/math.sqrt(2)], 1, [np.array([[1, 1j], [-1j, 1]])]),\n    ])\n    def test_supported_observable_single_wire_with_parameters(self, tensornet_device_1_wire, tol, name, state, expected_output, par):\n        """"""Tests supported observables on single wires with parameters.""""""\n\n        obs = getattr(qml.ops, name)\n\n        assert tensornet_device_1_wire.supports_observable(name)\n\n        @qml.qnode(tensornet_device_1_wire)\n        def circuit():\n            qml.QubitStateVector(np.array(state), wires=[0])\n            return qml.expval(obs(*par, wires=[0]))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,state,expected_output,par"", [\n        (""Hermitian"", [1/math.sqrt(3), 0, 1/math.sqrt(3), 1/math.sqrt(3)], 5/3, [np.array([[1, 1j, 0, 1], [-1j, 1, 0, 0], [0, 0, 1, -1j], [1, 0, 1j, 1]])]),\n        (""Hermitian"", [0, 0, 0, 1], 0, [np.array([[0, 1j, 0, 0], [-1j, 0, 0, 0], [0, 0, 0, -1j], [0, 0, 1j, 0]])]),\n        (""Hermitian"", [1/math.sqrt(2), 0, -1/math.sqrt(2), 0], 1, [np.array([[1, 1j, 0, 0], [-1j, 1, 0, 0], [0, 0, 1, -1j], [0, 0, 1j, 1]])]),\n        (""Hermitian"", [1/math.sqrt(3), -1/math.sqrt(3), 1/math.sqrt(6), 1/math.sqrt(6)], 1, [np.array([[1, 1j, 0, .5j], [-1j, 1, 0, 0], [0, 0, 1, -1j], [-.5j, 0, 1j, 1]])]),\n        (""Hermitian"", [1/math.sqrt(2), 0, 0, 1/math.sqrt(2)], 1, [np.array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])]),\n        (""Hermitian"", [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], -1, [np.array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])]),\n    ])\n    def test_supported_observable_two_wires_with_parameters(self, tensornet_device_2_wires, tol, name, state, expected_output, par):\n        """"""Tests supported observables on two wires with parameters.""""""\n\n        obs = getattr(qml.ops, name)\n\n        assert tensornet_device_2_wires.supports_observable(name)\n\n        @qml.qnode(tensornet_device_2_wires)\n        def circuit():\n            qml.QubitStateVector(np.array(state), wires=[0, 1])\n            return qml.expval(obs(*par, wires=[0, 1]))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    def test_expval_warnings(self):\n        """"""Tests that expval raises a warning if the given observable is complex.""""""\n\n        dev = qml.device(""default.tensor"", wires=1)\n\n        A = np.array([[2j, 1j], [-3j, 1j]])\n        obs_node = dev._add_node(A, wires=[0])\n\n        # text warning raised if matrix is complex\n        with pytest.warns(RuntimeWarning, match=\'Nonvanishing imaginary part\'):\n            dev.ev([obs_node], wires=[[0]])\n\n    def test_cannot_overwrite_state(self, tensornet_device_2_wires):\n        """"""Tests that _state is a property and cannot be overwritten.""""""\n\n        dev = tensornet_device_2_wires\n\n        with pytest.raises(AttributeError, match=""can\'t set attribute""):\n            dev._state = np.array([[1, 0],\n                                   [0, 0]])\n\n    def test_correct_state(self, tensornet_device_2_wires):\n\n        dev = tensornet_device_2_wires\n        state = dev._state\n\n        expected = np.array([[1, 0],\n                             [0, 0]])\n        assert np.allclose(state, expected)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.Hadamard(wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        circuit()\n        state = dev._state\n\n        expected = np.array([[1, 0],\n                             [1, 0]]) / np.sqrt(2)\n        assert np.allclose(state, expected)\n\n\n@pytest.mark.parametrize(""theta,phi,varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorExpval:\n    """"""Test tensor expectation values""""""\n\n    def test_paulix_pauliy(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        res = dev.expval([""PauliX"", ""PauliY""], [[0], [2]], [[], []])\n        expected = np.sin(theta) * np.sin(phi) * np.sin(varphi)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_pauliz_identity(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliZ and Identity works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        res = dev.expval([""PauliZ"", ""Identity"", ""PauliZ""], [[0], [1], [2]], [[], [], []])\n        expected = np.cos(varphi)*np.cos(phi)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_pauliz_hadamard(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        res = dev.expval([""PauliZ"", ""Hadamard"", ""PauliY""], [[0], [1], [2]], [[], [], []])\n        expected = -(np.cos(varphi) * np.sin(phi) + np.sin(varphi) * np.cos(theta)) / np.sqrt(2)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        res = dev.expval([""PauliZ"", ""Hermitian""], [[0], [1, 2]], [[], [A]])\n        expected = 0.5 * (\n            -6 * np.cos(theta) * (np.cos(varphi) + 1)\n            - 2 * np.sin(varphi) * (np.cos(theta) + np.sin(phi) - 2 * np.cos(phi))\n            + 3 * np.cos(varphi) * np.sin(phi)\n            + np.sin(phi)\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian_hermitian(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving two Hermitian matrices works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        A1 = np.array([[1, 2],\n                       [2, 4]])\n\n        A2 = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        res = dev.expval([""Hermitian"", ""Hermitian""], [[0], [1, 2]], [[A1], [A2]])\n        expected = 0.25 * (\n            -30\n            + 4 * np.cos(phi) * np.sin(theta)\n            + 3 * np.cos(varphi) * (-10 + 4 * np.cos(phi) * np.sin(theta) - 3 * np.sin(phi))\n            - 3 * np.sin(phi)\n            - 2 * (5 + np.cos(phi) * (6 + 4 * np.sin(theta)) + (-3 + 8 * np.sin(theta)) * np.sin(phi))\n            * np.sin(varphi)\n            + np.cos(theta)\n            * (\n                18\n                + 5 * np.sin(phi)\n                + 3 * np.cos(varphi) * (6 + 5 * np.sin(phi))\n                + 2 * (3 + 10 * np.cos(phi) - 5 * np.sin(phi)) * np.sin(varphi)\n            )\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian_identity_expectation(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving an Hermitian matrix and the identity works correctly""""""\n        dev = qml.device(""default.tensor"", wires=2)\n        dev.reset()\n        dev.apply(""RY"", wires=[0], par=[theta])\n        dev.apply(""RY"", wires=[1], par=[phi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n\n        A = np.array([[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]])\n\n        res = dev.expval([""Hermitian"", ""Identity""], [[0], [1]], [[A], []])\n\n        a = A[0, 0]\n        re_b = A[0, 1].real\n        d = A[1, 1]\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorVar:\n    """"""Test tensor variances""""""\n\n    def test_paulix_pauliy(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        res = dev.var([""PauliX"", ""PauliY""], [[0], [2]], [[], [], []])\n\n        expected = (\n            8 * np.sin(theta) ** 2 * np.cos(2 * varphi) * np.sin(phi) ** 2\n            - np.cos(2 * (theta - phi))\n            - np.cos(2 * (theta + phi))\n            + 2 * np.cos(2 * theta)\n            + 2 * np.cos(2 * phi)\n            + 14\n        ) / 16\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_pauliz_hadamard(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        res = dev.var([""PauliZ"", ""Hadamard"", ""PauliY""], [[0], [1], [2]], [[], [], []])\n\n        expected = (\n            3\n            + np.cos(2 * phi) * np.cos(varphi) ** 2\n            - np.cos(2 * theta) * np.sin(varphi) ** 2\n            - 2 * np.cos(theta) * np.sin(phi) * np.sin(2 * varphi)\n        ) / 4\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        res = dev.var([""PauliZ"", ""Hermitian""], [[0], [1, 2]], [[], [A]])\n\n        expected = (\n            1057\n            - np.cos(2 * phi)\n            + 12 * (27 + np.cos(2 * phi)) * np.cos(varphi)\n            - 2 * np.cos(2 * varphi) * np.sin(phi) * (16 * np.cos(phi) + 21 * np.sin(phi))\n            + 16 * np.sin(2 * phi)\n            - 8 * (-17 + np.cos(2 * phi) + 2 * np.sin(2 * phi)) * np.sin(varphi)\n            - 8 * np.cos(2 * theta) * (3 + 3 * np.cos(varphi) + np.sin(varphi)) ** 2\n            - 24 * np.cos(phi) * (np.cos(phi) + 2 * np.sin(phi)) * np.sin(2 * varphi)\n            - 8\n            * np.cos(theta)\n            * (\n                4\n                * np.cos(phi)\n                * (\n                    4\n                    + 8 * np.cos(varphi)\n                    + np.cos(2 * varphi)\n                    - (1 + 6 * np.cos(varphi)) * np.sin(varphi)\n                )\n                + np.sin(phi)\n                * (\n                    15\n                    + 8 * np.cos(varphi)\n                    - 11 * np.cos(2 * varphi)\n                    + 42 * np.sin(varphi)\n                    + 3 * np.sin(2 * varphi)\n                )\n            )\n        ) / 16\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n        \n\nclass TestSample:\n    """"""Tests that samples are properly calculated.""""""\n\n    def test_sample_dimensions(self, tensornet_device_2_wires):\n        """"""Tests if the samples returned by the sample function have\n        the correct dimensions\n        """"""\n\n        # Explicitly resetting is necessary as the internal\n        # state is set to None in __init__ and only properly\n        # initialized during reset\n        tensornet_device_2_wires.reset()\n\n        tensornet_device_2_wires.apply(\'RX\', wires=[0], par=[1.5708])\n        tensornet_device_2_wires.apply(\'RX\', wires=[1], par=[1.5708])\n\n        tensornet_device_2_wires.shots = 10\n        s1 = tensornet_device_2_wires.sample(\'PauliZ\', [0], [])\n        assert np.array_equal(s1.shape, (10,))\n\n        tensornet_device_2_wires.shots = 12\n        s2 = tensornet_device_2_wires.sample(\'PauliZ\', [1], [])\n        assert np.array_equal(s2.shape, (12,))\n\n        tensornet_device_2_wires.shots = 17\n        s3 = tensornet_device_2_wires.sample(\'CZ\', [0, 1], [])\n        assert np.array_equal(s3.shape, (17,))\n\n    def test_sample_values(self, tensornet_device_2_wires, tol):\n        """"""Tests if the samples returned by sample have\n        the correct values\n        """"""\n\n        # Explicitly resetting is necessary as the internal\n        # state is set to None in __init__ and only properly\n        # initialized during reset\n        tensornet_device_2_wires.reset()\n\n        tensornet_device_2_wires.apply(\'RX\', wires=[0], par=[1.5708])\n\n        s1 = tensornet_device_2_wires.sample(\'PauliZ\', [0], [])\n\n        # s1 should only contain 1 and -1, which is guaranteed if\n        # they square to 1\n        assert np.allclose(s1**2, 1, atol=tol, rtol=0)\n\n\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorSample:\n    """"""Test samped values from tensor product observables""""""\n\n    def test_paulix_pauliy(self, theta, phi, varphi, monkeypatch, tol):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3, shots=10000)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        with monkeypatch.context() as m:\n            m.setattr(""numpy.random.choice"", lambda x, y, p: (x, p))\n            s1, prob = dev.sample([""PauliX"", ""PauliY""], [[0], [2]], [[], [], []])\n\n        # s1 should only contain 1 and -1\n        assert np.allclose(s1 ** 2, 1, atol=tol, rtol=0)\n\n        mean = s1 @ prob\n        expected = np.sin(theta) * np.sin(phi) * np.sin(varphi)\n        assert np.allclose(mean, expected, atol=tol, rtol=0)\n\n        var = (s1 ** 2) @ prob - (s1 @ prob).real ** 2\n        expected = (\n            8 * np.sin(theta) ** 2 * np.cos(2 * varphi) * np.sin(phi) ** 2\n            - np.cos(2 * (theta - phi))\n            - np.cos(2 * (theta + phi))\n            + 2 * np.cos(2 * theta)\n            + 2 * np.cos(2 * phi)\n            + 14\n        ) / 16\n        assert np.allclose(var, expected, atol=tol, rtol=0)\n\n    def test_pauliz_hadamard(self, theta, phi, varphi, monkeypatch, tol):\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        with monkeypatch.context() as m:\n            m.setattr(""numpy.random.choice"", lambda x, y, p: (x, p))\n            s1, p = dev.sample([""PauliZ"", ""Hadamard"", ""PauliY""], [[0], [1], [2]], [[], [], []])\n\n        # s1 should only contain 1 and -1\n        assert np.allclose(s1 ** 2, 1, atol=tol, rtol=0)\n\n        mean = s1 @ p\n        expected = -(np.cos(varphi) * np.sin(phi) + np.sin(varphi) * np.cos(theta)) / np.sqrt(2)\n        assert np.allclose(mean, expected, atol=tol, rtol=0)\n\n        var = (s1 ** 2) @ p - (s1 @ p).real ** 2\n        expected = (\n            3\n            + np.cos(2 * phi) * np.cos(varphi) ** 2\n            - np.cos(2 * theta) * np.sin(varphi) ** 2\n            - 2 * np.cos(theta) * np.sin(phi) * np.sin(2 * varphi)\n        ) / 4\n        assert np.allclose(var, expected, atol=tol, rtol=0)\n\n    def test_hermitian(self, theta, phi, varphi, monkeypatch, tol):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.tensor"", wires=3)\n        dev.reset()\n        dev.apply(""RX"", wires=[0], par=[theta])\n        dev.apply(""RX"", wires=[1], par=[phi])\n        dev.apply(""RX"", wires=[2], par=[varphi])\n        dev.apply(""CNOT"", wires=[0, 1], par=[])\n        dev.apply(""CNOT"", wires=[1, 2], par=[])\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        with monkeypatch.context() as m:\n            m.setattr(""numpy.random.choice"", lambda x, y, p: (x, p))\n            s1, p = dev.sample([""PauliZ"", ""Hermitian""], [[0], [1, 2]], [[], [A]])\n\n        # s1 should only contain the eigenvalues of\n        # the hermitian matrix tensor product Z\n        Z = np.diag([1, -1])\n        eigvals = np.linalg.eigvalsh(np.kron(Z, A))\n        assert set(np.round(s1, 8)).issubset(set(np.round(eigvals, 8)))\n\n        mean = s1 @ p\n        expected = 0.5 * (\n            -6 * np.cos(theta) * (np.cos(varphi) + 1)\n            - 2 * np.sin(varphi) * (np.cos(theta) + np.sin(phi) - 2 * np.cos(phi))\n            + 3 * np.cos(varphi) * np.sin(phi)\n            + np.sin(phi)\n        )\n        assert np.allclose(mean, expected, atol=tol, rtol=0)\n\n        var = (s1 ** 2) @ p - (s1 @ p).real ** 2\n        expected = (\n            1057\n            - np.cos(2 * phi)\n            + 12 * (27 + np.cos(2 * phi)) * np.cos(varphi)\n            - 2 * np.cos(2 * varphi) * np.sin(phi) * (16 * np.cos(phi) + 21 * np.sin(phi))\n            + 16 * np.sin(2 * phi)\n            - 8 * (-17 + np.cos(2 * phi) + 2 * np.sin(2 * phi)) * np.sin(varphi)\n            - 8 * np.cos(2 * theta) * (3 + 3 * np.cos(varphi) + np.sin(varphi)) ** 2\n            - 24 * np.cos(phi) * (np.cos(phi) + 2 * np.sin(phi)) * np.sin(2 * varphi)\n            - 8\n            * np.cos(theta)\n            * (\n                4\n                * np.cos(phi)\n                * (\n                    4\n                    + 8 * np.cos(varphi)\n                    + np.cos(2 * varphi)\n                    - (1 + 6 * np.cos(varphi)) * np.sin(varphi)\n                )\n                + np.sin(phi)\n                * (\n                    15\n                    + 8 * np.cos(varphi)\n                    - 11 * np.cos(2 * varphi)\n                    + 42 * np.sin(varphi)\n                    + 3 * np.sin(2 * varphi)\n                )\n            )\n        ) / 16\n        assert np.allclose(var, expected, atol=tol, rtol=0)\n'"
tests/beta/test_default_tensor_tf.py,10,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests and integration tests for the :mod:`pennylane.plugin.Tensornet.tf` device.\n""""""\nfrom itertools import product\n\nimport numpy as np\nimport pytest\n\ntensornetwork = pytest.importorskip(""tensornetwork"", minversion=""0.1"")\ntensorflow = pytest.importorskip(""tensorflow"", minversion=""2.0"")\n\nimport pennylane as qml\nfrom pennylane.beta.plugins.default_tensor_tf import DefaultTensorTF\nfrom gate_data import I, X, Y, Z, H, CNOT, SWAP, CNOT, Toffoli, CSWAP\nfrom pennylane.qnodes import qnode, QNode\nfrom pennylane.qnodes.decorator import ALLOWED_INTERFACES, ALLOWED_DIFF_METHODS\n\nnp.random.seed(42)\n\n\n#####################################################\n# Test matrices\n#####################################################\n\nU = np.array(\n    [\n        [0.83645892 - 0.40533293j, -0.20215326 + 0.30850569j],\n        [-0.23889780 - 0.28101519j, -0.88031770 - 0.29832709j],\n    ]\n)\n\nU2 = np.array([[0, 1, 1, 1], [1, 0, 1, -1], [1, -1, 0, 1], [1, 1, -1, 0]]) / np.sqrt(3)\nA = np.array([[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]])\n\n\n#####################################################\n# Define standard qubit operations\n#####################################################\n\nphase_shift = lambda phi: np.array([[1, 0], [0, np.exp(1j * phi)]])\nrx = lambda theta: np.cos(theta / 2) * I + 1j * np.sin(-theta / 2) * X\nry = lambda theta: np.cos(theta / 2) * I + 1j * np.sin(-theta / 2) * Y\nrz = lambda theta: np.cos(theta / 2) * I + 1j * np.sin(-theta / 2) * Z\nrot = lambda a, b, c: rz(c) @ (ry(b) @ rz(a))\ncrz = lambda theta: np.array(\n    [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, np.exp(-1j * theta / 2), 0],\n        [0, 0, 0, np.exp(1j * theta / 2)],\n    ]\n)\n\n\nsingle_qubit = [(qml.PauliX, X), (qml.PauliY, Y), (qml.PauliZ, Z), (qml.Hadamard, H)]\n\n\nsingle_qubit_param = [(qml.PhaseShift, phase_shift), (qml.RX, rx), (qml.RY, ry), (qml.RZ, rz)]\ntwo_qubit = [(qml.CNOT, CNOT), (qml.SWAP, SWAP)]\ntwo_qubit_param = [(qml.CRZ, crz)]\nthree_qubit = [(qml.Toffoli, Toffoli), (qml.CSWAP, CSWAP)]\n\n\n#####################################################\n# Fixtures\n#####################################################\n\n\n@pytest.fixture\ndef init_state(scope=""session""):\n    """"""Generates a random initial state""""""\n\n    def _init_state(n):\n        """"""random initial state""""""\n        state = np.random.random([2 ** n]) + np.random.random([2 ** n]) * 1j\n        state /= np.linalg.norm(state)\n        return state\n\n    return _init_state\n\n\n#####################################################\n# Unit tests\n#####################################################\n\n\nclass TestApply:\n    """"""Test application of PennyLane operations.""""""\n\n    def test_basis_state(self, tol):\n        """"""Test basis state initialization""""""\n        dev = DefaultTensorTF(wires=4)\n        state = np.array([0, 0, 1, 0])\n\n        dev.execute([qml.BasisState(state, wires=[0, 1, 2, 3])], [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = np.zeros([2 ** 4])\n        expected[np.ravel_multi_index(state, [2] * 4)] = 1\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_qubit_state_vector(self, init_state, tol):\n        """"""Test qubit state vector application""""""\n        dev = DefaultTensorTF(wires=1)\n        state = init_state(1)\n\n        dev.execute([qml.QubitStateVector(state, wires=[0])], [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_invalid_qubit_state_vector(self):\n        """"""Test that an exception is raised if the state\n        vector is the wrong size""""""\n        dev = DefaultTensorTF(wires=2)\n        state = np.array([0, 123.432])\n\n        with pytest.raises(ValueError, match=r""State vector must be of length 2\\*\\*wires""):\n            dev.execute([qml.QubitStateVector(state, wires=[0])], [], {})\n\n    @pytest.mark.parametrize(""op,mat"", single_qubit)\n    def test_single_qubit_no_parameters(self, init_state, op, mat, tol):\n        """"""Test non-parametrized single qubit operations""""""\n        dev = DefaultTensorTF(wires=1)\n        state = init_state(1)\n\n        queue = [qml.QubitStateVector(state, wires=[0])]\n        queue += [op(wires=0)]\n        dev.execute(queue, [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = mat @ state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""theta"", [0.5432, -0.232])\n    @pytest.mark.parametrize(""op,func"", single_qubit_param)\n    def test_single_qubit_parameters(self, init_state, op, func, theta, tol):\n        """"""Test parametrized single qubit operations""""""\n        dev = DefaultTensorTF(wires=1)\n        state = init_state(1)\n\n        queue = [qml.QubitStateVector(state, wires=[0])]\n        queue += [op(theta, wires=0)]\n        dev.execute(queue, [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = func(theta) @ state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_rotation(self, init_state, tol):\n        """"""Test three axis rotation gate""""""\n        dev = DefaultTensorTF(wires=1)\n        state = init_state(1)\n\n        a = 0.542\n        b = 1.3432\n        c = -0.654\n\n        queue = [qml.QubitStateVector(state, wires=[0])]\n        queue += [qml.Rot(a, b, c, wires=0)]\n        dev.execute(queue, [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = rot(a, b, c) @ state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""op,mat"", two_qubit)\n    def test_two_qubit_no_parameters(self, init_state, op, mat, tol):\n        """"""Test non-parametrized two qubit operations""""""\n        dev = DefaultTensorTF(wires=2)\n        state = init_state(2)\n\n        queue = [qml.QubitStateVector(state, wires=[0, 1])]\n        queue += [op(wires=[0, 1])]\n        dev.execute(queue, [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = mat @ state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""mat"", [U, U2])\n    def test_qubit_unitary(self, init_state, mat, tol):\n        """"""Test application of arbitrary qubit unitaries""""""\n        N = int(np.log2(len(mat)))\n        dev = DefaultTensorTF(wires=N)\n        state = init_state(N)\n\n        queue = [qml.QubitStateVector(state, wires=range(N))]\n        queue += [qml.QubitUnitary(mat, wires=range(N))]\n        dev.execute(queue, [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = mat @ state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""op, mat"", three_qubit)\n    def test_three_qubit_no_parameters(self, init_state, op, mat, tol):\n        """"""Test non-parametrized three qubit operations""""""\n        dev = DefaultTensorTF(wires=3)\n        state = init_state(3)\n\n        queue = [qml.QubitStateVector(state, wires=[0, 1, 2])]\n        queue += [op(wires=[0, 1, 2])]\n        dev.execute(queue, [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = mat @ state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""theta"", [0.5432, -0.232])\n    @pytest.mark.parametrize(""op,func"", two_qubit_param)\n    def test_two_qubit_parameters(self, init_state, op, func, theta, tol):\n        """"""Test two qubit parametrized operations""""""\n        dev = DefaultTensorTF(wires=2)\n        state = init_state(2)\n\n        queue = [qml.QubitStateVector(state, wires=[0, 1])]\n        queue += [op(theta, wires=[0, 1])]\n        dev.execute(queue, [], {})\n\n        res = dev._state.numpy().flatten()\n        expected = func(theta) @ state\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\nTHETA = np.linspace(0.11, 1, 3)\nPHI = np.linspace(0.32, 1, 3)\nVARPHI = np.linspace(0.02, 1, 3)\n\n# test data; each tuple is of the form (GATE, OBSERVABLE, EXPECTED)\nsingle_wire_expval_test_data = [\n    (qml.RX, qml.Identity, lambda t, p: np.array([1, 1])),\n    (qml.RX, qml.PauliZ, lambda t, p: np.array([np.cos(t), np.cos(t) * np.cos(p)])),\n    (qml.RY, qml.PauliX, lambda t, p: np.array([np.sin(t) * np.sin(p), np.sin(p)])),\n    (qml.RX, qml.PauliY, lambda t, p: np.array([0, -np.cos(t) * np.sin(p)])),\n    (\n        qml.RY,\n        qml.Hadamard,\n        lambda t, p: np.array(\n            [np.sin(t) * np.sin(p) + np.cos(t), np.cos(t) * np.cos(p) + np.sin(p)]\n        )\n        / np.sqrt(2),\n    ),\n]\n\n\n@pytest.mark.parametrize(""theta, phi"", list(zip(THETA, PHI)))\nclass TestExpval:\n    """"""Test expectation values""""""\n\n    @pytest.mark.parametrize(""gate,obs,expected"", single_wire_expval_test_data)\n    def test_single_wire_expectation(self, gate, obs, expected, theta, phi, tol):\n        """"""Test that identity expectation value (i.e. the trace) is 1""""""\n        dev = DefaultTensorTF(wires=2)\n        queue = [gate(theta, wires=0), gate(phi, wires=1), qml.CNOT(wires=[0, 1])]\n        observables = [obs(wires=[i]) for i in range(2)]\n\n        for i in range(len(observables)):\n            observables[i].return_type = qml.operation.Expectation\n\n        res = dev.execute(queue, observables, {})\n        assert np.allclose(res, expected(theta, phi), atol=tol, rtol=0)\n\n    def test_hermitian_expectation(self, theta, phi, tol):\n        """"""Test that arbitrary Hermitian expectation values are correct""""""\n        dev = DefaultTensorTF(wires=2)\n        queue = [qml.RY(theta, wires=0), qml.RY(phi, wires=1), qml.CNOT(wires=[0, 1])]\n        observables = [qml.Hermitian(A, wires=[i]) for i in range(2)]\n\n        for i in range(len(observables)):\n            observables[i].return_type = qml.operation.Expectation\n\n        res = dev.execute(queue, observables, {})\n\n        a = A[0, 0]\n        re_b = A[0, 1].real\n        d = A[1, 1]\n        ev1 = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\n        ev2 = ((a - d) * np.cos(theta) * np.cos(phi) + 2 * re_b * np.sin(phi) + a + d) / 2\n        expected = np.array([ev1, ev2])\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_multi_mode_hermitian_expectation(self, theta, phi, tol):\n        """"""Test that arbitrary multi-mode Hermitian expectation values are correct""""""\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        dev = DefaultTensorTF(wires=2)\n        queue = [qml.RY(theta, wires=0), qml.RY(phi, wires=1), qml.CNOT(wires=[0, 1])]\n        observables = [qml.Hermitian(A, wires=[0, 1])]\n\n        for i in range(len(observables)):\n            observables[i].return_type = qml.operation.Expectation\n\n        res = dev.execute(queue, observables, {})\n\n        # below is the analytic expectation value for this circuit with arbitrary\n        # Hermitian observable A\n        expected = 0.5 * (\n            6 * np.cos(theta) * np.sin(phi)\n            - np.sin(theta) * (8 * np.sin(phi) + 7 * np.cos(phi) + 3)\n            - 2 * np.sin(phi)\n            - 6 * np.cos(phi)\n            - 6\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\n@pytest.mark.parametrize(""theta, phi"", list(zip(THETA, PHI)))\nclass TestVar:\n    """"""Tests for the variance""""""\n\n    def test_var(self, theta, phi, tol):\n        """"""Tests for variance calculation""""""\n        dev = DefaultTensorTF(wires=1)\n        # test correct variance for <Z> of a rotated state\n\n        queue = [qml.RX(phi, wires=0), qml.RY(theta, wires=0)]\n        observables = [qml.PauliZ(wires=[0])]\n\n        for i in range(len(observables)):\n            observables[i].return_type = qml.operation.Variance\n\n        res = dev.execute(queue, observables, {})\n        expected = 0.25 * (3 - np.cos(2 * theta) - 2 * np.cos(theta) ** 2 * np.cos(2 * phi))\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_var_hermitian(self, theta, phi, tol):\n        """"""Tests for variance calculation using an arbitrary Hermitian observable""""""\n        dev = DefaultTensorTF(wires=2)\n\n        # test correct variance for <H> of a rotated state\n        H = np.array([[4, -1 + 6j], [-1 - 6j, 2]])\n        queue = [qml.RX(phi, wires=0), qml.RY(theta, wires=0)]\n        observables = [qml.Hermitian(H, wires=[0])]\n\n        for i in range(len(observables)):\n            observables[i].return_type = qml.operation.Variance\n\n        res = dev.execute(queue, observables, {})\n        expected = 0.5 * (\n            2 * np.sin(2 * theta) * np.cos(phi) ** 2\n            + 24 * np.sin(phi) * np.cos(phi) * (np.sin(theta) - np.cos(theta))\n            + 35 * np.cos(2 * phi)\n            + 39\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\n#####################################################\n# Integration tests\n#####################################################\n\n\nclass TestQNodeIntegration:\n    """"""Integration tests for default.tensor.tf. This test ensures it integrates\n    properly with the PennyLane UI, in particular the new QNode.""""""\n\n    def test_load_tensornet_tf_device(self):\n        """"""Test that the tensor network plugin loads correctly""""""\n        dev = qml.device(""default.tensor.tf"", wires=2)\n        assert dev.num_wires == 2\n        assert dev.shots == 1000\n        assert dev.analytic\n        assert dev.short_name == ""default.tensor.tf""\n        assert dev.capabilities()[""provides_jacobian""]\n        assert dev.capabilities()[""passthru_interface""] == ""tf""\n\n    @pytest.mark.parametrize(""decorator"", [qml.qnode, qnode])\n    def test_qubit_circuit(self, decorator, tol):\n        """"""Test that the tensor network plugin provides correct\n        result for a simple circuit using the old QNode.\n        This test is parametrized for both the new and old QNode decorator.""""""\n        p = 0.543\n\n        dev = qml.device(""default.tensor.tf"", wires=1)\n\n        @decorator(dev)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliY(0))\n\n        expected = -np.sin(p)\n\n        assert np.isclose(circuit(p), expected, atol=tol, rtol=0)\n\n    def test_cannot_overwrite_state(self):\n        """"""Tests that _state is a property and cannot be overwritten.""""""\n        dev = qml.device(""default.tensor.tf"", wires=2)\n\n        with pytest.raises(AttributeError, match=""can\'t set attribute""):\n            dev._state = np.array([[1, 0], [0, 0]])\n\n    def test_correct_state(self, tol):\n        """"""Test that the device state is correct after applying a\n        quantum function on the device""""""\n\n        dev = qml.device(""default.tensor.tf"", wires=2)\n\n        state = dev._state\n\n        expected = np.array([[1, 0], [0, 0]])\n        assert np.allclose(state, expected, atol=tol, rtol=0)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.Hadamard(wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        circuit()\n        state = dev._state\n\n        expected = np.array([[1, 0], [1, 0]]) / np.sqrt(2)\n        assert np.allclose(state, expected, atol=tol, rtol=0)\n\n\nclass TestJacobianIntegration:\n    """"""Tests for the Jacobian calculation""""""\n\n    def test_jacobian_variable_multiply(self, torch_support, tol):\n        """"""Test that qnode.jacobian applied to the tensornet.tf device\n        gives the correct result in the case of parameters multiplied by scalars""""""\n        x = 0.43316321\n        y = 0.2162158\n        z = 0.75110998\n\n        dev = qml.device(""default.tensor.tf"", wires=1)\n\n        @qnode(dev)\n        def circuit(p):\n            qml.RX(3 * p[0], wires=0)\n            qml.RY(p[1], wires=0)\n            qml.RX(p[2] / 2, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        res = circuit([x, y, z])\n        expected = np.cos(3 * x) * np.cos(y) * np.cos(z / 2) - np.sin(3 * x) * np.sin(z / 2)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        res = circuit.jacobian([[x, y, z]])\n        expected = np.array(\n            [\n                -3 * (np.sin(3 * x) * np.cos(y) * np.cos(z / 2) + np.cos(3 * x) * np.sin(z / 2)),\n                -np.cos(3 * x) * np.sin(y) * np.cos(z / 2),\n                -0.5 * (np.sin(3 * x) * np.cos(z / 2) + np.cos(3 * x) * np.cos(y) * np.sin(z / 2)),\n            ]\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_jacobian_repeated(self, torch_support, tol):\n        """"""Test that qnode.jacobian applied to the tensornet.tf device\n        gives the correct result in the case of repeated parameters""""""\n        x = 0.43316321\n        y = 0.2162158\n        z = 0.75110998\n        p = np.array([x, y, z])\n        dev = qml.device(""default.tensor.tf"", wires=1)\n\n        @qnode(dev)\n        def circuit(x):\n            qml.RX(x[1], wires=0)\n            qml.Rot(x[0], x[1], x[2], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        res = circuit(p)\n        expected = np.cos(y) ** 2 - np.sin(x) * np.sin(y) ** 2\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        res = circuit.jacobian([p])\n        expected = np.array(\n            [-np.cos(x) * np.sin(y) ** 2, -2 * (np.sin(x) + 1) * np.sin(y) * np.cos(y), 0]\n        )\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""diff_method"", [""parameter-shift"", ""finite-diff"", ""device""])\n    def test_jacobian_agrees(self, diff_method, torch_support, tol):\n        """"""Test that qnode.jacobian applied to the tensornet.tf device\n        returns the same result as default.qubit.""""""\n        p = np.array([0.43316321, 0.2162158, 0.75110998, 0.94714242])\n\n        def circuit(x):\n            for i in range(0, len(p), 2):\n                qml.RX(x[i], wires=0)\n                qml.RY(x[i + 1], wires=1)\n            for i in range(2):\n                qml.CNOT(wires=[i, i + 1])\n            return qml.expval(qml.PauliZ(0)), qml.var(qml.PauliZ(1))\n\n        dev1 = qml.device(""default.tensor.tf"", wires=3)\n        dev2 = qml.device(""default.qubit"", wires=3)\n\n        circuit1 = QNode(circuit, dev1, diff_method=diff_method)\n        circuit2 = QNode(circuit, dev2, diff_method=""parameter-shift"")\n\n        assert np.allclose(circuit1(p), circuit2(p), atol=tol, rtol=0)\n        assert np.allclose(circuit1.jacobian([p]), circuit2.jacobian([p]), atol=tol, rtol=0)\n\n\nclass TestInterfaceDeviceIntegration:\n    """"""Integration tests for default.tensor.tf. This test class ensures it integrates\n    properly with the PennyLane UI, in particular the classical machine learning\n    interfaces, when using the \'device\' differentiation method.""""""\n\n    a = -0.234\n    b = 0.654\n    p = [a, b]\n\n    # the analytic result of evaluating circuit(a, b)\n    expected_cost = 0.5 * (np.cos(a) * np.cos(b) + np.cos(a) - np.cos(b) + 1)\n\n    # the analytic result of evaluating grad(circuit(a, b))\n    expected_grad = np.array(\n        [-0.5 * np.sin(a) * (np.cos(b) + 1), 0.5 * np.sin(b) * (1 - np.cos(a))]\n    )\n\n    @pytest.fixture\n    def circuit(self, interface, torch_support):\n        """"""Fixture to create cost function for the test class""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        dev = qml.device(""default.tensor.tf"", wires=2)\n\n        @qnode(dev, diff_method=""device"", interface=interface)\n        def circuit_fn(a, b):\n            qml.RX(a, wires=0)\n            qml.CRX(b, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n        return circuit_fn\n\n    @pytest.mark.parametrize(""interface"", [""autograd""])\n    def test_autograd_interface(self, circuit, interface, tol):\n        """"""Tests that the gradient of the circuit fixture above is correct\n        using the autograd interface""""""\n        res = circuit(*self.p)\n        assert np.allclose(res, self.expected_cost, atol=tol, rtol=0)\n\n        grad_fn = qml.grad(circuit, argnum=[0, 1])\n        res = np.asarray(grad_fn(*self.p))\n        assert np.allclose(res, self.expected_grad, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""interface"", [""torch""])\n    def test_torch_interface(self, circuit, interface, tol):\n        """"""Tests that the gradient of the circuit fixture above is correct\n        using the Torch interface""""""\n        import torch\n        from torch.autograd import Variable\n\n        params = Variable(torch.tensor(self.p), requires_grad=True)\n        res = circuit(*params)\n        assert np.allclose(res.detach().numpy(), self.expected_cost, atol=tol, rtol=0)\n\n        res.backward()\n        res = params.grad\n        assert np.allclose(res.detach().numpy(), self.expected_grad, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""interface"", [""tf""])\n    def test_tf_interface(self, circuit, interface, tol):\n        """"""Tests that the gradient of the circuit fixture above is correct\n        using the TensorFlow interface""""""\n        import tensorflow as tf\n\n        a = tf.Variable(self.a, dtype=tf.float64)\n        b = tf.Variable(self.b, dtype=tf.float64)\n\n        with tf.GradientTape() as tape:\n            tape.watch([a, b])\n            res = circuit(a, b)\n\n        assert np.allclose(res.numpy(), self.expected_cost, atol=tol, rtol=0)\n\n        res = tape.gradient(res, [a, b])\n        assert np.allclose(res, self.expected_grad, atol=tol, rtol=0)\n\n\nclass TestHybridInterfaceDeviceIntegration:\n    """"""Integration tests for default.tensor.tf. This test class ensures it integrates\n    properly with the PennyLane UI, in particular the classical machine learning\n    interfaces in the case of hybrid-classical computation, when using the\n    device differentiation option.""""""\n\n    theta = 0.543\n    phi = -0.234\n    lam = 0.654\n    p = [theta, phi, lam]\n\n    # the analytic result of evaluating cost(p)\n    expected_cost = (np.sin(lam) * np.sin(phi) - np.cos(theta) * np.cos(lam) * np.cos(phi)) ** 2\n\n    # the analytic result of evaluating grad(cost(p))\n    expected_grad = (\n        np.array(\n            [\n                np.sin(theta) * np.cos(lam) * np.cos(phi),\n                np.cos(theta) * np.cos(lam) * np.sin(phi) + np.sin(lam) * np.cos(phi),\n                np.cos(theta) * np.sin(lam) * np.cos(phi) + np.cos(lam) * np.sin(phi),\n            ]\n        )\n        * 2\n        * (np.sin(lam) * np.sin(phi) - np.cos(theta) * np.cos(lam) * np.cos(phi))\n    )\n\n    @pytest.fixture\n    def cost(self, diff_method, interface, torch_support):\n        """"""Fixture to create cost function for the test class""""""\n        dev = qml.device(""default.tensor.tf"", wires=1)\n\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        @qnode(dev, diff_method=diff_method, interface=interface)\n        def circuit(x, weights, w=None):\n            """"""In this example, a mixture of scalar\n            arguments, array arguments, and keyword arguments are used.""""""\n            qml.QubitStateVector(1j * np.array([1, -1]) / np.sqrt(2), wires=w)\n            # the parameterized gate is one that gets decomposed\n            # via a template\n            qml.U3(x, weights[0], weights[1], wires=w)\n            return qml.expval(qml.PauliX(w))\n\n        def cost_fn(params):\n            """"""Perform some classical processing""""""\n            return circuit(params[0], params[1:], w=0) ** 2\n\n        return cost_fn\n\n    @pytest.mark.parametrize(""interface"", [""autograd""])\n    @pytest.mark.parametrize(""diff_method"", [""device""])\n    def test_autograd_interface(self, cost, interface, diff_method, tol):\n        """"""Tests that the gradient of an arbitrary U3 gate is correct\n        using the autograd interface""""""\n        res = cost(self.p)\n        assert np.allclose(res, self.expected_cost, atol=tol, rtol=0)\n\n        grad_fn = qml.grad(cost, argnum=[0])\n        res = np.asarray(grad_fn(self.p))\n        assert np.allclose(res, self.expected_grad, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""interface"", [""torch""])\n    @pytest.mark.parametrize(""diff_method"", [""device""])\n    def test_torch_interface(self, cost, interface, diff_method, tol):\n        """"""Tests that the gradient of an arbitrary U3 gate is correct\n        using the Torch interface""""""\n        import torch\n        from torch.autograd import Variable\n\n        params = Variable(torch.tensor(self.p), requires_grad=True)\n        res = cost(params)\n        assert np.allclose(res.detach().numpy(), self.expected_cost, atol=tol, rtol=0)\n\n        res.backward()\n        res = params.grad\n        assert np.allclose(res.detach().numpy(), self.expected_grad, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""interface"", [""tf""])\n    @pytest.mark.parametrize(""diff_method"", [""device""])\n    def test_tf_interface_device_diff(self, cost, interface, diff_method, tol):\n        """"""Tests that the gradient of an arbitrary U3 gate is correct\n        using the TensorFlow interface""""""\n        import tensorflow as tf\n\n        params = tf.Variable(self.p, dtype=tf.float64)\n\n        with tf.GradientTape() as tape:\n            tape.watch(params)\n            res = cost(params)\n\n        assert np.allclose(res.numpy(), self.expected_cost, atol=tol, rtol=0)\n\n        res = tape.gradient(res, params)\n        assert np.allclose(res.numpy(), self.expected_grad, atol=tol, rtol=0)\n\n    @pytest.fixture\n    def cost_with_decomposition(self, diff_method, interface, torch_support):\n        """"""Fixture to create cost function for the test class""""""\n        dev = qml.device(""default.tensor.tf"", wires=1)\n\n        @qnode(dev, diff_method=diff_method, interface=interface)\n        def circuit(x, weights, w=None):\n            """"""In this example, a mixture of scalar\n            arguments, array arguments, and keyword arguments are used.""""""\n            qml.QubitStateVector(1j * np.array([1, -1]) / np.sqrt(2), wires=w)\n            # the parameterized gate is one that gets decomposed\n            # via a template\n            qml.U3.decomposition(x, weights[0], weights[1], wires=w)   # <--- decomposition is used\n            return qml.expval(qml.PauliX(w))\n\n        def cost_fn(params):\n            """"""Perform some classical processing""""""\n            return circuit(params[0], params[1:], w=0) ** 2\n\n        return cost_fn\n\n    @pytest.mark.parametrize(""interface"", [""tf""])\n    @pytest.mark.parametrize(""diff_method"", [""backprop""])\n    def test_tf_interface_classical_diff(self, cost_with_decomposition, interface, diff_method, tol):\n        """"""Tests that the gradient of an arbitrary U3 gate (that gets\n        decomposed) is correct using the TensorFlow interface and the classical\n        diff method""""""\n        # TODO: once the decomposition of operations and the PassThruQNode are\n        # compatible, merge this case into the previous one\n        import tensorflow as tf\n\n        params = tf.Variable(self.p, dtype=tf.float64)\n\n        with tf.GradientTape() as tape:\n            tape.watch(params)\n            res = cost_with_decomposition(params)\n\n        assert np.allclose(res.numpy(), self.expected_cost, atol=tol, rtol=0)\n\n        res = tape.gradient(res, params)\n        assert np.allclose(res.numpy(), self.expected_grad, atol=tol, rtol=0)\n\n\n    def test_error_classical_diff_torch(self, torch_support, tol):\n        """"""Tests that an error is raised if for the classical differentiation\n        method when using the Torch interface""""""\n        if not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        import torch\n        from torch.autograd import Variable\n\n        interface = ""torch""\n        diff_method = ""backprop""\n\n        params = Variable(torch.tensor(self.p), requires_grad=True)\n\n        def cost_raising_error(params):\n            # Cost within the test case such that the error can be caught\n            dev = qml.device(""default.tensor.tf"", wires=1)\n\n            if interface == ""torch"" and not torch_support:\n                pytest.skip(""Skipped, no torch support"")\n\n            @qnode(dev, diff_method=diff_method, interface=interface)\n            def circuit(x, w=None):\n                qml.RZ(x, wires=w)\n                return qml.expval(qml.PauliX(w))\n\n            return circuit(params[0], w=0)\n\n        with pytest.raises(ValueError, match=""Device default.tensor.tf only supports diff_method=\'backprop\' when using the tf interface""):\n            res = cost_raising_error(params)\n\n    def test_error_classical_diff_autograd(self, tol):\n        """"""Tests that an error is raised if for the classical differentiation\n        method when using the autograd interface""""""\n        interface = ""autograd""\n        diff_method = ""backprop""\n\n        params = self.p\n\n        def cost_raising_error(params):\n            # Cost within the test case such that the error can be caught\n            dev = qml.device(""default.tensor.tf"", wires=1)\n\n            @qnode(dev, diff_method=diff_method, interface=interface)\n            def circuit(x, w=None):\n                qml.RZ(x, wires=w)\n                return qml.expval(qml.PauliX(w))\n\n            return circuit(params[0], w=0)\n\n        with pytest.raises(ValueError, match=""Device default.tensor.tf only supports diff_method=\'backprop\' when using the tf interface""):\n            res = cost_raising_error(params)\n'"
tests/circuit_drawer/test_circuit_drawer.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.circuit_drawer` module.\n""""""\nfrom unittest.mock import Mock\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.circuit_drawer import CircuitDrawer\nfrom pennylane.circuit_drawer.circuit_drawer import _remove_duplicates\nfrom pennylane.circuit_drawer.grid import Grid, _transpose\n\n\nclass TestFunctions:\n    """"""Test the helper functions.""""""\n\n    @pytest.mark.parametrize(\n        ""input,expected_output"",\n        [\n            ([1, 1, 1, 2, 2, 2, 3, 2, 3], [1, 2, 3]),\n            ([""a"", ""b"", ""c"", ""c"", ""a"", ""d""], [""a"", ""b"", ""c"", ""d""]),\n            ([1, 2, 3, 4], [1, 2, 3, 4]),\n        ],\n    )\n    def test_remove_duplicates(self, input, expected_output):\n        """"""Test the function _remove_duplicates.""""""\n        assert _remove_duplicates(input) == expected_output\n\n\nop_CNOT21 = qml.CNOT(wires=[2, 1])\nop_SWAP03 = qml.SWAP(wires=[0, 3])\nop_SWAP12 = qml.SWAP(wires=[1, 2])\nop_X0 = qml.PauliX(0)\nop_CRX20 = qml.CRX(2.3, wires=[2, 0])\nop_Z3 = qml.PauliZ(3)\n\ndummy_raw_operation_grid = [\n    [None, op_SWAP03, op_X0, op_CRX20],\n    [op_CNOT21, op_SWAP12, None, None],\n    [op_CNOT21, op_SWAP12, None, op_CRX20],\n    [op_Z3, op_SWAP03, None, None],\n]\n\ndummy_raw_observable_grid = [\n    [qml.sample(qml.Hermitian(2 * np.eye(2), wires=[0]))],\n    [None],\n    [qml.expval(qml.PauliY(wires=[2]))],\n    [qml.var(qml.Hadamard(wires=[3]))],\n]\n\n\n@pytest.fixture\ndef dummy_circuit_drawer():\n    """"""A dummy CircuitDrawer instance.""""""\n    return CircuitDrawer(dummy_raw_operation_grid, dummy_raw_observable_grid)\n\n\ndef assert_nested_lists_equal(list1, list2):\n    """"""Assert that two nested lists are equal.\n\n    Args:\n        list1 (list[list[Any]]): The first list to be compared\n        list2 (list[list[Any]]): The second list to be compared\n    """"""\n    # pylint: disable=protected-access\n    for (obj1, obj2) in zip(qml.utils._flatten(list1), qml.utils._flatten(list2)):\n        assert obj1 == obj2\n\n\ndef to_layer(operation_list, num_wires):\n    """"""Convert the given list of operations to a layer.\n\n    Args:\n        operation_list (list[~.Operation]): List of Operations in the layer\n        num_wires (int): Number of wires in the system\n\n    Returns:\n        list[Union[~.Operation,None]]: The corresponding layer\n    """"""\n    layer = [None] * num_wires\n\n    for op in operation_list:\n        for wire in op.wires.tolist():\n            layer[wire] = op\n\n    return layer\n\n\ndef to_grid(layer_list, num_wires):\n    """"""Convert the given list of operations per layer to a Grid.\n\n    Args:\n        layer_list (list[list[~.Operation]]): List of layers in terms of Operations\n        num_wires (int): Number of wires in the system\n\n    Returns:\n        ~.Grid: The corresponding Operation grid\n    """"""\n    grid = Grid(_transpose([to_layer(layer_list[0], num_wires)]))\n\n    for i in range(1, len(layer_list)):\n        grid.append_layer(to_layer(layer_list[i], num_wires))\n\n    return grid\n\n\nclass TestCircuitDrawer:\n    """"""Test the CircuitDrawer class.""""""\n\n    def test_resolve_representation(self, dummy_circuit_drawer):\n        """"""Test that resolve_representation calls the representation resolver with the proper arguments.""""""\n\n        dummy_circuit_drawer.representation_resolver.element_representation = Mock(\n            return_value=""Test""\n        )\n\n        dummy_circuit_drawer.resolve_representation(Grid(dummy_raw_operation_grid), Grid())\n\n        args_tuples = [\n            call[0]\n            for call in dummy_circuit_drawer.representation_resolver.element_representation.call_args_list\n        ]\n\n        for idx, wire in enumerate(dummy_raw_operation_grid):\n            for op in wire:\n                assert (op, idx) in args_tuples\n\n    interlocking_multiwire_gate_grid = to_grid(\n        [[qml.CNOT(wires=[0, 4]), qml.CNOT(wires=[1, 5]), qml.Toffoli(wires=[2, 3, 6])]], 7\n    )\n    interlocking_multiwire_gate_representation_grid = Grid(\n        [\n            [""\xe2\x95\xad"", """", """"],\n            [""\xe2\x94\x82"", ""\xe2\x95\xad"", """"],\n            [""\xe2\x94\x82"", ""\xe2\x94\x82"", ""\xe2\x95\xad""],\n            [""\xe2\x94\x82"", ""\xe2\x94\x82"", ""\xe2\x94\x9c""],\n            [""\xe2\x95\xb0"", ""\xe2\x94\x82"", ""\xe2\x94\x82""],\n            ["""", ""\xe2\x95\xb0"", ""\xe2\x94\x82""],\n            ["""", """", ""\xe2\x95\xb0""],\n        ]\n    )\n\n    multiwire_and_single_wire_gate_grid = to_grid(\n        [[qml.Toffoli(wires=[0, 3, 4]), qml.PauliX(wires=[1]), qml.Hadamard(wires=[2])]], 5\n    )\n    multiwire_and_single_wire_gate_representation_grid = Grid([[""\xe2\x95\xad""], [""\xe2\x94\x82""], [""\xe2\x94\x82""], [""\xe2\x94\x9c""], [""\xe2\x95\xb0""]])\n\n    all_wire_state_preparation_grid = to_grid(\n        [[qml.BasisState(np.array([0, 1, 0, 0, 1, 1]), wires=[0, 1, 2, 3, 4, 5])]], 6\n    )\n    all_wire_state_preparation_representation_grid = Grid(\n        [[""\xe2\x95\xad""], [""\xe2\x94\x9c""], [""\xe2\x94\x9c""], [""\xe2\x94\x9c""], [""\xe2\x94\x9c""], [""\xe2\x95\xb0""]]\n    )\n\n    multiwire_gate_grid = to_grid(\n        [[qml.CNOT(wires=[0, 1]), qml.PauliX(2), qml.CNOT(wires=[3, 4])]], 5\n    )\n\n    multiwire_gate_representation_grid = Grid([[""\xe2\x95\xad""], [""\xe2\x95\xb0""], [""""], [""\xe2\x95\xad""], [""\xe2\x95\xb0""],])\n\n    multi_and_single_wire_gate_grid = to_grid(\n        [\n            [\n                qml.CNOT(wires=[0, 1]),\n                qml.PauliX(2),\n                qml.PauliX(4),\n                qml.CNOT(wires=[3, 5]),\n                qml.Hadamard(6),\n            ]\n        ],\n        7,\n    )\n\n    multi_and_single_wire_gate_representation_grid = Grid(\n        [[""\xe2\x95\xad""], [""\xe2\x95\xb0""], [""""], [""\xe2\x95\xad""], [""\xe2\x94\x82""], [""\xe2\x95\xb0""], [""""],]\n    )\n\n    @pytest.mark.parametrize(\n        ""grid,target_representation_grid"",\n        [\n            (interlocking_multiwire_gate_grid, interlocking_multiwire_gate_representation_grid),\n            (\n                multiwire_and_single_wire_gate_grid,\n                multiwire_and_single_wire_gate_representation_grid,\n            ),\n            (all_wire_state_preparation_grid, all_wire_state_preparation_representation_grid),\n            (multiwire_gate_grid, multiwire_gate_representation_grid),\n            (multi_and_single_wire_gate_grid, multi_and_single_wire_gate_representation_grid),\n        ],\n    )\n    def test_resolve_decorations(self, dummy_circuit_drawer, grid, target_representation_grid):\n        """"""Test that decorations are properly resolved.""""""\n        dummy_circuit_drawer.make_wire_conversion_dicts(grid.raw_grid, [[]])\n        representation_grid = Grid()\n        dummy_circuit_drawer.resolve_decorations(grid, representation_grid)\n\n        assert_nested_lists_equal(representation_grid.raw_grid, target_representation_grid.raw_grid)\n\n    CNOT04 = qml.CNOT(wires=[0, 4])\n    CNOT15 = qml.CNOT(wires=[1, 5])\n    Toffoli236 = qml.Toffoli(wires=[2, 3, 6])\n\n    interlocking_CNOT_grid = to_grid([[CNOT04, CNOT15, Toffoli236]], 7)\n    moved_interlocking_CNOT_grid = to_grid([[Toffoli236], [CNOT15], [CNOT04]], 7)\n\n    SWAP02 = qml.SWAP(wires=[0, 2])\n    SWAP35 = qml.SWAP(wires=[3, 5])\n    SWAP14 = qml.SWAP(wires=[1, 4])\n    SWAP24 = qml.SWAP(wires=[2, 4])\n\n    interlocking_SWAP_grid = to_grid([[SWAP02, SWAP35, SWAP14], [SWAP24]], 6)\n    moved_interlocking_SWAP_grid = to_grid([[SWAP35], [SWAP14], [SWAP02], [SWAP24]], 6)\n\n    @pytest.mark.parametrize(\n        ""grid,target_grid"",\n        [\n            (interlocking_CNOT_grid, moved_interlocking_CNOT_grid),\n            (interlocking_SWAP_grid, moved_interlocking_SWAP_grid),\n        ],\n    )\n    def test_move_multi_wire_gates(self, dummy_circuit_drawer, grid, target_grid):\n        """"""Test that decorations are properly resolved.""""""\n\n        operator_grid = grid.copy()\n        dummy_circuit_drawer.move_multi_wire_gates(operator_grid)\n\n        assert_nested_lists_equal(operator_grid.raw_grid, target_grid.raw_grid)\n\n\n@pytest.fixture\ndef parameterized_qubit_qnode():\n    """"""A parametrized qubit ciruit.""""""\n\n    def qfunc(a, b, c, angles):\n        qml.RX(a, wires=0)\n        qml.RX(b, wires=1)\n        qml.PauliZ(1)\n        qml.CNOT(wires=[0, 1]).inv()\n        qml.CRY(b, wires=[3, 1])\n        qml.RX(angles[0], wires=0)\n        qml.RX(4 * angles[1], wires=1)\n        qml.PhaseShift(17 / 9 * c, wires=2)\n        qml.RZ(b, wires=3)\n        qml.RX(angles[2], wires=2).inv()\n        qml.CRY(0.3589, wires=[3, 1]).inv()\n        qml.CSWAP(wires=[4, 2, 1]).inv()\n        qml.QubitUnitary(np.eye(2), wires=[2])\n        qml.Toffoli(wires=[0, 2, 1])\n        qml.CNOT(wires=[0, 2])\n        qml.PauliZ(wires=[1])\n        qml.PauliZ(wires=[1]).inv()\n        qml.CZ(wires=[0, 1])\n        qml.CZ(wires=[0, 2]).inv()\n        qml.CNOT(wires=[2, 1])\n        qml.CNOT(wires=[0, 2])\n        qml.SWAP(wires=[0, 2]).inv()\n        qml.CNOT(wires=[1, 3])\n        qml.RZ(b, wires=3)\n        qml.CSWAP(wires=[4, 0, 1])\n\n        return [\n            qml.expval(qml.PauliY(0)),\n            qml.var(qml.Hadamard(wires=1)),\n            qml.sample(qml.PauliX(2)),\n            qml.expval(qml.Hermitian(np.eye(4), wires=[3, 4])),\n        ]\n\n    dev = qml.device(""default.qubit"", wires=5)\n\n    qnode = qml.QNode(qfunc, dev)\n    qnode._construct((0.1, 0.2, 0.3, np.array([0.4, 0.5, 0.6])), {})\n    qnode.evaluate((0.1, 0.2, 0.3, np.array([0.4, 0.5, 0.6])), {})\n\n    return qnode\n\n\n@pytest.fixture\ndef drawn_parameterized_qubit_circuit_with_variable_names():\n    """"""The rendered circuit representation of the above qubit circuit with variable names.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80RX(a)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(angles[0])\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Y\xe2\x9f\xa9       \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80RX(b)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80Z\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadRY(b)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(4*angles[1])\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadRY(0.359)\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cX\xe2\x94\x80\xe2\x94\x80Z\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80Z\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0Z\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 Var[H]    \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80R\xcf\x95(1.889*c)\xe2\x94\x80\xe2\x94\x80RX(angles[2])\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cSWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80U0\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0Z\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 Sample[X] \\n""\n        + "" 3: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RZ(b)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RZ(b)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9      \\n""\n        + "" 4: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9      \\n""\n        + ""U0 =\\n""\n        + ""[[1. 0.]\\n""\n        + "" [0. 1.]]\\n""\n        + ""H0 =\\n""\n        + ""[[1. 0. 0. 0.]\\n""\n        + "" [0. 1. 0. 0.]\\n""\n        + "" [0. 0. 1. 0.]\\n""\n        + "" [0. 0. 0. 1.]]\\n""\n    )\n\n\n@pytest.fixture\ndef drawn_parameterized_qubit_circuit_with_values():\n    """"""The rendered circuit representation of the above qubit circuit with variable values.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80RX(0.1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(0.4)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Y\xe2\x9f\xa9       \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80RX(0.2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80Z\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadRY(0.2)\xe2\x94\x80\xe2\x94\x80RX(2.0)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadRY(0.359)\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cX\xe2\x94\x80\xe2\x94\x80Z\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80Z\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0Z\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 Var[H]    \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80R\xcf\x95(0.567)\xe2\x94\x80\xe2\x94\x80RX(0.6)\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cSWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80U0\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0Z\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x81\xbb\xc2\xb9\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 Sample[X] \\n""\n        + "" 3: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RZ(0.2)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RZ(0.2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9      \\n""\n        + "" 4: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9      \\n""\n        + ""U0 =\\n""\n        + ""[[1. 0.]\\n""\n        + "" [0. 1.]]\\n""\n        + ""H0 =\\n""\n        + ""[[1. 0. 0. 0.]\\n""\n        + "" [0. 1. 0. 0.]\\n""\n        + "" [0. 0. 1. 0.]\\n""\n        + "" [0. 0. 0. 1.]]\\n""\n    )\n\n\n@pytest.fixture\ndef parameterized_wide_qubit_qnode():\n    """"""A wide parametrized qubit circuit.""""""\n\n    def qfunc(a, b, c, d, e, f):\n        qml.RX(a, wires=0)\n        qml.RX(b, wires=1)\n        [qml.CNOT(wires=[2 * i, 2 * i + 1]) for i in range(4)]\n        [qml.CNOT(wires=[i, i + 4]) for i in range(4)]\n        [qml.PauliY(wires=[2 * i]) for i in range(4)]\n        [qml.CSWAP(wires=[i + 2, i, i + 4]) for i in range(4)]\n        qml.RX(a, wires=0)\n        qml.RX(b, wires=1)\n\n        return [qml.expval(qml.Hermitian(np.eye(4), wires=[i, i + 4])) for i in range(4)]\n\n    dev = qml.device(""default.qubit"", wires=8)\n    qnode = qml.QNode(qfunc, dev)\n    qnode._construct((0.1, 0.2, 0.3, 47 / 17, 0.5, 0.6), {})\n    qnode.evaluate((0.1, 0.2, 0.3, 47 / 17, 0.5, 0.6), {})\n\n    return qnode\n\n\n@pytest.fixture\ndef drawn_parameterized_wide_qubit_qnode_with_variable_names():\n    """"""The rendered circuit representation of the above wide qubit circuit with variable names.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(a)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(a)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(b)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(b)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x95\xad\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x82\xe2\x95\xad\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 3: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x82\xe2\x94\x82\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 4: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\x82\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 5: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 6: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 7: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + ""H0 =\\n""\n        + ""[[1. 0. 0. 0.]\\n""\n        + "" [0. 1. 0. 0.]\\n""\n        + "" [0. 0. 1. 0.]\\n""\n        + "" [0. 0. 0. 1.]]\\n""\n    )\n\n\n@pytest.fixture\ndef drawn_parameterized_wide_qubit_qnode_with_values():\n    """"""The rendered circuit representation of the above wide qubit circuit with variable values.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(0.1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(0.1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(0.2)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80RX(0.2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x95\xad\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x82\xe2\x95\xad\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 3: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadSWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x82\xe2\x94\x82\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 4: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\x82\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 5: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 6: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80Y\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + "" 7: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0SWAP\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8H0\xe2\x9f\xa9 \\n""\n        + ""H0 =\\n""\n        + ""[[1. 0. 0. 0.]\\n""\n        + "" [0. 1. 0. 0.]\\n""\n        + "" [0. 0. 1. 0.]\\n""\n        + "" [0. 0. 0. 1.]]\\n""\n    )\n\n\n@pytest.fixture\ndef wide_cv_qnode():\n    """"""A wide unparametrized CV circuit.""""""\n\n    def qfunc():\n        qml.GaussianState(\n            np.array([(2 * i + 2) // 2 for i in range(16)]), 2 * np.eye(16), wires=list(range(8))\n        )\n        [qml.Beamsplitter(0.4, 0, wires=[2 * i, 2 * i + 1]) for i in range(4)]\n        [qml.Beamsplitter(0.25475, 0.2312344, wires=[i, i + 4]) for i in range(4)]\n\n        return [\n            qml.expval(qml.FockStateProjector(np.array([1, 1]), wires=[i, i + 4])) for i in range(4)\n        ]\n\n    dev = qml.device(""default.gaussian"", wires=8)\n    qnode = qml.QNode(qfunc, dev)\n    qnode._construct((), {})\n    qnode.evaluate((), {})\n\n    return qnode\n\n\n@pytest.fixture\ndef drawn_wide_cv_qnode():\n    """"""The rendered circuit representation of the above wide CV circuit.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x95\xad\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x82\xe2\x95\xad\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + "" 3: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x82\xe2\x94\x82\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + "" 4: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\x82\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + "" 5: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + "" 6: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\x82\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + "" 7: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0Gaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.4, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.255, 0.231)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8|1,1\xe2\x95\xb31,1|\xe2\x9f\xa9 \\n""\n        + ""M0 =\\n""\n        + ""[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16]\\n""\n        + ""M1 =\\n""\n        + ""[[2. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 2. 0. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 2. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 2.]]\\n""\n    )\n\n\n@pytest.fixture\ndef parameterized_cv_qnode():\n    """"""A parametrized CV circuit.""""""\n\n    def qfunc(a, b, c, d, e, f):\n        qml.ThermalState(3, wires=[1])\n        qml.GaussianState(np.array([1, 1, 1, 2, 2, 3, 3, 3]), 2 * np.eye(8), wires=[0, 1, 2, 3])\n        qml.Rotation(a, wires=0)\n        qml.Rotation(b, wires=1)\n        qml.Beamsplitter(d, 1, wires=[0, 1])\n        qml.Beamsplitter(e, 1, wires=[1, 2])\n        qml.Displacement(f, 0, wires=[3])\n        qml.Squeezing(2.3, 0, wires=[0])\n        qml.Squeezing(2.3, 0, wires=[2])\n        qml.Beamsplitter(d, 1, wires=[1, 2])\n        qml.Beamsplitter(e, 1, wires=[2, 3])\n        qml.TwoModeSqueezing(2, 2, wires=[3, 1])\n        qml.ControlledPhase(2.3, wires=[2, 1])\n        qml.ControlledAddition(2, wires=[0, 3])\n        qml.QuadraticPhase(4, wires=[0])\n\n        return [\n            qml.expval(qml.ops.PolyXP(np.array([0, 1, 2]), wires=0)),\n            qml.expval(qml.ops.QuadOperator(4, wires=1)),\n            qml.expval(qml.ops.FockStateProjector(np.array([1, 5]), wires=[2, 3])),\n        ]\n\n    dev = qml.device(""default.gaussian"", wires=4)\n\n    qnode = qml.QNode(qfunc, dev)\n    qnode._construct((0.1, 0.2, 0.3, 47 / 17, 0.5, 0.6), {})\n    qnode.evaluate((0.1, 0.2, 0.3, 47 / 17, 0.5, 0.6), {})\n\n    return qnode\n\n\n@pytest.fixture\ndef drawn_parameterized_cv_qnode_with_variable_names():\n    """"""The rendered circuit representation of the above CV circuit with variable names.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80R(a)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(d, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80S(2.3, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80P(4)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8x\xe2\x82\x80+2p\xe2\x82\x80\xe2\x9f\xa9          \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80Thermal(3)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80R(b)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(d, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(e, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(d, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadS(2, 2)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadZ(2.3)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8cos(4)x+sin(4)p\xe2\x9f\xa9 \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(e, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80S(2.3, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(d, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(e, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8|1,5\xe2\x95\xb31,5|\xe2\x9f\xa9       \\n""\n        + "" 3: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0Gaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80D(f, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(e, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0S(2, 2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X(2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8|1,5\xe2\x95\xb31,5|\xe2\x9f\xa9       \\n""\n        + ""M0 =\\n""\n        + ""[1 1 1 2 2 3 3 3]\\n""\n        + ""M1 =\\n""\n        + ""[[2. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 2. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 2. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 2. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 2. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 2. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 2. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 2.]]\\n""\n    )\n\n\n@pytest.fixture\ndef drawn_parameterized_cv_qnode_with_values():\n    """"""The rendered circuit representation of the above CV circuit with variable values.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80R(0.1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(2.765, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80S(2.3, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80P(4)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8x\xe2\x82\x80+2p\xe2\x82\x80\xe2\x9f\xa9          \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80Thermal(3)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80R(0.2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(2.765, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.5, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(2.765, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadS(2, 2)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadZ(2.3)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8cos(4)x+sin(4)p\xe2\x9f\xa9 \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cGaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.5, 1)\xe2\x94\x80\xe2\x94\x80S(2.3, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(2.765, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadBS(0.5, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8|1,5\xe2\x95\xb31,5|\xe2\x9f\xa9       \\n""\n        + "" 3: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0Gaussian(M0,M1)\xe2\x94\x80\xe2\x94\x80D(0.6, 0)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0BS(0.5, 1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0S(2, 2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X(2)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8|1,5\xe2\x95\xb31,5|\xe2\x9f\xa9       \\n""\n        + ""M0 =\\n""\n        + ""[1 1 1 2 2 3 3 3]\\n""\n        + ""M1 =\\n""\n        + ""[[2. 0. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 2. 0. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 2. 0. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 2. 0. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 2. 0. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 2. 0. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 2. 0.]\\n""\n        + "" [0. 0. 0. 0. 0. 0. 0. 2.]]\\n""\n    )\n\n\n@pytest.fixture\ndef qubit_circuit_with_unused_wires():\n    """"""A qubit ciruit with unused wires.""""""\n\n    def qfunc():\n        qml.PauliX(0)\n        qml.PauliX(5)\n        qml.Toffoli(wires=[5, 1, 0])\n\n        return [\n            qml.expval(qml.PauliY(0)),\n            qml.expval(qml.PauliY(1)),\n            qml.expval(qml.PauliY(5)),\n        ]\n\n    dev = qml.device(""default.qubit"", wires=6)\n\n    qnode = qml.QNode(qfunc, dev)\n    qnode._construct((), {})\n    qnode.evaluate((), {})\n\n    return qnode\n\n\n@pytest.fixture\ndef drawn_qubit_circuit_with_unused_wires():\n    """"""The rendered circuit representation of the above qubit circuit.""""""\n    return "" 0: \xe2\x94\x80\xe2\x94\x80X\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Y\xe2\x9f\xa9 \\n"" + "" 1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Y\xe2\x9f\xa9 \\n"" + "" 5: \xe2\x94\x80\xe2\x94\x80X\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Y\xe2\x9f\xa9 \\n""\n\n\n@pytest.fixture\ndef qubit_circuit_with_probs():\n    """"""A qubit ciruit with probs.""""""\n\n    def qfunc():\n        qml.PauliX(0)\n        qml.PauliX(5)\n        qml.Toffoli(wires=[5, 1, 0])\n\n        return [qml.expval(qml.PauliY(0)), qml.probs(wires=[1, 2, 4])]\n\n    dev = qml.device(""default.qubit"", wires=6)\n\n    qnode = qml.QNode(qfunc, dev)\n    qnode._construct((), {})\n    qnode.evaluate((), {})\n\n    return qnode\n\n\n@pytest.fixture\ndef drawn_qubit_circuit_with_probs():\n    """"""The rendered circuit representation of the above qubit circuit.""""""\n    return (\n        "" 0: \xe2\x94\x80\xe2\x94\x80X\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Y\xe2\x9f\xa9   \\n""\n        + "" 1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9cC\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 Probs \\n""\n        + "" 2: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x9c\xe2\x94\xa4 Probs \\n""\n        + "" 4: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x82\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 Probs \\n""\n        + "" 5: \xe2\x94\x80\xe2\x94\x80X\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4       \\n""\n    )\n\n\nclass TestCircuitDrawerIntegration:\n    """"""Test that QNodes are properly drawn.""""""\n\n    def test_qubit_circuit_with_variable_names(\n        self, parameterized_qubit_qnode, drawn_parameterized_qubit_circuit_with_variable_names\n    ):\n        """"""Test that a parametrized qubit circuit renders correctly with variable names.""""""\n        output = parameterized_qubit_qnode.circuit.draw(show_variable_names=True)\n\n        assert output == drawn_parameterized_qubit_circuit_with_variable_names\n\n    def test_qubit_circuit_with_values(\n        self, parameterized_qubit_qnode, drawn_parameterized_qubit_circuit_with_values\n    ):\n        """"""Test that a parametrized qubit circuit renders correctly with values.""""""\n        output = parameterized_qubit_qnode.circuit.draw(show_variable_names=False)\n\n        assert output == drawn_parameterized_qubit_circuit_with_values\n\n    def test_wide_qubit_circuit_with_variable_names(\n        self,\n        parameterized_wide_qubit_qnode,\n        drawn_parameterized_wide_qubit_qnode_with_variable_names,\n    ):\n        """"""Test that a wide parametrized qubit circuit renders correctly with variable names.""""""\n        output = parameterized_wide_qubit_qnode.draw(show_variable_names=True)\n\n        assert output == drawn_parameterized_wide_qubit_qnode_with_variable_names\n\n    def test_wide_qubit_circuit_with_values(\n        self, parameterized_wide_qubit_qnode, drawn_parameterized_wide_qubit_qnode_with_values\n    ):\n        """"""Test that a wide parametrized qubit circuit renders correctly with values.""""""\n        output = parameterized_wide_qubit_qnode.draw(show_variable_names=False)\n\n        assert output == drawn_parameterized_wide_qubit_qnode_with_values\n\n    def test_wide_cv_circuit(self, wide_cv_qnode, drawn_wide_cv_qnode):\n        """"""Test that a wide CV circuit renders correctly.""""""\n        output = wide_cv_qnode.draw()\n\n        assert output == drawn_wide_cv_qnode\n\n    def test_cv_circuit_with_variable_names(\n        self, parameterized_cv_qnode, drawn_parameterized_cv_qnode_with_variable_names\n    ):\n        """"""Test that a parametrized CV circuit renders correctly with variable names.""""""\n        output = parameterized_cv_qnode.draw(show_variable_names=True)\n\n        assert output == drawn_parameterized_cv_qnode_with_variable_names\n\n    def test_cv_circuit_with_values(\n        self, parameterized_cv_qnode, drawn_parameterized_cv_qnode_with_values\n    ):\n        """"""Test that a parametrized CV circuit renders correctly with values.""""""\n        output = parameterized_cv_qnode.draw(show_variable_names=False)\n\n        assert output == drawn_parameterized_cv_qnode_with_values\n\n    def test_qubit_circuit_with_unused_wires(\n        self, qubit_circuit_with_unused_wires, drawn_qubit_circuit_with_unused_wires\n    ):\n        """"""Test that a qubit circuit with unused wires renders correctly.""""""\n        output = qubit_circuit_with_unused_wires.draw()\n\n        assert output == drawn_qubit_circuit_with_unused_wires\n\n    def test_qubit_circuit_with_probs(\n        self, qubit_circuit_with_probs, drawn_qubit_circuit_with_probs\n    ):\n        """"""Test that a qubit circuit with unused wires renders correctly.""""""\n        output = qubit_circuit_with_probs.draw()\n\n        assert output == drawn_qubit_circuit_with_probs\n\n    def test_direct_qnode_integration(self):\n        """"""Test that a regular QNode renders correctly.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def qfunc(a, w):\n            qml.Hadamard(0)\n            qml.CRX(a, wires=[0, 1])\n            qml.Rot(w[0], w[1], w[2], wires=[1])\n            qml.CRX(-a, wires=[0, 1])\n\n            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\n        res = qfunc(2.3, [1.2, 3.2, 0.7])\n\n        assert qfunc.draw() == (\n            "" 0: \xe2\x94\x80\xe2\x94\x80H\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9 \\n""\n            + "" 1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(2.3)\xe2\x94\x80\xe2\x94\x80Rot(1.2, 3.2, 0.7)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(-2.3)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9 \\n""\n        )\n\n        assert qfunc.draw(charset=""ascii"") == (\n            "" 0: --H--+C----------------------------+C---------+| <Z @ Z> \\n""\n            + "" 1: -----+RX(2.3)--Rot(1.2, 3.2, 0.7)--+RX(-2.3)--+| <Z @ Z> \\n""\n        )\n\n        assert qfunc.draw(show_variable_names=True) == (\n            "" 0: \xe2\x94\x80\xe2\x94\x80H\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xad\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9 \\n""\n            + "" 1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(a)\xe2\x94\x80\xe2\x94\x80Rot(w[0], w[1], w[2])\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0RX(-1*a)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0\xe2\x94\xa4 \xe2\x9f\xa8Z \xe2\x8a\x97 Z\xe2\x9f\xa9 \\n""\n        )\n'"
tests/circuit_drawer/test_grid.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.circuit_drawer.grid` module.\n""""""\nimport pytest\nimport numpy as np\n\nfrom pennylane.circuit_drawer import Grid\nfrom pennylane.circuit_drawer.grid import _transpose\n\n\nclass TestFunctions:\n    """"""Test the helper functions.""""""\n\n    @pytest.mark.parametrize(\n        ""input,expected_output"",\n        [\n            ([[0, 1], [2, 3]], [[0, 2], [1, 3]]),\n            ([[0, 1, 2], [3, 4, 5]], [[0, 3], [1, 4], [2, 5]]),\n            ([[0], [1], [2]], [[0, 1, 2]]),\n        ],\n    )\n    def test_transpose(self, input, expected_output):\n        """"""Test that transpose transposes a list of list.""""""\n        assert _transpose(input) == expected_output\n\n    @pytest.mark.parametrize(\n        ""input"",\n        [\n            [[0, 1], [2, 3]],\n            [[0, 2], [1, 3]],\n            [[0, 1, 2], [3, 4, 5]],\n            [[0, 3], [1, 4], [2, 5]],\n            [[0], [1], [2]],\n            [[0, 1, 2]],\n        ],\n    )\n    def test_transpose_squared(self, input):\n        """"""Test that transpose transposes a list of list.""""""\n        assert _transpose(_transpose(input)) == input\n\n\nclass TestGrid:\n    """"""Test the Grid helper class.""""""\n\n    def test_empty_init(self):\n        """"""Test that the Grid class is initialized correctly when no raw_grid is given.""""""\n        grid = Grid()\n\n        assert grid.num_layers == 0\n        assert grid.num_wires == 0\n        assert grid.raw_grid is None\n\n    def test_init(self):\n        """"""Test that the Grid class is initialized correctly.""""""\n\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        assert np.array_equal(grid.raw_grid, raw_grid)\n        assert np.array_equal(grid.raw_grid.T, [[0, 1, 2], [3, 4, 5]])\n\n    @pytest.mark.parametrize(\n        ""idx,expected_transposed_grid"",\n        [\n            (0, [[6, 7, 8], [0, 1, 2], [3, 4, 5]]),\n            (1, [[0, 1, 2], [6, 7, 8], [3, 4, 5]]),\n            (2, [[0, 1, 2], [3, 4, 5], [6, 7, 8]]),\n        ],\n    )\n    def test_insert_layer(self, idx, expected_transposed_grid):\n        """"""Test that layer insertion works properly.""""""\n\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        grid.insert_layer(idx, [6, 7, 8])\n\n        assert np.array_equal(grid.raw_grid.T, expected_transposed_grid)\n        assert np.array_equal(grid.raw_grid, _transpose(expected_transposed_grid))\n\n    def test_append_layer(self):\n        """"""Test that layer appending works properly.""""""\n\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        grid.append_layer([6, 7, 8])\n\n        assert np.array_equal(grid.raw_grid, [[0, 3, 6], [1, 4, 7], [2, 5, 8]])\n        assert np.array_equal(grid.raw_grid.T, [[0, 1, 2], [3, 4, 5], [6, 7, 8]])\n\n    @pytest.mark.parametrize(\n        ""idx,expected_transposed_grid"", [(0, [[6, 7, 8], [3, 4, 5]]), (1, [[0, 1, 2], [6, 7, 8]]),]\n    )\n    def test_replace_layer(self, idx, expected_transposed_grid):\n        """"""Test that layer replacement works properly.""""""\n\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        grid.replace_layer(idx, [6, 7, 8])\n\n        assert np.array_equal(grid.raw_grid.T, expected_transposed_grid)\n        assert np.array_equal(grid.raw_grid, _transpose(expected_transposed_grid))\n\n    @pytest.mark.parametrize(\n        ""idx,expected_grid"",\n        [\n            (0, [[6, 7], [0, 3], [1, 4], [2, 5]]),\n            (1, [[0, 3], [6, 7], [1, 4], [2, 5]]),\n            (2, [[0, 3], [1, 4], [6, 7], [2, 5]]),\n            (3, [[0, 3], [1, 4], [2, 5], [6, 7]]),\n        ],\n    )\n    def test_insert_wire(self, idx, expected_grid):\n        """"""Test that wire insertion works properly.""""""\n\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        grid.insert_wire(idx, [6, 7])\n\n        assert np.array_equal(grid.raw_grid, expected_grid)\n        assert np.array_equal(grid.raw_grid.T, _transpose(expected_grid))\n\n    def test_append_wire(self):\n        """"""Test that wire appending works properly.""""""\n\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        grid.append_wire([6, 7])\n\n        assert np.array_equal(grid.raw_grid, [[0, 3], [1, 4], [2, 5], [6, 7]])\n        assert np.array_equal(grid.raw_grid.T, [[0, 1, 2, 6], [3, 4, 5, 7]])\n\n    @pytest.mark.parametrize(\n        ""raw_grid,expected_num_layers"",\n        [\n            ([[6, 7], [0, 3], [1, 4], [2, 5]], 2),\n            ([[0, 1, 2, 6], [3, 4, 5, 7]], 4),\n            ([[0, 2, 6], [3, 5, 7]], 3),\n        ],\n    )\n    def test_num_layers(self, raw_grid, expected_num_layers):\n        """"""Test that num_layers returns the correct number of layers.""""""\n        grid = Grid(raw_grid)\n\n        assert grid.num_layers == expected_num_layers\n\n    @pytest.mark.parametrize(\n        ""raw_grid,expected_num_wires"",\n        [\n            ([[6, 7], [0, 3], [1, 4], [2, 5]], 4),\n            ([[0, 1, 2, 6], [3, 4, 5, 7]], 2),\n            ([[0, 2, 6], [3, 5, 7]], 2),\n        ],\n    )\n    def test_num_wires(self, raw_grid, expected_num_wires):\n        """"""Test that num_layers returns the correct number of wires.""""""\n        grid = Grid(raw_grid)\n\n        assert grid.num_wires == expected_num_wires\n\n    @pytest.mark.parametrize(\n        ""raw_transposed_grid"",\n        [\n            ([[6, 7], [0, 3], [1, 4], [2, 5]]),\n            ([[0, 1, 2, 6], [3, 4, 5, 7]]),\n            ([[0, 2, 6], [3, 5, 7]]),\n        ],\n    )\n    def test_layer(self, raw_transposed_grid):\n        """"""Test that layer returns the correct layer.""""""\n        grid = Grid(_transpose(raw_transposed_grid))\n\n        for idx, layer in enumerate(raw_transposed_grid):\n            assert np.array_equal(grid.layer(idx), layer)\n\n    @pytest.mark.parametrize(\n        ""raw_grid"",\n        [\n            ([[6, 7], [0, 3], [1, 4], [2, 5]]),\n            ([[0, 1, 2, 6], [3, 4, 5, 7]]),\n            ([[0, 2, 6], [3, 5, 7]]),\n        ],\n    )\n    def test_wire(self, raw_grid):\n        """"""Test that wire returns the correct wire.""""""\n        grid = Grid(raw_grid)\n\n        for idx, wire in enumerate(raw_grid):\n            assert np.array_equal(grid.wire(idx), wire)\n\n    def test_copy(self):\n        """"""Test that copy copies the grid.""""""\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        other_grid = grid.copy()\n\n        # Assert that everything is indeed copied\n        assert other_grid is not grid\n        assert other_grid.raw_grid is not grid.raw_grid\n\n        # Assert the copy is correct\n        assert np.array_equal(other_grid.raw_grid, grid.raw_grid)\n\n    def test_append_grid_by_layers(self):\n        """"""Test appending a grid to another by layers.""""""\n        raw_grid_transpose1 = [[0, 3], [1, 4], [2, 5]]\n        raw_grid_transpose2 = [[6, 7], [8, 9]]\n\n        grid1 = Grid(_transpose(raw_grid_transpose1))\n        grid2 = Grid(_transpose(raw_grid_transpose2))\n\n        grid1.append_grid_by_layers(grid2)\n\n        assert np.array_equal(grid1.raw_grid.T, [[0, 3], [1, 4], [2, 5], [6, 7], [8, 9]])\n        assert np.array_equal(grid1.raw_grid, _transpose([[0, 3], [1, 4], [2, 5], [6, 7], [8, 9]]))\n\n    def test_str(self):\n        """"""Test string rendering of Grid.""""""\n        raw_grid = [[0, 3], [1, 4], [2, 5]]\n        grid = Grid(raw_grid)\n\n        assert str(grid) == ""[0 3]\\n[1 4]\\n[2 5]\\n""\n\n    def test_replace_error_message(self):\n        """"""Test that an exception is raised when replacing layers in\n        an uninitialized Grid is attempted.""""""\n        grid = Grid()\n\n        with pytest.raises(\n            AttributeError, match=""Can\'t replace layer. The Grid has not yet been initialized.""\n        ):\n            grid.replace_layer(1, [1, 2, 3])\n'"
tests/circuit_drawer/test_representation_resolver.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.circuit_drawer.representation_resolver` module.\n""""""\nfrom unittest.mock import Mock\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.circuit_drawer import RepresentationResolver\nfrom pennylane.variable import Variable\n\n\n@pytest.fixture\ndef unicode_representation_resolver():\n    """"""An instance of a RepresentationResolver with unicode charset.""""""\n    return RepresentationResolver()\n\n\n@pytest.fixture\ndef ascii_representation_resolver():\n    """"""An instance of a RepresentationResolver with unicode charset.""""""\n    return RepresentationResolver(charset=qml.circuit_drawer.AsciiCharSet)\n\n\n@pytest.fixture\ndef unicode_representation_resolver_varnames():\n    """"""An instance of a RepresentationResolver with unicode charset and show_variable_names=True.""""""\n    return RepresentationResolver(show_variable_names=True)\n\n\n@pytest.fixture\ndef variable(monkeypatch):\n    """"""A mocked Variable instance for a non-keyword variable.""""""\n    monkeypatch.setattr(Variable, ""positional_arg_values"", [0, 1, 2, 3])\n    yield Variable(2, ""test"")\n\n\n@pytest.fixture\ndef kwarg_variable(monkeypatch):\n    """"""A mocked Variable instance for a keyword variable.""""""\n    monkeypatch.setattr(Variable, ""kwarg_values"", {""kwarg_test"": [0, 1, 2, 3]})\n    yield Variable(1, ""kwarg_test"", True)\n\n\nclass TestRepresentationResolver:\n    """"""Test the RepresentationResolver class.""""""\n\n    @pytest.mark.parametrize(\n        ""list,element,index,list_after"",\n        [\n            ([1, 2, 3], 2, 1, [1, 2, 3]),\n            ([1, 2, 2, 3], 2, 1, [1, 2, 2, 3]),\n            ([1, 2, 3], 4, 3, [1, 2, 3, 4]),\n        ],\n    )\n    def test_index_of_array_or_append(self, list, element, index, list_after):\n        """"""Test the method index_of_array_or_append.""""""\n\n        assert RepresentationResolver.index_of_array_or_append(element, list) == index\n        assert list == list_after\n\n    @pytest.mark.parametrize(""par,expected"", [(3, ""3""), (5.236422, ""5.236""),])\n    def test_single_parameter_representation(self, unicode_representation_resolver, par, expected):\n        """"""Test that single parameters are properly resolved.""""""\n        assert unicode_representation_resolver.single_parameter_representation(par) == expected\n\n    def test_single_parameter_representation_variable(\n        self, unicode_representation_resolver, variable\n    ):\n        """"""Test that variables are properly resolved.""""""\n\n        assert unicode_representation_resolver.single_parameter_representation(variable) == ""2""\n\n    def test_single_parameter_representation_kwarg_variable(\n        self, unicode_representation_resolver, kwarg_variable\n    ):\n        """"""Test that kwarg variables are properly resolved.""""""\n\n        assert (\n            unicode_representation_resolver.single_parameter_representation(kwarg_variable) == ""1""\n        )\n\n    @pytest.mark.parametrize(""par,expected"", [(3, ""3""), (5.236422, ""5.236""),])\n    def test_single_parameter_representation_varnames(\n        self, unicode_representation_resolver_varnames, par, expected\n    ):\n        """"""Test that single parameters are properly resolved when show_variable_names is True.""""""\n        assert (\n            unicode_representation_resolver_varnames.single_parameter_representation(par)\n            == expected\n        )\n\n    def test_single_parameter_representation_variable_varnames(\n        self, unicode_representation_resolver_varnames, variable\n    ):\n        """"""Test that variables are properly resolved when show_variable_names is True.""""""\n\n        assert (\n            unicode_representation_resolver_varnames.single_parameter_representation(variable)\n            == ""test""\n        )\n\n    def test_single_parameter_representation_kwarg_variable_varnames(\n        self, unicode_representation_resolver_varnames, kwarg_variable\n    ):\n        """"""Test that kwarg variables are properly resolved when show_variable_names is True.""""""\n\n        assert (\n            unicode_representation_resolver_varnames.single_parameter_representation(kwarg_variable)\n            == ""kwarg_test""\n        )\n\n    @pytest.mark.parametrize(\n        ""op,wire,target"",\n        [\n            (qml.PauliX(wires=[1]), 1, ""X""),\n            (qml.CNOT(wires=[0, 1]), 1, ""X""),\n            (qml.CNOT(wires=[0, 1]), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]), 1, ""X""),\n            (qml.Toffoli(wires=[0, 2, 1]), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]), 2, ""C""),\n            (qml.CSWAP(wires=[0, 2, 1]), 1, ""SWAP""),\n            (qml.CSWAP(wires=[0, 2, 1]), 2, ""SWAP""),\n            (qml.CSWAP(wires=[0, 2, 1]), 0, ""C""),\n            (qml.PauliY(wires=[1]), 1, ""Y""),\n            (qml.PauliZ(wires=[1]), 1, ""Z""),\n            (qml.CZ(wires=[0, 1]), 1, ""Z""),\n            (qml.CZ(wires=[0, 1]), 0, ""C""),\n            (qml.Identity(wires=[1]), 1, ""I""),\n            (qml.Hadamard(wires=[1]), 1, ""H""),\n            (qml.PauliRot(3.14, ""XX"", wires=[0, 1]), 1, ""RX(3.14)""),\n            (qml.PauliRot(3.14, ""YZ"", wires=[0, 1]), 1, ""RZ(3.14)""),\n            (qml.PauliRot(3.14, ""IXYZI"", wires=[0, 1, 2, 3, 4]), 0, ""RI(3.14)""),\n            (qml.PauliRot(3.14, ""IXYZI"", wires=[0, 1, 2, 3, 4]), 1, ""RX(3.14)""),\n            (qml.PauliRot(3.14, ""IXYZI"", wires=[0, 1, 2, 3, 4]), 2, ""RY(3.14)""),\n            (qml.PauliRot(3.14, ""IXYZI"", wires=[0, 1, 2, 3, 4]), 3, ""RZ(3.14)""),\n            (qml.PauliRot(3.14, ""IXYZI"", wires=[0, 1, 2, 3, 4]), 4, ""RI(3.14)""),\n            (qml.MultiRZ(3.14, wires=[0, 1]), 0, ""RZ(3.14)""),\n            (qml.MultiRZ(3.14, wires=[0, 1]), 1, ""RZ(3.14)""),\n            (qml.CRX(3.14, wires=[0, 1]), 1, ""RX(3.14)""),\n            (qml.CRX(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.CRY(3.14, wires=[0, 1]), 1, ""RY(3.14)""),\n            (qml.CRY(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.CRZ(3.14, wires=[0, 1]), 1, ""RZ(3.14)""),\n            (qml.CRZ(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.CRot(3.14, 2.14, 1.14, wires=[0, 1]), 1, ""Rot(3.14, 2.14, 1.14)""),\n            (qml.CRot(3.14, 2.14, 1.14, wires=[0, 1]), 0, ""C""),\n            (qml.PhaseShift(3.14, wires=[0]), 0, ""R\xcf\x95(3.14)""),\n            (qml.Beamsplitter(1, 2, wires=[0, 1]), 1, ""BS(1, 2)""),\n            (qml.Beamsplitter(1, 2, wires=[0, 1]), 0, ""BS(1, 2)""),\n            (qml.Squeezing(1, 2, wires=[1]), 1, ""S(1, 2)""),\n            (qml.TwoModeSqueezing(1, 2, wires=[0, 1]), 1, ""S(1, 2)""),\n            (qml.TwoModeSqueezing(1, 2, wires=[0, 1]), 0, ""S(1, 2)""),\n            (qml.Displacement(1, 2, wires=[1]), 1, ""D(1, 2)""),\n            (qml.NumberOperator(wires=[1]), 1, ""n""),\n            (qml.Rotation(3.14, wires=[1]), 1, ""R(3.14)""),\n            (qml.ControlledAddition(3.14, wires=[0, 1]), 1, ""X(3.14)""),\n            (qml.ControlledAddition(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.ControlledPhase(3.14, wires=[0, 1]), 1, ""Z(3.14)""),\n            (qml.ControlledPhase(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.ThermalState(3, wires=[1]), 1, ""Thermal(3)""),\n            (\n                qml.GaussianState(np.array([1, 2]), np.array([[2, 0], [0, 2]]), wires=[1]),\n                1,\n                ""Gaussian(M0,M1)"",\n            ),\n            (qml.QuadraticPhase(3.14, wires=[1]), 1, ""P(3.14)""),\n            (qml.RX(3.14, wires=[1]), 1, ""RX(3.14)""),\n            (qml.S(wires=[2]), 2, ""S""),\n            (qml.T(wires=[2]), 2, ""T""),\n            (qml.RX(3.14, wires=[1]), 1, ""RX(3.14)""),\n            (qml.RY(3.14, wires=[1]), 1, ""RY(3.14)""),\n            (qml.RZ(3.14, wires=[1]), 1, ""RZ(3.14)""),\n            (qml.Rot(3.14, 2.14, 1.14, wires=[1]), 1, ""Rot(3.14, 2.14, 1.14)""),\n            (qml.U1(3.14, wires=[1]), 1, ""U1(3.14)""),\n            (qml.U2(3.14, 2.14, wires=[1]), 1, ""U2(3.14, 2.14)""),\n            (qml.U3(3.14, 2.14, 1.14, wires=[1]), 1, ""U3(3.14, 2.14, 1.14)""),\n            (qml.BasisState(np.array([0, 1, 0]), wires=[1, 2, 3]), 1, ""|0\xe2\x9f\xa9""),\n            (qml.BasisState(np.array([0, 1, 0]), wires=[1, 2, 3]), 2, ""|1\xe2\x9f\xa9""),\n            (qml.BasisState(np.array([0, 1, 0]), wires=[1, 2, 3]), 3, ""|0\xe2\x9f\xa9""),\n            (qml.QubitStateVector(np.array([0, 1, 0, 0]), wires=[1, 2]), 1, ""QubitStateVector(M0)""),\n            (qml.QubitStateVector(np.array([0, 1, 0, 0]), wires=[1, 2]), 2, ""QubitStateVector(M0)""),\n            (qml.QubitUnitary(np.eye(2), wires=[1]), 1, ""U0""),\n            (qml.QubitUnitary(np.eye(4), wires=[1, 2]), 2, ""U0""),\n            (qml.Kerr(3.14, wires=[1]), 1, ""Kerr(3.14)""),\n            (qml.CrossKerr(3.14, wires=[1, 2]), 1, ""CrossKerr(3.14)""),\n            (qml.CrossKerr(3.14, wires=[1, 2]), 2, ""CrossKerr(3.14)""),\n            (qml.CubicPhase(3.14, wires=[1]), 1, ""V(3.14)""),\n            (qml.Interferometer(np.eye(4), wires=[1, 3]), 1, ""Interferometer(M0)""),\n            (qml.Interferometer(np.eye(4), wires=[1, 3]), 3, ""Interferometer(M0)""),\n            (qml.CatState(3.14, 2.14, 1, wires=[1]), 1, ""CatState(3.14, 2.14, 1)""),\n            (qml.CoherentState(3.14, 2.14, wires=[1]), 1, ""CoherentState(3.14, 2.14)""),\n            (\n                qml.FockDensityMatrix(np.kron(np.eye(4), np.eye(4)), wires=[1, 2]),\n                1,\n                ""FockDensityMatrix(M0)"",\n            ),\n            (\n                qml.FockDensityMatrix(np.kron(np.eye(4), np.eye(4)), wires=[1, 2]),\n                2,\n                ""FockDensityMatrix(M0)"",\n            ),\n            (\n                qml.DisplacedSqueezedState(3.14, 2.14, 1.14, 0.14, wires=[1]),\n                1,\n                ""DisplacedSqueezedState(3.14, 2.14, 1.14, 0.14)"",\n            ),\n            (qml.FockState(7, wires=[1]), 1, ""|7\xe2\x9f\xa9""),\n            (qml.FockStateVector(np.array([4, 5, 7]), wires=[1, 2, 3]), 1, ""|4\xe2\x9f\xa9""),\n            (qml.FockStateVector(np.array([4, 5, 7]), wires=[1, 2, 3]), 2, ""|5\xe2\x9f\xa9""),\n            (qml.FockStateVector(np.array([4, 5, 7]), wires=[1, 2, 3]), 3, ""|7\xe2\x9f\xa9""),\n            (qml.SqueezedState(3.14, 2.14, wires=[1]), 1, ""SqueezedState(3.14, 2.14)""),\n            (qml.Hermitian(np.eye(4), wires=[1, 2]), 1, ""H0""),\n            (qml.Hermitian(np.eye(4), wires=[1, 2]), 2, ""H0""),\n            (qml.X(wires=[1]), 1, ""x""),\n            (qml.P(wires=[1]), 1, ""p""),\n            (qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]), 1, ""|4,5,7\xe2\x95\xb34,5,7|""),\n            (qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1]), 2, ""1+2x\xe2\x82\x80-1.3x\xe2\x82\x81+6p\xe2\x82\x81"",),\n            (\n                qml.PolyXP(\n                    np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                ),\n                1,\n                ""1.2+1.1x\xe2\x82\x80+3.2p\xe2\x82\x80+1.2x\xe2\x82\x80\xc2\xb2+2.3p\xe2\x82\x80\xc2\xb2+3x\xe2\x82\x80p\xe2\x82\x80"",\n            ),\n            (\n                qml.PolyXP(\n                    np.array(\n                        [\n                            [1.2, 2.3, 4.5, 0, 0],\n                            [-1.2, 1.2, -1.5, 0, 0],\n                            [-1.3, 4.5, 2.3, 0, 0],\n                            [0, 2.6, 0, 0, 0],\n                            [0, 0, 0, -4.7, -1.0],\n                        ]\n                    ),\n                    wires=[1],\n                ),\n                1,\n                ""1.2+1.1x\xe2\x82\x80+3.2p\xe2\x82\x80+1.2x\xe2\x82\x80\xc2\xb2+2.3p\xe2\x82\x80\xc2\xb2+3x\xe2\x82\x80p\xe2\x82\x80+2.6x\xe2\x82\x80x\xe2\x82\x81-p\xe2\x82\x81\xc2\xb2-4.7x\xe2\x82\x81p\xe2\x82\x81"",\n            ),\n            (qml.QuadOperator(3.14, wires=[1]), 1, ""cos(3.14)x+sin(3.14)p""),\n            (qml.PauliX(wires=[1]).inv(), 1, ""X\xe2\x81\xbb\xc2\xb9""),\n            (qml.CNOT(wires=[0, 1]).inv(), 1, ""X\xe2\x81\xbb\xc2\xb9""),\n            (qml.CNOT(wires=[0, 1]).inv(), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]).inv(), 1, ""X\xe2\x81\xbb\xc2\xb9""),\n            (qml.Toffoli(wires=[0, 2, 1]).inv(), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]).inv(), 2, ""C""),\n        ],\n    )\n    def test_operator_representation_unicode(\n        self, unicode_representation_resolver, op, wire, target\n    ):\n        """"""Test that an Operator instance is properly resolved.""""""\n        assert unicode_representation_resolver.operator_representation(op, wire) == target\n\n    @pytest.mark.parametrize(\n        ""op,wire,target"",\n        [\n            (qml.PauliX(wires=[1]), 1, ""X""),\n            (qml.CNOT(wires=[0, 1]), 1, ""X""),\n            (qml.CNOT(wires=[0, 1]), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]), 1, ""X""),\n            (qml.Toffoli(wires=[0, 2, 1]), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]), 2, ""C""),\n            (qml.CSWAP(wires=[0, 2, 1]), 1, ""SWAP""),\n            (qml.CSWAP(wires=[0, 2, 1]), 2, ""SWAP""),\n            (qml.CSWAP(wires=[0, 2, 1]), 0, ""C""),\n            (qml.PauliY(wires=[1]), 1, ""Y""),\n            (qml.PauliZ(wires=[1]), 1, ""Z""),\n            (qml.CZ(wires=[0, 1]), 1, ""Z""),\n            (qml.CZ(wires=[0, 1]), 0, ""C""),\n            (qml.Identity(wires=[1]), 1, ""I""),\n            (qml.Hadamard(wires=[1]), 1, ""H""),\n            (qml.CRX(3.14, wires=[0, 1]), 1, ""RX(3.14)""),\n            (qml.CRX(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.CRY(3.14, wires=[0, 1]), 1, ""RY(3.14)""),\n            (qml.CRY(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.CRZ(3.14, wires=[0, 1]), 1, ""RZ(3.14)""),\n            (qml.CRZ(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.CRot(3.14, 2.14, 1.14, wires=[0, 1]), 1, ""Rot(3.14, 2.14, 1.14)""),\n            (qml.CRot(3.14, 2.14, 1.14, wires=[0, 1]), 0, ""C""),\n            (qml.PhaseShift(3.14, wires=[0]), 0, ""R\xcf\x95(3.14)""),\n            (qml.Beamsplitter(1, 2, wires=[0, 1]), 1, ""BS(1, 2)""),\n            (qml.Beamsplitter(1, 2, wires=[0, 1]), 0, ""BS(1, 2)""),\n            (qml.Squeezing(1, 2, wires=[1]), 1, ""S(1, 2)""),\n            (qml.TwoModeSqueezing(1, 2, wires=[0, 1]), 1, ""S(1, 2)""),\n            (qml.TwoModeSqueezing(1, 2, wires=[0, 1]), 0, ""S(1, 2)""),\n            (qml.Displacement(1, 2, wires=[1]), 1, ""D(1, 2)""),\n            (qml.NumberOperator(wires=[1]), 1, ""n""),\n            (qml.Rotation(3.14, wires=[1]), 1, ""R(3.14)""),\n            (qml.ControlledAddition(3.14, wires=[0, 1]), 1, ""X(3.14)""),\n            (qml.ControlledAddition(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.ControlledPhase(3.14, wires=[0, 1]), 1, ""Z(3.14)""),\n            (qml.ControlledPhase(3.14, wires=[0, 1]), 0, ""C""),\n            (qml.ThermalState(3, wires=[1]), 1, ""Thermal(3)""),\n            (\n                qml.GaussianState(np.array([1, 2]), np.array([[2, 0], [0, 2]]), wires=[1]),\n                1,\n                ""Gaussian(M0,M1)"",\n            ),\n            (qml.QuadraticPhase(3.14, wires=[1]), 1, ""P(3.14)""),\n            (qml.RX(3.14, wires=[1]), 1, ""RX(3.14)""),\n            (qml.S(wires=[2]), 2, ""S""),\n            (qml.T(wires=[2]), 2, ""T""),\n            (qml.RX(3.14, wires=[1]), 1, ""RX(3.14)""),\n            (qml.RY(3.14, wires=[1]), 1, ""RY(3.14)""),\n            (qml.RZ(3.14, wires=[1]), 1, ""RZ(3.14)""),\n            (qml.Rot(3.14, 2.14, 1.14, wires=[1]), 1, ""Rot(3.14, 2.14, 1.14)""),\n            (qml.U1(3.14, wires=[1]), 1, ""U1(3.14)""),\n            (qml.U2(3.14, 2.14, wires=[1]), 1, ""U2(3.14, 2.14)""),\n            (qml.U3(3.14, 2.14, 1.14, wires=[1]), 1, ""U3(3.14, 2.14, 1.14)""),\n            (qml.BasisState(np.array([0, 1, 0]), wires=[1, 2, 3]), 1, ""|0>""),\n            (qml.BasisState(np.array([0, 1, 0]), wires=[1, 2, 3]), 2, ""|1>""),\n            (qml.BasisState(np.array([0, 1, 0]), wires=[1, 2, 3]), 3, ""|0>""),\n            (qml.QubitStateVector(np.array([0, 1, 0, 0]), wires=[1, 2]), 1, ""QubitStateVector(M0)""),\n            (qml.QubitStateVector(np.array([0, 1, 0, 0]), wires=[1, 2]), 2, ""QubitStateVector(M0)""),\n            (qml.QubitUnitary(np.eye(2), wires=[1]), 1, ""U0""),\n            (qml.QubitUnitary(np.eye(4), wires=[1, 2]), 2, ""U0""),\n            (qml.Kerr(3.14, wires=[1]), 1, ""Kerr(3.14)""),\n            (qml.CrossKerr(3.14, wires=[1, 2]), 1, ""CrossKerr(3.14)""),\n            (qml.CrossKerr(3.14, wires=[1, 2]), 2, ""CrossKerr(3.14)""),\n            (qml.CubicPhase(3.14, wires=[1]), 1, ""V(3.14)""),\n            (qml.Interferometer(np.eye(4), wires=[1, 3]), 1, ""Interferometer(M0)""),\n            (qml.Interferometer(np.eye(4), wires=[1, 3]), 3, ""Interferometer(M0)""),\n            (qml.CatState(3.14, 2.14, 1, wires=[1]), 1, ""CatState(3.14, 2.14, 1)""),\n            (qml.CoherentState(3.14, 2.14, wires=[1]), 1, ""CoherentState(3.14, 2.14)""),\n            (\n                qml.FockDensityMatrix(np.kron(np.eye(4), np.eye(4)), wires=[1, 2]),\n                1,\n                ""FockDensityMatrix(M0)"",\n            ),\n            (\n                qml.FockDensityMatrix(np.kron(np.eye(4), np.eye(4)), wires=[1, 2]),\n                2,\n                ""FockDensityMatrix(M0)"",\n            ),\n            (\n                qml.DisplacedSqueezedState(3.14, 2.14, 1.14, 0.14, wires=[1]),\n                1,\n                ""DisplacedSqueezedState(3.14, 2.14, 1.14, 0.14)"",\n            ),\n            (qml.FockState(7, wires=[1]), 1, ""|7>""),\n            (qml.FockStateVector(np.array([4, 5, 7]), wires=[1, 2, 3]), 1, ""|4>""),\n            (qml.FockStateVector(np.array([4, 5, 7]), wires=[1, 2, 3]), 2, ""|5>""),\n            (qml.FockStateVector(np.array([4, 5, 7]), wires=[1, 2, 3]), 3, ""|7>""),\n            (qml.SqueezedState(3.14, 2.14, wires=[1]), 1, ""SqueezedState(3.14, 2.14)""),\n            (qml.Hermitian(np.eye(4), wires=[1, 2]), 1, ""H0""),\n            (qml.Hermitian(np.eye(4), wires=[1, 2]), 2, ""H0""),\n            (qml.X(wires=[1]), 1, ""x""),\n            (qml.P(wires=[1]), 1, ""p""),\n            (qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]), 1, ""|4,5,7X4,5,7|""),\n            (qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1]), 2, ""1+2x_0-1.3x_1+6p_1"",),\n            (\n                qml.PolyXP(\n                    np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                ),\n                1,\n                ""1.2+1.1x_0+3.2p_0+1.2x_0^2+2.3p_0^2+3x_0p_0"",\n            ),\n            (\n                qml.PolyXP(\n                    np.array(\n                        [\n                            [1.2, 2.3, 4.5, 0, 0],\n                            [-1.2, 1.2, -1.5, 0, 0],\n                            [-1.3, 4.5, 2.3, 0, 0],\n                            [0, 2.6, 0, 0, 0],\n                            [0, 0, 0, -4.7, 0],\n                        ]\n                    ),\n                    wires=[1],\n                ),\n                1,\n                ""1.2+1.1x_0+3.2p_0+1.2x_0^2+2.3p_0^2+3x_0p_0+2.6x_0x_1-4.7x_1p_1"",\n            ),\n            (qml.QuadOperator(3.14, wires=[1]), 1, ""cos(3.14)x+sin(3.14)p""),\n            (qml.QuadOperator(3.14, wires=[1]), 1, ""cos(3.14)x+sin(3.14)p""),\n            (qml.PauliX(wires=[1]).inv(), 1, ""X^-1""),\n            (qml.CNOT(wires=[0, 1]).inv(), 1, ""X^-1""),\n            (qml.CNOT(wires=[0, 1]).inv(), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]).inv(), 1, ""X^-1""),\n            (qml.Toffoli(wires=[0, 2, 1]).inv(), 0, ""C""),\n            (qml.Toffoli(wires=[0, 2, 1]).inv(), 2, ""C""),\n        ],\n    )\n    def test_operator_representation_ascii(self, ascii_representation_resolver, op, wire, target):\n        """"""Test that an Operator instance is properly resolved.""""""\n        assert ascii_representation_resolver.operator_representation(op, wire) == target\n\n    @pytest.mark.parametrize(\n        ""obs,wire,target"",\n        [\n            (qml.expval(qml.PauliX(wires=[1])), 1, ""\xe2\x9f\xa8X\xe2\x9f\xa9""),\n            (qml.expval(qml.PauliY(wires=[1])), 1, ""\xe2\x9f\xa8Y\xe2\x9f\xa9""),\n            (qml.expval(qml.PauliZ(wires=[1])), 1, ""\xe2\x9f\xa8Z\xe2\x9f\xa9""),\n            (qml.expval(qml.Hadamard(wires=[1])), 1, ""\xe2\x9f\xa8H\xe2\x9f\xa9""),\n            (qml.expval(qml.Hermitian(np.eye(4), wires=[1, 2])), 1, ""\xe2\x9f\xa8H0\xe2\x9f\xa9""),\n            (qml.expval(qml.Hermitian(np.eye(4), wires=[1, 2])), 2, ""\xe2\x9f\xa8H0\xe2\x9f\xa9""),\n            (qml.expval(qml.NumberOperator(wires=[1])), 1, ""\xe2\x9f\xa8n\xe2\x9f\xa9""),\n            (qml.expval(qml.X(wires=[1])), 1, ""\xe2\x9f\xa8x\xe2\x9f\xa9""),\n            (qml.expval(qml.P(wires=[1])), 1, ""\xe2\x9f\xa8p\xe2\x9f\xa9""),\n            (\n                qml.expval(qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3])),\n                1,\n                ""\xe2\x9f\xa8|4,5,7\xe2\x95\xb34,5,7|\xe2\x9f\xa9"",\n            ),\n            (\n                qml.expval(qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1])),\n                2,\n                ""\xe2\x9f\xa81+2x\xe2\x82\x80-1.3x\xe2\x82\x81+6p\xe2\x82\x81\xe2\x9f\xa9"",\n            ),\n            (\n                qml.expval(\n                    qml.PolyXP(\n                        np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                    )\n                ),\n                1,\n                ""\xe2\x9f\xa81.2+1.1x\xe2\x82\x80+3.2p\xe2\x82\x80+1.2x\xe2\x82\x80\xc2\xb2+2.3p\xe2\x82\x80\xc2\xb2+3x\xe2\x82\x80p\xe2\x82\x80\xe2\x9f\xa9"",\n            ),\n            (qml.expval(qml.QuadOperator(3.14, wires=[1])), 1, ""\xe2\x9f\xa8cos(3.14)x+sin(3.14)p\xe2\x9f\xa9""),\n            (qml.var(qml.PauliX(wires=[1])), 1, ""Var[X]""),\n            (qml.var(qml.PauliY(wires=[1])), 1, ""Var[Y]""),\n            (qml.var(qml.PauliZ(wires=[1])), 1, ""Var[Z]""),\n            (qml.var(qml.Hadamard(wires=[1])), 1, ""Var[H]""),\n            (qml.var(qml.Hermitian(np.eye(4), wires=[1, 2])), 1, ""Var[H0]""),\n            (qml.var(qml.Hermitian(np.eye(4), wires=[1, 2])), 2, ""Var[H0]""),\n            (qml.var(qml.NumberOperator(wires=[1])), 1, ""Var[n]""),\n            (qml.var(qml.X(wires=[1])), 1, ""Var[x]""),\n            (qml.var(qml.P(wires=[1])), 1, ""Var[p]""),\n            (\n                qml.var(qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3])),\n                1,\n                ""Var[|4,5,7\xe2\x95\xb34,5,7|]"",\n            ),\n            (\n                qml.var(qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1])),\n                2,\n                ""Var[1+2x\xe2\x82\x80-1.3x\xe2\x82\x81+6p\xe2\x82\x81]"",\n            ),\n            (\n                qml.var(\n                    qml.PolyXP(\n                        np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                    )\n                ),\n                1,\n                ""Var[1.2+1.1x\xe2\x82\x80+3.2p\xe2\x82\x80+1.2x\xe2\x82\x80\xc2\xb2+2.3p\xe2\x82\x80\xc2\xb2+3x\xe2\x82\x80p\xe2\x82\x80]"",\n            ),\n            (qml.var(qml.QuadOperator(3.14, wires=[1])), 1, ""Var[cos(3.14)x+sin(3.14)p]""),\n            (qml.sample(qml.PauliX(wires=[1])), 1, ""Sample[X]""),\n            (qml.sample(qml.PauliY(wires=[1])), 1, ""Sample[Y]""),\n            (qml.sample(qml.PauliZ(wires=[1])), 1, ""Sample[Z]""),\n            (qml.sample(qml.Hadamard(wires=[1])), 1, ""Sample[H]""),\n            (qml.sample(qml.Hermitian(np.eye(4), wires=[1, 2])), 1, ""Sample[H0]""),\n            (qml.sample(qml.Hermitian(np.eye(4), wires=[1, 2])), 2, ""Sample[H0]""),\n            (qml.sample(qml.NumberOperator(wires=[1])), 1, ""Sample[n]""),\n            (qml.sample(qml.X(wires=[1])), 1, ""Sample[x]""),\n            (qml.sample(qml.P(wires=[1])), 1, ""Sample[p]""),\n            (\n                qml.sample(qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3])),\n                1,\n                ""Sample[|4,5,7\xe2\x95\xb34,5,7|]"",\n            ),\n            (\n                qml.sample(qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1])),\n                2,\n                ""Sample[1+2x\xe2\x82\x80-1.3x\xe2\x82\x81+6p\xe2\x82\x81]"",\n            ),\n            (\n                qml.sample(\n                    qml.PolyXP(\n                        np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                    )\n                ),\n                1,\n                ""Sample[1.2+1.1x\xe2\x82\x80+3.2p\xe2\x82\x80+1.2x\xe2\x82\x80\xc2\xb2+2.3p\xe2\x82\x80\xc2\xb2+3x\xe2\x82\x80p\xe2\x82\x80]"",\n            ),\n            (qml.sample(qml.QuadOperator(3.14, wires=[1])), 1, ""Sample[cos(3.14)x+sin(3.14)p]""),\n            (\n                qml.expval(qml.PauliX(wires=[1]) @ qml.PauliY(wires=[2]) @ qml.PauliZ(wires=[3])),\n                1,\n                ""\xe2\x9f\xa8X \xe2\x8a\x97 Y \xe2\x8a\x97 Z\xe2\x9f\xa9"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                1,\n                ""\xe2\x9f\xa8|4,5,7\xe2\x95\xb34,5,7| \xe2\x8a\x97 x\xe2\x9f\xa9"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                2,\n                ""\xe2\x9f\xa8|4,5,7\xe2\x95\xb34,5,7| \xe2\x8a\x97 x\xe2\x9f\xa9"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                3,\n                ""\xe2\x9f\xa8|4,5,7\xe2\x95\xb34,5,7| \xe2\x8a\x97 x\xe2\x9f\xa9"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                4,\n                ""\xe2\x9f\xa8|4,5,7\xe2\x95\xb34,5,7| \xe2\x8a\x97 x\xe2\x9f\xa9"",\n            ),\n            (\n                qml.sample(\n                    qml.Hermitian(np.eye(4), wires=[1, 2]) @ qml.Hermitian(np.eye(4), wires=[0, 3])\n                ),\n                0,\n                ""Sample[H0 \xe2\x8a\x97 H0]"",\n            ),\n            (\n                qml.sample(\n                    qml.Hermitian(np.eye(4), wires=[1, 2])\n                    @ qml.Hermitian(2 * np.eye(4), wires=[0, 3])\n                ),\n                0,\n                ""Sample[H0 \xe2\x8a\x97 H1]"",\n            ),\n            (qml.probs([0]), 0, ""Probs""),\n        ],\n    )\n    def test_output_representation_unicode(\n        self, unicode_representation_resolver, obs, wire, target\n    ):\n        """"""Test that an Observable instance with return type is properly resolved.""""""\n        assert unicode_representation_resolver.output_representation(obs, wire) == target\n\n    def test_fallback_output_representation_unicode(self, unicode_representation_resolver):\n        """"""Test that an Observable instance with return type is properly resolved.""""""\n        obs = qml.PauliZ(0)\n        obs.return_type = ""TestReturnType""\n\n        assert unicode_representation_resolver.output_representation(obs, 0) == ""TestReturnType[Z]""\n\n    @pytest.mark.parametrize(\n        ""obs,wire,target"",\n        [\n            (qml.expval(qml.PauliX(wires=[1])), 1, ""<X>""),\n            (qml.expval(qml.PauliY(wires=[1])), 1, ""<Y>""),\n            (qml.expval(qml.PauliZ(wires=[1])), 1, ""<Z>""),\n            (qml.expval(qml.Hadamard(wires=[1])), 1, ""<H>""),\n            (qml.expval(qml.Hermitian(np.eye(4), wires=[1, 2])), 1, ""<H0>""),\n            (qml.expval(qml.Hermitian(np.eye(4), wires=[1, 2])), 2, ""<H0>""),\n            (qml.expval(qml.NumberOperator(wires=[1])), 1, ""<n>""),\n            (qml.expval(qml.X(wires=[1])), 1, ""<x>""),\n            (qml.expval(qml.P(wires=[1])), 1, ""<p>""),\n            (\n                qml.expval(qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3])),\n                1,\n                ""<|4,5,7X4,5,7|>"",\n            ),\n            (\n                qml.expval(qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1])),\n                2,\n                ""<1+2x_0-1.3x_1+6p_1>"",\n            ),\n            (\n                qml.expval(\n                    qml.PolyXP(\n                        np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                    )\n                ),\n                1,\n                ""<1.2+1.1x_0+3.2p_0+1.2x_0^2+2.3p_0^2+3x_0p_0>"",\n            ),\n            (qml.expval(qml.QuadOperator(3.14, wires=[1])), 1, ""<cos(3.14)x+sin(3.14)p>""),\n            (qml.var(qml.PauliX(wires=[1])), 1, ""Var[X]""),\n            (qml.var(qml.PauliY(wires=[1])), 1, ""Var[Y]""),\n            (qml.var(qml.PauliZ(wires=[1])), 1, ""Var[Z]""),\n            (qml.var(qml.Hadamard(wires=[1])), 1, ""Var[H]""),\n            (qml.var(qml.Hermitian(np.eye(4), wires=[1, 2])), 1, ""Var[H0]""),\n            (qml.var(qml.Hermitian(np.eye(4), wires=[1, 2])), 2, ""Var[H0]""),\n            (qml.var(qml.NumberOperator(wires=[1])), 1, ""Var[n]""),\n            (qml.var(qml.X(wires=[1])), 1, ""Var[x]""),\n            (qml.var(qml.P(wires=[1])), 1, ""Var[p]""),\n            (\n                qml.var(qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3])),\n                1,\n                ""Var[|4,5,7X4,5,7|]"",\n            ),\n            (\n                qml.var(qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1])),\n                2,\n                ""Var[1+2x_0-1.3x_1+6p_1]"",\n            ),\n            (\n                qml.var(\n                    qml.PolyXP(\n                        np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                    )\n                ),\n                1,\n                ""Var[1.2+1.1x_0+3.2p_0+1.2x_0^2+2.3p_0^2+3x_0p_0]"",\n            ),\n            (qml.var(qml.QuadOperator(3.14, wires=[1])), 1, ""Var[cos(3.14)x+sin(3.14)p]""),\n            (qml.sample(qml.PauliX(wires=[1])), 1, ""Sample[X]""),\n            (qml.sample(qml.PauliY(wires=[1])), 1, ""Sample[Y]""),\n            (qml.sample(qml.PauliZ(wires=[1])), 1, ""Sample[Z]""),\n            (qml.sample(qml.Hadamard(wires=[1])), 1, ""Sample[H]""),\n            (qml.sample(qml.Hermitian(np.eye(4), wires=[1, 2])), 1, ""Sample[H0]""),\n            (qml.sample(qml.Hermitian(np.eye(4), wires=[1, 2])), 2, ""Sample[H0]""),\n            (qml.sample(qml.NumberOperator(wires=[1])), 1, ""Sample[n]""),\n            (qml.sample(qml.X(wires=[1])), 1, ""Sample[x]""),\n            (qml.sample(qml.P(wires=[1])), 1, ""Sample[p]""),\n            (\n                qml.sample(qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3])),\n                1,\n                ""Sample[|4,5,7X4,5,7|]"",\n            ),\n            (\n                qml.sample(qml.PolyXP(np.array([1, 2, 0, -1.3, 6]), wires=[1])),\n                2,\n                ""Sample[1+2x_0-1.3x_1+6p_1]"",\n            ),\n            (\n                qml.sample(\n                    qml.PolyXP(\n                        np.array([[1.2, 2.3, 4.5], [-1.2, 1.2, -1.5], [-1.3, 4.5, 2.3]]), wires=[1]\n                    )\n                ),\n                1,\n                ""Sample[1.2+1.1x_0+3.2p_0+1.2x_0^2+2.3p_0^2+3x_0p_0]"",\n            ),\n            (qml.sample(qml.QuadOperator(3.14, wires=[1])), 1, ""Sample[cos(3.14)x+sin(3.14)p]""),\n            (\n                qml.expval(qml.PauliX(wires=[1]) @ qml.PauliY(wires=[2]) @ qml.PauliZ(wires=[3])),\n                1,\n                ""<X @ Y @ Z>"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                1,\n                ""<|4,5,7X4,5,7| @ x>"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                2,\n                ""<|4,5,7X4,5,7| @ x>"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                3,\n                ""<|4,5,7X4,5,7| @ x>"",\n            ),\n            (\n                qml.expval(\n                    qml.FockStateProjector(np.array([4, 5, 7]), wires=[1, 2, 3]) @ qml.X(wires=[4])\n                ),\n                4,\n                ""<|4,5,7X4,5,7| @ x>"",\n            ),\n            (\n                qml.sample(\n                    qml.Hermitian(np.eye(4), wires=[1, 2]) @ qml.Hermitian(np.eye(4), wires=[0, 3])\n                ),\n                0,\n                ""Sample[H0 @ H0]"",\n            ),\n            (\n                qml.sample(\n                    qml.Hermitian(np.eye(4), wires=[1, 2])\n                    @ qml.Hermitian(2 * np.eye(4), wires=[0, 3])\n                ),\n                0,\n                ""Sample[H0 @ H1]"",\n            ),\n            (qml.probs([0]), 0, ""Probs""),\n        ],\n    )\n    def test_output_representation_ascii(self, ascii_representation_resolver, obs, wire, target):\n        """"""Test that an Observable instance with return type is properly resolved.""""""\n        assert ascii_representation_resolver.output_representation(obs, wire) == target\n\n    def test_element_representation_none(self, unicode_representation_resolver):\n        """"""Test that element_representation properly handles None.""""""\n        assert unicode_representation_resolver.element_representation(None, 0) == """"\n\n    def test_element_representation_str(self, unicode_representation_resolver):\n        """"""Test that element_representation properly handles strings.""""""\n        assert unicode_representation_resolver.element_representation(""Test"", 0) == ""Test""\n\n    def test_element_representation_calls_output(self, unicode_representation_resolver):\n        """"""Test that element_representation calls output_representation for returned observables.""""""\n\n        unicode_representation_resolver.output_representation = Mock()\n\n        obs = qml.sample(qml.PauliX(3))\n        wire = 3\n\n        unicode_representation_resolver.element_representation(obs, wire)\n\n        assert unicode_representation_resolver.output_representation.call_args[0] == (obs, wire)\n\n    def test_element_representation_calls_operator(self, unicode_representation_resolver):\n        """"""Test that element_representation calls operator_representation for all operators that are not returned.""""""\n\n        unicode_representation_resolver.operator_representation = Mock()\n\n        op = qml.PauliX(3)\n        wire = 3\n\n        unicode_representation_resolver.element_representation(op, wire)\n\n        assert unicode_representation_resolver.operator_representation.call_args[0] == (op, wire)\n'"
tests/circuit_graph/test_circuit_graph.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.circuit_graph` module.\n""""""\n# pylint: disable=no-self-use,too-many-arguments,protected-access\n\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.circuit_graph import CircuitGraph\nfrom pennylane.wires import Wires\n\n\n@pytest.fixture\ndef queue():\n    """"""A fixture of a complex example of operations that depend on previous operations.""""""\n    return [\n        qml.RX(0.43, wires=0),\n        qml.RY(0.35, wires=1),\n        qml.RZ(0.35, wires=2),\n        qml.CNOT(wires=[0, 1]),\n        qml.Hadamard(wires=2),\n        qml.CNOT(wires=[2, 0]),\n        qml.PauliX(wires=1),\n    ]\n\n\n@pytest.fixture\ndef obs():\n    """"""A fixture of observables to go after the queue fixture.""""""\n    return [\n        qml.expval(qml.PauliX(wires=0)),\n        qml.expval(qml.Hermitian(np.identity(4), wires=[1, 2])),\n    ]\n\n\n@pytest.fixture\ndef ops(queue, obs):\n    """"""Queue of Operations followed by Observables.""""""\n    return queue + obs\n\n\n@pytest.fixture\ndef circuit(ops):\n    """"""A fixture of a circuit generated based on the queue and obs fixtures above.""""""\n    circuit = CircuitGraph(ops, {})\n    return circuit\n\n\n@pytest.fixture\ndef parameterized_circuit():\n    def qfunc(a, b, c, d, e, f):\n        qml.Rotation(a, wires=0),\n        qml.Rotation(b, wires=1),\n        qml.Rotation(c, wires=2),\n        qml.Beamsplitter(d, 1, wires=[0, 1])\n        qml.Rotation(1, wires=0),\n        qml.Rotation(e, wires=1),\n        qml.Rotation(f, wires=2),\n\n        return [\n            qml.expval(qml.ops.NumberOperator(wires=0)),\n            qml.expval(qml.ops.NumberOperator(wires=1)),\n            qml.expval(qml.ops.NumberOperator(wires=2)),\n        ]\n\n    return qfunc\n\nclass TestCircuitGraph:\n    """"""Test conversion of queues to DAGs""""""\n\n    def test_no_dependence(self):\n        """"""Test case where operations do not depend on each other.\n        This should result in a graph with no edges.""""""\n\n        ops = [qml.RX(0.43, wires=0), qml.RY(0.35, wires=1)]\n\n        res = CircuitGraph(ops, {}).graph\n        assert len(res) == 2\n        assert not res.edges()\n\n    def test_dependence(self, ops):\n        """"""Test a more complex example containing operations\n        that do depend on the result of previous operations""""""\n\n        circuit = CircuitGraph(ops, {})\n        graph = circuit.graph\n        assert len(graph) == 9\n        assert len(graph.edges()) == 9\n\n        # all ops should be nodes in the graph\n        for k in ops:\n            assert k in graph.nodes\n\n        # all nodes in the graph should be ops\n        for k in graph.nodes:\n            assert k is ops[k.queue_idx]\n\n        # Finally, checking the adjacency of the returned DAG:\n        assert set(graph.edges()) == set(\n            (ops[a], ops[b])\n            for a, b in [(0, 3), (1, 3), (2, 4), (3, 5), (3, 6), (4, 5), (5, 7), (5, 8), (6, 8),]\n        )\n\n    def test_ancestors_and_descendants_example(self, ops):\n        """"""\n        Test that the ``ancestors`` and ``descendants`` methods return the expected result.\n        """"""\n        circuit = CircuitGraph(ops, {})\n\n        ancestors = circuit.ancestors([ops[6]])\n        assert len(ancestors) == 3\n        for o_idx in (0, 1, 3):\n            assert ops[o_idx] in ancestors\n\n        descendants = circuit.descendants([ops[6]])\n        assert descendants == set([ops[8]])\n\n    def test_update_node(self, ops):\n        """"""Changing nodes in the graph.""""""\n\n        circuit = CircuitGraph(ops, {})\n        new = qml.RX(0.1, wires=0)\n        circuit.update_node(ops[0], new)\n        assert circuit.operations[0] is new\n\n    def test_observables(self, circuit, obs):\n        """"""Test that the `observables` property returns the list of observables in the circuit.""""""\n        assert circuit.observables == obs\n\n    def test_operations(self, circuit, queue):\n        """"""Test that the `operations` property returns the list of operations in the circuit.""""""\n        assert circuit.operations == queue\n\n    def test_op_indices(self, circuit):\n        """"""Test that for the given circuit, this method will fetch the correct operation indices for\n        a given wire""""""\n        op_indices_for_wire_0 = [0, 3, 5, 7]\n        op_indices_for_wire_1 = [1, 3, 6, 8]\n        op_indices_for_wire_2 = [2, 4, 5, 8]\n\n        assert circuit.wire_indices(0) == op_indices_for_wire_0\n        assert circuit.wire_indices(1) == op_indices_for_wire_1\n        assert circuit.wire_indices(2) == op_indices_for_wire_2\n\n    def test_layers(self, parameterized_circuit):\n        """"""A test of a simple circuit with 3 layers and 6 parameters""""""\n\n        dev = qml.device(""default.gaussian"", wires=3)\n        qnode = qml.QNode(parameterized_circuit, dev)\n        qnode._construct((0.1, 0.2, 0.3, 0.4, 0.5, 0.6), {})\n        circuit = qnode.circuit\n        layers = circuit.parametrized_layers\n        ops = circuit.operations\n\n        assert len(layers) == 3\n        assert layers[0].ops == [ops[x] for x in [0, 1, 2]]\n        assert layers[0].param_inds == [0, 1, 2]\n        assert layers[1].ops == [ops[3]]\n        assert layers[1].param_inds == [3]\n        assert layers[2].ops == [ops[x] for x in [5, 6]]\n        assert layers[2].param_inds == [4, 5]\n\n    def test_iterate_layers(self, parameterized_circuit):\n        """"""A test of the different layers, their successors and ancestors using a simple circuit""""""\n\n        dev = qml.device(""default.gaussian"", wires=3)\n        qnode = qml.QNode(parameterized_circuit, dev)\n        qnode._construct((0.1, 0.2, 0.3, 0.4, 0.5, 0.6), {})\n        circuit = qnode.circuit\n        result = list(circuit.iterate_parametrized_layers())\n\n        assert len(result) == 3\n        assert set(result[0][0]) == set([])\n        assert set(result[0][1]) == set(circuit.operations[:3])\n        assert result[0][2] == (0, 1, 2)\n        assert set(result[0][3]) == set(circuit.operations[3:] + circuit.observables)\n\n        assert set(result[1][0]) == set(circuit.operations[:2])\n        assert set(result[1][1]) == set([circuit.operations[3]])\n        assert result[1][2] == (3,)\n        assert set(result[1][3]) == set(circuit.operations[4:6] + circuit.observables[:2])\n\n        assert set(result[2][0]) == set(circuit.operations[:4])\n        assert set(result[2][1]) == set(circuit.operations[5:])\n        assert result[2][2] == (4, 5)\n        assert set(result[2][3]) == set(circuit.observables[1:])\n\n    def test_diagonalizing_gates(self):\n        """"""Tests that the diagonalizing gates are correct for a circuit""""""\n        circuit = CircuitGraph([qml.expval(qml.PauliX(0)), qml.var(qml.PauliZ(1))], {})\n        diag_gates = circuit.diagonalizing_gates\n\n        assert len(diag_gates) == 1\n        assert isinstance(diag_gates[0], qml.Hadamard)\n        assert diag_gates[0].wires == Wires([0])\n\n    def test_is_sampled(self):\n        """"""Test that circuit graphs with sampled observables properly return\n        True for CircuitGraph.is_sampled""""""\n        circuit = CircuitGraph([qml.expval(qml.PauliX(0)), qml.var(qml.PauliZ(1))], {})\n        assert not circuit.is_sampled\n\n        circuit = CircuitGraph([qml.expval(qml.PauliX(0)), qml.sample(qml.PauliZ(1))], {})\n        assert circuit.is_sampled\n\n'"
tests/circuit_graph/test_circuit_graph_hash.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit and integration tests for creating the :mod:`pennylane` :attr:`QNode.circuit.hash` attribute.\n""""""\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.operation import Tensor\nfrom pennylane.circuit_graph import CircuitGraph\nfrom pennylane.qnodes import BaseQNode\nfrom pennylane.variable import Variable\n\nclass TestCircuitGraphHash:\n    """"""Test the creation of a hash on a CircuitGraph""""""\n\n    numeric_queues = [\n                        ([\n                            qml.RX(0.3, wires=[0])\n                        ],\n                         [],\n                        \'RX!0.3![0]|||\'\n                        ),\n                        ([\n                            qml.RX(0.3, wires=[0]),\n                            qml.RX(0.4, wires=[1]),\n                            qml.RX(0.5, wires=[2]),\n                        ],\n                         [],\n                        \'RX!0.3![0]RX!0.4![1]RX!0.5![2]|||\'\n                        )\n                     ]\n\n    @pytest.mark.parametrize(""queue, observable_queue, expected_string"", numeric_queues)\n    def test_serialize_numeric_arguments(self, queue, observable_queue, expected_string):\n        """"""Tests that the same hash is created for two circuitgraphs that have numeric arguments.""""""\n        circuit_graph_1 = CircuitGraph(queue + observable_queue, {})\n        circuit_graph_2 = CircuitGraph(queue + observable_queue, {})\n\n        assert circuit_graph_1.serialize() == circuit_graph_2.serialize()\n        assert expected_string == circuit_graph_1.serialize()\n\n\n    variable = Variable(1)\n\n    symbolic_queue = [\n                        ([qml.RX(variable, wires=[0])],\n                         [],\n                        \'RX!V1![0]|||\'\n                        ),\n\n                    ]\n\n\n    @pytest.mark.parametrize(""queue, observable_queue, expected_string"", symbolic_queue)\n    def test_serialize_symbolic_argument(self, queue, observable_queue, expected_string):\n        """"""Tests that the same hash is created for two circuitgraphs that have symbolic arguments.""""""\n        circuit_graph_1 = CircuitGraph(queue + observable_queue, {})\n        circuit_graph_2 = CircuitGraph(queue + observable_queue, {})\n\n        assert circuit_graph_1.serialize() == circuit_graph_2.serialize()\n        assert expected_string == circuit_graph_1.serialize()\n\n\n    variable = Variable(1)\n\n    symbolic_queue = [\n                        ([\n                            qml.RX(variable, wires=[0]),\n                            qml.RX(0.3, wires=[1]),\n                            qml.RX(variable, wires=[2])\n                        ],\n                         [],\n                        \'RX!V1![0]RX!0.3![1]RX!V1![2]|||\'\n                        ),\n\n                        ]\n\n\n    @pytest.mark.parametrize(""queue, observable_queue, expected_string"", symbolic_queue)\n    def test_serialize_numeric_and_symbolic_argument(self, queue, observable_queue, expected_string):\n        """"""Tests that the same hash is created for two circuitgraphs that have both numeric and symbolic arguments.""""""\n\n        circuit_graph_1 = CircuitGraph(queue + observable_queue, {})\n        circuit_graph_2 = CircuitGraph(queue + observable_queue, {})\n\n        assert circuit_graph_1.serialize() == circuit_graph_2.serialize()\n        assert expected_string == circuit_graph_1.serialize()\n\n    variable = Variable(1)\n\n    many_symbolic_queue = [\n                        ([\n                            qml.RX(variable, wires=[0]),\n                            qml.RX(variable, wires=[1])\n                            ],\n                         [],\n                        \'RX!V1![0]\' +\n                        \'RX!V1![1]\' +\n                        \'|||\'\n                        ),\n\n                        ]\n\n    @pytest.mark.parametrize(""queue, observable_queue, expected_string"", many_symbolic_queue)\n    def test_serialize_symbolic_argument_multiple_times(self, queue, observable_queue, expected_string):\n        """"""Tests that the same hash is created for two circuitgraphs that have the same symbolic argument\n        used multiple times.""""""\n        circuit_graph_1 = CircuitGraph(queue + observable_queue, {})\n        circuit_graph_2 = CircuitGraph(queue + observable_queue, {})\n\n        assert circuit_graph_1.serialize() == circuit_graph_2.serialize()\n        assert expected_string == circuit_graph_1.serialize()\n\n    variable1 = Variable(1)\n    variable2 = Variable(2)\n\n    multiple_symbolic_queue = [\n                        ([\n                            qml.RX(variable1, wires=[0]),\n                            qml.RX(variable2, wires=[1])\n                            ],\n                         [],\n                        \'RX!V1![0]\' +\n                        \'RX!V2![1]\' +\n                        \'|||\'\n                        ),\n                        ]\n\n    @pytest.mark.parametrize(""queue, observable_queue, expected_string"", multiple_symbolic_queue)\n    def test_serialize_multiple_symbolic_arguments(self, queue, observable_queue, expected_string):\n        """"""Tests that the same hash is created for two circuitgraphs that have multiple symbolic arguments.""""""\n\n        circuit_graph_1 = CircuitGraph(queue + observable_queue, {})\n        circuit_graph_2 = CircuitGraph(queue + observable_queue, {})\n\n        assert circuit_graph_1.serialize() == circuit_graph_2.serialize()\n        assert expected_string == circuit_graph_1.serialize()\n\n\n    observable1 = qml.PauliZ(0)\n    observable1.return_type = not None\n\n    observable2 = qml.Hermitian(np.array([[1, 0],[0, -1]]), wires=[0])\n    observable2.return_type = not None\n\n    observable3 = Tensor(qml.PauliZ(0) @ qml.PauliZ(1))\n    observable3.return_type = not None\n\n    numeric_observable_queue = [\n                        ([],\n                         [observable1],\n                        \'|||PauliZ[0]\'\n                        ),\n                        (\n                         [],\n                         [observable2],\n                        \'|||Hermitian![[ 1  0]\\n [ 0 -1]]![0]\'\n                        ),\n                        (\n                         [],\n                         [observable3],\n                        \'|||[\\\'PauliZ\\\', \\\'PauliZ\\\'][0, 1]\'\n                        )\n\n                     ]\n\n    @pytest.mark.parametrize(""queue, observable_queue, expected_string"", numeric_observable_queue)\n    def test_serialize_numeric_arguments_observables(self, queue, observable_queue, expected_string):\n        """"""Tests that the same hash is created for two circuitgraphs that have identical queues and empty variable_deps.""""""\n\n        circuit_graph_1 = CircuitGraph(queue + observable_queue, {})\n        circuit_graph_2 = CircuitGraph(queue + observable_queue, {})\n\n        assert circuit_graph_1.serialize() == circuit_graph_2.serialize()\n        assert expected_string == circuit_graph_1.serialize()\n\n\nclass TestQNodeCircuitHashIntegration:\n    """"""Test for the circuit hash that is being created for a QNode during evaluation (inside of _construct)""""""\n\n    def test_evaluate_circuit_hash_numeric(self):\n        """"""Tests that the circuit hash of identical circuits containing only numeric parameters are equal""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        a = 0.3\n        b = 0.2\n\n        def circuit1():\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2():\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_symbolic(self, x, y):\n        """"""Tests that the circuit hash of identical circuits containing only symbolic parameters are equal""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit1(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_numeric_and_symbolic(self, x, y):\n        """"""Tests that the circuit hash of identical circuits containing numeric and symbolic parameters are equal""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""a,b"",\n        zip(np.linspace(0.1, 2 * np.pi, 3), np.linspace(0, 2 * np.pi, 3)),\n    )\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 0, 3), np.linspace(-2 * np.pi, 0, 3)),\n    )\n    def test_evaluate_circuit_hash_symbolic_assigned_arguments_do_not_matter(self, a, b, x, y):\n        """"""Tests that the circuit hashes of identical circuits where different values are assigned to symbolic parameters are equal""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit1(a, b):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([a, b], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_numeric_and_symbolic_tensor_return(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits having a tensor product in the return\n        statement are equal""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_same_operation_has_numeric_and_symbolic(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits where one operation has both numeric\n        and symbolic arguments are equal""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_numeric_and_symbolic_return_type_does_not_matter(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits only differing on their return types are equal""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.var(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        def circuit3(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.sample(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node3 = BaseQNode(circuit1, dev)\n        node3.evaluate([x, y], {})\n        circuit_hash_3 = node3.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2 == circuit_hash_3\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_hermitian(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits containing a Hermitian observable are equal""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        matrix = np.array([[1, 0], [0, 1]])\n\n        def circuit1(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.Hermitian(matrix, wires=[0]) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.Hermitian(matrix, wires=[0]) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 == circuit_hash_2\n\nclass TestQNodeCircuitHashDifferentHashIntegration:\n    """"""Tests for checking that different circuit graph hashes are being created for different circuits in a QNode during evaluation (inside of _construct)""""""\n\n    def test_evaluate_circuit_hash_numeric_different(self):\n        """"""Tests that the circuit hashes of identical circuits except for one numeric value are different""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        a = 0.3\n        b = 0.2\n\n        def circuit1():\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        c = 0.6\n\n        def circuit2():\n            qml.RX(c, wires=[0])\n            qml.RY(b, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    def test_evaluate_circuit_hash_numeric_different_operation(self):\n        """"""Tests that the circuit hashes of identical circuits except for one of the operations are different""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        a = 0.3\n\n        def circuit1():\n            qml.RX(a, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2():\n            qml.RY(a, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_numeric_and_symbolic_operation_differs(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits that have numeric and symbolic arguments\n        except for one of the operations are different""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.RX(x, wires=[0])\n            qml.RZ(y, wires=[1])          # <-------------------------------------- RZ\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])          # <-------------------------------------- RY\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_different_return_observable_vs_tensor(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits except for the return statement are different""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))                        # <------------- qml.PauliZ(0)\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.3, wires=[2])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))         # <------------- qml.PauliZ(0) @ qml.PauliX(1)\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_same_operation_has_numeric_and_symbolic_different_order(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits except for the order of numeric and symbolic arguments\n        in one of the operations are different.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.Rot(x, 0.3, y, wires=[0])         # <------------- x, 0.3, y\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])         # <------------- x, y, 0.3\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_same_operation_has_numeric_and_symbolic_different_argument(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits except for the numeric value \n        in one of the operations are different.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])         # <------------- 0.3\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.5, wires=[0])         # <------------- 0.5\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 2), np.linspace(-2 * np.pi, 2 * np.pi, 2) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_same_operation_has_numeric_and_symbolic_different_wires(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits except for the wires\n        in one of the operations are different.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])                               #<------ wires = [0, 1]\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[1, 0])                               #<------ wires = [1, 0]\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 2), np.linspace(-2 * np.pi, 2 * np.pi, 2) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_same_operation_has_numeric_and_symbolic_different_wires_in_return(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits except for the wires\n        in the return statement are different.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))         # <----- (0) @ (1)\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(2))         # <----- (0) @ (2)\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_numeric_and_symbolic_different_parameter(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits except for the numeric argument of a signle operation\n        in the circuits are different""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit1(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.3, wires=[2])         # <------------- 0.3\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.RZ(0.5, wires=[2])         # <------------- 0.5\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 2), np.linspace(-2 * np.pi, 2 * np.pi, 2) ** 2 / 11),\n    )\n    def test_evaluate_circuit_hash_hermitian_different_matrices(self, x, y):\n        """"""Tests that the circuit hashes of identical circuits except for the matrix argument of the Hermitian observable\n        in the return statement are different.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        matrix_1 = np.array([[1, 0], [0, 1]])\n        matrix_2 = np.array([[1, 0], [0, -1]])\n\n        def circuit1(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.Hermitian(matrix_1, wires=[0]) @ qml.PauliX(1))\n\n        node1 = BaseQNode(circuit1, dev)\n        node1.evaluate([x, y], {})\n        circuit_hash_1 = node1.circuit.hash\n\n        def circuit2(x, y):\n            qml.Rot(x, y, 0.3, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.Hermitian(matrix_2, wires=[0]) @ qml.PauliX(1))\n\n        node2 = BaseQNode(circuit2, dev)\n        node2.evaluate([x, y], {})\n        circuit_hash_2 = node2.circuit.hash\n\n        assert circuit_hash_1 != circuit_hash_2\n\n    def test_compiled_program_was_stored(self):\n        """"""Test that QVM device stores the compiled program correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit(params, wires):\n            qml.Hadamard(0)\n            qml.CNOT(wires=[0, 1])\n\n        obs = [qml.PauliZ(0) @ qml.PauliZ(1)]\n        obs_list = obs * 6\n\n        qnodes = qml.map(circuit, obs_list, dev)\n        qnodes([], parallel=True)\n\n        hashes = set()\n        for qnode in qnodes:\n            hashes.add(qnode.circuit.hash)\n\n        assert len(hashes) == 1\n\n'"
tests/circuit_graph/test_qasm.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nUnit tests for the :mod:`pennylane.circuit_graph.to_openqasm()` method.\r\n""""""\r\n# pylint: disable=no-self-use,too-many-arguments,protected-access\r\nfrom textwrap import dedent\r\n\r\nimport numpy as np\r\nimport pytest\r\n\r\nimport pennylane as qml\r\nfrom pennylane import CircuitGraph\r\nfrom pennylane.wires import Wires\r\n\r\n\r\nclass TestToQasmUnitTests:\r\n    """"""Unit tests for the to_openqasm() method""""""\r\n\r\n    def test_empty_circuit(self):\r\n        """"""Test that an empty circuit graph is properly\r\n        serialized into an empty QASM program.""""""\r\n        circuit = CircuitGraph([], {})\r\n        res = circuit.to_openqasm()\r\n        expected = \'OPENQASM 2.0;\\ninclude ""qelib1.inc"";\\n\'\r\n        assert res == expected\r\n\r\n    def test_native_qasm_gates(self):\r\n        """"""Test that a circuit containing solely native QASM\r\n        gates is properly serialized.""""""\r\n        ops = [\r\n            qml.RX(0.43, wires=0),\r\n            qml.RY(0.35, wires=1),\r\n            qml.RZ(0.35, wires=2),\r\n            qml.CNOT(wires=[0, 1]),\r\n            qml.Hadamard(wires=2),\r\n            qml.CNOT(wires=[2, 0]),\r\n            qml.PauliX(wires=1),\r\n        ]\r\n\r\n        circuit = CircuitGraph(ops, {})\r\n        res = circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[3];\r\n            creg c[3];\r\n            rx(0.43) q[0];\r\n            ry(0.35) q[1];\r\n            rz(0.35) q[2];\r\n            cx q[0],q[1];\r\n            h q[2];\r\n            cx q[2],q[0];\r\n            x q[1];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_native_inverse_gates(self):\r\n        """"""Test that a circuit containing inverse gates that are supported\r\n        natively by QASM, such as sdg, are correctly serialized.""""""\r\n        ops = [\r\n            qml.S(wires=0),\r\n            qml.S(wires=0).inv(),\r\n            qml.T(wires=0),\r\n            qml.T(wires=0).inv(),\r\n        ]\r\n\r\n        circuit = CircuitGraph(ops, {})\r\n        res = circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[1];\r\n            creg c[1];\r\n            s q[0];\r\n            sdg q[0];\r\n            t q[0];\r\n            tdg q[0];\r\n            measure q[0] -> c[0];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_unused_wires(self):\r\n        """"""Test that unused wires are correctly taken into account""""""\r\n        ops = [\r\n            qml.Hadamard(wires=4),\r\n            qml.CNOT(wires=[1, 0]),\r\n        ]\r\n\r\n        circuit = CircuitGraph(ops, {})\r\n        res = circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[5];\r\n            creg c[5];\r\n            h q[4];\r\n            cx q[1],q[0];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            measure q[3] -> c[3];\r\n            measure q[4] -> c[4];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_rotation_gate_decomposition(self):\r\n        """"""Test that gates not natively supported by QASM, such as the\r\n        rotation gate, are correctly decomposed and serialized.""""""\r\n        ops1 = [qml.Rot(0.3, 0.1, 0.2, wires=1)]\r\n        circuit1 = CircuitGraph(ops1, {})\r\n        qasm1 = circuit1.to_openqasm()\r\n\r\n        ops2 = qml.Rot.decomposition(0.3, 0.1, 0.2, wires=1)\r\n        circuit2 = CircuitGraph(ops2, {})\r\n        qasm2 = circuit2.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[2];\r\n            creg c[2];\r\n            rz(0.3) q[1];\r\n            ry(0.1) q[1];\r\n            rz(0.2) q[1];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            """"""\r\n        )\r\n\r\n        assert qasm1 == expected\r\n        assert qasm1 == qasm2\r\n\r\n    def test_state_initialization_decomposition(self):\r\n        """"""Test that the Mottonen state prepration decomposition\r\n        is correctly applied.""""""\r\n        psi = np.array([1, -1, -1, 1]) / np.sqrt(4)\r\n\r\n        ops1 = [qml.QubitStateVector(psi, wires=[0, 1])]\r\n        circuit1 = CircuitGraph(ops1, {})\r\n        qasm1 = circuit1.to_openqasm()\r\n\r\n        ops2 = qml.QubitStateVector.decomposition(psi, wires=[0, 1])\r\n        circuit2 = CircuitGraph(ops2, {})\r\n        qasm2 = circuit2.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[2];\r\n            creg c[2];\r\n            ry(1.5707963267948968) q[1];\r\n            ry(1.5707963267948963) q[0];\r\n            cx q[1],q[0];\r\n            ry(0.0) q[0];\r\n            cx q[1],q[0];\r\n            rz(0.0) q[0];\r\n            cx q[1],q[0];\r\n            rz(3.141592653589793) q[0];\r\n            cx q[1],q[0];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            """"""\r\n        )\r\n\r\n        assert qasm1 == expected\r\n        assert qasm1 == qasm2\r\n\r\n    def test_basis_state_initialization_decomposition(self):\r\n        """"""Test that the basis state preparation decomposition\r\n\r\n        is correctly applied.""""""\r\n        basis_state = np.array([1, 0, 1, 1])\r\n\r\n        ops1 = [qml.BasisState(basis_state, wires=[0, 1, 2, 3])]\r\n        circuit1 = CircuitGraph(ops1, {})\r\n        qasm1 = circuit1.to_openqasm()\r\n\r\n        ops2 = qml.BasisState.decomposition(basis_state, wires=[0, 1, 2, 3])\r\n        circuit2 = CircuitGraph(ops2, {})\r\n        qasm2 = circuit2.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[4];\r\n            creg c[4];\r\n            x q[0];\r\n            x q[2];\r\n            x q[3];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            measure q[3] -> c[3];\r\n            """"""\r\n        )\r\n\r\n        assert qasm1 == expected\r\n        assert qasm1 == qasm2\r\n\r\n    def test_unsupported_gate(self):\r\n        """"""Test an exception is raised if an unsupported operation is\r\n        applied.""""""\r\n        U = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\r\n        ops = [qml.S(wires=0), qml.QubitUnitary(U, wires=[0, 1])]\r\n\r\n        circuit = CircuitGraph(ops, {})\r\n\r\n        with pytest.raises(\r\n            qml.DeviceError, match=""Gate QubitUnitary not supported on device QASM serializer""\r\n        ):\r\n            res = circuit.to_openqasm()\r\n\r\n    def test_rotations(self):\r\n        """"""Test that observable rotations are correctly applied.""""""\r\n        ops = [\r\n            qml.Hadamard(wires=0),\r\n            qml.CNOT(wires=[0, 1]),\r\n            qml.expval(qml.PauliX(0)),\r\n            qml.expval(qml.PauliZ(1)),\r\n            qml.expval(qml.Hadamard(2)),\r\n        ]\r\n\r\n        circuit = CircuitGraph(ops, {})\r\n        res = circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[3];\r\n            creg c[3];\r\n            h q[0];\r\n            cx q[0],q[1];\r\n            h q[0];\r\n            ry(-0.7853981633974483) q[2];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n        ops2 = circuit.operations + circuit.diagonalizing_gates\r\n        circuit2 = CircuitGraph(ops2, {})\r\n        qasm2 = circuit2.to_openqasm()\r\n\r\n        assert res == qasm2\r\n\r\n\r\nclass TestQNodeQasmIntegrationTests:\r\n    """"""Test that the QASM serialization works correctly\r\n    when circuits are created via QNodes.""""""\r\n\r\n    def test_empty_circuit(self):\r\n        """"""Test that an empty QNode is properly\r\n        serialized into an empty QASM program.""""""\r\n        dev = qml.device(""default.qubit"", wires=1)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode():\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode()\r\n\r\n        res = qnode.circuit.to_openqasm()\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[1];\r\n            creg c[1];\r\n            measure q[0] -> c[0];\r\n            """"""\r\n        )\r\n        assert res == expected\r\n\r\n    def test_native_qasm_gates(self):\r\n        """"""Test that a QNode containing solely native QASM\r\n        gates is properly serialized.""""""\r\n        dev = qml.device(""default.qubit"", wires=3)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode():\r\n            qml.RX(0.43, wires=0)\r\n            qml.RY(0.35, wires=1)\r\n            qml.RZ(0.35, wires=2)\r\n            qml.CNOT(wires=[0, 1])\r\n            qml.Hadamard(wires=2)\r\n            qml.CNOT(wires=[2, 0])\r\n            qml.PauliX(wires=1)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode()\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[3];\r\n            creg c[3];\r\n            rx(0.43) q[0];\r\n            ry(0.35) q[1];\r\n            rz(0.35) q[2];\r\n            cx q[0],q[1];\r\n            h q[2];\r\n            cx q[2],q[0];\r\n            x q[1];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_parametrized_native_qasm_gates(self):\r\n        """"""Test that a QNode containing solely native QASM\r\n        gates, as well as input parameters, is properly serialized.\r\n        In addition, double check the serialization changes as parameters\r\n        are changed.""""""\r\n        dev = qml.device(""default.qubit"", wires=3)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode(x, y):\r\n            qml.RX(x, wires=0)\r\n            qml.RY(y[0], wires=1)\r\n            qml.RZ(y[1], wires=2)\r\n            qml.CNOT(wires=[0, 1])\r\n            qml.Hadamard(wires=2)\r\n            qml.CNOT(wires=[2, 0])\r\n            qml.PauliX(wires=1)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # execute the QNode with parameters, and serialize\r\n        params = np.array([0.5, [0.2, 0.1]])\r\n        qnode(*params)\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[3];\r\n            creg c[3];\r\n            rx(0.5) q[0];\r\n            ry(0.2) q[1];\r\n            rz(0.1) q[2];\r\n            cx q[0],q[1];\r\n            h q[2];\r\n            cx q[2],q[0];\r\n            x q[1];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            """"""\r\n        )\r\n\r\n        res = qnode.circuit.to_openqasm()\r\n        assert res == expected\r\n\r\n        # execute the QNode with new parameters, and serialize again\r\n        params = np.array([0.1, [0.3, 0.2]])\r\n        qnode(*params)\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[3];\r\n            creg c[3];\r\n            rx(0.1) q[0];\r\n            ry(0.3) q[1];\r\n            rz(0.2) q[2];\r\n            cx q[0],q[1];\r\n            h q[2];\r\n            cx q[2],q[0];\r\n            x q[1];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            """"""\r\n        )\r\n\r\n        res = qnode.circuit.to_openqasm()\r\n        assert res == expected\r\n\r\n    def test_native_inverse_gates(self):\r\n        """"""Test that a QNode containing inverse gates that are supported\r\n        natively by QASM, such as sdg, are correctly serialized.""""""\r\n        dev = qml.device(""default.qubit"", wires=1)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode():\r\n            qml.S(wires=0)\r\n            qml.S(wires=0).inv()\r\n            qml.T(wires=0)\r\n            qml.T(wires=0).inv()\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode()\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[1];\r\n            creg c[1];\r\n            s q[0];\r\n            sdg q[0];\r\n            t q[0];\r\n            tdg q[0];\r\n            measure q[0] -> c[0];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_unused_wires(self):\r\n        """"""Test that unused wires are correctly taken into account""""""\r\n        dev = qml.device(""default.qubit"", wires=5)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode():\r\n            qml.Hadamard(wires=4)\r\n            qml.CNOT(wires=[1, 0])\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode()\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[5];\r\n            creg c[5];\r\n            h q[4];\r\n            cx q[1],q[0];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            measure q[3] -> c[3];\r\n            measure q[4] -> c[4];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_rotation_gate_decomposition(self):\r\n        """"""Test that gates not natively supported by QASM, such as the\r\n        rotation gate, are correctly decomposed and serialized.""""""\r\n        dev = qml.device(""default.qubit"", wires=2)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode():\r\n            qml.Rot(0.3, 0.1, 0.2, wires=1)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode()\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[2];\r\n            creg c[2];\r\n            rz(0.3) q[1];\r\n            ry(0.1) q[1];\r\n            rz(0.2) q[1];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_state_initialization_decomposition(self):\r\n        """"""Test that the Mottonen state prepration decomposition\r\n        is correctly applied.""""""\r\n        dev = qml.device(""default.qubit"", wires=2)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode(state=None):\r\n            qml.QubitStateVector(state, wires=[0, 1])\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode(state=np.array([1, -1, -1, 1]) / np.sqrt(4))\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[2];\r\n            creg c[2];\r\n            ry(1.5707963267948968) q[1];\r\n            ry(1.5707963267948963) q[0];\r\n            cx q[1],q[0];\r\n            ry(0.0) q[0];\r\n            cx q[1],q[0];\r\n            rz(0.0) q[0];\r\n            cx q[1],q[0];\r\n            rz(3.141592653589793) q[0];\r\n            cx q[1],q[0];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_basis_state_initialization_decomposition(self):\r\n        """"""Test that the basis state prepration decomposition\r\n        is correctly applied.""""""\r\n        dev = qml.device(""default.qubit"", wires=4)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode(state=None):\r\n            qml.BasisState(state, wires=[0, 1, 2, 3])\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode(state=np.array([1, 0, 1, 1]))\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[4];\r\n            creg c[4];\r\n            x q[0];\r\n            x q[2];\r\n            x q[3];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            measure q[3] -> c[3];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n    def test_unsupported_gate(self):\r\n        """"""Test an exception is raised if an unsupported operation is\r\n        applied.""""""\r\n        U = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\r\n        dev = qml.device(""default.qubit"", wires=1)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode():\r\n            qml.S(wires=0)\r\n            qml.QubitUnitary(U, wires=0)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        qnode()\r\n\r\n        with pytest.raises(\r\n            qml.DeviceError, match=""Gate QubitUnitary not supported on device QASM serializer""\r\n        ):\r\n            qnode.circuit.to_openqasm()\r\n\r\n    def test_rotations(self):\r\n        """"""Test that observable rotations are correctly applied.""""""\r\n        dev = qml.device(""default.qubit"", wires=3)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode():\r\n            qml.Hadamard(wires=0)\r\n            qml.CNOT(wires=[0, 1])\r\n            return [\r\n                qml.expval(qml.PauliX(0)),\r\n                qml.expval(qml.PauliZ(1)),\r\n                qml.expval(qml.Hadamard(2)),\r\n            ]\r\n\r\n        qnode()\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        expected = dedent(\r\n            """"""\\\r\n            OPENQASM 2.0;\r\n            include ""qelib1.inc"";\r\n            qreg q[3];\r\n            creg c[3];\r\n            h q[0];\r\n            cx q[0],q[1];\r\n            h q[0];\r\n            ry(-0.7853981633974483) q[2];\r\n            measure q[0] -> c[0];\r\n            measure q[1] -> c[1];\r\n            measure q[2] -> c[2];\r\n            """"""\r\n        )\r\n\r\n        assert res == expected\r\n\r\n\r\nclass TestQASMConformanceTests:\r\n    """"""Conformance tests to ensure that the CircuitGraph\r\n    serialized QASM conforms to the QASM standard as implemented\r\n    by Qiskit. Note that this test class requires Qiskit and\r\n    PennyLane-Qiskit as a dependency.""""""\r\n\r\n\r\n    @pytest.fixture\r\n    def check_dependencies(self):\r\n        self.qiskit = pytest.importorskip(""qiskit"", minversion=""0.14.1"")\r\n        pl_qiskit = pytest.importorskip(""pennylane_qiskit"")\r\n\r\n    def test_agrees_qiskit_plugin(self, check_dependencies):\r\n        """"""Test that the QASM generated by the CircuitGraph agrees\r\n        with the QASM generated by the PennyLane-Qiskit plugin.""""""\r\n        dev = qml.device(""qiskit.basicaer"", wires=3)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode(x):\r\n            qml.Hadamard(wires=0)\r\n            qml.RY(x[1], wires=0)\r\n            qml.CNOT(wires=[0, 1])\r\n            qml.RX(x[0], wires=1)\r\n            return [\r\n                qml.expval(qml.PauliX(0)),\r\n                qml.expval(qml.PauliZ(1)),\r\n                qml.expval(qml.Hadamard(2)),\r\n            ]\r\n\r\n        qnode([0.1, 0.2])\r\n        res = qnode.circuit.to_openqasm()\r\n\r\n        # Note: Qiskit hardcodes in pi as a QASM constant.\r\n        # Here, we replace it with its numerical value.\r\n        expected = dev._circuit.qasm().replace(""pi/4"", str(np.pi / 4))\r\n\r\n        assert res == expected\r\n\r\n    def test_basis_state_agrees_qiskit_plugin(self, check_dependencies):\r\n        """"""Test that the basis state prepration QASM agrees\r\n        with that generated by the PennyLane-Qiskit plugin. This is\r\n        a useful test to ensure that we are using the correct qubit\r\n        ordering convention.""""""\r\n        dev = qml.device(""qiskit.basicaer"", wires=4)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode(state=None):\r\n            qml.BasisState(state, wires=[0, 1, 2, 3])\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        # construct the qnode circuit\r\n        qnode(state=np.array([1, 0, 1, 1]))\r\n        res = qnode.circuit.to_openqasm()\r\n        expected = dev._circuit.qasm()\r\n\r\n        assert res == expected\r\n\r\n    def test_qiskit_load_generated_qasm(self, check_dependencies):\r\n        """"""Test that the QASM generated by the CircuitGraph\r\n        corresponds to valid QASM, that can be loaded by Qiskit.""""""\r\n        dev = qml.device(""default.qubit"", wires=3)\r\n\r\n        @qml.qnode(dev)\r\n        def qnode(x):\r\n            qml.Hadamard(wires=0)\r\n            qml.RY(x[1], wires=0)\r\n            qml.CNOT(wires=[0, 1])\r\n            qml.RX(x[0], wires=1)\r\n            return [\r\n                qml.expval(qml.PauliX(0)),\r\n                qml.expval(qml.PauliZ(1)),\r\n                qml.expval(qml.Hadamard(2)),\r\n            ]\r\n\r\n        params = [0.1, 0.2]\r\n        qnode(params)\r\n        qasm = qnode.circuit.to_openqasm()\r\n        qc = self.qiskit.QuantumCircuit.from_qasm_str(qasm)\r\n\r\n        gates = [g for g, _, _ in qc.data]\r\n\r\n        for idx, g in enumerate(gates):\r\n            # attach a wires attribute to each gate, containing\r\n            # a list of wire integers it acts on, so we can assert\r\n            # correctness below.\r\n            g.wires = [q.index for q in qc.data[idx][1]]\r\n\r\n        # operations\r\n        assert gates[0].name == ""h""\r\n        assert gates[0].wires == Wires([0])\r\n\r\n        assert gates[1].name == ""ry""\r\n        assert gates[1].wires == Wires([0])\r\n        assert gates[1].params == [params[1]]\r\n\r\n        assert gates[2].name == ""cx""\r\n        assert gates[2].wires == Wires([0, 1])\r\n\r\n        assert gates[4].name == ""rx""\r\n        assert gates[4].wires == Wires([1])\r\n        assert gates[4].params == [params[0]]\r\n\r\n        # rotations\r\n        assert gates[3].name == ""h""\r\n        assert gates[3].wires == Wires([0])\r\n\r\n        assert gates[5].name == ""ry""\r\n        assert gates[5].wires == Wires([2])\r\n        assert gates[5].params == [-np.pi / 4]\r\n'"
tests/collections/conftest.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Fixtures and configuration for the collections package tests""""""\nimport pytest\n\nimport pennylane as qml\n\n\n@pytest.fixture\ndef qnodes(interface, tf_support, torch_support):\n    """"""fixture returning some QNodes""""""\n    if interface == ""torch"" and not torch_support:\n        pytest.skip(""Skipped, no torch support"")\n\n    if interface == ""tf"" and not tf_support:\n        pytest.skip(""Skipped, no tf support"")\n\n    dev1 = qml.device(""default.qubit"", wires=2)\n    dev2 = qml.device(""default.qubit"", wires=2)\n\n    @qml.qnode(dev1, interface=interface)\n    def qnode1(x):\n        qml.RX(x[0], wires=0)\n        qml.RY(x[1], wires=0)\n        qml.CNOT(wires=[0, 1])\n        return qml.var(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n    @qml.qnode(dev2, interface=interface)\n    def qnode2(x):\n        qml.Hadamard(wires=0)\n        qml.RX(x[0], wires=0)\n        qml.RY(x[1], wires=1)\n        qml.CNOT(wires=[0, 1])\n        return qml.expval(qml.PauliZ(0)), qml.var(qml.PauliZ(1))\n\n    return qnode1, qnode2\n'"
tests/collections/test_collections.py,7,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.collection` submodule.\n""""""\nfrom collections.abc import Sequence\n\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\n\ntry:\n    import torch\nexcept ImportError as e:\n    torch = None\n\ntry:\n    import tensorflow as tf\n\n    if tf.__version__[0] == ""1"":\n        tf.enable_eager_execution()\n\n    from tensorflow import Variable\nexcept ImportError as e:\n    tf = None\n    Variable = None\n\n\nclass TestMap:\n    """"""Test for mapping ansatz over observables or devices,\n    to return a QNode collection""""""\n\n    def test_template_not_callable(self):\n        """"""Test that an exception is correctly called if a\n        template is not callable""""""\n        with pytest.raises(ValueError, match=""template is not a callable""):\n            qml.map(5, 0, 0)\n\n    def test_mapping_over_observables(self):\n        """"""Test that mapping over a list of observables produces\n        a QNodeCollection with the correct QNodes, with a single\n        device broadcast.""""""\n        dev = qml.device(""default.qubit"", wires=1)\n        obs_list = [qml.PauliX(0), qml.PauliY(0)]\n        template = lambda x, wires: qml.RX(x, wires=0)\n\n        qc = qml.map(template, obs_list, dev)\n\n        assert len(qc) == 2\n\n        # evaluate collection so that queue is populated\n        qc(1)\n\n        assert len(qc[0].ops) == 2\n        assert qc[0].ops[0].name == ""RX""\n        assert qc[0].ops[1].name == ""PauliX""\n\n        assert len(qc[1].ops) == 2\n        assert qc[1].ops[0].name == ""RX""\n        assert qc[1].ops[1].name == ""PauliY""\n\n        # test that device is broadcast\n        assert qc[0].device is qc[1].device\n\n    def test_mapping_over_observables_as_tuples(self):\n        """"""Test that mapping over a tuple of observables produces\n        a QNodeCollection with the correct QNodes, with a single\n        device broadcast.""""""\n        dev = qml.device(""default.qubit"", wires=1)\n        obs_list = (qml.PauliX(0), qml.PauliY(0))\n        template = lambda x, wires: qml.RX(x, wires=0)\n\n        qc = qml.map(template, obs_list, dev)\n\n        assert len(qc) == 2\n\n        # evaluate collection so that queue is populated\n        qc(1)\n\n        assert len(qc[0].ops) == 2\n        assert qc[0].ops[0].name == ""RX""\n        assert qc[0].ops[1].name == ""PauliX""\n\n        assert len(qc[1].ops) == 2\n        assert qc[1].ops[0].name == ""RX""\n        assert qc[1].ops[1].name == ""PauliY""\n\n        # test that device is broadcast\n        assert qc[0].device is qc[1].device\n\n    def test_mapping_over_devices(self):\n        """"""Test that mapping over a list of devices produces\n        a QNodeCollection with the correct QNodes""""""\n        dev_list = [qml.device(""default.qubit"", wires=1), qml.device(""default.qubit"", wires=1)]\n\n        obs_list = [qml.PauliX(0), qml.PauliY(0)]\n        template = lambda x, wires: qml.RX(x, wires=0)\n\n        qc = qml.map(template, obs_list, dev_list)\n\n        assert len(qc) == 2\n\n        # evaluate collection so that queue is populated\n        qc(1)\n\n        assert len(qc[0].ops) == 2\n        assert qc[0].ops[0].name == ""RX""\n        assert qc[0].ops[1].name == ""PauliX""\n\n        assert len(qc[1].ops) == 2\n        assert qc[1].ops[0].name == ""RX""\n        assert qc[1].ops[1].name == ""PauliY""\n\n        # test that device is not broadcast\n        assert qc[0].device is not qc[1].device\n        assert qc[0].device is dev_list[0]\n        assert qc[1].device is dev_list[1]\n\n    def test_mapping_over_measurements(self):\n        """"""Test that mapping over a list of measurement types produces\n        a QNodeCollection with the correct QNodes""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        obs_list = [qml.PauliX(0), qml.PauliY(0)]\n        template = lambda x, wires: qml.RX(x, wires=0)\n\n        qc = qml.map(template, obs_list, dev, measure=[""expval"", ""var""])\n\n        assert len(qc) == 2\n\n        # evaluate collection so that queue is populated\n        qc(1)\n\n        assert len(qc[0].ops) == 2\n        assert qc[0].ops[0].name == ""RX""\n        assert qc[0].ops[1].name == ""PauliX""\n        assert qc[0].ops[1].return_type == qml.operation.Expectation\n\n        assert len(qc[1].ops) == 2\n        assert qc[1].ops[0].name == ""RX""\n        assert qc[1].ops[1].name == ""PauliY""\n        assert qc[1].ops[1].return_type == qml.operation.Variance\n\n    def test_invalid_observable(self):\n        """"""Test that an invalid observable raises an exception""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        obs_list = [qml.PauliX(0), qml.S(wires=0)]\n        template = lambda x, wires: qml.RX(x, wires=0)\n\n        with pytest.raises(ValueError, match=""Some or all observables are not valid""):\n            qml.map(template, obs_list, dev, measure=[""expval"", ""var""])\n\n    def test_passing_kwargs(self):\n        """"""Test that the step size and order used for the finite differences\n        differentiation method were passed to the QNode instances using the\n        keyword arguments.""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        obs_list = [qml.PauliX(0), qml.PauliY(0)]\n        template = lambda x, wires: qml.RX(x, wires=0)\n\n        qc = qml.map(template, obs_list, dev, measure=[""expval"", ""var""], h=123, order=2)\n\n        qc(1)\n\n        assert len(qc) == 2\n\n        # Checking the h attribute which contains the step size\n        assert qc[0].h == 123\n        assert qc[1].h == 123\n\n        # Checking that the order is set in each QNode\n        assert qc[0].order == 2\n        assert qc[1].order == 2\n\n\nclass TestApply:\n    """"""Tests for the apply function""""""\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy"", ""torch"", ""tf""])\n    def test_apply_summation(self, qnodes, interface, tf_support, torch_support, tol):\n        """"""Test that summation can be applied using all interfaces""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        if interface == ""tf"" and not tf_support:\n            pytest.skip(""Skipped, no tf support"")\n\n        qnode1, qnode2 = qnodes\n        qc = qml.QNodeCollection([qnode1, qnode2])\n\n        if interface == ""tf"":\n            sfn = tf.reduce_sum\n        elif interface == ""torch"":\n            sfn = torch.sum\n        else:\n            sfn = np.sum\n\n        cost = qml.apply(sfn, qc)\n\n        params = [0.5643, -0.45]\n        res = cost(params)\n        expected = sfn(qc(params))\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy"", ""torch"", ""tf""])\n    def test_nested_apply(self, qnodes, interface, tf_support, torch_support, tol):\n        """"""Test that nested apply can be done using all interfaces""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        if interface == ""tf"" and not tf_support:\n            pytest.skip(""Skipped, no tf support"")\n\n        qnode1, qnode2 = qnodes\n        qc = qml.QNodeCollection([qnode1, qnode2])\n\n        if interface == ""tf"":\n            sinfn = tf.sin\n            sfn = tf.reduce_sum\n        elif interface == ""torch"":\n            sinfn = torch.sin\n            sfn = torch.sum\n        else:\n            sinfn = np.sin\n            sfn = np.sum\n\n        cost = qml.apply(sfn, qml.apply(sinfn, qc))\n\n        params = [0.5643, -0.45]\n        res = cost(params)\n        expected = sfn(sinfn(qc(params)))\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n\nclass TestSum:\n    """"""Tests for the sum function""""""\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy"", ""torch"", ""tf"", None])\n    def test_apply_summation(self, qnodes, interface, tf_support, torch_support, tol):\n        """"""Test that summation can be applied using all interfaces""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        if interface == ""tf"" and not tf_support:\n            pytest.skip(""Skipped, no tf support"")\n\n        qnode1, qnode2 = qnodes\n        qc = qml.QNodeCollection([qnode1, qnode2])\n        cost = qml.sum(qc)\n\n        params = [0.5643, -0.45]\n        res = cost(params)\n        expected = sum(qc[0](params) + qc[1](params))\n\n        if interface in (""tf"", ""torch""):\n            res = res.numpy()\n            expected = expected.numpy()\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_unknown_interface(self, monkeypatch):\n        """"""Test exception raised if the interface is unknown""""""\n        monkeypatch.setattr(qml.QNodeCollection, ""interface"", ""invalid"")\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        qnodes = [qml.QNode(circuit, dev) for i in range(4)]\n        qc = qml.QNodeCollection(qnodes)\n        with pytest.raises(ValueError, match=""Unknown interface invalid""):\n            qml.sum(qc)\n\n\nclass TestDot:\n    """"""Tests for the sum function""""""\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy"", ""torch"", ""tf"", None])\n    def test_dot_product_tensor_qnodes(self, qnodes, interface, tf_support, torch_support):\n        """"""Test that the dot product of tensor.qnodes can be applied using all interfaces""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        if interface == ""tf"" and not tf_support:\n            pytest.skip(""Skipped, no tf support"")\n\n        qnode1, qnode2 = qnodes\n        qc = qml.QNodeCollection([qnode1, qnode2])\n        coeffs = [0.5, -0.1]\n\n        if interface == ""torch"":\n            coeffs = torch.tensor(coeffs, dtype=torch.float64)\n\n        if interface == ""tf"":\n            coeffs = tf.cast(coeffs, dtype=tf.float64)\n\n        # test the dot product of tensor, qnodes\n        cost = qml.dot(coeffs, qc)\n\n        params = [0.5643, -0.45]\n        res = cost(params)\n\n        qcval = qc(params)\n\n        if interface in (""tf"", ""torch""):\n            res = res.numpy()\n            qcval = qcval.numpy()\n            coeffs = coeffs.numpy()\n\n        expected = np.dot(coeffs, qcval)\n        assert np.all(res == expected)\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy"", ""torch"", ""tf"", None])\n    def test_dot_product_qnodes_qnodes(self, qnodes, interface, tf_support, torch_support):\n        """"""Test that the dot product of qnodes.qnodes can be applied using all interfaces""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        if interface == ""tf"" and not tf_support:\n            pytest.skip(""Skipped, no tf support"")\n\n        qnode1, qnode2 = qnodes\n        qc1 = qml.QNodeCollection([qnode1, qnode2])\n        qc2 = qml.QNodeCollection([qnode1, qnode2])\n\n        # test the dot product of qnodes, qnodes\n        cost = qml.dot(qc1, qc2)\n\n        params = [0.5643, -0.45]\n        res = cost(params)\n\n        qc1val = qc1(params)\n        qc2val = qc2(params)\n\n        if interface in (""tf"", ""torch""):\n            res = res.numpy()\n            qc1val = qc1val.numpy()\n            qc2val = qc2val.numpy()\n\n        expected = np.dot(qc1val, qc2val)\n        assert np.all(res == expected)\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy"", ""torch"", ""tf"", None])\n    def test_dot_product_qnodes_tensor(self, qnodes, interface, tf_support, torch_support):\n        """"""Test that the dot product of qnodes.tensor can be applied using all interfaces""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        if interface == ""tf"" and not tf_support:\n            pytest.skip(""Skipped, no tf support"")\n\n        qnode1, _ = qnodes\n        qc = qml.QNodeCollection([qnode1])\n        coeffs = [0.5, -0.1]\n\n        if interface == ""torch"":\n            coeffs = torch.tensor(coeffs, dtype=torch.float64)\n\n        if interface == ""tf"":\n            coeffs = tf.cast(coeffs, dtype=tf.float64)\n\n        # test the dot product of qnodes, tensor\n        cost = qml.dot(qc, coeffs)\n\n        params = [0.5643, -0.45]\n        res = cost(params)\n        qcval = qc(params)\n\n        if interface in (""tf"", ""torch""):\n            res = res.numpy()\n            qcval = qcval.numpy()\n            coeffs = coeffs.numpy()\n\n        expected = np.dot(qcval, coeffs)\n        assert np.all(res == expected)\n\n    def test_unknown_interface(self, monkeypatch):\n        """"""Test exception raised if the interface is unknown""""""\n        monkeypatch.setattr(qml.QNodeCollection, ""interface"", ""invalid"")\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def circuit1(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(dev)\n        def circuit2(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        qc = qml.QNodeCollection([circuit1, circuit2])\n        with pytest.raises(ValueError, match=""Unknown interface invalid""):\n            qml.dot([1, 2], qc)\n\n    def test_no_qnodes(self):\n        """"""Test exception raised if no qnodes are provided as arguments""""""\n        with pytest.raises(ValueError, match=""At least one argument must be a QNodeCollection""):\n            qml.dot([1, 2], [3, 4])\n'"
tests/collections/test_qnode_collection.py,4,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.QNodeCollection`\n""""""\nfrom collections.abc import Sequence\n\nimport numpy as onp\nimport pytest\nfrom pennylane import numpy as np\n\nimport pennylane as qml\n\ntry:\n    import torch\nexcept ImportError as e:\n    torch = None\n\ntry:\n    import tensorflow as tf\n\n    if tf.__version__[0] == ""1"":\n        tf.enable_eager_execution()\n\n    from tensorflow import Variable\nexcept ImportError as e:\n    tf = None\n    Variable = None\n\n\nclass TestConstruction:\n    """"""Tests for the QNodeCollection construction""""""\n\n    def test_empty_init(self):\n        """"""Test that an empty QNode collection can be initialized""""""\n        qc = qml.QNodeCollection()\n        assert qc.qnodes == []\n        assert len(qc) == 0\n\n    def test_init_with_qnodes(self):\n        """"""Test that a QNode collection can be initialized with QNodes""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        qnodes = [qml.QNode(circuit, dev) for i in range(4)]\n        qc = qml.QNodeCollection(qnodes)\n\n        assert qc.qnodes == qnodes\n        assert len(qc) == 4\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy"", ""torch"", ""tf""])\n    def test_interface_property(self, interface, tf_support, torch_support):\n        """"""Test that the interface property correctly\n        resolves interfaces from the internal QNodes""""""\n        if interface == ""torch"" and not torch_support:\n            pytest.skip(""Skipped, no torch support"")\n\n        if interface == ""tf"" and not tf_support:\n            pytest.skip(""Skipped, no tf support"")\n\n        qc = qml.QNodeCollection()\n        assert qc.interface is None\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        qnodes = [qml.QNode(circuit, dev, interface=interface) for i in range(4)]\n        qc = qml.QNodeCollection(qnodes)\n\n        if interface == ""numpy"":\n            # Note: the ""numpy"" interface is deprecated, and\n            # now resolves to ""autograd""\n            interface = ""autograd""\n\n        assert qc.interface == interface\n\n    def test_append_qnode(self):\n        """"""Test that a QNode is correctly appended""""""\n        qc = qml.QNodeCollection()\n        assert qc.qnodes == []\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        qnode = qml.QNode(circuit, dev)\n        qc.append(qnode)\n\n        assert qc.qnodes == [qnode]\n\n    def test_extend_qnodes(self):\n        """"""Test that a list of QNodes is correctly appended""""""\n        qc = qml.QNodeCollection()\n        assert qc.qnodes == []\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        qnodes = [qml.QNode(circuit, dev) for i in range(4)]\n        qc.extend(qnodes)\n\n        assert qc.qnodes == [] + qnodes\n\n    def test_extend_multiple_interface_qnodes(self):\n        """"""Test that an error is returned if QNodes with differing\n        interfaces are attempted to be added to a QNodeCollection""""""\n        qc = qml.QNodeCollection()\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        qnodes = [\n            qml.QNode(circuit, dev, interface=""autograd""),\n            qml.QNode(circuit, dev, interface=None),\n        ]\n\n        with pytest.raises(ValueError, match=""do not all use the same interface""):\n            qc.extend(qnodes)\n\n    def test_extend_interface_mismatch(self):\n        """"""Test that an error is returned if QNodes with a differing\n        interface to the QNode collection are appended""""""\n        qc = qml.QNodeCollection()\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        qnode1 = qml.QNode(circuit, dev, interface=""autograd"")\n        qnode2 = qml.QNode(circuit, dev, interface=None)\n\n        qc.extend([qnode1])\n\n        with pytest.raises(ValueError, match=""Interface mismatch""):\n            qc.extend([qnode2])\n\n    def test_indexing(self):\n        """"""Test that indexing into the QNodeCollection correctly works""""""\n\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        qnodes = [qml.QNode(circuit, dev) for i in range(4)]\n\n        qc = qml.QNodeCollection(qnodes)\n        assert qc[2] == qnodes[2]\n\n    def test_sequence(self):\n        """"""Test that the QNodeCollection is a sequence type""""""\n        qc = qml.QNodeCollection()\n        assert isinstance(qc, Sequence)\n\n\n@pytest.mark.parametrize(""parallel"", [False, True])\nclass TestEvalation:\n    """"""Tests for the QNodeCollection evaluation""""""\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy""])\n    def test_eval_autograd(self, qnodes, parallel, interface):\n        """"""Test correct evaluation of the QNodeCollection using\n        the Autograd interface""""""\n        qnode1, qnode2 = qnodes\n        qc = qml.QNodeCollection([qnode1, qnode2])\n        params = [0.5643, -0.45]\n\n        res = qc(params, parallel=parallel)\n        expected = np.vstack([qnode1(params), qnode2(params)])\n        assert np.all(res == expected)\n\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""numpy""])\n    def test_grad_autograd(self, qnodes, parallel, interface):\n        """"""Test correct gradient of the QNodeCollection using\n        the Autograd interface""""""\n        qnode1, qnode2 = qnodes\n\n        params = [0.5643, -0.45]\n        qc = qml.QNodeCollection([qnode1, qnode2])\n        cost_qc = lambda params: np.sum(qc(params))\n        grad_qc = qml.grad(cost_qc, argnum=0)\n\n        cost_expected = lambda params: np.sum(qnode1(params) + qnode2(params))\n        grad_expected = qml.grad(cost_expected, argnum=0)\n\n        res = grad_qc(params)\n        expected = grad_expected(params)\n\n        assert np.all(res == expected)\n\n    @pytest.mark.parametrize(""interface"", [""torch""])\n    def test_eval_torch(self, qnodes, skip_if_no_torch_support, parallel, interface):\n        """"""Test correct evaluation of the QNodeCollection using\n        the torch interface""""""\n        qnode1, qnode2 = qnodes\n        qc = qml.QNodeCollection([qnode1, qnode2])\n        params = [0.5643, -0.45]\n\n        res = qc(params, parallel=parallel).numpy()\n        expected = np.vstack([qnode1(params), qnode2(params)])\n        assert np.all(res == expected)\n\n    @pytest.mark.parametrize(""interface"", [""torch""])\n    def test_grad_torch(self, qnodes, skip_if_no_torch_support, parallel, interface):\n        """"""Test correct gradient of the QNodeCollection using\n        the torch interface""""""\n        qnode1, qnode2 = qnodes\n\n        # calculate the gradient of the collection using pytorch\n        params = torch.autograd.Variable(torch.tensor([0.5643, -0.45]), requires_grad=True)\n        qc = qml.QNodeCollection([qnode1, qnode2])\n        cost = torch.sum(qc(params, parallel=parallel))\n        cost.backward()\n        res = params.grad.numpy()\n\n        # calculate the gradient of the QNodes individually using pytorch\n        params = torch.autograd.Variable(torch.tensor([0.5643, -0.45]), requires_grad=True)\n        cost = torch.sum(qnode1(params) + qnode2(params))\n        cost.backward()\n        expected = params.grad.numpy()\n\n        assert np.all(res == expected)\n\n    @pytest.mark.parametrize(""interface"", [""tf""])\n    def test_eval_tf(self, qnodes, skip_if_no_tf_support, parallel, interface):\n        """"""Test correct evaluation of the QNodeCollection using\n        the tf interface""""""\n        qnode1, qnode2 = qnodes\n        qc = qml.QNodeCollection([qnode1, qnode2])\n        params = [0.5643, -0.45]\n\n        res = qc(params, parallel=parallel).numpy()\n        expected = onp.vstack([qnode1(params), qnode2(params)])\n        assert np.all(res == expected)\n\n    @pytest.mark.xfail(raises=AttributeError, reason=""Dask breaks the TF gradient tape"")\n    @pytest.mark.parametrize(""interface"", [""tf""])\n    def test_grad_tf(self, qnodes, skip_if_no_tf_support, parallel, interface):\n        """"""Test correct gradient of the QNodeCollection using\n        the tf interface""""""\n        qnode1, qnode2 = qnodes\n\n        # calculate the gradient of the collection using tf\n        params = Variable([0.5643, -0.45])\n        qc = qml.QNodeCollection([qnode1, qnode2])\n\n        with tf.GradientTape() as tape:\n            tape.watch(params)\n\n            if parallel:\n                with pytest.warns(UserWarning):\n                    cost = sum(qc(params, parallel=parallel))\n            else:\n                cost = sum(qc(params, parallel=parallel))\n\n            # the gradient will be None\n            res = tape.gradient(cost, params).numpy()\n\n        # calculate the gradient of the QNodes individually using tf\n        params = Variable([0.5643, -0.45])\n\n        with tf.GradientTape() as tape:\n            tape.watch(params)\n            cost = sum(qnode1(params) + qnode2(params))\n            expected = tape.gradient(cost, params).numpy()\n\n        assert np.all(res == expected)\n'"
tests/interfaces/test_autograd.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`to_autograd` class.\n""""""\n\nimport autograd\nimport autograd.numpy as anp  # only to be used inside classical computational nodes\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane.qnodes.base import QuantumFunctionError\nfrom pennylane.qnodes.qubit import QubitQNode\nfrom pennylane.qnodes.cv import CVQNode\n\nfrom pennylane.interfaces.autograd import to_autograd\n\n\nalpha = 0.5  # displacement in tests\nhbar = 2\nmag_alphas = np.linspace(0, 1.5, 5)\nthetas = np.linspace(-2*np.pi, 2*np.pi, 8)\nsqz_vals = np.linspace(0., 1., 5)\n\n\nclass TestAutogradDetails:\n    """"""Test configuration details of the autograd interface""""""\n\n    def test_interface_str(self, qubit_device_2_wires):\n        """"""Test that the interface string is correctly identified\n        as numpy""""""\n        def circuit(x, y, z):\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        circuit = to_autograd(QubitQNode(circuit, qubit_device_2_wires))\n        assert circuit.interface == ""autograd""\n\n\nclass TestAutogradJacobianCV:\n    """"""Tests involving Autograd functions grad and jacobian for CV circuits.""""""\n\n    @pytest.mark.parametrize(\'theta\', thetas)\n    def test_rotation_gradient(self, theta, tol):\n        """"""Tests that the automatic gradient of a phase space rotation is correct.""""""\n\n        def circuit(y):\n            qml.Displacement(alpha, 0., wires=[0])\n            qml.Rotation(y, wires=[0])\n            return qml.expval(qml.X(0))\n\n        dev = qml.device(\'default.gaussian\', wires=1)\n        circuit = to_autograd(QubitQNode(circuit, dev))\n        grad_fn = autograd.grad(circuit)\n\n        autograd_val = grad_fn(theta)\n        # qfunc evalutes to hbar * alpha * cos(theta)\n        manualgrad_val = - hbar * alpha * np.sin(theta)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'theta\', thetas)\n    def test_beamsplitter_gradient(self, theta, tol):\n        """"""Tests that the automatic gradient of a beamsplitter is correct.""""""\n\n        def circuit(y):\n            qml.Displacement(alpha, 0., wires=[0])\n            qml.Beamsplitter(y, 0, wires=[0, 1])\n            return qml.expval(qml.X(0))\n\n        dev = qml.device(\'default.gaussian\', wires=2)\n        circuit = to_autograd(CVQNode(circuit, dev))\n        grad_fn = autograd.grad(circuit)\n\n        autograd_val = grad_fn(theta)\n        # qfunc evalutes to hbar * alpha * cos(theta)\n        manualgrad_val = - hbar * alpha * np.sin(theta)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'mag\', mag_alphas)\n    @pytest.mark.parametrize(\'theta\', thetas)\n    def test_displacement_gradient(self, mag, theta, tol):\n        """"""Tests that the automatic gradient of a phase space displacement is correct.""""""\n\n        def circuit(r, phi):\n            qml.Displacement(r, phi, wires=[0])\n            return qml.expval(qml.X(0))\n\n        dev = qml.device(\'default.gaussian\', wires=1)\n        circuit = to_autograd(CVQNode(circuit, dev))\n        grad_fn = autograd.grad(circuit)\n\n        #alpha = mag * np.exp(1j * theta)\n        autograd_val = grad_fn(mag, theta)\n        # qfunc evalutes to hbar * Re(alpha)\n        manualgrad_val = hbar * np.cos(theta)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'r\', sqz_vals)\n    def test_squeeze_gradient(self, r, tol):\n        """"""Tests that the automatic gradient of a phase space squeezing is correct.""""""\n\n        def circuit(y):\n            qml.Displacement(alpha, 0., wires=[0])\n            qml.Squeezing(y, 0., wires=[0])\n            return qml.expval(qml.X(0))\n\n        dev = qml.device(\'default.gaussian\', wires=1)\n        circuit = to_autograd(CVQNode(circuit, dev))\n        grad_fn = autograd.grad(circuit)\n\n        autograd_val = grad_fn(r)\n        # qfunc evaluates to -exp(-r) * hbar * Re(alpha)\n        manualgrad_val = -np.exp(-r) * hbar * alpha\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'r\', sqz_vals[1:])  # formula is not valid for r=0\n    def test_number_state_gradient(self, r, tol):\n        """"""Tests that the automatic gradient of a squeezed state with number state expectation is correct.""""""\n\n        def circuit(y):\n            qml.Squeezing(y, 0., wires=[0])\n            return qml.expval(qml.FockStateProjector(np.array([2, 0]), wires=[0, 1]))\n\n        dev = qml.device(\'default.gaussian\', wires=2)\n        circuit = to_autograd(CVQNode(circuit, dev))\n        grad_fn = autograd.grad(circuit)\n\n        # (d/dr) |<2|S(r)>|^2 = 0.5 tanh(r)^3 (2 csch(r)^2 - 1) sech(r)\n        autograd_val = grad_fn(r)\n        manualgrad_val = 0.5*np.tanh(r)**3 * (2/(np.sinh(r)**2)-1) / np.cosh(r)\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n\n\nclass TestAutogradJacobianQubit:\n    """"""Tests involving Autograd functions grad and jacobian for qubit circuits.""""""\n\n    @staticmethod\n    def expected_jacobian(x, y, z):\n        dw0dx = 2 / 3 * np.sin(x) * np.sin(y)\n        dw0dy = 1 / 3 * (np.sin(y) - 2 * np.cos(x) * np.cos(y))\n        dw0dz = 0\n\n        dw1dx = -2 / 3 * np.cos(x) * np.sin(y)\n        dw1dy = -2 / 3 * np.cos(y) * np.sin(x)\n        dw1dz = 0\n\n        return np.array([[dw0dx, dw0dy, dw0dz], [dw1dx, dw1dy, dw1dz]])\n\n    def test_multiple_expectation_jacobian_positional(self, tol, qubit_device_2_wires):\n        """"""Tests that qnodes using positional arguments return\n        correct gradients for multiple expectation values.""""""\n        par = [0.5, 0.54, 0.3]\n\n        def circuit(x, y, z):\n            qml.QubitStateVector(np.array([1, 0, 1, 1]) / np.sqrt(3), wires=[0, 1])\n            qml.Rot(x, y, z, wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        circuit = to_autograd(QubitQNode(circuit, qubit_device_2_wires))\n\n        # compare our manual Jacobian computation to theoretical result\n        expected_jac = self.expected_jacobian(*par)\n        res = circuit.jacobian(par)\n        assert expected_jac == pytest.approx(res, abs=tol)\n\n        # compare our manual Jacobian computation to autograd\n        # not sure if this is the intended usage of jacobian\n        jac0 = autograd.jacobian(circuit, 0)\n        jac1 = autograd.jacobian(circuit, 1)\n        jac2 = autograd.jacobian(circuit, 2)\n        res = np.stack([jac0(*par), jac1(*par), jac2(*par)]).T\n\n        assert expected_jac == pytest.approx(res, abs=tol)\n\n        #compare with what we get if argnum is a list\n        jac = autograd.jacobian(circuit, argnum=[0, 1, 2])\n        #res2 = jac(*par)  # FIXME this call gives a TypeError inside Autograd\n        #assert res == pytest.approx(res2, abs=tol)\n\n    def test_multiple_expectation_jacobian_array(self, tol, qubit_device_2_wires):\n        """"""Tests that qnodes using an array argument return correct gradients\n        for multiple expectation values.""""""\n        par = np.array([0.5, 0.54, 0.3])\n\n        def circuit(weights):\n            qml.QubitStateVector(np.array([1, 0, 1, 1]) / np.sqrt(3), wires=[0, 1])\n            qml.Rot(weights[0], weights[1], weights[2], wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        circuit = to_autograd(QubitQNode(circuit, qubit_device_2_wires))\n\n        expected_jac = self.expected_jacobian(*par)\n        res = circuit.jacobian([par])\n        assert expected_jac == pytest.approx(res, abs=tol)\n\n        jac = autograd.jacobian(circuit, 0)\n        res = jac(par)\n        assert expected_jac == pytest.approx(res, abs=tol)\n\n\n    def test_array_parameters_autograd(self, tol, qubit_device_2_wires):\n        """"""Test that gradients of array parameters give\n        same results as positional arguments.""""""\n\n        par = [0.5, 0.54, 0.3]\n\n        def ansatz(x, y, z):\n            qml.QubitStateVector(np.array([1, 0, 1, 1]) / np.sqrt(3), wires=[0, 1])\n            qml.Rot(x, y, z, wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        def circuit1(x, y, z):\n            return ansatz(x, y, z)\n\n        def circuit2(x, array):\n            return ansatz(x, array[0], array[1])\n\n        def circuit3(array):\n            return ansatz(*array)\n\n        circuit1 = to_autograd(QubitQNode(circuit1, qubit_device_2_wires))\n        grad1 = autograd.grad(circuit1, argnum=[0, 1, 2])\n\n        # three positional parameters\n        jac = circuit1.jacobian(par)\n        ag = grad1(*par)\n        ag = np.array([ag])\n        assert jac == pytest.approx(ag, abs=tol)\n\n        circuit2 = to_autograd(QubitQNode(circuit2, qubit_device_2_wires))\n        grad2 = autograd.grad(circuit2, argnum=[0, 1])\n\n        # one scalar, one array\n        temp = [par[0], np.array(par[1:])]\n        jac = circuit2.jacobian(temp)\n        ag = grad2(*temp)\n        ag = np.r_[ag][np.newaxis, :]\n        assert jac == pytest.approx(ag, abs=tol)\n\n        circuit3 = to_autograd(QubitQNode(circuit3, qubit_device_2_wires))\n        grad3 = autograd.grad(circuit3, argnum=0)\n\n        # one array\n        temp = [np.array(par)]\n        jac = circuit3.jacobian(temp)\n        ag = grad3(*temp)[np.newaxis, :]\n        assert jac == pytest.approx(ag, abs=tol)\n\n\n    def test_array_parameters_scalar_return(self, qubit_device_1_wire, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with Autograd.\n           Test case for a circuit that returns a scalar.""""""\n\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0, 1], wires=0)\n            qml.RY(-0.5 * array[1, 1], wires=0)\n            return qml.expval(qml.PauliX(0))\n\n        node = to_autograd(QubitQNode(circuit, qubit_device_1_wire))\n\n        args = (0.46, np.array([[2.0, 3.0, 0.3], [7.0, 4.0, 2.1]]), -0.13)\n        grad_target = (\n            np.array(1.0),\n            np.array([[0.5, 0.43879, 0], [0, -0.43879, 0]]),\n            np.array(-0.4),\n        )\n        cost_target = 1.03257\n\n        def cost(x, array, y):\n            c = node(0.111, array, 4.5)\n            return c + 0.5 * array[0, 0] + x - 0.4 * y\n\n        cost_grad = autograd.grad(cost, argnum=[0, 1, 2])\n        computed_grad = cost_grad(*args)\n\n        assert cost(*args) == pytest.approx(cost_target, abs=tol)\n\n        assert computed_grad[0] == pytest.approx(grad_target[0], abs=tol)\n        assert computed_grad[1] == pytest.approx(grad_target[1], abs=tol)\n        assert computed_grad[2] == pytest.approx(grad_target[2], abs=tol)\n\n    def test_qnode_array_parameters_1_vector_return(self, qubit_device_1_wire, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with Autograd.\n           Test case for a circuit that returns a 1-vector.""""""\n\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0, 1], wires=0)\n            qml.RY(-0.5 * array[1, 1], wires=0)\n            return (qml.expval(qml.PauliX(0)),)\n\n        node = to_autograd(QubitQNode(circuit, qubit_device_1_wire))\n\n        args = (0.46, np.array([[2.0, 3.0, 0.3], [7.0, 4.0, 2.1]]), -0.13)\n        grad_target = (\n            np.array(1.0),\n            np.array([[0.5, 0.43879, 0], [0, -0.43879, 0]]),\n            np.array(-0.4),\n        )\n        cost_target = 1.03257\n\n        def cost(x, array, y):\n            c = node(0.111, array, 4.5)[0]\n            return c + 0.5 * array[0, 0] + x - 0.4 * y\n\n        cost_grad = autograd.grad(cost, argnum=[0, 1, 2])\n        computed_grad = cost_grad(*args)\n\n        assert cost(*args) == pytest.approx(cost_target, abs=tol)\n\n        assert computed_grad[0] == pytest.approx(grad_target[0], abs=tol)\n        assert computed_grad[1] == pytest.approx(grad_target[1], abs=tol)\n        assert computed_grad[2] == pytest.approx(grad_target[2], abs=tol)\n\n    def test_qnode_array_parameters_2_vector_return(self, qubit_device_2_wires, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with Autograd.\n           Test case for a circuit that returns a 2-vector.""""""\n\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0, 1], wires=0)\n            qml.RY(-0.5 * array[1, 1], wires=0)\n            qml.RY(array[1, 0], wires=1)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1))\n\n        node = to_autograd(QubitQNode(circuit, qubit_device_2_wires))\n\n        args = (0.46, np.array([[2.0, 3.0, 0.3], [7.0, 4.0, 2.1]]), -0.13)\n        grad_target = (\n            np.array(1.0),\n            np.array([[0.5, 0.43879, 0], [0, -0.43879, 0]]),\n            np.array(-0.4),\n        )\n        cost_target = 1.03257\n\n        def cost(x, array, y):\n            c = node(0.111, array, 4.5)[0]\n            return c + 0.5 * array[0, 0] + x - 0.4 * y\n\n        cost_grad = autograd.grad(cost, argnum=[0, 1, 2])\n        computed_grad = cost_grad(*args)\n\n        assert cost(*args) == pytest.approx(cost_target, abs=tol)\n\n        assert computed_grad[0] == pytest.approx(grad_target[0], abs=tol)\n        assert computed_grad[1] == pytest.approx(grad_target[1], abs=tol)\n        assert computed_grad[2] == pytest.approx(grad_target[2], abs=tol)\n\n    def test_qfunc_gradients(self, qubit_device_2_wires, tol):\n        ""Tests that the various ways of computing the gradient of a qfunc all agree.""\n\n        def circuit(x, y, z):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(-1.6, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[1, 0])\n            qml.RX(z, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = to_autograd(QubitQNode(circuit, qubit_device_2_wires))\n        params = np.array([0.1, -1.6, np.pi / 5])\n\n        # manual gradients\n        grad_fd1 = qnode.jacobian(params, method=\'F\', options={\'order\': 1})\n        grad_fd2 = qnode.jacobian(params, method=\'F\', options={\'order\': 2})\n        grad_angle = qnode.jacobian(params, method=\'A\')\n\n        # automatic gradient\n        grad_fn = autograd.grad(qnode, argnum=[0, 1, 2])\n        grad_auto = np.array([grad_fn(*params)])\n\n        # gradients computed with different methods must agree\n        assert grad_fd1 == pytest.approx(grad_fd2, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_angle, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_auto, abs=tol)\n\n    def test_hybrid_gradients(self, qubit_device_2_wires, tol):\n        ""Tests that the various ways of computing the gradient of a hybrid computation all agree.""\n\n        # input data is the first parameter\n        def classifier_circuit(in_data, x):\n            qml.RX(in_data, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(-1.6, wires=[0])\n            qml.RY(in_data, wires=[1])\n            qml.CNOT(wires=[1, 0])\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        classifier = to_autograd(QubitQNode(classifier_circuit, qubit_device_2_wires))\n\n        param = -0.1259\n        in_data = np.array([-0.1, -0.88, np.exp(0.5)])\n        out_data = np.array([1.5, np.pi / 3, 0.0])\n\n        def error(p):\n            ""Total square error of classifier predictions.""\n            ret = 0\n            for d_in, d_out in zip(in_data, out_data):\n                square_diff = (classifier(d_in, p) - d_out) ** 2\n                ret = ret + square_diff\n            return ret\n\n        def d_error(p, grad_method):\n            ""Gradient of error, computed manually.""\n            ret = 0\n            for d_in, d_out in zip(in_data, out_data):\n                args = (d_in, p)\n                diff = (classifier(*args) - d_out)\n                ret = ret + 2 * diff * classifier.jacobian(args, wrt=[1], method=grad_method)\n            return ret\n\n        y0 = error(param)\n        grad = autograd.grad(error)\n        grad_auto = grad(param)\n\n        grad_fd1 = d_error(param, \'F\')\n        grad_angle = d_error(param, \'A\')\n\n        # gradients computed with different methods must agree\n        assert grad_fd1 == pytest.approx(grad_angle, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_auto, abs=tol)\n        assert grad_angle == pytest.approx(grad_auto, abs=tol)\n\n\n    def test_hybrid_gradients_autograd_numpy(self, qubit_device_2_wires, tol):\n        ""Test the gradient of a hybrid computation requiring autograd.numpy functions.""\n\n        def circuit(x, y):\n            ""Quantum node.""\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(y, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        quantum = to_autograd(QubitQNode(circuit, qubit_device_2_wires))\n\n        def classical(p):\n            ""Classical node, requires autograd.numpy functions.""\n            return anp.exp(anp.sum(quantum(p[0], anp.log(p[1]))))\n\n        def d_classical(a, b, method):\n            ""Gradient of classical computed symbolically, can use normal numpy functions.""\n            val = classical((a, b))\n            J = quantum.jacobian((a, np.log(b)), method=method)\n            return val * np.array([J[0, 0] + J[1, 0], (J[0, 1] + J[1, 1]) / b])\n\n        param = np.array([-0.1259, 1.53])\n        y0 = classical(param)\n        grad_classical = autograd.jacobian(classical)\n        grad_auto = grad_classical(param)\n\n        grad_fd1 = d_classical(*param, \'F\')\n        grad_angle = d_classical(*param, \'A\')\n\n        # gradients computed with different methods must agree\n        assert grad_fd1 == pytest.approx(grad_angle, abs=tol)\n        assert grad_fd1 == pytest.approx(grad_auto, abs=tol)\n        assert grad_angle == pytest.approx(grad_auto, abs=tol)\n\n\nclass TestParameterHandlingIntegration:\n    """"""Test that the parameter handling for differentiable/non-differentiable\n    parameters works correctly.""""""\n\n    def test_no_differentiable_parameter(self):\n        """"""Test that the QNode can still be evaluated even when no parameters\n        are differentiable""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = qml.numpy.array(1., requires_grad=False)\n        y = qml.numpy.array(2., requires_grad=False)\n        z = qml.numpy.array(3., requires_grad=False)\n\n        circuit(x, y, z)\n        assert circuit.get_trainable_args() == set()\n\n        grad_fn = qml.grad(circuit)\n\n        with pytest.warns(UserWarning, match=""Output seems independent of input""):\n            res = grad_fn(x, y, z)\n\n        assert not res\n        assert circuit.get_trainable_args() == set()\n\n    def test_differentiable_parameter_first(self):\n        """"""Test that a differentiable parameter used as the first\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(weights, data1, data2):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # differentiating the circuit wrt the weights\n        grad_fn = qml.grad(circuit)\n\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n\n        # input data\n        data1 = qml.numpy.array([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = qml.numpy.array([1, 1], requires_grad=False)\n\n        res = grad_fn(weights, data1, data2)\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert len(res) == 1\n        assert res[0].shape == weights.shape\n\n        # check that the first arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {0}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [weights, data1, data2]\n        assert non_diff_var_indices == [18, 19, 20, 21, 22, 23]\n\n    def test_differentiable_parameter_middle(self):\n        """"""Test that a differentiable parameter provided as the middle\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(data1, weights, data2):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # differentiating the circuit wrt the weights\n        grad_fn = qml.grad(circuit)\n\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n\n        # input data\n        data1 = qml.numpy.array([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = qml.numpy.array([1, 1], requires_grad=False)\n\n        res = grad_fn(data1, weights, data2)\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert len(res) == 1\n        assert res[0].shape == weights.shape\n\n        # check that the second arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {1}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [data1, weights, data2]\n        assert non_diff_var_indices == [0, 1, 2, 3, 22, 23]\n\n    def test_differentiable_parameter_last(self):\n        """"""Test that a differentiable parameter used as the last\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(data1, data2, weights):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # differentiating the circuit wrt the weights\n        grad_fn = qml.grad(circuit)\n\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n\n        # input data\n        data1 = qml.numpy.array([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = qml.numpy.array([1, 1], requires_grad=False)\n\n        res = grad_fn(data1, data2, weights)\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert len(res) == 1\n        assert res[0].shape == weights.shape\n\n        # check that the last arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {2}\n\n        # Check that the parameter shift was not performed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [data1, data2, weights]\n        assert non_diff_var_indices == [0, 1, 2, 3, 4, 5]\n\n    def test_multiple_differentiable_and_non_differentiable_parameters(self):\n        """"""Test that multiple differentiable and non-differentiable parameters\n        works as expected""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(data1, weights1, data2, weights2):\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights1, wires=[0, 1])\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # differentiating the circuit wrt the weights\n        grad_fn = qml.grad(circuit)\n\n        # input weights\n        weights1 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights2 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=4)\n\n        # input data\n        data1 = qml.numpy.array([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = qml.numpy.array([1, 1], requires_grad=False)\n\n        res = grad_fn(data1, weights1, data2, weights2)\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert len(res) == 2\n        assert res[0].shape == weights1.shape\n        assert res[1].shape == weights2.shape\n\n        # check that the gradient was only computed for the\n        # differentiable elements of `weights`, not the data input\n        assert circuit.get_trainable_args() == {1, 3}\n\n    def test_gradient_non_differentiable_exception(self):\n        """"""Test that an exception is raised if non-differentiable data is\n        differentiated""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(data1):\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        grad_fn = qml.grad(circuit, argnum=[0])\n        data1 = qml.numpy.array([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n\n        with pytest.raises(qml.numpy.NonDifferentiableError, match=""is non-differentiable""):\n            grad_fn(data1)\n\n    def test_no_differentiable_parameters(self):\n        """"""If there are no differentiable parameters, the output of the gradient\n        function is an empty tuple, and a warning is emitted.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(data1):\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        grad_fn = qml.grad(circuit)\n        data1 = qml.numpy.array([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n\n        with pytest.warns(UserWarning, match=""Output seems independent of input""):\n            res = grad_fn(data1)\n\n        assert res == tuple()\n\n    def test_chained_qnodes(self):\n        """"""Test that the gradient of chained QNodes works without error""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit1(weights):\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit2(data, weights):\n            qml.templates.AngleEmbedding(data, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliX(0))\n\n        def cost(weights):\n            w1, w2 = weights\n            c1 = circuit1(w1)\n            c2 = circuit2(c1, w2)\n            return qml.numpy.sum(c2) ** 2\n\n        w1 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        w2 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=4)\n\n        weights = [w1, w2]\n\n        grad_fn = qml.grad(cost)\n        res = grad_fn(weights)\n\n        assert len(res[0]) == 2\n\n    def test_gradient_value(self, tol):\n        """"""Test that the returned gradient value for a qubit QNode is correct,\n        when one of the arguments is non-differentiable.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev)\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            return qml.expval(qml.PauliX(0) @ qml.PauliY(2))\n\n        dcircuit = qml.grad(circuit)\n\n        theta = 0.5\n        phi = 0.1\n\n        # explicitly mark varphi as non-differentiable\n        varphi = qml.numpy.array(0.23, requires_grad=False)\n\n        res = dcircuit(theta, phi, varphi)\n        expected = np.array([\n            np.cos(theta) * np.sin(phi) * np.sin(varphi),\n            np.sin(theta) * np.cos(phi) * np.sin(varphi)\n        ])\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # check that the gradient was not applied to varphi\n        assert circuit.get_trainable_args() == {0, 1}\n\n    def test_chained_gradient_value(self, mocker, tol):\n        """"""Test that the returned gradient value for two chained qubit QNodes\n        is correct.""""""\n        dev1 = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev1)\n        def circuit1(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(2))\n\n        dev2 = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev2)\n        def circuit2(data, weights):\n            qml.RX(data[0], wires=0)\n            qml.RX(data[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.RZ(weights[0], wires=0)\n            qml.RZ(weights[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliX(0) @ qml.PauliY(1))\n\n        def cost(a, b, c, weights):\n            return circuit2(circuit1(a, b, c), weights)\n\n        grad_fn = qml.grad(cost)\n\n        # Set the first parameter of circuit1 as non-differentiable.\n        a = qml.numpy.array(0.4, requires_grad=False)\n\n        # the remaining free parameters are all differentiable\n        b = 0.5\n        c = 0.1\n        weights = qml.numpy.array([0.2, 0.3])\n\n        res = grad_fn(a, b, c, weights)\n\n        # Output should have shape [dcost/db, dcost/dc, dcost/dw],\n        # where b,c are scalars, and w is a vector of length 2.\n        assert len(res) == 3\n        assert res[0].shape == tuple() # scalar\n        assert res[1].shape == tuple() # scalar\n        assert res[2].shape == (2,)    # vector\n\n        cacbsc = np.cos(a)*np.cos(b)*np.sin(c)\n\n        expected = np.array([\n            # analytic expression for dcost/db\n            -np.cos(a)*np.sin(b)*np.sin(c)*np.cos(cacbsc)*np.sin(weights[0])*np.sin(np.cos(a)),\n            # analytic expression for dcost/dc\n            np.cos(a)*np.cos(b)*np.cos(c)*np.cos(cacbsc)*np.sin(weights[0])*np.sin(np.cos(a)),\n            # analytic expression for dcost/dw[0]\n            np.sin(cacbsc)*np.cos(weights[0])*np.sin(np.cos(a)),\n            # analytic expression for dcost/dw[1]\n            0\n        ])\n\n        # np.hstack \'flattens\' the ragged gradient array allowing it\n        # to be compared with the expected result\n        assert np.allclose(np.hstack(res), expected, atol=tol, rtol=0)\n\n        # Check that the gradient was computed\n        # for all parameters in circuit2\n        assert circuit2.get_trainable_args() == {0, 1}\n\n        # check that the parameter-shift rule was not applied\n        # to the first parameter of circuit1\n        assert circuit1.get_trainable_args() == {1, 2}\n\n    def test_non_diff_not_a_variable(self):\n        """"""Test that an argument marked as non-differentiable\n        is not wrapped as a variable.""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n\n            assert isinstance(x, qml.variable.Variable)\n            assert isinstance(y, np.ndarray)\n            assert isinstance(z, qml.variable.Variable)\n\n            return qml.expval(qml.PauliZ(0))\n\n        x = 1\n        y = qml.numpy.array(2, requires_grad=False)\n        z = 3\n\n        res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {0, 2}\n\n        assert circuit.arg_vars[0] != x\n        assert circuit.arg_vars[1] == y\n        assert circuit.arg_vars[2] != z\n\n    a = 0.6\n    b = 0.2\n    test_data = [\n        ([0, 1], np.cos(2*a) * np.cos(b), [-2 * np.cos(b) * np.sin(2*a), -np.cos(2*a) * np.sin(b)]),\n        ([1, 0], -np.cos(b) * np.sin(b), [0, -np.cos(b) ** 2 + np.sin(b) ** 2]),\n    ]\n\n    @pytest.mark.parametrize(""w, expected_res, expected_grad"", test_data)\n    def test_non_diff_wires_argument(self, w, expected_res, expected_grad, tol):\n        """"""Test that passing wires as a non-differentiable positional\n        argument works correctly.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(wires, params):\n            qml.Hadamard(wires=wires[0])\n            qml.CNOT(wires=[wires[0], wires[1]])\n            qml.RX(params[0], wires=wires[0])\n            qml.RY(params[1], wires=wires[1])\n            qml.CNOT(wires=[wires[1], wires[0]])\n            qml.RX(params[0], wires=wires[0])\n            qml.RY(params[1], wires=wires[1])\n            return qml.expval(qml.PauliZ(0))\n\n        params = qml.numpy.array([0.6, 0.2])\n        wires = qml.numpy.array(w, requires_grad=False)\n\n        res = circuit(wires, params)\n\n        assert circuit.get_trainable_args() == {1}\n        assert np.allclose(res, expected_res, atol=tol, rtol=0)\n\n        grad_fn = qml.grad(circuit)\n        res_grad = grad_fn(wires, params)\n\n        assert circuit.get_trainable_args() == {1}\n        assert np.allclose(res_grad, expected_grad, atol=tol, rtol=0)\n\n    def test_call_changing_trainability(self):\n        """"""Test that trainability properly changes between QNode calls""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = qml.numpy.array(1, requires_grad=True)\n        y = qml.numpy.array(2, requires_grad=False)\n        z = qml.numpy.array(3, requires_grad=True)\n\n        res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {0, 2}\n\n        x.requires_grad = False\n        y.requires_grad = True\n\n        res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {1, 2}\n\n    def test_grad_changing_trainability(self):\n        """"""Test that trainability properly changes between QNode gradient calls""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = qml.numpy.array(1., requires_grad=True)\n        y = qml.numpy.array(2., requires_grad=False)\n        z = qml.numpy.array(3., requires_grad=True)\n\n        grad_fn = qml.grad(circuit)\n        res = grad_fn(x, y, z)\n\n        assert circuit.get_trainable_args() == {0, 2}\n\n        x.requires_grad = False\n        y.requires_grad = True\n\n        res = grad_fn(x, y, z)\n\n        assert circuit.get_trainable_args() == {1, 2}\n\n    def test_immutability(self):\n        """"""Test that changing parameter differentiability raises an exception\n        on immutable QNodes.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""autograd"", mutable=False)\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = qml.numpy.array(1., requires_grad=True)\n        y = qml.numpy.array(2., requires_grad=False)\n        z = qml.numpy.array(3., requires_grad=True)\n\n        grad_fn = qml.grad(circuit)\n        grad_fn(x, y, z)\n        assert circuit.get_trainable_args() == {0, 2}\n\n        # change values and compute the gradient again\n        grad_fn(2*x, -y, z)\n        assert circuit.get_trainable_args() == {0, 2}\n\n        # attempting to change differentiability raises an error\n        x.requires_grad = False\n        y.requires_grad = True\n\n        with pytest.raises(qml.QuantumFunctionError, match=""cannot be modified""):\n            grad_fn(x, y, z)\n'"
tests/interfaces/test_tf.py,101,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.interface.tf` QNode interface.\n""""""\n\nimport pytest\n\nimport numpy as np\n\ntf = pytest.importorskip(""tensorflow"", minversion=""1.15"")\nfrom tensorflow import Variable\n\nif tf.__version__[0] == ""1"":\n    tf.enable_eager_execution()\n\nimport pennylane as qml\n\nfrom pennylane.qnodes import QuantumFunctionError\nfrom pennylane.interfaces.tf import unflatten_tf\n\nfrom gate_data import CNOT, Rotx, Roty, Rotz, I, Y, Z\n\n\ndef expZ(state):\n    return np.abs(state[0]) ** 2 - np.abs(state[1]) ** 2\n\n\nclass TestTFQNodeExceptions():\n    """"""TFQNode basic tests.""""""\n\n    def test_qnode_fails_on_wrong_return_type(self, qubit_device_2_wires):\n        """"""The qfunc must return only Expectations""""""\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0)), 0.3\n\n        with pytest.raises(QuantumFunctionError, match=\'must return either\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_on_expval_not_returned(self, qubit_device_2_wires):\n        """"""All expectation values in the qfunc must be returned""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            ex = qml.expval(qml.PauliZ(1))\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'All measured observables\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_on_wrong_expval_order(self, qubit_device_2_wires):\n        """"""Expvals must be returned in the order they were created in""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            ex = qml.expval(qml.PauliZ(1))\n            return qml.expval(qml.PauliZ(0)), ex\n\n        with pytest.raises(QuantumFunctionError, match=\'All measured observables\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_on_gates_after_measurements(self, qubit_device_2_wires):\n        """"""Gates have to precede measurements""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            ev = qml.expval(qml.PauliZ(1))\n            qml.RY(0.5, wires=[0])\n            return ev\n\n        with pytest.raises(QuantumFunctionError, match=\'gates must precede\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_on_multiple_measurements_of_same_wire(self, qubit_device_2_wires):\n        """"""A wire can only be measured once""""""\n        \n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliX(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'can only be measured once\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_on_qfunc_with_too_many_wires(self, qubit_device_2_wires):\n        """"""The device must have sufficient wires for the qfunc""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 2])\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'applied to invalid wire\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_on_combination_of_cv_and_qbit_ops(self, qubit_device_1_wire):\n        """"""CV and discrete operations must not be mixed""""""\n        \n        @qml.qnode(qubit_device_1_wire, interface=\'tf\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            qml.Displacement(0.5, 0, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'Continuous and discrete\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_for_cv_ops_on_qubit_device(self, qubit_device_1_wire):\n        """"""A qubit device cannot execute CV operations""""""\n\n        @qml.qnode(qubit_device_1_wire, interface=\'tf\')\n        def qf(x):\n            qml.Displacement(0.5, 0, wires=[0])\n            return qml.expval(qml.X(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'Device default.qubit is a qubit device; CV operations are not allowed.\'):\n            qf(Variable(0.5))\n\n    def test_qnode_fails_for_cv_observables_on_qubit_device(self, qubit_device_1_wire):\n        """"""A qubit device cannot measure CV observables""""""\n\n        @qml.qnode(qubit_device_1_wire, interface=\'tf\')\n        def qf(x):\n            return qml.expval(qml.X(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'Device default.qubit is a qubit device; CV operations are not allowed.\'):\n            qf(Variable(0.5))\n\n\nclass TestTFQNodeParameterHandling:\n    """"""Test that the TFQNode properly handles the parameters of qfuncs""""""\n\n    def test_qnode_fanout(self, qubit_device_1_wire, tol):\n        """"""Tests that qnodes can compute the correct function when the same parameter is used in multiple gates.""""""\n\n        @qml.qnode(qubit_device_1_wire, interface=\'tf\')\n        def circuit(reused_param, other_param):\n            qml.RX(reused_param, wires=[0])\n            qml.RZ(other_param, wires=[0])\n            qml.RX(reused_param, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        thetas = tf.linspace(-2*np.pi, 2*np.pi, 7)\n\n        for reused_param in thetas:\n            for theta in thetas:\n                other_param = theta ** 2 / 11\n                y_eval = circuit(reused_param, other_param)\n                Rx = Rotx(reused_param.numpy())\n                Rz = Rotz(other_param.numpy())\n                zero_state = np.array([1.,0.])\n                final_state = (Rx @ Rz @ Rx @ zero_state)\n                y_true = expZ(final_state)\n\n                assert np.allclose(y_eval, y_true, atol=tol, rtol=0)\n\n    def test_qnode_array_parameters_scalar_return(self, qubit_device_1_wire, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with TensorFlow.\n           Test case for a circuit that returns a scalar.""""""\n\n        # The objective of this test is not to check if the results are correctly calculated, \n        # but to check that the interoperability of the different return types works.\n        @qml.qnode(qubit_device_1_wire, interface=\'tf\')\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0,1], wires=0)\n            qml.RY(-0.5 * array[1,1], wires=0)\n            return qml.expval(qml.PauliX(0))  # returns a scalar\n\n        grad_target = (np.array(1.), np.array([[0.5,  0.43879, 0], [0, -0.43879, 0]]), np.array(-0.4))\n        cost_target = 1.03257\n\n        args = (Variable(0.46), Variable([[2., 3., 0.3], [7., 4., 2.1]]), Variable(-0.13))\n\n        def cost(x, array, y):\n            c = tf.cast(circuit(tf.constant(0.111), array, tf.constant(4.5)), tf.float32)\n            \n            return c +0.5*array[0,0] +x -0.4*y\n\n        with tf.GradientTape() as tape:\n            cost_res = cost(*args)\n            grad_res = np.array([i.numpy() for i in tape.gradient(cost_res, [args[0], args[2]])])\n\n        assert np.allclose(cost_res.numpy(), cost_target, atol=tol, rtol=0)\n        assert np.allclose(grad_res, np.fromiter(grad_target[::2], dtype=np.float32), atol=tol, rtol=0)\n\n    def test_qnode_array_parameters_1_vector_return(self, qubit_device_1_wire, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with TensorFlow\n           Test case for a circuit that returns a 1-vector.""""""\n\n        # The objective of this test is not to check if the results are correctly calculated, \n        # but to check that the interoperability of the different return types works.\n        @qml.qnode(qubit_device_1_wire, interface=\'tf\')\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0,1], wires=0)\n            qml.RY(-0.5 * array[1,1], wires=0)\n            return qml.expval(qml.PauliX(0)),  # note the comma, returns a 1-vector\n\n        grad_target = (np.array(1.), np.array([[0.5,  0.43879, 0], [0, -0.43879, 0]]), np.array(-0.4))\n        cost_target = 1.03257\n\n        args = (Variable(0.46), Variable([[2., 3., 0.3], [7., 4., 2.1]]), Variable(-0.13))\n\n        def cost(x, array, y):\n            c = tf.cast(circuit(tf.constant(0.111), array, tf.constant(4.5)), tf.float32)\n            c = c[0]  # get a scalar\n            return c +0.5*array[0,0] +x -0.4*y\n\n        with tf.GradientTape() as tape:\n            cost_res = cost(*args)\n            grad_res = np.array([i.numpy() for i in tape.gradient(cost_res, [args[0], args[2]])])\n\n        assert np.allclose(cost_res.numpy(), cost_target, atol=tol, rtol=0)\n        assert np.allclose(grad_res, np.fromiter(grad_target[::2], dtype=np.float32), atol=tol, rtol=0)\n\n    def test_qnode_array_parameters_2_vector_return(self, qubit_device_2_wires, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with TensorFlow\n           Test case for a circuit that returns a 2-vector.""""""\n\n        # The objective of this test is not to check if the results are correctly calculated, \n        # but to check that the interoperability of the different return types works.\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0,1], wires=0)\n            qml.RY(-0.5 * array[1,1], wires=0)\n            qml.RY(array[1,0], wires=1)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1))  # returns a 2-vector\n\n        grad_target = (np.array(1.), np.array([[0.5,  0.43879, 0], [0, -0.43879, 0]]), np.array(-0.4))\n        cost_target = 1.03257\n\n        args = (Variable(0.46), Variable([[2., 3., 0.3], [7., 4., 2.1]]), Variable(-0.13))\n\n        def cost(x, array, y):\n            c = tf.cast(circuit(tf.constant(0.111), array, tf.constant(4.5)), tf.float32)\n            c = c[0]  # get a scalar\n            return c +0.5*array[0,0] +x -0.4*y\n\n        with tf.GradientTape() as tape:\n            cost_res = cost(*args)\n            grad_res = np.array([i.numpy() for i in tape.gradient(cost_res, [args[0], args[2]])])\n\n        assert np.allclose(cost_res.numpy(), cost_target, atol=tol, rtol=0)\n        assert np.allclose(grad_res, np.fromiter(grad_target[::2], dtype=np.float32), atol=tol, rtol=0)\n\n\n    def test_array_parameters_evaluate(self, qubit_device_2_wires, tol):\n        """"""Test that array parameters gives same result as positional arguments.""""""\n        a, b, c = tf.constant(0.5), tf.constant(0.54), tf.constant(0.3)\n\n        def ansatz(x, y, z):\n            qml.QubitStateVector(np.array([1, 0, 1, 1])/np.sqrt(3), wires=[0, 1])\n            qml.Rot(x, y, z, wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit1(x, y, z):\n            return ansatz(x, y, z)\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit2(x, array):\n            return ansatz(x, array[0], array[1])\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit3(array):\n            return ansatz(*array)\n\n        positional_res = circuit1(a, b, c)\n        array_res1 = circuit2(a, Variable([b, c]))\n        array_res2 = circuit3(Variable([a, b, c]))\n\n        assert np.allclose(positional_res.numpy(), array_res1.numpy(), atol=tol, rtol=0)\n        assert np.allclose(positional_res.numpy(), array_res2.numpy(), atol=tol, rtol=0)\n\n    def test_multiple_expectation_different_wires(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes return multiple expectation values.""""""\n        a, b, c = Variable(0.5), Variable(0.54), Variable(0.3)\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit(x, y, z):\n            qml.RX(x, wires=[0])\n            qml.RZ(y, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(y, wires=[0])\n            qml.RX(z, wires=[0])\n            return qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(1))\n\n        res = circuit(a, b, c)\n\n        out_state = np.kron(Rotx(c.numpy()), I) @ np.kron(Roty(b.numpy()), I) @ CNOT \\\n            @ np.kron(Rotz(b.numpy()), I) @ np.kron(Rotx(a.numpy()), I) @ np.array([1, 0, 0, 0])\n\n        ex0 = np.vdot(out_state, np.kron(Y, I) @ out_state)\n        ex1 = np.vdot(out_state, np.kron(I, Z) @ out_state)\n        ex = np.array([ex0, ex1])\n\n        assert np.allclose(ex, res.numpy(), atol=tol, rtol=0)\n\n    def test_multiple_keywordargs_used(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes use multiple keyword arguments.""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit(w, x=None, y=None):\n            qml.RX(x, wires=[0])\n            qml.RX(y, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        c = circuit(tf.constant(1.), x=np.pi, y=np.pi)\n\n        assert np.allclose(c.numpy(), [-1., -1.], atol=tol, rtol=0)\n\n    def test_multidimensional_keywordargs_used(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes use multi-dimensional keyword arguments.""""""\n        def circuit(w, x=None):\n            qml.RX(x[0], wires=[0])\n            qml.RX(x[1], wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_tf()\n\n        c = circuit(tf.constant(1.), x=[np.pi, np.pi])\n        assert np.allclose(c.numpy(), [-1., -1.], atol=tol, rtol=0)\n\n    def test_keywordargs_for_wires(self, qubit_device_2_wires, tol):\n        """"""Tests that wires can be passed as keyword arguments.""""""\n        default_q = 0\n\n        def circuit(x, q=default_q):\n            qml.RY(x, wires=0)\n            return qml.expval(qml.PauliZ(q))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_tf()\n\n        c = circuit(tf.constant(np.pi), q=1)\n        assert np.allclose(c, 1., atol=tol, rtol=0)\n\n        c = circuit(tf.constant(np.pi))\n        assert np.allclose(c.numpy(), -1., atol=tol, rtol=0)\n\n    def test_keywordargs_used(self, qubit_device_1_wire, tol):\n        """"""Tests that qnodes use keyword arguments.""""""\n\n        def circuit(w, x=None):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit = qml.QNode(circuit, qubit_device_1_wire).to_tf()\n\n        c = circuit(tf.constant(1.), x=np.pi)\n        assert np.allclose(c.numpy(), -1., atol=tol, rtol=0)\n\n    def test_mixture_numpy_tensors(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes work with python types and tensors.""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit(w, x, y):\n            qml.RX(x, wires=[0])\n            qml.RX(y, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        c = circuit(tf.constant(1.), np.pi, np.pi).numpy()\n        assert np.allclose(c, [-1., -1.], atol=tol, rtol=0)\n\n    def test_keywordarg_updated_in_multiple_calls(self, qubit_device_2_wires):\n        """"""Tests that qnodes update keyword arguments in consecutive calls.""""""\n\n        def circuit(w, x=None):\n            qml.RX(w, wires=[0])\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_tf()\n\n        c1 = circuit(tf.constant(0.1), x=tf.constant(0.))\n        c2 = circuit(tf.constant(0.1), x=np.pi)\n        assert c1[1] != c2[1]\n\n    def test_keywordarg_passes_through_classicalnode(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes\' keyword arguments pass through classical nodes.""""""\n\n        def circuit(w, x=None):\n            qml.RX(w, wires=[0])\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_tf()\n\n        def classnode(w, x=None):\n            return circuit(w, x=x)\n\n        c = classnode(tf.constant(0.), x=np.pi)\n        assert np.allclose(c.numpy(), [1., -1.], atol=tol, rtol=0)\n\n    def test_keywordarg_gradient(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes\' keyword arguments work with gradients""""""\n\n        def circuit(x, y, input_state=np.array([0, 0])):\n            qml.BasisState(input_state, wires=[0, 1])\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_tf()\n\n        x = 0.543\n        y = 0.45632\n        expected_grad = np.array([np.sin(x)*np.cos(y), np.sin(y)*np.cos(x)])\n\n        x_t = Variable(x)\n        y_t = Variable(y)\n\n        # test first basis state against analytic result\n        with tf.GradientTape() as tape:\n            c = circuit(x_t, y_t, input_state=np.array([0, 0]))\n            grads = np.array(tape.gradient(c, [x_t, y_t]))\n\n        assert np.allclose(grads, -expected_grad, atol=tol, rtol=0)\n\n        # test third basis state against analytic result\n        with tf.GradientTape() as tape:\n            c = circuit(x_t, y_t, input_state=np.array([1, 0]))\n            grads = np.array(tape.gradient(c, [x_t, y_t]))\n\n        assert np.allclose(grads, expected_grad, atol=tol, rtol=0)\n\n        # test first basis state via the default keyword argument against analytic result\n        with tf.GradientTape() as tape:\n            c = circuit(x_t, y_t)\n            grads = np.array(tape.gradient(c, [x_t, y_t]))\n\n        assert np.allclose(grads, -expected_grad, atol=tol, rtol=0)\n\n\nclass TestIntegration:\n    """"""Integration tests to ensure the TensorFlow QNode agrees with the NumPy QNode""""""\n\n    @pytest.fixture\n    def qnodes(self, qubit_device_2_wires):\n        """"""Two QNodes to be used for the gradient tests""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'autograd\')\n        def circuit(phi, theta):\n            qml.RX(phi[0], wires=0)\n            qml.RY(phi[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(theta[0], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(qubit_device_2_wires, interface=\'tf\')\n        def circuit_tf(phi, theta):\n            qml.RX(phi[0], wires=0)\n            qml.RY(phi[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(theta[0], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        return circuit, circuit_tf\n\n    def test_qnode_evaluation_agrees(self, qnodes, tol):\n        """"""Tests that simple example is consistent.""""""\n        circuit, circuit_tf = qnodes\n\n        phi = [0.5, 0.1]\n        theta = [0.2]\n\n        phi_t = Variable(phi)\n        theta_t = Variable(theta)\n\n        autograd_eval = circuit(phi, theta)\n        tf_eval = circuit_tf(phi_t, theta_t)\n        assert np.allclose(autograd_eval, tf_eval.numpy(), atol=tol, rtol=0)\n\n    def test_qnode_gradient_agrees(self, qnodes, tol):\n        """"""Tests that simple gradient example is consistent.""""""\n        circuit, circuit_tf = qnodes\n\n        phi = [0.5, 0.1]\n        theta = [0.2]\n\n        phi_t = Variable(phi)\n        theta_t = Variable(theta)\n\n        dcircuit = qml.grad(circuit, [0, 1])\n        autograd_grad = dcircuit(phi, theta)\n\n        with tf.GradientTape() as g:\n            g.watch([phi_t, theta_t])\n            y = circuit_tf(phi_t, theta_t)\n            tf_grad = g.gradient(y, [phi_t, theta_t])\n\n        assert np.allclose(autograd_grad[0], tf_grad[0], atol=tol, rtol=0)\n        assert np.allclose(autograd_grad[1], tf_grad[1], atol=tol, rtol=0)\n\n    def test_qnode_jacobian_agrees(self, qnodes, tol):\n        """"""Tests that simple jacobian example is consistent.""""""\n        circuit, circuit_tf = qnodes\n\n        phi = [0.5, 0.1]\n        theta = [0.2]\n\n        phi_t = Variable(phi)\n        theta_t = Variable(theta)\n\n        jac = qml.grad(circuit, [0, 1])\n        autograd_jac = jac(phi, theta)\n\n        with tf.GradientTape() as g:\n            g.watch([phi_t, theta_t])\n            y = circuit_tf(phi_t, theta_t)\n\n        tf_jac = g.jacobian(y, [phi_t, theta_t])\n\n        assert np.allclose(autograd_jac[0], tf_jac[0], atol=tol, rtol=0)\n        assert np.allclose(autograd_jac[1], tf_jac[1], atol=tol, rtol=0)\n\n\ngradient_test_data = [\n    (0.5, -0.1),\n    (0.0, np.pi),\n    (-3.6, -3.6),\n    (1.0, 2.5),\n]\n\n\nclass TestTFGradients:\n    """"""Integration tests involving gradients of QNodes and hybrid computations using the tf interface""""""\n\n    @pytest.fixture\n    def qnodes(self):\n        """"""Two QNodes to be used for the gradient tests""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def f(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(dev, interface=""tf"")\n        def g(y):\n            qml.RY(y, wires=0)\n            return qml.expval(qml.PauliX(0))\n\n        return f, g\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_addition_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of addition of two QNode circuits""""""\n        f, g = qnodes\n\n        def add(a, b):\n            return a + b\n\n        xt = Variable(x)\n        yt = Variable(y)\n\n        # addition\n        with tf.GradientTape() as tape:\n            tape.watch([xt, yt])\n            a = f(xt)\n            b = g(yt)\n            y = add(a, b)\n            grad = tape.gradient(y, [a, b])\n\n        assert grad[0].numpy() == 1.0\n        assert grad[1].numpy() == 1.0\n\n        # same tensor added to itself\n\n        with tf.GradientTape() as tape:\n            tape.watch([xt, yt])\n            a = f(xt)\n            y = add(a, a)\n            grad = tape.gradient(y, [a, a])\n\n        assert grad[0].numpy() == 2.0\n        assert grad[1].numpy() == 2.0\n\n        # different qnodes with same input parameter added together\n\n        with tf.GradientTape() as tape:\n            tape.watch([xt, yt])\n            a = f(xt)\n            b = g(xt)\n            y = add(a, b)\n            grad = tape.gradient(y, [a, b])\n\n        assert grad[0].numpy() == 1.0\n        assert grad[1].numpy() == 1.0\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_subtraction_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of subtraction of two QNode circuits""""""\n        f, g = qnodes\n\n        def subtract(a, b):\n            return a - b\n\n        xt = Variable(x)\n        yt = Variable(y)\n\n        # subtraction\n        with tf.GradientTape() as tape:\n            tape.watch([xt, yt])\n            a = f(xt)\n            b = g(yt)\n            y = subtract(a, b)\n            grad = tape.gradient(y, [a, b])\n\n        assert grad[0].numpy() == 1.0\n        assert grad[1].numpy() == -1.0\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_multiplication_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of multiplication of two QNode circuits""""""\n        f, g = qnodes\n\n        def mult(a, b):\n            return a * b\n\n        xt = Variable(x)\n        yt = Variable(y)\n\n        # multiplication\n        with tf.GradientTape() as tape:\n            tape.watch([xt, yt])\n            a = f(xt)\n            b = g(yt)\n            y = mult(a, b)\n            grad = tape.gradient(y, [a, b])\n\n        assert grad[0].numpy() == b.numpy()\n        assert grad[1].numpy() == a.numpy()\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_division_qnodes_gradient(self, qnodes, x, y, tf_tol):\n        """"""Test the gradient of division of two QNode circuits""""""\n        f, g = qnodes\n\n        def div(a, b):\n            return a / b\n\n        xt = Variable(x)\n        yt = Variable(y)\n\n        # division\n        with tf.GradientTape() as tape:\n            tape.watch([xt, yt])\n            a = f(xt)\n            b = g(yt)\n            y = div(a, b)\n            grad = tape.gradient(y, [a, b])\n\n        assert grad[0].numpy() == 1 / b.numpy()\n        res = grad[1].numpy()\n        exp = -a.numpy() / b.numpy() ** 2\n        assert np.allclose(res, exp, atol=tf_tol, rtol=0)\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_composition_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of composition of two QNode circuits""""""\n        f, g = qnodes\n\n        xt = Variable(x)\n        yt = Variable(y)\n\n        # compose function with xt as input\n        with tf.GradientTape() as tape:\n            tape.watch([xt])\n            y = f(xt)\n            grad1 = tape.gradient(y, xt)\n\n        with tf.GradientTape() as tape:\n            tape.watch([xt])\n            y = f(xt)\n            grad2 = tape.gradient(y, xt)\n\n        assert tf.equal(grad1, grad2)\n\n        # compose function with a as input\n        with tf.GradientTape() as tape:\n            tape.watch([xt])\n            a = f(xt)\n            y = f(a)\n            grad1 = tape.gradient(y, a)\n\n        with tf.GradientTape() as tape:\n            tape.watch([xt])\n            a = f(xt)\n            y = f(a)\n            grad2 = tape.gradient(y, a)\n\n        assert tf.equal(grad1, grad2)\n\n        # compose function with b as input\n        with tf.GradientTape() as tape:\n            tape.watch([xt])\n            b = g(xt)\n            y = g(b)\n            grad1 = tape.gradient(y, b)\n\n        with tf.GradientTape() as tape:\n            tape.watch([xt])\n            b = g(xt)\n            y = g(b)\n            grad2 = tape.gradient(y, b)\n\n        assert tf.equal(grad1, grad2)\n\n\nclass TestUnflattenTF:\n    """"""Tests for pennylane.interfaces.tf.unflatten_tf""""""\n\n    flat = tf.constant([i for i in range(12)])\n\n    def test_model_number(self):\n        """"""Test that the function simply splits flat between its first and remaining elements\n        when the model is a number""""""\n        unflattened = unflatten_tf(self.flat, 0)\n        assert tf.equal(unflattened[0], 0)\n        assert all(tf.equal(unflattened[1], tf.constant([i for i in range(1, 12)])))\n\n    def test_model_tensor(self):\n        """"""Test that function correctly takes the first elements of flat and reshapes it into the\n        model tensor, while leaving the remaining elements as a flat tensor""""""\n        model = tf.ones((3, 3))\n        unflattened = unflatten_tf(self.flat, model)\n\n        target = tf.reshape(self.flat[:9], (3, 3))\n        remaining = self.flat[-3:]\n\n        assert np.allclose(unflattened[0].numpy(), target.numpy())\n        assert np.allclose(unflattened[1].numpy(), remaining.numpy())\n\n    def test_model_iterable(self):\n        """"""Test that the function correctly unflattens when the model is a list of numbers,\n        which should result in unflatten_tf returning a list of tensors""""""\n        model = [1] * 12\n        unflattened = unflatten_tf(self.flat, model)\n\n        assert all([i.numpy().shape == () for i in unflattened[0]])\n        assert unflattened[1].numpy().size == 0\n\n    def test_model_nested_tensor(self):\n        """"""Test that the function correctly unflattens when the model is a nested tensor,\n        which should result in unflatten_tf returning a list of tensors of the same shape""""""\n        model = [tf.ones(3), tf.ones((2, 2)), tf.ones((3, 1)), tf.ones((1, 2))]\n        unflattened = unflatten_tf(self.flat, model)\n\n        assert all(\n            [u.numpy().shape == model[i].numpy().shape for i, u in enumerate(unflattened[0])]\n        )\n        assert unflattened[1].numpy().size == 0\n\n\nclass TestParameterHandlingIntegration:\n    """"""Test that the parameter handling for differentiable/non-differentiable\n    parameters works correctly.""""""\n\n    def test_differentiable_parameter_first(self):\n        """"""Test that a differentiable parameter used as the first\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(weights, data1, data2):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # differentiating the circuit wrt the weights\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights = tf.Variable(weights)\n\n        # input data\n        data1 = tf.constant([0, 1, 1, 0], dtype=tf.float64) / np.sqrt(2)\n        data2 = tf.Variable([1, 1], dtype=tf.float64, trainable=False)\n\n        with tf.GradientTape() as tape:\n            loss = circuit(weights, data1, data2)\n\n        grad = tape.gradient(loss, weights)\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert grad.shape == weights.shape\n\n        # check that the first arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {0}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [weights, data1, data2]\n        assert non_diff_var_indices == [18, 19, 20, 21, 22, 23]\n\n    def test_differentiable_parameter_middle(self):\n        """"""Test that a differentiable parameter provided as the middle\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(data1, weights, data2):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights = tf.Variable(weights)\n\n        # input data\n        data1 = tf.constant([0, 1, 1, 0], dtype=tf.float64) / np.sqrt(2)\n        data2 = tf.constant([1, 1], dtype=tf.float64)\n\n        with tf.GradientTape() as tape:\n            loss = circuit(data1, weights, data2)\n\n        grad = tape.gradient(loss, weights)\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert grad.shape == weights.shape\n\n        # check that the second arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {1}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [data1, weights, data2]\n        assert non_diff_var_indices == [0, 1, 2, 3, 22, 23]\n\n    def test_differentiable_parameter_last(self):\n        """"""Test that a differentiable parameter used as the last\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(data1, data2, weights):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights = tf.Variable(weights)\n\n        # input data\n        data1 = tf.constant([0, 1, 1, 0], dtype=tf.float64) / np.sqrt(2)\n        data2 = tf.constant([1, 1], dtype=tf.float64)\n\n        with tf.GradientTape() as tape:\n            loss = circuit(data1, data2, weights)\n\n        grad = tape.gradient(loss, weights)\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert grad.shape == weights.shape\n\n        # check that the last arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {2}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [data1, data2, weights]\n        assert non_diff_var_indices == [0, 1, 2, 3, 4, 5]\n\n    def test_multiple_differentiable_and_non_differentiable_parameters(self):\n        """"""Test that multiple differentiable and non-differentiable parameters\n        works as expected""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(data1, weights1, data2, weights2):\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights1, wires=[0, 1])\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # input weights\n        weights1 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights2 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=4)\n\n        weights1 = tf.Variable(weights1)\n        weights2 = tf.Variable(weights2)\n\n        # input data\n        data1 = tf.constant([0, 1, 1, 0], dtype=tf.float64) / np.sqrt(2)\n        data2 = tf.Variable([1, 1], dtype=tf.float64, trainable=False)\n\n        with tf.GradientTape() as tape:\n            loss = circuit(data1, weights1, data2, weights2)\n\n        grad = tape.gradient(loss, [weights1, weights2])\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert grad[0].shape == weights1.shape\n        assert grad[1].shape == weights2.shape\n\n        # check that the gradient was only computed for the\n        # differentiable elements of `weights`, not the data input\n        assert circuit.get_trainable_args() == {1, 3}\n\n    def test_gradient_non_differentiable_none(self, mocker):\n        """"""Test that the gradient of a non-differentiable tensor is None""""""\n        spy = mocker.spy(qml.qnodes.JacobianQNode, ""jacobian"")\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(weights):\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        weights = tf.constant(qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3))\n\n        with tf.GradientTape() as tape:\n            loss = circuit(weights)\n\n        assert circuit.get_trainable_args() == set()\n\n        grad = tape.gradient(loss, weights)\n        assert grad is None\n\n        spy.assert_not_called()\n\n    def test_non_differentiable_watch(self):\n        """"""Test that watching a non-differentiable tensor makes it differentiable""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(weights):\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        weights = tf.constant(qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3))\n\n        with tf.GradientTape() as tape:\n            tape.watch([weights])\n            loss = circuit(weights)\n\n        grad = tape.gradient(loss, weights)\n        assert grad is not None\n        assert grad.shape == weights.shape\n\n        assert circuit.get_trainable_args() == {0}\n\n    def test_chained_qnodes(self):\n        """"""Test that the gradient of chained QNodes works without error""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit1(weights):\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit2(data, weights):\n            qml.templates.AngleEmbedding(data, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliX(0))\n\n        def cost(weights):\n            w1, w2 = weights\n            c1 = circuit1(w1)\n            c2 = circuit2(c1, w2)\n            return tf.reduce_sum(c2) ** 2\n\n        # input weights\n        w1 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        w2 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=4)\n\n        w1 = tf.Variable(w1)\n        w2 = tf.Variable(w2)\n\n        weights = [w1, w2]\n\n        with tf.GradientTape() as tape:\n            loss = cost(weights)\n\n        grad = tape.gradient(loss, weights)\n\n        assert len(grad) == 2\n        assert grad[0].shape == w1.shape\n        assert grad[1].shape == w2.shape\n\n    def test_gradient_value(self, tol):\n        """"""Test that the returned gradient value for a qubit QNode is correct,\n        when one of the arguments is non-differentiable.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            return qml.expval(qml.PauliX(0) @ qml.PauliY(2))\n\n        theta = tf.Variable(0.5)\n        phi = tf.Variable(0.1)\n\n        # varphi is non-differentiable\n        varphi = tf.constant(0.23)\n\n        with tf.GradientTape() as tape:\n            loss = circuit(theta, phi, varphi)\n\n        grad = tape.gradient(loss, [theta, phi, varphi])\n\n        expected = [\n            tf.cos(theta) * tf.sin(phi) * tf.sin(varphi),\n            tf.sin(theta) * tf.cos(phi) * tf.sin(varphi),\n        ]\n\n        assert np.allclose(grad[:2], expected, atol=tol, rtol=0)\n        assert grad[2] is None\n\n        # check that the gradient was not computed for varphi\n        assert circuit.get_trainable_args() == {0, 1}\n\n    def test_chained_gradient_value(self, tol):\n        """"""Test that the returned gradient value for two chained qubit QNodes\n        is correct.""""""\n        dev1 = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev1, interface=""tf"")\n        def circuit1(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(2))\n\n        dev2 = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev2, interface=""tf"")\n        def circuit2(data, weights):\n            qml.RX(data[0], wires=0)\n            qml.RX(data[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.RZ(weights[0], wires=0)\n            qml.RZ(weights[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliX(0) @ qml.PauliY(1))\n\n        def cost(a, b, c, weights):\n            return circuit2(circuit1(a, b, c), weights)\n\n        # Set the first parameter of circuit1 as non-differentiable.\n        a = tf.constant(0.4)\n\n        # the remaining free parameters are all differentiable\n        b = tf.Variable(0.5)\n        c = tf.Variable(0.1)\n        weights = tf.Variable([0.2, 0.3])\n\n        with tf.GradientTape() as tape:\n            loss = cost(a, b, c, weights)\n\n        grad = tape.gradient(loss, [b, c, weights])\n\n        # Output should have shape [dcost/db, dcost/dc, dcost/dw],\n        # where b,c are scalars, and w is a vector of length 2.\n        assert len(grad) == 3\n        assert grad[0].shape == tuple() # scalar\n        assert grad[1].shape == tuple() # scalar\n        assert grad[2].shape == (2,)    # vector\n\n        cacbsc = tf.cos(a)*tf.cos(b)*tf.sin(c)\n\n        expected = [\n            # analytic expression for dcost/db\n            -tf.cos(a)*tf.sin(b)*tf.sin(c)*tf.cos(cacbsc)*tf.sin(weights[0])*tf.sin(tf.cos(a)),\n            # analytic expression for dcost/dc\n            tf.cos(a)*tf.cos(b)*tf.cos(c)*tf.cos(cacbsc)*tf.sin(weights[0])*tf.sin(tf.cos(a)),\n            # analytic expression for dcost/dw[0]\n            tf.sin(cacbsc)*tf.cos(weights[0])*tf.sin(tf.cos(a)),\n            # analytic expression for dcost/dw[1]\n            0\n        ]\n\n        # np.hstack \'flattens\' the ragged gradient array allowing it\n        # to be compared with the expected result\n        assert np.allclose(np.hstack(grad), expected, atol=tol, rtol=0)\n\n        # Check that the gradient was computed\n        # for all parameters in circuit2\n        assert circuit2.get_trainable_args() == {0, 1}\n\n        # check that the gradient was not computed\n        # for the first parameter of circuit1\n        assert circuit1.get_trainable_args() == {1, 2}\n\n    def test_non_diff_not_a_variable(self):\n        """"""Test that an argument marked as non-differentiable\n        is not wrapped as a variable.""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n\n            assert isinstance(x, qml.variable.Variable)\n            assert isinstance(y, np.float32)\n            assert isinstance(z, qml.variable.Variable)\n\n            return qml.expval(qml.PauliZ(0))\n\n        x = tf.Variable(1.)\n        y = tf.constant(2.)\n        z = tf.Variable(3.)\n\n        with tf.GradientTape() as tape:\n            res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {0, 2}\n\n        # the calls to `numpy()` are required so that TF 1.15 does not\n        # automatically cast the TensorFlow tensors on comparison.\n        assert circuit.arg_vars[0].val == x.numpy()\n        assert circuit.arg_vars[1] == y.numpy()\n        assert circuit.arg_vars[2].val == z.numpy()\n\n    a = 0.6\n    b = 0.2\n    test_data = [\n        ([0, 1], np.cos(2*a) * np.cos(b), [-2 * np.cos(b) * np.sin(2*a), -np.cos(2*a) * np.sin(b)]),\n        ([1, 0], -np.cos(b) * np.sin(b), [0, -np.cos(b) ** 2 + np.sin(b) ** 2]),\n    ]\n\n    @pytest.mark.parametrize(""w, expected_res, expected_grad"", test_data)\n    def test_non_diff_wires_argument(self, w, expected_res, expected_grad, tol):\n        """"""Test that passing wires as a non-differentiable positional\n        argument works correctly, and results in the expected QNode result and gradient.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(wires, params):\n            qml.Hadamard(wires=wires[0])\n            qml.CNOT(wires=[wires[0], wires[1]])\n            qml.RX(params[0], wires=wires[0])\n            qml.RY(params[1], wires=wires[1])\n            qml.CNOT(wires=[wires[1], wires[0]])\n            qml.RX(params[0], wires=wires[0])\n            qml.RY(params[1], wires=wires[1])\n            return qml.expval(qml.PauliZ(0))\n\n        params = tf.Variable([0.6, 0.2])\n\n        with tf.GradientTape() as tape:\n            res = circuit(w, params)\n\n        assert circuit.get_trainable_args() == {1}\n        assert np.allclose(res, expected_res, atol=tol, rtol=0)\n\n        grad = tape.gradient(res, params)\n\n        assert circuit.get_trainable_args() == {1}\n        assert np.allclose(grad, expected_grad, atol=tol, rtol=0)\n\n    def test_call_changing_trainability(self):\n        """"""Test that trainability properly changes between QNode calls""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = tf.Variable(1.)\n        y = tf.constant(2.)\n        z = tf.Variable(3.)\n\n        with tf.GradientTape() as tape:\n            res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {0, 2}\n\n        x = 1.\n\n        with tf.GradientTape() as tape:\n            tape.watch([y, z])\n            res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {1, 2}\n\n    def test_immutability(self):\n        """"""Test that changing parameter differentiability raises an exception\n        on immutable QNodes.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""tf"", mutable=False)\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = tf.Variable(1.)\n        y = 2.\n        z = tf.Variable(3.)\n\n        res = circuit(x, y, z)\n        assert circuit.get_trainable_args() == {0, 2}\n\n        # change values and compute the gradient again\n        with tf.GradientTape() as tape:\n            res = circuit(2*x, -y, z)\n        assert circuit.get_trainable_args() == {0, 2}\n\n        # attempting to change differentiability raises an error\n        x = 1.\n        y = tf.Variable(y)\n\n        with pytest.raises(qml.QuantumFunctionError, match=""cannot be modified""):\n            circuit(x, y, z)\n'"
tests/interfaces/test_torch.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.interface.torch` QNode interface.\n""""""\n\nimport pytest\n\nimport numpy as np\n\ntorch = pytest.importorskip(""torch"", minversion=""1.1"")\nfrom torch.autograd import Variable\n\nimport pennylane as qml\n\nfrom pennylane.utils import _flatten, unflatten\nfrom pennylane.qnodes import QNode, QuantumFunctionError\nfrom pennylane._device import DeviceError\nfrom pennylane.interfaces.torch import unflatten_torch\n\nfrom gate_data import CNOT, Rotx, Roty, Rotz, I, Y, Z\n\n\ndef expZ(state):\n    return np.abs(state[0]) ** 2 - np.abs(state[1]) ** 2\n\n\nclass TestTorchQNodeExceptions():\n    """"""TorchQNode basic tests.""""""\n\n    def test_qnode_fails_on_wrong_return_type(self, qubit_device_2_wires):\n        """"""The qfunc must return only Expectations""""""\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0)), 0.3\n\n        with pytest.raises(QuantumFunctionError, match=\'must return either\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_on_expval_not_returned(self, qubit_device_2_wires):\n        """"""All expectation values in the qfunc must be returned""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            ex = qml.expval(qml.PauliZ(1))\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'All measured observables\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_on_wrong_expval_order(self, qubit_device_2_wires):\n        """"""Expvals must be returned in the order they were created in""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            ex = qml.expval(qml.PauliZ(1))\n            return qml.expval(qml.PauliZ(0)), ex\n\n        with pytest.raises(QuantumFunctionError, match=\'All measured observables\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_on_gates_after_measurements(self, qubit_device_2_wires):\n        """"""Gates have to precede measurements""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            ev = qml.expval(qml.PauliZ(1))\n            qml.RY(0.5, wires=[0])\n            return ev\n\n        with pytest.raises(QuantumFunctionError, match=\'gates must precede\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_on_multiple_measurements_of_same_wire(self, qubit_device_2_wires):\n        """"""A wire can only be measured once""""""\n        \n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliX(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'can only be measured once\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_on_qfunc_with_too_many_wires(self, qubit_device_2_wires):\n        """"""The device must have sufficient wires for the qfunc""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 2])\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'applied to invalid wire\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_on_combination_of_cv_and_qbit_ops(self, qubit_device_1_wire):\n        """"""CV and discrete operations must not be mixed""""""\n        \n        @qml.qnode(qubit_device_1_wire, interface=\'torch\')\n        def qf(x):\n            qml.RX(x, wires=[0])\n            qml.Displacement(0.5, 0, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'Continuous and discrete\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_for_cv_ops_on_qubit_device(self, qubit_device_1_wire):\n        """"""A qubit device cannot execute CV operations""""""\n\n        @qml.qnode(qubit_device_1_wire, interface=\'torch\')\n        def qf(x):\n            qml.Displacement(0.5, 0, wires=[0])\n            return qml.expval(qml.X(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'Device default.qubit is a qubit device; CV operations are not allowed.\'):\n            qf(torch.tensor(0.5))\n\n    def test_qnode_fails_for_cv_observables_on_qubit_device(self, qubit_device_1_wire):\n        """"""A qubit device cannot measure CV observables""""""\n\n        @qml.qnode(qubit_device_1_wire, interface=\'torch\')\n        def qf(x):\n            return qml.expval(qml.X(0))\n\n        with pytest.raises(QuantumFunctionError, match=\'Device default.qubit is a qubit device; CV operations are not allowed.\'):\n            qf(torch.tensor(0.5))\n\n\nclass TestTorchQNodeParameterHandling:\n    """"""Test that the TorchQNode properly handles the parameters of qfuncs""""""\n\n    def test_qnode_fanout(self, qubit_device_1_wire, tol):\n        """"""Tests that qnodes can compute the correct function when the same parameter is used in multiple gates.""""""\n\n        @qml.qnode(qubit_device_1_wire, interface=\'torch\')\n        def circuit(reused_param, other_param):\n            qml.RX(reused_param, wires=[0])\n            qml.RZ(other_param, wires=[0])\n            qml.RX(reused_param, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        thetas = torch.linspace(-2*np.pi, 2*np.pi, 7)\n\n        for reused_param in thetas:\n            for theta in thetas:\n                other_param = theta ** 2 / 11\n                y_eval = circuit(reused_param, other_param)\n                Rx = Rotx(reused_param.numpy())\n                Rz = Rotz(other_param.numpy())\n                zero_state = np.array([1.,0.])\n                final_state = (Rx @ Rz @ Rx @ zero_state)\n                y_true = expZ(final_state)\n\n                assert np.allclose(y_eval, y_true, atol=tol, rtol=0)\n\n    def test_qnode_array_parameters_scalar_return(self, qubit_device_1_wire, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with PyTorch.\n           Test case for a circuit that returns a scalar.""""""\n\n        # The objective of this test is not to check if the results are correctly calculated,\n        # but to check that the interoperability of the different return types works.\n        @qml.qnode(qubit_device_1_wire, interface=\'torch\')\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0,1], wires=0)\n            qml.RY(-0.5 * array[1,1], wires=0)\n            return qml.expval(qml.PauliX(0))  # returns a scalar\n\n        grad_target = (np.array(1.), np.array([[0.5,  0.43879, 0], [0, -0.43879, 0]]), np.array(-0.4))\n        cost_target = 1.03257\n\n        args = (torch.tensor(0.46), torch.tensor([[2., 3., 0.3], [7., 4., 2.1]]), torch.tensor(-0.13))\n        for i in args:\n            i.requires_grad = True\n\n        def cost(x, array, y):\n            c = torch.as_tensor(circuit(torch.tensor(0.111), array, torch.tensor(4.5)), dtype=torch.float32)\n            return c +0.5*array[0,0] +x -0.4*y\n\n        cost_res = cost(*args)\n        cost_res.backward()\n\n        assert np.allclose(cost_res.detach().numpy(), cost_target, atol=tol, rtol=0)\n\n        for i in range(3):\n            assert np.allclose(args[i].grad.detach().numpy(), grad_target[i], atol=tol, rtol=0)\n\n    def test_qnode_array_parameters_1_vector_return(self, qubit_device_1_wire, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with PyTorch.\n           Test case for a circuit that returns a 1-vector.""""""\n\n        # The objective of this test is not to check if the results are correctly calculated, \n        # but to check that the interoperability of the different return types works.\n        @qml.qnode(qubit_device_1_wire, interface=\'torch\')\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0,1], wires=0)\n            qml.RY(-0.5 * array[1,1], wires=0)\n            return qml.expval(qml.PauliX(0)),  # note the comma, returns a 1-vector\n\n        grad_target = (np.array(1.), np.array([[0.5,  0.43879, 0], [0, -0.43879, 0]]), np.array(-0.4))\n        cost_target = 1.03257\n\n        args = (torch.tensor(0.46), torch.tensor([[2., 3., 0.3], [7., 4., 2.1]]), torch.tensor(-0.13))\n        for i in args:\n            i.requires_grad = True\n\n        def cost(x, array, y):\n            c = torch.as_tensor(circuit(torch.tensor(0.111), array, torch.tensor(4.5)), dtype=torch.float32)\n            c = c[0]  # get a scalar\n            return c +0.5*array[0,0] +x -0.4*y\n\n        cost_res = cost(*args)\n        cost_res.backward()\n\n        assert np.allclose(cost_res.detach().numpy(), cost_target, atol=tol, rtol=0)\n\n        for i in range(3):\n            assert np.allclose(args[i].grad.detach().numpy(), grad_target[i], atol=tol, rtol=0)\n\n    def test_qnode_array_parameters_2_vector_return(self, qubit_device_2_wires, tol):\n        """"""Test that QNode can take arrays as input arguments, and that they interact properly with PyTorch.\n           Test case for a circuit that returns a 2-vector.""""""\n\n        # The objective of this test is not to check if the results are correctly calculated, \n        # but to check that the interoperability of the different return types works.\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit(dummy1, array, dummy2):\n            qml.RY(0.5 * array[0,1], wires=0)\n            qml.RY(-0.5 * array[1,1], wires=0)\n            qml.RY(array[1,0], wires=1)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1))  # returns a 2-vector\n\n        grad_target = (np.array(1.), np.array([[0.5,  0.43879, 0], [0, -0.43879, 0]]), np.array(-0.4))\n        cost_target = 1.03257\n\n        args = (torch.tensor(0.46), torch.tensor([[2., 3., 0.3], [7., 4., 2.1]]), torch.tensor(-0.13))\n        for i in args:\n            i.requires_grad = True\n\n        def cost(x, array, y):\n            c = torch.as_tensor(circuit(torch.tensor(0.111), array, torch.tensor(4.5)), dtype=torch.float32)\n            c = c[0]  # get a scalar\n            return c +0.5*array[0,0] +x -0.4*y\n\n        cost_res = cost(*args)\n        cost_res.backward()\n\n        assert np.allclose(cost_res.detach().numpy(), cost_target, atol=tol, rtol=0)\n\n        for i in range(3):\n            assert np.allclose(args[i].grad.detach().numpy(), grad_target[i], atol=tol, rtol=0)\n\n\n    def test_array_parameters_evaluate(self, qubit_device_2_wires, tol):\n        """"""Test that array parameters gives same result as positional arguments.""""""\n        a, b, c = torch.tensor(0.5), torch.tensor(0.54), torch.tensor(0.3)\n\n        def ansatz(x, y, z):\n            qml.QubitStateVector(np.array([1, 0, 1, 1])/np.sqrt(3), wires=[0, 1])\n            qml.Rot(x, y, z, wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit1(x, y, z):\n            return ansatz(x, y, z)\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit2(x, array):\n            return ansatz(x, array[0], array[1])\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit3(array):\n            return ansatz(*array)\n\n        positional_res = circuit1(a, b, c)\n        array_res1 = circuit2(a, torch.tensor([b, c]))\n        array_res2 = circuit3(torch.tensor([a, b, c]))\n\n        assert np.allclose(positional_res.numpy(), array_res1.numpy(), atol=tol, rtol=0)\n        assert np.allclose(positional_res.numpy(), array_res2.numpy(), atol=tol, rtol=0)\n\n    def test_multiple_expectation_different_wires(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes return multiple expectation values.""""""\n        a, b, c = torch.tensor(0.5), torch.tensor(0.54), torch.tensor(0.3)\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit(x, y, z):\n            qml.RX(x, wires=[0])\n            qml.RZ(y, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(y, wires=[0])\n            qml.RX(z, wires=[0])\n            return qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(1))\n\n        res = circuit(a, b, c)\n\n        out_state = np.kron(Rotx(c.numpy()), I) @ np.kron(Roty(b.numpy()), I) @ CNOT \\\n            @ np.kron(Rotz(b.numpy()), I) @ np.kron(Rotx(a.numpy()), I) @ np.array([1, 0, 0, 0])\n\n        ex0 = np.vdot(out_state, np.kron(Y, I) @ out_state)\n        ex1 = np.vdot(out_state, np.kron(I, Z) @ out_state)\n        ex = np.array([ex0, ex1])\n\n        assert np.allclose(ex, res.numpy(), atol=tol, rtol=0)\n\n    def test_multiple_keywordargs_used(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes use multiple keyword arguments.""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit(w, x=None, y=None):\n            qml.RX(x, wires=[0])\n            qml.RX(y, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        c = circuit(torch.tensor(1.), x=np.pi, y=np.pi)\n\n        assert np.allclose(c.numpy(), [-1., -1.], atol=tol, rtol=0)\n\n    def test_multidimensional_keywordargs_used(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes use multi-dimensional keyword arguments.""""""\n        def circuit(w, x=None):\n            qml.RX(x[0], wires=[0])\n            qml.RX(x[1], wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_torch()\n\n        c = circuit(torch.tensor(1.), x=[np.pi, np.pi])\n        assert np.allclose(c.numpy(), [-1., -1.], atol=tol, rtol=0)\n\n    def test_keywordargs_for_wires(self, qubit_device_2_wires, tol):\n        """"""Tests that wires can be passed as keyword arguments.""""""\n        default_q = 0\n\n        def circuit(x, q=default_q):\n            qml.RY(x, wires=0)\n            return qml.expval(qml.PauliZ(q))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_torch()\n\n        c = circuit(torch.tensor(np.pi), q=1)\n        assert np.allclose(c, 1., atol=tol, rtol=0)\n\n        c = circuit(torch.tensor(np.pi))\n        assert np.allclose(c.numpy(), -1., atol=tol, rtol=0)\n\n    def test_keywordargs_used(self, qubit_device_1_wire, tol):\n        """"""Tests that qnodes use keyword arguments.""""""\n\n        def circuit(w, x=None):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit = qml.QNode(circuit, qubit_device_1_wire).to_torch()\n\n        c = circuit(torch.tensor(1.), x=np.pi)\n        assert np.allclose(c.numpy(), -1., atol=tol, rtol=0)\n\n    def test_mixture_numpy_tensors(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes work with python types and tensors.""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit(w, x, y):\n            qml.RX(x, wires=[0])\n            qml.RX(y, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        c = circuit(torch.tensor(1.), np.pi, np.pi).detach().numpy()\n        assert np.allclose(c, [-1., -1.], atol=tol, rtol=0)\n\n    def test_keywordarg_updated_in_multiple_calls(self, qubit_device_2_wires):\n        """"""Tests that qnodes update keyword arguments in consecutive calls.""""""\n\n        def circuit(w, x=None):\n            qml.RX(w, wires=[0])\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_torch()\n\n        c1 = circuit(torch.tensor(0.1), x=torch.tensor(0.))\n        c2 = circuit(torch.tensor(0.1), x=np.pi)\n        assert c1[1] != c2[1]\n\n    def test_keywordarg_passes_through_classicalnode(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes\' keyword arguments pass through classical nodes.""""""\n\n        def circuit(w, x=None):\n            qml.RX(w, wires=[0])\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_torch()\n\n        def classnode(w, x=None):\n            return circuit(w, x=x)\n\n        c = classnode(torch.tensor(0.), x=np.pi)\n        assert np.allclose(c.numpy(), [1., -1.], atol=tol, rtol=0)\n\n    def test_keywordarg_gradient(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes\' keyword arguments work with gradients""""""\n\n        def circuit(x, y, input_state=np.array([0, 0])):\n            qml.BasisState(input_state, wires=[0, 1])\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit = qml.QNode(circuit, qubit_device_2_wires).to_torch()\n\n        x = 0.543\n        y = 0.45632\n\n        x_t = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        y_t = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n        c = circuit(x_t, y_t, input_state=np.array([0, 0]))\n        c.backward()\n        assert np.allclose(x_t.grad.numpy(), [-np.sin(x)*np.cos(y)], atol=tol, rtol=0)\n        assert np.allclose(y_t.grad.numpy(), [-np.sin(y)*np.cos(x)], atol=tol, rtol=0)\n\n        x_t = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        y_t = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n        c = circuit(x_t, y_t, input_state=np.array([1, 0]))\n        c.backward()\n        assert np.allclose(x_t.grad.numpy(), [np.sin(x)*np.cos(y)], atol=tol, rtol=0)\n        assert np.allclose(y_t.grad.numpy(), [np.sin(y)*np.cos(x)], atol=tol, rtol=0)\n\n        x_t = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        y_t = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n        c = circuit(x_t, y_t)\n        c.backward()\n        assert np.allclose(x_t.grad.numpy(), [-np.sin(x)*np.cos(y)], atol=tol, rtol=0)\n        assert np.allclose(y_t.grad.numpy(), [-np.sin(y)*np.cos(x)], atol=tol, rtol=0)\n\n\nclass TestIntegration():\n    """"""Integration tests to ensure the Torch QNode agrees with the NumPy QNode""""""\n\n    def test_qnode_evaluation_agrees(self, qubit_device_2_wires, tol):\n        """"""Tests that simple example is consistent.""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'autograd\')\n        def circuit(phi, theta):\n            qml.RX(phi[0], wires=0)\n            qml.RY(phi[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(theta[0], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit_torch(phi, theta):\n            qml.RX(phi[0], wires=0)\n            qml.RY(phi[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(theta[0], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        phi = [0.5, 0.1]\n        theta = [0.2]\n\n        phi_t = torch.tensor(phi)\n        theta_t = torch.tensor(theta)\n\n        autograd_eval = circuit(phi, theta)\n        torch_eval = circuit_torch(phi_t, theta_t)\n        assert np.allclose(autograd_eval, torch_eval.detach().numpy(), atol=tol, rtol=0)\n\n    def test_qnode_gradient_agrees(self, qubit_device_2_wires, tol):\n        """"""Tests that simple gradient example is consistent.""""""\n\n        @qml.qnode(qubit_device_2_wires, interface=\'autograd\')\n        def circuit(phi, theta):\n            qml.RX(phi[0], wires=0)\n            qml.RY(phi[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(theta[0], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(qubit_device_2_wires, interface=\'torch\')\n        def circuit_torch(phi, theta):\n            qml.RX(phi[0], wires=0)\n            qml.RY(phi[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(theta[0], wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        phi = [0.5, 0.1]\n        theta = [0.2]\n\n        phi_t = torch.autograd.Variable(torch.tensor(phi), requires_grad=True)\n        theta_t = torch.autograd.Variable(torch.tensor(theta), requires_grad=True)\n\n        dcircuit = qml.grad(circuit, [0, 1])\n        autograd_grad = dcircuit(phi, theta)\n\n        torch_eval = circuit_torch(phi_t, theta_t)\n        torch_eval.backward()\n\n        assert np.allclose(autograd_grad[0], phi_t.grad.detach().numpy(), atol=tol, rtol=0)\n        assert np.allclose(autograd_grad[1], theta_t.grad.detach().numpy(), atol=tol, rtol=0)\n\n\ngradient_test_data = [\n    (0.5, -0.1),\n    (0.0, np.pi),\n    (-3.6, -3.6),\n    (1.0, 2.5),\n]\n\n\nclass TestTorchGradients:\n    """"""Integration tests involving gradients of QNodes and hybrid computations using the torch interface""""""\n\n    @pytest.fixture\n    def qnodes(self):\n        """"""Two QNodes to be used for the gradient tests""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def f(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(dev, interface=""torch"")\n        def g(y):\n            qml.RY(y, wires=0)\n            return qml.expval(qml.PauliX(0))\n\n        return f, g\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_addition_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of addition of two QNode circuits""""""\n        f, g = qnodes\n\n        def add(a, b):\n            return a + b\n\n        xt = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        yt = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n\n        # addition\n        a = f(xt)\n        b = g(yt)\n        a.retain_grad()\n        b.retain_grad()\n\n        add(a, b).backward()\n        assert a.grad == 1.0\n        assert b.grad == 1.0\n\n        # same tensor added to itself\n\n        a = f(xt)\n        a.retain_grad()\n\n        add(a, a).backward()\n        assert a.grad == 2.0\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_subtraction_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of subtraction of two QNode circuits""""""\n        f, g = qnodes\n\n        def subtract(a, b):\n            return a - b\n\n        xt = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        yt = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n\n        # subtraction\n        a = f(xt)\n        b = g(yt)\n        a.retain_grad()\n        b.retain_grad()\n\n        subtract(a, b).backward()\n        assert a.grad == 1.0\n        assert b.grad == -1.0\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_multiplication_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of multiplication of two QNode circuits""""""\n        f, g = qnodes\n\n        def mult(a, b):\n            return a * b\n\n        xt = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        yt = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n\n        # multiplication\n        a = f(xt)\n        b = g(yt)\n        a.retain_grad()\n        b.retain_grad()\n\n        mult(a, b).backward()\n        assert a.grad == b\n        assert b.grad == a\n\n        a = f(xt)\n        b = g(yt)\n        a.retain_grad()\n        b.retain_grad()\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_division_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of division of two QNode circuits""""""\n        f, g = qnodes\n\n        def div(a, b):\n            return a / b\n\n        xt = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        yt = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n\n        # division\n        # multiplication\n        a = f(xt)\n        b = g(yt)\n        a.retain_grad()\n        b.retain_grad()\n\n        div(a, b).backward()\n        assert a.grad == 1 / b\n        assert b.grad == -a / b ** 2\n\n    @pytest.mark.parametrize(""x, y"", gradient_test_data)\n    def test_composition_qnodes_gradient(self, qnodes, x, y):\n        """"""Test the gradient of composition of two QNode circuits""""""\n        f, g = qnodes\n\n        def compose(f, x):\n            return f(x)\n\n        xt = torch.autograd.Variable(torch.tensor(x), requires_grad=True)\n        yt = torch.autograd.Variable(torch.tensor(y), requires_grad=True)\n\n        # compose function with xt as input\n        compose(f, xt).backward()\n        grad1 = xt.grad.detach().numpy()\n\n        f(xt).backward()\n        grad2 = xt.grad.detach().numpy()\n        assert grad1 == grad2\n\n        # compose function with a as input\n        a = f(xt)\n        a.retain_grad()\n\n        compose(f, a).backward()\n        grad1 = a.grad.detach().numpy()\n\n        a = f(xt)\n        a.retain_grad()\n\n        f(a).backward()\n        grad2 = a.grad.detach().numpy()\n        assert grad1 == grad2\n\n        # compose function with b as input\n        b = g(yt)\n        b.retain_grad()\n\n        compose(f, b).backward()\n        grad1 = b.grad.detach().numpy()\n\n        b = g(yt)\n        b.retain_grad()\n\n        f(b).backward()\n        grad2 = b.grad.detach().numpy()\n        assert grad1 == grad2\n\n\nclass TestUnflatten:\n    """"""Tests for pennylane.interfaces.torch.unflatten_torch""""""\n\n    flat = torch.tensor([i for i in range(12)])\n\n    def test_unsupported_type_error(self):\n        """"""Test that an unsupported type exception is raised if there is\n        an unknown element in the model.""""""\n        with pytest.raises(TypeError, match=""Unsupported type in the model""):\n            unflatten_torch(self.flat, [object()])\n\n    def test_model_number(self):\n        """"""Test that the function simply splits flat between its first and remaining elements\n        when the model is a number""""""\n        unflattened = unflatten_torch(self.flat, 0)\n        assert unflattened[0] == 0\n        assert torch.all(unflattened[1] == self.flat[1:])\n\n    def test_model_tensor(self):\n        """"""Test that function correctly takes the first elements of flat and reshapes it into the\n        model tensor, while leaving the remaining elements as a flat tensor""""""\n        model = torch.ones((3, 3))\n        unflattened = unflatten_torch(self.flat, model)\n\n        target = self.flat[:9].view((3, 3))\n        remaining = self.flat[-3:]\n\n        assert torch.all(unflattened[0] == target)\n        assert torch.all(unflattened[1] == remaining)\n\n    def test_model_iterable(self):\n        """"""Test that the function correctly unflattens when the model is a list of numbers,\n        which should result in unflatten_torch returning a list of tensors""""""\n        model = [1] * 12\n        unflattened = unflatten_torch(self.flat, model)\n\n        assert all([i.shape == () for i in unflattened[0]])\n        assert unflattened[1].numel() == 0\n\n    def test_model_nested_tensor(self):\n        """"""Test that the function correctly unflattens when the model is a nested tensor,\n        which should result in unflatten_torch returning a list of tensors of the same shape""""""\n        model = [torch.ones(3), torch.ones((2, 2)), torch.ones((3, 1)), torch.ones((1, 2))]\n        unflattened = unflatten_torch(self.flat, model)\n\n        assert all(\n            [u.shape == model[i].shape for i, u in enumerate(unflattened[0])]\n        )\n        assert unflattened[1].numel() == 0\n\n\nclass TestParameterHandlingIntegration:\n    """"""Test that the parameter handling for differentiable/non-differentiable\n    parameters works correctly.""""""\n\n    def test_differentiable_parameter_first(self):\n        """"""Test that a differentiable parameter used as the first\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(weights, data1, data2):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # differentiating the circuit wrt the weights\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights = torch.tensor(weights, requires_grad=True)\n\n        # input data\n        data1 = torch.tensor([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = torch.tensor([1, 1], requires_grad=False)\n\n        loss = circuit(weights, data1, data2)\n        loss.backward()\n\n        # check that weights is only once differentiable\n        assert weights.grad.requires_grad == False\n\n        res = weights.grad.detach().numpy()\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert res.shape == weights.shape\n\n        # check that the first arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {0}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [weights, data1, data2]\n        assert non_diff_var_indices == [18, 19, 20, 21, 22, 23]\n\n    def test_differentiable_parameter_middle(self):\n        """"""Test that a differentiable parameter provided as the middle\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(data1, weights, data2):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights = torch.tensor(weights, requires_grad=True)\n\n        # input data\n        data1 = torch.tensor([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = torch.tensor([1, 1], requires_grad=False)\n\n        loss = circuit(data1, weights, data2)\n        loss.backward()\n        res = weights.grad.detach().numpy()\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert res.shape == weights.shape\n\n        # check that the second arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {1}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [data1, weights, data2]\n        assert non_diff_var_indices == [0, 1, 2, 3, 22, 23]\n\n    def test_differentiable_parameter_last(self):\n        """"""Test that a differentiable parameter used as the last\n        argument is correctly evaluated by QNode.jacobian, and that\n        all other non-differentiable parameters are ignored""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(data1, data2, weights):\n            # non-differentiable quantum function\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            # differentiable quantum function\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            # non-differentiable quantum function\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # input weights\n        weights = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights = torch.tensor(weights, requires_grad=True)\n\n        # input data\n        data1 = torch.tensor([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = torch.tensor([1, 1], requires_grad=False)\n\n        loss = circuit(data1, data2, weights)\n        loss.backward()\n        res = weights.grad.detach().numpy()\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert res.shape == weights.shape\n\n        # check that the last arg was marked as non-differentiable\n        assert circuit.get_trainable_args() == {2}\n\n        # Check that the gradient was not computed for the\n        # non-differentiable elements of `data1` and `data2`.\n        # First, extract the variable indices that the jacobian method\n        # \'skipped\' (those with grad_method=""0""):\n        non_diff_var_indices = sorted([k for k, v in circuit.par_to_grad_method.items() if v == ""0""])\n\n        # Check that these indices corresponds to the elements of data1 and data2\n        # within the flattenened list [data1, data2, weights]\n        assert non_diff_var_indices == [0, 1, 2, 3, 4, 5]\n\n\n    def test_multiple_differentiable_and_non_differentiable_parameters(self):\n        """"""Test that multiple differentiable and non-differentiable parameters\n        works as expected""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(data1, weights1, data2, weights2):\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights1, wires=[0, 1])\n            qml.templates.AngleEmbedding(data2, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights2, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        # input weights\n        weights1 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        weights2 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=4)\n\n        weights1 = torch.tensor(weights1, requires_grad=True)\n        weights2 = torch.tensor(weights2, requires_grad=True)\n\n        # input data\n        data1 = torch.tensor([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n        data2 = torch.tensor([1, 1], requires_grad=False)\n\n        loss = circuit(data1, weights1, data2, weights2)\n        loss.backward()\n        res1 = weights1.grad.detach().numpy()\n        res2 = weights2.grad.detach().numpy()\n\n        # we do not check for correctness, just that the output\n        # is the correct shape\n        assert res1.shape == weights1.shape\n        assert res2.shape == weights2.shape\n\n        # check that the parameter shift was only performed for the\n        # differentiable elements of `weights`, not the data input\n        assert circuit.get_trainable_args() == {1, 3}\n\n    def test_gradient_non_differentiable_exception(self):\n        """"""Test that an exception is raised if non-differentiable data is\n        differentiated""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(data1):\n            qml.templates.AmplitudeEmbedding(data1, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        grad_fn = qml.grad(circuit, argnum=[0])\n        data1 = torch.tensor([0, 1, 1, 0], requires_grad=False) / np.sqrt(2)\n\n        loss = circuit(data1)\n        assert circuit.get_trainable_args() == set()\n\n        assert not loss.requires_grad\n\n        with pytest.raises(RuntimeError, match=""does not have a grad_fn""):\n            loss.backward()\n\n    def test_chained_qnodes(self):\n        """"""Test that the gradient of chained QNodes works without error""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit1(weights):\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit2(data, weights):\n            qml.templates.AngleEmbedding(data, wires=[0, 1])\n            qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1])\n            return qml.expval(qml.PauliX(0))\n\n        def cost(weights):\n            w1, w2 = weights\n            c1 = circuit1(w1)\n            c2 = circuit2(c1, w2)\n            return torch.sum(c2) ** 2\n\n        w1 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=3)\n        w2 = qml.init.strong_ent_layers_normal(n_wires=2, n_layers=4)\n\n        w1 = torch.tensor(w1, requires_grad=True)\n        w2 = torch.tensor(w2, requires_grad=True)\n\n        weights = [w1, w2]\n\n        loss = cost(weights)\n        loss.backward()\n\n        res = w1.grad.detach().numpy()\n        assert res.shape == w1.shape\n\n        res = w2.grad.detach().numpy()\n        assert res.shape == w2.shape\n\n    def test_gradient_value(self, tol):\n        """"""Test that the returned gradient value for a qubit QNode is correct,\n        when one of the arguments is non-differentiable.""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            return qml.expval(qml.PauliX(0) @ qml.PauliY(2))\n\n        theta = torch.tensor(0.5, requires_grad=True)\n        phi = torch.tensor(0.1, requires_grad=True)\n\n        # varphi is non-differentiable\n        varphi = torch.tensor(0.23)\n\n        loss = circuit(theta, phi, varphi)\n        loss.backward()\n\n        res = [i.grad.detach().numpy() for i in [theta, phi]]\n        expected = torch.tensor([\n            torch.cos(theta) * torch.sin(phi) * torch.sin(varphi),\n            torch.sin(theta) * torch.cos(phi) * torch.sin(varphi)\n        ])\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # check that the parameter-shift rule was not applied to varphi\n        assert circuit.get_trainable_args() == {0, 1}\n\n    def test_chained_gradient_value(self, mocker, tol):\n        """"""Test that the returned gradient value for two chained qubit QNodes\n        is correct.""""""\n        spy = mocker.spy(qml.qnodes.JacobianQNode, ""jacobian"")\n        dev1 = qml.device(""default.qubit"", wires=3)\n\n        @qml.qnode(dev1, interface=""torch"")\n        def circuit1(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(2))\n\n        dev2 = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev2, interface=""torch"")\n        def circuit2(data, weights):\n            qml.RX(data[0], wires=0)\n            qml.RX(data[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.RZ(weights[0], wires=0)\n            qml.RZ(weights[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliX(0) @ qml.PauliY(1))\n\n        def cost(a, b, c, weights):\n            return circuit2(circuit1(a, b, c), weights)\n\n        # Set the first parameter of circuit1 as non-differentiable.\n        a = torch.tensor(0.4, requires_grad=False)\n\n        # the remaining free parameters are all differentiable\n        b = torch.tensor(0.5, requires_grad=True)\n        c = torch.tensor(0.1, requires_grad=True)\n        weights = torch.tensor([0.2, 0.3], requires_grad=True)\n\n        loss = cost(a, b, c, weights)\n        loss.backward()\n        res = [i.grad.detach().numpy() for i in [b, c, weights]]\n\n        # Output should have shape [dcost/db, dcost/dc, dcost/dw],\n        # where b,c are scalars, and w is a vector of length 2.\n        assert len(res) == 3\n        assert res[0].shape == tuple() # scalar\n        assert res[1].shape == tuple() # scalar\n        assert res[2].shape == (2,)    # vector\n\n        cacbsc = torch.cos(a)*torch.cos(b)*torch.sin(c)\n\n        expected = torch.tensor([\n            # analytic expression for dcost/db\n            -torch.cos(a)*torch.sin(b)*torch.sin(c)*torch.cos(cacbsc)*torch.sin(weights[0])*torch.sin(torch.cos(a)),\n            # analytic expression for dcost/dc\n            torch.cos(a)*torch.cos(b)*torch.cos(c)*torch.cos(cacbsc)*torch.sin(weights[0])*torch.sin(torch.cos(a)),\n            # analytic expression for dcost/dw[0]\n            torch.sin(cacbsc)*torch.cos(weights[0])*torch.sin(torch.cos(a)),\n            # analytic expression for dcost/dw[1]\n            0\n        ])\n\n        # np.hstack \'flattens\' the ragged gradient array allowing it\n        # to be compared with the expected result\n        assert np.allclose(np.hstack(res), expected, atol=tol, rtol=0)\n\n        # Check that the gradient was computed\n        # for all parameters in circuit2\n        assert circuit2.get_trainable_args() == {0, 1}\n\n        # check that the gradient was not computed\n        # for the first parameter of circuit1\n        assert circuit1.get_trainable_args() == {1, 2}\n\n    def test_non_diff_not_a_variable(self):\n        """"""Test that an argument marked as non-differentiable\n        is not wrapped as a variable.""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n\n            assert isinstance(x, qml.variable.Variable)\n            assert isinstance(y, float)\n            assert isinstance(z, qml.variable.Variable)\n\n            return qml.expval(qml.PauliZ(0))\n\n        x = torch.tensor(1., requires_grad=True)\n        y = torch.tensor(2., requires_grad=False)\n        z = torch.tensor(3., requires_grad=True)\n\n        res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {0, 2}\n\n        assert circuit.arg_vars[0] != x\n        assert circuit.arg_vars[1] == y\n        assert circuit.arg_vars[2] != z\n\n    a = 0.6\n    b = 0.2\n    test_data = [\n        ([0, 1], np.cos(2*a) * np.cos(b), [-2 * np.cos(b) * np.sin(2*a), -np.cos(2*a) * np.sin(b)]),\n        ([1, 0], -np.cos(b) * np.sin(b), [0, -np.cos(b) ** 2 + np.sin(b) ** 2]),\n    ]\n\n    @pytest.mark.parametrize(""w, expected_res, expected_grad"", test_data)\n    def test_non_diff_wires_argument(self, w, expected_res, expected_grad, tol):\n        """"""Test that passing wires as a non-differentiable positional\n        argument works correctly.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(wires, params):\n            qml.Hadamard(wires=wires[0])\n            qml.CNOT(wires=[wires[0], wires[1]])\n            qml.RX(params[0], wires=wires[0])\n            qml.RY(params[1], wires=wires[1])\n            qml.CNOT(wires=[wires[1], wires[0]])\n            qml.RX(params[0], wires=wires[0])\n            qml.RY(params[1], wires=wires[1])\n            return qml.expval(qml.PauliZ(0))\n\n        params = torch.tensor([0.6, 0.2], requires_grad=True)\n        wires = torch.tensor(w)\n\n        res = circuit(wires, params)\n\n        assert circuit.get_trainable_args() == {1}\n        assert np.allclose(res.detach(), expected_res, atol=tol, rtol=0)\n\n        res.backward()\n        res_grad = params.grad\n\n        assert circuit.get_trainable_args() == {1}\n        assert np.allclose(res_grad.detach(), expected_grad, atol=tol, rtol=0)\n\n    def test_call_changing_trainability(self):\n        """"""Test that trainability properly changes between QNode calls""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"")\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = torch.tensor(1., requires_grad=True)\n        y = torch.tensor(2., requires_grad=False)\n        z = torch.tensor(3., requires_grad=True)\n\n        res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {0, 2}\n\n        x.requires_grad = False\n        y.requires_grad = True\n\n        res = circuit(x, y, z)\n\n        assert circuit.get_trainable_args() == {1, 2}\n\n    def test_immutability(self):\n        """"""Test that changing parameter differentiability raises an exception\n        on immutable QNodes.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev, interface=""torch"", mutable=False)\n        def circuit(x, y, z):\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=0)\n            qml.RZ(z, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        x = torch.tensor(1., requires_grad=True)\n        y = torch.tensor(2., requires_grad=False)\n        z = torch.tensor(3., requires_grad=True)\n\n        res = circuit(x, y, z)\n        assert circuit.get_trainable_args() == {0, 2}\n\n        # change values and compute the gradient again\n        res = circuit(2*x, -y, z)\n        assert circuit.get_trainable_args() == {0, 2}\n\n        # attempting to change differentiability raises an error\n        x.requires_grad = False\n        y.requires_grad = True\n\n        with pytest.raises(qml.QuantumFunctionError, match=""cannot be modified""):\n            circuit(x, y, z)\n'"
tests/ops/test_cv_ops.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.plugin.DefaultGaussian` device.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\n\nfrom scipy.linalg import block_diag\nimport pytest\n\nimport pennylane\nfrom pennylane import numpy as np\nfrom pennylane.ops import cv\n\ns_vals = np.linspace(-3, 3, 13)\nphis = np.linspace(-2 * np.pi, 2 * np.pi, 11)\nmags = np.linspace(0.0, 1.0, 7)\n\nclass TestCV:\n    """"""Tests the continuous variable based operations.""""""\n\n    @pytest.mark.parametrize(""phi"", phis)\n    def test_rotation_heisenberg(self, phi):\n        """"""ops: Tests the Heisenberg representation of the Rotation gate.""""""\n        matrix = cv.Rotation._heisenberg_rep([phi])\n        true_matrix = np.array(\n            [[1, 0, 0], [0, np.cos(phi), -np.sin(phi)], [0, np.sin(phi), np.cos(phi)]]\n        )\n        assert np.allclose(matrix, true_matrix)\n\n\n    @pytest.mark.parametrize(""phi"", phis)\n    @pytest.mark.parametrize(""mag"", mags)\n    def test_squeezing_heisenberg(self, phi, mag):\n        """"""ops: Tests the Heisenberg representation of the Squeezing gate.""""""\n        r = mag\n        matrix = cv.Squeezing._heisenberg_rep([r, phi])\n        true_matrix = np.array(\n            [\n                [1, 0, 0],\n                [0, np.cosh(r) - np.cos(phi) * np.sinh(r), -np.sin(phi) * np.sinh(r)],\n                [0, -np.sin(phi) * np.sinh(r), np.cosh(r) + np.cos(phi) * np.sinh(r)],\n            ]\n        )\n        assert np.allclose(matrix, true_matrix)\n\n\n    @pytest.mark.parametrize(""phi"", phis)\n    @pytest.mark.parametrize(""mag"", mags)\n    def test_displacement_heisenberg(self, phi, mag):\n        """"""ops: Tests the Heisenberg representation of the Displacement gate.""""""\n        r = mag\n        hbar = 2\n        matrix = cv.Displacement._heisenberg_rep([r, phi])\n        true_matrix = np.array(\n            [\n                [1, 0, 0],\n                [np.sqrt(2 * hbar) * r * np.cos(phi), 1, 0],\n                [np.sqrt(2 * hbar) * r * np.sin(phi), 0, 1],\n            ]\n        )\n        assert np.allclose(matrix, true_matrix)\n\n\n    @pytest.mark.parametrize(""phi"", phis)\n    @pytest.mark.parametrize(""theta"", phis)\n    def test_beamsplitter_heisenberg(self, phi, theta):\n        """"""ops: Tests the Heisenberg representation of the Beamsplitter gate.""""""\n        matrix = cv.Beamsplitter._heisenberg_rep([theta, phi])\n        true_matrix = np.array(\n            [\n                [1, 0, 0, 0, 0],\n                [\n                    0,\n                    np.cos(theta),\n                    0,\n                    -np.cos(phi) * np.sin(theta),\n                    -np.sin(phi) * np.sin(theta),\n                ],\n                [\n                    0,\n                    0,\n                    np.cos(theta),\n                    np.sin(phi) * np.sin(theta),\n                    -np.cos(phi) * np.sin(theta),\n                ],\n                [\n                    0,\n                    np.cos(phi) * np.sin(theta),\n                    -np.sin(phi) * np.sin(theta),\n                    np.cos(theta),\n                    0,\n                ],\n                [\n                    0,\n                    np.sin(phi) * np.sin(theta),\n                    np.cos(phi) * np.sin(theta),\n                    0,\n                    np.cos(theta),\n                ],\n            ]\n        )\n        assert np.allclose(matrix, true_matrix)\n\n\n    @pytest.mark.parametrize(""phi"", phis)\n    @pytest.mark.parametrize(""mag"", mags)\n    def test_two_mode_squeezing_heisenberg(self, phi, mag):\n        """"""ops: Tests the Heisenberg representation of the Beamsplitter gate.""""""\n        r = mag\n        matrix = cv.TwoModeSqueezing._heisenberg_rep([r, phi])\n        true_matrix = np.array(\n            [\n                [1, 0, 0, 0, 0],\n                [0, np.cosh(r), 0, np.cos(phi) * np.sinh(r), np.sin(phi) * np.sinh(r)],\n                [0, 0, np.cosh(r), np.sin(phi) * np.sinh(r), -np.cos(phi) * np.sinh(r)],\n                [0, np.cos(phi) * np.sinh(r), np.sin(phi) * np.sinh(r), np.cosh(r), 0],\n                [0, np.sin(phi) * np.sinh(r), -np.cos(phi) * np.sinh(r), 0, np.cosh(r)],\n            ]\n        )\n        assert np.allclose(matrix, true_matrix)\n\n\n    @pytest.mark.parametrize(""s"", s_vals)\n    def test_quadratic_phase_heisenberg(self, s):\n        """"""ops: Tests the Heisenberg representation of the QuadraticPhase gate.""""""\n        matrix = cv.QuadraticPhase._heisenberg_rep([s])\n        true_matrix = np.array([[1, 0, 0], [0, 1, 0], [0, s, 1]])\n        assert np.allclose(matrix, true_matrix)\n\n\n    @pytest.mark.parametrize(""s"", s_vals)\n    def test_controlled_addition_heisenberg(self, s):\n        """"""ops: Tests the Heisenberg representation of ControlledAddition gate.\n        """"""\n        matrix = cv.ControlledAddition._heisenberg_rep([s])\n        true_matrix = np.array(\n            [\n                [1, 0, 0, 0, 0],\n                [0, 1, 0, 0, 0],\n                [0, 0, 1, 0, -s],\n                [0, s, 0, 1, 0],\n                [0, 0, 0, 0, 1],\n            ]\n        )\n        assert np.allclose(matrix, true_matrix)\n\n\n    @pytest.mark.parametrize(""s"", s_vals)\n    def test_controlled_phase_heisenberg(self, s):\n        """"""Tests the Heisenberg representation of the ControlledPhase gate.""""""\n        matrix = cv.ControlledPhase._heisenberg_rep([s])\n        true_matrix = np.array(\n            [\n                [1, 0, 0, 0, 0],\n                [0, 1, 0, 0, 0],\n                [0, 0, 1, s, 0],\n                [0, 0, 0, 1, 0],\n                [0, s, 0, 0, 1],\n            ]\n        )\n        assert np.allclose(matrix, true_matrix)\n\n\nclass TestNonGaussian:\n    """"""Tests that non-Gaussian gates are properly handled.""""""\n\n    @pytest.mark.parametrize(""gate"", [cv.Kerr, cv.CrossKerr, cv.CubicPhase])\n    def test_heisenberg_rep_nonguassian(self, gate):\n        """"""ops: Tests that the `_heisenberg_rep` for a non-Gaussian gates is\n        None\n        """"""\n        assert gate._heisenberg_rep(*[0.1] * gate.num_params) is None\n\n    def test_heisenberg_transformation_nongaussian(self):\n        """"""ops: Tests that proper exceptions are raised if we try to call the\n        Heisenberg transformation of non-Gaussian gates.""""""\n        op = cv.Kerr\n        with pytest.raises(RuntimeError, match=r""not a Gaussian operation""):\n            op_ = op(*[0.1] * op.num_params, wires=range(op.num_wires))\n            op_.heisenberg_tr(op.num_wires)\n\n        op = cv.CrossKerr\n        with pytest.raises(RuntimeError):\n            op_ = op(*[0.1] * op.num_params, wires=range(op.num_wires))\n            op_.heisenberg_tr(op.num_wires)\n\n        op = cv.CubicPhase\n        with pytest.raises(RuntimeError):\n            op_ = op(*[0.1] * op.num_params, wires=range(op.num_wires))\n            op_.heisenberg_tr(op.num_wires)\n'"
tests/ops/test_qubit_ops.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the available built-in discrete-variable quantum operations.\n""""""\nimport pytest\nimport functools\nimport numpy as np\nfrom numpy.linalg import multi_dot\n\nimport pennylane as qml\nfrom pennylane.wires import Wires\n\nfrom gate_data import I, X, Y, Z, H, CNOT, SWAP, CZ, S, T, CSWAP, Toffoli\n\n\n# Standard observables, their matrix representation, and eigenvlaues\nOBSERVABLES = [\n    (qml.PauliX, X, [1, -1]),\n    (qml.PauliY, Y, [1, -1]),\n    (qml.PauliZ, Z, [1, -1]),\n    (qml.Hadamard, H, [1, -1]),\n    (qml.Identity, I, [1, 1]),\n]\n\n# Hermitian matrices, their corresponding eigenvalues and eigenvectors.\nEIGVALS_TEST_DATA = [\n    (np.array([[1, 0], [0, 1]]), np.array([1.0, 1.0]), np.array([[1.0, 0.0], [0.0, 1.0]])),\n    (\n        np.array([[0, 1], [1, 0]]),\n        np.array([-1.0, 1.0]),\n        np.array([[-0.70710678, 0.70710678], [0.70710678, 0.70710678]]),\n    ),\n    (\n        np.array([[0, -1j], [1j, 0]]),\n        np.array([-1.0, 1.0]),\n        np.array(\n            [[-0.70710678 + 0.0j, -0.70710678 + 0.0j], [0.0 + 0.70710678j, 0.0 - 0.70710678j]]\n        ),\n    ),\n    (np.array([[1, 0], [0, -1]]), np.array([-1.0, 1.0]), np.array([[0.0, 1.0], [1.0, 0.0]])),\n    (\n        1 / np.sqrt(2) * np.array([[1, 1], [1, -1]]),\n        np.array([-1.0, 1.0]),\n        np.array([[0.38268343, -0.92387953], [-0.92387953, -0.38268343]]),\n    ),\n]\n\nEIGVALS_TEST_DATA_MULTI_WIRES = [functools.reduce(np.kron, [Y, I, Z])]\n\n\n@pytest.mark.usefixtures(""tear_down_hermitian"")\nclass TestObservables:\n    """"""Tests for observables""""""\n\n    @pytest.mark.parametrize(""obs, mat, eigs"", OBSERVABLES)\n    def test_diagonalization(self, obs, mat, eigs, tol):\n        """"""Test the method transforms standard observables into the Z-gate.""""""\n        ob = obs(wires=0)\n        A = ob.matrix\n\n        diag_gates = ob.diagonalizing_gates()\n        U = np.eye(2)\n\n        if diag_gates:\n            mats = [i.matrix for i in diag_gates]\n            # Need to revert the order in which the matrices are applied such that they adhere to the order\n            # of matrix multiplication\n            # E.g. for PauliY: [PauliZ(wires=self.wires), S(wires=self.wires), Hadamard(wires=self.wires)]\n            # becomes Hadamard @ S @ PauliZ, where @ stands for matrix multiplication\n            mats = mats[::-1]\n            U = multi_dot([np.eye(2)] + mats)\n\n        res = U @ A @ U.conj().T\n        expected = np.diag(eigs)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""obs, mat, eigs"", OBSERVABLES)\n    def test_eigvals(self, obs, mat, eigs, tol):\n        """"""Test eigenvalues of standard observables are correct""""""\n        obs = obs(wires=0)\n        res = obs.eigvals\n        assert np.allclose(res, eigs, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""obs, mat, eigs"", OBSERVABLES)\n    def test_matrices(self, obs, mat, eigs, tol):\n        """"""Test matrices of standard observables are correct""""""\n        obs = obs(wires=0)\n        res = obs.matrix\n        assert np.allclose(res, mat, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""observable, eigvals, eigvecs"", EIGVALS_TEST_DATA)\n    def test_hermitian_eigegendecomposition_single_wire(self, observable, eigvals, eigvecs, tol):\n        """"""Tests that the eigendecomposition property of the Hermitian class returns the correct results\n        for a single wire.""""""\n\n        eigendecomp = qml.Hermitian(observable, wires=0).eigendecomposition\n        assert np.allclose(eigendecomp[""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(eigendecomp[""eigvec""], eigvecs, atol=tol, rtol=0)\n\n        key = tuple(observable.flatten().tolist())\n        assert np.allclose(qml.Hermitian._eigs[key][""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(qml.Hermitian._eigs[key][""eigvec""], eigvecs, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n    @pytest.mark.parametrize(""observable"", EIGVALS_TEST_DATA_MULTI_WIRES)\n    def test_hermitian_eigegendecomposition_multiple_wires(self, observable, tol):\n        """"""Tests that the eigendecomposition property of the Hermitian class returns the correct results\n        for multiple wires.""""""\n\n        num_wires = int(np.log2(len(observable)))\n        eigendecomp = qml.Hermitian(observable, wires=list(range(num_wires))).eigendecomposition\n\n        eigvals, eigvecs = np.linalg.eigh(observable)\n\n        assert np.allclose(eigendecomp[""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(eigendecomp[""eigvec""], eigvecs, atol=tol, rtol=0)\n\n        key = tuple(observable.flatten().tolist())\n        assert np.allclose(qml.Hermitian._eigs[key][""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(qml.Hermitian._eigs[key][""eigvec""], eigvecs, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n    @pytest.mark.parametrize(""obs1"", EIGVALS_TEST_DATA)\n    @pytest.mark.parametrize(""obs2"", EIGVALS_TEST_DATA)\n    def test_hermitian_eigvals_eigvecs_two_different_observables(self, obs1, obs2, tol):\n        """"""Tests that the eigvals method of the Hermitian class returns the correct results\n        for two observables.""""""\n        if np.all(obs1[0] == obs2[0]):\n            pytest.skip(""Test only runs for pairs of differing observable"")\n\n        observable_1 = obs1[0]\n        observable_1_eigvals = obs1[1]\n        observable_1_eigvecs = obs1[2]\n\n        key = tuple(observable_1.flatten().tolist())\n\n        qml.Hermitian(observable_1, 0).eigvals\n        assert np.allclose(\n            qml.Hermitian._eigs[key][""eigval""], observable_1_eigvals, atol=tol, rtol=0\n        )\n        assert np.allclose(\n            qml.Hermitian._eigs[key][""eigvec""], observable_1_eigvecs, atol=tol, rtol=0\n        )\n        assert len(qml.Hermitian._eigs) == 1\n\n        observable_2 = obs2[0]\n        observable_2_eigvals = obs2[1]\n        observable_2_eigvecs = obs2[2]\n\n        key_2 = tuple(observable_2.flatten().tolist())\n\n        qml.Hermitian(observable_2, 0).eigvals\n        assert np.allclose(\n            qml.Hermitian._eigs[key_2][""eigval""], observable_2_eigvals, atol=tol, rtol=0\n        )\n        assert np.allclose(\n            qml.Hermitian._eigs[key_2][""eigvec""], observable_2_eigvecs, atol=tol, rtol=0\n        )\n        assert len(qml.Hermitian._eigs) == 2\n\n    @pytest.mark.parametrize(""observable, eigvals, eigvecs"", EIGVALS_TEST_DATA)\n    def test_hermitian_eigvals_eigvecs_same_observable_twice(\n        self, observable, eigvals, eigvecs, tol\n    ):\n        """"""Tests that the eigvals method of the Hermitian class keeps the same dictionary entries upon multiple calls.""""""\n        key = tuple(observable.flatten().tolist())\n\n        qml.Hermitian(observable, 0).eigvals\n        assert np.allclose(qml.Hermitian._eigs[key][""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(qml.Hermitian._eigs[key][""eigvec""], eigvecs, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n        qml.Hermitian(observable, 0).eigvals\n        assert np.allclose(qml.Hermitian._eigs[key][""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(qml.Hermitian._eigs[key][""eigvec""], eigvecs, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n    @pytest.mark.parametrize(""observable, eigvals, eigvecs"", EIGVALS_TEST_DATA)\n    def test_hermitian_diagonalizing_gates(self, observable, eigvals, eigvecs, tol):\n        """"""Tests that the diagonalizing_gates method of the Hermitian class returns the correct results.""""""\n        qubit_unitary = qml.Hermitian(observable, wires=[0]).diagonalizing_gates()\n\n        key = tuple(observable.flatten().tolist())\n        assert np.allclose(qml.Hermitian._eigs[key][""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(qml.Hermitian._eigs[key][""eigvec""], eigvecs, atol=tol, rtol=0)\n\n        assert np.allclose(qubit_unitary[0].params, eigvecs.conj().T, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n    @pytest.mark.parametrize(""obs1"", EIGVALS_TEST_DATA)\n    @pytest.mark.parametrize(""obs2"", EIGVALS_TEST_DATA)\n    def test_hermitian_diagonalizing_gates_two_different_observables(self, obs1, obs2, tol):\n        """"""Tests that the diagonalizing_gates method of the Hermitian class returns the correct results\n           for two observables.""""""\n        if np.all(obs1[0] == obs2[0]):\n            pytest.skip(""Test only runs for pairs of differing observable"")\n\n        observable_1 = obs1[0]\n        observable_1_eigvals = obs1[1]\n        observable_1_eigvecs = obs1[2]\n\n        qubit_unitary = qml.Hermitian(observable_1, wires=[0]).diagonalizing_gates()\n\n        key = tuple(observable_1.flatten().tolist())\n        assert np.allclose(\n            qml.Hermitian._eigs[key][""eigval""], observable_1_eigvals, atol=tol, rtol=0\n        )\n        assert np.allclose(\n            qml.Hermitian._eigs[key][""eigvec""], observable_1_eigvecs, atol=tol, rtol=0\n        )\n\n        assert np.allclose(qubit_unitary[0].params, observable_1_eigvecs.conj().T, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n        observable_2 = obs2[0]\n        observable_2_eigvals = obs2[1]\n        observable_2_eigvecs = obs2[2]\n\n        qubit_unitary_2 = qml.Hermitian(observable_2, wires=[0]).diagonalizing_gates()\n\n        key = tuple(observable_2.flatten().tolist())\n        assert np.allclose(\n            qml.Hermitian._eigs[key][""eigval""], observable_2_eigvals, atol=tol, rtol=0\n        )\n        assert np.allclose(\n            qml.Hermitian._eigs[key][""eigvec""], observable_2_eigvecs, atol=tol, rtol=0\n        )\n\n        assert np.allclose(\n            qubit_unitary_2[0].params, observable_2_eigvecs.conj().T, atol=tol, rtol=0\n        )\n        assert len(qml.Hermitian._eigs) == 2\n\n    @pytest.mark.parametrize(""observable, eigvals, eigvecs"", EIGVALS_TEST_DATA)\n    def test_hermitian_diagonalizing_gatesi_same_observable_twice(\n        self, observable, eigvals, eigvecs, tol\n    ):\n        """"""Tests that the diagonalizing_gates method of the Hermitian class keeps the same dictionary entries upon multiple calls.""""""\n        qubit_unitary = qml.Hermitian(observable, wires=[0]).diagonalizing_gates()\n\n        key = tuple(observable.flatten().tolist())\n        assert np.allclose(qml.Hermitian._eigs[key][""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(qml.Hermitian._eigs[key][""eigvec""], eigvecs, atol=tol, rtol=0)\n\n        assert np.allclose(qubit_unitary[0].params, eigvecs.conj().T, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n        qubit_unitary = qml.Hermitian(observable, wires=[0]).diagonalizing_gates()\n\n        key = tuple(observable.flatten().tolist())\n        assert np.allclose(qml.Hermitian._eigs[key][""eigval""], eigvals, atol=tol, rtol=0)\n        assert np.allclose(qml.Hermitian._eigs[key][""eigvec""], eigvecs, atol=tol, rtol=0)\n\n        assert np.allclose(qubit_unitary[0].params, eigvecs.conj().T, atol=tol, rtol=0)\n        assert len(qml.Hermitian._eigs) == 1\n\n    @pytest.mark.parametrize(""observable, eigvals, eigvecs"", EIGVALS_TEST_DATA)\n    def test_hermitian_diagonalizing_gates_integration(self, observable, eigvals, eigvecs, tol):\n        """"""Tests that the diagonalizing_gates method of the Hermitian class\n        diagonalizes the given observable.""""""\n        tensor_obs = np.kron(observable, observable)\n        eigvals = np.kron(eigvals, eigvals)\n\n        diag_gates = qml.Hermitian(tensor_obs, wires=[0, 1]).diagonalizing_gates()\n\n        assert len(diag_gates) == 1\n\n        U = diag_gates[0].parameters[0]\n        x = U @ tensor_obs @ U.conj().T\n        assert np.allclose(np.diag(np.sort(eigvals)), x, atol=tol, rtol=0)\n\n    def test_hermitian_matrix(self, tol):\n        """"""Test that the hermitian matrix method produces the correct output.""""""\n        H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\n        out = qml.Hermitian(H, wires=0).matrix\n\n        # verify output type\n        assert isinstance(out, np.ndarray)\n\n        # verify equivalent to input state\n        assert np.allclose(out, H, atol=tol, rtol=0)\n\n    def test_hermitian_exceptions(self):\n        """"""Tests that the hermitian matrix method raises the proper errors.""""""\n        H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\n\n        # test non-square matrix\n        with pytest.raises(ValueError, match=""must be a square matrix""):\n            qml.Hermitian(H[1:], wires=0).matrix\n\n        # test non-Hermitian matrix\n        H2 = H.copy()\n        H2[0, 1] = 2\n        with pytest.raises(ValueError, match=""must be Hermitian""):\n            qml.Hermitian(H2, wires=0).matrix\n\n\n# Non-parametrized operations and their matrix representation\nNON_PARAMETRIZED_OPERATIONS = [\n    (qml.CNOT, CNOT),\n    (qml.SWAP, SWAP),\n    (qml.CZ, CZ),\n    (qml.S, S),\n    (qml.T, T),\n    (qml.CSWAP, CSWAP),\n    (qml.Toffoli, Toffoli),\n]\n\n\nclass TestOperations:\n    """"""Tests for the operations""""""\n\n    @pytest.mark.parametrize(""ops, mat"", NON_PARAMETRIZED_OPERATIONS)\n    def test_matrices(self, ops, mat, tol):\n        """"""Test matrices of non-parametrized operations are correct""""""\n        op = ops(wires=range(ops.num_wires))\n        res = op.matrix\n        assert np.allclose(res, mat, atol=tol, rtol=0)\n\n    def test_x_decomposition(self, tol):\n        """"""Tests that the decomposition of the PauliX is correct""""""\n        op = qml.PauliX(wires=0)\n        res = op.decomposition(0)\n\n        assert len(res) == 3\n\n        assert res[0].name == ""PhaseShift""\n        assert res[0].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi / 2\n        \n        assert res[1].name == ""RX""\n        assert res[1].wires == qml.wires.Wires([0])\n        assert res[1].params[0] == np.pi\n        \n        assert res[2].name == ""PhaseShift""\n        assert res[2].wires == qml.wires.Wires([0])\n        assert res[2].params[0] == np.pi / 2\n\n        decomposed_matrix = np.linalg.multi_dot([i.matrix for i in reversed(res)])\n        assert np.allclose(decomposed_matrix, op.matrix, atol=tol, rtol=0)\n\n    def test_y_decomposition(self, tol):\n        """"""Tests that the decomposition of the PauliY is correct""""""\n        op = qml.PauliY(wires=0)\n        res = op.decomposition(0)\n\n        assert len(res) == 3\n\n        assert res[0].name == ""PhaseShift""\n        assert res[0].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi / 2\n        \n        assert res[1].name == ""RY""\n        assert res[1].wires == qml.wires.Wires([0])\n        assert res[1].params[0] == np.pi\n        \n        assert res[2].name == ""PhaseShift""\n        assert res[2].wires == qml.wires.Wires([0])\n        assert res[2].params[0] == np.pi / 2\n        \n        decomposed_matrix = np.linalg.multi_dot([i.matrix for i in reversed(res)])\n        assert np.allclose(decomposed_matrix, op.matrix, atol=tol, rtol=0)\n\n    def test_z_decomposition(self, tol):\n        """"""Tests that the decomposition of the PauliZ is correct""""""\n        op = qml.PauliZ(wires=0)\n        res = op.decomposition(0)\n\n        assert len(res) == 1\n\n        assert res[0].name == ""PhaseShift""\n        assert res[0].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi\n        \n        decomposed_matrix = res[0].matrix\n        assert np.allclose(decomposed_matrix, op.matrix, atol=tol, rtol=0)\n\n    def test_s_decomposition(self, tol):\n        """"""Tests that the decomposition of the S gate is correct""""""\n        op = qml.S(wires=0)\n        res = op.decomposition(0)\n\n        assert len(res) == 1\n\n        assert res[0].name == ""PhaseShift""\n        assert res[0].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi / 2\n        \n        decomposed_matrix = res[0].matrix\n        assert np.allclose(decomposed_matrix, op.matrix, atol=tol, rtol=0)\n\n    def test_t_decomposition(self, tol):\n        """"""Tests that the decomposition of the T gate is correct""""""\n        op = qml.T(wires=0)\n        res = op.decomposition(0)\n\n        assert len(res) == 1\n\n        assert res[0].name == ""PhaseShift""\n        assert res[0].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi / 4\n        \n        decomposed_matrix = res[0].matrix\n        assert np.allclose(decomposed_matrix, op.matrix, atol=tol, rtol=0)\n\n    def test_hadamard_decomposition(self, tol):\n        """"""Tests that the decomposition of the Hadamard gate is correct""""""\n        op = qml.Hadamard(wires=0)\n        res = op.decomposition(0)\n\n        assert len(res) == 3\n\n        assert res[0].name == ""PhaseShift""\n        assert res[0].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi / 2\n\n        assert res[1].name == ""RX""\n        assert res[1].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi / 2\n        \n        assert res[2].name == ""PhaseShift""\n        assert res[2].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == np.pi / 2\n        \n        decomposed_matrix = np.linalg.multi_dot([i.matrix for i in reversed(res)])\n        assert np.allclose(decomposed_matrix, op.matrix, atol=tol, rtol=0)\n\n    def test_phase_decomposition(self, tol):\n        """"""Tests that the decomposition of the Phase gate is correct""""""\n        phi = 0.3\n        op = qml.PhaseShift(phi, wires=0)\n        res = op.decomposition(phi, 0)\n\n        assert len(res) == 1\n\n        assert res[0].name == ""RZ""\n        assert res[0].wires == qml.wires.Wires([0])\n        assert res[0].params[0] == 0.3\n        \n        decomposed_matrix = res[0].matrix\n        global_phase = (decomposed_matrix[op.matrix != 0] / op.matrix[op.matrix != 0])[0]\n\n        assert np.allclose(decomposed_matrix, global_phase * op.matrix, atol=tol, rtol=0)\n\n    def test_phase_shift(self, tol):\n        """"""Test phase shift is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(qml.PhaseShift._matrix(0), np.identity(2), atol=tol, rtol=0)\n        assert np.allclose(qml.U1._matrix(0), np.identity(2), atol=tol, rtol=0)\n\n        # test arbitrary phase shift\n        phi = 0.5432\n        expected = np.array([[1, 0], [0, np.exp(1j * phi)]])\n        assert np.allclose(qml.PhaseShift._matrix(phi), expected, atol=tol, rtol=0)\n        assert np.allclose(qml.U1._matrix(phi), expected, atol=tol, rtol=0)\n\n    def test_x_rotation(self, tol):\n        """"""Test x rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(qml.RX._matrix(0), np.identity(2), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array([[1, -1j], [-1j, 1]]) / np.sqrt(2)\n        assert np.allclose(qml.RX._matrix(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = -1j * np.array([[0, 1], [1, 0]])\n        assert np.allclose(qml.RX._matrix(np.pi), expected, atol=tol, rtol=0)\n\n    def test_y_rotation(self, tol):\n        """"""Test y rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(qml.RY._matrix(0), np.identity(2), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array([[1, -1], [1, 1]]) / np.sqrt(2)\n        assert np.allclose(qml.RY._matrix(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[0, -1], [1, 0]])\n        assert np.allclose(qml.RY._matrix(np.pi), expected, atol=tol, rtol=0)\n\n    def test_z_rotation(self, tol):\n        """"""Test z rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(qml.RZ._matrix(0), np.identity(2), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.diag(np.exp([-1j * np.pi / 4, 1j * np.pi / 4]))\n        assert np.allclose(qml.RZ._matrix(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        assert np.allclose(qml.RZ._matrix(np.pi), -1j * Z, atol=tol, rtol=0)\n\n    def test_arbitrary_rotation(self, tol):\n        """"""Test arbitrary single qubit rotation is correct""""""\n\n        # test identity for phi,theta,omega=0\n        assert np.allclose(qml.Rot._matrix(0, 0, 0), np.identity(2), atol=tol, rtol=0)\n\n        # expected result\n        def arbitrary_rotation(x, y, z):\n            """"""arbitrary single qubit rotation""""""\n            c = np.cos(y / 2)\n            s = np.sin(y / 2)\n            return np.array(\n                [\n                    [np.exp(-0.5j * (x + z)) * c, -np.exp(0.5j * (x - z)) * s],\n                    [np.exp(-0.5j * (x - z)) * s, np.exp(0.5j * (x + z)) * c],\n                ]\n            )\n\n        a, b, c = 0.432, -0.152, 0.9234\n        assert np.allclose(qml.Rot._matrix(a, b, c), arbitrary_rotation(a, b, c), atol=tol, rtol=0)\n\n    def test_C_x_rotation(self, tol):\n        """"""Test controlled x rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(qml.CRX._matrix(0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, 1 / np.sqrt(2), -1j / np.sqrt(2)],\n                [0, 0, -1j / np.sqrt(2), 1 / np.sqrt(2)],\n            ]\n        )\n        assert np.allclose(qml.CRX._matrix(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1j], [0, 0, -1j, 0]])\n        assert np.allclose(qml.CRX._matrix(np.pi), expected, atol=tol, rtol=0)\n\n    def test_C_y_rotation(self, tol):\n        """"""Test controlled y rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(qml.CRY._matrix(0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, 1 / np.sqrt(2), -1 / np.sqrt(2)],\n                [0, 0, 1 / np.sqrt(2), 1 / np.sqrt(2)],\n            ]\n        )\n        assert np.allclose(qml.CRY._matrix(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1], [0, 0, 1, 0]])\n        assert np.allclose(qml.CRY._matrix(np.pi), expected, atol=tol, rtol=0)\n\n    def test_C_z_rotation(self, tol):\n        """"""Test controlled z rotation is correct""""""\n\n        # test identity for theta=0\n        assert np.allclose(qml.CRZ._matrix(0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for theta=pi/2\n        expected = np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, np.exp(-1j * np.pi / 4), 0],\n                [0, 0, 0, np.exp(1j * np.pi / 4)],\n            ]\n        )\n        assert np.allclose(qml.CRZ._matrix(np.pi / 2), expected, atol=tol, rtol=0)\n\n        # test identity for theta=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1j, 0], [0, 0, 0, 1j]])\n        assert np.allclose(qml.CRZ._matrix(np.pi), expected, atol=tol, rtol=0)\n\n    def test_controlled_arbitrary_rotation(self, tol):\n        """"""Test controlled arbitrary rotation is correct""""""\n\n        # test identity for phi,theta,omega=0\n        assert np.allclose(qml.CRot._matrix(0, 0, 0), np.identity(4), atol=tol, rtol=0)\n\n        # test identity for phi,theta,omega=pi\n        expected = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1], [0, 0, 1, 0]])\n        assert np.allclose(qml.CRot._matrix(np.pi, np.pi, np.pi), expected, atol=tol, rtol=0)\n\n        def arbitrary_Crotation(x, y, z):\n            """"""controlled arbitrary single qubit rotation""""""\n            c = np.cos(y / 2)\n            s = np.sin(y / 2)\n            return np.array(\n                [\n                    [1, 0, 0, 0],\n                    [0, 1, 0, 0],\n                    [0, 0, np.exp(-0.5j * (x + z)) * c, -np.exp(0.5j * (x - z)) * s],\n                    [0, 0, np.exp(-0.5j * (x - z)) * s, np.exp(0.5j * (x + z)) * c],\n                ]\n            )\n\n        a, b, c = 0.432, -0.152, 0.9234\n        assert np.allclose(\n            qml.CRot._matrix(a, b, c), arbitrary_Crotation(a, b, c), atol=tol, rtol=0\n        )\n\n    def test_U2_gate(self, tol):\n        """"""Test U2 gate matrix matches the documentation""""""\n        phi = 0.432\n        lam = -0.12\n        res = qml.U2._matrix(phi, lam)\n        expected = np.array(\n            [[1, -np.exp(1j * lam)], [np.exp(1j * phi), np.exp(1j * (phi + lam))]]\n        ) / np.sqrt(2)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_U3_gate(self, tol):\n        """"""Test U3 gate matrix matches the documentation""""""\n        theta = 0.65\n        phi = 0.432\n        lam = -0.12\n\n        res = qml.U3._matrix(theta, phi, lam)\n        expected = np.array(\n            [\n                [np.cos(theta / 2), -np.exp(1j * lam) * np.sin(theta / 2)],\n                [\n                    np.exp(1j * phi) * np.sin(theta / 2),\n                    np.exp(1j * (phi + lam)) * np.cos(theta / 2),\n                ],\n            ]\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_qubit_unitary(self, tol):\n        """"""Test that the unitary operator produces the correct output.""""""\n        U = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\n        out = qml.QubitUnitary(U, wires=0).matrix\n\n        # verify output type\n        assert isinstance(out, np.ndarray)\n\n        # verify equivalent to input state\n        assert np.allclose(out, U, atol=tol, rtol=0)\n\n    def test_qubit_unitary_exceptions(self):\n        """"""Tests that the unitary operator raises the proper errors.""""""\n        U = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\n\n        # test non-square matrix\n        with pytest.raises(ValueError, match=""must be a square matrix""):\n            qml.QubitUnitary(U[1:], wires=0).matrix\n\n        # test non-unitary matrix\n        U3 = U.copy()\n        U3[0, 0] += 0.5\n        with pytest.raises(ValueError, match=""must be unitary""):\n            qml.QubitUnitary(U3, wires=0).matrix\n\n\nPAULI_ROT_PARAMETRIC_MATRIX_TEST_DATA = [\n    (\n        ""XY"",\n        lambda theta: np.array(\n            [\n                [np.cos(theta / 2), 0, 0, -np.sin(theta / 2)],\n                [0, np.cos(theta / 2), np.sin(theta / 2), 0],\n                [0, -np.sin(theta / 2), np.cos(theta / 2), 0],\n                [np.sin(theta / 2), 0, 0, np.cos(theta / 2)],\n            ],\n            dtype=complex,\n        ),\n    ),\n    (\n        ""ZZ"",\n        lambda theta: np.diag(\n            [\n                np.exp(-1j * theta / 2),\n                np.exp(1j * theta / 2),\n                np.exp(1j * theta / 2),\n                np.exp(-1j * theta / 2),\n            ],\n        ),\n    ),\n    (\n        ""XI"",\n        lambda theta: np.array(\n            [\n                [np.cos(theta / 2), 0, -1j * np.sin(theta / 2), 0],\n                [0, np.cos(theta / 2), 0, -1j * np.sin(theta / 2)],\n                [-1j * np.sin(theta / 2), 0, np.cos(theta / 2), 0],\n                [0, -1j * np.sin(theta / 2), 0, np.cos(theta / 2)],\n            ],\n        ),\n    ),\n    (""X"", qml.RX._matrix),\n    (""Y"", qml.RY._matrix),\n    (""Z"", qml.RZ._matrix),\n]\n\nPAULI_ROT_MATRIX_TEST_DATA = [\n    (\n        np.pi,\n        ""XIZ"",\n        np.array(\n            [\n                [0, 0, 0, 0, -1j, 0, 0, 0],\n                [0, 0, 0, 0, 0, 1j, 0, 0],\n                [0, 0, 0, 0, 0, 0, -1j, 0],\n                [0, 0, 0, 0, 0, 0, 0, 1j],\n                [-1j, 0, 0, 0, 0, 0, 0, 0],\n                [0, 1j, 0, 0, 0, 0, 0, 0],\n                [0, 0, -1j, 0, 0, 0, 0, 0],\n                [0, 0, 0, 1j, 0, 0, 0, 0],\n            ]\n        ),\n    ),\n    (\n        np.pi / 3,\n        ""XYZ"",\n        np.array(\n            [\n                [np.sqrt(3) / 2, 0, 0, 0, 0, 0, -(1 / 2), 0],\n                [0, np.sqrt(3) / 2, 0, 0, 0, 0, 0, 1 / 2],\n                [0, 0, np.sqrt(3) / 2, 0, 1 / 2, 0, 0, 0],\n                [0, 0, 0, np.sqrt(3) / 2, 0, -(1 / 2), 0, 0],\n                [0, 0, -(1 / 2), 0, np.sqrt(3) / 2, 0, 0, 0],\n                [0, 0, 0, 1 / 2, 0, np.sqrt(3) / 2, 0, 0],\n                [1 / 2, 0, 0, 0, 0, 0, np.sqrt(3) / 2, 0],\n                [0, -(1 / 2), 0, 0, 0, 0, 0, np.sqrt(3) / 2],\n            ]\n        ),\n    ),\n]\n\n\nclass TestPauliRot:\n    """"""Test the PauliRot operation.""""""\n\n    @pytest.mark.parametrize(""theta"", np.linspace(0, 2 * np.pi, 7))\n    @pytest.mark.parametrize(\n        ""pauli_word,expected_matrix"", PAULI_ROT_PARAMETRIC_MATRIX_TEST_DATA,\n    )\n    def test_PauliRot_matrix_parametric(self, theta, pauli_word, expected_matrix, tol):\n        """"""Test parametrically that the PauliRot matrix is correct.""""""\n\n        res = qml.PauliRot._matrix(theta, pauli_word)\n        expected = expected_matrix(theta)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\n        ""theta,pauli_word,expected_matrix"", PAULI_ROT_MATRIX_TEST_DATA,\n    )\n    def test_PauliRot_matrix(self, theta, pauli_word, expected_matrix, tol):\n        """"""Test non-parametrically that the PauliRot matrix is correct.""""""\n\n        res = qml.PauliRot._matrix(theta, pauli_word)\n        expected = expected_matrix\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\n        ""theta,pauli_word,compressed_pauli_word,wires,compressed_wires"",\n        [\n            (np.pi, ""XIZ"", ""XZ"", [0, 1, 2], [0, 2]),\n            (np.pi / 3, ""XIYIZI"", ""XYZ"", [0, 1, 2, 3, 4, 5], [0, 2, 4]),\n            (np.pi / 7, ""IXI"", ""X"", [0, 1, 2], [1]),\n            (np.pi / 9, ""IIIIIZI"", ""Z"", [0, 1, 2, 3, 4, 5, 6], [5]),\n            (np.pi / 11, ""XYZIII"", ""XYZ"", [0, 1, 2, 3, 4, 5], [0, 1, 2]),\n            (np.pi / 11, ""IIIXYZ"", ""XYZ"", [0, 1, 2, 3, 4, 5], [3, 4, 5]),\n        ],\n    )\n    def test_PauliRot_matrix_identity(\n        self, theta, pauli_word, compressed_pauli_word, wires, compressed_wires, tol\n    ):\n        """"""Test PauliRot matrix correctly accounts for identities.""""""\n\n        res = qml.PauliRot._matrix(theta, pauli_word)\n        expected = qml.utils.expand(\n            qml.PauliRot._matrix(theta, compressed_pauli_word), compressed_wires, wires\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_PauliRot_decomposition_ZZ(self):\n        """"""Test that the decomposition for a ZZ rotation is correct.""""""\n\n        theta = 0.4\n        op = qml.PauliRot(theta, ""ZZ"", wires=[0, 1])\n        decomp_ops = op.decomposition(theta, ""ZZ"", wires=[0, 1])\n\n        assert len(decomp_ops) == 1\n\n        assert decomp_ops[0].name == ""MultiRZ""\n        assert decomp_ops[0].wires == Wires([0, 1])\n        assert decomp_ops[0].params[0] == theta\n\n    def test_PauliRot_decomposition_XY(self):\n        """"""Test that the decomposition for a XY rotation is correct.""""""\n\n        theta = 0.4\n        op = qml.PauliRot(theta, ""XY"", wires=[0, 1])\n        decomp_ops = op.decomposition(theta, ""XY"", wires=[0, 1])\n\n        assert len(decomp_ops) == 5\n\n        assert decomp_ops[0].name == ""Hadamard""\n        assert decomp_ops[0].wires == Wires([0])\n\n        assert decomp_ops[1].name == ""RX""\n        assert decomp_ops[1].wires == Wires([1])\n        assert decomp_ops[1].params[0] == np.pi / 2\n\n        assert decomp_ops[2].name == ""MultiRZ""\n        assert decomp_ops[2].wires == Wires([0, 1])\n        assert decomp_ops[2].params[0] == theta\n\n        assert decomp_ops[3].name == ""Hadamard""\n        assert decomp_ops[3].wires == Wires([0])\n\n        assert decomp_ops[4].name == ""RX""\n        assert decomp_ops[4].wires == Wires([1])\n        assert decomp_ops[4].params[0] == -np.pi / 2\n\n    def test_PauliRot_decomposition_XIYZ(self):\n        """"""Test that the decomposition for a XIYZ rotation is correct.""""""\n\n        theta = 0.4\n        op = qml.PauliRot(theta, ""XIYZ"", wires=[0, 1, 2, 3])\n        decomp_ops = op.decomposition(theta, ""XIYZ"", wires=[0, 1, 2, 3])\n\n        assert len(decomp_ops) == 5\n\n        assert decomp_ops[0].name == ""Hadamard""\n        assert decomp_ops[0].wires == Wires([0])\n\n        assert decomp_ops[1].name == ""RX""\n        assert decomp_ops[1].wires == Wires([2])\n        assert decomp_ops[1].params[0] == np.pi / 2\n\n        assert decomp_ops[2].name == ""MultiRZ""\n        assert decomp_ops[2].wires == Wires([0, 2, 3])\n        assert decomp_ops[2].params[0] == theta\n\n        assert decomp_ops[3].name == ""Hadamard""\n        assert decomp_ops[3].wires == Wires([0])\n\n        assert decomp_ops[4].name == ""RX""\n        assert decomp_ops[4].wires == Wires([2])\n        assert decomp_ops[4].params[0] == -np.pi / 2\n\n    @pytest.mark.parametrize(""angle"", np.linspace(0, 2 * np.pi, 7))\n    def test_differentiability(self, angle):\n        """"""Test that differentiation of PauliRot works.""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(theta):\n            qml.PauliRot(theta, ""XX"", wires=[0, 1])\n\n            return qml.expval(qml.PauliZ(0))\n\n        res = circuit(angle)\n        gradient = np.squeeze(circuit.jacobian(angle))\n\n        assert gradient == 0.5 * (circuit(angle + np.pi / 2) - circuit(angle - np.pi / 2))\n\n    @pytest.mark.parametrize(""angle"", np.linspace(0, 2 * np.pi, 7))\n    def test_decomposition_integration(self, angle, tol):\n        """"""Test that the decompositon of PauliRot yields the same results.""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(theta):\n            qml.PauliRot(theta, ""XX"", wires=[0, 1])\n\n            return qml.expval(qml.PauliZ(0))\n\n        @qml.qnode(dev)\n        def decomp_circuit(theta):\n            qml.PauliRot.decomposition(theta, ""XX"", wires=[0, 1])\n\n            return qml.expval(qml.PauliZ(0))\n\n        assert circuit(angle) == pytest.approx(decomp_circuit(angle), abs=tol)\n        assert np.squeeze(circuit.jacobian(angle)) == pytest.approx(\n            np.squeeze(decomp_circuit.jacobian(angle)), abs=tol\n        )\n\n    def test_matrix_incorrect_pauli_word_error(self):\n        """"""Test that _matrix throws an error if a wrong Pauli word is supplied.""""""\n\n        with pytest.raises(\n            ValueError,\n            match=\'The given Pauli word "".*"" contains characters that are not allowed.\'\n            "" Allowed characters are I, X, Y and Z"",\n        ):\n            qml.PauliRot._matrix(0.3, ""IXYZV"")\n\n    def test_init_incorrect_pauli_word_error(self):\n        """"""Test that __init__ throws an error if a wrong Pauli word is supplied.""""""\n\n        with pytest.raises(\n            ValueError,\n            match=\'The given Pauli word "".*"" contains characters that are not allowed.\'\n            "" Allowed characters are I, X, Y and Z"",\n        ):\n            qml.PauliRot(0.3, ""IXYZV"", wires=[0, 1, 2, 3, 4])\n\n    @pytest.mark.parametrize(""pauli_word,wires"", [(""XYZ"", [0, 1]), (""XYZ"", [0, 1, 2, 3]),])\n    def test_init_incorrect_pauli_word_length_error(self, pauli_word, wires):\n        """"""Test that __init__ throws an error if a Pauli word of wrong length is supplied.""""""\n\n        with pytest.raises(\n            ValueError,\n            match=""The given Pauli word has length .*, length .* was expected for wires .*"",\n        ):\n            qml.PauliRot(0.3, pauli_word, wires=wires)\n\n\nclass TestMultiRZ:\n    """"""Test the MultiRZ operation.""""""\n\n    @pytest.mark.parametrize(""theta"", np.linspace(0, 2 * np.pi, 7))\n    @pytest.mark.parametrize(\n        ""wires,expected_matrix"",\n        [\n            ([0], qml.RZ._matrix),\n            ([0, 1], lambda theta: np.diag(np.exp(1j * np.array([-1, 1, 1, -1]) * theta / 2),),),\n            (\n                [0, 1, 2],\n                lambda theta: np.diag(\n                    np.exp(1j * np.array([-1, 1, 1, -1, 1, -1, -1, 1]) * theta / 2),\n                ),\n            ),\n        ],\n    )\n    def test_MultiRZ_matrix_parametric(self, theta, wires, expected_matrix, tol):\n        """"""Test parametrically that the MultiRZ matrix is correct.""""""\n\n        res = qml.MultiRZ._matrix(theta, len(wires))\n        expected = expected_matrix(theta)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_MultiRZ_decomposition_ZZ(self):\n        """"""Test that the decomposition for a ZZ rotation is correct.""""""\n\n        theta = 0.4\n        op = qml.MultiRZ(theta, wires=[0, 1])\n        decomp_ops = op.decomposition(theta, wires=[0, 1])\n\n        assert decomp_ops[0].name == ""CNOT""\n        assert decomp_ops[0].wires == Wires([1, 0])\n\n        assert decomp_ops[1].name == ""RZ""\n        assert decomp_ops[1].wires == Wires([0])\n        assert decomp_ops[1].params[0] == theta\n\n        assert decomp_ops[2].name == ""CNOT""\n        assert decomp_ops[2].wires == Wires([1, 0])\n\n    def test_MultiRZ_decomposition_ZZZ(self):\n        """"""Test that the decomposition for a ZZZ rotation is correct.""""""\n\n        theta = 0.4\n        op = qml.MultiRZ(theta, wires=[0, 2, 3])\n        decomp_ops = op.decomposition(theta, wires=[0, 2, 3])\n\n        assert decomp_ops[0].name == ""CNOT""\n        assert decomp_ops[0].wires == Wires([3, 2])\n\n        assert decomp_ops[1].name == ""CNOT""\n        assert decomp_ops[1].wires == Wires([2, 0])\n\n        assert decomp_ops[2].name == ""RZ""\n        assert decomp_ops[2].wires == Wires([0])\n        assert decomp_ops[2].params[0] == theta\n\n        assert decomp_ops[3].name == ""CNOT""\n        assert decomp_ops[3].wires == Wires([2, 0])\n\n        assert decomp_ops[4].name == ""CNOT""\n        assert decomp_ops[4].wires == Wires([3, 2])\n\n    @pytest.mark.parametrize(""angle"", np.linspace(0, 2 * np.pi, 7))\n    def test_differentiability(self, angle):\n        """"""Test that differentiation of MultiRZ works.""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(theta):\n            qml.Hadamard(0)\n            qml.MultiRZ(theta, wires=[0, 1])\n\n            return qml.expval(qml.PauliX(0))\n\n        res = circuit(angle)\n        gradient = np.squeeze(circuit.jacobian(angle))\n\n        assert gradient == 0.5 * (circuit(angle + np.pi / 2) - circuit(angle - np.pi / 2))\n\n    @pytest.mark.parametrize(""angle"", np.linspace(0, 2 * np.pi, 7))\n    def test_decomposition_integration(self, angle, tol):\n        """"""Test that the decompositon of MultiRZ yields the same results.""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        @qml.qnode(dev)\n        def circuit(theta):\n            qml.Hadamard(0)\n            qml.MultiRZ(theta, wires=[0, 1])\n\n            return qml.expval(qml.PauliX(0))\n\n        @qml.qnode(dev)\n        def decomp_circuit(theta):\n            qml.Hadamard(0)\n            qml.MultiRZ.decomposition(theta, wires=[0, 1])\n\n            return qml.expval(qml.PauliX(0))\n\n        assert circuit(angle) == pytest.approx(decomp_circuit(angle), abs=tol)\n        assert np.squeeze(circuit.jacobian(angle)) == pytest.approx(\n            np.squeeze(decomp_circuit.jacobian(angle)), abs=tol\n        )\n\n\nclass TestDiagonalQubitUnitary:\n    """"""Test the DiagonalQubitUnitary operation.""""""\n\n    def test_decomposition(self):\n        """"""Test that DiagonalQubitUnitary falls back to QubitUnitary.""""""\n        D = np.array([1j, 1, 1, -1, -1j, 1j, 1, -1])\n\n        decomp = qml.DiagonalQubitUnitary.decomposition(D, [0, 1, 2])\n\n        assert decomp[0].name == ""QubitUnitary""\n        assert decomp[0].wires == Wires([0, 1, 2])\n        assert np.allclose(decomp[0].params[0], np.diag(D))\n'"
tests/plugins/test_default_gaussian.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.plugin.DefaultGaussian` device.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop,no-self-use\n\nimport pytest\nfrom scipy.special import factorial as fac\nfrom scipy.linalg import block_diag\nimport numpy as np\nimport numpy.random\n\nimport pennylane as qml\nfrom pennylane.plugins.default_gaussian import (\n    fock_prob,\n    rotation, squeezing, quadratic_phase, beamsplitter, two_mode_squeezing, controlled_addition, controlled_phase,\n    vacuum_state, coherent_state, squeezed_state, displaced_squeezed_state, thermal_state,\n    DefaultGaussian)\n\n\n\nU = np.array(\n    [[0.83645892-0.40533293j, -0.20215326+0.30850569j],\n     [-0.23889780-0.28101519j, -0.88031770-0.29832709j]]\n)\n\n\nU2 = np.array(\n    [[-0.07843244-3.57825948e-01j, 0.71447295-5.38069384e-02j, 0.20949966+6.59100734e-05j, -0.50297381+2.35731613e-01j],\n     [-0.26626692+4.53837083e-01j, 0.27771991-2.40717436e-01j, 0.41228017-1.30198687e-01j, 0.01384490-6.33200028e-01j],\n     [-0.69254712-2.56963068e-02j, -0.15484858+6.57298384e-02j, -0.53082141+7.18073414e-02j, -0.41060450-1.89462315e-01j],\n     [-0.09686189-3.15085273e-01j, -0.53241387-1.99491763e-01j, 0.56928622+3.97704398e-01j, -0.28671074-6.01574497e-02j]]\n)\n\n\nH = np.array(\n    [[1.02789352, 1.61296440-0.3498192j],\n     [1.61296440+0.3498192j, 1.23920938+0j]]\n)\n\n\nhbar = 2\n\ndef prep_par(par, op):\n    ""Convert par into a list of parameters that op expects.""\n    if op.par_domain == \'A\':\n        return [np.diag([x, 1]) for x in par]\n    return par\n\n\n@pytest.fixture(scope=""function"")\ndef gaussian_device_1_wire():\n    """"""Fixture of a default.gaussian device with 1 wire.""""""\n    return qml.device(\'default.gaussian\', wires=1)\n\n@pytest.fixture(scope=""function"")\ndef gaussian_device_2_wires():\n    """"""Fixture of a default.gaussian device with 2 wires.""""""\n    return qml.device(\'default.gaussian\', wires=2)\n\n@pytest.fixture(scope=""function"")\ndef gaussian_device_3_wires():\n    """"""Fixture of a default.gaussian device with 3 wires.""""""\n    return qml.device(\'default.gaussian\', wires=3)\n\ngaussian_dev = gaussian_device_2_wires  # alias\n\n\n\nclass TestExceptions:\n    """"""Tests that default.gaussian throws the correct error messages""""""\n\n    def test_sample_exception(self):\n        """"""Test that default.gaussian raises an exception if sampling is attempted.""""""\n\n        dev = qml.device(\'default.gaussian\', wires=1)\n\n        @qml.qnode(dev)\n        def circuit():\n            return qml.sample(qml.NumberOperator(0))\n            raise NotImplementedError()\n\n        with pytest.raises(NotImplementedError, match=""default.gaussian does not support sampling NumberOperator""):\n            circuit()\n\nclass TestAuxillaryFunctions:\n    """"""Tests the auxillary functions""""""\n\n    def test_fock_prob(self, tol):\n        """"""Test fock_prob returns the correct Fock probabilities""""""\n\n        # an arbitrary two-mode Gaussian state generated using Strawberry Fields\n        mu = np.array([0.6862, 0.4002, 0.09, 0.558]) * np.sqrt(hbar)\n        cov = np.array(\n            [[0.50750512, -0.04125979, -0.21058229, -0.07866912],\n             [-0.04125979, 0.50750512, -0.07866912, -0.21058229],\n             [-0.21058229, -0.07866912, 0.95906208, 0.27133391],\n             [-0.07866912, -0.21058229, 0.27133391, 0.95906208]]\n        ) * hbar\n\n        # expected Fock state probabilities\n        events = [(0, 0), (0, 1), (1, 1), (2, 3)]\n        probs = [0.430461524043, 0.163699407559, 0.0582788388927, 0.00167706931355]\n\n        for idx, e in enumerate(events):\n            res = fock_prob(mu, cov, e, hbar=hbar)\n            assert res == pytest.approx(probs[idx], abs=tol)\n\n\nclass TestGates:\n    """"""Gate tests.""""""\n\n    def test_rotation(self, tol):\n        """"""Test the Fourier transform of a displaced state.""""""\n        # pylint: disable=invalid-unary-operand-type\n\n        alpha = 0.23+0.12j\n        S = rotation(np.pi/2)\n\n        # apply to a coherent state. F{x, p} -> {-p, x}\n        out = S @ np.array([alpha.real, alpha.imag])*np.sqrt(2*hbar)\n        expected = np.array([-alpha.imag, alpha.real])*np.sqrt(2*hbar)\n        assert out == pytest.approx(expected, abs=tol)\n\n    def test_squeezing(self, tol):\n        """"""Test the squeezing symplectic transform.""""""\n\n        r = 0.543\n        phi = 0.123\n        S = squeezing(r, phi)\n\n        # apply to an identity covariance matrix\n        out = S @ S.T\n        expected = rotation(phi/2) @ np.diag(np.exp([-2*r, 2*r])) @ rotation(phi/2).T\n        assert out == pytest.approx(expected, abs=tol)\n\n    def test_quadratic_phase(self, tol):\n        """"""Test the quadratic phase symplectic transform.""""""\n\n        s = 0.543\n        S = quadratic_phase(s)\n\n        # apply to a coherent state. P[x, p] -> [x, p+sx]\n        alpha = 0.23+0.12j\n        out = S @ np.array([alpha.real, alpha.imag])*np.sqrt(2*hbar)\n        expected = np.array([alpha.real, alpha.imag+s*alpha.real])*np.sqrt(2*hbar)\n        assert out == pytest.approx(expected, abs=tol)\n\n    def test_beamsplitter(self, tol):\n        """"""Test the beamsplitter symplectic transform.""""""\n\n        theta = 0.543\n        phi = 0.312\n        S = beamsplitter(theta, phi)\n\n        # apply to a coherent state. BS|a1, a2> -> |ta1-r^*a2, ra1+ta2>\n        a1 = 0.23+0.12j\n        a2 = 0.23+0.12j\n        out = S @ np.array([a1.real, a2.real, a1.imag, a2.imag])*np.sqrt(2*hbar)\n\n        T = np.cos(theta)\n        R = np.exp(1j*phi)*np.sin(theta)\n        a1out = T*a1 - R.conj()*a2\n        a2out = R*a2 + T*a1\n        expected = np.array([a1out.real, a2out.real, a1out.imag, a2out.imag])*np.sqrt(2*hbar)\n        assert out == pytest.approx(expected, abs=tol)\n\n    def test_two_mode_squeezing(self, tol):\n        """"""Test the two mode squeezing symplectic transform.""""""\n\n        r = 0.543\n        phi = 0.123\n        S = two_mode_squeezing(r, phi)\n\n        # test that S = B^\\dagger(pi/4, 0) [S(z) x S(-z)] B(pi/4)\n        B = beamsplitter(np.pi/4, 0)\n        Sz = block_diag(squeezing(r, phi), squeezing(-r, phi))[:, [0, 2, 1, 3]][[0, 2, 1, 3]]\n        expected = B.conj().T @ Sz @ B\n        assert S == pytest.approx(expected, abs=tol)\n\n        # test that S |a1, a2> = |ta1+ra2, ta2+ra1>\n        a1 = 0.23+0.12j\n        a2 = 0.23+0.12j\n        out = S @ np.array([a1.real, a2.real, a1.imag, a2.imag])*np.sqrt(2*hbar)\n\n        T = np.cosh(r)\n        R = np.exp(1j*phi)*np.sinh(r)\n        a1out = T*a1 + R*np.conj(a2)\n        a2out = T*a2 + R*np.conj(a1)\n        expected = np.array([a1out.real, a2out.real, a1out.imag, a2out.imag])*np.sqrt(2*hbar)\n        assert out == pytest.approx(expected, abs=tol)\n\n    def test_controlled_addition(self, tol):\n        """"""Test the CX symplectic transform.""""""\n\n        s = 0.543\n        S = controlled_addition(s)\n\n        # test that S = B(theta+pi/2, 0) [S(z) x S(-z)] B(theta, 0)\n        r = np.arcsinh(-s/2)\n        theta = 0.5*np.arctan2(-1/np.cosh(r), -np.tanh(r))\n        Sz = block_diag(squeezing(r, 0), squeezing(-r, 0))[:, [0, 2, 1, 3]][[0, 2, 1, 3]]\n\n        expected = beamsplitter(theta+np.pi/2, 0) @ Sz @ beamsplitter(theta, 0)\n        assert S == pytest.approx(expected, abs=tol)\n\n        # test that S[x1, x2, p1, p2] -> [x1, x2+sx1, p1-sp2, p2]\n        x1 = 0.5432\n        x2 = -0.453\n        p1 = 0.154\n        p2 = -0.123\n        out = S @ np.array([x1, x2, p1, p2])*np.sqrt(2*hbar)\n        expected = np.array([x1, x2+s*x1, p1-s*p2, p2])*np.sqrt(2*hbar)\n        assert out == pytest.approx(expected, abs=tol)\n\n    def test_controlled_phase(self, tol):\n        """"""Test the CZ symplectic transform.""""""\n\n        s = 0.543\n        S = controlled_phase(s)\n\n        # test that S = R_2(pi/2) CX(s) R_2(pi/2)^\\dagger\n        R2 = block_diag(np.identity(2), rotation(np.pi/2))[:, [0, 2, 1, 3]][[0, 2, 1, 3]]\n        expected = R2 @ controlled_addition(s) @ R2.conj().T\n        assert S == pytest.approx(expected, abs=tol)\n\n        # test that S[x1, x2, p1, p2] -> [x1, x2, p1+sx2, p2+sx1]\n        x1 = 0.5432\n        x2 = -0.453\n        p1 = 0.154\n        p2 = -0.123\n        out = S @ np.array([x1, x2, p1, p2])*np.sqrt(2*hbar)\n        expected = np.array([x1, x2, p1+s*x2, p2+s*x1])*np.sqrt(2*hbar)\n        assert out == pytest.approx(expected, abs=tol)\n\n\nclass TestStates:\n    """"""State tests.""""""\n\n    def test_vacuum_state(self, tol):\n        """"""Test the vacuum state is correct.""""""\n        wires = 3\n        means, cov = vacuum_state(wires, hbar=hbar)\n        assert means == pytest.approx(np.zeros([2*wires]), abs=tol)\n        assert cov == pytest.approx(np.identity(2*wires)*hbar/2, abs=tol)\n\n    def test_coherent_state(self, tol):\n        """"""Test the coherent state is correct.""""""\n        a = 0.432-0.123j\n        means, cov = coherent_state(a, hbar=hbar)\n        assert means == pytest.approx(np.array([a.real, a.imag])*np.sqrt(2*hbar), abs=tol)\n        assert cov == pytest.approx(np.identity(2)*hbar/2, abs=tol)\n\n    def test_squeezed_state(self, tol):\n        """"""Test the squeezed state is correct.""""""\n        r = 0.432\n        phi = 0.123\n        means, cov = squeezed_state(r, phi, hbar=hbar)\n\n        # test vector of means is zero\n        assert means == pytest.approx(np.zeros([2]), abs=tol)\n\n        R = rotation(phi/2)\n        expected = R @ np.array([[np.exp(-2*r), 0],\n                                 [0, np.exp(2*r)]]) * hbar/2 @ R.T\n        # test covariance matrix is correct\n        assert cov == pytest.approx(expected, abs=tol)\n\n    def test_displaced_squeezed_state(self, tol):\n        """"""Test the displaced squeezed state is correct.""""""\n        alpha = 0.541+0.109j\n        a = abs(alpha)\n        phi_a = np.angle(alpha)\n        r = 0.432\n        phi_r = 0.123\n        means, cov = displaced_squeezed_state(a, phi_a, r, phi_r, hbar=hbar)\n\n        # test vector of means is correct\n        assert means == pytest.approx(np.array([alpha.real, alpha.imag])*np.sqrt(2*hbar), abs=tol)\n\n        R = rotation(phi_r/2)\n        expected = R @ np.array([[np.exp(-2*r), 0],\n                                 [0, np.exp(2*r)]]) * hbar/2 @ R.T\n        # test covariance matrix is correct\n        assert cov == pytest.approx(expected, abs=tol)\n\n    def thermal_state(self, tol):\n        """"""Test the thermal state is correct.""""""\n        nbar = 0.5342\n        means, cov = thermal_state(nbar, hbar=hbar)\n        assert means == pytest.approx(np.zeros([2]), abs=tol)\n        assert np.all((cov.diag*2/hbar-1)/2 == nbar)\n\n\nclass TestDefaultGaussianDevice:\n    """"""Test the default gaussian device. The test ensures that the device is properly\n    applying gaussian operations and calculating the correct observables.""""""\n\n    def test_operation_map(self, gaussian_dev):\n        """"""Test that default Gaussian device supports all PennyLane Gaussian CV gates.""""""\n\n        non_supported = {\'FockDensityMatrix\',\n                         \'FockStateVector\',\n                         \'FockState\',\n                         \'CrossKerr\',\n                         \'CatState\',\n                         \'CubicPhase\',\n                         \'Kerr\'}\n\n        assert set(qml.ops._cv__ops__) - non_supported == set(gaussian_dev._operation_map)\n\n    def test_observable_map(self, gaussian_dev):\n        """"""Test that default Gaussian device supports all PennyLane Gaussian continuous observables.""""""\n        assert set(qml.ops._cv__obs__)-{\'TensorN\'}|{\'Identity\'}-{\'Heterodyne\'} == set(gaussian_dev._observable_map)\n\n    def test_apply(self, gaussian_dev, tol):\n        """"""Test the application of gates to a state""""""\n\n        # loop through all supported operations\n        for gate_name, fn in gaussian_dev._operation_map.items():\n            #log.debug(""\\tTesting %s gate..."", gate_name)\n            gaussian_dev.reset()\n\n            # start in the displaced squeezed state\n            alpha = 0.542+0.123j\n            a = abs(alpha)\n            phi_a = np.angle(alpha)\n            r = 0.652\n            phi_r = -0.124\n\n            gaussian_dev.apply(\'DisplacedSqueezedState\', wires=[0], par=[a, phi_a, r, phi_r])\n            gaussian_dev.apply(\'DisplacedSqueezedState\', wires=[1], par=[a, phi_a, r, phi_r])\n\n            # get the equivalent pennylane operation class\n            op = qml.ops.__getattribute__(gate_name)\n            # the list of wires to apply the operation to\n            w = list(range(op.num_wires))\n\n            if op.par_domain == \'A\':\n                # the parameter is an array\n                if gate_name == \'GaussianState\':\n                    p = [np.array([0.432, 0.123, 0.342, 0.123]), np.diag([0.5234]*4)]\n                    w = list(range(2))\n                    expected_out = p\n                elif gate_name == \'Interferometer\':\n                    w = list(range(2))\n                    p = [U]\n                    S = fn(*p)\n                    expected_out = S @ gaussian_dev._state[0], S @ gaussian_dev._state[1] @ S.T\n            else:\n                # the parameter is a float\n                p = [0.432423, -0.12312, 0.324, 0.751][:op.num_params]\n\n                if gate_name == \'Displacement\':\n                    alpha = p[0]*np.exp(1j*p[1])\n                    state = gaussian_dev._state\n                    mu = state[0].copy()\n                    mu[w[0]] += alpha.real*np.sqrt(2*hbar)\n                    mu[w[0]+2] += alpha.imag*np.sqrt(2*hbar)\n                    expected_out = mu, state[1]\n                elif \'State\' in gate_name:\n                    mu, cov = fn(*p, hbar=hbar)\n                    expected_out = gaussian_dev._state\n                    expected_out[0][[w[0], w[0]+2]] = mu\n\n                    ind = np.concatenate([np.array([w[0]]), np.array([w[0]])+2])\n                    rows = ind.reshape(-1, 1)\n                    cols = ind.reshape(1, -1)\n                    expected_out[1][rows, cols] = cov\n                else:\n                    # if the default.gaussian is an operation accepting parameters,\n                    # initialise it using the parameters generated above.\n                    S = fn(*p)\n\n                    # calculate the expected output\n                    if op.num_wires == 1:\n                        # reorder from symmetric ordering to xp-ordering\n                        S = block_diag(S, np.identity(2))[:, [0, 2, 1, 3]][[0, 2, 1, 3]]\n\n                    expected_out = S @ gaussian_dev._state[0], S @ gaussian_dev._state[1] @ S.T\n\n            gaussian_dev.apply(gate_name, wires=w, par=p)\n\n            # verify the device is now in the expected state\n            assert gaussian_dev._state[0] == pytest.approx(expected_out[0], abs=tol)\n            assert gaussian_dev._state[1] == pytest.approx(expected_out[1], abs=tol)\n\n    def test_apply_errors(self, gaussian_dev):\n        """"""Test that apply fails for incorrect state preparation""""""\n\n        with pytest.raises(ValueError, match=\'incorrect size for the number of subsystems\'):\n            p = [thermal_state(0.5)]\n            gaussian_dev.apply(\'GaussianState\', wires=[0], par=[p])\n\n        with pytest.raises(ValueError, match=\'Incorrect number of subsystems\'):\n            p = U\n            gaussian_dev.apply(\'Interferometer\', wires=[0], par=[p])\n\n        with pytest.raises(ValueError, match=""Invalid target subsystems provided in \'wires\' argument""):\n            p = U2\n            #dev = DefaultGaussian(wires=4, shots=1000, hbar=hbar)\n            gaussian_dev.apply(\'Interferometer\', wires=[0, 1, 2], par=[p])\n\n    def test_expectation(self, tol):\n        """"""Test that expectation values are calculated correctly""""""\n\n        dev = qml.device(\'default.gaussian\', wires=1, hbar=hbar)\n\n        # test correct mean for <n> of a displaced thermal state\n        nbar = 0.5431\n        alpha = 0.324-0.59j\n        dev.apply(\'ThermalState\', wires=[0], par=[nbar])\n        dev.apply(\'Displacement\', wires=[0], par=[alpha, 0])\n        mean = dev.expval(\'NumberOperator\', [0], [])\n        assert mean == pytest.approx(np.abs(alpha)**2+nbar, abs=tol)\n\n        # test correct mean for Homodyne P measurement\n        alpha = 0.324-0.59j\n        dev.apply(\'CoherentState\', wires=[0], par=[alpha])\n        mean = dev.expval(\'P\', [0], [])\n        assert mean == pytest.approx(alpha.imag*np.sqrt(2*hbar), abs=tol)\n\n        # test correct mean for Homodyne measurement\n        mean = dev.expval(\'QuadOperator\', [0], [np.pi/2])\n        assert mean == pytest.approx(alpha.imag*np.sqrt(2*hbar), abs=tol)\n\n        # test correct mean for number state expectation |<n|alpha>|^2\n        # on a coherent state\n        for n in range(3):\n            mean = dev.expval(\'FockStateProjector\', [0], [np.array([n])])\n            expected = np.abs(np.exp(-np.abs(alpha)**2/2)*alpha**n/np.sqrt(fac(n)))**2\n            assert mean == pytest.approx(expected, abs=tol)\n\n        # test correct mean for number state expectation |<n|S(r)>|^2\n        # on a squeezed state\n        n = 1\n        r = 0.4523\n        dev.apply(\'SqueezedState\', wires=[0], par=[r, 0])\n        mean = dev.expval(\'FockStateProjector\', [0], [np.array([2*n])])\n        expected = np.abs(np.sqrt(fac(2*n))/(2**n*fac(n))*(-np.tanh(r))**n/np.sqrt(np.cosh(r)))**2\n        assert mean == pytest.approx(expected, abs=tol)\n\n    def test_variance_displaced_thermal_mean_photon(self, tol):\n        """"""test correct variance for <n> of a displaced thermal state""""""\n        dev = qml.device(\'default.gaussian\', wires=1, hbar=hbar)\n\n        nbar = 0.5431\n        alpha = 0.324-0.59j\n        dev.apply(\'ThermalState\', wires=[0], par=[nbar])\n        dev.apply(\'Displacement\', wires=[0], par=[alpha, 0])\n        var = dev.var(\'NumberOperator\', [0], [])\n        assert var == pytest.approx(nbar**2+nbar+np.abs(alpha)**2*(1+2*nbar), abs=tol)\n\n    def test_variance_coherent_homodyne(self, tol):\n        """"""test correct variance for Homodyne P measurement""""""\n        dev = qml.device(\'default.gaussian\', wires=1, hbar=hbar)\n\n        alpha = 0.324-0.59j\n        dev.apply(\'CoherentState\', wires=[0], par=[alpha])\n        var = dev.var(\'P\', [0], [])\n        assert var == pytest.approx(hbar/2, abs=tol)\n\n        # test correct mean and variance for Homodyne measurement\n        var = dev.var(\'QuadOperator\', [0], [np.pi/2])\n        assert var == pytest.approx(hbar/2, abs=tol)\n\n    def test_variance_coherent_numberstate(self, tol):\n        """"""test correct variance for number state expectation |<n|alpha>|^2\n        on a coherent state\n        """"""\n        dev = qml.device(\'default.gaussian\', wires=1, hbar=hbar)\n\n        alpha = 0.324-0.59j\n\n        dev.apply(\'CoherentState\', wires=[0], par=[alpha])\n\n        for n in range(3):\n            var = dev.var(\'FockStateProjector\', [0], [np.array([n])])\n            mean = np.abs(np.exp(-np.abs(alpha)**2/2)*alpha**n/np.sqrt(fac(n)))**2\n            assert var == pytest.approx(mean*(1-mean), abs=tol)\n\n    def test_variance_squeezed_numberstate(self, tol):\n        """"""test correct variance for number state expectation |<n|S(r)>|^2\n        on a squeezed state\n        """"""\n        dev = qml.device(\'default.gaussian\', wires=1, hbar=hbar)\n\n        n = 1\n        r = 0.4523\n        dev.apply(\'SqueezedState\', wires=[0], par=[r, 0])\n        var = dev.var(\'FockStateProjector\', [0], [np.array([2*n])])\n        mean = np.abs(np.sqrt(fac(2*n))/(2**n*fac(n))*(-np.tanh(r))**n/np.sqrt(np.cosh(r)))**2\n        assert var == pytest.approx(mean*(1-mean), abs=tol)\n\n    def test_reduced_state(self, gaussian_dev, tol):\n        """"""Test reduced state""""""\n\n        # Test error is raised if requesting a non-existant subsystem\n        with pytest.raises(ValueError, match=""specified wires cannot be larger than the number of subsystems""):\n            gaussian_dev.reduced_state([6, 4])\n\n        # Test requesting via an integer\n        res = gaussian_dev.reduced_state(0)\n        expected = gaussian_dev.reduced_state([0])\n        assert res[0] == pytest.approx(expected[0], abs=tol)\n        assert res[1] == pytest.approx(expected[1], abs=tol)\n\n        # Test requesting all wires returns the full state\n        res = gaussian_dev.reduced_state([0, 1])\n        expected = gaussian_dev._state\n        assert res[0] == pytest.approx(expected[0], abs=tol)\n        assert res[1] == pytest.approx(expected[1], abs=tol)\n\n\n\ndef input_logger(*args):\n    """"""Helper function for monkeypatch: logs its input.""""""\n    input_logger.args = args\n    return np.array([1, 2, 3, 4, 5])\n\n\nclass TestSample:\n    """"""Tests that sampling is correctly implemented.""""""\n\n    @pytest.mark.parametrize(""alpha"", [0.324-0.59j, 2.3+1.2j, 1.3j, -1.2])\n    def test_sampling_parameters_coherent(self, tol, gaussian_device_1_wire, alpha, monkeypatch):\n        """"""Tests that the np.random.normal is called with the correct parameters that reflect\n           the underlying distribution for a coherent state.""""""\n\n        mean = alpha.imag*np.sqrt(2*gaussian_device_1_wire.hbar)\n        std = gaussian_device_1_wire.hbar/2\n        gaussian_device_1_wire.apply(\'CoherentState\', wires=[0], par=[alpha])\n\n        with monkeypatch.context() as m:\n            m.setattr(numpy.random, \'normal\', input_logger)\n            sample = gaussian_device_1_wire.sample(\'P\', [0], [])\n            assert np.allclose(input_logger.args, [mean, std, gaussian_device_1_wire.shots], atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""alpha"", [0.324-0.59j, 2.3+1.2j, 1.3j, -1.2])\n    def test_sampling_parameters_coherent_quad_operator(self, tol, gaussian_device_1_wire, alpha, monkeypatch):\n        """"""Tests that the np.random.normal is called with the correct parameters that reflect\n           the underlying distribution for a coherent state when using QuadOperator.""""""\n\n        mean = alpha.imag*np.sqrt(2*gaussian_device_1_wire.hbar)\n        std = gaussian_device_1_wire.hbar/2\n        gaussian_device_1_wire.apply(\'CoherentState\', wires=[0], par=[alpha])\n\n        with monkeypatch.context() as m:\n            m.setattr(numpy.random, \'normal\', input_logger)\n            sample = gaussian_device_1_wire.sample(\'QuadOperator\', [0], [np.pi/2])\n            assert np.allclose(input_logger.args, [mean, std, gaussian_device_1_wire.shots], atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""r,phi"", [(1.0, 0.0)])\n    def test_sampling_parameters_squeezed(self, tol, gaussian_device_1_wire, r, phi, monkeypatch):\n        """"""Tests that the np.random.normal is called with the correct parameters that reflect\n           the underlying distribution for a squeezed state.""""""\n\n        mean = 0.0\n        std = np.sqrt(gaussian_device_1_wire.hbar*np.exp(2*r)/2)\n        gaussian_device_1_wire.apply(\'SqueezedState\', wires=[0], par=[r, phi])\n\n        with monkeypatch.context() as m:\n            m.setattr(numpy.random, \'normal\', input_logger)\n            sample = gaussian_device_1_wire.sample(\'P\', [0], [])\n            assert np.allclose(input_logger.args, [mean, std, gaussian_device_1_wire.shots], atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""observable,n_sample"", [(\'P\', 10), (\'P\', 25), (\'X\', 1), (\'X\', 16)])\n    def test_sample_shape_and_dtype(self, gaussian_device_2_wires, observable, n_sample):\n        """"""Test that the sample function outputs samples of the right size""""""\n\n        gaussian_device_2_wires.shots = n_sample\n        sample = gaussian_device_2_wires.sample(observable, [0], [])\n\n        assert np.array_equal(sample.shape, (n_sample,))\n        assert sample.dtype == np.dtype(""float"")\n\n    def test_sample_error_multi_wire(self, gaussian_device_2_wires):\n        """"""Test that the sample function raises an error if multiple wires are given""""""\n\n        with pytest.raises(ValueError, match=""Only one mode can be measured in homodyne""):\n            sample = gaussian_device_2_wires.sample(\'P\', [0, 1], [])\n\n    @pytest.mark.parametrize(""observable"", set(qml.ops.cv.obs) - set([\'P\', \'X\', \'QuadOperator\']))\n    def test_sample_error_unsupported_observable(self, gaussian_device_2_wires, observable):\n        """"""Test that the sample function raises an error if the given observable is not supported""""""\n\n        with pytest.raises(NotImplementedError, match=""default.gaussian does not support sampling""):\n            sample = gaussian_device_2_wires.sample(observable, [0], [])\n\n\nclass TestDefaultGaussianIntegration:\n    """"""Integration tests for default.gaussian. This test ensures it integrates\n    properly with the PennyLane interface, in particular QNode.""""""\n\n    def test_load_default_gaussian_device(self):\n        """"""Test that the default plugin loads correctly""""""\n\n        dev = qml.device(\'default.gaussian\', wires=2, hbar=2)\n        assert dev.num_wires == 2\n        assert dev.shots == 1000\n        assert dev.analytic == True\n        assert dev.hbar == 2\n        assert dev.short_name == \'default.gaussian\'\n\n    def test_args(self):\n        """"""Test that the plugin requires correct arguments""""""\n\n        with pytest.raises(TypeError, match=""missing 1 required positional argument: \'wires\'""):\n            qml.device(\'default.gaussian\')\n\n    def test_gaussian_circuit(self, tol):\n        """"""Test that the default gaussian plugin provides correct result for simple circuit""""""\n        dev = qml.device(\'default.gaussian\', wires=1)\n\n        p = 0.543\n\n        @qml.qnode(dev)\n        def circuit(x):\n            """"""Test quantum function""""""\n            qml.Displacement(x, 0, wires=0)\n            return qml.expval(qml.X(0))\n\n        assert circuit(p) == pytest.approx(p*np.sqrt(2*hbar), abs=tol)\n\n    def test_gaussian_identity(self, tol):\n        """"""Test that the default gaussian plugin provides correct result for the identity expectation""""""\n        dev = qml.device(\'default.gaussian\', wires=1)\n\n        p = 0.543\n\n        @qml.qnode(dev)\n        def circuit(x):\n            """"""Test quantum function""""""\n            qml.Displacement(x, 0, wires=0)\n            return qml.expval(qml.Identity(0))\n\n        assert circuit(p) == pytest.approx(1, abs=tol)\n\n    def test_nonzero_shots(self, tol):\n        """"""Test that the default gaussian plugin provides correct result for high shot number""""""\n\n        shots = 10**4\n        dev = qml.device(\'default.gaussian\', wires=1, shots=shots)\n\n        p = 0.543\n\n        @qml.qnode(dev)\n        def circuit(x):\n            """"""Test quantum function""""""\n            qml.Displacement(x, 0, wires=0)\n            return qml.expval(qml.X(0))\n\n        runs = []\n        for _ in range(100):\n            runs.append(circuit(p))\n\n        assert np.mean(runs) == pytest.approx(p*np.sqrt(2*hbar), abs=tol)\n\n    @pytest.mark.parametrize(""g, qop"", set(DefaultGaussian._operation_map.items()))\n    def test_supported_gates(self, g, qop, gaussian_dev):\n        """"""Test that all supported gates work correctly""""""\n        a = 0.312\n        dev = gaussian_dev\n        dev.reset()\n\n        assert dev.supports_operation(g)\n\n        op = getattr(qml.ops, g)\n        if op.num_wires <= 0:\n            wires = list(range(2))\n        else:\n            wires = list(range(op.num_wires))\n\n        @qml.qnode(gaussian_dev)\n        def circuit(*x):\n            """"""Reference quantum function""""""\n            qml.Displacement(a, 0, wires=[0])\n            op(*x, wires=wires)\n            return qml.expval(qml.X(0))\n\n        # compare to reference result\n        def reference(*x):\n            """"""reference circuit""""""\n            if g == \'GaussianState\':\n                return x[0][0]\n\n            if g == \'Displacement\':\n                alpha = x[0]*np.exp(1j*x[1])\n                return (alpha+a).real*np.sqrt(2*hbar)\n\n            if \'State\' in g:\n                mu, _ = qop(*x, hbar=hbar)\n                return mu[0]\n\n            S = qop(*x)\n\n            # calculate the expected output\n            if op.num_wires == 1:\n                S = block_diag(S, np.identity(2))[:, [0, 2, 1, 3]][[0, 2, 1, 3]]\n\n            return (S @ np.array([a.real, a.imag, 0, 0])*np.sqrt(2*hbar))[0]\n\n        if g == \'GaussianState\':\n            p = [np.array([0.432, 0.123, 0.342, 0.123]), np.diag([0.5234]*4)]\n        elif g == \'Interferometer\':\n            p = [U]\n        else:\n            p = [0.432423, -0.12312, 0.324, 0.763][:op.num_params]\n\n        assert circuit(*p) == reference(*p)\n'"
tests/plugins/test_default_qubit.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.plugin.DefaultQubit` device.\n""""""\nimport cmath\n# pylint: disable=protected-access,cell-var-from-loop\nimport math\n\nimport pytest\nimport pennylane as qml\nfrom pennylane import numpy as np, DeviceError\nfrom pennylane.operation import Operation\n\nU = np.array(\n    [\n        [0.83645892 - 0.40533293j, -0.20215326 + 0.30850569j],\n        [-0.23889780 - 0.28101519j, -0.88031770 - 0.29832709j],\n    ]\n)\n\n\nU2 = np.array(\n    [\n        [\n            -0.07843244 - 3.57825948e-01j,\n            0.71447295 - 5.38069384e-02j,\n            0.20949966 + 6.59100734e-05j,\n            -0.50297381 + 2.35731613e-01j,\n        ],\n        [\n            -0.26626692 + 4.53837083e-01j,\n            0.27771991 - 2.40717436e-01j,\n            0.41228017 - 1.30198687e-01j,\n            0.01384490 - 6.33200028e-01j,\n        ],\n        [\n            -0.69254712 - 2.56963068e-02j,\n            -0.15484858 + 6.57298384e-02j,\n            -0.53082141 + 7.18073414e-02j,\n            -0.41060450 - 1.89462315e-01j,\n        ],\n        [\n            -0.09686189 - 3.15085273e-01j,\n            -0.53241387 - 1.99491763e-01j,\n            0.56928622 + 3.97704398e-01j,\n            -0.28671074 - 6.01574497e-02j,\n        ],\n    ]\n)\n\n\nU_toffoli = np.diag([1 for i in range(8)])\nU_toffoli[6:8, 6:8] = np.array([[0, 1], [1, 0]])\n\nU_swap = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\n\nU_cswap = np.array([[1, 0, 0, 0, 0, 0, 0, 0],\n                    [0, 1, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 1, 0, 0, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0, 0, 0],\n                    [0, 0, 0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 1, 0],\n                    [0, 0, 0, 0, 0, 1, 0, 0],\n                    [0, 0, 0, 0, 0, 0, 0, 1]])\n\n\nH = np.array(\n    [[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]]\n)\n\n\nTHETA = np.linspace(0.11, 1, 3)\nPHI = np.linspace(0.32, 1, 3)\nVARPHI = np.linspace(0.02, 1, 3)\n\n\ndef prep_par(par, op):\n    ""Convert par into a list of parameters that op expects.""\n    if op.par_domain == ""A"":\n        return [np.diag([x, 1]) for x in par]\n    return par\n\n\ndef include_inverses_with_test_data(test_data):\n    return test_data + [(item[0] + "".inv"", item[1], item[2]) for item in test_data]\n\n\nclass TestApply:\n    """"""Tests that operations and inverses of certain operations are applied correctly or that the proper\n    errors are raised.\n    """"""\n\n    test_data_no_parameters = [\n        (qml.PauliX, [1, 0], np.array([0, 1])),\n        (qml.PauliX, [1/math.sqrt(2), 1/math.sqrt(2)], [1/math.sqrt(2), 1/math.sqrt(2)]),\n        (qml.PauliY, [1, 0], [0, 1j]),\n        (qml.PauliY, [1/math.sqrt(2), 1/math.sqrt(2)], [-1j/math.sqrt(2), 1j/math.sqrt(2)]),\n        (qml.PauliZ, [1, 0], [1, 0]),\n        (qml.PauliZ, [1/math.sqrt(2), 1/math.sqrt(2)], [1/math.sqrt(2), -1/math.sqrt(2)]),\n        (qml.S, [1, 0], [1, 0]),\n        (qml.S, [1/math.sqrt(2), 1/math.sqrt(2)], [1/math.sqrt(2), 1j/math.sqrt(2)]),\n        (qml.T, [1, 0], [1, 0]),\n        (qml.T, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / math.sqrt(2), np.exp(1j * np.pi / 4) / math.sqrt(2)]),\n        (qml.Hadamard, [1, 0], [1/math.sqrt(2), 1/math.sqrt(2)]),\n        (qml.Hadamard, [1/math.sqrt(2), -1/math.sqrt(2)], [0, 1]),\n    ]\n\n    test_data_no_parameters_inverses  = [\n        (qml.PauliX, [1, 0], np.array([0, 1])),\n        (qml.PauliX, [1/math.sqrt(2), 1/math.sqrt(2)], [1/math.sqrt(2), 1/math.sqrt(2)]),\n        (qml.PauliY, [1, 0], [0, 1j]),\n        (qml.PauliY, [1/math.sqrt(2), 1/math.sqrt(2)], [-1j/math.sqrt(2), 1j/math.sqrt(2)]),\n        (qml.PauliZ, [1, 0], [1, 0]),\n        (qml.PauliZ, [1/math.sqrt(2), 1/math.sqrt(2)], [1/math.sqrt(2), -1/math.sqrt(2)]),\n        (qml.S, [1, 0], [1, 0]),\n        (qml.S, [1/math.sqrt(2), 1/math.sqrt(2)], [1/math.sqrt(2), -1j/math.sqrt(2)]),\n        (qml.T, [1, 0], [1, 0]),\n        (qml.T, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / math.sqrt(2), np.exp(-1j * np.pi / 4) / math.sqrt(2)]),\n        (qml.Hadamard, [1, 0], [1/math.sqrt(2), 1/math.sqrt(2)]),\n        (qml.Hadamard, [1/math.sqrt(2), -1/math.sqrt(2)], [0, 1]),\n    ]\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", test_data_no_parameters)\n    def test_apply_operation_single_wire_no_parameters(self, qubit_device_1_wire, tol, operation, input, expected_output):\n        """"""Tests that applying an operation yields the expected output state for single wire\n           operations that have no parameters.""""""\n\n        qubit_device_1_wire._state = np.array(input)\n        qubit_device_1_wire.apply([operation(wires=[0])])\n\n        assert np.allclose(qubit_device_1_wire._state, np.array(expected_output), atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", test_data_no_parameters_inverses)\n    def test_apply_operation_single_wire_no_parameters_inverse(self, qubit_device_1_wire, tol, operation, input, expected_output):\n        """"""Tests that applying an operation yields the expected output state for single wire\n           operations that have no parameters.""""""\n\n        qubit_device_1_wire._state = np.array(input)\n        qubit_device_1_wire.apply([operation(wires=[0]).inv()])\n\n        assert np.allclose(qubit_device_1_wire._state, np.array(expected_output), atol=tol, rtol=0)\n\n    test_data_two_wires_no_parameters = [\n        (qml.CNOT, [1, 0, 0, 0], [1, 0, 0, 0]),\n        (qml.CNOT, [0, 0, 1, 0], [0, 0, 0, 1]),\n        (qml.CNOT, [1 / math.sqrt(2), 0, 0, 1 / math.sqrt(2)], [1 / math.sqrt(2), 0, 1 / math.sqrt(2), 0]),\n        (qml.SWAP, [1, 0, 0, 0], [1, 0, 0, 0]),\n        (qml.SWAP, [0, 0, 1, 0], [0, 1, 0, 0]),\n        (qml.SWAP, [1 / math.sqrt(2), 0, -1 / math.sqrt(2), 0], [1 / math.sqrt(2), -1 / math.sqrt(2), 0, 0]),\n        (qml.CZ, [1, 0, 0, 0], [1, 0, 0, 0]),\n        (qml.CZ, [0, 0, 0, 1], [0, 0, 0, -1]),\n        (qml.CZ, [1 / math.sqrt(2), 0, 0, -1 / math.sqrt(2)], [1 / math.sqrt(2), 0, 0, 1 / math.sqrt(2)]),\n    ]\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", test_data_two_wires_no_parameters)\n    def test_apply_operation_two_wires_no_parameters(self, qubit_device_2_wires, tol, operation, input, expected_output):\n        """"""Tests that applying an operation yields the expected output state for two wire\n           operations that have no parameters.""""""\n\n        qubit_device_2_wires._state = np.array(input).reshape((2, 2))\n        qubit_device_2_wires.apply([operation(wires=[0, 1])])\n\n        assert np.allclose(qubit_device_2_wires._state.flatten(), np.array(expected_output), atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", test_data_two_wires_no_parameters)\n    def test_apply_operation_two_wires_no_parameters_inverse(self, qubit_device_2_wires, tol, operation, input, expected_output):\n        """"""Tests that applying an operation yields the expected output state for two wire\n           operations that have no parameters.""""""\n\n        qubit_device_2_wires._state = np.array(input).reshape((2, 2))\n        qubit_device_2_wires.apply([operation(wires=[0, 1]).inv()])\n\n        assert np.allclose(qubit_device_2_wires._state.flatten(), np.array(expected_output), atol=tol, rtol=0)\n\n    test_data_three_wires_no_parameters = [\n        (qml.CSWAP, [1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0]),\n        (qml.CSWAP, [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0]),\n        (qml.CSWAP, [0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0]),\n    ]\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", test_data_three_wires_no_parameters)\n    def test_apply_operation_three_wires_no_parameters(self, qubit_device_3_wires, tol, operation, input, expected_output):\n        """"""Tests that applying an operation yields the expected output state for three wire\n           operations that have no parameters.""""""\n\n        qubit_device_3_wires._state = np.array(input).reshape((2, 2, 2))\n        qubit_device_3_wires.apply([operation(wires=[0, 1, 2])])\n\n        assert np.allclose(qubit_device_3_wires._state.flatten(), np.array(expected_output), atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", test_data_three_wires_no_parameters)\n    def test_apply_operation_three_wires_no_parameters_inverse(self, qubit_device_3_wires, tol, operation, input, expected_output):\n        """"""Tests that applying the inverse of an operation yields the expected output state for three wire\n           operations that have no parameters.""""""\n\n        qubit_device_3_wires._state = np.array(input).reshape((2, 2, 2))\n        qubit_device_3_wires.apply([operation(wires=[0, 1, 2]).inv()])\n\n        assert np.allclose(qubit_device_3_wires._state.flatten(), np.array(expected_output), atol=tol, rtol=0)\n\n\n    @pytest.mark.parametrize(""operation,expected_output,par"", [\n        (qml.BasisState, [0, 0, 1, 0], [1, 0]),\n        (qml.BasisState, [0, 0, 1, 0], [1, 0]),\n        (qml.BasisState, [0, 0, 0, 1], [1, 1]),\n        (qml.QubitStateVector, [0, 0, 1, 0], [0, 0, 1, 0]),\n        (qml.QubitStateVector, [0, 0, 1, 0], [0, 0, 1, 0]),\n        (qml.QubitStateVector, [0, 0, 0, 1], [0, 0, 0, 1]),\n        (qml.QubitStateVector, [1/math.sqrt(3), 0, 1/math.sqrt(3), 1/math.sqrt(3)], [1/math.sqrt(3), 0, 1/math.sqrt(3), 1/math.sqrt(3)]),\n        (qml.QubitStateVector, [1/math.sqrt(3), 0, -1/math.sqrt(3), 1/math.sqrt(3)], [1/math.sqrt(3), 0, -1/math.sqrt(3), 1/math.sqrt(3)]),\n    ])\n    def test_apply_operation_state_preparation(self, qubit_device_2_wires, tol, operation, expected_output, par):\n        """"""Tests that applying an operation yields the expected output state for single wire\n           operations that have no parameters.""""""\n\n        par = np.array(par)\n        qubit_device_2_wires.reset()\n        qubit_device_2_wires.apply([operation(par, wires=[0, 1])])\n\n        assert np.allclose(qubit_device_2_wires._state.flatten(), np.array(expected_output), atol=tol, rtol=0)\n\n    test_data_single_wire_with_parameters = [\n        (qml.PhaseShift, [1, 0], [1, 0], [math.pi / 2]),\n        (qml.PhaseShift, [0, 1], [0, 1j], [math.pi / 2]),\n        (qml.PhaseShift, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / math.sqrt(2), 1 / 2 + 1j / 2], [math.pi / 4]),\n        (qml.RX, [1, 0], [1 / math.sqrt(2), -1j * 1 / math.sqrt(2)], [math.pi / 2]),\n        (qml.RX, [1, 0], [0, -1j], [math.pi]),\n        (qml.RX, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / 2 - 1j / 2, 1 / 2 - 1j / 2], [math.pi / 2]),\n        (qml.RY, [1, 0], [1 / math.sqrt(2), 1 / math.sqrt(2)], [math.pi / 2]),\n        (qml.RY, [1, 0], [0, 1], [math.pi]),\n        (qml.RY, [1 / math.sqrt(2), 1 / math.sqrt(2)], [0, 1], [math.pi / 2]),\n        (qml.RZ, [1, 0], [1 / math.sqrt(2) - 1j / math.sqrt(2), 0], [math.pi / 2]),\n        (qml.RZ, [0, 1], [0, 1j], [math.pi]),\n        (qml.RZ, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / 2 - 1j / 2, 1 / 2 + 1j / 2], [math.pi / 2]),\n        (qml.MultiRZ, [1, 0], [1 / math.sqrt(2) - 1j / math.sqrt(2), 0], [math.pi / 2]),\n        (qml.MultiRZ, [0, 1], [0, 1j], [math.pi]),\n        (qml.MultiRZ, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / 2 - 1j / 2, 1 / 2 + 1j / 2], [math.pi / 2]),\n        (qml.Rot, [1, 0], [1 / math.sqrt(2) - 1j / math.sqrt(2), 0], [math.pi / 2, 0, 0]),\n        (qml.Rot, [1, 0], [1 / math.sqrt(2), 1 / math.sqrt(2)], [0, math.pi / 2, 0]),\n        (qml.Rot, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / 2 - 1j / 2, 1 / 2 + 1j / 2], [0, 0, math.pi / 2]),\n        (qml.Rot, [1, 0], [-1j / math.sqrt(2), -1 / math.sqrt(2)], [math.pi / 2, -math.pi / 2, math.pi / 2]),\n        (qml.Rot, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / 2 + 1j / 2, -1 / 2 + 1j / 2],\n         [-math.pi / 2, math.pi, math.pi]),\n        (qml.QubitUnitary, [1, 0], [1j / math.sqrt(2), 1j / math.sqrt(2)],\n         [np.array([[1j / math.sqrt(2), 1j / math.sqrt(2)], [1j / math.sqrt(2), -1j / math.sqrt(2)]])]),\n        (qml.QubitUnitary, [0, 1], [1j / math.sqrt(2), -1j / math.sqrt(2)],\n         [np.array([[1j / math.sqrt(2), 1j / math.sqrt(2)], [1j / math.sqrt(2), -1j / math.sqrt(2)]])]),\n        (qml.QubitUnitary, [1 / math.sqrt(2), -1 / math.sqrt(2)], [0, 1j],\n         [np.array([[1j / math.sqrt(2), 1j / math.sqrt(2)], [1j / math.sqrt(2), -1j / math.sqrt(2)]])]),\n        (qml.DiagonalQubitUnitary, [1, 0], [-1, 0], [np.array([-1, 1])]),\n        (qml.DiagonalQubitUnitary, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / math.sqrt(2), 1j / math.sqrt(2)], [np.array([1, 1j])]),\n        (qml.DiagonalQubitUnitary, [1 / 2, math.sqrt(3) / 4], [cmath.exp(1j * 0.4) / 2, cmath.exp(1j * -0.4) * math.sqrt(3) / 4], [np.array([cmath.exp(1j * 0.4), cmath.exp(1j * -0.4)])]),\n    ]\n\n    test_data_single_wire_with_parameters_inverses = [\n        (qml.PhaseShift, [1, 0], [1, 0], [math.pi / 2]),\n        (qml.PhaseShift, [0, 1], [0, -1j], [math.pi / 2]),\n        (qml.PhaseShift, [1 / math.sqrt(2), 1 / math.sqrt(2)],\n         [1 / math.sqrt(2), 1 / 2 - 1j / 2], [math.pi / 4]),\n        (qml.RX, [1, 0], [1 / math.sqrt(2), 1j * 1 / math.sqrt(2)], [math.pi / 2]),\n        (qml.RX, [1, 0], [0, 1j], [math.pi]),\n        (qml.RX, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / 2 + 1j / 2, 1 / 2 + 1j / 2], [math.pi / 2]),\n        (qml.RY, [1, 0], [1 / math.sqrt(2), -1 / math.sqrt(2)], [math.pi / 2]),\n        (qml.RY, [1, 0], [0, -1], [math.pi]),\n        (qml.RY, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1, 0], [math.pi / 2]),\n        (qml.RZ, [1, 0], [1 / math.sqrt(2) + 1j / math.sqrt(2), 0], [math.pi / 2]),\n        (qml.RZ, [0, 1], [0, -1j], [math.pi]),\n        (qml.RZ, [1 / math.sqrt(2), 1 / math.sqrt(2)],\n         [1 / 2 + 1/2*1j, 1 / 2 - 1/2*1j], [math.pi / 2]),\n        (qml.MultiRZ, [1, 0], [1 / math.sqrt(2) + 1j / math.sqrt(2), 0], [math.pi / 2]),\n        (qml.MultiRZ, [0, 1], [0, -1j], [math.pi]),\n        (qml.MultiRZ, [1 / math.sqrt(2), 1 / math.sqrt(2)],\n         [1 / 2 + 1/2*1j, 1 / 2 - 1/2*1j], [math.pi / 2]),\n        (qml.DiagonalQubitUnitary, [1, 0], [-1, 0], [np.array([-1, 1])]),\n        (qml.DiagonalQubitUnitary, [1 / math.sqrt(2), 1 / math.sqrt(2)], [1 / math.sqrt(2), -1j / math.sqrt(2)], [np.array([1, 1j])]),\n        (qml.DiagonalQubitUnitary, [1 / 2, math.sqrt(3) / 4], [cmath.exp(-1j * 0.4) / 2, cmath.exp(1j * 0.4) * math.sqrt(3) / 4], [np.array([cmath.exp(1j * 0.4), cmath.exp(1j * -0.4)])]),\n    ]\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", test_data_single_wire_with_parameters)\n    def test_apply_operation_single_wire_with_parameters(self, qubit_device_1_wire, tol, operation, input, expected_output, par):\n        """"""Tests that applying an operation yields the expected output state for single wire\n           operations that have parameters.""""""\n\n        #parameter = par[0]\n        qubit_device_1_wire._state = np.array(input)\n\n        qubit_device_1_wire.apply([operation(*par, wires=[0])])\n\n        assert np.allclose(qubit_device_1_wire._state, np.array(expected_output), atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", test_data_single_wire_with_parameters_inverses)\n    def test_apply_operation_single_wire_with_parameters_inverse(self, qubit_device_1_wire, tol, operation, input, expected_output, par):\n        """"""Tests that applying the inverse of an operation yields the expected output state for single wire\n           operations that have parameters.""""""\n\n        qubit_device_1_wire._state = np.array(input)\n        qubit_device_1_wire.apply([operation(*par, wires=[0]).inv()])\n\n        assert np.allclose(qubit_device_1_wire._state, np.array(expected_output), atol=tol, rtol=0)\n\n    test_data_two_wires_with_parameters = [\n        (qml.CRX, [0, 1, 0, 0], [0, 1, 0, 0], [math.pi / 2]),\n        (qml.CRX, [0, 0, 0, 1], [0, 0, -1j, 0], [math.pi]),\n        (qml.CRX, [0, 1 / math.sqrt(2), 1 / math.sqrt(2), 0], [0, 1 / math.sqrt(2), 1 / 2, -1j / 2], [math.pi / 2]),\n        (qml.CRY, [0, 0, 0, 1], [0, 0, -1 / math.sqrt(2), 1 / math.sqrt(2)], [math.pi / 2]),\n        (qml.CRY, [0, 0, 0, 1], [0, 0, -1, 0], [math.pi]),\n        (qml.CRY, [1 / math.sqrt(2), 1 / math.sqrt(2), 0, 0], [1 / math.sqrt(2), 1 / math.sqrt(2), 0, 0], [math.pi / 2]),\n        (qml.CRZ, [0, 0, 0, 1], [0, 0, 0, 1 / math.sqrt(2) + 1j / math.sqrt(2)], [math.pi / 2]),\n        (qml.CRZ, [0, 0, 0, 1], [0, 0, 0, 1j], [math.pi]),\n        (qml.CRZ, [1 / math.sqrt(2), 1 / math.sqrt(2), 0, 0], [1 / math.sqrt(2), 1 / math.sqrt(2), 0, 0], [math.pi / 2]),\n        (qml.MultiRZ, [0, 0, 0, 1], [0, 0, 0, 1 / math.sqrt(2) - 1j / math.sqrt(2)], [math.pi / 2]),\n        (qml.MultiRZ, [0, 0, 1, 0], [0, 0, 1j, 0], [math.pi]),\n        (qml.MultiRZ, [1 / math.sqrt(2), 1 / math.sqrt(2), 0, 0], [1 / 2 - 1j / 2, 1 / 2 + 1j / 2, 0, 0], [math.pi / 2]),\n        (qml.CRot, [0, 0, 0, 1], [0, 0, 0, 1 / math.sqrt(2) + 1j / math.sqrt(2)], [math.pi / 2, 0, 0]),\n        (qml.CRot, [0, 0, 0, 1], [0, 0, -1 / math.sqrt(2), 1 / math.sqrt(2)], [0, math.pi / 2, 0]),\n        (qml.CRot, [0, 0, 1 / math.sqrt(2), 1 / math.sqrt(2)], [0, 0, 1 / 2 - 1j / 2, 1 / 2 + 1j / 2],\n         [0, 0, math.pi / 2]),\n        (qml.CRot, [0, 0, 0, 1], [0, 0, 1 / math.sqrt(2), 1j / math.sqrt(2)], [math.pi / 2, -math.pi / 2, math.pi / 2]),\n        (qml.CRot, [0, 1 / math.sqrt(2), 1 / math.sqrt(2), 0], [0, 1 / math.sqrt(2), 0, -1 / 2 + 1j / 2],\n         [-math.pi / 2, math.pi, math.pi]),\n        (qml.QubitUnitary, [1, 0, 0, 0], [1, 0, 0, 0], [np.array(\n            [[1, 0, 0, 0], [0, 1 / math.sqrt(2), 1 / math.sqrt(2), 0], [0, 1 / math.sqrt(2), -1 / math.sqrt(2), 0],\n             [0, 0, 0, 1]])]),\n        (qml.QubitUnitary, [0, 1, 0, 0], [0, 1 / math.sqrt(2), 1 / math.sqrt(2), 0], [np.array(\n            [[1, 0, 0, 0], [0, 1 / math.sqrt(2), 1 / math.sqrt(2), 0], [0, 1 / math.sqrt(2), -1 / math.sqrt(2), 0],\n             [0, 0, 0, 1]])]),\n        (qml.QubitUnitary, [1 / 2, 1 / 2, -1 / 2, 1 / 2], [1 / 2, 0, 1 / math.sqrt(2), 1 / 2], [np.array(\n            [[1, 0, 0, 0], [0, 1 / math.sqrt(2), 1 / math.sqrt(2), 0], [0, 1 / math.sqrt(2), -1 / math.sqrt(2), 0],\n             [0, 0, 0, 1]])]),\n        (qml.DiagonalQubitUnitary, [1, 0, 0, 0], [-1, 0, 0, 0], [np.array([-1, 1, 1, -1])]),\n        (qml.DiagonalQubitUnitary, [1/math.sqrt(2), 0, 0, 1/math.sqrt(2)], [1/math.sqrt(2), 0, 0, -1/math.sqrt(2)], [np.array([1, 1, 1, -1])]),\n        (qml.DiagonalQubitUnitary, [0, 0, 1, 0], [0, 0, 1j, 0], [np.array([-1, 1j, 1j, -1])]),\n    ]\n\n    test_data_two_wires_with_parameters_inverses = [\n        (qml.CRX, [0, 1, 0, 0], [0, 1, 0, 0], [math.pi / 2]),\n        (qml.CRX, [0, 0, 0, 1], [0, 0, 1j, 0], [math.pi]),\n        (qml.CRX, [0, 1 / math.sqrt(2), 1 / math.sqrt(2), 0],\n         [0, 1 / math.sqrt(2), 1 / 2, 1j / 2], [math.pi / 2]),\n        (qml.MultiRZ, [0, 0, 0, 1], [0, 0, 0, 1 / math.sqrt(2) + 1j / math.sqrt(2)], [math.pi / 2]),\n        (qml.MultiRZ, [0, 0, 1, 0], [0, 0, -1j, 0], [math.pi]),\n        (qml.MultiRZ, [1 / math.sqrt(2), 1 / math.sqrt(2), 0, 0], [1 / 2 + 1j / 2, 1 / 2 - 1j / 2, 0, 0], [math.pi / 2]),\n        (qml.DiagonalQubitUnitary, [1, 0, 0, 0], [-1, 0, 0, 0], [np.array([-1, 1, 1, -1])]),\n        (qml.DiagonalQubitUnitary, [1/math.sqrt(2), 0, 0, 1/math.sqrt(2)], [1/math.sqrt(2), 0, 0, -1/math.sqrt(2)], [np.array([1, 1, 1, -1])]),\n        (qml.DiagonalQubitUnitary, [0, 0, 1, 0], [0, 0, -1j, 0], [np.array([-1, 1j, 1j, -1])]),\n    ]\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", test_data_two_wires_with_parameters)\n    def test_apply_operation_two_wires_with_parameters(self, qubit_device_2_wires, tol, operation, input, expected_output, par):\n        """"""Tests that applying an operation yields the expected output state for two wire\n           operations that have parameters.""""""\n\n        qubit_device_2_wires._state = np.array(input).reshape((2, 2))\n        qubit_device_2_wires.apply([operation(*par, wires=[0, 1])])\n\n        assert np.allclose(qubit_device_2_wires._state.flatten(), np.array(expected_output), atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", test_data_two_wires_with_parameters_inverses)\n    def test_apply_operation_two_wires_with_parameters_inverse(self, qubit_device_2_wires, tol, operation, input, expected_output, par):\n        """"""Tests that applying the inverse of an operation yields the expected output state for two wire\n           operations that have parameters.""""""\n\n        qubit_device_2_wires._state = np.array(input).reshape((2, 2))\n        qubit_device_2_wires.apply([operation(*par, wires=[0, 1]).inv()])\n\n        assert np.allclose(qubit_device_2_wires._state.flatten(), np.array(expected_output), atol=tol, rtol=0)\n\n    def test_apply_errors_qubit_state_vector(self, qubit_device_2_wires):\n        """"""Test that apply fails for incorrect state preparation, and > 2 qubit gates""""""\n        with pytest.raises(\n            ValueError,\n            match=""Sum of amplitudes-squared does not equal one.""\n        ):\n            qubit_device_2_wires.apply([qml.QubitStateVector(np.array([1, -1]), wires=[0])])\n\n        with pytest.raises(\n            ValueError,\n            match=r""State vector must be of length 2\\*\\*wires.""\n        ):\n            p = np.array([1, 0, 1, 1, 0]) / np.sqrt(3)\n            qubit_device_2_wires.apply([qml.QubitStateVector(p, wires=[0, 1])])\n\n        with pytest.raises(\n            DeviceError,\n            match=""Operation QubitStateVector cannot be used after other Operations have already been applied ""\n                                  ""on a default.qubit device.""\n        ):\n            qubit_device_2_wires.reset()\n            qubit_device_2_wires.apply([\n                qml.RZ(0.5, wires=[0]),\n                qml.QubitStateVector(np.array([0, 1, 0, 0]), wires=[0, 1])\n            ])\n\n    def test_apply_errors_basis_state(self, qubit_device_2_wires):\n        with pytest.raises(\n            ValueError,\n            match=""BasisState parameter must consist of 0 or 1 integers.""\n        ):\n            qubit_device_2_wires.apply([qml.BasisState(np.array([-0.2, 4.2]), wires=[0, 1])])\n\n        with pytest.raises(\n            ValueError,\n            match=""BasisState parameter and wires must be of equal length.""\n        ):\n            qubit_device_2_wires.apply([qml.BasisState(np.array([0, 1]), wires=[0])])\n\n        with pytest.raises(\n            DeviceError,\n            match=""Operation BasisState cannot be used after other Operations have already been applied ""\n                                  ""on a default.qubit device.""\n        ):\n            qubit_device_2_wires.reset()\n            qubit_device_2_wires.apply([\n                qml.RZ(0.5, wires=[0]),\n                qml.BasisState(np.array([1, 1]), wires=[0, 1])\n            ])\n\nclass TestExpval:\n    """"""Tests that expectation values are properly calculated or that the proper errors are raised.""""""\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", [\n        (qml.PauliX, [1/math.sqrt(2), 1/math.sqrt(2)], 1),\n        (qml.PauliX, [1/math.sqrt(2), -1/math.sqrt(2)], -1),\n        (qml.PauliX, [1, 0], 0),\n        (qml.PauliY, [1/math.sqrt(2), 1j/math.sqrt(2)], 1),\n        (qml.PauliY, [1/math.sqrt(2), -1j/math.sqrt(2)], -1),\n        (qml.PauliY, [1, 0], 0),\n        (qml.PauliZ, [1, 0], 1),\n        (qml.PauliZ, [0, 1], -1),\n        (qml.PauliZ, [1/math.sqrt(2), 1/math.sqrt(2)], 0),\n        (qml.Hadamard, [1, 0], 1/math.sqrt(2)),\n        (qml.Hadamard, [0, 1], -1/math.sqrt(2)),\n        (qml.Hadamard, [1/math.sqrt(2), 1/math.sqrt(2)], 1/math.sqrt(2)),\n        (qml.Identity, [1, 0], 1),\n        (qml.Identity, [0, 1], 1),\n        (qml.Identity, [1/math.sqrt(2), -1/math.sqrt(2)], 1),\n    ])\n    def test_expval_single_wire_no_parameters(self, qubit_device_1_wire, tol, operation, input, expected_output):\n        """"""Tests that expectation values are properly calculated for single-wire observables without parameters.""""""\n\n        obs = operation(wires=[0])\n\n        qubit_device_1_wire.reset()\n        qubit_device_1_wire.apply(\n            [qml.QubitStateVector(np.array(input), wires=[0])],\n            obs.diagonalizing_gates()\n        )\n        res = qubit_device_1_wire.expval(obs)\n\n        assert np.isclose(res, expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", [\n        (qml.Hermitian, [1, 0], 1, [[1, 1j], [-1j, 1]]),\n        (qml.Hermitian, [0, 1], 1, [[1, 1j], [-1j, 1]]),\n        (qml.Hermitian, [1/math.sqrt(2), -1/math.sqrt(2)], 1, [[1, 1j], [-1j, 1]]),\n    ])\n    def test_expval_single_wire_with_parameters(self, qubit_device_1_wire, tol, operation, input, expected_output, par):\n        """"""Tests that expectation values are properly calculated for single-wire observables with parameters.""""""\n\n        obs = operation(np.array(par), wires=[0])\n\n        qubit_device_1_wire.reset()\n        qubit_device_1_wire.apply(\n            [qml.QubitStateVector(np.array(input), wires=[0])],\n            obs.diagonalizing_gates()\n        )\n        res = qubit_device_1_wire.expval(obs)\n\n        assert np.isclose(res, expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", [\n        (qml.Hermitian, [1/math.sqrt(3), 0, 1/math.sqrt(3), 1/math.sqrt(3)], 5/3, [[1, 1j, 0, 1], [-1j, 1, 0, 0], [0, 0, 1, -1j], [1, 0, 1j, 1]]),\n        (qml.Hermitian, [0, 0, 0, 1], 0, [[0, 1j, 0, 0], [-1j, 0, 0, 0], [0, 0, 0, -1j], [0, 0, 1j, 0]]),\n        (qml.Hermitian, [1/math.sqrt(2), 0, -1/math.sqrt(2), 0], 1, [[1, 1j, 0, 0], [-1j, 1, 0, 0], [0, 0, 1, -1j], [0, 0, 1j, 1]]),\n        (qml.Hermitian, [1/math.sqrt(3), -1/math.sqrt(3), 1/math.sqrt(6), 1/math.sqrt(6)], 1, [[1, 1j, 0, .5j], [-1j, 1, 0, 0], [0, 0, 1, -1j], [-.5j, 0, 1j, 1]]),\n        (qml.Hermitian, [1/math.sqrt(2), 0, 0, 1/math.sqrt(2)], 1, [[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]]),\n        (qml.Hermitian, [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], -1, [[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]]),\n    ])\n    def test_expval_two_wires_with_parameters(self, qubit_device_2_wires, tol, operation, input, expected_output, par):\n        """"""Tests that expectation values are properly calculated for two-wire observables with parameters.""""""\n\n        obs = operation(np.array(par), wires=[0, 1])\n\n        qubit_device_2_wires.reset()\n        qubit_device_2_wires.apply(\n            [qml.QubitStateVector(np.array(input), wires=[0, 1])],\n            obs.diagonalizing_gates()\n        )\n        res = qubit_device_2_wires.expval(obs)\n\n        assert np.isclose(res, expected_output, atol=tol, rtol=0)\n\n    def test_expval_estimate(self):\n        """"""Test that the expectation value is not analytically calculated""""""\n\n        dev = qml.device(""default.qubit"", wires=1, shots=3, analytic=False)\n\n        @qml.qnode(dev)\n        def circuit():\n            return qml.expval(qml.PauliX(0))\n\n        expval = circuit()\n\n        # With 3 samples we are guaranteed to see a difference between\n        # an estimated variance an an analytically calculated one\n        assert expval != 0.0\n\nclass TestVar:\n    """"""Tests that variances are properly calculated.""""""\n\n    @pytest.mark.parametrize(""operation,input,expected_output"", [\n        (qml.PauliX, [1/math.sqrt(2), 1/math.sqrt(2)], 0),\n        (qml.PauliX, [1/math.sqrt(2), -1/math.sqrt(2)], 0),\n        (qml.PauliX, [1, 0], 1),\n        (qml.PauliY, [1/math.sqrt(2), 1j/math.sqrt(2)], 0),\n        (qml.PauliY, [1/math.sqrt(2), -1j/math.sqrt(2)], 0),\n        (qml.PauliY, [1, 0], 1),\n        (qml.PauliZ, [1, 0], 0),\n        (qml.PauliZ, [0, 1], 0),\n        (qml.PauliZ, [1/math.sqrt(2), 1/math.sqrt(2)], 1),\n        (qml.Hadamard, [1, 0], 1/2),\n        (qml.Hadamard, [0, 1], 1/2),\n        (qml.Hadamard, [1/math.sqrt(2), 1/math.sqrt(2)], 1/2),\n        (qml.Identity, [1, 0], 0),\n        (qml.Identity, [0, 1], 0),\n        (qml.Identity, [1/math.sqrt(2), -1/math.sqrt(2)], 0),\n\n    ])\n    def test_var_single_wire_no_parameters(self, qubit_device_1_wire, tol, operation, input, expected_output):\n        """"""Tests that variances are properly calculated for single-wire observables without parameters.""""""\n\n        obs = operation(wires=[0])\n\n        qubit_device_1_wire.reset()\n        qubit_device_1_wire.apply(\n            [qml.QubitStateVector(np.array(input), wires=[0])],\n            obs.diagonalizing_gates()\n        )\n        res = qubit_device_1_wire.var(obs)\n\n        assert np.isclose(res, expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", [\n        (qml.Hermitian, [1, 0], 1, [[1, 1j], [-1j, 1]]),\n        (qml.Hermitian, [0, 1], 1, [[1, 1j], [-1j, 1]]),\n        (qml.Hermitian, [1/math.sqrt(2), -1/math.sqrt(2)], 1, [[1, 1j], [-1j, 1]]),\n    ])\n    def test_var_single_wire_with_parameters(self, qubit_device_1_wire, tol, operation, input, expected_output, par):\n        """"""Tests that variances are properly calculated for single-wire observables with parameters.""""""\n\n        obs = operation(np.array(par), wires=[0])\n\n        qubit_device_1_wire.reset()\n        qubit_device_1_wire.apply(\n            [qml.QubitStateVector(np.array(input), wires=[0])],\n            obs.diagonalizing_gates()\n        )\n        res = qubit_device_1_wire.var(obs)\n\n        assert np.isclose(res, expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""operation,input,expected_output,par"", [\n        (qml.Hermitian, [1/math.sqrt(3), 0, 1/math.sqrt(3), 1/math.sqrt(3)], 11/9, [[1, 1j, 0, 1], [-1j, 1, 0, 0], [0, 0, 1, -1j], [1, 0, 1j, 1]]),\n        (qml.Hermitian, [0, 0, 0, 1], 1, [[0, 1j, 0, 0], [-1j, 0, 0, 0], [0, 0, 0, -1j], [0, 0, 1j, 0]]),\n        (qml.Hermitian, [1/math.sqrt(2), 0, -1/math.sqrt(2), 0], 1, [[1, 1j, 0, 0], [-1j, 1, 0, 0], [0, 0, 1, -1j], [0, 0, 1j, 1]]),\n        (qml.Hermitian, [1/math.sqrt(2), 0, 0, 1/math.sqrt(2)], 0, [[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]]),\n        (qml.Hermitian, [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], 0, [[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]]),\n    ])\n    def test_var_two_wires_with_parameters(self, qubit_device_2_wires, tol, operation, input, expected_output, par):\n        """"""Tests that variances are properly calculated for two-wire observables with parameters.""""""\n\n        obs = operation(np.array(par), wires=[0, 1])\n\n        qubit_device_2_wires.reset()\n        qubit_device_2_wires.apply(\n            [qml.QubitStateVector(np.array(input), wires=[0, 1])],\n            obs.diagonalizing_gates()\n        )\n        res = qubit_device_2_wires.var(obs)\n\n        assert np.isclose(res, expected_output, atol=tol, rtol=0)\n\n    def test_var_estimate(self):\n        """"""Test that the variance is not analytically calculated""""""\n\n        dev = qml.device(""default.qubit"", wires=1, shots=3, analytic=False)\n\n        @qml.qnode(dev)\n        def circuit():\n            return qml.var(qml.PauliX(0))\n\n        var = circuit()\n\n        # With 3 samples we are guaranteed to see a difference between\n        # an estimated variance and an analytically calculated one\n        assert var != 1.0\n\nclass TestSample:\n    """"""Tests that samples are properly calculated.""""""\n\n    def test_sample_dimensions(self, qubit_device_2_wires):\n        """"""Tests if the samples returned by the sample function have\n        the correct dimensions\n        """"""\n\n        # Explicitly resetting is necessary as the internal\n        # state is set to None in __init__ and only properly\n        # initialized during reset\n        qubit_device_2_wires.reset()\n\n        qubit_device_2_wires.apply(\n            [qml.RX(1.5708, wires=[0]), qml.RX(1.5708, wires=[1])]\n        )\n\n        qubit_device_2_wires.shots = 10\n        qubit_device_2_wires._wires_measured = {0}\n        qubit_device_2_wires._samples = qubit_device_2_wires.generate_samples()\n        s1 = qubit_device_2_wires.sample(qml.PauliZ(wires=[0]))\n        assert np.array_equal(s1.shape, (10,))\n\n        qubit_device_2_wires.reset()\n        qubit_device_2_wires.shots = 12\n        qubit_device_2_wires._wires_measured = {1}\n        qubit_device_2_wires._samples = qubit_device_2_wires.generate_samples()\n        s2 = qubit_device_2_wires.sample(qml.PauliZ(wires=[1]))\n        assert np.array_equal(s2.shape, (12,))\n\n        qubit_device_2_wires.reset()\n        qubit_device_2_wires.shots = 17\n        qubit_device_2_wires._wires_measured = {0, 1}\n        qubit_device_2_wires._samples = qubit_device_2_wires.generate_samples()\n        s3 = qubit_device_2_wires.sample(qml.PauliX(0) @ qml.PauliZ(1))\n        assert np.array_equal(s3.shape, (17,))\n\n    def test_sample_values(self, qubit_device_2_wires, tol):\n        """"""Tests if the samples returned by sample have\n        the correct values\n        """"""\n\n        # Explicitly resetting is necessary as the internal\n        # state is set to None in __init__ and only properly\n        # initialized during reset\n        qubit_device_2_wires.reset()\n\n        qubit_device_2_wires.apply([qml.RX(1.5708, wires=[0])])\n        qubit_device_2_wires._wires_measured = {0}\n        qubit_device_2_wires._samples = qubit_device_2_wires.generate_samples()\n\n        s1 = qubit_device_2_wires.sample(qml.PauliZ(0))\n\n        # s1 should only contain 1 and -1, which is guaranteed if\n        # they square to 1\n        assert np.allclose(s1**2, 1, atol=tol, rtol=0)\n\nclass TestDefaultQubitIntegration:\n    """"""Integration tests for default.qubit. This test ensures it integrates\n    properly with the PennyLane interface, in particular QNode.""""""\n\n    def test_load_default_qubit_device(self):\n        """"""Test that the default plugin loads correctly""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n        assert dev.num_wires == 2\n        assert dev.shots == 1000\n        assert dev.analytic\n        assert dev.short_name == ""default.qubit""\n\n    def test_args(self):\n        """"""Test that the plugin requires correct arguments""""""\n\n        with pytest.raises(\n            TypeError, match=""missing 1 required positional argument: \'wires\'""\n        ):\n            qml.device(""default.qubit"")\n\n    def test_qubit_circuit(self, qubit_device_1_wire, tol):\n        """"""Test that the default qubit plugin provides correct result for a simple circuit""""""\n\n        p = 0.543\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliY(0))\n\n        expected = -np.sin(p)\n\n        assert np.isclose(circuit(p), expected, atol=tol, rtol=0)\n\n    def test_qubit_identity(self, qubit_device_1_wire, tol):\n        """"""Test that the default qubit plugin provides correct result for the Identity expectation""""""\n\n        p = 0.543\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit(x):\n            """"""Test quantum function""""""\n            qml.RX(x, wires=0)\n            return qml.expval(qml.Identity(0))\n\n        assert np.isclose(circuit(p), 1, atol=tol, rtol=0)\n\n    def test_nonzero_shots(self, tol):\n        """"""Test that the default qubit plugin provides correct result for high shot number""""""\n\n        shots = 10 ** 5\n        dev = qml.device(""default.qubit"", wires=1)\n\n        p = 0.543\n\n        @qml.qnode(dev)\n        def circuit(x):\n            """"""Test quantum function""""""\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliY(0))\n\n        runs = []\n        for _ in range(100):\n            runs.append(circuit(p))\n\n        assert np.isclose(np.mean(runs), -np.sin(p), atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""PauliX"", 1),\n        (""PauliY"", 1),\n        (""S"", -1),\n    ])\n    def test_inverse_circuit(self, qubit_device_1_wire, tol, name, expected_output):\n        """"""Tests the inverse of supported gates that act on a single wire and are not parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            qml.BasisState(np.array([1]), wires=[0])\n            op(wires=0).inv()\n            return qml.expval(qml.PauliZ(0))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""PauliX"", 1),\n        (""PauliY"", 1),\n        (""S"", -1),\n    ])\n    def test_inverse_circuit_calling_inv_multiple_times(self, qubit_device_1_wire, tol, name, expected_output):\n        """"""Tests that multiple calls to the inverse of an operation works""""""\n\n        op = getattr(qml.ops, name)\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            qml.BasisState(np.array([1]), wires=[0])\n            op(wires=0).inv().inv().inv()\n            return qml.expval(qml.PauliZ(0))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,expected_output,phi"", [(""RX"", 1,\n                                                           multiplier * 0.5432) for multiplier in range(8)\n                                                          ])\n    def test_inverse_circuit_with_parameters(self, qubit_device_1_wire, tol, name, expected_output, phi):\n        """"""Tests the inverse of supported gates that act on a single wire and are parameterized""""""\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            qml.RX(phi, wires=0)\n            qml.RX(phi, wires=0).inv()\n            return qml.expval(qml.PauliZ(0))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n\n\n    @pytest.mark.parametrize(""name,expected_output,phi"", [(""RX"", 1,\n                                                           multiplier * 0.5432) for multiplier in range(8)\n                                                          ])\n    def test_inverse_circuit_with_parameters_expectation(self, qubit_device_1_wire, tol, name, expected_output, phi):\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            qml.RX(phi, wires=0)\n            qml.RX(phi, wires=0).inv()\n            return qml.expval(qml.PauliZ(0).inv())\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran against the state |0> with one Z expval\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""PauliX"", -1),\n        (""PauliY"", -1),\n        (""PauliZ"", 1),\n        (""Hadamard"", 0),\n    ])\n    def test_supported_gate_single_wire_no_parameters(self, qubit_device_1_wire, tol, name, expected_output):\n        """"""Tests supported gates that act on a single wire that are not parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert qubit_device_1_wire.supports_operation(name)\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            op(wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran against the state |Phi+> with two Z expvals\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""CNOT"", [-1/2, 1]),\n        (""SWAP"", [-1/2, -1/2]),\n        (""CZ"", [-1/2, -1/2]),\n    ])\n    def test_supported_gate_two_wires_no_parameters(self, qubit_device_2_wires, tol, name, expected_output):\n        """"""Tests supported gates that act on two wires that are not parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert qubit_device_2_wires.supports_operation(name)\n\n        @qml.qnode(qubit_device_2_wires)\n        def circuit():\n            qml.QubitStateVector(np.array([1/2, 0, 0, math.sqrt(3)/2]), wires=[0, 1])\n            op(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,expected_output"", [\n        (""CSWAP"", [-1, -1, 1]),\n    ])\n    def test_supported_gate_three_wires_no_parameters(self, qubit_device_3_wires, tol, name, expected_output):\n        """"""Tests supported gates that act on three wires that are not parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert qubit_device_3_wires.supports_operation(name)\n\n        @qml.qnode(qubit_device_3_wires)\n        def circuit():\n            qml.BasisState(np.array([1, 0, 1]), wires=[0, 1, 2])\n            op(wires=[0, 1, 2])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliZ(2))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran with two Z expvals\n    @pytest.mark.parametrize(""name,par,expected_output"", [\n        (""BasisState"", [0, 0], [1, 1]),\n        (""BasisState"", [1, 0], [-1, 1]),\n        (""BasisState"", [0, 1], [1, -1]),\n        (""QubitStateVector"", [1, 0, 0, 0], [1, 1]),\n        (""QubitStateVector"", [0, 0, 1, 0], [-1, 1]),\n        (""QubitStateVector"", [0, 1, 0, 0], [1, -1]),\n    ])\n    def test_supported_state_preparation(self, qubit_device_2_wires, tol, name, par, expected_output):\n        """"""Tests supported state preparations""""""\n\n        op = getattr(qml.ops, name)\n\n        assert qubit_device_2_wires.supports_operation(name)\n\n        @qml.qnode(qubit_device_2_wires)\n        def circuit():\n            op(np.array(par), wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran with two Z expvals\n    @pytest.mark.parametrize(""name,par,wires,expected_output"", [\n        (""BasisState"", [1, 1], [0, 1], [-1, -1]),\n        (""BasisState"", [1], [0], [-1, 1]),\n        (""BasisState"", [1], [1], [1, -1])\n    ])\n    def test_basis_state_2_qubit_subset(self, qubit_device_2_wires, tol, name, par, wires, expected_output):\n        """"""Tests qubit basis state preparation on subsets of qubits""""""\n\n        op = getattr(qml.ops, name)\n\n        @qml.qnode(qubit_device_2_wires)\n        def circuit():\n            op(np.array(par), wires=wires)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is run with two expvals\n    @pytest.mark.parametrize(""name,par,wires,expected_output"", [\n        (""QubitStateVector"", [0, 1], [1], [1, -1]),\n        (""QubitStateVector"", [0, 1], [0], [-1, 1]),\n        (""QubitStateVector"", [1./np.sqrt(2), 1./np.sqrt(2)], [1], [1, 0]),\n        (""QubitStateVector"", [1j/2., np.sqrt(3)/2.], [1], [1, -0.5]),\n        (""QubitStateVector"", [(2-1j)/3., 2j/3.], [0], [1/9., 1])\n    ])\n    def test_state_vector_2_qubit_subset(self, qubit_device_2_wires, tol, name, par, wires, expected_output):\n        """"""Tests qubit state vector preparation on subsets of 2 qubits""""""\n\n        op = getattr(qml.ops, name)\n\n        par = np.array(par)\n\n        @qml.qnode(qubit_device_2_wires)\n        def circuit():\n            op(par, wires=wires)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is run with three expvals\n    @pytest.mark.parametrize(""name,par,wires,expected_output"", [\n        (""QubitStateVector"", [1j/np.sqrt(10), (1-2j)/np.sqrt(10), 0, 0, 0, 2/np.sqrt(10), 0, 0],\n         [0, 1, 2], [1/5., 1., -4/5.]),\n        (""QubitStateVector"", [1/np.sqrt(2), 0, 0, 1/np.sqrt(2)], [0, 2], [0., 1., 0.]),\n        (""QubitStateVector"", [1 / np.sqrt(2), 0, 0, 1 / np.sqrt(2)], [0, 1], [0., 0., 1.]),\n        (""QubitStateVector"", [0, 1, 0, 0, 0, 0, 0, 0], [2, 1, 0], [-1., 1., 1.]),\n        (""QubitStateVector"", [0, 1j, 0, 0, 0, 0, 0, 0], [0, 2, 1], [1., -1., 1.]),\n        (""QubitStateVector"", [0, 1/np.sqrt(2), 0, 1/np.sqrt(2)], [1, 0], [-1., 0., 1.]),\n        (""QubitStateVector"", [0, 1 / np.sqrt(2), 0, 1 / np.sqrt(2)], [0, 1], [0., -1., 1.])\n    ])\n    def test_state_vector_3_qubit_subset(self, qubit_device_3_wires, tol, name, par, wires, expected_output):\n        """"""Tests qubit state vector preparation on subsets of 3 qubits""""""\n\n        op = getattr(qml.ops, name)\n\n        par = np.array(par)\n\n        @qml.qnode(qubit_device_3_wires)\n        def circuit():\n            op(par, wires=wires)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliZ(2))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran on the state |0> with one Z expvals\n    @pytest.mark.parametrize(""name,par,expected_output"", [\n        (""PhaseShift"", [math.pi/2], 1),\n        (""PhaseShift"", [-math.pi/4], 1),\n        (""RX"", [math.pi/2], 0),\n        (""RX"", [-math.pi/4], 1/math.sqrt(2)),\n        (""RY"", [math.pi/2], 0),\n        (""RY"", [-math.pi/4], 1/math.sqrt(2)),\n        (""RZ"", [math.pi/2], 1),\n        (""RZ"", [-math.pi/4], 1),\n        (""MultiRZ"", [math.pi/2], 1),\n        (""MultiRZ"", [-math.pi/4], 1),\n        (""Rot"", [math.pi/2, 0, 0], 1),\n        (""Rot"", [0, math.pi/2, 0], 0),\n        (""Rot"", [0, 0, math.pi/2], 1),\n        (""Rot"", [math.pi/2, -math.pi/4, -math.pi/4], 1/math.sqrt(2)),\n        (""Rot"", [-math.pi/4, math.pi/2, math.pi/4], 0),\n        (""Rot"", [-math.pi/4, math.pi/4, math.pi/2], 1/math.sqrt(2)),\n        (""QubitUnitary"", [np.array([[1j/math.sqrt(2), 1j/math.sqrt(2)], [1j/math.sqrt(2), -1j/math.sqrt(2)]])], 0),\n        (""QubitUnitary"", [np.array([[-1j/math.sqrt(2), 1j/math.sqrt(2)], [1j/math.sqrt(2), 1j/math.sqrt(2)]])], 0),\n    ])\n    def test_supported_gate_single_wire_with_parameters(self, qubit_device_1_wire, tol, name, par, expected_output):\n        """"""Tests supported gates that act on a single wire that are parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert qubit_device_1_wire.supports_operation(name)\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            op(*par, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    # This test is ran against the state 1/2|00>+sqrt(3)/2|11> with two Z expvals\n    @pytest.mark.parametrize(""name,par,expected_output"", [\n        (""CRX"", [0], [-1/2, -1/2]),\n        (""CRX"", [-math.pi], [-1/2, 1]),\n        (""CRX"", [math.pi/2], [-1/2, 1/4]),\n        (""CRY"", [0], [-1/2, -1/2]),\n        (""CRY"", [-math.pi], [-1/2, 1]),\n        (""CRY"", [math.pi/2], [-1/2, 1/4]),\n        (""CRZ"", [0], [-1/2, -1/2]),\n        (""CRZ"", [-math.pi], [-1/2, -1/2]),\n        (""CRZ"", [math.pi/2], [-1/2, -1/2]),\n        (""MultiRZ"", [0], [-1/2, -1/2]),\n        (""MultiRZ"", [-math.pi], [-1/2, -1/2]),\n        (""MultiRZ"", [math.pi/2], [-1/2, -1/2]),\n        (""CRot"", [math.pi/2, 0, 0], [-1/2, -1/2]),\n        (""CRot"", [0, math.pi/2, 0], [-1/2, 1/4]),\n        (""CRot"", [0, 0, math.pi/2], [-1/2, -1/2]),\n        (""CRot"", [math.pi/2, 0, -math.pi], [-1/2, -1/2]),\n        (""CRot"", [0, math.pi/2, -math.pi], [-1/2, 1/4]),\n        (""CRot"", [-math.pi, 0, math.pi/2], [-1/2, -1/2]),\n        (""QubitUnitary"", [np.array([[1, 0, 0, 0], [0, 1/math.sqrt(2), 1/math.sqrt(2), 0], [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], [0, 0, 0, 1]])], [-1/2, -1/2]),\n        (""QubitUnitary"", [np.array([[-1, 0, 0, 0], [0, 1/math.sqrt(2), 1/math.sqrt(2), 0], [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], [0, 0, 0, -1]])], [-1/2, -1/2]),\n    ])\n    def test_supported_gate_two_wires_with_parameters(self, qubit_device_2_wires, tol, name, par, expected_output):\n        """"""Tests supported gates that act on two wires wires that are parameterized""""""\n\n        op = getattr(qml.ops, name)\n\n        assert qubit_device_2_wires.supports_operation(name)\n\n        @qml.qnode(qubit_device_2_wires)\n        def circuit():\n            qml.QubitStateVector(np.array([1/2, 0, 0, math.sqrt(3)/2]), wires=[0, 1])\n            op(*par, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        assert np.allclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,state,expected_output"", [\n        (""PauliX"", [1/math.sqrt(2), 1/math.sqrt(2)], 1),\n        (""PauliX"", [1/math.sqrt(2), -1/math.sqrt(2)], -1),\n        (""PauliX"", [1, 0], 0),\n        (""PauliY"", [1/math.sqrt(2), 1j/math.sqrt(2)], 1),\n        (""PauliY"", [1/math.sqrt(2), -1j/math.sqrt(2)], -1),\n        (""PauliY"", [1, 0], 0),\n        (""PauliZ"", [1, 0], 1),\n        (""PauliZ"", [0, 1], -1),\n        (""PauliZ"", [1/math.sqrt(2), 1/math.sqrt(2)], 0),\n        (""Hadamard"", [1, 0], 1/math.sqrt(2)),\n        (""Hadamard"", [0, 1], -1/math.sqrt(2)),\n        (""Hadamard"", [1/math.sqrt(2), 1/math.sqrt(2)], 1/math.sqrt(2)),\n    ])\n    def test_supported_observable_single_wire_no_parameters(self, qubit_device_1_wire, tol, name, state, expected_output):\n        """"""Tests supported observables on single wires without parameters.""""""\n\n        obs = getattr(qml.ops, name)\n\n        assert qubit_device_1_wire.supports_observable(name)\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            qml.QubitStateVector(np.array(state), wires=[0])\n            return qml.expval(obs(wires=[0]))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,state,expected_output,par"", [\n        (""Identity"", [1, 0], 1, []),\n        (""Identity"", [0, 1], 1, []),\n        (""Identity"", [1/math.sqrt(2), -1/math.sqrt(2)], 1, []),\n        (""Hermitian"", [1, 0], 1, [np.array([[1, 1j], [-1j, 1]])]),\n        (""Hermitian"", [0, 1], 1, [np.array([[1, 1j], [-1j, 1]])]),\n        (""Hermitian"", [1/math.sqrt(2), -1/math.sqrt(2)], 1, [np.array([[1, 1j], [-1j, 1]])]),\n    ])\n    def test_supported_observable_single_wire_with_parameters(self, qubit_device_1_wire, tol, name, state, expected_output, par):\n        """"""Tests supported observables on single wires with parameters.""""""\n\n        obs = getattr(qml.ops, name)\n\n        assert qubit_device_1_wire.supports_observable(name)\n\n        @qml.qnode(qubit_device_1_wire)\n        def circuit():\n            qml.QubitStateVector(np.array(state), wires=[0])\n            return qml.expval(obs(*par, wires=[0]))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""name,state,expected_output,par"", [\n        (""Hermitian"", [1/math.sqrt(3), 0, 1/math.sqrt(3), 1/math.sqrt(3)], 5/3, [np.array([[1, 1j, 0, 1], [-1j, 1, 0, 0], [0, 0, 1, -1j], [1, 0, 1j, 1]])]),\n        (""Hermitian"", [0, 0, 0, 1], 0, [np.array([[0, 1j, 0, 0], [-1j, 0, 0, 0], [0, 0, 0, -1j], [0, 0, 1j, 0]])]),\n        (""Hermitian"", [1/math.sqrt(2), 0, -1/math.sqrt(2), 0], 1, [np.array([[1, 1j, 0, 0], [-1j, 1, 0, 0], [0, 0, 1, -1j], [0, 0, 1j, 1]])]),\n        (""Hermitian"", [1/math.sqrt(3), -1/math.sqrt(3), 1/math.sqrt(6), 1/math.sqrt(6)], 1, [np.array([[1, 1j, 0, .5j], [-1j, 1, 0, 0], [0, 0, 1, -1j], [-.5j, 0, 1j, 1]])]),\n        (""Hermitian"", [1/math.sqrt(2), 0, 0, 1/math.sqrt(2)], 1, [np.array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])]),\n        (""Hermitian"", [0, 1/math.sqrt(2), -1/math.sqrt(2), 0], -1, [np.array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])]),\n    ])\n    def test_supported_observable_two_wires_with_parameters(self, qubit_device_2_wires, tol, name, state, expected_output, par):\n        """"""Tests supported observables on two wires with parameters.""""""\n\n        obs = getattr(qml.ops, name)\n\n        assert qubit_device_2_wires.supports_observable(name)\n\n        @qml.qnode(qubit_device_2_wires)\n        def circuit():\n            qml.QubitStateVector(np.array(state), wires=[0, 1])\n            return qml.expval(obs(*par, wires=[0, 1]))\n\n        assert np.isclose(circuit(), expected_output, atol=tol, rtol=0)\n\n    def test_multi_samples_return_correlated_results(self):\n        """"""Tests if the samples returned by the sample function have\n        the correct dimensions\n        """"""\n\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.Hadamard(0)\n            qml.CNOT(wires=[0, 1])\n            return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliZ(1))\n\n        outcomes = circuit()\n\n        assert np.array_equal(outcomes[0], outcomes[1])\n\n    @pytest.mark.parametrize(""num_wires"", [3, 4, 5, 6, 7, 8])\n    def test_multi_samples_return_correlated_results_more_wires_than_size_of_observable(self, num_wires):\n        """"""Tests if the samples returned by the sample function have\n        the correct dimensions\n        """"""\n\n        dev = qml.device(\'default.qubit\', wires=num_wires)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.Hadamard(0)\n            qml.CNOT(wires=[0, 1])\n            return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliZ(1))\n\n        outcomes = circuit()\n\n        assert np.array_equal(outcomes[0], outcomes[1])\n\n@pytest.mark.parametrize(""theta,phi,varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorExpval:\n    """"""Test tensor expectation values""""""\n\n    def test_paulix_pauliy(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n        dev.reset()\n\n        obs = qml.PauliX(0) @ qml.PauliY(2)\n\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.expval(obs)\n\n        expected = np.sin(theta) * np.sin(phi) * np.sin(varphi)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_pauliz_identity(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliZ and Identity works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n        dev.reset()\n\n        obs = qml.PauliZ(0) @ qml.Identity(1) @ qml.PauliZ(2)\n\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.expval(obs)\n\n        expected = np.cos(varphi)*np.cos(phi)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_pauliz_hadamard(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n        obs = qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2)\n\n        dev.reset()\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.expval(obs)\n\n        expected = -(np.cos(varphi) * np.sin(phi) + np.sin(varphi) * np.cos(theta)) / np.sqrt(2)\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n        dev.reset()\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        obs = qml.PauliZ(0) @ qml.Hermitian(A, wires=[1, 2])\n\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.expval(obs)\n\n        expected = 0.5 * (\n            -6 * np.cos(theta) * (np.cos(varphi) + 1)\n            - 2 * np.sin(varphi) * (np.cos(theta) + np.sin(phi) - 2 * np.cos(phi))\n            + 3 * np.cos(varphi) * np.sin(phi)\n            + np.sin(phi)\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian_hermitian(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving two Hermitian matrices works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        A1 = np.array([[1, 2],\n                       [2, 4]])\n\n        A2 = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        obs = qml.Hermitian(A1, wires=[0]) @ qml.Hermitian(A2, wires=[1, 2])\n\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.expval(obs)\n\n        expected = 0.25 * (\n            -30\n            + 4 * np.cos(phi) * np.sin(theta)\n            + 3 * np.cos(varphi) * (-10 + 4 * np.cos(phi) * np.sin(theta) - 3 * np.sin(phi))\n            - 3 * np.sin(phi)\n            - 2 * (5 + np.cos(phi) * (6 + 4 * np.sin(theta)) + (-3 + 8 * np.sin(theta)) * np.sin(phi))\n            * np.sin(varphi)\n            + np.cos(theta)\n            * (\n                18\n                + 5 * np.sin(phi)\n                + 3 * np.cos(varphi) * (6 + 5 * np.sin(phi))\n                + 2 * (3 + 10 * np.cos(phi) - 5 * np.sin(phi)) * np.sin(varphi)\n            )\n        )\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian_identity_expectation(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving an Hermitian matrix and the identity works correctly""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        A = np.array([[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]])\n\n        obs = qml.Hermitian(A, wires=[0]) @ qml.Identity(wires=[1])\n\n        dev.apply(\n            [\n                qml.RY(theta, wires=[0]),\n                qml.RY(phi, wires=[1]),\n                qml.CNOT(wires=[0, 1])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.expval(obs)\n\n        a = A[0, 0]\n        re_b = A[0, 1].real\n        d = A[1, 1]\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian_two_wires_identity_expectation(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving an Hermitian matrix for two wires and the identity works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, analytic=True)\n\n        A = np.array([[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]])\n        Identity = np.array([[1, 0],[0, 1]])\n        H = np.kron(np.kron(Identity,Identity), A)\n        obs = qml.Hermitian(H, wires=[2, 1, 0])\n\n        dev.apply(\n            [\n                qml.RY(theta, wires=[0]),\n                qml.RY(phi, wires=[1]),\n                qml.CNOT(wires=[0, 1])\n            ],\n            obs.diagonalizing_gates()\n        )\n        res = dev.expval(obs)\n\n        a = A[0, 0]\n        re_b = A[0, 1].real\n        d = A[1, 1]\n\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorVar:\n    """"""Tests for variance of tensor observables""""""\n\n    def test_paulix_pauliy(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        obs = qml.PauliX(0) @ qml.PauliY(2)\n\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.var(obs)\n\n        expected = (\n            8 * np.sin(theta) ** 2 * np.cos(2 * varphi) * np.sin(phi) ** 2\n            - np.cos(2 * (theta - phi))\n            - np.cos(2 * (theta + phi))\n            + 2 * np.cos(2 * theta)\n            + 2 * np.cos(2 * phi)\n            + 14\n        ) / 16\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_pauliz_hadamard(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n        obs = qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2)\n\n        dev.reset()\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.var(obs)\n\n        expected = (\n            3\n            + np.cos(2 * phi) * np.cos(varphi) ** 2\n            - np.cos(2 * theta) * np.sin(varphi) ** 2\n            - 2 * np.cos(theta) * np.sin(phi) * np.sin(2 * varphi)\n        ) / 4\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_hermitian(self, theta, phi, varphi, tol):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        obs = qml.PauliZ(0) @ qml.Hermitian(A, wires=[1, 2])\n\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        res = dev.var(obs)\n\n        expected = (\n            1057\n            - np.cos(2 * phi)\n            + 12 * (27 + np.cos(2 * phi)) * np.cos(varphi)\n            - 2 * np.cos(2 * varphi) * np.sin(phi) * (16 * np.cos(phi) + 21 * np.sin(phi))\n            + 16 * np.sin(2 * phi)\n            - 8 * (-17 + np.cos(2 * phi) + 2 * np.sin(2 * phi)) * np.sin(varphi)\n            - 8 * np.cos(2 * theta) * (3 + 3 * np.cos(varphi) + np.sin(varphi)) ** 2\n            - 24 * np.cos(phi) * (np.cos(phi) + 2 * np.sin(phi)) * np.sin(2 * varphi)\n            - 8\n            * np.cos(theta)\n            * (\n                4\n                * np.cos(phi)\n                * (\n                    4\n                    + 8 * np.cos(varphi)\n                    + np.cos(2 * varphi)\n                    - (1 + 6 * np.cos(varphi)) * np.sin(varphi)\n                )\n                + np.sin(phi)\n                * (\n                    15\n                    + 8 * np.cos(varphi)\n                    - 11 * np.cos(2 * varphi)\n                    + 42 * np.sin(varphi)\n                    + 3 * np.sin(2 * varphi)\n                )\n            )\n        ) / 16\n\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\nclass TestTensorSample:\n    """"""Test tensor expectation values""""""\n\n    def test_paulix_pauliy(self, theta, phi, varphi, monkeypatch, tol):\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3, shots=10000)\n\n        obs = qml.PauliX(0) @ qml.PauliY(2)\n\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        dev._wires_measured = {0, 1, 2}\n        dev._samples = dev.generate_samples()\n        dev.sample(obs)\n\n        s1 = obs.eigvals\n        p = dev.probability(wires=obs.wires.tolist())\n\n        # s1 should only contain 1 and -1\n        assert np.allclose(s1 ** 2, 1, atol=tol, rtol=0)\n\n        mean = s1 @ p\n        expected = np.sin(theta) * np.sin(phi) * np.sin(varphi)\n        assert np.allclose(mean, expected, atol=tol, rtol=0)\n\n        var = (s1 ** 2) @ p - (s1 @ p).real ** 2\n        expected = (\n            8 * np.sin(theta) ** 2 * np.cos(2 * varphi) * np.sin(phi) ** 2\n            - np.cos(2 * (theta - phi))\n            - np.cos(2 * (theta + phi))\n            + 2 * np.cos(2 * theta)\n            + 2 * np.cos(2 * phi)\n            + 14\n        ) / 16\n        assert np.allclose(var, expected, atol=tol, rtol=0)\n\n    def test_pauliz_hadamard(self, theta, phi, varphi, monkeypatch, tol):\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n        obs = qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2)\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        dev._wires_measured = {0, 1, 2}\n        dev._samples = dev.generate_samples()\n        dev.sample(obs)\n\n        s1 = obs.eigvals\n        p = dev.marginal_prob(dev.probability(), wires=obs.wires.tolist())\n\n        # s1 should only contain 1 and -1\n        assert np.allclose(s1 ** 2, 1, atol=tol, rtol=0)\n\n        mean = s1 @ p\n        expected = -(np.cos(varphi) * np.sin(phi) + np.sin(varphi) * np.cos(theta)) / np.sqrt(2)\n        assert np.allclose(mean, expected, atol=tol, rtol=0)\n\n        var = (s1 ** 2) @ p - (s1 @ p).real ** 2\n        expected = (\n            3\n            + np.cos(2 * phi) * np.cos(varphi) ** 2\n            - np.cos(2 * theta) * np.sin(varphi) ** 2\n            - 2 * np.cos(theta) * np.sin(phi) * np.sin(2 * varphi)\n        ) / 4\n        assert np.allclose(var, expected, atol=tol, rtol=0)\n\n    def test_hermitian(self, theta, phi, varphi, monkeypatch, tol):\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        A = np.array(\n            [\n                [-6, 2 + 1j, -3, -5 + 2j],\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\n                [-3, 2 + 1j, 0, -4 + 3j],\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\n            ]\n        )\n\n        obs = qml.PauliZ(0) @ qml.Hermitian(A, wires=[1, 2])\n        dev.apply(\n            [\n                qml.RX(theta, wires=[0]),\n                qml.RX(phi, wires=[1]),\n                qml.RX(varphi, wires=[2]),\n                qml.CNOT(wires=[0, 1]),\n                qml.CNOT(wires=[1, 2])\n            ],\n            obs.diagonalizing_gates()\n        )\n\n        dev._wires_measured = {0, 1, 2}\n        dev._samples = dev.generate_samples()\n        dev.sample(obs)\n\n        s1 = obs.eigvals\n        p = dev.marginal_prob(dev.probability(), wires=obs.wires.tolist())\n\n        # s1 should only contain the eigenvalues of\n        # the hermitian matrix tensor product Z\n        Z = np.diag([1, -1])\n        eigvals = np.linalg.eigvalsh(np.kron(Z, A))\n        assert set(np.round(s1, 8)).issubset(set(np.round(eigvals, 8)))\n\n        mean = s1 @ p\n        expected = 0.5 * (\n            -6 * np.cos(theta) * (np.cos(varphi) + 1)\n            - 2 * np.sin(varphi) * (np.cos(theta) + np.sin(phi) - 2 * np.cos(phi))\n            + 3 * np.cos(varphi) * np.sin(phi)\n            + np.sin(phi)\n        )\n        assert np.allclose(mean, expected, atol=tol, rtol=0)\n\n        var = (s1 ** 2) @ p - (s1 @ p).real ** 2\n        expected = (\n            1057\n            - np.cos(2 * phi)\n            + 12 * (27 + np.cos(2 * phi)) * np.cos(varphi)\n            - 2 * np.cos(2 * varphi) * np.sin(phi) * (16 * np.cos(phi) + 21 * np.sin(phi))\n            + 16 * np.sin(2 * phi)\n            - 8 * (-17 + np.cos(2 * phi) + 2 * np.sin(2 * phi)) * np.sin(varphi)\n            - 8 * np.cos(2 * theta) * (3 + 3 * np.cos(varphi) + np.sin(varphi)) ** 2\n            - 24 * np.cos(phi) * (np.cos(phi) + 2 * np.sin(phi)) * np.sin(2 * varphi)\n            - 8\n            * np.cos(theta)\n            * (\n                4\n                * np.cos(phi)\n                * (\n                    4\n                    + 8 * np.cos(varphi)\n                    + np.cos(2 * varphi)\n                    - (1 + 6 * np.cos(varphi)) * np.sin(varphi)\n                )\n                + np.sin(phi)\n                * (\n                    15\n                    + 8 * np.cos(varphi)\n                    - 11 * np.cos(2 * varphi)\n                    + 42 * np.sin(varphi)\n                    + 3 * np.sin(2 * varphi)\n                )\n            )\n        ) / 16\n        assert np.allclose(var, expected, atol=tol, rtol=0)\n\nclass TestProbabilityIntegration:\n    """"""Test probability method for when analytic is True/False""""""\n\n    def mock_analytic_counter(self, wires=None):\n        self.analytic_counter += 1\n        return np.array([1, 0, 0, 0], dtype=float)\n\n    @pytest.mark.parametrize(""x"", [[0.2, 0.5], [0.4, 0.9], [0.8, 0.3]])\n    def test_probability(self, x, tol):\n        """"""Test that the probability function works when analytic=False""""""\n        dev = qml.device(""default.qubit"", wires=2, analytic=False)\n        dev_analytic = qml.device(""default.qubit"", wires=2, analytic=True)\n\n        def circuit(x):\n            qml.RX(x[0], wires=0)\n            qml.RY(x[1], wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.probs(wires=[0, 1])\n\n        prob = qml.QNode(circuit, dev)\n        prob_analytic = qml.QNode(circuit, dev_analytic)\n\n        assert np.isclose(prob(x).sum(), 1, atol=tol, rtol=0)\n        assert np.allclose(prob_analytic(x), prob(x), atol=0.1, rtol=0)\n        assert not np.array_equal(prob_analytic(x), prob(x))\n\n    @pytest.mark.parametrize(""analytic"", [True, False])\n    def test_call_generate_samples(self, analytic, monkeypatch):\n        """"""Test analytic_probability call when generating samples""""""\n        self.analytic_counter = False\n\n        dev = qml.device(""default.qubit"", wires=2, analytic=analytic)\n        monkeypatch.setattr(dev, ""analytic_probability"", self.mock_analytic_counter)\n\n        # generate samples through `generate_samples` (using \'analytic_probability\')\n        dev.generate_samples()\n\n        # should call `analytic_probability` once through `generate_samples`\n        assert self.analytic_counter == 1\n\n    def test_stateless_analytic_return(self):\n        """"""Test that analytic_probability returns None if device is stateless""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        dev._state = None\n\n        assert dev.analytic_probability() is None\n'"
tests/plugins/test_default_qubit_tf.py,56,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\r\n\r\n# Licensed under the Apache License, Version 2.0 (the ""License"");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an ""AS IS"" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n""""""\r\nUnit tests and integration tests for the ``default.qubit.tf`` device.\r\n""""""\r\nfrom itertools import product\r\n\r\nimport numpy as np\r\nimport pytest\r\n\r\ntf = pytest.importorskip(""tensorflow"", minversion=""2.0"")\r\n\r\nimport pennylane as qml\r\nfrom pennylane.plugins.default_qubit_tf import DefaultQubitTF\r\nfrom gate_data import (\r\n    I,\r\n    X,\r\n    Y,\r\n    Z,\r\n    H,\r\n    S,\r\n    T,\r\n    CNOT,\r\n    CZ,\r\n    SWAP,\r\n    CNOT,\r\n    Toffoli,\r\n    CSWAP,\r\n    Rphi,\r\n    Rotx,\r\n    Roty,\r\n    Rotz,\r\n    Rot3,\r\n    CRotx,\r\n    CRoty,\r\n    CRotz,\r\n    CRot3,\r\n)\r\n\r\nnp.random.seed(42)\r\n\r\n\r\n#####################################################\r\n# Test matrices\r\n#####################################################\r\n\r\nU = np.array(\r\n    [\r\n        [0.83645892 - 0.40533293j, -0.20215326 + 0.30850569j],\r\n        [-0.23889780 - 0.28101519j, -0.88031770 - 0.29832709j],\r\n    ]\r\n)\r\n\r\nU2 = np.array([[0, 1, 1, 1], [1, 0, 1, -1], [1, -1, 0, 1], [1, 1, -1, 0]]) / np.sqrt(3)\r\nA = np.array([[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]])\r\n\r\n\r\n#####################################################\r\n# Define standard qubit operations\r\n#####################################################\r\n\r\nsingle_qubit = [(qml.S, S), (qml.T, T), (qml.PauliX, X), (qml.PauliY, Y), (qml.PauliZ, Z), (qml.Hadamard, H)]\r\nsingle_qubit_param = [(qml.PhaseShift, Rphi), (qml.RX, Rotx), (qml.RY, Roty), (qml.RZ, Rotz)]\r\ntwo_qubit = [(qml.CZ, CZ), (qml.CNOT, CNOT), (qml.SWAP, SWAP)]\r\ntwo_qubit_param = [(qml.CRX, CRotx), (qml.CRY, CRoty), (qml.CRZ, CRotz)]\r\nthree_qubit = [(qml.Toffoli, Toffoli), (qml.CSWAP, CSWAP)]\r\n\r\n\r\n#####################################################\r\n# Fixtures\r\n#####################################################\r\n\r\n\r\n@pytest.fixture\r\ndef init_state(scope=""session""):\r\n    """"""Generates a random initial state""""""\r\n\r\n    def _init_state(n):\r\n        """"""random initial state""""""\r\n        state = np.random.random([2 ** n]) + np.random.random([2 ** n]) * 1j\r\n        state /= np.linalg.norm(state)\r\n        return state\r\n\r\n    return _init_state\r\n\r\n\r\n#####################################################\r\n# Device-level integration tests\r\n#####################################################\r\n\r\n\r\nclass TestApply:\r\n    """"""Test application of PennyLane operations.""""""\r\n\r\n    def test_basis_state(self, tol):\r\n        """"""Test basis state initialization""""""\r\n        dev = DefaultQubitTF(wires=4)\r\n        state = np.array([0, 0, 1, 0])\r\n\r\n        dev.apply([qml.BasisState(state, wires=[0, 1, 2, 3])])\r\n\r\n        res = dev.state\r\n        expected = np.zeros([2 ** 4])\r\n        expected[np.ravel_multi_index(state, [2] * 4)] = 1\r\n\r\n        assert isinstance(res, tf.Tensor)\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_invalid_basis_state_length(self, tol):\r\n        """"""Test that an exception is raised if the basis state is the wrong size""""""\r\n        dev = DefaultQubitTF(wires=4)\r\n        state = np.array([0, 0, 1, 0])\r\n\r\n        with pytest.raises(\r\n            ValueError, match=r""BasisState parameter and wires must be of equal length""\r\n        ):\r\n            dev.apply([qml.BasisState(state, wires=[0, 1, 2])])\r\n\r\n    def test_invalid_basis_state(self, tol):\r\n        """"""Test that an exception is raised if the basis state is invalid""""""\r\n        dev = DefaultQubitTF(wires=4)\r\n        state = np.array([0, 0, 1, 2])\r\n\r\n        with pytest.raises(\r\n            ValueError, match=r""BasisState parameter must consist of 0 or 1 integers""\r\n        ):\r\n            dev.apply([qml.BasisState(state, wires=[0, 1, 2, 3])])\r\n\r\n    def test_qubit_state_vector(self, init_state, tol):\r\n        """"""Test qubit state vector application""""""\r\n        dev = DefaultQubitTF(wires=1)\r\n        state = init_state(1)\r\n\r\n        dev.apply([qml.QubitStateVector(state, wires=[0])])\r\n\r\n        res = dev.state\r\n        expected = state\r\n        assert isinstance(res, tf.Tensor)\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_invalid_qubit_state_vector_size(self):\r\n        """"""Test that an exception is raised if the state\r\n        vector is the wrong size""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        state = np.array([0, 1])\r\n\r\n        with pytest.raises(ValueError, match=r""State vector must be of length 2\\*\\*wires""):\r\n            dev.apply([qml.QubitStateVector(state, wires=[0, 1])])\r\n\r\n    def test_invalid_qubit_state_vector_norm(self):\r\n        """"""Test that an exception is raised if the state\r\n        vector is not normalized""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        state = np.array([0, 12])\r\n\r\n        with pytest.raises(ValueError, match=r""Sum of amplitudes-squared does not equal one""):\r\n            dev.apply([qml.QubitStateVector(state, wires=[0])])\r\n\r\n    def test_invalid_state_prep(self):\r\n        """"""Test that an exception is raised if a state preparation is not the\r\n        first operation in the circuit.""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        state = np.array([0, 12])\r\n\r\n        with pytest.raises(\r\n            qml.DeviceError,\r\n            match=r""cannot be used after other Operations have already been applied"",\r\n        ):\r\n            dev.apply([qml.PauliZ(0), qml.QubitStateVector(state, wires=[0])])\r\n\r\n    @pytest.mark.parametrize(""op,mat"", single_qubit)\r\n    def test_single_qubit_no_parameters(self, init_state, op, mat, tol):\r\n        """"""Test non-parametrized single qubit operations""""""\r\n        dev = DefaultQubitTF(wires=1)\r\n        state = init_state(1)\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0])]\r\n        queue += [op(wires=0)]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = mat @ state\r\n        assert isinstance(res, tf.Tensor)\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    @pytest.mark.parametrize(""theta"", [0.5432, -0.232])\r\n    @pytest.mark.parametrize(""op,func"", single_qubit_param)\r\n    def test_single_qubit_parameters(self, init_state, op, func, theta, tol):\r\n        """"""Test parametrized single qubit operations""""""\r\n        dev = DefaultQubitTF(wires=1)\r\n        state = init_state(1)\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0])]\r\n        queue += [op(theta, wires=0)]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = func(theta) @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_rotation(self, init_state, tol):\r\n        """"""Test three axis rotation gate""""""\r\n        dev = DefaultQubitTF(wires=1)\r\n        state = init_state(1)\r\n\r\n        a = 0.542\r\n        b = 1.3432\r\n        c = -0.654\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0])]\r\n        queue += [qml.Rot(a, b, c, wires=0)]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = Rot3(a, b, c) @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_controlled_rotation(self, init_state, tol):\r\n        """"""Test three axis controlled-rotation gate""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        state = init_state(2)\r\n\r\n        a = 0.542\r\n        b = 1.3432\r\n        c = -0.654\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0, 1])]\r\n        queue += [qml.CRot(a, b, c, wires=[0, 1])]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = CRot3(a, b, c) @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_inverse_operation(self, init_state, tol):\r\n        """"""Test that the inverse of an operation is correctly applied""""""\r\n        """"""Test three axis rotation gate""""""\r\n        dev = DefaultQubitTF(wires=1)\r\n        state = init_state(1)\r\n\r\n        a = 0.542\r\n        b = 1.3432\r\n        c = -0.654\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0])]\r\n        queue += [qml.Rot(a, b, c, wires=0).inv()]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = np.linalg.inv(Rot3(a, b, c)) @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    @pytest.mark.parametrize(""op,mat"", two_qubit)\r\n    def test_two_qubit_no_parameters(self, init_state, op, mat, tol):\r\n        """"""Test non-parametrized two qubit operations""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        state = init_state(2)\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0, 1])]\r\n        queue += [op(wires=[0, 1])]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = mat @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    @pytest.mark.parametrize(""mat"", [U, U2])\r\n    def test_qubit_unitary(self, init_state, mat, tol):\r\n        """"""Test application of arbitrary qubit unitaries""""""\r\n        N = int(np.log2(len(mat)))\r\n        dev = DefaultQubitTF(wires=N)\r\n        state = init_state(N)\r\n\r\n        queue = [qml.QubitStateVector(state, wires=range(N))]\r\n        queue += [qml.QubitUnitary(mat, wires=range(N))]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = mat @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    @pytest.mark.parametrize(""op, mat"", three_qubit)\r\n    def test_three_qubit_no_parameters(self, init_state, op, mat, tol):\r\n        """"""Test non-parametrized three qubit operations""""""\r\n        dev = DefaultQubitTF(wires=3)\r\n        state = init_state(3)\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0, 1, 2])]\r\n        queue += [op(wires=[0, 1, 2])]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = mat @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    @pytest.mark.parametrize(""theta"", [0.5432, -0.232])\r\n    @pytest.mark.parametrize(""op,func"", two_qubit_param)\r\n    def test_two_qubit_parameters(self, init_state, op, func, theta, tol):\r\n        """"""Test two qubit parametrized operations""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        state = init_state(2)\r\n\r\n        queue = [qml.QubitStateVector(state, wires=[0, 1])]\r\n        queue += [op(theta, wires=[0, 1])]\r\n        dev.apply(queue)\r\n\r\n        res = dev.state\r\n        expected = func(theta) @ state\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n\r\nTHETA = np.linspace(0.11, 1, 3)\r\nPHI = np.linspace(0.32, 1, 3)\r\nVARPHI = np.linspace(0.02, 1, 3)\r\n\r\n\r\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\r\nclass TestExpval:\r\n    """"""Test expectation values""""""\r\n\r\n    # test data; each tuple is of the form (GATE, OBSERVABLE, EXPECTED)\r\n    single_wire_expval_test_data = [\r\n        (qml.RX, qml.Identity, lambda t, p: np.array([1, 1])),\r\n        (qml.RX, qml.PauliZ, lambda t, p: np.array([np.cos(t), np.cos(t) * np.cos(p)])),\r\n        (qml.RY, qml.PauliX, lambda t, p: np.array([np.sin(t) * np.sin(p), np.sin(p)])),\r\n        (qml.RX, qml.PauliY, lambda t, p: np.array([0, -np.cos(t) * np.sin(p)])),\r\n        (\r\n            qml.RY,\r\n            qml.Hadamard,\r\n            lambda t, p: np.array(\r\n                [np.sin(t) * np.sin(p) + np.cos(t), np.cos(t) * np.cos(p) + np.sin(p)]\r\n            )\r\n            / np.sqrt(2),\r\n        ),\r\n    ]\r\n\r\n    @pytest.mark.parametrize(""gate,obs,expected"", single_wire_expval_test_data)\r\n    def test_single_wire_expectation(self, gate, obs, expected, theta, phi, varphi, tol):\r\n        """"""Test that identity expectation value (i.e. the trace) is 1""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        queue = [gate(theta, wires=0), gate(phi, wires=1), qml.CNOT(wires=[0, 1])]\r\n        observables = [obs(wires=[i]) for i in range(2)]\r\n\r\n        for i in range(len(observables)):\r\n            observables[i].return_type = qml.operation.Expectation\r\n\r\n        res = dev.execute(qml.CircuitGraph(queue + observables, {}))\r\n        assert np.allclose(res, expected(theta, phi), atol=tol, rtol=0)\r\n\r\n    def test_hermitian_expectation(self, theta, phi, varphi, tol):\r\n        """"""Test that arbitrary Hermitian expectation values are correct""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n        queue = [qml.RY(theta, wires=0), qml.RY(phi, wires=1), qml.CNOT(wires=[0, 1])]\r\n        observables = [qml.Hermitian(A, wires=[i]) for i in range(2)]\r\n\r\n        for i in range(len(observables)):\r\n            observables[i].return_type = qml.operation.Expectation\r\n\r\n        res = dev.execute(qml.CircuitGraph(queue + observables, {}))\r\n\r\n        a = A[0, 0]\r\n        re_b = A[0, 1].real\r\n        d = A[1, 1]\r\n        ev1 = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\r\n        ev2 = ((a - d) * np.cos(theta) * np.cos(phi) + 2 * re_b * np.sin(phi) + a + d) / 2\r\n        expected = np.array([ev1, ev2])\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_multi_mode_hermitian_expectation(self, theta, phi, varphi, tol):\r\n        """"""Test that arbitrary multi-mode Hermitian expectation values are correct""""""\r\n        A = np.array(\r\n            [\r\n                [-6, 2 + 1j, -3, -5 + 2j],\r\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\r\n                [-3, 2 + 1j, 0, -4 + 3j],\r\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\r\n            ]\r\n        )\r\n\r\n        dev = DefaultQubitTF(wires=2)\r\n        queue = [qml.RY(theta, wires=0), qml.RY(phi, wires=1), qml.CNOT(wires=[0, 1])]\r\n        observables = [qml.Hermitian(A, wires=[0, 1])]\r\n\r\n        for i in range(len(observables)):\r\n            observables[i].return_type = qml.operation.Expectation\r\n\r\n        res = dev.execute(qml.CircuitGraph(queue + observables, {}))\r\n\r\n        # below is the analytic expectation value for this circuit with arbitrary\r\n        # Hermitian observable A\r\n        expected = 0.5 * (\r\n            6 * np.cos(theta) * np.sin(phi)\r\n            - np.sin(theta) * (8 * np.sin(phi) + 7 * np.cos(phi) + 3)\r\n            - 2 * np.sin(phi)\r\n            - 6 * np.cos(phi)\r\n            - 6\r\n        )\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_paulix_pauliy(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n        dev.reset()\r\n\r\n        obs = qml.PauliX(0) @ qml.PauliY(2)\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.expval(obs)\r\n\r\n        expected = np.sin(theta) * np.sin(phi) * np.sin(varphi)\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_pauliz_identity(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving PauliZ and Identity works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n        dev.reset()\r\n\r\n        obs = qml.PauliZ(0) @ qml.Identity(1) @ qml.PauliZ(2)\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.expval(obs)\r\n\r\n        expected = np.cos(varphi)*np.cos(phi)\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_pauliz_hadamard(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n        obs = qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2)\r\n\r\n        dev.reset()\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.expval(obs)\r\n\r\n        expected = -(np.cos(varphi) * np.sin(phi) + np.sin(varphi) * np.cos(theta)) / np.sqrt(2)\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_hermitian(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n        dev.reset()\r\n\r\n        A = np.array(\r\n            [\r\n                [-6, 2 + 1j, -3, -5 + 2j],\r\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\r\n                [-3, 2 + 1j, 0, -4 + 3j],\r\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\r\n            ]\r\n        )\r\n\r\n        obs = qml.PauliZ(0) @ qml.Hermitian(A, wires=[1, 2])\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.expval(obs)\r\n\r\n        expected = 0.5 * (\r\n            -6 * np.cos(theta) * (np.cos(varphi) + 1)\r\n            - 2 * np.sin(varphi) * (np.cos(theta) + np.sin(phi) - 2 * np.cos(phi))\r\n            + 3 * np.cos(varphi) * np.sin(phi)\r\n            + np.sin(phi)\r\n        )\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_hermitian_hermitian(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving two Hermitian matrices works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n\r\n        A1 = np.array([[1, 2],\r\n                       [2, 4]])\r\n\r\n        A2 = np.array(\r\n            [\r\n                [-6, 2 + 1j, -3, -5 + 2j],\r\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\r\n                [-3, 2 + 1j, 0, -4 + 3j],\r\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\r\n            ]\r\n        )\r\n\r\n        obs = qml.Hermitian(A1, wires=[0]) @ qml.Hermitian(A2, wires=[1, 2])\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.expval(obs)\r\n\r\n        expected = 0.25 * (\r\n            -30\r\n            + 4 * np.cos(phi) * np.sin(theta)\r\n            + 3 * np.cos(varphi) * (-10 + 4 * np.cos(phi) * np.sin(theta) - 3 * np.sin(phi))\r\n            - 3 * np.sin(phi)\r\n            - 2 * (5 + np.cos(phi) * (6 + 4 * np.sin(theta)) + (-3 + 8 * np.sin(theta)) * np.sin(phi))\r\n            * np.sin(varphi)\r\n            + np.cos(theta)\r\n            * (\r\n                18\r\n                + 5 * np.sin(phi)\r\n                + 3 * np.cos(varphi) * (6 + 5 * np.sin(phi))\r\n                + 2 * (3 + 10 * np.cos(phi) - 5 * np.sin(phi)) * np.sin(varphi)\r\n            )\r\n        )\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_hermitian_identity_expectation(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving an Hermitian matrix and the identity works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=2)\r\n\r\n        A = np.array([[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]])\r\n\r\n        obs = qml.Hermitian(A, wires=[0]) @ qml.Identity(wires=[1])\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RY(theta, wires=[0]),\r\n                qml.RY(phi, wires=[1]),\r\n                qml.CNOT(wires=[0, 1])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.expval(obs)\r\n\r\n        a = A[0, 0]\r\n        re_b = A[0, 1].real\r\n        d = A[1, 1]\r\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_hermitian_two_wires_identity_expectation(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving an Hermitian matrix for two wires and the identity works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3, analytic=True)\r\n\r\n        A = np.array([[1.02789352, 1.61296440 - 0.3498192j], [1.61296440 + 0.3498192j, 1.23920938 + 0j]])\r\n        Identity = np.array([[1, 0],[0, 1]])\r\n        H = np.kron(np.kron(Identity,Identity), A)\r\n        obs = qml.Hermitian(H, wires=[2, 1, 0])\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RY(theta, wires=[0]),\r\n                qml.RY(phi, wires=[1]),\r\n                qml.CNOT(wires=[0, 1])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n        res = dev.expval(obs)\r\n\r\n        a = A[0, 0]\r\n        re_b = A[0, 1].real\r\n        d = A[1, 1]\r\n\r\n        expected = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d) / 2\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n\r\n@pytest.mark.parametrize(""theta, phi, varphi"", list(zip(THETA, PHI, VARPHI)))\r\nclass TestVar:\r\n    """"""Tests for the variance""""""\r\n\r\n    def test_var(self, theta, phi, varphi, tol):\r\n        """"""Tests for variance calculation""""""\r\n        dev = DefaultQubitTF(wires=1)\r\n        # test correct variance for <Z> of a rotated state\r\n\r\n        queue = [qml.RX(phi, wires=0), qml.RY(theta, wires=0)]\r\n        observables = [qml.PauliZ(wires=[0])]\r\n\r\n        for i in range(len(observables)):\r\n            observables[i].return_type = qml.operation.Variance\r\n\r\n        res = dev.execute(qml.CircuitGraph(queue + observables, {}))\r\n        expected = 0.25 * (3 - np.cos(2 * theta) - 2 * np.cos(theta) ** 2 * np.cos(2 * phi))\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_var_hermitian(self, theta, phi, varphi, tol):\r\n        """"""Tests for variance calculation using an arbitrary Hermitian observable""""""\r\n        dev = DefaultQubitTF(wires=2)\r\n\r\n        # test correct variance for <H> of a rotated state\r\n        H = np.array([[4, -1 + 6j], [-1 - 6j, 2]])\r\n        queue = [qml.RX(phi, wires=0), qml.RY(theta, wires=0)]\r\n        observables = [qml.Hermitian(H, wires=[0])]\r\n\r\n        for i in range(len(observables)):\r\n            observables[i].return_type = qml.operation.Variance\r\n\r\n        res = dev.execute(qml.CircuitGraph(queue + observables, {}))\r\n        expected = 0.5 * (\r\n            2 * np.sin(2 * theta) * np.cos(phi) ** 2\r\n            + 24 * np.sin(phi) * np.cos(phi) * (np.sin(theta) - np.cos(theta))\r\n            + 35 * np.cos(2 * phi)\r\n            + 39\r\n        )\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_paulix_pauliy(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving PauliX and PauliY works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n\r\n        obs = qml.PauliX(0) @ qml.PauliY(2)\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.var(obs)\r\n\r\n        expected = (\r\n            8 * np.sin(theta) ** 2 * np.cos(2 * varphi) * np.sin(phi) ** 2\r\n            - np.cos(2 * (theta - phi))\r\n            - np.cos(2 * (theta + phi))\r\n            + 2 * np.cos(2 * theta)\r\n            + 2 * np.cos(2 * phi)\r\n            + 14\r\n        ) / 16\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_pauliz_hadamard(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving PauliZ and PauliY and hadamard works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n        obs = qml.PauliZ(0) @ qml.Hadamard(1) @ qml.PauliY(2)\r\n\r\n        dev.reset()\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.var(obs)\r\n\r\n        expected = (\r\n            3\r\n            + np.cos(2 * phi) * np.cos(varphi) ** 2\r\n            - np.cos(2 * theta) * np.sin(varphi) ** 2\r\n            - 2 * np.cos(theta) * np.sin(phi) * np.sin(2 * varphi)\r\n        ) / 4\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_hermitian(self, theta, phi, varphi, tol):\r\n        """"""Test that a tensor product involving qml.Hermitian works correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3)\r\n\r\n        A = np.array(\r\n            [\r\n                [-6, 2 + 1j, -3, -5 + 2j],\r\n                [2 - 1j, 0, 2 - 1j, -5 + 4j],\r\n                [-3, 2 + 1j, 0, -4 + 3j],\r\n                [-5 - 2j, -5 - 4j, -4 - 3j, -6],\r\n            ]\r\n        )\r\n\r\n        obs = qml.PauliZ(0) @ qml.Hermitian(A, wires=[1, 2])\r\n\r\n        dev.apply(\r\n            [\r\n                qml.RX(theta, wires=[0]),\r\n                qml.RX(phi, wires=[1]),\r\n                qml.RX(varphi, wires=[2]),\r\n                qml.CNOT(wires=[0, 1]),\r\n                qml.CNOT(wires=[1, 2])\r\n            ],\r\n            obs.diagonalizing_gates()\r\n        )\r\n\r\n        res = dev.var(obs)\r\n\r\n        expected = (\r\n            1057\r\n            - np.cos(2 * phi)\r\n            + 12 * (27 + np.cos(2 * phi)) * np.cos(varphi)\r\n            - 2 * np.cos(2 * varphi) * np.sin(phi) * (16 * np.cos(phi) + 21 * np.sin(phi))\r\n            + 16 * np.sin(2 * phi)\r\n            - 8 * (-17 + np.cos(2 * phi) + 2 * np.sin(2 * phi)) * np.sin(varphi)\r\n            - 8 * np.cos(2 * theta) * (3 + 3 * np.cos(varphi) + np.sin(varphi)) ** 2\r\n            - 24 * np.cos(phi) * (np.cos(phi) + 2 * np.sin(phi)) * np.sin(2 * varphi)\r\n            - 8\r\n            * np.cos(theta)\r\n            * (\r\n                4\r\n                * np.cos(phi)\r\n                * (\r\n                    4\r\n                    + 8 * np.cos(varphi)\r\n                    + np.cos(2 * varphi)\r\n                    - (1 + 6 * np.cos(varphi)) * np.sin(varphi)\r\n                )\r\n                + np.sin(phi)\r\n                * (\r\n                    15\r\n                    + 8 * np.cos(varphi)\r\n                    - 11 * np.cos(2 * varphi)\r\n                    + 42 * np.sin(varphi)\r\n                    + 3 * np.sin(2 * varphi)\r\n                )\r\n            )\r\n        ) / 16\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n\r\n#####################################################\r\n# QNode-level integration tests\r\n#####################################################\r\n\r\n\r\nclass TestQNodeIntegration:\r\n    """"""Integration tests for default.qubit.tf. This test ensures it integrates\r\n    properly with the PennyLane UI, in particular the new QNode.""""""\r\n\r\n    def test_load_tensornet_tf_device(self):\r\n        """"""Test that the tensor network plugin loads correctly""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=2)\r\n        assert dev.num_wires == 2\r\n        assert dev.shots == 1000\r\n        assert dev.analytic\r\n        assert dev.short_name == ""default.qubit.tf""\r\n        assert dev.capabilities()[""passthru_interface""] == ""tf""\r\n\r\n    def test_qubit_circuit(self, tol):\r\n        """"""Test that the tensor network plugin provides correct\r\n        result for a simple circuit using the old QNode.""""""\r\n        p = tf.Variable(0.543)\r\n\r\n        dev = qml.device(""default.qubit.tf"", wires=1)\r\n\r\n        @qml.qnode(dev, interface=""tf"")\r\n        def circuit(x):\r\n            qml.RX(x, wires=0)\r\n            return qml.expval(qml.PauliY(0))\r\n\r\n        expected = -tf.math.sin(p)\r\n\r\n        assert isinstance(circuit, qml.qnodes.PassthruQNode)\r\n        assert np.isclose(circuit(p), expected, atol=tol, rtol=0)\r\n\r\n    def test_correct_state(self, tol):\r\n        """"""Test that the device state is correct after applying a\r\n        quantum function on the device""""""\r\n\r\n        dev = qml.device(""default.qubit.tf"", wires=2)\r\n\r\n        state = dev.state\r\n        expected = np.array([1, 0, 0, 0])\r\n        assert np.allclose(state, expected, atol=tol, rtol=0)\r\n\r\n        @qml.qnode(dev, interface=""tf"", diff_method=""backprop"")\r\n        def circuit():\r\n            qml.Hadamard(wires=0)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        circuit()\r\n        state = dev.state\r\n\r\n        expected = tf.constant([1.0, 0, 1.0, 0]) / np.sqrt(2)\r\n        assert np.allclose(state, expected, atol=tol, rtol=0)\r\n\r\n\r\nclass TestPassthruIntegration:\r\n    """"""Tests for integration with the PassthruQNode""""""\r\n\r\n    def test_jacobian_variable_multiply(self, tol):\r\n        """"""Test that jacobian of a QNode with an attached default.qubit.tf device\r\n        gives the correct result in the case of parameters multiplied by scalars""""""\r\n        x = tf.Variable(0.43316321)\r\n        y = tf.Variable(0.2162158)\r\n        z = tf.Variable(0.75110998)\r\n\r\n        dev = qml.device(""default.qubit.tf"", wires=1)\r\n\r\n        @qml.qnode(dev, interface=""tf"", diff_method=""backprop"")\r\n        def circuit(p):\r\n            qml.RX(3 * p[0], wires=0)\r\n            qml.RY(p[1], wires=0)\r\n            qml.RX(p[2] / 2, wires=0)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        with tf.GradientTape() as tape:\r\n            res = circuit([x, y, z])\r\n\r\n        expected = tf.math.cos(3 * x) * tf.math.cos(y) * tf.math.cos(z / 2) - tf.math.sin(\r\n            3 * x\r\n        ) * tf.math.sin(z / 2)\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n        res = tf.concat(tape.jacobian(res, [x, y, z]), axis=0)\r\n\r\n        expected = np.array(\r\n            [\r\n                -3\r\n                * (\r\n                    tf.math.sin(3 * x) * tf.math.cos(y) * tf.math.cos(z / 2)\r\n                    + tf.math.cos(3 * x) * tf.math.sin(z / 2)\r\n                ),\r\n                -tf.math.cos(3 * x) * tf.math.sin(y) * tf.math.cos(z / 2),\r\n                -0.5\r\n                * (\r\n                    tf.math.sin(3 * x) * tf.math.cos(z / 2)\r\n                    + tf.math.cos(3 * x) * tf.math.cos(y) * tf.math.sin(z / 2)\r\n                ),\r\n            ]\r\n        )\r\n\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_jacobian_repeated(self, tol):\r\n        """"""Test that jacobian of a QNode with an attached default.qubit.tf device\r\n        gives the correct result in the case of repeated parameters""""""\r\n        x = 0.43316321\r\n        y = 0.2162158\r\n        z = 0.75110998\r\n        p = tf.Variable([x, y, z])\r\n        dev = qml.device(""default.qubit.tf"", wires=1)\r\n\r\n        @qml.qnode(dev, interface=""tf"", diff_method=""backprop"")\r\n        def circuit(x):\r\n            qml.RX(x[1], wires=0)\r\n            qml.Rot(x[0], x[1], x[2], wires=0)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        with tf.GradientTape() as tape:\r\n            res = circuit(p)\r\n\r\n        expected = np.cos(y) ** 2 - np.sin(x) * np.sin(y) ** 2\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n        res = tape.jacobian(res, p)\r\n\r\n        expected = np.array(\r\n            [-np.cos(x) * np.sin(y) ** 2, -2 * (np.sin(x) + 1) * np.sin(y) * np.cos(y), 0]\r\n        )\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_jacobian_agrees_backprop_parameter_shift(self, tol):\r\n        """"""Test that jacobian of a QNode with an attached default.qubit.tf device\r\n        gives the correct result with respect to the parameter-shift method""""""\r\n        p = np.array([0.43316321, 0.2162158, 0.75110998, 0.94714242])\r\n\r\n        def circuit(x):\r\n            for i in range(0, len(p), 2):\r\n                qml.RX(x[i], wires=0)\r\n                qml.RY(x[i + 1], wires=1)\r\n            for i in range(2):\r\n                qml.CNOT(wires=[i, i + 1])\r\n            return qml.expval(qml.PauliZ(0)), qml.var(qml.PauliZ(1))\r\n\r\n        dev1 = qml.device(""default.qubit.tf"", wires=3)\r\n        dev2 = qml.device(""default.qubit.tf"", wires=3)\r\n\r\n        circuit1 = qml.QNode(circuit, dev1, diff_method=""backprop"", interface=""tf"")\r\n        circuit2 = qml.QNode(circuit, dev2, diff_method=""parameter-shift"")\r\n\r\n        p_tf = tf.Variable(p)\r\n        with tf.GradientTape() as tape:\r\n            res = circuit1(p_tf)\r\n\r\n        assert np.allclose(res, circuit2(p), atol=tol, rtol=0)\r\n\r\n        res = tape.jacobian(res, p_tf)\r\n        assert np.allclose(res, circuit2.jacobian([p]), atol=tol, rtol=0)\r\n\r\n    def test_state_differentiability(self, tol):\r\n        """"""Test that the device state can be differentiated""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=1)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit(a):\r\n            qml.RY(a, wires=0)\r\n            return qml.expval(qml.PauliZ(0))\r\n\r\n        a = tf.Variable(0.54)\r\n\r\n        with tf.GradientTape() as tape:\r\n            circuit(a)\r\n            res = tf.abs(dev.state) ** 2\r\n            res = res[1] - res[0]\r\n\r\n        grad = tape.gradient(res, a)\r\n        expected = tf.sin(a)\r\n        assert np.allclose(grad, expected, atol=tol, rtol=0)\r\n\r\n    def test_prob_differentiability(self, tol):\r\n        """"""Test that the device probability can be differentiated""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=2)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit(a, b):\r\n            qml.RX(a, wires=0)\r\n            qml.RY(b, wires=1)\r\n            qml.CNOT(wires=[0, 1])\r\n            return qml.probs(wires=[1])\r\n\r\n        a = tf.Variable(0.54)\r\n        b = tf.Variable(0.12)\r\n\r\n        with tf.GradientTape() as tape:\r\n            # get the probability of wire 1\r\n            prob_wire_1 = circuit(a, b)[0]\r\n            # compute Prob(|1>_1) - Prob(|0>_1)\r\n            res = prob_wire_1[1] - prob_wire_1[0]\r\n\r\n        expected = -tf.cos(a) * tf.cos(b)\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n        grad = tape.gradient(res, [a, b])\r\n        expected = [tf.sin(a) * tf.cos(b), tf.cos(a) * tf.sin(b)]\r\n        assert np.allclose(grad, expected, atol=tol, rtol=0)\r\n\r\n    def test_backprop_gradient(self, tol):\r\n        """"""Tests that the gradient of the qnode is correct""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=2)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit(a, b):\r\n            qml.RX(a, wires=0)\r\n            qml.CRX(b, wires=[0, 1])\r\n            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n\r\n        a = -0.234\r\n        b = 0.654\r\n\r\n        a_tf = tf.Variable(a, dtype=tf.float64)\r\n        b_tf = tf.Variable(b, dtype=tf.float64)\r\n\r\n        with tf.GradientTape() as tape:\r\n            tape.watch([a_tf, b_tf])\r\n            res = circuit(a_tf, b_tf)\r\n\r\n        # the analytic result of evaluating circuit(a, b)\r\n        expected_cost = 0.5 * (np.cos(a) * np.cos(b) + np.cos(a) - np.cos(b) + 1)\r\n\r\n        # the analytic result of evaluating grad(circuit(a, b))\r\n        expected_grad = np.array(\r\n            [-0.5 * np.sin(a) * (np.cos(b) + 1), 0.5 * np.sin(b) * (1 - np.cos(a))]\r\n        )\r\n\r\n        assert np.allclose(res.numpy(), expected_cost, atol=tol, rtol=0)\r\n\r\n        res = tape.gradient(res, [a_tf, b_tf])\r\n        assert np.allclose(res, expected_grad, atol=tol, rtol=0)\r\n\r\n    @pytest.mark.parametrize(""operation"", [qml.U3, qml.U3.decomposition])\r\n    @pytest.mark.parametrize(""diff_method"", [""backprop"", ""parameter-shift"", ""finite-diff""])\r\n    def test_tf_interface_gradient(self, operation, diff_method, tol):\r\n        """"""Tests that the gradient of an arbitrary U3 gate is correct\r\n        using the TensorFlow interface, using a variety of differentiation methods.""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=1)\r\n\r\n        @qml.qnode(dev, diff_method=diff_method, interface=""tf"")\r\n        def circuit(x, weights, w=None):\r\n            """"""In this example, a mixture of scalar\r\n            arguments, array arguments, and keyword arguments are used.""""""\r\n            qml.QubitStateVector(1j * np.array([1, -1]) / np.sqrt(2), wires=w)\r\n            operation(x, weights[0], weights[1], wires=w)\r\n            return qml.expval(qml.PauliX(w))\r\n\r\n        # Check that the correct QNode type is being used.\r\n        if diff_method == ""backprop"":\r\n            assert isinstance(circuit, qml.qnodes.PassthruQNode)\r\n            assert not hasattr(circuit, ""jacobian"")\r\n        else:\r\n            assert not isinstance(circuit, qml.qnodes.PassthruQNode)\r\n            assert hasattr(circuit, ""jacobian"")\r\n\r\n        def cost(params):\r\n            """"""Perform some classical processing""""""\r\n            return circuit(params[0], params[1:], w=0) ** 2\r\n\r\n        theta = 0.543\r\n        phi = -0.234\r\n        lam = 0.654\r\n\r\n        params = tf.Variable([theta, phi, lam], dtype=tf.float64)\r\n\r\n        with tf.GradientTape() as tape:\r\n            tape.watch(params)\r\n            res = cost(params)\r\n\r\n        # check that the result is correct\r\n        expected_cost = (np.sin(lam) * np.sin(phi) - np.cos(theta) * np.cos(lam) * np.cos(phi)) ** 2\r\n        assert np.allclose(res.numpy(), expected_cost, atol=tol, rtol=0)\r\n\r\n        res = tape.gradient(res, params)\r\n\r\n        # check that the gradient is correct\r\n        expected_grad = (\r\n            np.array(\r\n                [\r\n                    np.sin(theta) * np.cos(lam) * np.cos(phi),\r\n                    np.cos(theta) * np.cos(lam) * np.sin(phi) + np.sin(lam) * np.cos(phi),\r\n                    np.cos(theta) * np.sin(lam) * np.cos(phi) + np.cos(lam) * np.sin(phi),\r\n                ]\r\n            )\r\n            * 2\r\n            * (np.sin(lam) * np.sin(phi) - np.cos(theta) * np.cos(lam) * np.cos(phi))\r\n        )\r\n        assert np.allclose(res.numpy(), expected_grad, atol=tol, rtol=0)\r\n\r\n    @pytest.mark.parametrize(""interface"", [""autograd"", ""torch""])\r\n    def test_error_backprop_wrong_interface(self, interface, tol):\r\n        """"""Tests that an error is raised if diff_method=\'backprop\' but not using\r\n        the TF interface""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=1)\r\n\r\n        def circuit(x, w=None):\r\n            qml.RZ(x, wires=w)\r\n            return qml.expval(qml.PauliX(w))\r\n\r\n        with pytest.raises(\r\n            ValueError,\r\n            match=""default.qubit.tf only supports diff_method=\'backprop\' when using the tf interface"",\r\n        ):\r\n            qml.qnode(dev, diff_method=""backprop"", interface=interface)(circuit)\r\n\r\n\r\nclass TestSamplesNonAnalytic:\r\n    """"""Tests for sampling and non-analytic mode""""""\r\n\r\n    def test_sample_observables(self):\r\n        """"""Test that the device allows for sampling from observables.""""""\r\n        shots = 100\r\n        dev = qml.device(""default.qubit.tf"", wires=2, shots=shots)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit(a):\r\n            qml.RX(a, wires=0)\r\n            return qml.sample(qml.PauliZ(0))\r\n\r\n        a = tf.Variable(0.54)\r\n        res = circuit(a)\r\n\r\n        assert isinstance(res, tf.Tensor)\r\n        assert res.shape == (1, shots)\r\n        assert set(res[0].numpy()) == {-1, 1}\r\n\r\n    def test_sample_observables_non_differentiable(self):\r\n        """"""Test that sampled observables cannot be differentiated.""""""\r\n        shots = 100\r\n        dev = qml.device(""default.qubit.tf"", wires=2, shots=shots)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit(a):\r\n            qml.RX(a, wires=0)\r\n            return qml.sample(qml.PauliZ(0))\r\n\r\n        a = tf.Variable(0.54)\r\n\r\n        with tf.GradientTape() as tape:\r\n            res = circuit(a)\r\n\r\n        assert tape.gradient(res, a) is None\r\n\r\n    def test_estimating_marginal_probability(self, tol):\r\n        """"""Test that the probability of a subset of wires is accurately estimated.""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=2, analytic=False, shots=1000)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit():\r\n            qml.PauliX(0)\r\n            return qml.probs(wires=[0])\r\n\r\n        res = circuit()\r\n\r\n        assert isinstance(res, tf.Tensor)\r\n\r\n        expected = np.array([0, 1])\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_estimating_full_probability(self, tol):\r\n        """"""Test that the probability of a subset of wires is accurately estimated.""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=2, analytic=False, shots=1000)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit():\r\n            qml.PauliX(0)\r\n            qml.PauliX(1)\r\n            return qml.probs(wires=[0, 1])\r\n\r\n        res = circuit()\r\n\r\n        assert isinstance(res, tf.Tensor)\r\n\r\n        expected = np.array([0, 0, 0, 1])\r\n        assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_estimating_expectation_values(self, tol):\r\n        """"""Test that estimating expectation values using a finite number\r\n        of shots produces a numeric tensor""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3, analytic=False, shots=1000)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit(a, b):\r\n            qml.RX(a, wires=[0])\r\n            qml.RX(b, wires=[1])\r\n            qml.CNOT(wires=[0, 1])\r\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\r\n\r\n        a = tf.Variable(0.543)\r\n        b = tf.Variable(0.43)\r\n\r\n        res = circuit(a, b)\r\n        assert isinstance(res, tf.Tensor)\r\n\r\n        # We don\'t check the expected value due to stochasticity, but\r\n        # leave it here for completeness.\r\n        # expected = [tf.cos(a), tf.cos(a) * tf.cos(b)]\r\n        # assert np.allclose(res, expected, atol=tol, rtol=0)\r\n\r\n    def test_estimating_expectation_values_not_differentiable(self, tol):\r\n        """"""Test that analytic=False results in non-differentiable QNodes""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=3, analytic=False)\r\n\r\n        @qml.qnode(dev, diff_method=""backprop"", interface=""tf"")\r\n        def circuit(a, b):\r\n            qml.RX(a, wires=[0])\r\n            qml.RX(b, wires=[1])\r\n            qml.CNOT(wires=[0, 1])\r\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\r\n\r\n        a = tf.Variable(0.543)\r\n        b = tf.Variable(0.43)\r\n\r\n        with tf.GradientTape() as tape:\r\n            res = circuit(a, b)\r\n\r\n        assert isinstance(res, tf.Tensor)\r\n        grad = tape.gradient(res, [a, b])\r\n        assert grad == [None, None]\r\n\r\n\r\nclass TestHighLevelIntegration:\r\n    """"""Tests for integration with higher level components of PennyLane.""""""\r\n\r\n    def test_qnode_collection_integration(self):\r\n        """"""Test that a PassthruQNode default.qubit.tf works with QNodeCollections.""""""\r\n        dev = qml.device(""default.qubit.tf"", wires=2)\r\n\r\n        obs_list = [qml.PauliX(0) @ qml.PauliY(1), qml.PauliZ(0), qml.PauliZ(0) @ qml.PauliZ(1)]\r\n        qnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev, interface=""tf"")\r\n\r\n        assert qnodes.interface == ""tf""\r\n\r\n        weights = tf.Variable(qml.init.strong_ent_layers_normal(n_wires=2, n_layers=2))\r\n\r\n        @tf.function\r\n        def cost(weights):\r\n            return tf.reduce_sum(qnodes(weights))\r\n\r\n        with tf.GradientTape() as tape:\r\n            res = qnodes(weights)\r\n\r\n        grad = tape.gradient(res, weights)\r\n\r\n        assert isinstance(grad, tf.Tensor)\r\n        assert grad.shape == weights.shape\r\n'"
tests/qnn/conftest.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nCommon fixtures for the qnn module.\n""""""\nimport pytest\nimport pennylane as qml\n\n\n@pytest.fixture\ndef get_circuit(n_qubits, output_dim, interface):\n    """"""Fixture for getting a sample quantum circuit with a controllable qubit number and output\n    dimension. Returns both the circuit and the shape of the weights.""""""\n\n    dev = qml.device(""default.qubit"", wires=n_qubits)\n    weight_shapes = {\n        ""w1"": (3, n_qubits, 3),\n        ""w2"": (1,),\n        ""w3"": 1,\n        ""w4"": [3],\n        ""w5"": (2, n_qubits, 3),\n        ""w6"": 3,\n        ""w7"": 0,\n    }\n\n    @qml.qnode(dev, interface=interface)\n    def circuit(inputs, w1, w2, w3, w4, w5, w6, w7):\n        """"""A circuit that embeds data using the AngleEmbedding and then performs a variety of\n        operations. The output is a PauliZ measurement on the first output_dim qubits. One set of\n        parameters, w5, are specified as non-trainable.""""""\n        qml.templates.AngleEmbedding(inputs, wires=list(range(n_qubits)))\n        qml.templates.StronglyEntanglingLayers(w1, wires=list(range(n_qubits)))\n        qml.RX(w2[0], wires=0 % n_qubits)\n        qml.RX(w3, wires=1 % n_qubits)\n        qml.Rot(*w4, wires=2 % n_qubits)\n        qml.templates.StronglyEntanglingLayers(w5, wires=list(range(n_qubits)))\n        qml.Rot(*w6, wires=3 % n_qubits)\n        qml.RX(w7, wires=4 % n_qubits)\n        return [qml.expval(qml.PauliZ(i)) for i in range(output_dim)]\n\n    return circuit, weight_shapes\n'"
tests/qnn/test_cost.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nTests for the pennylane.qnn.cost module.\n""""""\nimport numpy as np\nimport pennylane as qml\nimport pytest\n\nfrom pennylane.qnn.cost import SquaredErrorLoss\n\n\ndef rx_ansatz(phis, **kwargs):\n    for w, phi in enumerate(phis):\n        qml.RX(phi, wires=w)\n\n\ndef layer_ansatz(weights, x=None, **kwargs):\n    qml.templates.AngleEmbedding(x, wires=[0, 1, 2])\n    qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1, 2])\n\n\n@pytest.fixture\ndef skip_if_no_torch_support():\n    """"""Overrides the skip_if_no_torch_support in the main conftest to also skip if torch is\n    present but is version 1.3 or earlier""""""\n    pytest.importorskip(""torch"", minversion=""1.4"")\n\n\n@pytest.mark.parametrize(""interface"", qml.qnodes.decorator.ALLOWED_INTERFACES)\n@pytest.mark.usefixtures(""skip_if_no_torch_support"", ""skip_if_no_tf_support"")\nclass TestSquaredErrorLoss:\n    def test_no_target(self, interface):\n        with pytest.raises(ValueError, match=""The target cannot be None""):\n            num_qubits = 1\n\n            dev = qml.device(""default.qubit"", wires=num_qubits)\n            observables = [qml.PauliZ(0)]\n            loss = SquaredErrorLoss(rx_ansatz, observables, dev, interface=interface)\n\n            phis = np.ones(num_qubits)\n            loss(phis)\n\n    def test_invalid_target(self, interface):\n        with pytest.raises(ValueError, match=""Input target of incorrect length 2 instead of 1""):\n            num_qubits = 1\n\n            dev = qml.device(""default.qubit"", wires=num_qubits)\n            observables = [qml.PauliZ(0)]\n            loss = SquaredErrorLoss(rx_ansatz, observables, dev, interface=interface)\n\n            phis = np.ones(num_qubits)\n            loss(phis, target=np.array([1.0, 2.0]))\n\n    def test_layer_circuit(self, interface):\n        num_qubits = 3\n\n        dev = qml.device(""default.qubit"", wires=num_qubits)\n        observables = [qml.PauliZ(0), qml.PauliX(0), qml.PauliZ(1) @ qml.PauliZ(2)]\n        loss = SquaredErrorLoss(layer_ansatz, observables, dev, interface=interface)\n\n        weights = np.ones((num_qubits, 3, 3))\n        res = loss(weights, x=np.array([1.0, 2.0, 1.0]), target=np.array([1.0, 0.5, 0.1]))\n\n        assert np.allclose(res, np.array([0.88, 0.83, 0.05]), atol=0.01, rtol=0.01)\n\n    def test_rx_circuit(self, interface):\n        num_qubits = 3\n\n        dev = qml.device(""default.qubit"", wires=num_qubits)\n        observables = [qml.PauliZ(0), qml.PauliX(0), qml.PauliZ(1) @ qml.PauliZ(2)]\n        loss = SquaredErrorLoss(rx_ansatz, observables, dev, interface=interface)\n\n        phis = np.ones(num_qubits)\n        res = loss(phis, target=np.array([1.0, 0.5, 0.1]))\n\n        assert np.allclose(res, np.array([0.21, 0.25, 0.03]), atol=0.01, rtol=0.01)\n'"
tests/qnn/test_keras.py,19,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nTests for the pennylane.qnn.keras module.\n""""""\nimport numpy as np\nimport pytest\n\nimport pennylane as qml\nfrom pennylane.qnn.keras import KerasLayer\n\ntf = pytest.importorskip(""tensorflow"", minversion=""2"")\n\n\n@pytest.mark.usefixtures(""get_circuit"")\n@pytest.fixture\ndef model(get_circuit, n_qubits, output_dim):\n    """"""Fixture for creating a hybrid Keras model. The model is composed of KerasLayers sandwiched\n    between Dense layers.""""""\n    c, w = get_circuit\n    layer1 = KerasLayer(c, w, output_dim)\n    layer2 = KerasLayer(c, w, output_dim)\n\n    model = tf.keras.models.Sequential(\n        [\n            tf.keras.layers.Dense(n_qubits),\n            layer1,\n            tf.keras.layers.Dense(n_qubits),\n            layer2,\n            tf.keras.layers.Dense(output_dim),\n        ]\n    )\n\n    return model\n\n\ndef indices_up_to(n_max):\n    """"""Returns an iterator over the number of qubits and output dimension, up to value n_max.\n    The output dimension never exceeds the number of qubits.""""""\n    a, b = np.tril_indices(n_max)\n    return zip(*[a + 1, b + 1])\n\n\n@pytest.mark.parametrize(""interface"", [""tf""])  # required for the get_circuit fixture\n@pytest.mark.usefixtures(""get_circuit"")\nclass TestKerasLayer:\n    """"""Unit tests for the pennylane.qnn.keras.KerasLayer class.""""""\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_bad_tf_version(self, get_circuit, output_dim, monkeypatch):\n        """"""Test if an ImportError is raised when instantiated with an incorrect version of\n        TensorFlow""""""\n        c, w = get_circuit\n        with monkeypatch.context() as m:\n            m.setattr(qml.qnn.keras, ""CORRECT_TF_VERSION"", False)\n            with pytest.raises(ImportError, match=""KerasLayer requires TensorFlow version 2""):\n                KerasLayer(c, w, output_dim)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_no_input(self, get_circuit, output_dim):\n        """"""Test if a TypeError is raised when instantiated with a QNode that does not have an\n        argument with name equal to the input_arg class attribute of KerasLayer""""""\n        c, w = get_circuit\n        del c.func.sig[qml.qnn.keras.KerasLayer._input_arg]\n        with pytest.raises(TypeError, match=""QNode must include an argument with name""):\n            KerasLayer(c, w, output_dim)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_input_in_weight_shapes(self, get_circuit, n_qubits, output_dim):\n        """"""Test if a ValueError is raised when instantiated with a weight_shapes dictionary that\n        contains the shape of the input argument given by the input_arg class attribute of\n        KerasLayer""""""\n        c, w = get_circuit\n        w[qml.qnn.keras.KerasLayer._input_arg] = n_qubits\n        with pytest.raises(\n            ValueError,\n            match=""{} argument should not have its dimension"".format(\n                qml.qnn.keras.KerasLayer._input_arg\n            ),\n        ):\n            KerasLayer(c, w, output_dim)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_weight_shape_unspecified(self, get_circuit, output_dim):\n        """"""Test if a ValueError is raised when instantiated with a weight missing from the\n        weight_shapes dictionary""""""\n        c, w = get_circuit\n        del w[""w1""]\n        with pytest.raises(ValueError, match=""Must specify a shape for every non-input parameter""):\n            KerasLayer(c, w, output_dim)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_var_pos(self, get_circuit, monkeypatch, output_dim):\n        """"""Test if a TypeError is raised when instantiated with a variable number of positional\n        arguments""""""\n        c, w = get_circuit\n\n        class FuncPatch:\n            """"""Patch for variable number of keyword arguments""""""\n\n            sig = c.func.sig\n            var_pos = True\n            var_keyword = False\n\n        with monkeypatch.context() as m:\n            m.setattr(c, ""func"", FuncPatch)\n\n            with pytest.raises(TypeError, match=""Cannot have a variable number of positional""):\n                KerasLayer(c, w, output_dim)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_var_keyword(self, get_circuit, monkeypatch, output_dim):\n        """"""Test if a TypeError is raised when instantiated with a variable number of keyword\n        arguments""""""\n        c, w = get_circuit\n\n        class FuncPatch:\n            """"""Patch for variable number of keyword arguments""""""\n\n            sig = c.func.sig\n            var_pos = False\n            var_keyword = True\n\n        with monkeypatch.context() as m:\n            m.setattr(c, ""func"", FuncPatch)\n\n            with pytest.raises(TypeError, match=""Cannot have a variable number of keyword""):\n                KerasLayer(c, w, output_dim)\n\n    @pytest.mark.parametrize(""n_qubits"", [1])\n    @pytest.mark.parametrize(""output_dim"", zip(*[[[1], (1,), 1], [1, 1, 1]]))\n    def test_output_dim(self, get_circuit, output_dim):\n        """"""Test if the output_dim is correctly processed, i.e., that an iterable is mapped to\n        its first element while an int is left unchanged.""""""\n        c, w = get_circuit\n        layer = KerasLayer(c, w, output_dim[0])\n        assert layer.output_dim == output_dim[1]\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_weight_shapes(self, get_circuit, output_dim, n_qubits):\n        """"""Test if the weight_shapes input argument is correctly processed to be a dictionary\n        with values that are tuples.""""""\n        c, w = get_circuit\n        layer = KerasLayer(c, w, output_dim)\n        assert layer.weight_shapes == {\n            ""w1"": (3, n_qubits, 3),\n            ""w2"": (1,),\n            ""w3"": (),\n            ""w4"": (3,),\n            ""w5"": (2, n_qubits, 3),\n            ""w6"": (3,),\n            ""w7"": (),\n        }\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_non_input_defaults(self, get_circuit, output_dim, n_qubits):\n        """"""Test if a TypeError is raised when default arguments that are not the input argument are\n        present in the QNode""""""\n        c, w = get_circuit\n\n        @qml.qnode(qml.device(""default.qubit"", wires=n_qubits), interface=""tf"")\n        def c_dummy(inputs, w1, w2, w3, w4, w5, w6, w7, w8=None):\n            """"""Dummy version of the circuit with a default argument""""""\n            return c(inputs, w1, w2, w3, w4, w5, w6, w7)\n\n        with pytest.raises(\n            TypeError,\n            match=""Only the argument {} is permitted"".format(qml.qnn.keras.KerasLayer._input_arg),\n        ):\n            KerasLayer(c_dummy, {**w, **{""w8"": 1}}, output_dim)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_qnode_weights(self, get_circuit, n_qubits, output_dim):\n        """"""Test if the build() method correctly initializes the weights in the qnode_weights\n        dictionary, i.e., that each value of the dictionary has correct shape and name.""""""\n        c, w = get_circuit\n        layer = KerasLayer(c, w, output_dim)\n        layer.build(input_shape=(10, n_qubits))\n\n        for weight, shape in layer.weight_shapes.items():\n            assert layer.qnode_weights[weight].shape == shape\n            assert layer.qnode_weights[weight].name[:-2] == weight\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_qnode_weights_with_spec(self, get_circuit, monkeypatch, output_dim, n_qubits):\n        """"""Test if the build() method correctly passes on user specified weight_specs to the\n        inherited add_weight() method. This is done by monkeypatching add_weight() so that it\n        simply returns its input keyword arguments. The qnode_weights dictionary should then have\n        values that are the input keyword arguments, and we check that the specified weight_specs\n        keywords are there.""""""\n\n        def add_weight_dummy(*args, **kwargs):\n            """"""Dummy function for mocking out the add_weight method to simply return the input\n            keyword arguments""""""\n            return kwargs\n\n        weight_specs = {\n            ""w1"": {""initializer"": ""random_uniform"", ""trainable"": False},\n            ""w2"": {""initializer"": tf.keras.initializers.RandomNormal(mean=0, stddev=0.5)},\n            ""w3"": {},\n            ""w4"": {},\n            ""w5"": {},\n            ""w6"": {},\n            ""w7"": {},\n        }\n\n        with monkeypatch.context() as m:\n            m.setattr(tf.keras.layers.Layer, ""add_weight"", add_weight_dummy)\n            c, w = get_circuit\n            layer = KerasLayer(c, w, output_dim, weight_specs=weight_specs)\n            layer.build(input_shape=(10, n_qubits))\n\n            for weight in layer.weight_shapes:\n                assert all(\n                    item in layer.qnode_weights[weight].items()\n                    for item in weight_specs[weight].items()\n                )\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(3))\n    @pytest.mark.parametrize(""input_shape"", [(10, 4), (8, 3)])\n    def test_compute_output_shape(self, get_circuit, output_dim, input_shape):\n        """"""Test if the compute_output_shape() method performs correctly, i.e., that it replaces\n        the last element in the input_shape tuple with the specified output_dim and that the\n        output shape is of type tf.TensorShape""""""\n        c, w = get_circuit\n        layer = KerasLayer(c, w, output_dim)\n\n        assert layer.compute_output_shape(input_shape) == (input_shape[0], output_dim)\n        assert isinstance(layer.compute_output_shape(input_shape), tf.TensorShape)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    @pytest.mark.parametrize(""batch_size"", [2])\n    def test_call(self, get_circuit, output_dim, batch_size, n_qubits):\n        """"""Test if the call() method performs correctly, i.e., that it outputs with shape\n        (batch_size, output_dim) with results that agree with directly calling the QNode""""""\n        c, w = get_circuit\n        layer = KerasLayer(c, w, output_dim)\n        x = tf.ones((batch_size, n_qubits))\n\n        layer_out = layer(x)\n        weights = [w.numpy() for w in layer.qnode_weights.values()]\n        assert layer_out.shape == (batch_size, output_dim)\n        assert np.allclose(layer_out[0], c(x[0], *weights))\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    @pytest.mark.parametrize(""batch_size"", [2])\n    def test_call_shuffled_args(self, get_circuit, output_dim, batch_size, n_qubits):\n        """"""Test if the call() method performs correctly when the inputs argument is not the first\n        positional argument, i.e., that it outputs with shape (batch_size, output_dim) with\n        results that agree with directly calling the QNode""""""\n        c, w = get_circuit\n\n        @qml.qnode(qml.device(""default.qubit"", wires=n_qubits), interface=""tf"")\n        def c_shuffled(w1, inputs, w2, w3, w4, w5, w6, w7):\n            """"""Version of the circuit with a shuffled signature""""""\n            qml.templates.AngleEmbedding(inputs, wires=list(range(n_qubits)))\n            qml.templates.StronglyEntanglingLayers(w1, wires=list(range(n_qubits)))\n            qml.RX(w2[0], wires=0)\n            qml.RX(w3, wires=0)\n            qml.Rot(*w4, wires=0)\n            qml.templates.StronglyEntanglingLayers(w5, wires=list(range(n_qubits)))\n            qml.Rot(*w6, wires=0)\n            qml.RX(w7, wires=0)\n            return [qml.expval(qml.PauliZ(i)) for i in range(output_dim)]\n\n        layer = KerasLayer(c_shuffled, w, output_dim)\n        x = tf.ones((batch_size, n_qubits))\n\n        layer_out = layer(x)\n        weights = [w.numpy() for w in layer.qnode_weights.values()]\n\n        assert layer_out.shape == (batch_size, output_dim)\n        assert np.allclose(layer_out[0], c(x[0], *weights))\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    @pytest.mark.parametrize(""batch_size"", [2])\n    def test_call_default_input(self, get_circuit, output_dim, batch_size, n_qubits):\n        """"""Test if the call() method performs correctly when the inputs argument is a default\n        argument, i.e., that it outputs with shape (batch_size, output_dim) with results that\n        agree with directly calling the QNode""""""\n        c, w = get_circuit\n\n        @qml.qnode(qml.device(""default.qubit"", wires=n_qubits), interface=""tf"")\n        def c_default(w1, w2, w3, w4, w5, w6, w7, inputs=None):\n            """"""Version of the circuit with inputs as a default argument""""""\n            qml.templates.AngleEmbedding(inputs, wires=list(range(n_qubits)))\n            qml.templates.StronglyEntanglingLayers(w1, wires=list(range(n_qubits)))\n            qml.RX(w2[0], wires=0)\n            qml.RX(w3, wires=0)\n            qml.Rot(*w4, wires=0)\n            qml.templates.StronglyEntanglingLayers(w5, wires=list(range(n_qubits)))\n            qml.Rot(*w6, wires=0)\n            qml.RX(w7, wires=0)\n            return [qml.expval(qml.PauliZ(i)) for i in range(output_dim)]\n\n        layer = KerasLayer(c_default, w, output_dim)\n        x = tf.ones((batch_size, n_qubits))\n\n        layer_out = layer(x)\n        weights = [w.numpy() for w in layer.qnode_weights.values()]\n\n        assert layer_out.shape == (batch_size, output_dim)\n        assert np.allclose(layer_out[0], c(x[0], *weights))\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_str_repr(self, get_circuit, output_dim):\n        """"""Test the __str__ and __repr__ representations""""""\n        c, w = get_circuit\n        layer = KerasLayer(c, w, output_dim)\n\n        assert layer.__str__() == ""<Quantum Keras Layer: func=circuit>""\n        assert layer.__repr__() == ""<Quantum Keras Layer: func=circuit>""\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_gradients(self, get_circuit, output_dim, n_qubits):\n        """"""Test if the gradients of the KerasLayer are equal to the gradients of the circuit when\n        taken with respect to the trainable variables""""""\n        c, w = get_circuit\n        layer = KerasLayer(c, w, output_dim)\n        x = tf.ones((1, n_qubits))\n\n        with tf.GradientTape() as tape:\n            out_layer = layer(x)\n\n        g_layer = tape.gradient(out_layer, layer.trainable_variables)\n\n        with tf.GradientTape() as tape:\n            out_circuit = c(x[0], *layer.trainable_variables)\n\n        g_circuit = tape.gradient(out_circuit, layer.trainable_variables)\n\n        for i in range(len(out_layer)):\n            assert np.allclose(g_layer[i], g_circuit[i])\n\n\n@pytest.mark.parametrize(""interface"", qml.qnodes.decorator.ALLOWED_INTERFACES)\n@pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n@pytest.mark.usefixtures(""get_circuit"")\n@pytest.mark.usefixtures(""skip_if_no_torch_support"")\ndef test_interface_conversion(get_circuit, output_dim, skip_if_no_torch_support):\n    """"""Test if input QNodes with all types of interface are converted internally to the TensorFlow\n    interface""""""\n    c, w = get_circuit\n    layer = KerasLayer(c, w, output_dim)\n    assert layer.qnode.interface == ""tf""\n\n\n@pytest.mark.parametrize(""interface"", [""tf""])\n@pytest.mark.usefixtures(""get_circuit"", ""model"")\nclass TestKerasLayerIntegration:\n    """"""Integration tests for the pennylane.qnn.keras.KerasLayer class.""""""\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    @pytest.mark.parametrize(""batch_size"", [2])\n    def test_train_model(self, model, batch_size, n_qubits, output_dim):\n        """"""Test if a model can train using the KerasLayer. The model is composed of two\n        KerasLayers sandwiched between Dense neural network layers, and the dataset is simply\n        input and output vectors of zeros.""""""\n\n        x = np.zeros((batch_size, n_qubits))\n        y = np.zeros((batch_size, output_dim))\n\n        model.compile(optimizer=""sgd"", loss=""mse"")\n\n        model.fit(x, y, batch_size=batch_size, verbose=0)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_model_gradients(self, model, output_dim, n_qubits):\n        """"""Test if a gradient can be calculated with respect to all of the trainable variables in\n        the model""""""\n        x = tf.zeros((2, n_qubits))\n        y = tf.zeros((2, output_dim))\n\n        with tf.GradientTape() as tape:\n            out = model(x)\n            loss = tf.keras.losses.mean_squared_error(out, y)\n\n        gradients = tape.gradient(loss, model.trainable_variables)\n        assert all([g.dtype == tf.keras.backend.floatx() for g in gradients])\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_model_save_weights(self, model, n_qubits, tmpdir):\n        """"""Test if the model can be successfully saved and reloaded using the get_weights()\n        method""""""\n        prediction = model.predict(np.ones(n_qubits))\n        weights = model.get_weights()\n        file = str(tmpdir) + ""/model""\n        model.save_weights(file)\n        model.load_weights(file)\n        prediction_loaded = model.predict(np.ones(n_qubits))\n        weights_loaded = model.get_weights()\n\n        assert np.allclose(prediction, prediction_loaded)\n        for i, w in enumerate(weights):\n            assert np.allclose(w, weights_loaded[i])\n'"
tests/qnn/test_qnn_torch.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nTests for the pennylane.qnn.torch module.\n""""""\nfrom unittest import mock\nimport math\nimport numpy as np\nimport pytest\n\nimport pennylane as qml\nfrom pennylane.qnn.torch import TorchLayer\n\ntorch = pytest.importorskip(""torch"")\n\n\ndef indices_up_to(n_max):\n    """"""Returns an iterator over the number of qubits and output dimension, up to value n_max.\n    The output dimension never exceeds the number of qubits.""""""\n    a, b = np.tril_indices(n_max)\n    return zip(*[a + 1, b + 1])\n\n\n@pytest.mark.usefixtures(""get_circuit"")  # this fixture is in tests/qnn/conftest.py\n@pytest.fixture\ndef module(get_circuit, n_qubits, output_dim):\n    """"""Fixture for creating a hybrid Torch module. The module is composed of quantum TorchLayers\n    sandwiched between Linear layers.""""""\n    c, w = get_circuit\n\n    class Net(torch.nn.Module):\n        def __init__(self):\n            super().__init__()\n            self.clayer1 = torch.nn.Linear(n_qubits, n_qubits)\n            self.clayer2 = torch.nn.Linear(output_dim, n_qubits)\n            self.clayer3 = torch.nn.Linear(output_dim, output_dim)\n            self.qlayer1 = TorchLayer(c, w)\n            self.qlayer2 = TorchLayer(c, w)\n\n        def forward(self, x):\n            x = self.clayer1(x)\n            x = self.qlayer1(x)\n            x = self.clayer2(x)\n            x = self.qlayer2(x)\n            x = self.clayer3(x)\n            return x\n\n    return Net()\n\n\nordered_weights = [""w{}"".format(i) for i in range(1, 8)]  # we do this for Python 3.5\n\n\n@pytest.mark.parametrize(""interface"", [""torch""])  # required for the get_circuit fixture\n@pytest.mark.usefixtures(""get_circuit"")  # this fixture is in tests/qnn/conftest.py\nclass TestTorchLayer:\n    """"""Unit tests for the pennylane.qnn.torch.TorchLayer class.""""""\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_no_torch(self, get_circuit, monkeypatch):\n        """"""Test if an ImportError is raised when instantiated without PyTorch""""""\n        c, w = get_circuit\n        with monkeypatch.context() as m:\n            m.setattr(qml.qnn.torch, ""TORCH_IMPORTED"", False)\n            with pytest.raises(ImportError, match=""TorchLayer requires PyTorch""):\n                TorchLayer(c, w)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_no_input(self, get_circuit):\n        """"""Test if a TypeError is raised when instantiated with a QNode that does not have an\n        argument with name equal to the input_arg class attribute of TorchLayer""""""\n        c, w = get_circuit\n        del c.func.sig[qml.qnn.torch.TorchLayer._input_arg]\n        with pytest.raises(TypeError, match=""QNode must include an argument with name""):\n            TorchLayer(c, w)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_input_in_weight_shapes(self, get_circuit, n_qubits):\n        """"""Test if a ValueError is raised when instantiated with a weight_shapes dictionary that\n        contains the shape of the input argument given by the input_arg class attribute of\n        TorchLayer""""""\n        c, w = get_circuit\n        w[qml.qnn.torch.TorchLayer._input_arg] = n_qubits\n        with pytest.raises(\n            ValueError,\n            match=""{} argument should not have its dimension"".format(\n                qml.qnn.torch.TorchLayer._input_arg\n            ),\n        ):\n            TorchLayer(c, w)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_weight_shape_unspecified(self, get_circuit):\n        """"""Test if a ValueError is raised when instantiated with a weight missing from the\n        weight_shapes dictionary""""""\n        c, w = get_circuit\n        del w[""w1""]\n        with pytest.raises(ValueError, match=""Must specify a shape for every non-input parameter""):\n            TorchLayer(c, w)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_var_pos(self, get_circuit, monkeypatch):\n        """"""Test if a TypeError is raised when instantiated with a variable number of positional\n        arguments""""""\n        c, w = get_circuit\n\n        class FuncPatch:\n            """"""Patch for variable number of keyword arguments""""""\n\n            sig = c.func.sig\n            var_pos = True\n            var_keyword = False\n\n        with monkeypatch.context() as m:\n            m.setattr(c, ""func"", FuncPatch)\n\n            with pytest.raises(TypeError, match=""Cannot have a variable number of positional""):\n                TorchLayer(c, w)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_var_keyword(self, get_circuit, monkeypatch):\n        """"""Test if a TypeError is raised when instantiated with a variable number of keyword\n        arguments""""""\n        c, w = get_circuit\n\n        class FuncPatch:\n            """"""Patch for variable number of keyword arguments""""""\n\n            sig = c.func.sig\n            var_pos = False\n            var_keyword = True\n\n        with monkeypatch.context() as m:\n            m.setattr(c, ""func"", FuncPatch)\n\n            with pytest.raises(TypeError, match=""Cannot have a variable number of keyword""):\n                TorchLayer(c, w)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_nonspecified_init(self, get_circuit, n_qubits, monkeypatch):\n        """"""Test if weights are initialized according to the uniform distribution in [0, 2 pi]""""""\n        c, w = get_circuit\n\n        uniform_ = mock.MagicMock(return_value=torch.Tensor(1))\n        with monkeypatch.context() as m:\n            m.setattr(torch.nn.init, ""uniform_"", uniform_)\n            TorchLayer(c, w)\n            kwargs = uniform_.call_args[1]\n            assert kwargs[""b""] == 2 * math.pi\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_non_input_defaults(self, get_circuit, n_qubits):\n        """"""Test if a TypeError is raised when default arguments that are not the input argument are\n        present in the QNode""""""\n        c, w = get_circuit\n\n        @qml.qnode(qml.device(""default.qubit"", wires=n_qubits), interface=""torch"")\n        def c_dummy(inputs, w1, w2, w3, w4, w5, w6, w7, w8=None):\n            """"""Dummy version of the circuit with a default argument""""""\n            return c(inputs, w1, w2, w3, w4, w5, w6, w7)\n\n        with pytest.raises(\n            TypeError,\n            match=""Only the argument {} is permitted"".format(qml.qnn.torch.TorchLayer._input_arg),\n        ):\n            TorchLayer(c_dummy, {**w, **{""w8"": 1}})\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_qnode_weights_shapes(self, get_circuit, n_qubits):\n        """"""Test if the weights in qnode_weights have the correct shape""""""\n        c, w = get_circuit\n        layer = TorchLayer(c, w)\n\n        ideal_shapes = {\n            ""w1"": torch.Size((3, n_qubits, 3)),\n            ""w2"": torch.Size((1,)),\n            ""w3"": torch.Size([]),\n            ""w4"": torch.Size((3,)),\n            ""w5"": torch.Size((2, n_qubits, 3)),\n            ""w6"": torch.Size((3,)),\n            ""w7"": torch.Size([]),\n        }\n\n        for name, weight in layer.qnode_weights.items():\n            assert weight.shape == ideal_shapes[name]\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_qnode_weights_registered(self, get_circuit, n_qubits):\n        """"""Test if the weights in qnode_weights are registered to the internal _parameters\n        dictionary and that requires_grad == True""""""\n        c, w = get_circuit\n        layer = TorchLayer(c, w)\n\n        for name, weight in layer.qnode_weights.items():\n            assert torch.allclose(weight, layer._parameters[name])\n            assert weight.requires_grad\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_evaluate_qnode(self, get_circuit, n_qubits):\n        """"""Test if the _evaluate_qnode() method works correctly, i.e., that it gives the same\n        result as calling the QNode directly""""""\n        c, w = get_circuit\n        layer = TorchLayer(c, w)\n        x = torch.ones(n_qubits)\n\n        layer_out = layer._evaluate_qnode(x).detach().numpy()\n\n        weights = [layer.qnode_weights[weight].detach().numpy() for weight in ordered_weights]\n\n        circuit_out = c(x, *weights)\n        assert np.allclose(layer_out, circuit_out)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_evaluate_qnode_shuffled_args(self, get_circuit, output_dim, n_qubits):\n        """"""Test if the _evaluate_qnode() method works correctly when the inputs argument is not the\n        first positional argument, i.e., that it gives the same result as calling the QNode\n        directly""""""\n        c, w = get_circuit\n\n        @qml.qnode(qml.device(""default.qubit"", wires=n_qubits), interface=""torch"")\n        def c_shuffled(w1, inputs, w2, w3, w4, w5, w6, w7):\n            """"""Version of the circuit with a shuffled signature""""""\n            qml.templates.AngleEmbedding(inputs, wires=list(range(n_qubits)))\n            qml.templates.StronglyEntanglingLayers(w1, wires=list(range(n_qubits)))\n            qml.RX(w2[0], wires=0)\n            qml.RX(w3, wires=0)\n            qml.Rot(*w4, wires=0)\n            qml.templates.StronglyEntanglingLayers(w5, wires=list(range(n_qubits)))\n            qml.Rot(*w6, wires=0)\n            qml.RX(w7, wires=0)\n            return [qml.expval(qml.PauliZ(i)) for i in range(output_dim)]\n\n        layer = TorchLayer(c_shuffled, w)\n        x = torch.Tensor(np.ones(n_qubits))\n\n        layer_out = layer._evaluate_qnode(x).detach().numpy()\n\n        weights = [layer.qnode_weights[weight].detach().numpy() for weight in ordered_weights]\n\n        circuit_out = c(x, *weights)\n        assert np.allclose(layer_out, circuit_out)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_evaluate_qnode_default_input(self, get_circuit, output_dim, n_qubits):\n        """"""Test if the _evaluate_qnode() method works correctly when the inputs argument is a\n        default argument, i.e., that it gives the same result as calling the QNode directly""""""\n        c, w = get_circuit\n\n        @qml.qnode(qml.device(""default.qubit"", wires=n_qubits), interface=""torch"")\n        def c_default(w1, w2, w3, w4, w5, w6, w7, inputs=None):\n            """"""Version of the circuit with inputs as a default argument""""""\n            qml.templates.AngleEmbedding(inputs, wires=list(range(n_qubits)))\n            qml.templates.StronglyEntanglingLayers(w1, wires=list(range(n_qubits)))\n            qml.RX(w2[0], wires=0)\n            qml.RX(w3, wires=0)\n            qml.Rot(*w4, wires=0)\n            qml.templates.StronglyEntanglingLayers(w5, wires=list(range(n_qubits)))\n            qml.Rot(*w6, wires=0)\n            qml.RX(w7, wires=0)\n            return [qml.expval(qml.PauliZ(i)) for i in range(output_dim)]\n\n        layer = TorchLayer(c_default, w)\n        x = torch.Tensor(np.ones(n_qubits))\n\n        layer_out = layer._evaluate_qnode(x).detach().numpy()\n\n        weights = [layer.qnode_weights[weight].detach().numpy() for weight in ordered_weights]\n\n        circuit_out = c(x, *weights)\n        assert np.allclose(layer_out, circuit_out)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_forward_single_input(self, get_circuit, output_dim, n_qubits):\n        """"""Test if the forward() method accepts a single input (i.e., not with an extra batch\n        dimension) and returns a tensor of the right shape""""""\n        c, w = get_circuit\n        layer = TorchLayer(c, w)\n        x = torch.Tensor(np.ones(n_qubits))\n\n        layer_out = layer.forward(x)\n        assert layer_out.shape == torch.Size((output_dim,))\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_forward(self, get_circuit, output_dim, n_qubits):\n        """"""Test if the forward() method accepts a batched input and returns a tensor of the right\n        shape""""""\n        c, w = get_circuit\n        layer = TorchLayer(c, w)\n        x = torch.Tensor(np.ones((2, n_qubits)))\n\n        layer_out = layer.forward(x)\n        assert layer_out.shape == torch.Size((2, output_dim))\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_str_repr(self, get_circuit):\n        """"""Test the __str__ and __repr__ representations""""""\n        c, w = get_circuit\n        layer = TorchLayer(c, w)\n\n        assert layer.__str__() == ""<Quantum Torch Layer: func=circuit>""\n        assert layer.__repr__() == ""<Quantum Torch Layer: func=circuit>""\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_gradients(self, get_circuit, n_qubits):\n        """"""Test if the gradients of the TorchLayer are equal to the gradients of the circuit when\n        taken with respect to the trainable variables""""""\n        c, w = get_circuit\n        layer = TorchLayer(c, w)\n        x = torch.ones(n_qubits)\n\n        weights = [layer.qnode_weights[weight] for weight in ordered_weights]\n\n        out_layer = layer(x)\n        out_layer.backward()\n\n        g_layer = [w.grad.numpy() for w in weights]\n\n        out_circuit = c(x, *weights)\n        out_circuit.backward()\n\n        g_circuit = [w.grad.numpy() for w in weights]\n\n        for g1, g2 in zip(g_layer, g_circuit):\n            assert np.allclose(g1, g2)\n        assert len(weights) == len(list(layer.parameters()))\n\n\n@pytest.mark.parametrize(""interface"", qml.qnodes.decorator.ALLOWED_INTERFACES)\n@pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n@pytest.mark.usefixtures(""get_circuit"")  # this fixture is in tests/qnn/conftest.py\n@pytest.mark.usefixtures(""skip_if_no_tf_support"")\ndef test_interface_conversion(get_circuit, skip_if_no_tf_support):\n    """"""Test if input QNodes with all types of interface are converted internally to the PyTorch\n    interface""""""\n    c, w = get_circuit\n    layer = TorchLayer(c, w)\n    assert layer.qnode.interface == ""torch""\n\n\n@pytest.mark.parametrize(""interface"", [""torch""])\n@pytest.mark.usefixtures(""get_circuit"", ""module"")\nclass TestTorchLayerIntegration:\n    """"""Integration tests for the pennylane.qnn.torch.TorchLayer class.""""""\n\n    @pytest.mark.parametrize(""dtype"", [torch.float32, torch.float64])\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    @pytest.mark.parametrize(""batch_size"", [2])\n    def test_step_module(self, module, batch_size, n_qubits, output_dim, dtype):\n        """"""Test if a module that includes TorchLayers can perform one optimization step. This\n        test checks that some of the parameters in the module are different after one step.\n        The module is composed of two TorchLayers sandwiched between Linear neural network layers,\n        and the dataset is simply input and output vectors of zeros.""""""\n        module = module.type(dtype)\n        loss_func = torch.nn.MSELoss()\n        optimizer = torch.optim.SGD(module.parameters(), lr=0.5)\n\n        x = torch.zeros((batch_size, n_qubits)).type(dtype)\n        y = torch.zeros((batch_size, output_dim)).type(dtype)\n\n        params_before = [w.detach().numpy().copy() for w in list(module.parameters())]\n\n        module_out = module(x)\n        optimizer.zero_grad()\n        loss = loss_func(module_out, y)\n        loss.backward()\n        optimizer.step()\n\n        params_after = [w.detach().numpy().copy() for w in list(module.parameters())]\n\n        params_similar = [np.allclose(p1, p2) for p1, p2 in zip(params_before, params_after)]\n        assert not all(params_similar)\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(2))\n    def test_module_gradients(self, module, output_dim, n_qubits, get_circuit):\n        """"""Test if a gradient can be calculated with respect to all of the trainable variables in\n        the module""""""\n        c, w = get_circuit\n\n        x = torch.zeros((2, n_qubits))\n        y = torch.zeros((2, output_dim))\n\n        module_out = module(x)\n        loss_func = torch.nn.MSELoss()\n        loss = loss_func(module_out, y)\n        loss.backward()\n\n        gradients = [w.grad for w in module.parameters()]\n        assert all([g.is_floating_point() for g in gradients])\n        assert len(gradients) == 2 * len(w) + 6  # six parameters come from classical layers\n\n    @pytest.mark.parametrize(""n_qubits, output_dim"", indices_up_to(1))\n    def test_module_state_dict(self, module, n_qubits, get_circuit):\n        """"""Test if the state dictionary output by the module contains all the expected trainable\n        parameters""""""\n        c, w = get_circuit\n\n        state_dict = module.state_dict()\n        dict_keys = set(state_dict.keys())\n\n        clayer_weights = set(""clayer{}.weight"".format(i + 1) for i in range(3))\n        clayer_biases = set(""clayer{}.bias"".format(i + 1) for i in range(3))\n        qlayer_params = set(\n            ""qlayer{}.w{}"".format(i + 1, j + 1) for i in range(2) for j in range(len(w))\n        )\n\n        all_params = clayer_weights | clayer_biases | qlayer_params\n\n        assert dict_keys == all_params\n        assert len(dict_keys) == len(all_params)\n'"
tests/qnodes/test_qnode_base.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`QNode` class.\n""""""\nimport contextlib\nimport io\nimport textwrap\n\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane._device import Device\nfrom pennylane.qnodes.base import BaseQNode, QuantumFunctionError, decompose_queue\nfrom pennylane.variable import Variable\nfrom pennylane.wires import Wires, WireError\n\n\n@pytest.fixture(scope=""function"")\ndef mock_qnode(mock_device):\n    """"""Provides a circuit for the subsequent tests of the operation queue""""""\n\n    def circuit(x):\n        qml.RX(x, wires=[0])\n        qml.CNOT(wires=[0, 1])\n        qml.RY(0.4, wires=[0])\n        qml.RZ(-0.2, wires=[1])\n        return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliZ(1))\n\n    node = BaseQNode(circuit, mock_device)\n    node._construct([1.0], {})\n    return node\n\n\n@pytest.fixture(scope=""function"")\ndef operable_mock_device_2_wires(monkeypatch):\n    """"""A mock instance of the abstract Device class that can support Qubit qfuncs.""""""\n\n    dev = Device\n    with monkeypatch.context() as m:\n        m.setattr(dev, ""__abstractmethods__"", frozenset())\n        m.setattr(dev, ""capabilities"", lambda cls: {""model"": ""qubit""})\n        m.setattr(dev, ""operations"", [""BasisState"", ""RX"", ""RY"", ""CNOT"", ""Rot"", ""PhaseShift""])\n        m.setattr(dev, ""observables"", [""PauliX"", ""PauliY"", ""PauliZ""])\n        m.setattr(dev, ""reset"", lambda self: None)\n        m.setattr(dev, ""apply"", lambda self, x, y, z: None)\n        m.setattr(dev, ""expval"", lambda self, x, y, z: 1)\n        yield Device(wires=2)\n\n\n@pytest.fixture(scope=""function"")\ndef operable_mock_device_2_wires_with_inverses(monkeypatch):\n    """"""A mock instance of the abstract Device class that can support Qubit qfuncs.""""""\n\n    dev = Device\n    with monkeypatch.context() as m:\n        m.setattr(dev, ""__abstractmethods__"", frozenset())\n        m.setattr(dev, ""capabilities"", lambda cls: {""model"": ""qubit"", ""inverse_operations"": True})\n        m.setattr(dev, ""operations"", [""BasisState"", ""RX"", ""RY"", ""RZ"", ""CNOT"", ""PhaseShift""])\n        m.setattr(dev, ""observables"", [""PauliX"", ""PauliY"", ""PauliZ""])\n        m.setattr(dev, ""reset"", lambda self: None)\n        m.setattr(dev, ""apply"", lambda self, x, y, z: None)\n        m.setattr(dev, ""expval"", lambda self, x, y, z: 1)\n        yield Device(wires=2)\n\n\n@pytest.fixture(scope=""function"")\ndef operable_mock_CV_device_2_wires(monkeypatch):\n    """"""A mock instance of the abstract Device class that can support CV qfuncs.""""""\n\n    dev = Device\n    with monkeypatch.context() as m:\n        m.setattr(dev, ""__abstractmethods__"", frozenset())\n        m.setattr(\n            dev,\n            ""operations"",\n            [""Displacement"", ""CubicPhase"", ""Squeezing"", ""Rotation"", ""Kerr"", ""Beamsplitter""],\n        )\n        m.setattr(dev, ""observables"", [""X"", ""NumberOperator""])\n        m.setattr(dev, ""reset"", lambda self: None)\n        m.setattr(dev, ""apply"", lambda self, x, y, z: None)\n        m.setattr(dev, ""expval"", lambda self, x, y, z: 1)\n        yield Device(wires=2)\n\n\nclass TestQNodeOperationQueue:\n    """"""Tests that the QNode operation queue is properly filled and interacted with""""""\n\n    def test_operation_ordering(self, mock_qnode):\n        """"""Tests that the ordering of the operations is correct""""""\n\n        qnode = mock_qnode\n        assert qnode.ops[0].name == ""RX""\n        assert qnode.ops[1].name == ""CNOT""\n        assert qnode.ops[2].name == ""RY""\n        assert qnode.ops[3].name == ""RZ""\n        assert qnode.ops[4].name == ""PauliX""\n        assert qnode.ops[5].name == ""PauliZ""\n\n    def test_op_descendants_operations_only(self, mock_qnode):\n        """"""Tests that _op_descendants properly extracts the successors that are operations""""""\n\n        qnode = mock_qnode\n        operation_successors = qnode._op_descendants(qnode.ops[0], only=""G"")\n        assert qnode.ops[0] not in operation_successors\n        assert qnode.ops[1] in operation_successors\n        assert qnode.ops[4] not in operation_successors\n\n    def test_op_descendants_observables_only(self, mock_qnode):\n        """"""Tests that _op_descendants properly extracts the successors that are observables""""""\n\n        qnode = mock_qnode\n        observable_successors = qnode._op_descendants(qnode.ops[0], only=""O"")\n        assert qnode.ops[0] not in observable_successors\n        assert qnode.ops[1] not in observable_successors\n        assert qnode.ops[4] in observable_successors\n\n    def test_op_descendants_both_operations_and_observables(self, mock_qnode):\n        """"""Tests that _op_descendants properly extracts all successors""""""\n\n        qnode = mock_qnode\n        successors = qnode._op_descendants(qnode.ops[0], only=None)\n        assert qnode.ops[0] not in successors\n        assert qnode.ops[1] in successors\n        assert qnode.ops[4] in successors\n\n    def test_op_descendants_both_operations_and_observables_nodes(self, mock_qnode):\n        """"""Tests that _op_descendants properly extracts all successor nodes""""""\n\n        qnode = mock_qnode\n        successors = qnode._op_descendants(qnode.ops[0], only=None)\n        assert qnode.circuit.operations[0] not in successors\n        assert qnode.circuit.operations[1] in successors\n        assert qnode.circuit.operations[2] in successors\n        assert qnode.circuit.operations[3] in successors\n        assert qnode.circuit.observables[0] in successors\n\n    def test_op_descendants_both_operations_and_observables_strict_ordering(self, mock_qnode):\n        """"""Tests that _op_descendants properly extracts all successors""""""\n\n        qnode = mock_qnode\n        successors = qnode._op_descendants(qnode.ops[2], only=None)\n        assert qnode.circuit.operations[0] not in successors\n        assert qnode.circuit.operations[1] not in successors\n        assert qnode.circuit.operations[2] not in successors\n        assert qnode.circuit.operations[3] not in successors\n        assert qnode.circuit.observables[0] in successors\n\n    def test_op_descendants_extracts_all_successors(self, mock_qnode):\n        """"""Tests that _op_descendants properly extracts all successors""""""\n\n        qnode = mock_qnode\n        successors = qnode._op_descendants(qnode.ops[2], only=None)\n        assert qnode.ops[4] in successors\n        assert qnode.ops[5] not in successors\n\n    def test_print_applied(self, mock_device):\n        """"""Test that printing applied gates works correctly""""""\n\n        H = np.array([[0, 1], [1, 0]])\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(0.4, wires=[0])\n            qml.RZ(-0.2, wires=[1])\n            return qml.expval(qml.PauliX(0)), qml.var(qml.Hermitian(H, wires=1))\n\n        expected_qnode_print = textwrap.dedent(\n            """"""\\\n            Operations\n            ==========\n            RX({x}, wires=[0])\n            CNOT(wires=[0, 1])\n            RY(0.4, wires=[0])\n            RZ(-0.2, wires=[1])\n\n            Observables\n            ===========\n            expval(PauliX(wires=[0]))\n            var(Hermitian(array([[0, 1],\n                   [1, 0]]), wires=[1]))""""""\n        )\n\n        node = BaseQNode(circuit, mock_device)\n\n        # test before construction\n        f = io.StringIO()\n\n        with contextlib.redirect_stdout(f):\n            node.print_applied()\n            out = f.getvalue().strip()\n\n        assert out == ""QNode has not yet been executed.""\n\n        # construct QNode\n        f = io.StringIO()\n        node._set_variables([0.1], {})\n        node._construct([0.1], {})\n\n        with contextlib.redirect_stdout(f):\n            node.print_applied()\n            out = f.getvalue().strip()\n\n        assert out == expected_qnode_print.format(x=0.1)\n\n    def test_print_applied_with_probs(self, mock_device):\n        """"""Test that printing applied gates works correctly when probs are returned""""""\n\n        H = np.array([[0, 1], [1, 0]])\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.SWAP(wires=[1, 0])\n            qml.RZ(-0.2, wires=[1])\n            return qml.probs(wires=[0]), qml.var(qml.Hermitian(H, wires=1))\n\n        expected_qnode_print = textwrap.dedent(\n            """"""\\\n            Operations\n            ==========\n            RX({x}, wires=[0])\n            CNOT(wires=[0, 1])\n            SWAP(wires=[1, 0])\n            RZ(-0.2, wires=[1])\n\n            Observables\n            ===========\n            probs(wires=[0])\n            var(Hermitian(array([[0, 1],\n                   [1, 0]]), wires=[1]))""""""\n        )\n\n        node = BaseQNode(circuit, mock_device)\n\n        # test before construction\n        f = io.StringIO()\n\n        with contextlib.redirect_stdout(f):\n            node.print_applied()\n            out = f.getvalue().strip()\n\n        assert out == ""QNode has not yet been executed.""\n\n        # construct QNode\n        f = io.StringIO()\n        node._set_variables([0.1], {})\n        node._construct([0.1], {})\n\n        with contextlib.redirect_stdout(f):\n            node.print_applied()\n            out = f.getvalue().strip()\n\n        assert out == expected_qnode_print.format(x=0.1)\n\n    def test_operation_appending(self, mock_device):\n        """"""Tests that operations are correctly appended.""""""\n        CNOT = qml.CNOT(wires=[0, 1])\n\n        def circuit(x):\n            qml.QueuingContext.append_operator(CNOT)\n            qml.RY(0.4, wires=[0])\n            qml.RZ(-0.2, wires=[1])\n\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliZ(1))\n\n        qnode = BaseQNode(circuit, mock_device)\n        qnode._construct([1.0], {})\n\n        assert qnode.ops[0].name == ""CNOT""\n        assert qnode.ops[1].name == ""RY""\n        assert qnode.ops[2].name == ""RZ""\n        assert qnode.ops[3].name == ""PauliX""\n\n    def test_operation_removal(self, mock_device):\n        """"""Tests that operations are correctly removed.""""""\n\n        def circuit(x):\n            RX = qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(0.4, wires=[0])\n            qml.RZ(-0.2, wires=[1])\n\n            qml.QueuingContext.remove_operator(RX)\n\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliZ(1))\n\n        qnode = BaseQNode(circuit, mock_device)\n        qnode._construct([1.0], {})\n\n        assert qnode.ops[0].name == ""CNOT""\n        assert qnode.ops[1].name == ""RY""\n        assert qnode.ops[2].name == ""RZ""\n        assert qnode.ops[3].name == ""PauliX""\n\n    def test_prune_tensors(self, mock_device):\n        """"""Test that the _prune_tensors auxiliary method prunes correct for\n        a single Identity in the Tensor.""""""\n        px = qml.PauliX(1)\n        obs = qml.Identity(0) @ px\n\n        def circuit(x):\n            return qml.expval(obs)\n\n        qnode = BaseQNode(circuit, mock_device)\n\n        assert qnode._prune_tensors(obs) == px\n\n    def test_prune_tensors_no_pruning_took_place(self, mock_device):\n        """"""Test that the _prune_tensors auxiliary method returns\n        the original tensor if no observables were pruned.""""""\n        px = qml.PauliX(1)\n        obs = px\n\n        def circuit(x):\n            return qml.expval(obs)\n\n        qnode = BaseQNode(circuit, mock_device)\n\n        assert qnode._prune_tensors(obs) == px\n\n    def test_prune_tensors_construct(self, mock_device):\n        """"""Test that the tensors are pruned in construct.""""""\n\n        def circuit(x):\n            return qml.expval(qml.PauliX(0) @ qml.Identity(1))\n\n        qnode = BaseQNode(circuit, mock_device)\n        qnode._construct([1.0], {})\n\n        assert qnode.ops[0].name == ""PauliX""\n        assert len(qnode.ops[0].wires) == 1\n        assert qnode.ops[0].wires[0] == Wires(0)\n\n\nclass TestQNodeExceptions:\n    """"""Tests that QNode raises proper errors""""""\n\n    def test_operations_after_observables(self, operable_mock_device_2_wires):\n        """"""Error: qfunc contains operations after observables.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            ex = qml.expval(qml.PauliZ(wires=1))\n            qml.RY(0.5, wires=[0])\n            return qml.expval(qml.PauliZ(wires=0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""gates must precede measured""):\n            node(0.5)\n\n    def test_return_of_non_observable(self, operable_mock_device_2_wires):\n        """"""Error: qfunc returns something besides observables.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(wires=0)), 0.3\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""A quantum function must return either""):\n            node(0.5)\n\n    def test_observable_with_no_measurement_type(self, operable_mock_device_2_wires):\n        """"""Error: observable lacks the measurement type.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(wires=0)), qml.PauliZ(wires=1)\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(\n            QuantumFunctionError, match=""does not have the measurement type specified""\n        ):\n            node(0.5)\n\n    def test_observable_not_returned(self, operable_mock_device_2_wires):\n        """"""Error: qfunc does not return all observables.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            ex = qml.expval(qml.PauliZ(wires=1))\n            return qml.expval(qml.PauliZ(wires=0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""All measured observables must be returned""):\n            node(0.5)\n\n    def test_observable_order_violated(self, operable_mock_device_2_wires):\n        """"""Error: qfunc does not return all observables in the correct order.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            ex = qml.expval(qml.PauliZ(wires=1))\n            return qml.expval(qml.PauliZ(wires=0)), ex\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""All measured observables must be returned""):\n            node(0.5)\n\n    def test_mixing_of_cv_and_qubit_operations(self, operable_mock_device_2_wires):\n        """"""Error: qubit and CV operations are mixed in the same qfunc.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            qml.Displacement(0.5, 0, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(\n            QuantumFunctionError, match=""Continuous and discrete operations are not allowed""\n        ):\n            node(0.5)\n\n    def test_cv_operations_on_qubit_device(self, operable_mock_device_2_wires):\n        """"""Error: cannot use CV operations on a qubit device.""""""\n\n        def circuit(x):\n            qml.Displacement(0.5, 0, wires=[0])\n            return qml.expval(qml.X(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(\n            QuantumFunctionError, match=""a qubit device; CV operations are not allowed""\n        ):\n            node(0.5)\n\n    def test_qubit_operations_on_CV_device(self, operable_mock_device_2_wires, monkeypatch):\n        """"""Error: cannot use qubit operations on a CV device.""""""\n        monkeypatch.setattr(operable_mock_device_2_wires, ""capabilities"", lambda: {""model"": ""cv""})\n\n        def circuit(x):\n            qml.RX(0.5, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(\n            QuantumFunctionError, match=""a CV device; qubit operations are not allowed""\n        ):\n            node(0.5)\n\n    def test_multiple_measurements_on_same_wire(self, operable_mock_device_2_wires):\n        """"""Error: the same wire is measured multiple times.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""can only be measured once""):\n            node(0.5)\n\n    def test_invisible_operations(self, operable_mock_device_2_wires):\n        """"""Error: an operation does not affect the measurements.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            qml.RX(x, wires=[1])  # on its own component in the circuit graph\n            return qml.expval(qml.PauliZ(0))\n\n        kwargs = {""vis_check"": True}\n        node = BaseQNode(circuit, operable_mock_device_2_wires, **kwargs)\n        with pytest.raises(QuantumFunctionError, match=""cannot affect the circuit output""):\n            node(0.5)\n\n    def test_operation_requiring_all_wires(self, operable_mock_device_2_wires):\n        """"""Error: an operation that must be applied to all wires is not\n        applied to all wires.""""""\n\n        class DummyOp(qml.operation.Operation):\n            """"""Dummy operation""""""\n\n            num_wires = qml.operation.ActsOn.AllWires\n            num_params = 0\n            par_domain = None\n\n        def circuit():\n            DummyOp(wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""must act on all wires""):\n            node()\n\n    def test_operation_on_nonexistant_wire(self, operable_mock_device_2_wires):\n        """"""Error: an operation is applied to a non-existant wire.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            qml.CNOT(wires=[0, 2])\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""applied to invalid wire""):\n            node(0.5)\n\n    def test_observable_on_nonexistant_wire(self, operable_mock_device_2_wires):\n        """"""Error: an observable is measured on a non-existant wire.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(2))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(QuantumFunctionError, match=""applied to invalid wire""):\n            node(0.5)\n\n    def test_bad_wire_argument(self, operable_mock_device_2_wires):\n        """"""Error: wire arguments must be intergers.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[qml.PauliX])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(2))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(WireError, match=""Wires must be represented by""):\n            node(1)\n\n    def test_arg_as_wire_argument(self, operable_mock_device_2_wires):\n        """"""Error: trying to use a differentiable parameter as a wire argument.""""""\n\n        def circuit(x):\n            qml.RX(0.5, wires=[x])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(2))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        with pytest.raises(WireError, match=""Wires must be represented by""):\n            node(1)\n\n    def test_kwarg_as_wire_argument(self, operable_mock_device_2_wires):\n        """"""Error: trying to use a keyword-only parameter as a wire argument in an immutable circuit.""""""\n\n        def circuit(*, x=None):\n            qml.RX(0.5, wires=[x])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires, mutable=False)\n        with pytest.raises(WireError, match=""Wires must be represented by""):\n            node(x=1)\n\n    @pytest.mark.xfail(\n        reason=""Tests the auxiliary-equals-keyword-only syntax"", raises=TypeError, strict=True\n    )\n    def test_simple_valid_call(self, operable_mock_device_2_wires):\n        """"""BaseQNode gives an error here, ""got multiple values for argument \'x\'""\n        """"""\n\n        def circuit(x=0):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n        node(0.3)\n        assert node.ops[0].parameters[0] == 0.3\n\n    @pytest.mark.xfail(\n        reason=""Tests the auxiliary-equals-keyword-only syntax"", raises=AssertionError, strict=True\n    )\n    def test_calling_no_kwargs(self, operable_mock_device_2_wires):\n        """"""Various quantum func calling syntax errors.""""""\n\n        def circuit(x, y=0.2, *args, m=0.3, n):\n            circuit.in_args = (x, y, m, n)\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires, mutable=True)\n\n        with pytest.raises(QuantumFunctionError, match=""parameter \'x\' given twice""):\n            node(0.1, x=1.1)\n        with pytest.raises(QuantumFunctionError, match=""Unknown quantum function parameter \'foo\'""):\n            node(foo=1)\n        with pytest.raises(\n            QuantumFunctionError, match=""\'args\' cannot be given using the keyword syntax""\n        ):\n            node(args=1)\n        with pytest.raises(QuantumFunctionError, match=""positional parameter \'x\' missing""):\n            node(n=0.4)\n        with pytest.raises(QuantumFunctionError, match=""keyword-only parameter \'n\' missing""):\n            node(0.1)\n\n        # valid calls\n        node(x=0.1, n=0.4)\n        assert circuit.in_args[2:] == (0.3, 0.4)  # first two are Variables\n        node(0.1, n=0.4)\n        assert circuit.in_args[2:] == (0.3, 0.4)\n\n    def test_unused_positional_parameter(self, operable_mock_device_2_wires):\n        """"""Error: a positional parameter is not used in the circuit.""""""\n\n        def circuit(a, x):\n            qml.RX(a, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        kwargs = {""par_check"": True}\n        node = BaseQNode(circuit, operable_mock_device_2_wires, **kwargs)\n        with pytest.raises(QuantumFunctionError, match=""The positional parameters""):\n            node(1.0, 2.0)\n\n    @pytest.mark.xfail(\n        reason=""Tests the auxiliary-equals-keyword-only syntax"", raises=AssertionError, strict=True\n    )\n    def test_calling_with_kwargs(self, operable_mock_device_2_wires):\n        """"""Various quantum func calling syntax errors.""""""\n\n        def circuit(x, y=0.2, *, m=0.3, n, **kwargs):\n            circuit.in_args = (x, y, m, n)\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires, mutable=True)\n\n        with pytest.raises(QuantumFunctionError, match=""parameter \'x\' given twice""):\n            node(0.1, x=1.1)\n        with pytest.raises(\n            QuantumFunctionError, match=""\'kwargs\' cannot be given using the keyword syntax""\n        ):\n            node(kwargs=1)\n        with pytest.raises(QuantumFunctionError, match=""takes 2 positional parameters, 3 given""):\n            node(0.1, 0.2, 100, n=0.4)\n        with pytest.raises(QuantumFunctionError, match=""positional parameter \'x\' missing""):\n            node(n=0.4)\n        with pytest.raises(QuantumFunctionError, match=""keyword-only parameter \'n\' missing""):\n            node(0.1)\n\n        # valid calls\n        node(x=0.1, n=0.4)\n        assert circuit.in_args[2:] == (0.3, 0.4)  # first two are Variables\n        node(0.1, n=0.4)\n        assert circuit.in_args[2:] == (0.3, 0.4)\n\n    def test_calling_bad_errors(self, operable_mock_device_2_wires):\n        """"""Confusing quantum func calling errors and bugs (auxiliary-equals-parameters-with-default syntax).""""""\n\n        def circuit(x=0.1):\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(TypeError, match=""got multiple values for argument \'x\'""):\n            node(0.3)  # default arg given positionally, wrong error message\n\n    def test_calling_errors(self, operable_mock_device_2_wires):\n        """"""Good quantum func calling syntax errors (auxiliary-equals-parameters-with-default syntax).""""""\n\n        def circuit(x, y=0.2, *args, z=0.3):\n            circuit.in_args = (x, y, z)\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, operable_mock_device_2_wires, mutable=True)\n\n        with pytest.raises(\n            QuantumFunctionError, match=""\'x\' cannot be given using the keyword syntax""\n        ):\n            node(0.1, x=1.1)\n        with pytest.raises(QuantumFunctionError, match=""Unknown quantum function parameter \'foo\'""):\n            node(foo=1)\n        with pytest.raises(\n            QuantumFunctionError, match=""\'args\' cannot be given using the keyword syntax""\n        ):\n            node(args=1)\n        with pytest.raises(TypeError, match=""missing 1 required positional argument: \'x\'""):\n            node(z=0.4)\n\n        # valid calls\n        node(0.1)\n        assert circuit.in_args[1:] == (0.2, 0.3)  # first is a Variable\n        node(0.1, y=1.2)\n        assert circuit.in_args[1:] == (1.2, 0.3)\n        node(0.1, z=1.3, y=1.2)\n        assert circuit.in_args[1:] == (1.2, 1.3)\n\n\nclass TestQNodeArgs:\n    """"""Tests the handling of calling arguments in the QNode""""""\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_fanout(self, qubit_device_1_wire, tol, x, y):\n        """"""Tests that qnodes can compute the correct function when the\n           same parameter is used in multiple gates.""""""\n\n        def circuit(x, y):\n            qml.RX(x, wires=[0])\n            qml.RZ(y, wires=[0])\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        def analytic_expval(x, y):\n            return np.cos(x) ** 2 - np.cos(y) * np.sin(x) ** 2\n\n        node = BaseQNode(circuit, qubit_device_1_wire)\n        res = node(x, y)\n        assert res == pytest.approx(analytic_expval(x, y), abs=tol)\n\n    def test_multiple_expectation_different_wires(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes return multiple expectation values.""""""\n\n        a, b, c = 0.5, 0.54, 0.3\n\n        def circuit(x, y, z):\n            qml.RX(x, wires=[0])\n            qml.RZ(y, wires=[0])\n            qml.CNOT(wires=[0, 1])\n            qml.RY(y, wires=[0])\n            qml.RX(z, wires=[0])\n            return qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(1))\n\n        def analytic_expval(a, b, c):\n            return [-1 * np.cos(a) * np.cos(b) * np.sin(c), np.cos(a)]\n\n        node = BaseQNode(circuit, qubit_device_2_wires)\n        res = node(a, b, c)\n        assert res == pytest.approx(analytic_expval(a, b, c), abs=tol)\n\n    def test_multiple_keywordargs_used(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes can use multiple keyword-only arguments.""""""\n\n        def circuit(w, *, x=None, y=None):\n            qml.RX(x, wires=[0])\n            qml.RX(y, wires=[1])\n            qml.RZ(w, wires=[0])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = BaseQNode(circuit, qubit_device_2_wires)\n        c = node(1.0, x=np.pi, y=np.pi / 2)\n        assert c == pytest.approx([-1.0, 0.0], abs=tol)\n\n    def test_arraylike_args_used(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes use array-like positional arguments.""""""\n\n        def circuit(x):\n            qml.RX(x[0], wires=[0])\n            qml.RX(x[1], wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = BaseQNode(circuit, qubit_device_2_wires)\n        c = node([np.pi, np.pi])\n        assert c == pytest.approx([-1.0, -1.0], abs=tol)\n\n    def test_arraylike_keywordargs_used(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes use array-like keyword-only arguments.""""""\n\n        def circuit(w, *, x=None):\n            qml.RX(x[0], wires=[0])\n            qml.RX(x[1], wires=[1])\n            qml.RZ(w, wires=[0])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = BaseQNode(circuit, qubit_device_2_wires)\n        c = node(1.0, x=[np.pi, np.pi / 2])\n        assert c == pytest.approx([-1.0, 0.0], abs=tol)\n\n    def test_keywordargs_for_wires(self, qubit_device_2_wires, tol):\n        """"""Tests that wires can be passed as keyword-only arguments in mutable circuits.""""""\n\n        default_q = 0\n\n        def circuit(x, *, q=default_q):\n            qml.RX(x, wires=[q])\n            return qml.expval(qml.PauliZ(q))\n\n        node = BaseQNode(circuit, qubit_device_2_wires)\n        c = node(np.pi, q=1)\n        assert node.ops[0].wires == Wires([1])\n        assert c == pytest.approx(-1.0, abs=tol)\n\n        c = node(np.pi)\n        assert node.ops[0].wires == Wires([default_q])\n        assert c == pytest.approx(-1.0, abs=tol)\n\n    def test_keywordargs_used(self, qubit_device_1_wire, tol):\n        """"""Tests that qnodes use keyword arguments.""""""\n\n        def circuit(w, x=None):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, qubit_device_1_wire)\n        c = node(1.0, x=np.pi)\n        assert c == pytest.approx(-1.0, abs=tol)\n\n    def test_keywordarg_updated_in_multiple_calls(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes update keyword arguments in consecutive calls.""""""\n\n        def circuit(w, x=None):\n            qml.RX(w, wires=[0])\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = BaseQNode(circuit, qubit_device_2_wires)\n        c1 = node(0.1, x=0.0)\n        c2 = node(0.1, x=np.pi)\n        assert c1[1] != c2[1]\n\n    def test_keywordarg_passes_through_classicalnode(self, qubit_device_2_wires, tol):\n        """"""Tests that qnodes\' keyword arguments pass through classical nodes.""""""\n\n        def circuit(w, x=None):\n            qml.RX(w, wires=[0])\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = BaseQNode(circuit, qubit_device_2_wires)\n\n        def classical_node(w, x=None):\n            return node(w, x=x)\n\n        c = classical_node(0.0, x=np.pi)\n        assert c == pytest.approx([1.0, -1.0], abs=tol)\n\n    def test_keywordargs_with_kwargs(self, qubit_device_1_wire, tol):\n        """"""Tests that nothing happens if unknown keyword arg passed with\n        qnodes accepting **kwargs.""""""\n\n        def circuit(w, x=None, **kwargs):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(circuit, qubit_device_1_wire)\n        c = node(1.0, x=np.pi, y=10)\n        assert c == pytest.approx(-1.0, abs=tol)\n\n\nclass TestQNodeCaching:\n    """"""Tests for the QNode construction caching""""""\n\n    def test_no_caching(self):\n        """"""Test that mutable circuit structure changes on subsequent evalutions.""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def mutable_circuit(x, *, c=None):\n            qml.RX(x, wires=0)\n            for i in range(c):\n                qml.RX(x, wires=i)\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(mutable_circuit, dev, mutable=True)\n\n        # first evaluation\n        node(0, c=0)\n        assert len(node.circuit.operations) == 1\n        temp = node.ops[0]\n\n        # second evaluation\n        node(0, c=1)\n        assert len(node.circuit.operations) == 2\n        node.ops[0] is not temp  # all Operations in the circuit are generated anew\n\n    def test_caching(self):\n        """"""Test that non-mutable circuit structure does not change on subsequent evalutions.""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def non_mutable_circuit(x, *, c=None):\n            qml.RX(x, wires=0)\n            qml.RX(c, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        node = BaseQNode(non_mutable_circuit, dev, mutable=False)\n\n        # first evaluation\n        node(0, c=0)\n        assert len(node.circuit.operations) == 2\n        temp = node.ops[0]\n\n        # second evaluation\n        node(0, c=1)\n        assert len(node.circuit.operations) == 2\n        node.ops[0] is temp  # it\'s the same circuit with the same objects\n\n    THETA = np.linspace(0.11, 1, 3)\n    PHI = np.linspace(0.32, 1, 3)\n    VARPHI = np.linspace(0.02, 1, 3)\n\n    @pytest.mark.parametrize(""theta,phi,varphi"", list(zip(THETA, PHI, VARPHI)))\n    def test_mutable_qnode(self, theta, phi, varphi, tol):\n        """"""Test that a mutable QNode evaluated multiple times mutates well and produces\n        the desired result.\n        """"""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def circuit(weights, n_layers=1):\n            for idx in range(n_layers):\n                qml.RX(weights[idx], wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        res = circuit([phi], n_layers=1)\n        exp = np.cos(phi)\n        assert np.allclose(res, exp, atol=tol, rtol=0)\n\n        res = circuit([phi, theta], n_layers=2)\n        exp = np.cos(phi + theta)\n        assert np.allclose(res, exp, atol=tol, rtol=0)\n\n        res = circuit([phi, theta, varphi], n_layers=3)\n        exp = np.cos(phi + theta + varphi)\n        assert np.allclose(res, exp, atol=tol, rtol=0)\n\n    def test_mutable_qnode_for_loop_varying_executions(self, tol):\n        """"""Test that a mutable QNode containing a for loop correctly mutates\n        when called with different auxiliary arguments and different shaped positional\n        arguments.\n        """"""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def node(x, n=1):\n            for k in range(2):\n                for j in range(min(n, k + 1)):\n                    qml.RX(x[k][j], wires=0)\n            return qml.expval(qml.PauliZ(wires=0))\n\n        res = node([[0.1], [0.2]], n=1)\n        exp = np.cos(sum([0.1] + [0.2]))\n        assert np.allclose(res, exp, atol=tol, rtol=0)\n\n        res = node([[0.1], [0.2, 0.3]], n=2)\n        exp = np.cos(sum([0.1] + [0.2, 0.3]))\n        assert np.allclose(res, exp, atol=tol, rtol=0)\n\n\nclass TestQNodeEvaluate:\n    """"""Test for observable statistic evaluation""""""\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_evaluate(self, x, y, tol):\n        """"""Tests correct evaluation""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node = BaseQNode(circuit, dev)\n        res = node.evaluate([x, y], {})\n        expected = np.sin(y) * np.cos(x)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\n        ""x,y"",\n        zip(np.linspace(-2 * np.pi, 2 * np.pi, 7), np.linspace(-2 * np.pi, 2 * np.pi, 7) ** 2 / 11),\n    )\n    def test_obs_evaluate(self, x, y, tol):\n        """"""Tests correct evaluation swapping out the observables""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node = BaseQNode(circuit, dev)\n\n        # test standard evaluation\n        node = BaseQNode(circuit, dev)\n        res = node.evaluate([x, y], {})\n        expected = np.sin(y) * np.cos(x)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # hot-swap the observable\n        res = node.evaluate_obs([qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))], [x, y], {})\n        expected = np.cos(y)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_single_mode_sample(self):\n        """"""Test that there is only one array of values returned\n        for single mode samples""""""\n        shots = 10\n        dev = qml.device(""default.qubit"", wires=2, shots=shots)\n\n        def circuit(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(y, wires=[1])\n            qml.CNOT(wires=[0, 1])\n            return qml.sample(qml.PauliZ(0) @ qml.PauliX(1))\n\n        node = BaseQNode(circuit, dev)\n        res = node(0.432, 0.12)\n        assert res.shape == (10,)\n\n\nclass TestDecomposition:\n    """"""Test for queue decomposition""""""\n\n    def test_no_decomposition(self, operable_mock_device_2_wires):\n        """"""Test that decompose queue makes no changes\n        if there are no operations to be decomposed""""""\n\n        queue = [qml.Rot(0, 1, 2, wires=0), qml.CNOT(wires=[0, 1]), qml.RX(6, wires=0)]\n\n        res = decompose_queue(queue, operable_mock_device_2_wires)\n        assert res == queue\n\n    def test_decompose_queue(self, operable_mock_device_2_wires):\n        """"""Test that decompose queue works correctly\n        when an operation exists that can be decomposed""""""\n\n        queue = [qml.Rot(0, 1, 2, wires=0), qml.U3(3, 4, 5, wires=0), qml.RX(6, wires=0)]\n\n        res = decompose_queue(queue, operable_mock_device_2_wires)\n\n        assert len(res) == 5\n\n        assert res[0].name == ""Rot""\n        assert res[0].parameters == [0, 1, 2]\n\n        assert res[1].name == ""Rot""\n        assert res[1].parameters == [5, 3, -5]\n\n        assert res[2].name == ""PhaseShift""\n        assert res[2].parameters == [5]\n\n        assert res[3].name == ""PhaseShift""\n        assert res[3].parameters == [4]\n\n        assert res[4].name == ""RX""\n        assert res[4].parameters == [6]\n\n    def test_decompose_queue_recursive(self, operable_mock_device_2_wires_with_inverses):\n        """"""Test that decompose queue works correctly\n        when an operation exists that can be decomposed""""""\n\n        queue = [qml.CRY(1, wires=[0, 1]), qml.U3(3, 4, 5, wires=0)]\n\n        res = decompose_queue(queue, operable_mock_device_2_wires_with_inverses)\n\n        assert len(res) == 9\n\n        assert res[0].name == ""RY""\n        assert res[0].parameters == [0.5]\n\n        assert res[1].name == ""CNOT""\n\n        assert res[2].name == ""RY""\n        assert res[2].parameters == [-0.5]\n\n        assert res[3].name == ""CNOT""\n\n        assert res[4].name == ""RZ""\n        assert res[4].parameters == [5]\n\n        assert res[5].name == ""RY""\n        assert res[5].parameters == [3]\n\n        assert res[6].name == ""RZ""\n        assert res[6].parameters == [-5]\n\n        assert res[7].name == ""PhaseShift""\n        assert res[7].parameters == [5]\n\n        assert res[8].name == ""PhaseShift""\n        assert res[8].parameters == [4]\n\n    def test_decompose_queue_inv(self, operable_mock_device_2_wires_with_inverses):\n        """"""Test that decompose queue works correctly\n        when an operation exists that can be decomposed""""""\n\n        queue = [\n            qml.Rot(0, 1, 2, wires=0).inv(),\n            qml.U3(3, 4, 5, wires=0).inv(),\n            qml.RX(6, wires=0).inv(),\n        ]\n\n        res = decompose_queue(queue, operable_mock_device_2_wires_with_inverses)\n\n\n        assert len(res) == 9\n\n        assert res[0].name == ""RZ.inv""\n        assert res[0].parameters == [2]\n\n        assert res[1].name == ""RY.inv""\n        assert res[1].parameters == [1]\n\n        assert res[2].name == ""RZ.inv""\n        assert res[2].parameters == [0]\n\n        assert res[3].name == ""PhaseShift.inv""\n        assert res[3].parameters == [4]\n\n        assert res[4].name == ""PhaseShift.inv""\n        assert res[4].parameters == [5]\n\n        assert res[5].name == ""RZ.inv""\n        assert res[5].parameters == [-5]\n\n        assert res[6].name == ""RY.inv""\n        assert res[6].parameters == [3]\n\n        assert res[7].name == ""RZ.inv""\n        assert res[7].parameters == [5]\n\n        assert res[8].name == ""RX.inv""\n        assert res[8].parameters == [6]\n\n    def test_invalid_decompose(self, operable_mock_device_2_wires):\n        """"""Test that an error is raised if the device\n        does not support an operation arising from a\n        decomposition.""""""\n\n        class DummyOp(qml.operation.Operation):\n            """"""Dummy operation""""""\n\n            num_params = 0\n            num_wires = 1\n            par_domain = ""R""\n            grad_method = ""A""\n\n            @staticmethod\n            def decomposition(wires=None):\n                phi = 0.3\n                ops = [qml.RZ(phi, wires=wires)]\n                return ops\n\n        queue = [qml.Rot(0, 1, 2, wires=0), DummyOp(wires=0), qml.RX(6, wires=0)]\n\n        with pytest.raises(qml.DeviceError, match=""DummyOp not supported on device""):\n            decompose_queue(queue, operable_mock_device_2_wires)\n\n\nclass TestQNodeVariableMap:\n    """"""Test the conversion of arguments to Variable instances.""""""\n\n    def test_regular_arguments(self, mock_device):\n        """"""Test that regular arguments are properly converted to Variable instances.""""""\n\n        def circuit(a, b, c, d):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        arg_vars, kwarg_vars = node._make_variables([1.0, 2.0, 3.0, 4.0], {})\n\n        expected_arg_vars = [\n            Variable(0, ""a""),\n            Variable(1, ""b""),\n            Variable(2, ""c""),\n            Variable(3, ""d""),\n        ]\n\n        for var, expected in zip(qml.utils._flatten(arg_vars), expected_arg_vars):\n            assert var == expected\n\n        assert not kwarg_vars\n\n    def test_array_arguments(self, mock_device):\n        """"""Test that array arguments are properly converted to Variable instances.""""""\n\n        def circuit(weights):\n            qml.RX(weights[0, 0], wires=[0])\n            qml.RY(weights[0, 1], wires=[0])\n            qml.RZ(weights[1, 0], wires=[0])\n            qml.RZ(weights[1, 1], wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n\n        weights = np.array([[1, 2], [3, 4]])\n        arg_vars, kwarg_vars = node._make_variables([weights], {})\n\n        expected_arg_vars = [\n            Variable(0, ""weights[0,0]""),\n            Variable(1, ""weights[0,1]""),\n            Variable(2, ""weights[1,0]""),\n            Variable(3, ""weights[1,1]""),\n        ]\n\n        for var, expected in zip(qml.utils._flatten(arg_vars), expected_arg_vars):\n            assert var == expected\n\n        assert not kwarg_vars\n\n    def test_regular_keyword_arguments(self, mock_device):\n        """"""Test that regular keyword arguments are properly converted to Variable instances.""""""\n\n        def circuit(*, a=1, b=2, c=3, d=4):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        arg_vars, kwarg_vars = node._make_variables([], {""b"": 3})\n\n        expected_kwarg_vars = {\n            ""a"": [Variable(0, ""a"", is_kwarg=True)],\n            ""b"": [Variable(0, ""b"", is_kwarg=True)],\n            ""c"": [Variable(0, ""c"", is_kwarg=True)],\n            ""d"": [Variable(0, ""d"", is_kwarg=True)],\n        }\n\n        assert not arg_vars\n\n        for expected_key in expected_kwarg_vars:\n            for var, expected in zip(\n                qml.utils._flatten(kwarg_vars[expected_key]),\n                qml.utils._flatten(expected_kwarg_vars[expected_key]),\n            ):\n                assert var == expected\n\n    def test_array_keyword_arguments(self, mock_device):\n        """"""Test that array keyword arguments are properly converted to Variable instances.""""""\n\n        def circuit(*, a=np.array([[1, 0], [0, 1]]), b=np.array([1, 2, 3])):\n            qml.RX(a[0, 0], wires=[0])\n            qml.RX(a[0, 1], wires=[0])\n            qml.RX(a[1, 0], wires=[0])\n            qml.RX(a[1, 1], wires=[0])\n            qml.RY(b[0], wires=[0])\n            qml.RY(b[1], wires=[0])\n            qml.RY(b[2], wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        arg_vars, kwarg_vars = node._make_variables([], {""b"": np.array([6, 7, 8, 9])})\n\n        expected_kwarg_vars = {\n            ""a"": [\n                Variable(0, ""a[0,0]"", is_kwarg=True),\n                Variable(1, ""a[0,1]"", is_kwarg=True),\n                Variable(2, ""a[1,0]"", is_kwarg=True),\n                Variable(3, ""a[1,1]"", is_kwarg=True),\n            ],\n            ""b"": [\n                Variable(0, ""b[0]"", is_kwarg=True),\n                Variable(1, ""b[1]"", is_kwarg=True),\n                Variable(2, ""b[2]"", is_kwarg=True),\n                Variable(3, ""b[3]"", is_kwarg=True),\n            ],\n        }\n\n        assert not arg_vars\n\n        for expected_key in expected_kwarg_vars:\n            for var, expected in zip(\n                qml.utils._flatten(kwarg_vars[expected_key]),\n                qml.utils._flatten(expected_kwarg_vars[expected_key]),\n            ):\n                assert var == expected\n\n    def test_variadic_arguments(self, mock_device):\n        """"""Test that variadic arguments are properly converted to Variable instances.""""""\n\n        def circuit(a, *b):\n            qml.RX(a, wires=[0])\n            qml.RX(b[0], wires=[0])\n            qml.RX(b[1][1], wires=[0])\n            qml.RX(b[2], wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        arg_vars, kwarg_vars = node._make_variables([0.1, 0.2, np.array([0, 1, 2, 3]), 0.5], {})\n\n        expected_arg_vars = [\n            Variable(0, ""a""),\n            Variable(1, ""b[0]""),\n            Variable(2, ""b[1][0]""),\n            Variable(3, ""b[1][1]""),\n            Variable(4, ""b[1][2]""),\n            Variable(5, ""b[1][3]""),\n            Variable(6, ""b[2]""),\n        ]\n\n        assert not kwarg_vars\n\n        for var, expected in zip(qml.utils._flatten(arg_vars), expected_arg_vars):\n            assert var == expected\n\n    def test_non_trainable_args(self, mock_device):\n        """"""Test that non trainable args are not converted to Variables""""""\n\n        def circuit(a, b, c, d):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        node.set_trainable_args({0, 3})\n        var_values = [1.0, 2.0, 3.0, 4.0]\n        arg_vars, kwarg_vars = node._make_variables(var_values, {})\n\n        expected_arg_vars = [\n            Variable(0, ""a""),\n            var_values[1],\n            var_values[2],\n            Variable(3, ""d""),\n        ]\n\n        for var, expected in zip(qml.utils._flatten(arg_vars), expected_arg_vars):\n            assert var == expected\n\n        assert not kwarg_vars\n\n    def test_numpy_scalars(self, mock_device):\n        """"""Test that non-differentiable NumPy scalars are correctly cast to Python numeric literals\n        during Variable creation.""""""\n\n        def circuit(a, b):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        node.set_trainable_args({0})\n        var_values = [np.array(1.0), np.array(2.0)]\n        arg_vars, kwarg_vars = node._make_variables(var_values, {})\n\n        expected_arg_vars = [\n            Variable(0, ""a[]""),\n            var_values[1].item(),\n        ]\n\n        for var, expected in zip(qml.utils._flatten(arg_vars), expected_arg_vars):\n            assert var == expected\n\n        assert not kwarg_vars\n\n\nclass TestQNodeDraw:\n    """"""Test functionality related to draw.""""""\n\n    def test_unknown_charset_error(self, mock_qnode):\n        """"""Test that an error is raised for an unsupported charset.""""""\n        with pytest.raises(ValueError, match=""Charset does_not_exist is not supported""):\n            mock_qnode.draw(charset=""does_not_exist"")\n\n    def test_draw_before_construction_error(self):\n        """"""Test that an error is raised when drawing a QNode that is not yet constructed is attempted.""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        @qml.qnode(dev)\n        def circuit(a):\n            qml.RX(a, wires=[0])\n\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(\n            RuntimeError,\n            match=""The QNode can only be drawn after its CircuitGraph has been constructed"",\n        ):\n            circuit.draw()\n\n\nclass TestTrainableArgs:\n    """"""Test functionality related to trainable argument setting and validation""""""\n\n    def test_all_trainable(self, mock_device):\n        """"""Test that setting trainable_args to None treats all\n        arguments as differentiable""""""\n\n        def circuit(a, b, c, d):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        node.set_trainable_args(None)\n        var_values = [1.0, 2.0, 3.0, 4.0]\n        arg_vars, kwarg_vars = node._make_variables(var_values, {})\n\n        expected_arg_vars = [\n            Variable(0, ""a""),\n            Variable(1, ""b""),\n            Variable(2, ""c""),\n            Variable(3, ""d""),\n        ]\n\n        for var, expected in zip(qml.utils._flatten(arg_vars), expected_arg_vars):\n            assert var == expected\n\n    def test_none_trainable(self, mock_device):\n        """"""Test that an empty set results in no trainable arguments""""""\n\n        def circuit(a, b, c, d):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n        node.set_trainable_args(set())\n        var_values = [1.0, 2.0, 3.0, 4.0]\n        arg_vars, kwarg_vars = node._make_variables(var_values, {})\n\n        expected_arg_vars = [1.0, 2.0, 3.0, 4.0]\n\n        for var, expected in zip(qml.utils._flatten(arg_vars), expected_arg_vars):\n            assert var == expected\n\n    def test_invalid_index_type(self, mock_device):\n        """"""Test floats and/or negative integers passed raise an exception""""""\n\n        def circuit(a, b, c, d):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n\n        with pytest.raises(ValueError, match=""Argument indices must be positive integers""):\n            node.set_trainable_args({-1, 2})\n\n        with pytest.raises(ValueError, match=""Argument indices must be positive integers""):\n            node.set_trainable_args({0.5})\n\n    def test_invalid_index_value(self, mock_device):\n        """"""Test that an exception is raised if a specified trainable argument doesn\'t exist""""""\n\n        def circuit(a, b, c, d):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n\n        with pytest.raises(ValueError, match=r""not available\\. QNode has at most 4 arguments""):\n            node.set_trainable_args({0, 1, 5})\n\n        # QNodes with variable positional arguments turn this check off\n\n        def circuit(a, b, c, d, *args):\n            qml.RX(a, wires=[0])\n            qml.RY(b, wires=[0])\n            qml.RZ(c, wires=[0])\n            qml.RZ(d, wires=[0])\n\n            return qml.expval(qml.PauliX(0))\n\n        node = BaseQNode(circuit, mock_device)\n\n        assert node.func.var_pos\n        assert node.func.n_pos == 4\n\n        # The following will no longer raise an exception,\n        # since we do not know in advance how many arguments\n        # the user will evaluate the QNode with.\n        node.set_trainable_args({0, 1, 6})\n        assert node.get_trainable_args() == {0, 1, 6}\n'"
tests/qnodes/test_qnode_cv.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the PennyLane :class:`~.CVQNode` class.\n""""""\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane._device import Device\nfrom pennylane.operation import CVObservable\nfrom pennylane.qnodes.base import QuantumFunctionError\nfrom pennylane.qnodes.cv import CVQNode\n\n\nclass PolyN(qml.ops.PolyXP):\n    """"""Mimics NumberOperator using the arbitrary 2nd order observable interface.\n    Results should be identical.""""""\n    def __init__(self, wires):\n        hbar = 2\n        q = np.diag([-0.5, 0.5/hbar, 0.5/hbar])\n        super().__init__(q, wires=wires)\n        self.name = \'PolyXP\'\n\n\ncv_ops = [getattr(qml.ops, name) for name in qml.ops._cv__ops__]\nanalytic_cv_ops = [cls for cls in cv_ops if cls.supports_parameter_shift]\n\n\n@pytest.fixture(scope=""function"")\ndef operable_mock_CV_device_2_wires(monkeypatch):\n    """"""A mock instance of the abstract Device class that can support qfuncs.""""""\n\n    dev = Device\n    with monkeypatch.context() as m:\n        m.setattr(dev, \'__abstractmethods__\', frozenset())\n        m.setattr(dev, \'_capabilities\', {""model"": ""cv""})\n        m.setattr(dev, \'operations\', [""FockState"", ""Displacement"", ""CubicPhase"", ""Squeezing"", ""Rotation"", ""Kerr"", ""Beamsplitter""])\n        m.setattr(dev, \'observables\', [""X"", ""NumberOperator"", ""PolyXP""])\n        m.setattr(dev, \'reset\', lambda self: None)\n        m.setattr(dev, \'apply\', lambda self, x, y, z: None)\n        m.setattr(dev, \'expval\', lambda self, x, y, z: 1)\n        yield Device(wires=2)\n\n\ndef test_transform_observable_incorrect_heisenberg_size():\n    """"""The number of dimensions of a CV observable Heisenberg representation does\n    not match the ev_order attribute.""""""\n\n    class P(CVObservable):\n        """"""Dummy CV observable with incorrect ev_order""""""\n        num_wires = 1\n        num_params = 0\n        par_domain = None\n        ev_order = 2\n\n        @staticmethod\n        def _heisenberg_rep(p):\n            return np.array([0, 1, 0])\n\n    dev = qml.device(""default.gaussian"", wires=1)\n    def circuit(x):\n        qml.Displacement(x, 0.1, wires=0)\n        return qml.expval(P(0))\n\n    node = CVQNode(circuit, dev)\n\n    with pytest.raises(QuantumFunctionError, match=""Mismatch between the polynomial order""):\n        node.jacobian([0.5])\n\n\nclass TestBestMethod:\n    """"""\n    Test different flows of _best_method using a mock device. TODO more\n    """"""\n    def test_gaussian_successors_fails(self, operable_mock_CV_device_2_wires):\n        """"""Tests that the parameter-shift differentiation method is not allowed\n        if a non-gaussian gate is between a differentiable gaussian gate and an observable.""""""\n\n        def circuit(x):\n            qml.Squeezing(x, 0, wires=[0])\n            qml.Beamsplitter(np.pi/4, 0, wires=[0, 1])\n            qml.Kerr(0.54, wires=[1])\n            return qml.expval(qml.NumberOperator(1))\n\n        node = CVQNode(circuit, operable_mock_CV_device_2_wires)\n\n        with pytest.raises(ValueError, match=""analytic gradient method cannot be used with""):\n            node.jacobian([0.321], method=""A"")\n\n        assert node.par_to_grad_method == {0: ""F""}\n\n    def test_correct_method_non_gaussian_successor_one_param(self, operable_mock_CV_device_2_wires):\n        """"""Tests that a non-Gaussian succeeding a parameter fallsback to finite-diff""""""\n        par = [0.4, -2.3]\n\n        def qf(x, y):\n            qml.Displacement(x, 0, wires=[0])\n            qml.CubicPhase(0.2, wires=[0])\n            qml.Squeezing(0.3, y, wires=[1])\n            qml.Rotation(1.3, wires=[1])\n            # nongaussian succeeding x but not y\n            return qml.expval(qml.X(0)), qml.expval(qml.X(1))\n\n        q = CVQNode(qf, operable_mock_CV_device_2_wires)\n        q._construct(par, {})\n        assert q.par_to_grad_method == {0: ""F"", 1: ""A""}\n\n    def test_correct_method_non_gaussian_successor_unused_param(self, operable_mock_CV_device_2_wires):\n        """"""Tests that a non-Gaussian succeeding a parameter fallsback to finite-diff\n        alongside an unused parameter""""""\n        par = [0.4, -2.3]\n\n        def qf(x, y):\n            qml.Displacement(x, 0, wires=[0])\n            qml.CubicPhase(0.2, wires=[0])  # nongaussian succeeding x\n            qml.Squeezing(0.3, x, wires=[1])  # x affects gates on both wires, y unused\n            qml.Rotation(1.3, wires=[1])\n            return qml.expval(qml.X(0)), qml.expval(qml.X(1))\n\n        q = CVQNode(qf, operable_mock_CV_device_2_wires)\n        q._construct(par, {})\n        assert q.par_to_grad_method == {0: ""F"", 1: ""0""}\n\n    def test_param_not_differentiable(self, operable_mock_CV_device_2_wires):\n        """"""Tests that a parameter is not differentiable if used in an operation\n        where grad_method=None""""""\n        par = [0.4]\n\n        def qf(x):\n            qml.FockState(x, wires=[0])\n            qml.Rotation(1.3, wires=[0])\n            return qml.expval(qml.X(0))\n\n        q = CVQNode(qf, operable_mock_CV_device_2_wires)\n        q._construct(par, {})\n        assert q.par_to_grad_method == {0: None}\n\n    def test_param_no_observables(self, operable_mock_CV_device_2_wires):\n        """"""Tests that a parameter has 0 gradient if it is not followed by any observables""""""\n        par = [0.4]\n\n        def qf(x):\n            qml.Displacement(x, 0, wires=[0])\n            qml.Squeezing(0.3, x, wires=[0])\n            qml.Rotation(1.3, wires=[1])\n            return qml.expval(qml.X(1))\n\n        q = CVQNode(qf, operable_mock_CV_device_2_wires)\n        q._construct(par, {})\n        assert q.par_to_grad_method == {0: ""0""}\n\n    def test_correct_method_non_gaussian_successor_all_params(self, operable_mock_CV_device_2_wires):\n        """"""Tests that a non-Gaussian succeeding all parameters fallsback to finite-diff""""""\n        par = [0.4, -2.3]\n\n        def qf(x, y):\n            qml.Displacement(x, 0, wires=[0])\n            qml.Displacement(1.2, y, wires=[1])\n            qml.Beamsplitter(0.2, 1.7, wires=[0, 1])\n            qml.Rotation(1.9, wires=[0])\n            qml.Kerr(0.3, wires=[1])  # nongaussian succeeding both x and y due to the beamsplitter\n            return qml.expval(qml.X(0)), qml.expval(qml.X(1))\n\n        q = CVQNode(qf, operable_mock_CV_device_2_wires)\n        q._construct(par, {})\n        assert q.par_to_grad_method == {0: ""F"", 1: ""F""}\n\n    def test_correct_method_non_gaussian_preceeding_one_param(self, operable_mock_CV_device_2_wires):\n        """"""Tests that a non-Gaussian preceeding one parameter fallsback to finite-diff""""""\n        par = [0.4, -2.3]\n\n        def qf(x, y):\n            qml.Kerr(y, wires=[1])\n            qml.Displacement(x, 0, wires=[0])\n            qml.Beamsplitter(0.2, 1.7, wires=[0, 1])\n            return qml.expval(qml.X(0)), qml.expval(qml.X(1))\n\n        q = CVQNode(qf, operable_mock_CV_device_2_wires)\n        q._construct(par, {})\n        assert q.par_to_grad_method == {0: ""A"", 1: ""F""}\n\n    def test_correct_method_non_gaussian_observable(self, operable_mock_CV_device_2_wires):\n        """"""Tests that a non-Gaussian observable one parameter fallsback to finite-diff""""""\n        par = [0.4, -2.3]\n\n        def qf(x, y):\n            qml.Displacement(x, 0, wires=[0])  # followed by nongaussian observable\n            qml.Beamsplitter(0.2, 1.7, wires=[0, 1])\n            qml.Displacement(y, 0, wires=[1])  # followed by order-2 observable\n            return qml.expval(qml.FockStateProjector(np.array([2]), 0)), qml.expval(qml.NumberOperator(1))\n\n        q = CVQNode(qf, operable_mock_CV_device_2_wires)\n        q._construct(par, {})\n        assert q.par_to_grad_method == {0: ""F"", 1: ""A""}\n\n\nclass TestExpectationJacobian:\n    """"""Jacobian integration tests for CV expectations.""""""\n\n    def test_keywordarg_second_order_cv(self, tol):\n        """"""Non-differentiable keyword arguments with a second order CV expectation value.""""""\n\n        dev = qml.device(""default.gaussian"", wires=3)\n        def circuit(x, *, k=0.0):\n            qml.Displacement(x, 0, wires=0)\n            qml.Rotation(k, wires=0)\n            return qml.expval(qml.PolyXP(np.diag([0, 1, 0]), wires=0))  # X^2\n\n        node = CVQNode(circuit, dev)\n        par = [0.62]\n        aux = {\'k\': 0.4}\n\n        # circuit jacobians\n        grad_A = node.jacobian(par, aux, method=""A"")\n        grad_F = node.jacobian(par, aux, method=""F"")\n        expected = np.array([[8 * par[0] * np.cos(aux[\'k\']) ** 2]])\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A == pytest.approx(expected, abs=tol)\n\n    def test_keywordarg_with_positional_arg_immutable_second_order_cv(self, tol):\n        """"""Non-differentiable keyword arguments appear in the same op with differentiable arguments,\n        qfunc is immutable so kwargs are passed as Variables.""""""\n\n        dev = qml.device(""default.gaussian"", wires=1)\n        def circuit(x, *, k=0.0):\n            qml.Displacement(0.5, 0, wires=0)\n            qml.Squeezing(x, k, wires=0)\n            return qml.expval(qml.X(0))\n\n        node = CVQNode(circuit, dev, mutable=False)\n        par = [0.39]\n        aux = {\'k\': -0.7}\n\n        # circuit jacobians\n        grad_A = node.jacobian(par, aux, method=""A"", options={\'force_order2\': True})\n        grad_F = node.jacobian(par, aux, method=""F"")\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n\n    @pytest.mark.parametrize(\'O\', [qml.ops.X, qml.ops.NumberOperator, PolyN, qml.ops.Identity])\n    @pytest.mark.parametrize(\'G\', analytic_cv_ops)\n    def test_cv_gradients_gaussian_circuit(self, G, O, tol):\n        """"""Tests that the gradients of circuits of gaussian gates match between the finite difference and analytic methods.""""""\n        gaussian_dev = qml.device(""default.gaussian"", wires=2)\n\n        tol = 1e-5\n        par = [0.4]\n        def circuit(x):\n            args = [0.3] * G.num_params\n            args[0] = x\n            qml.Displacement(0.5, 0, wires=0)\n            G(*args, wires=range(G.num_wires))\n            qml.Beamsplitter(1.3, -2.3, wires=[0, 1])\n            qml.Displacement(-0.5, 0.1, wires=0)\n            qml.Squeezing(0.5, -1.5, wires=0)\n            qml.Rotation(-1.1, wires=0)\n            return qml.expval(O(wires=0))\n\n        q = CVQNode(circuit, gaussian_dev)\n        val = q.evaluate(par, {})\n\n        grad_F  = q.jacobian(par, method=""F"")\n        grad_A2 = q.jacobian(par, method=""A"", options={\'force_order2\': True})\n        if O.ev_order == 1:\n            grad_A = q.jacobian(par, method=""A"")\n            # the different methods agree\n            assert grad_A == pytest.approx(grad_F, abs=tol)\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {0:""A""}\n        # the different methods agree\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n    def test_gradient_gate_with_two_parameters(self, tol):\n        """"""Gates with two parameters yield the correct parshift gradient.""""""\n\n        dev = qml.device(""default.gaussian"", wires=1)\n        def qf(r0, phi0, r1, phi1):\n            qml.Squeezing(r0, phi0, wires=[0])\n            qml.Squeezing(r1, phi1, wires=[0])\n            return qml.expval(qml.NumberOperator(0))\n\n        q = CVQNode(qf, dev)\n        par = [0.543, 0.123, 0.654, -0.629]\n\n        grad_A = q.jacobian(par, method=""A"")\n        grad_F = q.jacobian(par, method=""F"")\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n\n    def test_cv_gradients_multiple_gate_parameters(self, tol):\n        """"""Tests that gates with multiple free parameters yield correct gradients.""""""\n\n        gaussian_dev = qml.device(""default.gaussian"", wires=2)\n        def qf(r0, phi0, r1, phi1):\n            qml.Squeezing(r0, phi0, wires=[0])\n            qml.Squeezing(r1, phi1, wires=[0])\n            return qml.expval(qml.NumberOperator(0))\n\n        q = CVQNode(qf, gaussian_dev)\n        par = [0.4, -0.3, -0.7, 0.2]\n\n        grad_F = q.jacobian(par, method=""F"")\n        grad_A = q.jacobian(par, method=""A"")\n        grad_A2 = q.jacobian(par, method=""A"", options={\'force_order2\': True})\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {i:""A"" for i in range(4)}\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n        # check against the known analytic formula\n        r0, phi0, r1, phi1 = par\n        dn = np.zeros([4])\n        dn[0] = np.cosh(2 * r1) * np.sinh(2 * r0) + np.cos(phi0 - phi1) * np.cosh(2 * r0) * np.sinh(2 * r1)\n        dn[1] = -0.5 * np.sin(phi0 - phi1) * np.sinh(2 * r0) * np.sinh(2 * r1)\n        dn[2] = np.cos(phi0 - phi1) * np.cosh(2 * r1) * np.sinh(2 * r0) + np.cosh(2 * r0) * np.sinh(2 * r1)\n        dn[3] = 0.5 * np.sin(phi0 - phi1) * np.sinh(2 * r0) * np.sinh(2 * r1)\n        assert dn[np.newaxis, :] == pytest.approx(grad_F, abs=tol)\n\n    def test_cv_gradients_repeated_gate_parameters(self, tol):\n        """"""Tests that repeated use of a free parameter in a multi-parameter gate yield correct gradients.""""""\n        gaussian_dev = qml.device(""default.gaussian"", wires=2)\n        par = [0.2, 0.3]\n\n        def qf(x, y):\n            qml.Displacement(x, 0, wires=[0])\n            qml.Squeezing(y, -1.3*y, wires=[0])\n            return qml.expval(qml.X(0))\n\n        q = CVQNode(qf, gaussian_dev)\n        grad_F = q.jacobian(par, method=""F"")\n        grad_A = q.jacobian(par, method=""A"")\n        grad_A2 = q.jacobian(par, method=""A"", options={\'force_order2\': True})\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {0:""A"", 1:""A""}\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n    def test_cv_gradients_parameters_inside_array(self, tol):\n        """"""Tests that free parameters inside an array passed to an Operation yield correct gradients.""""""\n        gaussian_dev = qml.device(""default.gaussian"", wires=2)\n        par = [0.4, 1.3]\n\n        def qf(x, y):\n            qml.Displacement(0.5, 0, wires=[0])\n            qml.Squeezing(x, 0, wires=[0])\n            M = np.zeros((5, 5), dtype=object)\n            M[1,1] = y\n            M[1,2] = 1.0\n            M[2,1] = 1.0\n            return qml.expval(qml.PolyXP(M, [0, 1]))\n\n        q = CVQNode(qf, gaussian_dev)\n\n        grad_best = q.jacobian(par)\n        grad_best2 = q.jacobian(par, options={""force_order2"": True})\n        grad_F = q.jacobian(par, method=""F"")\n\n        # par[0] can use the ""A"" method, par[1] cannot\n        assert q.par_to_grad_method == {0: ""A"", 1: ""F""}\n        # the different methods agree\n        assert grad_best == pytest.approx(grad_F, abs=tol)\n        assert grad_best2 == pytest.approx(grad_F, abs=tol)\n\n    def test_cv_gradient_fanout(self, tol):\n        """"""Tests that CV qnodes can compute the correct gradient when the same parameter is used\n        in multiple gates.""""""\n        gaussian_dev = qml.device(""default.gaussian"", wires=2)\n        par = [0.5, 1.3]\n\n        def circuit(x, y):\n            qml.Displacement(x, 0, wires=[0])\n            qml.Rotation(y, wires=[0])\n            qml.Displacement(0, x, wires=[0])\n            return qml.expval(qml.X(0))\n\n        q = CVQNode(circuit, gaussian_dev)\n        grad_F = q.jacobian(par, method=""F"")\n        grad_A = q.jacobian(par, method=""A"")\n        grad_A2 = q.jacobian(par, method=""A"", options={\'force_order2\': True})\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {0:""A"", 1:""A""}\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n    @pytest.mark.parametrize(\'name\', qml.ops._cv__ops__)\n    def test_CVOperation_with_heisenberg_and_no_parshift(self, name, tol):\n        """"""An integration test for Gaussian CV gates that have a Heisenberg representation\n        but cannot be differentiated using the parameter-shift method themselves\n        (for example, they may accept no parameters, or have no gradient recipe).\n\n        Tests that the parameter-shift method can still be used with other gates in the circuit.\n        """"""\n        gaussian_dev = qml.device(""default.gaussian"", wires=2)\n\n        cls = getattr(qml.ops, name)\n        if cls.supports_heisenberg and (not cls.supports_parameter_shift):\n            U = np.array([[0.51310276+0.81702166j, 0.13649626+0.22487759j],\n                          [0.26300233+0.00556194j, -0.96414101-0.03508489j]])\n\n            if cls.num_wires <= 0:\n                w = list(range(2))\n            else:\n                w = list(range(cls.num_wires))\n\n            def circuit(x):\n                qml.Displacement(x, 0, wires=0)\n\n                if cls.par_domain == ""A"":\n                    cls(U, wires=w)\n                else:\n                    cls(wires=w)\n                return qml.expval(qml.X(0))\n\n            qnode = CVQNode(circuit, gaussian_dev)\n            grad_F = qnode.jacobian(0.5, method=""F"")\n            grad_A = qnode.jacobian(0.5, method=""A"")\n            grad_A2 = qnode.jacobian(0.5, method=""A"", options={\'force_order2\': True})\n\n            # par[0] can use the ""A"" method\n            assert qnode.par_to_grad_method == {0: ""A""}\n\n            # the different methods agree\n            assert grad_A == pytest.approx(grad_F, abs=tol)\n            assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n    def test_non_gaussian_gate_successor(self, gaussian_device, tol):\n        """"""Parshift differentiation method is allowed and matches finite diff\n        if a non-Gaussian gate follows the parametrized gate but is not followed by an observable.""""""\n\n        def circuit(x):\n            qml.Squeezing(x, 0, wires=[0])\n            qml.Beamsplitter(1.1, 0, wires=[0, 1])\n            qml.Kerr(0.54, wires=[1])  # nongaussian\n            return qml.expval(qml.NumberOperator(0))\n\n        node = CVQNode(circuit, gaussian_device)\n        par = [0.321]\n\n        grad_A = node.jacobian(par, wrt=[0], method=""A"")\n        grad_F = node.jacobian(par, method=""F"")\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert node.par_to_grad_method == {0: ""A""}\n\n    def test_non_gaussian_obs_predecessor(self, gaussian_device, tol):\n        """"""Parshift differentiation method is allowed and matches finite diff\n        if a non-Gaussian gate precedes an observable but is not preceded by the parametrized gate.""""""\n\n        def circuit(x):\n            qml.Squeezing(x, 0, wires=[0])\n            qml.Kerr(0.54, wires=[1])  # nongaussian\n            qml.Beamsplitter(1.1, 0, wires=[0, 1])\n            return qml.expval(qml.NumberOperator(0))\n\n        node = CVQNode(circuit, gaussian_device)\n        par = [0.321]\n\n        grad_A = node.jacobian(par, wrt=[0], method=""A"")\n        grad_F = node.jacobian(par, method=""F"")\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert node.par_to_grad_method == {0: ""A""}\n\n    def test_second_order_obs_not_following_gate(self, tol):\n        """"""Parshift differentiation method matches finite diff and analytical result\n        when we have order-2 observables that do not follow the parametrized gate.\n        """"""\n        num_wires = 2\n        dev = qml.device(""default.gaussian"", wires=2)\n        def circuit(params):\n            for i in range(num_wires):\n                qml.Squeezing(params[i], 0, wires=i)\n            return [qml.expval(qml.NumberOperator(wires=i)) for i in range(num_wires)]\n\n        node = CVQNode(circuit, dev)\n        par = [0.321, -0.184]\n\n        res = node(par)\n        res_true = np.sinh(np.abs(par)) ** 2  # analytical result\n        assert res == pytest.approx(res_true, abs=tol)\n\n        grad_A = node.jacobian([par], method=""A"")\n        grad_F = node.jacobian([par], method=""F"")\n        grad_true = np.diag(np.sinh(2 * np.abs(par)) * np.sign(par))  # analytical gradient\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A == pytest.approx(grad_true, abs=tol)\n\n    @pytest.mark.xfail(reason=""FIXME: \'A\' method fails on QuadOperator (it has no gradient recipe)"", raises=AttributeError, strict=True)\n    def test_quadoperator(self, tol):\n        """"""Test the differentiation of CV observables that depend on positional qfunc parameters.""""""\n\n        def circuit(a):\n            qml.Displacement(1.0, 0, wires=0)\n            return qml.expval(qml.QuadOperator(a, 0))\n\n        gaussian_dev = qml.device(""default.gaussian"", wires=1)\n        qnode = CVQNode(circuit, gaussian_dev)\n\n        par = [0.6]\n        grad_F = qnode.jacobian(par, method=\'F\')\n        grad_A = qnode.jacobian(par, method=\'A\')\n        grad_A2 = qnode.jacobian(par, method=\'A\', options={\'force_order2\': True})\n\n        # par 0 can use the \'A\' method\n        assert qnode.par_to_grad_method == {0: \'A\'}\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n        assert grad_A2 == pytest.approx(grad_F, abs=tol)\n\n\nclass TestVarianceJacobian:\n    """"""Variance analytic jacobian integration tests.""""""\n\n    def test_first_order_cv(self, tol):\n        """"""Test variance of a first order CV expectation value""""""\n        dev = qml.device(""default.gaussian"", wires=1)\n\n        def circuit(r, phi):\n            qml.Squeezing(r, 0, wires=0)\n            qml.Rotation(phi, wires=0)\n            return qml.var(qml.X(0))\n\n        circuit = CVQNode(circuit, dev)\n\n        r = 0.543\n        phi = -0.654\n        var = circuit(r, phi)\n        expected = np.exp(2 * r) * np.sin(phi) ** 2 + np.exp(-2 * r) * np.cos(phi) ** 2\n        assert var == pytest.approx(expected, abs=tol)\n\n        # circuit jacobians\n        gradA = circuit.jacobian([r, phi], method=""A"")\n        gradF = circuit.jacobian([r, phi], method=""F"")\n        expected = np.array(\n            [[\n                2 * np.exp(2 * r) * np.sin(phi) ** 2 - 2 * np.exp(-2 * r) * np.cos(phi) ** 2,\n                2 * np.sinh(2 * r) * np.sin(2 * phi),\n            ]]\n        )\n        assert gradA == pytest.approx(expected, abs=tol)\n        assert gradF == pytest.approx(expected, abs=tol)\n\n    def test_second_order_cv(self, tol):\n        """"""Test variance of a second order CV expectation value""""""\n        dev = qml.device(""default.gaussian"", wires=1)\n\n        def circuit(n, a):\n            qml.ThermalState(n, wires=0)\n            qml.Displacement(a, 0, wires=0)\n            return qml.var(qml.NumberOperator(0))\n\n        circuit = CVQNode(circuit, dev)\n\n        n = 0.12\n        a = 0.765\n        var = circuit(n, a)\n        expected = n ** 2 + n + np.abs(a) ** 2 * (1 + 2 * n)\n        assert var == pytest.approx(expected, abs=tol)\n\n        # circuit jacobians\n        gradF = circuit.jacobian([n, a], method=""F"")\n        expected = np.array([[2 * a ** 2 + 2 * n + 1, 2 * a * (2 * n + 1)]])\n        assert gradF == pytest.approx(expected, abs=tol)\n\n\n    def test_expval_and_variance_cv(self, tol):\n        """"""Test that the qnode works for a combination of CV expectation\n        values and variances""""""\n        dev = qml.device(""default.gaussian"", wires=3)\n\n        def circuit(a, b):\n            qml.Displacement(0.5, 0, wires=0)\n            qml.Squeezing(a, 0, wires=0)\n            qml.Squeezing(b, 0, wires=1)\n            qml.Beamsplitter(0.6, -0.3, wires=[0, 1])\n            qml.Squeezing(-0.3, 0, wires=2)\n            qml.Beamsplitter(1.4, 0.5, wires=[1, 2])\n            return qml.var(qml.X(0)), qml.expval(qml.X(1)), qml.var(qml.X(2))\n\n        node = CVQNode(circuit, dev)\n        par = [0.54, -0.423]\n\n        # jacobians must match\n        gradA = node.jacobian(par, method=""A"")\n        gradF = node.jacobian(par, method=""F"")\n        assert gradA == pytest.approx(gradF, abs=tol)\n\n    def test_error_analytic_second_order_cv(self):\n        """"""Test exception raised if attempting to use a second\n        order observable to compute the variance derivative analytically""""""\n        dev = qml.device(""default.gaussian"", wires=1)\n\n        def circuit(a):\n            qml.Displacement(a, 0, wires=0)\n            return qml.var(qml.NumberOperator(0))\n\n        circuit = CVQNode(circuit, dev)\n\n        with pytest.raises(ValueError, match=r""cannot be used with the argument\\(s\\) \\{\'a\'\\}""):\n            circuit.jacobian([1.0], method=""A"")\n'"
tests/qnodes/test_qnode_decorator.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.qnode` decorator.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport numpy as np\nimport pytest\n\nimport pennylane as qml\nfrom pennylane.qnodes import qnode, CVQNode, JacobianQNode, BaseQNode, QubitQNode\nfrom pennylane.qnodes.jacobian import DEFAULT_STEP_SIZE_ANALYTIC, DEFAULT_STEP_SIZE\n\n\ndef test_create_qubit_qnode():\n    """"""Test the decorator correctly creates Qubit QNodes""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev)\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert isinstance(circuit, QubitQNode)\n    assert hasattr(circuit, ""jacobian"")\n\ndef test_create_CV_qnode():\n    """"""Test the decorator correctly creates Qubit QNodes""""""\n    dev = qml.device(\'default.gaussian\', wires=1)\n\n    @qnode(dev)\n    def circuit(a):\n        qml.Displacement(a, 0, wires=0)\n        return qml.expval(qml.X(wires=0))\n\n    assert isinstance(circuit, CVQNode)\n    assert hasattr(circuit, ""jacobian"")\n\n\ndef test_fallback_Jacobian_qnode(monkeypatch):\n    """"""Test the decorator fallsback to Jacobian QNode if it\n    can\'t determine the device model""""""\n    dev = qml.device(\'default.gaussian\', wires=1)\n\n    # use monkeypatch to avoid setting class attributes\n    with monkeypatch.context() as m:\n        m.setitem(dev._capabilities, ""model"", ""None"")\n\n        @qnode(dev)\n        def circuit(a):\n            qml.Displacement(a, 0, wires=0)\n            return qml.expval(qml.X(wires=0))\n\n        assert not isinstance(circuit, CVQNode)\n        assert not isinstance(circuit, QubitQNode)\n        assert isinstance(circuit, JacobianQNode)\n        assert hasattr(circuit, ""jacobian"")\n\ndef test_torch_interface(skip_if_no_torch_support):\n    """"""Test torch interface conversion""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev, interface=""torch"")\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert circuit.interface == ""torch""\n\nstep_sizes = [(True, DEFAULT_STEP_SIZE_ANALYTIC),\n            (False, DEFAULT_STEP_SIZE)]\n\n\n@pytest.mark.parametrize(""analytic, step_size"", step_sizes)\ndef test_finite_diff_qubit_qnode(analytic, step_size):\n    """"""Test that a finite-difference differentiable qubit QNode\n    is correctly created when diff_method=\'finite-diff\' and analytic=True""""""\n    dev = qml.device(\'default.qubit\', wires=1, analytic=analytic)\n\n    @qnode(dev, diff_method=""finite-diff"")\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert not isinstance(circuit, CVQNode)\n    assert not isinstance(circuit, QubitQNode)\n    assert isinstance(circuit, JacobianQNode)\n    assert hasattr(circuit, ""jacobian"")\n    assert circuit.h == step_size\n    assert circuit.order == 1\n\n\n@pytest.mark.parametrize(""order"", [1, 2])\ndef test_setting_order(order):\n    """"""Test that the order is correctly set and reset in a finite-difference QNode.""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev, diff_method=""finite-diff"", order=order)\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert circuit.order == order\n\n    circuit.order = 1\n    assert circuit.order == 1\n\n\ndef test_finite_diff_qubit_qnode_passing_step_size_through_decorator():\n    """"""Test that a finite-difference differentiable qubit QNode is correctly\n    created when diff_method=\'finite-diff\' and the step size is set through the\n    decorator.""""""\n    step_size = 0.5\n    new_step_size = 0.12345\n\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev, diff_method=""finite-diff"", h=step_size)\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert not isinstance(circuit, CVQNode)\n    assert not isinstance(circuit, QubitQNode)\n    assert isinstance(circuit, JacobianQNode)\n    assert hasattr(circuit, ""jacobian"")\n    assert circuit.h == step_size\n\n    circuit.h = new_step_size\n    assert circuit.h == new_step_size\n\ndef test_tf_interface(skip_if_no_tf_support):\n    """"""Test tf interface conversion""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev, interface=""tf"")\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert circuit.interface == ""tf""\n\n\ndef test_autograd_interface():\n    """"""Test autograd interface conversion""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev, interface=""autograd"")\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert circuit.interface == ""autograd""\n\n\ndef test_no_interface():\n    """"""Test no interface conversion""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev, interface=None)\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert circuit.interface is None\n\n\ndef test_not_differentiable():\n    """"""Test QNode marked as non-differentiable""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    @qnode(dev, interface=None, diff_method=None)\n    def circuit(a):\n        qml.RX(a, wires=0)\n        return qml.expval(qml.PauliZ(wires=0))\n\n    assert isinstance(circuit, BaseQNode)\n    assert not isinstance(circuit, JacobianQNode)\n\n    assert not hasattr(circuit, ""interface"")\n    assert not hasattr(circuit, ""jacobian"")\n\n\ndef test_invalid_diff_method():\n    """"""Test exception raised if an invalid diff\n    method is provided""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    with pytest.raises(ValueError, match=r""Differentiation method \\w+ not recognized""):\n        @qnode(dev, interface=None, diff_method=""test"")\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliZ(wires=0))\n\n\ndef test_invalid_interface():\n    """"""Test exception raised if an invalid interface\n    is provided""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    with pytest.raises(ValueError, match=r""Interface \\w+ not recognized""):\n        @qnode(dev, interface=""test"")\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliZ(wires=0))\n\ndef test_classical_diff_method_unsupported():\n    """"""Test exception raised if an the classical diff method is specified for a\n    device that does not support it""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    with pytest.raises(ValueError, match=r""device does not support native computations with ""\n            ""autodifferentiation frameworks""):\n\n        @qnode(dev, diff_method=""backprop"")\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliZ(wires=0))\n\ndef test_device_diff_method_unsupported():\n    """"""Test exception raised if an the device diff method is specified for a\n    device that does not support it""""""\n    dev = qml.device(\'default.qubit\', wires=1)\n\n    with pytest.raises(ValueError, match=r""device does not provide a native method ""\n            ""for computing the jacobian""):\n\n        @qnode(dev, diff_method=""device"")\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliZ(wires=0))\n\ndef test_parameter_shift_diff_method_unsupported():\n    """"""Test exception raised if an the device diff method is specified for a\n    device that does not support it""""""\n    class DummyDevice(qml.plugins.DefaultQubit):\n\n        @classmethod\n        def capabilities(cls):\n            return { ""model"": ""NotSupportedModel""}\n\n\n    dev = DummyDevice(wires=2)\n\n    with pytest.raises(ValueError, match=r""The parameter shift rule is not available for devices with model""):\n\n        @qnode(dev, diff_method=""parameter-shift"")\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliZ(wires=0))\n'"
tests/qnodes/test_qnode_jacobian.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`JacobianQNode` class.\n""""""\nfrom unittest import mock\n\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane._device import Device\nfrom pennylane.operation import CVObservable\nfrom pennylane.qnodes.base import QuantumFunctionError\nfrom pennylane.qnodes.jacobian import JacobianQNode\n\n\n@pytest.fixture(scope=""function"")\ndef operable_mock_device_2_wires(monkeypatch):\n    """"""A mock instance of the abstract Device class that can support qfuncs.""""""\n\n    dev = Device\n    with monkeypatch.context() as m:\n        m.setattr(dev, \'__abstractmethods__\', frozenset())\n        m.setattr(dev, \'_capabilities\', {""model"": ""qubit""})\n        m.setattr(dev, \'operations\', [""BasisState"", ""RX"", ""RY"", ""CNOT"", ""Rot"", ""PhaseShift""])\n        m.setattr(dev, \'observables\', [""PauliX"", ""PauliY"", ""PauliZ""])\n        m.setattr(dev, \'reset\', lambda self: None)\n        m.setattr(dev, \'apply\', lambda self, x, y, z: None)\n        m.setattr(dev, \'expval\', lambda self, x, y, z: 1)\n        yield Device(wires=2)\n\n\nclass TestAJacobianQNodeDetails:\n    """"""Test configuration details of the autograd interface""""""\n\n    def test_interface_str(self, qubit_device_2_wires):\n        """"""Test that the interface string is correctly identified\n        as None""""""\n        def circuit(x, y, z):\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        circuit = JacobianQNode(circuit, qubit_device_2_wires)\n        assert circuit.interface == None\n\n\nclass TestJacobianQNodeExceptions:\n    """"""Tests that JacobianQNode.jacobian raises proper errors.""""""\n\n    def test_gradient_of_sample(self, operable_mock_device_2_wires):\n        """"""Differentiation of a sampled output.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliX(1))\n\n        node = JacobianQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(QuantumFunctionError,\n                           match=""Circuits that include sampling can not be differentiated.""):\n            node.jacobian(1.0)\n\n    def test_nondifferentiable_operator(self, operable_mock_device_2_wires):\n        """"""Differentiating wrt. a parameter\n        that appears as an argument to a nondifferentiable operator.""""""\n\n        def circuit(x):\n            qml.BasisState(np.array([x, 0]), wires=[0, 1])  # not differentiable\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = JacobianQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(ValueError, match=r""Cannot differentiate with respect to argument\\(s\\) \\{\'x\'\\}""):\n            node.jacobian(0.5)\n\n    def test_operator_not_supporting_pd_analytic(self, operable_mock_device_2_wires):\n        """"""Differentiating wrt. a parameter that appears\n        as an argument to an operation that does not support parameter-shift derivatives.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.Hermitian(np.diag([x, 0]), 0))\n\n        node = JacobianQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(ValueError, match=""analytic gradient method cannot be used with""):\n            node.jacobian(0.5, method=""A"")\n\n    def test_bogus_gradient_method_set(self, operable_mock_device_2_wires):\n        """"""The gradient method set is bogus.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        # in mutable mode, the grad method would be\n        # recomputed and overwritten from the\n        # bogus value \'J\'. Caching stops this from happening.\n        node = JacobianQNode(circuit, operable_mock_device_2_wires, mutable=False)\n\n        node.evaluate([0.0], {})\n        node.par_to_grad_method[0] = ""J""\n\n        with pytest.raises(ValueError, match=""Unknown gradient method""):\n            node.jacobian(0.5)\n\n    def test_indices_not_unique(self, operable_mock_device_2_wires):\n        """"""The Jacobian is requested for non-unique indices.""""""\n\n        def circuit(x):\n            qml.Rot(0.3, x, -0.2, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = JacobianQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(ValueError, match=""Parameter indices must be unique.""):\n            node.jacobian(0.5, wrt=[0, 0])\n\n    def test_indices_nonexistant(self, operable_mock_device_2_wires):\n        """""" The Jacobian is requested for non-existant parameters.""""""\n\n        def circuit(x):\n            qml.Rot(0.3, x, -0.2, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = JacobianQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(ValueError, match=""Tried to compute the gradient with respect to""):\n            node.jacobian(0.5, wrt=[0, 6])\n\n        with pytest.raises(ValueError, match=""Tried to compute the gradient with respect to""):\n            node.jacobian(0.5, wrt=[1, -1])\n\n    def test_unknown_gradient_method(self, operable_mock_device_2_wires):\n        """""" The gradient method is unknown.""""""\n\n        def circuit(x):\n            qml.Rot(0.3, x, -0.2, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = JacobianQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(ValueError, match=""Unknown gradient method""):\n            node.jacobian(0.5, method=""unknown"")\n\n    def test_wrong_order_in_finite_difference(self, operable_mock_device_2_wires):\n        """"""Finite difference are attempted with wrong order.""""""\n\n        def circuit(x):\n            qml.Rot(0.3, x, -0.2, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        node = JacobianQNode(circuit, operable_mock_device_2_wires)\n\n        with pytest.raises(ValueError, match=""Order must be 1 or 2""):\n            node.jacobian(0.5, method=""F"", options={\'order\': 3})\n\n\nclass TestBestMethod:\n    """"""Test different flows of _best_method""""""\n\n    def test_all_finite_difference(self, operable_mock_device_2_wires):\n        """"""Finite difference is the best method in almost all cases""""""\n\n        def circuit(x, y, z):\n            qml.Rot(x, y, z, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        q = JacobianQNode(circuit, operable_mock_device_2_wires)\n        q._construct([1.0, 1.0, 1.0], {})\n        assert q.par_to_grad_method == {0: ""F"", 1: ""F"", 2: ""F""}\n\n    def test_no_following_observable(self, operable_mock_device_2_wires):\n        """"""Test that the gradient is 0 if no observables succeed""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0))\n\n        q = JacobianQNode(circuit, operable_mock_device_2_wires)\n        q._construct([1.0], {})\n        assert q.par_to_grad_method == {0: ""0""}\n\n    def test_param_unused(self, operable_mock_device_2_wires):\n        """"""Test that the gradient is 0 of an unused parameter""""""\n\n        def circuit(x, y):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        q = JacobianQNode(circuit, operable_mock_device_2_wires)\n        q._construct([1.0, 1.0], {})\n        assert q.par_to_grad_method == {0: ""F"", 1: ""0""}\n\n    def test_not_differentiable(self, operable_mock_device_2_wires):\n        """"""Test that an operation with grad_method=None is marked as\n        non-differentiable""""""\n\n        def circuit(x):\n            qml.BasisState(x, wires=[1])\n            return qml.expval(qml.PauliZ(0))\n\n        q = JacobianQNode(circuit, operable_mock_device_2_wires)\n        q._construct([np.array([1.0])], {})\n        assert q.par_to_grad_method == {0: None}\n\n\n@pytest.mark.parametrize(""order"", [1, 2])\n@pytest.mark.parametrize(""h"", [0.01, 0.1])\ndef test_finite_difference_options(qubit_device_1_wire, order, h, monkeypatch):\n    """"""Test that the _pd_finite_diff method for calculating the finite difference gradient\n    correctly receives the options set when the JacobianQNode was instantiated.""""""\n\n    def circuit(x):\n        qml.RX(x, wires=0)\n        return qml.expval(qml.PauliZ(0))\n\n    q = JacobianQNode(circuit, qubit_device_1_wire, order=order, h=h)\n\n    _pd_finite_diff = mock.MagicMock(return_value=0)\n\n    with monkeypatch.context() as m:\n        m.setattr(""pennylane.qnodes.jacobian.JacobianQNode._pd_finite_diff"", _pd_finite_diff)\n        q.jacobian(0.2)\n        call_kwargs = _pd_finite_diff.call_args[1]\n\n        assert call_kwargs[""order""] == order\n        assert call_kwargs[""h""] == h\n'"
tests/qnodes/test_qnode_metric_tensor.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`QubitQNode` metric tensor methods.\n""""""\nimport pytest\nimport numpy as np\nfrom scipy.linalg import block_diag\n\nimport pennylane as qml\nfrom pennylane.qnodes.qubit import QubitQNode\nfrom pennylane.qnodes.base import QuantumFunctionError\nfrom gate_data import Y, Z\n\n\nclass TestMetricTensor:\n    """"""Tests for metric tensor subcircuit construction and evaluation""""""\n\n    def test_no_generator(self):\n        """"""Test exception is raised if subcircuit contains an\n        operation with no generator""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def circuit(a):\n            qml.Rot(a, 0, 0, wires=0)\n            return qml.expval(qml.PauliX(0))\n\n        circuit = QubitQNode(circuit, dev)\n\n        with pytest.raises(QuantumFunctionError, match=""has no defined generator""):\n            circuit.metric_tensor([1], only_construct=True)\n\n    def test_generator_no_expval(self, monkeypatch):\n        """"""Test exception is raised if subcircuit contains an\n        operation with generator object that is not an observable""""""\n        dev = qml.device(""default.qubit"", wires=1)\n\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliX(0))\n\n        circuit = QubitQNode(circuit, dev)\n\n        with monkeypatch.context() as m:\n            m.setattr(""pennylane.RX.generator"", [qml.RX, 1])\n\n            with pytest.raises(QuantumFunctionError, match=""no corresponding observable""):\n                circuit.metric_tensor([1], only_construct=True)\n\n    def test_construct_subcircuit(self):\n        """"""Test correct subcircuits constructed""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RY(b, wires=0)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(c, wires=1)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1))\n\n        circuit = QubitQNode(circuit, dev)\n        circuit.metric_tensor([1, 1, 1], only_construct=True)\n        res = circuit._metric_tensor_subcircuits\n\n        # first parameter subcircuit\n        assert len(res[(0,)][""queue""]) == 0\n        assert res[(0,)][""scale""] == [-0.5]\n        assert isinstance(res[(0,)][""observable""][0], qml.PauliX)\n\n        # second parameter subcircuit\n        assert len(res[(1,)][""queue""]) == 1\n        assert res[(1,)][""scale""] == [-0.5]\n        assert isinstance(res[(1,)][""queue""][0], qml.RX)\n        assert isinstance(res[(1,)][""observable""][0], qml.PauliY)\n\n        # third parameter subcircuit\n        assert len(res[(2,)][""queue""]) == 3\n        assert res[(2,)][""scale""] == [1]\n        assert isinstance(res[(2,)][""queue""][0], qml.RX)\n        assert isinstance(res[(2,)][""queue""][1], qml.RY)\n        assert isinstance(res[(2,)][""queue""][2], qml.CNOT)\n        assert isinstance(res[(2,)][""observable""][0], qml.Hermitian)\n        assert np.all(res[(2,)][""observable""][0].params[0] == qml.PhaseShift.generator[0])\n\n    def test_construct_subcircuit_layers(self):\n        """"""Test correct subcircuits constructed\n        when a layer structure exists""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit(params):\n            # section 1\n            qml.RX(params[0], wires=0)\n            # section 2\n            qml.RY(params[1], wires=0)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            # section 3\n            qml.RX(params[2], wires=0)\n            qml.RY(params[3], wires=1)\n            qml.RZ(params[4], wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            # section 4\n            qml.RX(params[5], wires=0)\n            qml.RY(params[6], wires=1)\n            qml.RZ(params[7], wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1)), qml.expval(qml.PauliX(2))\n\n        circuit = QubitQNode(circuit, dev)\n\n        params = np.ones([8])\n        circuit.metric_tensor([params], only_construct=True)\n        res = circuit._metric_tensor_subcircuits\n\n        # this circuit should split into 4 independent\n        # sections or layers when constructing subcircuits\n        assert len(res) == 4\n\n        # first layer subcircuit\n        layer = res[(0,)]\n        assert len(layer[""queue""]) == 0\n        assert len(layer[""observable""]) == 1\n        assert isinstance(layer[""observable""][0], qml.PauliX)\n\n        # second layer subcircuit\n        layer = res[(1,)]\n        assert len(layer[""queue""]) == 1\n        assert len(layer[""observable""]) == 1\n        assert isinstance(layer[""queue""][0], qml.RX)\n        assert isinstance(layer[""observable""][0], qml.PauliY)\n\n        # third layer subcircuit\n        layer = res[(2, 3, 4)]\n        assert len(layer[""queue""]) == 4\n        assert len(layer[""observable""]) == 3\n        assert isinstance(layer[""queue""][0], qml.RX)\n        assert isinstance(layer[""queue""][1], qml.RY)\n        assert isinstance(layer[""queue""][2], qml.CNOT)\n        assert isinstance(layer[""queue""][3], qml.CNOT)\n        assert isinstance(layer[""observable""][0], qml.PauliX)\n        assert isinstance(layer[""observable""][1], qml.PauliY)\n        assert isinstance(layer[""observable""][2], qml.PauliZ)\n\n        # fourth layer subcircuit\n        layer = res[(5, 6, 7)]\n        assert len(layer[""queue""]) == 9\n        assert len(layer[""observable""]) == 3\n        assert isinstance(layer[""queue""][0], qml.RX)\n        assert isinstance(layer[""queue""][1], qml.RY)\n        assert isinstance(layer[""queue""][2], qml.CNOT)\n        assert isinstance(layer[""queue""][3], qml.CNOT)\n        assert isinstance(layer[""queue""][4], qml.RX)\n        assert isinstance(layer[""queue""][5], qml.RY)\n        assert isinstance(layer[""queue""][6], qml.RZ)\n        assert isinstance(layer[""queue""][7], qml.CNOT)\n        assert isinstance(layer[""queue""][8], qml.CNOT)\n        assert isinstance(layer[""observable""][0], qml.PauliX)\n        assert isinstance(layer[""observable""][1], qml.PauliY)\n        assert isinstance(layer[""observable""][2], qml.PauliZ)\n\n    def test_evaluate_subcircuits(self, tol):\n        """"""Test subcircuits evaluate correctly""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RY(b, wires=0)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(c, wires=1)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1))\n\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.432\n        b = 0.12\n        c = -0.432\n\n        # evaluate subcircuits\n        circuit.metric_tensor((a, b, c))\n\n        # first parameter subcircuit\n        res = circuit._metric_tensor_subcircuits[(0,)][""result""]\n        expected = 0.25\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # second parameter subcircuit\n        res = circuit._metric_tensor_subcircuits[(1,)][""result""]\n        expected = np.cos(a) ** 2 / 4\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n        # third parameter subcircuit\n        res = circuit._metric_tensor_subcircuits[(2,)][""result""]\n        expected = (3 - 2 * np.cos(a) ** 2 * np.cos(2 * b) - np.cos(2 * a)) / 16\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    def test_evaluate_diag_metric_tensor(self, tol):\n        """"""Test that a diagonal metric tensor evaluates correctly""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RY(b, wires=0)\n            qml.CNOT(wires=[0, 1])\n            qml.PhaseShift(c, wires=1)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1))\n\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.432\n        b = 0.12\n        c = -0.432\n\n        # evaluate metric tensor\n        g = circuit.metric_tensor((a, b, c))\n\n        # check that the metric tensor is correct\n        expected = (\n            np.array(\n                [1, np.cos(a) ** 2, (3 - 2 * np.cos(a) ** 2 * np.cos(2 * b) - np.cos(2 * a)) / 4]\n            )\n            / 4\n        )\n        assert np.allclose(g, np.diag(expected), atol=tol, rtol=0)\n\n    @pytest.fixture\n    def sample_circuit(self):\n        """"""Sample variational circuit fixture used in the\n        next couple of tests""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def non_parametrized_layer(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.CNOT(wires=[1, 2])\n            qml.RZ(a, wires=0)\n            qml.Hadamard(wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.RZ(b, wires=1)\n            qml.Hadamard(wires=0)\n\n        a = 0.5\n        b = 0.1\n        c = 0.5\n\n        def final(x, y, z, h, g, f):\n            non_parametrized_layer(a, b, c)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.RZ(z, wires=2)\n            non_parametrized_layer(a, b, c)\n            qml.RY(f, wires=1)\n            qml.RZ(g, wires=2)\n            qml.RX(h, wires=1)\n            return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1)), qml.expval(qml.PauliX(2))\n\n        final = QubitQNode(final, dev)\n\n        return dev, final, non_parametrized_layer, a, b, c\n\n    def test_evaluate_block_diag_metric_tensor(self, sample_circuit, tol):\n        """"""Test that a block diagonal metric tensor evaluates correctly,\n        by comparing it to a known analytic result as well as numerical\n        computation.""""""\n        dev, circuit, non_parametrized_layer, a, b, c = sample_circuit\n\n        params = [-0.282203, 0.145554, 0.331624, -0.163907, 0.57662, 0.081272]\n        x, y, z, h, g, f = params\n\n        G = circuit.metric_tensor(params)\n\n        # ============================================\n        # Test block diag metric tensor of first layer is correct.\n        # We do this by comparing against the known analytic result.\n        # First layer includes the non_parametrized_layer,\n        # followed by observables corresponding to generators of:\n        #   qml.RX(x, wires=0)\n        #   qml.RY(y, wires=1)\n        #   qml.RZ(z, wires=2)\n\n        G1 = np.zeros([3, 3])\n\n        # diag elements\n        G1[0, 0] = np.sin(a) ** 2 / 4\n        G1[1, 1] = (\n            16 * np.cos(a) ** 2 * np.sin(b) ** 3 * np.cos(b) * np.sin(2 * c)\n            + np.cos(2 * b) * (2 - 8 * np.cos(a) ** 2 * np.sin(b) ** 2 * np.cos(2 * c))\n            + np.cos(2 * (a - b))\n            + np.cos(2 * (a + b))\n            - 2 * np.cos(2 * a)\n            + 14\n        ) / 64\n        G1[2, 2] = (3 - np.cos(2 * a) - 2 * np.cos(a) ** 2 * np.cos(2 * (b + c))) / 16\n\n        # off diag elements\n        G1[0, 1] = np.sin(a) ** 2 * np.sin(b) * np.cos(b + c) / 4\n        G1[0, 2] = np.sin(a) ** 2 * np.cos(b + c) / 4\n        G1[1, 2] = (\n            -np.sin(b)\n            * (\n                np.cos(2 * (a - b - c))\n                + np.cos(2 * (a + b + c))\n                + 2 * np.cos(2 * a)\n                + 2 * np.cos(2 * (b + c))\n                - 6\n            )\n            / 32\n        )\n\n        G1[1, 0] = G1[0, 1]\n        G1[2, 0] = G1[0, 2]\n        G1[2, 1] = G1[1, 2]\n\n        assert np.allclose(G[:3, :3], G1, atol=tol, rtol=0)\n\n        # =============================================\n        # Test block diag metric tensor of second layer is correct.\n        # We do this by computing the required expectation values\n        # numerically.\n        # The second layer includes the non_parametrized_layer,\n        # RX, RY, RZ gates (x, y, z params), a 2nd non_parametrized_layer,\n        # followed by the qml.RY(f, wires=2) operation.\n        #\n        # Observable is simply generator of:\n        #   qml.RY(f, wires=2)\n        #\n        # Note: since this layer only consists of a single parameter,\n        # only need to compute a single diagonal element.\n\n        def layer2_diag(x, y, z, h, g, f):\n            non_parametrized_layer(a, b, c)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.RZ(z, wires=2)\n            non_parametrized_layer(a, b, c)\n            qml.RY(f, wires=2)\n            return qml.var(qml.PauliX(1))\n\n        layer2_diag = QubitQNode(layer2_diag, dev)\n        G2 = layer2_diag(x, y, z, h, g, f) / 4\n        assert np.allclose(G[3:4, 3:4], G2, atol=tol, rtol=0)\n\n        # =============================================\n        # Test block diag metric tensor of third layer is correct.\n        # We do this by computing the required expectation values\n        # numerically using multiple circuits.\n        # The second layer includes the non_parametrized_layer,\n        # RX, RY, RZ gates (x, y, z params), and a 2nd non_parametrized_layer.\n        #\n        # Observables are the generators of:\n        #   qml.RY(f, wires=1)\n        #   qml.RZ(g, wires=2)\n        G3 = np.zeros([2, 2])\n\n        def layer3_diag(x, y, z, h, g, f):\n            non_parametrized_layer(a, b, c)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.RZ(z, wires=2)\n            non_parametrized_layer(a, b, c)\n            return qml.var(qml.PauliZ(2)), qml.var(qml.PauliY(1))\n\n        layer3_diag = QubitQNode(layer3_diag, dev)\n\n        def layer3_off_diag_first_order(x, y, z, h, g, f):\n            non_parametrized_layer(a, b, c)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.RZ(z, wires=2)\n            non_parametrized_layer(a, b, c)\n            return qml.expval(qml.PauliZ(2)), qml.expval(qml.PauliY(1))\n\n        layer3_off_diag_first_order = QubitQNode(layer3_off_diag_first_order, dev)\n\n        def layer3_off_diag_second_order(x, y, z, h, g, f):\n            non_parametrized_layer(a, b, c)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.RZ(z, wires=2)\n            non_parametrized_layer(a, b, c)\n            return qml.expval(qml.Hermitian(np.kron(Z, Y), wires=[2, 1]))\n\n        layer3_off_diag_second_order = QubitQNode(layer3_off_diag_second_order, dev)\n\n        # calculate the diagonal terms\n        varK0, varK1 = layer3_diag(x, y, z, h, g, f)\n        G3[0, 0] = varK0 / 4\n        G3[1, 1] = varK1 / 4\n\n        # calculate the off-diagonal terms\n        exK0, exK1 = layer3_off_diag_first_order(x, y, z, h, g, f)\n        exK01 = layer3_off_diag_second_order(x, y, z, h, g, f)\n\n        G3[0, 1] = (exK01 - exK0 * exK1) / 4\n        G3[1, 0] = (exK01 - exK0 * exK1) / 4\n\n        assert np.allclose(G[4:6, 4:6], G3, atol=tol, rtol=0)\n\n        # ============================================\n        # Finally, double check that the entire metric\n        # tensor is as computed.\n\n        G_expected = block_diag(G1, G2, G3)\n        assert np.allclose(G, G_expected, atol=tol, rtol=0)\n\n    def test_evaluate_diag_approx_metric_tensor(self, sample_circuit, tol):\n        """"""Test that a metric tensor under the\n        diagonal approximation evaluates correctly.""""""\n        dev, circuit, non_parametrized_layer, a, b, c = sample_circuit\n        params = [-0.282203, 0.145554, 0.331624, -0.163907, 0.57662, 0.081272]\n        x, y, z, h, g, f = params\n\n        G = circuit.metric_tensor(params, diag_approx=True)\n\n        # ============================================\n        # Test block diag metric tensor of first layer is correct.\n        # We do this by comparing against the known analytic result.\n        # First layer includes the non_parametrized_layer,\n        # followed by observables corresponding to generators of:\n        #   qml.RX(x, wires=0)\n        #   qml.RY(y, wires=1)\n        #   qml.RZ(z, wires=2)\n\n        G1 = np.zeros([3, 3])\n\n        # diag elements\n        G1[0, 0] = np.sin(a) ** 2 / 4\n        G1[1, 1] = (\n            16 * np.cos(a) ** 2 * np.sin(b) ** 3 * np.cos(b) * np.sin(2 * c)\n            + np.cos(2 * b) * (2 - 8 * np.cos(a) ** 2 * np.sin(b) ** 2 * np.cos(2 * c))\n            + np.cos(2 * (a - b))\n            + np.cos(2 * (a + b))\n            - 2 * np.cos(2 * a)\n            + 14\n        ) / 64\n        G1[2, 2] = (3 - np.cos(2 * a) - 2 * np.cos(a) ** 2 * np.cos(2 * (b + c))) / 16\n\n        assert np.allclose(G[:3, :3], G1, atol=tol, rtol=0)\n\n        # =============================================\n        # Test metric tensor of second layer is correct.\n        # We do this by computing the required expectation values\n        # numerically.\n        # The second layer includes the non_parametrized_layer,\n        # RX, RY, RZ gates (x, y, z params), a 2nd non_parametrized_layer,\n        # followed by the qml.RY(f, wires=2) operation.\n        #\n        # Observable is simply generator of:\n        #   qml.RY(f, wires=2)\n        #\n        # Note: since this layer only consists of a single parameter,\n        # only need to compute a single diagonal element.\n\n        def layer2_diag(x, y, z, h, g, f):\n            non_parametrized_layer(a, b, c)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.RZ(z, wires=2)\n            non_parametrized_layer(a, b, c)\n            qml.RY(f, wires=2)\n            return qml.var(qml.PauliX(1))\n\n        layer2_diag = QubitQNode(layer2_diag, dev)\n        G2 = layer2_diag(x, y, z, h, g, f) / 4\n        assert np.allclose(G[3:4, 3:4], G2, atol=tol, rtol=0)\n\n        # =============================================\n        # Test block diag metric tensor of third layer is correct.\n        # We do this by computing the required expectation values\n        # numerically using multiple circuits.\n        # The second layer includes the non_parametrized_layer,\n        # RX, RY, RZ gates (x, y, z params), and a 2nd non_parametrized_layer.\n        #\n        # Observables are the generators of:\n        #   qml.RY(f, wires=1)\n        #   qml.RZ(g, wires=2)\n        G3 = np.zeros([2, 2])\n\n        def layer3_diag(x, y, z, h, g, f):\n            non_parametrized_layer(a, b, c)\n            qml.RX(x, wires=0)\n            qml.RY(y, wires=1)\n            qml.RZ(z, wires=2)\n            non_parametrized_layer(a, b, c)\n            return qml.var(qml.PauliZ(2)), qml.var(qml.PauliY(1))\n\n        layer3_diag = QubitQNode(layer3_diag, dev)\n\n        # calculate the diagonal terms\n        varK0, varK1 = layer3_diag(x, y, z, h, g, f)\n        G3[0, 0] = varK0 / 4\n        G3[1, 1] = varK1 / 4\n\n        assert np.allclose(G[4:6, 4:6], G3, atol=tol, rtol=0)\n\n        # ============================================\n        # Finally, double check that the entire metric\n        # tensor is as computed.\n\n        G_expected = block_diag(G1, G2, G3)\n        assert np.allclose(G, G_expected, atol=tol, rtol=0)\n'"
tests/qnodes/test_qnode_passthru.py,21,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane` :class:`.PassthruQNode` class.\n""""""\nimport pytest\nimport numpy as np\n\ntry:\n    import tensorflow as tf\n\n    if tf.__version__[0] == ""1"":\n        tf = None  # default.tensor.tf requires TF 2\n    else:\n        from tensorflow import Variable\nexcept ImportError:\n    tf = None\n\nimport pennylane as qml\nfrom pennylane.qnodes import PassthruQNode, BaseQNode, JacobianQNode\n\n\n\n@pytest.fixture(scope=""function"")\ndef mock_qnode(mock_device):\n    """"""Simple PassthruQNode with default properties.""""""\n\n    def circuit(x):\n        qml.RX(x, wires=0)\n        return qml.expval(qml.PauliZ(0))\n\n    node = PassthruQNode(circuit, mock_device)\n    return node\n\n\nclass TestPassthruBasics:\n    """"""Tests basic PassthruQNode properties.""""""\n\n    def test_always_mutable(self, mock_qnode):\n        """"""PassthruQNodes are always mutable.""""""\n        assert mock_qnode.mutable\n\n    def test_repr(self, mock_qnode):\n        """"""String representation.""""""\n        assert repr(mock_qnode) == ""<PassthruQNode: device=\'mock_device\', func=circuit, wires=2>""\n\n    def test_immutable_error(self, mock_device):\n        """"""Test that an error is raised if the mutable=False option is passed\n        upon instantiation""""""\n        def circuit(x):\n            qml.RX(x, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=r""PassthruQNode does not support immutable mode""):\n            node = PassthruQNode(circuit, mock_device, mutable=False)\n\n@pytest.mark.skipif(tf is None, reason=""TensorFlow 2.0 not found."")\n@pytest.fixture(scope=""function"")\ndef tensornet_tf_device():\n    return qml.device(\'default.tensor.tf\', wires=2)\n\n\n@pytest.mark.skipif(tf is None, reason=""TensorFlow 2.0 not found."")\nclass TestPassthruTF:\n    """"""Test that TF objects can be successfully passed through to a TF simulator device, and back to user.""""""\n\n    # real data type used by the default.tensor.tf plugin (TensorFlow is strict about types)\n    DTYPE = tf.float64 if tf else None\n\n    def test_arraylike_args(self, tensornet_tf_device, tol):\n        """"""Tests that PassthruQNode can use array-like TF objects as positional arguments.""""""\n\n        def circuit(x):\n            qml.RX(x[0], wires=[0])\n            qml.RX(2*x[1], wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = PassthruQNode(circuit, tensornet_tf_device)\n        x = tf.Variable([1.1, 1.4], dtype=self.DTYPE)\n        res = node(x)\n        assert isinstance(res, tf.Tensor)\n        assert res.shape == (2,)\n        assert res.dtype == self.DTYPE\n\n    def test_arraylike_keywordargs(self, tensornet_tf_device, tol):\n        """"""Tests that qnodes use array-like TF objects as keyword-only arguments.""""""\n\n        def circuit(*, x=None):\n            qml.RX(x[0], wires=[0])\n            qml.RX(2*x[1], wires=[1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        node = PassthruQNode(circuit, tensornet_tf_device)\n        x = tf.Variable([1.1, 1.4], dtype=self.DTYPE)\n        res = node(x=x)\n        assert isinstance(res, tf.Tensor)\n        assert res.shape == (2,)\n        assert res.dtype == self.DTYPE\n\n    def test_tensor_operations(self, tensornet_tf_device, tol):\n        """"""Tests the evaluation of a PassthruQNode involving algebraic operations between tensor parameters,\n        and TF functions acting on them.""""""\n\n        def circuit(phi, theta):\n            x = phi * theta\n            qml.RX(x[0], wires=0)\n            qml.RY(tf.cos(x[1]), wires=1)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n\n        node = PassthruQNode(circuit, tensornet_tf_device)\n\n        phi = tf.Variable(np.array([0.7, -1.2]), dtype=self.DTYPE)\n        theta = tf.Variable(1.7, dtype=self.DTYPE)\n        res = node(phi, theta)\n        assert isinstance(res, tf.Tensor)\n        assert res.shape == (2,)\n        assert res.dtype == self.DTYPE\n\n    def test_evaluate(self, tensornet_tf_device, tol):\n        """"""Tests the evaluation of a PassthruQNode.""""""\n\n        def circuit(x):\n            qml.RX(x[0], wires=0)\n            qml.RY(x[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.RX(x[2], wires=1)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        x = np.array([-1.4, 0.2, 2.1])\n        x_tf = tf.Variable(x, dtype=self.DTYPE)\n\n        node = PassthruQNode(circuit, tensornet_tf_device)\n        res = node(x_tf)\n\n        # compare to a reference node\n        #ref_device = qml.device(\'default.qubit\', wires=2)\n        #ref_node = BaseQNode(circuit, ref_device)\n        #ref_res = ref_node(x)\n        # analytic result\n        ref_res = np.cos(x[0]) * np.array([1.0, np.cos(x[1]) * np.cos(x[2])])\n\n        assert isinstance(res, tf.Tensor)\n        assert res.shape == (2,)\n        assert res.dtype == self.DTYPE\n        assert res.numpy() == pytest.approx(ref_res, abs=tol)\n\n    def test_circuit_with_decomposition(self, tol):\n        """"""Tests a PassthruQNode in which the circuit contains an operation\n        that needs to be decomposed.""""""\n        theta = 0.543\n        phi = -0.234\n        lam = 0.654\n        p = [theta, phi, lam]\n\n        dev = qml.device(""default.tensor.tf"", wires=1)\n\n        def circuit(weights):\n            qml.QubitStateVector(1j*np.array([1, -1])/np.sqrt(2), wires=[0])\n            qml.U3(weights[0], weights[1], weights[2], wires=[0])    # <--- decomposition is required\n            return qml.expval(qml.PauliX(0))\n\n        node = PassthruQNode(circuit, dev, interface=""tf"")\n\n        params = tf.Variable(p, dtype=tf.float64)\n\n        with tf.GradientTape() as tape:\n            tape.watch(params)\n            res = node(params)\n\n        expected = np.sin(lam)*np.sin(phi) - np.cos(theta)*np.cos(lam)*np.cos(phi)\n        assert np.allclose(res, expected, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(""vectorize_jacobian"", [True, False])\n    def test_jacobian(self, tensornet_tf_device, vectorize_jacobian, tol):\n        """"""Tests the computing of the Jacobian of a PassthruQNode using TensorFlow.""""""\n\n        def circuit(phi, theta):\n            qml.RX(phi[0], wires=0)\n            qml.RY(phi[1], wires=1)\n            qml.CNOT(wires=[0, 1])\n            qml.RX(theta, wires=1)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        ph = np.array([0.7, -1.2])\n        th = 1.7\n        phi = tf.Variable(ph, dtype=self.DTYPE)\n        theta = tf.Variable(th, dtype=self.DTYPE)\n\n        node = PassthruQNode(circuit, tensornet_tf_device)\n        # In TF 2, tf.GradientTape.jacobian comes with a vectorization option.\n        with tf.GradientTape(persistent=not vectorize_jacobian) as tape:\n            tape.watch([phi, theta])\n            res = node(phi, theta)\n        phi_grad, theta_grad = tape.jacobian(res, [phi, theta],\n                                             unconnected_gradients=tf.UnconnectedGradients.ZERO,\n                                             experimental_use_pfor=vectorize_jacobian)\n\n        # compare to a reference Jacobian computed using finite differences\n        #ref_device = qml.device(\'default.qubit\', wires=2)\n        #ref_node = JacobianQNode(circuit, ref_device)\n        #ref_jac = ref_node.jacobian([ph, th])\n        # analytic result\n        ref_jac = np.array([\n            [-np.sin(ph[0]), 0., 0.],\n            [-np.sin(ph[0]) * np.cos(ph[1]) * np.cos(th),\n             np.cos(ph[0]) * -np.sin(ph[1]) * np.cos(th),\n             np.cos(ph[0]) * np.cos(ph[1]) * -np.sin(th)]\n        ])\n\n        assert isinstance(phi_grad, tf.Tensor)\n        assert phi_grad.shape == (2, 2)\n        assert phi_grad.dtype == self.DTYPE\n        assert phi_grad.numpy() == pytest.approx(ref_jac[:, 0:2], abs=tol)\n\n        assert isinstance(theta_grad, tf.Tensor)\n        assert theta_grad.shape == (2,)\n        assert theta_grad.dtype == self.DTYPE\n        assert theta_grad.numpy() == pytest.approx(ref_jac[:, 2], abs=tol)\n'"
tests/qnodes/test_qnode_qubit.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the PennyLane :class:`~.QubitQNode` class.\n""""""\nimport pytest\nimport numpy as np\n\nimport pennylane as qml\nfrom pennylane._device import Device\nfrom pennylane.operation import CVObservable\nfrom pennylane.qnodes.base import QuantumFunctionError\nfrom pennylane.qnodes.qubit import QubitQNode\n\n\nthetas = np.linspace(-2*np.pi, 2*np.pi, 8)\n\n\n@pytest.fixture(scope=""function"")\ndef operable_mock_device_2_wires(monkeypatch):\n    """"""A mock instance of the abstract Device class that can support qfuncs.""""""\n\n    dev = Device\n    with monkeypatch.context() as m:\n        m.setattr(dev, \'__abstractmethods__\', frozenset())\n        m.setattr(dev, \'_capabilities\', {""model"": ""qubit""})\n        m.setattr(dev, \'operations\', [""BasisState"", ""RX"", ""RY"", ""CNOT"", ""Rot"", ""PhaseShift""])\n        m.setattr(dev, \'observables\', [""PauliX"", ""PauliY"", ""PauliZ""])\n        m.setattr(dev, \'reset\', lambda self: None)\n        m.setattr(dev, \'apply\', lambda self, x, y, z: None)\n        m.setattr(dev, \'expval\', lambda self, x, y, z: 1)\n        yield Device(wires=2)\n\n\nclass TestBestMethod:\n    """"""Test different flows of _best_method""""""\n\n    def test_no_following_observable(self, operable_mock_device_2_wires):\n        """"""Test that the gradient is 0 if no observables succeed""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[1])\n            return qml.expval(qml.PauliZ(0))\n\n        q = QubitQNode(circuit, operable_mock_device_2_wires)\n        q._construct([1.0], {})\n        assert q.par_to_grad_method == {0: ""0""}\n\n    def test_param_unused(self, operable_mock_device_2_wires):\n        """"""Test that the gradient is 0 of an unused parameter""""""\n\n        def circuit(x, y):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        q = QubitQNode(circuit, operable_mock_device_2_wires)\n        q._construct([1.0, 1.0], {})\n        assert q.par_to_grad_method == {0: ""A"", 1: ""0""}\n\n    def test_not_differentiable(self, operable_mock_device_2_wires):\n        """"""Test that an operation with grad_method=None is marked as\n        non-differentiable""""""\n\n        def circuit(x):\n            qml.BasisState(x, wires=[1])\n            return qml.expval(qml.PauliZ(0))\n\n        q = QubitQNode(circuit, operable_mock_device_2_wires)\n        q._construct([np.array([1.0])], {})\n        assert q.par_to_grad_method == {0: None}\n\n\nclass TestExpectationJacobian:\n    """"""Jacobian integration tests for qubit expectations.""""""\n\n    @pytest.mark.parametrize(""mult"", [1, -2, 1.623, -0.051, 0])  # intergers, floats, zero\n    def test_parameter_multipliers(self, mult, tol):\n        """"""Test that various types and values of scalar multipliers for differentiable\n        qfunc parameters yield the correct gradients.""""""\n\n        def circuit(x):\n            qml.RY(mult * x, wires=[0])\n            return qml.expval(qml.PauliX(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        q = QubitQNode(circuit, dev)\n\n        par = [0.1]\n\n        # gradients\n        exact = mult * np.cos(mult * np.array([par]))\n        grad_F = q.jacobian(par, method=""F"")\n        grad_A = q.jacobian(par, method=""A"")\n\n        # different methods must agree\n        assert grad_F == pytest.approx(exact, abs=tol)\n        assert grad_A == pytest.approx(exact, abs=tol)\n\n    @pytest.mark.parametrize(""reused_p"", thetas ** 3 / 19)\n    @pytest.mark.parametrize(""other_p"", thetas ** 2 / 1)\n    def test_fanout_multiple_params(self, reused_p, other_p, tol):\n        """"""Tests that the correct gradient is computed for qnodes which\n        use the same parameter in multiple gates.""""""\n\n        from gate_data import Rotx as Rx, Roty as Ry, Rotz as Rz\n\n        def expZ(state):\n            return np.abs(state[0]) ** 2 - np.abs(state[1]) ** 2\n\n        extra_param = 0.31\n        def circuit(reused_param, other_param):\n            qml.RX(extra_param, wires=[0])\n            qml.RY(reused_param, wires=[0])\n            qml.RZ(other_param, wires=[0])\n            qml.RX(reused_param, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        f = QubitQNode(circuit, dev)\n        zero_state = np.array([1., 0.])\n\n        # analytic gradient\n        grad_A = f.jacobian([reused_p, other_p])\n\n        # manual gradient\n        grad_true0 = (expZ(Rx(reused_p) @ Rz(other_p) @ Ry(reused_p + np.pi / 2) @ Rx(extra_param) @ zero_state) \\\n                     -expZ(Rx(reused_p) @ Rz(other_p) @ Ry(reused_p - np.pi / 2) @ Rx(extra_param) @ zero_state)) / 2\n        grad_true1 = (expZ(Rx(reused_p + np.pi / 2) @ Rz(other_p) @ Ry(reused_p) @ Rx(extra_param) @ zero_state) \\\n                     -expZ(Rx(reused_p - np.pi / 2) @ Rz(other_p) @ Ry(reused_p) @ Rx(extra_param) @ zero_state)) / 2\n        grad_true = grad_true0 + grad_true1 # product rule\n\n        assert grad_A[0, 0] == pytest.approx(grad_true, abs=tol)\n\n    @pytest.mark.parametrize(""shape"", [(8,), (8, 1), (4, 2), (2, 2, 2), (2, 1, 2, 1, 2)])\n    def test_multidim_array_parameter(self, shape, tol):\n        """"""Tests that arguments which are multidimensional arrays are\n        properly evaluated and differentiated in QubitQNodes.""""""\n\n        n = np.prod(shape)\n        base_array = np.linspace(-1.0, 1.0, n)\n        multidim_array = np.reshape(base_array, shape)\n\n        def circuit(w):\n            for k in range(n):\n                qml.RX(w[np.unravel_index(k, shape)], wires=k)  # base_array[k]\n            return tuple(qml.expval(qml.PauliZ(idx)) for idx in range(n))\n\n        dev = qml.device(""default.qubit"", wires=n)\n        circuit = QubitQNode(circuit, dev)\n\n        # circuit evaluations\n        circuit_output = circuit(multidim_array)\n        expected_output = np.cos(base_array)\n        assert circuit_output == pytest.approx(expected_output, abs=tol)\n\n        # circuit jacobians\n        circuit_jacobian = circuit.jacobian([multidim_array])\n        expected_jacobian = -np.diag(np.sin(base_array))\n        assert circuit_jacobian == pytest.approx(expected_jacobian, abs=tol)\n\n    def test_gradient_gate_with_multiple_parameters(self, tol):\n        """"""Tests that gates with multiple free parameters yield correct gradients.""""""\n        par = [0.5, 0.3, -0.7]\n\n        def qf(x, y, z):\n            qml.RX(0.4, wires=[0])\n            qml.Rot(x, y, z, wires=[0])\n            qml.RY(-0.2, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        q = QubitQNode(qf, dev)\n        value = q(*par)\n        grad_A = q.jacobian(par, method=""A"")\n        grad_F = q.jacobian(par, method=""F"")\n\n        # analytic method works for every parameter\n        assert q.par_to_grad_method == {0: ""A"", 1: ""A"", 2: ""A""}\n        # gradient has the correct shape and every element is nonzero\n        assert grad_A.shape == (1, 3)\n        assert np.count_nonzero(grad_A) == 3\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n\n    def test_gradient_repeated_gate_parameters(self, tol):\n        """"""Tests that repeated use of a free parameter in a\n        multi-parameter gate yield correct gradients.""""""\n        par = [0.8, 1.3]\n\n        def qf(x, y):\n            qml.RX(np.pi / 4, wires=[0])\n            qml.Rot(y, x, 2 * x, wires=[0])\n            return qml.expval(qml.PauliX(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        q = QubitQNode(qf, dev)\n        grad_A = q.jacobian(par, method=""A"")\n        grad_F = q.jacobian(par, method=""F"")\n\n        # the different methods agree\n        assert grad_A == pytest.approx(grad_F, abs=tol)\n\n    def test_gradient_parameters_inside_array(self, tol):\n        """"""Tests that free parameters inside an array passed to\n        an Operation yield correct gradients.""""""\n        par = [0.8, 1.3]\n\n        def qf(x, y):\n            qml.RX(x, wires=[0])\n            qml.RY(x, wires=[0])\n            return qml.expval(qml.Hermitian(np.diag([y, 1]), 0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        q = QubitQNode(qf, dev)\n        grad = q.jacobian(par)\n        grad_F = q.jacobian(par, method=""F"")\n\n        # par[0] can use the ""A"" method, par[1] cannot\n        assert q.par_to_grad_method == {0: ""A"", 1: ""F""}\n        # the different methods agree\n        assert grad == pytest.approx(grad_F, abs=tol)\n\n    def test_keywordarg_not_differentiated(self, tol):\n        """"""Tests that qnodes do not differentiate w.r.t. keyword arguments.""""""\n        par = np.array([0.5, 0.54])\n\n        def circuit1(weights, x=0.3):\n            qml.QubitStateVector(np.array([1, 0, 1, 1]) / np.sqrt(3), wires=[0, 1])\n            qml.Rot(weights[0], weights[1], x, wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        dev = qml.device(""default.qubit"", wires=2)\n        circuit1 = QubitQNode(circuit1, dev)\n\n        def circuit2(weights):\n            qml.QubitStateVector(np.array([1, 0, 1, 1]) / np.sqrt(3), wires=[0, 1])\n            qml.Rot(weights[0], weights[1], 0.3, wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        circuit2 = QubitQNode(circuit2, dev)\n\n        res1 = circuit1.jacobian([par])\n        res2 = circuit2.jacobian([par])\n        assert res1 == pytest.approx(res2, abs=tol)\n\n    def test_differentiate_all_positional(self, tol):\n        """"""Tests that all positional arguments are differentiated.""""""\n\n        def circuit1(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RX(b, wires=1)\n            qml.RX(c, wires=2)\n            return tuple(qml.expval(qml.PauliZ(idx)) for idx in range(3))\n\n        dev = qml.device(""default.qubit"", wires=3)\n        circuit1 = QubitQNode(circuit1, dev)\n\n        vals = np.array([np.pi, np.pi / 2, np.pi / 3])\n        circuit_output = circuit1(*vals)\n        expected_output = np.cos(vals)\n        assert circuit_output == pytest.approx(expected_output, abs=tol)\n\n        # circuit jacobians\n        circuit_jacobian = circuit1.jacobian(vals)\n        expected_jacobian = -np.diag(np.sin(vals))\n        assert circuit_jacobian == pytest.approx(expected_jacobian, abs=tol)\n\n    def test_differentiate_first_positional(self, tol):\n        """"""Tests that the first positional arguments are differentiated.""""""\n\n        def circuit2(a, b):\n            qml.RX(a, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=2)\n        circuit2 = QubitQNode(circuit2, dev)\n\n        a = 0.7418\n        b = -5.0\n        circuit_output = circuit2(a, b)\n        expected_output = np.cos(a)\n        assert circuit_output == pytest.approx(expected_output, abs=tol)\n\n        # circuit jacobians\n        circuit_jacobian = circuit2.jacobian([a, b])\n        expected_jacobian = np.array([[-np.sin(a), 0]])\n        assert circuit_jacobian == pytest.approx(expected_jacobian, abs=tol)\n\n    def test_differentiate_second_positional(self, tol):\n        """"""Tests that the second positional arguments are differentiated.""""""\n\n        def circuit3(a, b):\n            qml.RX(b, wires=0)\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=2)\n        circuit3 = QubitQNode(circuit3, dev)\n\n        a = 0.7418\n        b = -5.0\n        circuit_output = circuit3(a, b)\n        expected_output = np.cos(b)\n        assert circuit_output == pytest.approx(expected_output, abs=tol)\n\n        # circuit jacobians\n        circuit_jacobian = circuit3.jacobian([a, b])\n        expected_jacobian = np.array([[0, -np.sin(b)]])\n        assert circuit_jacobian == pytest.approx(expected_jacobian, abs=tol)\n\n    def test_differentiate_second_third_positional(self, tol):\n        """"""Tests that the second and third positional arguments are differentiated.""""""\n\n        def circuit4(a, b, c):\n            qml.RX(b, wires=0)\n            qml.RX(c, wires=1)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\n        dev = qml.device(""default.qubit"", wires=2)\n        circuit4 = QubitQNode(circuit4, dev)\n\n        a = 0.7418\n        b = -5.0\n        c = np.pi / 7\n        circuit_output = circuit4(a, b, c)\n        expected_output = np.array([np.cos(b), np.cos(c)])\n        assert circuit_output == pytest.approx(expected_output, abs=tol)\n\n        # circuit jacobians\n        circuit_jacobian = circuit4.jacobian([a, b, c])\n        expected_jacobian = np.array([[0.0, -np.sin(b), 0.0], [0.0, 0.0, -np.sin(c)]])\n        assert circuit_jacobian == pytest.approx(expected_jacobian, abs=tol)\n\n    def test_differentiate_positional_multidim(self, tol):\n        """"""Tests that all positional arguments are differentiated\n        when they are multidimensional.""""""\n\n        def circuit(a, b):\n            qml.RX(a[0], wires=0)\n            qml.RX(a[1], wires=1)\n            qml.RX(b[2, 1], wires=2)\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliZ(2))\n\n        dev = qml.device(""default.qubit"", wires=3)\n        circuit = QubitQNode(circuit, dev)\n\n        a = np.array([-np.sqrt(2), -0.54])\n        b = np.array([np.pi / 7] * 6).reshape([3, 2])\n        circuit_output = circuit(a, b)\n        expected_output = np.cos(np.array([a[0], a[1], b[-1, 0]]))\n        assert circuit_output == pytest.approx(expected_output, abs=tol)\n\n        # circuit jacobians\n        circuit_jacobian = circuit.jacobian([a, b])\n        expected_jacobian = np.array(\n            [\n                [-np.sin(a[0])] + [0.0] * 7,  # expval 0\n                [0.0, -np.sin(a[1])] + [0.0] * 6,  # expval 1\n                [0.0] * 2 + [0.0] * 5 + [-np.sin(b[2, 1])],\n            ]\n        )  # expval 2\n        assert circuit_jacobian == pytest.approx(expected_jacobian, abs=tol)\n\n    def test_array_parameters_evaluate(self, tol):\n        """"""Tests that array parameters gives same result as positional arguments.""""""\n        a, b, c = 0.5, 0.54, 0.3\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def ansatz(x, y, z):\n            qml.QubitStateVector(np.array([1, 0, 1, 1]) / np.sqrt(3), wires=[0, 1])\n            qml.Rot(x, y, z, wires=0)\n            qml.CNOT(wires=[0, 1])\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n\n        def circuit1(x, y, z):\n            return ansatz(x, y, z)\n\n        def circuit2(x, array):\n            return ansatz(x, array[0], array[1])\n\n        def circuit3(array):\n            return ansatz(*array)\n\n        circuit1 = QubitQNode(circuit1, dev)\n        circuit2 = QubitQNode(circuit2, dev)\n        circuit3 = QubitQNode(circuit3, dev)\n\n        positional_res = circuit1(a, b, c)\n        positional_grad = circuit1.jacobian([a, b, c])\n\n        array_res = circuit2(a, np.array([b, c]))\n        array_grad = circuit2.jacobian([a, np.array([b, c])])\n\n        assert positional_res == pytest.approx(array_res, abs=tol)\n        assert positional_grad == pytest.approx(array_grad, abs=tol)\n\n        list_res = circuit2(a, [b, c])\n        list_grad = circuit2.jacobian([a, [b, c]])\n\n        assert positional_res == pytest.approx(list_res, abs=tol)\n        assert positional_grad == pytest.approx(list_grad, abs=tol)\n\n        array_res = circuit3(np.array([a, b, c]))\n        array_grad = circuit3.jacobian([np.array([a, b, c])])\n\n        list_res = circuit3([a, b, c])\n        list_grad = circuit3.jacobian([[a, b, c]])\n\n        assert positional_res == pytest.approx(array_res, abs=tol)\n        assert positional_grad == pytest.approx(array_grad, abs=tol)\n\n    @pytest.mark.parametrize(\'theta\', thetas)\n    @pytest.mark.parametrize(\'G\', [qml.ops.RX, qml.ops.RY, qml.ops.RZ])\n    def test_pauli_rotation_gradient(self, G, theta, tol):\n        """"""Tests that the automatic gradients of Pauli rotations are correct.""""""\n\n        def circuit(x):\n            qml.RX(x, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        circuit = QubitQNode(circuit, dev)\n\n        autograd_val = circuit.jacobian([theta])\n        manualgrad_val = (circuit(theta + np.pi / 2) - circuit(theta - np.pi / 2)) / 2\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    @pytest.mark.parametrize(\'theta\', thetas)\n    def test_Rot_gradient(self, theta, tol):\n        """"""Tests that the automatic gradient of a arbitrary Euler-angle-parameterized gate is correct.""""""\n\n        def circuit(x,y,z):\n            qml.Rot(x,y,z, wires=[0])\n            return qml.expval(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        circuit = QubitQNode(circuit, dev)\n        eye = np.eye(3)\n\n        angle_inputs = np.array([theta, theta ** 3, np.sqrt(2) * theta])\n        autograd_val = circuit.jacobian(angle_inputs)\n        manualgrad_val = np.zeros((1,3))\n\n        for idx in range(3):\n            onehot_idx = eye[idx]\n            param1 = angle_inputs + np.pi / 2 * onehot_idx\n            param2 = angle_inputs - np.pi / 2 * onehot_idx\n            manualgrad_val[0, idx] = (circuit(*param1) - circuit(*param2)) / 2\n\n        assert autograd_val == pytest.approx(manualgrad_val, abs=tol)\n\n    def test_controlled_RX_gradient(self, tol):\n        """"""Test gradient of controlled RX gate""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(x):\n            qml.PauliX(wires=0)\n            qml.CRX(x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.542  # any value of a should give zero gradient\n\n        # get the analytic gradient\n        gradA = circuit.jacobian([a], method=""A"")\n        # get the finite difference gradient\n        gradF = circuit.jacobian([a], method=""F"")\n\n        # the expected gradient\n        expected = 0\n\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n\n        def circuit1(x):\n            qml.RX(x, wires=0)\n            qml.CRX(x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit1 = QubitQNode(circuit1, dev)\n\n        b = 0.123  # gradient is -sin(x)\n\n        # get the analytic gradient\n        gradA = circuit1.jacobian([b], method=""A"")\n        # get the finite difference gradient\n        gradF = circuit1.jacobian([b], method=""F"")\n\n        # the expected gradient\n        expected = -np.sin(b)\n\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n\n    def test_controlled_RY_gradient(self, tol):\n        """"""Test gradient of controlled RY gate""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(x):\n            qml.PauliX(wires=0)\n            qml.CRY(x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.542  # any value of a should give zero gradient\n\n        # get the analytic gradient\n        gradA = circuit.jacobian([a], method=""A"")\n        # get the finite difference gradient\n        gradF = circuit.jacobian([a], method=""F"")\n\n        # the expected gradient\n        expected = 0\n\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n\n        def circuit1(x):\n            qml.RX(x, wires=0)\n            qml.CRY(x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit1 = QubitQNode(circuit1, dev)\n\n        b = 0.123  # gradient is -sin(x)\n\n        # get the analytic gradient\n        gradA = circuit1.jacobian([b], method=""A"")\n        # get the finite difference gradient\n        gradF = circuit1.jacobian([b], method=""F"")\n\n        # the expected gradient\n        expected = -np.sin(b)\n\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n\n    def test_controlled_RZ_gradient(self, tol):\n        """"""Test gradient of controlled RZ gate""""""\n        dev = qml.device(""default.qubit"", wires=2)\n\n        def circuit(x):\n            qml.PauliX(wires=0)\n            qml.CRZ(x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.542  # any value of a should give zero gradient\n\n        # get the analytic gradient\n        gradA = circuit.jacobian([a], method=""A"")\n        # get the finite difference gradient\n        gradF = circuit.jacobian([a], method=""F"")\n\n        # the expected gradient\n        expected = 0\n\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n\n        def circuit1(x):\n            qml.RX(x, wires=0)\n            qml.CRZ(x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        circuit1 = QubitQNode(circuit1, dev)\n\n        b = 0.123  # gradient is -sin(x)\n\n        # get the analytic gradient\n        gradA = circuit1.jacobian([b], method=""A"")\n        # get the finite difference gradient\n        gradF = circuit1.jacobian([b], method=""F"")\n\n        # the expected gradient\n        expected = -np.sin(b)\n\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n\n\nclass TestVarianceJacobian:\n    """"""Variance analytic jacobian integration tests.""""""\n\n    def test_involutory_variance(self, tol):\n        """"""Tests qubit observable that are involutory""""""\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.var(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.54\n        var = circuit(a)\n        expected = 1 - np.cos(a) ** 2\n        assert var == pytest.approx(expected, abs=tol)\n\n        # circuit jacobians\n        gradA = circuit.jacobian([a], method=""A"")\n        gradF = circuit.jacobian([a], method=""F"")\n        expected = 2 * np.sin(a) * np.cos(a)\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n\n    def test_non_involutory_variance(self, tol):\n        """"""Tests a qubit Hermitian observable that is not involutory""""""\n        A = np.array([[4, -1 + 6j], [-1 - 6j, 2]])\n\n        def circuit(a):\n            qml.RX(a, wires=0)\n            return qml.var(qml.Hermitian(A, 0))\n\n        dev = qml.device(""default.qubit"", wires=1)\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.54\n        var = circuit(a)\n        expected = (39 / 2) - 6 * np.sin(2 * a) + (35 / 2) * np.cos(2 * a)\n        assert var == pytest.approx(expected, abs=tol)\n\n        # circuit jacobians\n        gradA = circuit.jacobian([a], method=""A"")\n        gradF = circuit.jacobian([a], method=""F"")\n        expected = -35 * np.sin(2 * a) - 12 * np.cos(2 * a)\n        assert gradA == pytest.approx(expected, abs=tol)\n        assert gradF == pytest.approx(expected, abs=tol)\n\n    def test_fanout(self, tol):\n        """"""Tests qubit observable with repeated parameters""""""\n        def circuit(a):\n            qml.RX(a, wires=0)\n            qml.RY(a, wires=0)\n            return qml.var(qml.PauliZ(0))\n\n        dev = qml.device(""default.qubit"", wires=2)\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.54\n        var = circuit(a)\n        expected = 0.5 * np.sin(a) ** 2 * (np.cos(2 * a) + 3)\n        assert var == pytest.approx(expected, abs=tol)\n\n        # circuit jacobians\n        gradA = circuit.jacobian([a], method=""A"")\n        gradF = circuit.jacobian([a], method=""F"")\n        expected = 4 * np.sin(a) * np.cos(a) ** 3\n        assert gradA == pytest.approx(expected, abs=tol)\n        assert gradF == pytest.approx(expected, abs=tol)\n\n    def test_expval_and_variance(self, tol):\n        """"""Test that the qnode works for a combination of expectation\n        values and variances""""""\n        dev = qml.device(""default.qubit"", wires=3)\n\n        def circuit(a, b, c):\n            qml.RX(a, wires=0)\n            qml.RY(b, wires=1)\n            qml.CNOT(wires=[1, 2])\n            qml.RX(c, wires=2)\n            qml.CNOT(wires=[0, 1])\n            qml.RZ(c, wires=2)\n            return qml.var(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.var(qml.PauliZ(2))\n\n        circuit = QubitQNode(circuit, dev)\n\n        a = 0.54\n        b = -0.423\n        c = 0.123\n        var = circuit(a, b, c)\n        expected = np.array(\n            [\n                np.sin(a) ** 2,\n                np.cos(a) * np.cos(b),\n                0.25 * (3 - 2 * np.cos(b) ** 2 * np.cos(2 * c) - np.cos(2 * b)),\n            ]\n        )\n        assert var == pytest.approx(expected, abs=tol)\n\n        # # circuit jacobians\n        gradA = circuit.jacobian([a, b, c], method=""A"")\n        gradF = circuit.jacobian([a, b, c], method=""F"")\n        expected = np.array(\n            [\n                [2 * np.cos(a) * np.sin(a), -np.cos(b) * np.sin(a), 0],\n                [\n                    0,\n                    -np.cos(a) * np.sin(b),\n                    0.5 * (2 * np.cos(b) * np.cos(2 * c) * np.sin(b) + np.sin(2 * b)),\n                ],\n                [0, 0, np.cos(b) ** 2 * np.sin(2 * c)],\n            ]\n        ).T\n        assert gradF == pytest.approx(expected, abs=tol)\n        assert gradA == pytest.approx(expected, abs=tol)\n'"
tests/templates/test_broadcast.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :func:`pennylane.template.broadcast` function.\nIntegration tests should be placed into ``test_templates.py``.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport pytest\nfrom math import pi\nimport numpy as np\nimport pennylane as qml\nfrom pennylane.templates import template, broadcast\nfrom pennylane.ops import RX, RY, T, S, Rot, CRX, CRot, CNOT\nfrom pennylane.templates.broadcast import wires_pyramid, wires_all_to_all, wires_ring\nfrom pennylane.wires import Wires\n\n@template\ndef ConstantTemplate(wires):\n    T(wires=wires)\n    S(wires=wires)\n\n\n@template\ndef ParametrizedTemplate(par1, par2, wires):\n    RX(par1, wires=wires)\n    RY(par2, wires=wires)\n\n\n@template\ndef KwargTemplate(par, wires, a=True):\n    if a:\n        T(wires=wires)\n    RY(par, wires=wires)\n\n\n@template\ndef ConstantTemplateDouble(wires):\n    T(wires=wires[0])\n    CNOT(wires=wires)\n\n\n@template\ndef ParametrizedTemplateDouble(par1, par2, wires):\n    CRX(par1, wires=wires)\n    RY(par2, wires=wires[0])\n\n\n@template\ndef KwargTemplateDouble(par, wires, a=True):\n    if a:\n        T(wires=wires[0])\n    CRX(par, wires=wires)\n\n\nTARGET_OUTPUTS = [(""single"", 4, [pi, pi, pi / 2, 0], RX, [1, 1, 0, -1]),\n                  (""double"", 4, [pi / 2, pi / 2], CRX, [-1, 0, -1, 0]),\n                  (""double"", 4, None, CNOT, [-1, 1, -1, 1]),\n                  (""double_odd"", 4, [pi / 2], CRX, [-1, -1, 0, -1]),\n                  (""chain"", 4, [pi, pi, pi / 2], CRX, [-1, 1, -1, 0]),\n                  (""ring"", 4, [pi, pi, pi / 2, pi], CRX, [0, 1, -1, 0]),\n                  (""pyramid"", 4, [0, pi, pi / 2], CRX, [-1, -1, 0, 1]),\n                  (""all_to_all"", 4, [pi / 2, pi / 2, pi / 2, pi / 2, pi / 2, pi / 2], CRX, [-1, 0, 1 / 2, 3 / 4])\n                  ]\n\nGATE_PARAMETERS = [(""single"", 0, T, []),\n                   (""single"", 1, T, [[]]),\n                   (""single"", 2, T, [[], []]),\n                   (""single"", 3, T, [[], [], []]),\n                   (""single"", 3, RX, [[0.1], [0.2], [0.3]]),\n                   (""single"", 3, Rot, [[0.1, 0.2, 0.3], [0.3, 0.2, 0.1], [0.3, 0.2, -0.1]]),\n                   (""double"", 0, CNOT, []),\n                   (""double"", 1, CNOT, []),\n                   (""double"", 3, CNOT, [[]]),\n                   (""double"", 2, CNOT, [[]]),\n                   (""double"", 3, CRX, [[0.1]]),\n                   (""double"", 3, CRot, [[0.1, 0.2, 0.3]]),\n                   (""double_odd"", 0, CNOT, []),\n                   (""double_odd"", 1, CNOT, []),\n                   (""double_odd"", 2, CNOT, []),\n                   (""double_odd"", 3, CNOT, [[]]),\n                   (""double_odd"", 3, CRX, [[0.1]]),\n                   (""double_odd"", 3, CRot, [[0.3, 0.2, 0.1]]),\n                   (""chain"", 0, CNOT, []),\n                   (""chain"", 1, CNOT, []),\n                   (""chain"", 2, CNOT, [[]]),\n                   (""chain"", 3, CNOT, [[], []]),\n                   (""chain"", 3, CRX, [[0.1], [0.1]]),\n                   (""chain"", 3, CRot, [[0.3, 0.2, 0.1], [0.3, 0.2, 0.1]]),\n                   (""ring"", 0, CNOT, []),\n                   (""ring"", 1, CNOT, []),\n                   (""ring"", 2, CNOT, [[]]),\n                   (""ring"", 3, CNOT, [[], [], []]),\n                   (""ring"", 3, CRX, [[0.1], [0.1], [0.1]]),\n                   (""ring"", 3, CRot, [[0.3, 0.2, 0.1], [0.3, 0.2, 0.1], [0.3, 0.2, 0.1]]),\n                   (""pyramid"", 0, CNOT, []),\n                   (""pyramid"", 1, CNOT, []),\n                   (""pyramid"", 2, CNOT, [[]]),\n                   (""pyramid"", 4, CNOT, [[], [], []]),\n                   (""pyramid"", 3, CRX, [[0.1]]),\n                   (""pyramid"", 4, CRX, [[0.1], [0.1], [0.1]]),\n                   (""pyramid"", 4, CRot, [[0.3, 0.2, 0.1], [0.3, 0.2, 0.1], [0.3, 0.2, 0.1]]),\n                   (""all_to_all"", 0, CNOT, []),\n                   (""all_to_all"", 1, CNOT, []),\n                   (""all_to_all"", 2, CNOT, [[]]),\n                   (""all_to_all"", 4, CNOT, [[], [], [], [], [], []]),\n                   (""all_to_all"", 3, CRX, [[0.1], [0.1], [0.1]]),\n                   (""all_to_all"", 4, CRX, [[0.1], [0.1], [0.1], [0.1], [0.1], [0.1]]),\n                   (""all_to_all"", 4, CRot, [[0.3, 0.2, 0.1], [0.3, 0.2, 0.1], [0.3, 0.2, 0.1],\n                                            [0.3, 0.2, 0.1], [0.3, 0.2, 0.1], [0.3, 0.2, 0.1]]),\n                   ]\n\n\nclass TestBuiltinPatterns:\n    """"""Tests the built-in patterns (""single"", ""ring"", etc) of the broadcast template constructor.""""""\n\n    @pytest.mark.parametrize(""unitary, parameters"", [(RX, [[0.1], [0.2], [0.3]]),\n                                                     (Rot,\n                                                      [[0.1, 0.2, 0.3], [0.3, 0.2, 0.1],\n                                                       [0.3, 0.2, -0.1]]),\n                                                     (T, [[], [], []]),\n                                                     ])\n    def test_correct_queue_for_gate_unitary(self, unitary, parameters):\n        """"""Tests that correct gate queue is created when \'unitary\' is a single gate.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            broadcast(unitary=unitary, pattern=""single"", wires=range(3), parameters=parameters)\n\n        for gate in rec.queue:\n            assert isinstance(gate, unitary)\n\n    @pytest.mark.parametrize(""unitary, gates, parameters"",\n                             [(ParametrizedTemplate, [RX, RY], [[0.1, 1], [0.2, 1], [0.1, 1]]),\n                              (ConstantTemplate, [T, S], [[], [], []]),\n                              ])\n    def test_correct_queue_for_template_unitary(self, unitary, gates, parameters):\n        """"""Tests that correct gate queue is created when \'unitary\' is a template.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            broadcast(unitary=unitary, pattern=""single"", wires=range(3), parameters=parameters)\n\n        first_gate = gates[0]\n        second_gate = gates[1]\n        for idx, gate in enumerate(rec.queue):\n            if idx % 2 == 0:\n                assert isinstance(gate, first_gate)\n            else:\n                assert isinstance(gate, second_gate)\n\n    @pytest.mark.parametrize(""template, kwarg, target_queue, parameters"",\n                             [(KwargTemplate, True, [T, RY, T, RY], [[1], [2]]),\n                              (KwargTemplate, False, [RY, RY], [[1], [2]]),\n                              ])\n    def test_correct_queue_for_template_unitary_with_keyword(self, template, kwarg, target_queue, parameters):\n        """"""Tests that correct gate queue is created when \'unitary\' is a template that uses a keyword.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            broadcast(unitary=template, pattern=""single"", wires=range(2),\n                      parameters=parameters, kwargs={\'a\': kwarg})\n\n        for gate, target_gate in zip(rec.queue, target_queue):\n            assert isinstance(gate, target_gate)\n\n    @pytest.mark.parametrize(""pars1, pars2, gate"", [([[], [], []], None, T),\n                                                    ([1, 2, 3], [[1], [2], [3]], RX),\n                                                    ])\n    def test_correct_queue_same_gate_unitary_different_parameter_formats(self, pars1, pars2, gate):\n        """"""Tests that specific parameter inputs have the same output.""""""\n\n        with qml.utils.OperationRecorder() as rec1:\n            broadcast(unitary=gate, pattern=""single"", wires=range(3), parameters=pars1)\n\n        with qml.utils.OperationRecorder() as rec2:\n            broadcast(unitary=gate, pattern=""single"", wires=range(3), parameters=pars2)\n\n        for g1, g2 in zip(rec1.queue, rec2.queue):\n            assert g1.parameters == g2.parameters\n\n    @pytest.mark.parametrize(""pattern, n_wires, gate, parameters"", GATE_PARAMETERS)\n    def test_correct_parameters_in_queue(self, pattern, n_wires, gate, parameters):\n        """"""Tests that gate queue has correct parameters.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            broadcast(unitary=gate, pattern=pattern, wires=range(n_wires), parameters=parameters)\n\n        for target_par, g in zip(parameters, rec.queue):\n            assert g.parameters == target_par\n\n    @pytest.mark.parametrize(""pattern, n_wires, parameters, unitary, target"", TARGET_OUTPUTS)\n    def test_prepares_correct_state(self, pattern, n_wires, parameters, unitary, target):\n        """"""Tests the state produced by different unitaries.""""""\n\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit():\n            for w in range(4):\n                qml.PauliX(wires=w)\n            broadcast(unitary=unitary, pattern=pattern, wires=range(4), parameters=parameters)\n            return [qml.expval(qml.PauliZ(wires=w)) for w in range(4)]\n\n        res = circuit()\n        assert np.allclose(res, target)\n\n    @pytest.mark.parametrize(""parameters, n_wires"", [(np.array([0]), 2),\n                                                     ([0, 0, 0, 1, 0], 3)])\n    def test_throws_error_when_mismatch_params_wires(self, parameters, n_wires):\n        """"""Tests that error thrown when \'parameters\' does not contain one set\n           of parameters for each wire.""""""\n\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit():\n            broadcast(unitary=RX, wires=range(n_wires), pattern=""single"", parameters=parameters)\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=""\'parameters\' must contain entries for""):\n            circuit()\n\n    def test_throws_special_error_for_ring_pattern_2_wires(self):\n        """"""Tests that the special error is thrown when \'parameters\' does not contain one sequence\n           of parameters for a two-wire ring pattern.""""""\n\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(pars):\n            broadcast(unitary=RX, wires=range(2), pattern=""ring"", parameters=pars)\n            return qml.expval(qml.PauliZ(0))\n\n        pars = [[1.6], [2.1]]\n\n        with pytest.raises(ValueError, match=""the ring pattern with 2 wires is an exception""):\n            circuit(pars)\n\n    def test_exception_parameters_not_valid(self):\n        """"""Tests that an exception is raised if \'parameters\' argument has invalid format.""""""\n\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit():\n            broadcast(unitary=RX, wires=[0, 1], pattern=""single"", parameters=RX)\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=""\'parameters\' must be either of type None or ""):\n            circuit()\n\n    @pytest.mark.parametrize(""function, wires, target"", [(wires_pyramid, [8, 2, 0, 4, 6, 1],\n                                                          [[8, 2], [0, 4], [6, 1], [2, 0], [4, 6], [0, 4]]),\n                                                         (wires_pyramid, [5, 10, 1, 0, 3, 4, 6],\n                                                          [[5, 10], [1, 0], [3, 4], [10, 1], [0, 3], [1, 0]]),\n                                                         (wires_pyramid, [0], []),\n                                                         (wires_ring, [8, 2, 0, 4, 6, 1],\n                                                          [[8, 2], [2, 0], [0, 4], [4, 6], [6, 1], [1, 8]]),\n                                                         (wires_ring, [0], []),\n                                                         (wires_ring, [4, 2], [[4, 2]]),\n                                                         (wires_all_to_all, [8, 2, 0, 4],\n                                                          [[8, 2], [8, 0], [8, 4], [2, 0], [2, 4], [0, 4]]),\n                                                         (wires_all_to_all, [0],\n                                                          []),\n                                                         ])\n    def test_wire_sequence_generating_functions(self, function, wires, target):\n        """"""Tests that the wire list generating functions for different patterns create the correct sequence.""""""\n\n        wires = Wires(wires)\n        sequence = function(wires)\n        for w, t in zip(sequence, target):\n            assert w.tolist() == t\n\n\nclass TestCustomPattern:\n    """"""Additional tests for using broadcast with a custom pattern.""""""\n\n    @pytest.mark.parametrize(""custom_pattern, pattern"", [([[0, 1], [1, 2], [2, 3], [3, 0]], ""ring""),\n                                                         ([[0, 1], [1, 2], [2, 3]], ""chain""),\n                                                         ([[0, 1], [2, 3]], ""double"")\n                                                         ])\n    def test_reproduce_builtin_patterns(self, custom_pattern, pattern):\n        """"""Tests that the custom pattern can reproduce the built in patterns.""""""\n\n        dev = qml.device(\'default.qubit\', wires=4)\n\n        # qnode using custom pattern\n        @qml.qnode(dev)\n        def circuit1():\n            broadcast(unitary=qml.CNOT, pattern=custom_pattern, wires=range(4))\n            return [qml.expval(qml.PauliZ(wires=w)) for w in range(4)]\n\n        # qnode using built-in pattern\n        @qml.qnode(dev)\n        def circuit2():\n            broadcast(unitary=qml.CNOT, pattern=pattern, wires=range(4))\n            return [qml.expval(qml.PauliZ(wires=w)) for w in range(4)]\n\n        custom = circuit1()\n        built_in = circuit2()\n        assert np.allclose(custom, built_in)\n\n    @pytest.mark.parametrize(""custom_pattern, expected"", [([[0], [2], [3], [2]], [-1., 1., 1., -1.]),\n                                                          ([[3], [2], [0]], [-1., 1., -1., -1.]),\n                                                         ])\n    def test_correct_output(self, custom_pattern, expected):\n        """"""Tests the output for simple cases.""""""\n\n        dev = qml.device(\'default.qubit\', wires=4)\n\n        @qml.qnode(dev)\n        def circuit():\n            broadcast(unitary=qml.PauliX, wires=range(4), pattern=custom_pattern)\n            return [qml.expval(qml.PauliZ(w)) for w in range(4)]\n\n        res = circuit()\n        assert np.allclose(res, expected)\n'"
tests/templates/test_decorator.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.template.decorator` module.\nIntegration tests should be placed into ``test_templates.py``.\n""""""\nimport pennylane as qml\nfrom pennylane.templates.decorator import template\n\n\ndef expected_queue(wires):\n    """"""Expected queue for the dummy template.""""""\n    return [qml.RX(2 * i, wires=[wire]) for i, wire in enumerate(wires)] + [\n        qml.RY(3 * i, wires=[wire]) for i, wire in enumerate(wires)\n    ]\n\n\ndef dummy_template(wires):\n    """"""Dummy template for template decorator tests.""""""\n    for i, wire in enumerate(wires):\n        qml.RX(2 * i, wires=[wire])\n\n    for i, wire in enumerate(wires):\n        qml.RY(3 * i, wires=[wire])\n\n\n@template\ndef decorated_dummy_template(wires):\n    """"""Already decorated dummy template for template decorator tests.""""""\n    for i, wire in enumerate(wires):\n        qml.RX(2 * i, wires=[wire])\n\n    for i, wire in enumerate(wires):\n        qml.RY(3 * i, wires=[wire])\n\n\nclass TestDecorator:\n    """"""Tests the template decorator.""""""\n\n    def test_dummy_template(self):\n        """"""Test the decorator for a dummy template.""""""\n\n        @template\n        def my_template(wires):\n            dummy_template(wires)\n\n        res = my_template([0, 1])\n        expected = expected_queue([0, 1])\n\n        for res_op, exp_op in zip(res, expected):\n            assert res_op.name == exp_op.name\n            assert res_op.wires == exp_op.wires\n            assert res_op.params == exp_op.params\n\n    def test_decorated_dummy_template(self):\n        """"""Test the decorator for an already decorated template.""""""\n        res = decorated_dummy_template([0, 1])\n\n        expected = expected_queue([0, 1])\n\n        for res_op, exp_op in zip(res, expected):\n            assert res_op.name == exp_op.name\n            assert res_op.wires == exp_op.wires\n            assert res_op.params == exp_op.params\n\n    def test_decorated_decorated_dummy_template(self):\n        """"""Test the decorator for decorating an already decorated template.""""""\n\n        @template\n        def my_template(wires):\n            decorated_dummy_template(wires)\n\n        res = my_template([0, 1])\n        expected = expected_queue([0, 1])\n\n        for res_op, exp_op in zip(res, expected):\n            assert res_op.name == exp_op.name\n            assert res_op.wires == exp_op.wires\n            assert res_op.params == exp_op.params\n'"
tests/templates/test_embeddings.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.template.embeddings` module.\nIntegration tests should be placed into ``test_templates.py``.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport pytest\nfrom math import pi\nimport numpy as np\nimport pennylane as qml\nfrom pennylane.templates.embeddings import (AngleEmbedding,\n                                            BasisEmbedding,\n                                            AmplitudeEmbedding,\n                                            QAOAEmbedding,\n                                            DisplacementEmbedding,\n                                            SqueezingEmbedding)\nfrom pennylane import Beamsplitter\nfrom pennylane.wires import Wires\n\n\nclass TestAmplitudeEmbedding:\n    """""" Tests the AmplitudeEmbedding method.""""""\n\n    INPT = [np.array([0, 1, 0, 0]),\n            1 / np.sqrt(4) * np.array([1, 1, 1, 1]),\n            np.array([np.complex(-np.sqrt(0.1), 0.0), np.sqrt(0.3),\n                      np.complex(0, -np.sqrt(0.1)), np.sqrt(0.5)])]\n\n    NOT_ENOUGH_FEATURES = [np.array([0, 1, 0]),\n                           1 / np.sqrt(3) * np.array([1, 1, 1]),\n                           np.array([np.complex(-np.sqrt(0.1), 0.0), np.sqrt(0.3),\n                                     np.complex(0, -np.sqrt(0.6))])]\n\n    TOO_MANY_FEATURES = [[0, 0, 0, 1, 0],\n                         1 / np.sqrt(8) * np.array([1] * 8),\n                         [np.complex(-np.sqrt(0.1), 0.0), np.sqrt(0.3),\n                          np.complex(0, -np.sqrt(0.6)), 0., 0.]]\n\n    @pytest.mark.parametrize(""inpt"", INPT)\n    def test_amplitude_embedding_prepares_state(self, inpt):\n        """"""Checks the state produced by AmplitudeEmbedding() for real and complex\n        inputs.""""""\n\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AmplitudeEmbedding(features=x, wires=range(n_qubits), pad=None, normalize=False)\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_qubits)]\n\n        circuit(x=inpt)\n        state = dev._state.ravel()\n        assert np.allclose(state, inpt)\n\n    @pytest.mark.parametrize(""inpt"", NOT_ENOUGH_FEATURES)\n    @pytest.mark.parametrize(""pad"", [complex(0.1, 0.1), 0., 1.])\n    def test_amplitude_embedding_prepares_padded_state(self, inpt, pad):\n        """"""Checks the state produced by AmplitudeEmbedding() for real and complex padding constants.""""""\n\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AmplitudeEmbedding(features=x, wires=range(n_qubits), pad=pad, normalize=False)\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_qubits)]\n\n        circuit(x=inpt)\n        state = dev._state.ravel()\n        assert len(set(state[len(inpt):])) == 1\n\n    @pytest.mark.parametrize(""inpt"", INPT)\n    def test_amplitude_embedding_throws_exception_if_not_normalized(self, inpt):\n        """"""Checks that AmplitudeEmbedding() throws exception when state is not normalized and `normalize=False`.""""""\n        not_nrmlzd = 2 * inpt\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AmplitudeEmbedding(features=x, wires=range(n_qubits), pad=None, normalize=False)\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_qubits)]\n\n        with pytest.raises(ValueError, match=""\'features\' must be a vector of length""):\n            circuit(x=not_nrmlzd)\n\n    @pytest.mark.parametrize(""inpt"", NOT_ENOUGH_FEATURES)\n    def test_amplitude_embedding_throws_exception_if_fewer_features_than_amplitudes(self, inpt):\n        """"""Verifies that AmplitudeEmbedding() throws exception\n        if the number of features is fewer than the number of amplitudes, and\n        no automatic padding is chosen.""""""\n\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=n_qubits)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AmplitudeEmbedding(features=x, wires=range(n_qubits), pad=None, normalize=False)\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(x=inpt)\n\n    @pytest.mark.parametrize(""inpt"", TOO_MANY_FEATURES)\n    def test_amplitude_embedding_throws_exception_if_more_features_than_amplitudes(self, inpt):\n        """"""Verifies that AmplitudeEmbedding() throws exception\n        if the number of features is larger than the number of amplitudes, and\n        no automatic padding is chosen.""""""\n\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=n_qubits)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AmplitudeEmbedding(features=x, wires=range(n_qubits), pad=None, normalize=False)\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(x=inpt)\n\n    @pytest.mark.parametrize(""inpt"", TOO_MANY_FEATURES)\n    def test_amplitude_embedding_with_padding_throws_exception_if_more_features_than_amplitudes(self, inpt):\n        """"""Verifies that AmplitudeEmbedding() throws exception\n        if the number of features is larger than the number of amplitudes, and\n        automatic padding is chosen.""""""\n\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=n_qubits)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AmplitudeEmbedding(features=x, wires=range(n_qubits), pad=0., normalize=False)\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(x=inpt)\n\n    def test_amplitude_embedding_tolerance_value(self):\n        """"""Tests that a small enough tolerance value is used for Amplitude\n        Embedding.""""""\n        inputs = np.array([0.25895178024895, 0.115997030111517, 0.175840500169049, 0.16545033015906,\n                            0.016337370015706, 0.006616800006361, 0.22326375021464, 0.161815530155566,\n                            0.234776190225708, 0.082623190079432, 0.291982110280705, 0.295344560283937,\n                            0.05998731005767, 0.056911140054713, 0.274260680263668, 0.163596590157278,\n                            0.048460970046589, 0.292306260281016, 0.292451040281155, 0.007849840007547,\n                            0.218302930209871, 0.326763300314142, 0.163634550157314, 0.275472160264832,\n                            0.105510810101436])\n\n        tolerance = 10e-10\n        num_qubits = 5\n        dev = qml.device(\'default.qubit\', wires=num_qubits)\n        assert np.isclose(np.sum(np.abs(inputs) ** 2), 1, tolerance)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AmplitudeEmbedding(x, list(range(num_qubits)), pad=0., normalize=True)\n            return qml.expval(qml.PauliZ(0))\n\n        # No normalization error is raised\n        circuit(x=inputs)\n\nclass TestAngleEmbedding:\n    """""" Tests the AngleEmbedding method.""""""\n\n    def test_angle_embedding_state_rotx(self, qubit_device, n_subsystems):\n        """"""Checks the state produced by AngleEmbedding()\n           using the rotation=\'X\' strategy.""""""\n\n        features = [pi / 2, pi / 2, pi / 4, 0]\n\n        @qml.qnode(qubit_device)\n        def circuit(x=None):\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=\'X\')\n            qml.PauliX(wires=0)\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=\'X\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        res = circuit(x=features[:n_subsystems])\n        target = [1, -1, 0, 1, 1]\n\n        assert np.allclose(res, target[:n_subsystems])\n\n    def test_angle_embedding_state_roty(self, qubit_device, n_subsystems):\n        """"""Checks the state produced by AngleEmbedding()\n           using the rotation=\'Y\' strategy.""""""\n\n        features = [pi / 2, pi / 2, pi / 4, 0]\n\n        @qml.qnode(qubit_device)\n        def circuit(x=None):\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=\'Y\')\n            qml.PauliX(wires=0)\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=\'Y\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        res = circuit(x=features[:n_subsystems])\n        target = [-1, -1, 0, 1, 1]\n        assert np.allclose(res, target[:n_subsystems])\n\n    def test_angle_embedding_state_rotz(self, qubit_device, n_subsystems):\n        """"""Checks the state produced by AngleEmbedding()\n           using the rotation=\'Z\' strategy.""""""\n\n        features = [pi / 2, pi / 2, pi / 4, 0]\n\n        @qml.qnode(qubit_device)\n        def circuit(x=None):\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=\'Z\')\n            qml.PauliX(wires=0)\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=\'Z\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        res = circuit(x=features[:n_subsystems])\n        target = [-1, 1, 1, 1, 1]\n        assert np.allclose(res, target[:n_subsystems])\n\n    @pytest.mark.parametrize(\'strategy\', [\'X\', \'Y\', \'Z\'])\n    def test_angle_embedding_exception_fewer_rotations(self, strategy):\n        """"""Verifies that AngleEmbedding() raises an exception if there are fewer\n           rotation gates than features.""""""\n\n        features = [0, 0, 0, 0]\n        n_subsystems = 1\n        dev = qml.device(\'default.qubit\', wires=n_subsystems)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=strategy)\n            qml.PauliX(wires=0)\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=strategy)\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(x=features)\n\n    def test_angle_embedding_exception_wrongrot(self):\n        """"""Verifies that AngleEmbedding() raises an exception if the\n        rotation strategy is unknown.""""""\n\n        n_subsystems = 1\n        dev = qml.device(\'default.qubit\', wires=n_subsystems)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            AngleEmbedding(features=x, wires=range(n_subsystems), rotation=\'A\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        with pytest.raises(ValueError, match=""did not recognize option""):\n            circuit(x=[1])\n\n\nclass TestBasisEmbedding:\n    """""" Tests the BasisEmbedding method.""""""\n\n    def test_basis_embedding_state(self):\n        """"""Checks the state produced by BasisEmbedding().""""""\n\n        state = np.array([0, 1])\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=n_qubits)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            BasisEmbedding(features=x, wires=range(2))\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_qubits)]\n\n        res = circuit(x=state)\n        assert np.allclose(res, [1, -1])\n\n    def test_basis_embedding_too_many_input_bits_exception(self):\n        """"""Verifies that BasisEmbedding() throws exception if there are more features than qubits.""""""\n\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=n_qubits)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            BasisEmbedding(features=x, wires=range(2))\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError):\n            circuit(x=np.array([0, 1, 1]))\n\n    def test_basis_embedding_not_enough_input_bits_exception(self):\n        """"""Verifies that BasisEmbedding() throws exception if there are less features than qubits.""""""\n\n        n_qubits = 2\n        dev = qml.device(\'default.qubit\', wires=n_qubits)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            BasisEmbedding(features=x, wires=range(2))\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError):\n            circuit(x=np.array([0]))\n\n\n    def test_basis_embedding_input_not_binary_exception(self):\n        """"""Verifies that BasisEmbedding() raises an exception if the features contain\n        values other than zero and one.""""""\n\n        n_subsystems = 2\n        dev = qml.device(\'default.qubit\', wires=n_subsystems)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            BasisEmbedding(features=x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=""\'basis_state\' must only consist of""):\n            circuit(x=[2, 3])\n\n    def test_basis_embedding_features_not_iterable_exception(self):\n        """"""Verifies that BasisEmbedding() raises an exception if the features are not\n        of type Iterable.""""""\n\n        n_subsystems = 2\n        dev = qml.device(\'default.qubit\', wires=n_subsystems)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            BasisEmbedding(features=x, wires=[0, 1])\n            return qml.expval(qml.PauliZ(0))\n\n        with pytest.raises(ValueError, match=""\'features\' must be iterable""):\n            circuit(x=1)\n\n\nclass TestIQPEmbedding:\n    """""" Tests the IQPEmbedding method.""""""\n\n    QUEUES = [(0, []),\n              (1, [qml.Hadamard, qml.RZ]),\n              (2, [qml.Hadamard, qml.Hadamard, qml.RZ, qml.RZ, qml.MultiRZ]),\n              (3, [qml.Hadamard, qml.Hadamard, qml.Hadamard, qml.RZ, qml.RZ, qml.RZ,\n                   qml.MultiRZ, qml.MultiRZ, qml.MultiRZ])]\n\n    @pytest.mark.parametrize(\'n_wires, expected_queue\', QUEUES)\n    @pytest.mark.parametrize(\'n_repeats\', [1, 2])\n    def test_queue_default_pattern(self, n_wires, expected_queue, n_repeats):\n        """"""Checks the queue for the default pattern.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.templates.IQPEmbedding(features=list(range(n_wires)), wires=range(n_wires), n_repeats=n_repeats)\n\n        expected_queue = expected_queue * n_repeats\n\n        for gate, expected_gate in zip(rec.queue, expected_queue):\n            assert isinstance(gate, expected_gate)\n\n    @pytest.mark.parametrize(\'features, expected_params\', [([1., 2., 3.],\n                                                            [1., 2., 3., 1 * 2, 1 * 3, 2 * 3]),\n                                                           ([0.1, 0.2, 0.3],\n                                                            [0.1, 0.2, 0.3, 0.1 * 0.2, 0.1 * 0.3, 0.2 * 0.3])])\n    @pytest.mark.parametrize(\'wires\', [range(3),\n                                       [2, 0, 1]])\n    def test_queue_parameters(self, features, expected_params, wires):\n        """"""Checks the queued parameters, for consecutive and non-consecutive ``wires`` argument.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.templates.IQPEmbedding(features=features, wires=wires)\n\n        # compare all nonempty gate parameters to expected ones\n        counter = 0\n        for gate in rec.queue:\n            if gate.parameters:\n                assert gate.parameters[0] == expected_params[counter]\n                counter += 1\n\n    @pytest.mark.parametrize(\'wires, expected_queue_wires\', [(range(3), [[0], [1], [2], [0], [1], [2],\n                                                                         [0, 1], [0, 2], [1, 2]]),\n                                                             ([2, 0, 1], [[2], [0], [1], [2], [0], [1],\n                                                                          [2, 0], [2, 1], [0, 1]])])\n    def test_queue_correct_wires(self, wires, expected_queue_wires):\n        """"""Checks the queued wires for a consecutive and non-consecutive sequence\n           of indices in the ``wires`` argument.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.templates.IQPEmbedding(features=list(range(3)), wires=wires)\n\n        # compare all gate wires to expected ones\n        for idx, gate in enumerate(rec.queue):\n            assert gate.wires == Wires(expected_queue_wires[idx])\n\n    @pytest.mark.parametrize(\'pattern\', [[[0, 3], [1, 2], [2, 0]],\n                                         [[2, 3], [0, 2], [1, 0]]])\n    def test_wires_custom_pattern(self, pattern):\n        """"""Checks the queue for a custom pattern.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            qml.templates.IQPEmbedding(features=list(range(4)), wires=range(4), pattern=pattern)\n\n        counter = 0\n        for gate in rec.queue:\n            # check wires of entanglers\n            if len(gate.wires) == 2:\n                assert gate.wires == Wires(pattern[counter])\n                counter += 1\n\n    @pytest.mark.parametrize(\'features\', [[1., 2.],\n                                          [1., 2., 3., 4.],\n                                          [[1., 1.], [2., 2.], [3., 3.]]])\n    def test_exception_wrong_number_of_features(self, features):\n        """"""Verifies that an exception is raised if \'feature\' has the wrong shape.""""""\n\n        dev = qml.device(\'default.qubit\', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(f=None):\n            qml.templates.IQPEmbedding(features=f, wires=range(3))\n            return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(f=features)\n\n    @pytest.mark.parametrize(\'pattern\', [[[1], [2]],\n                                         [[0, 1, 2], [0, 1, 2]]])\n    def test_exception_wrong_shape_pattern(self, pattern):\n        """"""Verifies that an exception is raised if \'pattern\' is of a wrong shape.""""""\n\n        dev = qml.device(\'default.qubit\', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(f=None):\n            qml.templates.IQPEmbedding(features=f, wires=range(3), pattern=pattern)\n            return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n        with pytest.raises(ValueError, match=""\'pattern\' must be a list of pairs of wires""):\n            circuit(f=[1., 2., 3.])\n\n    def test_exception_wrong_type_n_repeats(self):\n        """"""Verifies that an exception is raised if \'n_repeats\' is of a wrong type.""""""\n\n        dev = qml.device(\'default.qubit\', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(f=None):\n            qml.templates.IQPEmbedding(features=f, wires=range(3), n_repeats=\'a\')\n            return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n        with pytest.raises(ValueError, match=""\'n_repeats\' must be an integer""):\n            circuit(f=[1., 2., 3.])\n\n    def test_exception_features_passed_as_positional_arg(self):\n        """"""Verifies that an exception is raised if \'features\' is passed as a positional argument to the\n         qnode.""""""\n\n        dev = qml.device(\'default.qubit\', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(features):\n            qml.templates.IQPEmbedding(features=features, wires=range(3))\n            return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n        with pytest.raises(ValueError, match=""\'features\' cannot be differentiable""):\n            circuit([1., 2., 3.])\n\n\nclass TestQAOAEmbedding:\n    """""" Tests the QAOAEmbedding method.""""""\n\n    QUEUES = [(1, (1, 1), [qml.RX, qml.RY, qml.RX]),\n              (2, (1, 3), [qml.RX, qml.RX, qml.MultiRZ, qml.RY, qml.RY, qml.RX, qml.RX]),\n              (3, (1, 6), [qml.RX, qml.RX, qml.RX, qml.MultiRZ, qml.MultiRZ, qml.MultiRZ,\n                   qml.RY, qml.RY, qml.RY, qml.RX, qml.RX, qml.RX])]\n\n    @pytest.mark.parametrize(\'n_wires, weight_shape, expected_queue\', QUEUES)\n    def test_queue(self, n_wires, weight_shape, expected_queue):\n        """"""Checks the queue for the default settings.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            QAOAEmbedding(features=list(range(n_wires)), weights=np.zeros(shape=weight_shape), wires=range(n_wires))\n\n        for gate, expected_gate in zip(rec.queue, expected_queue):\n            assert isinstance(gate, expected_gate)\n\n    def test_state_zero_weights(self, qubit_device, n_subsystems, tol):\n        """"""Checks the state produced by QAOAEmbedding() is correct if the weights are zero.""""""\n\n        features = [pi, pi / 2, pi / 4, 0]\n        if n_subsystems == 1:\n            shp = (1, 1)\n        elif n_subsystems == 2:\n            shp = (1, 3)\n        else:\n            shp = (1, 2 * n_subsystems)\n\n        weights = np.zeros(shape=shp)\n\n        @qml.qnode(qubit_device)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(n_subsystems))\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        res = circuit(x=features[:n_subsystems])\n        target = [1, -1, 0, 1, 1]\n        assert np.allclose(res, target[:n_subsystems], atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\'n_subsystems, weights, target\', [(1, [[pi / 2]], [0]),\n                                                               (2, [[1, pi / 2, pi / 4]], [0, 1 / np.sqrt(2)]),\n                                                               (3, [[0, 0, 0, pi, pi / 2, pi / 4]],\n                                                                [-1, 0, 1 / np.sqrt(2)])])\n    def test_output_local_field_ry(self, n_subsystems, weights, target, tol):\n        """"""Checks the output if the features are zero. Uses RY local fields.""""""\n\n        features = np.zeros(shape=(n_subsystems,))\n        dev = qml.device(\'default.qubit\', wires=n_subsystems)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(n_subsystems), local_field=\'Y\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        res = circuit(x=features[:n_subsystems])\n        assert np.allclose(res, target, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\'n_subsystems, weights, target\', [(1, [[pi / 2]], [0]),\n                                                               (2, [[1, pi / 2, pi / 4]], [0, 1 / np.sqrt(2)]),\n                                                               (3, [[0, 0, 0, pi, pi / 2, pi / 4]],\n                                                                [-1, 0, 1 / np.sqrt(2)])])\n    def test_output_local_field_rx(self, n_subsystems, weights, target, tol):\n        """"""Checks the output if the features are zero. Uses RX local fields.""""""\n\n        features = np.zeros(shape=(n_subsystems,))\n        dev = qml.device(\'default.qubit\', wires=n_subsystems)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(n_subsystems), local_field=\'X\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        res = circuit(x=features[:n_subsystems])\n        assert np.allclose(res, target, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\'n_subsystems, weights, target\', [(1, [[pi / 2]], [1]),\n                                                               (2, [[1, pi / 2, pi / 4]], [1, 1]),\n                                                               (3, [[0, 0, 0, pi, pi / 2, pi / 4]], [1, 1, 1])])\n    def test_output_local_field_rz(self, n_subsystems, weights, target, tol):\n        """"""Checks the output if the features are zero. Uses RZ local fields.""""""\n\n        features = np.zeros(shape=(n_subsystems,))\n        dev = qml.device(\'default.qubit\', wires=n_subsystems)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(n_subsystems), local_field=\'Z\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_subsystems)]\n\n        res = circuit(x=features[:n_subsystems])\n        assert np.allclose(res, target, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\'weights, target\', [([[np.pi, 0, 0]], [1, 1]),\n                                                 ([[np.pi / 2, 0, 0]], [0, 0]),\n                                                 ([[0, 0, 0]], [-1, -1])])\n    def test_output_zz(self, weights, target, tol):\n        """"""Checks the output if the features and entangler weights are nonzero.""""""\n\n        dev = qml.device(\'default.qubit\', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(2))\n            return [qml.expval(qml.PauliZ(i)) for i in range(2)]\n\n        res = circuit(x=[np.pi/2, np.pi/2])\n\n        assert np.allclose(res, target, atol=tol, rtol=0)\n\n    @pytest.mark.parametrize(\'n_wires, features, weights, target\', [(2, [0], [[0, 0, np.pi / 2]], [1, 0]),\n                                                                    (3, [0, 0], [[0, 0, 0, 0, 0, np.pi / 2]],\n                                                                     [1, 1, 0])])\n    def test_state_more_qubits_than_features(self, n_wires, features, weights, target, tol):\n        """"""Checks the state is correct if there are more qubits than features.""""""\n\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(n_wires), local_field=\'Z\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\n        res = circuit(x=features)\n        assert np.allclose(res, target, atol=tol, rtol=0)\n\n    def test_exception_fewer_wires_than_features(self, ):\n        """"""Verifies that QAOAEmbedding() raises an exception if there are fewer\n           wires than features.""""""\n\n        features = [0, 0, 0, 0]\n        n_wires = 1\n        weights = np.zeros(shape=(1, 2 * n_wires))\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(n_wires))\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(x=features)\n\n    def test_exception_wrongrot(self):\n        """"""Verifies that QAOAEmbedding() raises an exception if the\n        rotation strategy is unknown.""""""\n\n        n_wires = 1\n        weights = np.zeros(shape=(1, 2 * n_wires))\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            QAOAEmbedding(features=x, weights=weights, wires=range(n_wires), local_field=\'A\')\n            return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\n        with pytest.raises(ValueError, match=""did not recognize option""):\n            circuit(x=[1])\n\n\nclass TestDisplacementEmbedding:\n    """""" Tests the DisplacementEmbedding method.""""""\n\n    def test_displacement_embedding_state_execution_amplitude(self):\n        """"""Checks the state produced by DisplacementEmbedding()\n        using the amplitude execution method.""""""\n\n        features = np.array([0.1, 1.2])\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            DisplacementEmbedding(features=x, wires=range(n_wires), method=\'amplitude\', c=1.)\n            return [qml.expval(qml.NumberOperator(wires=0)), qml.expval(qml.NumberOperator(wires=1))]\n\n        assert np.allclose(circuit(x=features), [0.01, 1.44], atol=0.001)\n\n    def test_displacement_embedding_state_execution_phase(self):\n        """"""Checks the state produced by DisplacementEmbedding()\n        using the phase execution method.""""""\n\n        features = np.array([1.2, 0.3])\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            DisplacementEmbedding(features=x, wires=range(n_wires), method=\'phase\', c=1.)\n            Beamsplitter(pi / 2, 0, wires=[0, 1])\n            DisplacementEmbedding(features=[0, 0], wires=range(n_wires), method=\'phase\', c=1.)\n            return [qml.expval(qml.NumberOperator(wires=0)), qml.expval(qml.NumberOperator(wires=1))]\n\n        assert np.allclose(circuit(x=features), [0.089327, 2.724715], atol=0.01)\n\n    def test_squeezing_embedding_exception_for_wrong_num_wires(self):\n        """"""Verifies that DisplacementEmbedding() throws exception\n        if number of subsystems wrong.""""""\n\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            DisplacementEmbedding(features=x, wires=range(n_wires), method=\'phase\')\n            return [qml.expval(qml.X(i)) for i in range(n_wires)]\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(x=[0.2, 0.3, 0.4])\n\n    def test_displacement_embedding_strategy_not_recognized_exception(self):\n        """"""Verifies that DisplacementEmbedding() throws exception\n        if strategy unknown.""""""\n\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            DisplacementEmbedding(features=x, wires=range(n_wires), method=\'A\')\n            return [qml.expval(qml.X(i)) for i in range(n_wires)]\n\n        with pytest.raises(ValueError, match=""did not recognize option""):\n            circuit(x=[1, 2])\n\n\nclass TestSqueezingEmbedding:\n    """""" Tests the SqueezingEmbedding method.""""""\n\n    def test_squeezing_embedding_state_execution_amplitude(self):\n        """"""Checks the state produced by SqueezingEmbedding()\n        using the amplitude execution method.""""""\n\n        features = np.array([1.2, 0.3])\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            SqueezingEmbedding(features=x, wires=range(n_wires), method=\'amplitude\', c=1)\n            return [qml.expval(qml.NumberOperator(wires=0)), qml.expval(qml.NumberOperator(wires=1))]\n\n        assert np.allclose(circuit(x=features), [2.2784, 0.09273], atol=0.001)\n\n    def test_squeezing_embedding_state_execution_phase(self):\n        """"""Checks the state produced by SqueezingEmbedding()\n        using the phase execution method.""""""\n\n        features = np.array([1.2, 0.3])\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            SqueezingEmbedding(features=x, wires=range(n_wires), method=\'phase\', c=1)\n            Beamsplitter(pi / 2, 0, wires=[0, 1])\n            SqueezingEmbedding(features=[0, 0], wires=range(n_wires), method=\'phase\', c=1)\n            return [qml.expval(qml.NumberOperator(wires=0)), qml.expval(qml.NumberOperator(wires=1))]\n\n        assert np.allclose(circuit(x=features), [12.86036, 8.960306], atol=0.001)\n\n    def test_squeezing_embedding_exception_for_wrong_num_wires(self):\n        """"""Verifies that SqueezingEmbedding() throws exception if number of modes is wrong.""""""\n\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            SqueezingEmbedding(features=x, wires=range(n_wires), method=\'phase\')\n            return [qml.expval(qml.X(i)) for i in range(n_wires)]\n\n        with pytest.raises(ValueError, match=""\'features\' must be of shape""):\n            circuit(x=[0.2, 0.3, 0.4])\n\n    def test_squeezing_embedding_strategy_not_recognized_exception(self):\n        """"""Verifies that SqueezingEmbedding() throws exception\n        if strategy unknown.""""""\n\n        n_wires = 2\n        dev = qml.device(\'default.gaussian\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(x=None):\n            SqueezingEmbedding(features=x, wires=range(n_wires), method=\'A\')\n            return [qml.expval(qml.X(i)) for i in range(n_wires)]\n\n        with pytest.raises(ValueError, match=""did not recognize option""):\n            circuit(x=[1, 2])\n'"
tests/templates/test_integration.py,4,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nIntegration tests for templates.\n\nNew **templates** are added as follows:\n\n* extend the fixtures ``QUBIT_DIFFABLE_NONDIFFABLE`` or ``CV_DIFFABLE_NONDIFFABLE``\n  by the new template\n* extend the fixtures ``QUBIT_INIT`` or ``CV_INIT`` if you want to test integration with initialization\n  functions from the ``pennylane.init`` module.\n\nNote that a template may need to be manually excluded from a test,\nas shown for the templates listed in NO_OPS_BEFORE, which do not allow for\noperations to be executed before the template is called.\n\nTemplates are tested with a range of interfaces. To test templates with an additional interface:\n\n* Try to import the interface and add its variable creation function to INTERFACES\n* Extend the fixture ``interfaces``\n* Add the interface gradient computation to the TestGradientIntegration tests\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport pytest\nimport numpy as np\nimport pennylane as qml\n\n#######################################\n# Interfaces\n\nINTERFACES = [(\'numpy\', np.array)]\n\ntry:\n    import torch\n    from torch.autograd import Variable as TorchVariable\n\n    INTERFACES.append((\'torch\', torch.tensor))\nexcept ImportError as e:\n    pass\n\ntry:\n    import tensorflow as tf\n\n    if tf.__version__[0] == ""1"":\n        tf.enable_eager_execution()\n\n    from tensorflow import Variable as TFVariable\n    INTERFACES.append((\'tf\', TFVariable))\n\nexcept ImportError as e:\n    pass\n\n#########################################\n# Fixtures for integration tests\n#########################################\n\n# Each entry to QUBIT_DIFFABLE_NONDIFFABLE or CV_DIFFABLE_NONDIFFABLE\n# adds a template with specified inputs to the integration tests\n# ``TestIntegrationQnode``, ``TestIntegrationOtherOps``, ``TestIntegrationGradient``\n\n# The entries have the following form:\n# (template, dict of differentiable arguments, dict of non-differentiable arguments)\n\n# ""Differentiable arguments"" to a template are those that in principle allow a user to compute gradients for,\n# while ""nondifferentiable arguments"" must always be passed as auxiliary (keyword) arguments to a qnode.\n\n# Note that the template is called in all tests using 2 wires\n\nQUBIT_DIFFABLE_NONDIFFABLE = [(qml.templates.AmplitudeEmbedding,\n                               {\'features\': [1 / 2, 1 / 2, 1 / 2, 1 / 2]},\n                               {\'wires\': [0, 1], \'normalize\': False}),\n                              (qml.templates.AmplitudeEmbedding,\n                               {\'features\': [1 / 2, 1 / 2, 1 / 2, 1 / 2]},\n                               {\'wires\': [0, 1], \'normalize\': True}),\n                              (qml.templates.BasisEmbedding,\n                               {},\n                               {\'wires\': [0, 1], \'features\': [1, 0]}),\n                              (qml.templates.MottonenStatePreparation,\n                               {\'state_vector\': np.array([1 / 2, 1 / 2, 1 / 2, 1 / 2])},\n                               {\'wires\': [0, 1]}),\n                              (qml.templates.BasisStatePreparation,\n                               {},\n                               {\'wires\': [0, 1], \'basis_state\': np.array([1, 0])}),\n                              (qml.templates.StronglyEntanglingLayers,\n                               {\'weights\': [[[4.54, 4.79, 2.98], [4.93, 4.11, 5.58]],\n                                            [[6.08, 5.94, 0.05], [2.44, 5.07, 0.95]]]},\n                               {\'wires\': [0, 1]}),\n                              (qml.templates.RandomLayers,\n                               {\'weights\': [[0.56, 5.14], [2.21, 4.27]]},\n                               {\'wires\': [0, 1]}),\n                              (qml.templates.AngleEmbedding,\n                               {\'features\': [1., 2.]},\n                               {\'wires\': [0, 1]}),\n                              (qml.templates.QAOAEmbedding,\n                               {\'features\': [1., 2.],\n                                \'weights\': [[0.1, 0.1, 0.1]]},\n                               {\'wires\': [0, 1]}),\n                              (qml.templates.broadcast,\n                               {\'parameters\': [[1.], [1.]]},\n                               {\'wires\': [0, 1], \'unitary\': qml.RX, \'pattern\': \'single\'}),\n                              (qml.templates.SimplifiedTwoDesign,\n                               {\'initial_layer_weights\': [1., 1.],\n                                \'weights\': [[[1., 1.]]]},\n                               {\'wires\': [0, 1]}),\n                              (qml.templates.BasicEntanglerLayers,\n                               {\'weights\': [[1., 1.]]},\n                               {\'wires\': [0, 1], \'rotation\': qml.RX}),\n                              (qml.templates.IQPEmbedding,\n                               {},\n                               {\'wires\': [0, 1], \'features\': [1., 1.]}),\n                              (qml.templates.SingleExcitationUnitary,\n                               {\'weight\': 0.56},\n                               {\'wires\': [0, 1]}),\n                              (qml.templates.DoubleExcitationUnitary,\n                               {\'weight\': 0.56},\n                               {\'wires\': [0, 1, 2, 3]}),\n                              (qml.templates.UCCSD,\n                               {\'weights\':[3.90575761, -1.89772083, -1.36689032]},\n                               {\'wires\': [0, 1, 2, 3], \'ph\': [[0, 2], [1, 3]],\n                                \'pphh\': [[0, 1, 2, 3]], \'init_state\':np.array([1, 1, 0, 0])},),\n                              ]\n\nCV_DIFFABLE_NONDIFFABLE = [(qml.templates.DisplacementEmbedding,\n                            {\'features\': [1., 2.]},\n                            {\'wires\': [0, 1]}),\n                           (qml.templates.SqueezingEmbedding,\n                            {\'features\': [1., 2.]},\n                            {\'wires\': [0, 1]}),\n                           (qml.templates.CVNeuralNetLayers,\n                            {\'theta_1\': [[2.31], [1.22]],\n                             \'phi_1\': [[3.47], [2.01]],\n                             \'varphi_1\': [[0.93, 1.58], [5.07, 4.82]],\n                             \'r\': [[0.21, 0.12], [-0.09, 0.04]],\n                             \'phi_r\': [[4.76, 6.08], [6.09, 6.22]],\n                             \'theta_2\': [[4.83], [1.70]],\n                             \'phi_2\': [[4.74], [5.39]],\n                             \'varphi_2\': [[0.88, 0.62], [1.09, 3.02]],\n                             \'a\': [[-0.01, -0.05], [0.08, -0.19]],\n                             \'phi_a\': [[1.89, 3.59], [1.49, 3.71]],\n                             \'k\': [[0.09, 0.03], [-0.14, 0.04]]},\n                            {\'wires\': [0, 1]}),\n                           (qml.templates.Interferometer,\n                            {\'theta\': [2.31],\n                             \'phi\': [3.49],\n                             \'varphi\': [0.98, 1.54]},\n                            {\'wires\': [0, 1]}),\n                           ]\n\n# List templates in NO_OP_BEFORE that do not allow for operations\n# before they are called in a quantum function.\n# These templates will be skipped in tests of that nature.\n\nNO_OP_BEFORE = [""AmplitudeEmbedding"", ""UCCSD""]\n\n# Each entry to QUBIT_INIT and CV_INIT adds a template with specified inputs to the\n# integration tests ``TestIntegrationInitFunctions``\n\n# The entries have the following form:\n#\n# (template, dict of arguments)\n#\n# The dictionary of arguments calls the initialization function, and contains all other arguments that need to\n# be defined in the template.\n\nQUBIT_INIT = [(qml.templates.StronglyEntanglingLayers,\n               {\'weights\': qml.init.strong_ent_layers_uniform(n_layers=3, n_wires=2), \'wires\': range(2)}),\n              (qml.templates.StronglyEntanglingLayers,\n               {\'weights\': qml.init.strong_ent_layers_uniform(n_layers=2, n_wires=3), \'wires\': range(3)}),\n              (qml.templates.StronglyEntanglingLayers,\n               {\'weights\': qml.init.strong_ent_layers_normal(n_layers=3, n_wires=2), \'wires\': range(2)}),\n              (qml.templates.StronglyEntanglingLayers,\n               {\'weights\': qml.init.strong_ent_layers_normal(n_layers=2, n_wires=3), \'wires\': range(3)}),\n              (qml.templates.RandomLayers,\n               {\'weights\': qml.init.random_layers_uniform(n_layers=3, n_rots=2, n_wires=1), \'wires\': range(1)}),\n              (qml.templates.RandomLayers,\n               {\'weights\': qml.init.random_layers_uniform(n_layers=3, n_rots=2, n_wires=2), \'wires\': range(2)}),\n              (qml.templates.RandomLayers,\n               {\'weights\': qml.init.random_layers_normal(n_layers=2, n_rots=2, n_wires=1), \'wires\': range(1)}),\n              (qml.templates.RandomLayers,\n               {\'weights\': qml.init.random_layers_normal(n_layers=2, n_rots=2, n_wires=2), \'wires\': range(2)}),\n              (qml.templates.QAOAEmbedding,\n               {\'features\': [1.], \'weights\': qml.init.qaoa_embedding_uniform(n_layers=3, n_wires=1),\n                \'wires\': range(1)}),\n              (qml.templates.QAOAEmbedding,\n               {\'features\': [1., 2.], \'weights\': qml.init.qaoa_embedding_uniform(n_layers=3, n_wires=2),\n                \'wires\': range(2)}),\n              (qml.templates.QAOAEmbedding,\n               {\'features\': [1., 2., 3.], \'weights\': qml.init.qaoa_embedding_uniform(n_layers=2, n_wires=3),\n                \'wires\': range(3)}),\n              (qml.templates.QAOAEmbedding,\n               {\'features\': [1.], \'weights\': qml.init.qaoa_embedding_normal(n_layers=3, n_wires=1),\n                \'wires\': range(1)}),\n              (qml.templates.QAOAEmbedding,\n               {\'features\': [1., 2.], \'weights\': qml.init.qaoa_embedding_normal(n_layers=3, n_wires=2),\n                \'wires\': range(2)}),\n              (qml.templates.QAOAEmbedding,\n               {\'features\': [1., 2., 3.], \'weights\': qml.init.qaoa_embedding_normal(n_layers=3, n_wires=3),\n                \'wires\': range(3)}),\n              (qml.templates.SimplifiedTwoDesign,\n               {\'initial_layer_weights\': qml.init.simplified_two_design_initial_layer_uniform(n_wires=4),\n                \'weights\': qml.init.simplified_two_design_weights_uniform(n_layers=3, n_wires=4),\n                \'wires\': range(4)}),\n              (qml.templates.SimplifiedTwoDesign,\n               {\'initial_layer_weights\': qml.init.simplified_two_design_initial_layer_normal(n_wires=4),\n                \'weights\': qml.init.simplified_two_design_weights_normal(n_layers=3, n_wires=4),\n                \'wires\': range(4)}),\n              (qml.templates.BasicEntanglerLayers,\n               {\'weights\': qml.init.basic_entangler_layers_uniform(n_layers=1, n_wires=1), \'wires\': range(1)}),\n              (qml.templates.BasicEntanglerLayers,\n               {\'weights\': qml.init.basic_entangler_layers_uniform(n_layers=3, n_wires=1), \'wires\': range(1)}),\n              (qml.templates.BasicEntanglerLayers,\n               {\'weights\': qml.init.basic_entangler_layers_uniform(n_layers=3, n_wires=2), \'wires\': range(2)}),\n              (qml.templates.BasicEntanglerLayers,\n               {\'weights\': qml.init.basic_entangler_layers_uniform(n_layers=3, n_wires=3), \'wires\': range(3)}),\n              (qml.templates.BasicEntanglerLayers,\n               {\'weights\': qml.init.basic_entangler_layers_normal(n_layers=3, n_wires=1), \'wires\': range(1)}),\n              (qml.templates.BasicEntanglerLayers,\n               {\'weights\': qml.init.basic_entangler_layers_normal(n_layers=3, n_wires=2), \'wires\': range(2)}),\n              (qml.templates.BasicEntanglerLayers,\n               {\'weights\': qml.init.basic_entangler_layers_normal(n_layers=3, n_wires=3), \'wires\': range(3)}),\n              ]\n\nCV_INIT = [(qml.templates.CVNeuralNetLayers,\n            {\'theta_1\': qml.init.cvqnn_layers_theta_uniform(n_layers=3, n_wires=1),\n             \'phi_1\': qml.init.cvqnn_layers_phi_uniform(n_layers=3, n_wires=1),\n             \'varphi_1\': qml.init.cvqnn_layers_varphi_uniform(n_layers=3, n_wires=1),\n             \'r\': qml.init.cvqnn_layers_r_uniform(n_layers=3, n_wires=1),\n             \'phi_r\': qml.init.cvqnn_layers_phi_r_uniform(n_layers=3, n_wires=1),\n             \'theta_2\': qml.init.cvqnn_layers_theta_uniform(n_layers=3, n_wires=1),\n             \'phi_2\': qml.init.cvqnn_layers_phi_uniform(n_layers=3, n_wires=1),\n             \'varphi_2\': qml.init.cvqnn_layers_varphi_uniform(n_layers=3, n_wires=1),\n             \'a\': qml.init.cvqnn_layers_a_uniform(n_layers=3, n_wires=1),\n             \'phi_a\': qml.init.cvqnn_layers_phi_a_uniform(n_layers=3, n_wires=1),\n             \'k\': qml.init.cvqnn_layers_kappa_uniform(n_layers=3, n_wires=1),\n             \'wires\': range(1)}),\n           (qml.templates.CVNeuralNetLayers,\n            {\'theta_1\': qml.init.cvqnn_layers_theta_normal(n_layers=3, n_wires=2),\n             \'phi_1\': qml.init.cvqnn_layers_phi_normal(n_layers=3, n_wires=2),\n             \'varphi_1\': qml.init.cvqnn_layers_varphi_normal(n_layers=3, n_wires=2),\n             \'r\': qml.init.cvqnn_layers_r_normal(n_layers=3, n_wires=2),\n             \'phi_r\': qml.init.cvqnn_layers_phi_r_normal(n_layers=3, n_wires=2),\n             \'theta_2\': qml.init.cvqnn_layers_theta_normal(n_layers=3, n_wires=2),\n             \'phi_2\': qml.init.cvqnn_layers_phi_normal(n_layers=3, n_wires=2),\n             \'varphi_2\': qml.init.cvqnn_layers_varphi_normal(n_layers=3, n_wires=2),\n             \'a\': qml.init.cvqnn_layers_a_normal(n_layers=3, n_wires=2),\n             \'phi_a\': qml.init.cvqnn_layers_phi_a_normal(n_layers=3, n_wires=2),\n             \'k\': qml.init.cvqnn_layers_kappa_normal(n_layers=3, n_wires=2),\n             \'wires\': range(2)}),\n           (qml.templates.Interferometer,\n            {\'phi\': qml.init.interferometer_phi_uniform(n_wires=1),\n             \'varphi\': qml.init.interferometer_varphi_uniform(n_wires=1),\n             \'theta\': qml.init.interferometer_theta_uniform(n_wires=1),\n             \'wires\': range(1)}),\n           (qml.templates.Interferometer,\n            {\'phi\': qml.init.interferometer_phi_normal(n_wires=1),\n             \'varphi\': qml.init.interferometer_varphi_normal(n_wires=1),\n             \'theta\': qml.init.interferometer_theta_normal(n_wires=1),\n             \'wires\': range(1)}),\n           (qml.templates.Interferometer,\n            {\'phi\': qml.init.interferometer_phi_uniform(n_wires=3),\n             \'varphi\': qml.init.interferometer_varphi_uniform(n_wires=3),\n             \'theta\': qml.init.interferometer_theta_uniform(n_wires=3),\n             \'wires\': range(3)}),\n           (qml.templates.Interferometer,\n            {\'phi\': qml.init.interferometer_phi_normal(n_wires=3),\n             \'varphi\': qml.init.interferometer_varphi_normal(n_wires=3),\n             \'theta\': qml.init.interferometer_theta_normal(n_wires=3),\n             \'wires\': range(3)})\n           ]\n\n\nclass TestIntegrationQnode:\n    """"""Tests the integration of templates into qnodes when differentiable arguments are passed as\n    primary or auxiliary arguments to the qnode, using different interfaces.\n\n    ""Differentiable arguments"" to a template are those that in principle allow a user to compute gradients for,\n    while ""nondifferentiable arguments"" must always be passed as auxiliary (keyword) arguments to a qnode.\n\n    The tests are motivated by the fact that the way arguments are passed to the qnode\n    influences what shape and/or type the argument has inside the qnode, which is where the template calls it.\n\n    All templates should work no matter how the ""differentiable arguments"" are passed to the qnode.\n    """"""\n\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", QUBIT_DIFFABLE_NONDIFFABLE)\n    @pytest.mark.parametrize(""interface, to_var"", INTERFACES)\n    def test_qubit_qnode_primary_args(self, template, diffable, nondiffable, interface, to_var):\n        """"""Tests integration of qubit templates with other operations, passing differentiable arguments\n        as primary arguments to qnode.""""""\n\n        # Extract keys and items\n        keys_diffable = [*diffable]\n        diffable = list(diffable.values())\n\n        # Turn into correct format\n        diffable = [to_var(i) for i in diffable]\n\n        # Generate qnode\n        n_wires = len(nondiffable[\'wires\'])\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        # Generate qnode in which differentiable arguments are passed\n        # as primary argument\n        @qml.qnode(dev, interface=interface)\n        def circuit(*diffable, keys_diffable=None, nondiffable=None):\n            # Turn diffables back into dictionary\n            all_args = {key: item for key, item in zip(keys_diffable, diffable)}\n\n            # Merge with nondiffables\n            all_args.update(nondiffable)\n\n            template(**all_args)\n            return qml.expval(qml.Identity(0))\n\n        # Check that execution does not throw error\n        circuit(*diffable, keys_diffable=keys_diffable, nondiffable=nondiffable)\n\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", CV_DIFFABLE_NONDIFFABLE)\n    @pytest.mark.parametrize(""interface, to_var"", INTERFACES)\n    def test_cv_qnode_primary_args(self, template, diffable, nondiffable,\n                                   interface, to_var, gaussian_dummy):\n        """"""Tests integration of cv templates passing differentiable arguments as positional arguments to qnode.""""""\n\n        # Extract keys and items\n        keys_diffable = [*diffable]\n        diffable = list(diffable.values())\n\n        # Turn into correct format\n        diffable = [to_var(i) for i in diffable]\n\n        # Generate qnode in which differentiable arguments are passed\n        # as primary argument\n        n_wires = len(nondiffable[\'wires\'])\n        dev = gaussian_dummy(n_wires)\n\n        @qml.qnode(dev, interface=interface)\n        def circuit(*diffable, keys_diffable=None, nondiffable=None):\n            # Turn diffables back into dictionary\n            all_args = dict(zip(keys_diffable, diffable))\n\n            # Merge with nondiffables\n            all_args.update(nondiffable)\n\n            template(**all_args)\n            return qml.expval(qml.Identity(0))\n\n        # Check that execution does not throw error\n        circuit(*diffable, keys_diffable=keys_diffable, nondiffable=nondiffable)\n\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", QUBIT_DIFFABLE_NONDIFFABLE)\n    @pytest.mark.parametrize(""interface, to_var"", INTERFACES)\n    def test_qubit_qnode_auxiliary_args(self, template, diffable, nondiffable, interface, to_var):\n        """"""Tests integration of qubit templates passing differentiable arguments as auxiliary arguments to qnode.""""""\n\n        # Change type of differentiable arguments\n        # Fix: templates should all take arrays AND lists, at the moment this is not the case\n        diffable = {k: np.array(v) for k, v in diffable.items()}\n\n        # Merge differentiable and non-differentiable arguments\n        all_args = {**diffable, **nondiffable}\n\n        # Generate qnode\n        n_wires = len(nondiffable[\'wires\'])\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        # Generate qnode in which differentiable arguments are passed\n        # as auxiliary argument\n        @qml.qnode(dev, interface=interface)\n        def circuit(all_args=None):\n            template(**all_args)\n            return qml.expval(qml.Identity(0))\n\n        # Check that execution does not throw error\n        circuit(all_args=all_args)\n\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", CV_DIFFABLE_NONDIFFABLE)\n    @pytest.mark.parametrize(""interface, to_var"", INTERFACES)\n    def test_qubit_cv_auxiliary_args(self, template, diffable, nondiffable,\n                                     interface, to_var, gaussian_dummy):\n        """"""Tests integration of cv templates passing differentiable arguments as auxiliary arguments to qnode.""""""\n\n        # Change type of differentiable arguments\n        # Fix: templates should all take arrays AND lists, at the moment this is not the case\n        diffable = {k: np.array(v) for k, v in diffable.items()}\n\n        # Merge differentiable and non-differentiable arguments\n        all_args = {**diffable, **nondiffable}\n\n        # Generate qnode in which differentiable arguments are passed\n        # as primary argument\n        n_wires = len(nondiffable[\'wires\'])\n        dev = gaussian_dummy(n_wires)\n\n        @qml.qnode(dev, interface=interface)\n        def circuit(all_args=None):\n            template(**all_args)\n            return qml.expval(qml.Identity(0))\n\n        # Check that execution does not throw error\n        circuit(all_args=all_args)\n\n\n# hand-coded templates for the operation integration test\n@qml.template\ndef QubitTemplate(w):\n    qml.PauliX(wires=w)\n\n\n@qml.template\ndef CVTemplate(w):\n    qml.Displacement(1., 1., wires=w)\n\n\nclass TestIntegrationOtherOps:\n    """"""Tests the integration of templates into qnodes where the template is called\n    together with other operations or templates.""""""\n\n    @pytest.mark.parametrize(""op_before_template"", [True, False])\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", QUBIT_DIFFABLE_NONDIFFABLE)\n    def test_qubit_template_followed_by_operations(self, template, diffable, nondiffable, op_before_template):\n        """"""Tests integration of qubit templates with other operations.""""""\n\n        # skip this test if template does not allow for operations before\n        if template.__name__ in NO_OP_BEFORE and op_before_template:\n            pytest.skip(""Template does not allow operations before - skipping this test."")\n\n        # Change type of differentiable arguments\n        # Fix: templates should all take arrays AND lists, at the moment this is not the case\n        diffable = {k: np.array(v) for k, v in diffable.items()}\n\n        # Merge differentiable and non-differentiable arguments\n        nondiffable.update(diffable)\n\n        # Generate qnode\n        n_wires = len(nondiffable[\'wires\'])\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(nondiffable=None):\n            # Circuit with operations before and\n            # after the template is called\n            if op_before_template:\n                QubitTemplate(w=0)\n                qml.PauliX(wires=0)\n            template(**nondiffable)\n            if not op_before_template:\n                QubitTemplate(w=0)\n                qml.PauliX(wires=1)\n            return [qml.expval(qml.Identity(0)), qml.expval(qml.PauliX(1))]\n\n        # Check that execution does not throw error\n        circuit(nondiffable=nondiffable)\n\n    @pytest.mark.parametrize(""op_before_template"", [True, False])\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", CV_DIFFABLE_NONDIFFABLE)\n    def test_cv_template_followed_by_operations(self, template, diffable, nondiffable, gaussian_dummy,\n                                                op_before_template):\n        """"""Tests integration of cv templates passing differentiable arguments as auxiliary arguments to qnode.""""""\n\n        # Change type of differentiable arguments\n        # Fix: templates should all take arrays AND lists, at the moment this is not the case\n        diffable = {k: np.array(v) for k, v in diffable.items()}\n\n        # Merge differentiable and non-differentiable arguments\n        nondiffable.update(diffable)\n\n        # Make qnode\n        n_wires = len(nondiffable[\'wires\'])\n        dev = gaussian_dummy(n_wires)\n\n        @qml.qnode(dev)\n        def circuit(nondiffable=None):\n\n            # Circuit with operations before and\n            # after the template is called\n            if op_before_template:\n                CVTemplate(w=0)\n                qml.Displacement(1., 1., wires=0)\n            template(**nondiffable)\n            if not op_before_template:\n                CVTemplate(w=0)\n                qml.Displacement(1., 1., wires=1)\n            return [qml.expval(qml.Identity(0)), qml.expval(qml.X(1))]\n\n        # Check that execution does not throw error\n        circuit(nondiffable=nondiffable)\n\n\nclass TestIntegrationGradient:\n    """"""Tests that gradients of circuits with templates can be computed.""""""\n\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", QUBIT_DIFFABLE_NONDIFFABLE)\n    @pytest.mark.parametrize(""interface, to_var"", INTERFACES)\n    def test_integration_qubit_grad(self, template, diffable, nondiffable, interface, to_var):\n        """"""Tests that gradient calculations of qubit templates execute without error.""""""\n\n        # Extract keys and items\n        keys_diffable = [*diffable]\n        diffable = list(diffable.values())\n\n        # Turn into correct format\n        diffable = [to_var(i) for i in diffable]\n\n        # Make qnode\n        n_wires = len(nondiffable[\'wires\'])\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev, interface=interface)\n        def circuit(*diffable):\n\n            # Turn diffables back into dictionaries\n            dict = {key: item for key, item in zip(keys_diffable, diffable)}\n\n            # Merge diffables and nondiffables\n            dict.update(nondiffable)\n\n            # Circuit\n            template(**dict)\n            return qml.expval(qml.Identity(0))\n\n        # Do gradient check for every differentiable argument\n        for argnum in range(len(diffable)):\n\n            # Check gradients in numpy interface\n            if interface == \'numpy\':\n                grd = qml.grad(circuit, argnum=[argnum])\n                grd(*diffable)\n\n            # Check gradients in torch interface\n            if interface == \'torch\':\n                diffable[argnum] = TorchVariable(diffable[argnum], requires_grad=True)\n                res = circuit(*diffable)\n                res.backward()\n                diffable[argnum].grad.numpy()\n\n            # Check gradients in tf interface\n            if interface == \'tf\':\n                with tf.GradientTape() as tape:\n                    loss = circuit(*diffable)\n                    tape.gradient(loss, diffable[argnum])\n\n    @pytest.mark.parametrize(""template, diffable, nondiffable"", CV_DIFFABLE_NONDIFFABLE)\n    @pytest.mark.parametrize(""interface, to_var"", INTERFACES)\n    def test_integration_cv_grad(self, template, diffable, nondiffable, interface, to_var, gaussian_dummy):\n        """"""Tests that gradient calculations of cv templates execute without error.""""""\n\n        # Extract keys and items\n        keys_diffable = [*diffable]\n        diffable = list(diffable.values())\n\n        # Turn into correct format\n        diffable = [to_var(i) for i in diffable]\n\n        # Make qnode\n        n_wires = len(nondiffable[\'wires\'])\n        dev = gaussian_dummy(n_wires)\n\n        @qml.qnode(dev, interface=interface)\n        def circuit(*diffable):\n\n            # Turn diffables back into dictionaries\n            dict = {key: item for key, item in zip(keys_diffable, diffable)}\n\n            # Merge diffables and nondiffables\n            dict.update(nondiffable)\n\n            # Circuit\n            template(**dict)\n            return qml.expval(qml.Identity(0))\n\n        # Do gradient check for every differentiable argument\n        for argnum in range(len(diffable)):\n\n            # Check gradients in numpy interface\n            if interface == \'numpy\':\n                grd = qml.grad(circuit, argnum=[argnum])\n                grd(*diffable)\n\n            # Check gradients in torch interface\n            if interface == \'torch\':\n                diffable[argnum] = TorchVariable(diffable[argnum], requires_grad=True)\n                res = circuit(*diffable)\n                res.backward()\n                diffable[argnum].grad.numpy()\n\n            # Check gradients in tf interface\n            if interface == \'tf\':\n                with tf.GradientTape() as tape:\n                    loss = circuit(*diffable)\n                    tape.gradient(loss, diffable[argnum])\n\n\nclass TestInitializationIntegration:\n    """"""Tests integration with the parameter initialization functions from pennylane.init""""""\n\n    @pytest.mark.parametrize(""template, dict"", QUBIT_INIT)\n    def test_integration_qubit_init(self, template, dict):\n        """"""Tests that parameter initializations are compatible with qubit templates.""""""\n\n        n_wires = len(dict[\'wires\'])\n        dev = qml.device(\'default.qubit\', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit():\n            template(**dict)\n            return qml.expval(qml.Identity(0))\n\n        # Check that execution does not throw error\n        circuit()\n\n    @pytest.mark.parametrize(""template, dict"", CV_INIT)\n    def test_integration_cv_init(self, template, dict, gaussian_dummy):\n        """"""Tests that parameter initializations are compatible with cv templates.""""""\n\n        n_wires = len(dict[\'wires\'])\n        dev = gaussian_dummy(n_wires)\n\n        @qml.qnode(dev)\n        def circuit():\n            template(**dict)\n            return qml.expval(qml.Identity(0))\n\n        # Check that execution does not throw error\n        circuit()\n'"
tests/templates/test_layers.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.template.layers` module.\nIntegration tests should be placed into ``test_templates.py``.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport pytest\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom pennylane.templates.layers import (\n    CVNeuralNetLayers,\n    StronglyEntanglingLayers,\n    RandomLayers,\n    BasicEntanglerLayers,\n    SimplifiedTwoDesign,\n)\nfrom pennylane.templates.layers.random import random_layer\nfrom pennylane import RX, RY, RZ, CZ, CNOT\nfrom pennylane.wires import Wires\n\nTOLERANCE = 1e-8\n\n\nclass TestCVNeuralNet:\n    """"""Tests for the CVNeuralNet from the pennylane.template module.""""""\n\n    # Have a fixed number of subsystems in this handcoded test\n    @pytest.fixture(scope=""class"")\n    def num_subsystems(self):\n        return 4\n\n    @pytest.fixture(scope=""class"")\n    def weights(self):\n        return [\n            np.array(\n                [\n                    [5.48791879, 6.08552046, 5.46131036, 3.33546468, 1.46227521, 0.0716208],\n                    [3.36869403, 0.63074883, 4.59400392, 5.9040016, 5.92704296, 2.35455147],\n                ]\n            ),\n            np.array(\n                [\n                    [2.70471535, 2.52804815, 3.28406182, 3.0058243, 3.48940764, 3.41419504],\n                    [3.74320919, 4.15936005, 3.20807161, 2.95870535, 0.05574621, 0.42660569],\n                ]\n            ),\n            np.array(\n                [\n                    [4.7808479, 4.47598146, 3.89357744, 2.67721355],\n                    [2.73203094, 2.71115444, 1.16794164, 3.32823666],\n                ]\n            ),\n            np.array(\n                [\n                    [0.27344502, 0.68431314, 0.30026443, 0.23128064],\n                    [0.45945175, 0.53255468, 0.28383751, 0.34263728],\n                ]\n            ),\n            np.array(\n                [\n                    [2.3936353, 4.80135971, 5.89867895, 2.00867023],\n                    [5.14552399, 3.31578667, 5.90119363, 4.54515204],\n                ]\n            ),\n            np.array(\n                [\n                    [0.4134863, 6.17555778, 0.80334114, 2.02400747, 0.44574704, 1.41227118],\n                    [5.16969442, 3.6890488, 4.43916808, 3.20808287, 5.21543123, 4.52815349],\n                ]\n            ),\n            np.array(\n                [\n                    [2.47328111, 5.63064513, 2.17059932, 6.1873632, 0.18052879, 2.20970037],\n                    [5.44288268, 1.27806129, 1.87574979, 2.98956484, 3.10140853, 3.81814174],\n                ]\n            ),\n            np.array(\n                [\n                    [5.03318258, 4.01017269, 0.43159284, 3.7928101],\n                    [3.5329307, 4.79661266, 5.0683084, 1.87631749],\n                ]\n            ),\n            np.array(\n                [\n                    [1.61159166, 0.1608155, 0.96535086, 1.60132783],\n                    [0.36293094, 1.30725604, 0.11578591, 1.5983082],\n                ]\n            ),\n            np.array(\n                [\n                    [6.21267547, 3.71076099, 0.34060195, 2.86031556],\n                    [3.20443756, 6.26536946, 6.18450567, 1.50406923],\n                ]\n            ),\n            np.array(\n                [\n                    [0.1376345, 0.22541113, 0.14306356, 0.13019402],\n                    [0.26999146, 0.26256351, 0.14722687, 0.23137066],\n                ]\n            ),\n        ]\n\n    def test_cvneuralnet_uses_correct_weights(self, weights):\n        """"""Tests that the CVNeuralNetLayers template uses the weigh parameters correctly.""""""\n\n        with qml.utils.OperationRecorder() as rec:\n            CVNeuralNetLayers(*weights, wires=range(4))\n\n        # Test that gates appear in the right order for each layer:\n        # BS-R-S-BS-R-D-K\n        for l in range(2):\n            gates = [\n                qml.Beamsplitter,\n                qml.Rotation,\n                qml.Squeezing,\n                qml.Beamsplitter,\n                qml.Rotation,\n                qml.Displacement,\n            ]\n\n            # count the position of each group of gates in the layer\n            num_gates_per_type = [0, 6, 4, 4, 6, 4, 4, 4]\n            s = np.cumsum(num_gates_per_type)\n            gc = l * sum(num_gates_per_type) + np.array(list(zip(s[:-1], s[1:])))\n\n            # loop through expected gates\n            for idx, g in enumerate(gates):\n                # loop through where these gates should be in the queue\n                for opidx, op in enumerate(rec.queue[gc[idx, 0] : gc[idx, 1]]):\n                    # check that op in queue is correct gate\n                    assert isinstance(op, g)\n\n                    # test that the parameters are correct\n                    res_params = op.parameters\n\n                    if idx == 0:\n                        # first BS\n                        exp_params = [weights[0][l][opidx], weights[1][l][opidx]]\n                    elif idx == 1:\n                        # first rot\n                        exp_params = [weights[2][l][opidx]]\n                    elif idx == 2:\n                        # squeezing\n                        exp_params = [weights[3][l][opidx], weights[4][l][opidx]]\n                    elif idx == 3:\n                        # second BS\n                        exp_params = [weights[5][l][opidx], weights[6][l][opidx]]\n                    elif idx == 4:\n                        # second rot\n                        exp_params = [weights[7][l][opidx]]\n                    elif idx == 5:\n                        # displacement\n                        exp_params = [weights[8][l][opidx], weights[9][l][opidx]]\n\n                    assert res_params == exp_params\n\n    def test_cvqnn_layers_exception_nlayers(self, gaussian_device_4modes):\n        """"""Integration test for the CVNeuralNetLayers method.""""""\n\n        def circuit(weights):\n            CVNeuralNetLayers(*weights, wires=range(4))\n            return qml.expval(qml.X(0))\n\n        qnode = qml.QNode(circuit, gaussian_device_4modes)\n\n        wrong_weights = [np.array([1]) if i < 10 else np.array([1, 1]) for i in range(11)]\n        with pytest.raises(ValueError, match=""the first dimension of the weight parameters""):\n            qnode(wrong_weights)\n\n\nclass TestStronglyEntangling:\n    """"""Tests for the StronglyEntanglingLayers method from the pennylane.templates.layers module.""""""\n\n    @pytest.mark.parametrize(""n_layers"", range(1, 4))\n    def test_single_qubit(self, n_layers):\n        weights = np.zeros((n_layers, 1, 3))\n        with qml.utils.OperationRecorder() as rec:\n            StronglyEntanglingLayers(weights, wires=range(1))\n\n        assert len(rec.queue) == n_layers\n        assert all([isinstance(q, qml.Rot) for q in rec.queue])\n        assert all([q._wires[0] == Wires(0) for q in rec.queue])\n\n    def test_strong_ent_layers_uses_correct_weights(self, n_subsystems):\n        """"""Test that StronglyEntanglingLayers uses the correct weights in the circuit.""""""\n        np.random.seed(12)\n        n_layers = 2\n        num_wires = n_subsystems\n\n        weights = np.random.randn(n_layers, num_wires, 3)\n\n        with qml.utils.OperationRecorder() as rec:\n            StronglyEntanglingLayers(weights, wires=range(num_wires))\n\n        # Test that gates appear in the right order\n        exp_gates = [qml.Rot] * num_wires + [qml.CNOT] * num_wires\n        exp_gates *= n_layers\n        res_gates = rec.queue\n\n        for op1, op2 in zip(res_gates, exp_gates):\n            assert isinstance(op1, op2)\n\n        # test the device parameters\n        for l in range(n_layers):\n\n            layer_ops = rec.queue[2 * l * num_wires : 2 * (l + 1) * num_wires]\n\n            # check each rotation gate parameter\n            for n in range(num_wires):\n                res_params = layer_ops[n].parameters\n                exp_params = weights[l, n, :]\n                assert sum([r == e for r, e in zip(res_params, exp_params)])\n\n    def test_strong_ent_layers_uses_correct_number_of_imprimitives(self, n_layers, n_subsystems):\n        """"""Test that StronglyEntanglingLayers uses the correct number of imprimitives.""""""\n        imprimitive = CZ\n        weights = np.random.randn(n_layers, n_subsystems, 3)\n\n        with qml.utils.OperationRecorder() as rec:\n            StronglyEntanglingLayers(\n                weights=weights, wires=range(n_subsystems), imprimitive=imprimitive\n            )\n\n        types = [type(q) for q in rec.queue]\n        assert types.count(imprimitive) == n_subsystems * n_layers\n\n    @pytest.mark.parametrize(""n_wires, n_layers, ranges"", [(2, 2, [2, 1]), (3, 1, [5])])\n    def test_strong_ent_layers_ranges_equals_wires_exception(self, n_layers, n_wires, ranges):\n        """"""Test that StronglyEntanglingLayers throws and exception if a range is equal to or\n        larger than the number of wires.""""""\n        dev = qml.device(""default.qubit"", wires=n_wires)\n        weights = np.random.randn(n_layers, n_wires, 3)\n\n        def circuit(weights):\n            StronglyEntanglingLayers(weights=weights, wires=range(n_wires), ranges=ranges)\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = qml.QNode(circuit, dev)\n\n        with pytest.raises(ValueError, match=""the range for all layers needs to be smaller than""):\n            qnode(weights)\n\n    def test_strong_ent_layers_illegal_ranges_exception(self):\n        """"""Test that StronglyEntanglingLayers throws and exception if ``ranges`` parameter of illegal type.""""""\n        n_wires = 2\n        n_layers = 2\n        dev = qml.device(""default.qubit"", wires=n_wires)\n        weights = np.random.randn(n_layers, n_wires, 3)\n\n        def circuit(weights):\n            StronglyEntanglingLayers(weights=weights, wires=range(n_wires), ranges=[""a"", ""a""])\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = qml.QNode(circuit, dev)\n\n        with pytest.raises(ValueError, match=""\'ranges\' must be a list of integers""):\n            qnode(weights)\n\n    @pytest.mark.parametrize(""n_layers, ranges"", [(2, [1, 2, 4]), (5, [2])])\n    def test_strong_ent_layers_wrong_size_ranges_exception(self, n_layers, ranges):\n        """"""Test that StronglyEntanglingLayers throws and exception if ``ranges`` parameter\n        not of shape (len(wires),).""""""\n        n_wires = 5\n        dev = qml.device(""default.qubit"", wires=n_wires)\n        weights = np.random.randn(n_layers, n_wires, 3)\n\n        def circuit(weights):\n            StronglyEntanglingLayers(weights=weights, wires=range(n_wires), ranges=ranges)\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = qml.QNode(circuit, dev)\n\n        with pytest.raises(ValueError, match=""\'ranges\' must be of shape""):\n            qnode(weights)\n\n\nclass TestRandomLayers:\n    """"""Tests for the RandomLayers method from the pennylane.templates module.""""""\n\n    @pytest.fixture(scope=""class"", params=[0.2, 0.6])\n    def ratio(self, request):\n        return request.param\n\n    @pytest.fixture(scope=""class"", params=[CNOT, CZ])\n    def impr(self, request):\n        return request.param\n\n    @pytest.fixture(scope=""class"", params=[[RX], [RY, RZ]])\n    def rots(self, request):\n        return request.param\n\n    def test_same_circuit_for_same_seed(self, tol, seed):\n        """"""Test that RandomLayers() creates the same circuit when using the same seed.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        weights = [[0.1, 0.2, 0.3]]\n\n        def circuit(weights):\n            RandomLayers(weights=weights, wires=range(2), seed=seed)\n            return qml.expval(qml.PauliZ(0))\n\n        qnode1 = qml.QNode(circuit, dev)\n        qnode2 = qml.QNode(circuit, dev)\n        assert np.allclose(qnode1(weights), qnode2(weights), atol=tol)\n\n    def test_different_circuits_for_different_seeds(self, tol):\n        """"""Test that RandomLayers() does not necessarily have the same output for two different seeds.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        weights = [[0.1, 0.2, 0.3]]\n\n        def circuit1(weights):\n            RandomLayers(weights=weights, wires=range(2), seed=10)\n            return qml.expval(qml.PauliZ(0))\n\n        def circuit2(weights):\n            RandomLayers(weights=weights, wires=range(2), seed=20)\n            return qml.expval(qml.PauliZ(0))\n\n        qnode1 = qml.QNode(circuit1, dev)\n        qnode2 = qml.QNode(circuit2, dev)\n\n        assert not np.allclose(qnode1(weights), qnode2(weights), atol=tol)\n\n    @pytest.mark.parametrize(""mutable"", [True, False])\n    def test_same_circuit_in_each_qnode_call(self, mutable, tol):\n        """"""Test that RandomLayers() creates the same circuit in two calls of a qnode.""""""\n        dev = qml.device(""default.qubit"", wires=2)\n        weights = [[0.1, 0.2, 0.3]]\n\n        @qml.qnode(dev, mutable=mutable)\n        def circuit(weights):\n            RandomLayers(weights=weights, wires=range(2))\n            return qml.expval(qml.PauliZ(0))\n\n        first_call = circuit(weights)\n        second_call = circuit(weights)\n        assert np.allclose(first_call, second_call, atol=tol)\n\n    def test_no_seed(self, tol):\n        """"""Test that two calls to a qnode with RandomLayers() for \'seed=None\' option create the\n        same circuit for immutable qnodes.""""""\n\n        dev = qml.device(""default.qubit"", wires=2)\n        weights = [[0.1] * 100]\n\n        @qml.qnode(dev, mutable=False)\n        def circuit(weights):\n            RandomLayers(weights=weights, wires=range(2), seed=None)\n            return qml.expval(qml.PauliZ(0))\n\n        first_call = circuit(weights)\n        second_call = circuit(weights)\n        assert np.allclose(first_call, second_call, atol=tol)\n\n    def test_random_layers_nlayers(self, n_layers):\n        """"""Test that RandomLayers() picks the correct number of gates.""""""\n        np.random.seed(12)\n        n_rots = 1\n        n_wires = 2\n        impr = CNOT\n        weights = np.random.randn(n_layers, n_rots)\n\n        with qml.utils.OperationRecorder() as rec:\n            RandomLayers(weights=weights, wires=range(n_wires))\n\n        types = [type(q) for q in rec.queue]\n        assert len(types) - types.count(impr) == n_layers\n\n    def test_random_layer_ratio_imprimitive(self, ratio):\n        """"""Test that  random_layer() has the right ratio of imprimitive gates.""""""\n        n_rots = 500\n        n_wires = 2\n        impr = CNOT\n        weights = np.random.randn(n_rots)\n\n        with qml.utils.OperationRecorder() as rec:\n            random_layer(\n                weights=weights,\n                wires=Wires(range(n_wires)),\n                ratio_imprim=ratio,\n                imprimitive=CNOT,\n                rotations=[RX, RY, RZ],\n                seed=42,\n            )\n\n        types = [type(q) for q in rec.queue]\n        ratio_impr = types.count(impr) / len(types)\n        assert np.isclose(ratio_impr, ratio, atol=0.05)\n\n    def test_random_layer_gate_types(self, n_subsystems, impr, rots):\n        """"""Test that  random_layer() uses the correct types of gates.""""""\n        n_rots = 20\n        weights = np.random.randn(n_rots)\n\n        with qml.utils.OperationRecorder() as rec:\n            random_layer(\n                weights=weights,\n                wires=Wires(range(n_subsystems)),\n                ratio_imprim=0.3,\n                imprimitive=impr,\n                rotations=rots,\n                seed=42,\n            )\n\n        types = [type(q) for q in rec.queue]\n        unique = set(types)\n        gates = {impr, *rots}\n        assert unique == gates\n\n    def test_random_layer_numgates(self, n_subsystems):\n        """"""Test that random_layer() uses the correct number of gates.""""""\n        n_rots = 5\n        weights = np.random.randn(n_rots)\n\n        with qml.utils.OperationRecorder() as rec:\n            random_layer(\n                weights=weights,\n                wires=Wires(range(n_subsystems)),\n                ratio_imprim=0.3,\n                imprimitive=qml.CNOT,\n                rotations=[RX, RY, RZ],\n                seed=42,\n            )\n\n        types = [type(q) for q in rec.queue]\n        assert len(types) - types.count(qml.CNOT) == n_rots\n\n    def test_random_layer_randomwires(self, n_subsystems):\n        """"""Test that  random_layer() picks random wires.""""""\n        n_rots = 500\n        weights = np.random.randn(n_rots)\n\n        with qml.utils.OperationRecorder() as rec:\n            random_layer(\n                weights=weights,\n                wires=Wires(range(n_subsystems)),\n                ratio_imprim=0.3,\n                imprimitive=qml.CNOT,\n                rotations=[RX, RY, RZ],\n                seed=42,\n            )\n\n        wires = [q._wires.tolist() for q in rec.queue]\n        wires_flat = [item for w in wires for item in w]\n        mean_wire = np.mean(wires_flat)\n        assert np.isclose(mean_wire, (n_subsystems - 1) / 2, atol=0.05)\n\n    def test_random_layer_weights(self, n_subsystems, tol):\n        """"""Test that random_layer() uses the correct weights.""""""\n        np.random.seed(12)\n        n_rots = 5\n        weights = np.random.randn(n_rots)\n\n        with qml.utils.OperationRecorder() as rec:\n            random_layer(\n                weights=weights,\n                wires=Wires(range(n_subsystems)),\n                ratio_imprim=0.3,\n                imprimitive=qml.CNOT,\n                rotations=[RX, RY, RZ],\n                seed=4,\n            )\n\n        params = [q.parameters for q in rec.queue]\n        params_flat = [item for p in params for item in p]\n        assert np.allclose(weights.flatten(), params_flat, atol=tol)\n\n\nclass TestSimplifiedTwoDesign:\n    """"""Tests for the SimplifiedTwoDesign method from the pennylane.templates.layers module.""""""\n\n    @pytest.mark.parametrize(\n        ""n_wires, n_layers, shape_weights"",\n        [(1, 2, (0,)), (2, 2, (2, 1, 2)), (3, 2, (2, 2, 2)), (4, 2, (2, 3, 2))],\n    )\n    def test_circuit_queue(self, n_wires, n_layers, shape_weights):\n        """"""Tests the gate types in the circuit.""""""\n        np.random.seed(42)\n        initial_layer = np.random.randn(n_wires)\n        weights = np.random.randn(*shape_weights)\n\n        with qml.utils.OperationRecorder() as rec:\n            SimplifiedTwoDesign(initial_layer, weights, wires=range(n_wires))\n\n        # Test that gates appear in the right order\n        exp_gates = [qml.CZ, qml.RY, qml.RY] * ((n_wires // 2) + (n_wires - 1) // 2)\n        exp_gates *= n_layers\n        exp_gates = [qml.RY] * n_wires + exp_gates\n\n        res_gates = rec.queue\n\n        for op1, op2 in zip(res_gates, exp_gates):\n            assert isinstance(op1, op2)\n\n    @pytest.mark.parametrize(\n        ""n_wires, n_layers, shape_weights"",\n        [(1, 2, (0,)), (2, 2, (2, 1, 2)), (3, 2, (2, 2, 2)), (4, 2, (2, 3, 2))],\n    )\n    def test_circuit_parameters(self, n_wires, n_layers, shape_weights):\n        """"""Tests the parameter values in the circuit.""""""\n        np.random.seed(42)\n        initial_layer = np.random.randn(n_wires)\n        weights = np.random.randn(*shape_weights)\n\n        with qml.utils.OperationRecorder() as rec:\n            SimplifiedTwoDesign(initial_layer, weights, wires=range(n_wires))\n\n        # test the device parameters\n        for l in range(n_layers):\n            # only select the rotation gates\n            ops = [gate for gate in rec.queue if isinstance(gate, qml.RY)]\n\n            # check each initial_layer gate parameters\n            for n in range(n_wires):\n                res_param = ops[n].parameters[0]\n                exp_param = initial_layer[n]\n                assert res_param == exp_param\n\n            # check layer gate parameters\n            ops = ops[n_wires:]\n            exp_params = weights.flatten()\n            for o, exp_param in zip(ops, exp_params):\n                res_param = o.parameters[0]\n                assert res_param == exp_param\n\n    @pytest.mark.parametrize(\n        ""initial_layer_weights, weights, n_wires, target"",\n        [\n            ([np.pi], [], 1, [-1]),\n            ([np.pi] * 2, [[[np.pi] * 2]], 2, [1, 1]),\n            ([np.pi] * 3, [[[np.pi] * 2] * 2], 3, [1, -1, 1]),\n            ([np.pi] * 4, [[[np.pi] * 2] * 3], 4, [1, -1, -1, 1]),\n        ],\n    )\n    def test_correct_target_output(self, initial_layer_weights, weights, n_wires, target):\n        """"""Tests the result of the template for simple cases.""""""\n        dev = qml.device(""default.qubit"", wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(initial_layer, weights):\n            SimplifiedTwoDesign(\n                initial_layer_weights=initial_layer, weights=weights, wires=range(n_wires)\n            )\n            return [qml.expval(qml.PauliZ(wires=i)) for i in range(n_wires)]\n\n        expectations = circuit(initial_layer_weights, weights)\n        for exp, target_exp in zip(expectations, target):\n            assert pytest.approx(exp, target_exp, abs=TOLERANCE)\n\n\nclass TestBasicEntangler:\n    """"""Tests for the BasicEntanglerLayers method from the pennylane.templates.layers module.""""""\n\n    @pytest.mark.parametrize(""n_wires, n_cnots"", [(1, 0), (2, 1), (3, 3), (4, 4)])\n    def test_circuit_queue(self, n_wires, n_cnots):\n        """"""Tests the gate types in the circuit.""""""\n        np.random.seed(42)\n        n_layers = 2\n\n        weights = np.random.randn(n_layers, n_wires)\n\n        with qml.utils.OperationRecorder() as rec:\n            BasicEntanglerLayers(weights, wires=range(n_wires))\n\n        # Test that gates appear in the right order\n        exp_gates = [qml.RX] * n_wires + [qml.CNOT] * n_cnots\n        exp_gates *= n_layers\n        res_gates = rec.queue\n\n        for op1, op2 in zip(res_gates, exp_gates):\n            assert isinstance(op1, op2)\n\n    @pytest.mark.parametrize(""n_wires, n_cnots"", [(1, 0), (2, 1), (3, 3), (4, 4)])\n    def test_circuit_parameters(self, n_wires, n_cnots):\n        """"""Tests the parameter values in the circuit.""""""\n        np.random.seed(42)\n        n_layers = 2\n\n        weights = np.random.randn(n_layers, n_wires)\n\n        with qml.utils.OperationRecorder() as rec:\n            BasicEntanglerLayers(weights, wires=range(n_wires))\n\n        # test the device parameters\n        for l in range(n_layers):\n            # only select the rotation gates\n            layer_ops = rec.queue[l * (n_wires + n_cnots) : l * (n_wires + n_cnots) + n_wires]\n\n            # check each rotation gate parameter\n            for n in range(n_wires):\n                res_param = layer_ops[n].parameters[0]\n                exp_param = weights[l, n]\n                assert res_param == exp_param\n\n    @pytest.mark.parametrize(""rotation"", [RX, RY, RZ])\n    def test_custom_rotation(self, rotation):\n        """"""Tests that non-default rotation gates are used correctly.""""""\n        n_layers = 2\n        n_wires = 4\n        weights = np.ones(shape=(n_layers, n_wires))\n\n        with qml.utils.OperationRecorder() as rec:\n            BasicEntanglerLayers(weights, wires=range(n_wires), rotation=rotation)\n\n        # assert queue contains the custom rotations and CNOTs only\n        gates = rec.queue\n        for op in gates:\n            if not isinstance(op, CNOT):\n                assert isinstance(op, rotation)\n\n    @pytest.mark.parametrize(\n        ""weights, n_wires, target"",\n        [\n            ([[np.pi]], 1, [-1]),\n            ([[np.pi] * 2], 2, [-1, 1]),\n            ([[np.pi] * 3], 3, [1, 1, -1]),\n            ([[np.pi] * 4], 4, [-1, 1, -1, 1]),\n        ],\n    )\n    def test_simple_target_outputs(self, weights, n_wires, target):\n        """"""Tests the result of the template for simple cases.""""""\n\n        dev = qml.device(""default.qubit"", wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(weights):\n            BasicEntanglerLayers(weights=weights, wires=range(n_wires), rotation=RX)\n            return [qml.expval(qml.PauliZ(wires=i)) for i in range(n_wires)]\n\n        expectations = circuit(weights)\n        for exp, target_exp in zip(expectations, target):\n            assert exp == target_exp\n'"
tests/templates/test_state_preparations.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.template.state_preparations` module.\nIntegration tests should be placed into ``test_templates.py``.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\n\nimport math\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nimport pennylane as qml\nfrom pennylane.templates.state_preparations import (BasisStatePreparation,\n                                                    MottonenStatePreparation,\n                                                    ArbitraryStatePreparation)\nfrom pennylane.templates.state_preparations.mottonen import gray_code\nfrom pennylane.templates.state_preparations.arbitrary_state_preparation import _state_preparation_pauli_words\nfrom pennylane.wires import Wires\n\n\nclass TestHelperFunctions:\n    """"""Tests the functionality of helper functions.""""""\n\n    # fmt: off\n    @pytest.mark.parametrize(""rank,expected_gray_code"", [\n        (1, [\'0\', \'1\']),\n        (2, [\'00\', \'01\', \'11\', \'10\']),\n        (3, [\'000\', \'001\', \'011\', \'010\', \'110\', \'111\', \'101\', \'100\']),\n    ])\n    # fmt: on\n    def test_gray_code(self, rank, expected_gray_code):\n        """"""Tests that the function gray_code generates the proper\n        Gray code of given rank.""""""\n\n        assert gray_code(rank) == expected_gray_code\n\n    @pytest.mark.parametrize(""num_wires,expected_pauli_words"", [\n        (1, [""X"", ""Y""]),\n        (2, [""XI"", ""YI"", ""IX"", ""IY"", ""XX"", ""XY""]),\n        (3, [""XII"", ""YII"", ""IXI"", ""IYI"", ""IIX"", ""IIY"", ""IXX"", ""IXY"", ""XXI"", ""XYI"", ""XIX"", ""XIY"", ""XXX"", ""XXY""]),\n    ])\n    def test_state_preparation_pauli_words(self, num_wires, expected_pauli_words):\n        """"""Test that the correct Pauli words are returned.""""""\n        for idx, pauli_word in enumerate(_state_preparation_pauli_words(num_wires)):\n            assert expected_pauli_words[idx] == pauli_word\n\n\nclass TestBasisStatePreparation:\n    """"""Tests the template BasisStatePreparation.""""""\n\n    # fmt: off\n    @pytest.mark.parametrize(""basis_state,wires,target_wires"", [\n        ([0], [0], []),\n        ([0], [1], []),\n        ([1], [0], [0]),\n        ([1], [1], [1]),\n        ([0, 1], [0, 1], [1]),\n        ([1, 0], [1, 4], [1]),\n        ([1, 1], [0, 2], [0, 2]),\n        ([1, 0], [4, 5], [4]),\n        ([0, 0, 1, 0], [1, 2, 3, 4], [3]),\n        ([1, 1, 1, 0], [1, 2, 6, 8], [1, 2, 6]),\n        ([1, 0, 1, 1], [1, 2, 6, 8], [1, 6, 8]),\n    ])\n    # fmt: on\n    def test_correct_pl_gates(self, basis_state, wires, target_wires):\n        """"""Tests that the template BasisStatePreparation calls the correct\n        PennyLane gates on the correct wires.""""""\n\n        with patch(""pennylane.PauliX"") as mock:\n            BasisStatePreparation(basis_state, wires)\n\n            called_wires = [args[0] for args, kwargs in mock.call_args_list]\n\n            assert len(target_wires) == len(called_wires)\n            assert Wires(called_wires) == Wires(target_wires)\n\n    # fmt: off\n    @pytest.mark.parametrize(""basis_state,wires,target_state"", [\n        ([0], [0], [0, 0, 0]),\n        ([0], [1], [0, 0, 0]),\n        ([1], [0], [1, 0, 0]),\n        ([1], [1], [0, 1, 0]),\n        ([0, 1], [0, 1], [0, 1, 0]),\n        ([1, 1], [0, 2], [1, 0, 1]),\n        ([1, 1], [1, 2], [0, 1, 1]),\n        ([1, 0], [0, 2], [1, 0, 0]),\n        ([1, 1, 0], [0, 1, 2], [1, 1, 0]),\n        ([1, 0, 1], [0, 1, 2], [1, 0, 1]),\n    ])\n    # fmt: on\n    def test_state_preparation(self, tol, qubit_device_3_wires, basis_state, wires, target_state):\n        """"""Tests that the template BasisStatePreparation integrates correctly with PennyLane.""""""\n\n        @qml.qnode(qubit_device_3_wires)\n        def circuit():\n            BasisStatePreparation(basis_state, wires)\n\n            # Pauli Z gates identify the basis state\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliZ(2))\n\n        # Convert from Pauli Z eigenvalues to basis state\n        output_state = [0 if x == 1.0 else 1 for x in circuit()]\n\n        assert np.allclose(output_state, target_state, atol=tol, rtol=0)\n\n    # fmt: off\n    @pytest.mark.parametrize(""basis_state,wires"", [\n        ([0], [0, 1]),\n        ([0, 1], [0]),\n    ])\n    # fmt: on\n    def test_error_num_qubits(self, basis_state, wires):\n        """"""Tests that the correct error message is raised when the number\n        of qubits doesn\'t match the number of wires.""""""\n\n        with pytest.raises(ValueError, match=""\'basis_state\' must be of shape""):\n            BasisStatePreparation(basis_state, wires)\n\n    # fmt: off\n    @pytest.mark.parametrize(""basis_state,wires"", [\n        ([3], [0]),\n        ([1, 0, 2], [0, 1, 2]),\n    ])\n    # fmt: on\n    def test_error_basis_state_format(self, basis_state, wires):\n        """"""Tests that the correct error messages is raised when\n        the basis state contains numbers different from 0 and 1.""""""\n\n        with pytest.raises(ValueError, match=""\'basis_state\' must only contain""):\n            BasisStatePreparation(basis_state, wires)\n\n\nclass TestMottonenStatePreparation:\n    """"""Tests the template MottonenStatePreparation.""""""\n\n    # fmt: off\n    @pytest.mark.parametrize(""state_vector,wires,target_state"", [\n        ([1, 0], [0], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([1, 0], [1], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([1, 0], [2], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([0, 1], [0], [0, 0, 0, 0, 1, 0, 0, 0]),\n        ([0, 1], [1], [0, 0, 1, 0, 0, 0, 0, 0]),\n        ([0, 1], [2], [0, 1, 0, 0, 0, 0, 0, 0]),\n        ([0, 1, 0, 0], [0, 1], [0, 0, 1, 0, 0, 0, 0, 0]),\n        ([0, 0, 0, 1], [0, 2], [0, 0, 0, 0, 0, 1, 0, 0]),\n        ([0, 0, 0, 1], [1, 2], [0, 0, 0, 1, 0, 0, 0, 0]),\n        ([1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([0, 0, 0, 0, 1j, 0, 0, 0], [0, 1, 2], [0, 0, 0, 0, 1j, 0, 0, 0]),\n        ([1/2, 0, 0, 0, 1/2, 1j/2, -1/2, 0], [0, 1, 2], [1/2, 0, 0, 0, 1/2, 1j/2, -1/2, 0]),\n        ([1/3, 0, 0, 0, 2j/3, 2j/3, 0, 0], [0, 1, 2], [1/3, 0, 0, 0, 2j/3, 2j/3, 0, 0]),\n        ([2/3, 0, 0, 0, 1/3, 0, 0, 2/3], [0, 1, 2], [2/3, 0, 0, 0, 1/3, 0, 0, 2/3]),\n        (\n            [1/math.sqrt(8), 1j/math.sqrt(8), 1/math.sqrt(8), -1j/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1j/math.sqrt(8)],\n            [0, 1, 2],\n            [1/math.sqrt(8), 1j/math.sqrt(8), 1/math.sqrt(8), -1j/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1j/math.sqrt(8)],\n        ),\n        (\n            [-0.17133152-0.18777771j, 0.00240643-0.40704011j, 0.18684538-0.36315606j, -0.07096948+0.104501j, 0.30357755-0.23831927j, -0.38735106+0.36075556j, 0.12351096-0.0539908j, 0.27942828-0.24810483j],\n            [0, 1, 2],\n            [-0.17133152-0.18777771j, 0.00240643-0.40704011j, 0.18684538-0.36315606j, -0.07096948+0.104501j, 0.30357755-0.23831927j, -0.38735106+0.36075556j, 0.12351096-0.0539908j, 0.27942828-0.24810483j],\n        ),\n        (\n            [-0.29972867+0.04964242j, -0.28309418+0.09873227j, 0.00785743-0.37560696j, -0.3825148 +0.00674343j, -0.03008048+0.31119167j, 0.03666351-0.15935903j, -0.25358831+0.35461265j, -0.32198531+0.33479292j],\n            [0, 1, 2],\n            [-0.29972867+0.04964242j, -0.28309418+0.09873227j, 0.00785743-0.37560696j, -0.3825148 +0.00674343j, -0.03008048+0.31119167j, 0.03666351-0.15935903j, -0.25358831+0.35461265j, -0.32198531+0.33479292j],\n        ),\n        (\n            [-0.39340123+0.05705932j, 0.1980509 -0.24234781j, 0.27265585-0.0604432j, -0.42641249+0.25767258j, 0.40386614-0.39925987j, 0.03924761+0.13193724j, -0.06059103-0.01753834j, 0.21707136-0.15887973j],\n            [0, 1, 2],\n            [-0.39340123+0.05705932j, 0.1980509 -0.24234781j, 0.27265585-0.0604432j, -0.42641249+0.25767258j, 0.40386614-0.39925987j, 0.03924761+0.13193724j, -0.06059103-0.01753834j, 0.21707136-0.15887973j],\n        ),\n        (\n            [-1.33865287e-01+0.09802308j, 1.25060033e-01+0.16087698j, -4.14678130e-01-0.00774832j, 1.10121136e-01+0.37805482j, -3.21284864e-01+0.21521063j, -2.23121454e-04+0.28417422j, 5.64131205e-02+0.38135286j, 2.32694503e-01+0.41331133j],\n            [0, 1, 2],\n            [-1.33865287e-01+0.09802308j, 1.25060033e-01+0.16087698j, -4.14678130e-01-0.00774832j, 1.10121136e-01+0.37805482j, -3.21284864e-01+0.21521063j, -2.23121454e-04+0.28417422j, 5.64131205e-02+0.38135286j, 2.32694503e-01+0.41331133j],\n        ),\n        ([1/2, 0, 0, 0, 1j/2, 0, 1j/math.sqrt(2), 0], [0, 1, 2], [1/2, 0, 0, 0, 1j/2, 0, 1j/math.sqrt(2), 0]),\n        ([1/2, 0, 1j/2, 1j/math.sqrt(2)], [0, 1], [1/2, 0, 0, 0, 1j/2, 0, 1j/math.sqrt(2), 0]),\n    ])\n    # fmt: on\n    def test_state_preparation_fidelity(self, tol, qubit_device_3_wires, state_vector, wires, target_state):\n        """"""Tests that the template MottonenStatePreparation integrates correctly with PennyLane\n        and produces states with correct fidelity.""""""\n\n        @qml.qnode(qubit_device_3_wires)\n        def circuit():\n            MottonenStatePreparation(state_vector, wires)\n\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliZ(2))\n\n        circuit()\n\n        state = qubit_device_3_wires._state.ravel()\n        fidelity = abs(np.vdot(state, target_state))**2\n\n        # We test for fidelity here, because the vector themselves will hardly match\n        # due to imperfect state preparation\n        assert np.isclose(fidelity, 1, atol=tol, rtol=0)\n\n    # fmt: off\n    @pytest.mark.parametrize(""state_vector,wires,target_state"", [\n        ([1, 0], [0], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([1, 0], [1], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([1, 0], [2], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([0, 1], [0], [0, 0, 0, 0, 1, 0, 0, 0]),\n        ([0, 1], [1], [0, 0, 1, 0, 0, 0, 0, 0]),\n        ([0, 1], [2], [0, 1, 0, 0, 0, 0, 0, 0]),\n        ([0, 1, 0, 0], [0, 1], [0, 0, 1, 0, 0, 0, 0, 0]),\n        ([0, 0, 0, 1], [0, 2], [0, 0, 0, 0, 0, 1, 0, 0]),\n        ([0, 0, 0, 1], [1, 2], [0, 0, 0, 1, 0, 0, 0, 0]),\n        ([1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2], [1, 0, 0, 0, 0, 0, 0, 0]),\n        ([0, 0, 0, 0, 1j, 0, 0, 0], [0, 1, 2], [0, 0, 0, 0, 1j, 0, 0, 0]),\n        ([1/2, 0, 0, 0, 1/2, 1j/2, -1/2, 0], [0, 1, 2], [1/2, 0, 0, 0, 1/2, 1j/2, -1/2, 0]),\n        ([1/3, 0, 0, 0, 2j/3, 2j/3, 0, 0], [0, 1, 2], [1/3, 0, 0, 0, 2j/3, 2j/3, 0, 0]),\n        ([2/3, 0, 0, 0, 1/3, 0, 0, 2/3], [0, 1, 2], [2/3, 0, 0, 0, 1/3, 0, 0, 2/3]),\n        (\n            [1/math.sqrt(8), 1j/math.sqrt(8), 1/math.sqrt(8), -1j/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1j/math.sqrt(8)],\n            [0, 1, 2],\n            [1/math.sqrt(8), 1j/math.sqrt(8), 1/math.sqrt(8), -1j/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1/math.sqrt(8), 1j/math.sqrt(8)],\n        ),\n        (\n            [-0.17133152-0.18777771j, 0.00240643-0.40704011j, 0.18684538-0.36315606j, -0.07096948+0.104501j, 0.30357755-0.23831927j, -0.38735106+0.36075556j, 0.12351096-0.0539908j, 0.27942828-0.24810483j],\n            [0, 1, 2],\n            [-0.17133152-0.18777771j, 0.00240643-0.40704011j, 0.18684538-0.36315606j, -0.07096948+0.104501j, 0.30357755-0.23831927j, -0.38735106+0.36075556j, 0.12351096-0.0539908j, 0.27942828-0.24810483j],\n        ),\n        (\n            [-0.29972867+0.04964242j, -0.28309418+0.09873227j, 0.00785743-0.37560696j, -0.3825148 +0.00674343j, -0.03008048+0.31119167j, 0.03666351-0.15935903j, -0.25358831+0.35461265j, -0.32198531+0.33479292j],\n            [0, 1, 2],\n            [-0.29972867+0.04964242j, -0.28309418+0.09873227j, 0.00785743-0.37560696j, -0.3825148 +0.00674343j, -0.03008048+0.31119167j, 0.03666351-0.15935903j, -0.25358831+0.35461265j, -0.32198531+0.33479292j],\n        ),\n        (\n            [-0.39340123+0.05705932j, 0.1980509 -0.24234781j, 0.27265585-0.0604432j, -0.42641249+0.25767258j, 0.40386614-0.39925987j, 0.03924761+0.13193724j, -0.06059103-0.01753834j, 0.21707136-0.15887973j],\n            [0, 1, 2],\n            [-0.39340123+0.05705932j, 0.1980509 -0.24234781j, 0.27265585-0.0604432j, -0.42641249+0.25767258j, 0.40386614-0.39925987j, 0.03924761+0.13193724j, -0.06059103-0.01753834j, 0.21707136-0.15887973j],\n        ),\n        (\n            [-1.33865287e-01+0.09802308j, 1.25060033e-01+0.16087698j, -4.14678130e-01-0.00774832j, 1.10121136e-01+0.37805482j, -3.21284864e-01+0.21521063j, -2.23121454e-04+0.28417422j, 5.64131205e-02+0.38135286j, 2.32694503e-01+0.41331133j],\n            [0, 1, 2],\n            [-1.33865287e-01+0.09802308j, 1.25060033e-01+0.16087698j, -4.14678130e-01-0.00774832j, 1.10121136e-01+0.37805482j, -3.21284864e-01+0.21521063j, -2.23121454e-04+0.28417422j, 5.64131205e-02+0.38135286j, 2.32694503e-01+0.41331133j],\n        ),\n        ([1/2, 0, 0, 0, 1j/2, 0, 1j/math.sqrt(2), 0], [0, 1, 2], [1/2, 0, 0, 0, 1j/2, 0, 1j/math.sqrt(2), 0]),\n        ([1/2, 0, 1j/2, 1j/math.sqrt(2)], [0, 1], [1/2, 0, 0, 0, 1j/2, 0, 1j/math.sqrt(2), 0]),\n    ])\n    # fmt: on\n    def test_state_preparation_probability_distribution(self, tol, qubit_device_3_wires, state_vector, wires, target_state):\n        """"""Tests that the template MottonenStatePreparation integrates correctly with PennyLane\n        and produces states with correct probability distribution.""""""\n\n        @qml.qnode(qubit_device_3_wires)\n        def circuit():\n            MottonenStatePreparation(state_vector, wires)\n\n            return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)), qml.expval(qml.PauliZ(2))\n\n        circuit()\n\n        state = qubit_device_3_wires._state.ravel()\n\n        probabilities = np.abs(state)**2\n        target_probabilities = np.abs(target_state)**2\n\n        assert np.allclose(probabilities, target_probabilities, atol=tol, rtol=0)\n\n    # fmt: off\n    @pytest.mark.parametrize(""state_vector, wires"", [\n        ([1/2, 1/2], [0]),\n        ([2/3, 0, 2j/3, -2/3], [0, 1]),\n    ])\n    # fmt: on\n    def test_error_state_vector_not_normalized(self, state_vector, wires):\n        """"""Tests that the correct error messages is raised if\n        the given state vector is not normalized.""""""\n\n        with pytest.raises(ValueError, match=""\'state_vector\' has to be of length""):\n            MottonenStatePreparation(state_vector, wires)\n\n    # fmt: off\n    @pytest.mark.parametrize(""state_vector,wires"", [\n        ([0, 1, 0], [0, 1]),\n        ([0, 1, 0, 0, 0], [0]),\n    ])\n    # fmt: on\n    def test_error_num_entries(self, state_vector, wires):\n        """"""Tests that the correct error messages is raised  if\n        the number of entries in the given state vector does not match\n        with the number of wires in the system.""""""\n\n        with pytest.raises(ValueError, match=""\'state_vector\' must be of shape""):\n            MottonenStatePreparation(state_vector, wires)\n\n\nclass TestArbitraryStatePreparation:\n    """"""Test the ArbitraryStatePreparation template.""""""\n\n    def test_correct_gates_single_wire(self):\n        """"""Test that the correct gates are applied on a single wire.""""""\n        weights = np.array([0, 1], dtype=float)\n\n        with qml.utils.OperationRecorder() as rec:\n            ArbitraryStatePreparation(weights, wires=[0])\n\n        assert rec.queue[0].name == ""PauliRot""\n        assert rec.queue[0].params[0] == weights[0]\n        assert rec.queue[0].params[1] == ""X""\n        assert rec.queue[0].wires == Wires([0])\n\n        assert rec.queue[1].name == ""PauliRot""\n        assert rec.queue[1].params[0] == weights[1]\n        assert rec.queue[1].params[1] == ""Y""\n        assert rec.queue[1].wires == Wires([0])\n\n    def test_correct_gates_two_wires(self):\n        """"""Test that the correct gates are applied on on two wires.""""""\n        weights = np.array([0, 1, 2, 3, 4, 5], dtype=float)\n\n        with qml.utils.OperationRecorder() as rec:\n            ArbitraryStatePreparation(weights, wires=[0, 1])\n\n        assert rec.queue[0].name == ""PauliRot""\n        assert rec.queue[0].params[0] == weights[0]\n        assert rec.queue[0].params[1] == ""XI""\n        assert rec.queue[0].wires == Wires([0, 1])\n\n        assert rec.queue[1].name == ""PauliRot""\n        assert rec.queue[1].params[0] == weights[1]\n        assert rec.queue[1].params[1] == ""YI""\n        assert rec.queue[1].wires == Wires([0, 1])\n\n        assert rec.queue[2].name == ""PauliRot""\n        assert rec.queue[2].params[0] == weights[2]\n        assert rec.queue[2].params[1] == ""IX""\n        assert rec.queue[2].wires == Wires([0, 1])\n\n        assert rec.queue[3].name == ""PauliRot""\n        assert rec.queue[3].params[0] == weights[3]\n        assert rec.queue[3].params[1] == ""IY""\n        assert rec.queue[3].wires == Wires([0, 1])\n\n        assert rec.queue[4].name == ""PauliRot""\n        assert rec.queue[4].params[0] == weights[4]\n        assert rec.queue[4].params[1] == ""XX""\n        assert rec.queue[4].wires == Wires([0, 1])\n\n        assert rec.queue[5].name == ""PauliRot""\n        assert rec.queue[5].params[0] == weights[5]\n        assert rec.queue[5].params[1] == ""XY""\n        assert rec.queue[5].wires == Wires([0, 1])\n\n    def test_GHZ_generation(self, qubit_device_3_wires, tol):\n        """"""Test that the template prepares a GHZ state.""""""\n        GHZ_state = np.array([1/math.sqrt(2), 0, 0, 0, 0, 0, 0, 1/math.sqrt(2)])\n\n        weights = np.zeros(14)\n        weights[13] = math.pi / 2\n\n        @qml.qnode(qubit_device_3_wires)\n        def circuit(weights):\n            ArbitraryStatePreparation(weights, [0, 1, 2])\n\n            return qml.expval(qml.PauliZ(0))\n\n        circuit(weights)\n\n        assert np.allclose(qubit_device_3_wires.state, GHZ_state, atol=tol, rtol=0)\n\n    def test_even_superposition_generation(self, qubit_device_3_wires, tol):\n        """"""Test that the template prepares a even superposition state.""""""\n        even_superposition_state = np.ones(8)/math.sqrt(8)\n\n        weights = np.zeros(14)\n        weights[1] = math.pi / 2\n        weights[3] = math.pi / 2\n        weights[5] = math.pi / 2\n\n        @qml.qnode(qubit_device_3_wires)\n        def circuit(weights):\n            ArbitraryStatePreparation(weights, [0, 1, 2])\n\n            return qml.expval(qml.PauliZ(0))\n\n        circuit(weights)\n\n        assert np.allclose(qubit_device_3_wires.state, even_superposition_state, atol=tol, rtol=0)\n'"
tests/templates/test_subroutines.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nUnit tests for the :mod:`pennylane.template.subroutines` module.\nIntegration tests should be placed into ``test_templates.py``.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport pytest\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom pennylane.wires import Wires\n\nfrom pennylane.templates.subroutines import (\n    Interferometer, \n    ArbitraryUnitary,\n    SingleExcitationUnitary,\n    DoubleExcitationUnitary,\n    UCCSD\n)\n\nfrom pennylane.templates.subroutines.arbitrary_unitary import (\n    _all_pauli_words_but_identity,\n    _tuple_to_word,\n    _n_k_gray_code,\n)\n\n# fmt: off\nPAULI_WORD_TEST_DATA = [\n    (1, [""X"", ""Y"", ""Z""]),\n    (\n        2,\n        [""XI"", ""YI"", ""ZI"", ""ZX"", ""IX"", ""XX"", ""YX"", ""YY"", ""ZY"", ""IY"", ""XY"", ""XZ"", ""YZ"", ""ZZ"", ""IZ""],\n    ),\n    (\n        3,\n        [\n            ""XII"", ""YII"", ""ZII"", ""ZXI"", ""IXI"", ""XXI"", ""YXI"", ""YYI"", ""ZYI"", ""IYI"", ""XYI"", ""XZI"", ""YZI"",\n            ""ZZI"", ""IZI"", ""IZX"", ""XZX"", ""YZX"", ""ZZX"", ""ZIX"", ""IIX"", ""XIX"", ""YIX"", ""YXX"", ""ZXX"", ""IXX"",\n            ""XXX"", ""XYX"", ""YYX"", ""ZYX"", ""IYX"", ""IYY"", ""XYY"", ""YYY"", ""ZYY"", ""ZZY"", ""IZY"", ""XZY"", ""YZY"",\n            ""YIY"", ""ZIY"", ""IIY"", ""XIY"", ""XXY"", ""YXY"", ""ZXY"", ""IXY"", ""IXZ"", ""XXZ"", ""YXZ"", ""ZXZ"", ""ZYZ"",\n            ""IYZ"", ""XYZ"", ""YYZ"", ""YZZ"", ""ZZZ"", ""IZZ"", ""XZZ"", ""XIZ"", ""YIZ"", ""ZIZ"", ""IIZ"",\n        ]\n    ),\n]\n\nGRAY_CODE_TEST_DATA = [\n    (2, 2, [[0, 0], [1, 0], [1, 1], [0, 1]]),\n    (2, 3, [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 0, 1], [0, 0, 1]]),\n    (4, 2, [\n        [0, 0], [1, 0], [2, 0], [3, 0], [3, 1], [0, 1], [1, 1], [2, 1], \n        [2, 2], [3, 2], [0, 2], [1, 2], [1, 3], [2, 3], [3, 3], [0, 3]\n    ]),\n    (3, 3, [\n        [0, 0, 0], [1, 0, 0], [2, 0, 0], [2, 1, 0], [0, 1, 0], [1, 1, 0], [1, 2, 0], [2, 2, 0], [0, 2, 0], \n        [0, 2, 1], [1, 2, 1], [2, 2, 1], [2, 0, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1], [2, 1, 1], [0, 1, 1], \n        [0, 1, 2], [1, 1, 2], [2, 1, 2], [2, 2, 2], [0, 2, 2], [1, 2, 2], [1, 0, 2], [2, 0, 2], [0, 0, 2]\n    ]),\n]\n# fmt: on\n\n\nclass TestHelperFunctions:\n    """"""Test the helper functions used in the layers.""""""\n\n    @pytest.mark.parametrize(""n,k,expected_code"", GRAY_CODE_TEST_DATA)\n    def test_n_k_gray_code(self, n, k, expected_code):\n        """"""Test that _n_k_gray_code produces the Gray code correctly.""""""\n        for expected_word, word in zip(expected_code, _n_k_gray_code(n, k)):\n            assert expected_word == word\n\n    @pytest.mark.parametrize(""num_wires,expected_pauli_words"", PAULI_WORD_TEST_DATA)\n    def test_all_pauli_words_but_identity(self, num_wires, expected_pauli_words):\n        """"""Test that the correct Pauli words are returned.""""""\n        for expected_pauli_word, pauli_word in zip(expected_pauli_words, _all_pauli_words_but_identity(num_wires)):\n            assert expected_pauli_word == pauli_word\n\n    @pytest.mark.parametrize(""tuple,expected_word"", [\n        ((0,), ""I""),\n        ((1,), ""X""),\n        ((2,), ""Y""),\n        ((3,), ""Z""),\n        ((0, 0, 0), ""III""),\n        ((1, 2, 3), ""XYZ""),\n        ((1, 2, 3, 0, 0, 3, 2, 1), ""XYZIIZYX""),\n    ])\n    def test_tuple_to_word(self, tuple, expected_word):\n        assert _tuple_to_word(tuple) == expected_word\n\nclass TestInterferometer:\n    """"""Tests for the Interferometer from the pennylane.template.layers module.""""""\n\n    def test_invalid_mesh_exception(self):\n        """"""Test that Interferometer() raises correct exception when mesh not recognized.""""""\n        dev = qml.device(\'default.gaussian\', wires=1)\n        varphi = [0.42342]\n\n        @qml.qnode(dev)\n        def circuit(varphi, mesh=None):\n            Interferometer(theta=[], phi=[], varphi=varphi, mesh=mesh, wires=0)\n            return qml.expval(qml.NumberOperator(0))\n\n        with pytest.raises(ValueError, match=""Mesh option""):\n            circuit(varphi, mesh=\'a\')\n\n    def test_invalid_mesh_exception(self):\n        """"""Test that Interferometer() raises correct exception when beamsplitter not recognized.""""""\n        dev = qml.device(\'default.gaussian\', wires=1)\n        varphi = [0.42342]\n\n        @qml.qnode(dev)\n        def circuit(varphi, bs=None):\n            Interferometer(theta=[], phi=[], varphi=varphi, beamsplitter=bs, wires=0)\n            return qml.expval(qml.NumberOperator(0))\n\n        with pytest.raises(ValueError, match=""did not recognize option""):\n            circuit(varphi, bs=\'a\')\n\n    def test_clements_beamsplitter_convention(self, tol):\n        """"""test the beamsplitter convention""""""\n        N = 2\n        wires = range(N)\n\n        theta = [0.321]\n        phi = [0.234]\n        varphi = [0.42342, 0.1121]\n\n        with qml.utils.OperationRecorder() as rec_rect:\n            Interferometer(theta, phi, varphi, mesh=\'rectangular\', beamsplitter=\'clements\', wires=wires)\n\n        with qml.utils.OperationRecorder() as rec_tria:\n            Interferometer(theta, phi, varphi, mesh=\'triangular\', beamsplitter=\'clements\', wires=wires)\n\n        for rec in [rec_rect, rec_tria]:\n\n            assert len(rec.queue) == 4\n\n            assert isinstance(rec.queue[0], qml.Rotation)\n            assert rec.queue[0].parameters == phi\n\n            assert isinstance(rec.queue[1], qml.Beamsplitter)\n            assert rec.queue[1].parameters == [theta[0], 0]\n\n            assert isinstance(rec.queue[2], qml.Rotation)\n            assert rec.queue[2].parameters == [varphi[0]]\n\n            assert isinstance(rec.queue[3], qml.Rotation)\n            assert rec.queue[3].parameters == [varphi[1]]\n\n    def test_one_mode(self, tol):\n        """"""Test that a one mode interferometer correctly gives a rotation gate""""""\n        varphi = [0.42342]\n\n        with qml.utils.OperationRecorder() as rec:\n            Interferometer(theta=[], phi=[], varphi=varphi, wires=0)\n\n        assert len(rec.queue) == 1\n        assert isinstance(rec.queue[0], qml.Rotation)\n        assert np.allclose(rec.queue[0].parameters, varphi, atol=tol)\n\n    def test_two_mode_rect(self, tol):\n        """"""Test that a two mode interferometer using the rectangular mesh\n        correctly gives a beamsplitter+rotation gate""""""\n        N = 2\n        wires = range(N)\n\n        theta = [0.321]\n        phi = [0.234]\n        varphi = [0.42342, 0.1121]\n\n        with qml.utils.OperationRecorder() as rec:\n            Interferometer(theta, phi, varphi, wires=wires)\n\n        isinstance(rec.queue[0], qml.Beamsplitter)\n        assert rec.queue[0].parameters == theta+phi\n\n        assert isinstance(rec.queue[1], qml.Rotation)\n        assert rec.queue[1].parameters == [varphi[0]]\n\n        assert isinstance(rec.queue[2], qml.Rotation)\n        assert rec.queue[2].parameters == [varphi[1]]\n\n    def test_two_mode_triangular(self, tol):\n        """"""Test that a two mode interferometer using the triangular mesh\n        correctly gives a beamsplitter+rotation gate""""""\n        N = 2\n        wires = range(N)\n\n        theta = [0.321]\n        phi = [0.234]\n        varphi = [0.42342, 0.1121]\n\n        with qml.utils.OperationRecorder() as rec:\n            Interferometer(theta, phi, varphi, mesh=\'triangular\', wires=wires)\n\n        assert len(rec.queue) == 3\n\n        assert isinstance(rec.queue[0], qml.Beamsplitter)\n        assert rec.queue[0].parameters == theta+phi\n\n        assert isinstance(rec.queue[1], qml.Rotation)\n        assert rec.queue[1].parameters == [varphi[0]]\n\n        assert isinstance(rec.queue[2], qml.Rotation)\n        assert rec.queue[2].parameters == [varphi[1]]\n\n    def test_three_mode(self, tol):\n        """"""Test that a three mode interferometer using either mesh gives the correct gates""""""\n        N = 3\n        wires = range(N)\n\n        theta = [0.321, 0.4523, 0.21321]\n        phi = [0.234, 0.324, 0.234]\n        varphi = [0.42342, 0.234, 0.1121]\n\n        with qml.utils.OperationRecorder() as rec_rect:\n            Interferometer(theta, phi, varphi, wires=wires)\n\n        with qml.utils.OperationRecorder() as rec_tria:\n            Interferometer(theta, phi, varphi, wires=wires)\n\n        for rec in [rec_rect, rec_tria]:\n            # test both meshes (both give identical results for the 3 mode case).\n            assert len(rec.queue) == 6\n\n            expected_bs_wires = [[0, 1], [1, 2], [0, 1]]\n\n            for idx, op in enumerate(rec_rect.queue[:3]):\n                assert isinstance(op, qml.Beamsplitter)\n                assert op.parameters == [theta[idx], phi[idx]]\n                assert op.wires == Wires(expected_bs_wires[idx])\n\n            for idx, op in enumerate(rec.queue[3:]):\n                assert isinstance(op, qml.Rotation)\n                assert op.parameters == [varphi[idx]]\n                assert op.wires == Wires([idx])\n\n    def test_four_mode_rect(self, tol):\n        """"""Test that a 4 mode interferometer using rectangular mesh gives the correct gates""""""\n        N = 4\n        wires = range(N)\n\n        theta = [0.321, 0.4523, 0.21321, 0.123, 0.5234, 1.23]\n        phi = [0.234, 0.324, 0.234, 1.453, 1.42341, -0.534]\n        varphi = [0.42342, 0.234, 0.4523, 0.1121]\n\n        with qml.utils.OperationRecorder() as rec:\n            Interferometer(theta, phi, varphi, wires=wires)\n\n        assert len(rec.queue) == 10\n\n        expected_bs_wires = [[0, 1], [2, 3], [1, 2], [0, 1], [2, 3], [1, 2]]\n\n        for idx, op in enumerate(rec.queue[:6]):\n            assert isinstance(op, qml.Beamsplitter)\n            assert op.parameters == [theta[idx], phi[idx]]\n            assert op.wires == Wires(expected_bs_wires[idx])\n\n        for idx, op in enumerate(rec.queue[6:]):\n            assert isinstance(op, qml.Rotation)\n            assert op.parameters == [varphi[idx]]\n            assert op.wires == Wires([idx])\n\n    def test_four_mode_triangular(self, tol):\n        """"""Test that a 4 mode interferometer using triangular mesh gives the correct gates""""""\n        N = 4\n        wires = range(N)\n\n        theta = [0.321, 0.4523, 0.21321, 0.123, 0.5234, 1.23]\n        phi = [0.234, 0.324, 0.234, 1.453, 1.42341, -0.534]\n        varphi = [0.42342, 0.234, 0.4523, 0.1121]\n\n        with qml.utils.OperationRecorder() as rec:\n            Interferometer(theta, phi, varphi, mesh=\'triangular\', wires=wires)\n\n        assert len(rec.queue) == 10\n\n        expected_bs_wires = [[2, 3], [1, 2], [0, 1], [2, 3], [1, 2], [2, 3]]\n\n        for idx, op in enumerate(rec.queue[:6]):\n            assert isinstance(op, qml.Beamsplitter)\n            assert op.parameters == [theta[idx], phi[idx]]\n            assert op.wires == Wires(expected_bs_wires[idx])\n\n        for idx, op in enumerate(rec.queue[6:]):\n            assert isinstance(op, qml.Rotation)\n            assert op.parameters == [varphi[idx]]\n            assert op.wires == Wires([idx])\n\n    def test_integration(self, tol):\n        """"""test integration with PennyLane and gradient calculations""""""\n        N = 4\n        wires = range(N)\n        dev = qml.device(\'default.gaussian\', wires=N)\n\n        sq = np.array([[0.8734294, 0.96854066],\n                       [0.86919454, 0.53085569],\n                       [0.23272833, 0.0113988 ],\n                       [0.43046882, 0.40235136]])\n\n        theta = np.array([3.28406182, 3.0058243, 3.48940764, 3.41419504, 4.7808479, 4.47598146])\n        phi = np.array([3.89357744, 2.67721355, 1.81631197, 6.11891294, 2.09716418, 1.37476761])\n        varphi = np.array([0.4134863, 6.17555778, 0.80334114, 2.02400747])\n\n        @qml.qnode(dev)\n        def circuit(theta, phi, varphi):\n            for w in wires:\n                qml.Squeezing(sq[w][0], sq[w][1], wires=w)\n\n            Interferometer(theta=theta, phi=phi, varphi=varphi, wires=wires)\n            return [qml.expval(qml.NumberOperator(w)) for w in wires]\n\n        res = circuit(theta, phi, varphi)\n        expected = np.array([0.96852694, 0.23878521, 0.82310606, 0.16547786])\n        assert np.allclose(res, expected, atol=tol)\n\n        # compare the two methods of computing the Jacobian\n        jac_A = circuit.jacobian((theta, phi, varphi), method=""A"")\n        jac_F = circuit.jacobian((theta, phi, varphi), method=""F"")\n        assert jac_A == pytest.approx(jac_F, abs=tol)\n\n\nclass TestSingleExcitationUnitary:\n    """"""Tests for the SingleExcitationUnitary template from the pennylane.templates.subroutine module.""""""\n\n    @pytest.mark.parametrize(\n        (""ph"", ""ref_gates""),\n        [\n        ([0,2],   [[0 , qml.RX      , [0]  , [-np.pi/2]] , [1 , qml.Hadamard, [2], []],\n                   [7 , qml.RX      , [0]  , [ np.pi/2]] , [8 , qml.Hadamard, [2], []],\n                   [9 , qml.Hadamard, [0]  , []]         , [10, qml.RX      , [2], [-np.pi/2]],\n                   [16, qml.Hadamard, [0]  , []]         , [17, qml.RX      , [2], [ np.pi/2]],\n                   [4 , qml.RZ      , [2]  , [np.pi/6]]  , [13, qml.RZ      , [2], [-np.pi/6]]]\n                   ),\n\n        ([10,11], [[0 , qml.RX      , [10]  , [-np.pi/2]] , [1 , qml.Hadamard, [11], []],\n                   [12, qml.Hadamard, [10]  , []]         , [13, qml.RX      , [11], [ np.pi/2]],\n                   [3 , qml.RZ      , [11], [np.pi/6]]    , [10, qml.RZ      , [11], [-np.pi/6]]]\n                   ),        \n\n        ([1,4],   [[2 , qml.CNOT, [1,2], []], [3 , qml.CNOT, [2,3], []], [4 , qml.CNOT, [3,4], []],\n                   [6 , qml.CNOT, [3,4], []], [7 , qml.CNOT, [2,3], []], [8 , qml.CNOT, [1,2], []],\n                   [13, qml.CNOT, [1,2], []], [14, qml.CNOT, [2,3], []], [15, qml.CNOT, [3,4], []],\n                   [17, qml.CNOT, [3,4], []], [18, qml.CNOT, [2,3], []], [19, qml.CNOT, [1,2], []]]\n                   ),\n\n        ([10,11], [[2 , qml.CNOT, [10,11] , []], [4  , qml.CNOT, [10,11], []],\n                   [9 , qml.CNOT, [10,11] , []], [11 , qml.CNOT, [10,11], []]]\n                   )        \n        ]\n    )\n    def test_single_ex_unitary_operations(self, ph, ref_gates):\n        """"""Test the correctness of the SingleExcitationUnitary template including the gate count\n        and order, the wires each operation acts on and the correct use of parameters \n        in the circuit.""""""\n\n        sqg = 10\n        cnots = 4*(ph[1]-ph[0])\n        weight = np.pi/3\n        with qml.utils.OperationRecorder() as rec:\n            SingleExcitationUnitary(weight, wires=ph)\n\n        assert len(rec.queue) == sqg + cnots            \n\n        for gate in ref_gates:\n            idx = gate[0]\n\n            exp_gate = gate[1]\n            res_gate = rec.queue[idx]\n            assert isinstance(res_gate, exp_gate)\n\n            exp_wires = gate[2]\n            res_wires = rec.queue[idx]._wires\n            assert res_wires == Wires(exp_wires)\n\n            exp_weight = gate[3]\n            res_weight = rec.queue[idx].parameters\n            assert res_weight == exp_weight\n\n    @pytest.mark.parametrize(\n        (""weight"", ""ph"", ""msg_match""),\n        [\n            ( 0.2      , [0]         , ""expected 2 wires""),\n            ( 0.2      , []          , ""expected 2 wires""),\n            ([0.2, 1.1], [0,2]       , ""\'weight\' must be of shape""),\n            ( 0.2      , [3, 1]      , ""wires_1 must be greater than wires_0"")\n        ]\n    )\n    def test_single_excitation_unitary_exceptions(self, weight, ph, msg_match):\n        """"""Test that SingleExcitationUnitary throws an exception if ``weight`` or \n        ``ph`` parameter has illegal shapes, types or values.""""""\n        dev = qml.device(""default.qubit"", wires=5)\n\n        def circuit(weight=weight, wires=ph):\n            SingleExcitationUnitary(weight=weight, wires=ph)\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = qml.QNode(circuit, dev)\n\n        with pytest.raises(ValueError, match=msg_match):\n            qnode(weight=weight, wires=ph)\n\n    @pytest.mark.parametrize(\n        (""weight"", ""ph"", ""expected""),\n        [\n            ( 2.21375586 , [0, 2], [-0.59956665, 1.        , 0.59956665, -1.]),\n            ( -5.93892805, [1, 3], [ 1.        , 0.94132639, -1.       , -0.94132639])\n        ]\n    )\n    def test_integration(self, weight, ph, expected, tol):\n        """"""Test integration with PennyLane and gradient calculations""""""\n\n        N = 4\n        wires = range(N)\n        dev = qml.device(\'default.qubit\', wires=N)\n\n        @qml.qnode(dev)\n        def circuit(weight):\n            init_state = np.flip(np.array([1,1,0,0]))\n            qml.BasisState(init_state, wires=wires)\n            SingleExcitationUnitary(weight, wires=ph)\n\n        return [qml.expval(qml.PauliZ(w)) for w in range(N)]\n\n        res = circuit(weight)\n        assert np.allclose(res, np.array(expected), atol=tol)\n\n        # compare the two methods of computing the Jacobian\n        jac_A = circuit.jacobian((weight), method=""A"")\n        jac_F = circuit.jacobian((weight), method=""F"")\n        assert jac_A == pytest.approx(jac_F, abs=tol)\n\n\nclass TestArbitraryUnitary:\n    """"""Test the ArbitraryUnitary template.""""""\n\n    def test_correct_gates_single_wire(self):\n        """"""Test that the correct gates are applied on a single wire.""""""\n        weights = np.arange(3, dtype=float)\n\n        with qml.utils.OperationRecorder() as rec:\n            ArbitraryUnitary(weights, wires=[0])\n\n        assert all(op.name == ""PauliRot"" and op.wires == Wires([0]) for op in rec.queue)\n\n        pauli_words = [""X"", ""Y"", ""Z""]\n\n        for i, op in enumerate(rec.queue):\n            assert op.params[0] == weights[i]\n            assert op.params[1] == pauli_words[i]\n\n    def test_correct_gates_two_wires(self):\n        """"""Test that the correct gates are applied on two wires.""""""\n        weights = np.arange(15, dtype=float)\n\n        with qml.utils.OperationRecorder() as rec:\n            ArbitraryUnitary(weights, wires=[0, 1])\n\n        assert all(op.name == ""PauliRot"" and op.wires == Wires([0, 1]) for op in rec.queue)\n\n        pauli_words = [""XI"", ""YI"", ""ZI"", ""ZX"", ""IX"", ""XX"", ""YX"", ""YY"", ""ZY"", ""IY"", ""XY"", ""XZ"", ""YZ"", ""ZZ"", ""IZ""]\n\n        for i, op in enumerate(rec.queue):\n            assert op.params[0] == weights[i]\n            assert op.params[1] == pauli_words[i]\n\n\nclass TestDoubleExcitationUnitary:\n    """"""Tests for the DoubleExcitationUnitary template from the pennylane.templates.subroutine module.""""""\n\n    @pytest.mark.parametrize(\n        (""pphh"", ""ref_gates""),\n        [\n        ([0,2,4,6],   [[0,  qml.Hadamard, [0], []]        , [1, qml.Hadamard, [2], []],\n                       [2,  qml.RX,       [4], [-np.pi/2]], [3, qml.Hadamard, [6], []],\n                       [9,  qml.RZ, [6], [np.pi/24]]      ,\n                       [15, qml.Hadamard, [0], []]        , [16, qml.Hadamard, [2], []],\n                       [17, qml.RX,       [4], [np.pi/2]] , [18, qml.Hadamard, [6], []]]\n                   ),\n        ([0,1,4,5],   [[15, qml.RX, [0], [-np.pi/2]], [16, qml.Hadamard, [1], []],\n                       [17, qml.RX, [4], [-np.pi/2]], [18, qml.RX,       [5], [-np.pi/2]],\n                       [22, qml.RZ, [5], [np.pi/24]],\n                       [26, qml.RX, [0], [np.pi/2]] , [27, qml.Hadamard, [1], []],\n                       [28, qml.RX, [4], [np.pi/2]] , [29, qml.RX,       [5], [np.pi/2]]]\n                   ),\n        ([1,3,7,11],  [[46, qml.Hadamard, [1], []]         , [47, qml.RX, [3],  [-np.pi/2]],\n                       [48, qml.RX      , [7], [-np.pi/2]] , [49, qml.RX, [11], [-np.pi/2]],\n                       [57, qml.RZ, [11], [np.pi/24]]      ,\n                       [65, qml.Hadamard, [1], []]         , [66, qml.RX, [3] , [np.pi/2]],\n                       [67, qml.RX      , [7], [np.pi/2]]  , [68, qml.RX, [11], [np.pi/2]]]\n                   ),\n        ([2,4,8,10],  [[57, qml.Hadamard, [2], []], [58, qml.Hadamard, [4] , []],\n                       [59, qml.Hadamard, [8], []], [60, qml.RX,       [10], [-np.pi/2]],\n                       [66, qml.RZ, [10], [np.pi/24]]  ,\n                       [72, qml.Hadamard, [2], []], [73, qml.Hadamard, [4], []],\n                       [74, qml.Hadamard, [8], []], [75, qml.RX,      [10], [np.pi/2]]]\n                   ),\n        ([3,5,11,15], [[92,  qml.RX,       [3],  [-np.pi/2]], [93, qml.Hadamard, [5] , []],\n                       [94,  qml.Hadamard, [11], []]        , [95, qml.Hadamard, [15], []],\n                       [103, qml.RZ, [15], [-np.pi/24]]     ,\n                       [111, qml.RX,       [3],  [np.pi/2]] , [112, qml.Hadamard, [5] , []],\n                       [113, qml.Hadamard, [11], []]        , [114, qml.Hadamard, [15], []]]\n                   ),\n        ([4,7,9,10] , [[95,  qml.Hadamard, [4], []]     , [96, qml.RX,       [7],  [-np.pi/2]],\n                       [97,  qml.Hadamard, [9], []]     , [98, qml.Hadamard, [10], []],\n                       [104, qml.RZ, [10], [-np.pi/24]] ,\n                       [110, qml.Hadamard, [4], []]     , [111, qml.RX,       [7] , [np.pi/2]],\n                       [112, qml.Hadamard, [9], []]     , [113, qml.Hadamard, [10], []]]\n                   ),\n        ([5,6,10,12], [[102, qml.RX, [5],  [-np.pi/2]]  , [103, qml.RX,       [6],  [-np.pi/2]],\n                       [104, qml.RX, [10], [-np.pi/2]]  , [105, qml.Hadamard, [12], []],\n                       [110, qml.RZ, [12], [-np.pi/24]] ,\n                       [115, qml.RX, [5],  [np.pi/2]]   , [116, qml.RX,       [6],  [np.pi/2]],\n                       [117, qml.RX, [10], [np.pi/2]]   , [118, qml.Hadamard, [12], []]]\n                   ),\n        ([3,6,17,19], [[147, qml.RX,       [3],  [-np.pi/2]], [148, qml.RX, [6],  [-np.pi/2]],\n                       [149, qml.Hadamard, [17], []]        , [150, qml.RX, [19], [-np.pi/2]],\n                       [157, qml.RZ, [19], [-np.pi/24]]     ,\n                       [164, qml.RX, [3],  [np.pi/2]]       , [165, qml.RX, [6],  [np.pi/2]],\n                       [166, qml.Hadamard, [17], []]        , [167, qml.RX, [19], [np.pi/2]]]\n                   ),\n        ([6,7,8,9]  , [[4, qml.CNOT, [6, 7], []], [5,  qml.CNOT, [7, 8], []], \n                       [6, qml.CNOT, [8, 9], []], [8,  qml.CNOT, [8, 9], []],\n                       [9, qml.CNOT, [7, 8], []], [10, qml.CNOT, [6, 7], []]]\n                   ),\n        ([4,7,8,13] , [[58,  qml.CNOT, [4, 5],   []], [59, qml.CNOT, [5, 6],   []], \n                       [60,  qml.CNOT, [6, 7],   []], [61, qml.CNOT, [7, 8],   []],\n                       [62,  qml.CNOT, [8, 9],   []], [63, qml.CNOT, [9, 10],  []],\n                       [64,  qml.CNOT, [10, 11], []], [65, qml.CNOT, [11, 12], []],\n                       [66,  qml.CNOT, [12,13],  []],\n                       [122, qml.CNOT, [12, 13], []], [123, qml.CNOT, [11, 12], []], \n                       [124, qml.CNOT, [10, 11], []], [125, qml.CNOT, [9, 10],  []],\n                       [126, qml.CNOT, [8, 9],   []], [127, qml.CNOT, [7, 8],   []],\n                       [128, qml.CNOT, [6, 7],   []], [129, qml.CNOT, [5, 6],   []],\n                       [130, qml.CNOT, [4,5],    []]]\n                   ),\n        ]\n    )\n    def test_double_ex_unitary_operations(self, pphh, ref_gates):\n        """"""Test the correctness of the DoubleExcitationUnitary template including the gate count\n        and order, the wires each operation acts on and the correct use of parameters \n        in the circuit.""""""\n\n        sqg = 72\n        cnots = 16*(pphh[1]-pphh[0] + pphh[3]-pphh[2] + 1)\n        weight = np.pi/3\n        with qml.utils.OperationRecorder() as rec:\n            DoubleExcitationUnitary(weight, wires=pphh)\n\n        assert len(rec.queue) == sqg + cnots\n\n        for gate in ref_gates:\n            idx = gate[0]\n\n            exp_gate = gate[1]\n            res_gate = rec.queue[idx]\n            assert isinstance(res_gate, exp_gate)\n\n            exp_wires = gate[2]\n            res_wires = rec.queue[idx]._wires\n            assert res_wires == Wires(exp_wires)\n\n            exp_weight = gate[3]\n            res_weight = rec.queue[idx].parameters\n            assert res_weight == exp_weight\n\n    @pytest.mark.parametrize(\n        (""weight"", ""pphh"", ""msg_match""),\n        [\n            ( 0.2      , [0]                  , ""expected 4 wires""),\n            ( 0.2      , [0, 1]               , ""expected 4 wires""),\n            ( 0.2      , [0, 1, 2, 3, 4]      , ""expected 4 wires""),\n            ( 0.2      , []                   , ""expected 4 wires""),\n            ([0.2, 1.1], [0, 2, 4, 6]         , ""\'weight\' must be of shape""),\n            ( 0.2      , [1, 0, 6, 3]         , ""wires_3 > wires_2 > wires_1 > wires_0""),\n            ( 0.2      , [1, 0, 3, 6]         , ""wires_3 > wires_2 > wires_1 > wires_0"")\n        ]\n    )\n    def test_double_excitation_unitary_exceptions(self, weight, pphh, msg_match):\n        """"""Test that DoubleExcitationUnitary throws an exception if ``weight`` or \n        ``pphh`` parameter has illegal shapes, types or values.""""""\n        dev = qml.device(""default.qubit"", wires=10)\n\n        def circuit(weight=weight, wires=None):\n            DoubleExcitationUnitary(weight=weight, wires=wires)\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = qml.QNode(circuit, dev)\n\n        with pytest.raises(ValueError, match=msg_match):\n            qnode(weight=weight, wires=pphh)\n\n    @pytest.mark.parametrize(\n        (""weight"", ""pphh"", ""expected""),\n        [\n            (1.34817, [0, 1, 3, 4], [0.22079189, 0.22079189, 1.,         -0.22079189, -0.22079189]),\n            (0.84817, [1, 2, 3, 4], [1.,         0.66135688, 0.66135688, -0.66135688, -0.66135688])\n        ]\n    )\n    def test_integration(self, weight, pphh, expected, tol):\n        """"""Test integration with PennyLane and gradient calculations""""""\n\n        N = 5\n        wires = range(N)\n        dev = qml.device(\'default.qubit\', wires=N)\n\n        @qml.qnode(dev)\n        def circuit(weight):\n            init_state = np.flip(np.array([1,1,0,0,0]))\n            qml.BasisState(init_state, wires=wires)\n            DoubleExcitationUnitary(weight, wires=pphh)\n\n            return [qml.expval(qml.PauliZ(w)) for w in range(N)]\n\n        res = circuit(weight)\n        assert np.allclose(res, np.array(expected), atol=tol)\n\n        # compare the two methods of computing the Jacobian\n        jac_A = circuit.jacobian((weight), method=""A"")\n        jac_F = circuit.jacobian((weight), method=""F"")\n        assert jac_A == pytest.approx(jac_F, abs=tol)\n\n\nclass TestUCCSDUnitary:\n    """"""Tests for the UCCSD template from the pennylane.templates.subroutine module.""""""\n\n    @pytest.mark.parametrize(\n        (""ph"", ""pphh"", ""weights"", ""ref_gates""),\n        [\n          ([[0, 2]], [], np.array([3.815]),\n             [ [0, qml.BasisState, [0, 1, 2, 3, 4, 5], [np.array([0, 0, 0, 0, 1, 1])]],\n               [1, qml.RX,         [0],        [-np.pi/2]],\n               [5, qml.RZ,         [2],        [1.9075]],\n               [6, qml.CNOT,       [1, 2],     []] ]),\n\n          ([[0, 2], [1, 3]], [], np.array([3.815, 4.866]),\n             [ [2,  qml.Hadamard, [2],    []],\n               [8,  qml.RX,       [0],    [np.pi/2]],\n               [12, qml.CNOT,     [0, 1], []],\n               [23, qml.RZ,       [3],    [2.433]],\n               [24, qml.CNOT,     [2, 3], []],\n               [26, qml.RX,       [1],    [np.pi/2]] ]),\n\n          ([], [[0, 1, 2, 5]], np.array([3.815]),\n             [ [3,   qml.RX,       [2],    [-np.pi/2]],\n               [29,  qml.RZ,       [5],    [0.476875]],\n               [73,  qml.Hadamard, [0],    []],\n               [150, qml.RX,       [1],    [np.pi/2]],\n               [88,  qml.CNOT,     [3, 4], []],\n               [121, qml.CNOT,     [2, 3], []] ]),\n\n          ([], [[0, 1, 2, 3], [0, 1, 4, 5]], np.array([3.815, 4.866]),\n             [ [4,   qml.Hadamard, [3],    []],\n               [16,  qml.RX,       [0],    [-np.pi/2]],\n               [38,  qml.RZ,       [3],    [0.476875]],\n               [78,  qml.Hadamard, [2],    []],\n               [107, qml.RX,       [1],    [-np.pi/2]],\n               [209, qml.Hadamard, [4],    []],\n               [218, qml.RZ,       [5],    [-0.60825]],\n               [82,  qml.CNOT,     [2, 3], []],\n               [159, qml.CNOT,     [4, 5], []] ]),\n\n          ([[0, 4], [1, 3]], [[0, 1, 2, 3], [0, 1, 4, 5]], np.array([3.815, 4.866, 1.019, 0.639]),\n             [ [16,  qml.RX,       [0],    [-np.pi/2]],\n               [47,  qml.Hadamard, [1],    []],\n               [74,  qml.Hadamard, [2],    []],\n               [83,  qml.RZ,       [3],    [-0.127375]],\n               [134, qml.RX,       [4],    [np.pi/2]],\n               [158, qml.RZ,       [5],    [0.079875]],\n               [188, qml.RZ,       [5],    [-0.079875]],\n               [96,  qml.CNOT,     [1, 2], []],\n               [235, qml.CNOT,     [1, 4], []] ])\n        ]\n    )\n    def test_uccsd_operations(self, ph, pphh, weights, ref_gates):\n        """"""Test the correctness of the UCCSD template including the gate count\n        and order, the wires the operation acts on and the correct use of parameters \n        in the circuit.""""""\n\n        sqg = 10*len(ph) + 72*len(pphh)\n\n        cnots = 0\n        for i_ph in ph:\n            cnots += 4*(i_ph[1]-i_ph[0])\n\n        for i_pphh in pphh:\n            cnots += 16*(i_pphh[1]-i_pphh[0] + i_pphh[3]-i_pphh[2] + 1)\n        N = 6\n        wires = range(N)\n\n        ref_state = np.array([1, 1, 0, 0, 0, 0])\n\n        with qml.utils.OperationRecorder() as rec:\n            UCCSD(weights, wires, ph=ph, pphh=pphh, init_state=ref_state)\n\n        assert len(rec.queue) == sqg + cnots + 1\n\n        for gate in ref_gates:\n            idx = gate[0]\n\n            exp_gate = gate[1]\n            res_gate = rec.queue[idx]\n            assert isinstance(res_gate, exp_gate)\n\n            exp_wires = gate[2]\n            res_wires = rec.queue[idx]._wires\n            assert res_wires == Wires(exp_wires)\n\n            exp_weight = gate[3]\n            res_weight = rec.queue[idx].parameters\n            if exp_gate != qml.BasisState:\n                assert res_weight == exp_weight\n            else:\n                assert np.allclose(res_weight, exp_weight)\n\n    @pytest.mark.parametrize(\n        (""weights"", ""ph"", ""pphh"", ""init_state"", ""msg_match""),\n        [\n            ( np.array([-2.8]), [[0, 2]], [], [1, 1, 0, 0],\n             ""\'init_state\' must be a Numpy array""),\n\n            ( np.array([-2.8]), [[0, 2]], [], (1, 1, 0, 0),\n             ""\'init_state\' must be a Numpy array""),\n\n            ( np.array([-2.8]), [[0, 2]], [], np.array([1.2, 1, 0, 0]),\n             ""Elements of \'init_state\' must be integers""),\n\n            ( np.array([-2.8]), [], [], np.array([1, 1, 0, 0]),\n             ""\'ph\' and \'pphh\' lists can not be both empty""),\n\n            ( np.array([-2.8]), None, None, np.array([1, 1, 0, 0]),\n             ""\'ph\' and \'pphh\' lists can not be both empty""),\n\n            ( np.array([-2.8]), None, [[0, 1, 2, 3]], np.array([1, 1, 0, 0]),\n             ""\'ph\' must be a list""),\n\n            ( np.array([-2.8, 1.6]), [0, [1, 2]], [], np.array([1, 1, 0, 0]),\n             ""Each element of \'ph\' must be a list""),\n\n            ( np.array([-2.8, 1.6]), [[""a"", 3], [1, 2]], [], np.array([1, 1, 0, 0]),\n             ""Each element of \'ph\' must be a list of integers""),\n\n            ( np.array([-2.8, 1.6]), [[1.4, 3], [1, 2]], [], np.array([1, 1, 0, 0]),\n             ""Each element of \'ph\' must be a list of integers""),\n\n            ( np.array([-2.8]), [[0, 2]], None, np.array([1, 1, 0, 0]),\n             ""\'pphh\' must be a list""),\n\n            ( np.array([-2.8, 1.6]), [], [0, [1, 2, 3, 4]], np.array([1, 1, 0, 0]),\n             ""Each element of \'pphh\' must be a list""),\n\n            ( np.array([-2.8, 1.6]), [], [[0, 1, ""a"", 3], [1, 2, 3, 4]], np.array([1, 1, 0, 0]),\n             ""Each element of \'pphh\' must be a list of integers""),\n\n            ( np.array([-2.8, 1.6]), [], [[0, 1, 1.4, 3], [1, 2, 3, 4]], np.array([1, 1, 0, 0]),\n             ""Each element of \'pphh\' must be a list of integers""),\n\n            ( np.array([-2.8]), [[0, 2]], [], np.array([1, 1, 0, 0, 0]),\n             ""\'init_state\' must be of shape""),\n\n            ( np.array([-2.8, 1.6]), [[0, 2], [1, 3, 4]], [], np.array([1, 1, 0, 0]),\n             ""Elements of \'ph\' must be of shape""),\n\n            ( np.array([-2.8, 1.6]), [[0, 2]], [[0, 1, 2,]], np.array([1, 1, 0, 0]),\n             ""Elements of \'pphh\' must be of shape""),\n\n            ( np.array([-2.8, 1.6]), [[0, 2]], [], np.array([1, 1, 0, 0]),\n             ""\'weights\' must be of shape""),\n\n            ( np.array([-2.8, 1.6]), [], [[0, 1, 2, 3]], np.array([1, 1, 0, 0]),\n             ""\'weights\' must be of shape""),\n\n            ( np.array([-2.8, 1.6]), [[0, 2], [1, 3]], [[0, 1, 2, 3]], np.array([1, 1, 0, 0]),\n             ""\'weights\' must be of shape"")\n        \n        ]\n    )\n    def test_uccsd_xceptions(self, weights, ph, pphh, init_state, msg_match):\n        """"""Test that UCCSD throws an exception if the parameters have illegal\n        shapes, types or values.""""""\n        N=4\n        wires = range(4)\n        dev = qml.device(""default.qubit"", wires=N)\n\n        def circuit(weights=weights, wires=wires, ph=ph, pphh=pphh, init_state=init_state):\n            UCCSD(weights=weights, wires=wires, ph=ph, pphh=pphh, init_state=init_state)\n            return qml.expval(qml.PauliZ(0))\n\n        qnode = qml.QNode(circuit, dev)\n\n        with pytest.raises(ValueError, match=msg_match):\n            qnode(weights=weights, wires=wires, ph=ph, pphh=pphh, init_state=init_state)\n\n    @pytest.mark.parametrize(\n        (""weights"", ""ph"", ""pphh"", ""expected""),\n        [\n            (np.array([3.90575761, -1.89772083, -1.36689032]),\n             [[0, 2], [1, 3]], [[0, 1, 2, 3]],\n             [-0.14619406, -0.06502792, 0.14619406, 0.06502792])\n        ]\n    )\n    def test_integration(self, weights, ph, pphh, expected, tol):\n        """"""Test integration with PennyLane and gradient calculations""""""\n\n        N = 4\n        wires = range(N)\n        dev = qml.device(\'default.qubit\', wires=N)\n\n        w_ph_0 = weights[0]\n        w_ph_1 = weights[1]\n        w_pphh = weights[2]\n\n        @qml.qnode(dev)\n        def circuit(w_ph_0, w_ph_1, w_pphh):\n            UCCSD([w_ph_0, w_ph_1, w_pphh], wires, ph=ph, pphh=pphh, init_state=np.array([1, 1, 0, 0]))\n            return [qml.expval(qml.PauliZ(w)) for w in range(N)]\n\n        res = circuit(w_ph_0, w_ph_1, w_pphh)\n        assert np.allclose(res, np.array(expected), atol=tol)\n\n        # compare the two methods of computing the Jacobian\n        jac_A = circuit.jacobian((w_ph_0, w_ph_1, w_pphh), method=""A"")\n        jac_F = circuit.jacobian((w_ph_0, w_ph_1, w_pphh), method=""F"")\n        assert jac_A == pytest.approx(jac_F, abs=tol)\n'"
tests/templates/test_templ_utils.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""\nTests for the templates utility functions.\n""""""\n# pylint: disable=protected-access,cell-var-from-loop\nimport pytest\nimport numpy as np\nfrom pennylane.variable import Variable\nfrom pennylane.templates.utils import (check_wires,\n                                       check_shape,\n                                       check_shapes,\n                                       get_shape,\n                                       check_number_of_layers,\n                                       check_no_variable,\n                                       check_is_in_options,\n                                       check_type)\n\n#########################################\n# Inputs\n\nWIRES_PASS = [(0, [0]),\n              ([4], [4]),\n              ([1, 2], [1, 2])]\nWIRES_FAIL = [[-1],\n              [\'a\'],\n              lambda x: x,\n              None\n              ]\n\nSHAPE_PASS = [(0.231, (), None),\n              ([[1., 2.], [3., 4.]], (2, 2), None),\n              ([-2.3], (1,), None),\n              ([-2.3, 3.4], (4,), \'max\'),\n              ([-2.3, 3.4], (1,), \'min\'),\n              ([-2.3], (1,), \'max\'),\n              ([-2.3], (1,), \'min\'),\n              ([[-2.3, 3.4], [1., 0.2]], (3, 3), \'max\'),\n              ([[-2.3, 3.4, 1.], [1., 0.2, 1.]], (1, 2), \'min\'),\n              ]\n\nSHAPE_LST_PASS = [([0.231, 0.1], [(), ()], None),\n                  ([[1., 2.], [4.]], [(2,), (1,)], None),\n                  ([[-2.3], -1.], [(1,), ()], None),\n                  ([[-2.3, 0.1], -1.], [(1,), ()], \'min\'),\n                  ([[-2.3, 0.1], -1.], [(3,), ()], \'max\')\n                  ]\n\nSHAPE_FAIL = [(0.231, (1,), None),\n              ([[1., 2.], [3., 4.]], (2,), None),\n              ([-2.3], (4, 5), None),\n              ([-2.3, 3.4], (4,), \'min\'),\n              ([-2.3, 3.4], (1,), \'max\'),\n              ([[-2.3, 3.4], [1., 0.2]], (3, 3), \'min\'),\n              ([[-2.3, 3.4, 1.], [1., 0.2, 1.]], (1, 2), \'max\'),\n              ]\n\nGET_SHAPE_PASS = [(0.231, ()),\n                  (complex(1, 0), ()),\n                  (1, ()),\n                  ([[1., 2.], [3., 4.]], (2, 2)),\n                  ([-2.3], (1,)),\n                  ([-2.3, 3.4], (2,)),\n                  ([-2.3], (1,)),\n                  ([[-2.3, 3.4, 1.], [1., 0.2, 1.]], (2, 3)),\n                  ]\n\nGET_SHAPE_FAIL = [(""a"",),\n                  (None,)]\n\nSHAPE_LST_FAIL = [([[0.231, 0.1]], [[()], [(3, 4)]], None),\n                  ([[1., 2.], [4.]], [(1,), (1,)], None),\n                  ([[-2.3], -1.], [(1, 2), (1,)], None),\n                  ([[-2.3, 0.1], -1.], [(1,), ()], \'max\'),\n                  ([[-2.3, 0.1], -1.], [(3,), ()], \'min\')\n                  ]\n\nLAYERS_PASS = [([[1], [2], [3]], 1),\n               ([[[1], [2], [3]], [[1], [2], [3]]], 3),\n               ]\n\nLAYERS_FAIL = [([[[1], [2], [3]], 1], 5),\n               ([[[1], [2], [3]], [[1], [2]]], 4),\n               ]\n\nNO_VARIABLES_PASS = [[[], np.array([1., 4.])],\n                     [1, \'a\']]\n\nNO_VARIABLES_FAIL = [[[Variable(0.1)], Variable([0.1])],\n                     np.array([Variable(0.3), Variable(4.)]),\n                     Variable(-1.)]\n\nOPTIONS_PASS = [(""a"", [""a"", ""b""])]\n\nOPTIONS_FAIL = [(""c"", [""a"", ""b""])]\n\nTYPE_PASS = [([""a""], list, type(None)),\n             (1, int, type(None)),\n             (""a"", int, str),\n             (Variable(1.), list, Variable)\n             ]\n\nTYPE_FAIL = [(""a"", list, type(None)),\n             (Variable(1.), int, list),\n             (1., Variable, type(None))\n             ]\n\n\n##############################\n\n\nclass TestInputChecks:\n    """"""Test private functions that check the input of templates.""""""\n\n    @pytest.mark.parametrize(""arg"", NO_VARIABLES_PASS)\n    def test_check_no_variable(self, arg):\n        """"""Tests that variable check succeeds for valid arguments.""""""\n        check_no_variable(arg, msg=""XXX"")\n\n    @pytest.mark.parametrize(""arg"", NO_VARIABLES_FAIL)\n    def test_check_no_variable_exception(self, arg):\n        """"""Tests that variable check throws error for invalid arguments.""""""\n        with pytest.raises(ValueError, match=""XXX""):\n            check_no_variable(arg, msg=""XXX"")\n\n    @pytest.mark.parametrize(""wires, target"", WIRES_PASS)\n    def test_check_wires(self, wires, target):\n        """"""Tests that wires check returns correct wires list and its length.""""""\n        res = check_wires(wires=wires)\n        assert res == target\n\n    @pytest.mark.parametrize(""wires"", WIRES_FAIL)\n    def test_check_wires_exception(self, wires):\n        """"""Tests that wires check fails if ``wires`` is not a positive integer or iterable of positive integers.""""""\n        with pytest.raises(ValueError, match=""wires must be a positive integer""):\n            check_wires(wires=wires)\n\n    @pytest.mark.parametrize(""inpt, target_shape"", GET_SHAPE_PASS)\n    def test_get_shape(self, inpt, target_shape):\n        """"""Tests that ``get_shape`` returns correct shape.""""""\n        shape = get_shape(inpt)\n        assert shape == target_shape\n\n    @pytest.mark.parametrize(""inpt"", GET_SHAPE_FAIL)\n    def test_get_shape_exception(self, inpt):\n        """"""Tests that ``get_shape`` fails if unkown type of arguments.""""""\n        with pytest.raises(ValueError, match=""could not extract shape of object""):\n            get_shape(inpt)\n\n    @pytest.mark.parametrize(""inpt, target_shape, bound"", SHAPE_PASS)\n    def test_check_shape(self, inpt, target_shape, bound):\n        """"""Tests that shape check succeeds for valid arguments.""""""\n        check_shape(inpt, target_shape, bound=bound, msg=""XXX"")\n\n    @pytest.mark.parametrize(""inpt, target_shape, bound"", SHAPE_LST_PASS)\n    def test_check_shape_list_of_inputs(self, inpt, target_shape, bound):\n        """"""Tests that list version of shape check succeeds for valid arguments.""""""\n        check_shapes(inpt, target_shape, bounds=[bound] * len(inpt), msg=""XXX"")\n\n    @pytest.mark.parametrize(""inpt, target_shape, bound"", SHAPE_FAIL)\n    def test_check_shape_exception(self, inpt, target_shape, bound):\n        """"""Tests that shape check fails for invalid arguments.""""""\n        with pytest.raises(ValueError, match=""XXX""):\n            check_shape(inpt, target_shape, bound=bound, msg=""XXX"")\n\n    @pytest.mark.parametrize(""inpt, target_shape, bound"", SHAPE_LST_FAIL)\n    def test_check_shape_list_of_inputs_exception(self, inpt, target_shape, bound):\n        """"""Tests that list version of shape check succeeds for valid arguments.""""""\n        with pytest.raises(ValueError, match=""XXX""):\n            check_shapes(inpt, target_shape, bounds=[bound] * len(inpt), msg=""XXX"")\n\n    @pytest.mark.parametrize(""hp, opts"", OPTIONS_PASS)\n    def test_check_options(self, hp, opts):\n        """"""Tests that option check succeeds for valid arguments.""""""\n        check_is_in_options(hp, opts, msg=""XXX"")\n\n    @pytest.mark.parametrize(""hp, opts"", OPTIONS_FAIL)\n    def test_check_options_exception(self, hp, opts):\n        """"""Tests that option check throws error for invalid arguments.""""""\n        with pytest.raises(ValueError, match=""XXX""):\n            check_is_in_options(hp, opts, msg=""XXX"")\n\n    @pytest.mark.parametrize(""hp, typ, alt"", TYPE_PASS)\n    def test_check_type(self, hp, typ, alt):\n        """"""Tests that type check succeeds for valid arguments.""""""\n        check_type(hp, [typ, alt], msg=""XXX"")\n\n    @pytest.mark.parametrize(""hp, typ, alt"", TYPE_FAIL)\n    def test_check_type_exception(self, hp, typ, alt):\n        """"""Tests that type check throws error for invalid arguments.""""""\n        with pytest.raises(ValueError, match=""XXX""):\n            check_type(hp, [typ, alt], msg=""XXX"")\n\n    @pytest.mark.parametrize(""inpt, repeat"", LAYERS_PASS)\n    def test_check_num_layers(self, inpt, repeat):\n        """"""Tests that layer check returns correct number of layers.""""""\n        n_layers = check_number_of_layers(inpt)\n        assert n_layers == repeat\n\n    @pytest.mark.parametrize(""inpt, repeat"", LAYERS_FAIL)\n    def test_check_num_layers_exception(self, inpt, repeat):\n        """"""Tests that layer check throws exception if number of layers not consistent.""""""\n        with pytest.raises(ValueError, match=""the first dimension of the weight parameters""):\n            check_number_of_layers(inpt)\n'"
pennylane/beta/plugins/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nThis package contains experimental plugin devices for PennyLane.\n\n.. currentmodule:: pennylane.beta.plugins\n""""""\nfrom .default_tensor import DefaultTensor\nfrom .default_tensor_tf import DefaultTensorTF\n'"
pennylane/beta/plugins/default_tensor.py,2,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nExperimental simulator plugin based on tensor network contractions\n""""""\nimport math\nimport cmath\nimport warnings\nfrom itertools import product\n\nimport numpy as np\nfrom numpy.linalg import eigh\n\ntry:\n    import tensornetwork as tn\nexcept ImportError as e:\n    raise ImportError(""default.tensor device requires TensorNetwork>=0.2"")\n\nfrom pennylane._device import Device\n\n# tolerance for numerical errors\ntolerance = 1e-10\n\n\n# ========================================================\n#  utilities\n# ========================================================\n\n\ndef spectral_decomposition(A):\n    r""""""Spectral decomposition of a Hermitian matrix.\n\n    Args:\n        A (array): Hermitian matrix\n\n    Returns:\n        (vector[float], list[array[complex]]): (a, P): eigenvalues and hermitian projectors\n            such that :math:`A = \\sum_k a_k P_k`.\n    """"""\n    d, v = eigh(A)\n    P = []\n    for k in range(d.shape[0]):\n        temp = v[:, k]\n        P.append(np.outer(temp, temp.conj()))\n    return d, P\n\n\n# ========================================================\n#  fixed gates\n# ========================================================\n\nI = np.eye(2)\n# Pauli matrices\nX = np.array([[0, 1], [1, 0]])  #: Pauli-X matrix\nY = np.array([[0, -1j], [1j, 0]])  #: Pauli-Y matrix\nZ = np.array([[1, 0], [0, -1]])  #: Pauli-Z matrix\n\nH = np.array([[1, 1], [1, -1]]) / math.sqrt(2)  #: Hadamard gate\n# Two qubit gates\nCNOT = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])  #: CNOT gate\nSWAP = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])  #: SWAP gate\nCZ = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]])  #: CZ gate\nS = np.array([[1, 0], [0, 1j]])  #: Phase Gate\nT = np.array([[1, 0], [0, cmath.exp(1j * np.pi / 4)]])  #: T Gate\n# Three qubit gates\nCSWAP = np.array(\n    [\n        [1, 0, 0, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 1, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 1],\n    ]\n)  #: CSWAP gate\n\nToffoli = np.diag([1 for i in range(8)])\nToffoli[6:8, 6:8] = np.array([[0, 1], [1, 0]])\n\n# ========================================================\n#  parametrized gates\n# ========================================================\n\n\ndef Rphi(phi):\n    r""""""One-qubit phase shift.\n\n    Args:\n        phi (float): phase shift angle\n    Returns:\n        array: unitary 2x2 phase shift matrix\n    """"""\n    return np.array([[1, 0], [0, cmath.exp(1j * phi)]])\n\n\ndef Rotx(theta):\n    r""""""One-qubit rotation about the x axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_x \\theta/2}`\n    """"""\n    return math.cos(theta / 2) * I + 1j * math.sin(-theta / 2) * X\n\n\ndef Roty(theta):\n    r""""""One-qubit rotation about the y axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_y \\theta/2}`\n    """"""\n    return math.cos(theta / 2) * I + 1j * math.sin(-theta / 2) * Y\n\n\ndef Rotz(theta):\n    r""""""One-qubit rotation about the z axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_z \\theta/2}`\n    """"""\n    return math.cos(theta / 2) * I + 1j * math.sin(-theta / 2) * Z\n\n\ndef Rot3(a, b, c):\n    r""""""Arbitrary one-qubit rotation using three Euler angles.\n\n    Args:\n        a,b,c (float): rotation angles\n    Returns:\n        array: unitary 2x2 rotation matrix ``rz(c) @ ry(b) @ rz(a)``\n    """"""\n    return Rotz(c) @ (Roty(b) @ Rotz(a))\n\n\ndef CRotx(theta):\n    r""""""Two-qubit controlled rotation about the x axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_x(\\theta)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, math.cos(theta / 2), -1j * math.sin(theta / 2)],\n            [0, 0, -1j * math.sin(theta / 2), math.cos(theta / 2)],\n        ]\n    )\n\n\ndef CRoty(theta):\n    r""""""Two-qubit controlled rotation about the y axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_y(\\theta)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, math.cos(theta / 2), -math.sin(theta / 2)],\n            [0, 0, math.sin(theta / 2), math.cos(theta / 2)],\n        ]\n    )\n\n\ndef CRotz(theta):\n    r""""""Two-qubit controlled rotation about the z axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_z(\\theta)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, cmath.exp(-1j * theta / 2), 0],\n            [0, 0, 0, cmath.exp(1j * theta / 2)],\n        ]\n    )\n\n\ndef CRot3(a, b, c):\n    r""""""Arbitrary two-qubit controlled rotation using three Euler angles.\n\n    Args:\n        a,b,c (float): rotation angles\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R(a,b,c)`\n    """"""\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [\n                0,\n                0,\n                cmath.exp(-1j * (a + c) / 2) * math.cos(b / 2),\n                -cmath.exp(1j * (a - c) / 2) * math.sin(b / 2),\n            ],\n            [\n                0,\n                0,\n                cmath.exp(-1j * (a - c) / 2) * math.sin(b / 2),\n                cmath.exp(1j * (a + c) / 2) * math.cos(b / 2),\n            ],\n        ]\n    )\n\n\n# ========================================================\n#  Arbitrary states and operators\n# ========================================================\n\n\ndef unitary(*args):\n    r""""""Input validation for an arbitary unitary operation.\n\n    Args:\n        args (array): square unitary matrix\n\n    Raises:\n        ValueError: if the matrix is not unitary or square\n\n    Returns:\n        array: square unitary matrix\n    """"""\n    U = np.asarray(args[0])\n\n    if U.shape[0] != U.shape[1]:\n        raise ValueError(""Operator must be a square matrix."")\n\n    if not np.allclose(U @ U.conj().T, np.identity(U.shape[0])):\n        raise ValueError(""Operator must be unitary."")\n\n    return U\n\n\ndef hermitian(*args):\n    r""""""Input validation for an arbitary Hermitian expectation.\n\n    Args:\n        args (array): square hermitian matrix\n\n    Raises:\n        ValueError: if the matrix is not Hermitian or square\n\n    Returns:\n        array: square hermitian matrix\n    """"""\n    A = np.asarray(args[0])\n    if A.shape[0] != A.shape[1]:\n        raise ValueError(""Expectation must be a square matrix."")\n\n    if not np.allclose(A, A.conj().T):\n        raise ValueError(""Expectation must be Hermitian."")\n\n    return A\n\n\ndef identity(*_):\n    """"""Identity matrix observable.\n\n    Returns:\n        array: 2x2 identity matrix\n    """"""\n    return np.identity(2)\n\n\n# ========================================================\n#  device\n# ========================================================\n\n\nclass DefaultTensor(Device):\n    """"""Experimental Tensor Network simulator device for PennyLane.\n\n    Args:\n        wires (int): the number of modes to initialize the device in\n    """"""\n\n    name = ""PennyLane TensorNetwork simulator plugin""\n    short_name = ""default.tensor""\n    pennylane_requires = ""0.10""\n    version = ""0.10.0""\n    author = ""Xanadu Inc.""\n    _capabilities = {""model"": ""qubit"", ""tensor_observables"": True}\n\n    _operation_map = {\n        ""BasisState"": None,\n        ""QubitStateVector"": None,\n        ""QubitUnitary"": unitary,\n        ""PauliX"": X,\n        ""PauliY"": Y,\n        ""PauliZ"": Z,\n        ""Hadamard"": H,\n        ""S"": S,\n        ""T"": T,\n        ""CNOT"": CNOT,\n        ""SWAP"": SWAP,\n        ""CSWAP"": CSWAP,\n        ""Toffoli"": Toffoli,\n        ""CZ"": CZ,\n        ""PhaseShift"": Rphi,\n        ""RX"": Rotx,\n        ""RY"": Roty,\n        ""RZ"": Rotz,\n        ""Rot"": Rot3,\n        ""CRX"": CRotx,\n        ""CRY"": CRoty,\n        ""CRZ"": CRotz,\n        ""CRot"": CRot3,\n    }\n\n    _observable_map = {\n        ""PauliX"": X,\n        ""PauliY"": Y,\n        ""PauliZ"": Z,\n        ""Hadamard"": H,\n        ""Hermitian"": hermitian,\n        ""Identity"": identity,\n    }\n\n    backend = ""numpy""\n    _reshape = staticmethod(np.reshape)\n    _array = staticmethod(np.array)\n    _asarray = staticmethod(np.asarray)\n    _real = staticmethod(np.real)\n    _imag = staticmethod(np.imag)\n    _abs = staticmethod(np.abs)\n\n    C_DTYPE = np.complex128\n    R_DTYPE = np.float64\n\n    def __init__(self, wires, shots=1000, analytic=True):\n        super().__init__(wires, shots)\n        self.analytic = True\n        self._nodes = []\n        self._edges = []\n        self._state_node = None\n        self._free_edges = []\n        self.reset()\n\n    @staticmethod\n    def _create_basis_state(state, wires):\n        """"""Helper function to create a basis state with the correct shape.\n\n        Args:\n            state (array[int]): array of 0s and 1s of size ``(wires,)`` representing\n                the basis state\n            wires (list[int]): the wires the basis state should\n                be prepared on\n\n        Returns:\n            array[int]: state array of size ``[2]*len(wires)``\n        """"""\n        state_node = np.zeros(tuple([2] * len(wires)))\n        state_node[tuple(state)] = 1\n        return state_node\n\n    def _add_node(self, A, wires, name=""UnnamedNode""):\n        """"""Adds a node to the underlying tensor network.\n\n        The node is also added to ``self._nodes`` for bookkeeping.\n\n        Args:\n            A (array): numerical data values for the operator (i.e., matrix form)\n            wires (list[int]): wires that this operator acts on\n            name (str): optional name for the node\n\n        Returns:\n            tn.Node: the newly created node\n        """"""\n        name = ""{}{}"".format(name, tuple(w for w in wires))\n        if isinstance(A, tn.Node):\n            A.set_name(name)\n            node = A\n        else:\n            node = tn.Node(A, name=name, backend=self.backend)\n        self._nodes.append(node)\n        return node\n\n    def _add_edge(self, node1, idx1, node2, idx2):\n        """"""Adds an edge to the underlying tensor network.\n\n        The edge is also added to ``self._edges`` for bookkeeping.\n\n        Args:\n            node1 (tn.Node): first node to connect\n            idx1 (int): index of node1 to add the edge to\n            node2 (tn.Node): second node to connect\n            idx2 (int): index of node2 to add the edge to\n\n        Returns:\n            tn.Edge: the newly created edge\n        """"""\n        edge = tn.connect(node1[idx1], node2[idx2])\n        self._edges.append(edge)\n\n        return edge\n\n    def pre_apply(self):\n        self.reset()\n\n    def apply(self, operation, wires, par):\n        if operation == ""QubitStateVector"":\n            state = self._array(par[0], dtype=self.C_DTYPE)\n            if state.ndim == 1 and state.shape[0] == 2 ** self.num_wires:\n                self._state_node.tensor = self._reshape(state, [2] * self.num_wires)\n            else:\n                raise ValueError(""State vector must be of length 2**wires."")\n            if wires is not None and wires != [] and list(wires) != list(range(self.num_wires)):\n                raise ValueError(\n                    ""The default.tensor plugin can apply QubitStateVector only to all of the {} wires."".format(\n                        self.num_wires\n                    )\n                )\n            return\n        if operation == ""BasisState"":\n            n = len(par[0])\n            if n == 0 or n > self.num_wires or not set(par[0]).issubset({0, 1}):\n                raise ValueError(\n                    ""BasisState parameter must be an array of 0 or 1 integers of length at most {}."".format(\n                        self.num_wires\n                    )\n                )\n            if wires is not None and wires != [] and list(wires) != list(range(self.num_wires)):\n                raise ValueError(\n                    ""The default.tensor plugin can apply BasisState only to all of the {} wires."".format(\n                        self.num_wires\n                    )\n                )\n            state_node = self._create_basis_state(par[0], wires)\n            self._state_node.tensor = self._asarray(state_node, dtype=self.C_DTYPE)\n            return\n\n        A = self._get_operator_matrix(operation, par)\n        num_mult_idxs = len(wires)\n        A = self._reshape(A, [2] * num_mult_idxs * 2)\n        op_node = self._add_node(A, wires=wires, name=operation)\n        for idx, w in enumerate(wires):\n            self._add_edge(op_node, num_mult_idxs + idx, self._state_node, w)\n            self._free_edges[w] = op_node[idx]\n        # TODO: can be smarter here about collecting contractions?\n        self._state_node = tn.contract_between(\n            op_node, self._state_node, output_edge_order=self._free_edges\n        )\n\n    def create_nodes_from_tensors(self, tensors: list, wires: list, observable_names: list):\n        """"""Helper function for creating tensornetwork nodes based on tensors.\n\n        Args:\n          tensors (np.ndarray, tf.Tensor, torch.Tensor): tensors of the observables\n          wires (Sequence[Sequence[int]]): measured subsystems for each observable\n          observable_names (Sequence[str]): name of the operation/observable\n\n        Returns:\n          list[tn.Node]: the observables as tensornetwork Nodes\n        """"""\n        return [self._add_node(A, w, name=o) for A, w, o in zip(tensors, wires, observable_names)]\n\n    def expval(self, observable, wires, par):\n\n        if not isinstance(observable, list):\n            observable, wires, par = [observable], [wires], [par]\n\n        tensors = []\n        for o, p, w in zip(observable, par, wires):\n            A = self._get_operator_matrix(o, p)\n            num_mult_idxs = len(w)\n            tensors.append(self._reshape(A, [2] * num_mult_idxs * 2))\n\n        nodes = self.create_nodes_from_tensors(tensors, wires, observable)\n        return self.ev(nodes, wires)\n\n    def var(self, observable, wires, par):\n\n        if not isinstance(observable, list):\n            observable, wires, par = [observable], [wires], [par]\n\n        matrices = [self._get_operator_matrix(o, p) for o, p in zip(observable, par)]\n\n        tensors = [self._reshape(A, [2] * len(wires) * 2) for A, wires in zip(matrices, wires)]\n        tensors_of_squared_matrices = [\n            self._reshape(A @ A, [2] * len(wires) * 2) for A, wires in zip(matrices, wires)\n        ]\n\n        obs_nodes = self.create_nodes_from_tensors(tensors, wires, observable)\n        obs_nodes_for_squares = self.create_nodes_from_tensors(\n            tensors_of_squared_matrices, wires, observable\n        )\n\n        return self.ev(obs_nodes_for_squares, wires) - self.ev(obs_nodes, wires) ** 2\n\n    def sample(self, observable, wires, par):\n\n        if not isinstance(observable, list):\n            observable, wires, par = [observable], [wires], [par]\n\n        matrices = [self._get_operator_matrix(o, p) for o, p in zip(observable, par)]\n\n        decompositions = [spectral_decomposition(A) for A in matrices]\n        eigenvalues, projector_groups = list(zip(*decompositions))\n        eigenvalues = list(eigenvalues)\n\n        # Matching each projector with the wires it acts on\n        # while preserving the groupings\n        projectors_with_wires = [\n            [(proj, wires[idx]) for proj in proj_group]\n            for idx, proj_group in enumerate(projector_groups)\n        ]\n\n        # The eigenvalue - projector maps are preserved as product() preserves\n        # the previous ordering by creating a lexicographic ordering\n        joint_outcomes = list(product(*eigenvalues))\n        projector_tensor_products = list(product(*projectors_with_wires))\n\n        joint_probabilities = []\n\n        for projs in projector_tensor_products:\n            obs_nodes = []\n            obs_wires = []\n            for proj, proj_wires in projs:\n\n                tensor = proj.reshape([2] * len(proj_wires) * 2)\n                obs_nodes.append(self._add_node(tensor, proj_wires))\n                obs_wires.append(proj_wires)\n\n            joint_probabilities.append(self.ev(obs_nodes, obs_wires))\n\n        outcomes = np.array([np.prod(p) for p in joint_outcomes])\n        return np.random.choice(outcomes, self.shots, p=joint_probabilities)\n\n    def _get_operator_matrix(self, operation, par):\n        """"""Get the operator matrix for a given operation or observable.\n\n        Args:\n          operation    (str): name of the operation/observable\n          par (tuple[float]): parameter values\n        Returns:\n          array: matrix representation.\n        """"""\n        A = {**self._operation_map, **self._observable_map}[operation]\n        if not callable(A):\n            return self._array(A, dtype=self.C_DTYPE)\n        return self._asarray(A(*par), dtype=self.C_DTYPE)\n\n    def ev(self, obs_nodes, wires):\n        r""""""Expectation value of observables on specified wires.\n\n         Args:\n            obs_nodes (Sequence[tn.Node]): the observables as tensornetwork Nodes\n            wires (Sequence[Sequence[int]]): measured subsystems for each observable\n         Returns:\n            float: expectation value :math:`\\expect{A} = \\bra{\\psi}A\\ket{\\psi}`\n        """"""\n\n        all_wires = tuple(w for w in range(self.num_wires))\n        ket = self._add_node(self._state_node, wires=all_wires, name=""Ket"")\n        bra = self._add_node(tn.conj(ket), wires=all_wires, name=""Bra"")\n        meas_wires = []\n        # We need to build up <psi|A|psi> step-by-step.\n        # For wires which are measured, we need to connect edges between\n        # bra, obs_node, and ket.\n        # For wires which are not measured, we need to connect edges between\n        # bra and ket.\n        # We use the convention that the indices of a tensor are ordered like\n        # [output_idx1, output_idx2, ..., input_idx1, input_idx2, ...]\n        for obs_node, obs_wires in zip(obs_nodes, wires):\n            meas_wires.extend(obs_wires)\n            for idx, w in enumerate(obs_wires):\n                output_idx = idx\n                input_idx = len(obs_wires) + idx\n                self._add_edge(obs_node, input_idx, ket, w)  # A|psi>\n                self._add_edge(bra, w, obs_node, output_idx)  # <psi|A\n        for w in set(all_wires) - set(meas_wires):\n            self._add_edge(bra, w, ket, w)  # |psi[w]|**2\n\n        # At this stage, all nodes are connected, and the contraction yields a\n        # scalar value.\n        contracted_ket = ket\n        for obs_node in obs_nodes:\n            contracted_ket = tn.contract_between(obs_node, contracted_ket)\n        expval = tn.contract_between(bra, contracted_ket).tensor\n        if self._abs(self._imag(expval)) > tolerance:\n            warnings.warn(\n                ""Nonvanishing imaginary part {} in expectation value."".format(expval.imag),\n                RuntimeWarning,\n            )\n        return self._real(expval)\n\n    @property\n    def _state(self):\n        """"""The numerical value of the current state vector.\n\n        This attribute cannot be manually overwritten.\n\n        Returns:\n            (array, tf.Tensor, torch.Tensor): the numerical tensor\n        """"""\n\n        return self._state_node.tensor\n\n    def reset(self):\n        """"""Reset the device""""""\n        self._nodes = []\n        self._edges = []\n\n        state = self._create_basis_state([0] * self.num_wires, range(self.num_wires))\n        state = self._array(state, dtype=self.C_DTYPE)\n\n        # TODO: since this state is separable, can be more intelligent about not making a dense matrix\n        self._state_node = self._add_node(\n            state, wires=tuple(w for w in range(self.num_wires)), name=""AllZeroState""\n        )\n        self._free_edges = self._state_node.edges[\n            :\n        ]  # we need this list to be distinct from self._state_node.edges\n\n    @property\n    def operations(self):\n        return set(self._operation_map.keys())\n\n    @property\n    def observables(self):\n        return set(self._observable_map.keys())\n'"
pennylane/beta/plugins/default_tensor_tf.py,60,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nExperimental simulator plugin based on tensor network contractions,\nusing the TensorFlow backend for Jacobian computations.\n""""""\nimport copy\n\nimport numpy as np\n\ntry:\n    import tensorflow as tf\n\n    if tf.__version__[0] == ""1"":\n        raise ImportError(""default.tensor.tf device requires TensorFlow>=2.0"")\n\nexcept ImportError as e:\n    raise ImportError(""default.tensor.tf device requires TensorFlow>=2.0"")\n\nfrom pennylane.variable import Variable\nfrom pennylane.beta.plugins.default_tensor import DefaultTensor, I, X, Y, Z\n\n\n# tolerance for numerical errors\ntolerance = 1e-10\nC_DTYPE = tf.complex128\nR_DTYPE = tf.float64\n\n\nI = tf.constant(I, dtype=C_DTYPE)\nX = tf.constant(X, dtype=C_DTYPE)\n\nII = tf.eye(4, dtype=C_DTYPE)\nZZ = tf.constant(np.kron(Z, Z), dtype=C_DTYPE)\n\nIX = tf.constant(np.kron(I, X), dtype=C_DTYPE)\nIY = tf.constant(np.kron(I, Y), dtype=C_DTYPE)\nIZ = tf.constant(np.kron(I, Z), dtype=C_DTYPE)\n\nZI = tf.constant(np.kron(Z, I), dtype=C_DTYPE)\nZX = tf.constant(np.kron(Z, X), dtype=C_DTYPE)\nZY = tf.constant(np.kron(Z, Y), dtype=C_DTYPE)\n\n\ndef Rphi(phi):\n    r""""""One-qubit phase shift.\n\n    Args:\n        phi (float): phase shift angle\n\n    Returns:\n        array: unitary 2x2 phase shift matrix\n    """"""\n    phi = tf.cast(phi, dtype=C_DTYPE)\n    return ((1 + tf.exp(1j * phi)) * I + (1 - tf.exp(1j * phi)) * Z) / 2\n\n\ndef Rotx(theta):\n    r""""""One-qubit rotation about the x axis.\n\n    Args:\n        theta (float): rotation angle\n\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_x \\theta/2}`\n    """"""\n    theta = tf.cast(theta, dtype=C_DTYPE)\n    return tf.cos(theta / 2) * I + 1j * tf.sin(-theta / 2) * X\n\n\ndef Roty(theta):\n    r""""""One-qubit rotation about the y axis.\n\n    Args:\n        theta (float): rotation angle\n\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_y \\theta/2}`\n    """"""\n    theta = tf.cast(theta, dtype=C_DTYPE)\n    return tf.cos(theta / 2) * I + 1j * tf.sin(-theta / 2) * Y\n\n\ndef Rotz(theta):\n    r""""""One-qubit rotation about the z axis.\n\n    Args:\n        theta (float): rotation angle\n\n    Returns:\n        array: unitary 2x2 rotation matrix :math:`e^{-i \\sigma_z \\theta/2}`\n    """"""\n    theta = tf.cast(theta, dtype=C_DTYPE)\n    return tf.cos(theta / 2) * I + 1j * tf.sin(-theta / 2) * Z\n\n\ndef Rot3(a, b, c):\n    r""""""Arbitrary one-qubit rotation using three Euler angles.\n\n    Args:\n        a,b,c (float): rotation angles\n\n    Returns:\n        array: unitary 2x2 rotation matrix ``rz(c) @ ry(b) @ rz(a)``\n    """"""\n    return Rotz(c) @ Roty(b) @ Rotz(a)\n\n\ndef CRotx(theta):\n    r""""""Two-qubit controlled rotation about the x axis.\n\n    Args:\n        theta (float): rotation angle\n\n    Returns:\n        array: unitary 4x4 rotation matrix\n        :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_x(\\theta)`\n    """"""\n    theta = tf.cast(theta, dtype=C_DTYPE)\n    return (\n        tf.cos(theta / 4) ** 2 * II\n        - 1j * tf.sin(theta / 2) / 2 * IX\n        + tf.sin(theta / 4) ** 2 * ZI\n        + 1j * tf.sin(theta / 2) / 2 * ZX\n    )\n\n\ndef CRoty(theta):\n    r""""""Two-qubit controlled rotation about the y axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_y(\\theta)`\n    """"""\n    theta = tf.cast(theta, dtype=C_DTYPE)\n    return (\n        tf.cos(theta / 4) ** 2 * II\n        - 1j * tf.sin(theta / 2) / 2 * IY\n        + tf.sin(theta / 4) ** 2 * ZI\n        + 1j * tf.sin(theta / 2) / 2 * ZY\n    )\n\n\ndef CRotz(theta):\n    r""""""Two-qubit controlled rotation about the z axis.\n\n    Args:\n        theta (float): rotation angle\n    Returns:\n        array: unitary 4x4 rotation matrix\n        :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R_z(\\theta)`\n    """"""\n    theta = tf.cast(theta, dtype=C_DTYPE)\n    return (\n        tf.cos(theta / 4) ** 2 * II\n        - 1j * tf.sin(theta / 2) / 2 * IZ\n        + tf.sin(theta / 4) ** 2 * ZI\n        + 1j * tf.sin(theta / 2) / 2 * ZZ\n    )\n\n\ndef CRot3(a, b, c):\n    r""""""Arbitrary two-qubit controlled rotation using three Euler angles.\n\n    Args:\n        a,b,c (float): rotation angles\n    Returns:\n        array: unitary 4x4 rotation matrix\n        :math:`|0\\rangle\\langle 0|\\otimes \\mathbb{I}+|1\\rangle\\langle 1|\\otimes R(a,b,c)`\n    """"""\n    return CRotz(c) @ (CRoty(b) @ CRotz(a))\n\n\nclass DefaultTensorTF(DefaultTensor):\n    """"""Experimental TensorFlow Tensor Network simulator device for PennyLane.\n\n    **Short name:** ``default.tensor.tf``\n\n    This experimental device extends ``default.tensor`` by making use of\n    the TensorFlow backend of TensorNetwork. As a result, it supports\n    classical backpropagation as a means to compute the Jacobian. This can\n    be faster than the parameter-shift rule for analytic quantum gradients\n    when the number of parameters to be optimized is large.\n\n    To use this device, you will need to install TensorFlow and TensorNetwork:\n\n    .. code-block:: bash\n\n        pip install tensornetwork>=0.2 tensorflow>=2.0\n\n    **Example**\n\n    The ``default.tensor.tf`` device supports various differentiation modes.\n\n    * *End-to-end classical backpropagation with the TensorFlow interface*.\n      Using this method, the created QNode is a \'white-box\', and is\n      tightly integrated with your TensorFlow computation:\n\n      >>> dev = qml.device(""default.tensor.tf"", wires=1)\n      >>> @qml.qnode(dev, interface=""tf"", diff_method=""backprop"")\n      >>> def circuit(x):\n      ...     qml.RX(x[1], wires=0)\n      ...     qml.Rot(x[0], x[1], x[2], wires=0)\n      ...     return qml.expval(qml.PauliZ(0))\n      >>> vars = tf.Variable([0.2, 0.5, 0.1])\n      >>> with tf.GradientTape() as tape:\n      ...     res = circuit(vars)\n      >>> tape.gradient(res, vars)\n      <tf.Tensor: shape=(3,), dtype=float32, numpy=array([-2.2526717e-01, -1.0086454e+00,  1.3877788e-17], dtype=float32)>\n\n      In this mode, you must use the ``""tf""`` interface, as TensorFlow\n      is used as the device backend.\n\n    * *Device differentiation*. Using this method, the created QNode\n      is a \'black-box\' to your classical computation. PennyLane will automatically\n      accept classical tensors from any supported interface, and query the\n      device directly for the quantum gradient when required.\n\n      >>> dev = qml.device(""default.tensor.tf"", wires=1)\n      >>> @qml.qnode(dev, interface=""autograd"", diff_method=""device"")\n      >>> def circuit(x):\n      ...     qml.RX(x[1], wires=0)\n      ...     qml.Rot(x[0], x[1], x[2], wires=0)\n      ...     return qml.expval(qml.PauliZ(0))\n      >>> grad_fn = qml.grad(circuit, argnum=[0])\n      >>> print(grad_fn([0.2, 0.5, 0.1]))\n      ([array(-0.22526717), array(-1.00864546), array(6.9388939e-18)],)\n\n      In this mode, even though TensorFlow is used as the device backend, it\n      is independent of the chosen QNode interface. In the example above, we combine\n      ``default.tensor.tf`` with the ``autograd`` interface.\n      It can also be used with the ``torch`` and the ``tf`` interface.\n\n    In addition to end-to-end classical backpropagation and device differentiation,\n    the ``default.tensor.tf`` device also supports ``parameter-shift`` and\n    ``finite-diff`` differentiation methods.\n\n    Args:\n        wires (int): the number of modes to initialize the device in\n        shots (int): the number of shots used for returning samples\n    """"""\n\n    # pylint: disable=too-many-instance-attributes\n    name = ""PennyLane TensorNetwork (TensorFlow) simulator plugin""\n    short_name = ""default.tensor.tf""\n    _capabilities = {\n        ""model"": ""qubit"",\n        ""tensor_observables"": True,\n        ""provides_jacobian"": True,\n        ""passthru_interface"": ""tf"",\n    }\n\n    _operation_map = copy.copy(DefaultTensor._operation_map)\n    _operation_map.update(\n        {\n            ""PhaseShift"": Rphi,\n            ""RX"": Rotx,\n            ""RY"": Roty,\n            ""RZ"": Rotz,\n            ""Rot"": Rot3,\n            ""CRX"": CRotx,\n            ""CRY"": CRoty,\n            ""CRZ"": CRotz,\n            ""CRot"": CRot3,\n        }\n    )\n\n    backend = ""tensorflow""\n    _reshape = staticmethod(tf.reshape)\n    _array = staticmethod(tf.constant)\n    _asarray = staticmethod(tf.convert_to_tensor)\n    _real = staticmethod(tf.math.real)\n    _imag = staticmethod(tf.math.imag)\n    _abs = staticmethod(tf.abs)\n\n    C_DTYPE = C_DTYPE\n    R_DTYPE = R_DTYPE\n\n    def __init__(self, wires, shots=1000):\n        self.variables = []\n        """"""List[tf.Variable]: Free parameters, cast to TensorFlow variables,\n        for this circuit.""""""\n\n        self.res = None\n        """"""tf.tensor[tf.float64]: result from the last circuit execution""""""\n\n        self.op_params = {}\n        """"""dict[Operation, List[Any, tf.Variable]]: A mapping from each operation\n        in the queue, to the corresponding list of parameter values. These\n        values can be Python numeric types, NumPy arrays, or TensorFlow variables.""""""\n\n        self.tape = None\n        """"""tf.GradientTape: the gradient tape under which all tensor network\n        modifications must be made""""""\n\n        super().__init__(wires, shots=shots, analytic=True)\n\n    def reset(self):\n        self.res = None\n        self.variables = []\n        super().reset()\n\n    def execution_context(self):\n        self.tape = tf.GradientTape(persistent=True)\n        return self.tape\n\n    def pre_apply(self):\n        super().pre_apply()\n\n        self.op_params = {}\n\n        for operation in self.op_queue:\n            # Copy the operation parameters to the op_params dictionary.\n            # Note that these are the unwrapped parameters, so PennyLane\n            # free parameters will be represented as Variable instances.\n            self.op_params[operation] = operation.params[:]\n\n        # Loop through the free parameter reference dictionary\n        for _, par_dep_list in self.parameters.items():\n            if not par_dep_list:\n                # parameter is not used within circuit\n                v = tf.Variable(0, dtype=self.R_DTYPE)\n                self.variables.append(v)\n                continue\n\n            # get the first parameter dependency for each free parameter\n            first = par_dep_list[0]\n\n            # For the above parameter dependency, get the corresponding\n            # operation parameter variable, and get the numeric value.\n            # Convert the resulting value to a TensorFlow tensor.\n            val = first.op.params[first.par_idx].val\n            mult = first.op.params[first.par_idx].mult\n            v = tf.Variable(val / mult, dtype=self.R_DTYPE)\n\n            # Mark the variable to be watched by the gradient tape,\n            # and append it to the variable list.\n            self.variables.append(v)\n\n            for p in par_dep_list:\n                # Replace the existing Variable free parameter in the op_params dictionary\n                # with the corresponding tf.Variable parameter.\n                # Note that the free parameter might be scaled by the\n                # variable.mult scaling factor.\n                mult = p.op.params[p.par_idx].mult\n                self.op_params[p.op][p.par_idx] = v * mult\n\n        # check that no Variables remain in the op_params dictionary\n        values = [item for sublist in self.op_params.values() for item in sublist]\n        assert not any(\n            isinstance(v, Variable) for v in values\n        ), ""A pennylane.Variable instance was not correctly converted to a tf.Variable""\n\n        # flatten the variables list in case of nesting\n        self.variables = tf.nest.flatten(self.variables)\n        self.tape.watch(self.variables)\n\n        for operation in self.op_queue:\n            # Apply each operation, but instead of passing operation.parameters\n            # (which contains the evaluated numeric parameter values),\n            # pass op_params[operation], which contains numeric values\n            # for fixed parameters, and tf.Variable objects for free parameters.\n            super().apply(operation.name, operation.wires.tolist(), self.op_params[operation])\n\n    def apply(self, operation, wires, par):\n        # individual operations are already applied inside self.pre_apply()\n        pass\n\n    def execute(self, queue, observables, parameters=None, **kwargs):\n        # pylint: disable=bad-super-call\n        results = super(DefaultTensor, self).execute(queue, observables, parameters=parameters)\n\n        with self.tape:\n            # convert the results list into a single tensor\n            self.res = tf.stack(results)\n\n        if kwargs.get(""return_native_type"", False):\n            return self.res\n        # return the results as a NumPy array\n        return self.res.numpy()\n\n    def jacobian(self, queue, observables, parameters):\n        """"""Calculates the Jacobian of the device circuit using TensorFlow\n        backpropagation.\n\n        Args:\n            queue (list[Operation]): operations to be applied to the device\n            observables (list[Observable]): observables to be measured\n            parameters (dict[int, ParameterDependency]): reference dictionary\n                mapping free parameter values to the operations that\n                depend on them\n\n        Returns:\n            array[float]: Jacobian matrix of size (``num_params``, ``num_wires``)\n        """"""\n        self.execute(queue, observables, parameters=parameters)\n        jac = self.tape.jacobian(self.res, self.variables, experimental_use_pfor=False)\n        # TODO use unconnected_gradients=tf.UnconnectedGradients.ZERO instead of the following?\n        jac = [i if i is not None else tf.zeros(self.res.shape, dtype=tf.float64) for i in jac]\n        jac = tf.stack(jac)\n        return jac.numpy().T\n'"
pennylane/templates/embeddings/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nEmbeddings are templates encode features (i.e., classical data) into a quantum state.\nThey can optionally be repeated, and may contain trainable parameters. Embeddings are typically\nused at the beginning of a circuit.\n""""""\n\nfrom .angle import AngleEmbedding\nfrom .amplitude import AmplitudeEmbedding\nfrom .basis import BasisEmbedding\nfrom .displacement import DisplacementEmbedding\nfrom .iqp import IQPEmbedding\nfrom .qaoa import QAOAEmbedding\nfrom .squeezing import SqueezingEmbedding\n'"
pennylane/templates/embeddings/amplitude.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``AmplitudeEmbedding`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nimport math\nimport numpy as np\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import QubitStateVector\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_no_variable,\n    check_type,\n    get_shape,\n)\nfrom pennylane.variable import Variable\nfrom pennylane.wires import Wires\n\n# tolerance for normalization\nTOLERANCE = 1e-10\n\n\n@template\ndef AmplitudeEmbedding(features, wires, pad=None, normalize=False):\n    r""""""Encodes :math:`2^n` features into the amplitude vector of :math:`n` qubits.\n\n    By setting ``pad`` to a real or complex number, ``features`` is automatically padded to dimension\n    :math:`2^n` where :math:`n` is the number of qubits used in the embedding.\n\n    To represent a valid quantum state vector, the L2-norm of ``features`` must be one.\n    The argument ``normalize`` can be set to ``True`` to automatically normalize the features.\n\n    If both automatic padding and normalization are used, padding is executed *before* normalizing.\n\n    .. note::\n\n        On some devices, ``AmplitudeEmbedding`` must be the first operation of a quantum node.\n\n\n    .. warning::\n\n        ``AmplitudeEmbedding`` calls a circuit that involves non-trivial classical processing of the\n        features. The ``features`` argument is therefore **not differentiable** when using the template, and\n        gradients with respect to the features cannot be computed by PennyLane.\n\n    Args:\n        features (array): input array of shape ``(2^n,)``\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        pad (float or complex): if not None, the input is padded with this constant to size :math:`2^n`\n        normalize (Boolean): controls the activation of automatic normalization\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        Amplitude embedding encodes a normalized :math:`2^n`-dimensional feature vector into the state\n        of :math:`n` qubits:\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import AmplitudeEmbedding\n\n            dev = qml.device(\'default.qubit\', wires=2)\n\n            @qml.qnode(dev)\n            def circuit(f=None):\n                AmplitudeEmbedding(features=f, wires=range(2))\n                return qml.expval(qml.PauliZ(0))\n\n            circuit(f=[1/2, 1/2, 1/2, 1/2])\n\n        Checking the final state of the device, we find that it is equivalent to the input passed to the circuit:\n\n        >>> dev._state\n        [0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j]\n\n        **Passing features as positional arguments to a quantum node**\n\n        The ``features`` argument of ``AmplitudeEmbedding`` can in principle also be passed to the quantum node\n        as a positional argument:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit(f):\n                AmplitudeEmbedding(features=f, wires=range(2))\n                return qml.expval(qml.PauliZ(0))\n\n        However, due to non-trivial classical processing to construct the state preparation circuit,\n        the features argument is **not differentiable**.\n\n        >>> g = qml.grad(circuit, argnum=0)\n        >>> g([1,1,1,1])\n        ValueError: Cannot differentiate wrt parameter(s) {0, 1, 2, 3}.\n\n\n        **Normalization**\n\n        The template will raise an error if the feature input is not normalized.\n        One can set ``normalize=True`` to automatically normalize it:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit(f=None):\n                AmplitudeEmbedding(features=f, wires=range(2), normalize=True)\n                return qml.expval(qml.PauliZ(0))\n\n            circuit(f=[15, 15, 15, 15])\n\n        The re-normalized feature vector is encoded into the quantum state vector:\n\n        >>> dev._state\n        [0.5 + 0.j, 0.5 + 0.j, 0.5 + 0.j, 0.5 + 0.j]\n\n        **Padding**\n\n        If the dimension of the feature vector is smaller than the number of amplitudes,\n        one can automatically pad it with a constant for the missing dimensions using the ``pad`` option:\n\n        .. code-block:: python\n\n            from math import sqrt\n\n            @qml.qnode(dev)\n            def circuit(f=None):\n                AmplitudeEmbedding(features=f, wires=range(2), pad=0.)\n                return qml.expval(qml.PauliZ(0))\n\n            circuit(f=[1/sqrt(2), 1/sqrt(2)])\n\n        >>> dev._state\n        [0.70710678 + 0.j, 0.70710678 + 0.j, 0.0 + 0.j, 0.0 + 0.j]\n\n        **Operations before the embedding**\n\n        On some devices, ``AmplitudeEmbedding`` must be the first operation in the quantum node.\n        For example, ``\'default.qubit\'`` complains when running the following circuit:\n\n        .. code-block:: python\n\n            dev = qml.device(\'default.qubit\', wires=2)\n\n            @qml.qnode(dev)\n            def circuit(f=None):\n                qml.Hadamard(wires=0)\n                AmplitudeEmbedding(features=f, wires=range(2))\n                return qml.expval(qml.PauliZ(0))\n\n\n        >>> circuit(f=[1/2, 1/2, 1/2, 1/2])\n        pennylane._device.DeviceError: Operation QubitStateVector cannot be used\n        after other Operations have already been applied on a default.qubit device.\n\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(pad, msg=""\'pad\' cannot be differentiable"")\n    check_no_variable(normalize, msg=""\'normalize\' cannot be differentiable"")\n\n    n_amplitudes = 2 ** len(wires)\n    expected_shape = (n_amplitudes,)\n    if pad is None:\n        shape = check_shape(\n            features,\n            expected_shape,\n            msg=""\'features\' must be of shape {}; got {}. Use the \'pad\' ""\n            ""argument for automated padding.""\n            """".format(expected_shape, get_shape(features)),\n        )\n    else:\n        shape = check_shape(\n            features,\n            expected_shape,\n            bound=""max"",\n            msg=""\'features\' must be of shape {} or smaller ""\n            ""to be padded; got {}""\n            """".format(expected_shape, get_shape(features)),\n        )\n\n    check_type(\n        pad,\n        [float, complex, type(None)],\n        msg=""\'pad\' must be a float or complex; got {}"".format(pad),\n    )\n    check_type(normalize, [bool], msg=""\'normalize\' must be a boolean; got {}"".format(normalize))\n\n    ###############\n\n    #############\n    # Preprocessing\n\n    # pad\n    n_features = shape[0]\n    if pad is not None and n_amplitudes > n_features:\n        features = np.pad(\n            features, (0, n_amplitudes - n_features), mode=""constant"", constant_values=pad\n        )\n\n    # normalize\n    if isinstance(features[0], Variable):\n        feature_values = [s.val for s in features]\n        norm = np.sum(np.abs(feature_values) ** 2)\n    else:\n        norm = np.sum(np.abs(features) ** 2)\n\n    if not np.isclose(norm, 1.0, atol=TOLERANCE):\n        if normalize or pad:\n            features = features / math.sqrt(norm)\n        else:\n            raise ValueError(\n                ""\'features\' must be a vector of length 1.0; got length {}.""\n                ""Use \'normalization=True\' to automatically normalize."".format(norm)\n            )\n\n    ###############\n\n    features = np.array(features)\n    QubitStateVector(features, wires=wires)\n'"
pennylane/templates/embeddings/angle.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``AngleEmbedding`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import RX, RY, RZ\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_no_variable,\n    check_is_in_options,\n    check_type,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef AngleEmbedding(features, wires, rotation=""X""):\n    r""""""\n    Encodes :math:`N` features into the rotation angles of :math:`n` qubits, where :math:`N \\leq n`.\n\n    The rotations can be chosen as either :class:`~pennylane.ops.RX`, :class:`~pennylane.ops.RY`\n    or :class:`~pennylane.ops.RZ` gates, as defined by the ``rotation`` parameter:\n\n    * ``rotation=\'X\'`` uses the features as angles of RX rotations\n\n    * ``rotation=\'Y\'`` uses the features as angles of RY rotations\n\n    * ``rotation=\'Z\'`` uses the features as angles of RZ rotations\n\n    The length of ``features`` has to be smaller or equal to the number of qubits. If there are fewer entries in\n    ``features`` than rotations, the circuit does not apply the remaining rotation gates.\n\n    Args:\n        features (array): input array of shape ``(N,)``, where N is the number of input features to embed,\n            with :math:`N\\leq n`\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        rotation (str): Type of rotations used\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(rotation, msg=""\'rotation\' cannot be differentiable"")\n\n    check_shape(\n        features,\n        (len(wires),),\n        bound=""max"",\n        msg=""\'features\' must be of shape {} or smaller; ""\n        ""got {}."".format((len(wires),), get_shape(features)),\n    )\n    check_type(rotation, [str], msg=""\'rotation\' must be a string; got {}"".format(rotation))\n\n    check_is_in_options(\n        rotation,\n        [""X"", ""Y"", ""Z""],\n        msg=""did not recognize option {} for \'rotation\'."".format(rotation),\n    )\n\n    ###############\n\n    if rotation == ""X"":\n        broadcast(unitary=RX, pattern=""single"", wires=wires, parameters=features)\n\n    elif rotation == ""Y"":\n        broadcast(unitary=RY, pattern=""single"", wires=wires, parameters=features)\n\n    elif rotation == ""Z"":\n        broadcast(unitary=RZ, pattern=""single"", wires=wires, parameters=features)\n'"
pennylane/templates/embeddings/basis.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``BasisEmbedding`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom collections import Iterable\n\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import check_shape, get_shape, check_type\nimport pennylane as qml\nfrom pennylane.wires import Wires\n\n\n@template\ndef BasisEmbedding(features, wires):\n    r""""""Encodes :math:`n` binary features into a basis state of :math:`n` qubits.\n\n    For example, for ``features=np.array([0, 1, 0])``, the quantum system will be\n    prepared in state :math:`|010 \\rangle`.\n\n    .. warning::\n\n        ``BasisEmbedding`` calls a circuit whose architecture depends on the binary features.\n        The ``features`` argument is therefore not differentiable when using the template, and\n        gradients with respect to the argument cannot be computed by PennyLane.\n\n    Args:\n        features (array): binary input array of shape ``(n, )``\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_type(\n        features, [Iterable], msg=""\'features\' must be iterable; got type {}"".format(type(features))\n    )\n\n    expected_shape = (len(wires),)\n    check_shape(\n        features,\n        expected_shape,\n        msg=""\'features\' must be of shape {}; got {}"" """".format(expected_shape, get_shape(features)),\n    )\n\n    if any([b not in [0, 1] for b in features]):\n        raise ValueError(""\'basis_state\' must only consist of 0s and 1s; got {}"".format(features))\n\n    ###############\n\n    for wire, bit in zip(wires, features):\n        if bit == 1:\n            qml.PauliX(wire)\n'"
pennylane/templates/embeddings/displacement.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``DisplacementEmbedding`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import Displacement\nfrom pennylane.templates import broadcast\nfrom pennylane.wires import Wires\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_no_variable,\n    check_is_in_options,\n    get_shape,\n)\n\n\n@template\ndef DisplacementEmbedding(features, wires, method=""amplitude"", c=0.1):\n    r""""""Encodes :math:`N` features into the displacement amplitudes :math:`r` or phases :math:`\\phi` of :math:`M` modes,\n     where :math:`N\\leq M`.\n\n    The mathematical definition of the displacement gate is given by the operator\n\n    .. math::\n            D(\\alpha) = \\exp(r (e^{i\\phi}\\ad -e^{-i\\phi}\\a)),\n\n    where :math:`\\a` and :math:`\\ad` are the bosonic creation and annihilation operators.\n\n    ``features`` has to be an array of at most ``len(wires)`` floats. If there are fewer entries in\n    ``features`` than wires, the circuit does not apply the remaining displacement gates.\n\n    Args:\n        features (array): Array of features of size (N,)\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        method (str): ``\'phase\'`` encodes the input into the phase of single-mode displacement, while\n            ``\'amplitude\'`` uses the amplitude\n        c (float): value of the phase of all displacement gates if ``execution=\'amplitude\'``, or\n            the amplitude of all displacement gates if ``execution=\'phase\'``\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n   """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(method, msg=""\'method\' cannot be differentiable"")\n    check_no_variable(c, msg=""\'c\' cannot be differentiable"")\n\n    expected_shape = (len(wires),)\n    check_shape(\n        features,\n        expected_shape,\n        bound=""max"",\n        msg=""\'features\' must be of shape {} or smaller; got {}.""\n        """".format(expected_shape, get_shape(features)),\n    )\n\n    check_is_in_options(\n        method,\n        [""amplitude"", ""phase""],\n        msg=""did not recognize option {} for \'method\'"" """".format(method),\n    )\n\n    #############\n\n    constants = [c] * len(features)\n\n    if method == ""amplitude"":\n        broadcast(\n            unitary=Displacement,\n            pattern=""single"",\n            wires=wires,\n            parameters=list(zip(features, constants)),\n        )\n\n    elif method == ""phase"":\n        broadcast(\n            unitary=Displacement,\n            pattern=""single"",\n            wires=wires,\n            parameters=list(zip(constants, features)),\n        )\n'"
pennylane/templates/embeddings/iqp.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``IQPEmbedding`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom collections import Sequence, Iterable\nfrom itertools import combinations\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import RZ, MultiRZ, Hadamard\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_type,\n    get_shape,\n    check_no_variable,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef IQPEmbedding(features, wires, n_repeats=1, pattern=None):\n    r""""""\n    Encodes :math:`n` features into :math:`n` qubits using diagonal gates of an IQP circuit.\n\n    The embedding has been proposed by `Havlicek et al. (2018) <https://arxiv.org/pdf/1804.11326.pdf>`_.\n\n    The basic IQP circuit can be repeated by specifying ``n_repeats``. Repetitions can make the\n    embedding ""richer"" through interference.\n\n    .. warning::\n\n        ``IQPEmbedding`` calls a circuit that involves non-trivial classical processing of the\n        features. The ``features`` argument is therefore **not differentiable** when using the template, and\n        gradients with respect to the features cannot be computed by PennyLane.\n\n    An IQP circuit is a quantum circuit of a block of Hadamards, followed by a block of gates that are\n    diagonal in the computational basis. Here, the diagonal gates are single-qubit ``RZ`` rotations, applied to each\n    qubit and encoding the :math:`n` features, followed by two-qubit ZZ entanglers,\n    :math:`e^{-i x_i x_j \\sigma_z \\otimes \\sigma_z}`. The entangler applied to wires ``(wires[i], wires[j])``\n    encodes the product of features ``features[i]*features[j]``. The pattern in which the entanglers are\n    applied is either the default, or a custom pattern:\n\n    * If ``pattern`` is not specified, the default pattern will be used, in which the entangling gates connect all\n      pairs of neighbours:\n\n      |\n\n      .. figure:: ../../_static/templates/embeddings/iqp.png\n          :align: center\n          :width: 50%\n          :target: javascript:void(0);\n\n      |\n\n    * Else, ``pattern`` is a list of wire pairs ``[[a, b], [c, d],...]``, applying the entangler\n      on wires ``[a, b]``, ``[c, d]``, etc. For example, ``pattern = [[0, 1], [1, 2]]`` produces\n      the following entangler pattern:\n\n      |\n\n      .. figure:: ../../_static/templates/embeddings/iqp_custom.png\n          :align: center\n          :width: 50%\n          :target: javascript:void(0);\n\n      |\n\n      Since diagonal gates commute, the order of the entanglers does not change the result.\n\n    Args:\n        features (array): array of features to encode\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        n_repeats (int): number of times the basic embedding is repeated\n        pattern (list[int]): specifies the wires and features of the entanglers\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        A typical usage example of the template is the following:\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import IQPEmbedding\n\n            dev = qml.device(\'default.qubit\', wires=3)\n\n            @qml.qnode(dev)\n            def circuit(features=None):\n                IQPEmbedding(features=features, wires=range(3))\n                return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n            circuit(features=[1., 2., 3.])\n\n        **Do not pass features as a positional argument to the qnode**\n\n        The ``features`` argument cannot be passed to the quantum node\n        as a positional argument. This is due to the fact that the embedding performs non-trivial calculations\n        on the features. As a consequence, the following code **will produce an error**:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit(features):\n               IQPEmbedding(features=features, wires=range(3), n_repeats=2)\n               return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n            circuit([1., 2., 3.])\n\n        >>> ValueError: \'features\' cannot be differentiable\n\n        **Repeating the embedding**\n\n        The embedding can be repeated by specifying the ``n_repeats`` argument:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit(features=None):\n                IQPEmbedding(features=features, wires=range(3), n_repeats=4)\n                return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n            circuit(features=[1., 2., 3.])\n\n        Every repetition uses exactly the same quantum circuit.\n\n        **Using a custom entangler pattern**\n\n        A custom entangler pattern can be used by specifying the ``pattern`` argument. A pattern has to be\n        a nested list of dimension ``(K, 2)``, where ``K`` is the number of entanglers to apply.\n\n        .. code-block:: python\n\n            pattern = [[1, 2], [0, 2], [1, 0]]\n\n            @qml.qnode(dev)\n            def circuit(features=None):\n                IQPEmbedding(features=features, wires=range(3), pattern=pattern)\n                return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n            circuit(features=[1., 2., 3.])\n\n        Since diagonal gates commute, the order of the wire pairs has no effect on the result.\n\n        .. code-block:: python\n\n            from pennylane import numpy as np\n\n            pattern1 = [[1, 2], [0, 2], [1, 0]]\n            pattern2 = [[1, 0], [0, 2], [1, 2]]  # a reshuffling of pattern1\n\n            @qml.qnode(dev)\n            def circuit(features=None, pattern=None):\n                IQPEmbedding(features=features, wires=range(3), pattern=pattern, n_repeats=3)\n                return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n\n            res1 = circuit(features=[1., 2., 3.], pattern=pattern1)\n            res2 = circuit(features=[1., 2., 3.], pattern=pattern2)\n\n            assert np.allclose(res1, res2)\n\n        **Non-consecutive wires**\n\n        In principle, the user can also pass a non-consecutive wire list to the template.\n        For single qubit gates, the i\'th feature is applied to the i\'th wire index (which may not be the i\'th wire).\n        For the entanglers, the product of i\'th and j\'th features is applied to the wire indices at the i\'th and j\'th\n        position in ``wires``.\n\n        For example, for ``wires=[2, 0, 1]`` the ``RZ`` block applies the first feature to wire 2,\n        the second feature to wire 0, and the third feature to wire 1.\n\n        Likewise, using the default pattern, the entangler block applies the product of the first and second\n        feature to the wire pair ``[2, 0]``, the product of the second and third feature to ``[2, 1]``, and so\n        forth.\n\n    """"""\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(features, msg=""\'features\' cannot be differentiable"")\n\n    expected_shape = (len(wires),)\n    check_shape(\n        features,\n        expected_shape,\n        msg=""\'features\' must be of shape {}; got {}"" """".format(expected_shape, get_shape(features)),\n    )\n\n    check_type(\n        n_repeats, [int], msg=""\'n_repeats\' must be an integer; got type {}"".format(type(n_repeats))\n    )\n\n    if pattern is None:\n        # default is an all-to-all pattern\n        pattern = [Wires(wire_pair) for wire_pair in combinations(wires, 2)]\n    else:\n        # do some checks\n        check_type(\n            pattern,\n            [Iterable, type(None)],\n            msg=""\'pattern\' must be a list of pairs of wires; got {}"".format(pattern),\n        )\n        shape = get_shape(pattern)\n        if len(shape) != 2 or shape[1] != 2:\n            raise ValueError(""\'pattern\' must be a list of pairs of wires; got {}"".format(pattern))\n\n        # convert wire pairs to Wires object\n        pattern = [Wires(wire_pair) for wire_pair in pattern]\n\n    #####################\n\n    for i in range(n_repeats):\n\n        # first block of Hadamards\n        broadcast(unitary=Hadamard, pattern=""single"", wires=wires)\n        # encode features into block of RZ rotations\n        broadcast(unitary=RZ, pattern=""single"", wires=wires, parameters=features)\n\n        # create new features for entangling block\n        products = []\n        for wire_pair in pattern:\n            # get the position of the wire indices in the array\n            idx1, idx2 = wires.indices(wire_pair)\n            # create products of parameters\n            products.append(features[idx1] * features[idx2])\n\n        broadcast(unitary=MultiRZ, pattern=pattern, wires=wires, parameters=products)\n'"
pennylane/templates/embeddings/qaoa.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``QAOAEmbedding`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import RX, RY, RZ, MultiRZ, Hadamard\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_is_in_options,\n    check_number_of_layers,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\ndef qaoa_feature_encoding_hamiltonian(features, wires):\n    """"""Implements the encoding Hamiltonian of the QAOA embedding.\n\n    Args:\n        features (array): array of features to encode\n        wires (Wires): wires that the template acts on\n    """"""\n\n    feature_encoding_wires = wires[: len(features)]\n    remaining_wires = wires[len(features) :]\n\n    broadcast(unitary=RX, pattern=""single"", wires=feature_encoding_wires, parameters=features)\n    broadcast(unitary=Hadamard, pattern=""single"", wires=remaining_wires)\n\n\ndef qaoa_ising_hamiltonian(weights, wires, local_fields):\n    """"""Implements the Ising-like Hamiltonian of the QAOA embedding.\n\n    Args:\n        weights (array): array of weights for one layer\n        wires (Wires): qubit indices that the template acts on\n        local_fields (str): gate implementing the local field\n    """"""\n\n    if len(wires) == 1:\n        weights_zz = []\n        weights_fields = weights\n\n    elif len(wires) == 2:\n        # for 2 wires the periodic boundary condition is dropped in broadcast\'s ""ring"" pattern\n        # only feed in 1 parameter\n        weights_zz = weights[:1]\n        weights_fields = weights[1:]\n\n    else:\n        weights_zz = weights[: len(wires)]\n        weights_fields = weights[len(wires) :]\n\n    # zz couplings\n    broadcast(unitary=MultiRZ, pattern=""ring"", wires=wires, parameters=weights_zz)\n    # local fields\n    broadcast(unitary=local_fields, pattern=""single"", wires=wires, parameters=weights_fields)\n\n\n@template\ndef QAOAEmbedding(features, weights, wires, local_field=""Y""):\n    r""""""\n    Encodes :math:`N` features into :math:`n>N` qubits, using a layered, trainable quantum\n    circuit that is inspired by the QAOA ansatz.\n\n    A single layer applies two circuits or ""Hamiltonians"": The first encodes the features, and the second is\n    a variational ansatz inspired by a 1-dimensional Ising model. The feature-encoding circuit associates features with\n    the angles of :class:`RX` rotations. The Ising ansatz consists of trainable two-qubit ZZ interactions\n    :math:`e^{-i \\frac{\\alpha}{2} \\sigma_z \\otimes \\sigma_z}` (in PennyLane represented by the :class:`~.MultiRZ` gate),\n    and trainable local fields :math:`e^{-i \\frac{\\beta}{2} \\sigma_{\\mu}}`, where :math:`\\sigma_{\\mu}`\n    can be chosen to be :math:`\\sigma_{x}`, :math:`\\sigma_{y}` or :math:`\\sigma_{z}`\n    (default choice is :math:`\\sigma_{y}` or the ``RY`` gate), and :math:`\\alpha, \\beta` are adjustable gate parameters.\n\n    The number of features has to be smaller or equal to the number of qubits. If there are fewer features than\n    qubits, the feature-encoding rotation is replaced by a Hadamard gate.\n\n    The argument ``weights`` contains an array of the :math:`\\alpha, \\beta` parameters for each layer.\n    The number of layers :math:`L` is derived from the first dimension of ``weights``, which has the following\n    shape:\n\n    * :math:`(L, 1)`, if the embedding acts on a single wire,\n    * :math:`(L, 3)`, if the embedding acts on two wires,\n    * :math:`(L, 2n)` else.\n\n    After the :math:`L` th layer, another set of feature-encoding :class:`RX` gates is applied.\n\n    This is an example for the full embedding circuit using 2 layers, 3 features, 4 wires, and ``RY`` local fields:\n\n    |\n\n    .. figure:: ../../_static/qaoa_layers.png\n        :align: center\n        :width: 60%\n        :target: javascript:void(0);\n\n    |\n\n    .. note::\n        ``QAOAEmbedding`` supports gradient computations with respect to both the ``features`` and the ``weights``\n        arguments. Note that trainable parameters need to be passed to the quantum node as positional arguments.\n\n    Args:\n        features (array): array of features to encode\n        weights (array): array of weights\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        local_field (str): type of local field used, one of ``\'X\'``, ``\'Y\'``, or ``\'Z\'``\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        The QAOA embedding encodes an :math:`n`-dimensional feature vector into at most :math:`n` qubits. The\n        embedding applies layers of a circuit, and each layer is defined by a set of weight parameters.\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import QAOAEmbedding\n\n            dev = qml.device(\'default.qubit\', wires=2)\n\n            @qml.qnode(dev)\n            def circuit(weights, f=None):\n                QAOAEmbedding(features=f, weights=weights, wires=range(2))\n                return qml.expval(qml.PauliZ(0))\n\n            features = [1., 2.]\n            layer1 = [0.1, -0.3, 1.5]\n            layer2 = [3.1, 0.2, -2.8]\n            weights = [layer1, layer2]\n\n            print(circuit(weights, f=features))\n\n        **Using parameter initialization functions**\n\n        The initial weight parameters can alternatively be generated by utility functions from the\n        ``pennylane.init`` module, for example using the function :func:`~.qaoa_embedding_normal`:\n\n        .. code-block:: python\n\n            from pennylane.init import qaoa_embedding_normal\n            weights = qaoa_embedding_normal(n_layers=2, n_wires=2, mean=0, std=0.2)\n\n\n        **Training the embedding**\n\n        The embedding is typically trained with respect to a given cost. For example, one can train it to\n        minimize the PauliZ expectation of the first qubit:\n\n        .. code-block:: python\n\n            o = GradientDescentOptimizer()\n            for i in range(10):\n                weights = o.step(lambda w : circuit(w, f=features), weights)\n                print(""Step "", i, "" weights = "", weights)\n\n\n        **Training the features**\n\n        In principle, also the features are trainable, which means that gradients with respect to feature values\n        can be computed. To train both weights and features, they need to be passed to the qnode as\n        positional arguments. If the built-in optimizer is used, they have to be merged to one input:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit2(pars):\n                weights = pars[0]\n                features = pars[1]\n                QAOAEmbedding(features=features, weights=weights, wires=range(2))\n                return qml.expval(qml.PauliZ(0))\n\n\n            features = [1., 2.]\n            weights = [[0.1, -0.3, 1.5], [3.1, 0.2, -2.8]]\n            pars = [weights, features]\n\n            o = GradientDescentOptimizer()\n            for i in range(10):\n                pars = o.step(circuit2, pars)\n                print(""Step "", i, "" weights = "", pars[0], "" features = "", pars[1])\n\n        **Local Fields**\n\n        While by default, ``RY`` gates are used as local fields, one may also choose ``local_field=\'Z\'`` or\n        ``local_field=\'X\'`` as hyperparameters of the embedding.\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit(weights, f=None):\n                QAOAEmbedding(features=f, weights=weights, wires=range(2), local_field=\'Z\')\n                return qml.expval(qml.PauliZ(0))\n\n        Choosing ``\'Z\'`` fields implements a QAOAEmbedding where the second Hamiltonian is a\n        1-dimensional Ising model.\n\n    """"""\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    expected_shape = (len(wires),)\n    check_shape(\n        features,\n        expected_shape,\n        bound=""max"",\n        msg=""\'features\' must be of shape {} or smaller; got {}""\n        """".format((len(wires),), get_shape(features)),\n    )\n\n    check_is_in_options(\n        local_field,\n        [""X"", ""Y"", ""Z""],\n        msg=""did not recognize option {} for \'local_field\'"" """".format(local_field),\n    )\n\n    repeat = check_number_of_layers([weights])\n\n    if len(wires) == 1:\n        expected_shape = (repeat, 1)\n        check_shape(\n            weights,\n            expected_shape,\n            msg=""\'weights\' must be of shape {}; got {}""\n            """".format(expected_shape, get_shape(features)),\n        )\n    elif len(wires) == 2:\n        expected_shape = (repeat, 3)\n        check_shape(\n            weights,\n            expected_shape,\n            msg=""\'weights\' must be of shape {}; got {}""\n            """".format(expected_shape, get_shape(features)),\n        )\n    else:\n        expected_shape = (repeat, 2 * len(wires))\n        check_shape(\n            weights,\n            expected_shape,\n            msg=""\'weights\' must be of shape {}; got {}""\n            """".format(expected_shape, get_shape(features)),\n        )\n\n    #####################\n\n    if local_field == ""Z"":\n        local_fields = RZ\n    elif local_field == ""X"":\n        local_fields = RX\n    else:\n        local_fields = RY\n\n    for l in range(repeat):\n        # apply alternating Hamiltonians\n        qaoa_feature_encoding_hamiltonian(features, wires)\n        qaoa_ising_hamiltonian(weights[l], wires, local_fields)\n\n    # repeat the feature encoding once more at the end\n    qaoa_feature_encoding_hamiltonian(features, wires)\n'"
pennylane/templates/embeddings/squeezing.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``SqueezingEmbedding`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import Squeezing\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_no_variable,\n    check_is_in_options,\n    get_shape,\n    check_type,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef SqueezingEmbedding(features, wires, method=""amplitude"", c=0.1):\n    r""""""Encodes :math:`N` features into the squeezing amplitudes :math:`r \\geq 0` or phases :math:`\\phi \\in [0, 2\\pi)`\n    of :math:`M` modes, where :math:`N\\leq M`.\n\n    The mathematical definition of the squeezing gate is given by the operator\n\n    .. math::\n\n        S(z) = \\exp\\left(\\frac{r}{2}\\left(e^{-i\\phi}\\a^2 -e^{i\\phi}{\\ad}^{2} \\right) \\right),\n\n    where :math:`\\a` and :math:`\\ad` are the bosonic creation and annihilation operators.\n\n    ``features`` has to be an iterable of at most ``len(wires)`` floats. If there are fewer entries in\n    ``features`` than wires, the circuit does not apply the remaining squeezing gates.\n\n    Args:\n        features (array): Array of features of size (N,)\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        method (str): ``\'phase\'`` encodes the input into the phase of single-mode squeezing, while\n            ``\'amplitude\'`` uses the amplitude\n        c (float): value of the phase of all squeezing gates if ``execution=\'amplitude\'``, or the\n            amplitude of all squeezing gates if ``execution=\'phase\'``\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(method, msg=""\'method\' cannot be differentiable"")\n    check_no_variable(c, msg=""\'c\' cannot be differentiable"")\n\n    check_type(c, [float, int], msg=""\'c\' must be of type float or integer; got {}"".format(type(c)))\n\n    expected_shape = (len(wires),)\n    check_shape(\n        features,\n        expected_shape,\n        bound=""max"",\n        msg=""\'features\' must be of shape {} or smaller; got {}""\n        """".format(expected_shape, get_shape(features)),\n    )\n\n    check_is_in_options(\n        method,\n        [""amplitude"", ""phase""],\n        msg=""did not recognize option {} for \'method\'"".format(method),\n    )\n\n    ##############\n\n    constants = [c] * len(features)\n\n    if method == ""amplitude"":\n        broadcast(\n            unitary=Squeezing,\n            pattern=""single"",\n            wires=wires,\n            parameters=list(zip(features, constants)),\n        )\n\n    elif method == ""phase"":\n        broadcast(\n            unitary=Squeezing,\n            pattern=""single"",\n            wires=wires,\n            parameters=list(zip(constants, features)),\n        )\n'"
pennylane/templates/layers/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nLayers are trainable templates that are typically repeated, using different adjustable parameters in each repetition.\nThey implement a transformation from a quantum state to another quantum state.\n""""""\n\nfrom .strongly_entangling import StronglyEntanglingLayers\nfrom .random import RandomLayers\nfrom .cv_neural_net import CVNeuralNetLayers\nfrom .simplified_two_design import SimplifiedTwoDesign\nfrom .basic_entangler import BasicEntanglerLayers\n'"
pennylane/templates/layers/basic_entangler.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``BasicEntanglerLayers`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import CNOT, RX\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_no_variable,\n    check_number_of_layers,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef BasicEntanglerLayers(weights, wires, rotation=None):\n    r""""""Layers consisting of one-parameter single-qubit rotations on each qubit, followed by a closed chain\n    or *ring* of CNOT gates.\n\n    The ring of CNOT gates connects every qubit with its neighbour,\n    with the last qubit being considered as a neighbour to the first qubit.\n\n    .. figure:: ../../_static/templates/layers/basic_entangler.png\n        :align: center\n        :width: 40%\n        :target: javascript:void(0);\n\n    The number of layers :math:`L` is determined by the first dimension of the argument ``weights``.\n    When using a single wire, the template only applies the single\n    qubit gates in each layer.\n\n    .. note::\n\n        This template follows the convention of dropping the entanglement between the last and the first\n        qubit when using only two wires, so the entangler is not repeated on the same wires.\n        In this case, only one CNOT gate is applied in each layer:\n\n        .. figure:: ../../_static/templates/layers/basic_entangler_2wires.png\n            :align: center\n            :width: 30%\n            :target: javascript:void(0);\n\n    Args:\n        weights (array[float]): array of weights with shape ``(L, len(wires))``, each weight is used as a parameter\n                                for the rotation\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        rotation (pennylane.ops.Operation): one-parameter single-qubit gate to use,\n                                            if ``None``, :class:`~pennylane.ops.RX` is used as default\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        The template is used inside a qnode:\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import BasicEntanglerLayers\n            from math import pi\n\n            n_wires = 3\n            dev = qml.device(\'default.qubit\', wires=n_wires)\n\n            @qml.qnode(dev)\n            def circuit(weights):\n                BasicEntanglerLayers(weights=weights, wires=range(n_wires))\n                return [qml.expval(qml.PauliZ(wires=i)) for i in range(n_wires)]\n\n        >>> circuit([[pi, pi, pi]])\n        [1., 1., -1.]\n\n        **Parameter initialization function**\n\n        The :mod:`~pennylane.init` module has two parameter initialization functions, ``basic_entangler_layers_normal``\n        and ``basic_entangler_layers_uniform``.\n\n        .. code-block:: python\n\n            from pennylane.init import basic_entangler_layers_normal\n\n            n_layers = 4\n            weights = basic_entangler_layers_normal(n_layers=n_layers, n_wires=n_wires)\n\n            circuit(weights)\n\n\n        **No periodic boundary for two wires**\n\n        When using two wires, the convention is to drop the periodic boundary condition.\n        This means that the connection from the second to the first wire is omitted.\n\n        .. code-block:: python\n\n            n_wires = 2\n            dev = qml.device(\'default.qubit\', wires=n_wires)\n\n            @qml.qnode(dev)\n            def circuit(weights):\n                BasicEntanglerLayers(weights=weights, wires=range(n_wires))\n                return [qml.expval(qml.PauliZ(wires=i)) for i in range(n_wires)]\n\n        >>> circuit([[pi, pi]])\n        [-1, 1]\n\n\n        **Changing the rotation gate**\n\n        Any single-qubit gate can be used as a rotation gate, as long as it only takes a single parameter. The default is the ``RX`` gate.\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit(weights):\n                BasicEntanglerLayers(weights=weights, wires=range(n_wires), rotation=qml.RZ)\n                return [qml.expval(qml.PauliZ(wires=i)) for i in range(n_wires)]\n\n        Accidentally using a gate that expects more parameters throws a\n        ``ValueError: Wrong number of parameters``.\n    """"""\n\n    #############\n    # Input checks\n\n    if rotation is None:\n        rotation = RX\n\n    wires = Wires(wires)\n\n    check_no_variable(rotation, msg=""\'rotation\' cannot be differentiable"")\n\n    repeat = check_number_of_layers([weights])\n\n    expected_shape = (repeat, len(wires))\n    check_shape(\n        weights,\n        expected_shape,\n        msg=""\'weights\' must be of shape {}; got {}"" """".format(expected_shape, get_shape(weights)),\n    )\n\n    ###############\n\n    for layer in range(repeat):\n\n        broadcast(unitary=rotation, pattern=""single"", wires=wires, parameters=weights[layer])\n        broadcast(unitary=CNOT, pattern=""ring"", wires=wires)\n'"
pennylane/templates/layers/cv_neural_net.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``CVNeuralNetLayers`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import Squeezing, Displacement, Kerr\nfrom pennylane.templates.subroutines import Interferometer\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import check_number_of_layers, check_shapes\nfrom pennylane.wires import Wires\n\n\ndef cv_neural_net_layer(\n    theta_1, phi_1, varphi_1, r, phi_r, theta_2, phi_2, varphi_2, a, phi_a, k, wires\n):\n    r""""""A single continuous-variable neural network layer.\n\n    The layer acts on the :math:`M` wires modes specified in ``wires``, and includes interferometers\n    of :math:`K=M(M-1)/2` beamsplitters.\n\n    Args:\n        theta_1 (array[float]): length :math:`(K, )` array of transmittivity angles for first interferometer\n        phi_1 (array[float]): length :math:`(K, )` array of phase angles for first interferometer\n        varphi_1 (array[float]): length :math:`(M, )` array of rotation angles to apply after first interferometer\n        r (array[float]): length :math:`(M, )` array of squeezing amounts for\n            :class:`~pennylane.ops.Squeezing` operations\n        phi_r (array[float]): length :math:`(M, )` array of squeezing angles for\n            :class:`~pennylane.ops.Squeezing` operations\n        theta_2 (array[float]): length :math:`(K, )` array of transmittivity angles for second interferometer\n        phi_2 (array[float]): length :math:`(K, )` array of phase angles for second interferometer\n        varphi_2 (array[float]): length :math:`(M, )` array of rotation angles to apply after second interferometer\n        a (array[float]): length :math:`(M, )` array of displacement magnitudes for\n            :class:`~pennylane.ops.Displacement` operations\n        phi_a (array[float]): length :math:`(M, )` array of displacement angles for\n            :class:`~pennylane.ops.Displacement` operations\n        k (array[float]): length :math:`(M, )` array of kerr parameters for :class:`~pennylane.ops.Kerr` operations\n        wires (Wires): wires that the template acts on\n    """"""\n    Interferometer(theta=theta_1, phi=phi_1, varphi=varphi_1, wires=wires)\n\n    broadcast(unitary=Squeezing, pattern=""single"", wires=wires, parameters=list(zip(r, phi_r)))\n\n    Interferometer(theta=theta_2, phi=phi_2, varphi=varphi_2, wires=wires)\n\n    broadcast(unitary=Displacement, pattern=""single"", wires=wires, parameters=list(zip(a, phi_a)))\n\n    broadcast(unitary=Kerr, pattern=""single"", wires=wires, parameters=k)\n\n\n@template\ndef CVNeuralNetLayers(\n    theta_1, phi_1, varphi_1, r, phi_r, theta_2, phi_2, varphi_2, a, phi_a, k, wires\n):\n    r""""""A sequence of layers of a continuous-variable quantum neural network,\n    as specified in `arXiv:1806.06871 <https://arxiv.org/abs/1806.06871>`_.\n\n    The layer consists\n    of interferometers, displacement and squeezing gates mimicking the linear transformation of\n    a neural network in the x-basis of the quantum system, and uses a Kerr gate\n    to introduce a \'quantum\' nonlinearity.\n\n    The layers act on the :math:`M` modes given in ``wires``,\n    and include interferometers of :math:`K=M(M-1)/2` beamsplitters. The different weight parameters\n    contain the weights for each layer. The number of layers :math:`L` is therefore derived\n    from the first dimension of ``weights``.\n\n    This example shows a 4-mode CVNeuralNet layer with squeezing gates :math:`S`, displacement gates :math:`D` and\n    Kerr gates :math:`K`. The two big blocks are interferometers of type\n    :mod:`pennylane.templates.layers.Interferometer`:\n\n    .. figure:: ../../_static/layer_cvqnn.png\n        :align: center\n        :width: 60%\n        :target: javascript:void(0);\n\n    .. note::\n       The CV neural network architecture includes :class:`~pennylane.ops.Kerr` operations.\n       Make sure to use a suitable device, such as the :code:`strawberryfields.fock`\n       device of the `PennyLane-SF <https://github.com/XanaduAI/pennylane-sf>`_ plugin.\n\n    Args:\n        theta_1 (array[float]): length :math:`(L, K)` array of transmittivity angles for first interferometer\n        phi_1 (array[float]): length :math:`(L, K)` array of phase angles for first interferometer\n        varphi_1 (array[float]): length :math:`(L, M)` array of rotation angles to apply after first interferometer\n        r (array[float]): length :math:`(L, M)` array of squeezing amounts for :class:`~pennylane.ops.Squeezing` operations\n        phi_r (array[float]): length :math:`(L, M)` array of squeezing angles for :class:`~pennylane.ops.Squeezing` operations\n        theta_2 (array[float]): length :math:`(L, K)` array of transmittivity angles for second interferometer\n        phi_2 (array[float]): length :math:`(L, K)` array of phase angles for second interferometer\n        varphi_2 (array[float]): length :math:`(L, M)` array of rotation angles to apply after second interferometer\n        a (array[float]): length :math:`(L, M)` array of displacement magnitudes for :class:`~pennylane.ops.Displacement` operations\n        phi_a (array[float]): length :math:`(L, M)` array of displacement angles for :class:`~pennylane.ops.Displacement` operations\n        k (array[float]): length :math:`(L, M)` array of kerr parameters for :class:`~pennylane.ops.Kerr` operations\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    n_wires = len(wires)\n    n_if = n_wires * (n_wires - 1) // 2\n    weights_list = [theta_1, phi_1, varphi_1, r, phi_r, theta_2, phi_2, varphi_2, a, phi_a, k]\n    repeat = check_number_of_layers(weights_list)\n\n    expected_shapes = [\n        (repeat, n_if),\n        (repeat, n_if),\n        (repeat, n_wires),\n        (repeat, n_wires),\n        (repeat, n_wires),\n        (repeat, n_if),\n        (repeat, n_if),\n        (repeat, n_wires),\n        (repeat, n_wires),\n        (repeat, n_wires),\n        (repeat, n_wires),\n    ]\n    check_shapes(weights_list, expected_shapes, msg=""wrong shape of weight input(s) detected"")\n\n    ###############\n\n    for l in range(repeat):\n        cv_neural_net_layer(\n            theta_1=theta_1[l],\n            phi_1=phi_1[l],\n            varphi_1=varphi_1[l],\n            r=r[l],\n            phi_r=phi_r[l],\n            theta_2=theta_2[l],\n            phi_2=phi_2[l],\n            varphi_2=varphi_2[l],\n            a=a[l],\n            phi_a=phi_a[l],\n            k=k[l],\n            wires=wires,\n        )\n'"
pennylane/templates/layers/random.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``RandomLayers`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nimport numpy as np\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import CNOT, RX, RY, RZ\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_no_variable,\n    check_type,\n    check_number_of_layers,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\ndef random_layer(weights, wires, ratio_imprim, imprimitive, rotations, seed):\n    r""""""A single random layer.\n\n    Args:\n        weights (array[float]): array of weights of shape ``(k,)``\n        wires (Wires): wires that the template acts on\n        ratio_imprim (float): value between 0 and 1 that determines the ratio of imprimitive to rotation gates\n        imprimitive (pennylane.ops.Operation): two-qubit gate to use, defaults to :class:`~pennylane.ops.CNOT`\n        rotations (list[pennylane.ops.Operation]): List of Pauli-X, Pauli-Y and/or Pauli-Z gates. The frequency\n            determines how often a particular rotation type is used. Defaults to the use of all three\n            rotations with equal frequency.\n        seed (int): seed to generate random architecture\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    i = 0\n    while i < len(weights):\n        if np.random.random() > ratio_imprim:\n            # Apply a random rotation gate to a random wire\n            gate = np.random.choice(rotations)\n            rnd_wire = wires.select_random(1)\n            gate(weights[i], wires=rnd_wire)\n            i += 1\n        else:\n            # Apply the imprimitive to two random wires\n            if len(wires) > 1:\n                rnd_wires = wires.select_random(2)\n                imprimitive(wires=rnd_wires)\n\n\n@template\ndef RandomLayers(weights, wires, ratio_imprim=0.3, imprimitive=CNOT, rotations=None, seed=42):\n    r""""""Layers of randomly chosen single qubit rotations and 2-qubit entangling gates, acting\n    on randomly chosen qubits.\n\n    .. warning::\n        This template uses random number generation inside qnodes. Find more\n        details about how to invoke the desired random behaviour in the ""Usage Details"" section below.\n\n    The argument ``weights`` contains the weights for each layer. The number of layers :math:`L` is therefore derived\n    from the first dimension of ``weights``.\n\n    The two-qubit gates of type ``imprimitive`` and the rotations are distributed randomly in the circuit.\n    The number of random rotations is derived from the second dimension of ``weights``. The number of\n    two-qubit gates is determined by ``ratio_imprim``. For example, a ratio of ``0.3`` with ``30`` rotations\n    will lead to the use of ``10`` two-qubit gates.\n\n    .. note::\n        If applied to one qubit only, this template will use no imprimitive gates.\n\n    This is an example of two 4-qubit random layers with four Pauli-Y/Pauli-Z rotations :math:`R_y, R_z`,\n    controlled-Z gates as imprimitives, as well as ``ratio_imprim=0.3``:\n\n    .. figure:: ../../_static/layer_rnd.png\n        :align: center\n        :width: 60%\n        :target: javascript:void(0);\n\n    Args:\n        weights (array[float]): array of weights of shape ``(L, k)``,\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        ratio_imprim (float): value between 0 and 1 that determines the ratio of imprimitive to rotation gates\n        imprimitive (pennylane.ops.Operation): two-qubit gate to use, defaults to :class:`~pennylane.ops.CNOT`\n        rotations (list[pennylane.ops.Operation]): List of Pauli-X, Pauli-Y and/or Pauli-Z gates. The frequency\n            determines how often a particular rotation type is used. Defaults to the use of all three\n            rotations with equal frequency.\n        seed (int): seed to generate random architecture, defaults to 42\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        **Default seed**\n\n        ``RandomLayers`` always uses a seed to initialize the construction of a random circuit. This means\n        that the template creates the same circuit every time it is called. If no seed is provided, the default\n        seed of ``42`` is used.\n\n        .. code-block:: python\n\n            import pennylane as qml\n            import numpy as np\n            from pennylane.templates.layers import RandomLayers\n\n            dev = qml.device(""default.qubit"", wires=2)\n            weights = [[0.1, -2.1, 1.4]]\n\n            @qml.qnode(dev)\n            def circuit1(weights):\n                RandomLayers(weights=weights, wires=range(2))\n                return qml.expval(qml.PauliZ(0))\n\n            @qml.qnode(dev)\n            def circuit2(weights):\n                RandomLayers(weights=weights, wires=range(2))\n                return qml.expval(qml.PauliZ(0))\n\n        >>> np.allclose(circuit1(weights), circuit2(weights))\n        >>> True\n\n        You can verify this by drawing the circuits.\n\n            >>> print(circuit1.draw())\n            >>>  0: \xe2\x94\x80\xe2\x94\x80RX(0.1)\xe2\x94\x80\xe2\x94\x80RX(-2.1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Z\xe2\x9f\xa9\n            ...  1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80RZ(1.4)\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n\n            >>> print(circuit2.draw())\n            >>>  0: \xe2\x94\x80\xe2\x94\x80RX(0.1)\xe2\x94\x80\xe2\x94\x80RX(-2.1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Z\xe2\x9f\xa9\n            ...  1: \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80RZ(1.4)\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n\n        **Changing the seed**\n\n        To change the randomly generated circuit architecture, you have to change the seed passed to the template.\n        For example, these two calls of ``RandomLayers`` *do not* create the same circuit:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit_9(weights):\n                RandomLayers(weights=weights, wires=range(2), seed=9)\n                return qml.expval(qml.PauliZ(0))\n\n            @qml.qnode(dev)\n            def circuit_12(weights):\n                RandomLayers(weights=weights, wires=range(2), seed=12)\n                return qml.expval(qml.PauliZ(0))\n\n        >>> np.allclose(circuit_9(weights), circuit_12(weights))\n        >>> False\n\n        >>> print(circuit_9.draw())\n        >>>  0: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80RY(-2.1)\xe2\x94\x80\xe2\x94\x80RX(1.4)\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Z\xe2\x9f\xa9\n        ...  1: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80RX(0.1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n\n        >>> print(circuit_12.draw())\n        >>>  0: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80RX(-2.1)\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadC\xe2\x94\x80\xe2\x94\x80\xe2\x95\xadX\xe2\x94\x80\xe2\x94\x80RZ(1.4)\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4 \xe2\x9f\xa8Z\xe2\x9f\xa9\n        ...  1: \xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80RZ(0.1)\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0X\xe2\x94\x80\xe2\x94\x80\xe2\x95\xb0C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n\n\n        **Automatically creating random circuits**\n\n        To automate the process of creating different circuits with ``RandomLayers``,\n        you can set ``seed=None`` to avoid specifying a seed. However, in this case care needs\n        to be taken. In the default setting, a quantum node is **mutable**, which means that the quantum function is\n        re-evaluated every time it is called. This means that the circuit is re-constructed from scratch\n        each time you call the qnode:\n\n        .. code-block:: python\n\n            @qml.qnode(dev)\n            def circuit_rnd(weights):\n                RandomLayers(weights=weights, wires=range(2), seed=None)\n                return qml.expval(qml.PauliZ(0))\n\n            first_call = circuit_rnd(weights)\n            second_call = circuit_rnd(weights)\n\n        >>> np.allclose(first_call, second_call)\n        >>> False\n\n        This can be rectified by making the quantum node **immutable**.\n\n        .. code-block:: python\n\n            @qml.qnode(dev, mutable=False)\n            def circuit_rnd(weights):\n                RandomLayers(weights=weights, wires=range(2), seed=None)\n                return qml.expval(qml.PauliZ(0))\n\n            first_call = circuit_rnd(weights)\n            second_call = circuit_rnd(weights)\n\n        >>> np.allclose(first_call, second_call)\n        >>> True\n    """"""\n    if seed is not None:\n        np.random.seed(seed)\n\n    if rotations is None:\n        rotations = [RX, RY, RZ]\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(ratio_imprim, msg=""\'ratio_imprim\' cannot be differentiable"")\n    check_no_variable(imprimitive, msg=""\'imprimitive\' cannot be differentiable"")\n    check_no_variable(rotations, msg=""\'rotations\' cannot be differentiable"")\n    check_no_variable(seed, msg=""\'seed\' cannot be differentiable"")\n\n    repeat = check_number_of_layers([weights])\n    n_rots = get_shape(weights)[1]\n\n    expected_shape = (repeat, n_rots)\n    check_shape(\n        weights,\n        expected_shape,\n        msg=""\'weights\' must be of shape {}; got {}"" """".format(expected_shape, get_shape(weights)),\n    )\n\n    check_type(\n        ratio_imprim,\n        [float, type(None)],\n        msg=""\'ratio_imprim\' must be a float; got {}"".format(ratio_imprim),\n    )\n    check_type(n_rots, [int, type(None)], msg=""\'n_rots\' must be an integer; got {}"".format(n_rots))\n    # TODO: Check that \'rotations\' contains operations\n    check_type(\n        rotations,\n        [list, type(None)],\n        msg=""\'rotations\' must be a list of PennyLane operations; got {}"" """".format(rotations),\n    )\n    check_type(seed, [int, type(None)], msg=""\'seed\' must be an integer; got {}."".format(seed))\n\n    ###############\n\n    for l in range(repeat):\n        random_layer(\n            weights=weights[l],\n            wires=wires,\n            ratio_imprim=ratio_imprim,\n            imprimitive=imprimitive,\n            rotations=rotations,\n            seed=seed,\n        )\n'"
pennylane/templates/layers/simplified_two_design.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``SimplifiedTwoDesign`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane import numpy as np\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import CZ, RY\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_number_of_layers,\n    check_type,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef entangler(par1, par2, wires):\n    """"""Implements a two qubit unitary consisting of a controlled-Z entangler and Pauli-Y rotations.\n\n    Args:\n         par1 (float or qml.Variable): parameter of first Pauli-Y rotation\n         par2 (float or qml.Variable): parameter of second Pauli-Y rotation\n         wires (Wires): two wire indices that unitary acts on\n    """"""\n\n    CZ(wires=wires)\n    RY(par1, wires=wires[0])\n    RY(par2, wires=wires[1])\n\n\n@template\ndef SimplifiedTwoDesign(initial_layer_weights, weights, wires):\n    r""""""\n    Layers consisting of a simplified 2-design architecture of Pauli-Y rotations and controlled-Z entanglers\n    proposed in `Cerezo et al. (2020) <https://arxiv.org/abs/2001.00550>`_.\n\n    A 2-design is an ensemble of unitaries whose statistical properties are the same as sampling random unitaries\n    with respect to the Haar measure up to the first 2 moments.\n\n    The template is not a strict 2-design, since\n    it does not consist of universal 2-qubit gates as building blocks, but has been shown in\n    `Cerezo et al. (2020) <https://arxiv.org/abs/2001.00550>`_ to exhibit important properties to study ""barren plateaus""\n    in quantum optimization landscapes.\n\n    The template starts with an initial layer of single qubit Pauli-Y rotations, before the main\n    :math:`L` layers are applied. The basic building block of the main layers are controlled-Z entanglers\n    followed by a pair of Pauli-Y rotation gates (one for each wire).\n    Each layer consists of an ""even"" part whose entanglers start with the first qubit,\n    and an ""odd"" part that starts with the second qubit.\n\n    This is an example of two layers, including the initial layer:\n\n    .. figure:: ../../_static/templates/layers/simplified_two_design.png\n        :align: center\n        :width: 40%\n        :target: javascript:void(0);\n\n    |\n\n    The argument ``initial_layer_weights`` contains the rotation angles of the initial layer of Pauli-Y rotations,\n    while ``weights`` contains the pairs of Pauli-Y rotation angles of the respective layers. Each layer takes\n    :math:`\\lfloor M/2 \\rfloor + \\lfloor (M-1)/2 \\rfloor = M-1` pairs of angles, where :math:`M` is the number of wires.\n    The number of layers :math:`L` is derived from the first dimension of ``weights``.\n\n    Args:\n        initial_layer_weights (array[float]): array of weights for the initial rotation block, shape ``(M,)``\n        weights (array[float]): array of rotation angles for the layers, shape ``(L, M-1, 2)``\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        template - here shown for two layers - is used inside a :class:`~.QNode`:\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import SimplifiedTwoDesign\n            from math import pi\n\n            n_wires = 3\n            dev = qml.device(\'default.qubit\', wires=n_wires)\n\n            @qml.qnode(dev)\n            def circuit(init_weights, weights):\n                SimplifiedTwoDesign(initial_layer_weights=init_weights, weights=weights, wires=range(n_wires))\n                return [qml.expval(qml.PauliZ(wires=i)) for i in range(n_wires)]\n\n            init_weights = [pi, pi, pi]\n            weights_layer1 = [[0., pi],\n                              [0., pi]]\n            weights_layer2 = [[pi, 0.],\n                              [pi, 0.]]\n            weights = [weights_layer1, weights_layer2]\n\n            >>> circuit(init_weights, weights)\n            [1., -1., 1.]\n\n        **Parameter initialization function**\n\n        The :mod:`~pennylane.init` module contains four parameter initialization functions:\n\n        * ``simplified_two_design_initial_layer_normal``\n        * ``simplified_two_design_initial_layer_uniform``\n        * ``simplified_two_design_weights_normal``.\n        * ``simplified_two_design_weights_uniform``.\n\n        They can be used as follows:\n\n        .. code-block:: python\n\n            from pennylane.init import (simplified_two_design_initial_layer_normal,\n                                        simplified_two_design_weights_normal)\n\n            n_layers = 4\n            init_weights = simplified_two_design_initial_layer_normal(n_wires)\n            weights = simplified_two_design_weights_normal(n_layers, n_wires)\n\n            >>> circuit(initial_layer_weights, weights)\n\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    repeat = check_number_of_layers([weights])\n\n    check_type(\n        initial_layer_weights,\n        [list, np.ndarray],\n        msg=""\'initial_layer_weights\' must be of type list or np.ndarray; got type {}"".format(\n            type(initial_layer_weights)\n        ),\n    )\n    check_type(\n        weights,\n        [list, np.ndarray],\n        msg=""\'weights\' must be of type list or np.ndarray; got type {}"".format(type(weights)),\n    )\n\n    expected_shape_initial = (len(wires),)\n    check_shape(\n        initial_layer_weights,\n        expected_shape_initial,\n        msg=""\'initial_layer_weights\' must be of shape {}; got {}""\n        """".format(expected_shape_initial, get_shape(initial_layer_weights)),\n    )\n\n    if len(wires) in [0, 1]:\n        expected_shape_weights = (0,)\n    else:\n        expected_shape_weights = (repeat, len(wires) - 1, 2)\n\n    check_shape(\n        weights,\n        expected_shape_weights,\n        msg=""\'weights\' must be of shape {}; got {}""\n        """".format(expected_shape_weights, get_shape(weights)),\n    )\n\n    ###############\n    # initial rotations\n    broadcast(unitary=RY, pattern=""single"", wires=wires, parameters=initial_layer_weights)\n\n    # alternate layers\n    for layer in range(repeat):\n\n        # even layer\n        weights_even = weights[layer][: len(wires) // 2]\n        broadcast(unitary=entangler, pattern=""double"", wires=wires, parameters=weights_even)\n\n        # odd layer\n        weights_odd = weights[layer][len(wires) // 2 :]\n        broadcast(unitary=entangler, pattern=""double_odd"", wires=wires, parameters=weights_odd)\n'"
pennylane/templates/layers/strongly_entangling.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``StronglyEntanglingLayers`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import CNOT, Rot\nfrom pennylane.templates import broadcast\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_no_variable,\n    check_type,\n    check_number_of_layers,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\ndef strongly_entangling_layer(weights, wires, r, imprimitive):\n    r""""""A layer applying rotations on each qubit followed by cascades of 2-qubit entangling gates.\n\n    Args:\n        weights (array[float]): array of weights of shape ``(len(wires), 3)``\n        wires (Wires): wires that the template acts on\n        r (int): range of the imprimitive gates of this layer, defaults to 1\n        imprimitive (pennylane.ops.Operation): two-qubit gate to use, defaults to :class:`~pennylane.ops.CNOT`\n    """"""\n\n    broadcast(unitary=Rot, pattern=""single"", wires=wires, parameters=weights)\n\n    n_wires = len(wires)\n    if n_wires > 1:\n        for i in range(n_wires):\n            act_on = wires.subset([i, i + r], periodic_boundary=True)\n            act_on = act_on.tolist()  # Todo: remove when operator takes Wires object\n            imprimitive(wires=act_on)\n\n\n@template\ndef StronglyEntanglingLayers(weights, wires, ranges=None, imprimitive=CNOT):\n    r""""""Layers consisting of single qubit rotations and entanglers, inspired by the circuit-centric classifier design\n    `arXiv:1804.00633 <https://arxiv.org/abs/1804.00633>`_.\n\n    The argument ``weights`` contains the weights for each layer. The number of layers :math:`L` is therefore derived\n    from the first dimension of ``weights``.\n\n    The 2-qubit gates, whose type is specified by the ``imprimitive`` argument,\n    act chronologically on the :math:`M` wires, :math:`i = 1,...,M`. The second qubit of each gate is given by\n    :math:`(i+r)\\mod M`, where :math:`r` is a  hyperparameter called the *range*, and :math:`0 < r < M`.\n    If applied to one qubit only, this template will use no imprimitive gates.\n\n    This is an example of two 4-qubit strongly entangling layers (ranges :math:`r=1` and :math:`r=2`, respectively) with\n    rotations :math:`R` and CNOTs as imprimitives:\n\n    .. figure:: ../../_static/layer_sec.png\n        :align: center\n        :width: 60%\n        :target: javascript:void(0);\n\n    Args:\n\n        weights (array[float]): array of weights of shape ``(:math:`L`, :math:`M`, 3)``\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        ranges (Sequence[int]): sequence determining the range hyperparameter for each subsequent layer; if None\n                                using :math:`r=l \\mod M` for the :math:`l`th layer and :math:`M` wires.\n        imprimitive (pennylane.ops.Operation): two-qubit gate to use, defaults to :class:`~pennylane.ops.CNOT`\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(ranges, msg=""\'ranges\' cannot be differentiable"")\n    check_no_variable(imprimitive, msg=""\'imprimitive\' cannot be differentiable"")\n\n    repeat = check_number_of_layers([weights])\n\n    expected_shape = (repeat, len(wires), 3)\n    check_shape(\n        weights,\n        expected_shape,\n        msg=""\'weights\' must be of shape {}; got {}"" """".format(expected_shape, get_shape(weights)),\n    )\n\n    if len(wires) > 1:\n        if ranges is None:\n            # tile ranges with iterations of range(1, n_wires)\n            ranges = [(l % (len(wires) - 1)) + 1 for l in range(repeat)]\n\n        expected_shape = (repeat,)\n        check_shape(\n            ranges,\n            expected_shape,\n            msg=""\'ranges\' must be of shape {}; got {}""\n            """".format(expected_shape, get_shape(weights)),\n        )\n\n        check_type(ranges, [list], msg=""\'ranges\' must be a list; got {}"" """".format(ranges))\n        for r in ranges:\n            check_type(\n                r, [int], msg=""\'ranges\' must be a list of integers; got {}"" """".format(ranges)\n            )\n        if any((r >= len(wires) or r == 0) for r in ranges):\n            raise ValueError(\n                ""the range for all layers needs to be smaller than the number of ""\n                ""qubits; got ranges {}."".format(ranges)\n            )\n    else:\n        ranges = [0] * repeat\n\n    ###############\n\n    for l in range(repeat):\n\n        strongly_entangling_layer(\n            weights=weights[l], wires=wires, r=ranges[l], imprimitive=imprimitive\n        )\n'"
pennylane/templates/state_preparations/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nState preperations are templates that prepare a given quantum state,\nby decomposing it into elementary operations.\n""""""\n\nfrom .mottonen import MottonenStatePreparation\nfrom .basis import BasisStatePreparation\nfrom .arbitrary_state_preparation import ArbitraryStatePreparation\n'"
pennylane/templates/state_preparations/arbitrary_state_preparation.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``ArbitraryStatePreparation`` template.\n""""""\nimport functools\nimport pennylane as qml\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import check_shape, get_shape\nfrom pennylane.wires import Wires\n\n\n@functools.lru_cache()\ndef _state_preparation_pauli_words(num_wires):\n    """"""Pauli words necessary for a state preparation.\n\n    Args:\n        num_wires (int): Number of wires of the state preparation\n\n    Returns:\n        List[str]: List of all necessary Pauli words for the state preparation\n    """"""\n    if num_wires == 1:\n        return [""X"", ""Y""]\n\n    sub_pauli_words = _state_preparation_pauli_words(num_wires - 1)\n    sub_id = ""I"" * (num_wires - 1)\n\n    single_qubit_words = [""X"" + sub_id, ""Y"" + sub_id]\n    multi_qubit_words = list(map(lambda word: ""I"" + word, sub_pauli_words)) + list(\n        map(lambda word: ""X"" + word, sub_pauli_words)\n    )\n\n    return single_qubit_words + multi_qubit_words\n\n\n@template\ndef ArbitraryStatePreparation(weights, wires):\n    """"""Implements an arbitrary state preparation on the specified wires.\n\n    An arbitrary state on :math:`n` wires is parametrized by :math:`2^{n+1} - 2`\n    independent real parameters. This templates uses Pauli word rotations to\n    parametrize the unitary.\n\n    **Example**\n\n    ArbitraryStatePreparation can be used to train state preparations,\n    for example using a circuit with some measurement observable ``H``:\n\n    .. code-block:: python\n\n        dev = qml.device(""default.qubit"", wires=4)\n\n        @qml.qnode(dev)\n        def vqe(weights):\n            qml.ArbitraryStatePreparations(weights, wires=[0, 1, 2, 3])\n\n            return qml.expval(qml.Hermitian(H, wires=[0, 1, 2, 3]))\n\n    Args:\n        weights (array[float]): The angles of the Pauli word rotations, needs to have length :math:`2^(n+1) - 2`\n            where :math:`n` is the number of wires the template acts upon.\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n    """"""\n\n    wires = Wires(wires)\n\n    n_wires = len(wires)\n    expected_shape = (2 ** (n_wires + 1) - 2,)\n    check_shape(\n        weights,\n        expected_shape,\n        msg=""\'weights\' must be of shape {}; got {}."" """".format(expected_shape, get_shape(weights)),\n    )\n\n    wires = wires.tolist()  # Todo: remove when ops take Wires object\n\n    for i, pauli_word in enumerate(_state_preparation_pauli_words(len(wires))):\n        qml.PauliRot(weights[i], pauli_word, wires=wires)\n'"
pennylane/templates/state_preparations/basis.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``BasisStatePreparation`` template.\n""""""\n\nimport pennylane as qml\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import check_no_variable, check_shape, get_shape\nfrom pennylane.wires import Wires\n\n\n@template\ndef BasisStatePreparation(basis_state, wires):\n    r""""""\n    Prepares a basis state on the given wires using a sequence of Pauli X gates.\n\n    .. warning::\n\n        ``basis_state`` influences the circuit architecture and is therefore incompatible with\n        gradient computations. Ensure that ``basis_state`` is not passed to the qnode by positional\n        arguments.\n\n    Args:\n        basis_state (array): Input array of shape ``(N,)``, where N is the number of wires\n            the state preparation acts on. ``N`` must be smaller or equal to the total\n            number of wires of the device.\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    ######################\n    # Input checks\n\n    wires = Wires(wires)\n\n    expected_shape = (len(wires),)\n    check_shape(\n        basis_state,\n        expected_shape,\n        msg="" \'basis_state\' must be of shape {}; got {}.""\n        """".format(expected_shape, get_shape(basis_state)),\n    )\n\n    # basis_state cannot be trainable\n    check_no_variable(\n        basis_state,\n        msg=""\'basis_state\' cannot be differentiable; must be passed as a keyword argument ""\n        ""to the quantum node"",\n    )\n\n    # basis_state is guaranteed to be a list of binary values\n    if any([b not in [0, 1] for b in basis_state]):\n        raise ValueError(\n            ""\'basis_state\' must only contain values of 0 and 1; got {}"".format(basis_state)\n        )\n\n    ######################\n\n    for wire, state in zip(wires, basis_state):\n        if state == 1:\n            qml.PauliX(wire)\n'"
pennylane/templates/state_preparations/mottonen.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``MottonenStatePreparation`` template.\n""""""\nimport math\nimport numpy as np\nfrom scipy import sparse\n\nimport pennylane as qml\n\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import check_shape, get_shape\nfrom pennylane.variable import Variable\nfrom pennylane.wires import Wires\n\n\n# pylint: disable=len-as-condition,arguments-out-of-order\ndef gray_code(rank):\n    """"""Generates the Gray code of given rank.\n\n    Args:\n        rank (int): rank of the Gray code (i.e. number of bits)\n    """"""\n\n    def gray_code_recurse(g, rank):\n        k = len(g)\n        if rank <= 0:\n            return\n\n        for i in range(k - 1, -1, -1):\n            char = ""1"" + g[i]\n            g.append(char)\n        for i in range(k - 1, -1, -1):\n            g[i] = ""0"" + g[i]\n\n        gray_code_recurse(g, rank - 1)\n\n    g = [""0"", ""1""]\n    gray_code_recurse(g, rank - 1)\n\n    return g\n\n\ndef _matrix_M_entry(row, col):\n    """"""Returns one entry for the matrix that maps alpha to theta.\n\n    Args:\n        row (int): one-based row number\n        col (int): one-based column number\n\n    Returns:\n        (float): transformation matrix entry at given row and column\n    """"""\n    # (col >> 1) ^ col is the Gray code of col\n    b_and_g = row & ((col >> 1) ^ col)\n    sum_of_ones = 0\n    while b_and_g > 0:\n        if b_and_g & 0b1:\n            sum_of_ones += 1\n\n        b_and_g = b_and_g >> 1\n\n    return (-1) ** sum_of_ones\n\n\ndef _compute_theta(alpha):\n    """"""Calculates the rotation angles from the alpha vector.\n\n    Args:\n        alpha (array[float]): alpha parameters\n\n    Returns:\n        (array[float]): rotation angles theta\n    """"""\n    k = np.log2(alpha.shape[0])\n    factor = 2 ** (-k)\n\n    theta = sparse.dok_matrix(alpha.shape, dtype=np.float64)  # type: sparse.dok_matrix\n\n    for row in range(alpha.shape[0]):\n        # Use transpose of M:\n        entry = sum([_matrix_M_entry(col, row) * a for (col, _), a in alpha.items()])\n        entry *= factor\n        if abs(entry) > 1e-6:\n            theta[row, 0] = entry\n\n    return theta\n\n\ndef _uniform_rotation_dagger(gate, alpha, control_wires, target_wire):\n    """"""Applies a given inverse rotation to the target qubit\n    that is uniformly controlled by the control qubits.\n\n    Args:\n        gate (~.Operation): gate to be applied, needs to have exactly\n            one parameter\n        alpha (array[float]): alpha parameters\n        control_wires (array[int]): wires that act as control\n        target_wire (int): wire that acts as target\n    """"""\n\n    theta = _compute_theta(alpha)  # type: sparse.dok_matrix\n\n    gray_code_rank = len(control_wires)\n\n    if gray_code_rank == 0:\n        gate(theta[0, 0], wires=[target_wire])\n        return\n\n    code = gray_code(gray_code_rank)\n    num_selections = len(code)\n\n    control_indices = [\n        int(np.log2(int(code[i], 2) ^ int(code[(i + 1) % num_selections], 2)))\n        for i in range(num_selections)  # TODO: re-asses for nonconsecutive wires\n    ]\n\n    for i, control_index in enumerate(control_indices):\n        gate(theta[i, 0], wires=[target_wire])\n        qml.CNOT(wires=[control_wires[control_index], target_wire])\n\n\ndef _uniform_rotation_z_dagger(alpha, control_wires, target_wire):\n    """"""Applies the inverse of a Z rotation to the target qubit\n    that is uniformly controlled by the control qubits.\n\n    Args:\n        alpha (array[float]): alpha parameters\n        control_wires (array[int]): wires that act as control\n        target_wire (int): wire that acts as target\n    """"""\n\n    _uniform_rotation_dagger(qml.RZ, alpha, control_wires, target_wire)\n\n\ndef _uniform_rotation_y_dagger(alpha, control_wires, target_wire):\n    """"""Applies the inverse of a Y rotation to the target qubit\n    that is uniformly controlled by the control qubits.\n\n    Args:\n        alpha (array[float]): alpha parameters\n        control_wires (array[int]): wires that act as control\n        target_wire (int): wire that acts as target\n    """"""\n\n    _uniform_rotation_dagger(qml.RY, alpha, control_wires, target_wire)\n\n\ndef _get_alpha_z(omega, n, k):\n    r""""""Computes the rotation angles alpha for the Z rotations.\n\n    Args:\n        omega (float): phase of the input\n        n (int): total number of qubits\n        k (int): index of current qubit\n\n    Returns:\n        scipy.sparse.dok_matrix[np.float64]: a sparse vector representing :math:`\\alpha^z_k`\n    """"""\n    alpha_z_k = sparse.dok_matrix((2 ** (n - k), 1), dtype=np.float64)\n\n    for (i, _), om in omega.items():\n        i += 1\n        j = int(np.ceil(i * 2 ** (-k)))\n        s_condition = 2 ** (k - 1) * (2 * j - 1)\n        s_i = 1.0 if i > s_condition else -1.0\n        alpha_z_k[j - 1, 0] = alpha_z_k[j - 1, 0] + s_i * om / 2 ** (k - 1)\n\n    return alpha_z_k\n\n\ndef _get_alpha_y(a, n, k):\n    r""""""Computes the rotation angles alpha for the Y rotations.\n\n    Args:\n        omega (float): phase of the input\n        n (int): total number of qubits\n        k (int): index of current qubit\n\n    Returns:\n        scipy.sparse.dok_matrix[np.float64]: a sparse vector representing :math:`\\alpha^y_k`\n    """"""\n\n    alpha = sparse.dok_matrix((2 ** (n - k), 1), dtype=np.float64)\n\n    numerator = sparse.dok_matrix((2 ** (n - k), 1), dtype=np.float64)\n    denominator = sparse.dok_matrix((2 ** (n - k), 1), dtype=np.float64)\n\n    for (i, _), e in a.items():\n        j = int(math.ceil((i + 1) / 2 ** k))\n        l = (i + 1) - (2 * j - 1) * 2 ** (k - 1)\n        is_part_numerator = 1 <= l <= 2 ** (k - 1)\n\n        if is_part_numerator:\n            numerator[j - 1, 0] += e * e\n        denominator[j - 1, 0] += e * e\n\n    for (j, _), e in numerator.items():\n        numerator[j, 0] = math.sqrt(e)\n    for (j, _), e in denominator.items():\n        denominator[j, 0] = 1 / math.sqrt(e)\n\n    pre_alpha = numerator.multiply(denominator)  # type: sparse.csr_matrix\n    for (j, _), e in pre_alpha.todok().items():\n        alpha[j, 0] = 2 * np.arcsin(e)\n\n    return alpha\n\n\n@template\ndef MottonenStatePreparation(state_vector, wires):\n    r""""""\n    Prepares an arbitrary state on the given wires using a decomposition into gates developed\n    by M\xc3\xb6tt\xc3\xb6nen et al. (Quantum Info. Comput., 2005).\n\n    The state is prepared via a sequence\n    of ""uniformly controlled rotations"". A uniformly controlled rotation on a target qubit is\n    composed from all possible controlled rotations on said qubit and can be used to address individual\n    elements of the state vector. In the work of Mottonen et al., the inverse of their state preparation\n    is constructed by first equalizing the phases of the state vector via uniformly controlled Z rotations\n    and then rotating the now real state vector into the direction of the state :math:`|0\\rangle` via\n    uniformly controlled Y rotations.\n\n    This code is adapted from code written by Carsten Blank for PennyLane-Qiskit.\n\n    Args:\n        state_vector (array): Input array of shape ``(2^N,)``, where N is the number of wires\n            the state preparation acts on. ``N`` must be smaller or equal to the total\n            number of wires.\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    ###############\n    # Input checks\n\n    wires = Wires(wires)\n\n    n_wires = len(wires)\n    expected_shape = (2 ** n_wires,)\n    check_shape(\n        state_vector,\n        expected_shape,\n        msg=""\'state_vector\' must be of shape {}; got {}.""\n        """".format(expected_shape, get_shape(state_vector)),\n    )\n\n    # check if state_vector is normalized\n    if isinstance(state_vector[0], Variable):\n        state_vector_values = [s.val for s in state_vector]\n        norm = np.sum(np.abs(state_vector_values) ** 2)\n    else:\n        norm = np.sum(np.abs(state_vector) ** 2)\n    if not np.isclose(norm, 1.0, atol=1e-3):\n        raise ValueError(""\'state_vector\' has to be of length 1.0, got {}"".format(norm))\n\n    #######################\n\n    # Change ordering of indices, original code was for IBM machines\n    state_vector = np.array(state_vector).reshape([2] * n_wires).T.flatten()[:, np.newaxis]\n    state_vector = sparse.dok_matrix(state_vector)\n\n    a = sparse.dok_matrix(state_vector.shape)\n    omega = sparse.dok_matrix(state_vector.shape)\n\n    for (i, j), v in state_vector.items():\n        if isinstance(v, Variable):\n            a[i, j] = np.absolute(v.val)\n            omega[i, j] = np.angle(v.val)\n        else:\n            a[i, j] = np.absolute(v)\n            omega[i, j] = np.angle(v)\n    # This code is directly applying the inverse of Carsten Blank\'s\n    # code to avoid inverting at the end\n\n    # Apply y rotations\n    for k in range(n_wires, 0, -1):  # Todo: use actual wire ordering!\n        alpha_y_k = _get_alpha_y(a, n_wires, k)  # type: sparse.dok_matrix\n        control = wires[k:]\n        target = wires[k - 1]\n        _uniform_rotation_y_dagger(alpha_y_k, control, target)\n\n    # Apply z rotations\n    for k in range(n_wires, 0, -1):  # Todo: use actual wire ordering!\n        alpha_z_k = _get_alpha_z(omega, n_wires, k)\n        control = wires[k:]\n        target = wires[k - 1]\n        if len(alpha_z_k) > 0:\n            _uniform_rotation_z_dagger(alpha_z_k, control, target)\n'"
pennylane/templates/subroutines/__init__.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nSubroutines are the most basic template, consisting of a collection of quantum operations, and not fulfilling\nany of the characteristics of other templates (i.e. to prepare a specific state, to be repeated or to encode features).\n""""""\n\nfrom .arbitrary_unitary import ArbitraryUnitary\nfrom .double_excitation_unitary import DoubleExcitationUnitary\nfrom .interferometer import Interferometer\nfrom .single_excitation_unitary import SingleExcitationUnitary\nfrom .uccsd import UCCSD\n'"
pennylane/templates/subroutines/arbitrary_unitary.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``ArbitraryUnitary`` template.\n""""""\nimport pennylane as qml\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import check_shape, get_shape\nfrom pennylane.wires import Wires\n\n_PAULIS = [""I"", ""X"", ""Y"", ""Z""]\n\n\ndef _tuple_to_word(index_tuple):\n    """"""Convert an integer tuple to the corresponding Pauli word.\n\n    The Pauli operators are converted as ``0 -> I``, ``1 -> X``,\n    ``2 -> Y``, ``3 -> Z``.\n\n    Args:\n        index_tuple (Tuple[int]): An integer tuple describing the Pauli word\n\n    Returns:\n        str: The corresponding Pauli word\n    """"""\n    return """".join([_PAULIS[i] for i in index_tuple])\n\n\ndef _n_k_gray_code(n, k, start=0):\n    """"""Iterates over a full n-ary Gray code with k digits.\n\n    Args:\n        n (int): Base of the Gray code. Needs to be greater than one.\n        k (int): Number of digits of the Gray code. Needs to be greater than zero.\n        start (int, optional): Optional start of the Gray code. The generated code\n            will be shorter as the code does not wrap. Defaults to 0.\n    """"""\n    for i in range(start, n ** k):\n        codeword = [0] * k\n\n        base_repesentation = []\n        val = i\n\n        for j in range(k):\n            base_repesentation.append(val % n)\n            val //= n\n\n        shift = 0\n        for j in reversed(range(k)):\n            codeword[j] = (base_repesentation[j] + shift) % n\n            shift += n - codeword[j]\n\n        yield codeword\n\n\ndef _all_pauli_words_but_identity(num_wires):\n    # Start at 1 to ignore identity\n    yield from (_tuple_to_word(idx_tuple) for idx_tuple in _n_k_gray_code(4, num_wires, start=1))\n\n\n@template\ndef ArbitraryUnitary(weights, wires):\n    """"""Implements an arbitrary unitary on the specified wires.\n\n    An arbitrary unitary on :math:`n` wires is parametrized by :math:`4^n - 1`\n    independent real parameters. This templates uses Pauli word rotations to\n    parametrize the unitary.\n\n    **Example**\n\n    ArbitraryUnitary can be used as a building block, e.g. to parametrize arbitrary\n    two-qubit operations in a circuit:\n\n    .. code-block:: python\n\n        @qml.template\n        def arbitrary_nearest_neighbour_interaction(weights, wires):\n            qml.broadcast(unitary=ArbitraryUnitary, pattern=""double"", wires=wires, params=weights)\n\n    Args:\n        weights (array[float]): The angles of the Pauli word rotations, needs to have length :math:`4^n - 1`\n            where :math:`n` is the number of wires the template acts upon.\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n    """"""\n    wires = Wires(wires)\n\n    n_wires = len(wires)\n    expected_shape = (4 ** n_wires - 1,)\n    check_shape(\n        weights,\n        expected_shape,\n        msg=""\'weights\' must be of shape {}; got {}."" """".format(expected_shape, get_shape(weights)),\n    )\n\n    wires = wires.tolist()  # Todo: remove when ops take Wires object\n\n    for i, pauli_word in enumerate(_all_pauli_words_but_identity(len(wires))):\n        qml.PauliRot(weights[i], pauli_word, wires=wires)\n'"
pennylane/templates/subroutines/double_excitation_unitary.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``DoubleExcitationUnitary`` template.\n""""""\nimport numpy as np\n\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.ops import CNOT, RX, RZ, Hadamard\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import (\n    check_no_variable,\n    check_shape,\n    check_type,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\ndef _layer1(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the first layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(1)}(\\theta) = \\mathrm{exp} \\Big\\{ \\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{X}_s \\hat{X}_r \\hat{Y}_q \\hat{X}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    Hadamard(wires=r)\n    RX(-np.pi / 2, wires=q)\n    Hadamard(wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    Hadamard(wires=r)\n    RX(np.pi / 2, wires=q)\n    Hadamard(wires=p)\n\n\ndef _layer2(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the second layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(2)}(\\theta) = \\mathrm{exp} \\Big\\{ \\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{Y}_s \\hat{X}_r \\hat{Y}_q \\hat{Y}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(-np.pi / 2, wires=s)\n    Hadamard(wires=r)\n    RX(-np.pi / 2, wires=q)\n    RX(-np.pi / 2, wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(np.pi / 2, wires=s)\n    Hadamard(wires=r)\n    RX(np.pi / 2, wires=q)\n    RX(np.pi / 2, wires=p)\n\n\ndef _layer3(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the third layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(3)}(\\theta) = \\mathrm{exp} \\Big\\{ \\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{X}_s \\hat{Y}_r \\hat{Y}_q \\hat{Y}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    RX(-np.pi / 2, wires=r)\n    RX(-np.pi / 2, wires=q)\n    RX(-np.pi / 2, wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    RX(np.pi / 2, wires=r)\n    RX(np.pi / 2, wires=q)\n    RX(np.pi / 2, wires=p)\n\n\ndef _layer4(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the fourth layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(4)}(\\theta) = \\mathrm{exp} \\Big\\{ \\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{X}_s \\hat{X}_r \\hat{X}_q \\hat{Y}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    Hadamard(wires=r)\n    Hadamard(wires=q)\n    RX(-np.pi / 2, wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    Hadamard(wires=r)\n    Hadamard(wires=q)\n    RX(np.pi / 2, wires=p)\n\n\ndef _layer5(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the fifth layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(5)}(\\theta) = \\mathrm{exp} \\Big\\{ -\\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{Y}_s \\hat{X}_r \\hat{X}_q \\hat{X}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(-np.pi / 2, wires=s)\n    Hadamard(wires=r)\n    Hadamard(wires=q)\n    Hadamard(wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(-weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(np.pi / 2, wires=s)\n    Hadamard(wires=r)\n    Hadamard(wires=q)\n    Hadamard(wires=p)\n\n\ndef _layer6(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the sixth layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(6)}(\\theta) = \\mathrm{exp} \\Big\\{ -\\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{X}_s \\hat{Y}_r \\hat{X}_q \\hat{X}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    RX(-np.pi / 2, wires=r)\n    Hadamard(wires=q)\n    Hadamard(wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(-weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    Hadamard(wires=s)\n    RX(np.pi / 2, wires=r)\n    Hadamard(wires=q)\n    Hadamard(wires=p)\n\n\ndef _layer7(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the seventh layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(7)}(\\theta) = \\mathrm{exp} \\Big\\{ -\\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{Y}_s \\hat{Y}_r \\hat{Y}_q \\hat{X}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(-np.pi / 2, wires=s)\n    RX(-np.pi / 2, wires=r)\n    RX(-np.pi / 2, wires=q)\n    Hadamard(wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(-weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(np.pi / 2, wires=s)\n    RX(np.pi / 2, wires=r)\n    RX(np.pi / 2, wires=q)\n    Hadamard(wires=p)\n\n\ndef _layer8(weight, s, r, q, p, set_cnot_wires):\n    r""""""Implement the eighth layer of the circuit to exponentiate the double-excitation\n    operator entering the UCCSD ansatz.\n\n    .. math::\n\n        \\hat{U}_{pqrs}^{(8)}(\\theta) = \\mathrm{exp} \\Big\\{ -\\frac{i\\theta}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1} \\hat{Z}_a\n        (\\hat{Y}_s \\hat{Y}_r \\hat{X}_q \\hat{Y}_p) \\Big\\}\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        s (int): qubit index ``s``\n        r (int): qubit index ``r``\n        q (int): qubit index ``q``\n        p (int): qubit index ``p``\n        set_cnot_wires (sequence[int]): two-element sequence with the indices of the qubits\n            the CNOT gates act on\n    """"""\n\n    # U_1, U_2, U_3, U_4 acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(-np.pi / 2, wires=s)\n    RX(-np.pi / 2, wires=r)\n    Hadamard(wires=q)\n    RX(-np.pi / 2, wires=p)\n\n    # Applying CNOTs between wires \'s\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(-weight / 8, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+, U_3^+, U_4^+ acting on wires \'s\', \'r\', \'q\' and \'p\'\n    RX(np.pi / 2, wires=s)\n    RX(np.pi / 2, wires=r)\n    Hadamard(wires=q)\n    RX(np.pi / 2, wires=p)\n\n\n@template\ndef DoubleExcitationUnitary(weight, wires=None):\n    r""""""Circuit to exponentiate the tensor product of Pauli matrices representing the\n    fermionic double-excitation operator entering the Unitary Coupled-Cluster Singles\n    and Doubles (UCCSD) ansatz. UCCSD is a VQE ansatz commonly used to run quantum\n    chemistry simulations.\n\n    The CC double-excitation operator is given by\n\n    .. math::\n\n        \\hat{U}_{pqrs}(\\theta) = \\mathrm{exp} \\{ \\theta (\\hat{c}_p^\\dagger \\hat{c}_q^\\dagger\n        \\hat{c}_r \\hat{c}_s - \\mathrm{H.c.}) \\},\n\n    where :math:`\\hat{c}` and :math:`\\hat{c}^\\dagger` are the fermionic annihilation and\n    creation operators and the indices :math:`r, s` and :math:`p, q` run over the occupied and\n    unoccupied molecular orbitals, respectively. Using the `Jordan-Wigner transformation\n    <https://arxiv.org/abs/1208.5986>`_ the fermionic operator defined above can be written\n    in terms of Pauli matrices (for more details see\n    `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_):\n\n    .. math::\n\n        \\hat{U}_{pqrs}(\\theta) = \\mathrm{exp} \\Big\\{\n        \\frac{i\\theta}{8} \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1}\n        \\hat{Z}_a (\\hat{X}_s \\hat{X}_r \\hat{Y}_q \\hat{X}_p +\n        \\hat{Y}_s \\hat{X}_r \\hat{Y}_q \\hat{Y}_p + \\hat{X}_s \\hat{Y}_r \\hat{Y}_q \\hat{Y}_p +\n        \\hat{X}_s \\hat{X}_r \\hat{X}_q \\hat{Y}_p - \\mathrm{H.c.}  ) \\Big\\}\n\n    The quantum circuit to exponentiate the tensor product of Pauli matrices entering\n    the latter equation is shown below:\n\n    |\n\n    .. figure:: ../../_static/templates/subroutines/double_excitation_unitary.png\n\n    |\n        :align: center\n        :width: 60%\n        :target: javascript:void(0);\n\n    As explained in `Seely et al. (2012) <https://arxiv.org/abs/1208.5986>`_,\n    the exponential of a tensor product of Pauli-Z operators can be decomposed in terms of\n    :math:`2(n-1)` CNOT gates and a single-qubit Z-rotation. If there are :math:`X` or\n    :math:`Y` Pauli matrices in the product, the Hadamard (:math:`H`) or :math:`R_x` gate has\n    to be applied to change to the :math:`X` or :math:`Y` basis, respectively.\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        wires (Iterable or Wires): Wires ``s, r, q, p`` that the template acts on. Must be of length 4.\n            Accepts an iterable of numbers or strings, or a Wires object.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        Notice that:\n\n        #. :math:`\\hat{U}_{pqrs}(\\theta)` involves eight exponentiations where\n           :math:`\\hat{U}_1`, :math:`\\hat{U}_2`, :math:`\\hat{U}_3`, :math:`\\hat{U}_4` and\n           :math:`\\hat{U}_\\theta` are defined as follows,\n\n           .. math::\n\n               [U_1, && U_2, U_3, U_4, U_{\\theta}] = \\\\\n               && \\Bigg\\{\\bigg[H, H, R_x(-\\frac{\\pi}{2}), H, R_z(\\theta/8)\\bigg],\n               \\bigg[R_x(-\\frac{\\pi}{2}), H, R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n               R_z(\\frac{\\theta}{8}) \\bigg], \\\\\n               && \\bigg[H, R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n               R_z(\\frac{\\theta}{8}) \\bigg], \\bigg[H, H, H, R_x(-\\frac{\\pi}{2}),\n               R_z(\\frac{\\theta}{8}) \\bigg], \\\\\n               && \\bigg[R_x(-\\frac{\\pi}{2}), H, H, H, R_z(-\\frac{\\theta}{8}) \\bigg],\n               \\bigg[H, R_x(-\\frac{\\pi}{2}), H, H, R_z(-\\frac{\\theta}{8}) \\bigg], \\\\\n               && \\bigg[R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n               H, R_z(-\\frac{\\theta}{8}) \\bigg], \\bigg[R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n               H, R_x(-\\frac{\\pi}{2}), R_z(-\\frac{\\theta}{8}) \\bigg] \\Bigg\\}\n\n        #. For a given quadruple ``[s, r, q, p]`` with :math:`p>q>r>s`, seventy-two single-qubit\n           operations are applied. Notice also that consecutive CNOT gates act on qubits with\n           indices between ``s`` and ``r`` and ``q`` and ``p`` while a single CNOT acts on wires\n           ``r`` and ``q``. The operations performed across these qubits are shown in dashed lines\n           in the figure above.\n\n        An example of how to use this template is shown below:\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import DoubleExcitationUnitary\n\n            dev = qml.device(\'default.qubit\', wires=5)\n\n            @qml.qnode(dev)\n            def circuit(weight, pphh=None):\n                DoubleExcitationUnitary(weight, wires=pphh)\n                return qml.expval(qml.PauliZ(0))\n\n            weight = 1.34817\n            double_excitation = [0, 1, 3, 4]\n            print(circuit(weight, pphh=double_excitation))\n\n    """"""\n\n    ##############\n    # Input checks\n\n    wires = Wires(wires)\n\n    if len(wires) != 4:\n        raise ValueError(""expected 4 wires; got {}"".format(len(wires)))\n\n    expected_shape = ()\n    check_shape(\n        weight,\n        expected_shape,\n        msg=""\'weight\' must be of shape {}; got {}"".format(expected_shape, get_shape(weight)),\n    )\n\n    wire_list = wires.tolist()  # TODO: delete the following checks for non-consec wires\n    if wire_list != sorted(wire_list):\n        raise ValueError(\n            ""Elements of \'wires\' must satisfy that wires_3 > wires_2 > wires_1 > wires_0.\\n""\n            ""Got wires[3]={}, wires[2]={}, wires[1]={}, wires[0]={}"".format(*wires)\n        )\n\n    ###############\n\n    s, r, q, p = wires.tolist()  # TODO: need to change logic here when introducing non-consec wires\n\n    # Sequence of the wires entering the CNOTs between wires \'s\' and \'p\'\n    set_cnot_wires = (  # TODO: change logic for non-consec wires\n        [[l, l + 1] for l in range(s, r)] + [[r, q]] + [[l, l + 1] for l in range(q, p)]\n    )\n\n    # Apply the first layer\n    _layer1(weight, s, r, q, p, set_cnot_wires)\n\n    # Apply the second layer\n    _layer2(weight, s, r, q, p, set_cnot_wires)\n\n    # Apply the third layer\n    _layer3(weight, s, r, q, p, set_cnot_wires)\n\n    # Apply the fourth layer\n    _layer4(weight, s, r, q, p, set_cnot_wires)\n\n    # Apply the fifth layer\n    _layer5(weight, s, r, q, p, set_cnot_wires)\n\n    # Apply the sixth layer\n    _layer6(weight, s, r, q, p, set_cnot_wires)\n\n    # Apply the seventh layer\n    _layer7(weight, s, r, q, p, set_cnot_wires)\n\n    # Apply the eighth layer\n    _layer8(weight, s, r, q, p, set_cnot_wires)\n'"
pennylane/templates/subroutines/interferometer.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``Interferometer`` template.\n""""""\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.ops import Beamsplitter, Rotation\nfrom pennylane.templates.utils import (\n    check_shapes,\n    check_no_variable,\n    check_is_in_options,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef Interferometer(theta, phi, varphi, wires, mesh=""rectangular"", beamsplitter=""pennylane""):\n    r""""""General linear interferometer, an array of beamsplitters and phase shifters.\n\n    For :math:`M` wires, the general interferometer is specified by\n    providing :math:`M(M-1)/2` transmittivity angles :math:`\\theta` and the same number of\n    phase angles :math:`\\phi`, as well as :math:`M-1` additional rotation\n    parameters :math:`\\varphi`.\n\n    By specifying the keyword argument ``mesh``, the scheme used to implement the interferometer\n    may be adjusted:\n\n    * ``mesh=\'rectangular\'`` (default): uses the scheme described in\n      `Clements et al. <https://dx.doi.org/10.1364/OPTICA.3.001460>`__, resulting in a *rectangular* array of\n      :math:`M(M-1)/2` beamsplitters arranged in :math:`M` slices and ordered from left\n      to right and top to bottom in each slice. The first beamsplitter acts on\n      wires :math:`0` and :math:`1`:\n\n      .. figure:: ../../_static/clements.png\n          :align: center\n          :width: 30%\n          :target: javascript:void(0);\n\n\n    * ``mesh=\'triangular\'``: uses the scheme described in `Reck et al. <https://dx.doi.org/10.1103/PhysRevLett.73.58>`__,\n      resulting in a *triangular* array of :math:`M(M-1)/2` beamsplitters arranged in\n      :math:`2M-3` slices and ordered from left to right and top to bottom. The\n      first and fourth beamsplitters act on wires :math:`M-1` and :math:`M`, the second\n      on :math:`M-2` and :math:`M-1`, and the third on :math:`M-3` and :math:`M-2`, and\n      so on.\n\n      .. figure:: ../../_static/reck.png\n          :align: center\n          :width: 30%\n          :target: javascript:void(0);\n\n    In both schemes, the network of :class:`~pennylane.ops.Beamsplitter` operations is followed by\n    :math:`M` local :class:`~pennylane.ops.Rotation` Operations.\n\n    The rectangular decomposition is generally advantageous, as it has a lower\n    circuit depth (:math:`M` vs :math:`2M-3`) and optical depth than the triangular\n    decomposition, resulting in reduced optical loss.\n\n    This is an example of a 4-mode interferometer with beamsplitters :math:`B` and rotations :math:`R`,\n    using ``mesh=\'rectangular\'``:\n\n    .. figure:: ../../_static/layer_interferometer.png\n        :align: center\n        :width: 60%\n        :target: javascript:void(0);\n\n    .. note::\n\n        The decomposition as formulated in `Clements et al. <https://dx.doi.org/10.1364/OPTICA.3.001460>`__ uses a different\n        convention for a beamsplitter :math:`T(\\theta, \\phi)` than PennyLane, namely:\n\n        .. math:: T(\\theta, \\phi) = BS(\\theta, 0) R(\\phi)\n\n        For the universality of the decomposition, the used convention is irrelevant, but\n        for a given set of angles the resulting interferometers will be different.\n\n        If an interferometer consistent with the convention from `Clements et al. <https://dx.doi.org/10.1364/OPTICA.3.001460>`__\n        is needed, the optional keyword argument ``beamsplitter=\'clements\'`` can be specified. This\n        will result in each :class:`~pennylane.ops.Beamsplitter` being preceded by a :class:`~pennylane.ops.Rotation` and\n        thus increase the number of elementary operations in the circuit.\n\n    Args:\n        theta (array): length :math:`M(M-1)/2` array of transmittivity angles :math:`\\theta`\n        phi (array): length :math:`M(M-1)/2` array of phase angles :math:`\\phi`\n        varphi (array): length :math:`M` array of rotation angles :math:`\\varphi`\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        mesh (string): the type of mesh to use\n        beamsplitter (str): if ``clements``, the beamsplitter convention from\n          Clements et al. 2016 (https://dx.doi.org/10.1364/OPTICA.3.001460) is used; if ``pennylane``, the\n          beamsplitter is implemented via PennyLane\'s ``Beamsplitter`` operation.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n    """"""\n\n    #############\n    # Input checks\n\n    wires = Wires(wires)\n\n    check_no_variable(beamsplitter, msg=""\'beamsplitter\' cannot be differentiable"")\n    check_no_variable(mesh, msg=""\'mesh\' cannot be differentiable"")\n\n    weights_list = [theta, phi, varphi]\n    n_wires = len(wires)\n    n_if = n_wires * (n_wires - 1) // 2\n    expected_shapes = [(n_if,), (n_if,), (n_wires,)]\n    check_shapes(weights_list, expected_shapes, msg=""wrong shape of weight input(s) detected"")\n\n    check_is_in_options(\n        beamsplitter,\n        [""clements"", ""pennylane""],\n        msg=""did not recognize option {} for \'beamsplitter\'"" """".format(beamsplitter),\n    )\n    check_is_in_options(\n        mesh,\n        [""triangular"", ""rectangular""],\n        msg=""did not recognize option {} for \'mesh\'"" """".format(mesh),\n    )\n    ###############\n\n    M = len(wires)\n\n    if M == 1:\n        # the interferometer is a single rotation\n        Rotation(varphi[0], wires=wires[0])\n        return\n\n    n = 0  # keep track of free parameters\n\n    if mesh == ""rectangular"":\n        # Apply the Clements beamsplitter array\n        # The array depth is N\n        for l in range(M):\n            for k, (w1, w2) in enumerate(zip(wires[:-1], wires[1:])):\n                # skip even or odd pairs depending on layer\n                if (l + k) % 2 != 1:\n                    if beamsplitter == ""clements"":\n                        Rotation(phi[n], wires=Wires(w1))\n                        Beamsplitter(theta[n], 0, wires=Wires([w1, w2]))\n                    else:\n                        Beamsplitter(theta[n], phi[n], wires=Wires([w1, w2]))\n                    n += 1\n\n    elif mesh == ""triangular"":\n        # apply the Reck beamsplitter array\n        # The array depth is 2*N-3\n        for l in range(2 * M - 3):\n            for k in range(abs(l + 1 - (M - 1)), M - 1, 2):\n                if beamsplitter == ""clements"":\n                    Rotation(phi[n], wires=wires[k])\n                    Beamsplitter(theta[n], 0, wires=wires.subset([k, k + 1]))\n                else:\n                    Beamsplitter(theta[n], phi[n], wires=wires.subset([k, k + 1]))\n                n += 1\n\n    # apply the final local phase shifts to all modes\n    for i, p in enumerate(varphi):\n        act_on = wires[i]\n        Rotation(p, wires=act_on)\n'"
pennylane/templates/subroutines/single_excitation_unitary.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``SingleExcitationUnitary`` template.\n""""""\nfrom pennylane import numpy as np\n\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.ops import CNOT, RX, RZ, Hadamard\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_type,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef SingleExcitationUnitary(weight, wires=None):\n    r""""""Circuit to exponentiate the tensor product of Pauli matrices representing the\n    fermionic single-excitation operator entering the Unitary Coupled-Cluster Singles\n    and Doubles (UCCSD) ansatz. UCCSD is a VQE ansatz commonly used to run quantum\n    chemistry simulations.\n\n    The CC single-excitation operator is given by\n\n    .. math::\n\n        \\hat{U}_{pr}^{(1)}(\\theta) = \\mathrm{exp} \\{ \\theta_{pr} (\\hat{c}_p^\\dagger \\hat{c}_r\n        -\\mathrm{H.c.}) \\},\n\n    where :math:`\\hat{c}` and :math:`\\hat{c}^\\dagger` are the fermionic annihilation and\n    creation operators and the indices :math:`r` and :math:`p` run over the occupied and\n    unoccupied molecular orbitals, respectively. Using the `Jordan-Wigner transformation\n    <https://arxiv.org/abs/1208.5986>`_ the fermionic operator defined above can be written\n    in terms of Pauli matrices (for more details see\n    `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_).\n\n    .. math::\n\n        \\hat{U}_{pr}^{(1)}(\\theta) = \\mathrm{exp} \\Big\\{ \\frac{i\\theta}{2}\n        \\bigotimes_{a=r+1}^{p-1}\\hat{Z}_a (\\hat{Y}_r \\hat{X}_p) \\Big\\}\n        \\mathrm{exp} \\Big\\{ -\\frac{i\\theta}{2}\n        \\bigotimes_{a=r+1}^{p-1} \\hat{Z}_a (\\hat{X}_r \\hat{Y}_p) \\Big\\}.\n\n    The quantum circuit to exponentiate the tensor product of Pauli matrices entering\n    the latter equation is shown below:\n\n    .. figure:: ../../_static/templates/subroutines/single_excitation_unitary.png\n        :align: center\n        :width: 60%\n        :target: javascript:void(0);\n\n    As explained in `Seely et al. (2012) <https://arxiv.org/abs/1208.5986>`_,\n    the exponential of a tensor product of Pauli-Z operators can be decomposed in terms of\n    :math:`2(n-1)` CNOT gates and a single-qubit Z-rotation. If there are :math:`X` or\n    :math:`Y` Pauli matrices in the product, the Hadamard (:math:`H`) or :math:`R_x` gate has\n    to be applied to change to the :math:`X` or :math:`Y` basis, respectively.\n\n    Args:\n        weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n        wires (Iterable or Wires): Wires ``r, p`` that the template acts on. Must be of length 2.\n            Accepts an iterable of numbers or strings, or a Wires object.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        Notice that:\n\n        #. :math:`\\hat{U}_{pr}^{(1)}(\\theta)` involves two exponentiations where :math:`\\hat{U}_1`,\n           :math:`\\hat{U}_2`, and :math:`\\hat{U}_\\theta` are defined as follows,\n\n           .. math::\n               [U_1, U_2, U_{\\theta}] = \\Bigg\\{\\bigg[R_x(-\\pi/2), H, R_z(\\theta/2)\\bigg],\n               \\bigg[H, R_x(-\\frac{\\pi}{2}), R_z(-\\theta/2) \\bigg] \\Bigg\\}\n\n        #. For a given pair ``[r, p]``, ten single-qubit operations are applied. Notice also that\n           CNOT gates act only on qubits with indices between ``r`` and ``p``. The operations\n           performed across these qubits are shown in dashed lines in the figure above.\n\n        An example of how to use this template is shown below:\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import SingleExcitationUnitary\n\n            dev = qml.device(\'default.qubit\', wires=3)\n\n            @qml.qnode(dev)\n            def circuit(weight, ph=None):\n                SingleExcitationUnitary(weight, wires=ph)\n                return qml.expval(qml.PauliZ(0))\n\n            weight = 0.56\n            single_excitation = [0, 2]\n            print(circuit(weight, ph=single_excitation))\n\n    """"""\n\n    ##############\n    # Input checks\n\n    wires = Wires(wires)\n\n    if len(wires) != 2:\n        raise ValueError(""expected 2 wires; got {}"".format(len(wires)))\n\n    wire_list = wires.tolist()  # TODO: delete this ""<="" check for non-consec wires\n    if wire_list[1] <= wire_list[0]:\n        raise ValueError(\n            ""wires_1 must be greater than wires_0; got wires[1]={}, wires[0]={}"".format(\n                wires[1], wires[0]\n            )\n        )\n\n    expected_shape = ()\n    check_shape(\n        weight,\n        expected_shape,\n        msg=""\'weight\' must be of shape {}; got {}"".format(expected_shape, get_shape(weight)),\n    )\n\n    ###############\n\n    r, p = wires.tolist()  # TODO: need to change logic here when introducing non-consec wires\n\n    # Sequence of the wires entering the CNOTs between wires \'r\' and \'p\'\n    set_cnot_wires = [[l, l + 1] for l in range(r, p)]\n\n    # ------------------------------------------------------------------\n    # Apply the first layer\n\n    # U_1, U_2 acting on wires \'r\' and \'p\'\n    RX(-np.pi / 2, wires=r)\n    Hadamard(wires=p)\n\n    # Applying CNOTs between wires \'r\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(weight / 2, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+ acting on wires \'r\' and \'p\'\n    RX(np.pi / 2, wires=r)\n    Hadamard(wires=p)\n\n    # ------------------------------------------------------------------\n    # Apply the second layer\n\n    # U_1, U_2 acting on wires \'r\' and \'p\'\n    Hadamard(wires=r)\n    RX(-np.pi / 2, wires=p)\n\n    # Applying CNOTs between wires \'r\' and \'p\'\n    for cnot_wires in set_cnot_wires:\n        CNOT(wires=cnot_wires)\n\n    # Z rotation acting on wire \'p\'\n    RZ(-weight / 2, wires=p)\n\n    # Applying CNOTs in reverse order\n    for cnot_wires in reversed(set_cnot_wires):\n        CNOT(wires=cnot_wires)\n\n    # U_1^+, U_2^+ acting on wires \'r\' and \'p\'\n    Hadamard(wires=r)\n    RX(np.pi / 2, wires=p)\n'"
pennylane/templates/subroutines/uccsd.py,0,"b'# Copyright 2018-2020 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr""""""\nContains the ``UCCSD`` template.\n""""""\nimport numpy as np\n\nimport pennylane as qml\n\n# pylint: disable-msg=too-many-branches,too-many-arguments,protected-access\nfrom pennylane.templates.decorator import template\nfrom pennylane.templates.subroutines import DoubleExcitationUnitary, SingleExcitationUnitary\nfrom pennylane.templates.utils import (\n    check_shape,\n    check_type,\n    get_shape,\n)\nfrom pennylane.wires import Wires\n\n\n@template\ndef UCCSD(weights, wires, ph=None, pphh=None, init_state=None):\n    r""""""Implements the Unitary Coupled-Cluster Singles and Doubles (UCCSD) ansatz.\n\n    The UCCSD ansatz calls the\n    :func:`~.SingleExcitationUnitary` and :func:`~.DoubleExcitationUnitary`\n    templates to exponentiate the coupled-cluster excitation operator. UCCSD is a VQE ansatz\n    commonly used to run quantum chemistry simulations.\n\n    The UCCSD unitary, within the first-order Trotter approximation, is given by:\n\n    .. math::\n\n        \\hat{U}(\\vec{\\theta}) =\n        \\prod_{p > r} \\mathrm{exp} \\Big\\{\\theta_{pr}\n        (\\hat{c}_p^\\dagger \\hat{c}_r-\\mathrm{H.c.}) \\Big\\}\n        \\prod_{p > q > r > s} \\mathrm{exp} \\Big\\{\\theta_{pqrs}\n        (\\hat{c}_p^\\dagger \\hat{c}_q^\\dagger \\hat{c}_r \\hat{c}_s-\\mathrm{H.c.}) \\Big\\}\n\n    where :math:`\\hat{c}` and :math:`\\hat{c}^\\dagger` are the fermionic annihilation and\n    creation operators and the indices :math:`r, s` and :math:`p, q` run over the occupied and\n    unoccupied molecular orbitals, respectively. Using the `Jordan-Wigner transformation\n    <https://arxiv.org/abs/1208.5986>`_ the UCCSD unitary defined above can be written in terms\n    of Pauli matrices as follows (for more details see\n    `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_):\n\n    .. math::\n\n        \\hat{U}(\\vec{\\theta}) = && \\prod_{p > r} \\mathrm{exp} \\Big\\{ \\frac{i\\theta_{pr}}{2}\n        \\bigotimes_{a=r+1}^{p-1} \\hat{Z}_a (\\hat{Y}_r \\hat{X}_p - \\mathrm{H.c.}) \\Big\\} \\\\\n        && \\times \\prod_{p > q > r > s} \\mathrm{exp} \\Big\\{ \\frac{i\\theta_{pqrs}}{8}\n        \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1}\n        \\hat{Z}_a (\\hat{X}_s \\hat{X}_r \\hat{Y}_q \\hat{X}_p +\n        \\hat{Y}_s \\hat{X}_r \\hat{Y}_q \\hat{Y}_p +\n        \\hat{X}_s \\hat{Y}_r \\hat{Y}_q \\hat{Y}_p +\n        \\hat{X}_s \\hat{X}_r \\hat{X}_q \\hat{Y}_p -\n        \\{\\mathrm{H.c.}\\}) \\Big\\}.\n\n    Args:\n        weights (array): length ``len(ph)+len(pphh)`` vector containing the parameters\n            :math:`\\theta_{pr}` and :math:`\\theta_{pqrs}` entering the Z rotation in\n            :func:`~.SingleExcitationUnitary`\n            and\n            :func:`~.DoubleExcitationUnitary`. These parameters are precisely the coupled-cluster\n            amplitudes that need to be optimized for each configuration generated by the\n            excitation operator.\n        wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n            a Wires object.\n        ph (Sequence[list]): Sequence of two-element lists containing the indices ``r, p`` that\n            define the 1particle-1hole (ph) configuration :math:`\\vert \\mathrm{ph} \\rangle =\n            \\hat{c}_p^\\dagger \\hat{c}_r \\vert \\mathrm{HF} \\rangle`,\n            where :math:`\\vert \\mathrm{HF} \\rangle` denotes the Hartee-Fock (HF) reference state.\n        pphh (Sequence[list]): Sequence of four-elements lists containing the indices\n            ``s, r, q, p`` that define the 2particle-2hole configuration (pphh)\n            :math:`\\vert \\mathrm{pphh} \\rangle = \\hat{c}_p^\\dagger \\hat{c}_q^\\dagger \\hat{c}_r\n            \\hat{c}_s \\vert \\mathrm{HF} \\rangle`.\n        init_state (array[int]): Length ``len(wires)`` occupation-number vector representing the\n            HF state. ``init_state`` is used to initialize the qubit register.\n\n    Raises:\n        ValueError: if inputs do not have the correct format\n\n    .. UsageDetails::\n\n        Notice that:\n\n        #. The number of wires has to be equal to the number of spin-orbitals included in\n           the active space.\n\n        #. The ``ph`` and ``pphh`` lists can be generated with the function\n           :func:`~.sd_excitations`. See example below.\n\n        #. The vector of parameters ``weights`` is a one-dimensional array of size\n           ``len(ph)+len(pphh)``\n\n\n        An example of how to use this template is shown below:\n\n        .. code-block:: python\n\n            import pennylane as qml\n            from pennylane.templates import UCCSD\n\n            # Number of active electrons\n            n_active_electrons = 2\n\n            # Number of active spin-orbitals\n            n_active_orbitals = 4\n\n            # Set the ``ref_state`` array to encode the HF state\n            ref_state = qml.qchem.hf_state(n_active_electrons, n_active_orbitals)\n\n            # Spin-projection selection rule to generate the excitations\n            DSz = 0\n\n            # Generate the particle-hole configurations\n            ph, pphh = qml.qchem.sd_excitations(n_active_electrons, n_active_orbitals, DS=DSz)\n\n            dev = qml.device(\'default.qubit\', wires=n_active_orbitals)\n\n            @qml.qnode(dev)\n            def circuit(weights, wires, ph=ph, pphh=pphh, init_state=ref_state):\n                UCCSD(weights, wires, ph=ph, pphh=pphh, init_state=ref_state)\n                return qml.expval(qml.PauliZ(0))\n\n            params = np.random.normal(0, np.pi, len(ph) + len(pphh))\n            print(circuit(params, wires, ph=ph, pphh=pphh, init_state=ref_state))\n\n    """"""\n\n    ##############\n    # Input checks\n\n    wires = Wires(wires)\n\n    if (not ph) and (not pphh):\n        raise ValueError(\n            ""\'ph\' and \'pphh\' lists can not be both empty; got ph={}, pphh={}"".format(ph, pphh)\n        )\n\n    check_type(ph, [list], msg=""\'ph\' must be a list; got {}"".format(ph))\n    expected_shape = (2,)\n    for i_ph in ph:\n        check_type(i_ph, [list], msg=""Each element of \'ph\' must be a list; got {}"".format(i_ph))\n        check_shape(\n            i_ph,\n            expected_shape,\n            msg=""Elements of \'ph\' must be of shape {}; got {}"".format(\n                expected_shape, get_shape(i_ph)\n            ),\n        )\n        for i in i_ph:\n            check_type(\n                i, [int], msg=""Each element of \'ph\' must be a list of integers; got {}"".format(i_ph)\n            )\n\n    check_type(pphh, [list], msg=""\'pphh\' must be a list; got {}"".format(pphh))\n    expected_shape = (4,)\n    for i_pphh in pphh:\n        check_type(\n            i_pphh, [list], msg=""Each element of \'pphh\' must be a list; got {}"".format(i_pphh)\n        )\n        check_shape(\n            i_pphh,\n            expected_shape,\n            msg=""Elements of \'pphh\' must be of shape {}; got {}"".format(\n                expected_shape, get_shape(i_pphh)\n            ),\n        )\n        for i in i_pphh:\n            check_type(\n                i,\n                [int],\n                msg=""Each element of \'pphh\' must be a list of integers; got {}"".format(i_pphh),\n            )\n\n    check_type(\n        init_state,\n        [np.ndarray],\n        msg=""\'init_state\' must be a Numpy array; got {}"".format(init_state),\n    )\n    for i in init_state:\n        check_type(\n            i,\n            [int, np.int64],\n            msg=""Elements of \'init_state\' must be integers; got {}"".format(init_state),\n        )\n\n    expected_shape = (len(ph) + len(pphh),)\n    check_shape(\n        weights,\n        expected_shape,\n        msg=""\'weights\' must be of shape {}; got {}"".format(expected_shape, get_shape(weights)),\n    )\n\n    expected_shape = (len(wires),)\n    check_shape(\n        init_state,\n        expected_shape,\n        msg=""\'init_state\' must be of shape {}; got {}"".format(\n            expected_shape, get_shape(init_state)\n        ),\n    )\n\n    ###############\n\n    qml.BasisState(np.flip(init_state), wires=wires)\n\n    for d, i_pphh in enumerate(pphh):\n        DoubleExcitationUnitary(weights[len(ph) + d], wires=i_pphh)\n\n    for s, i_ph in enumerate(ph):\n        SingleExcitationUnitary(weights[s], wires=i_ph)\n'"
