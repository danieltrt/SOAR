file_path,api_count,code
gridworld.py,0,"b'import numpy as np\nimport random\nimport itertools\nimport scipy.ndimage\nimport scipy.misc\nimport matplotlib.pyplot as plt\n\n\nclass gameOb():\n    def __init__(self,coordinates,size,color,reward,name):\n        self.x = coordinates[0]\n        self.y = coordinates[1]\n        self.size = size\n        self.color = color\n        self.reward = reward\n        self.name = name\n        \nclass gameEnv():\n    def __init__(self,partial,size,goal_color):\n        self.sizeX = size\n        self.sizeY = size\n        self.actions = 4\n        self.objects = []\n        self.partial = partial\n        self.bg = np.zeros([size,size])\n        a,a_big = self.reset(goal_color)\n        plt.imshow(a_big,interpolation=""nearest"")\n        \n        \n    def getFeatures(self):\n        return np.array([self.objects[0].x,self.objects[0].y]) / float(self.sizeX)\n        \n    def reset(self,goal_color):\n        self.objects = []\n        self.goal_color = goal_color\n        self.other_color = [1 - a for a in self.goal_color]\n        self.orientation = 0\n        self.hero = gameOb(self.newPosition(0),1,[0,0,1],None,\'hero\')\n        self.objects.append(self.hero)\n        for i in range(self.sizeX-1):\n            bug = gameOb(self.newPosition(0),1,self.goal_color,1,\'goal\')\n            self.objects.append(bug)\n        for i in range(self.sizeX-1):\n            hole = gameOb(self.newPosition(0),1,self.other_color,0,\'fire\')\n            self.objects.append(hole)\n        state,s_big = self.renderEnv()\n        self.state = state\n        return state,s_big\n\n    def moveChar(self,action):\n        # 0 - up, 1 - down, 2 - left, 3 - right, 4 - 90 counter-clockwise, 5 - 90 clockwise\n        hero = self.objects[0]\n        blockPositions = [[-1,-1]]\n        for ob in self.objects:\n            if ob.name == \'block\': blockPositions.append([ob.x,ob.y])\n        blockPositions = np.array(blockPositions)\n        heroX = hero.x\n        heroY = hero.y\n        penalize = 0.\n        if action < 4 :\n            if self.orientation == 0:\n               direction = action            \n            if self.orientation == 1:\n               if action == 0: direction = 1\n               elif action == 1: direction = 0\n               elif action == 2: direction = 3\n               elif action == 3: direction = 2\n            if self.orientation == 2:\n               if action == 0: direction = 3\n               elif action == 1: direction = 2\n               elif action == 2: direction = 0\n               elif action == 3: direction = 1\n            if self.orientation == 3:\n               if action == 0: direction = 2\n               elif action == 1: direction = 3\n               elif action == 2: direction = 1\n               elif action == 3: direction = 0\n        \n            if direction == 0 and hero.y >= 1 and [hero.x,hero.y - 1] not in blockPositions.tolist():\n                hero.y -= 1\n            if direction == 1 and hero.y <= self.sizeY-2 and [hero.x,hero.y + 1] not in blockPositions.tolist():\n                hero.y += 1\n            if direction == 2 and hero.x >= 1 and [hero.x - 1,hero.y] not in blockPositions.tolist():\n                hero.x -= 1\n            if direction == 3 and hero.x <= self.sizeX-2 and [hero.x + 1,hero.y] not in blockPositions.tolist():\n                hero.x += 1     \n        if hero.x == heroX and hero.y == heroY:\n            penalize = 0.0\n        self.objects[0] = hero\n        return penalize\n    \n    def newPosition(self,sparcity):\n        iterables = [ range(self.sizeX), range(self.sizeY)]\n        points = []\n        for t in itertools.product(*iterables):\n            points.append(t)\n        for objectA in self.objects:\n            if (objectA.x,objectA.y) in points: points.remove((objectA.x,objectA.y))\n        location = np.random.choice(range(len(points)),replace=False)\n        return points[location]\n\n    def checkGoal(self):\n        hero = self.objects[0]\n        others = self.objects[1:]\n        ended = False\n        for other in others:\n            if hero.x == other.x and hero.y == other.y and hero != other:\n                self.objects.remove(other)\n                if other.reward == 1:\n                    self.objects.append(gameOb(self.newPosition(0),1,self.goal_color,1,\'goal\'))\n                    return other.reward,False\n                else: \n                    self.objects.append(gameOb(self.newPosition(0),1,self.other_color,0,\'fire\'))\n                    return other.reward,False\n        if ended == False:\n            return 0.0,False\n\n    def renderEnv(self):\n        if self.partial == True:\n            padding = 2\n            a = np.ones([self.sizeY+(padding*2),self.sizeX+(padding*2),3])\n            a[padding:-padding,padding:-padding,:] = 0\n            a[padding:-padding,padding:-padding,:] += np.dstack([self.bg,self.bg,self.bg])\n        else:\n            a = np.zeros([self.sizeY,self.sizeX,3])\n            padding = 0\n            a += np.dstack([self.bg,self.bg,self.bg])\n        hero = self.objects[0]\n        for item in self.objects:\n            a[item.y+padding:item.y+item.size+padding,item.x+padding:item.x+item.size+padding,:] = item.color\n            #if item.name == \'hero\':\n            #    hero = item\n        if self.partial == True:\n            a = a[(hero.y):(hero.y+(padding*2)+hero.size),(hero.x):(hero.x+(padding*2)+hero.size),:]\n        a_big = scipy.misc.imresize(a,[32,32,3],interp=\'nearest\')\n        return a,a_big\n\n    def step(self,action):\n        penalty = self.moveChar(action)\n        reward,done = self.checkGoal()\n        state,s_big = self.renderEnv()\n        if reward == None:\n            print done\n            print reward\n            print penalty\n            return state,(reward+penalty),done\n        else:\n            goal = None\n            for ob in self.objects:\n                if ob.name == \'goal\':\n                    goal = ob\n            return state,s_big,(reward+penalty),done,[self.objects[0].y,self.objects[0].x],[goal.y,goal.x]\n'"
helper.py,3,"b'import numpy as np\nimport random\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nimport scipy.misc\nimport os\nimport csv\nimport itertools\nimport tensorflow.contrib.slim as slim\nfrom PIL import Image\nfrom PIL import ImageDraw \nfrom PIL import ImageFont\n\n\n# Copies one set of variables to another.\n# Used to set worker network parameters to those of global network.\ndef update_target_graph(from_scope,to_scope):\n    from_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, from_scope)\n    to_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, to_scope)\n\n    op_holder = []\n    for from_var,to_var in zip(from_vars,to_vars):\n        op_holder.append(to_var.assign(from_var))\n    return op_holder\n\n# Discounting function used to calculate discounted returns.\ndef discount(x, gamma):\n    return scipy.signal.lfilter([1], [1, -gamma], x[::-1], axis=0)[::-1]\n\n#Used to initialize weights for policy and value output layers\ndef normalized_columns_initializer(std=1.0):\n    def _initializer(shape, dtype=None, partition_info=None):\n        out = np.random.randn(*shape).astype(np.float32)\n        out *= std / np.sqrt(np.square(out).sum(axis=0, keepdims=True))\n        return tf.constant(out)\n    return _initializer\n\n\n#This code allows gifs to be saved of the training episode for use in the Control Center.\ndef make_gif(images, fname, duration=2, true_image=False):\n  import moviepy.editor as mpy\n  \n  def make_frame(t):\n    try:\n      x = images[int(len(images)/duration*t)]\n    except:\n      x = images[-1]\n\n    if true_image:\n      return x.astype(np.uint8)\n    else:\n      return ((x+1)/2*255).astype(np.uint8)\n  \n  clip = mpy.VideoClip(make_frame, duration=duration)\n  clip.write_gif(fname, fps = len(images) / duration,verbose=False)\n\ndef set_image_bandit(values,probs,selection,trial):\n    bandit_image = Image.open(\'./resources/bandit.png\')\n    draw = ImageDraw.Draw(bandit_image)\n    font = ImageFont.truetype(""./resources/FreeSans.ttf"", 24)\n    draw.text((40, 10),str(float(""{0:.2f}"".format(probs[0]))),(0,0,0),font=font)\n    draw.text((130, 10),str(float(""{0:.2f}"".format(probs[1]))),(0,0,0),font=font)\n    draw.text((60, 370),\'Trial: \' + str(trial),(0,0,0),font=font)\n    bandit_image = np.array(bandit_image)\n    bandit_image[115:115+floor(values[0]*2.5),20:75,:] = [0,255.0,0] \n    bandit_image[115:115+floor(values[1]*2.5),120:175,:] = [0,255.0,0]    \n    bandit_image[101:107,10+(selection*95):10+(selection*95)+80,:] = [80.0,80.0,225.0]\n    return bandit_image\n    \n    \ndef set_image_context(correct, observation,values,selection,trial):\n    obs = observation * 225.0\n    obs_a = obs[:,0:1,:]\n    obs_b = obs[:,1:2,:]\n    cor = correct * 225.0\n    obs_a = scipy.misc.imresize(obs_a,[100,100],interp=\'nearest\')\n    obs_b = scipy.misc.imresize(obs_b,[100,100],interp=\'nearest\')\n    cor = scipy.misc.imresize(cor,[100,100],interp=\'nearest\')\n    bandit_image = Image.open(\'./resources/c_bandit.png\')\n    draw = ImageDraw.Draw(bandit_image)\n    font = ImageFont.truetype(""./resources/FreeSans.ttf"", 24)\n    draw.text((50, 360),\'Trial: \' + str(trial),(0,0,0),font=font)\n    draw.text((50, 330),\'Reward: \' + str(values),(0,0,0),font=font)\n    bandit_image = np.array(bandit_image)\n    bandit_image[120:220,0:100,:] = obs_a\n    bandit_image[120:220,100:200,:] = obs_b\n    bandit_image[0:100,50:150,:] = cor\n    bandit_image[291:297,10+(selection*95):10+(selection*95)+80,:] = [80.0,80.0,225.0]\n    return bandit_image\n\n\ndef set_image_gridworld(frame,color,reward,step):\n    a = scipy.misc.imresize(frame,[200,200],interp=\'nearest\')\n    b = np.ones([400,200,3]) * 255.0\n    b[0:200,0:200,:] = a \n    b[200:210,0:200,:] = np.array(color) * 255.0\n    b = Image.fromarray(b.astype(\'uint8\'))\n    draw = ImageDraw.Draw(b)\n    font = ImageFont.truetype(""./resources/FreeSans.ttf"", 24)\n    draw.text((40, 280),\'Step: \' + str(step),(0,0,0),font=font)\n    draw.text((40, 330),\'Reward: \' + str(reward),(0,0,0),font=font)\n    c = np.array(b)\n    return c\n'"
