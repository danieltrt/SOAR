file_path,api_count,code
app.py,0,"b'import os\nimport sys\nimport cv2\n\nfrom flask import Flask, render_template, Response,  request, session, redirect, url_for, send_from_directory, flash, jsonify, abort\nfrom werkzeug.utils import secure_filename\nfrom PIL import Image\n\nfrom src.config import shooting_result\nfrom src.app_helper import getVideoStream, get_image, detectionAPI\n\napp = Flask(__name__)\nUPLOAD_FOLDER = \'./static/uploads\'\napp.config[\'UPLOAD_FOLDER\'] = UPLOAD_FOLDER\n#useless key, in order to use session\napp.secret_key = ""super secret key"" \n\n@app.route(""/"")\ndef index():\n    return render_template(""index.html"")\n\n@app.route(\'/detection_json\', methods=[\'GET\', \'POST\'])\ndef detection_json():\n    if request.method == \'POST\':\n        response = []\n        f = request.files[\'image\']\n        # create a secure filename\n        filename = secure_filename(f.filename)\n        print(""filename"", filename)\n        # save file to /static/uploads\n        filepath = os.path.join(app.config[\'UPLOAD_FOLDER\'], filename)\n        print(""filepath"", filepath)\n        f.save(filepath)\n        detectionAPI(response, filepath)\n        print(response)\n        try:\n            return jsonify(response), 200\n        except FileNotFoundError:\n            abort(404)\n\n\n@app.route(\'/sample_detection\', methods=[\'GET\', \'POST\'])\ndef upload_sample_image():\n    if request.method == \'POST\':\n        response = []\n        filename = ""sample_image.jpg""\n        print(""filename"", filename)\n        filepath = ""./static/uploads/sample_image.jpg""\n        print(""filepath"", filepath)\n        get_image(filepath, filename, response)\n        return render_template(""shot_detection.html"", display_detection=filename, fname=filename, response=response)\n\n@app.route(\'/basketball_detection\', methods=[\'GET\', \'POST\'])\ndef upload_image():\n    if request.method == \'POST\':\n        response = []\n        f = request.files[\'image\']\n        # create a secure filename\n        filename = secure_filename(f.filename)\n        print(""filename"", filename)\n        # save file to /static/uploads\n        filepath = os.path.join(app.config[\'UPLOAD_FOLDER\'], filename)\n        print(""filepath"", filepath)\n        f.save(filepath)\n        get_image(filepath, filename, response)\n        return render_template(""shot_detection.html"", display_detection=filename, fname=filename, response=response)\n\n@app.route(\'/sample_analysis\', methods=[\'GET\', \'POST\'])\ndef upload_video():\n    global shooting_result\n    shooting_result[\'attempts\'] = 0\n    shooting_result[\'made\'] = 0\n    shooting_result[\'miss\'] = 0\n    if (os.path.exists(""./static/detections/trajectory_fitting.jpg"")):\n        os.remove(""./static/detections/trajectory_fitting.jpg"")\n    if request.method == \'POST\':\n        filename = ""sample_video.mp4""\n        print(""filename"", filename)\n        filepath = ""./static/uploads/sample_video.mp4""\n        print(""filepath"", filepath)\n        session[\'video_path\'] = filepath\n        return render_template(""shooting_analysis.html"")\n\n@app.route(\'/shooting_analysis\', methods=[\'GET\', \'POST\'])\ndef upload_sample_video():\n    global shooting_result\n    shooting_result[\'attempts\'] = 0\n    shooting_result[\'made\'] = 0\n    shooting_result[\'miss\'] = 0\n    if (os.path.exists(""./static/detections/trajectory_fitting.jpg"")):\n        os.remove(""./static/detections/trajectory_fitting.jpg"")\n    if request.method == \'POST\':\n        f = request.files[\'video\']\n        # create a secure filename\n        filename = secure_filename(f.filename)\n        print(""filename"", filename)\n        # save file to /static/uploads\n        filepath = os.path.join(app.config[\'UPLOAD_FOLDER\'], filename)\n        print(""filepath"", filepath)\n        f.save(filepath)\n        session[\'video_path\'] = filepath\n        return render_template(""shooting_analysis.html"")\n\n@app.route(\'/video_feed\')\ndef video_feed():\n    video_path = session.get(\'video_path\', None)\n    stream = getVideoStream(video_path)\n    return Response(stream,\n                    mimetype=\'multipart/x-mixed-replace; boundary=frame\')\n\n@app.route(""/result"", methods=[\'GET\', \'POST\'])\ndef result():\n    return render_template(""result.html"", shooting_result=shooting_result)\n\n#disable caching\n@app.after_request\ndef after_request(response):\n    response.headers[""Cache-Control""] = ""no-cache, no-store, must-revalidate, public, max-age=0""\n    response.headers[""Expires""] = 0\n    response.headers[""Pragma""] = ""no-cache""\n    return response\n\nif __name__ == \'__main__\':\n    app.run(debug=True, use_reloader=True)\n'"
src/app_helper.py,3,"b'import time\nfrom absl import app, logging\nimport cv2\nimport numpy as np\nimport tensorflow.compat.v1 as tf\nfrom flask import Flask, request, Response, jsonify, send_from_directory, abort\nimport os\nfrom .config import shooting_result\nimport sys\nfrom sys import platform\nimport argparse\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom .utils import detect_shot, detect_image, detect_API, tensorflow_init, openpose_init\nfrom statistics import mean\ntf.disable_v2_behavior()\n\ndef getVideoStream(video_path):\n    datum, opWrapper = openpose_init()\n    detection_graph, image_tensor, boxes, scores, classes, num_detections = tensorflow_init()\n\n    cap = cv2.VideoCapture(video_path)\n    width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)\n    height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)\n    fps = cap.get(cv2.CAP_PROP_FPS)\n    trace = np.full((int(height), int(width), 3), 255, np.uint8)\n\n    fig = plt.figure()\n    #objects to store detection status\n    previous = {\n    \'ball\': np.array([0, 0]),  # x, y\n    \'hoop\': np.array([0, 0, 0, 0]),  # xmin, ymax, xmax, ymin\n        \'hoop_height\': 0\n    }\n    during_shooting = {\n        \'isShooting\': False,\n        \'balls_during_shooting\': [],\n        \'release_angle_list\': [],\n        \'release_point\': []\n    }\n    shooting_pose = {\n        \'ball_in_hand\': False,\n        \'elbow_angle\': 370,\n        \'knee_angle\': 370,\n        \'ballInHand_frames\': 0,\n        \'elbow_angle_list\': [],\n        \'knee_angle_list\': [],\n        \'ballInHand_frames_list\': []\n    }\n    shot_result = {\n        \'displayFrames\': 0,\n        \'release_displayFrames\': 0,\n        \'judgement\': """"\n    }\n\n    config = tf.ConfigProto()\n    config.gpu_options.allow_growth = True\n    config.gpu_options.per_process_gpu_memory_fraction = 0.36\n\n    skip_count = 0\n    with tf.Session(graph=detection_graph, config=config) as sess:\n        while True:\n            ret, img = cap.read()\n            if ret == False:\n                break\n            skip_count += 1\n            if(skip_count < 4):\n                continue\n            skip_count = 0\n            detection, trace = detect_shot(img, trace, width, height, sess, image_tensor, boxes, scores, classes,\n                                        num_detections, previous, during_shooting, shot_result, fig, datum, opWrapper, shooting_pose)\n\n            detection = cv2.resize(detection, (0, 0), fx=0.83, fy=0.83)\n            frame = cv2.imencode(\'.jpg\', detection)[1].tobytes()\n            result = (b\'--frame\\r\\n\'b\'Content-Type: image/jpeg\\r\\n\\r\\n\' + frame + b\'\\r\\n\')\n            yield result\n\n\n    # getting average shooting angle\n    shooting_result[\'avg_elbow_angle\'] = round(mean(shooting_pose[\'elbow_angle_list\']), 2)\n    shooting_result[\'avg_knee_angle\'] = round(mean(shooting_pose[\'knee_angle_list\']), 2)\n    shooting_result[\'avg_release_angle\'] = round(mean(during_shooting[\'release_angle_list\']), 2)\n    shooting_result[\'avg_ballInHand_time\'] = round(mean(shooting_pose[\'ballInHand_frames_list\']) * (4 / fps), 2)\n\n    print(""avg"", shooting_result[\'avg_elbow_angle\'])\n    print(""avg"", shooting_result[\'avg_knee_angle\'])\n    print(""avg"", shooting_result[\'avg_release_angle\'])\n    print(""avg"", shooting_result[\'avg_ballInHand_time\'])\n\n    plt.title(""Trajectory Fitting"", figure=fig)\n    plt.ylim(bottom=0, top=height)\n    trajectory_path = os.path.join(\n        os.getcwd(), ""static/detections/trajectory_fitting.jpg"")\n    fig.savefig(trajectory_path)\n    fig.clear()\n    trace_path = os.path.join(os.getcwd(), ""static/detections/basketball_trace.jpg"")\n    cv2.imwrite(trace_path, trace)\n\ndef get_image(image_path, img_name, response):\n    output_path = \'./static/detections/\'\n    # reading the images & apply detection \n    image = cv2.imread(image_path)\n    filename = img_name\n    detection = detect_image(image, response)\n\n    cv2.imwrite(output_path + \'{}\' .format(filename), detection)\n    print(\'output saved to: {}\'.format(output_path + \'{}\'.format(filename)))\n\ndef detectionAPI(response, image_path):\n    image = cv2.imread(image_path)\n    detect_API(response, image)\n'"
src/config.py,0,"b""shooting_result = {\n    'attempts': 0,\n    'made': 0,\n    'miss': 0,\n    'avg_elbow_angle': 0,\n    'avg_knee_angle': 0,\n    'avg_release_angle': 0,\n    'avg_ballInHand_time': 0\n}\n"""
src/utils.py,7,"b'import time\nfrom absl import app, logging\nimport cv2\nimport numpy as np\nimport tensorflow.compat.v1 as tf\nfrom flask import Flask, request, Response, jsonify, send_from_directory, abort\nimport os\nfrom .config import shooting_result\nimport sys\nfrom sys import platform\nimport argparse\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\ntf.disable_v2_behavior()\n\ndef tensorflow_init():\n    MODEL_NAME = \'inference_graph\'\n    PATH_TO_CKPT = MODEL_NAME + \'/frozen_inference_graph.pb\'\n\n    detection_graph = tf.Graph()\n    with detection_graph.as_default():\n        od_graph_def = tf.GraphDef()\n        with tf.gfile.GFile(PATH_TO_CKPT, \'rb\') as fid:\n            serialized_graph = fid.read()\n            od_graph_def.ParseFromString(serialized_graph)\n            tf.import_graph_def(od_graph_def, name=\'\')\n\n    image_tensor = detection_graph.get_tensor_by_name(\'image_tensor:0\')\n    boxes = detection_graph.get_tensor_by_name(\'detection_boxes:0\')\n    scores = detection_graph.get_tensor_by_name(\'detection_scores:0\')\n    classes = detection_graph.get_tensor_by_name(\'detection_classes:0\')\n    num_detections = detection_graph.get_tensor_by_name(\'num_detections:0\')\n    return detection_graph, image_tensor, boxes, scores, classes, num_detections\n\ndef openpose_init():\n    try:\n        if platform == ""win32"":\n            sys.path.append(os.path.dirname(os.getcwd()))\n            import OpenPose.Release.pyopenpose as op\n        else:\n            path = os.path.join(os.getcwd(), \'OpenPose/openpose\')\n            print(path)\n            sys.path.append(path)\n            import pyopenpose as op\n    except ImportError as e:\n        print(""Something went wrong when importing OpenPose"")\n        raise e\n\n    # Custom Params (refer to include/openpose/flags.hpp for more parameters)\n    params = dict()\n    params[""model_folder""] = ""./OpenPose/models""\n\n    # Starting OpenPose\n    opWrapper = op.WrapperPython()\n    opWrapper.configure(params)\n    opWrapper.start()\n\n    # Process Image\n    datum = op.Datum()\n    return datum, opWrapper\n\ndef fit_func(x, a, b, c):\n    return a*(x ** 2) + b * x + c\n\n\ndef trajectory_fit(balls, height, width, shotJudgement, fig):\n    x = [ball[0] for ball in balls]\n    y = [height - ball[1] for ball in balls]\n\n    try:\n        params = curve_fit(fit_func, x, y)\n        [a, b, c] = params[0]   \n    except:\n        print(""fitting error"")\n        a = 0\n        b = 0\n        c = 0\n    x_pos = np.arange(0, width, 1)\n    y_pos = [(a * (x_val ** 2)) + (b * x_val) + c for x_val in x_pos]\n\n    if(shotJudgement == ""MISS""):\n        plt.plot(x, y, \'ro\', figure=fig)\n        plt.plot(x_pos, y_pos, linestyle=\'-\', color=\'red\',\n                 alpha=0.4, linewidth=5, figure=fig)\n    else:\n        plt.plot(x, y, \'go\', figure=fig)\n        plt.plot(x_pos, y_pos, linestyle=\'-\', color=\'green\',\n                 alpha=0.4, linewidth=5, figure=fig)\n\ndef distance(x, y):\n    return ((y[0] - x[0]) ** 2 + (y[1] - x[1]) ** 2) ** (1/2)\n\n\ndef calculateAngle(a, b, c):\n    ba = a - b\n    bc = c - b\n    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))\n    angle = np.arccos(cosine_angle)\n    return round(np.degrees(angle), 2)\n\n\ndef getAngleFromDatum(datum):\n    hipX, hipY, _ = datum.poseKeypoints[0][9]\n    kneeX, kneeY, _ = datum.poseKeypoints[0][10]\n    ankleX, ankleY, _ = datum.poseKeypoints[0][11]\n\n    shoulderX, shoulderY, _ = datum.poseKeypoints[0][2]\n    elbowX, elbowY, _ = datum.poseKeypoints[0][3]\n    wristX, wristY, _ = datum.poseKeypoints[0][4]\n\n    kneeAngle = calculateAngle(np.array([hipX, hipY]), np.array(\n        [kneeX, kneeY]), np.array([ankleX, ankleY]))\n    elbowAngle = calculateAngle(np.array([shoulderX, shoulderY]), np.array(\n        [elbowX, elbowY]), np.array([wristX, wristY]))\n\n    elbowCoord = np.array([int(elbowX), int(elbowY)])\n    kneeCoord = np.array([int(kneeX), int(kneeY)])\n    return elbowAngle, kneeAngle, elbowCoord, kneeCoord\n\ndef detect_shot(frame, trace, width, height, sess, image_tensor, boxes, scores, classes, num_detections, previous, during_shooting, shot_result, fig, datum, opWrapper, shooting_pose):\n    global shooting_result\n\n    if(shot_result[\'displayFrames\'] > 0):\n        shot_result[\'displayFrames\'] -= 1\n    if(shot_result[\'release_displayFrames\'] > 0):\n        shot_result[\'release_displayFrames\'] -= 1\n    if(shooting_pose[\'ball_in_hand\']):\n        shooting_pose[\'ballInHand_frames\'] += 1\n        # print(""ball in hand"")\n\n    # getting openpose keypoints\n    datum.cvInputData = frame\n    opWrapper.emplaceAndPop([datum])\n    try:\n        headX, headY, headConf = datum.poseKeypoints[0][0]\n        handX, handY, handConf = datum.poseKeypoints[0][4]\n        elbowAngle, kneeAngle, elbowCoord, kneeCoord = getAngleFromDatum(datum)\n    except:\n        print(""Something went wrong with OpenPose"")\n        headX = 0\n        headY = 0\n        handX = 0\n        handY = 0\n        elbowAngle = 0\n        kneeAngle = 0\n        elbowCoord = np.array([0, 0])\n        kneeCoord = np.array([0, 0])\n\n    frame_expanded = np.expand_dims(frame, axis=0)\n    # main tensorflow detection\n    (boxes, scores, classes, num_detections) = sess.run(\n        [boxes, scores, classes, num_detections],\n        feed_dict={image_tensor: frame_expanded})\n\n    # displaying openpose, joint angle and release angle\n    frame = datum.cvOutputData\n    cv2.putText(frame, \'Elbow: \' + str(elbowAngle) + \' deg\',\n                (elbowCoord[0] + 65, elbowCoord[1]), cv2.FONT_HERSHEY_COMPLEX, 1.3, (102, 255, 0), 3)\n    cv2.putText(frame, \'Knee: \' + str(kneeAngle) + \' deg\',\n                (kneeCoord[0] + 65, kneeCoord[1]), cv2.FONT_HERSHEY_COMPLEX, 1.3, (102, 255, 0), 3)\n    if(shot_result[\'release_displayFrames\']):\n        cv2.putText(frame, \'Release: \' + str(during_shooting[\'release_angle_list\'][-1]) + \' deg\',\n                    (during_shooting[\'release_point\'][0] - 80, during_shooting[\'release_point\'][1] + 80), cv2.FONT_HERSHEY_COMPLEX, 1.3, (102, 255, 255), 3)\n\n    for i, box in enumerate(boxes[0]):\n        if (scores[0][i] > 0.5):\n            ymin = int((box[0] * height))\n            xmin = int((box[1] * width))\n            ymax = int((box[2] * height))\n            xmax = int((box[3] * width))\n            xCoor = int(np.mean([xmin, xmax]))\n            yCoor = int(np.mean([ymin, ymax]))\n            # Basketball (not head)\n            if(classes[0][i] == 1 and (distance([headX, headY], [xCoor, yCoor]) > 30)):\n\n                # recording shooting pose\n                if(distance([xCoor, yCoor], [handX, handY]) < 120):\n                    shooting_pose[\'ball_in_hand\'] = True\n                    shooting_pose[\'knee_angle\'] = min(\n                        shooting_pose[\'knee_angle\'], kneeAngle)\n                    shooting_pose[\'elbow_angle\'] = min(\n                        shooting_pose[\'elbow_angle\'], elbowAngle)\n                else:\n                    shooting_pose[\'ball_in_hand\'] = False\n\n                # During Shooting\n                if(ymin < (previous[\'hoop_height\'])):\n                    if(not during_shooting[\'isShooting\']):\n                        during_shooting[\'isShooting\'] = True\n\n                    during_shooting[\'balls_during_shooting\'].append(\n                        [xCoor, yCoor])\n\n                    #calculating release angle\n                    if(len(during_shooting[\'balls_during_shooting\']) == 2):\n                        first_shooting_point = during_shooting[\'balls_during_shooting\'][0]\n                        release_angle = calculateAngle(np.array(during_shooting[\'balls_during_shooting\'][1]), np.array(\n                            first_shooting_point), np.array([first_shooting_point[0] + 1, first_shooting_point[1]]))\n                        if(release_angle > 90):\n                            release_angle = 180 - release_angle\n                        during_shooting[\'release_angle_list\'].append(\n                            release_angle)\n                        during_shooting[\'release_point\'] = first_shooting_point\n                        shot_result[\'release_displayFrames\'] = 30\n                        print(""release angle:"", release_angle)\n\n                    #draw purple circle\n                    cv2.circle(img=frame, center=(xCoor, yCoor), radius=7,\n                               color=(235, 103, 193), thickness=3)\n                    cv2.circle(img=trace, center=(xCoor, yCoor), radius=7,\n                               color=(235, 103, 193), thickness=3)\n\n                # Not shooting\n                elif(ymin >= (previous[\'hoop_height\'] - 30) and (distance([xCoor, yCoor], previous[\'ball\']) < 100)):\n                    # the moment when ball go below basket\n                    if(during_shooting[\'isShooting\']):\n                        if(xCoor >= previous[\'hoop\'][0] and xCoor <= previous[\'hoop\'][2]):  # shot\n                            shooting_result[\'attempts\'] += 1\n                            shooting_result[\'made\'] += 1\n                            shot_result[\'displayFrames\'] = 10\n                            shot_result[\'judgement\'] = ""SCORE""\n                            print(""SCORE"")\n                            # draw green trace when miss\n                            for ballCoor in during_shooting[\'balls_during_shooting\']:\n                                cv2.circle(img=trace, center=(ballCoor[0], ballCoor[1]), radius=10,\n                                           color=(82, 168, 50), thickness=-1)\n                        else:  # miss\n                            shooting_result[\'attempts\'] += 1\n                            shooting_result[\'miss\'] += 1\n                            shot_result[\'displayFrames\'] = 10\n                            shot_result[\'judgement\'] = ""MISS""\n                            print(""miss"")\n                            # draw red trace when miss\n                            for ballCoor in during_shooting[\'balls_during_shooting\']:\n                                cv2.circle(img=trace, center=(ballCoor[0], ballCoor[1]), radius=10,\n                                           color=(0, 0, 255), thickness=-1)\n\n                        # reset all variables\n                        trajectory_fit(\n                            during_shooting[\'balls_during_shooting\'], height, width, shot_result[\'judgement\'], fig)\n                        during_shooting[\'balls_during_shooting\'].clear()\n                        during_shooting[\'isShooting\'] = False\n                        shooting_pose[\'ballInHand_frames_list\'].append(\n                            shooting_pose[\'ballInHand_frames\'])\n                        print(""ball in hand frames: "",\n                              shooting_pose[\'ballInHand_frames\'])\n                        shooting_pose[\'ballInHand_frames\'] = 0\n\n                        print(""elbow angle: "", shooting_pose[\'elbow_angle\'])\n                        print(""knee angle: "", shooting_pose[\'knee_angle\'])\n                        shooting_pose[\'elbow_angle_list\'].append(\n                            shooting_pose[\'elbow_angle\'])\n                        shooting_pose[\'knee_angle_list\'].append(\n                            shooting_pose[\'knee_angle\'])\n                        shooting_pose[\'elbow_angle\'] = 370\n                        shooting_pose[\'knee_angle\'] = 370\n\n                    #draw blue circle\n                    cv2.circle(img=frame, center=(xCoor, yCoor), radius=10,\n                               color=(255, 0, 0), thickness=-1)\n                    cv2.circle(img=trace, center=(xCoor, yCoor), radius=10,\n                               color=(255, 0, 0), thickness=-1)\n\n                previous[\'ball\'][0] = xCoor\n                previous[\'ball\'][1] = yCoor\n\n            if(classes[0][i] == 2):  # Rim\n                # cover previous hoop with white rectangle\n                cv2.rectangle(\n                    trace, (previous[\'hoop\'][0], previous[\'hoop\'][1]), (previous[\'hoop\'][2], previous[\'hoop\'][3]), (255, 255, 255), 5)\n                cv2.rectangle(frame, (xmin, ymax),\n                              (xmax, ymin), (48, 124, 255), 5)\n                cv2.rectangle(trace, (xmin, ymax),\n                              (xmax, ymin), (48, 124, 255), 5)\n\n                #display judgement after shot\n                if(shot_result[\'displayFrames\']):\n                    if(shot_result[\'judgement\'] == ""MISS""):\n                        cv2.putText(frame, shot_result[\'judgement\'], (xCoor - 65, yCoor - 65),\n                                    cv2.FONT_HERSHEY_COMPLEX, 3, (0, 0, 255), 8)\n                    else:\n                        cv2.putText(frame, shot_result[\'judgement\'], (xCoor - 65, yCoor - 65),\n                                    cv2.FONT_HERSHEY_COMPLEX, 3, (82, 168, 50), 8)\n\n                previous[\'hoop\'][0] = xmin\n                previous[\'hoop\'][1] = ymax\n                previous[\'hoop\'][2] = xmax\n                previous[\'hoop\'][3] = ymin\n                previous[\'hoop_height\'] = max(ymin, previous[\'hoop_height\'])\n\n    combined = np.concatenate((frame, trace), axis=1)\n    return combined, trace\n\n\ndef detect_image(img, response):\n    height, width = img.shape[:2]\n    detection_graph, image_tensor, boxes, scores, classes, num_detections = tensorflow_init()\n\n    with tf.Session(graph=detection_graph) as sess:\n        img_expanded = np.expand_dims(img, axis=0)\n        (boxes, scores, classes, num_detections) = sess.run(\n            [boxes, scores, classes, num_detections],\n            feed_dict={image_tensor: img_expanded})\n        valid_detections = 0\n\n        for i, box in enumerate(boxes[0]):\n            # print(""detect"")\n            if (scores[0][i] > 0.5):\n                valid_detections += 1\n                ymin = int((box[0] * height))\n                xmin = int((box[1] * width))\n                ymax = int((box[2] * height))\n                xmax = int((box[3] * width))\n                xCoor = int(np.mean([xmin, xmax]))\n                yCoor = int(np.mean([ymin, ymax]))\n                if(classes[0][i] == 1):  # basketball\n                    cv2.circle(img=img, center=(xCoor, yCoor), radius=25,\n                               color=(255, 0, 0), thickness=-1)\n                    cv2.putText(img, ""BALL"", (xCoor - 50, yCoor - 50),\n                                cv2.FONT_HERSHEY_COMPLEX, 3, (255, 0, 0), 8)\n                    print(""add basketball"")\n                    response.append({\n                        \'class\': \'Basketball\',\n                        \'detection_detail\': {\n                            \'confidence\': float(""{:.5f}"".format(scores[0][i])),\n                            \'center_coordinate\': {\'x\': xCoor, \'y\': yCoor},\n                            \'box_boundary\': {\'x_min\': xmin, \'x_max\': xmax, \'y_min\': ymin, \'y_max\': ymax}\n                        }\n                    })\n                if(classes[0][i] == 2):  # Rim\n                    cv2.rectangle(img, (xmin, ymax),\n                                  (xmax, ymin), (48, 124, 255), 10)\n                    cv2.putText(img, ""HOOP"", (xCoor - 65, yCoor - 65),\n                                cv2.FONT_HERSHEY_COMPLEX, 3, (48, 124, 255), 8)\n                    print(""add hoop"")\n                    response.append({\n                        \'class\': \'Hoop\',\n                        \'detection_detail\': {\n                            \'confidence\': float(""{:.5f}"".format(scores[0][i])),\n                            \'center_coordinate\': {\'x\': xCoor, \'y\': yCoor},\n                            \'box_boundary\': {\'x_min\': xmin, \'x_max\': xmax, \'y_min\': ymin, \'y_max\': ymax}\n                        }\n                    })\n        \n        if(valid_detections < 2):\n            for i in range(2):\n                response.append({\n                    \'class\': \'Not Found\',\n                    \'detection_detail\': {\n                        \'confidence\': 0.0,\n                        \'center_coordinate\': {\'x\': 0, \'y\': 0},\n                        \'box_boundary\': {\'x_min\': 0, \'x_max\': 0, \'y_min\': 0, \'y_max\': 0}\n                    }\n                })\n            \n    return img\n\ndef detect_API(response, img):\n    height, width = img.shape[:2]\n    detection_graph, image_tensor, boxes, scores, classes, num_detections = tensorflow_init()\n\n    with tf.Session(graph=detection_graph) as sess:\n        img_expanded = np.expand_dims(img, axis=0)\n        (boxes, scores, classes, num_detections) = sess.run(\n            [boxes, scores, classes, num_detections],\n            feed_dict={image_tensor: img_expanded})\n\n        for i, box in enumerate(boxes[0]):\n            if (scores[0][i] > 0.5):\n                ymin = int((box[0] * height))\n                xmin = int((box[1] * width))\n                ymax = int((box[2] * height))\n                xmax = int((box[3] * width))\n                xCoor = int(np.mean([xmin, xmax]))\n                yCoor = int(np.mean([ymin, ymax]))\n                if(classes[0][i] == 1):  # basketball\n                    response.append({\n                        \'class\': \'Basketball\',\n                        \'detection_detail\': {\n                            \'confidence\': float(scores[0][i]),\n                            \'center_coordinate\': {\'x\': xCoor, \'y\': yCoor},\n                            \'box_boundary\': {\'x_min\': xmin, \'x_max\': xmax, \'y_min\': ymin, \'y_max\': ymax}\n                        }\n                    })\n                if(classes[0][i] == 2):  # Rim\n                    response.append({\n                        \'class\': \'Hoop\',\n                        \'detection_detail\': {\n                            \'confidence\': float(scores[0][i]),\n                            \'center_coordinate\': {\'x\': xCoor, \'y\': yCoor},\n                            \'box_boundary\': {\'x_min\': xmin, \'x_max\': xmax, \'y_min\': ymin, \'y_max\': ymax}\n                        }\n                    })\n\n'"
OpenPose/openpose/__init__.py,0,b'from . import pyopenpose as pyopenpose\n'
