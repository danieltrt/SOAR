file_path,api_count,code
setup.py,0,"b'import os\nimport re\nimport glob\nfrom setuptools import setup, find_packages\n\n\ndef find_version(*paths):\n    fname = os.path.join(*paths)\n    with open(fname) as fhandler:\n        version_file = fhandler.read()\n        version_match = re.search(r""^__VERSION__ = [\'\\""]([^\'\\""]*)[\'\\""]"",\n                                  version_file, re.M)\n\n    if not version_match:\n        raise RuntimeError(""Unable to find version string in %s"" % (fname,))\n\n    version = version_match.group(1)\n\n    return version\n\n\ndef find_readme(*paths):\n    with open(os.path.join(*paths)) as f:\n        return f.read()\n\n\nversion = find_version(\'tfmesos\', \'__init__.py\')\nsetup(\n    name=\'tfmesos\',\n    version=version,\n    packages=find_packages(),\n    license=\'BSD License\',\n    description=""Tensorflow on Mesos"",\n    long_description=find_readme(\'README.rst\'),\n    author=""Zhongbo Tian"",\n    author_email=""tianzhongbo@douban.com"",\n    download_url=(\n        \'https://github.com/douban/tfmesos/archive/%s.tar.gz\' % version\n    ),\n    classifiers=[\n        ""Intended Audience :: Developers"",\n        ""License :: OSI Approved :: BSD License"",\n        ""Programming Language :: Python"",\n        ""Programming Language :: Python :: Implementation :: CPython"",\n        ""Operating System :: POSIX :: Linux"",\n        ""Topic :: Software Development :: Libraries""\n    ],\n    install_requires=[\n        \'six\',\n        \'addict\',\n        \'pymesos>=0.2.10\',\n    ],\n    extras_require={\n        \'cpu\': [\'tensorflow>=0.8.0\'],\n        \'gpu\': [\'tensorflow-gpu>=0.8.0\'],\n    },\n    scripts=glob.glob(os.path.join(\'script\', \'*\')),\n)\n'"
examples/matrix_factorization.py,14,"b'# coding: utf-8\nfrom __future__ import print_function\nimport sys\nimport numpy as np\nimport tensorflow as tf\nfrom tfmesos import cluster\n\n\n\nINFINITY = 10e+12\n\n\nclass NMF(object):\n\n    def __init__(self, np_matrix, rank,\n                 learning_rate=0.1):\n        matrix = tf.constant(np_matrix, dtype=tf.float32)\n        scale = 2 * np.sqrt(np_matrix.mean() / rank)\n        initializer = tf.random_uniform_initializer(maxval=scale)\n\n        with tf.device(\'/job:ps/task:0\'):\n            self.matrix_W = tf.get_variable(\n                ""W"", (np_matrix.shape[0], rank), initializer=initializer\n            )\n        with tf.device(""/job:ps/task:1""):\n            self.matrix_H = tf.get_variable(\n                ""H"", (rank, np_matrix.shape[1]), initializer=initializer\n            )\n\n        matrix_WH = tf.matmul(self.matrix_W, self.matrix_H)\n        f_norm = tf.reduce_sum(tf.pow(matrix - matrix_WH, 2))\n\n        nn_w = tf.reduce_sum(tf.abs(self.matrix_W) - self.matrix_W)\n        nn_h = tf.reduce_sum(tf.abs(self.matrix_H) - self.matrix_H)\n        constraint = INFINITY * (nn_w + nn_h)\n        self.loss = f_norm + constraint\n        self.constraint = constraint\n\n        self.optimizer = tf.train.GradientDescentOptimizer(\n            learning_rate\n        ).minimize(self.loss)\n\n    def run(self, session):\n        with tf.device(""/job:worker/task:0""):\n            current_loss, current_constraint, _ = session.run([\n                self.loss, self.constraint, self.optimizer\n            ])\n\n        return self.matrix_W.eval(), self.matrix_H.eval(), self.loss.eval()\n\n\ndef main(argv):\n    max_iter = 100\n    matrix = np.random.random((1000, 1000))\n    jobs_def = [\n        {\n            ""name"": ""ps"",\n            ""num"": 2\n        },\n        {\n            ""name"": ""worker"",\n            ""num"": 2\n        },\n    ]\n    mesos_master = argv[1]\n    nmf = NMF(matrix, 200)\n    with cluster(jobs_def, master=mesos_master) as c:\n        with tf.Session(c.targets[\'/job:worker/task:1\']) as session:\n            session.run(tf.global_variables_initializer())\n            for i in range(max_iter):\n                mat_w, mat_h, loss = nmf.run(session)\n                print(""loss#%d: %s"" % (i, loss))\n\n    err = np.power(matrix - np.matmul(mat_w, mat_h), 2)\n    print(""err mean: %s"" % err.mean())\n    print(""loss: %s"" % loss)\n\n\nif __name__ == \'__main__\':\n    main(sys.argv)\n'"
examples/plus.py,6,"b'# coding: utf-8\nfrom __future__ import print_function\n\nimport sys\nimport logging\nimport tensorflow as tf\nfrom tfmesos import cluster\n\n\ndef main(argv):\n    jobs_def = [\n        {\n            ""name"": ""ps"",\n            ""num"": 2\n        },\n        {\n            ""name"": ""worker"",\n            ""num"": 2\n        },\n    ]\n    mesos_master = sys.argv[1]\n    with cluster(jobs_def, master=mesos_master, quiet=False) as c:\n        with tf.device(\'/job:ps/task:0\'):\n            a = tf.constant(10)\n\n        with tf.device(\'/job:ps/task:1\'):\n            b = tf.constant(32)\n\n        with tf.device(""/job:worker/task:1""):\n            op = a + b\n\n        with tf.Session(c.targets[\'/job:worker/task:0\']) as sess:\n            print(sess.run(op))\n\n\nif __name__ == \'__main__\':\n    logging.basicConfig()\n    main(sys.argv)\n'"
tfmesos/__init__.py,0,"b""from contextlib import contextmanager\nfrom tfmesos.scheduler import Job, TFMesosScheduler\n\n__VERSION__ = '0.0.10'\n\n\n@contextmanager\ndef cluster(jobs, **kw):\n    if isinstance(jobs, dict):\n        jobs = [Job(**jobs)]\n\n    if isinstance(jobs, Job):\n        jobs = [jobs]\n\n    jobs = [job if isinstance(job, Job) else Job(**job)\n            for job in jobs]\n    s = TFMesosScheduler(jobs, **kw)\n    try:\n        s.start()\n        yield s\n    finally:\n        s.stop()\n"""
tfmesos/scheduler.py,0,"b'import os\nimport sys\nimport math\nimport select\nimport socket\nimport getpass\nimport logging\nimport textwrap\nfrom addict import Dict\nfrom six import iteritems\nfrom six.moves import urllib\nfrom pymesos import Scheduler, MesosSchedulerDriver\nfrom tfmesos.utils import send, recv, setup_logger\nimport uuid\n\n\nFOREVER = 0xFFFFFFFF\nlogger = logging.getLogger(__name__)\n\n\nclass Job(object):\n\n    def __init__(self, name, num, cpus=1.0, mem=1024.0,\n                 gpus=0, cmd=None, start=0):\n        self.name = name\n        self.num = num\n        self.cpus = cpus\n        self.gpus = gpus\n        self.mem = mem\n        self.cmd = cmd\n        self.start = start\n\n\nclass Task(object):\n\n    def __init__(self, mesos_task_id, job_name, task_index,\n                 cpus=1.0, mem=1024.0, gpus=0, cmd=None, volumes={}, env={}):\n        self.mesos_task_id = mesos_task_id\n        self.job_name = job_name\n        self.task_index = task_index\n\n        self.cpus = cpus\n        self.gpus = gpus\n        self.mem = mem\n        self.cmd = cmd\n        self.volumes = volumes\n        self.env = env\n        self.offered = False\n\n        self.addr = None\n        self.connection = None\n        self.initalized = False\n\n    def __str__(self):\n        return textwrap.dedent(\'\'\'\n        <Task\n          mesos_task_id=%s\n          addr=%s\n        >\'\'\' % (self.mesos_task_id, self.addr))\n\n    def to_task_info(self, offer, master_addr, gpu_uuids=[],\n                     gpu_resource_type=None, containerizer_type=\'MESOS\',\n                     force_pull_image=False):\n        ti = Dict()\n        ti.task_id.value = str(self.mesos_task_id)\n        ti.agent_id.value = offer.agent_id.value\n        ti.name = \'/job:%s/task:%s\' % (self.job_name, self.task_index)\n        ti.resources = resources = []\n\n        cpus = Dict()\n        resources.append(cpus)\n        cpus.name = \'cpus\'\n        cpus.type = \'SCALAR\'\n        cpus.scalar.value = self.cpus\n\n        mem = Dict()\n        resources.append(mem)\n        mem.name = \'mem\'\n        mem.type = \'SCALAR\'\n        mem.scalar.value = self.mem\n\n        image = os.environ.get(\'DOCKER_IMAGE\')\n\n        if image is not None:\n            if containerizer_type == \'DOCKER\':\n                ti.container.type = \'DOCKER\'\n                ti.container.docker.image = image\n                ti.container.docker.force_pull_image = force_pull_image\n\n                ti.container.docker.parameters = parameters = []\n                p = Dict()\n                p.key = \'memory-swap\'\n                p.value = \'-1\'\n                parameters.append(p)\n\n                if self.gpus and gpu_uuids:\n                    hostname = offer.hostname\n                    url = \'http://%s:3476/docker/cli?dev=%s\' % (\n                        hostname, urllib.parse.quote(\n                            \' \'.join(gpu_uuids)\n                        )\n                    )\n\n                    try:\n                        docker_args = urllib.request.urlopen(url).read()\n                        for arg in docker_args.split():\n                            k, v = arg.split(\'=\')\n                            assert k.startswith(\'--\')\n                            k = k[2:]\n                            p = Dict()\n                            parameters.append(p)\n                            p.key = k\n                            p.value = v\n                    except Exception:\n                        logger.exception(\n                            \'fail to determine remote device parameter,\'\n                            \' disable gpu resources\'\n                        )\n                        gpu_uuids = []\n\n            elif containerizer_type == \'MESOS\':\n                ti.container.type = \'MESOS\'\n                ti.container.mesos.image.type = \'DOCKER\'\n                ti.container.mesos.image.docker.name = image\n                # ""cached"" means the opposite of ""force_pull_image""\n                ti.container.mesos.image.cached = not force_pull_image\n\n            else:\n                assert False, (\n                    \'Unsupported containerizer: %s\' % containerizer_type\n                )\n\n            ti.container.volumes = volumes = []\n\n            for path in [\'/etc/passwd\', \'/etc/group\']:\n                v = Dict()\n                volumes.append(v)\n                v.host_path = v.container_path = path\n                v.mode = \'RO\'\n\n            for src, dst in iteritems(self.volumes):\n                v = Dict()\n                volumes.append(v)\n                v.container_path = dst\n                v.host_path = src\n                v.mode = \'RW\'\n\n        if self.gpus and gpu_uuids and gpu_resource_type is not None:\n            if gpu_resource_type == \'SET\':\n                gpus = Dict()\n                resources.append(gpus)\n                gpus.name = \'gpus\'\n                gpus.type = \'SET\'\n                gpus.set.item = gpu_uuids\n            else:\n                gpus = Dict()\n                resources.append(gpus)\n                gpus.name = \'gpus\'\n                gpus.type = \'SCALAR\'\n                gpus.scalar.value = len(gpu_uuids)\n\n        ti.command.shell = True\n        cmd = [\n            sys.executable, \'-m\', \'%s.server\' % __package__,\n            str(self.mesos_task_id), master_addr\n        ]\n        ti.command.value = \' \'.join(cmd)\n        ti.command.environment.variables = variables = [\n            Dict(name=name, value=value)\n            for name, value in self.env.items()\n            if name != \'PYTHONPATH\'\n        ]\n        env = Dict()\n        variables.append(env)\n        env.name = \'PYTHONPATH\'\n        env.value = \':\'.join(sys.path)\n        return ti\n\n\nclass TFMesosScheduler(Scheduler):\n    MAX_FAILURE_COUNT = 3\n\n    def __init__(self, task_spec, role=None, master=None, name=None,\n                 quiet=False, volumes={}, containerizer_type=None,\n                 force_pull_image=False, forward_addresses=None,\n                 protocol=\'grpc\', env={}, extra_config={}):\n        self.started = False\n        self.master = master or os.environ[\'MESOS_MASTER\']\n        self.name = name or \'[tensorflow] %s %s\' % (\n            os.path.abspath(sys.argv[0]), \' \'.join(sys.argv[1:]))\n        self.task_spec = task_spec\n        self.containerizer_type = containerizer_type\n        self.force_pull_image = force_pull_image\n        self.protocol = protocol\n        self.extra_config = extra_config\n        self.forward_addresses = forward_addresses\n        self.role = role or \'*\'\n        self.tasks = {}\n        self.task_failure_count = {}\n        self.job_finished = {}\n        for job in task_spec:\n            self.job_finished[job.name] = 0\n            for task_index in range(job.start, job.num):\n                mesos_task_id = str(uuid.uuid4())\n                task = Task(\n                    mesos_task_id,\n                    job.name,\n                    task_index,\n                    cpus=job.cpus,\n                    mem=job.mem,\n                    gpus=job.gpus,\n                    cmd=job.cmd,\n                    volumes=volumes,\n                    env=env\n                )\n                self.tasks[mesos_task_id] = task\n                self.task_failure_count[self.decorated_task_index(task)] = 0\n\n        if not quiet:\n            global logger\n            setup_logger(logger)\n\n    def resourceOffers(self, driver, offers):\n        \'\'\'\n        Offer resources and launch tasks\n        \'\'\'\n\n        for offer in offers:\n            if all(task.offered for id, task in iteritems(self.tasks)):\n                self.driver.suppressOffers()\n                driver.declineOffer(offer.id, Dict(refuse_seconds=FOREVER))\n                continue\n\n            offered_cpus = offered_mem = 0.0\n            offered_gpus = []\n            offered_tasks = []\n            gpu_resource_type = None\n\n            for resource in offer.resources:\n                if resource.name == \'cpus\':\n                    offered_cpus = resource.scalar.value\n                elif resource.name == \'mem\':\n                    offered_mem = resource.scalar.value\n                elif resource.name == \'gpus\':\n                    if resource.type == \'SET\':\n                        offered_gpus = resource.set.item\n                    else:\n                        offered_gpus = list(range(int(resource.scalar.value)))\n\n                    gpu_resource_type = resource.type\n\n            for id, task in iteritems(self.tasks):\n                if task.offered:\n                    continue\n\n                if not (task.cpus <= offered_cpus and\n                        task.mem <= offered_mem and\n                        task.gpus <= len(offered_gpus)):\n\n                    continue\n\n                offered_cpus -= task.cpus\n                offered_mem -= task.mem\n                gpus = int(math.ceil(task.gpus))\n                gpu_uuids = offered_gpus[:gpus]\n                offered_gpus = offered_gpus[gpus:]\n                task.offered = True\n                offered_tasks.append(\n                    task.to_task_info(\n                        offer, self.addr, gpu_uuids=gpu_uuids,\n                        gpu_resource_type=gpu_resource_type,\n                        containerizer_type=self.containerizer_type,\n                        force_pull_image=self.force_pull_image\n                    )\n                )\n\n            driver.launchTasks(offer.id, offered_tasks)\n\n    @property\n    def targets(self):\n        targets = {}\n        for id, task in iteritems(self.tasks):\n            target_name = \'/job:%s/task:%s\' % (task.job_name, task.task_index)\n            grpc_addr = \'grpc://%s\' % task.addr\n            targets[target_name] = grpc_addr\n        return targets\n\n    def _start_tf_cluster(self):\n        cluster_def = {}\n\n        tasks = sorted(self.tasks.values(), key=lambda task: task.task_index)\n        for task in tasks:\n            cluster_def.setdefault(task.job_name, []).append(task.addr)\n\n        for id, task in iteritems(self.tasks):\n            response = {\n                \'job_name\': task.job_name,\n                \'task_index\': task.task_index,\n                \'cpus\': task.cpus,\n                \'mem\': task.mem,\n                \'gpus\': task.gpus,\n                \'cmd\': task.cmd,\n                \'cwd\': os.getcwd(),\n                \'cluster_def\': cluster_def,\n                \'forward_addresses\': self.forward_addresses,\n                \'extra_config\': self.extra_config,\n                \'protocol\': self.protocol\n            }\n            send(task.connection, response)\n            assert recv(task.connection) == \'ok\'\n            logger.info(\n                \'Device /job:%s/task:%s activated @ grpc://%s \',\n                task.job_name,\n                task.task_index,\n                task.addr\n\n            )\n            task.connection.close()\n\n    def start(self):\n\n        def readable(fd):\n            return bool(select.select([fd], [], [], 0.1)[0])\n\n        lfd = socket.socket()\n        try:\n            lfd.bind((\'\', 0))\n            self.addr = \'%s:%s\' % (socket.gethostname(), lfd.getsockname()[1])\n            lfd.listen(10)\n            framework = Dict()\n            framework.user = getpass.getuser()\n            framework.name = self.name\n            framework.hostname = socket.gethostname()\n            framework.role = self.role\n\n            self.driver = MesosSchedulerDriver(\n                self, framework, self.master, use_addict=True\n            )\n            self.driver.start()\n            task_start_count = 0\n            while any((not task.initalized\n                       for id, task in iteritems(self.tasks))):\n                if readable(lfd):\n                    c, _ = lfd.accept()\n                    if readable(c):\n                        mesos_task_id, addr = recv(c)\n                        task = self.tasks[mesos_task_id]\n                        task.addr = addr\n                        task.connection = c\n                        task.initalized = True\n                        task_start_count += 1\n                        logger.info(\'Task %s with mesos_task_id %s has \'\n                                    \'registered\',\n                                    \'{}:{}\'.format(task.job_name,\n                                                   task.task_index),\n                                    mesos_task_id)\n                        logger.info(\'Out of %d tasks \'\n                                    \'%d tasks have been registered\',\n                                    len(self.tasks), task_start_count)\n                    else:\n                        c.close()\n\n            self.started = True\n            self._start_tf_cluster()\n        except Exception:\n            self.stop()\n            raise\n        finally:\n            lfd.close()\n\n    def registered(self, driver, framework_id, master_info):\n        logger.info(\n            \'Tensorflow cluster registered. \'\n            \'( http://%s:%s/#/frameworks/%s )\',\n            master_info.hostname, master_info.port, framework_id.value\n        )\n\n        if self.containerizer_type is None:\n            version = tuple(int(x) for x in driver.version.split("".""))\n            self.containerizer_type = (\n                \'MESOS\' if version >= (1, 0, 0) else \'DOCKER\'\n            )\n\n    def statusUpdate(self, driver, update):\n        logger.debug(\'Received status update %s\', str(update.state))\n        mesos_task_id = update.task_id.value\n        if self._is_terminal_state(update.state):\n            task = self.tasks.get(mesos_task_id)\n            if task is None:\n                # This should be very rare and hence making this info.\n                logger.info(""Task not found for mesos task id {}""\n                            .format(mesos_task_id))\n                return\n            if self.started:\n                if update.state != \'TASK_FINISHED\':\n                    logger.error(\'Task failed: %s, %s with state %s\', task,\n                                 update.message, update.state)\n                    raise RuntimeError(\n                        \'Task %s failed! %s with state %s\' %\n                        (task, update.message, update.state)\n                    )\n                else:\n                    self.job_finished[task.job_name] += 1\n            else:\n                logger.warn(\'Task failed while launching the server: %s, \'\n                            \'%s with state %s\', task,\n                            update.message, update.state)\n\n                if task.connection:\n                    task.connection.close()\n\n                self.task_failure_count[self.decorated_task_index(task)] += 1\n\n                if self._can_revive_task(task):\n                    self.revive_task(driver, mesos_task_id, task)\n                else:\n                    raise RuntimeError(\'Task %s failed %s with state %s and \'\n                                       \'retries=%s\' %\n                                       (task, update.message, update.state,\n                                        TFMesosScheduler.MAX_FAILURE_COUNT))\n\n    def revive_task(self, driver, mesos_task_id, task):\n        logger.info(\'Going to revive task %s \', task.task_index)\n        self.tasks.pop(mesos_task_id)\n        task.offered = False\n        task.addr = None\n        task.connection = None\n        new_task_id = task.mesos_task_id = str(uuid.uuid4())\n        self.tasks[new_task_id] = task\n        driver.reviveOffers()\n\n    def _can_revive_task(self, task):\n        return self.task_failure_count[self.decorated_task_index(task)] < \\\n            TFMesosScheduler.MAX_FAILURE_COUNT\n\n    @staticmethod\n    def decorated_task_index(task):\n        return \'{}.{}\'.format(task.job_name, str(task.task_index))\n\n    @staticmethod\n    def _is_terminal_state(task_state):\n        return task_state in [""TASK_FINISHED"", ""TASK_FAILED"", ""TASK_KILLED"",\n                              ""TASK_ERROR""]\n\n    def slaveLost(self, driver, agent_id):\n        if self.started:\n            logger.error(\'Slave %s lost:\', agent_id.value)\n            raise RuntimeError(\'Slave %s lost\' % agent_id)\n\n    def executorLost(self, driver, executor_id, agent_id, status):\n        if self.started:\n            logger.error(\'Executor %s lost:\', executor_id.value)\n            raise RuntimeError(\'Executor %s@%s lost\' % (executor_id, agent_id))\n\n    def error(self, driver, message):\n        logger.error(\'Mesos error: %s\', message)\n        raise RuntimeError(\'Error \' + message)\n\n    def stop(self):\n        logger.debug(\'exit\')\n\n        if hasattr(self, \'tasks\'):\n            for id, task in iteritems(self.tasks):\n                if task.connection:\n                    task.connection.close()\n\n            del self.tasks\n\n        if hasattr(self, \'driver\'):\n            self.driver.stop()\n            self.driver.join()\n            del self.driver\n\n    def finished(self):\n        return any(\n            self.job_finished[job.name] >= job.num for job in self.task_spec\n        )\n\n    def processHeartBeat(self):\n        # compatibility with pymesos\n        pass\n'"
tfmesos/server.py,3,"b'# coding: utf-8\n\nimport os\nimport sys\nimport socket\nimport subprocess\nimport tensorflow as tf\nimport logging\nfrom tfmesos.utils import send, recv\n\nlogger = logging.getLogger(__name__)\n\n\ndef main(argv):\n    mesos_task_id, maddr = argv[1:]\n    maddr = maddr.split(\':\', 2)\n    maddr = (maddr[0], int(maddr[1]))\n    lfd = socket.socket()\n    lfd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    lfd.bind((\'\', 0))\n    addr = ""%s:%s"" % (socket.gethostname(), lfd.getsockname()[1])\n    job_name = None\n    task_index = None\n    cpus = None\n    c = socket.socket()\n    c.connect(maddr)\n    send(c, (mesos_task_id, addr))\n    response = recv(c)\n    cluster_def = response[""cluster_def""]\n    job_name = response[""job_name""]\n    task_index = response[""task_index""]\n    cpus = response[""cpus""]\n    gpus = response[""gpus""]\n    cmd = response[""cmd""]\n    cwd = response[""cwd""]\n    extra_config = response[\'extra_config\']\n\n    forward_addresses = response[\'forward_addresses\']\n    protocol = response[\'protocol\']\n\n    forward_fd = None\n    grpc_addr = \'/job:%s/task:%s\' % (job_name, task_index)\n    if forward_addresses and grpc_addr in forward_addresses:\n        addr = forward_addresses[grpc_addr]\n        forward_fd = socket.socket()\n        forward_fd.connect(addr)\n\n    send(c, \'ok\')\n    c.close()\n\n    if cmd is None:\n        server_def = tf.train.ServerDef(\n            cluster=tf.train.ClusterSpec(cluster_def).as_cluster_def(),\n            job_name=job_name,\n            task_index=task_index,\n            protocol=protocol,\n        )\n\n        server_def.default_session_config.device_count[""CPU""] = int(cpus)\n        server_def.default_session_config.device_count[""GPU""] = int(gpus)\n        server = tf.train.Server(server_def)\n\n        try:\n            server.join()\n        except Exception:\n            return 0\n    else:\n        initial_cmd = extra_config.get(\'initializer\')\n        if initial_cmd is not None:\n            subprocess.check_call(initial_cmd, shell=True)\n\n        server_name = \'ps\'\n        worker_name = \'worker\'\n        ps_hosts = \',\'.join(cluster_def[server_name])\n        worker_hosts = \',\'.join(cluster_def[worker_name])\n        env = os.environ.copy()\n        env.update({\n            \'PYTHONUNBUFFERED\': \'1\',\n            \'TFMESOS_PS_HOSTS\': ps_hosts,\n            \'TFMESOS_WORKER_HOSTS\': worker_hosts,\n            \'TFMESOS_JOB_NAME\': job_name,\n            \'TFMESOS_TASK_INDEX\': str(task_index),\n            \'TFMESOS_DISTRIBUTED\': \'1\'\n        })\n\n        prefix = \'[%s:%s] \' % (job_name, task_index)\n        prefix = prefix.encode(\'ascii\')\n\n        cmd = cmd.format(\n            ps_hosts=ps_hosts, worker_hosts=worker_hosts,\n            job_name=job_name, task_index=task_index\n        )\n        out = os.fdopen(sys.stdout.fileno(), \'wb\', 1)\n        try:\n            p = subprocess.Popen(\n                cmd, shell=True, cwd=cwd, stdout=subprocess.PIPE,\n                bufsize=1, env=env\n            )\n            for l in iter(p.stdout.readline, b\'\'):\n                out.write(l)\n                if forward_fd:\n                    forward_fd.send(prefix + l)\n\n            return p.wait()\n        finally:\n            final_cmd = extra_config.get(\'finalizer\')\n            if final_cmd is not None:\n                logger.info(\'Running clean up command {}\'.format(final_cmd))\n                subprocess.check_call(final_cmd, shell=True)\n\n            out.close()\n            if forward_fd:\n                forward_fd.close()\n\n\nif __name__ == \'__main__\':\n    sys.exit(main(sys.argv))\n'"
tfmesos/utils.py,0,"b""import struct\nimport logging\nfrom six.moves import cPickle as pickle\n\n\ndef send(fd, o):\n    d = pickle.dumps(o)\n    fd.send(struct.pack('>I', len(d)) + d)\n\n\ndef recv(fd):\n    d = fd.recv(struct.calcsize('>I'))\n    assert len(d) == struct.calcsize('>I'), repr(d)\n    size, = struct.unpack('>I', d)\n    return pickle.loads(fd.recv(size))\n\n\ndef setup_logger(logger):\n    FORMAT = '%(asctime)-11s [%(levelname)s] [%(name)-9s] %(message)s'\n    formatter = logging.Formatter(FORMAT)\n    logger.setLevel(logging.INFO)\n\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.DEBUG)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n    return logger\n"""
examples/mnist/mnist.py,17,"b'import argparse\nimport tensorflow as tf\nfrom tensorflow.contrib.learn.python.learn.datasets.mnist import read_data_sets\nfrom tfmesos import cluster\nfrom threading import Thread, RLock\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\'-w\', \'--nworker\', type=int, default=1)\nparser.add_argument(\'-s\', \'--nserver\', type=int, default=1)\nparser.add_argument(\'-Gw\', \'--worker-gpus\', type=int, default=0)\nparser.add_argument(\'-C\', \'--containerizer_type\', choices=[""MESOS"", ""DOCKER""], type=lambda s: s.upper(), nargs=\'?\')\nparser.add_argument(\'-P\', \'--protocol\', type=str)\nargs, cmd = parser.parse_known_args()\nmaster = cmd[0] if cmd else None\nnworker = args.nworker\nnserver = args.nserver\n\nextra_kw = {}\nif args.containerizer_type:\n    extra_kw[\'containerizer_type\'] = args.containerizer_type\n\nif args.protocol:\n    extra_kw[\'protocol\'] = args.protocol\n\n\njobs_def = [\n    {\n        ""name"": ""ps"",\n        ""num"": nserver\n    },\n    {\n        ""name"": ""worker"",\n        ""num"": nworker,\n        ""gpus"": args.worker_gpus,\n    },\n]\n\n_lock = RLock()\nmnist = read_data_sets(""MNIST_data/"", one_hot=True)\nwith cluster(jobs_def, master=master, quiet=False, **extra_kw) as c:\n    graph = tf.Graph()\n    with graph.as_default():\n        with tf.device(tf.train.replica_device_setter(ps_tasks=nserver)):\n            W = tf.Variable(tf.zeros([784, 10]))\n            b = tf.Variable(tf.zeros([10]))\n            global_step = tf.Variable(0)\n            x = tf.placeholder(tf.float32, [None, 784])\n            y = tf.nn.softmax(tf.matmul(x, W) + b)\n            y_ = tf.placeholder(tf.float32, [None, 10])\n            cross_entropy = -tf.reduce_sum(y_*tf.log(y))\n\n            steps = []\n            for i in range(nworker):\n                with tf.device(\'/job:worker/task:%d\' % i):\n                    steps.append(tf.train.GradientDescentOptimizer(0.005).minimize(cross_entropy, global_step=global_step))\n\n            correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))\n            accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n\n            init_op = tf.global_variables_initializer()\n            coord = tf.train.Coordinator()\n\n        def train(i):\n            with graph.as_default():\n                with tf.Session(c.targets[\'/job:worker/task:%d\' % i]) as sess:\n                    step = 0\n                    while not coord.should_stop() and step < 10000:\n                        with _lock:\n                            batch_xs, batch_ys = mnist.train.next_batch(100)\n\n                        _, step = sess.run([steps[i], global_step], feed_dict={x: batch_xs, y_: batch_ys})\n                    coord.request_stop()\n\n        with tf.Session(c.targets[\'/job:worker/task:0\']) as sess:\n            sess.run(init_op)\n            threads = [Thread(target=train, args=(i,)) for i in range(nworker)]\n            for t in threads:\n                t.start()\n\n            coord.join(threads)\n            print(sess.run(accuracy, feed_dict={x: mnist.test.images, y_: mnist.test.labels}))\n'"
examples/mnist/mnist_replica.py,25,"b'# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n""""""Distributed MNIST training and validation, with model replicas.\n\nA simple softmax model with one hidden layer is defined. The parameters\n(weights and biases) are located on two parameter servers (ps), while the\nops are defined on a worker node. The TF sessions also run on the worker\nnode.\nMultiple invocations of this script can be done in parallel, with different\nvalues for --worker_index. There should be exactly one invocation with\n--worker_index, which will create a master session that carries out variable\ninitialization. The other, non-master, sessions will wait for the master\nsession to finish the initialization before proceeding to the training stage.\n\nThe coordination between the multiple worker invocations occurs due to\nthe definition of the parameters on the same ps devices. The parameter updates\nfrom one worker is visible to all other workers. As such, the workers can\nperform forward computation and gradient calculation in parallel, which\nshould lead to increased training speed for the simple model.\n""""""\n\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport math\nimport sys\nimport tempfile\nimport time\n\nimport tensorflow as tf\nfrom tensorflow.contrib.learn.python.learn.datasets.mnist import read_data_sets\n\n\nflags = tf.app.flags\nflags.DEFINE_string(""data_dir"", ""/tmp/mnist-data"",\n                    ""Directory for storing mnist data"")\nflags.DEFINE_boolean(""download_only"", False,\n                     ""Only perform downloading of data; Do not proceed to ""\n                     ""session preparation, model definition or training"")\nflags.DEFINE_integer(""worker_index"", 0,\n                     ""Worker task index, should be >= 0. worker_index=0 is ""\n                     ""the master worker task the performs the variable ""\n                     ""initialization "")\nflags.DEFINE_string(""ps_hosts"", """",\n                    ""Comma-separated list of hostname:port pairs"")\nflags.DEFINE_string(""worker_hosts"", """",\n                    ""Comma-separated list of hostname:port pairs"")\nflags.DEFINE_string(""job_name"", """", ""One of \'ps\', \'worker\'"")\nflags.DEFINE_integer(""replicas_to_aggregate"", None,\n                     ""Number of replicas to aggregate before parameter update""\n                     ""is applied (For sync_replicas mode only; default: ""\n                     ""num_workers)"")\nflags.DEFINE_integer(""hidden_units"", 100,\n                     ""Number of units in the hidden layer of the NN"")\nflags.DEFINE_integer(""train_steps"", 200,\n                     ""Number of (global) training steps to perform"")\nflags.DEFINE_integer(""batch_size"", 100, ""Training batch size"")\nflags.DEFINE_float(""learning_rate"", 0.01, ""Learning rate"")\nflags.DEFINE_boolean(""sync_replicas"", False,\n                     ""Use the sync_replicas (synchronized replicas) mode, ""\n                     ""wherein the parameter updates from workers are aggregated ""\n                     ""before applied to avoid stale gradients"")\nFLAGS = flags.FLAGS\n\n\nIMAGE_PIXELS = 28\n\n\ndef main(unused_argv):\n  ps_hosts = FLAGS.ps_hosts.split("","")\n  worker_hosts = FLAGS.worker_hosts.split("","")\n  cluster = tf.train.ClusterSpec({""ps"": ps_hosts, ""worker"": worker_hosts})\n  server = tf.train.Server(cluster,\n                           job_name=FLAGS.job_name,\n                           task_index=FLAGS.worker_index)\n\n\n  if FLAGS.job_name == ""ps"":\n    server.join()\n    sys.exit(0)\n    \n  mnist = read_data_sets(FLAGS.data_dir, one_hot=True)\n  if FLAGS.download_only:\n    sys.exit(0)\n\n  num_workers = len(worker_hosts)\n  worker_grpc_url = \'grpc://\' + worker_hosts[0]\n  print(""Worker GRPC URL: %s"" % worker_grpc_url)\n  print(""Worker index = %d"" % FLAGS.worker_index)\n  print(""Number of workers = %d"" % num_workers)\n\n  is_chief = (FLAGS.worker_index == 0)\n\n  if FLAGS.sync_replicas:\n    if FLAGS.replicas_to_aggregate is None:\n      replicas_to_aggregate = num_workers\n    else:\n      replicas_to_aggregate = FLAGS.replicas_to_aggregate\n\n  # Construct device setter object\n  device_setter = tf.train.replica_device_setter(cluster=cluster)\n\n  # The device setter will automatically place Variables ops on separate\n  # parameter servers (ps). The non-Variable ops will be placed on the workers.\n  with tf.device(device_setter):\n    global_step = tf.Variable(0, name=""global_step"", trainable=False)\n\n    # Variables of the hidden layer\n    hid_w = tf.Variable(\n        tf.truncated_normal([IMAGE_PIXELS * IMAGE_PIXELS, FLAGS.hidden_units],\n                            stddev=1.0 / IMAGE_PIXELS), name=""hid_w"")\n    hid_b = tf.Variable(tf.zeros([FLAGS.hidden_units]), name=""hid_b"")\n\n    # Variables of the softmax layer\n    sm_w = tf.Variable(\n        tf.truncated_normal([FLAGS.hidden_units, 10],\n                            stddev=1.0 / math.sqrt(FLAGS.hidden_units)),\n        name=""sm_w"")\n    sm_b = tf.Variable(tf.zeros([10]), name=""sm_b"")\n\n    # Ops: located on the worker specified with FLAGS.worker_index\n    x = tf.placeholder(tf.float32, [None, IMAGE_PIXELS * IMAGE_PIXELS])\n    y_ = tf.placeholder(tf.float32, [None, 10])\n\n    hid_lin = tf.nn.xw_plus_b(x, hid_w, hid_b)\n    hid = tf.nn.relu(hid_lin)\n\n    y = tf.nn.softmax(tf.nn.xw_plus_b(hid, sm_w, sm_b))\n    cross_entropy = -tf.reduce_sum(y_ *\n                                   tf.log(tf.clip_by_value(y, 1e-10, 1.0)))\n\n    opt = tf.train.AdamOptimizer(FLAGS.learning_rate)\n    if FLAGS.sync_replicas:\n      opt = tf.train.SyncReplicasOptimizer(\n          opt,\n          replicas_to_aggregate=replicas_to_aggregate,\n          total_num_replicas=num_workers,\n          replica_id=FLAGS.worker_index,\n          name=""mnist_sync_replicas"")\n\n    train_step = opt.minimize(cross_entropy,\n                              global_step=global_step)\n\n    if FLAGS.sync_replicas and is_chief:\n      # Initial token and chief queue runners required by the sync_replicas mode\n      chief_queue_runner = opt.get_chief_queue_runner()\n      init_tokens_op = opt.get_init_tokens_op()\n\n    init_op = tf.initialize_all_variables()\n    train_dir = tempfile.mkdtemp()\n    sv = tf.train.Supervisor(is_chief=is_chief,\n                             logdir=train_dir,\n                             init_op=init_op,\n                             recovery_wait_secs=1,\n                             global_step=global_step)\n\n    sess_config = tf.ConfigProto(\n        device_filters=[""/job:ps"", ""/job:worker/task:%d"" % FLAGS.worker_index])\n\n    # The chief worker (worker_index==0) session will prepare the session,\n    # while the remaining workers will wait for the preparation to complete.\n    if is_chief:\n      print(""Worker %d: Initializing session..."" % FLAGS.worker_index)\n    else:\n      print(""Worker %d: Waiting for session to be initialized..."" %\n            FLAGS.worker_index)\n\n    with sv.prepare_or_wait_for_session(worker_grpc_url, config=sess_config) as sess:\n        print(""Worker %d: Session initialization complete."" % FLAGS.worker_index)\n\n        if FLAGS.sync_replicas and is_chief:\n          # Chief worker will start the chief queue runner and call the init op\n          print(""Starting chief queue runner and running init_tokens_op"")\n          sv.start_queue_runners(sess, [chief_queue_runner])\n          sess.run(init_tokens_op)\n\n        # Perform training\n        time_begin = time.time()\n        print(""Training begins @ %f"" % time_begin)\n\n        local_step = 0\n        step = 0\n        while not sv.should_stop() and step < FLAGS.train_steps:\n          # Training feed\n          batch_xs, batch_ys = mnist.train.next_batch(FLAGS.batch_size)\n          train_feed = {x: batch_xs,\n                        y_: batch_ys}\n\n          _, step = sess.run([train_step, global_step], feed_dict=train_feed)\n          local_step += 1\n\n          now = time.time()\n          if is_chief:\n              print(""%f: Worker %d: training step %d done (global step: %d)"" %\n                    (now, FLAGS.worker_index, local_step, step))\n\n\n        sv.stop()\n        if is_chief:\n            time_end = time.time()\n            print(""Training ends @ %f"" % time_end)\n            training_time = time_end - time_begin\n            print(""Training elapsed time: %f s"" % training_time)\n\n\n            # Validation feed\n            val_feed = {x: mnist.validation.images,\n                        y_: mnist.validation.labels}\n            val_xent = sess.run(cross_entropy, feed_dict=val_feed)\n            print(""After %d training step(s), validation cross entropy = %g"" %\n                  (FLAGS.train_steps, val_xent))\n\n\nif __name__ == ""__main__"":\n  tf.app.run()\n'"
