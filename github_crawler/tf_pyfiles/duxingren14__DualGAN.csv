file_path,api_count,code
main.py,2,"b'import argparse\nimport os\n#import scipy.misc\nimport numpy as np\n\nfrom model import DualNet\nimport tensorflow as tf\n\nparser = argparse.ArgumentParser(description=\'Argument parser\')\n"""""" Arguments related to network architecture""""""\nparser.add_argument(\'--image_size\', dest=\'image_size\', type=int, default=256, help=\'size of input images (applicable to both A images and B images)\')\nparser.add_argument(\'--gcn\', dest=\'gcn\', type=int, default=64, help=\'# of filters in 1st conv layer of generator\')\nparser.add_argument(\'--dcn\', dest=\'dcn\', type=int, default=64, help=\'# of filters in 1st conv layer of discriminators\')\nparser.add_argument(\'--A_channels\', dest=\'A_channels\', type=int, default=3, help=\'# of channels of image A\')\nparser.add_argument(\'--B_channels\', dest=\'B_channels\', type=int, default=3, help=\'# of channels of image B\')\nparser.add_argument(\'--dropout_rate\', dest=\'dropout_rate\', type=float, default=0.0, help=\'dropout rate\')\n\n""""""Arguments related to run mode""""""\nparser.add_argument(\'--phase\', dest=\'phase\', default=\'train\', choices=[\'train\', \'test\'], help=\'train, test\')\n\n""""""Arguments related to training""""""\nparser.add_argument(\'--loss_metric\', dest=\'loss_metric\', default=\'L1\', choices=[\'L1\', \'L2\'], help=\'L1, or L2\')\nparser.add_argument(\'--niter\', dest=\'niter\', type=int, default=30, help=\'# of iter at starting learning rate\')\nparser.add_argument(\'--lr\', dest=\'lr\', type=float, default=0.00005, help=\'initial learning rate for adam\')#0.0002\nparser.add_argument(\'--beta1\', dest=\'beta1\', type=float, default=0.5, help=\'momentum term of adam\')\nparser.add_argument(\'--flip\', dest=\'flip\', type=bool, default=True, help=\'if flip the images for data argumentation\')\nparser.add_argument(\'--dataset_name\', dest=\'dataset_name\', default=\'facades\', help=\'name of the dataset\')\nparser.add_argument(\'--epoch\', dest=\'epoch\', type=int, default=50, help=\'# of epoch\')\nparser.add_argument(\'--batch_size\', dest=\'batch_size\', type=int, default=1, help=\'# images in batch\')\nparser.add_argument(\'--lambda_A\', dest=\'lambda_A\', type=float, default=500.0, help=\'# weights of A recovery loss\')\nparser.add_argument(\'--lambda_B\', dest=\'lambda_B\', type=float, default=500.0, help=\'# weights of B recovery loss\')\nparser.add_argument(\'--GAN_type\', dest=\'GAN_type\', type=str, default=\'wgan-gp\', choices=[\'wgan-gp\', \'wgan\', \'classic\'], help=\'wgan gp | wgan | classic\')\nparser.add_argument(\'--clip_value\', dest=\'clip_value\', type=float, default=0.01, help=\'clip values\')\nparser.add_argument(\'--n_critic\', dest=\'n_critic\', type=int, default=1, help=\'train discriminators # times per generator training\')\nparser.add_argument(\'--disc_type\', dest=\'disc_type\', type=str, default=\'globalgan\', choices=[\'globalgan\', \'patchgan\'], help=\'globalgan | patchgan\')\n\n""""""Arguments related to monitoring and outputs""""""\nparser.add_argument(\'--log_freq\', dest=\'log_freq\', type=int, default=10, help=\'save the model every save_freq sgd iterations\')\nparser.add_argument(\'--save_freq\', dest=\'save_freq\', type=int, default=100, help=\'save the model every save_freq sgd iterations\')\nparser.add_argument(\'--checkpoint_dir\', dest=\'checkpoint_dir\', default=\'./checkpoint\', help=\'models are saved here\')\nparser.add_argument(\'--sample_dir\', dest=\'sample_dir\', default=\'./sample\', help=\'sample are saved here\')\nparser.add_argument(\'--test_dir\', dest=\'test_dir\', default=\'./test\', help=\'test sample are saved here\')\n\nargs = parser.parse_args()\n\ndef main(_):\n    if not os.path.exists(args.checkpoint_dir):\n        os.makedirs(args.checkpoint_dir)\n    if not os.path.exists(args.sample_dir):\n        os.makedirs(args.sample_dir)\n    if not os.path.exists(args.test_dir):\n        os.makedirs(args.test_dir)\n\n\n    with tf.Session() as sess:\n        model = DualNet(sess, image_size=args.image_size, batch_size=args.batch_size,\\\n                        dataset_name=args.dataset_name,A_channels = args.A_channels, \\\n\t\t\t\t\t\tB_channels = args.B_channels, flip  = (args.flip == \'True\'),\\\n                        checkpoint_dir=args.checkpoint_dir, sample_dir=args.sample_dir,\\\n\t\t\t\t\t\tgcn = args.gcn, dcn=args.dcn, \\\n\t\t\t\t\t\tloss_metric=args.loss_metric, lambda_B=args.lambda_B, \\\n\t\t\t\t\t\tlambda_A= args.lambda_A, dropout_rate=args.dropout_rate, \\\n                        n_critic=args.n_critic, GAN_type = args.GAN_type, clip_value=args.clip_value, \\\n                        log_freq=args.log_freq, disc_type=args.disc_type)\n\n        if args.phase == \'train\':\n            model.train(args)\n        else:\n            model.test(args)\n\nif __name__ == \'__main__\':\n    tf.app.run()\n'"
model.py,60,"b'from __future__ import division\nimport os\nimport time\nfrom glob import glob\nimport tensorflow as tf\nimport numpy as np\n#from six.moves import xrange\n\nfrom ops import *\nfrom utils import *\n\nclass DualNet(object):\n    def __init__(self, sess, image_size=256, batch_size=1,gcn = 64, dcn=64, \\\n                 A_channels = 3, B_channels = 3, dataset_name=\'facades\', \\\n                 checkpoint_dir=None, lambda_A = 500., lambda_B = 500., \\\n                 sample_dir=None, dropout_rate=0.0, loss_metric = \'L1\', flip = False,\\\n                 n_critic = 5, GAN_type = \'wgan-gp\', clip_value = 0.1, log_freq=50, disc_type = \'globalgan\'):\n        self.dcn = dcn\n        self.flip = flip\n        self.lambda_A = lambda_A\n        self.lambda_B = lambda_B\n        \n        self.sess = sess\n        self.is_grayscale_A = (A_channels == 1)\n        self.is_grayscale_B = (B_channels == 1)\n        self.batch_size = batch_size\n        self.image_size = image_size\n        self.gcn = gcn\n        self.A_channels = A_channels\n        self.B_channels = B_channels\n        self.loss_metric = loss_metric\n\n        self.dataset_name = dataset_name\n        self.checkpoint_dir = checkpoint_dir\n        \n        #directory name for output and logs saving\n        self.dir_name = ""%s-img_sz_%s-fltr_dim_%d-%s-lambda_AB_%s_%s"" % (\n                    self.dataset_name, \n                    self.image_size,\n                    self.gcn,\n                    self.loss_metric, \n                    self.lambda_A, \n                    self.lambda_B\n                ) \n        self.dropout_rate = dropout_rate\n        self.clip_value = clip_value\n        self.GAN_type = GAN_type\n        self.n_critic = n_critic\n        self.log_freq = log_freq\n        self.gamma = 10.\n        self.disc_type = disc_type\n        self.build_model()\n\n    def build_model(self):\n    ###    define place holders\n        self.real_A = tf.placeholder(tf.float32,[self.batch_size, self.image_size, self.image_size,\n                                         self.A_channels ],name=\'real_A\')\n        self.real_B = tf.placeholder(tf.float32, [self.batch_size, self.image_size, self.image_size,\n                                         self.B_channels ], name=\'real_B\')\n        \n    ###  define graphs\n        self.A2B = self.A_g_net(self.real_A, reuse = False)\n        self.B2A = self.B_g_net(self.real_B, reuse = False)\n        self.A2B2A = self.B_g_net(self.A2B, reuse = True)\n        self.B2A2B = self.A_g_net(self.B2A, reuse = True)\n        \n        if self.loss_metric == \'L1\':\n            self.A_loss = tf.reduce_mean(tf.abs(self.A2B2A - self.real_A))\n            self.B_loss = tf.reduce_mean(tf.abs(self.B2A2B - self.real_B))\n        elif self.loss_metric == \'L2\':\n            self.A_loss = tf.reduce_mean(tf.square(self.A2B2A - self.real_A))\n            self.B_loss = tf.reduce_mean(tf.square(self.B2A2B - self.real_B))\n        \n        self.Ad_logits_fake = self.A_d_net(self.A2B, reuse = False)\n        self.Ad_logits_real = self.A_d_net(self.real_B, reuse = True)\n\n        if self.GAN_type == \'wgan-gp\':\n            epsilon_B = tf.random_uniform(\n                shape=[self.batch_size, 1, 1, 1], minval=0., maxval=1.)\n            interpolated_image_B = self.real_B + epsilon_B * (self.A2B - self.real_B)\n            d_interpolated_B = self.A_d_net(interpolated_image_B, reuse = True)\n\n        if self.GAN_type == \'classic\':\n            self.Ad_loss_real = celoss(self.Ad_logits_real, tf.ones_like(self.Ad_logits_real))\n            self.Ad_loss_fake = celoss(self.Ad_logits_fake, tf.zeros_like(self.Ad_logits_fake))\n        else:\n            self.Ad_loss_real = -tf.reduce_mean(self.Ad_logits_real)\n            self.Ad_loss_fake = tf.reduce_mean(self.Ad_logits_fake)\n        self.Ad_loss = self.Ad_loss_fake + self.Ad_loss_real\n        if self.GAN_type == \'classic\':\n            self.Ag_loss = celoss(self.Ad_logits_fake, labels=tf.ones_like(self.Ad_logits_fake))+self.lambda_B * self.B_loss\n        else:\n            self.Ag_loss = - tf.reduce_mean(self.Ad_logits_fake)+self.lambda_B * self.B_loss\n\n        self.Bd_logits_fake = self.B_d_net(self.B2A, reuse = False)\n        self.Bd_logits_real = self.B_d_net(self.real_A, reuse = True)\n        if self.GAN_type == \'wgan-gp\':\n            epsilon_A = tf.random_uniform(\n                shape=[self.batch_size, 1, 1, 1], minval=0., maxval=1.)\n            interpolated_image_A = self.real_A + epsilon_A * (self.B2A - self.real_A)\n            d_interpolated_A = self.B_d_net(interpolated_image_A, reuse = True)\n\n        if self.GAN_type == \'classic\':\n            self.Bd_loss_real = celoss(self.Bd_logits_real, tf.ones_like(self.Bd_logits_real))\n            self.Bd_loss_fake = celoss(self.Bd_logits_fake, tf.zeros_like(self.Bd_logits_fake))\n        else:\n            self.Bd_loss_real = -tf.reduce_mean(self.Bd_logits_real)\n            self.Bd_loss_fake = tf.reduce_mean(self.Bd_logits_fake)\n        self.Bd_loss = self.Bd_loss_fake + self.Bd_loss_real\n        if self.GAN_type == \'classic\':\n            self.Bg_loss = celoss(self.Bd_logits_fake, tf.ones_like(self.Bd_logits_fake))+self.lambda_A * self.A_loss\n        else:\n            self.Bg_loss = -tf.reduce_mean(self.Bd_logits_fake)+self.lambda_A * self.A_loss\n\n\n        self.d_loss = self.Ad_loss + self.Bd_loss\n        self.g_loss = self.Ag_loss + self.Bg_loss\n\n        if self.GAN_type == \'wgan-gp\':\n            grad_d_interp = tf.gradients(\n                d_interpolated_A, [interpolated_image_A])[0]\n            slopes = tf.sqrt(1e-8 + tf.reduce_sum(\n                tf.square(grad_d_interp), axis=[1, 2, 3]))\n            gradient_penalty = tf.reduce_mean((slopes - 1.) ** 2)\n            self.d_loss += self.gamma * gradient_penalty\n\n            grad_d_interp = tf.gradients(\n                d_interpolated_B, [interpolated_image_B])[0]\n            slopes = tf.sqrt(1e-8 + tf.reduce_sum(\n                tf.square(grad_d_interp), axis=[1, 2, 3]))\n            gradient_penalty = tf.reduce_mean((slopes - 1.) ** 2)\n            self.d_loss += self.gamma * gradient_penalty\n\n\n        ## define trainable variables\n        t_vars = tf.trainable_variables()\n        self.A_d_vars = [var for var in t_vars if \'A_d_\' in var.name]\n        self.B_d_vars = [var for var in t_vars if \'B_d_\' in var.name]\n        self.A_g_vars = [var for var in t_vars if \'A_g_\' in var.name]\n        self.B_g_vars = [var for var in t_vars if \'B_g_\' in var.name]\n        self.d_vars = self.A_d_vars + self.B_d_vars \n        self.g_vars = self.A_g_vars + self.B_g_vars\n        self.saver = tf.train.Saver()\n\n    def load_random_samples(self):\n        #np.random.choice(\n        sample_files =np.random.choice(glob(\'./datasets/{}/val/A/*.*[g|G]\'.format(self.dataset_name)),self.batch_size)\n        sample_A_imgs = [load_data(f, image_size =self.image_size, flip = False) for f in sample_files]\n        \n        sample_files = np.random.choice(glob(\'./datasets/{}/val/B/*.*[g|G]\'.format(self.dataset_name)),self.batch_size)\n        sample_B_imgs = [load_data(f, image_size =self.image_size, flip = False) for f in sample_files]\n\n        sample_A_imgs = np.reshape(np.array(sample_A_imgs).astype(np.float32),(self.batch_size,self.image_size, self.image_size,-1))\n        sample_B_imgs = np.reshape(np.array(sample_B_imgs).astype(np.float32),(self.batch_size,self.image_size, self.image_size,-1))\n        return sample_A_imgs, sample_B_imgs\n\n    def sample_shotcut(self, sample_dir, epoch_idx, batch_idx):\n        sample_A_imgs,sample_B_imgs = self.load_random_samples()\n        \n        Ag, A2B2A_imgs, A2B_imgs = self.sess.run([self.A_loss, self.A2B2A, self.A2B], feed_dict={self.real_A: sample_A_imgs, self.real_B: sample_B_imgs})\n        Bg, B2A2B_imgs, B2A_imgs = self.sess.run([self.B_loss, self.B2A2B, self.B2A], feed_dict={self.real_A: sample_A_imgs, self.real_B: sample_B_imgs})\n\n        save_images(A2B_imgs, [self.batch_size,1], \'./{}/{}/{:06d}_{:04d}_A2B.jpg\'.format(sample_dir,self.dir_name , epoch_idx, batch_idx))\n        save_images(A2B2A_imgs, [self.batch_size,1],    \'./{}/{}/{:06d}_{:04d}_A2B2A.jpg\'.format(sample_dir,self.dir_name, epoch_idx,  batch_idx))\n        \n        save_images(B2A_imgs, [self.batch_size,1], \'./{}/{}/{:06d}_{:04d}_B2A.jpg\'.format(sample_dir,self.dir_name, epoch_idx, batch_idx))\n        save_images(B2A2B_imgs, [self.batch_size,1], \'./{}/{}/{:06d}_{:04d}_B2A2B.jpg\'.format(sample_dir,self.dir_name, epoch_idx, batch_idx))\n        \n        print(""[Sample] A_loss: {:.8f}, B_loss: {:.8f}"".format(Ag, Bg))\n\n    def train(self, args):\n        """"""Train Dual GAN""""""\n        decay = 0.9\n        self.d_optim = tf.train.RMSPropOptimizer(args.lr, decay=decay) \\\n                          .minimize(self.d_loss, var_list=self.d_vars)\n                          \n        self.g_optim = tf.train.RMSPropOptimizer(args.lr, decay=decay) \\\n                          .minimize(self.g_loss, var_list=self.g_vars)          \n        tf.global_variables_initializer().run()\n        if self.GAN_type == \'wgan\':\n            self.clip_ops =  [var.assign(tf.clip_by_value(var, -self.clip_value, self.clip_value)) for var in self.d_vars]\n\n        self.writer = tf.summary.FileWriter(""./logs/""+self.dir_name, self.sess.graph)\n\n        step = 1\n        start_time = time.time()\n\n        if self.load(self.checkpoint_dir):\n            print("" [*] Load SUCCESS"")\n        else:\n            print("" Load failed...ignored..."")\n            print("" start training..."")\n\n        for epoch_idx in range(args.epoch):\n            data_A = glob(\'./datasets/{}/train/A/*.*[g|G]\'.format(self.dataset_name))\n            data_B = glob(\'./datasets/{}/train/B/*.*[g|G]\'.format(self.dataset_name))\n            np.random.shuffle(data_A)\n            np.random.shuffle(data_B)\n            epoch_size = min(len(data_A), len(data_B)) // (self.batch_size)\n            print(\'[*] training data loaded successfully\')\n            print(""#data_A: %d  #data_B:%d"" %(len(data_A),len(data_B)))\n            print(\'[*] run optimizor...\')\n\n            for batch_idx in range(0, epoch_size):\n                imgA_batch = self.load_training_imgs(data_A, batch_idx)\n                imgB_batch = self.load_training_imgs(data_B, batch_idx)\n                if step % self.log_freq == 0:\n                    print(""Epoch: [%2d] [%4d/%4d]""%(epoch_idx, batch_idx, epoch_size))\n                step = step + 1\n                self.run_optim(imgA_batch, imgB_batch, step, start_time, step)\n\n                if np.mod(step, 100) == 1:\n                    self.sample_shotcut(args.sample_dir, epoch_idx, batch_idx)\n\n                if np.mod(step, args.save_freq) == 2:\n                    self.save(args.checkpoint_dir, step)\n\n    def load_training_imgs(self, files, idx):\n        batch_files = files[idx*self.batch_size:(idx+1)*self.batch_size]\n        batch_imgs = [load_data(f, image_size =self.image_size, flip = self.flip) for f in batch_files]\n                \n        batch_imgs = np.reshape(np.array(batch_imgs).astype(np.float32),(self.batch_size,self.image_size, self.image_size,-1))\n        \n        return batch_imgs\n        \n    def run_optim(self,batch_A_imgs, batch_B_imgs,  counter, start_time, batch_idx):\n        \n\n        _, Adfake,Adreal,Bdfake,Bdreal, Ad, Bd = self.sess.run(\n            [self.d_optim, self.Ad_loss_fake, self.Ad_loss_real, self.Bd_loss_fake, self.Bd_loss_real, self.Ad_loss, self.Bd_loss], \n            feed_dict = {self.real_A: batch_A_imgs, self.real_B: batch_B_imgs})\n        \n        if \'wgan\' == self.GAN_type:\n        \tself.sess.run(self.clip_ops)\n\n        if \'wgan\' in self.GAN_type:\n            if batch_idx % self.n_critic == 0:\n                _, Ag, Bg, Aloss, Bloss = self.sess.run(\n                [self.g_optim, self.Ag_loss, self.Bg_loss, self.A_loss, self.B_loss], \n                feed_dict={ self.real_A: batch_A_imgs, self.real_B: batch_B_imgs})\n            else:\n                Ag, Bg, Aloss, Bloss = self.sess.run(\n                [self.Ag_loss, self.Bg_loss, self.A_loss, self.B_loss], \n                feed_dict={ self.real_A: batch_A_imgs, self.real_B: batch_B_imgs})\n        else:\n            _, Ag, Bg, Aloss, Bloss = self.sess.run(\n                [self.g_optim, self.Ag_loss, self.Bg_loss, self.A_loss, self.B_loss], \n                feed_dict={ self.real_A: batch_A_imgs, self.real_B: batch_B_imgs})\n            _, Ag, Bg, Aloss, Bloss = self.sess.run(\n                [self.g_optim, self.Ag_loss, self.Bg_loss, self.A_loss, self.B_loss], \n                feed_dict={ self.real_A: batch_A_imgs, self.real_B: batch_B_imgs})\n        if batch_idx % self.log_freq == 0:\n            print(""time: %4.4f, Ad: %.2f, Ag: %.2f, Bd: %.2f, Bg: %.2f,  U_diff: %.5f, V_diff: %.5f"" \\\n                    % (time.time() - start_time, Ad,Ag,Bd,Bg, Aloss, Bloss))\n            print(""Ad_fake: %.2f, Ad_real: %.2f, Bd_fake: %.2f, Bd_real: %.2f"" % (Adfake,Adreal,Bdfake,Bdreal))\n\n    def A_d_net(self, imgs, y = None, reuse = False):\n        return self.discriminator(imgs, prefix = \'A_d_\', reuse = reuse)\n    \n    def B_d_net(self, imgs, y = None, reuse = False):\n        return self.discriminator(imgs, prefix = \'B_d_\', reuse = reuse)\n        \n    def discriminator(self, image,  y=None, prefix=\'A_d_\', reuse=False):\n        # image is 256 x 256 x (input_c_dim + output_c_dim)\n        with tf.variable_scope(tf.get_variable_scope()) as scope:\n            if reuse:\n                scope.reuse_variables()\n            else:\n                assert scope.reuse == False\n\n            h0 = lrelu(conv2d(image, self.dcn, k_h=5, k_w=5, name=prefix+\'h0_conv\'))\n            # h0 is (128 x 128 x self.dcn)\n            h1 = lrelu(batch_norm(conv2d(h0, self.dcn*2, name=prefix+\'h1_conv\'), name = prefix+\'bn1\'))\n            # h1 is (64 x 64 x self.dcn*2)\n            h2 = lrelu(batch_norm(conv2d(h1, self.dcn*4, name=prefix+\'h2_conv\'), name = prefix+ \'bn2\'))\n            # h2 is (32x 32 x self.dcn*4)\n            h3 = lrelu(batch_norm(conv2d(h2, self.dcn*8, name=prefix+\'h3_conv\'), name = prefix+ \'bn3\'))\n            # h3 is (16 x 16 x self.dcn*8)\n            h3 = lrelu(batch_norm(conv2d(h3, self.dcn*8, name=prefix+\'h3_1_conv\'), name = prefix+ \'bn3_1\'))\n            # h3 is (8 x 8 x self.dcn*8)\n\n            if self.disc_type == \'patchgan\':\n                h4 = conv2d(h3, 1, name =prefix+\'h4\')\n            else:\n                h4 = linear(tf.reshape(h3, [self.batch_size, -1]), 1, prefix+\'d_h3_lin\')\n\n            return h4\n        \n    def A_g_net(self, imgs, reuse=False):\n        return self.fcn(imgs, prefix=\'A_g_\', reuse = reuse)\n        \n\n    def B_g_net(self, imgs, reuse=False):\n        return self.fcn(imgs, prefix = \'B_g_\', reuse = reuse)\n        \n    def fcn(self, imgs, prefix=None, reuse = False):\n        with tf.variable_scope(tf.get_variable_scope()) as scope:\n            if reuse:\n                scope.reuse_variables()\n            else:\n                assert scope.reuse == False\n            \n            s = self.image_size\n            s2, s4, s8, s16, s32, s64, s128 = int(s/2), int(s/4), int(s/8), int(s/16), int(s/32), int(s/64), int(s/128)\n\n            # imgs is (256 x 256 x input_c_dim)\n            e1 = conv2d(imgs, self.gcn, k_h=5, k_w=5, name=prefix+\'e1_conv\')\n            # e1 is (128 x 128 x self.gcn)\n            e2 = batch_norm(conv2d(lrelu(e1), self.gcn*2, name=prefix+\'e2_conv\'), name = prefix+\'bn_e2\')\n            # e2 is (64 x 64 x self.gcn*2)\n            e3 = batch_norm(conv2d(lrelu(e2), self.gcn*4, name=prefix+\'e3_conv\'), name = prefix+\'bn_e3\')\n            # e3 is (32 x 32 x self.gcn*4)\n            e4 = batch_norm(conv2d(lrelu(e3), self.gcn*8, name=prefix+\'e4_conv\'), name = prefix+\'bn_e4\')\n            # e4 is (16 x 16 x self.gcn*8)\n            e5 = batch_norm(conv2d(lrelu(e4), self.gcn*8, name=prefix+\'e5_conv\'), name = prefix+\'bn_e5\')\n            # e5 is (8 x 8 x self.gcn*8)\n            e6 = batch_norm(conv2d(lrelu(e5), self.gcn*8, name=prefix+\'e6_conv\'), name = prefix+\'bn_e6\')\n            # e6 is (4 x 4 x self.gcn*8)\n            e7 = batch_norm(conv2d(lrelu(e6), self.gcn*8, name=prefix+\'e7_conv\'), name = prefix+\'bn_e7\')\n            # e7 is (2 x 2 x self.gcn*8)\n            e8 = batch_norm(conv2d(lrelu(e7), self.gcn*8, name=prefix+\'e8_conv\'), name = prefix+\'bn_e8\')\n            # e8 is (1 x 1 x self.gcn*8)\n\n            self.d1, self.d1_w, self.d1_b = deconv2d(tf.nn.relu(e8),\n                [self.batch_size, s128, s128, self.gcn*8], name=prefix+\'d1\', with_w=True)\n            if self.dropout_rate <= 0.:\n                d1 = batch_norm(self.d1, name = prefix+\'bn_d1\')\n            else:\n                d1 = tf.nn.dropout(batch_norm(self.d1, name = prefix+\'bn_d1\'), self.dropout_rate)\n            d1 = tf.concat([d1, e7],3)\n            # d1 is (2 x 2 x self.gcn*8*2)\n\n            self.d2, self.d2_w, self.d2_b = deconv2d(tf.nn.relu(d1),\n                [self.batch_size, s64, s64, self.gcn*8], name=prefix+\'d2\', with_w=True)\n            if self.dropout_rate <= 0.:\n                d2 = batch_norm(self.d2, name = prefix+\'bn_d2\')\n            else:\n                d2 = tf.nn.dropout(batch_norm(self.d2, name = prefix+\'bn_d2\'), self.dropout_rate)\n            d2 = tf.concat([d2, e6],3)\n            # d2 is (4 x 4 x self.gcn*8*2)\n\n            self.d3, self.d3_w, self.d3_b = deconv2d(tf.nn.relu(d2),\n                [self.batch_size, s32, s32, self.gcn*8], name=prefix+\'d3\', with_w=True)\n            if self.dropout_rate <= 0.:\n                d3 = batch_norm(self.d3, name = prefix+\'bn_d3\')\n            else:\n                d3 = tf.nn.dropout(batch_norm(self.d3, name = prefix+\'bn_d3\'), self.dropout_rate)\n            d3 = tf.concat([d3, e5],3)\n            # d3 is (8 x 8 x self.gcn*8*2)\n\n            self.d4, self.d4_w, self.d4_b = deconv2d(tf.nn.relu(d3),\n                [self.batch_size, s16, s16, self.gcn*8], name=prefix+\'d4\', with_w=True)\n            d4 = batch_norm(self.d4, name = prefix+\'bn_d4\')\n\n            d4 = tf.concat([d4, e4],3)\n            # d4 is (16 x 16 x self.gcn*8*2)\n\n            self.d5, self.d5_w, self.d5_b = deconv2d(tf.nn.relu(d4),\n                [self.batch_size, s8, s8, self.gcn*4], name=prefix+\'d5\', with_w=True)\n            d5 = batch_norm(self.d5, name = prefix+\'bn_d5\')\n            d5 = tf.concat([d5, e3],3)\n            # d5 is (32 x 32 x self.gcn*4*2)\n\n            self.d6, self.d6_w, self.d6_b = deconv2d(tf.nn.relu(d5),\n                [self.batch_size, s4, s4, self.gcn*2], name=prefix+\'d6\', with_w=True)\n            d6 = batch_norm(self.d6, name = prefix+\'bn_d6\')\n            d6 = tf.concat([d6, e2],3)\n            # d6 is (64 x 64 x self.gcn*2*2)\n\n            self.d7, self.d7_w, self.d7_b = deconv2d(tf.nn.relu(d6),\n                [self.batch_size, s2, s2, self.gcn], name=prefix+\'d7\', with_w=True)\n            d7 = batch_norm(self.d7, name = prefix+\'bn_d7\')\n            d7 = tf.concat([d7, e1],3)\n            # d7 is (128 x 128 x self.gcn*1*2)\n\n            if prefix == \'B_g_\':\n                self.d8, self.d8_w, self.d8_b = deconv2d(tf.nn.relu(d7),[self.batch_size, s, s, self.A_channels], k_h=5, k_w=5, name=prefix+\'d8\', with_w=True)\n            elif prefix == \'A_g_\':\n                self.d8, self.d8_w, self.d8_b = deconv2d(tf.nn.relu(d7),[self.batch_size, s, s, self.B_channels], k_h=5, k_w=5, name=prefix+\'d8\', with_w=True)\n             # d8 is (256 x 256 x output_c_dim)\n            return tf.nn.tanh(self.d8)\n    \n    def save(self, checkpoint_dir, step):\n        model_name = ""DualNet.model""\n        model_dir = self.dir_name\n        checkpoint_dir = os.path.join(checkpoint_dir, model_dir)\n\n        if not os.path.exists(checkpoint_dir):\n            os.makedirs(checkpoint_dir)\n\n        self.saver.save(self.sess,\n                        os.path.join(checkpoint_dir, model_name),\n                        global_step=step)\n\n    def load(self, checkpoint_dir):\n        print("" [*] Reading checkpoint..."")\n\n        model_dir =  self.dir_name\n        checkpoint_dir = os.path.join(checkpoint_dir, model_dir)\n\n        ckpt = tf.train.get_checkpoint_state(checkpoint_dir)\n        if ckpt and ckpt.model_checkpoint_path:\n            ckpt_name = os.path.basename(ckpt.model_checkpoint_path)\n            self.saver.restore(self.sess, os.path.join(checkpoint_dir, ckpt_name))\n            return True\n        else:\n            return False\n\n    def test(self, args):\n        """"""Test DualNet""""""\n        start_time = time.time()\n        tf.global_variables_initializer().run()\n        if self.load(self.checkpoint_dir):\n            print("" [*] Load SUCCESS"")\n            test_dir = \'./{}/{}\'.format(args.test_dir, self.dir_name)\n            if not os.path.exists(test_dir):\n                os.makedirs(test_dir)\n            test_log = open(test_dir+\'evaluation.txt\',\'a\') \n            test_log.write(self.dir_name)\n            self.test_domain(args, test_log, type = \'A\')\n            self.test_domain(args, test_log, type = \'B\')\n            test_log.close()\n        \n    def test_domain(self, args, test_log, type = \'A\'):\n        test_files = glob(\'./datasets/{}/val/{}/*.*[g|G]\'.format(self.dataset_name,type))\n        # load testing input\n        print(""Loading testing images ..."")\n        test_imgs = [load_data(f, is_test=True, image_size =self.image_size, flip = args.flip) for f in test_files]\n        print(""#images loaded: %d""%(len(test_imgs)))\n        test_imgs = np.reshape(np.asarray(test_imgs).astype(np.float32),(len(test_files),self.image_size, self.image_size,-1))\n        test_imgs = [test_imgs[i*self.batch_size:(i+1)*self.batch_size]\n                         for i in range(0, len(test_imgs)//self.batch_size)]\n        test_imgs = np.asarray(test_imgs)\n        test_path = \'./{}/{}/\'.format(args.test_dir, self.dir_name)\n        # test input samples\n        if type == \'A\':\n            for i in range(0, len(test_files)//self.batch_size):\n                filename_o = test_files[i*self.batch_size].split(\'/\')[-1].split(\'.\')[0]\n                print(filename_o)\n                idx = i+1\n                A_imgs = np.reshape(np.array(test_imgs[i]), (self.batch_size,self.image_size, self.image_size,-1))\n                print(""testing A image %d""%(idx))\n                print(A_imgs.shape)\n                A2B_imgs, A2B2A_imgs = self.sess.run(\n                    [self.A2B, self.A2B2A],\n                    feed_dict={self.real_A: A_imgs}\n                    )\n                save_images(A_imgs, [self.batch_size, 1], test_path+filename_o+\'_realA.jpg\')\n                save_images(A2B_imgs, [self.batch_size, 1], test_path+filename_o+\'_A2B.jpg\')\n                save_images(A2B2A_imgs, [self.batch_size, 1], test_path+filename_o+\'_A2B2A.jpg\')\n        elif type==\'B\':\n            for i in range(0, len(test_files)//self.batch_size):\n                filename_o = test_files[i*self.batch_size].split(\'/\')[-1].split(\'.\')[0]\n                idx = i+1\n                B_imgs = np.reshape(np.array(test_imgs[i]), (self.batch_size,self.image_size, self.image_size,-1))\n                print(""testing B image %d""%(idx))\n                B2A_imgs, B2A2B_imgs = self.sess.run(\n                    [self.B2A, self.B2A2B],\n                    feed_dict={self.real_B:B_imgs}\n                    )\n                save_images(B_imgs, [self.batch_size, 1],test_path+filename_o+\'_realB.jpg\')\n                save_images(B2A_imgs, [self.batch_size, 1],test_path+filename_o+\'_B2A.jpg\')\n                save_images(B2A2B_imgs, [self.batch_size, 1],test_path+filename_o+\'_B2A2B.jpg\')'"
ops.py,27,"b'#import math\nimport numpy as np \nimport tensorflow as tf\n\n#from tensorflow.python.framework import ops\n\nfrom utils import *\n\ndef batch_norm(x,  name=""batch_norm""):\n    eps = 1e-6\n    with tf.variable_scope(name):\n        nchannels = x.get_shape()[3]\n        scale = tf.get_variable(""scale"", [nchannels], initializer=tf.random_normal_initializer(1.0, 0.02, dtype=tf.float32))\n        center = tf.get_variable(""center"", [nchannels], initializer=tf.constant_initializer(0.0, dtype = tf.float32))\n        ave, dev = tf.nn.moments(x, axes=[1,2], keep_dims=True)\n        inv_dev = tf.rsqrt(dev + eps)\n        normalized = (x-ave)*inv_dev * scale + center\n        return normalized\n\ndef conv2d(input_, output_dim, \n           k_h=3, k_w=3, d_h=2, d_w=2, stddev=0.02,\n           name=""conv2d""):\n    with tf.variable_scope(name):\n        w = tf.get_variable(\'w\', [k_h, k_w, input_.get_shape()[-1], output_dim],\n                            initializer=tf.truncated_normal_initializer(stddev=stddev))\n        conv = tf.nn.conv2d(input_, w, strides=[1, d_h, d_w, 1], padding=\'SAME\')\n\n        biases = tf.get_variable(\'biases\', [output_dim], initializer=tf.constant_initializer(0.0))\n        conv = tf.reshape(tf.nn.bias_add(conv, biases), conv.get_shape())\n\n        return conv\n\ndef deconv2d(input_, output_shape,\n             k_h=3, k_w=3, d_h=2, d_w=2, stddev=0.02,\n             name=""deconv2d"", with_w=False):\n    with tf.variable_scope(name):\n        # filter : [height, width, output_channels, in_channels]\n        w = tf.get_variable(\'w\', [k_h, k_w, output_shape[-1], input_.get_shape()[-1]],\n                            initializer=tf.random_normal_initializer(stddev=stddev))\n        try:\n            deconv = tf.nn.conv2d_transpose(input_, w, output_shape=output_shape,\n                                strides=[1, d_h, d_w, 1])\n\n        # Support for verisons of TensorFlow before 0.7.0\n        except AttributeError:\n            deconv = tf.nn.deconv2d(input_, w, output_shape=output_shape,\n                                strides=[1, d_h, d_w, 1])\n\n        biases = tf.get_variable(\'biases\', [output_shape[-1]], initializer=tf.constant_initializer(0.0))\n        deconv = tf.reshape(tf.nn.bias_add(deconv, biases), deconv.get_shape())\n\n        if with_w:\n            return deconv, w, biases\n        else:\n            return deconv\n       \ndef lrelu(x, leak=0.2, name=""lrelu""):\n  return tf.maximum(x, leak*x)\n\ndef celoss(logits, labels):\n    return tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=logits, labels=labels))\n       \n\ndef linear(input_, output_size, scope=None, stddev=0.02, bias_start=0.0, with_w=False):\n    shape = input_.get_shape().as_list()\n\n    with tf.variable_scope(scope or ""Linear""):\n        matrix = tf.get_variable(""Matrix"", [shape[1], output_size], tf.float32,\n                                 tf.random_normal_initializer(stddev=stddev))\n        bias = tf.get_variable(""bias"", [output_size],\n            initializer=tf.constant_initializer(bias_start))\n        if with_w:\n            return tf.matmul(input_, matrix) + bias, matrix, bias\n        else:\n            return tf.matmul(input_, matrix) + bias\n'"
utils.py,0,"b'""""""\nSome codes from https://github.com/Newmu/dcgan_code\n""""""\nfrom __future__ import division\nimport random\nimport cv2\nimport numpy as np\nimport os\nfrom time import gmtime, strftime\n\n\n\n    \ndef load_data(image_path, flip=False, is_test=False, image_size = 128):\n    img = load_image(image_path)\n    img = preprocess_img(img, img_size=image_size, flip=flip, is_test=is_test)\n\n    img = img/127.5 - 1.\n    if len(img.shape)<3:\n        img = np.expand_dims(img, axis=2)\n    return img\n\ndef load_image(image_path):\n    img = imread(image_path)\n    return img\n\ndef preprocess_img(img, img_size=128, flip=False, is_test=False):\n    img = cv2.resize(img, (img_size, img_size))\n    if (not is_test) and flip and np.random.random() > 0.5:\n        img = np.fliplr(img)\n    return img\n\ndef get_image(image_path, image_size, is_crop=True, resize_w=64, is_grayscale = False):\n    return transform(imread(image_path, is_grayscale), image_size, is_crop, resize_w)\n\ndef save_images(images, size, image_path):\n    dir = os.path.dirname(image_path)\n    if not os.path.exists(dir):\n        os.makedirs(dir)\n    return imsave(inverse_transform(images), size, image_path)\n\ndef imread(path, is_grayscale = False):\n    if (is_grayscale):\n        return cv2.imread(path, flatten = True)#.astype(np.float)\n    else:\n        return cv2.imread(path)#.astype(np.float)\n\ndef merge_images(images, size):\n    return inverse_transform(images)\n\ndef merge(images, size):\n    h, w = images.shape[1], images.shape[2]\n    if len(images.shape) < 4:\n        img = np.zeros((h * size[0], w * size[1], 1))\n        images = np.expand_dims(images, axis = 3)\n    else:\n        img = np.zeros((h * size[0], w * size[1], images.shape[3]))\n    for idx, image in enumerate(images):\n        i = idx % size[1]\n        j = idx // size[1]\n        img[j*h:j*h+h, i*w:i*w+w, :] = image\n    if images.shape[3] ==1:\n        return np.concatenate([img,img,img],axis=2)\n    else:\n        return img.astype(np.uint8)\n\ndef imsave(images, size, path):\n    return cv2.imwrite(path, merge(images, size))\n\ndef transform(image, npx=64, is_crop=True, resize_w=64):\n    # npx : # of pixels width/height of image\n    if is_crop:\n        cropped_image = center_crop(image, npx, resize_w=resize_w)\n    else:\n        cropped_image = image\n    return np.array(cropped_image)/127.5 - 1.\n\ndef inverse_transform(images):\n    return ((images+1.)*127.5)'"
