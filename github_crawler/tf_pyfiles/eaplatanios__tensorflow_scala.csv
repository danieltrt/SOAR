file_path,api_count,code
modules/examples/src/main/resources/python2scala/linearRegression.py,12,"b'import tensorflow as tf\nimport numpy as np\nimport sys\nfrom random import seed\nimport itertools\n\nseed(22)\n\nflagTrain = [""train"", ""true"", ""True"", ""1""]\n\n\ndef generate_one_data(limit=100):\n    for x in itertools.count(1):\n        for inp in [x, x * -1]:\n            if x == limit:\n                return\n            out = (inp * 8.254) + 2.555\n\n            n_inp = np.array(inp)\n            n_out = np.array(out)\n            yield (np.reshape(n_inp, [-1, 1]), np.reshape(n_out, [-1, 1]))\n\n\n# --- CHECK FLAG ---\nif len(sys.argv) != 5:\n    print(""Error:"")\n    print(""python {} <flag_do_train> <device> <abs_path_virgin_model> <abs_path_trained_model>"".format(sys.argv[0]))\n    exit(1)\n\ndo_train = True if sys.argv[1] in flagTrain else False\ndevice = ""CPU:0"" if sys.argv[2] == ""cpu"" else ""GPU:0""\nabs_path_virgin_model = sys.argv[3]\nabs_path_trained_model = sys.argv[4]\nprint(""doTrain: "", do_train)\n\nwith tf.device(device):\n    x = tf.placeholder(tf.float64, shape=[None, 1], name=""p2s_input"")\n    y_ = tf.placeholder(tf.float64, shape=[None, 1], name=""p2s_output"")\n    w = tf.get_variable(""p2s_weights_w"", dtype=tf.float64, shape=[1, 1], initializer=tf.zeros_initializer,\n                        use_resource=True)\n    b = tf.get_variable(""p2s_weights_b"", dtype=tf.float64, shape=[1, 1], initializer=tf.zeros_initializer,\n                        use_resource=True)\n\n    prediction = tf.add(tf.matmul(x, w), b, name=""p2s_prediction"")\n\n    loss = tf.reduce_mean(tf.square(prediction - y_), name=""p2s_loss"")\n    grads_and_vars = tf.train.AdamOptimizer(0.5).compute_gradients(loss)\n    trainOp = tf.train.AdagradOptimizer(0.5).apply_gradients(grads_and_vars, name=""p2s_train_op"")\n\n    sess = tf.InteractiveSession()\n    tf.global_variables_initializer().run()\n    saver = tf.train.Saver()\n\n    # - - - - SAVE MODEL - - -\n    saver.save(sess, abs_path_virgin_model)\n\n# - - - - TRAIN - - - - -\nif do_train:\n    i = 0\n    for data in generate_one_data():\n        inp = data[0]\n        expected = data[1]\n\n        # --- TRAINING ---\n        _, predicted = sess.run([trainOp, prediction], feed_dict={x: inp, y_: expected})\n\n        # --- RUN ---\n        print(""[iter {}] expected/predicted: {}, {}\\n"".format(i, predicted[0], expected))\n\n        # - - - - SAVE MODEL - - - - -\n        saver.save(sess, abs_path_trained_model)\n        i += 1\n'"
