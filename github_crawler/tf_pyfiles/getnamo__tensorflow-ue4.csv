file_path,api_count,code
Content/Scripts/TFPluginAPI.py,2,"b""import sys\n\nimport tensorflow as tf\nimport unreal_engine as ue\n\nclass TFPluginAPI():\n\t@classmethod\n\tdef getInstance(cls):\n\t\t#This should return an instance of your class even if you subclassed it\n\t\treturn cls()\n\n\t## Private\n\tdef __init__(self):\n\t\t#class scoped variable for stopping\n\t\tself.shouldStop = False\t\t#check this variable to stop training early\n\t\tself.shouldRetrain = False\t#use this variable to force your training\n\t\tself.stored = {}\n\n\t#internal don't need to override this\n\tdef _resetTrainingTrigger(self):\n\t\tself.shouldStop = False\n\n\t#internal don't need to override this: early stopping\n\tdef _stopTraining(self):\n\t\tself.shouldStop = True\n\t\tself.onStopTraining()\n\n\t## Public\n\t\n\t#call this inside your class to emit a custom event on gt, don't override the function\n\tdef callEvent(self, event, data = None, useJson = False):\n\t\tself.tf_component.custom_event(event, data, useJson)\n\n\t#expected api: setup your model for training\n\tdef onSetup(self):\n\t\t#setup or load your model and pass it into stored\n\t\t\n\t\t#Usually store session, graph, and model if using keras\n\t\t#self.sess = tf.InteractiveSession()\n\t\t#self.graph = tf.get_default_graph()\n\t\tpass\n\n\t#expected api: storedModel and session, json inputs\n\tdef onJsonInput(self, jsonInput):\n\t\t#e.g. our json input could be a pixel array\n\t\t#pixelarray = jsonInput['pixels']\n\n\t\t#run input on your graph\n\t\t#e.g. sess.run(model['y'], feed_dict)\n\t\t# where y is your result graph and feed_dict is {x:[input]}\n\n\t\t#...\n\n\t\t#return a json you will parse e.g. a prediction\n\t\tresult = {}\n\t\tresult['prediction'] = 0\n\n\t\treturn result\n\n\n\n\t#expected api: no params forwarded for training? TBC\n\tdef onBeginTraining(self):\n\t\t#train here\n\n\t\t#...\n\n\t\t#inside your training loop check if we should stop early\n\t\t#if(self.shouldStop):\n\t\t#\tbreak\n\t\tpass\n\n\tdef onStopTraining(self):\n\t\t#you should be listening to self.shouldStop, but you can also receive this call\n\t\tpass\n\n#required function to get our api\ndef getApi():\n\t#return CLASSNAME.getInstance()\n\treturn TFPluginAPI.getInstance()"""
Content/Scripts/TensorFlowComponent.py,0,"b""import unreal_engine as ue\nimport upythread as ut\nimport json\nimport sys\nimport importlib\nimport time\nimport imp\n\nclass TensorFlowComponent:\n\n\t# constructor adding a component - Unused atm\n\t#def __init__(self):\n\t#\tue.log('Component Init')\n\n\t# this is called on game start\n\tdef begin_play(self):\n\t\tif(self.uobject.VerbosePythonLog):\n\t\t\tue.log('BeginPlay, importing TF module: ' + self.uobject.TensorFlowModule)\n\n\t\t#import the module\n\t\tself.tfModule = importlib.import_module(self.uobject.TensorFlowModule)\n\t\timp.reload(self.tfModule)\n\t\t\n\t\t#tfc or the class instance holding the pluginAPI\n\t\tself.tfapi = self.tfModule.getApi()\n\t\tself.tfapi.tf_component = self\n\n\t\t#link default variables\n\t\tself.tfapi.shouldRetrain = self.uobject.ShouldRetrain\n\n\t\t#Valid game world toggle for threading guards\n\t\tself.ValidGameWorld = True\n\n\t\t#call our tfapi setup, typically on another thread\n\t\tself.setup()\n\n\tdef end_play(self, reason):\n\t\tself.ValidGameWorld = False\n\t\tself.stop_training()\n\n\tdef stop_training(self):\n\t\tself.tfapi._stopTraining() \n\n\t#multi-threaded call\n\tdef setup(self, args=None):\n\t\tif(self.uobject.ShouldUseMultithreading):\n\t\t\ttry:\n\t\t\t\tif(self.uobject.VerbosePythonLog):\n\t\t\t\t\tue.log('running setup on background thread')\n\t\t\t\tut.run_on_bt(self.setup_blocking)\n\t\t\texcept:\n\t\t\t\te = sys.exc_info()[0]\n\t\t\t\tue.log('TensorFlowComponent::setup error: ' + str(e))\n\t\telse:\n\t\t\tself.setup_blocking()\n\n\t#multi-threaded call\n\tdef train(self, args=None):\n\t\t#ensure our training trigger is reset\n\t\tself.tfapi._resetTrainingTrigger()\n\n\t\tif(self.uobject.VerbosePythonLog):\n\t\t\tue.log(self.uobject.TensorFlowModule + ' training scheduled.')\n\n\t\tif(self.uobject.ShouldUseMultithreading):\n\t\t\ttry:\n\t\t\t\tut.run_on_bt(self.train_blocking)\n\t\t\texcept:\n\t\t\t\te = sys.exc_info()[0]\n\t\t\t\tue.log('TensorFlowComponent::train error: ' + str(e))\n\t\telse:\n\t\t\tself.train_blocking()\n\n\n\t#allow call custom functions on the tfapi object. Note all of these are synchronous\n\tdef custom_function(self, args=None):\n\t\t#split our custom function call by first ','\n\t\tstringList = args.split(',', 1)\n\n\t\t#call our custom function with our passed variables and return result\n\t\treturn getattr(self.tfapi, stringList[0])(stringList[1])\n\n\tdef custom_event_gt(self, eventdata):\n\t\tif(eventdata['useJson']):\n\t\t\tdata = json.dumps(eventdata['data'])\n\t\telse:\n\t\t\tdata = eventdata['data']\n\t\tself.uobject.OnEventFunction(eventdata['event'], data)\n\n\t#pass back a custom event\n\tdef custom_event(self, event, data=None, useJson=False):\n\t\t#embedd the data\n\t\teventdata = {}\n\t\teventdata['event'] = event\n\t\teventdata['data'] = data\n\t\teventdata['useJson'] = useJson\n\t\tue.run_on_gt(self.custom_event_gt, eventdata)\n\n\t#json input\n\tdef json_input(self, args):\n\t\tif(self.uobject.VerbosePythonLog):\n\t\t\tue.log(self.uobject.TensorFlowModule + ' input passed: ' + args)\n\n\t\t#branch based on threading\n\t\tif(self.uobject.ShouldUseMultithreading):\n\t\t\tut.run_on_bt(self.json_input_blocking, args)\n\t\telse:\n\t\t\tself.json_input_blocking(args)\n\n\t#setup blocking\n\tdef json_input_blocking(self, args):\n\t\t#pass the raw json to the script to handle\n\t\tresultJson = self.tfapi.onJsonInput(json.loads(args))\n\n\t\tif(self.uobject.ShouldUseMultithreading):\n\t\t\t#pass prediction json back\n\t\t\tif(self.ValidGameWorld):\n\t\t\t\tue.run_on_gt(self.json_input_gt_callback, resultJson)\n\t\telse:\n\t\t\tself.json_input_gt_callback(resultJson)\n\n\tdef json_input_gt_callback(self, resultJson):\n\t\tself.uobject.OnResultsFunction(json.dumps(resultJson))\n\n\t#setup blocking\n\tdef setup_blocking(self):\n\n\t\t#call the api setup (may be multi-threaded!)\n\t\tself.tfapi.onSetup()\n\n\t\t#run callbacks only if we're still in a valid game world\n\t\tif(self.ValidGameWorld):\n\t\t\tue.run_on_gt(self.setup_complete)\n\n\t#setup callback function\n\tdef setup_complete(self):\n\t\tif(self.uobject.VerbosePythonLog):\n\t\t\tue.log('Setup complete!');\n\n\t\t#train after setup has completed if toggled\n\t\tif(self.uobject.ShouldTrainOnBeginPlay):\n\t\t\tself.train()\n\n\t#single threaded call\n\tdef train_blocking(self):\n\t\tif(self.uobject.VerbosePythonLog):\n\t\t\tue.log(self.uobject.TensorFlowModule + ' training started on bt thread.')\n\n\t\t#calculate the time it takes to train your network\n\t\tstart = time.time()\n\t\tself.trained = self.tfapi.onBeginTraining()\n\t\tstop = time.time()\n\n\t\tif hasattr(self.trained, 'summary'):\n\t\t\tsummary = self.trained['summary']\n\t\telse:\n\t\t\tsummary = {}\n\n\t\tsummary['elapsed'] = stop-start\n\n\t\t#run callbacks only if we're still in a valid game world\n\t\tif(self.ValidGameWorld):\n\t\t\tue.run_on_gt(self.training_complete, summary)\n\n\t#training callback function\n\tdef training_complete(self, summary):\n\t\tif(self.uobject.VerbosePythonLog):\n\t\t\tue.log(self.uobject.TensorFlowModule + ' trained in ' + str(round(summary['elapsed'],2)) + ' seconds.')\n\n\t\tself.uobject.OnTrainingCompleteFunction(json.dumps(summary))"""
