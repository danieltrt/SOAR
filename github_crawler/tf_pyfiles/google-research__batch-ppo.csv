file_path,api_count,code
setup.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Setup script for TensorFlow Agents.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport setuptools\n\n\nsetuptools.setup(\n    name=\'batch-ppo\',\n    version=\'1.4.0\',\n    description=(\n        \'Efficient TensorFlow implementation of \' +\n        \'Proximal Policy Optimization.\'),\n    license=\'Apache 2.0\',\n    url=\'http://github.com/google-research/batch-ppo\',\n    install_requires=[\n        \'tensorflow\',\n        \'gym\',\n        \'ruamel.yaml\',\n    ],\n    packages=setuptools.find_packages(),\n    classifiers=[\n        \'Programming Language :: Python :: 2\',\n        \'Programming Language :: Python :: 3\',\n        \'License :: OSI Approved :: Apache Software License\',\n        \'Topic :: Scientific/Engineering :: Artificial Intelligence\',\n        \'Intended Audience :: Science/Research\',\n    ],\n)\n'"
agents/__init__.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Main package of TensorFlow agents.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom . import algorithms\nfrom . import scripts\nfrom . import tools\n'"
agents/algorithms/__init__.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Agent implementations.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom .ppo import PPO\n'"
agents/parts/__init__.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Reusable parts for building agents.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom .normalize import StreamingNormalize\nfrom .memory import EpisodeMemory\nfrom .iterate_sequences import iterate_sequences\n'"
agents/parts/iterate_sequences.py,11,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Normalize tensors based on streaming estimates of mean and variance.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom agents import tools\n\n\ndef iterate_sequences(\n    consumer_fn, output_template, sequences, length, chunk_length=None,\n    batch_size=None, num_epochs=1, padding_value=0):\n  """"""Iterate over batches of chunks of sequences for multiple epochs.\n\n  The batch dimension of the length tensor must be set because it is used to\n  infer buffer sizes.\n\n  Args:\n    consumer_fn: Function creating the operation to process the data.\n    output_template: Nested tensors of same shape and dtype as outputs.\n    sequences: Nested collection of tensors with batch and time dimension.\n    length: Tensor containing the length for each sequence.\n    chunk_length: Split sequences into chunks of this size; optional.\n    batch_size: Split epochs into batches of this size; optional.\n    num_epochs: How many times to repeat over the data.\n    padding_value: Value used for padding the last chunk after the sequence.\n\n  Raises:\n    ValueError: Unknown batch size of the length tensor.\n\n  Returns:\n    Concatenated nested tensors returned by the consumer.\n  """"""\n  if not length.shape[0].value:\n    raise ValueError(\'Batch size of length tensor must be set.\')\n  num_sequences = length.shape[0].value\n  sequences = dict(sequence=sequences, length=length)\n  dataset = tf.data.Dataset.from_tensor_slices(sequences)\n  dataset = dataset.repeat(num_epochs)\n  if chunk_length:\n    dataset = dataset.map(remove_padding).flat_map(\n        # pylint: disable=g-long-lambda\n        lambda x: tf.data.Dataset.from_tensor_slices(\n            chunk_sequence(x, chunk_length, padding_value)))\n    num_chunks = tf.reduce_sum((length - 1) // chunk_length + 1)\n  else:\n    num_chunks = num_sequences\n  if batch_size:\n    dataset = dataset.shuffle(num_sequences // 2)\n  dataset = dataset.batch(batch_size or num_sequences)\n  dataset = dataset.prefetch(num_epochs)\n  iterator = dataset.make_initializable_iterator()\n  with tf.control_dependencies([iterator.initializer]):\n    num_batches = num_epochs * num_chunks // (batch_size or num_sequences)\n    return tf.scan(\n        # pylint: disable=g-long-lambda\n        lambda _1, index: consumer_fn(iterator.get_next()),\n        tf.range(num_batches), output_template, parallel_iterations=1)\n\n\ndef chunk_sequence(sequence, chunk_length=200, padding_value=0):\n  """"""Split a nested dict of sequence tensors into a batch of chunks.\n\n  This function does not expect a batch of sequences, but a single sequence. A\n  `length` key is added if it did not exist already.\n\n  Args:\n    sequence: Nested dict of tensors with time dimension.\n    chunk_length: Size of chunks the sequence will be split into.\n    padding_value: Value used for padding the last chunk after the sequence.\n\n  Returns:\n    Nested dict of sequence tensors with chunk dimension.\n  """"""\n  if \'length\' in sequence:\n    length = sequence.pop(\'length\')\n  else:\n    length = tf.shape(tools.nested.flatten(sequence)[0])[0]\n  num_chunks = (length - 1) // chunk_length + 1\n  padding_length = chunk_length * num_chunks - length\n  padded = tools.nested.map(\n      # pylint: disable=g-long-lambda\n      lambda tensor: tf.concat([\n          tensor, 0 * tensor[:padding_length] + padding_value], 0),\n      sequence)\n  chunks = tools.nested.map(\n      # pylint: disable=g-long-lambda\n      lambda tensor: tf.reshape(\n          tensor, [num_chunks, chunk_length] + tensor.shape[1:].as_list()),\n      padded)\n  chunks[\'length\'] = tf.concat([\n      chunk_length * tf.ones((num_chunks - 1,), dtype=tf.int32),\n      [chunk_length - padding_length]], 0)\n  return chunks\n\n\ndef remove_padding(sequence):\n  """"""Selects the used frames of a sequence, up to its length.\n\n  This function does not expect a batch of sequences, but a single sequence.\n  The sequence must be a dict with `length` key, which will removed from the\n  result.\n\n  Args:\n    sequence: Nested dict of tensors with time dimension.\n\n  Returns:\n    Nested dict of tensors with padding elements and `length` key removed.\n  """"""\n  length = sequence.pop(\'length\')\n  sequence = tools.nested.map(lambda tensor: tensor[:length], sequence)\n  return sequence\n'"
agents/parts/memory.py,30,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Memory that stores episodes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom agents import tools\n\n\nclass EpisodeMemory(object):\n  """"""Memory that stores episodes.""""""\n\n  def __init__(self, template, capacity, max_length, scope):\n    """"""Create a memory that stores episodes.\n\n    Each transition tuple consists of quantities specified by the template.\n    These quantities would typically be be observations, actions, rewards, and\n    done indicators.\n\n    Args:\n      template: Nested tensors to derive shapes and dtypes of each transition.\n      capacity: Number of episodes, or rows, hold by the memory.\n      max_length: Allocated sequence length for the episodes.\n      scope: Variable scope to use for internal variables.\n    """"""\n    self._capacity = capacity\n    self._max_length = max_length\n    with tf.variable_scope(scope) as var_scope:\n      self._scope = var_scope\n      self._length = tf.Variable(tf.zeros(capacity, tf.int32), False)\n      self._buffers = tools.nested.map(\n          lambda x: tf.Variable(tf.zeros(\n              [capacity, max_length] + x.shape.as_list(), x.dtype), False),\n          template)\n\n  def length(self, rows=None):\n    """"""Tensor holding the current length of episodes.\n\n    Args:\n      rows: Episodes to select length from, defaults to all.\n\n    Returns:\n      Batch tensor of sequence lengths.\n    """"""\n    rows = tf.range(self._capacity) if rows is None else rows\n    return tf.gather(self._length, rows)\n\n  def append(self, transitions, rows=None):\n    """"""Append a batch of transitions to rows of the memory.\n\n    Args:\n      transitions: Tuple of transition quantities with batch dimension.\n      rows: Episodes to append to, defaults to all.\n\n    Returns:\n      Operation.\n    """"""\n    rows = tf.range(self._capacity) if rows is None else rows\n    assert rows.shape.ndims == 1\n    assert_capacity = tf.assert_less(\n        rows, self._capacity,\n        message=\'capacity exceeded\')\n    with tf.control_dependencies([assert_capacity]):\n      assert_max_length = tf.assert_less(\n          tf.gather(self._length, rows), self._max_length,\n          message=\'max length exceeded\')\n    with tf.control_dependencies([assert_max_length]):\n      timestep = tf.gather(self._length, rows)\n      indices = tf.stack([rows, timestep], 1)\n      append_ops = tools.nested.map(\n          lambda var, val: tf.scatter_nd_update(var, indices, val),\n          self._buffers, transitions, flatten=True)\n    with tf.control_dependencies(append_ops):\n      episode_mask = tf.reduce_sum(tf.one_hot(\n          rows, self._capacity, dtype=tf.int32), 0)\n      return self._length.assign_add(episode_mask)\n\n  def replace(self, episodes, length, rows=None):\n    """"""Replace full episodes.\n\n    Args:\n      episodes: Tuple of transition quantities with batch and time dimensions.\n      length: Batch of sequence lengths.\n      rows: Episodes to replace, defaults to all.\n\n    Returns:\n      Operation.\n    """"""\n    rows = tf.range(self._capacity) if rows is None else rows\n    assert rows.shape.ndims == 1\n    assert_capacity = tf.assert_less(\n        rows, self._capacity, message=\'capacity exceeded\')\n    with tf.control_dependencies([assert_capacity]):\n      assert_max_length = tf.assert_less_equal(\n          length, self._max_length, message=\'max length exceeded\')\n    with tf.control_dependencies([assert_max_length]):\n      replace_ops = tools.nested.map(\n          lambda var, val: tf.scatter_update(var, rows, val),\n          self._buffers, episodes, flatten=True)\n    with tf.control_dependencies(replace_ops):\n      return tf.scatter_update(self._length, rows, length)\n\n  def data(self, rows=None):\n    """"""Access a batch of episodes from the memory.\n\n    Padding elements after the length of each episode are unspecified and might\n    contain old data.\n\n    Args:\n      rows: Episodes to select, defaults to all.\n\n    Returns:\n      Tuple containing a tuple of transition quantities with batch and time\n      dimensions, and a batch of sequence lengths.\n    """"""\n    rows = tf.range(self._capacity) if rows is None else rows\n    assert rows.shape.ndims == 1\n    episode = tools.nested.map(lambda var: tf.gather(var, rows), self._buffers)\n    length = tf.gather(self._length, rows)\n    return episode, length\n\n  def clear(self, rows=None):\n    """"""Reset episodes in the memory.\n\n    Internally, this only sets their lengths to zero. The memory entries will\n    be overridden by future calls to append() or replace().\n\n    Args:\n      rows: Episodes to clear, defaults to all.\n\n    Returns:\n      Operation.\n    """"""\n    rows = tf.range(self._capacity) if rows is None else rows\n    assert rows.shape.ndims == 1\n    return tf.scatter_update(self._length, rows, tf.zeros_like(rows))\n'"
agents/parts/normalize.py,34,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Normalize tensors based on streaming estimates of mean and variance.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\n\nclass StreamingNormalize(object):\n  """"""Normalize tensors based on streaming estimates of mean and variance.""""""\n\n  def __init__(\n      self, template, center=True, scale=True, clip=10, name=\'normalize\'):\n    """"""Normalize tensors based on streaming estimates of mean and variance.\n\n    Centering the value, scaling it by the standard deviation, and clipping\n    outlier values are optional.\n\n    Args:\n      template: Example tensor providing shape and dtype of the vaule to track.\n      center: Python boolean indicating whether to subtract mean from values.\n      scale: Python boolean indicating whether to scale values by stddev.\n      clip: If and when to clip normalized values.\n      name: Parent scope of operations provided by this class.\n    """"""\n    self._center = center\n    self._scale = scale\n    self._clip = clip\n    self._name = name\n    with tf.name_scope(name):\n      self._count = tf.Variable(0, False)\n      self._mean = tf.Variable(tf.zeros_like(template), False)\n      self._var_sum = tf.Variable(tf.zeros_like(template), False)\n\n  def transform(self, value):\n    """"""Normalize a single or batch tensor.\n\n    Applies the activated transformations in the constructor using current\n    estimates of mean and variance.\n\n    Args:\n      value: Batch or single value tensor.\n\n    Returns:\n      Normalized batch or single value tensor.\n    """"""\n    with tf.name_scope(self._name + \'/transform\'):\n      no_batch_dim = value.shape.ndims == self._mean.shape.ndims\n      if no_batch_dim:\n        # Add a batch dimension if necessary.\n        value = value[None, ...]\n      if self._center:\n        value -= self._mean[None, ...]\n      if self._scale:\n        # We cannot scale before seeing at least two samples.\n        value /= tf.cond(\n            self._count > 1, lambda: self._std() + 1e-8,\n            lambda: tf.ones_like(self._var_sum))[None]\n      if self._clip:\n        value = tf.clip_by_value(value, -self._clip, self._clip)\n      # Remove batch dimension if necessary.\n      if no_batch_dim:\n        value = value[0]\n      return tf.check_numerics(value, \'value\')\n\n  def update(self, value):\n    """"""Update the mean and variance estimates.\n\n    Args:\n      value: Batch or single value tensor.\n\n    Returns:\n      Summary tensor.\n    """"""\n    with tf.name_scope(self._name + \'/update\'):\n      if value.shape.ndims == self._mean.shape.ndims:\n        # Add a batch dimension if necessary.\n        value = value[None, ...]\n      count = tf.shape(value)[0]\n      with tf.control_dependencies([self._count.assign_add(count)]):\n        step = tf.cast(self._count, tf.float32)\n        mean_delta = tf.reduce_sum(value - self._mean[None, ...], 0)\n        new_mean = self._mean + mean_delta / step\n        new_mean = tf.cond(self._count > 1, lambda: new_mean, lambda: value[0])\n        var_delta = (\n            value - self._mean[None, ...]) * (value - new_mean[None, ...])\n        new_var_sum = self._var_sum + tf.reduce_sum(var_delta, 0)\n      with tf.control_dependencies([new_mean, new_var_sum]):\n        update = self._mean.assign(new_mean), self._var_sum.assign(new_var_sum)\n      with tf.control_dependencies(update):\n        if value.shape.ndims == 1:\n          value = tf.reduce_mean(value)\n        return self._summary(\'value\', tf.reduce_mean(value))\n\n  def reset(self):\n    """"""Reset the estimates of mean and variance.\n\n    Resets the full state of this class.\n\n    Returns:\n      Operation.\n    """"""\n    with tf.name_scope(self._name + \'/reset\'):\n      return tf.group(\n          self._count.assign(0),\n          self._mean.assign(tf.zeros_like(self._mean)),\n          self._var_sum.assign(tf.zeros_like(self._var_sum)))\n\n  def summary(self):\n    """"""Summary string of mean and standard deviation.\n\n    Returns:\n      Summary tensor.\n    """"""\n    with tf.name_scope(self._name + \'/summary\'):\n      mean_summary = tf.cond(\n          self._count > 0, lambda: self._summary(\'mean\', self._mean), str)\n      std_summary = tf.cond(\n          self._count > 1, lambda: self._summary(\'stddev\', self._std()), str)\n      return tf.summary.merge([mean_summary, std_summary])\n\n  def _std(self):\n    """"""Computes the current estimate of the standard deviation.\n\n    Note that the standard deviation is not defined until at least two samples\n    were seen.\n\n    Returns:\n      Tensor of current variance.\n    """"""\n    variance = tf.cond(\n        self._count > 1,\n        lambda: self._var_sum / tf.cast(self._count - 1, tf.float32),\n        lambda: tf.ones_like(self._var_sum) * float(\'nan\'))\n    # The epsilon corrects for small negative variance values caused by\n    # the algorithm. It was empirically chosen to work with all environments\n    # tested.\n    return tf.sqrt(variance + 1e-4)\n\n  def _summary(self, name, tensor):\n    """"""Create a scalar or histogram summary matching the rank of the tensor.\n\n    Args:\n      name: Name for the summary.\n      tensor: Tensor to summarize.\n\n    Returns:\n      Summary tensor.\n    """"""\n    if tensor.shape.ndims == 0:\n      return tf.summary.scalar(name, tensor)\n    else:\n      return tf.summary.histogram(name, tensor)\n'"
agents/scripts/__init__.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Executable scripts for reinforcement learning.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom . import train\nfrom . import utility\nfrom . import visualize\n'"
agents/scripts/configs.py,1,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Example configurations using the PPO algorithm.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n# pylint: disable=unused-variable\n\nimport tensorflow as tf\n\nfrom agents import algorithms\nfrom agents.scripts import networks\n\n\ndef default():\n  """"""Default configuration for PPO.""""""\n  # General\n  algorithm = algorithms.PPO\n  num_agents = 30\n  eval_episodes = 30\n  use_gpu = False\n  # Environment\n  normalize_ranges = True\n  # Network\n  network = networks.feed_forward_gaussian\n  weight_summaries = dict(\n      all=r\'.*\', policy=r\'.*/policy/.*\', value=r\'.*/value/.*\')\n  policy_layers = 200, 100\n  value_layers = 200, 100\n  init_output_factor = 0.1\n  init_std = 0.35\n  # Optimization\n  update_every = 30\n  update_epochs = 25\n  optimizer = tf.train.AdamOptimizer\n  learning_rate = 1e-4\n  # Losses\n  discount = 0.995\n  kl_target = 1e-2\n  kl_cutoff_factor = 2\n  kl_cutoff_coef = 1000\n  kl_init_penalty = 1\n  return locals()\n\n\ndef pendulum():\n  """"""Configuration for the pendulum classic control task.""""""\n  locals().update(default())\n  # Environment\n  env = \'Pendulum-v0\'\n  max_length = 200\n  steps = 1e6  # 1M\n  # Optimization\n  batch_size = 20\n  chunk_length = 50\n  return locals()\n\n\ndef cartpole():\n  """"""Configuration for the cart pole classic control task.""""""\n  locals().update(default())\n  # Environment\n  env = \'CartPole-v1\'\n  max_length = 500\n  steps = 2e5  # 200k\n  normalize_ranges = False  # The env reports wrong ranges.\n  # Network\n  network = networks.feed_forward_categorical\n  return locals()\n\n\ndef reacher():\n  """"""Configuration for MuJoCo\'s reacher task.""""""\n  locals().update(default())\n  # Environment\n  env = \'Reacher-v2\'\n  max_length = 1000\n  steps = 5e6  # 5M\n  discount = 0.985\n  update_every = 60\n  return locals()\n\n\ndef cheetah():\n  """"""Configuration for MuJoCo\'s half cheetah task.""""""\n  locals().update(default())\n  # Environment\n  env = \'HalfCheetah-v2\'\n  max_length = 1000\n  steps = 1e7  # 10M\n  discount = 0.99\n  return locals()\n\n\ndef walker():\n  """"""Configuration for MuJoCo\'s walker task.""""""\n  locals().update(default())\n  # Environment\n  env = \'Walker2d-v2\'\n  max_length = 1000\n  steps = 1e7  # 10M\n  return locals()\n\n\ndef hopper():\n  """"""Configuration for MuJoCo\'s hopper task.""""""\n  locals().update(default())\n  # Environment\n  env = \'Hopper-v2\'\n  max_length = 1000\n  steps = 1e7  # 10M\n  update_every = 60\n  return locals()\n\n\ndef ant():\n  """"""Configuration for MuJoCo\'s ant task.""""""\n  locals().update(default())\n  # Environment\n  env = \'Ant-v2\'\n  max_length = 1000\n  steps = 2e7  # 20M\n  return locals()\n\n\ndef humanoid():\n  """"""Configuration for MuJoCo\'s humanoid task.""""""\n  locals().update(default())\n  # Environment\n  env = \'Humanoid-v2\'\n  max_length = 1000\n  steps = 5e7  # 50M\n  update_every = 60\n  return locals()\n\n\ndef bullet_ant():\n  """"""Configuration for PyBullet\'s ant task.""""""\n  locals().update(default())\n  # Environment\n  import pybullet_envs  # noqa pylint: disable=unused-import\n  env = \'AntBulletEnv-v0\'\n  max_length = 1000\n  steps = 3e7  # 30M\n  update_every = 60\n  return locals()\n'"
agents/scripts/networks.py,55,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Policy networks for agents.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\nimport operator\n\nimport gym\nimport numpy as np\nimport tensorflow as tf\n\nimport agents\n\ntfd = tf.contrib.distributions\n\n\n# TensorFlow\'s default implementation of the KL divergence between two\n# tf.contrib.distributions.MultivariateNormalDiag instances sometimes results\n# in NaN values in the gradients (not in the forward pass). Until the default\n# implementation is fixed, we use our own KL implementation.\nclass CustomKLDiagNormal(tfd.MultivariateNormalDiag):\n  """"""Multivariate Normal with diagonal covariance and our custom KL code.""""""\n  pass\n\n\n@tfd.RegisterKL(CustomKLDiagNormal, CustomKLDiagNormal)\ndef _custom_diag_normal_kl(lhs, rhs, name=None):  # pylint: disable=unused-argument\n  """"""Empirical KL divergence of two normals with diagonal covariance.\n\n  Args:\n    lhs: Diagonal Normal distribution.\n    rhs: Diagonal Normal distribution.\n    name: Name scope for the op.\n\n  Returns:\n    KL divergence from lhs to rhs.\n  """"""\n  with tf.name_scope(name or \'kl_divergence\'):\n    mean0 = lhs.mean()\n    mean1 = rhs.mean()\n    logstd0 = tf.log(lhs.stddev())\n    logstd1 = tf.log(rhs.stddev())\n    logstd0_2, logstd1_2 = 2 * logstd0, 2 * logstd1\n    return 0.5 * (\n        tf.reduce_sum(tf.exp(logstd0_2 - logstd1_2), -1) +\n        tf.reduce_sum((mean1 - mean0) ** 2 / tf.exp(logstd1_2), -1) +\n        tf.reduce_sum(logstd1_2, -1) - tf.reduce_sum(logstd0_2, -1) -\n        mean0.shape[-1].value)\n\n\ndef feed_forward_gaussian(\n    config, action_space, observations, unused_length, state=None):\n  """"""Independent feed forward networks for policy and value.\n\n  The policy network outputs the mean action and the standard deviation is\n  learned as independent parameter vector.\n\n  Args:\n    config: Configuration object.\n    action_space: Action space of the environment.\n    observations: Sequences of observations.\n    unused_length: Batch of sequence lengths.\n    state: Unused batch of initial states.\n\n  Raises:\n    ValueError: Unexpected action space.\n\n  Returns:\n    Attribute dictionary containing the policy, value, and unused state.\n  """"""\n  if not isinstance(action_space, gym.spaces.Box):\n    raise ValueError(\'Network expects continuous actions.\')\n  if not len(action_space.shape) == 1:\n    raise ValueError(\'Network only supports 1D action vectors.\')\n  action_size = action_space.shape[0]\n  init_output_weights = tf.contrib.layers.variance_scaling_initializer(\n      factor=config.init_output_factor)\n  before_softplus_std_initializer = tf.constant_initializer(\n      np.log(np.exp(config.init_std) - 1))\n  flat_observations = tf.reshape(observations, [\n      tf.shape(observations)[0], tf.shape(observations)[1],\n      functools.reduce(operator.mul, observations.shape.as_list()[2:], 1)])\n  with tf.variable_scope(\'policy\'):\n    x = flat_observations\n    for size in config.policy_layers:\n      x = tf.contrib.layers.fully_connected(x, size, tf.nn.relu)\n    mean = tf.contrib.layers.fully_connected(\n        x, action_size, tf.tanh,\n        weights_initializer=init_output_weights)\n    std = tf.nn.softplus(tf.get_variable(\n        \'before_softplus_std\', mean.shape[2:], tf.float32,\n        before_softplus_std_initializer))\n    std = tf.tile(\n        std[None, None],\n        [tf.shape(mean)[0], tf.shape(mean)[1]] + [1] * (mean.shape.ndims - 2))\n  with tf.variable_scope(\'value\'):\n    x = flat_observations\n    for size in config.value_layers:\n      x = tf.contrib.layers.fully_connected(x, size, tf.nn.relu)\n    value = tf.contrib.layers.fully_connected(x, 1, None)[..., 0]\n  mean = tf.check_numerics(mean, \'mean\')\n  std = tf.check_numerics(std, \'std\')\n  value = tf.check_numerics(value, \'value\')\n  policy = CustomKLDiagNormal(mean, std)\n  return agents.tools.AttrDict(policy=policy, value=value, state=state)\n\n\ndef feed_forward_categorical(\n    config, action_space, observations, unused_length, state=None):\n  """"""Independent feed forward networks for policy and value.\n\n  The policy network outputs the mean action and the log standard deviation\n  is learned as independent parameter vector.\n\n  Args:\n    config: Configuration object.\n    action_space: Action space of the environment.\n    observations: Sequences of observations.\n    unused_length: Batch of sequence lengths.\n    state: Unused batch of initial recurrent states.\n\n  Raises:\n    ValueError: Unexpected action space.\n\n  Returns:\n    Attribute dictionary containing the policy, value, and unused state.\n  """"""\n  init_output_weights = tf.contrib.layers.variance_scaling_initializer(\n      factor=config.init_output_factor)\n  if not isinstance(action_space, gym.spaces.Discrete):\n    raise ValueError(\'Network expects discrete actions.\')\n  flat_observations = tf.reshape(observations, [\n      tf.shape(observations)[0], tf.shape(observations)[1],\n      functools.reduce(operator.mul, observations.shape.as_list()[2:], 1)])\n  with tf.variable_scope(\'policy\'):\n    x = flat_observations\n    for size in config.policy_layers:\n      x = tf.contrib.layers.fully_connected(x, size, tf.nn.relu)\n    logits = tf.contrib.layers.fully_connected(\n        x, action_space.n, None, weights_initializer=init_output_weights)\n  with tf.variable_scope(\'value\'):\n    x = flat_observations\n    for size in config.value_layers:\n      x = tf.contrib.layers.fully_connected(x, size, tf.nn.relu)\n    value = tf.contrib.layers.fully_connected(x, 1, None)[..., 0]\n  policy = tfd.Categorical(logits)\n  return agents.tools.AttrDict(policy=policy, value=value, state=state)\n\n\ndef recurrent_gaussian(\n    config, action_space, observations, length, state=None):\n  """"""Independent recurrent policy and feed forward value networks.\n\n  The policy network outputs the mean action and the standard deviation is\n  learned as independent parameter vector. The last policy layer is recurrent\n  and uses a GRU cell.\n\n  Args:\n    config: Configuration object.\n    action_space: Action space of the environment.\n    observations: Sequences of observations.\n    length: Batch of sequence lengths.\n    state: Batch of initial recurrent states.\n\n  Raises:\n    ValueError: Unexpected action space.\n\n  Returns:\n    Attribute dictionary containing the policy, value, and state.\n  """"""\n  if not isinstance(action_space, gym.spaces.Box):\n    raise ValueError(\'Network expects continuous actions.\')\n  if not len(action_space.shape) == 1:\n    raise ValueError(\'Network only supports 1D action vectors.\')\n  action_size = action_space.shape[0]\n  init_output_weights = tf.contrib.layers.variance_scaling_initializer(\n      factor=config.init_output_factor)\n  before_softplus_std_initializer = tf.constant_initializer(\n      np.log(np.exp(config.init_std) - 1))\n  cell = tf.contrib.rnn.GRUBlockCell(config.policy_layers[-1])\n  flat_observations = tf.reshape(observations, [\n      tf.shape(observations)[0], tf.shape(observations)[1],\n      functools.reduce(operator.mul, observations.shape.as_list()[2:], 1)])\n  with tf.variable_scope(\'policy\'):\n    x = flat_observations\n    for size in config.policy_layers[:-1]:\n      x = tf.contrib.layers.fully_connected(x, size, tf.nn.relu)\n    x, state = tf.nn.dynamic_rnn(cell, x, length, state, tf.float32)\n    mean = tf.contrib.layers.fully_connected(\n        x, action_size, tf.tanh,\n        weights_initializer=init_output_weights)\n    std = tf.nn.softplus(tf.get_variable(\n        \'before_softplus_std\', mean.shape[2:], tf.float32,\n        before_softplus_std_initializer))\n    std = tf.tile(\n        std[None, None],\n        [tf.shape(mean)[0], tf.shape(mean)[1]] + [1] * (mean.shape.ndims - 2))\n  with tf.variable_scope(\'value\'):\n    x = flat_observations\n    for size in config.value_layers:\n      x = tf.contrib.layers.fully_connected(x, size, tf.nn.relu)\n    value = tf.contrib.layers.fully_connected(x, 1, None)[..., 0]\n  mean = tf.check_numerics(mean, \'mean\')\n  std = tf.check_numerics(std, \'std\')\n  value = tf.check_numerics(value, \'value\')\n  policy = CustomKLDiagNormal(mean, std)\n  return agents.tools.AttrDict(policy=policy, value=value, state=state)\n'"
agents/scripts/train.py,12,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nr""""""Script to train a batch reinforcement learning algorithm.\n\nCommand line:\n\n  python3 -m agents.scripts.train --logdir=/path/to/logdir --config=pendulum\n""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport datetime\nimport os\n\nimport gym\nimport tensorflow as tf\n\nfrom agents import tools\nfrom agents.scripts import configs\nfrom agents.scripts import utility\n\n\ndef _create_environment(config):\n  """"""Constructor for an instance of the environment.\n\n  Args:\n    config: Object providing configurations via attributes.\n\n  Raises:\n    NotImplementedError: For action spaces other than Box and Discrete.\n\n  Returns:\n    Wrapped OpenAI Gym environment.\n  """"""\n  if isinstance(config.env, str):\n    env = gym.make(config.env)\n  else:\n    env = config.env()\n  if config.max_length:\n    env = tools.wrappers.LimitDuration(env, config.max_length)\n  if isinstance(env.action_space, gym.spaces.Box):\n    if config.normalize_ranges:\n      env = tools.wrappers.RangeNormalize(env)\n    env = tools.wrappers.ClipAction(env)\n  elif isinstance(env.action_space, gym.spaces.Discrete):\n    if config.normalize_ranges:\n      env = tools.wrappers.RangeNormalize(env, action=False)\n  else:\n    message = ""Unsupported action space \'{}\'"".format(type(env.action_space))\n    raise NotImplementedError(message)\n  env = tools.wrappers.ConvertTo32Bit(env)\n  env = tools.wrappers.CacheSpaces(env)\n  return env\n\n\ndef _define_loop(graph, logdir, train_steps, eval_steps):\n  """"""Create and configure a training loop with training and evaluation phases.\n\n  Args:\n    graph: Object providing graph elements via attributes.\n    logdir: Log directory for storing checkpoints and summaries.\n    train_steps: Number of training steps per epoch.\n    eval_steps: Number of evaluation steps per epoch.\n\n  Returns:\n    Loop object.\n  """"""\n  loop = tools.Loop(\n      logdir, graph.step, graph.should_log, graph.do_report,\n      graph.force_reset)\n  loop.add_phase(\n      \'train\', graph.done, graph.score, graph.summary, train_steps,\n      report_every=train_steps,\n      log_every=train_steps // 2,\n      checkpoint_every=None,\n      feed={graph.is_training: True})\n  loop.add_phase(\n      \'eval\', graph.done, graph.score, graph.summary, eval_steps,\n      report_every=eval_steps,\n      log_every=eval_steps // 2,\n      checkpoint_every=10 * eval_steps,\n      feed={graph.is_training: False})\n  return loop\n\n\ndef train(config, env_processes):\n  """"""Training and evaluation entry point yielding scores.\n\n  Resolves some configuration attributes, creates environments, graph, and\n  training loop. By default, assigns all operations to the CPU.\n\n  Args:\n    config: Object providing configurations via attributes.\n    env_processes: Whether to step environments in separate processes.\n\n  Yields:\n    Evaluation scores.\n  """"""\n  tf.reset_default_graph()\n  if config.update_every % config.num_agents:\n    tf.logging.warn(\'Number of agents should divide episodes per update.\')\n  with tf.device(\'/cpu:0\'):\n    batch_env = utility.define_batch_env(\n        lambda: _create_environment(config),\n        config.num_agents, env_processes)\n    graph = utility.define_simulation_graph(\n        batch_env, config.algorithm, config)\n    loop = _define_loop(\n        graph, config.logdir,\n        config.update_every * config.max_length,\n        config.eval_episodes * config.max_length)\n    total_steps = int(\n        config.steps / config.update_every *\n        (config.update_every + config.eval_episodes))\n  # Exclude episode related variables since the Python state of environments is\n  # not checkpointed and thus new episodes start after resuming.\n  saver = utility.define_saver(exclude=(r\'.*_temporary.*\',))\n  sess_config = tf.ConfigProto(allow_soft_placement=True)\n  sess_config.gpu_options.allow_growth = True\n  with tf.Session(config=sess_config) as sess:\n    utility.initialize_variables(sess, saver, config.logdir)\n    for score in loop.run(sess, saver, total_steps):\n      yield score\n  batch_env.close()\n\n\ndef main(_):\n  """"""Create or load configuration and launch the trainer.""""""\n  utility.set_up_logging()\n  if not FLAGS.config:\n    raise KeyError(\'You must specify a configuration.\')\n  logdir = FLAGS.logdir and os.path.expanduser(os.path.join(\n      FLAGS.logdir, \'{}-{}\'.format(FLAGS.timestamp, FLAGS.config)))\n  try:\n    config = utility.load_config(logdir)\n  except IOError:\n    config = tools.AttrDict(getattr(configs, FLAGS.config)())\n    config = utility.save_config(config, logdir)\n  for score in train(config, FLAGS.env_processes):\n    tf.logging.info(\'Score {}.\'.format(score))\n\n\nif __name__ == \'__main__\':\n  FLAGS = tf.app.flags.FLAGS\n  tf.app.flags.DEFINE_string(\n      \'logdir\', None,\n      \'Base directory to store logs.\')\n  tf.app.flags.DEFINE_string(\n      \'timestamp\', datetime.datetime.now().strftime(\'%Y%m%dT%H%M%S\'),\n      \'Sub directory to store logs.\')\n  tf.app.flags.DEFINE_string(\n      \'config\', None,\n      \'Configuration to execute.\')\n  tf.app.flags.DEFINE_boolean(\n      \'env_processes\', True,\n      \'Step environments in separate processes to circumvent the GIL.\')\n  tf.app.run()\n'"
agents/scripts/train_ppo_test.py,2,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests for the PPO algorithm usage example.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\nimport itertools\n\nimport tensorflow as tf\n\nfrom agents import algorithms\nfrom agents import tools\nfrom agents.scripts import configs\nfrom agents.scripts import networks\nfrom agents.scripts import train\n\n\nclass PPOTest(tf.test.TestCase):\n\n  def test_pendulum_no_crash(self):\n    nets = networks.feed_forward_gaussian, networks.recurrent_gaussian\n    for network in nets:\n      config = self._define_config()\n      with config.unlocked:\n        config.env = \'Pendulum-v0\'\n        config.max_length = 200\n        config.steps = 500\n        config.network = network\n      for score in train.train(config, env_processes=True):\n        float(score)\n\n  def test_no_crash_cartpole(self):\n    config = self._define_config()\n    with config.unlocked:\n      config.env = \'CartPole-v1\'\n      config.max_length = 200\n      config.steps = 500\n      config.normalize_ranges = False  # The env reports wrong ranges.\n      config.network = networks.feed_forward_categorical\n    for score in train.train(config, env_processes=True):\n      float(score)\n\n  def test_no_crash_observation_shape(self):\n    nets = networks.feed_forward_gaussian, networks.recurrent_gaussian\n    observ_shapes = (1,), (2, 3), (2, 3, 4)\n    for network, observ_shape in itertools.product(nets, observ_shapes):\n      config = self._define_config()\n      with config.unlocked:\n        config.env = functools.partial(\n            tools.MockEnvironment, observ_shape, action_shape=(3,),\n            min_duration=15, max_duration=15)\n        config.max_length = 20\n        config.steps = 50\n        config.network = network\n      for score in train.train(config, env_processes=False):\n        float(score)\n\n  def test_no_crash_variable_duration(self):\n    config = self._define_config()\n    with config.unlocked:\n      config.env = functools.partial(\n          tools.MockEnvironment, observ_shape=(2, 3), action_shape=(3,),\n          min_duration=5, max_duration=25)\n      config.max_length = 25\n      config.steps = 100\n      config.network = networks.recurrent_gaussian\n    for score in train.train(config, env_processes=False):\n      float(score)\n\n  def test_no_crash_chunking(self):\n    config = self._define_config()\n    with config.unlocked:\n      config.env = functools.partial(\n          tools.MockEnvironment, observ_shape=(2, 3), action_shape=(3,),\n          min_duration=5, max_duration=25)\n      config.max_length = 25\n      config.steps = 100\n      config.network = networks.recurrent_gaussian\n      config.chunk_length = 10\n      config.batch_size = 5\n    for score in train.train(config, env_processes=False):\n      float(score)\n\n  def _define_config(self):\n    # Start from the example configuration.\n    locals().update(configs.default())\n    # pylint: disable=unused-variable\n    # General\n    algorithm = algorithms.PPO\n    num_agents = 2\n    update_every = 4\n    use_gpu = False\n    # Network\n    policy_layers = 20, 10\n    value_layers = 20, 10\n    # Optimization\n    update_epochs_policy = 2\n    update_epochs_value = 2\n    # pylint: enable=unused-variable\n    return tools.AttrDict(locals())\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
agents/scripts/utility.py,21,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Utilities for using reinforcement learning algorithms.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport os\nimport re\n\nimport ruamel.yaml as yaml\nimport tensorflow as tf\n\nfrom agents import tools\n\n\ndef define_simulation_graph(batch_env, algo_cls, config):\n  """"""Define the algorithm and environment interaction.\n\n  Args:\n    batch_env: In-graph environments object.\n    algo_cls: Constructor of a batch algorithm.\n    config: Configuration object for the algorithm.\n\n  Returns:\n    Object providing graph elements via attributes.\n  """"""\n  # pylint: disable=unused-variable\n  step = tf.Variable(0, False, dtype=tf.int32, name=\'global_step\')\n  is_training = tf.placeholder(tf.bool, name=\'is_training\')\n  should_log = tf.placeholder(tf.bool, name=\'should_log\')\n  do_report = tf.placeholder(tf.bool, name=\'do_report\')\n  force_reset = tf.placeholder(tf.bool, name=\'force_reset\')\n  algo = algo_cls(batch_env, step, is_training, should_log, config)\n  done, score, summary = tools.simulate(\n      batch_env, algo, should_log, force_reset)\n  message = \'Graph contains {} trainable variables.\'\n  tf.logging.info(message.format(tools.count_weights()))\n  # pylint: enable=unused-variable\n  return tools.AttrDict(locals())\n\n\ndef define_batch_env(constructor, num_agents, env_processes):\n  """"""Create environments and apply all desired wrappers.\n\n  Args:\n    constructor: Constructor of an OpenAI gym environment.\n    num_agents: Number of environments to combine in the batch.\n    env_processes: Whether to step environment in external processes.\n\n  Returns:\n    In-graph environments object.\n  """"""\n  with tf.variable_scope(\'environments\'):\n    if env_processes:\n      envs = [\n          tools.wrappers.ExternalProcess(constructor)\n          for _ in range(num_agents)]\n    else:\n      envs = [constructor() for _ in range(num_agents)]\n    batch_env = tools.BatchEnv(envs, blocking=not env_processes)\n    batch_env = tools.InGraphBatchEnv(batch_env)\n  return batch_env\n\n\ndef define_saver(exclude=None):\n  """"""Create a saver for the variables we want to checkpoint.\n\n  Args:\n    exclude: List of regexes to match variable names to exclude.\n\n  Returns:\n    Saver object.\n  """"""\n  variables = []\n  exclude = exclude or []\n  exclude = [re.compile(regex) for regex in exclude]\n  for variable in tf.global_variables():\n    if any(regex.match(variable.name) for regex in exclude):\n      continue\n    variables.append(variable)\n  saver = tf.train.Saver(variables, keep_checkpoint_every_n_hours=5)\n  return saver\n\n\ndef initialize_variables(sess, saver, logdir, checkpoint=None, resume=None):\n  """"""Initialize or restore variables from a checkpoint if available.\n\n  Args:\n    sess: Session to initialize variables in.\n    saver: Saver to restore variables.\n    logdir: Directory to search for checkpoints.\n    checkpoint: Specify what checkpoint name to use; defaults to most recent.\n    resume: Whether to expect recovering a checkpoint or starting a new run.\n\n  Raises:\n    ValueError: If resume expected but no log directory specified.\n    RuntimeError: If no resume expected but a checkpoint was found.\n  """"""\n  sess.run(tf.group(\n      tf.local_variables_initializer(),\n      tf.global_variables_initializer()))\n  if resume and not (logdir or checkpoint):\n    raise ValueError(\'Need to specify logdir to resume a checkpoint.\')\n  if logdir:\n    state = tf.train.get_checkpoint_state(logdir)\n    if checkpoint:\n      checkpoint = os.path.join(logdir, checkpoint)\n    if not checkpoint and state and state.model_checkpoint_path:\n      checkpoint = state.model_checkpoint_path\n    if checkpoint and resume is False:\n      message = \'Found unexpected checkpoint when starting a new run.\'\n      raise RuntimeError(message)\n    if checkpoint:\n      saver.restore(sess, checkpoint)\n\n\ndef save_config(config, logdir=None):\n  """"""Save a new configuration by name.\n\n  If a logging directory is specified, is will be created and the configuration\n  will be stored there. Otherwise, a log message will be printed.\n\n  Args:\n    config: Configuration object.\n    logdir: Location for writing summaries and checkpoints if specified.\n\n  Returns:\n    Configuration object.\n  """"""\n  if logdir:\n    with config.unlocked:\n      config.logdir = logdir\n    message = \'Start a new run and write summaries and checkpoints to {}.\'\n    tf.logging.info(message.format(config.logdir))\n    tf.gfile.MakeDirs(config.logdir)\n    config_path = os.path.join(config.logdir, \'config.yaml\')\n    with tf.gfile.FastGFile(config_path, \'w\') as file_:\n      yaml.dump(config, file_, default_flow_style=False)\n  else:\n    message = (\n        \'Start a new run without storing summaries and checkpoints since no \'\n        \'logging directory was specified.\')\n    tf.logging.info(message)\n  return config\n\n\ndef load_config(logdir):\n  # pylint: disable=missing-raises-doc\n  """"""Load a configuration from the log directory.\n\n  Args:\n    logdir: The logging directory containing the configuration file.\n\n  Raises:\n    IOError: The logging directory does not contain a configuration file.\n\n  Returns:\n    Configuration object.\n  """"""\n  config_path = logdir and os.path.join(logdir, \'config.yaml\')\n  if not config_path or not tf.gfile.Exists(config_path):\n    message = (\n        \'Cannot resume an existing run since the logging directory does not \'\n        \'contain a configuration file.\')\n    raise IOError(message)\n  with tf.gfile.FastGFile(config_path, \'r\') as file_:\n    config = yaml.load(file_, Loader=yaml.Loader)\n  message = \'Resume run and write summaries and checkpoints to {}.\'\n  tf.logging.info(message.format(config.logdir))\n  return config\n\n\ndef set_up_logging():\n  """"""Configure the TensorFlow logger.""""""\n  tf.logging.set_verbosity(tf.logging.INFO)\n  logging.getLogger(\'tensorflow\').propagate = False\n'"
agents/scripts/visualize.py,11,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nr""""""Script to render videos of the Proximal Policy Gradient algorithm.\n\nCommand line:\n\n  python3 -m agents.scripts.visualize \\\n      --logdir=/path/to/logdir/<time>-<config> --outdir=/path/to/outdir/\n""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\n\nimport gym\nimport tensorflow as tf\n\nfrom agents import tools\nfrom agents.scripts import utility\n\n\ndef _create_environment(config, outdir):\n  """"""Constructor for an instance of the environment.\n\n  Args:\n    config: Object providing configurations via attributes.\n    outdir: Directory to store videos in.\n\n  Raises:\n    NotImplementedError: For action spaces other than Box and Discrete.\n\n  Returns:\n    Wrapped OpenAI Gym environment.\n  """"""\n  if isinstance(config.env, str):\n    env = gym.make(config.env)\n  else:\n    env = config.env()\n  # Ensure that the environment has the specification attribute set as expected\n  # by the monitor wrapper.\n  if not hasattr(env, \'spec\'):\n    setattr(env, \'spec\', getattr(env, \'spec\', None))\n  if config.max_length:\n    env = tools.wrappers.LimitDuration(env, config.max_length)\n  env = gym.wrappers.Monitor(\n      env, outdir, lambda unused_episode_number: True)\n  if isinstance(env.action_space, gym.spaces.Box):\n    env = tools.wrappers.RangeNormalize(env)\n    env = tools.wrappers.ClipAction(env)\n  elif isinstance(env.action_space, gym.spaces.Discrete):\n    env = tools.wrappers.RangeNormalize(env, action=False)\n  else:\n    message = ""Unsupported action space \'{}\'"".format(type(env.action_space))\n    raise NotImplementedError(message)\n  env = tools.wrappers.ConvertTo32Bit(env)\n  env = tools.wrappers.CacheSpaces(env)\n  return env\n\n\ndef _define_loop(graph, eval_steps):\n  """"""Create and configure an evaluation loop.\n\n  Args:\n    graph: Object providing graph elements via attributes.\n    eval_steps: Number of evaluation steps per epoch.\n\n  Returns:\n    Loop object.\n  """"""\n  loop = tools.Loop(\n      None, graph.step, graph.should_log, graph.do_report, graph.force_reset)\n  loop.add_phase(\n      \'eval\', graph.done, graph.score, graph.summary, eval_steps,\n      report_every=eval_steps,\n      log_every=None,\n      checkpoint_every=None,\n      feed={graph.is_training: False})\n  return loop\n\n\ndef visualize(\n    logdir, outdir, num_agents, num_episodes, checkpoint=None,\n    env_processes=True):\n  """"""Recover checkpoint and render videos from it.\n\n  Args:\n    logdir: Logging directory of the trained algorithm.\n    outdir: Directory to store rendered videos in.\n    num_agents: Number of environments to simulate in parallel.\n    num_episodes: Total number of episodes to simulate.\n    checkpoint: Checkpoint name to load; defaults to most recent.\n    env_processes: Whether to step environments in separate processes.\n  """"""\n  config = utility.load_config(logdir)\n  with tf.device(\'/cpu:0\'):\n    batch_env = utility.define_batch_env(\n        lambda: _create_environment(config, outdir),\n        num_agents, env_processes)\n    graph = utility.define_simulation_graph(\n        batch_env, config.algorithm, config)\n    total_steps = num_episodes * config.max_length\n    loop = _define_loop(graph, total_steps)\n  saver = utility.define_saver(\n      exclude=(r\'.*_temporary.*\', r\'global_step\'))\n  sess_config = tf.ConfigProto(allow_soft_placement=True)\n  sess_config.gpu_options.allow_growth = True\n  with tf.Session(config=sess_config) as sess:\n    utility.initialize_variables(\n        sess, saver, config.logdir, checkpoint, resume=True)\n    for unused_score in loop.run(sess, saver, total_steps):\n      pass\n  batch_env.close()\n\n\ndef main(_):\n  """"""Load a trained algorithm and render videos.""""""\n  utility.set_up_logging()\n  if not FLAGS.logdir or not FLAGS.outdir:\n    raise KeyError(\'You must specify logging and outdirs directories.\')\n  FLAGS.logdir = os.path.expanduser(FLAGS.logdir)\n  FLAGS.outdir = os.path.expanduser(FLAGS.outdir)\n  visualize(\n      FLAGS.logdir, FLAGS.outdir, FLAGS.num_agents, FLAGS.num_episodes,\n      FLAGS.checkpoint, FLAGS.env_processes)\n\n\nif __name__ == \'__main__\':\n  FLAGS = tf.app.flags.FLAGS\n  tf.app.flags.DEFINE_string(\n      \'logdir\', None,\n      \'Directory to the checkpoint of a training run.\')\n  tf.app.flags.DEFINE_string(\n      \'outdir\', None,\n      \'Local directory for storing the monitoring outdir.\')\n  tf.app.flags.DEFINE_string(\n      \'checkpoint\', None,\n      \'Checkpoint name to load; defaults to most recent.\')\n  tf.app.flags.DEFINE_integer(\n      \'num_agents\', 1,\n      \'How many environments to step in parallel.\')\n  tf.app.flags.DEFINE_integer(\n      \'num_episodes\', 5,\n      \'Minimum number of episodes to render.\')\n  tf.app.flags.DEFINE_boolean(\n      \'env_processes\', True,\n      \'Step environments in separate processes to circumvent the GIL.\')\n  tf.app.run()\n'"
agents/tools/__init__.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tools for reinforcement learning.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom . import nested\nfrom . import wrappers\nfrom .attr_dict import AttrDict\nfrom .batch_env import BatchEnv\nfrom .count_weights import count_weights\nfrom .in_graph_batch_env import InGraphBatchEnv\nfrom .in_graph_env import InGraphEnv\nfrom .loop import Loop\nfrom .mock_algorithm import MockAlgorithm\nfrom .mock_environment import MockEnvironment\nfrom .simulate import simulate\nfrom .streaming_mean import StreamingMean\n'"
agents/tools/attr_dict.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Wrap a dictionary to access keys as attributes.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport contextlib\n\n\nclass AttrDict(dict):\n  """"""Wrap a dictionary to access keys as attributes.""""""\n\n  def __init__(self, *args, **kwargs):\n    super(AttrDict, self).__init__(*args, **kwargs)\n    super(AttrDict, self).__setattr__(\'_mutable\', False)\n\n  def __getattr__(self, key):\n    # Do not provide None for unimplemented magic attributes.\n    if key.startswith(\'__\'):\n      raise AttributeError\n    return self.get(key, None)\n\n  def __setattr__(self, key, value):\n    if not self._mutable:\n      message = ""Cannot set attribute \'{}\'."".format(key)\n      message += "" Use \'with obj.unlocked:\' scope to set attributes.""\n      raise RuntimeError(message)\n    if key.startswith(\'__\'):\n      raise AttributeError(""Cannot set magic attribute \'{}\'"".format(key))\n    self[key] = value\n\n  @property\n  @contextlib.contextmanager\n  def unlocked(self):\n    super(AttrDict, self).__setattr__(\'_mutable\', True)\n    yield\n    super(AttrDict, self).__setattr__(\'_mutable\', False)\n\n  def copy(self):\n    return type(self)(super(AttrDict, self).copy())\n'"
agents/tools/attr_dict_test.py,2,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests for the attribute dictionary.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom agents.tools import attr_dict\n\n\nclass AttrDictTest(tf.test.TestCase):\n\n  def test_construct_from_dict(self):\n    initial = dict(foo=13, bar=42)\n    obj = attr_dict.AttrDict(initial)\n    self.assertEqual(13, obj.foo)\n    self.assertEqual(42, obj.bar)\n\n  def test_construct_from_kwargs(self):\n    obj = attr_dict.AttrDict(foo=13, bar=42)\n    self.assertEqual(13, obj.foo)\n    self.assertEqual(42, obj.bar)\n\n  def test_has_attribute(self):\n    obj = attr_dict.AttrDict(foo=13)\n    self.assertTrue(\'foo\' in obj)\n    self.assertFalse(\'bar\' in obj)\n\n  def test_access_default(self):\n    obj = attr_dict.AttrDict()\n    self.assertEqual(None, obj.foo)\n\n  def test_access_magic(self):\n    obj = attr_dict.AttrDict()\n    with self.assertRaises(AttributeError):\n      obj.__getstate__  # pylint: disable=pointless-statement\n\n  def test_immutable_create(self):\n    obj = attr_dict.AttrDict()\n    with self.assertRaises(RuntimeError):\n      obj.foo = 42\n\n  def test_immutable_modify(self):\n    obj = attr_dict.AttrDict(foo=13)\n    with self.assertRaises(RuntimeError):\n      obj.foo = 42\n\n  def test_immutable_unlocked(self):\n    obj = attr_dict.AttrDict()\n    with obj.unlocked:\n      obj.foo = 42\n    self.assertEqual(42, obj.foo)\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
agents/tools/batch_env.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Combine multiple environments to step them in batch.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\n\n\nclass BatchEnv(object):\n  """"""Combine multiple environments to step them in batch.""""""\n\n  def __init__(self, envs, blocking):\n    """"""Combine multiple environments to step them in batch.\n\n    To step environments in parallel, environments must support a\n    `blocking=False` argument to their step and reset functions that makes them\n    return callables instead to receive the result at a later time.\n\n    Args:\n      envs: List of environments.\n      blocking: Step environments after another rather than in parallel.\n\n    Raises:\n      ValueError: Environments have different observation or action spaces.\n    """"""\n    self._envs = envs\n    self._blocking = blocking\n    observ_space = self._envs[0].observation_space\n    if not all(env.observation_space == observ_space for env in self._envs):\n      raise ValueError(\'All environments must use the same observation space.\')\n    action_space = self._envs[0].action_space\n    if not all(env.action_space == action_space for env in self._envs):\n      raise ValueError(\'All environments must use the same observation space.\')\n\n  def __len__(self):\n    """"""Number of combined environments.""""""\n    return len(self._envs)\n\n  def __getitem__(self, index):\n    """"""Access an underlying environment by index.""""""\n    return self._envs[index]\n\n  def __getattr__(self, name):\n    """"""Forward unimplemented attributes to one of the original environments.\n\n    Args:\n      name: Attribute that was accessed.\n\n    Returns:\n      Value behind the attribute name one of the wrapped environments.\n    """"""\n    return getattr(self._envs[0], name)\n\n  def step(self, actions):\n    """"""Forward a batch of actions to the wrapped environments.\n\n    Args:\n      actions: Batched action to apply to the environment.\n\n    Raises:\n      ValueError: Invalid actions.\n\n    Returns:\n      Batch of observations, rewards, and done flags.\n    """"""\n    for index, (env, action) in enumerate(zip(self._envs, actions)):\n      if not env.action_space.contains(action):\n        message = \'Invalid action at index {}: {}\'\n        raise ValueError(message.format(index, action))\n    if self._blocking:\n      transitions = [\n          env.step(action)\n          for env, action in zip(self._envs, actions)]\n    else:\n      transitions = [\n          env.step(action, blocking=False)\n          for env, action in zip(self._envs, actions)]\n      transitions = [transition() for transition in transitions]\n    observs, rewards, dones, infos = zip(*transitions)\n    observ = np.stack(observs)\n    reward = np.stack(rewards)\n    done = np.stack(dones)\n    info = tuple(infos)\n    return observ, reward, done, info\n\n  def reset(self, indices=None):\n    """"""Reset the environment and convert the resulting observation.\n\n    Args:\n      indices: The batch indices of environments to reset; defaults to all.\n\n    Returns:\n      Batch of observations.\n    """"""\n    if indices is None:\n      indices = np.arange(len(self._envs))\n    if self._blocking:\n      observs = [self._envs[index].reset() for index in indices]\n    else:\n      observs = [self._envs[index].reset(blocking=False) for index in indices]\n      observs = [observ() for observ in observs]\n    observ = np.stack(observs)\n    return observ\n\n  def close(self):\n    """"""Send close messages to the external process and join them.""""""\n    for env in self._envs:\n      if hasattr(env, \'close\'):\n        env.close()\n'"
agents/tools/count_weights.py,2,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Count learnable parameters.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\n\nimport numpy as np\nimport tensorflow as tf\n\n\ndef count_weights(scope=None, exclude=None, graph=None):\n  """"""Count learnable parameters.\n\n  Args:\n    scope: Restrict the count to a variable scope.\n    exclude: Regex to match variable names to exclude.\n    graph: Operate on a graph other than the current default graph.\n\n  Returns:\n    Number of learnable parameters as integer.\n  """"""\n  if scope:\n    scope = scope if scope.endswith(\'/\') else scope + \'/\'\n  graph = graph or tf.get_default_graph()\n  vars_ = graph.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES)\n  if scope:\n    vars_ = [var for var in vars_ if var.name.startswith(scope)]\n  if exclude:\n    exclude = re.compile(exclude)\n    vars_ = [var for var in vars_ if not exclude.match(var.name)]\n  shapes = [var.get_shape().as_list() for var in vars_]\n  return int(sum(np.prod(shape) for shape in shapes))\n'"
agents/tools/count_weights_test.py,40,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests for the weight counting utility.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom agents.tools import count_weights\n\n\nclass CountWeightsTest(tf.test.TestCase):\n\n  def test_count_trainable(self):\n    tf.Variable(tf.zeros((5, 3)), trainable=True)\n    tf.Variable(tf.zeros((1, 1)), trainable=True)\n    tf.Variable(tf.zeros((5,)), trainable=True)\n    self.assertEqual(15 + 1 + 5, count_weights())\n\n  def test_ignore_non_trainable(self):\n    tf.Variable(tf.zeros((5, 3)), trainable=False)\n    tf.Variable(tf.zeros((1, 1)), trainable=False)\n    tf.Variable(tf.zeros((5,)), trainable=False)\n    self.assertEqual(0, count_weights())\n\n  def test_trainable_and_non_trainable(self):\n    tf.Variable(tf.zeros((5, 3)), trainable=True)\n    tf.Variable(tf.zeros((8, 2)), trainable=False)\n    tf.Variable(tf.zeros((1, 1)), trainable=True)\n    tf.Variable(tf.zeros((5,)), trainable=True)\n    tf.Variable(tf.zeros((3, 1)), trainable=False)\n    self.assertEqual(15 + 1 + 5, count_weights())\n\n  def test_include_scopes(self):\n    tf.Variable(tf.zeros((3, 2)), trainable=True)\n    with tf.variable_scope(\'foo\'):\n      tf.Variable(tf.zeros((5, 2)), trainable=True)\n    self.assertEqual(6 + 10, count_weights())\n\n  def test_restrict_scope(self):\n    tf.Variable(tf.zeros((3, 2)), trainable=True)\n    with tf.variable_scope(\'foo\'):\n      tf.Variable(tf.zeros((5, 2)), trainable=True)\n      with tf.variable_scope(\'bar\'):\n        tf.Variable(tf.zeros((1, 2)), trainable=True)\n    self.assertEqual(10 + 2, count_weights(\'foo\'))\n\n  def test_restrict_nested_scope(self):\n    tf.Variable(tf.zeros((3, 2)), trainable=True)\n    with tf.variable_scope(\'foo\'):\n      tf.Variable(tf.zeros((5, 2)), trainable=True)\n      with tf.variable_scope(\'bar\'):\n        tf.Variable(tf.zeros((1, 2)), trainable=True)\n    self.assertEqual(2, count_weights(\'foo/bar\'))\n\n  def test_restrict_invalid_scope(self):\n    tf.Variable(tf.zeros((3, 2)), trainable=True)\n    with tf.variable_scope(\'foo\'):\n      tf.Variable(tf.zeros((5, 2)), trainable=True)\n      with tf.variable_scope(\'bar\'):\n        tf.Variable(tf.zeros((1, 2)), trainable=True)\n    self.assertEqual(0, count_weights(\'bar\'))\n\n  def test_exclude_by_regex(self):\n    tf.Variable(tf.zeros((3, 2)), trainable=True)\n    with tf.variable_scope(\'foo\'):\n      tf.Variable(tf.zeros((5, 2)), trainable=True)\n      with tf.variable_scope(\'bar\'):\n        tf.Variable(tf.zeros((1, 2)), trainable=True)\n    self.assertEqual(0, count_weights(exclude=r\'.*\'))\n    self.assertEqual(6, count_weights(exclude=r\'(^|/)foo/.*\'))\n    self.assertEqual(16, count_weights(exclude=r\'.*/bar/.*\'))\n\n  def test_non_default_graph(self):\n    graph = tf.Graph()\n    with graph.as_default():\n      tf.Variable(tf.zeros((5, 3)), trainable=True)\n      tf.Variable(tf.zeros((8, 2)), trainable=False)\n    self.assertNotEqual(graph, tf.get_default_graph)\n    self.assertEqual(15, count_weights(graph=graph))\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
agents/tools/in_graph_batch_env.py,30,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Batch of environments inside the TensorFlow graph.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport gym\nimport tensorflow as tf\n\n\nclass InGraphBatchEnv(object):\n  """"""Batch of environments inside the TensorFlow graph.\n\n  The batch of environments will be stepped and reset inside of the graph using\n  a tf.py_func(). The current batch of observations, actions, rewards, and done\n  flags are held in according variables.\n  """"""\n\n  def __init__(self, batch_env):\n    """"""Batch of environments inside the TensorFlow graph.\n\n    Args:\n      batch_env: Batch environment.\n    """"""\n    self._batch_env = batch_env\n    batch_dims = (len(self._batch_env),)\n    observ_shape = self._parse_shape(self._batch_env.observation_space)\n    observ_dtype = self._parse_dtype(self._batch_env.observation_space)\n    action_shape = self._parse_shape(self._batch_env.action_space)\n    action_dtype = self._parse_dtype(self._batch_env.action_space)\n    with tf.variable_scope(\'env_temporary\'):\n      self._observ = tf.Variable(\n          lambda: tf.zeros(batch_dims + observ_shape, observ_dtype),\n          name=\'observ\', trainable=False)\n      self._action = tf.Variable(\n          lambda: tf.zeros(batch_dims + action_shape, action_dtype),\n          name=\'action\', trainable=False)\n      self._reward = tf.Variable(\n          lambda: tf.zeros(batch_dims, tf.float32),\n          name=\'reward\', trainable=False)\n      self._done = tf.Variable(\n          lambda: tf.cast(tf.ones(batch_dims), tf.bool),\n          name=\'done\', trainable=False)\n\n  def __getattr__(self, name):\n    """"""Forward unimplemented attributes to one of the original environments.\n\n    Args:\n      name: Attribute that was accessed.\n\n    Returns:\n      Value behind the attribute name in one of the original environments.\n    """"""\n    return getattr(self._batch_env, name)\n\n  def __len__(self):\n    """"""Number of combined environments.""""""\n    return len(self._batch_env)\n\n  def __getitem__(self, index):\n    """"""Access an underlying environment by index.""""""\n    return self._batch_env[index]\n\n  def simulate(self, action):\n    """"""Step the batch of environments.\n\n    The results of the step can be accessed from the variables defined below.\n\n    Args:\n      action: Tensor holding the batch of actions to apply.\n\n    Returns:\n      Operation.\n    """"""\n    with tf.name_scope(\'environment/simulate\'):\n      if action.dtype in (tf.float16, tf.float32, tf.float64):\n        action = tf.check_numerics(action, \'action\')\n      observ_dtype = self._parse_dtype(self._batch_env.observation_space)\n      observ, reward, done = tf.py_func(\n          lambda a: self._batch_env.step(a)[:3], [action],\n          [observ_dtype, tf.float32, tf.bool], name=\'step\')\n      observ = tf.check_numerics(observ, \'observ\')\n      reward = tf.check_numerics(reward, \'reward\')\n      return tf.group(\n          self._observ.assign(observ),\n          self._action.assign(action),\n          self._reward.assign(reward),\n          self._done.assign(done))\n\n  def reset(self, indices=None):\n    """"""Reset the batch of environments.\n\n    Args:\n      indices: The batch indices of the environments to reset; defaults to all.\n\n    Returns:\n      Batch tensor of the new observations.\n    """"""\n    if indices is None:\n      indices = tf.range(len(self._batch_env))\n    observ_dtype = self._parse_dtype(self._batch_env.observation_space)\n    observ = tf.py_func(\n        self._batch_env.reset, [indices], observ_dtype, name=\'reset\')\n    observ = tf.check_numerics(observ, \'observ\')\n    reward = tf.zeros_like(indices, tf.float32)\n    done = tf.zeros_like(indices, tf.bool)\n    with tf.control_dependencies([\n        tf.scatter_update(self._observ, indices, observ),\n        tf.scatter_update(self._reward, indices, reward),\n        tf.scatter_update(self._done, indices, done)]):\n      return tf.identity(observ)\n\n  @property\n  def observ(self):\n    """"""Access the variable holding the current observation.""""""\n    return self._observ\n\n  @property\n  def action(self):\n    """"""Access the variable holding the last received action.""""""\n    return self._action\n\n  @property\n  def reward(self):\n    """"""Access the variable holding the current reward.""""""\n    return self._reward\n\n  @property\n  def done(self):\n    """"""Access the variable indicating whether the episode is done.""""""\n    return self._done\n\n  def close(self):\n    """"""Send close messages to the external process and join them.""""""\n    self._batch_env.close()\n\n  def _parse_shape(self, space):\n    """"""Get a tensor shape from a OpenAI Gym space.\n\n    Args:\n      space: Gym space.\n\n    Raises:\n      NotImplementedError: For spaces other than Box and Discrete.\n\n    Returns:\n      Shape tuple.\n    """"""\n    if isinstance(space, gym.spaces.Discrete):\n      return ()\n    if isinstance(space, gym.spaces.Box):\n      return space.shape\n    raise NotImplementedError()\n\n  def _parse_dtype(self, space):\n    """"""Get a tensor dtype from a OpenAI Gym space.\n\n    Args:\n      space: Gym space.\n\n    Raises:\n      NotImplementedError: For spaces other than Box and Discrete.\n\n    Returns:\n      TensorFlow data type.\n    """"""\n    if isinstance(space, gym.spaces.Discrete):\n      return tf.int32\n    if isinstance(space, gym.spaces.Box):\n      return tf.float32\n    raise NotImplementedError()\n'"
agents/tools/in_graph_env.py,26,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Put an OpenAI Gym environment into the TensorFlow graph.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport gym\nimport tensorflow as tf\n\n\nclass InGraphEnv(object):\n  """"""Put an OpenAI Gym environment into the TensorFlow graph.\n\n  The environment will be stepped and reset inside of the graph using\n  tf.py_func(). The current observation, action, reward, and done flag are held\n  in according variables.\n  """"""\n\n  def __init__(self, env):\n    """"""Put an OpenAI Gym environment into the TensorFlow graph.\n\n    Args:\n      env: OpenAI Gym environment.\n    """"""\n    self._env = env\n    observ_shape = self._parse_shape(self._env.observation_space)\n    observ_dtype = self._parse_dtype(self._env.observation_space)\n    action_shape = self._parse_shape(self._env.action_space)\n    action_dtype = self._parse_dtype(self._env.action_space)\n    with tf.name_scope(\'environment\'):\n      self._observ = tf.Variable(\n          tf.zeros(observ_shape, observ_dtype), name=\'observ\', trainable=False)\n      self._action = tf.Variable(\n          tf.zeros(action_shape, action_dtype), name=\'action\', trainable=False)\n      self._reward = tf.Variable(\n          0.0, dtype=tf.float32, name=\'reward\', trainable=False)\n      self._done = tf.Variable(\n          True, dtype=tf.bool, name=\'done\', trainable=False)\n      self._step = tf.Variable(\n          0, dtype=tf.int32, name=\'step\', trainable=False)\n\n  def __getattr__(self, name):\n    """"""Forward unimplemented attributes to the original environment.\n\n    Args:\n      name: Attribute that was accessed.\n\n    Returns:\n      Value behind the attribute name in the wrapped environment.\n    """"""\n    return getattr(self._env, name)\n\n  def simulate(self, action):\n    """"""Step the environment.\n\n    The result of the step can be accessed from the variables defined below.\n\n    Args:\n      action: Tensor holding the action to apply.\n\n    Returns:\n      Operation.\n    """"""\n    with tf.name_scope(\'environment/simulate\'):\n      if action.dtype in (tf.float16, tf.float32, tf.float64):\n        action = tf.check_numerics(action, \'action\')\n      observ_dtype = self._parse_dtype(self._env.observation_space)\n      observ, reward, done = tf.py_func(\n          lambda a: self._env.step(a)[:3], [action],\n          [observ_dtype, tf.float32, tf.bool], name=\'step\')\n      observ = tf.check_numerics(observ, \'observ\')\n      reward = tf.check_numerics(reward, \'reward\')\n      return tf.group(\n          self._observ.assign(observ),\n          self._action.assign(action),\n          self._reward.assign(reward),\n          self._done.assign(done),\n          self._step.assign_add(1))\n\n  def reset(self):\n    """"""Reset the environment.\n\n    Returns:\n      Tensor of the current observation.\n    """"""\n    observ_dtype = self._parse_dtype(self._env.observation_space)\n    observ = tf.py_func(self._env.reset, [], observ_dtype, name=\'reset\')\n    observ = tf.check_numerics(observ, \'observ\')\n    with tf.control_dependencies([\n        self._observ.assign(observ),\n        self._reward.assign(0),\n        self._done.assign(False)]):\n      return tf.identity(observ)\n\n  @property\n  def observ(self):\n    """"""Access the variable holding the current observation.""""""\n    return self._observ\n\n  @property\n  def action(self):\n    """"""Access the variable holding the last received action.""""""\n    return self._action\n\n  @property\n  def reward(self):\n    """"""Access the variable holding the current reward.""""""\n    return self._reward\n\n  @property\n  def done(self):\n    """"""Access the variable indicating whether the episode is done.""""""\n    return self._done\n\n  @property\n  def step(self):\n    """"""Access the variable containing total steps of this environment.""""""\n    return self._step\n\n  def _parse_shape(self, space):\n    """"""Get a tensor shape from a OpenAI Gym space.\n\n    Args:\n      space: Gym space.\n\n    Raises:\n      NotImplementedError: For spaces other than Box and Discrete.\n\n    Returns:\n      Shape tuple.\n    """"""\n    if isinstance(space, gym.spaces.Discrete):\n      return ()\n    if isinstance(space, gym.spaces.Box):\n      return space.shape\n    raise NotImplementedError()\n\n  def _parse_dtype(self, space):\n    """"""Get a tensor dtype from a OpenAI Gym space.\n\n    Args:\n      space: Gym space.\n\n    Raises:\n      NotImplementedError: For spaces other than Box and Discrete.\n\n    Returns:\n      TensorFlow data type.\n    """"""\n    if isinstance(space, gym.spaces.Discrete):\n      return tf.int32\n    if isinstance(space, gym.spaces.Box):\n      return tf.float32\n    raise NotImplementedError()\n'"
agents/tools/loop.py,21,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Execute operations in a loop and coordinate logging and checkpoints.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\n\nimport tensorflow as tf\n\nfrom agents.tools import streaming_mean\n\n\n_Phase = collections.namedtuple(\n    \'Phase\',\n    \'name, writer, op, batch, steps, feed, report_every, log_every,\'\n    \'checkpoint_every\')\n\n\nclass Loop(object):\n  """"""Execute operations in a loop and coordinate logging and checkpoints.\n\n  Supports multiple phases, that define their own operations to run, and\n  intervals for reporting scores, logging summaries, and storing checkpoints.\n  All class state is stored in-graph to properly recover from checkpoints.\n  """"""\n\n  def __init__(self, logdir, step=None, log=None, report=None, reset=None):\n    """"""Execute operations in a loop and coordinate logging and checkpoints.\n\n    The step, log, report, and report arguments will get created if not\n    provided. Reset is used to indicate switching to a new phase, so that the\n    model can start a new computation in case its computation is split over\n    multiple training steps.\n\n    Args:\n      logdir: Will contain checkpoints and summaries for each phase.\n      step: Variable of the global step (optional).\n      log: Tensor indicating to the model to compute summary tensors.\n      report: Tensor indicating to the loop to report the current mean score.\n      reset: Tensor indicating to the model to start a new computation.\n    """"""\n    self._logdir = logdir\n    self._step = (\n        tf.Variable(0, False, name=\'global_step\') if step is None else step)\n    self._log = tf.placeholder(tf.bool) if log is None else log\n    self._report = tf.placeholder(tf.bool) if report is None else report\n    self._reset = tf.placeholder(tf.bool) if reset is None else reset\n    self._phases = []\n\n  def add_phase(\n      self, name, done, score, summary, steps,\n      report_every=None, log_every=None, checkpoint_every=None, feed=None):\n    """"""Add a phase to the loop protocol.\n\n    If the model breaks long computation into multiple steps, the done tensor\n    indicates whether the current score should be added to the mean counter.\n    For example, in reinforcement learning we only have a valid score at the\n    end of the episode.\n\n    Score and done tensors can either be scalars or vectors, to support\n    single and batched computations.\n\n    Args:\n      name: Name for the phase, used for the summary writer.\n      done: Tensor indicating whether current score can be used.\n      score: Tensor holding the current, possibly intermediate, score.\n      summary: Tensor holding summary string to write if not an empty string.\n      steps: Duration of the phase in steps.\n      report_every: Yield mean score every this number of steps.\n      log_every: Request summaries via `log` tensor every this number of steps.\n      checkpoint_every: Write checkpoint every this number of steps.\n      feed: Additional feed dictionary for the session run call.\n\n    Raises:\n      ValueError: Unknown rank for done or score tensors.\n    """"""\n    done = tf.convert_to_tensor(done, tf.bool)\n    score = tf.convert_to_tensor(score, tf.float32)\n    summary = tf.convert_to_tensor(summary, tf.string)\n    feed = feed or {}\n    if done.shape.ndims is None or score.shape.ndims is None:\n      raise ValueError(""Rank of \'done\' and \'score\' tensors must be known."")\n    writer = self._logdir and tf.summary.FileWriter(\n        os.path.join(self._logdir, name), tf.get_default_graph(),\n        flush_secs=60)\n    op = self._define_step(done, score, summary)\n    batch = 1 if score.shape.ndims == 0 else score.shape[0].value\n    self._phases.append(_Phase(\n        name, writer, op, batch, int(steps), feed, report_every,\n        log_every, checkpoint_every))\n\n  def run(self, sess, saver, max_step=None):\n    """"""Run the loop schedule for a specified number of steps.\n\n    Call the operation of the current phase until the global step reaches the\n    specified maximum step. Phases are repeated over and over in the order they\n    were added.\n\n    Args:\n      sess: Session to use to run the phase operation.\n      saver: Saver used for checkpointing.\n      max_step: Run the operations until the step reaches this limit.\n\n    Yields:\n      Reported mean scores.\n    """"""\n    global_step = sess.run(self._step)\n    steps_made = 1\n    while True:\n      if max_step and global_step >= max_step:\n        break\n      phase, epoch, steps_in = self._find_current_phase(global_step)\n      phase_step = epoch * phase.steps + steps_in\n      if steps_in % phase.steps < steps_made:\n        message = \'\\n\' + (\'-\' * 50) + \'\\n\'\n        message += \'Phase {} (phase step {}, global step {}).\'\n        tf.logging.info(message.format(phase.name, phase_step, global_step))\n      # Populate book keeping tensors.\n      phase.feed[self._reset] = (steps_in < steps_made)\n      phase.feed[self._log] = (\n          phase.writer and\n          self._is_every_steps(phase_step, phase.batch, phase.log_every))\n      phase.feed[self._report] = (\n          self._is_every_steps(phase_step, phase.batch, phase.report_every))\n      summary, mean_score, global_step, steps_made = sess.run(\n          phase.op, phase.feed)\n      if self._is_every_steps(phase_step, phase.batch, phase.checkpoint_every):\n        self._store_checkpoint(sess, saver, global_step)\n      if self._is_every_steps(phase_step, phase.batch, phase.report_every):\n        yield mean_score\n      if summary and phase.writer:\n        # We want smaller phases to catch up at the beginnig of each epoch so\n        # that their graphs are aligned.\n        longest_phase = max(phase.steps for phase in self._phases)\n        summary_step = epoch * longest_phase + steps_in\n        phase.writer.add_summary(summary, summary_step)\n\n  def _is_every_steps(self, phase_step, batch, every):\n    """"""Determine whether a periodic event should happen at this step.\n\n    Args:\n      phase_step: The incrementing step.\n      batch: The number of steps progressed at once.\n      every: The interval of the period.\n\n    Returns:\n      Boolean of whether the event should happen.\n    """"""\n    if not every:\n      return False\n    covered_steps = range(phase_step, phase_step + batch)\n    return any((step + 1) % every == 0 for step in covered_steps)\n\n  def _find_current_phase(self, global_step):\n    """"""Determine the current phase based on the global step.\n\n    This ensures continuing the correct phase after restoring checkoints.\n\n    Args:\n      global_step: The global number of steps performed across all phases.\n\n    Returns:\n      Tuple of phase object, epoch number, and phase steps within the epoch.\n    """"""\n    epoch_size = sum(phase.steps for phase in self._phases)\n    epoch = int(global_step // epoch_size)\n    steps_in = global_step % epoch_size\n    for phase in self._phases:\n      if steps_in < phase.steps:\n        return phase, epoch, steps_in\n      steps_in -= phase.steps\n\n  def _define_step(self, done, score, summary):\n    """"""Combine operations of a phase.\n\n    Keeps track of the mean score and when to report it.\n\n    Args:\n      done: Tensor indicating whether current score can be used.\n      score: Tensor holding the current, possibly intermediate, score.\n      summary: Tensor holding summary string to write if not an empty string.\n\n    Returns:\n      Tuple of summary tensor, mean score, and new global step. The mean score\n      is zero for non reporting steps.\n    """"""\n    if done.shape.ndims == 0:\n      done = done[None]\n    if score.shape.ndims == 0:\n      score = score[None]\n    score_mean = streaming_mean.StreamingMean((), tf.float32)\n    with tf.control_dependencies([done, score, summary]):\n      done_score = tf.gather(score, tf.where(done)[:, 0])\n      submit_score = tf.cond(\n          tf.reduce_any(done), lambda: score_mean.submit(done_score), tf.no_op)\n    with tf.control_dependencies([submit_score]):\n      mean_score = tf.cond(self._report, score_mean.clear, float)\n      steps_made = tf.shape(score)[0]\n      next_step = self._step.assign_add(steps_made)\n    with tf.control_dependencies([mean_score, next_step]):\n      return tf.identity(summary), mean_score, next_step, steps_made\n\n  def _store_checkpoint(self, sess, saver, global_step):\n    """"""Store a checkpoint if a log directory was provided to the constructor.\n\n    The directory will be created if needed.\n\n    Args:\n      sess: Session containing variables to store.\n      saver: Saver used for checkpointing.\n      global_step: Step number of the checkpoint name.\n    """"""\n    if not self._logdir or not saver:\n      return\n    tf.gfile.MakeDirs(self._logdir)\n    filename = os.path.join(self._logdir, \'model.ckpt\')\n    saver.save(sess, filename, global_step)\n'"
agents/tools/loop_test.py,15,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests for the training loop.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom agents import tools\n\n\nclass LoopTest(tf.test.TestCase):\n\n  def test_report_every_step(self):\n    step = tf.Variable(0, False, dtype=tf.int32, name=\'step\')\n    loop = tools.Loop(None, step)\n    loop.add_phase(\n        \'phase_1\', done=True, score=0, summary=\'\', steps=1, report_every=3)\n    # Step:   0 1 2 3 4 5 6 7 8\n    # Report:     x     x     x\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      scores = loop.run(sess, saver=None, max_step=9)\n      next(scores)\n      self.assertEqual(3, sess.run(step))\n      next(scores)\n      self.assertEqual(6, sess.run(step))\n      next(scores)\n      self.assertEqual(9, sess.run(step))\n\n  def test_phases_feed(self):\n    score = tf.placeholder(tf.float32, [])\n    loop = tools.Loop(None)\n    loop.add_phase(\n        \'phase_1\', done=True, score=score, summary=\'\', steps=1, report_every=1,\n        log_every=None, checkpoint_every=None, feed={score: 1})\n    loop.add_phase(\n        \'phase_2\', done=True, score=score, summary=\'\', steps=3, report_every=1,\n        log_every=None, checkpoint_every=None, feed={score: 2})\n    loop.add_phase(\n        \'phase_3\', done=True, score=score, summary=\'\', steps=2, report_every=1,\n        log_every=None, checkpoint_every=None, feed={score: 3})\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      scores = list(loop.run(sess, saver=None, max_step=15))\n    self.assertAllEqual([1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 3, 3, 1, 2, 2], scores)\n\n  def test_average_score_over_phases(self):\n    loop = tools.Loop(None)\n    loop.add_phase(\n        \'phase_1\', done=True, score=1, summary=\'\', steps=1, report_every=2)\n    loop.add_phase(\n        \'phase_2\', done=True, score=2, summary=\'\', steps=2, report_every=5)\n    # Score:    1 2 2 1 2 2 1 2 2 1 2 2 1 2 2 1 2\n    # Report 1:       x           x           x\n    # Report 2:               x             x\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      scores = list(loop.run(sess, saver=None, max_step=17))\n    self.assertAllEqual([1, 2, 1, 2, 1], scores)\n\n  def test_not_done(self):\n    step = tf.Variable(0, False, dtype=tf.int32, name=\'step\')\n    done = tf.equal((step + 1) % 2, 0)\n    score = tf.cast(step, tf.float32)\n    loop = tools.Loop(None, step)\n    loop.add_phase(\n        \'phase_1\', done, score, summary=\'\', steps=1, report_every=3)\n    # Score:  0 1 2 3 4 5 6 7 8\n    # Done:     x   x   x   x\n    # Report:     x     x     x\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      scores = list(loop.run(sess, saver=None, max_step=9))\n    self.assertAllEqual([1, 4, 7], scores)\n\n  def test_not_done_batch(self):\n    step = tf.Variable(0, False, dtype=tf.int32, name=\'step\')\n    done = tf.equal([step % 3, step % 4], 0)\n    score = tf.cast([step, step ** 2], tf.float32)\n    loop = tools.Loop(None, step)\n    loop.add_phase(\n        \'phase_1\', done, score, summary=\'\', steps=1, report_every=8)\n    # Step:    0  2  4  6\n    # Score 1: 0  2  4  6\n    # Done 1:  x        x\n    # Score 2: 0  4 16 32\n    # Done 2:  x     x\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      scores = list(loop.run(sess, saver=None, max_step=8))\n      self.assertEqual(8, sess.run(step))\n    self.assertAllEqual([(0 + 0 + 16 + 6) / 4], scores)\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
agents/tools/mock_algorithm.py,6,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Mock algorithm for testing reinforcement learning code.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\n\nclass MockAlgorithm(object):\n  """"""Produce random actions and empty summaries.""""""\n\n  def __init__(self, envs):\n    """"""Produce random actions and empty summaries.\n\n    Args:\n      envs: List of in-graph environments.\n    """"""\n    self._envs = envs\n\n  def begin_episode(self, unused_agent_indices):\n    return tf.constant(\'\')\n\n  def perform(self, agent_indices, unused_observ):\n    shape = (tf.shape(agent_indices)[0],) + self._envs[0].action_space.shape\n    low = self._envs[0].action_space.low\n    high = self._envs[0].action_space.high\n    action = tf.random_uniform(shape) * (high - low) + low\n    return action, tf.constant(\'\')\n\n  def experience(self, unused_agent_indices, *unused_transition):\n    return tf.constant(\'\')\n\n  def end_episode(self, unused_agent_indices):\n    return tf.constant(\'\')\n'"
agents/tools/mock_environment.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Mock environment for testing reinforcement learning code.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport gym\nimport gym.spaces\nimport numpy as np\n\n\nclass MockEnvironment(object):\n  """"""Generate random agent input and keep track of statistics.""""""\n\n  def __init__(self, observ_shape, action_shape, min_duration, max_duration):\n    """"""Generate random agent input and keep track of statistics.\n\n    Args:\n      observ_shape: Shape for the random observations.\n      action_shape: Shape for the action space.\n      min_duration: Minimum number of steps per episode.\n      max_duration: Maximum number of steps per episode.\n\n    Attributes:\n      steps: List of actual simulated lengths for all episodes.\n      durations: List of decided lengths for all episodes.\n    """"""\n    self._observ_shape = observ_shape\n    self._action_shape = action_shape\n    self._min_duration = min_duration\n    self._max_duration = max_duration\n    self._random = np.random.RandomState(0)\n    self.steps = []\n    self.durations = []\n\n  @property\n  def observation_space(self):\n    low = np.zeros(self._observ_shape)\n    high = np.ones(self._observ_shape)\n    return gym.spaces.Box(low, high, dtype=np.float32)\n\n  @property\n  def action_space(self):\n    low = np.zeros(self._action_shape)\n    high = np.ones(self._action_shape)\n    return gym.spaces.Box(low, high, dtype=np.float32)\n\n  @property\n  def unwrapped(self):\n    return self\n\n  def step(self, action):\n    assert self.action_space.contains(action)\n    assert self.steps[-1] < self.durations[-1]\n    self.steps[-1] += 1\n    observ = self._current_observation()\n    reward = self._current_reward()\n    done = self.steps[-1] >= self.durations[-1]\n    info = {}\n    return observ, reward, done, info\n\n  def reset(self):\n    duration = self._random.randint(self._min_duration, self._max_duration + 1)\n    self.steps.append(0)\n    self.durations.append(duration)\n    return self._current_observation()\n\n  def _current_observation(self):\n    return self._random.uniform(0, 1, self._observ_shape)\n\n  def _current_reward(self):\n    return self._random.uniform(-1, 1)\n'"
agents/tools/nested.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tools for manipulating nested tuples, list, and dictionaries.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n# Disable linter warning for using `flatten` as argument name.\n# pylint: disable=redefined-outer-name\n\n_builtin_zip = zip\n_builtin_map = map\n_builtin_filter = filter\n\n\ndef zip_(*structures, **kwargs):\n  # pylint: disable=differing-param-doc,missing-param-doc\n  """"""Combine corresponding elements in multiple nested structure to tuples.\n\n  The nested structures can consist of any combination of lists, tuples, and\n  dicts. All provided structures must have the same nesting.\n\n  Args:\n    *structures: Nested structures.\n    flatten: Whether to flatten the resulting structure into a tuple. Keys of\n        dictionaries will be discarded.\n\n  Returns:\n    Nested structure.\n  """"""\n  # Named keyword arguments are not allowed after *args in Python 2.\n  flatten = kwargs.pop(\'flatten\', False)\n  assert not kwargs, \'zip() got unexpected keyword arguments.\'\n  return map(\n      lambda *x: x if len(x) > 1 else x[0],\n      *structures,\n      flatten=flatten)\n\n\ndef map_(function, *structures, **kwargs):\n  # pylint: disable=differing-param-doc,missing-param-doc\n  """"""Apply a function to every element in a nested structure.\n\n  If multiple structures are provided as input, their structure must match and\n  the function will be applied to corresponding groups of elements. The nested\n  structure can consist of any combination of lists, tuples, and dicts.\n\n  Args:\n    function: The function to apply to the elements of the structure. Receives\n        one argument for every structure that is provided.\n    *structures: One of more nested structures.\n    flatten: Whether to flatten the resulting structure into a tuple. Keys of\n        dictionaries will be discarded.\n\n  Returns:\n    Nested structure.\n  """"""\n  # Named keyword arguments are not allowed after *args in Python 2.\n  flatten = kwargs.pop(\'flatten\', False)\n  assert not kwargs, \'map() got unexpected keyword arguments.\'\n\n  def impl(function, *structures):\n    if len(structures) == 0:  # pylint: disable=len-as-condition\n      return structures\n    if all(isinstance(s, (tuple, list)) for s in structures):\n      if len(set(len(x) for x in structures)) > 1:\n        raise ValueError(\'Cannot merge tuples or lists of different length.\')\n      args = tuple((impl(function, *x) for x in _builtin_zip(*structures)))\n      if hasattr(structures[0], \'_fields\'):  # namedtuple\n        return type(structures[0])(*args)\n      else:  # tuple, list\n        return type(structures[0])(args)\n    if all(isinstance(s, dict) for s in structures):\n      if len(set(frozenset(x.keys()) for x in structures)) > 1:\n        raise ValueError(\'Cannot merge dicts with different keys.\')\n      merged = {\n          k: impl(function, *(s[k] for s in structures))\n          for k in structures[0]}\n      return type(structures[0])(merged)\n    return function(*structures)\n\n  result = impl(function, *structures)\n  if flatten:\n    result = flatten_(result)\n  return result\n\n\ndef flatten_(structure):\n  """"""Combine all leaves of a nested structure into a tuple.\n\n  The nested structure can consist of any combination of tuples, lists, and\n  dicts. Dictionary keys will be discarded but values will ordered by the\n  sorting of the keys.\n\n  Args:\n    structure: Nested structure.\n\n  Returns:\n    Flat tuple.\n  """"""\n  if isinstance(structure, dict):\n    if structure:\n      structure = zip(*sorted(structure.items(), key=lambda x: x[0]))[1]\n    else:\n      # Zip doesn\'t work on an the items of an empty dictionary.\n      structure = ()\n  if isinstance(structure, (tuple, list)):\n    result = []\n    for element in structure:\n      result += flatten_(element)\n    return tuple(result)\n  return (structure,)\n\n\ndef filter_(predicate, *structures, **kwargs):\n  # pylint: disable=differing-param-doc,missing-param-doc, too-many-branches\n  """"""Select elements of a nested structure based on a predicate function.\n\n  If multiple structures are provided as input, their structure must match and\n  the function will be applied to corresponding groups of elements. The nested\n  structure can consist of any combination of lists, tuples, and dicts.\n\n  Args:\n    predicate: The function to determine whether an element should be kept.\n        Receives one argument for every structure that is provided.\n    *structures: One of more nested structures.\n    flatten: Whether to flatten the resulting structure into a tuple. Keys of\n        dictionaries will be discarded.\n\n  Returns:\n    Nested structure.\n  """"""\n  # Named keyword arguments are not allowed after *args in Python 2.\n  flatten = kwargs.pop(\'flatten\', False)\n  assert not kwargs, \'filter() got unexpected keyword arguments.\'\n\n  def impl(predicate, *structures):\n    if len(structures) == 0:  # pylint: disable=len-as-condition\n      return structures\n    if all(isinstance(s, (tuple, list)) for s in structures):\n      if len(set(len(x) for x in structures)) > 1:\n        raise ValueError(\'Cannot merge tuples or lists of different length.\')\n      # Only wrap in tuples if more than one structure provided.\n      if len(structures) > 1:\n        filtered = (impl(predicate, *x) for x in _builtin_zip(*structures))\n      else:\n        filtered = (impl(predicate, x) for x in structures[0])\n      # Remove empty containers and construct result structure.\n      if hasattr(structures[0], \'_fields\'):  # namedtuple\n        filtered = (x if x != () else None for x in filtered)\n        return type(structures[0])(*filtered)\n      else:  # tuple, list\n        filtered = (\n            x for x in filtered if not isinstance(x, (tuple, list, dict)) or x)\n        return type(structures[0])(filtered)\n    if all(isinstance(s, dict) for s in structures):\n      if len(set(frozenset(x.keys()) for x in structures)) > 1:\n        raise ValueError(\'Cannot merge dicts with different keys.\')\n      # Only wrap in tuples if more than one structure provided.\n      if len(structures) > 1:\n        filtered = {\n            k: impl(predicate, *(s[k] for s in structures))\n            for k in structures[0]}\n      else:\n        filtered = {k: impl(predicate, v) for k, v in structures[0].items()}\n      # Remove empty containers and construct result structure.\n      filtered = {\n          k: v for k, v in filtered.items()\n          if not isinstance(v, (tuple, list, dict)) or v}\n      return type(structures[0])(filtered)\n    if len(structures) > 1:\n      return structures if predicate(*structures) else ()\n    else:\n      return structures[0] if predicate(structures[0]) else ()\n\n  result = impl(predicate, *structures)\n  if flatten:\n    result = flatten_(result)\n  return result\n\n\n# pylint: disable=redefined-builtin\nzip = zip_\nmap = map_\nflatten = flatten_\nfilter = filter_\n'"
agents/tools/nested_test.py,4,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests of tools for managing nested structures.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\n\nimport tensorflow as tf\n\nfrom agents.tools import nested\n\n\nclass ZipTest(tf.test.TestCase):\n\n  def test_scalar(self):\n    self.assertEqual(42, nested.zip(42))\n    self.assertEqual((13, 42), nested.zip(13, 42))\n\n  def test_empty(self):\n    self.assertEqual({}, nested.zip({}, {}))\n\n  def test_base_case(self):\n    self.assertEqual((1, 2, 3), nested.zip(1, 2, 3))\n\n  def test_shallow_list(self):\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    c = [7, 8, 9]\n    result = nested.zip(a, b, c)\n    self.assertEqual([(1, 4, 7), (2, 5, 8), (3, 6, 9)], result)\n\n  def test_shallow_tuple(self):\n    a = (1, 2, 3)\n    b = (4, 5, 6)\n    c = (7, 8, 9)\n    result = nested.zip(a, b, c)\n    self.assertEqual(((1, 4, 7), (2, 5, 8), (3, 6, 9)), result)\n\n  def test_shallow_dict(self):\n    a = {\'a\': 1, \'b\': 2, \'c\': 3}\n    b = {\'a\': 4, \'b\': 5, \'c\': 6}\n    c = {\'a\': 7, \'b\': 8, \'c\': 9}\n    result = nested.zip(a, b, c)\n    self.assertEqual({\'a\': (1, 4, 7), \'b\': (2, 5, 8), \'c\': (3, 6, 9)}, result)\n\n  def test_single(self):\n    a = [[1, 2], 3]\n    result = nested.zip(a)\n    self.assertEqual(a, result)\n\n  def test_mixed_structures(self):\n    a = [(1, 2), 3, {\'foo\': [4]}]\n    b = [(5, 6), 7, {\'foo\': [8]}]\n    result = nested.zip(a, b)\n    self.assertEqual([((1, 5), (2, 6)), (3, 7), {\'foo\': [(4, 8)]}], result)\n\n  def test_different_types(self):\n    a = [1, 2, 3]\n    b = \'a b c\'.split()\n    result = nested.zip(a, b)\n    self.assertEqual([(1, \'a\'), (2, \'b\'), (3, \'c\')], result)\n\n  def test_use_type_of_first(self):\n    a = (1, 2, 3)\n    b = [4, 5, 6]\n    c = [7, 8, 9]\n    result = nested.zip(a, b, c)\n    self.assertEqual(((1, 4, 7), (2, 5, 8), (3, 6, 9)), result)\n\n  def test_namedtuple(self):\n    Foo = collections.namedtuple(\'Foo\', \'value\')\n    foo, bar = Foo(42), Foo(13)\n    self.assertEqual(Foo((42, 13)), nested.zip(foo, bar))\n\n\nclass MapTest(tf.test.TestCase):\n\n  def test_scalar(self):\n    self.assertEqual(42, nested.map(lambda x: x, 42))\n\n  def test_empty(self):\n    self.assertEqual({}, nested.map(lambda x: x, {}))\n\n  def test_shallow_list(self):\n    self.assertEqual([2, 4, 6], nested.map(lambda x: 2 * x, [1, 2, 3]))\n\n  def test_shallow_dict(self):\n    data = {\'a\': 1, \'b\': 2, \'c\': 3, \'d\': 4}\n    self.assertEqual(data, nested.map(lambda x: x, data))\n\n  def test_mixed_structure(self):\n    structure = [(1, 2), 3, {\'foo\': [4]}]\n    result = nested.map(lambda x: 2 * x, structure)\n    self.assertEqual([(2, 4), 6, {\'foo\': [8]}], result)\n\n  def test_mixed_types(self):\n    self.assertEqual([14, \'foofoo\'], nested.map(lambda x: x * 2, [7, \'foo\']))\n\n  def test_multiple_lists(self):\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    c = [7, 8, 9]\n    result = nested.map(lambda x, y, z: x + y + z, a, b, c)\n    self.assertEqual([12, 15, 18], result)\n\n  def test_namedtuple(self):\n    Foo = collections.namedtuple(\'Foo\', \'value\')\n    foo, bar = [Foo(42)], [Foo(13)]\n    function = nested.map(lambda x, y: (y, x), foo, bar)\n    self.assertEqual([Foo((13, 42))], function)\n    function = nested.map(lambda x, y: x + y, foo, bar)\n    self.assertEqual([Foo(55)], function)\n\n\nclass FlattenTest(tf.test.TestCase):\n\n  def test_scalar(self):\n    self.assertEqual((42,), nested.flatten(42))\n\n  def test_empty(self):\n    self.assertEqual((), nested.flatten({}))\n\n  def test_base_case(self):\n    self.assertEqual((1,), nested.flatten(1))\n\n  def test_convert_type(self):\n    self.assertEqual((1, 2, 3), nested.flatten([1, 2, 3]))\n\n  def test_mixed_structure(self):\n    self.assertEqual((1, 2, 3, 4), nested.flatten([(1, 2), 3, {\'foo\': [4]}]))\n\n  def test_value_ordering(self):\n    self.assertEqual((1, 2, 3), nested.flatten({\'a\': 1, \'b\': 2, \'c\': 3}))\n\n\nclass FilterTest(tf.test.TestCase):\n\n  def test_empty(self):\n    self.assertEqual({}, nested.filter(lambda x: True, {}))\n    self.assertEqual({}, nested.filter(lambda x: False, {}))\n\n  def test_base_case(self):\n    self.assertEqual((), nested.filter(lambda x: False, 1))\n\n  def test_single_dict(self):\n    predicate = lambda x: x % 2 == 0\n    data = {\'a\': 1, \'b\': 2, \'c\': 3, \'d\': 4}\n    self.assertEqual({\'b\': 2, \'d\': 4}, nested.filter(predicate, data))\n\n  def test_multiple_lists(self):\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    c = [7, 8, 9]\n    predicate = lambda *args: any(x % 4 == 0 for x in args)\n    result = nested.filter(predicate, a, b, c)\n    self.assertEqual([(1, 4, 7), (2, 5, 8)], result)\n\n  def test_multiple_dicts(self):\n    a = {\'a\': 1, \'b\': 2, \'c\': 3}\n    b = {\'a\': 4, \'b\': 5, \'c\': 6}\n    c = {\'a\': 7, \'b\': 8, \'c\': 9}\n    predicate = lambda *args: any(x % 4 == 0 for x in args)\n    result = nested.filter(predicate, a, b, c)\n    self.assertEqual({\'a\': (1, 4, 7), \'b\': (2, 5, 8)}, result)\n\n  def test_mixed_structure(self):\n    predicate = lambda x: x % 2 == 0\n    data = [(1, 2), 3, {\'foo\': [4]}]\n    self.assertEqual([(2,), {\'foo\': [4]}], nested.filter(predicate, data))\n\n  def test_remove_empty_containers(self):\n    data = [(1, 2, 3), 4, {\'foo\': [5, 6], \'bar\': 7}]\n    self.assertEqual([], nested.filter(lambda x: False, data))\n\n  def test_namedtuple(self):\n    Foo = collections.namedtuple(\'Foo\', \'value1, value2\')\n    self.assertEqual(Foo(1, None), nested.filter(lambda x: x == 1, Foo(1, 2)))\n\n  def test_namedtuple_multiple(self):\n    Foo = collections.namedtuple(\'Foo\', \'value1, value2\')\n    foo = Foo(1, 2)\n    bar = Foo(2, 3)\n    result = nested.filter(lambda x, y: x + y > 3, foo, bar)\n    self.assertEqual(Foo(None, (2, 3)), result)\n\n  def test_namedtuple_nested(self):\n    Foo = collections.namedtuple(\'Foo\', \'value1, value2\')\n    foo = Foo(1, [1, 2, 3])\n    self.assertEqual(Foo(None, [2, 3]), nested.filter(lambda x: x > 1, foo))\n'"
agents/tools/simulate.py,45,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""In-graph simulation step of a vectorized algorithm with environments.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom agents.tools import streaming_mean\n\n\ndef simulate(batch_env, algo, log=True, reset=False):\n  """"""Simulation step of a vectorized algorithm with in-graph environments.\n\n  Integrates the operations implemented by the algorithm and the environments\n  into a combined operation.\n\n  Args:\n    batch_env: In-graph batch environment.\n    algo: Algorithm instance implementing required operations.\n    log: Tensor indicating whether to compute and return summaries.\n    reset: Tensor causing all environments to reset.\n\n  Returns:\n    Tuple of tensors containing done flags for the current episodes, possibly\n    intermediate scores for the episodes, and a summary tensor.\n  """"""\n\n  def _define_begin_episode(agent_indices):\n    """"""Reset environments, intermediate scores and durations for new episodes.\n\n    Args:\n      agent_indices: Tensor containing batch indices starting an episode.\n\n    Returns:\n      Summary tensor.\n    """"""\n    assert agent_indices.shape.ndims == 1\n    zero_scores = tf.zeros_like(agent_indices, tf.float32)\n    zero_durations = tf.zeros_like(agent_indices)\n    reset_ops = [\n        batch_env.reset(agent_indices),\n        tf.scatter_update(score, agent_indices, zero_scores),\n        tf.scatter_update(length, agent_indices, zero_durations)]\n    with tf.control_dependencies(reset_ops):\n      return algo.begin_episode(agent_indices)\n\n  def _define_step():\n    """"""Request actions from the algorithm and apply them to the environments.\n\n    Increments the lengths of all episodes and increases their scores by the\n    current reward. After stepping the environments, provides the full\n    transition tuple to the algorithm.\n\n    Returns:\n      Summary tensor.\n    """"""\n    prevob = batch_env.observ + 0  # Ensure a copy of the variable value.\n    agent_indices = tf.range(len(batch_env))\n    action, step_summary = algo.perform(agent_indices, prevob)\n    action.set_shape(batch_env.action.shape)\n    with tf.control_dependencies([batch_env.simulate(action)]):\n      add_score = score.assign_add(batch_env.reward)\n      inc_length = length.assign_add(tf.ones(len(batch_env), tf.int32))\n    with tf.control_dependencies([add_score, inc_length]):\n      agent_indices = tf.range(len(batch_env))\n      experience_summary = algo.experience(\n          agent_indices, prevob, batch_env.action, batch_env.reward,\n          batch_env.done, batch_env.observ)\n    return tf.summary.merge([step_summary, experience_summary])\n\n  def _define_end_episode(agent_indices):\n    """"""Notify the algorithm of ending episodes.\n\n    Also updates the mean score and length counters used for summaries.\n\n    Args:\n      agent_indices: Tensor holding batch indices that end their episodes.\n\n    Returns:\n      Summary tensor.\n    """"""\n    assert agent_indices.shape.ndims == 1\n    submit_score = mean_score.submit(tf.gather(score, agent_indices))\n    submit_length = mean_length.submit(\n        tf.cast(tf.gather(length, agent_indices), tf.float32))\n    with tf.control_dependencies([submit_score, submit_length]):\n      return algo.end_episode(agent_indices)\n\n  def _define_summaries():\n    """"""Reset the average score and duration, and return them as summary.\n\n    Returns:\n      Summary string.\n    """"""\n    score_summary = tf.cond(\n        tf.logical_and(log, tf.cast(mean_score.count, tf.bool)),\n        lambda: tf.summary.scalar(\'mean_score\', mean_score.clear()), str)\n    length_summary = tf.cond(\n        tf.logical_and(log, tf.cast(mean_length.count, tf.bool)),\n        lambda: tf.summary.scalar(\'mean_length\', mean_length.clear()), str)\n    return tf.summary.merge([score_summary, length_summary])\n\n  with tf.name_scope(\'simulate\'):\n    log = tf.convert_to_tensor(log)\n    reset = tf.convert_to_tensor(reset)\n    with tf.variable_scope(\'simulate_temporary\'):\n      score = tf.Variable(\n          lambda: tf.zeros(len(batch_env), dtype=tf.float32),\n          trainable=False, name=\'score\')\n      length = tf.Variable(\n          lambda: tf.zeros(len(batch_env), dtype=tf.int32),\n          trainable=False, name=\'length\')\n    mean_score = streaming_mean.StreamingMean((), tf.float32)\n    mean_length = streaming_mean.StreamingMean((), tf.float32)\n    agent_indices = tf.cond(\n        reset,\n        lambda: tf.range(len(batch_env)),\n        lambda: tf.cast(tf.where(batch_env.done)[:, 0], tf.int32))\n    begin_episode = tf.cond(\n        tf.cast(tf.shape(agent_indices)[0], tf.bool),\n        lambda: _define_begin_episode(agent_indices), str)\n    with tf.control_dependencies([begin_episode]):\n      step = _define_step()\n    with tf.control_dependencies([step]):\n      agent_indices = tf.cast(tf.where(batch_env.done)[:, 0], tf.int32)\n      end_episode = tf.cond(\n          tf.cast(tf.shape(agent_indices)[0], tf.bool),\n          lambda: _define_end_episode(agent_indices), str)\n    with tf.control_dependencies([end_episode]):\n      summary = tf.summary.merge([\n          _define_summaries(), begin_episode, step, end_episode])\n    with tf.control_dependencies([summary]):\n      done, score = tf.identity(batch_env.done), tf.identity(score)\n    return done, score, summary\n'"
agents/tools/simulate_test.py,8,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests for the simulation operation.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom agents import tools\n\n\nclass SimulateTest(tf.test.TestCase):\n\n  def test_done_automatic(self):\n    batch_env = self._create_test_batch_env((1, 2, 3, 4))\n    algo = tools.MockAlgorithm(batch_env)\n    done, _, _ = tools.simulate(batch_env, algo, log=False, reset=False)\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      self.assertAllEqual([True, False, False, False], sess.run(done))\n      self.assertAllEqual([True, True, False, False], sess.run(done))\n      self.assertAllEqual([True, False, True, False], sess.run(done))\n      self.assertAllEqual([True, True, False, True], sess.run(done))\n\n  def test_done_forced(self):\n    reset = tf.placeholder_with_default(False, ())\n    batch_env = self._create_test_batch_env((2, 4))\n    algo = tools.MockAlgorithm(batch_env)\n    done, _, _ = tools.simulate(batch_env, algo, False, reset)\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      self.assertAllEqual([False, False], sess.run(done))\n      self.assertAllEqual([False, False], sess.run(done, {reset: True}))\n      self.assertAllEqual([True, False], sess.run(done))\n      self.assertAllEqual([False, False], sess.run(done, {reset: True}))\n      self.assertAllEqual([True, False], sess.run(done))\n      self.assertAllEqual([False, False], sess.run(done))\n      self.assertAllEqual([True, True], sess.run(done))\n\n  def test_reset_automatic(self):\n    batch_env = self._create_test_batch_env((1, 2, 3, 4))\n    algo = tools.MockAlgorithm(batch_env)\n    done, _, _ = tools.simulate(batch_env, algo, log=False, reset=False)\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      for _ in range(10):\n        sess.run(done)\n    self.assertAllEqual([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], batch_env[0].steps)\n    self.assertAllEqual([2, 2, 2, 2, 2], batch_env[1].steps)\n    self.assertAllEqual([3, 3, 3, 1], batch_env[2].steps)\n    self.assertAllEqual([4, 4, 2], batch_env[3].steps)\n\n  def test_reset_forced(self):\n    reset = tf.placeholder_with_default(False, ())\n    batch_env = self._create_test_batch_env((2, 4))\n    algo = tools.MockAlgorithm(batch_env)\n    done, _, _ = tools.simulate(batch_env, algo, False, reset)\n    with self.test_session() as sess:\n      sess.run(tf.global_variables_initializer())\n      sess.run(done)\n      sess.run(done, {reset: True})\n      sess.run(done)\n      sess.run(done, {reset: True})\n      sess.run(done)\n      sess.run(done)\n      sess.run(done)\n    self.assertAllEqual([1, 2, 2, 2], batch_env[0].steps)\n    self.assertAllEqual([1, 2, 4], batch_env[1].steps)\n\n  def _create_test_batch_env(self, durations):\n    envs = []\n    for duration in durations:\n      env = tools.MockEnvironment(\n          observ_shape=(2, 3), action_shape=(3,),\n          min_duration=duration, max_duration=duration)\n      env = tools.wrappers.ConvertTo32Bit(env)\n      envs.append(env)\n    batch_env = tools.BatchEnv(envs, blocking=True)\n    batch_env = tools.InGraphBatchEnv(batch_env)\n    return batch_env\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
agents/tools/streaming_mean.py,11,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Compute a streaming estimation of the mean of submitted tensors.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\n\nclass StreamingMean(object):\n  """"""Compute a streaming estimation of the mean of submitted tensors.""""""\n\n  def __init__(self, shape, dtype):\n    """"""Specify the shape and dtype of the mean to be estimated.\n\n    Note that a float mean to zero submitted elements is NaN, while computing\n    the integer mean of zero elements raises a division by zero error.\n\n    Args:\n      shape: Shape of the mean to compute.\n      dtype: Data type of the mean to compute.\n    """"""\n    self._dtype = dtype\n    self._sum = tf.Variable(lambda: tf.zeros(shape, dtype), False)\n    self._count = tf.Variable(lambda: 0, trainable=False)\n\n  @property\n  def value(self):\n    """"""The current value of the mean.""""""\n    return self._sum / tf.cast(self._count, self._dtype)\n\n  @property\n  def count(self):\n    """"""The number of submitted samples.""""""\n    return self._count\n\n  def submit(self, value):\n    """"""Submit a single or batch tensor to refine the streaming mean.""""""\n    # Add a batch dimension if necessary.\n    if value.shape.ndims == self._sum.shape.ndims:\n      value = value[None, ...]\n    return tf.group(\n        self._sum.assign_add(tf.reduce_sum(value, 0)),\n        self._count.assign_add(tf.shape(value)[0]))\n\n  def clear(self):\n    """"""Return the mean estimate and reset the streaming statistics.""""""\n    value = self._sum / tf.cast(self._count, self._dtype)\n    with tf.control_dependencies([value]):\n      reset_value = self._sum.assign(tf.zeros_like(self._sum))\n      reset_count = self._count.assign(0)\n    with tf.control_dependencies([reset_value, reset_count]):\n      return tf.identity(value)\n'"
agents/tools/wrappers.py,4,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Wrappers for OpenAI Gym environments.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport atexit\nimport multiprocessing\nimport sys\nimport traceback\n\nimport gym\nimport gym.spaces\nimport numpy as np\nimport tensorflow as tf\n\n\nclass AutoReset(object):\n  """"""Automatically reset environment when the episode is done.""""""\n\n  def __init__(self, env):\n    self._env = env\n    self._done = True\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  def step(self, action):\n    if self._done:\n      observ, reward, done, info = self._env.reset(), 0.0, False, {}\n    else:\n      observ, reward, done, info = self._env.step(action)\n    self._done = done\n    return observ, reward, done, info\n\n  def reset(self):\n    self._done = False\n    return self._env.reset()\n\n\nclass ActionRepeat(object):\n  """"""Repeat the agent action multiple steps.""""""\n\n  def __init__(self, env, amount):\n    self._env = env\n    self._amount = amount\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  def step(self, action):\n    done = False\n    total_reward = 0\n    current_step = 0\n    while current_step < self._amount and not done:\n      observ, reward, done, info = self._env.step(action)\n      total_reward += reward\n      current_step += 1\n    return observ, total_reward, done, info\n\n\nclass RandomStart(object):\n  """"""Perform random number of random actions at the start of the episode.""""""\n\n  def __init__(self, env, max_steps):\n    self._env = env\n    self._max_steps = max_steps\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  def reset(self):\n    observ = self._env.reset()\n    random_steps = np.random.randint(0, self._max_steps)\n    for _ in range(random_steps):\n      action = self._env.action_space.sample()\n      observ, unused_reward, done, unused_info = self._env.step(action)\n      if done:\n        tf.logging.warning(\'Episode ended during random start.\')\n        return self.reset()\n    return observ\n\n\nclass FrameHistory(object):\n  """"""Augment the observation with past observations.""""""\n\n  def __init__(self, env, past_indices, flatten):\n    """"""Augment the observation with past observations.\n\n    Implemented as a Numpy ring buffer holding the necessary past observations.\n\n    Args:\n      env: OpenAI Gym environment to wrap.\n      past_indices: List of non-negative integers indicating the time offsets\n        from the current time step of observations to include.\n      flatten: Concatenate the past observations rather than stacking them.\n\n    Raises:\n      KeyError: The current observation is not included in the indices.\n    """"""\n    if 0 not in past_indices:\n      raise KeyError(\'Past indices should include 0 for the current frame.\')\n    self._env = env\n    self._past_indices = past_indices\n    self._step = 0\n    self._buffer = None\n    self._capacity = max(past_indices) + 1\n    self._flatten = flatten\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  @property\n  def observation_space(self):\n    low = self._env.observation_space.low\n    high = self._env.observation_space.high\n    low = np.repeat(low[None, ...], len(self._past_indices), 0)\n    high = np.repeat(high[None, ...], len(self._past_indices), 0)\n    if self._flatten:\n      low = np.reshape(low, (-1,) + low.shape[2:])\n      high = np.reshape(high, (-1,) + high.shape[2:])\n    return gym.spaces.Box(low, high, dtype=np.float32)\n\n  def step(self, action):\n    observ, reward, done, info = self._env.step(action)\n    self._step += 1\n    self._buffer[self._step % self._capacity] = observ\n    observ = self._select_frames()\n    return observ, reward, done, info\n\n  def reset(self):\n    observ = self._env.reset()\n    self._buffer = np.repeat(observ[None, ...], self._capacity, 0)\n    self._step = 0\n    return self._select_frames()\n\n  def _select_frames(self):\n    indices = [\n        (self._step - index) % self._capacity for index in self._past_indices]\n    observ = self._buffer[indices]\n    if self._flatten:\n      observ = np.reshape(observ, (-1,) + observ.shape[2:])\n    return observ\n\n\nclass FrameDelta(object):\n  """"""Convert the observation to a difference from the previous observation.""""""\n\n  def __init__(self, env):\n    self._env = env\n    self._last = None\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  @property\n  def observation_space(self):\n    low = self._env.observation_space.low\n    high = self._env.observation_space.high\n    low, high = low - high, high - low\n    return gym.spaces.Box(low, high, dtype=np.float32)\n\n  def step(self, action):\n    observ, reward, done, info = self._env.step(action)\n    delta = observ - self._last\n    self._last = observ\n    return delta, reward, done, info\n\n  def reset(self):\n    observ = self._env.reset()\n    self._last = observ\n    return observ\n\n\nclass RangeNormalize(object):\n  """"""Normalize the specialized observation and action ranges to [-1, 1].""""""\n\n  def __init__(self, env, observ=None, action=None):\n    self._env = env\n    self._should_normalize_observ = (\n        observ is not False and self._is_finite(self._env.observation_space))\n    if observ is True and not self._should_normalize_observ:\n      raise ValueError(\'Cannot normalize infinite observation range.\')\n    if observ is None and not self._should_normalize_observ:\n      tf.logging.info(\'Not normalizing infinite observation range.\')\n    self._should_normalize_action = (\n        action is not False and self._is_finite(self._env.action_space))\n    if action is True and not self._should_normalize_action:\n      raise ValueError(\'Cannot normalize infinite action range.\')\n    if action is None and not self._should_normalize_action:\n      tf.logging.info(\'Not normalizing infinite action range.\')\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  @property\n  def observation_space(self):\n    space = self._env.observation_space\n    if not self._should_normalize_observ:\n      return space\n    low, high = -np.ones(space.shape), np.ones(space.shape)\n    return gym.spaces.Box(low, high, dtype=np.float32)\n\n  @property\n  def action_space(self):\n    space = self._env.action_space\n    if not self._should_normalize_action:\n      return space\n    low, high = -np.ones(space.shape), np.ones(space.shape)\n    return gym.spaces.Box(low, high, dtype=np.float32)\n\n  def step(self, action):\n    if self._should_normalize_action:\n      action = self._denormalize_action(action)\n    observ, reward, done, info = self._env.step(action)\n    if self._should_normalize_observ:\n      observ = self._normalize_observ(observ)\n    return observ, reward, done, info\n\n  def reset(self):\n    observ = self._env.reset()\n    if self._should_normalize_observ:\n      observ = self._normalize_observ(observ)\n    return observ\n\n  def _denormalize_action(self, action):\n    min_ = self._env.action_space.low\n    max_ = self._env.action_space.high\n    action = (action + 1) / 2 * (max_ - min_) + min_\n    return action\n\n  def _normalize_observ(self, observ):\n    min_ = self._env.observation_space.low\n    max_ = self._env.observation_space.high\n    observ = 2 * (observ - min_) / (max_ - min_) - 1\n    return observ\n\n  def _is_finite(self, space):\n    return np.isfinite(space.low).all() and np.isfinite(space.high).all()\n\n\nclass ClipAction(object):\n  """"""Clip out of range actions to the action space of the environment.""""""\n\n  def __init__(self, env):\n    self._env = env\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  @property\n  def action_space(self):\n    shape = self._env.action_space.shape\n    low, high = -np.inf * np.ones(shape), np.inf * np.ones(shape)\n    return gym.spaces.Box(low, high, dtype=np.float32)\n\n  def step(self, action):\n    action_space = self._env.action_space\n    action = np.clip(action, action_space.low, action_space.high)\n    return self._env.step(action)\n\n\nclass LimitDuration(object):\n  """"""End episodes after specified number of steps.""""""\n\n  def __init__(self, env, duration):\n    self._env = env\n    self._duration = duration\n    self._step = None\n\n  def __getattr__(self, name):\n    return getattr(self._env, name)\n\n  def step(self, action):\n    if self._step is None:\n      raise RuntimeError(\'Must reset environment.\')\n    observ, reward, done, info = self._env.step(action)\n    self._step += 1\n    if self._step >= self._duration:\n      done = True\n      self._step = None\n    return observ, reward, done, info\n\n  def reset(self):\n    self._step = 0\n    return self._env.reset()\n\n\nclass ExternalProcess(object):\n  """"""Step environment in a separate process for lock free paralellism.""""""\n\n  # Message types for communication via the pipe.\n  _ACCESS = 1\n  _CALL = 2\n  _RESULT = 3\n  _EXCEPTION = 4\n  _CLOSE = 5\n\n  def __init__(self, constructor):\n    """"""Step environment in a separate process for lock free parallelism.\n\n    The environment will be created in the external process by calling the\n    specified callable. This can be an environment class, or a function\n    creating the environment and potentially wrapping it. The returned\n    environment should not access global variables.\n\n    Args:\n      constructor: Callable that creates and returns an OpenAI gym environment.\n\n    Attributes:\n      observation_space: The cached observation space of the environment.\n      action_space: The cached action space of the environment.\n    """"""\n    self._conn, conn = multiprocessing.Pipe()\n    self._process = multiprocessing.Process(\n        target=self._worker, args=(constructor, conn))\n    atexit.register(self.close)\n    self._process.start()\n    self._observ_space = None\n    self._action_space = None\n\n  @property\n  def observation_space(self):\n    if not self._observ_space:\n      self._observ_space = self.__getattr__(\'observation_space\')\n    return self._observ_space\n\n  @property\n  def action_space(self):\n    if not self._action_space:\n      self._action_space = self.__getattr__(\'action_space\')\n    return self._action_space\n\n  def __getattr__(self, name):\n    """"""Request an attribute from the environment.\n\n    Note that this involves communication with the external process, so it can\n    be slow.\n\n    Args:\n      name: Attribute to access.\n\n    Returns:\n      Value of the attribute.\n    """"""\n    self._conn.send((self._ACCESS, name))\n    return self._receive()\n\n  def call(self, name, *args, **kwargs):\n    """"""Asynchronously call a method of the external environment.\n\n    Args:\n      name: Name of the method to call.\n      *args: Positional arguments to forward to the method.\n      **kwargs: Keyword arguments to forward to the method.\n\n    Returns:\n      Promise object that blocks and provides the return value when called.\n    """"""\n    payload = name, args, kwargs\n    self._conn.send((self._CALL, payload))\n    return self._receive\n\n  def close(self):\n    """"""Send a close message to the external process and join it.""""""\n    try:\n      self._conn.send((self._CLOSE, None))\n      self._conn.close()\n    except IOError:\n      # The connection was already closed.\n      pass\n    self._process.join()\n\n  def step(self, action, blocking=True):\n    """"""Step the environment.\n\n    Args:\n      action: The action to apply to the environment.\n      blocking: Whether to wait for the result.\n\n    Returns:\n      Transition tuple when blocking, otherwise callable that returns the\n      transition tuple.\n    """"""\n    promise = self.call(\'step\', action)\n    if blocking:\n      return promise()\n    else:\n      return promise\n\n  def reset(self, blocking=True):\n    """"""Reset the environment.\n\n    Args:\n      blocking: Whether to wait for the result.\n\n    Returns:\n      New observation when blocking, otherwise callable that returns the new\n      observation.\n    """"""\n    promise = self.call(\'reset\')\n    if blocking:\n      return promise()\n    else:\n      return promise\n\n  def _receive(self):\n    """"""Wait for a message from the worker process and return its payload.\n\n    Raises:\n      Exception: An exception was raised inside the worker process.\n      KeyError: The received message is of an unknown type.\n\n    Returns:\n      Payload object of the message.\n    """"""\n    message, payload = self._conn.recv()\n    # Re-raise exceptions in the main process.\n    if message == self._EXCEPTION:\n      stacktrace = payload\n      raise Exception(stacktrace)\n    if message == self._RESULT:\n      return payload\n    raise KeyError(\'Received message of unexpected type {}\'.format(message))\n\n  def _worker(self, constructor, conn):\n    """"""The process waits for actions and sends back environment results.\n\n    Args:\n      constructor: Constructor for the OpenAI Gym environment.\n      conn: Connection for communication to the main process.\n\n    Raises:\n      KeyError: When receiving a message of unknown type.\n    """"""\n    try:\n      env = constructor()\n      while True:\n        try:\n          # Only block for short times to have keyboard exceptions be raised.\n          if not conn.poll(0.1):\n            continue\n          message, payload = conn.recv()\n        except (EOFError, KeyboardInterrupt):\n          break\n        if message == self._ACCESS:\n          name = payload\n          result = getattr(env, name)\n          conn.send((self._RESULT, result))\n          continue\n        if message == self._CALL:\n          name, args, kwargs = payload\n          result = getattr(env, name)(*args, **kwargs)\n          conn.send((self._RESULT, result))\n          continue\n        if message == self._CLOSE:\n          assert payload is None\n          break\n        raise KeyError(\'Received message of unknown type {}\'.format(message))\n    except Exception:  # pylint: disable=broad-except\n      stacktrace = \'\'.join(traceback.format_exception(*sys.exc_info()))\n      tf.logging.error(\'Error in environment process: {}\'.format(stacktrace))\n      conn.send((self._EXCEPTION, stacktrace))\n    conn.close()\n\n\nclass ConvertTo32Bit(object):\n  """"""Convert data types of an OpenAI Gym environment to 32 bit.""""""\n\n  def __init__(self, env):\n    """"""Convert data types of an OpenAI Gym environment to 32 bit.\n\n    Args:\n      env: OpenAI Gym environment.\n    """"""\n    self._env = env\n\n  def __getattr__(self, name):\n    """"""Forward unimplemented attributes to the original environment.\n\n    Args:\n      name: Attribute that was accessed.\n\n    Returns:\n      Value behind the attribute name in the wrapped environment.\n    """"""\n    return getattr(self._env, name)\n\n  def step(self, action):\n    """"""Forward action to the wrapped environment.\n\n    Args:\n      action: Action to apply to the environment.\n\n    Raises:\n      ValueError: Invalid action.\n\n    Returns:\n      Converted observation, converted reward, done flag, and info object.\n    """"""\n    observ, reward, done, info = self._env.step(action)\n    observ = self._convert_observ(observ)\n    reward = self._convert_reward(reward)\n    return observ, reward, done, info\n\n  def reset(self):\n    """"""Reset the environment and convert the resulting observation.\n\n    Returns:\n      Converted observation.\n    """"""\n    observ = self._env.reset()\n    observ = self._convert_observ(observ)\n    return observ\n\n  def _convert_observ(self, observ):\n    """"""Convert the observation to 32 bits.\n\n    Args:\n      observ: Numpy observation.\n\n    Raises:\n      ValueError: Observation contains infinite values.\n\n    Returns:\n      Numpy observation with 32-bit data type.\n    """"""\n    if not np.isfinite(observ).all():\n      raise ValueError(\'Infinite observation encountered.\')\n    if observ.dtype == np.float64:\n      return observ.astype(np.float32)\n    if observ.dtype == np.int64:\n      return observ.astype(np.int32)\n    return observ\n\n  def _convert_reward(self, reward):\n    """"""Convert the reward to 32 bits.\n\n    Args:\n      reward: Numpy reward.\n\n    Raises:\n      ValueError: Rewards contain infinite values.\n\n    Returns:\n      Numpy reward with 32-bit data type.\n    """"""\n    if not np.isfinite(reward).all():\n      raise ValueError(\'Infinite reward encountered.\')\n    return np.array(reward, dtype=np.float32)\n\n\nclass CacheSpaces(object):\n  """"""Cache observation and action space to not recompute them repeatedly.""""""\n\n  def __init__(self, env):\n    """"""Cache observation and action space to not recompute them repeatedly.\n\n    Args:\n      env: OpenAI Gym environment.\n    """"""\n    self._env = env\n    self._observation_space = self._env.observation_space\n    self._action_space = self._env.action_space\n\n  def __getattr__(self, name):\n    """"""Forward unimplemented attributes to the original environment.\n\n    Args:\n      name: Attribute that was accessed.\n\n    Returns:\n      Value behind the attribute name in the wrapped environment.\n    """"""\n    return getattr(self._env, name)\n\n  @property\n  def observation_space(self):\n    return self._observation_space\n\n  @property\n  def action_space(self):\n    return self._action_space\n'"
agents/tools/wrappers_test.py,2,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests for environment wrappers.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\n\nimport tensorflow as tf\n\nfrom agents import tools\n\n\nclass ExternalProcessTest(tf.test.TestCase):\n\n  def test_close_no_hang_after_init(self):\n    constructor = functools.partial(\n        tools.MockEnvironment,\n        observ_shape=(2, 3), action_shape=(2,),\n        min_duration=2, max_duration=2)\n    env = tools.wrappers.ExternalProcess(constructor)\n    env.close()\n\n  def test_close_no_hang_after_step(self):\n    constructor = functools.partial(\n        tools.MockEnvironment,\n        observ_shape=(2, 3), action_shape=(2,),\n        min_duration=5, max_duration=5)\n    env = tools.wrappers.ExternalProcess(constructor)\n    env.reset()\n    env.step(env.action_space.sample())\n    env.step(env.action_space.sample())\n    env.close()\n\n  def test_reraise_exception_in_init(self):\n    constructor = MockEnvironmentCrashInInit\n    env = tools.wrappers.ExternalProcess(constructor)\n    with self.assertRaises(Exception):\n      env.step(env.action_space.sample())\n\n  def test_reraise_exception_in_step(self):\n    constructor = functools.partial(\n        MockEnvironmentCrashInStep, crash_at_step=3)\n    env = tools.wrappers.ExternalProcess(constructor)\n    env.reset()\n    env.step(env.action_space.sample())\n    env.step(env.action_space.sample())\n    with self.assertRaises(Exception):\n      env.step(env.action_space.sample())\n\n\nclass MockEnvironmentCrashInInit(object):\n  """"""Raise an error when instantiated.""""""\n\n  def __init__(self, *unused_args, **unused_kwargs):\n    raise RuntimeError()\n\n\nclass MockEnvironmentCrashInStep(tools.MockEnvironment):\n  """"""Raise an error after specified number of steps in an episode.""""""\n\n  def __init__(self, crash_at_step):\n    super(MockEnvironmentCrashInStep, self).__init__(\n        observ_shape=(2, 3), action_shape=(2,),\n        min_duration=crash_at_step + 1, max_duration=crash_at_step + 1)\n    self._crash_at_step = crash_at_step\n\n  def step(self, *args, **kwargs):  # pylint: disable=arguments-differ\n    transition = super(MockEnvironmentCrashInStep, self).step(*args, **kwargs)\n    if self.steps[-1] == self._crash_at_step:\n      raise RuntimeError()\n    return transition\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
agents/algorithms/ppo/__init__.py,0,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Proximal Policy Optimization algorithm.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom .ppo import PPO\n'"
agents/algorithms/ppo/ppo.py,139,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Proximal Policy Optimization agent.\n\nBased on John Schulman\'s implementation in Python and Theano:\nhttps://github.com/joschu/modular_rl/blob/master/modular_rl/ppo.py\n""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\n\nimport tensorflow as tf\n\nfrom agents import parts\nfrom agents import tools\nfrom agents.algorithms.ppo import utility\n\n\nclass PPO(object):\n  """"""A vectorized implementation of the PPO algorithm by John Schulman.""""""\n\n  def __init__(self, batch_env, step, is_training, should_log, config):\n    """"""Create an instance of the PPO algorithm.\n\n    Args:\n      batch_env: In-graph batch environment.\n      step: Integer tensor holding the current training step.\n      is_training: Boolean tensor for whether the algorithm should train.\n      should_log: Boolean tensor for whether summaries should be returned.\n      config: Object containing the agent configuration as attributes.\n    """"""\n    self._batch_env = batch_env\n    self._step = step\n    self._is_training = is_training\n    self._should_log = should_log\n    self._config = config\n    self._observ_filter = parts.StreamingNormalize(\n        self._batch_env.observ[0], center=True, scale=True, clip=5,\n        name=\'normalize_observ\')\n    self._reward_filter = parts.StreamingNormalize(\n        self._batch_env.reward[0], center=False, scale=True, clip=10,\n        name=\'normalize_reward\')\n    self._use_gpu = self._config.use_gpu and utility.available_gpus()\n    policy_params, state = self._initialize_policy()\n    self._initialize_memory(policy_params)\n    # Initialize the optimizer and penalty.\n    with tf.device(\'/gpu:0\' if self._use_gpu else \'/cpu:0\'):\n      self._optimizer = self._config.optimizer(self._config.learning_rate)\n    self._penalty = tf.Variable(\n        self._config.kl_init_penalty, False, dtype=tf.float32)\n    # If the policy is stateful, allocate space to store its state.\n    with tf.variable_scope(\'ppo_temporary\'):\n      with tf.device(\'/gpu:0\'):\n        if state is None:\n          self._last_state = None\n        else:\n          var_like = lambda x: tf.Variable(lambda: tf.zeros_like(x), False)\n          self._last_state = tools.nested.map(var_like, state)\n    # Remember the action and policy parameters to write into the memory.\n    with tf.variable_scope(\'ppo_temporary\'):\n      self._last_action = tf.Variable(\n          tf.zeros_like(self._batch_env.action), False, name=\'last_action\')\n      self._last_policy = tools.nested.map(\n          lambda x: tf.Variable(tf.zeros_like(x[:, 0], False)), policy_params)\n\n  def begin_episode(self, agent_indices):\n    """"""Reset the recurrent states and stored episode.\n\n    Args:\n      agent_indices: Tensor containing current batch indices.\n\n    Returns:\n      Summary tensor.\n    """"""\n    with tf.name_scope(\'begin_episode/\'):\n      if self._last_state is None:\n        reset_state = tf.no_op()\n      else:\n        reset_state = utility.reinit_nested_vars(\n            self._last_state, agent_indices)\n      reset_buffer = self._current_episodes.clear(agent_indices)\n      with tf.control_dependencies([reset_state, reset_buffer]):\n        return tf.constant(\'\')\n\n  def perform(self, agent_indices, observ):\n    """"""Compute batch of actions and a summary for a batch of observation.\n\n    Args:\n      agent_indices: Tensor containing current batch indices.\n      observ: Tensor of a batch of observations for all agents.\n\n    Returns:\n      Tuple of action batch tensor and summary tensor.\n    """"""\n    with tf.name_scope(\'perform/\'):\n      observ = self._observ_filter.transform(observ)\n      if self._last_state is None:\n        state = None\n      else:\n        state = tools.nested.map(\n            lambda x: tf.gather(x, agent_indices), self._last_state)\n      with tf.device(\'/gpu:0\' if self._use_gpu else \'/cpu:0\'):\n        output = self._network(\n            observ[:, None], tf.ones(observ.shape[0]), state)\n      action = tf.cond(\n          self._is_training, output.policy.sample, output.policy.mode)\n      logprob = output.policy.log_prob(action)[:, 0]\n      # pylint: disable=g-long-lambda\n      summary = tf.cond(self._should_log, lambda: tf.summary.merge([\n          tf.summary.histogram(\'mode\', output.policy.mode()[:, 0]),\n          tf.summary.histogram(\'action\', action[:, 0]),\n          tf.summary.histogram(\'logprob\', logprob)]), str)\n      # Remember current policy to append to memory in the experience callback.\n      if self._last_state is None:\n        assign_state = tf.no_op()\n      else:\n        assign_state = utility.assign_nested_vars(\n            self._last_state, output.state, agent_indices)\n      remember_last_action = tf.scatter_update(\n          self._last_action, agent_indices, action[:, 0])\n      policy_params = tools.nested.filter(\n          lambda x: isinstance(x, tf.Tensor), output.policy.parameters)\n      assert policy_params, \'Policy has no parameters to store.\'\n      remember_last_policy = tools.nested.map(\n          lambda var, val: tf.scatter_update(var, agent_indices, val[:, 0]),\n          self._last_policy, policy_params, flatten=True)\n      with tf.control_dependencies((\n          assign_state, remember_last_action) + remember_last_policy):\n        return action[:, 0], tf.identity(summary)\n\n  def experience(\n      self, agent_indices, observ, action, reward, unused_done, unused_nextob):\n    """"""Process the transition tuple of the current step.\n\n    When training, add the current transition tuple to the memory and update\n    the streaming statistics for observations and rewards. A summary string is\n    returned if requested at this step.\n\n    Args:\n      agent_indices: Tensor containing current batch indices.\n      observ: Batch tensor of observations.\n      action: Batch tensor of actions.\n      reward: Batch tensor of rewards.\n      unused_done: Batch tensor of done flags.\n      unused_nextob: Batch tensor of successor observations.\n\n    Returns:\n      Summary tensor.\n    """"""\n    with tf.name_scope(\'experience/\'):\n      return tf.cond(\n          self._is_training,\n          # pylint: disable=g-long-lambda\n          lambda: self._define_experience(\n              agent_indices, observ, action, reward), str)\n\n  def _define_experience(self, agent_indices, observ, action, reward):\n    """"""Implement the branch of experience() entered during training.""""""\n    update_filters = tf.summary.merge([\n        self._observ_filter.update(observ),\n        self._reward_filter.update(reward)])\n    with tf.control_dependencies([update_filters]):\n      if self._config.train_on_agent_action:\n        # NOTE: Doesn\'t seem to change much.\n        action = self._last_action\n      policy = tools.nested.map(\n          lambda x: tf.gather(x, agent_indices), self._last_policy)\n      batch = (observ, action, policy, reward)\n      append = self._current_episodes.append(batch, agent_indices)\n    with tf.control_dependencies([append]):\n      norm_observ = self._observ_filter.transform(observ)\n      norm_reward = tf.reduce_mean(self._reward_filter.transform(reward))\n      # pylint: disable=g-long-lambda\n      summary = tf.cond(self._should_log, lambda: tf.summary.merge([\n          update_filters,\n          self._observ_filter.summary(),\n          self._reward_filter.summary(),\n          tf.summary.scalar(\'memory_size\', self._num_finished_episodes),\n          tf.summary.histogram(\'normalized_observ\', norm_observ),\n          tf.summary.histogram(\'action\', self._last_action),\n          tf.summary.scalar(\'normalized_reward\', norm_reward)]), str)\n      return summary\n\n  def end_episode(self, agent_indices):\n    """"""Add episodes to the memory and perform update steps if memory is full.\n\n    During training, add the collected episodes of the batch indices that\n    finished their episode to the memory. If the memory is full, train on it,\n    and then clear the memory. A summary string is returned if requested at\n    this step.\n\n    Args:\n      agent_indices: Tensor containing current batch indices.\n\n    Returns:\n       Summary tensor.\n    """"""\n    with tf.name_scope(\'end_episode/\'):\n      return tf.cond(\n          self._is_training,\n          lambda: self._define_end_episode(agent_indices), str)\n\n  def _initialize_policy(self):\n    """"""Initialize the policy.\n\n    Run the policy network on dummy data to initialize its parameters for later\n    reuse and to analyze the policy distribution. Initializes the attributes\n    `self._network` and `self._policy_type`.\n\n    Raises:\n      ValueError: Invalid policy distribution.\n\n    Returns:\n      Parameters of the policy distribution and policy state.\n    """"""\n    with tf.device(\'/gpu:0\' if self._use_gpu else \'/cpu:0\'):\n      network = functools.partial(\n          self._config.network, self._config, self._batch_env.action_space)\n      self._network = tf.make_template(\'network\', network)\n      output = self._network(\n          tf.zeros_like(self._batch_env.observ)[:, None],\n          tf.ones(len(self._batch_env)))\n    if output.policy.event_shape != self._batch_env.action.shape[1:]:\n      message = \'Policy event shape {} does not match action shape {}.\'\n      message = message.format(\n          output.policy.event_shape, self._batch_env.action.shape[1:])\n      raise ValueError(message)\n    self._policy_type = type(output.policy)\n    is_tensor = lambda x: isinstance(x, tf.Tensor)\n    policy_params = tools.nested.filter(is_tensor, output.policy.parameters)\n    set_batch_dim = lambda x: utility.set_dimension(x, 0, len(self._batch_env))\n    tools.nested.map(set_batch_dim, policy_params)\n    if output.state is not None:\n      tools.nested.map(set_batch_dim, output.state)\n    return policy_params, output.state\n\n  def _initialize_memory(self, policy_params):\n    """"""Initialize temporary and permanent memory.\n\n    Args:\n      policy_params: Nested tuple of policy parameters with all dimensions set.\n\n    Initializes the attributes `self._current_episodes`,\n    `self._finished_episodes`, and `self._num_finished_episodes`. The episodes\n    memory serves to collect multiple episodes in parallel. Finished episodes\n    are copied into the next free slot of the second memory. The memory index\n    points to the next free slot.\n    """"""\n    # We store observation, action, policy parameters, and reward.\n    template = (\n        self._batch_env.observ[0],\n        self._batch_env.action[0],\n        tools.nested.map(lambda x: x[0, 0], policy_params),\n        self._batch_env.reward[0])\n    with tf.variable_scope(\'ppo_temporary\'):\n      self._current_episodes = parts.EpisodeMemory(\n          template, len(self._batch_env), self._config.max_length, \'episodes\')\n    self._finished_episodes = parts.EpisodeMemory(\n        template, self._config.update_every, self._config.max_length, \'memory\')\n    self._num_finished_episodes = tf.Variable(0, False)\n\n  def _define_end_episode(self, agent_indices):\n    """"""Implement the branch of end_episode() entered during training.""""""\n    episodes, length = self._current_episodes.data(agent_indices)\n    space_left = self._config.update_every - self._num_finished_episodes\n    use_episodes = tf.range(tf.minimum(\n        tf.shape(agent_indices)[0], space_left))\n    episodes = tools.nested.map(lambda x: tf.gather(x, use_episodes), episodes)\n    append = self._finished_episodes.replace(\n        episodes, tf.gather(length, use_episodes),\n        use_episodes + self._num_finished_episodes)\n    with tf.control_dependencies([append]):\n      increment_index = self._num_finished_episodes.assign_add(\n          tf.shape(use_episodes)[0])\n    with tf.control_dependencies([increment_index]):\n      memory_full = self._num_finished_episodes >= self._config.update_every\n      return tf.cond(memory_full, self._training, str)\n\n  def _training(self):\n    """"""Perform multiple training iterations of both policy and value baseline.\n\n    Training on the episodes collected in the memory. Reset the memory\n    afterwards. Always returns a summary string.\n\n    Returns:\n      Summary tensor.\n    """"""\n    with tf.device(\'/gpu:0\' if self._use_gpu else \'/cpu:0\'):\n      with tf.name_scope(\'training\'):\n        assert_full = tf.assert_equal(\n            self._num_finished_episodes, self._config.update_every)\n        with tf.control_dependencies([assert_full]):\n          data = self._finished_episodes.data()\n        (observ, action, old_policy_params, reward), length = data\n        # We set padding frames of the parameters to ones to prevent Gaussians\n        # with zero variance. This would result in an infinite KL divergence,\n        # which, even if masked out, would result in NaN gradients.\n        old_policy_params = tools.nested.map(\n            lambda param: self._mask(param, length, 1), old_policy_params)\n        with tf.control_dependencies([tf.assert_greater(length, 0)]):\n          length = tf.identity(length)\n        observ = self._observ_filter.transform(observ)\n        reward = self._reward_filter.transform(reward)\n        update_summary = self._perform_update_steps(\n            observ, action, old_policy_params, reward, length)\n        with tf.control_dependencies([update_summary]):\n          penalty_summary = self._adjust_penalty(\n              observ, old_policy_params, length)\n        with tf.control_dependencies([penalty_summary]):\n          clear_memory = tf.group(\n              self._finished_episodes.clear(),\n              self._num_finished_episodes.assign(0))\n        with tf.control_dependencies([clear_memory]):\n          weight_summary = utility.variable_summaries(\n              tf.trainable_variables(), self._config.weight_summaries)\n          return tf.summary.merge([\n              update_summary, penalty_summary, weight_summary])\n\n  def _perform_update_steps(\n      self, observ, action, old_policy_params, reward, length):\n    """"""Perform multiple update steps of value function and policy.\n\n    The advantage is computed once at the beginning and shared across\n    iterations. We need to decide for the summary of one iteration, and thus\n    choose the one after half of the iterations.\n\n    Args:\n      observ: Sequences of observations.\n      action: Sequences of actions.\n      old_policy_params: Parameters of the behavioral policy.\n      reward: Sequences of rewards.\n      length: Batch of sequence lengths.\n\n    Returns:\n      Summary tensor.\n    """"""\n    return_ = utility.discounted_return(\n        reward, length, self._config.discount)\n    value = self._network(observ, length).value\n    if self._config.gae_lambda:\n      advantage = utility.lambda_advantage(\n          reward, value, length, self._config.discount,\n          self._config.gae_lambda)\n    else:\n      advantage = return_ - value\n    mean, variance = tf.nn.moments(advantage, axes=[0, 1], keep_dims=True)\n    advantage = (advantage - mean) / (tf.sqrt(variance) + 1e-8)\n    advantage = tf.Print(\n        advantage, [tf.reduce_mean(return_), tf.reduce_mean(value)],\n        \'return and value: \')\n    advantage = tf.Print(\n        advantage, [tf.reduce_mean(advantage)],\n        \'normalized advantage: \')\n    episodes = (observ, action, old_policy_params, reward, advantage)\n    value_loss, policy_loss, summary = parts.iterate_sequences(\n        self._update_step, [0., 0., \'\'], episodes, length,\n        self._config.chunk_length,\n        self._config.batch_size,\n        self._config.update_epochs,\n        padding_value=1)\n    print_losses = tf.group(\n        tf.Print(0, [tf.reduce_mean(value_loss)], \'value loss: \'),\n        tf.Print(0, [tf.reduce_mean(policy_loss)], \'policy loss: \'))\n    with tf.control_dependencies([value_loss, policy_loss, print_losses]):\n      return summary[self._config.update_epochs // 2]\n\n  def _update_step(self, sequence):\n    """"""Compute the current combined loss and perform a gradient update step.\n\n    The sequences must be a dict containing the keys `length` and `sequence`,\n    where the latter is a tuple containing observations, actions, parameters of\n    the behavioral policy, rewards, and advantages.\n\n    Args:\n      sequence: Sequences of episodes or chunks of episodes.\n\n    Returns:\n      Tuple of value loss, policy loss, and summary tensor.\n    """"""\n    observ, action, old_policy_params, reward, advantage = sequence[\'sequence\']\n    length = sequence[\'length\']\n    old_policy = self._policy_type(**old_policy_params)\n    value_loss, value_summary = self._value_loss(observ, reward, length)\n    network = self._network(observ, length)\n    policy_loss, policy_summary = self._policy_loss(\n        old_policy, network.policy, action, advantage, length)\n    network_loss = network.get(\'loss\', 0.0)\n    loss = policy_loss + value_loss + tf.reduce_mean(network_loss)\n    gradients, variables = (\n        zip(*self._optimizer.compute_gradients(loss)))\n    optimize = self._optimizer.apply_gradients(\n        zip(gradients, variables))\n    summary = tf.summary.merge([\n        value_summary, policy_summary,\n        tf.summary.histogram(\'network_loss\', network_loss),\n        tf.summary.scalar(\'avg_network_loss\', tf.reduce_mean(network_loss)),\n        tf.summary.scalar(\'gradient_norm\', tf.global_norm(gradients)),\n        utility.gradient_summaries(zip(gradients, variables))])\n    with tf.control_dependencies([optimize]):\n      return [tf.identity(x) for x in (value_loss, policy_loss, summary)]\n\n  def _value_loss(self, observ, reward, length):\n    """"""Compute the loss function for the value baseline.\n\n    The value loss is the difference between empirical and approximated returns\n    over the collected episodes. Returns the loss tensor and a summary strin.\n\n    Args:\n      observ: Sequences of observations.\n      reward: Sequences of reward.\n      length: Batch of sequence lengths.\n\n    Returns:\n      Tuple of loss tensor and summary tensor.\n    """"""\n    with tf.name_scope(\'value_loss\'):\n      value = self._network(observ, length).value\n      return_ = utility.discounted_return(\n          reward, length, self._config.discount)\n      advantage = return_ - value\n      value_loss = 0.5 * self._mask(advantage ** 2, length)\n      summary = tf.summary.merge([\n          tf.summary.histogram(\'value_loss\', value_loss),\n          tf.summary.scalar(\'avg_value_loss\', tf.reduce_mean(value_loss))])\n      value_loss = tf.reduce_mean(value_loss)\n      return tf.check_numerics(value_loss, \'value_loss\'), summary\n\n  def _policy_loss(\n      self, old_policy, policy, action, advantage, length):\n    """"""Compute the policy loss composed of multiple components.\n\n    1. The policy gradient loss is importance sampled from the data-collecting\n       policy at the beginning of training.\n    2. The second term is a KL penalty between the policy at the beginning of\n       training and the current policy.\n    3. Additionally, if this KL already changed more than twice the target\n       amount, we activate a strong penalty discouraging further divergence.\n\n    Args:\n      old_policy: Action distribution of the behavioral policy.\n      policy: Sequences of distribution params of the current policy.\n      action: Sequences of actions.\n      advantage: Sequences of advantages.\n      length: Batch of sequence lengths.\n\n    Returns:\n      Tuple of loss tensor and summary tensor.\n    """"""\n    with tf.name_scope(\'policy_loss\'):\n      kl = tf.contrib.distributions.kl_divergence(old_policy, policy)\n      # Infinite values in the KL, even for padding frames that we mask out,\n      # cause NaN gradients since TensorFlow computes gradients with respect to\n      # the whole input tensor.\n      kl = tf.check_numerics(kl, \'kl\')\n      kl = tf.reduce_mean(self._mask(kl, length), 1)\n      policy_gradient = tf.exp(\n          policy.log_prob(action) - old_policy.log_prob(action))\n      surrogate_loss = -tf.reduce_mean(self._mask(\n          policy_gradient * tf.stop_gradient(advantage), length), 1)\n      surrogate_loss = tf.check_numerics(surrogate_loss, \'surrogate_loss\')\n      kl_penalty = self._penalty * kl\n      cutoff_threshold = self._config.kl_target * self._config.kl_cutoff_factor\n      cutoff_count = tf.reduce_sum(\n          tf.cast(kl > cutoff_threshold, tf.int32))\n      with tf.control_dependencies([tf.cond(\n          cutoff_count > 0,\n          lambda: tf.Print(0, [cutoff_count], \'kl cutoff! \'), int)]):\n        kl_cutoff = (\n            self._config.kl_cutoff_coef *\n            tf.cast(kl > cutoff_threshold, tf.float32) *\n            (kl - cutoff_threshold) ** 2)\n      policy_loss = surrogate_loss + kl_penalty + kl_cutoff\n      entropy = tf.reduce_mean(policy.entropy(), axis=1)\n      if self._config.entropy_regularization:\n        policy_loss -= self._config.entropy_regularization * entropy\n      summary = tf.summary.merge([\n          tf.summary.histogram(\'entropy\', entropy),\n          tf.summary.histogram(\'kl\', kl),\n          tf.summary.histogram(\'surrogate_loss\', surrogate_loss),\n          tf.summary.histogram(\'kl_penalty\', kl_penalty),\n          tf.summary.histogram(\'kl_cutoff\', kl_cutoff),\n          tf.summary.histogram(\'kl_penalty_combined\', kl_penalty + kl_cutoff),\n          tf.summary.histogram(\'policy_loss\', policy_loss),\n          tf.summary.scalar(\'avg_surr_loss\', tf.reduce_mean(surrogate_loss)),\n          tf.summary.scalar(\'avg_kl_penalty\', tf.reduce_mean(kl_penalty)),\n          tf.summary.scalar(\'avg_policy_loss\', tf.reduce_mean(policy_loss))])\n      policy_loss = tf.reduce_mean(policy_loss, 0)\n      return tf.check_numerics(policy_loss, \'policy_loss\'), summary\n\n  def _adjust_penalty(self, observ, old_policy_params, length):\n    """"""Adjust the KL policy between the behavioral and current policy.\n\n    Compute how much the policy actually changed during the multiple\n    update steps. Adjust the penalty strength for the next training phase if we\n    overshot or undershot the target divergence too much.\n\n    Args:\n      observ: Sequences of observations.\n      old_policy_params: Parameters of the behavioral policy.\n      length: Batch of sequence lengths.\n\n    Returns:\n      Summary tensor.\n    """"""\n    old_policy = self._policy_type(**old_policy_params)\n    with tf.name_scope(\'adjust_penalty\'):\n      network = self._network(observ, length)\n      print_penalty = tf.Print(0, [self._penalty], \'current penalty: \')\n      with tf.control_dependencies([print_penalty]):\n        kl_change = tf.reduce_mean(self._mask(\n            tf.contrib.distributions.kl_divergence(old_policy, network.policy),\n            length))\n        kl_change = tf.Print(kl_change, [kl_change], \'kl change: \')\n        maybe_increase = tf.cond(\n            kl_change > 1.3 * self._config.kl_target,\n            # pylint: disable=g-long-lambda\n            lambda: tf.Print(self._penalty.assign(\n                self._penalty * 1.5), [0], \'increase penalty \'),\n            float)\n        maybe_decrease = tf.cond(\n            kl_change < 0.7 * self._config.kl_target,\n            # pylint: disable=g-long-lambda\n            lambda: tf.Print(self._penalty.assign(\n                self._penalty / 1.5), [0], \'decrease penalty \'),\n            float)\n      with tf.control_dependencies([maybe_increase, maybe_decrease]):\n        return tf.summary.merge([\n            tf.summary.scalar(\'kl_change\', kl_change),\n            tf.summary.scalar(\'penalty\', self._penalty)])\n\n  def _mask(self, tensor, length, padding_value=0):\n    """"""Set padding elements of a batch of sequences to a constant.\n\n    Useful for setting padding elements to zero before summing along the time\n    dimension, or for preventing infinite results in padding elements.\n\n    Args:\n      tensor: Tensor of sequences.\n      length: Batch of sequence lengths.\n      padding_value: Value to write into padding elements.\n\n    Returns:\n      Masked sequences.\n    """"""\n    with tf.name_scope(\'mask\'):\n      range_ = tf.range(tensor.shape[1].value)\n      mask = range_[None, :] < length[:, None]\n      if tensor.shape.ndims > 2:\n        for _ in range(tensor.shape.ndims - 2):\n          mask = mask[..., None]\n        mask = tf.tile(mask, [1, 1] + tensor.shape[2:].as_list())\n      masked = tf.where(mask, tensor, padding_value * tf.ones_like(tensor))\n      return tf.check_numerics(masked, \'masked\')\n'"
agents/algorithms/ppo/utility.py,44,"b'# Copyright 2017 The TensorFlow Agents Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Utilities for the PPO algorithm.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport re\n\nimport tensorflow as tf\nfrom tensorflow.python.client import device_lib\n\n\ndef reinit_nested_vars(variables, indices=None):\n  """"""Reset all variables in a nested tuple to zeros.\n\n  Args:\n    variables: Nested tuple or list of variables.\n    indices: Batch indices to reset, defaults to all.\n\n  Returns:\n    Operation.\n  """"""\n  if isinstance(variables, (tuple, list)):\n    return tf.group(*[\n        reinit_nested_vars(variable, indices) for variable in variables])\n  if indices is None:\n    return variables.assign(tf.zeros_like(variables))\n  else:\n    zeros = tf.zeros([tf.shape(indices)[0]] + variables.shape[1:].as_list())\n    return tf.scatter_update(variables, indices, zeros)\n\n\ndef assign_nested_vars(variables, tensors, indices=None):\n  """"""Assign tensors to matching nested tuple of variables.\n\n  Args:\n    variables: Nested tuple or list of variables to update.\n    tensors: Nested tuple or list of tensors to assign.\n    indices: Batch indices to assign to; default to all.\n\n  Returns:\n    Operation.\n  """"""\n  if isinstance(variables, (tuple, list)):\n    return tf.group(*[\n        assign_nested_vars(variable, tensor)\n        for variable, tensor in zip(variables, tensors)])\n  if indices is None:\n    return variables.assign(tensors)\n  else:\n    return tf.scatter_update(variables, indices, tensors)\n\n\ndef discounted_return(reward, length, discount):\n  """"""Discounted Monte-Carlo returns.""""""\n  timestep = tf.range(reward.shape[1].value)\n  mask = tf.cast(timestep[None, :] < length[:, None], tf.float32)\n  return_ = tf.reverse(tf.transpose(tf.scan(\n      lambda agg, cur: cur + discount * agg,\n      tf.transpose(tf.reverse(mask * reward, [1]), [1, 0]),\n      tf.zeros_like(reward[:, -1]), 1, False), [1, 0]), [1])\n  return tf.check_numerics(tf.stop_gradient(return_), \'return\')\n\n\ndef fixed_step_return(reward, value, length, discount, window):\n  """"""N-step discounted return.""""""\n  timestep = tf.range(reward.shape[1].value)\n  mask = tf.cast(timestep[None, :] < length[:, None], tf.float32)\n  return_ = tf.zeros_like(reward)\n  for _ in range(window):\n    return_ += reward\n    reward = discount * tf.concat(\n        [reward[:, 1:], tf.zeros_like(reward[:, -1:])], 1)\n  return_ += discount ** window * tf.concat(\n      [value[:, window:], tf.zeros_like(value[:, -window:])], 1)\n  return tf.check_numerics(tf.stop_gradient(mask * return_), \'return\')\n\n\ndef lambda_return(reward, value, length, discount, lambda_):\n  """"""TD-lambda returns.""""""\n  timestep = tf.range(reward.shape[1].value)\n  mask = tf.cast(timestep[None, :] < length[:, None], tf.float32)\n  sequence = mask * reward + discount * value * (1 - lambda_)\n  discount = mask * discount * lambda_\n  sequence = tf.stack([sequence, discount], 2)\n  return_ = tf.reverse(tf.transpose(tf.scan(\n      lambda agg, cur: cur[0] + cur[1] * agg,\n      tf.transpose(tf.reverse(sequence, [1]), [1, 2, 0]),\n      tf.zeros_like(value[:, -1]), 1, False), [1, 0]), [1])\n  return tf.check_numerics(tf.stop_gradient(return_), \'return\')\n\n\ndef lambda_advantage(reward, value, length, discount, gae_lambda):\n  """"""Generalized Advantage Estimation.""""""\n  timestep = tf.range(reward.shape[1].value)\n  mask = tf.cast(timestep[None, :] < length[:, None], tf.float32)\n  next_value = tf.concat([value[:, 1:], tf.zeros_like(value[:, -1:])], 1)\n  delta = reward + discount * next_value - value\n  advantage = tf.reverse(tf.transpose(tf.scan(\n      lambda agg, cur: cur + gae_lambda * discount * agg,\n      tf.transpose(tf.reverse(mask * delta, [1]), [1, 0]),\n      tf.zeros_like(delta[:, -1]), 1, False), [1, 0]), [1])\n  return tf.check_numerics(tf.stop_gradient(advantage), \'advantage\')\n\n\ndef available_gpus():\n  """"""List of GPU device names detected by TensorFlow.""""""\n  local_device_protos = device_lib.list_local_devices()\n  return [x.name for x in local_device_protos if x.device_type == \'GPU\']\n\n\ndef gradient_summaries(grad_vars, groups=None, scope=\'gradients\'):\n  """"""Create histogram summaries of the gradient.\n\n  Summaries can be grouped via regexes matching variables names.\n\n  Args:\n    grad_vars: List of (gradient, variable) tuples as returned by optimizers.\n    groups: Mapping of name to regex for grouping summaries.\n    scope: Name scope for this operation.\n\n  Returns:\n    Summary tensor.\n  """"""\n  groups = groups or {r\'all\': r\'.*\'}\n  grouped = collections.defaultdict(list)\n  for grad, var in grad_vars:\n    if grad is None:\n      continue\n    for name, pattern in groups.items():\n      if re.match(pattern, var.name):\n        name = re.sub(pattern, name, var.name)\n        grouped[name].append(grad)\n  for name in groups:\n    if name not in grouped:\n      tf.logging.warn(""No variables matching \'{}\' group."".format(name))\n  summaries = []\n  for name, grads in grouped.items():\n    grads = [tf.reshape(grad, [-1]) for grad in grads]\n    grads = tf.concat(grads, 0)\n    summaries.append(tf.summary.histogram(scope + \'/\' + name, grads))\n  return tf.summary.merge(summaries)\n\n\ndef variable_summaries(vars_, groups=None, scope=\'weights\'):\n  """"""Create histogram summaries for the provided variables.\n\n  Summaries can be grouped via regexes matching variables names.\n\n  Args:\n    vars_: List of variables to summarize.\n    groups: Mapping of name to regex for grouping summaries.\n    scope: Name scope for this operation.\n\n  Returns:\n    Summary tensor.\n  """"""\n  groups = groups or {r\'all\': r\'.*\'}\n  grouped = collections.defaultdict(list)\n  for var in vars_:\n    for name, pattern in groups.items():\n      if re.match(pattern, var.name):\n        name = re.sub(pattern, name, var.name)\n        grouped[name].append(var)\n  for name in groups:\n    if name not in grouped:\n      tf.logging.warn(""No variables matching \'{}\' group."".format(name))\n  summaries = []\n  # pylint: disable=redefined-argument-from-local\n  for name, vars_ in grouped.items():\n    vars_ = [tf.reshape(var, [-1]) for var in vars_]\n    vars_ = tf.concat(vars_, 0)\n    summaries.append(tf.summary.histogram(scope + \'/\' + name, vars_))\n  return tf.summary.merge(summaries)\n\n\ndef set_dimension(tensor, axis, value):\n  """"""Set the length of a tensor along the specified dimension.\n\n  Args:\n    tensor: Tensor to define shape of.\n    axis: Dimension to set the static shape for.\n    value: Integer holding the length.\n\n  Raises:\n    ValueError: When the tensor already has a different length specified.\n  """"""\n  shape = tensor.shape.as_list()\n  if shape[axis] not in (value, None):\n    message = \'Cannot set dimension {} of tensor {} to {}; is already {}.\'\n    raise ValueError(message.format(axis, tensor.name, value, shape[axis]))\n  shape[axis] = value\n  tensor.set_shape(shape)\n'"
