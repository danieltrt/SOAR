file_path,api_count,code
setup.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Setup script for gin-config.\n\nSee https://github.com/google/gin-config for documentation.\n""""""\n\nfrom os import path\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n_VERSION = \'0.4.0\'\n\nhere = path.abspath(path.dirname(__file__))\n\nlong_description = """"""\n# Gin\n\nGin provides a lightweight configuration framework for Python, based on\ndependency injection. Functions or classes can be decorated with\n`@gin.configurable`, allowing default parameter values to be supplied from a\nconfig file (or passed via the command line) using a simple but powerful syntax.\nThis removes the need to define and maintain configuration objects (e.g.\nprotos), or write boilerplate parameter plumbing and factory code, while often\ndramatically expanding a project\'s flexibility and configurability.\n\nGin is particularly well suited for machine learning experiments (e.g. using\nTensorFlow), which tend to have many parameters, often nested in complex ways.\n\n\n**Authors**: Dan Holtmann-Rice, Sergio Guadarrama, Nathan Silberman\n**Contributors**: Oscar Ramirez, Marek Fiser\n""""""\n\ninstall_requires = [\'six >= 1.10.0\']\n\nsetup(\n    name=\'gin-config\',\n    version=_VERSION,\n    include_package_data=True,\n    packages=find_packages(exclude=[\'docs\']),  # Required\n    package_data={\'testdata\': [\'testdata/*.gin\']},\n    install_requires=install_requires,\n    extras_require={  # Optional\n        \':python_version<""3""\': [\'enum34\'],\n        \'tensorflow\': [\'tensorflow >= 1.13.0\'],\n        \'tensorflow-gpu\': [\'tensorflow-gpu >= 1.13.0\'],\n        \'tf-nightly\': [\'tf-nightly\'],\n        \'torch\': [\'torch >= 1.3.0\'],\n        \'pytorch-nightly\': [\'pytorch-nightly\'],\n        \'testing\': [\n            \'six >= 1.10.0\',\n            \'absl-py >= 0.1.6\',\n            \'mock >= 3.0.5\',\n            \'nose\',\n        ]\n    },\n    description=\'Gin-Config: A lightweight configuration library for Python\',\n    long_description=long_description,\n    long_description_content_type=\'text/markdown\',\n    url=\'https://github.com/google/gin-config\',  # Optional\n    author=\'The Gin-Config Team\',  # Optional\n    classifiers=[  # Optional\n        \'Development Status :: 3 - Alpha\',\n\n        # Indicate who your project is intended for\n        \'Intended Audience :: Developers\',\n        \'Intended Audience :: Education\',\n        \'Intended Audience :: Science/Research\',\n\n        # Pick your license as you wish\n        \'License :: OSI Approved :: Apache Software License\',\n\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n        \'Programming Language :: Python :: 2\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: 3\',\n        \'Programming Language :: Python :: 3.5\',\n        \'Programming Language :: Python :: 3.6\',\n        \'Programming Language :: Python :: 3.7\',\n\n        \'Topic :: Scientific/Engineering\',\n        \'Topic :: Scientific/Engineering :: Mathematics\',\n        \'Topic :: Scientific/Engineering :: Artificial Intelligence\',\n        \'Topic :: Software Development\',\n        \'Topic :: Software Development :: Libraries\',\n        \'Topic :: Software Development :: Libraries :: Python Modules\',\n    ],\n    project_urls={  # Optional\n        \'Documentation\': \'https://github.com/google/gin-config/docs\',\n        \'Bug Reports\': \'https://github.com/google/gin-config/issues\',\n        \'Source\': \'https://github.com/google/gin-config\',\n    },\n    license=\'Apache 2.0\',\n    keywords=\'gin-config gin python configuration machine learning\'\n)\n'"
gin/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Init file for Gin.""""""\nfrom gin.config import add_config_file_search_path\nfrom gin.config import bind_parameter\nfrom gin.config import clear_config\nfrom gin.config import config_is_locked\nfrom gin.config import config_scope\nfrom gin.config import config_str\nfrom gin.config import configurable\nfrom gin.config import constant\nfrom gin.config import constants_from_enum\nfrom gin.config import current_scope\nfrom gin.config import current_scope_str\nfrom gin.config import enter_interactive_mode\nfrom gin.config import exit_interactive_mode\nfrom gin.config import external_configurable\nfrom gin.config import finalize\nfrom gin.config import operative_config_str\nfrom gin.config import parse_config\nfrom gin.config import parse_config_file\nfrom gin.config import parse_config_files_and_bindings\nfrom gin.config import query_parameter\nfrom gin.config import register\nfrom gin.config import REQUIRED\nfrom gin.config import unlock_config\n\n'"
gin/config.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# -*- coding: UTF-8 -*-\n""""""Defines the Gin configuration framework.\n\nPrograms frequently have a number of ""hyperparameters"" that require variation\nacross different executions of the program. When the number of such parameters\ngrows even moderately large, or use of some parameter is deeply embedded in the\ncode, top-level flags become very cumbersome. This module provides an\nalternative mechanism for setting such hyperparameters, by allowing injection of\nparameter values for any function marked as ""configurable"".\n\nFor detailed documentation, please see the user guide:\n\nhttps://github.com/google/gin-config/tree/master/docs/index.md\n\n# Making functions and classes configurable\n\nFunctions and classes can be marked configurable using the `@configurable`\ndecorator, which associates a ""configurable name"" with the function or class (by\ndefault, just the function or class name). Optionally, parameters can be\nwhitelisted or blacklisted to mark only a subset of the function\'s parameters as\nconfigurable. Once parameters have been bound (see below) to this function, any\nsubsequent calls will have those parameters automatically supplied by Gin.\n\nIf an argument supplied to a function by its caller (either as a positional\nargument or as a keyword argument) corresponds to a parameter configured by Gin,\nthe caller\'s value will take precedence.\n\n# A short example\n\nPython code:\n\n    @gin.configurable\n    def mix_cocktail(ingredients):\n      ...\n\n    @gin.configurable\n    def serve_random_cocktail(available_cocktails):\n      ...\n\n    @gin.configurable\n    def drink(cocktail):\n      ...\n\nGin configuration:\n\n    martini/mix_cocktail.ingredients = [\'gin\', \'vermouth\', \'twist of lemon\']\n    gin_and_tonic/mix_cocktail.ingredients = [\'gin\', \'tonic water\']\n\n    serve_random_cocktail.available_cocktails = {\n        \'martini\': @martini/mix_cocktail,\n        \'gin_and_tonic\': @gin_and_tonic/mix_cocktail,\n    }\n\n    drink.cocktail = @serve_random_cocktail()\n\nIn the above example, there are three configurable functions: `mix_cocktail`\n(with a parameter `ingredients`), `serve_random_cocktail` (with parameter\n`available_cocktails`), and `drink` (with parameter `cocktail`).\n\nWhen `serve_random_cocktail` is called, it will receive a dictionary\ncontaining two scoped *references* to the `mix_cocktail` function (each scope\nproviding unique parameters, meaning calling the different references will\npresumably produce different outputs).\n\nOn the other hand, when the `drink` function is called, it will receive the\n*output* of calling `serve_random_cocktail` as the value of its `cocktail`\nparameter, due to the trailing `()` in `@serve_random_cocktail()`.\n""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import google_type_annotations\nfrom __future__ import print_function\n\nimport collections\nimport contextlib\nimport copy\nimport enum\nimport functools\nimport inspect\nimport logging\nimport os\nimport pprint\nimport sys\nimport threading\nimport traceback\nfrom typing import Optional, Sequence\n\nfrom gin import config_parser\nfrom gin import selector_map\nfrom gin import utils\n\nimport six\n\n\nclass _ScopeManager(threading.local):\n  """"""Manages currently active config scopes.\n\n  This ensures thread safety of config scope management by subclassing\n  `threading.local`. Scopes are tracked as a stack, where elements in the\n  stack are lists of the currently active scope names.\n  """"""\n\n  def _maybe_init(self):\n    if not hasattr(self, \'_active_scopes\'):\n      self._active_scopes = [[]]\n\n  @property\n  def active_scopes(self):\n    self._maybe_init()\n    return self._active_scopes[:]\n\n  @property\n  def current_scope(self):\n    self._maybe_init()\n    return self._active_scopes[-1][:]  # Slice to get copy.\n\n  def enter_scope(self, scope):\n    """"""Enters the given scope, updating the list of active scopes.\n\n    Args:\n      scope: A list of active scope names, ordered from outermost to innermost.\n    """"""\n    self._maybe_init()\n    self._active_scopes.append(scope)\n\n  def exit_scope(self):\n    """"""Exits the most recently entered scope.""""""\n    self._maybe_init()\n    self._active_scopes.pop()\n\n\n# Maintains the registry of configurable functions and classes.\n_REGISTRY = selector_map.SelectorMap()\n\n# Maps tuples of `(scope, selector)` to associated parameter values. This\n# specifies the current global ""configuration"" set through `bind_parameter` or\n# `parse_config`, but doesn\'t include any functions\' default argument values.\n_CONFIG = {}\n\n# Keeps a set of module names that were dynamically imported via config files.\n_IMPORTED_MODULES = set()\n\n# Maps `(scope, selector)` tuples to all configurable parameter values used\n# during program execution (including default argument values).\n_OPERATIVE_CONFIG = {}\n_OPERATIVE_CONFIG_LOCK = threading.Lock()\n\n# Keeps track of currently active config scopes.\n_SCOPE_MANAGER = _ScopeManager()\n\n# Keeps track of hooks to run when the Gin config is finalized.\n_FINALIZE_HOOKS = []\n# Keeps track of whether the config is locked.\n_CONFIG_IS_LOCKED = False\n# Keeps track of whether ""interactive mode"" is enabled, in which case redefining\n# a configurable is not an error.\n_INTERACTIVE_MODE = False\n\n# Keeps track of constants created via gin.constant, to both prevent duplicate\n# definitions and to avoid writing them to the operative config.\n_CONSTANTS = selector_map.SelectorMap()\n\n# Keeps track of singletons created via the singleton configurable.\n_SINGLETONS = {}\n\n# Keeps track of file readers. These are functions that behave like Python\'s\n# `open` function (can be used a context manager) and will be used to load\n# config files. Each element of this list should be a tuple of `(function,\n# exception_type)`, where `exception_type` is the type of exception thrown by\n# `function` when a file can\'t be opened/read successfully.\n_FILE_READERS = [(open, os.path.isfile)]\n\n# Maintains a cache of argspecs for functions.\n_ARG_SPEC_CACHE = {}\n\n# List of location prefixes. Similar to PATH var in unix to be used to search\n# for files with those prefixes.\n_LOCATION_PREFIXES = [\'\']\n\n# Value to represent required parameters.\nREQUIRED = object()\n\n\ndef _find_class_construction_fn(cls):\n  """"""Find the first __init__ or __new__ method in the given class\'s MRO.""""""\n  for base in type.mro(cls):\n    if \'__init__\' in base.__dict__:\n      return base.__init__\n    if \'__new__\' in base.__dict__:\n      return base.__new__\n\n\ndef _ensure_wrappability(fn):\n  """"""Make sure `fn` can be wrapped cleanly by functools.wraps.""""""\n  # Handle ""builtin_function_or_method"", ""wrapped_descriptor"", and\n  # ""method-wrapper"" types.\n  unwrappable_types = (type(sum), type(object.__init__), type(object.__call__))\n  if isinstance(fn, unwrappable_types):\n    # pylint: disable=unnecessary-lambda\n    wrappable_fn = lambda *args, **kwargs: fn(*args, **kwargs)\n    wrappable_fn.__name__ = fn.__name__\n    wrappable_fn.__doc__ = fn.__doc__\n    wrappable_fn.__module__ = \'\'  # These types have no __module__, sigh.\n    wrappable_fn.__wrapped__ = fn\n    return wrappable_fn\n\n  # Otherwise we\'re good to go...\n  return fn\n\n\ndef _decorate_fn_or_cls(decorator, fn_or_cls, subclass=False):\n  """"""Decorate a function or class with the given decorator.\n\n  When `fn_or_cls` is a function, applies `decorator` to the function and\n  returns the (decorated) result.\n\n  When `fn_or_cls` is a class and the `subclass` parameter is `False`, this will\n  replace `fn_or_cls.__init__` with the result of applying `decorator` to it.\n\n  When `fn_or_cls` is a class and `subclass` is `True`, this will subclass the\n  class, but with `__init__` defined to be the result of applying `decorator` to\n  `fn_or_cls.__init__`. The decorated class has metadata (docstring, name, and\n  module information) copied over from `fn_or_cls`. The goal is to provide a\n  decorated class the behaves as much like the original as possible, without\n  modifying it (for example, inspection operations using `isinstance` or\n  `issubclass` should behave the same way as on the original class).\n\n  Args:\n    decorator: The decorator to use.\n    fn_or_cls: The function or class to decorate.\n    subclass: Whether to decorate classes by subclassing. This argument is\n      ignored if `fn_or_cls` is not a class.\n\n  Returns:\n    The decorated function or class.\n  """"""\n  if not inspect.isclass(fn_or_cls):\n    return decorator(_ensure_wrappability(fn_or_cls))\n\n  construction_fn = _find_class_construction_fn(fn_or_cls)\n\n  if subclass:\n\n    class DecoratedClass(fn_or_cls):\n      __doc__ = fn_or_cls.__doc__\n      __module__ = fn_or_cls.__module__\n\n    DecoratedClass.__name__ = fn_or_cls.__name__\n    if six.PY3:\n      DecoratedClass.__qualname__ = fn_or_cls.__qualname__\n    cls = DecoratedClass\n  else:\n    cls = fn_or_cls\n\n  decorated_fn = decorator(_ensure_wrappability(construction_fn))\n  if construction_fn.__name__ == \'__new__\':\n    decorated_fn = staticmethod(decorated_fn)\n  setattr(cls, construction_fn.__name__, decorated_fn)\n  return cls\n\n\nclass Configurable(\n    collections.namedtuple(\n        \'Configurable\',\n        [\'fn_or_cls\', \'name\', \'module\', \'whitelist\', \'blacklist\', \'selector\'])):\n  pass\n\n\ndef _raise_unknown_reference_error(ref, additional_msg=\'\'):\n  err_str = ""No configurable matching reference \'@{}{}\'.{}""\n  maybe_parens = \'()\' if ref.evaluate else \'\'\n  raise ValueError(err_str.format(ref.selector, maybe_parens, additional_msg))\n\n\nclass ConfigurableReference(object):\n  """"""Represents a reference to a configurable function or class.""""""\n\n  def __init__(self, scoped_selector, evaluate):\n    self._scoped_selector = scoped_selector\n    self._evaluate = evaluate\n\n    scoped_selector_parts = self._scoped_selector.split(\'/\')\n    self._scopes = scoped_selector_parts[:-1]\n    self._selector = scoped_selector_parts[-1]\n    self._configurable = _REGISTRY.get_match(self._selector)\n    if not self._configurable:\n      _raise_unknown_reference_error(self)\n\n    def reference_decorator(fn):\n      if self._scopes:\n\n        @six.wraps(fn)\n        def scoping_wrapper(*args, **kwargs):\n          with config_scope(self._scopes):\n            return fn(*args, **kwargs)\n\n        return scoping_wrapper\n      return fn\n\n    self._scoped_configurable_fn = _decorate_fn_or_cls(\n        reference_decorator, self.configurable.fn_or_cls, True)\n\n  @property\n  def configurable(self):\n    return self._configurable\n\n  @property\n  def scoped_configurable_fn(self):\n    return self._scoped_configurable_fn\n\n  @property\n  def scopes(self):\n    return self._scopes\n\n  @property\n  def selector(self):\n    return self._selector\n\n  @property\n  def scoped_selector(self):\n    return self._scoped_selector\n\n  @property\n  def config_key(self):\n    return (\'/\'.join(self._scopes), self._configurable.selector)\n\n  @property\n  def evaluate(self):\n    return self._evaluate\n\n  def __eq__(self, other):\n    if isinstance(other, self.__class__):\n      # pylint: disable=protected-access\n      return (self._configurable == other._configurable and\n              self._evaluate == other._evaluate)\n      # pylint: enable=protected-access\n    return False\n\n  def __ne__(self, other):\n    return not self.__eq__(other)\n\n  def __hash__(self):\n    return hash(repr(self))\n\n  def __repr__(self):\n    # Check if this reference is a macro or constant, i.e. @.../macro() or\n    # @.../constant(). Only macros and constants correspond to the %... syntax.\n    configurable_fn = self._configurable.fn_or_cls\n    if configurable_fn in (macro, _retrieve_constant) and self._evaluate:\n      return \'%\' + \'/\'.join(self._scopes)\n    maybe_parens = \'()\' if self._evaluate else \'\'\n    return \'@{}{}\'.format(self._scoped_selector, maybe_parens)\n\n  def __deepcopy__(self, memo):\n    """"""Dishonestly implements the __deepcopy__ special method.\n\n    When called, this returns either the `ConfigurableReference` instance itself\n    (when `self._evaluate` is `False`) or the result of calling the underlying\n    configurable. Configurable references may be deeply nested inside other\n    Python data structures, and by providing this implementation,\n    `copy.deepcopy` can be used on the containing Python structure to return a\n    copy replacing any `ConfigurableReference` marked for evaluation with its\n    corresponding configurable\'s output.\n\n    Args:\n      memo: The memoization dict (unused).\n\n    Returns:\n      When `self._evaluate` is `False`, returns the underlying configurable\n      (maybe wrapped to be called in the proper scope). When `self._evaluate` is\n      `True`, returns the output of calling the underlying configurable.\n    """"""\n    if self._evaluate:\n      return self._scoped_configurable_fn()\n    return self._scoped_configurable_fn\n\n\nclass _UnknownConfigurableReference(object):\n  """"""Represents a reference to an unknown configurable.\n\n  This class acts as a substitute for `ConfigurableReference` when the selector\n  doesn\'t match any known configurable.\n  """"""\n\n  def __init__(self, selector, evaluate):\n    self._selector = selector.split(\'/\')[-1]\n    self._evaluate = evaluate\n\n  @property\n  def selector(self):\n    return self._selector\n\n  @property\n  def evaluate(self):\n    return self._evaluate\n\n  def __deepcopy__(self, memo):\n    """"""Dishonestly implements the __deepcopy__ special method.\n\n    See `ConfigurableReference` above. If this method is called, it means there\n    was an attempt to use this unknown configurable reference, so we throw an\n    error here.\n\n    Args:\n      memo: The memoization dict (unused).\n\n    Raises:\n      ValueError: To report that there is no matching configurable.\n    """"""\n    addl_msg = \'\\n\\n    To catch this earlier, ensure gin.finalize() is called.\'\n    _raise_unknown_reference_error(self, addl_msg)\n\n\ndef _validate_skip_unknown(skip_unknown):\n  if not isinstance(skip_unknown, (bool, list, tuple, set)):\n    err_str = \'Invalid value for `skip_unknown`: {}\'\n    raise ValueError(err_str.format(skip_unknown))\n\n\ndef _should_skip(selector, skip_unknown):\n  """"""Checks whether `selector` should be skipped (if unknown).""""""\n  _validate_skip_unknown(skip_unknown)\n  if _REGISTRY.matching_selectors(selector):\n    return False  # Never skip known configurables.\n  if isinstance(skip_unknown, (list, tuple, set)):\n    return selector in skip_unknown\n  return skip_unknown  # Must be a bool by validation check.\n\n\nclass ParserDelegate(config_parser.ParserDelegate):\n  """"""Delegate to handle creation of configurable references and macros.""""""\n\n  def __init__(self, skip_unknown=False):\n    self._skip_unknown = skip_unknown\n\n  def configurable_reference(self, scoped_selector, evaluate):\n    unscoped_selector = scoped_selector.rsplit(\'/\', 1)[-1]\n    if _should_skip(unscoped_selector, self._skip_unknown):\n      return _UnknownConfigurableReference(scoped_selector, evaluate)\n    return ConfigurableReference(scoped_selector, evaluate)\n\n  def macro(self, name):\n    matching_selectors = _CONSTANTS.matching_selectors(name)\n    if matching_selectors:\n      if len(matching_selectors) == 1:\n        name = matching_selectors[0]\n        return ConfigurableReference(name + \'/gin.constant\', True)\n      err_str = ""Ambiguous constant selector \'{}\', matches {}.""\n      raise ValueError(err_str.format(name, matching_selectors))\n    return ConfigurableReference(name + \'/gin.macro\', True)\n\n\nclass ParsedBindingKey(\n    collections.namedtuple(\n        \'ParsedBindingKey\',\n        [\'scope\', \'given_selector\', \'complete_selector\', \'arg_name\'])):\n  """"""Represents a parsed and validated binding key.\n\n  A ""binding key"" identifies a specific parameter (`arg_name`), of a specific\n  configurable (`complete_selector`), in a specific scope (`scope`), to which a\n  value may be bound in the global configuration. The `given_selector` field\n  retains information about how the original configurable selector was\n  specified, which can be helpful for error messages (but is ignored for the\n  purposes of equality and hashing).\n  """"""\n\n  def __new__(cls, binding_key):\n    """"""Parses and validates the given binding key.\n\n    This function will parse `binding_key` (if necessary), and ensure that the\n    specified parameter can be bound for the given configurable selector (i.e.,\n    that the parameter isn\'t blacklisted or not whitelisted if a whitelist was\n    provided).\n\n    Args:\n      binding_key: A spec identifying a parameter of a configurable (maybe in\n        some scope). This should either be a string of the form\n        \'maybe/some/scope/maybe.modules.configurable_name.parameter_name\'; or a\n        list or tuple of `(scope, selector, arg_name)`; or another instance of\n        `ParsedBindingKey`.\n\n    Returns:\n      A new instance of `ParsedBindingKey`.\n\n    Raises:\n      ValueError: If no function can be found matching the configurable name\n        specified by `binding_key`, or if the specified parameter name is\n        blacklisted or not in the function\'s whitelist (if present).\n    """"""\n    if isinstance(binding_key, ParsedBindingKey):\n      return super(ParsedBindingKey, cls).__new__(cls, *binding_key)\n\n    if isinstance(binding_key, (list, tuple)):\n      scope, selector, arg_name = binding_key\n    elif isinstance(binding_key, six.string_types):\n      scope, selector, arg_name = config_parser.parse_binding_key(binding_key)\n    else:\n      err_str = \'Invalid type for binding_key: {}.\'\n      raise ValueError(err_str.format(type(binding_key)))\n\n    configurable_ = _REGISTRY.get_match(selector)\n    if not configurable_:\n      raise ValueError(""No configurable matching \'{}\'."".format(selector))\n\n    if not _might_have_parameter(configurable_.fn_or_cls, arg_name):\n      err_str = ""Configurable \'{}\' doesn\'t have a parameter named \'{}\'.""\n      raise ValueError(err_str.format(selector, arg_name))\n\n    if configurable_.whitelist and arg_name not in configurable_.whitelist:\n      err_str = ""Configurable \'{}\' doesn\'t include kwarg \'{}\' in its whitelist.""\n      raise ValueError(err_str.format(selector, arg_name))\n\n    if configurable_.blacklist and arg_name in configurable_.blacklist:\n      err_str = ""Configurable \'{}\' has blacklisted kwarg \'{}\'.""\n      raise ValueError(err_str.format(selector, arg_name))\n\n    return super(ParsedBindingKey, cls).__new__(\n        cls,\n        scope=scope,\n        given_selector=selector,\n        complete_selector=configurable_.selector,\n        arg_name=arg_name)\n\n  @property\n  def config_key(self):\n    return self.scope, self.complete_selector\n\n  @property\n  def scope_selector_arg(self):\n    return self.scope, self.complete_selector, self.arg_name\n\n  def __equal__(self, other):\n    # Equality ignores the `given_selector` field, since two binding keys should\n    # be equal whenever they identify the same parameter.\n    return self.scope_selector_arg == other.scope_selector_arg\n\n  def __hash__(self):\n    return hash(self.scope_selector_arg)\n\n\ndef _format_value(value):\n  """"""Returns `value` in a format parseable by `parse_value`, or `None`.\n\n  Simply put, This function ensures that when it returns a string value, the\n  following will hold:\n\n      parse_value(_format_value(value)) == value\n\n  Args:\n    value: The value to format.\n\n  Returns:\n    A string representation of `value` when `value` is literally representable,\n    or `None`.\n  """"""\n  literal = repr(value)\n  try:\n    if parse_value(literal) == value:\n      return literal\n  except SyntaxError:\n    pass\n  return None\n\n\ndef _is_literally_representable(value):\n  """"""Returns `True` if `value` can be (parseably) represented as a string.\n\n  Args:\n    value: The value to check.\n\n  Returns:\n    `True` when `value` can be represented as a string parseable by\n    `parse_literal`, `False` otherwise.\n  """"""\n  return _format_value(value) is not None\n\n\ndef clear_config(clear_constants=False):\n  """"""Clears the global configuration.\n\n  This clears any parameter values set by `bind_parameter` or `parse_config`, as\n  well as the set of dynamically imported modules. It does not remove any\n  configurable functions or classes from the registry of configurables.\n\n  Args:\n    clear_constants: Whether to clear constants created by `constant`. Defaults\n      to False.\n  """"""\n  _set_config_is_locked(False)\n  _CONFIG.clear()\n  _SINGLETONS.clear()\n  if clear_constants:\n    _CONSTANTS.clear()\n  else:\n    saved_constants = _CONSTANTS.copy()\n    _CONSTANTS.clear()  # Clear then redefine constants (re-adding bindings).\n    for name, value in six.iteritems(saved_constants):\n      constant(name, value)\n  _IMPORTED_MODULES.clear()\n  _OPERATIVE_CONFIG.clear()\n\n\ndef bind_parameter(binding_key, value):\n  """"""Binds the parameter value specified by `binding_key` to `value`.\n\n  The `binding_key` argument should either be a string of the form\n  `maybe/scope/optional.module.names.configurable_name.parameter_name`, or a\n  list or tuple of `(scope, selector, parameter_name)`, where `selector`\n  corresponds to `optional.module.names.configurable_name`. Once this function\n  has been called, subsequent calls (in the specified scope) to the specified\n  configurable function will have `value` supplied to their `parameter_name`\n  parameter.\n\n  Example:\n\n      @configurable(\'fully_connected_network\')\n      def network_fn(num_layers=5, units_per_layer=1024):\n         ...\n\n      def main(_):\n        config.bind_parameter(\'fully_connected_network.num_layers\', 3)\n        network_fn()  # Called with num_layers == 3, not the default of 5.\n\n  Args:\n    binding_key: The parameter whose value should be set. This can either be a\n      string, or a tuple of the form `(scope, selector, parameter)`.\n    value: The desired value.\n\n  Raises:\n    RuntimeError: If the config is locked.\n    ValueError: If no function can be found matching the configurable name\n      specified by `binding_key`, or if the specified parameter name is\n      blacklisted or not in the function\'s whitelist (if present).\n  """"""\n  if config_is_locked():\n    raise RuntimeError(\'Attempted to modify locked Gin config.\')\n\n  pbk = ParsedBindingKey(binding_key)\n  fn_dict = _CONFIG.setdefault(pbk.config_key, {})\n  fn_dict[pbk.arg_name] = value\n\n\ndef query_parameter(binding_key):\n  """"""Returns the currently bound value to the specified `binding_key`.\n\n  The `binding_key` argument should look like\n  \'maybe/some/scope/maybe.modules.configurable_name.parameter_name\'. Note that\n  this will not include default parameters.\n\n  Args:\n    binding_key: The parameter whose value should be queried.\n\n  Returns:\n    The value bound to the configurable/parameter combination given in\n    `binding_key`.\n\n  Raises:\n    ValueError: If no function can be found matching the configurable name\n      specified by `biding_key`, or if the specified parameter name is\n      blacklisted or not in the function\'s whitelist (if present) or if there is\n      no value bound for the queried parameter or configurable.\n  """"""\n  if config_parser.MODULE_RE.match(binding_key):\n    matching_selectors = _CONSTANTS.matching_selectors(binding_key)\n    if len(matching_selectors) == 1:\n      return _CONSTANTS[matching_selectors[0]]\n    elif len(matching_selectors) > 1:\n      err_str = ""Ambiguous constant selector \'{}\', matches {}.""\n      raise ValueError(err_str.format(binding_key, matching_selectors))\n  pbk = ParsedBindingKey(binding_key)\n  if pbk.config_key not in _CONFIG:\n    err_str = ""Configurable \'{}\' has no bound parameters.""\n    raise ValueError(err_str.format(pbk.given_selector))\n  if pbk.arg_name not in _CONFIG[pbk.config_key]:\n    err_str = ""Configurable \'{}\' has no value bound for parameter \'{}\'.""\n    raise ValueError(err_str.format(pbk.given_selector, pbk.arg_name))\n  return _CONFIG[pbk.config_key][pbk.arg_name]\n\n\ndef _might_have_parameter(fn_or_cls, arg_name):\n  """"""Returns True if `arg_name` might be a valid parameter for `fn_or_cls`.\n\n  Specifically, this means that `fn_or_cls` either has a parameter named\n  `arg_name`, or has a `**kwargs` parameter.\n\n  Args:\n    fn_or_cls: The function or class to check.\n    arg_name: The name fo the parameter.\n\n  Returns:\n    Whether `arg_name` might be a valid argument of `fn`.\n  """"""\n  if inspect.isclass(fn_or_cls):\n    fn = _find_class_construction_fn(fn_or_cls)\n  else:\n    fn = fn_or_cls\n\n  while hasattr(fn, \'__wrapped__\'):\n    fn = fn.__wrapped__\n  arg_spec = _get_cached_arg_spec(fn)\n  if six.PY3:\n    if arg_spec.varkw:\n      return True\n    return arg_name in arg_spec.args or arg_name in arg_spec.kwonlyargs\n  else:\n    if arg_spec.keywords:\n      return True\n    return arg_name in arg_spec.args\n\n\ndef _validate_parameters(fn_or_cls, arg_name_list, err_prefix):\n  for arg_name in arg_name_list or []:\n    if not _might_have_parameter(fn_or_cls, arg_name):\n      err_str = ""Argument \'{}\' in {} not a parameter of \'{}\'.""\n      raise ValueError(err_str.format(arg_name, err_prefix, fn_or_cls.__name__))\n\n\ndef _get_cached_arg_spec(fn):\n  """"""Gets cached argspec for `fn`.""""""\n  arg_spec = _ARG_SPEC_CACHE.get(fn)\n  if arg_spec is None:\n    arg_spec_fn = inspect.getfullargspec if six.PY3 else inspect.getargspec\n    try:\n      arg_spec = arg_spec_fn(fn)\n    except TypeError:\n      # `fn` might be a callable object.\n      arg_spec = arg_spec_fn(fn.__call__)\n    _ARG_SPEC_CACHE[fn] = arg_spec\n  return arg_spec\n\n\ndef _get_supplied_positional_parameter_names(fn, args):\n  """"""Returns the names of the supplied arguments to the given function.""""""\n  arg_spec = _get_cached_arg_spec(fn)\n  # May be shorter than len(args) if args contains vararg (*args) arguments.\n  return arg_spec.args[:len(args)]\n\n\ndef _get_all_positional_parameter_names(fn):\n  """"""Returns the names of all positional arguments to the given function.""""""\n  arg_spec = _get_cached_arg_spec(fn)\n  args = arg_spec.args\n  if arg_spec.defaults:\n    args = args[:-len(arg_spec.defaults)]\n  return args\n\n\ndef _get_kwarg_defaults(fn):\n  """"""Returns a dict mapping kwargs to default values for the given function.""""""\n  arg_spec = _get_cached_arg_spec(fn)\n  if arg_spec.defaults:\n    default_kwarg_names = arg_spec.args[-len(arg_spec.defaults):]\n    arg_vals = dict(zip(default_kwarg_names, arg_spec.defaults))\n  else:\n    arg_vals = {}\n\n  if six.PY3 and arg_spec.kwonlydefaults:\n    arg_vals.update(arg_spec.kwonlydefaults)\n\n  return arg_vals\n\n\ndef _get_validated_required_kwargs(fn, fn_descriptor, whitelist, blacklist):\n  """"""Gets required argument names, and validates against white/blacklist.""""""\n  kwarg_defaults = _get_kwarg_defaults(fn)\n\n  required_kwargs = []\n  for kwarg, default in six.iteritems(kwarg_defaults):\n    if default is REQUIRED:\n      if blacklist and kwarg in blacklist:\n        err_str = ""Argument \'{}\' of {} marked REQUIRED but blacklisted.""\n        raise ValueError(err_str.format(kwarg, fn_descriptor))\n      if whitelist and kwarg not in whitelist:\n        err_str = ""Argument \'{}\' of {} marked REQUIRED but not whitelisted.""\n        raise ValueError(err_str.format(kwarg, fn_descriptor))\n      required_kwargs.append(kwarg)\n\n  return required_kwargs\n\n\ndef _get_default_configurable_parameter_values(fn, whitelist, blacklist):\n  """"""Retrieve all default values for configurable parameters of a function.\n\n  Any parameters included in the supplied blacklist, or not included in the\n  supplied whitelist, are excluded.\n\n  Args:\n    fn: The function whose parameter values should be retrieved.\n    whitelist: The whitelist (or `None`) associated with the function.\n    blacklist: The blacklist (or `None`) associated with the function.\n\n  Returns:\n    A dictionary mapping configurable parameter names to their default values.\n  """"""\n  arg_vals = _get_kwarg_defaults(fn)\n\n  # Now, eliminate keywords that are blacklisted, or aren\'t whitelisted (if\n  # there\'s a whitelist), or aren\'t representable as a literal value.\n  for k in list(six.iterkeys(arg_vals)):\n    whitelist_fail = whitelist and k not in whitelist\n    blacklist_fail = blacklist and k in blacklist\n    representable = _is_literally_representable(arg_vals[k])\n    if whitelist_fail or blacklist_fail or not representable:\n      del arg_vals[k]\n\n  return arg_vals\n\n\ndef _order_by_signature(fn, arg_names):\n  """"""Orders given `arg_names` based on their order in the signature of `fn`.""""""\n  arg_spec = _get_cached_arg_spec(fn)\n  all_args = list(arg_spec.args)\n  if six.PY3 and arg_spec.kwonlyargs:\n    all_args.extend(arg_spec.kwonlyargs)\n  ordered = [arg for arg in all_args if arg in arg_names]\n  # Handle any leftovers corresponding to varkwargs in the order we got them.\n  ordered.extend([arg for arg in arg_names if arg not in ordered])\n  return ordered\n\n\ndef current_scope():\n  return _SCOPE_MANAGER.current_scope\n\n\ndef current_scope_str():\n  return \'/\'.join(current_scope())\n\n\n@contextlib.contextmanager\ndef config_scope(name_or_scope):\n  """"""Opens a new configuration scope.\n\n  Provides a context manager that opens a new explicit configuration\n  scope. Explicit configuration scopes restrict parameter bindings to only\n  certain sections of code that run within the scope. Scopes can be nested to\n  arbitrary depth; any configurable functions called within a scope inherit\n  parameters defined by higher level scopes.\n\n  For example, suppose a function named `preprocess_images` is called in two\n  places in a codebase: Once when loading data for a training task, and once\n  when loading data for an evaluation task:\n\n      def load_training_data():\n        ...\n        with gin.config_scope(\'train\'):\n          images = preprocess_images(images)\n        ...\n\n\n      def load_eval_data():\n        ...\n        with gin.config_scope(\'eval\'):\n          images = preprocess_images(images)\n        ...\n\n  By using a `config_scope` to wrap each invocation of `preprocess_images` as\n  above, it is possible to use Gin to supply specific parameters to each. Here\n  is a possible configuration for the above example:\n\n      preprocess_images.crop_size = [64, 64]\n      preprocess_images.normalize_image = True\n\n      train/preprocess_images.crop_location = \'random\'\n      train/preprocess_images.random_flip_lr = True\n\n      eval/preprocess_images.crop_location = \'center\'\n\n  The `crop_size` and `normalize_image` parameters above will be shared by both\n  the `train` and `eval` invocations; only `train` will receive\n  `random_flip_lr`, and the two invocations receive different values for\n  `crop_location`.\n\n  Passing `None` or `\'\'` to `config_scope` will temporarily clear all currently\n  active scopes (within the `with` block; they will be restored afterwards).\n\n  Args:\n    name_or_scope: A name for the config scope, or an existing scope (e.g.,\n      captured from `with gin.config_scope(...) as scope`), or `None` to clear\n      currently active scopes.\n\n  Raises:\n    ValueError: If `name_or_scope` is not a list, string, or None.\n\n  Yields:\n    The resulting config scope (a list of all active scope names, ordered from\n    outermost to innermost).\n  """"""\n  try:\n    valid_value = True\n    if isinstance(name_or_scope, list):\n      new_scope = name_or_scope\n    elif name_or_scope and isinstance(name_or_scope, six.string_types):\n      new_scope = current_scope()  # Returns a copy.\n      new_scope.extend(name_or_scope.split(\'/\'))\n    else:\n      valid_value = name_or_scope in (None, \'\')\n      new_scope = []\n\n    # Append new_scope first. It will be popped in the finally block if an\n    # exception is raised below.\n    _SCOPE_MANAGER.enter_scope(new_scope)\n\n    scopes_are_valid = map(config_parser.MODULE_RE.match, new_scope)\n    if not valid_value or not all(scopes_are_valid):\n      err_str = \'Invalid value for `name_or_scope`: {}.\'\n      raise ValueError(err_str.format(name_or_scope))\n\n    yield new_scope\n  finally:\n    _SCOPE_MANAGER.exit_scope()\n\n\ndef _make_gin_wrapper(fn, fn_or_cls, name, selector, whitelist, blacklist):\n  """"""Creates the final Gin wrapper for the given function.\n\n  Args:\n    fn: The function that will be wrapped.\n    fn_or_cls: The original function or class being made configurable. This will\n      differ from `fn` when making a class configurable, in which case `fn` will\n      be the constructor/new function, while `fn_or_cls` will be the class.\n    name: The name given to the configurable.\n    selector: The full selector of the configurable (name including any module\n      components).\n    whitelist: A whitelist of configurable parameters.\n    blacklist: A blacklist of non-configurable parameters.\n\n  Returns:\n    The Gin wrapper around `fn`.\n  """"""\n  # At this point we have access to the final function to be wrapped, so we\n  # can cache a few things here.\n  fn_descriptor = ""\'{}\' (\'{}\')"".format(name, fn_or_cls)\n  signature_required_kwargs = _get_validated_required_kwargs(\n      fn, fn_descriptor, whitelist, blacklist)\n  initial_configurable_defaults = _get_default_configurable_parameter_values(\n      fn, whitelist, blacklist)\n\n  @six.wraps(fn)\n  def gin_wrapper(*args, **kwargs):\n    """"""Supplies fn with parameter values from the configuration.""""""\n    scope_components = current_scope()\n    new_kwargs = {}\n    for i in range(len(scope_components) + 1):\n      partial_scope_str = \'/\'.join(scope_components[:i])\n      new_kwargs.update(_CONFIG.get((partial_scope_str, selector), {}))\n    gin_bound_args = list(new_kwargs.keys())\n    scope_str = partial_scope_str\n\n    arg_names = _get_supplied_positional_parameter_names(fn, args)\n\n    for arg in args[len(arg_names):]:\n      if arg is REQUIRED:\n        raise ValueError(\n            \'gin.REQUIRED is not allowed for unnamed (vararg) parameters. If \'\n            \'the function being called is wrapped by a non-Gin decorator, \'\n            \'try explicitly providing argument names for positional \'\n            \'parameters.\')\n\n    required_arg_names = []\n    required_arg_indexes = []\n    for i, arg in enumerate(args[:len(arg_names)]):\n      if arg is REQUIRED:\n        required_arg_names.append(arg_names[i])\n        required_arg_indexes.append(i)\n\n    caller_required_kwargs = []\n    for kwarg, value in six.iteritems(kwargs):\n      if value is REQUIRED:\n        caller_required_kwargs.append(kwarg)\n\n    # If the caller passed arguments as positional arguments that correspond to\n    # a keyword arg in new_kwargs, remove the keyword argument from new_kwargs\n    # to let the caller win and avoid throwing an error. Unless it is an arg\n    # marked as REQUIRED.\n    for arg_name in arg_names:\n      if arg_name not in required_arg_names:\n        new_kwargs.pop(arg_name, None)\n\n    # Get default values for configurable parameters.\n    operative_parameter_values = initial_configurable_defaults.copy()\n    # Update with the values supplied via configuration.\n    operative_parameter_values.update(new_kwargs)\n\n    # Remove any values from the operative config that are overridden by the\n    # caller. These can\'t be configured, so they won\'t be logged. We skip values\n    # that are marked as REQUIRED.\n    for k in arg_names:\n      if k not in required_arg_names:\n        operative_parameter_values.pop(k, None)\n    for k in kwargs:\n      if k not in caller_required_kwargs:\n        operative_parameter_values.pop(k, None)\n\n    # An update is performed in case another caller of this same configurable\n    # object has supplied a different set of arguments. By doing an update, a\n    # Gin-supplied or default value will be present if it was used (not\n    # overridden by the caller) at least once.\n    with _OPERATIVE_CONFIG_LOCK:\n      op_cfg = _OPERATIVE_CONFIG.setdefault((scope_str, selector), {})\n      op_cfg.update(operative_parameter_values)\n\n    # We call deepcopy for two reasons: First, to prevent the called function\n    # from modifying any of the values in `_CONFIG` through references passed in\n    # via `new_kwargs`; Second, to facilitate evaluation of any\n    # `ConfigurableReference` instances buried somewhere inside `new_kwargs`.\n    # See the docstring on `ConfigurableReference.__deepcopy__` above for more\n    # details on the dark magic happening here.\n    new_kwargs = copy.deepcopy(new_kwargs)\n\n    # Validate args marked as REQUIRED have been bound in the Gin config.\n    missing_required_params = []\n    new_args = list(args)\n    for i, arg_name in zip(required_arg_indexes, required_arg_names):\n      if arg_name not in new_kwargs:\n        missing_required_params.append(arg_name)\n      else:\n        new_args[i] = new_kwargs.pop(arg_name)\n\n    # Validate kwargs marked as REQUIRED have been bound in the Gin config.\n    for required_kwarg in signature_required_kwargs:\n      if (required_kwarg not in arg_names and  # not a positional arg\n          required_kwarg not in kwargs and  # or a keyword arg\n          required_kwarg not in new_kwargs):  # or bound in config\n        missing_required_params.append(required_kwarg)\n    for required_kwarg in caller_required_kwargs:\n      if required_kwarg not in new_kwargs:\n        missing_required_params.append(required_kwarg)\n      else:\n        # Remove from kwargs and let the new_kwargs value be used.\n        kwargs.pop(required_kwarg)\n\n    if missing_required_params:\n      missing_required_params = (\n          _order_by_signature(fn, missing_required_params))\n      err_str = \'Required bindings for `{}` not provided in config: {}\'\n      minimal_selector = _REGISTRY.minimal_selector(selector)\n      err_str = err_str.format(minimal_selector, missing_required_params)\n      raise RuntimeError(err_str)\n\n    # Now, update with the caller-supplied `kwargs`, allowing the caller to have\n    # the final say on keyword argument values.\n    new_kwargs.update(kwargs)\n\n    try:\n      return fn(*new_args, **new_kwargs)\n    except Exception as e:  # pylint: disable=broad-except\n      err_str = \'\'\n      if isinstance(e, TypeError):\n        all_arg_names = _get_all_positional_parameter_names(fn)\n        if len(new_args) < len(all_arg_names):\n          unbound_positional_args = list(\n              set(all_arg_names[len(new_args):]) - set(new_kwargs))\n          if unbound_positional_args:\n            caller_supplied_args = list(\n                set(arg_names + list(kwargs)) -\n                set(required_arg_names + list(caller_required_kwargs)))\n            fmt = (\'\\n  No values supplied by Gin or caller for arguments: {}\'\n                   \'\\n  Gin had values bound for: {gin_bound_args}\'\n                   \'\\n  Caller supplied values for: {caller_supplied_args}\')\n            canonicalize = lambda x: list(map(str, sorted(x)))\n            err_str += fmt.format(\n                canonicalize(unbound_positional_args),\n                gin_bound_args=canonicalize(gin_bound_args),\n                caller_supplied_args=canonicalize(caller_supplied_args))\n      err_str += ""\\n  In call to configurable \'{}\' ({}){}""\n      scope_info = "" in scope \'{}\'"".format(scope_str) if scope_str else \'\'\n      err_str = err_str.format(name, fn_or_cls, scope_info)\n      utils.augment_exception_message_and_reraise(e, err_str)\n\n  return gin_wrapper\n\n\ndef _make_configurable(fn_or_cls,\n                       name=None,\n                       module=None,\n                       whitelist=None,\n                       blacklist=None,\n                       subclass=False):\n  """"""Wraps `fn_or_cls` to make it configurable.\n\n  Infers the configurable name from `fn_or_cls.__name__` if necessary, and\n  updates global state to keep track of configurable name <-> function\n  mappings, as well as whitelisted and blacklisted parameters.\n\n  Args:\n    fn_or_cls: The function or class to decorate.\n    name: A name for the configurable. If `None`, the name will be inferred from\n      from `fn_or_cls`. The `name` may also include module components to be used\n      for disambiguation (these will be appended to any components explicitly\n      specified by `module`).\n    module: The module to associate with the configurable, to help handle naming\n      collisions. If `None`, `fn_or_cls.__module__` will be used (if no module\n      is specified as part of `name`).\n    whitelist: A whitelisted set of parameter names to supply values for.\n    blacklist: A blacklisted set of parameter names not to supply values for.\n    subclass: If `fn_or_cls` is a class and `subclass` is `True`, decorate by\n      subclassing `fn_or_cls` and overriding its `__init__` method. If `False`,\n      replace the existing `__init__` with a decorated version.\n\n  Returns:\n    A wrapped version of `fn_or_cls` that will take parameter values from the\n    global configuration.\n\n  Raises:\n    RuntimeError: If the config is locked.\n    ValueError: If a configurable with `name` (or the name of `fn_or_cls`)\n      already exists, or if both a whitelist and blacklist are specified.\n  """"""\n  if config_is_locked():\n    err_str = \'Attempted to add a new configurable after the config was locked.\'\n    raise RuntimeError(err_str)\n\n  name = fn_or_cls.__name__ if name is None else name\n  if config_parser.IDENTIFIER_RE.match(name):\n    default_module = getattr(fn_or_cls, \'__module__\', None)\n    module = default_module if module is None else module\n  elif not config_parser.MODULE_RE.match(name):\n    raise ValueError(""Configurable name \'{}\' is invalid."".format(name))\n\n  if module is not None and not config_parser.MODULE_RE.match(module):\n    raise ValueError(""Module \'{}\' is invalid."".format(module))\n\n  selector = module + \'.\' + name if module else name\n  if not _INTERACTIVE_MODE and selector in _REGISTRY:\n    err_str = (""A configurable matching \'{}\' already exists.\\n\\n""\n               \'To allow re-registration of configurables in an interactive \'\n               \'environment, use:\\n\\n\'\n               \'    gin.enter_interactive_mode()\')\n    raise ValueError(err_str.format(selector))\n\n  if whitelist and blacklist:\n    err_str = \'A whitelist or a blacklist can be specified, but not both.\'\n    raise ValueError(err_str)\n\n  if whitelist and not isinstance(whitelist, (list, tuple)):\n    raise TypeError(\'Whitelist should be a list or tuple.\')\n\n  if blacklist and not isinstance(blacklist, (list, tuple)):\n    raise TypeError(\'Blacklist should be a list or tuple.\')\n\n  _validate_parameters(fn_or_cls, whitelist, \'whitelist\')\n  _validate_parameters(fn_or_cls, blacklist, \'blacklist\')\n\n  def decorator(fn):\n    """"""Wraps `fn` so that it obtains parameters from the configuration.""""""\n    return _make_gin_wrapper(fn, fn_or_cls, name, selector, whitelist,\n                             blacklist)\n\n  decorated_fn_or_cls = _decorate_fn_or_cls(\n      decorator, fn_or_cls, subclass=subclass)\n\n  _REGISTRY[selector] = Configurable(\n      decorated_fn_or_cls,\n      name=name,\n      module=module,\n      whitelist=whitelist,\n      blacklist=blacklist,\n      selector=selector)\n  return decorated_fn_or_cls\n\n\ndef configurable(name_or_fn=None, module=None, whitelist=None, blacklist=None):\n  """"""Decorator to make a function or class configurable.\n\n  This decorator registers the decorated function/class as configurable, which\n  allows its parameters to be supplied from the global configuration (i.e., set\n  through `bind_parameter` or `parse_config`). The decorated function is\n  associated with a name in the global configuration, which by default is simply\n  the name of the function or class, but can be specified explicitly to avoid\n  naming collisions or improve clarity.\n\n  If some parameters should not be configurable, they can be specified in\n  `blacklist`. If only a restricted set of parameters should be configurable,\n  they can be specified in `whitelist`.\n\n  The decorator can be used without any parameters as follows:\n\n      @config.configurable\n      def some_configurable_function(param1, param2=\'a default value\'):\n        ...\n\n  In this case, the function is associated with the name\n  `\'some_configurable_function\'` in the global configuration, and both `param1`\n  and `param2` are configurable.\n\n  The decorator can be supplied with parameters to specify the configurable name\n  or supply a whitelist/blacklist:\n\n      @config.configurable(\'explicit_configurable_name\', whitelist=\'param2\')\n      def some_configurable_function(param1, param2=\'a default value\'):\n        ...\n\n  In this case, the configurable is associated with the name\n  `\'explicit_configurable_name\'` in the global configuration, and only `param2`\n  is configurable.\n\n  Classes can be decorated as well, in which case parameters of their\n  constructors are made configurable:\n\n      @config.configurable\n      class SomeClass(object):\n        def __init__(self, param1, param2=\'a default value\'):\n          ...\n\n  In this case, the name of the configurable is `\'SomeClass\'`, and both `param1`\n  and `param2` are configurable.\n\n  Args:\n    name_or_fn: A name for this configurable, or a function to decorate (in\n      which case the name will be taken from that function). If not set,\n      defaults to the name of the function/class that is being made\n      configurable. If a name is provided, it may also include module components\n      to be used for disambiguation (these will be appended to any components\n      explicitly specified by `module`).\n    module: The module to associate with the configurable, to help handle naming\n      collisions. By default, the module of the function or class being made\n      configurable will be used (if no module is specified as part of the name).\n    whitelist: A whitelisted set of kwargs that should be configurable. All\n      other kwargs will not be configurable. Only one of `whitelist` or\n      `blacklist` should be specified.\n    blacklist: A blacklisted set of kwargs that should not be configurable. All\n      other kwargs will be configurable. Only one of `whitelist` or `blacklist`\n      should be specified.\n\n  Returns:\n    When used with no parameters (or with a function/class supplied as the first\n    parameter), it returns the decorated function or class. When used with\n    parameters, it returns a function that can be applied to decorate the target\n    function or class.\n  """"""\n  decoration_target = None\n  if callable(name_or_fn):\n    decoration_target = name_or_fn\n    name = None\n  else:\n    name = name_or_fn\n\n  def perform_decoration(fn_or_cls):\n    return _make_configurable(fn_or_cls, name, module, whitelist, blacklist)\n\n  if decoration_target:\n    return perform_decoration(decoration_target)\n  return perform_decoration\n\n\ndef external_configurable(fn_or_cls,\n                          name=None,\n                          module=None,\n                          whitelist=None,\n                          blacklist=None):\n  """"""Allow referencing/configuring an external class or function.\n\n  This alerts Gin to the existence of the class or function `fn_or_cls` in the\n  event that it can\'t be easily annotated with `@configurable` (for instance, if\n  it is from another project). This allows `fn_or_cls` to be configured and\n  referenced (using the `@name` notation) via parameter binding strings.\n\n  Note that only calls to the return value of this function or resulting from\n  references to `fn_or_cls` made through binding strings (configurations) will\n  have their parameters injected by Gin---explicit calls to `fn_or_cls` directly\n  won\'t have any parameter bindings applied.\n\n  Args:\n    fn_or_cls: The external function or class that should be made configurable.\n    name: The configurable name to be associated with `fn_or_cls`. The name may\n      also include module components to be used for disambiguation (these will\n      be appended to any components explicitly specified by `module`).\n    module: The module to associate with the configurable, to help handle naming\n      collisions. By default, `fn_or_cls.__module__` will be used (if no module\n      is specified as part of the name).\n    whitelist: A whitelist of parameter names to allow configuration for.\n    blacklist: A blacklist of parameter names not to allow configuration for.\n\n  Returns:\n    A decorated version of `fn_or_cls` that permits parameter binding. For\n    functions, this is just a wrapped version of the function. For classes, this\n    is a carefully constructed subclass of `fn_or_cls` designed to behave nearly\n    identically (even under many type inspection operations) save for the\n    addition of parameter binding.\n  """"""\n  return _make_configurable(\n      fn_or_cls,\n      name=name,\n      module=module,\n      whitelist=whitelist,\n      blacklist=blacklist,\n      subclass=True)\n\n\ndef register(name_or_fn=None, module=None, whitelist=None, blacklist=None):\n  """"""Decorator to register a function or class configurable.\n\n  This decorator only registers the decorated function/class with Gin, so it can\n  be passed to other configurables in `bind_parameter` or `parse_config`.\n  This decorator doesn\'t change the decorated function/class, so any direct\n  calls from within Python code are not affected by the configuration.\n\n  If some parameters should not be configurable, they can be specified in\n  `blacklist`. If only a restricted set of parameters should be configurable,\n  they can be specified in `whitelist`.\n\n  The decorator can be used without any parameters as follows:\n\n      @config.register\n      def some_configurable_function(param1, param2=\'a default value\'):\n        ...\n\n  In this case, the function is associated with the name\n  `\'some_configurable_function\'` in the configuration, and both `param1`\n  and `param2` are configurable.\n\n  The decorator can be supplied with parameters to specify the name used to\n  register or supply a whitelist/blacklist:\n\n      @config.register(\'explicit_name\', whitelist=\'param2\')\n      def some_configurable_function(param1, param2=\'a default value\'):\n        ...\n\n  In this case, the function is registered with the name `\'explicit_name\'` in\n  the configuration registry, and only `param2` is configurable.\n\n  Classes can be decorated as well, in which case parameters of their\n  constructors are made configurable:\n\n      @config.register\n      class SomeClass(object):\n        def __init__(self, param1, param2=\'a default value\'):\n          ...\n\n  In this case, the name of the configurable is `\'SomeClass\'`, and both `param1`\n  and `param2` are configurable.\n\n  Args:\n    name_or_fn: A name for this configurable, or a function to decorate (in\n      which case the name will be taken from that function). If not set,\n      defaults to the name of the function/class that is being made\n      configurable. If a name is provided, it may also include module components\n      to be used for disambiguation (these will be appended to any components\n      explicitly specified by `module`).\n    module: The module to associate with the configurable, to help handle naming\n      collisions. By default, the module of the function or class being made\n      configurable will be used (if no module is specified as part of the name).\n    whitelist: A whitelisted set of kwargs that should be configurable. All\n      other kwargs will not be configurable. Only one of `whitelist` or\n      `blacklist` should be specified.\n    blacklist: A blacklisted set of kwargs that should not be configurable. All\n      other kwargs will be configurable. Only one of `whitelist` or `blacklist`\n      should be specified.\n\n  Returns:\n    When used with no parameters as a decorator (or with a function/class\n    supplied as the first parameter), it returns the target function or class\n    unchanged. When used with parameters, it returns a function that can be\n    applied to register the target function or class with Gin (this function\n    also returns the target function or class unchanged).\n  """"""\n  decoration_target = None\n  if callable(name_or_fn):\n    decoration_target = name_or_fn\n    name = None\n  else:\n    name = name_or_fn\n\n  def perform_decoration(fn_or_cls):\n    # Register it as configurable but return the orinal fn_or_cls.\n    _make_configurable(\n        fn_or_cls,\n        name=name,\n        module=module,\n        whitelist=whitelist,\n        blacklist=blacklist,\n        subclass=True)\n    return fn_or_cls\n\n  if decoration_target:\n    return perform_decoration(decoration_target)\n  return perform_decoration\n\n\ndef _config_str(configuration_object,\n                max_line_length=80,\n                continuation_indent=4):\n  """"""Print the configuration specified in configuration object.\n\n  Args:\n    configuration_object: Either OPERATIVE_CONFIG_ (operative config) or _CONFIG\n      (all config, bound and unbound).\n    max_line_length: A (soft) constraint on the maximum length of a line in the\n      formatted string. Large nested structures will be split across lines, but\n      e.g. long strings won\'t be split into a concatenation of shorter strings.\n    continuation_indent: The indentation for continued lines.\n\n  Returns:\n    A config string capturing all parameter values set by the object.\n  """"""\n\n  def format_binding(key, value):\n    """"""Pretty print the given key/value pair.""""""\n    formatted_val = pprint.pformat(\n        value, width=(max_line_length - continuation_indent))\n    formatted_val_lines = formatted_val.split(\'\\n\')\n    if (len(formatted_val_lines) == 1 and\n        len(key + formatted_val) <= max_line_length):\n      output = \'{} = {}\'.format(key, formatted_val)\n    else:\n      indented_formatted_val = \'\\n\'.join(\n          [\' \' * continuation_indent + line for line in formatted_val_lines])\n      output = \'{} = \\\\\\n{}\'.format(key, indented_formatted_val)\n    return output\n\n  def sort_key(key_tuple):\n    """"""Sort configurable selector/innermost scopes, ignoring case.""""""\n    scope, selector = key_tuple[0]\n    parts = selector.lower().split(\'.\')[::-1] + scope.lower().split(\'/\')[::-1]\n    return \'/\'.join(parts)\n\n  # Build the output as an array of formatted Gin statements. Each statement may\n  # span multiple lines. Imports are first, followed by macros, and finally all\n  # other bindings sorted in alphabetical order by configurable name.\n  formatted_statements = [\n      \'import {}\'.format(module) for module in sorted(_IMPORTED_MODULES)\n  ]\n  if formatted_statements:\n    formatted_statements.append(\'\')\n\n  macros = {}\n  for (scope, selector), config in six.iteritems(configuration_object):\n    if _REGISTRY[selector].fn_or_cls == macro:\n      macros[scope, selector] = config\n  if macros:\n    formatted_statements.append(\'# Macros:\')\n    formatted_statements.append(\'# \' + \'=\' * (max_line_length - 2))\n  for (name, _), config in sorted(macros.items(), key=sort_key):\n    binding = format_binding(name, config[\'value\'])\n    formatted_statements.append(binding)\n  if macros:\n    formatted_statements.append(\'\')\n\n  sorted_items = sorted(configuration_object.items(), key=sort_key)\n  for (scope, selector), config in sorted_items:\n    configurable_ = _REGISTRY[selector]\n\n    fn = configurable_.fn_or_cls\n    if fn == macro or fn == _retrieve_constant:\n      continue\n\n    minimal_selector = _REGISTRY.minimal_selector(configurable_.selector)\n    scoped_selector = (scope + \'/\' if scope else \'\') + minimal_selector\n    parameters = [(k, v)\n                  for k, v in six.iteritems(config)\n                  if _is_literally_representable(v)]\n    formatted_statements.append(\'# Parameters for {}:\'.format(scoped_selector))\n    formatted_statements.append(\'# \' + \'=\' * (max_line_length - 2))\n    for arg, val in sorted(parameters):\n      binding = format_binding(\'{}.{}\'.format(scoped_selector, arg), val)\n      formatted_statements.append(binding)\n    if not parameters:\n      formatted_statements.append(\'# None.\')\n    formatted_statements.append(\'\')\n\n  return \'\\n\'.join(formatted_statements)\n\n\ndef operative_config_str(max_line_length=80, continuation_indent=4):\n  """"""Retrieve the ""operative"" configuration as a config string.\n\n  The operative configuration consists of all parameter values used by\n  configurable functions that are actually called during execution of the\n  current program. Parameters associated with configurable functions that are\n  not called (and so can have no effect on program execution) won\'t be included.\n\n  The goal of the function is to return a config that captures the full set of\n  relevant configurable ""hyperparameters"" used by a program. As such, the\n  returned configuration will include the default values of arguments from\n  configurable functions (as long as the arguments aren\'t blacklisted or missing\n  from a supplied whitelist), as well as any parameter values overridden via\n  `bind_parameter` or through `parse_config`.\n\n  Any parameters that can\'t be represented as literals (capable of being parsed\n  by `parse_config`) are excluded. The resulting config string is sorted\n  lexicographically and grouped by configurable name.\n\n  Args:\n    max_line_length: A (soft) constraint on the maximum length of a line in the\n      formatted string. Large nested structures will be split across lines, but\n      e.g. long strings won\'t be split into a concatenation of shorter strings.\n    continuation_indent: The indentation for continued lines.\n\n  Returns:\n    A config string capturing all parameter values set in the current program.\n  """"""\n  return _config_str(_OPERATIVE_CONFIG, max_line_length, continuation_indent)\n\n\ndef config_str(max_line_length=80, continuation_indent=4):\n  """"""Retrieve the interpreted configuration as a config string.\n\n  This is not the _operative configuration_, in that it includes parameter\n  values which are unused by by the program.\n\n  Args:\n    max_line_length: A (soft) constraint on the maximum length of a line in the\n      formatted string. Large nested structures will be split across lines, but\n      e.g. long strings won\'t be split into a concatenation of shorter strings.\n    continuation_indent: The indentation for continued lines.\n\n  Returns:\n    A config string capturing all parameter values used by the current program.\n  """"""\n  return _config_str(_CONFIG, max_line_length, continuation_indent)\n\n\nclass ParsedConfigFileIncludesAndImports(\n    collections.namedtuple(\'ParsedConfigFileIncludesAndImports\',\n                           [\'filename\', \'imports\', \'includes\'])):\n  pass\n\n\ndef parse_config(bindings, skip_unknown=False):\n  """"""Parse a file, string, or list of strings containing parameter bindings.\n\n  Parses parameter binding strings to set up the global configuration.  Once\n  `parse_config` has been called, any calls to configurable functions will have\n  parameter values set according to the values specified by the parameter\n  bindings in `bindings`.\n\n  An individual parameter binding has the format\n\n      maybe/some/scopes/configurable_name.parameter_name = value\n\n  Multiple binding strings can be passed either in the form of a file-like\n  object supporting the `readline` method, a single string with each individual\n  parameter binding separated by a newline, or as a list of individual parameter\n  binding strings.\n\n  Any Python literal (lists, tuples, dicts, strings, etc.) is acceptable to the\n  right of the equals sign, and follows standard Python rules for line\n  continuation. Additionally, a value starting with \'@\' is interpreted as a\n  (possibly scoped) reference to another configurable function, in which case\n  this value is replaced by a reference to that function. If the value\n  furthermore ends in `()` (e.g., `@configurable_name()`), then the value\n  returned when calling the function is used (it will be called *just before*\n  the function consuming the output is called).\n\n  See the module documentation for a more detailed description of scoping\n  mechanisms and a complete example.\n\n  Reading from a file could be done as follows:\n\n      with open(\'/path/to/file.config\') as bindings:\n        gin.parse_config(bindings)\n\n  Passing a newline separated string of parameter bindings might look like:\n\n      bindings = \'\'\'\n          my_class.param_one = \'asdf\'\n          my_class_param_two = 9.7\n      \'\'\'\n      gin.parse_config(bindings)\n\n  Alternatively, one can declare a list of parameter bindings and pass it in:\n\n      bindings = [\n          \'my_class.param_one = ""asdf""\',\n          \'my_class.param_two = 9.7\',\n      ]\n      gin.parse_config(bindings)\n\n  Can skip unknown configurables. For example, if no module containing a\n  \'training\' configurable was imported, errors can be avoided by specifying\n  `skip_unknown=True`:\n\n      bindings = [\n          \'my_class.param_one = ""asdf""\',\n          \'my_class.param_two = 9.7\',\n          \'training.learning_rate = 0.1\',\n      ]\n      gin.parse_config(bindings, skip_unknown=True)\n\n  Args:\n    bindings: A file-like object supporting the readline method, a newline\n      separated string of parameter bindings, or a list of individual parameter\n      binding strings.\n    skip_unknown: A boolean indicating whether unknown configurables and imports\n      should be skipped (instead of causing an error). Configurable references\n      to unknown configurables will cause errors if they are present in a\n      binding that is not itself skipped due to an unknown configurable. This\n      can also be a list of configurable names: any unknown configurables that\n        do not match an item in the list will still cause errors. Note that\n        bindings for known configurables will always be parsed.\n\n  Returns:\n    includes: List of ParsedConfigFileIncludesAndImports describing the result\n      of loading nested include statements.\n    imports: List of names of imported modules.\n  """"""\n  if isinstance(bindings, (list, tuple)):\n    bindings = \'\\n\'.join(bindings)\n\n  _validate_skip_unknown(skip_unknown)\n  if isinstance(skip_unknown, (list, tuple)):\n    skip_unknown = set(skip_unknown)\n\n  parser = config_parser.ConfigParser(bindings, ParserDelegate(skip_unknown))\n  includes = []\n  imports = []\n  for statement in parser:\n    if isinstance(statement, config_parser.BindingStatement):\n      scope, selector, arg_name, value, location = statement\n      if not arg_name:\n        macro_name = \'{}/{}\'.format(scope, selector) if scope else selector\n        with utils.try_with_location(location):\n          bind_parameter((macro_name, \'gin.macro\', \'value\'), value)\n        continue\n      if not _should_skip(selector, skip_unknown):\n        with utils.try_with_location(location):\n          bind_parameter((scope, selector, arg_name), value)\n    elif isinstance(statement, config_parser.ImportStatement):\n      imports.append(statement.module)\n      if skip_unknown:\n        try:\n          __import__(statement.module)\n          _IMPORTED_MODULES.add(statement.module)\n        except ImportError:\n          tb_len = len(traceback.extract_tb(sys.exc_info()[2]))\n          log_str = (\'Skipping import of unknown module `%s` \'\n                     \'(skip_unknown=True).\')\n          log_args = [statement.module]\n          if tb_len > 1:\n            # In case the error comes from a nested import (i.e. the module is\n            # available, but it imports some unavailable module), print the\n            # traceback to avoid confusion.\n            log_str += \'\\n%s\'\n            log_args.append(traceback.format_exc())\n          logging.info(log_str, *log_args)\n      else:\n        with utils.try_with_location(statement.location):\n          __import__(statement.module)\n        _IMPORTED_MODULES.add(statement.module)\n    elif isinstance(statement, config_parser.IncludeStatement):\n      with utils.try_with_location(statement.location):\n        nested_includes = parse_config_file(statement.filename, skip_unknown)\n        includes.append(nested_includes)\n    else:\n      raise AssertionError(\'Unrecognized statement type {}.\'.format(statement))\n  return includes, imports\n\n\ndef register_file_reader(*args):\n  """"""Register a file reader for use in parse_config_file.\n\n  Registered file readers will be used to try reading files passed to\n  `parse_config_file`. All file readers (beginning with the default `open`) will\n  be tried until one of them succeeds at opening the file.\n\n  This function may also be be used used as a decorator. For example:\n\n      @register_file_reader(IOError)\n      def exotic_data_source(filename):\n        ...\n\n  Args:\n    *args: (When used as a decorator, only the existence check is supplied.)\n      - file_reader_fn: The file reader function to register. This should be a\n        function that can be used as a context manager to open a file and\n        provide a file-like object, similar to Python\'s built-in `open`.\n      - is_readable_fn: A function taking the file path and returning a boolean\n        indicating whether the file can be read by `file_reader_fn`.\n\n  Returns:\n    `None`, or when used as a decorator, a function that will perform the\n    registration using the supplied readability predicate.\n  """"""\n\n  def do_registration(file_reader_fn, is_readable_fn):\n    if file_reader_fn not in list(zip(*_FILE_READERS))[0]:\n      _FILE_READERS.append((file_reader_fn, is_readable_fn))\n\n  if len(args) == 1:  # It\'s a decorator.\n    return functools.partial(do_registration, is_readable_fn=args[0])\n  elif len(args) == 2:\n    do_registration(*args)\n  else:  # 0 or > 2 arguments supplied.\n    err_str = \'register_file_reader() takes 1 or 2 arguments ({} given)\'\n    raise TypeError(err_str.format(len(args)))\n\n\ndef add_config_file_search_path(location_prefix):\n  """"""Adds a path that will be searched for config files by parse_config_file.""""""\n  _LOCATION_PREFIXES.append(location_prefix)\n\n\ndef parse_config_file(\n    config_file: str,\n    skip_unknown: bool = False,\n    print_includes_and_imports: bool = False\n) -> ParsedConfigFileIncludesAndImports:\n  """"""Parse a Gin config file.\n\n  Args:\n    config_file: The path to a Gin config file.\n    skip_unknown: A boolean indicating whether unknown configurables and imports\n      should be skipped instead of causing errors (alternatively a list of\n      configurable names to skip if unknown). See `parse_config` for additional\n      details.\n    print_includes_and_imports: Whether to print the resulting nested includes\n      and imports.\n\n  Returns:\n    results: An instance of ParsedConfigFileIncludesAndImports containing the\n      filename of the parse files, a list of names of imported modules and a\n      list of ParsedConfigFileIncludesAndImports created from including nested\n      gin files.\n\n  Raises:\n    IOError: If `config_file` cannot be read using any register file reader.\n  """"""\n  prefixes = _LOCATION_PREFIXES if not os.path.isabs(config_file) else [\'\']\n  for location_prefix in prefixes:\n    config_file_with_prefix = os.path.join(location_prefix, config_file)\n    for reader, existence_check in _FILE_READERS:\n      if existence_check(config_file_with_prefix):\n        with reader(config_file_with_prefix) as f:\n          includes, imports = parse_config(f, skip_unknown=skip_unknown)\n          results = ParsedConfigFileIncludesAndImports(\n              filename=config_file, imports=imports, includes=includes)\n          if print_includes_and_imports:\n            log_includes_and_imports(results)\n          return results\n  err_str = \'Unable to open file: {}. Searched config paths: {}.\'\n  raise IOError(err_str.format(config_file, prefixes))\n\n\ndef parse_config_files_and_bindings(config_files: Optional[Sequence[str]],\n                                    bindings: Optional[Sequence[str]],\n                                    finalize_config: bool = True,\n                                    skip_unknown: bool = False,\n                                    print_includes_and_imports: bool = False):\n  """"""Parse a list of config files followed by extra Gin bindings.\n\n  This function is equivalent to:\n\n      for config_file in config_files:\n        gin.parse_config_file(config_file, skip_configurables)\n      gin.parse_config(bindings, skip_configurables)\n      if finalize_config:\n        gin.finalize()\n\n  Args:\n    config_files: A list of paths to the Gin config files.\n    bindings: A list of individual parameter binding strings.\n    finalize_config: Whether to finalize the config after parsing and binding\n      (defaults to True).\n    skip_unknown: A boolean indicating whether unknown configurables and imports\n      should be skipped instead of causing errors (alternatively a list of\n      configurable names to skip if unknown). See `parse_config` for additional\n      details.\n    print_includes_and_imports: If true, print a summary of the hierarchy of\n      included gin config files and imported modules.\n\n  Returns:\n    includes_and_imports: List of ParsedConfigFileIncludesAndImports.\n  """"""\n  if config_files is None:\n    config_files = []\n  if bindings is None:\n    bindings = \'\'\n  nested_includes_and_imports = []\n  for config_file in config_files:\n    includes_and_imports = parse_config_file(config_file, skip_unknown)\n    nested_includes_and_imports.append(includes_and_imports)\n  parse_config(bindings, skip_unknown)\n  if finalize_config:\n    finalize()\n\n  if print_includes_and_imports:\n    for includes_and_imports in nested_includes_and_imports:\n      log_includes_and_imports(includes_and_imports)\n  return nested_includes_and_imports\n\n\ndef log_includes_and_imports(\n    file_includes_and_imports: ParsedConfigFileIncludesAndImports,\n    first_line_prefix: str = \'\',\n    prefix: str = \'\'):\n  """"""Logs a ParsedConfigFileIncludesAndImports and its includes and imports.""""""\n  logging.info(\'%s%s\', first_line_prefix, file_includes_and_imports.filename)\n  infix = \' \xe2\x94\x82\' if file_includes_and_imports.includes else \'  \'\n  if file_includes_and_imports.imports:\n    for imported_module in file_includes_and_imports.imports:\n      logging.info(\'%s%s import %s\', prefix, infix, imported_module)\n  if file_includes_and_imports.includes:\n    for i, nested_result in enumerate(file_includes_and_imports.includes):\n      if i < len(file_includes_and_imports.includes) - 1:\n        nested_first_line_prefix = prefix + \' \xe2\x94\x9c\xe2\x94\x80 \'\n        nested_prefix = prefix + \' \xe2\x94\x82 \'\n      else:\n        nested_first_line_prefix = prefix + \' \xe2\x94\x94\xe2\x94\x80 \'\n        nested_prefix = prefix + \'   \'\n      log_includes_and_imports(\n          nested_result,\n          first_line_prefix=nested_first_line_prefix,\n          prefix=nested_prefix)\n\n\ndef parse_value(value):\n  """"""Parse and return a single Gin value.""""""\n  if not isinstance(value, six.string_types):\n    raise ValueError(\'value ({}) should be a string type.\'.format(value))\n  return config_parser.ConfigParser(value, ParserDelegate()).parse_value()\n\n\ndef config_is_locked():\n  return _CONFIG_IS_LOCKED\n\n\ndef _set_config_is_locked(is_locked):\n  global _CONFIG_IS_LOCKED\n  _CONFIG_IS_LOCKED = is_locked\n\n\n@contextlib.contextmanager\ndef unlock_config():\n  """"""A context manager that temporarily unlocks the config.\n\n  Once the config has been locked by `gin.finalize`, it can only be modified\n  using this context manager (to make modifications explicit). Example:\n\n      with gin.unlock_config():\n        ...\n        gin.bind_parameter(...)\n\n  In the case where the config is already unlocked, this does nothing (the\n  config remains unlocked).\n\n  Yields:\n    None.\n  """"""\n  config_was_locked = config_is_locked()\n  _set_config_is_locked(False)\n  yield\n  _set_config_is_locked(config_was_locked)\n\n\ndef enter_interactive_mode():\n  global _INTERACTIVE_MODE\n  _INTERACTIVE_MODE = True\n\n\ndef exit_interactive_mode():\n  global _INTERACTIVE_MODE\n  _INTERACTIVE_MODE = False\n\n\n@contextlib.contextmanager\ndef interactive_mode():\n  try:\n    enter_interactive_mode()\n    yield\n  finally:\n    exit_interactive_mode()\n\n\ndef finalize():\n  """"""A function that should be called after parsing all Gin config files.\n\n  Calling this function allows registered ""finalize hooks"" to inspect (and\n  potentially modify) the Gin config, to provide additional functionality. Hooks\n  should not modify the configuration object they receive directly; instead,\n  they should return a dictionary mapping Gin binding keys to (new or updated)\n  values. This way, all hooks see the config as originally parsed.\n\n  Raises:\n    RuntimeError: If the config is already locked.\n    ValueError: If two or more hooks attempt to modify or introduce bindings for\n      the same key. Since it is difficult to control the order in which hooks\n      are registered, allowing this could yield unpredictable behavior.\n  """"""\n  if config_is_locked():\n    raise RuntimeError(\'Finalize called twice (config already locked).\')\n\n  bindings = {}\n  for hook in _FINALIZE_HOOKS:\n    new_bindings = hook(_CONFIG)\n    if new_bindings is not None:\n      for key, value in six.iteritems(new_bindings):\n        pbk = ParsedBindingKey(key)\n        if pbk in bindings:\n          err_str = \'Received conflicting updates when running {}.\'\n          raise ValueError(err_str.format(hook))\n        bindings[pbk] = value\n\n  for pbk, value in six.iteritems(bindings):\n    bind_parameter(pbk, value)\n\n  _set_config_is_locked(True)\n\n\ndef register_finalize_hook(fn):\n  """"""Registers `fn` as a hook that will run during `gin.finalize`.\n\n  All finalize hooks should accept the current config, and return a dictionary\n  containing any additional parameter bindings that should occur in the form of\n  a mapping from (scoped) configurable names to values.\n\n  Args:\n    fn: The function to register.\n\n  Returns:\n    `fn`, allowing `register_finalize_hook` to be used as a decorator.\n  """"""\n  _FINALIZE_HOOKS.append(fn)\n  return fn\n\n\ndef _iterate_flattened_values(value):\n  """"""Provides an iterator over all values in a nested structure.""""""\n  if isinstance(value, six.string_types):\n    yield value\n    return\n\n  if isinstance(value, collections.Mapping):\n    value = collections.ValuesView(value)\n\n  if isinstance(value, collections.Iterable):\n    for nested_value in value:\n      for nested_nested_value in _iterate_flattened_values(nested_value):\n        yield nested_nested_value\n\n  yield value\n\n\ndef iterate_references(config, to=None):\n  """"""Provides an iterator over references in the given config.\n\n  Args:\n    config: A dictionary mapping scoped configurable names to argument bindings.\n    to: If supplied, only yield references whose `configurable_fn` matches `to`.\n\n  Yields:\n    `ConfigurableReference` instances within `config`, maybe restricted to those\n    matching the `to` parameter if it is supplied.\n  """"""\n  for value in _iterate_flattened_values(config):\n    if isinstance(value, ConfigurableReference):\n      if to is None or value.configurable.fn_or_cls == to:\n        yield value\n\n\ndef validate_reference(ref, require_bindings=True, require_evaluation=False):\n  if require_bindings and ref.config_key not in _CONFIG:\n    err_str = ""No bindings specified for \'{}\' in config string: \\n{}""\n    raise ValueError(err_str.format(ref.scoped_selector, config_str()))\n\n  if require_evaluation and not ref.evaluate:\n    err_str = (""Reference \'{}\' must be evaluated (add \'()\') ""\n               \'in config string: \\n{}.\')\n    raise ValueError(err_str.format(ref, config_str()))\n\n\n@configurable(module=\'gin\')\ndef macro(value):\n  """"""A Gin macro.""""""\n  return value\n\n\n@configurable(\'constant\', module=\'gin\')\ndef _retrieve_constant():\n  """"""Fetches and returns a constant from the _CONSTANTS map.""""""\n  return _CONSTANTS[current_scope_str()]\n\n\n@configurable(module=\'gin\')\ndef singleton(constructor):\n  return singleton_value(current_scope_str(), constructor)\n\n\ndef singleton_value(key, constructor=None):\n  if key not in _SINGLETONS:\n    if not constructor:\n      err_str = ""No singleton found for key \'{}\', and no constructor was given.""\n      raise ValueError(err_str.format(key))\n    if not callable(constructor):\n      err_str = ""The constructor for singleton \'{}\' is not callable.""\n      raise ValueError(err_str.format(key))\n    _SINGLETONS[key] = constructor()\n  return _SINGLETONS[key]\n\n\ndef constant(name, value):\n  """"""Creates a constant that can be referenced from gin config files.\n\n  After calling this function in Python, the constant can be referenced from\n  within a Gin config file using the macro syntax. For example, in Python:\n\n      gin.constant(\'THE_ANSWER\', 42)\n\n  Then, in a Gin config file:\n\n      meaning.of_life = %THE_ANSWER\n\n  Note that any Python object can be used as the value of a constant (including\n  objects not representable as Gin literals). Values will be stored until\n  program termination in a Gin-internal dictionary, so avoid creating constants\n  with values that should have a limited lifetime.\n\n  Optionally, a disambiguating module may be prefixed onto the constant\n  name. For instance:\n\n      gin.constant(\'some.modules.PI\', 3.14159)\n\n  Args:\n    name: The name of the constant, possibly prepended by one or more\n      disambiguating module components separated by periods. An macro with this\n      name (including the modules) will be created.\n    value: The value of the constant. This can be anything (including objects\n      not representable as Gin literals). The value will be stored and returned\n      whenever the constant is referenced.\n\n  Raises:\n    ValueError: If the constant\'s selector is invalid, or a constant with the\n      given selector already exists.\n  """"""\n  if not config_parser.MODULE_RE.match(name):\n    raise ValueError(""Invalid constant selector \'{}\'."".format(name))\n\n  if _CONSTANTS.matching_selectors(name):\n    err_str = ""Constants matching selector \'{}\' already exist ({}).""\n    raise ValueError(err_str.format(name, _CONSTANTS.matching_selectors(name)))\n\n  _CONSTANTS[name] = value\n\n\ndef constants_from_enum(cls=None, module=None):\n  """"""Decorator for an enum class that generates Gin constants from values.\n\n  Generated constants have format `module.ClassName.ENUM_VALUE`. The module\n  name is optional when using the constant.\n\n  Args:\n    cls: Class type.\n    module: The module to associate with the constants, to help handle naming\n      collisions. If `None`, `cls.__module__` will be used.\n\n  Returns:\n    Class type (identity function).\n\n  Raises:\n    TypeError: When applied to a non-enum class.\n  """"""\n\n  def decorator(cls, module=module):\n    if not issubclass(cls, enum.Enum):\n      raise TypeError(""Class \'{}\' is not subclass of enum."".format(\n          cls.__name__))\n\n    if module is None:\n      module = cls.__module__\n    for value in cls:\n      constant(\'{}.{}\'.format(module, str(value)), value)\n    return cls\n\n  if cls is None:\n    return decorator\n  return decorator(cls)\n\n\n@register_finalize_hook\ndef validate_macros_hook(config):\n  for ref in iterate_references(config, to=macro):\n    validate_reference(ref, require_evaluation=True)\n\n\n@register_finalize_hook\ndef find_unknown_references_hook(config):\n  """"""Hook to find/raise errors for references to unknown configurables.""""""\n  additional_msg_fmt = "" In binding for \'{}\'.""\n  for (scope, selector), param_bindings in six.iteritems(config):\n    for param_name, param_value in six.iteritems(param_bindings):\n      for maybe_unknown in _iterate_flattened_values(param_value):\n        if isinstance(maybe_unknown, _UnknownConfigurableReference):\n          scope_str = scope + \'/\' if scope else \'\'\n          min_selector = _REGISTRY.minimal_selector(selector)\n          binding_key = \'{}{}.{}\'.format(scope_str, min_selector, param_name)\n          additional_msg = additional_msg_fmt.format(binding_key)\n          _raise_unknown_reference_error(maybe_unknown, additional_msg)\n\n\ndef markdownify_operative_config_str(string):\n  """"""Convert an operative config string to markdown format.""""""\n\n  # TODO: Total hack below. Implement more principled formatting.\n  def process(line):\n    """"""Convert a single line to markdown format.""""""\n    if not line.startswith(\'#\'):\n      return \'    \' + line\n\n    line = line[2:]\n    if line.startswith(\'====\'):\n      return \'\'\n    if line.startswith(\'None\'):\n      return \'    # None.\'\n    if line.endswith(\':\'):\n      return \'#### \' + line\n    return line\n\n  output_lines = []\n  for line in string.splitlines():\n    procd_line = process(line)\n    if procd_line is not None:\n      output_lines.append(procd_line)\n\n  return \'\\n\'.join(output_lines)\n'"
gin/config_parser.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Provides a parser for Gin configuration files.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport abc\nimport ast\nimport collections\nimport io\nimport re\nimport tokenize\n\nfrom gin import selector_map\nfrom gin import utils\n\nimport six\n\n# A regular expression matching a valid module identifier. A valid module\n# identifier consists of one or more valid identifiers (see below), separated by\n# periods (as in a Python module).\nMODULE_RE = selector_map.SELECTOR_RE\n# A regular expression matching valid identifiers. A valid identifier consists\n# of a string beginning with an alphabet character or underscore, followed by\n# any number of alphanumeric (or underscore) characters, as in Python.\nIDENTIFIER_RE = re.compile(r\'^[a-zA-Z_]\\w*$\')\n\n\nclass ParserDelegate(object):\n  """"""A delegate object used to handle certain operations while parsing.""""""\n\n  __metaclass__ = abc.ABCMeta\n\n  @abc.abstractmethod\n  def configurable_reference(self, scoped_configurable_name, evaluate):\n    """"""Called to construct an object representing a configurable reference.\n\n    Args:\n      scoped_configurable_name: The name of the configurable reference,\n        including all scopes.\n      evaluate: Whether the configurable reference should be evaluated.\n\n    Returns:\n      Should return an object representing the configurable reference.\n    """"""\n    pass\n\n  @abc.abstractmethod\n  def macro(self, macro_name):\n    """"""Called to construct an object representing an macro.\n\n    Args:\n      macro_name: The name of the macro, including all scopes.\n\n    Returns:\n      Should return an object representing the macro.\n    """"""\n    pass\n\n\nclass BindingStatement(\n    collections.namedtuple(\n        \'BindingStatement\',\n        [\'scope\', \'selector\', \'arg_name\', \'value\', \'location\'])):\n  pass\n\n\nclass ImportStatement(\n    collections.namedtuple(\'ImportStatement\', [\'module\', \'location\'])):\n  pass\n\n\nclass IncludeStatement(\n    collections.namedtuple(\'IncludeStatement\', [\'filename\', \'location\'])):\n  pass\n\n\nclass ConfigParser(object):\n  """"""A parser for configuration files/strings.\n\n  This class implements a recursive descent parser for (sequences of) parameter\n  binding strings. Each parameter binding string has the form:\n\n      maybe/some/scope/configurable_name.parameter_name = value\n\n  The `value` above may be any legal Python literal (list, tuple, dict, string,\n  number, boolean, or None). Additionally, a ""configurable reference"" literal is\n  supported, with the syntax\n\n      @maybe/some/scope/configurable_name\n\n  or\n\n      @maybe/some/scope/configurable_name()\n\n  The first form represents a reference to the configurable function itself,\n  whereas the second form represents the result of calling the configurable\n  function.\n\n  This class doesn\'t assume a specific type for configurable function\n  references, and instead allows the type to be specified at construction time.\n\n  The primary method that should be called is `parse_binding`, which parses one\n  parameter binding string. Additionally, a `parse_value` function is provided\n  which just parses a literal value.\n\n  This class implements the iterator interface, which makes it easy to iterate\n  over multiple parameter bindings (newline separated) in a given file/string.\n\n  Example:\n\n      class DummyConfigurableReferenceType(object):\n        def __init__(self, scoped_configurable_name, evaluate):\n          pass\n\n      f = open(\'/path/to/file.config\')\n      parser = config_parser.ConfigParser(f, DummyConfigurableReferenceType)\n      config = {}\n      for scoped_configurable_name, parameter_name, value in parser:\n        config.setdefault(scoped_configurable_name, {})[parameter_name] = value\n      f.close()\n  """"""\n\n  _TOKEN_FIELDS = [\'kind\', \'value\', \'begin\', \'end\', \'line\']\n\n  class Token(collections.namedtuple(\'Token\', _TOKEN_FIELDS)):\n\n    @property\n    def line_number(self):\n      return self.begin[0]\n\n  def __init__(self, string_or_filelike, parser_delegate):\n    """"""Construct the parser.\n\n    Args:\n      string_or_filelike: Either the string to parse, or a file-like object\n        supporting the readline method.\n      parser_delegate: An instance of the ParserDelegate class, that will be\n        responsible for constructing appropriate objects for configurable\n        references and macros.\n    """"""\n    if hasattr(string_or_filelike, \'readline\'):\n      line_reader = string_or_filelike.readline\n    else:  # Assume it\'s string-like.\n      if six.PY2:\n        string_or_filelike = unicode(string_or_filelike)\n      string_io = io.StringIO(string_or_filelike)\n      line_reader = string_io.readline\n\n    def _text_line_reader():\n      line = line_reader()\n      if isinstance(line, bytes):\n        line = line.decode(\'utf8\')\n      return line\n\n    self._token_generator = tokenize.generate_tokens(_text_line_reader)\n    self._filename = getattr(string_or_filelike, \'name\', None)\n    self._current_token = None\n    self._delegate = parser_delegate\n    self._advance_one_token()\n\n  def __iter__(self):\n    return self\n\n  def __next__(self):\n    return self.next()\n\n  @property\n  def current_token(self):\n    return self._current_token\n\n  def next(self):\n    statement = self.parse_statement()\n    if statement:\n      return statement\n    raise StopIteration\n\n  def parse_statement(self):\n    """"""Parse a single statement.\n\n    Returns:\n      Either a `BindingStatement`, `ImportStatement`, `IncludeStatement`, or\n      `None` if no more statements can be parsed (EOF reached).\n    """"""\n    self._skip_whitespace_and_comments()\n    if self._current_token.kind == tokenize.ENDMARKER:\n      return None\n\n    # Save off location, but ignore char_num for any statement-level errors.\n    stmt_loc = self._current_location(ignore_char_num=True)\n    binding_key_or_keyword = self._parse_selector()\n    statement = None\n    if self._current_token.value != \'=\':\n      if binding_key_or_keyword == \'import\':\n        module = self._parse_selector(scoped=False)\n        statement = ImportStatement(module, stmt_loc)\n      elif binding_key_or_keyword == \'include\':\n        str_loc = self._current_location()\n        success, filename = self._maybe_parse_basic_type()\n        if not success or not isinstance(filename, str):\n          self._raise_syntax_error(\'Expected file path as string.\', str_loc)\n        statement = IncludeStatement(filename, stmt_loc)\n      else:\n        self._raise_syntax_error(""Expected \'=\'."")\n    else:  # We saw an \'=\'.\n      self._advance_one_token()\n      value = self.parse_value()\n      scope, selector, arg_name = parse_binding_key(binding_key_or_keyword)\n      statement = BindingStatement(scope, selector, arg_name, value, stmt_loc)\n\n    assert statement, \'Internal parsing error.\'\n\n    if (self._current_token.kind != tokenize.NEWLINE and\n        self._current_token.kind != tokenize.ENDMARKER):\n      self._raise_syntax_error(\'Expected newline.\')\n    elif self._current_token.kind == tokenize.NEWLINE:\n      self._advance_one_token()\n\n    return statement\n\n  def parse_value(self):\n    """"""Parse a single literal value.\n\n    Returns:\n      The parsed value.\n    """"""\n    parsers = [\n        self._maybe_parse_container, self._maybe_parse_basic_type,\n        self._maybe_parse_configurable_reference, self._maybe_parse_macro\n    ]\n    for parser in parsers:\n      success, value = parser()\n      if success:\n        return value\n    self._raise_syntax_error(\'Unable to parse value.\')\n\n  def _advance_one_token(self):\n    self._current_token = ConfigParser.Token(*next(self._token_generator))\n    # Certain symbols (e.g., ""$"") cause ERRORTOKENs on all preceding space\n    # characters. Find the first non-space or non-ERRORTOKEN token.\n    while (self._current_token.kind == tokenize.ERRORTOKEN and\n           self._current_token.value in \' \\t\'):\n      self._current_token = ConfigParser.Token(*next(self._token_generator))\n\n  def advance_one_line(self):\n    """"""Advances to next line.""""""\n\n    current_line = self._current_token.line_number\n    while current_line == self._current_token.line_number:\n      self._current_token = ConfigParser.Token(*next(self._token_generator))\n\n  def _skip_whitespace_and_comments(self):\n    skippable_token_kinds = [\n        tokenize.COMMENT, tokenize.NL, tokenize.INDENT, tokenize.DEDENT\n    ]\n    while self._current_token.kind in skippable_token_kinds:\n      self._advance_one_token()\n\n  def _advance(self):\n    self._advance_one_token()\n    self._skip_whitespace_and_comments()\n\n  def _current_location(self, ignore_char_num=False):\n    line_num, char_num = self._current_token.begin\n    if ignore_char_num:\n      char_num = None\n    return (self._filename, line_num, char_num, self._current_token.line)\n\n  def _raise_syntax_error(self, msg, location=None):\n    if not location:\n      location = self._current_location()\n    raise SyntaxError(msg, location)\n\n  def _parse_dict_item(self):\n    key = self.parse_value()\n    if self._current_token.value != \':\':\n      self._raise_syntax_error(""Expected \':\'."")\n    self._advance()\n    value = self.parse_value()\n    return key, value\n\n  def _parse_selector(self, scoped=True, allow_periods_in_scope=False):\n    """"""Parse a (possibly scoped) selector.\n\n    A selector is a sequence of one or more valid Python-style identifiers\n    separated by periods (see also `SelectorMap`). A scoped selector is a\n    selector that may be preceded by scope names (separated by slashes).\n\n    Args:\n      scoped: Whether scopes are allowed.\n      allow_periods_in_scope: Whether to allow period characters in the scope\n        names preceding the selector.\n\n    Returns:\n      The parsed selector (as a string).\n\n    Raises:\n      SyntaxError: If the scope or selector is malformatted.\n    """"""\n    if self._current_token.kind != tokenize.NAME:\n      self._raise_syntax_error(\'Unexpected token.\')\n\n    begin_line_num = self._current_token.begin[0]\n    begin_char_num = self._current_token.begin[1]\n    end_char_num = self._current_token.end[1]\n    line = self._current_token.line\n\n    selector_parts = []\n    # This accepts an alternating sequence of NAME and \'/\' or \'.\' tokens.\n    step_parity = 0\n    while (step_parity == 0 and self._current_token.kind == tokenize.NAME or\n           step_parity == 1 and self._current_token.value in (\'/\', \'.\')):\n      selector_parts.append(self._current_token.value)\n      step_parity = not step_parity\n      end_char_num = self._current_token.end[1]\n      self._advance_one_token()\n    self._skip_whitespace_and_comments()\n\n    # Due to tokenization, most whitespace has been stripped already. To prevent\n    # whitespace inside the scoped selector, we verify that it matches an\n    # untokenized version of the selector obtained from the first through last\n    # character positions of the consumed tokens in the line being parsed.\n    scoped_selector = \'\'.join(selector_parts)\n    untokenized_scoped_selector = line[begin_char_num:end_char_num]\n    # Also check that it\'s properly formatted (e.g., no consecutive slashes).\n    scope_re = IDENTIFIER_RE\n    if allow_periods_in_scope:\n      scope_re = MODULE_RE\n    selector_re = MODULE_RE\n\n    scope_parts = scoped_selector.split(\'/\')\n    valid_format = all(scope_re.match(scope) for scope in scope_parts[:-1])\n    valid_format &= bool(selector_re.match(scope_parts[-1]))\n    valid_format &= bool(scoped or len(scope_parts) == 1)\n    if untokenized_scoped_selector != scoped_selector or not valid_format:\n      location = (self._filename, begin_line_num, begin_char_num + 1, line)\n      self._raise_syntax_error(\'Malformatted scope or selector.\', location)\n\n    return scoped_selector\n\n  def _maybe_parse_container(self):\n    """"""Try to parse a container type (dict, list, or tuple).""""""\n    bracket_types = {\n        \'{\': (\'}\', dict, self._parse_dict_item),\n        \'(\': (\')\', tuple, self.parse_value),\n        \'[\': (\']\', list, self.parse_value)\n    }\n    if self._current_token.value in bracket_types:\n      open_bracket = self._current_token.value\n      close_bracket, type_fn, parse_item = bracket_types[open_bracket]\n      self._advance()\n\n      values = []\n      saw_comma = False\n      while self._current_token.value != close_bracket:\n        values.append(parse_item())\n        if self._current_token.value == \',\':\n          saw_comma = True\n          self._advance()\n        elif self._current_token.value != close_bracket:\n          self._raise_syntax_error(""Expected \',\' or \'%s\'."" % close_bracket)\n\n      # If it\'s just a single value enclosed in parentheses without a trailing\n      # comma, it\'s not a tuple, so just grab the value.\n      if type_fn is tuple and len(values) == 1 and not saw_comma:\n        type_fn = lambda x: x[0]\n\n      self._advance()\n      return True, type_fn(values)\n\n    return False, None\n\n  def _maybe_parse_basic_type(self):\n    """"""Try to parse a basic type (str, bool, number).""""""\n    token_value = \'\'\n    # Allow a leading dash to handle negative numbers.\n    if self._current_token.value == \'-\':\n      token_value += self._current_token.value\n      self._advance()\n\n    basic_type_tokens = [tokenize.NAME, tokenize.NUMBER, tokenize.STRING]\n    continue_parsing = self._current_token.kind in basic_type_tokens\n    if not continue_parsing:\n      return False, None\n\n    while continue_parsing:\n      token_value += self._current_token.value\n\n      try:\n        value = ast.literal_eval(token_value)\n      except Exception as e:  # pylint: disable=broad-except\n        err_str = ""{}\\n    Failed to parse token \'{}\'""\n        self._raise_syntax_error(err_str.format(e, token_value))\n\n      was_string = self._current_token.kind == tokenize.STRING\n      self._advance()\n      is_string = self._current_token.kind == tokenize.STRING\n      continue_parsing = was_string and is_string\n\n    return True, value\n\n  def _maybe_parse_configurable_reference(self):\n    """"""Try to parse a configurable reference (@[scope/name/]fn_name[()]).""""""\n    if self._current_token.value != \'@\':\n      return False, None\n\n    location = self._current_location()\n    self._advance_one_token()\n    scoped_name = self._parse_selector(allow_periods_in_scope=True)\n\n    evaluate = False\n    if self._current_token.value == \'(\':\n      evaluate = True\n      self._advance()\n      if self._current_token.value != \')\':\n        self._raise_syntax_error(""Expected \')\'."")\n      self._advance_one_token()\n    self._skip_whitespace_and_comments()\n\n    with utils.try_with_location(location):\n      reference = self._delegate.configurable_reference(scoped_name, evaluate)\n\n    return True, reference\n\n  def _maybe_parse_macro(self):\n    """"""Try to parse an macro (%scope/name).""""""\n    if self._current_token.value != \'%\':\n      return False, None\n\n    location = self._current_location()\n    self._advance_one_token()\n    scoped_name = self._parse_selector(allow_periods_in_scope=True)\n\n    with utils.try_with_location(location):\n      macro = self._delegate.macro(scoped_name)\n\n    return True, macro\n\n\ndef parse_scoped_selector(scoped_selector):\n  """"""Parse scoped selector.""""""\n  # Conver Macro (%scope/name) to (scope/name/macro.value)\n  if scoped_selector[0] == \'%\':\n    if scoped_selector.endswith(\'.value\'):\n      err_str = \'{} is invalid cannot use % and end with .value\'\n      raise ValueError(err_str.format(scoped_selector))\n    scoped_selector = scoped_selector[1:] + \'/macro.value\'\n  scope_selector_list = scoped_selector.rsplit(\'/\', 1)\n  scope = \'\'.join(scope_selector_list[:-1])\n  selector = scope_selector_list[-1]\n  return scope, selector\n\n\ndef parse_binding_key(binding_key):\n  scope, selector = parse_scoped_selector(binding_key)\n  selector_arg_name_list = selector.rsplit(\'.\', 1)\n  selector = \'\'.join(selector_arg_name_list[0])\n  arg_name = \'\'.join(selector_arg_name_list[1:])\n  return scope, selector, arg_name\n'"
gin/selector_map.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Provides a dict-like object that handles Gin ""selectors"".""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\n\nimport six\n\n# Key used to represent terminal nodes (nodes that correspond to a complete\n# selector that was added to the map) in the selector tree.\n_TERMINAL_KEY = \'$\'\n\n# A regular expression that matches valid selectors.\nSELECTOR_RE = re.compile(r\'^([a-zA-Z_]\\w*\\.)*[a-zA-Z_]\\w*$\')\n\n\nclass SelectorMap(object):\n  """"""A dict-like object that supports partial matches of ""selectors"".\n\n  A ""selector"" is an identifier consisting of multiple components separated by\n  periods, for instance ""outer.inner.name"". The `SelectorMap` object acts like a\n  dictionary, allowing these selectors to be stored and retrieved (but currently\n  not deleted). Additionally, it supports partial matching of selectors through\n  the `matching_selectors`, `get_match`, and `get_all_matches` methods. Partial\n  matching is done from the *innermost* components of selectors. For instance\n  ""name"" and ""inner.name"" both match ""outer.inner.name"", but ""outer"" and\n  ""outer.inner"" do not.\n  """"""\n\n  def __init__(self):\n    """"""Constructs an empty `SelectorMap`.""""""\n    # Stores a suffix-tree representation of selectors as a dictionary of\n    # dictionaries (of dictionaries ...), where the top-level dictionary\'s keys\n    # are *innermost* selector components. The values in the leaves of the tree\n    # are the complete selectors corresponding to the path to the terminal.\n    self._selector_tree = {}\n    # Stores a mapping from complete selectors to values.\n    self._selector_map = {}\n\n  def clear(self):\n    self._selector_tree.clear()\n    self._selector_map.clear()\n\n  def copy(self):\n    # pylint: disable=protected-access\n    sm = SelectorMap()\n    sm._selector_tree = self._selector_tree.copy()\n    sm._selector_map = self._selector_map.copy()\n    return sm\n\n  def __copy__(self):\n    return self.copy()\n\n  def iteritems(self):\n    return six.iteritems(self._selector_map)\n\n  def items(self):\n    if six.PY2:\n      return self._selector_map.items()\n    return self.iteritems()\n\n  def __setitem__(self, complete_selector, value):\n    """"""Associates a value with `complete_selector`.\n\n    This function also performs some additional bookkeeping to facilitate\n    partial matching of selectors.\n\n    Args:\n      complete_selector: The (complete) selector to associate a value with.\n      value: The value to associate.\n\n    Raises:\n      ValueError: If `complete_selector` isn\'t a string consisting of valid\n        Python identifiers separated by periods.\n    """"""\n    if not SELECTOR_RE.match(complete_selector):\n      raise ValueError(""Invalid selector \'{}\'."".format(complete_selector))\n\n    selector_components = complete_selector.split(\'.\')\n    node = self._selector_tree\n\n    # Iterate backwards over the components of the selector.\n    for component in selector_components[::-1]:\n      node = node.setdefault(component, {})\n    node[_TERMINAL_KEY] = complete_selector\n    self._selector_map[complete_selector] = value\n\n  def __getitem__(self, complete_selector):\n    """"""Look up the value of `complete_selector` (no partial matching).""""""\n    return self._selector_map[complete_selector]\n\n  def __contains__(self, complete_selector):\n    """"""Check if `complete_selector` is present.""""""\n    return complete_selector in self._selector_map\n\n  def get(self, complete_selector, default=None):\n    """"""Look up the value of `complete_selector` if present, or `default`.""""""\n    return self._selector_map.get(complete_selector, default)\n\n  def matching_selectors(self, partial_selector):\n    """"""Retrieves all selectors matching `partial_selector`.\n\n    For instance, if ""one.a.b"" and ""two.a.b"" are stored in a `SelectorMap`, both\n    `matching_selectors(\'b\')` and `matching_selectors(\'a.b\')` will return them.\n\n    In the event that `partial_selector` exactly matches an existing complete\n    selector, only that complete selector is returned. For instance, if\n    ""a.b.c.d"" and ""c.d"" are stored, `matching_selectors(\'c.d\')` will return only\n    `[\'c.d\']`, while `matching_selectors(\'d\')` will return both.\n\n    Args:\n      partial_selector: The partial selector to find matches for.\n\n    Returns:\n      A list of selectors matching `partial_selector`.\n    """"""\n    if partial_selector in self._selector_map:\n      return [partial_selector]\n\n    selector_components = partial_selector.split(\'.\')\n    node = self._selector_tree\n\n    for component in reversed(selector_components):\n      if component not in node:\n        return []\n      node = node[component]\n\n    selectors = []\n    dfs_stack = [node]\n    while dfs_stack:\n      node = dfs_stack.pop().copy()\n      selector = node.pop(_TERMINAL_KEY, None)\n      dfs_stack.extend(node.values())\n      if selector:\n        selectors.append(selector)\n\n    return selectors\n\n  def get_match(self, partial_selector, default=None):\n    """"""Gets a (single) value matching `partial_selector`.\n\n    If the partial_selector exactly matches a complete selector, the value\n    associated with the complete selector is returned.\n\n    Args:\n      partial_selector: The partial selector to find values for.\n      default: A default value to return if nothing matches `partial_selector`.\n\n    Returns:\n      The value associated with `partial_selector` if it exists, else `default`.\n\n    Raises:\n      KeyError: If `partial_selector` matches more than one selector in the map.\n    """"""\n    matching_selectors = self.matching_selectors(partial_selector)\n    if not matching_selectors:\n      return default\n    if len(matching_selectors) > 1:\n      err_str = ""Ambiguous selector \'{}\', matches {}.""\n      raise KeyError(err_str.format(partial_selector, matching_selectors))\n    return self._selector_map[matching_selectors[0]]\n\n  def get_all_matches(self, partial_selector):\n    """"""Returns all values matching `partial_selector` as a list.""""""\n    matching_selectors = self.matching_selectors(partial_selector)\n    return [self._selector_map[selector] for selector in matching_selectors]\n\n  def minimal_selector(self, complete_selector):\n    """"""Returns the minimal selector that uniquely matches `complete_selector`.\n\n    Args:\n      complete_selector: A complete selector stored in the map.\n\n    Returns:\n      A partial selector that unambiguously matches `complete_selector`.\n\n    Raises:\n      KeyError: If `complete_selector` is not in the map.\n    """"""\n    if complete_selector not in self._selector_map:\n      raise KeyError(""No value with selector \'{}\'."".format(complete_selector))\n\n    selector_components = complete_selector.split(\'.\')\n    node = self._selector_tree\n\n    start = None\n    for i, component in enumerate(reversed(selector_components)):\n      if len(node) == 1:\n        if start is None:\n          start = -i  # Negative index, since we\'re iterating in reverse.\n      else:\n        start = None\n      node = node[component]\n\n    if len(node) > 1:  # The selector is a substring of another selector.\n      return complete_selector\n    return \'.\'.join(selector_components[start:])\n'"
gin/utils.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Some generic utility functions used by Gin.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport contextlib\nimport sys\n\nimport six\n\n\ndef augment_exception_message_and_reraise(exception, message):\n  """"""Reraises `exception`, appending `message` to its string representation.""""""\n\n  class ExceptionProxy(type(exception)):\n    """"""Acts as a proxy for an exception with an augmented message.""""""\n    __module__ = type(exception).__module__\n\n    def __init__(self):\n      pass\n\n    def __getattr__(self, attr_name):\n      return getattr(exception, attr_name)\n\n    def __str__(self):\n      return str(exception) + message\n\n  ExceptionProxy.__name__ = type(exception).__name__\n\n  proxy = ExceptionProxy()\n  if six.PY3:\n    ExceptionProxy.__qualname__ = type(exception).__qualname__\n    six.raise_from(proxy.with_traceback(exception.__traceback__), None)\n  else:\n    six.reraise(proxy, None, sys.exc_info()[2])\n\n\ndef _format_location(location):\n  filename, line_num, char_num, line = location\n  filename = \'file ""{}"",\'.format(filename) if filename else \'bindings string\'\n  line_info = \'\\n  In {filename} line {line_num}\\n    {line}\'.format(\n      filename=filename, line_num=line_num, line=line.rstrip())\n  char_info = \'\\n    {}^\'.format(\' \' * char_num) if char_num else \'\'\n  return line_info + char_info\n\n\n@contextlib.contextmanager\ndef try_with_location(location):\n  try:\n    yield\n  except Exception as exception:  # pylint: disable=broad-except\n    augment_exception_message_and_reraise(exception, _format_location(location))\n'"
tests/config_parser_test.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport ast\nimport collections\nimport pprint\nimport random\n\nfrom absl.testing import absltest\n\nfrom gin import config_parser\n\nimport six\n\n\ndef _generate_nested_value(max_depth=4, max_container_size=5):\n  def generate_int():\n    return random.randint(-10000, 10000)\n\n  def generate_float():\n    return random.random() * 10000 - 5000\n\n  def generate_bool():\n    return random.random() > 0.5\n\n  def generate_none():\n    return None\n\n  def generate_string():\n    length = random.randint(0, 10)\n    quote = random.choice([\'""\', ""\'""])\n    alphabet = \'abcdefghijklmnopqrstuvwxyz\\\\\\\'\\"" \'\n    contents = [random.choice(alphabet) for _ in range(length)]\n    return quote + \'\'.join(contents) + quote\n\n  def generate_list():\n    length = random.randint(0, max_container_size + 1)\n    return [_generate_nested_value(max_depth - 1) for _ in range(length)]\n\n  def generate_tuple():\n    return tuple(generate_list())\n\n  def generate_dict():\n    length = random.randint(0, max_container_size + 1)\n    key_generators = [generate_int, generate_float, generate_string]\n    return {\n        random.choice(key_generators)(): _generate_nested_value(max_depth - 1)\n        for _ in range(length)\n    }\n\n  generators = [\n      generate_int, generate_float, generate_bool, generate_none,\n      generate_string\n  ]\n  if max_depth > 0:\n    generators.extend([generate_list, generate_tuple, generate_dict])\n\n  return random.choice(generators)()\n\n\nclass _TestConfigurableReference(\n    collections.namedtuple(\'_TestConfigurableReference\', [\'name\', \'evaluate\'])):\n  pass\n\n\nclass _TestMacro(collections.namedtuple(\'_TestMacro\', [\'name\'])):\n  pass\n\n\nclass _TestParserDelegate(config_parser.ParserDelegate):\n\n  def __init__(self, raise_error=False):\n    self._raise_error = raise_error\n\n  def configurable_reference(self, scoped_name, evaluate):\n    if self._raise_error:\n      raise ValueError(\'Unknown configurable.\')\n    return _TestConfigurableReference(scoped_name, evaluate)\n\n  def macro(self, scoped_name):\n    if self._raise_error:\n      raise ValueError(\'Bad macro.\')\n    return _TestMacro(scoped_name)\n\n\nclass ConfigParserTest(absltest.TestCase):\n\n  def _parse_value(self, literal):\n    parser = config_parser.ConfigParser(literal, _TestParserDelegate())\n    return parser.parse_value()\n\n  def _validate_against_literal_eval(self, literal):\n    parsed_value = self._parse_value(literal)\n    self.assertEqual(parsed_value, ast.literal_eval(literal))\n\n  def _assert_raises_syntax_error(self, literal):\n    with self.assertRaises(SyntaxError):\n      self._parse_value(literal)\n\n  def _parse_config(self,\n                    config_str,\n                    only_bindings=True,\n                    generate_unknown_reference_errors=False):\n    parser = config_parser.ConfigParser(\n        config_str, _TestParserDelegate(generate_unknown_reference_errors))\n\n    config = {}\n    imports = []\n    includes = []\n    for statement in parser:\n      if isinstance(statement, config_parser.BindingStatement):\n        scope, selector, arg_name, value, _ = statement\n        config.setdefault((scope, selector), {})[arg_name] = value\n      elif isinstance(statement, config_parser.ImportStatement):\n        imports.append(statement.module)\n      elif isinstance(statement, config_parser.IncludeStatement):\n        includes.append(statement.filename)\n\n    if only_bindings:\n      return config\n    return config, imports, includes\n\n  def testParseRandomLiterals(self):\n    # Try a bunch of random nested Python structures and make sure we can parse\n    # them back to the correct value.\n    random.seed(42)\n    for _ in range(1000):\n      value = _generate_nested_value()\n      literal = pprint.pformat(value)\n      parsed_value = self._parse_value(literal)\n      self.assertEqual(value, parsed_value)\n\n  def testInvalidBasicType(self):\n    with self.assertRaises(SyntaxError) as assert_raises:\n      self._parse_config(""""""\n        scope/some_fn.arg1 = None\n        scope/some_fn.arg2 = Garbage  # <-- Not a valid Python value.\n      """""")\n    self.assertEqual(assert_raises.exception.lineno, 3)\n    self.assertEqual(assert_raises.exception.offset, 29)\n    self.assertEqual(\n        assert_raises.exception.text.strip(),\n        \'scope/some_fn.arg2 = Garbage  # <-- Not a valid Python value.\')\n    six.assertRegex(self, str(assert_raises.exception),\n                    r""malformed (string|node or string: <_ast.Name [^\\n]+>)\\n""\n                    r""    Failed to parse token \'Garbage\' \\(line 3\\)"")\n\n  def testUnknownConfigurableAndMacro(self):\n    with six.assertRaisesRegex(self, ValueError, \'line 2\\n.*@raise_an_error\'):\n      self._parse_config(\n          \'\\n\'.join([\n              \'some_fn.arg1 = None\',\n              \'some_fn.arg2 = @raise_an_error\',\n          ]),\n          generate_unknown_reference_errors=True)\n\n    with six.assertRaisesRegex(self, ValueError, \'line 2\\n.*%raise_an_error\'):\n      self._parse_config(\n          \'\\n\'.join([\n              \'some_fn.arg1 = None\',\n              \'some_fn.arg2 = %raise_an_error\',\n          ]),\n          generate_unknown_reference_errors=True)\n\n  def testSyntaxCornerCases(self):\n    # Trailing commas are ok.\n    self._validate_against_literal_eval(\'[1, 2, 3,]\')\n    # Two trailing commas are not ok.\n    self._assert_raises_syntax_error(\'[1, 2, 3,,]\')\n\n    # Parens without trailing comma is not a tuple.\n    self._validate_against_literal_eval(\'(1)\')\n    # Parens with trailing comma is a tuple.\n    self._validate_against_literal_eval(\'(1,)\')\n\n    # Newlines inside a container are ok.\n    self._validate_against_literal_eval(""""""{\n        1: 2, 3: 4\n    }"""""")\n    self._validate_against_literal_eval(""""""(-\n        5)"""""")\n    # Newlines outside a container are not ok.\n    self._assert_raises_syntax_error(""""""\n        [1, 2, 3]"""""")\n\n    # Missing quotes are bad.\n    self._assert_raises_syntax_error(""\'missing quote"")\n\n    # Adjacent strings concatenate.\n    value = self._parse_value(""""""(\n        \'one \' \'two \'\n        \'three\'\n    )"""""")\n    # They also concatenate when doing explicit line continuation.\n    self.assertEqual(value, \'one two three\')\n    value = self._parse_value(r""""""\'one \' \\\n        \'two \' \\\n        \'three\'\n    """""")\n    self.assertEqual(value, \'one two three\')\n\n    # Triple-quoted strings work fine.\n    self._validate_against_literal_eval(\'\'\'""""""\n      I\'m a triple quoted string!\n    """"""\'\'\')\n    self._validate_against_literal_eval(""""""\'\'\'\n      I\'m a triple quoted string too!\n    \'\'\'"""""")\n\n  def testConfigurableReferences(self):\n    configurable_reference = self._parse_value(\'@a/scoped/configurable\')\n    self.assertEqual(configurable_reference.name, \'a/scoped/configurable\')\n    self.assertFalse(configurable_reference.evaluate)\n\n    configurable_reference = self._parse_value(\'@a/scoped/configurable()\')\n    self.assertEqual(configurable_reference.name, \'a/scoped/configurable\')\n    self.assertTrue(configurable_reference.evaluate)\n\n    # Space after @ and around parens is ok, if hideous.\n    configurable_reference = self._parse_value(\'@ a/scoped/configurable ( )\')\n    self.assertEqual(configurable_reference.name, \'a/scoped/configurable\')\n    self.assertTrue(configurable_reference.evaluate)\n\n    configurable_reference = self._parse_value(\'@ configurable ( )\')\n    self.assertEqual(configurable_reference.name, \'configurable\')\n    self.assertTrue(configurable_reference.evaluate)\n\n    # Spaces inside the configurable name or scope are verboten.\n    self._assert_raises_syntax_error(\'@a / scoped /configurable\')\n\n    # Configurable references deep in the bowels of a nested structure work too.\n    literal = """"""{\n      \'some key\': [1, 2, (@a/reference(),)]\n    }""""""\n    value = self._parse_value(literal)\n    configurable_reference = value[\'some key\'][2][0]\n    self.assertEqual(configurable_reference.name, \'a/reference\')\n    self.assertTrue(configurable_reference.evaluate)\n\n    # Test a list of configurable references.\n    value = self._parse_value(\'[@ref1, @scoped/ref2, @ref3]\')\n    self.assertLen(value, 3)\n    self.assertEqual(value[0].name, \'ref1\')\n    self.assertFalse(value[0].evaluate)\n    self.assertEqual(value[1].name, \'scoped/ref2\')\n    self.assertFalse(value[1].evaluate)\n    self.assertEqual(value[2].name, \'ref3\')\n    self.assertFalse(value[2].evaluate)\n\n    # Test mix of configurable references with output references.\n    value = self._parse_value(\'[@ref1(), @scoped/ref2(), @ref3]\')\n    self.assertLen(value, 3)\n    self.assertEqual(value[0].name, \'ref1\')\n    self.assertTrue(value[0].evaluate)\n    self.assertEqual(value[1].name, \'scoped/ref2\')\n    self.assertTrue(value[1].evaluate)\n    self.assertEqual(value[2].name, \'ref3\')\n    self.assertFalse(value[2].evaluate)\n\n    multiline = r""""""[\n      @ref1\n    ]""""""\n    value = self._parse_value(multiline)\n    self.assertLen(value, 1)\n    self.assertEqual(value[0].name, \'ref1\')\n    self.assertFalse(value[0].evaluate)\n\n  def testMacros(self):\n    value = self._parse_value(\'%pele\')\n    self.assertIsInstance(value, _TestMacro)\n    self.assertEqual(value.name, \'pele\')\n\n    value = self._parse_value(\'%one.two.three\')\n    self.assertIsInstance(value, _TestMacro)\n    self.assertEqual(value.name, \'one.two.three\')\n\n    # Commit all kinds of atrocities with whitespace here.\n    value_str = """"""[%ronaldinho,\n      ( %robert/galbraith, {\n        \'Samuel Clemens\':       %mark/twain,\n        \'Charles Dodgson\':\n%lewis/carroll     ,\n\'Eric Blair\':            %george_orwell})\n    ]""""""\n    expected_result = [\n        _TestMacro(\'ronaldinho\'), (_TestMacro(\'robert/galbraith\'), {\n            \'Samuel Clemens\': _TestMacro(\'mark/twain\'),\n            \'Charles Dodgson\': _TestMacro(\'lewis/carroll\'),\n            \'Eric Blair\': _TestMacro(\'george_orwell\')\n        })\n    ]\n    value = self._parse_value(value_str)\n    self.assertEqual(value, expected_result)\n\n    # But it doesn\'t do anything foul to newlines.\n    still_an_error = """"""function.arg =\n%macro""""""\n    with self.assertRaises(SyntaxError):\n      self._parse_config(still_an_error)\n\n  def testScopeAndSelectorFormat(self):\n    config = self._parse_config(""""""\n      a = 0\n      a1.B2.c = 1\n      scope/name = %macro\n      scope/fn.param = %a.b  # Periods in macros are OK (e.g. for constants).\n      a/scope/fn.param = 4\n    """""")\n    self.assertEqual(config[\'\', \'a\'], {\'\': 0})\n    self.assertEqual(config[\'\', \'a1.B2\'], {\'c\': 1})\n    self.assertEqual(config[\'scope\', \'name\'], {\'\': _TestMacro(\'macro\')})\n    self.assertEqual(config[\'scope\', \'fn\'], {\'param\': _TestMacro(\'a.b\')})\n    self.assertEqual(config[\'a/scope\', \'fn\'], {\'param\': 4})\n\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'1a = 3\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'dotted.scope/name.value = 3\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'a..b = 3\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'a/.b = 3\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'a/b. = 3\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'a//b = 3\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'//b = 3\')\n\n  def testParseImports(self):\n    config_str = """"""\n      import some.module.name  # Comment afterwards ok.\n      import another.module.name\n    """"""\n    _, imports, _ = self._parse_config(config_str, only_bindings=False)\n    self.assertEqual(imports, [\'some.module.name\', \'another.module.name\'])\n\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'import a.0b\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'import a.b.\')\n\n  def testParseIncludes(self):\n    config_str = """"""\n      include \'a/file/path.gin\'\n      include ""another/"" ""path.gin""\n    """"""\n    _, _, includes = self._parse_config(config_str, only_bindings=False)\n    self.assertEqual(includes, [\'a/file/path.gin\', \'another/path.gin\'])\n\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'include path/to/file.gin\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'include None\')\n    with self.assertRaises(SyntaxError):\n      self._parse_config(\'include 123\')\n\n  def testParseConfig(self):\n    config_str = r""""""\n      # Leading comments are cool.\n\n      import some.module.with.configurables\n      import another.module.providing.configs\n\n      include \'another/gin/file.gin\'\n\n      a/b/c/d.param_name = {\n          \'super sweet\': \'multi line\',\n          \'dictionary\': \'!\',  # And trailing comments too.\n      }\n\n      include \'path/to/config/file.gin\'\n\n      # They work fine in the middle.\n      import module\n\n      # Line continuations are fine!\n      moar.goodness = \\\n        [\'a\', \'moose\']\n\n      # And at the end!\n    """"""\n    config, imports, includes = self._parse_config(\n        config_str, only_bindings=False)\n\n    expected_config = {\n        (\'a/b/c\', \'d\'): {\n            \'param_name\': {\n                \'super sweet\': \'multi line\',\n                \'dictionary\': \'!\'\n            }\n        },\n        (\'\', \'moar\'): {\n            \'goodness\': [\'a\', \'moose\']\n        }\n    }\n    self.assertEqual(config, expected_config)\n\n    expected_imports = [\n        \'some.module.with.configurables\', \'another.module.providing.configs\',\n        \'module\'\n    ]\n    self.assertEqual(imports, expected_imports)\n\n    expected_includes = [\'another/gin/file.gin\', \'path/to/config/file.gin\']\n    self.assertEqual(includes, expected_includes)\n\n\nif __name__ == \'__main__\':\n  absltest.main()\n'"
tests/config_py3_test.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# python3\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import absltest\n\nfrom gin import config\n\n\n@config.configurable\ndef fn_with_kw_only_args(arg1, *, kwarg1=None):\n  return arg1, kwarg1\n\n\n@config.configurable\ndef fn_with_kw_only_required_arg(arg1, *, kwarg1=config.REQUIRED):\n  return arg1, kwarg1\n\n\nclass ConfigTest(absltest.TestCase):\n\n  def tearDown(self):\n    config.clear_config()\n    super(ConfigTest, self).tearDown()\n\n  def testKwOnlyArgs(self):\n    config_str = """"""\n      fn_with_kw_only_args.arg1 = \'arg1\'\n      fn_with_kw_only_args.kwarg1 = \'kwarg1\'\n    """"""\n\n    arg, kwarg = fn_with_kw_only_args(None)\n    self.assertEqual(arg, None)\n    self.assertEqual(kwarg, None)\n    self.assertIn(\'fn_with_kw_only_args.kwarg1 = None\',\n                  config.operative_config_str())\n\n    config.parse_config(config_str)\n\n    arg, kwarg = fn_with_kw_only_args(\'arg1\')\n    self.assertEqual(arg, \'arg1\')\n    self.assertEqual(kwarg, \'kwarg1\')\n    self.assertIn(""fn_with_kw_only_args.kwarg1 = \'kwarg1\'"",\n                  config.operative_config_str())\n\n  def testKwOnlyRequiredArgs(self):\n    expected_err_regexp = (\n        r\'Required bindings for `fn_with_kw_only_args` not provided in config: \'\n        r""\\[\'kwarg1\'\\]"")\n    with self.assertRaisesRegex(RuntimeError, expected_err_regexp):\n      fn_with_kw_only_args(\'positional\', kwarg1=config.REQUIRED)\n\n  def testKwOnlyRequiredArgsInSignature(self):\n    expected_err_regexp = (\n        r\'Required bindings for `fn_with_kw_only_required_arg` not provided in \'\n        r""config: \\[\'kwarg1\'\\]"")\n    with self.assertRaisesRegex(RuntimeError, expected_err_regexp):\n      fn_with_kw_only_required_arg(\'positional\')\n    arg, kwarg = fn_with_kw_only_required_arg(\'positional\', kwarg1=\'a value\')\n    self.assertEqual(arg, \'positional\')\n    self.assertEqual(kwarg, \'a value\')\n\n\nif __name__ == \'__main__\':\n  absltest.main()\n'"
tests/config_test.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport abc\nimport collections\nimport inspect\nimport io\nimport logging\nimport os\nimport threading\n\nfrom absl.testing import absltest\n\nimport enum\nfrom gin import config\nimport six\n\n\n_EXPECTED_OPERATIVE_CONFIG_STR = """"""\nimport gin.testdata.import_test_configurables\n\n# Macros:\n# ==============================================================================\npen_names = [\'Pablo Neruda\', \'Voltaire\', \'Snoop Lion\']\nsuper/sweet = \'lugduname\'\n\n# Parameters for configurable1:\n# ==============================================================================\nconfigurable1.kwarg1 = \\\\\n    \'a super duper extra double very wordy string that is just plain long\'\nconfigurable1.kwarg2 = None\nconfigurable1.kwarg3 = @configurable2\n\n# Parameters for configurable2:\n# ==============================================================================\nconfigurable2.non_kwarg = \'ferret == domesticated polecat\'\n\n# Parameters for ConfigurableClass:\n# ==============================================================================\nConfigurableClass.kwarg1 = \'statler\'\nConfigurableClass.kwarg2 = \'waldorf\'\n\n# Parameters for test/scopes/ConfigurableClass:\n# ==============================================================================\ntest/scopes/ConfigurableClass.kwarg1 = \'statler\'\ntest/scopes/ConfigurableClass.kwarg2 = \'beaker\'\n\n# Parameters for ConfigurableSubclass:\n# ==============================================================================\nConfigurableSubclass.kwarg1 = \'waldorf\'\nConfigurableSubclass.kwarg2 = None\nConfigurableSubclass.kwarg3 = \'ferret\'\n\n# Parameters for woolly.sheep.dolly:\n# ==============================================================================\nwoolly.sheep.dolly.kwarg = 0\n\n# Parameters for no_arg_fn:\n# ==============================================================================\n# None.\n\n# Parameters for var_arg_fn:\n# ==============================================================================\nvar_arg_fn.any_name_is_ok = [%THE_ANSWER, %super/sweet, %pen_names]\nvar_arg_fn.dict_value = {\'success\': True}\nvar_arg_fn.float_value = 2.718\nvar_arg_fn.non_kwarg2 = \\\\\n    {\'long\': [\'nested\',\n              \'structure\',\n              (\'that\', \'will\', \'span\'),\n              \'more\',\n              (\'than\', 1),\n              \'line\']}\n""""""\n\n_EXPECTED_CONFIG_STR = """"""\nimport gin.testdata.import_test_configurables\n\n# Macros:\n# ==============================================================================\npen_names = [\'Pablo Neruda\', \'Voltaire\', \'Snoop Lion\']\nsuper/sweet = \'lugduname\'\n\n# Parameters for configurable1:\n# ==============================================================================\nconfigurable1.kwarg1 = \\\\\n    \'a super duper extra double very wordy string that is just plain long\'\nconfigurable1.kwarg3 = @configurable2\n\n# Parameters for configurable2:\n# ==============================================================================\nconfigurable2.non_kwarg = \'ferret == domesticated polecat\'\n\n# Parameters for ConfigurableClass:\n# ==============================================================================\nConfigurableClass.kwarg1 = \'statler\'\nConfigurableClass.kwarg2 = \'waldorf\'\n\n# Parameters for test/scopes/ConfigurableClass:\n# ==============================================================================\ntest/scopes/ConfigurableClass.kwarg2 = \'beaker\'\n\n# Parameters for ConfigurableSubclass:\n# ==============================================================================\nConfigurableSubclass.kwarg1 = \'waldorf\'\nConfigurableSubclass.kwarg3 = \'ferret\'\n\n# Parameters for woolly.sheep.dolly:\n# ==============================================================================\nwoolly.sheep.dolly.kwarg = 0\n\n# Parameters for var_arg_fn:\n# ==============================================================================\nvar_arg_fn.any_name_is_ok = [%THE_ANSWER, %super/sweet, %pen_names]\nvar_arg_fn.dict_value = {\'success\': True}\nvar_arg_fn.float_value = 2.718\nvar_arg_fn.non_kwarg2 = \\\\\n    {\'long\': [\'nested\',\n              \'structure\',\n              (\'that\', \'will\', \'span\'),\n              \'more\',\n              (\'than\', 1),\n              \'line\']}\n""""""\n\n\n@config.configurable(\'configurable1\')\ndef fn1(non_kwarg, kwarg1=None, kwarg2=None, kwarg3=None):\n  return non_kwarg, kwarg1, kwarg2, kwarg3\n\n\n@config.configurable\ndef configurable2(non_kwarg, kwarg1=None):\n  return non_kwarg, kwarg1\n\n\n@config.configurable(whitelist=[\'whitelisted\'])\ndef whitelisted_configurable(whitelisted=None, other=None):\n  return whitelisted, other\n\n\n@config.configurable(blacklist=[\'blacklisted\'])\ndef blacklisted_configurable(blacklisted=None, other=None):\n  return blacklisted, other\n\n\n@config.configurable\ndef required_args(arg1, arg2, arg3, kwarg1=4, kwarg2=5, kwarg3=6):\n  return arg1, arg2, arg3, kwarg1, kwarg2, kwarg3\n\n\n@config.configurable\ndef required_with_vargs(arg1, arg2, arg3, *args, **kwargs):\n  return arg1, arg2, arg3, args, kwargs\n\n\n@config.configurable\ndef required_with_vkwargs(arg1,\n                          arg2,\n                          arg3,\n                          kwarg1=4,\n                          kwarg2=5,\n                          kwarg3=6,\n                          **kwargs):\n  return arg1, arg2, arg3, kwarg1, kwarg2, kwarg3, kwargs\n\n\n@config.configurable\ndef no_arg_fn():\n  pass\n\n\n@config.configurable\ndef var_arg_fn(non_kwarg1, non_kwarg2, *args, **kwargs):\n  all_non_kwargs = [non_kwarg1, non_kwarg2] + list(args)\n  return all_non_kwargs + [kwargs[key] for key in sorted(kwargs)]\n\n\n@config.configurable(\'dolly\', module=\'__main__\')\ndef clone0(kwarg=None):\n  return kwarg\n\n\n@config.configurable(\'dolly\', module=\'a.furry.sheep\')\ndef clone1(kwarg=None):\n  return kwarg\n\n\n@config.configurable(\'dolly\', module=\'a.woolly.sheep\')\ndef clone2(kwarg=None):\n  return kwarg\n\n\n@config.configurable(\'a.fuzzy.sheep.dolly\')\ndef clone3(kwarg=None):\n  return kwarg\n\n\n@config.configurable(\'sheep.dolly\', module=\'a.hairy\')\ndef clone4(kwarg=None):\n  return kwarg\n\n\n@config.configurable\ndef new_object():\n  return object()\n\n\n@config.configurable\ndef required_as_kwarg_default(positional_arg, required_kwarg=config.REQUIRED):\n  return positional_arg, required_kwarg\n\n\n@config.configurable\nclass ConfigurableClass(object):\n  """"""A configurable class.""""""\n\n  def __init__(self, kwarg1=None, kwarg2=None):\n    self.kwarg1 = kwarg1\n    self.kwarg2 = kwarg2\n\n\n@config.configurable\nclass ConfigurableSubclass(ConfigurableClass):\n  """"""A subclass of a configurable class.""""""\n\n  def __init__(self, kwarg1=None, kwarg2=None, kwarg3=None):\n    super(ConfigurableSubclass, self).__init__(kwarg1, kwarg2)\n    self.kwarg3 = kwarg3\n\n\nNamedTuple = collections.namedtuple(\'ConfigurableNamedTuple\',\n                                    [\'field1\', \'field2\'])\n\n\n@config.configurable\nclass ConfigurableNamedTuple(NamedTuple):\n  pass\n\n\n@config.register\nclass RegisteredExternalNamedTuple(NamedTuple):\n  pass\n\n\n@config.configurable\ndef create_named_tuple(named_tuple, *args):\n  return named_tuple(*args)\n\n\nconfigurable_external_named_tuple = config.external_configurable(\n    NamedTuple, \'ExternalConfigurableNamedTuple\')\n\n\n@config.configurable\nclass ObjectSubclassWithoutInit(object):\n  """"""A class that subclasses object but doesn\'t define its own __init__.\n\n  While there\'s nothing to configure in this class, it may still be desirable to\n  instantiate such a class from within Gin and bind it to something else.\n  """"""\n\n  @config.configurable(module=\'ObjectSubclassWithoutInit\')\n  def method(self, arg1=\'default\'):\n    return arg1\n\n\nclass ExternalClass(object):\n  """"""A class we\'ll pretend was defined somewhere else.""""""\n\n  __module__ = \'timbuktu\'\n\n  def __init__(self, kwarg1=None, kwarg2=None):\n    self.kwarg1 = kwarg1\n    self.kwarg2 = kwarg2\n\nconfigurable_external_class = config.external_configurable(\n    ExternalClass, \'ExternalConfigurable\')\nconfig.external_configurable(ExternalClass, \'module.ExternalConfigurable2\')\n\n\n@config.configurable\nclass ConfigurableExternalSubclass(configurable_external_class):\n  """"""Subclassing an external configurable object.\n\n  This is a configurable subclass (of the configurable subclass implicitly\n  created by external_configurable) of the ExternalClass class.\n  """"""\n\n  def __init__(self, kwarg1=None, kwarg2=None, kwarg3=None):\n    super(ConfigurableExternalSubclass, self).__init__(\n        kwarg1=kwarg1, kwarg2=kwarg2)\n    self.kwarg3 = kwarg3\n\n\nclass AbstractConfigurable(object):\n  __metaclass__ = abc.ABCMeta\n\n  def __init__(self, kwarg1=None):\n    self.kwarg1 = kwarg1\n\n  @abc.abstractmethod\n  def implement_me(self):\n    pass\n\n\n@config.configurable\nclass AbstractConfigurableSubclass(AbstractConfigurable):\n\n  def __init__(self, kwarg1=None, kwarg2=None):\n    super(AbstractConfigurableSubclass, self).__init__(kwarg1=kwarg1)\n    self.kwarg2 = kwarg2\n\n  @config.configurable\n  def implement_me(self, method_arg=\'arglebargle\'):\n    return method_arg\n\n\nclass ExternalAbstractConfigurableSubclass(AbstractConfigurable):\n\n  def implement_me(self):\n    pass\n\nconfig.external_configurable(ExternalAbstractConfigurableSubclass)\n\n\nclass ConfigTest(absltest.TestCase):\n\n  def tearDown(self):\n    config.clear_config(clear_constants=True)\n    super(ConfigTest, self).tearDown()\n\n  def testConfigurable(self):\n    config.bind_parameter(\'configurable1.kwarg1\', \'value1\')\n    config.bind_parameter(\'configurable1.kwarg2\', \'value2\')\n\n    self.assertEqual(fn1(\'value0\'), (\'value0\', \'value1\', \'value2\', None))\n\n  def testInvalidNameOrModule(self):\n    with six.assertRaisesRegex(self, ValueError, \'invalid.$\'):\n      config.configurable(\'0ops\')(lambda _: None)\n\n    with six.assertRaisesRegex(self, ValueError, \'invalid.$\'):\n      config.configurable(\'\')(lambda _: None)\n\n    with six.assertRaisesRegex(self, ValueError, \'Module .* invalid\'):\n      config.configurable(\'ok\', module=\'not.0k\')(lambda _: None)\n\n    with six.assertRaisesRegex(self, ValueError, \'Module .* invalid\'):\n      config.configurable(\'fine\', module=\'\')(lambda _: None)\n\n  def testParseConfigFromFilelike(self):\n    config_str = u""""""\n       configurable1.kwarg1 = \'stringval\'\n       configurable1.kwarg2 = 0\n       configurable1.kwarg3 = [0, 1, \'hello\']\n    """"""\n    string_io = io.StringIO(config_str)\n    config.parse_config(string_io)\n    self.assertEqual(fn1(\'value0\'), (\'value0\', \'stringval\', 0, [0, 1, \'hello\']))\n\n  def testParseConfigFromSingleString(self):\n    config_str = """"""\n       configurable1.kwarg1 = \'stringval\'\n       configurable1.kwarg2 = 0\n       configurable1.kwarg3 = [0, 1, \'hello\']\n    """"""\n    config.parse_config(config_str)\n    self.assertEqual(fn1(\'value0\'), (\'value0\', \'stringval\', 0, [0, 1, \'hello\']))\n\n  def testParseConfigFromList(self):\n    config_str = [\n        \'configurable1.kwarg1 = ""stringval""\', \'configurable1.kwarg2 = 0\',\n        \'configurable1.kwarg3 = [0, 1, ""hello""]\'\n    ]\n    config.parse_config(config_str)\n    self.assertEqual(fn1(\'value0\'), (\'value0\', \'stringval\', 0, [0, 1, \'hello\']))\n\n  def testParseConfigImportsAndIncludes(self):\n    config_str = """"""\n      import gin.testdata.import_test_configurables\n      include \'{}\'\n\n      identity.param = \'success\'\n      ConfigurableClass.kwarg1 = @identity()\n      ConfigurableClass.kwarg2 = @my_other_func()\n    """"""\n    include_path = os.path.join(\n        absltest.get_default_test_srcdir(),\n        \'gin/testdata/my_other_func.gin\')\n    config.parse_config(config_str.format(include_path))\n    self.assertEqual(ConfigurableClass().kwarg1, \'success\')\n    self.assertEqual(ConfigurableClass().kwarg2, (-2.9, 9.3, \'Oh, Dear.\'))\n\n    with six.assertRaisesRegex(self, ImportError, \'No module\'):\n      config.parse_config(\'import nonexistent.module\')\n\n    with self.assertRaises(IOError):\n      config.parse_config(""include \'nonexistent/file\'"")\n\n  def testInvalidIncludeError(self):\n    config_file = os.path.join(\n        absltest.get_default_test_srcdir(),\n        \'gin/testdata/invalid_include.gin\')\n    err_msg_regex = (\'Unable to open file: not/a/valid/file.gin. \'\n                     \'Searched config paths:\')\n    with six.assertRaisesRegex(self, IOError, err_msg_regex):\n      config.parse_config_file(config_file)\n\n  def testExplicitParametersOverrideGin(self):\n    config_str = """"""\n      configurable1.non_kwarg = \'non_kwarg\'\n      configurable1.kwarg1 = \'kwarg1\'\n      configurable1.kwarg3 = \'kwarg3\'\n    """"""\n    config.parse_config(config_str)\n    # pylint: disable=no-value-for-parameter\n    non_kwarg, kwarg1, kwarg2, kwarg3 = fn1(kwarg1=\'ahoy\', kwarg3=\'matey!\')\n    # pylint: enable=no-value-for-parameter\n    self.assertEqual(non_kwarg, \'non_kwarg\')\n    self.assertEqual(kwarg1, \'ahoy\')\n    self.assertEqual(kwarg2, None)\n    self.assertEqual(kwarg3, \'matey!\')\n\n  def testUnknownReference(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = \'okie dokie\'\n      unknown.kwarg1 = \'kwarg1\'\n    """"""\n    expected_err_msg = (""No configurable matching \'unknown\'.\\n""\n                        ""  In bindings string line 3"")\n    with six.assertRaisesRegex(self, ValueError, expected_err_msg):\n      config.parse_config(config_str)\n\n  def testSkipUnknown(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = \'okie dokie\'\n      unknown.kwarg1 = \'kwarg1\'\n    """"""\n    with self.assertRaises(ValueError):\n      config.parse_config(config_str)\n    expected_err_msg = ""No configurable matching \'unknown\'""\n    with six.assertRaisesRegex(self, ValueError, expected_err_msg):\n      config.parse_config(config_str, skip_unknown=[\'moose\'])\n    config.parse_config(config_str, skip_unknown=[\'unknown\'])\n    config.parse_config(config_str, skip_unknown=True)\n    self.assertEqual(ConfigurableClass().kwarg1, \'okie dokie\')\n\n  def testSkipUnknownImports(self):\n    config_str = """"""\n      import not.a.real.module\n    """"""\n    with self.assertRaises(ImportError):\n      config.parse_config(config_str)\n    with absltest.mock.patch.object(logging, \'info\') as mock_log:\n      config.parse_config(config_str, skip_unknown=True)\n      found_log = False\n      for log in mock_log.call_args_list:\n        log = log[0][0] % tuple(log[0][1:])\n        if \'not.a.real.module\' in log:\n          if \'Traceback\' in log:\n            self.fail(\'Traceback included for non-nested unknown import log.\')\n          else:\n            found_log = True\n            break\n      self.assertTrue(\n          found_log, msg=\'Did not log import error.\')\n\n  def testSkipUnknownNestedImport(self):\n    config_str = """"""\n      import gin.testdata.invalid_import\n    """"""\n    with self.assertRaises(ImportError):\n      config.parse_config(config_str)\n    with absltest.mock.patch.object(logging, \'info\') as mock_log:\n      config.parse_config(config_str, skip_unknown=True)\n      found_log = False\n      for args, _ in mock_log.call_args_list:\n        log = args[0] % tuple(args[1:])\n        if \'gin.testdata.invalid_import\' in log and \'Traceback\' in log:\n          found_log = True\n          break\n      self.assertTrue(\n          found_log, msg=\'Did not log traceback of nested import error.\')\n\n  def testSkipUnknownReference(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = [1, @UnknownReference()]\n      ConfigurableClass.kwarg2 = 12345\n      configurable2.kwarg1 = \'bog snorkelling\'\n      unknown.kwarg1 = @UnknownReference\n    """"""\n    expected_err_msg = (\n        r""No configurable matching reference \'@UnknownReference\\(\\)\'"")\n    with six.assertRaisesRegex(self, ValueError, expected_err_msg):\n      config.parse_config(config_str)\n    with six.assertRaisesRegex(self, ValueError, expected_err_msg):\n      config.parse_config(config_str, skip_unknown=[\'moose\'])\n\n    config.parse_config(\n        config_str, skip_unknown=[\'UnknownReference\', \'unknown\'])\n    _, kwarg1_val = configurable2(None)\n    self.assertEqual(kwarg1_val, \'bog snorkelling\')\n\n    config.parse_config(config_str, skip_unknown=True)\n    _, kwarg1_val = configurable2(None)\n    self.assertEqual(kwarg1_val, \'bog snorkelling\')\n\n    with six.assertRaisesRegex(self, ValueError, expected_err_msg):\n      ConfigurableClass()\n    addl_msg = "".* In binding for \'ConfigurableClass.kwarg1\'""\n    with six.assertRaisesRegex(self, ValueError, expected_err_msg + addl_msg):\n      config.finalize()\n\n    config.bind_parameter(\'ConfigurableClass.kwarg1\', \'valid\')\n    instance = ConfigurableClass()\n    config.finalize()\n    self.assertEqual(instance.kwarg1, \'valid\')\n    self.assertEqual(instance.kwarg2, 12345)\n\n  def testParameterValidation(self):\n    config.parse_config(\'var_arg_fn.anything_is_fine = 0\')\n\n    err_regexp = "".* doesn\'t have a parameter.*\\n  In bindings string line 1""\n    with six.assertRaisesRegex(self, ValueError, err_regexp):\n      config.parse_config(\'configurable2.not_a_parameter = 0\')\n    with six.assertRaisesRegex(self, ValueError, err_regexp):\n      config.parse_config(\'ConfigurableClass.not_a_parameter = 0\')\n\n    config.external_configurable(lambda arg: arg, \'lamdba1\', blacklist=[\'arg\'])\n    config.external_configurable(lambda arg: arg, \'lambda2\', whitelist=[\'arg\'])\n\n    err_regexp = \'.* not a parameter of\'\n    with six.assertRaisesRegex(self, ValueError, err_regexp):\n      config.external_configurable(\n          lambda arg: arg, \'lambda3\', blacklist=[\'nonexistent\'])\n    with six.assertRaisesRegex(self, ValueError, err_regexp):\n      config.external_configurable(\n          lambda arg: arg, \'lambda4\', whitelist=[\'nonexistent\'])\n\n  def testMissingPositionalParameter(self):\n    config.parse_config(""""""\n       required_args.arg2 = None\n       required_args.kwarg2 = None\n    """""")\n    err_regexp = (r"".*\\n  No values supplied .*: \\[\'arg3\'\\]\\n""\n                  r""  Gin had values bound for: \\[\'arg2\', \'kwarg2\'\\]\\n""\n                  r""  Caller supplied values for: \\[\'arg1\', \'kwarg1\'\\]"")\n    with six.assertRaisesRegex(self, TypeError, err_regexp):\n      required_args(None, kwarg1=None)  # pylint: disable=no-value-for-parameter\n\n  def testMissingPositionalParameterVarargs(self):\n    config.parse_config(""""""\n       required_with_vargs.arg2 = None\n       required_with_vargs.kwarg2 = None\n    """""")\n    err_regexp = (r"".*\\n  No values supplied .*: \\[\'arg3\'\\]\\n""\n                  r""  Gin had values bound for: \\[\'arg2\', \'kwarg2\'\\]\\n""\n                  r""  Caller supplied values for: \\[\'arg1\', \'kwarg1\'\\]"")\n    with six.assertRaisesRegex(self, TypeError, err_regexp):\n      # pylint: disable=no-value-for-parameter\n      required_with_vargs(None, kwarg1=None)\n\n  def testSubclassParametersOverrideSuperclass(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = \'base_kwarg1\'\n      ConfigurableClass.kwarg2 = \'base_kwarg2\'\n\n      ConfigurableSubclass.kwarg1 = \'sub_kwarg1\'\n      ConfigurableSubclass.kwarg2 = \'sub_kwarg2\'\n      ConfigurableSubclass.kwarg3 = \'sub_kwarg3\'\n    """"""\n    config.parse_config(config_str)\n\n    base = ConfigurableClass()\n    self.assertEqual(base.kwarg1, \'base_kwarg1\')\n    self.assertEqual(base.kwarg2, \'base_kwarg2\')\n\n    sub = ConfigurableSubclass()\n    self.assertEqual(sub.kwarg1, \'sub_kwarg1\')\n    self.assertEqual(sub.kwarg2, \'sub_kwarg2\')\n    self.assertEqual(sub.kwarg3, \'sub_kwarg3\')\n\n  def testPositionalArgumentsOverrideConfig(self):\n    config_str = """"""\n      configurable2.non_kwarg = \'non_kwarg\'\n    """"""\n    config.parse_config(config_str)\n\n    # Our Gin config works.\n    non_kwarg, _ = configurable2()  # pylint: disable=no-value-for-parameter\n    self.assertEqual(non_kwarg, \'non_kwarg\')\n\n    # Gin gets overridden by an explicitly supplied positional argument.\n    non_kwarg, _ = configurable2(\'overridden\')\n    self.assertEqual(non_kwarg, \'overridden\')\n\n    # But we haven\'t broken a legitimate error.\n    with self.assertRaises(TypeError):\n      # pylint: disable=redundant-keyword-arg\n      configurable2(\'positional\', non_kwarg=\'duplicate\')\n      # pylint: enable=redundant-keyword-arg\n\n  def testParseConfigurableReferences(self):\n    config_str = """"""\n      configurable1.kwarg1 = \'stringval\'\n      configurable1.kwarg2 = @scoped/configurable2()\n      configurable1.kwarg3 = @configurable2\n      scoped/configurable2.non_kwarg = \'wombat\'\n      configurable2.kwarg1 = {\'success\': True}\n    """"""\n    config.parse_config(config_str)\n    value0, value1, value2, value3 = fn1(\'value0\')\n    self.assertEqual((value0, value1), (\'value0\', \'stringval\'))\n    self.assertEqual(value2, (\'wombat\', {\'success\': True}))\n    self.assertTrue(callable(value3))\n    self.assertEqual(value3(\'muppeteer\'), (\'muppeteer\', {\'success\': True}))\n\n  def testConfigurableClass(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = \'statler\'\n      ConfigurableClass.kwarg2 = \'waldorf\'\n    """"""\n    config.parse_config(config_str)\n    instance = ConfigurableClass()\n    self.assertEqual(instance.kwarg1, \'statler\')\n    self.assertEqual(instance.kwarg2, \'waldorf\')\n\n  def testConfigurableReferenceClassIdentityIsPreserved(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = \'hi\'\n      configurable2.non_kwarg = @ConfigurableClass\n      configurable2.kwarg1 = @ConfigurableClass()\n    """"""\n    config.parse_config(config_str)\n    # pylint: disable=no-value-for-parameter\n    reference, instance = configurable2()\n    # pylint: enable=no-value-for-parameter\n    self.assertTrue(inspect.isclass(reference))\n    self.assertTrue(issubclass(reference, ConfigurableClass))\n    self.assertIsInstance(instance, ConfigurableClass)\n\n  def testConfigurableSubclass(self):\n    config_str = """"""\n      configurable2.non_kwarg = @ConfigurableSubclass\n      configurable2.kwarg1 = @ConfigurableClass\n\n      ConfigurableClass.kwarg1 = \'one\'\n      ConfigurableSubclass.kwarg1 = \'some\'\n      ConfigurableSubclass.kwarg3 = \'thing\'\n    """"""\n    config.parse_config(config_str)\n    # pylint: disable=no-value-for-parameter\n    sub_cls_ref, super_cls_ref = configurable2()\n    # pylint: enable=no-value-for-parameter\n    self.assertTrue(inspect.isclass(super_cls_ref))\n    self.assertTrue(inspect.isclass(sub_cls_ref))\n\n    sub_instance = sub_cls_ref()\n    super_instance = super_cls_ref()\n\n    self.assertTrue(issubclass(sub_cls_ref, ConfigurableClass))\n    self.assertIsInstance(sub_instance, ConfigurableClass)\n\n    # Because references always wrap the original class via subclassing, other\n    # subclasses of the original class are not subclasses of the reference.\n    self.assertFalse(issubclass(sub_cls_ref, super_cls_ref))\n    self.assertNotIsInstance(sub_instance, super_cls_ref)\n    self.assertNotIsInstance(sub_instance, type(super_instance))\n\n    self.assertEqual(super_instance.kwarg1, \'one\')\n    self.assertEqual(super_instance.kwarg2, None)\n    self.assertEqual(sub_instance.kwarg1, \'some\')\n    self.assertEqual(sub_instance.kwarg2, None)\n    self.assertEqual(sub_instance.kwarg3, \'thing\')\n\n  def testConfigurableMethod(self):\n    config_str = """"""\n      configurable2.non_kwarg = @scoped/AbstractConfigurableSubclass()\n      implement_me.method_arg = \'bananaphone\'\n    """"""\n    config.parse_config(config_str)\n    instance, _ = configurable2()  # pylint: disable=no-value-for-parameter\n    self.assertEqual(instance.implement_me(), \'bananaphone\')\n\n  def testExternalConfigurableClass(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = @ExternalConfigurable\n      ConfigurableClass.kwarg2 = @module.ExternalConfigurable2\n      ExternalConfigurable.kwarg1 = \'statler\'\n      ExternalConfigurable.kwarg2 = \'waldorf\'\n    """"""\n    config.parse_config(config_str)\n    configurable_class = ConfigurableClass()\n    cls = configurable_class.kwarg1\n    self.assertTrue(issubclass(cls, ExternalClass))\n    self.assertEqual(cls.__module__, ExternalClass.__module__)\n    self.assertEqual(cls.__name__, ExternalClass.__name__)\n    self.assertEqual(cls.__doc__, ExternalClass.__doc__)\n    self.assertTrue(issubclass(configurable_class.kwarg2, ExternalClass))\n\n    instance = cls()\n    self.assertIsInstance(instance, ExternalClass)\n    self.assertEqual(instance.kwarg1, \'statler\')\n    self.assertEqual(instance.kwarg2, \'waldorf\')\n\n  def testAbstractExternalConfigurableClass(self):\n    config_str = """"""\n      configurable2.non_kwarg = @ExternalAbstractConfigurableSubclass()\n      configurable2.kwarg1 = @ConfigurableClass()\n      ExternalAbstractConfigurableSubclass.kwarg1 = \'fish\'\n    """"""\n    config.parse_config(config_str)\n    # pylint: disable=no-value-for-parameter\n    instance, not_instance = configurable2()\n    # pylint: enable=no-value-for-parameter\n    self.assertIsInstance(instance, AbstractConfigurable)\n    self.assertNotIsInstance(not_instance, AbstractConfigurable)\n\n  def testImplicitlyScopedConfigurableClass(self):\n    config_str = """"""\n      configurable2.non_kwarg = @scope1/ConfigurableClass\n      configurable2.kwarg1 = @scope2/ConfigurableClass\n      scope1/ConfigurableClass.kwarg1 = \'scope1arg1\'\n      scope1/ConfigurableClass.kwarg2 = \'scope1arg2\'\n      scope2/ConfigurableClass.kwarg1 = \'scope2arg1\'\n      scope2/ConfigurableClass.kwarg2 = \'scope2arg2\'\n    """"""\n    config.parse_config(config_str)\n    # pylint: disable=no-value-for-parameter\n    scope1_cls, scope2_cls = configurable2()\n    # pylint: enable=no-value-for-parameter\n    self.assertEqual(scope1_cls.__module__, ConfigurableClass.__module__)\n    self.assertEqual(scope1_cls.__name__, ConfigurableClass.__name__)\n    self.assertEqual(scope1_cls.__doc__, ConfigurableClass.__doc__)\n    scope1_instance = scope1_cls()\n    scope2_instance = scope2_cls()\n    self.assertEqual(scope1_instance.kwarg1, \'scope1arg1\')\n    self.assertEqual(scope1_instance.kwarg2, \'scope1arg2\')\n    self.assertEqual(scope2_instance.kwarg1, \'scope2arg1\')\n    self.assertEqual(scope2_instance.kwarg2, \'scope2arg2\')\n\n  def testImplicitlyScopedExternalConfigurableAndSubclass(self):\n    config_str = """"""\n      configurable2.non_kwarg = @scope1/ExternalConfigurable\n      configurable2.kwarg1 = @scope2/ConfigurableExternalSubclass\n      scope1/ExternalConfigurable.kwarg1 = \'one\'\n      scope2/ConfigurableExternalSubclass.kwarg2 = \'two\'\n      scope2/ConfigurableExternalSubclass.kwarg3 = \'three\'\n    """"""\n    config.parse_config(config_str)\n    # pylint: disable=no-value-for-parameter\n    super_cls, sub_cls = configurable2()\n    # pylint: enable=no-value-for-parameter\n    self.assertTrue(issubclass(super_cls, ExternalClass))\n    self.assertTrue(issubclass(sub_cls, ExternalClass))\n    self.assertTrue(issubclass(sub_cls, ConfigurableExternalSubclass))\n\n    super_instance, sub_instance = super_cls(), sub_cls()\n    self.assertIsInstance(super_instance, ExternalClass)\n    self.assertIsInstance(sub_instance, ConfigurableExternalSubclass)\n    self.assertIsInstance(sub_instance, ExternalClass)\n\n    self.assertEqual(super_instance.kwarg1, \'one\')\n    self.assertEqual(super_instance.kwarg2, None)\n\n    self.assertEqual(sub_instance.kwarg1, None)\n    self.assertEqual(sub_instance.kwarg2, \'two\')\n    self.assertEqual(sub_instance.kwarg3, \'three\')\n\n  def testAbstractConfigurableSubclass(self):\n    config_str = """"""\n      configurable2.non_kwarg = @scoped/AbstractConfigurableSubclass()\n      scoped/AbstractConfigurableSubclass.kwarg1 = \'kwarg1\'\n      scoped/AbstractConfigurableSubclass.kwarg2 = \'kwarg2\'\n    """"""\n    config.parse_config(config_str)\n    with config.config_scope(\'scoped\'):\n      instance = AbstractConfigurableSubclass()\n    self.assertEqual(instance.kwarg1, \'kwarg1\')\n    self.assertEqual(instance.kwarg2, \'kwarg2\')\n    self.assertEqual(instance.implement_me(method_arg=\'gouda\'), \'gouda\')\n\n    # Also try when creating from a configurable reference.\n    instance, _ = configurable2()  # pylint: disable=no-value-for-parameter\n    self.assertEqual(instance.kwarg1, \'kwarg1\')\n    self.assertEqual(instance.kwarg2, \'kwarg2\')\n    self.assertEqual(instance.implement_me(method_arg=\'havarti\'), \'havarti\')\n\n  def testConfigurableObjectSubclassWithoutInit(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = @ObjectSubclassWithoutInit()\n      ObjectSubclassWithoutInit.method.arg1 = \'valuesaurus\'\n    """"""\n    config.parse_config(config_str)\n    subclass_instance = ConfigurableClass().kwarg1\n    self.assertIsInstance(subclass_instance, ObjectSubclassWithoutInit)\n    self.assertEqual(subclass_instance.method(), \'valuesaurus\')\n\n  def testExternalConfigurableMethodWrapper(self):\n    obj_maker = config.external_configurable(object.__call__, \'obj_call\')\n    self.assertIsInstance(obj_maker(), object)\n\n  def testExternalConfigurableBuiltin(self):\n    wrapped_sum = config.external_configurable(sum)\n    self.assertEqual(wrapped_sum([1, 2, 3]), 6)\n\n  def testConfigurableNamedTuple(self):\n    config_str = """"""\n      ConfigurableNamedTuple.field1 = \'field1\'\n      ConfigurableNamedTuple.field2 = \'field2\'\n\n      ExternalConfigurableNamedTuple.field1 = \'external_field1\'\n      ExternalConfigurableNamedTuple.field2 = \'external_field2\'\n    """"""\n    config.parse_config(config_str)\n\n    configurable_named_tuple = ConfigurableNamedTuple()\n    self.assertEqual(configurable_named_tuple.field1, \'field1\')\n    self.assertEqual(configurable_named_tuple.field2, \'field2\')\n\n    configurable_named_tuple = configurable_external_named_tuple()\n    self.assertEqual(configurable_named_tuple.field1, \'external_field1\')\n    self.assertEqual(configurable_named_tuple.field2, \'external_field2\')\n\n  def testRegisteredExternalNamedTuple(self):\n    config_str = """"""\n      RegisteredExternalNamedTuple.field1 = \'external_field1\'\n      RegisteredExternalNamedTuple.field2 = \'external_field2\'\n      create_named_tuple.named_tuple = @RegisteredExternalNamedTuple\n    """"""\n    config.parse_config(config_str)\n\n    # expected = \'__new__() takes exactly 3 arguments (1 given)\'\n    with self.assertRaises(TypeError):\n      RegisteredExternalNamedTuple()\n\n    with self.assertRaises(TypeError):\n      create_named_tuple(RegisteredExternalNamedTuple)\n\n    configurable_named_tuple = create_named_tuple(config.REQUIRED)\n    self.assertEqual(configurable_named_tuple.field1, \'external_field1\')\n    self.assertEqual(configurable_named_tuple.field2, \'external_field2\')\n\n  def testFailedFunctionCall(self):\n    def some_fn(only_one_arg=None):\n      del only_one_arg\n\n    @config.configurable(\'broken_function\')\n    def borked_fn(arg):  # pylint: disable=unused-variable\n      some_fn(nonexistent_arg=arg)  # pylint: disable=unexpected-keyword-arg\n\n    config.parse_config([\n        \'configurable2.non_kwarg = @broken_function()\',\n        \'ConfigurableClass.kwarg1 = @scoped/broken_function()\',\n        \'broken_function.arg = ""mulberries""\'\n    ])\n\n    expected_msg_regexp = r""\'broken_function\' \\(<function .*borked_fn.*\\)$""\n    with six.assertRaisesRegex(self, TypeError, expected_msg_regexp):\n      configurable2()  # pylint: disable=no-value-for-parameter\n\n    expected_msg_regexp = r""\'broken_function\' \\(<.*\\) in scope \'scoped\'$""\n    with six.assertRaisesRegex(self, TypeError, expected_msg_regexp):\n      ConfigurableClass()  # pylint: disable=no-value-for-parameter\n\n  def testOperativeConfigStr(self):\n    config_str = """"""\n      import gin.testdata.import_test_configurables\n\n      configurable1.kwarg1 = \\\\\n        \'a super duper extra double very wordy string that is just plain long\'\n      configurable1.kwarg3 = @configurable2\n      configurable2.non_kwarg = \'ferret == domesticated polecat\'\n      ConfigurableClass.kwarg1 = \'statler\'\n      ConfigurableClass.kwarg2 = \'waldorf\'\n      ConfigurableSubclass.kwarg1 = \'waldorf\'\n      ConfigurableSubclass.kwarg3 = \'ferret\'\n      test/scopes/ConfigurableClass.kwarg2 = \'beaker\'\n      var_arg_fn.non_kwarg2 = {\n        \'long\': [\n          \'nested\', \'structure\', (\'that\', \'will\', \'span\'),\n          \'more\', (\'than\', 1), \'line\',\n        ]\n      }\n      var_arg_fn.any_name_is_ok = [%THE_ANSWER, %super/sweet, %pen_names]\n      var_arg_fn.float_value = 2.718\n      var_arg_fn.dict_value = {\'success\': True}\n\n      super/sweet = \'lugduname\'\n      pen_names = [\'Pablo Neruda\', \'Voltaire\', \'Snoop Lion\']\n      a.woolly.sheep.dolly.kwarg = 0\n    """"""\n    config.constant(\'THE_ANSWER\', 42)\n    config.parse_config(config_str)\n    config.finalize()\n\n    fn1(\'mustelid\')\n    # pylint: disable=no-value-for-parameter\n    configurable2(kwarg1=\'I am supplied explicitly.\')\n    # pylint: enable=no-value-for-parameter\n    ConfigurableClass()\n    ConfigurableSubclass()\n    with config.config_scope(\'test\'):\n      with config.config_scope(\'scopes\'):\n        ConfigurableClass()\n    var_arg_fn(\'non_kwarg1_value\')  # pylint: disable=no-value-for-parameter\n    no_arg_fn()\n    clone2()\n\n    applied_config_lines = config.operative_config_str().splitlines()\n    # See the definition of _EXPECTED_OPERATIVE_CONFIG_STR at top of file.\n    expected_config_lines = _EXPECTED_OPERATIVE_CONFIG_STR.splitlines()\n    self.assertEqual(applied_config_lines, expected_config_lines[1:])\n\n  def testConfigStr(self):\n    config_str = """"""\n      import gin.testdata.import_test_configurables\n\n      configurable1.kwarg1 = \\\\\n        \'a super duper extra double very wordy string that is just plain long\'\n      configurable1.kwarg3 = @configurable2\n      configurable2.non_kwarg = \'ferret == domesticated polecat\'\n      ConfigurableClass.kwarg1 = \'statler\'\n      ConfigurableClass.kwarg2 = \'waldorf\'\n      ConfigurableSubclass.kwarg1 = \'waldorf\'\n      ConfigurableSubclass.kwarg3 = \'ferret\'\n      test/scopes/ConfigurableClass.kwarg2 = \'beaker\'\n      var_arg_fn.non_kwarg2 = {\n        \'long\': [\n          \'nested\', \'structure\', (\'that\', \'will\', \'span\'),\n          \'more\', (\'than\', 1), \'line\',\n        ]\n      }\n      var_arg_fn.any_name_is_ok = [%THE_ANSWER, %super/sweet, %pen_names]\n      var_arg_fn.float_value = 2.718\n      var_arg_fn.dict_value = {\'success\': True}\n\n      super/sweet = \'lugduname\'\n      pen_names = [\'Pablo Neruda\', \'Voltaire\', \'Snoop Lion\']\n      a.woolly.sheep.dolly.kwarg = 0\n    """"""\n    config.constant(\'THE_ANSWER\', 42)\n    config.parse_config(config_str)\n    config.finalize()\n\n    config_lines = config.config_str().splitlines()\n    # See the definition of _EXPECTED_CONFIG_STR at top of file.\n    expected_config_lines = _EXPECTED_CONFIG_STR.splitlines()\n    self.assertEqual(config_lines, expected_config_lines[1:])\n\n  def testOperativeConfigStrHandlesOverrides(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = \'base_kwarg1\'\n      ConfigurableClass.kwarg2 = \'base_kwarg2\'\n      ConfigurableSubclass.kwarg1 = \'sub_kwarg1\'\n    """"""\n    config.parse_config(config_str)\n\n    ConfigurableSubclass()\n    # Initially, since ConfigurableClass had all of its parameters overwritten,\n    # none of them are logged to the operative config.\n    selector = config._REGISTRY.get_match(\'ConfigurableClass\').selector\n    self.assertEqual(config._OPERATIVE_CONFIG[\'\', selector], {})\n    selector = config._REGISTRY.get_match(\'ConfigurableSubclass\').selector\n    self.assertEqual(config._OPERATIVE_CONFIG[\'\', selector],\n                     {\'kwarg1\': \'sub_kwarg1\',\n                      \'kwarg2\': None,\n                      \'kwarg3\': None})\n\n    ConfigurableClass()\n    # Now that it\'s been called, we can see its parameters.\n    selector = config._REGISTRY.get_match(\'ConfigurableClass\').selector\n    self.assertEqual(config._OPERATIVE_CONFIG[\'\', selector],\n                     {\'kwarg1\': \'base_kwarg1\', \'kwarg2\': \'base_kwarg2\'})\n\n    ConfigurableSubclass()\n    # And they\'re still around after another call to the subclass.\n    self.assertEqual(config._OPERATIVE_CONFIG[\'\', selector],\n                     {\'kwarg1\': \'base_kwarg1\', \'kwarg2\': \'base_kwarg2\'})\n\n  def testParsingOperativeConfigStrIsIdempotent(self):\n    config_str = """"""\n      configurable1.kwarg1 = \\\\\n        \'a super duper extra double very wordy string that is just plain long\'\n      configurable1.kwarg3 = @configurable2\n      configurable2.non_kwarg = \'ferret == domesticated polecat\'\n      ConfigurableClass.kwarg1 = \'statler\'\n      ConfigurableClass.kwarg2 = \'waldorf\'\n      ConfigurableSubclass.kwarg1 = \'subclass_kwarg1\'\n      ConfigurableSubclass.kwarg3 = \'subclass_kwarg3\'\n      test/scopes/ConfigurableClass.kwarg2 = \'beaker\'\n      var_arg_fn.non_kwarg2 = {\n        \'long\': [\n          \'nested\', \'structure\', (\'that\', \'will\', \'span\'),\n          \'more\', (\'than\', 1), \'line\',\n        ]\n      }\n      var_arg_fn.any_name_is_ok = [1, 2, 3]\n      var_arg_fn.float_value = 2.718\n      var_arg_fn.dict_value = {\'success\': True}\n    """"""\n    config.parse_config(config_str)\n\n    def call_configurables():\n      fn1(\'mustelid\')\n      # pylint: disable=no-value-for-parameter\n      configurable2(kwarg1=\'I am supplied explicitly.\')\n      # pylint: enable=no-value-for-parameter\n      ConfigurableClass()\n      ConfigurableSubclass()\n      with config.config_scope(\'test\'):\n        with config.config_scope(\'scopes\'):\n          ConfigurableClass()\n      var_arg_fn(\'non_kwarg1_value\')  # pylint: disable=no-value-for-parameter\n\n    call_configurables()\n    operative_config_str = config.operative_config_str()\n\n    config.clear_config()\n    config.parse_config(operative_config_str)\n\n    call_configurables()\n    self.assertEqual(config.operative_config_str(), operative_config_str)\n\n  def testWhitelist(self):\n    config.bind_parameter(\'whitelisted_configurable.whitelisted\', 0)\n    self.assertEqual(whitelisted_configurable(), (0, None))\n    config.bind_parameter(\'scope/whitelisted_configurable.whitelisted\', 1)\n    with config.config_scope(\'scope\'):\n      self.assertEqual(whitelisted_configurable(), (1, None))\n    with self.assertRaises(ValueError):\n      config.bind_parameter(\'whitelisted_configurable.other\', 0)\n    with self.assertRaises(ValueError):\n      config.bind_parameter(\'a/b/whitelisted_configurable.other\', 0)\n\n  def testBlacklist(self):\n    config.bind_parameter(\'blacklisted_configurable.other\', 0)\n    self.assertEqual(blacklisted_configurable(), (None, 0))\n    config.bind_parameter(\'scope/blacklisted_configurable.other\', 1)\n    with config.config_scope(\'scope\'):\n      self.assertEqual(blacklisted_configurable(), (None, 1))\n    with self.assertRaises(ValueError):\n      config.bind_parameter(\'blacklisted_configurable.blacklisted\', 0)\n    with self.assertRaises(ValueError):\n      config.bind_parameter(\'a/b/blacklisted_configurable.blacklisted\', 0)\n\n  def testRequiredArgs(self):\n    with self.assertRaisesRegex(RuntimeError, \'arg1.*arg2\'):\n      required_args(config.REQUIRED, config.REQUIRED, 3)\n\n    config.bind_parameter(\'scope/required_args.arg1\', 1)\n    config.bind_parameter(\'scope/required_args.arg2\', 2)\n    with config.config_scope(\'scope\'):\n      self.assertEqual(\n          required_args(config.REQUIRED, config.REQUIRED, 3),\n          (1, 2, 3, 4, 5, 6))\n\n  def testRequiredArgsWithVargs(self):\n    with self.assertRaisesRegex(RuntimeError, \'arg1.*arg2\'):\n      required_with_vargs(config.REQUIRED, config.REQUIRED, 3, 4, 5, kwarg1=6)\n\n    config.bind_parameter(\'scope/required_with_vargs.arg1\', 1)\n    config.bind_parameter(\'scope/required_with_vargs.arg2\', 2)\n    with config.config_scope(\'scope\'):\n      expected = (1, 2, 3, (4, 5), {\'kwarg1\': 6})\n      actual = required_with_vargs(\n          config.REQUIRED, config.REQUIRED, 3, 4, 5, kwarg1=6)\n      self.assertEqual(expected, actual)\n\n  def testRequiredDisallowedInVargs(self):\n    with self.assertRaisesRegex(ValueError, \'not allowed\'):\n      required_with_vargs(1, 2, 3, config.REQUIRED)\n\n  def testRequiredKwargs(self):\n    with self.assertRaisesRegex(RuntimeError, \'kwarg1.*kwarg2|kwarg2.*kwarg1\'):\n      required_args(1, 2, 3, kwarg1=config.REQUIRED, kwarg2=config.REQUIRED)\n\n    config.bind_parameter(\'scope/required_args.kwarg1\', 4)\n    config.bind_parameter(\'scope/required_args.kwarg2\', 5)\n    with config.config_scope(\'scope\'):\n      self.assertEqual(\n          required_args(\n              1, 2, 3, kwarg1=config.REQUIRED, kwarg2=config.REQUIRED),\n          (1, 2, 3, 4, 5, 6))\n\n  def testRequiredArgsAndKwargs(self):\n    with self.assertRaisesRegex(RuntimeError,\n                                \'arg2.*kwarg1.*kwarg2|arg2.*kwarg2.*kwarg1\'):\n      required_args(\n          1, config.REQUIRED, 3, kwarg1=config.REQUIRED, kwarg2=config.REQUIRED)\n\n    config.bind_parameter(\'scope/required_args.arg3\', 3)\n    config.bind_parameter(\'scope/required_args.kwarg2\', 5)\n    with config.config_scope(\'scope\'):\n      self.assertEqual(\n          required_args(1, 2, config.REQUIRED, kwarg2=config.REQUIRED),\n          (1, 2, 3, 4, 5, 6))\n\n  def testRequiredArgsVkwargs(self):\n    with self.assertRaisesRegex(RuntimeError,\n                                \'arg2.*kwarg1.*kwarg6|arg2.*kwarg6.*kwarg1\'):\n      required_with_vkwargs(\n          1, config.REQUIRED, 3, kwarg1=config.REQUIRED, kwarg6=config.REQUIRED)\n\n    config.bind_parameter(\'scope/required_with_vkwargs.arg2\', 2)\n    config.bind_parameter(\'scope/required_with_vkwargs.kwarg1\', 4)\n    config.bind_parameter(\'scope/required_with_vkwargs.kwarg6\', 7)\n    with config.config_scope(\'scope\'):\n      expected = (1, 2, 3, 4, 5, 6, {\'kwarg6\': 7})\n      actual = required_with_vkwargs(\n          1, config.REQUIRED, 3, kwarg1=config.REQUIRED, kwarg6=config.REQUIRED)\n      self.assertEqual(expected, actual)\n\n  def testRequiredInSignature(self):\n    expected_err_regexp = (\n        r\'Required bindings for `required_as_kwarg_default` not provided in \'\n        r""config: \\[\'required_kwarg\'\\]"")\n    with self.assertRaisesRegex(RuntimeError, expected_err_regexp):\n      required_as_kwarg_default(\'positional\')\n    # No issues if REQUIRED is also passed as by caller.\n    with self.assertRaisesRegex(RuntimeError, expected_err_regexp):\n      required_as_kwarg_default(\'positional\', required_kwarg=config.REQUIRED)\n    # No issues if REQUIRED is also passed to different arg.\n    expected_err_regexp = r""config: \\[\'positional_arg\', \'required_kwarg\'\\]""\n    with self.assertRaisesRegex(RuntimeError, expected_err_regexp):\n      required_as_kwarg_default(config.REQUIRED, required_kwarg=config.REQUIRED)\n    # Everything works if all values are passed.\n    positional, kwarg = required_as_kwarg_default(\n        \'positional\', required_kwarg=\'a value\')\n    # Even if not passed as a kwarg.\n    positional, kwarg = required_as_kwarg_default(\'positional\', \'a value\')\n    self.assertEqual(positional, \'positional\')\n    self.assertEqual(kwarg, \'a value\')\n\n  def testRequiredInSignatureBlacklistWhitelist(self):\n    expected_err_regexp = (\n        r""Argument \'arg\' of \'test_required_blacklist\' \\(\'<function .+>\'\\) ""\n        r\'marked REQUIRED but blacklisted.\')\n    with self.assertRaisesRegex(ValueError, expected_err_regexp):\n      config.external_configurable(\n          lambda arg=config.REQUIRED: arg,\n          \'test_required_blacklist\',\n          blacklist=[\'arg\'])\n    expected_err_regexp = (\n        r""Argument \'arg\' of \'test_required_whitelist\' \\(\'<function .+>\'\\) ""\n        r\'marked REQUIRED but not whitelisted.\')\n    with self.assertRaisesRegex(ValueError, expected_err_regexp):\n      config.external_configurable(\n          lambda arg=config.REQUIRED, arg2=4: arg,\n          \'test_required_whitelist\',\n          whitelist=[\'arg2\'])\n\n  def testConfigScope(self):\n    config_str = """"""\n      configurable2.non_kwarg = \'no_scope_arg_0\'\n      configurable2.kwarg1 = \'no_scope_arg_1\'\n\n      scope_1/configurable2.non_kwarg = \'scope_1_arg_0\'\n      scope_1/configurable2.kwarg1 = \'scope_1_arg_1\'\n\n      scope_1/scope_2/configurable2.non_kwarg = \'scope_2_arg_0\'\n    """"""\n    config.parse_config(config_str)\n\n    # pylint: disable=no-value-for-parameter\n    self.assertEqual(configurable2(), (\'no_scope_arg_0\', \'no_scope_arg_1\'))\n    with config.config_scope(\'scope_1\'):\n      self.assertEqual(configurable2(), (\'scope_1_arg_0\', \'scope_1_arg_1\'))\n      with config.config_scope(\'scope_2\'):\n        self.assertEqual(configurable2(), (\'scope_2_arg_0\', \'scope_1_arg_1\'))\n        with config.config_scope(None):\n          expected = (\'no_scope_arg_0\', \'no_scope_arg_1\')\n          self.assertEqual(configurable2(), expected)\n        self.assertEqual(configurable2(), (\'scope_2_arg_0\', \'scope_1_arg_1\'))\n      self.assertEqual(configurable2(), (\'scope_1_arg_0\', \'scope_1_arg_1\'))\n    self.assertEqual(configurable2(), (\'no_scope_arg_0\', \'no_scope_arg_1\'))\n\n    # Test shorthand for nested scopes.\n    with config.config_scope(\'scope_1/scope_2\'):\n      self.assertEqual(configurable2(), (\'scope_2_arg_0\', \'scope_1_arg_1\'))\n\n    with six.assertRaisesRegex(self, ValueError, \'Invalid value\'):\n      with config.config_scope(4):\n        pass\n\n    with six.assertRaisesRegex(self, ValueError, \'Invalid value\'):\n      with config.config_scope(\'inv@lid/scope/name!\'):\n        pass\n\n    with six.assertRaisesRegex(self, ValueError, \'Invalid value\'):\n      with config.config_scope(0):\n        pass\n\n  def testImplicitScopes(self):\n    config_str = """"""\n      configurable2.non_kwarg = \'no_scope_non_kwarg\'\n      configurable2.kwarg1 = \'no_scope_kwarg1\'\n\n      implicit_scope_1/configurable2.non_kwarg = \'#1_non_kwarg\'\n      implicit_scope_1/configurable2.kwarg1 = \'#1_kwarg1\'\n\n      implicit_scope_2/configurable2.kwarg1 = \'#2_kwarg1\'\n\n      ConfigurableClass.kwarg1 = @implicit_scope_1/configurable2\n      ConfigurableClass.kwarg2 = @implicit_scope_2/configurable2()\n    """"""\n    config.parse_config(config_str)\n\n    value = ConfigurableClass()\n    self.assertEqual(value.kwarg1(), (\'#1_non_kwarg\', \'#1_kwarg1\'))\n    self.assertEqual(value.kwarg2, (\'no_scope_non_kwarg\', \'#2_kwarg1\'))\n\n  def testExplicitVsImplicitScopes(self):\n    config_str = """"""\n      configurable2.non_kwarg = \'no_scope_non_kwarg\'\n      configurable2.kwarg1 = \'no_scope_kwarg1\'\n\n      explicit_scope/configurable2.non_kwarg = \'explicit_non_kwarg\'\n      explicit_scope/configurable2.kwarg1 = \'explicit_scope\'\n\n      implicit_scope/configurable2.kwarg1 = \'implicit_scope\'\n\n      ConfigurableClass.kwarg1 = @implicit_scope/configurable2\n      ConfigurableClass.kwarg2 = @configurable2()\n    """"""\n    config.parse_config(config_str)\n\n    value = ConfigurableClass()\n    self.assertEqual(value.kwarg1(), (\'no_scope_non_kwarg\', \'implicit_scope\'))\n    self.assertEqual(value.kwarg2, (\'no_scope_non_kwarg\', \'no_scope_kwarg1\'))\n\n    with config.config_scope(\'explicit_scope\'):\n      value = ConfigurableClass()\n    self.assertEqual(value.kwarg1(), (\'no_scope_non_kwarg\', \'implicit_scope\'))\n    self.assertEqual(value.kwarg2, (\'explicit_non_kwarg\', \'explicit_scope\'))\n\n  def testScopingThreadSafety(self):\n\n    # pylint: disable=unused-variable\n    @config.configurable(blacklist=[\'expected_value\'])\n    def sanity_check(expected_value, config_value=None):\n      return expected_value == config_value\n\n    # pylint: enable=unused-variable\n\n    def validate_test_fn(output_list, index, test_fn):\n      for _ in range(10000):\n        output_list[index] = output_list[index] and test_fn(index)\n\n    @config.configurable\n    def run_threaded_test_fns(test_fns):\n      outputs = [True] * len(test_fns)\n      threads = []\n      for i, test_fn in enumerate(test_fns):\n        args = (outputs, i, test_fn)\n        thread = threading.Thread(target=validate_test_fn, args=args)\n        threads.append(thread)\n        thread.start()\n\n      for thread in threads:\n        thread.join()\n\n      return outputs\n\n    config_str = """"""\n      scope0/sanity_check.config_value = 0\n      scope1/sanity_check.config_value = 1\n      scope2/sanity_check.config_value = 2\n      scope3/sanity_check.config_value = 3\n\n      run_threaded_test_fns.test_fns = [\n          @scope0/sanity_check,\n          @scope1/sanity_check,\n          @scope2/sanity_check,\n          @scope3/sanity_check,\n      ]\n    """"""\n    config.parse_config(config_str)\n    outputs = run_threaded_test_fns(config.REQUIRED)\n    self.assertTrue(all(outputs))\n\n  def testIterateReferences(self):\n    config_str = """"""\n      configurable2.non_kwarg = [\n          {\'so\': @much/macro()},\n          (@nesting/macro(),)\n      ]\n      configurable2.kwarg1 = {\n          \'another\': {\'deeply\': [\'nested\', (@structure/macro(),)]}\n      }\n    """"""\n    config.parse_config(config_str)\n    macros = list(config.iterate_references(config._CONFIG, to=config.macro))\n    self.assertLen(macros, 3)\n\n  def testInteractiveMode(self):\n    @config.configurable(\'duplicate_fn\')\n    def duplicate_fn1():  # pylint: disable=unused-variable\n      return \'duplicate_fn1\'\n\n    with six.assertRaisesRegex(self, ValueError, \'A configurable matching\'):\n      @config.configurable(\'duplicate_fn\')\n      def duplicate_fn2():  # pylint: disable=unused-variable\n        pass\n\n    config_str = """"""\n      ConfigurableClass.kwarg1 = @duplicate_fn()\n    """"""\n    config.parse_config(config_str)\n    self.assertEqual(ConfigurableClass().kwarg1, \'duplicate_fn1\')\n\n    with config.interactive_mode():\n      @config.configurable(\'duplicate_fn\')\n      def duplicate_fn3():  # pylint: disable=unused-variable\n        return \'duplicate_fn3\'\n\n    with six.assertRaisesRegex(self, ValueError, \'A configurable matching\'):\n      @config.configurable(\'duplicate_fn\')\n      def duplicate_fn4():  # pylint: disable=unused-variable\n        pass\n\n    config_str = """"""\n      ConfigurableClass.kwarg1 = @duplicate_fn()\n    """"""\n    config.parse_config(config_str)\n    self.assertEqual(ConfigurableClass().kwarg1, \'duplicate_fn3\')\n\n  def testFinalizeLocksConfig(self):\n    config.finalize()\n    with self.assertRaises(RuntimeError):\n      config.parse_config(\'configurable2.non_kwarg = 3\')\n    with self.assertRaises(RuntimeError):\n      config.bind_parameter(\'configurable2.non_kwarg\', 3)\n    with self.assertRaises(RuntimeError):\n      @config.configurable\n      def bah():  # pylint: disable=unused-variable\n        pass\n    with self.assertRaises(RuntimeError):\n      config.external_configurable(RuntimeError)\n\n  def testUnlockConfig(self):\n    with config.unlock_config():\n      pass\n    self.assertFalse(config.config_is_locked())\n    config.finalize()\n    with config.unlock_config():\n      config.parse_config(\'configurable2.kwarg1 = 3\')\n    self.assertTrue(config.config_is_locked())\n    self.assertEqual(configurable2(1), (1, 3))\n\n  def testFinalizeHooks(self):\n    self.skipTest(\'b/137302565\')\n    old_finalize_hooks = config._FINALIZE_HOOKS[:]\n\n    @config.register_finalize_hook\n    def provide_binding(_):  # pylint: disable=unused-variable\n      return {\'configurable2.kwarg1\': 5}\n\n    _, kwarg = configurable2(None)\n    self.assertIsNone(kwarg)\n    config.finalize()\n    _, kwarg = configurable2(None)\n    self.assertEqual(kwarg, 5)\n\n    @config.register_finalize_hook\n    def provide_conflicting_binding(_):  # pylint: disable=unused-variable\n      # Provide a slightly different selector.\n      return {\'config_test.configurable2.kwarg1\': 7}\n\n    with self.assertRaises(ValueError), config.unlock_config():\n      config.finalize()\n\n    config._FINALIZE_HOOKS = old_finalize_hooks\n\n  def testBasicMacro(self):\n    config_str = """"""\n      batch_size/macro.value = 512\n      discriminator/num_layers/macro.value = 5\n      configurable2.non_kwarg = @batch_size/macro()\n      configurable2.kwarg1 = @discriminator/num_layers/macro()\n    """"""\n    config.parse_config(config_str)\n    # pylint:disable=no-value-for-parameter\n    batch_size, num_layers = configurable2()\n    # pylint:enable=no-value-for-parameter\n    self.assertEqual(batch_size, 512)\n    self.assertEqual(num_layers, 5)\n\n  def testOverwriteBasicMacro(self):\n    config_str = """"""\n      batch_size/macro.value = 512\n      discriminator/num_layers/macro.value = 5\n      configurable2.non_kwarg = @batch_size/macro()\n      configurable2.kwarg1 = @discriminator/num_layers/macro()\n    """"""\n    config.parse_config(config_str)\n    config.bind_parameter(\'batch_size/macro.value\', 256)\n    config.bind_parameter(\'discriminator/num_layers/macro.value\', 10)\n    # pylint:disable=no-value-for-parameter\n    batch_size, num_layers = configurable2()\n    # pylint:enable=no-value-for-parameter\n    self.assertEqual(batch_size, 256)\n    self.assertEqual(num_layers, 10)\n\n  def testSpecialMacroSyntax(self):\n    config_str = """"""\n      batch_size = 512\n      discriminator/num_layers = 5\n      configurable2.non_kwarg = %batch_size\n      configurable2.kwarg1 = %discriminator/num_layers\n    """"""\n    config.parse_config(config_str)\n    # pylint:disable=no-value-for-parameter\n    batch_size, num_layers = configurable2()\n    # pylint:enable=no-value-for-parameter\n    self.assertEqual(batch_size, 512)\n    self.assertEqual(num_layers, 5)\n\n  def testOverwriteSpecialMacroSyntax(self):\n    config_str = """"""\n      batch_size = 512\n      discriminator/num_layers = 5\n      configurable2.non_kwarg = %batch_size\n      configurable2.kwarg1 = %discriminator/num_layers\n    """"""\n    config.parse_config(config_str)\n    config.bind_parameter(\'%batch_size\', 256)\n    config.bind_parameter(\'%discriminator/num_layers\', 10)\n    # pylint:disable=no-value-for-parameter\n    batch_size, num_layers = configurable2()\n    # pylint:enable=no-value-for-parameter\n    self.assertEqual(batch_size, 256)\n    self.assertEqual(num_layers, 10)\n\n  def testUncalledMacroAtFinalize(self):\n    config_str = """"""\n      batch_size/macro.value = 512\n      configurable2.non_kwarg = ([{\'batch_size\': @batch_size/macro}],)\n    """"""\n    config.parse_config(config_str)\n    with self.assertRaises(ValueError):\n      config.finalize()\n\n  def testModuleDisambiguation(self):\n    with self.assertRaises(KeyError):\n      config.bind_parameter(\'dolly.kwarg\', 5)\n    with self.assertRaises(KeyError):\n      config.bind_parameter(\'sheep.dolly.kwarg\', 5)\n    with self.assertRaises(ValueError):\n      # Make sure the default module isn\'t prepended if the module is supplied\n      # as part of the configurable name.\n      config.bind_parameter(\'__main__.a.fuzzy.sheep.dolly.kwarg\', 5)\n\n    config_str = """"""\n      __main__.dolly.kwarg = \'\'\n      furry.sheep.dolly.kwarg = \'bah\'\n      a.woolly.sheep.dolly.kwarg = \'baaah\'\n      fuzzy.sheep.dolly.kwarg = \'baaaaah\'\n      hairy.sheep.dolly.kwarg = \'baaaaaaah\'\n      cow/woolly.sheep.dolly.kwarg = \'mooo\'\n      reference/furry.sheep.dolly.kwarg = @cow/a.woolly.sheep.dolly()\n    """"""\n    config.parse_config(config_str)\n    self.assertEqual(clone0(), \'\')\n    self.assertEqual(clone1(), \'bah\')\n    self.assertEqual(clone2(), \'baaah\')\n    self.assertEqual(clone3(), \'baaaaah\')\n    self.assertEqual(clone4(), \'baaaaaaah\')\n    with config.config_scope(\'cow\'):\n      self.assertEqual(clone2(), \'mooo\')\n    with config.config_scope(\'reference\'):\n      self.assertEqual(clone1(), \'mooo\')\n\n  def testConstant(self):\n    value = \'istanbul\'\n    config.constant(\'CONSTANTINOPLE\', value)\n    config_str = """"""\n      configurable2.non_kwarg = %CONSTANTINOPLE\n    """"""\n    config.parse_config(config_str)\n    non_kwarg, _ = configurable2()  # pylint: disable=no-value-for-parameter\n    self.assertIs(non_kwarg, value)  # We should be getting the same object.\n\n    with six.assertRaisesRegex(self, ValueError, \'Invalid constant selector\'):\n      config.constant(\'CONST@NTINOPLE\', 0)\n\n  def testConstantModuleDisambiguation(self):\n    config.constant(\'foo.PI\', 3.14)\n    config.constant(\'bar.PI\', 22/7)\n    config.constant(\'bar.E\', 2.718)\n\n    with self.assertRaises(ValueError):\n      config.parse_config(\'configurable2.non_kwarg = %PI\')\n\n    config_str = """"""\n      configurable2.non_kwarg = %foo.PI\n      configurable2.kwarg1 = %bar.PI\n      ConfigurableClass.kwarg1 = %E\n      ConfigurableClass.kwarg2 = %bar.E\n    """"""\n    config.parse_config(config_str)\n\n    non_kwarg, kwarg1 = configurable2()  # pylint: disable=no-value-for-parameter\n    self.assertEqual(non_kwarg, 3.14)\n    self.assertEqual(kwarg1, 22/7)\n\n    configurable_class = ConfigurableClass()\n    self.assertEqual(configurable_class.kwarg1, 2.718)\n    self.assertEqual(configurable_class.kwarg2, 2.718)\n\n  def testSingletons(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = @obj1/singleton()\n      ConfigurableClass.kwarg2 = @obj2/singleton()\n      error/ConfigurableClass.kwarg1 = @not_callable/singleton()\n\n      obj1/singleton.constructor = @new_object\n      obj2/singleton.constructor = @new_object\n      not_callable/singleton.constructor = @new_object()\n    """"""\n    config.parse_config(config_str)\n\n    class1 = ConfigurableClass()\n    class2 = ConfigurableClass()\n    self.assertIs(class1.kwarg1, class2.kwarg1)\n    self.assertIs(class1.kwarg2, class2.kwarg2)\n    self.assertIsNot(class1.kwarg1, class1.kwarg2)\n    self.assertIsNot(class2.kwarg1, class2.kwarg2)\n    with config.config_scope(\'error\'):\n      expected = ""The constructor for singleton \'not_callable\' is not callable.""\n      with six.assertRaisesRegex(self, ValueError, expected):\n        ConfigurableClass()\n\n  def testQueryParameter(self):\n    config.bind_parameter(\'whitelisted_configurable.whitelisted\', 0)\n    value = config.query_parameter(\'whitelisted_configurable.whitelisted\')\n    self.assertEqual(0, value)\n    with self.assertRaises(ValueError):\n      config.query_parameter(\'whitelisted_configurable.wrong_param\')\n    with self.assertRaises(ValueError):\n      config.query_parameter(\'blacklisted_configurable.blacklisted\')\n    with self.assertRaises(ValueError):\n      # Parameter not set.\n      config.query_parameter(\'whitelisted_configurable.other\')\n    with six.assertRaisesRegex(self, TypeError, \'expected string*\'):\n      config.query_parameter(4)\n\n  def testQueryConstant(self):\n    config.constant(\'Euler\', 0.5772156649)\n    self.assertEqual(0.5772156649, config.query_parameter(\'Euler\'))\n    config.constant(\'OLD.ANSWER\', 0)\n    config.constant(\'NEW.ANSWER\', 10)\n    with six.assertRaisesRegex(\n        self, ValueError, \'Ambiguous constant selector*\'):\n      config.query_parameter(\'ANSWER\')\n    self.assertEqual(0, config.query_parameter(\'OLD.ANSWER\'))\n    self.assertEqual(10, config.query_parameter(\'NEW.ANSWER\'))\n\n  def testConstantsFromEnum(self):\n\n    @config.constants_from_enum(module=\'enum_module\')\n    class SomeEnum(enum.Enum):\n      A = 0,\n      B = 1\n\n    @config.configurable\n    def f(a, b):\n      return a, b\n\n    config.parse_config(""""""\n      f.a = %enum_module.SomeEnum.A\n      f.b = %SomeEnum.B\n    """""")\n    # pylint: disable=no-value-for-parameter\n    a, b = f()\n    # pylint: enable=no-value-for-parameter\n    self.assertEqual(SomeEnum.A, a)\n    self.assertEqual(SomeEnum.B, b)\n\n  def testConstantsFromEnumWithModule(self):\n\n    class SomeOtherEnum(enum.Enum):\n      A = 0,\n      B = 1\n\n    @config.configurable\n    def g(a, b):\n      return a, b\n\n    config.constants_from_enum(SomeOtherEnum, module=\'TestModule\')\n    config.parse_config(""""""\n      g.a = %TestModule.SomeOtherEnum.A\n      g.b = %SomeOtherEnum.B\n    """""")\n    # pylint: disable=no-value-for-parameter\n    a, b = g()\n    # pylint: enable=no-value-for-parameter\n    self.assertEqual(SomeOtherEnum.A, a)\n    self.assertEqual(SomeOtherEnum.B, b)\n\n  def testConstantsFromEnumNotEnum(self):\n    expected_msg = ""Class \'FakeEnum\' is not subclass of enum.""\n    with six.assertRaisesRegex(self, TypeError, expected_msg):\n\n      # pylint: disable=unused-variable\n      @config.constants_from_enum\n      class FakeEnum(object):\n        A = 0,\n        B = 1\n\n  def testAddConfigPath(self):\n    gin_file = \'test_gin_file_location_prefix.gin\'\n    with self.assertRaises(IOError):\n      config.parse_config_files_and_bindings([gin_file], None)\n    test_srcdir = absltest.get_default_test_srcdir()\n    relative_testdata_path = \'gin/testdata\'\n    absolute_testdata_path = os.path.join(test_srcdir, relative_testdata_path)\n    config.add_config_file_search_path(absolute_testdata_path)\n    config.parse_config_files_and_bindings([gin_file], None)\n\n  def testPrintAndReturnNestedIncludesAndImports(self):\n    gin_file = \'root_with_nested_includes_and_imports.gin\'\n    test_srcdir = absltest.get_default_test_srcdir()\n    relative_testdata_path = \'gin/testdata\'\n    absolute_testdata_path = os.path.join(test_srcdir, relative_testdata_path)\n    config.add_config_file_search_path(absolute_testdata_path)\n    result = config.parse_config_files_and_bindings(\n        [gin_file], None, print_includes_and_imports=True)[0]\n    self.assertEqual(result.filename, gin_file)\n    self.assertListEqual(result.imports,\n                         [\'gin.testdata.import_test_configurables\'])\n    self.assertEqual(result.includes[0].filename, \'valid.gin\')\n    self.assertListEqual(result.includes[0].imports, [])\n    self.assertListEqual(result.includes[0].includes, [])\n    self.assertEqual(result.includes[1].filename, \'nested.gin\')\n    self.assertListEqual(result.includes[1].imports, [\'io\', \'time\'])\n    self.assertListEqual(result.includes[1].includes, [])\n\n  def testEmptyNestedIncludesAndImports(self):\n    test_srcdir = absltest.get_default_test_srcdir()\n    relative_testdata_path = \'gin/testdata\'\n    absolute_testdata_path = os.path.join(test_srcdir, relative_testdata_path)\n    config.add_config_file_search_path(absolute_testdata_path)\n    result = config.parse_config_files_and_bindings(\n        [], [\'TEST=1\'], print_includes_and_imports=True)\n    self.assertListEqual(result, [])\n\n\nif __name__ == \'__main__\':\n  absltest.main()\n'"
tests/selector_map_test.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import absltest\n\nfrom gin import selector_map\n\n\nclass SelectorMapTest(absltest.TestCase):\n\n  def testBasicOperations(self):\n    sm = selector_map.SelectorMap()\n    sm[\'signifier\'] = \'signified\'\n    sm[\'module.chain.name\'] = \'value\'\n\n    self.assertIn(\'signifier\', sm)\n    self.assertEqual(sm[\'signifier\'], \'signified\')\n    self.assertIn(\'module.chain.name\', sm)\n    self.assertEqual(sm[\'module.chain.name\'], \'value\')\n\n    with self.assertRaises(KeyError):\n      _ = sm[\'nonexistent\']\n\n  def testInvalidSelectors(self):\n    self.assertFalse(selector_map.SELECTOR_RE.match(\'.a\'))\n    self.assertFalse(selector_map.SELECTOR_RE.match(\'a.\'))\n    self.assertFalse(selector_map.SELECTOR_RE.match(\'0.a\'))\n    self.assertFalse(selector_map.SELECTOR_RE.match(\'a.0\'))\n    self.assertFalse(selector_map.SELECTOR_RE.match(\'$\'))\n    self.assertFalse(selector_map.SELECTOR_RE.match(\'a.b!\'))\n\n    sm = selector_map.SelectorMap()\n    with self.assertRaises(ValueError):\n      sm[\'0oops\'] = 0\n\n  def testPartiallyMatchingCompleteSelectors(self):\n    sm = selector_map.SelectorMap()\n    sm[\'more.specific.selector\'] = 1\n    sm[\'specific.selector\'] = 2\n    self.assertEqual(sm.get_match(\'specific.selector\'), 2)\n    self.assertEqual(sm.get_match(\'more.specific.selector\'), 1)\n    self.assertCountEqual(sm.get_all_matches(\'selector\'), [1, 2])\n    # Because \'specific.selector\' exactly matches an existing selector, it isn\'t\n    # ambiguous and `get_all_matches` only returns one value.\n    self.assertCountEqual(sm.get_all_matches(\'specific.selector\'), [2])\n\n    # Try in the reverse order.\n    sm = selector_map.SelectorMap()\n    sm[\'specific.selector\'] = 2\n    sm[\'more.specific.selector\'] = 1\n    self.assertEqual(sm.get_match(\'more.specific.selector\'), 1)\n    self.assertEqual(sm.get_match(\'specific.selector\'), 2)\n    self.assertCountEqual(sm.get_all_matches(\'selector\'), [1, 2])\n\n    self.assertEqual(\n        sm.minimal_selector(\'specific.selector\'), \'specific.selector\')\n    self.assertEqual(\n        sm.minimal_selector(\'more.specific.selector\'), \'more.specific.selector\')\n\n  def testPartialMatching(self):\n    sm = selector_map.SelectorMap()\n    sm[\'a.a.a.name\'] = \'one\'\n    sm[\'a.a.b.name\'] = 2\n    sm[\'a.a.a.moose\'] = [\'three\']\n\n    self.assertEqual(sm.get_match(\'moose\'), [\'three\'])\n    self.assertEqual(sm.get_match(\'a.name\'), \'one\')\n    self.assertEqual(sm.get_match(\'b.name\'), 2)\n    self.assertEqual(sm.get_match(\'a.b.name\'), 2)\n    self.assertEqual(sm.get_match(\'a.a.b.name\'), 2)\n    self.assertEqual(sm.get_match(\'nonexistent\', \'default\'), \'default\')\n\n  def testAmbiguityException(self):\n    sm = selector_map.SelectorMap()\n    sm[\'a.a.a.name\'] = \'one\'\n    sm[\'b.a.a.name\'] = 2\n\n    with self.assertRaisesRegexp(KeyError, \'Ambiguous\'):\n      sm.get_match(\'name\')\n    with self.assertRaisesRegexp(KeyError, \'Ambiguous\'):\n      sm.get_match(\'a.name\')\n    with self.assertRaisesRegexp(KeyError, \'Ambiguous\'):\n      sm.get_match(\'a.a.name\')\n\n    sm.get_match(\'a.a.a.name\')\n    sm.get_match(\'b.a.a.name\')\n\n  def testMinimalSelector(self):\n    sm = selector_map.SelectorMap()\n    sm[\'a.a.a.name\'] = \'one\'\n    sm[\'a.b.a.name\'] = 2\n    sm[\'a.a.a.moose\'] = [\'three\']\n\n    self.assertEqual(sm.minimal_selector(\'a.a.a.moose\'), \'moose\')\n    self.assertEqual(sm.minimal_selector(\'a.b.a.name\'), \'b.a.name\')\n\nif __name__ == \'__main__\':\n  absltest.main()\n'"
gin/testdata/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n'"
gin/testdata/import_test_configurables.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Provides a simple configurable for testing Gin imports.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n# Just using the config module, so we don\'t run Gin\'s __init__.py (which alters\n# the set of a available file readers and makes the test take ~15x longer due to\n# a dependency on TensorFlow).\nfrom gin import config\n\n\n@config.configurable\ndef identity(param=None):\n  return param\n\n\n@config.configurable\ndef my_other_func(a, b, c):\n  return a, b, c\n'"
gin/testdata/invalid_import.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Provides a simple python file that imports a non-existent module.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport nonexistent.module  # pylint: disable=unused-import\n\n'"
gin/tf/__init__.py,3,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Init file for TensorFlow-specific Gin-Config package.""""""\n\n# pylint: disable=g-import-not-at-top\n\n\n# Ensure TensorFlow is importable and its version is sufficiently recent. This\n# needs to happen before anything else, since the imports below will try to\n# import tensorflow, too.\ndef _ensure_tf_install():  # pylint: disable=g-statement-before-imports\n  """"""Attempt to import TensorFlow, and ensure its version is sufficient.\n\n  Raises:\n    ImportError: If either TensorFlow is not importable or its version is\n      inadequate.\n  """"""\n  try:\n    import tensorflow as tf\n  except ImportError:\n    # Print more informative error message, then reraise.\n    print(""\\n\\nFailed to import TensorFlow. Please note that TensorFlow is not ""\n          ""installed by default when you install Gin-Config. This is so that ""\n          ""users can decide whether to install TensorFlow, GPU-enabled ""\n          ""Tensorflow, or PyTorch. To use Gin-Config with TensorFlow, please ""\n          ""install the most recent version of TensorFlow, by following ""\n          ""instructions at https://tensorflow.org/install.\\n\\n"")\n    raise\n\n  # Update this whenever we need to depend on a newer TensorFlow release.\n  required_tensorflow_version = ""1.13.0""\n\n  import distutils.version\n\n  if (distutils.version.LooseVersion(tf.__version__) <\n      distutils.version.LooseVersion(required_tensorflow_version)):\n    raise ImportError(\n        ""This version of Gin-Config requires TensorFlow ""\n        ""version >= {required}; Detected an installation of version {present}. ""\n        ""Please upgrade TensorFlow to proceed."".format(\n            required=required_tensorflow_version,\n            present=tf.__version__))\n\n\n_ensure_tf_install()\n\n\n# Cleanup symbols to avoid polluting namespace.\nimport sys as _sys\nfor symbol in [""_ensure_tf_install"", ""_sys""]:\n  delattr(_sys.modules[__name__], symbol)\n\n\n# pylint: disable=unused-import\nfrom gin.tf.utils import GinConfigSaverHook\n\n# pylint: enable=g-import-not-at-top\n'"
gin/tf/external_configurables.py,86,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Supplies a default set of configurables from core TensorFlow.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\n\nfrom gin import config\n\nimport numpy as np\nimport tensorflow as tf\n\n# Learning rate decays.\n\nconfig.external_configurable(\n    tf.compat.v1.train.exponential_decay, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.inverse_time_decay, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.natural_exp_decay, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.polynomial_decay, module=\'tf.train\')\n\n\n@config.configurable(module=\'tf.train\')\n@functools.wraps(tf.compat.v1.train.piecewise_constant)\ndef piecewise_constant(global_step, *args, **kwargs):\n  if \'boundaries\' in kwargs:\n    kwargs[\'boundaries\'] = list(np.int64(kwargs[\'boundaries\']))\n  return tf.compat.v1.train.piecewise_constant(global_step, *args, **kwargs)\n\n\n# Losses.\n\nconfig.external_configurable(\n    tf.compat.v1.losses.absolute_difference, module=\'tf.losses\')\nconfig.external_configurable(\n    tf.compat.v1.losses.cosine_distance, module=\'tf.losses\')\nconfig.external_configurable(tf.compat.v1.losses.hinge_loss, module=\'tf.losses\')\nconfig.external_configurable(tf.compat.v1.losses.huber_loss, module=\'tf.losses\')\nconfig.external_configurable(tf.compat.v1.losses.log_loss, module=\'tf.losses\')\nconfig.external_configurable(\n    tf.compat.v1.losses.mean_pairwise_squared_error, module=\'tf.losses\')\nconfig.external_configurable(\n    tf.compat.v1.losses.mean_squared_error, module=\'tf.losses\')\nconfig.external_configurable(\n    tf.compat.v1.losses.sigmoid_cross_entropy, module=\'tf.losses\')\nconfig.external_configurable(\n    tf.compat.v1.losses.softmax_cross_entropy, module=\'tf.losses\')\nconfig.external_configurable(\n    tf.compat.v1.losses.sparse_softmax_cross_entropy, module=\'tf.losses\')\n\n# Maths.\n\nconfig.external_configurable(\n    tf.math.squared_difference, module=\'tf.math\')\n\n# Optimizers.\n\nconfig.external_configurable(\n    tf.compat.v1.train.GradientDescentOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.AdadeltaOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.AdagradOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.AdagradDAOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.MomentumOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.AdamOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.FtrlOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.ProximalGradientDescentOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.ProximalAdagradOptimizer, module=\'tf.train\')\nconfig.external_configurable(\n    tf.compat.v1.train.RMSPropOptimizer, module=\'tf.train\')\n\n# Keras optimizers.\n\nconfig.external_configurable(\n    tf.keras.optimizers.Adadelta, module=\'tf.keras.optimizers\')\nconfig.external_configurable(\n    tf.keras.optimizers.Adagrad, module=\'tf.keras.optimizers\')\nconfig.external_configurable(\n    tf.keras.optimizers.Adam, module=\'tf.keras.optimizers\')\nconfig.external_configurable(\n    tf.keras.optimizers.Adamax, module=\'tf.keras.optimizers\')\nconfig.external_configurable(\n    tf.keras.optimizers.Ftrl, module=\'tf.keras.optimizers\')\nconfig.external_configurable(\n    tf.keras.optimizers.Nadam, module=\'tf.keras.optimizers\')\nconfig.external_configurable(\n    tf.keras.optimizers.RMSprop, module=\'tf.keras.optimizers\')\nconfig.external_configurable(\n    tf.keras.optimizers.SGD, module=\'tf.keras.optimizers\')\n\n# Activation functions.\n\nconfig.external_configurable(tf.nn.crelu, \'tf.nn.crelu\')\nconfig.external_configurable(tf.nn.dropout, \'tf.nn.dropout\')\nconfig.external_configurable(tf.nn.elu, \'tf.nn.elu\')\nconfig.external_configurable(tf.nn.leaky_relu, \'tf.nn.leaky_relu\')\nconfig.external_configurable(tf.nn.relu, \'tf.nn.relu\')\nconfig.external_configurable(tf.nn.relu6, \'tf.nn.relu6\')\nconfig.external_configurable(tf.nn.sigmoid, \'tf.nn.sigmoid\')\nconfig.external_configurable(tf.nn.softmax, \'tf.nn.softmax\')\nconfig.external_configurable(tf.nn.softplus, \'tf.nn.softplus\')\nconfig.external_configurable(tf.nn.softsign, \'tf.nn.softsign\')\nconfig.external_configurable(tf.nn.tanh, \'tf.nn.tanh\')\n\n# Random distributions.\n\nconfig.external_configurable(tf.random.gamma, \'tf.random.gamma\')\nconfig.external_configurable(tf.compat.v1.random.multinomial,\n                             \'tf.random.multinomial\')\nconfig.external_configurable(tf.random.normal, \'tf.random.normal\')\nconfig.external_configurable(tf.random.poisson, \'tf.random.poisson\')\nconfig.external_configurable(tf.random.truncated_normal,\n                             \'tf.random.truncated_normal\')\nconfig.external_configurable(tf.random.uniform, \'tf.random.uniform\')\nconfig.external_configurable(tf.random.stateless_categorical,\n                             \'tf.random.stateless_categorical\')\nconfig.external_configurable(tf.random.stateless_normal,\n                             \'tf.random.stateless_normal\')\nconfig.external_configurable(tf.random.stateless_truncated_normal,\n                             \'tf.random.stateless_truncated_normal\')\nconfig.external_configurable(tf.random.stateless_uniform,\n                             \'tf.random.stateless_uniform\')\n\n# Distribution strategies.\nconfig.external_configurable(tf.compat.v2.distribute.MirroredStrategy,\n                             module=\'tf.compat.v2.distribute\')\n\n# Constants\n\nconfig.constant(\'tf.float16\', tf.float16)\nconfig.constant(\'tf.float32\', tf.float32)\nconfig.constant(\'tf.float64\', tf.float64)\nconfig.constant(\'tf.bfloat16\', tf.bfloat16)\nconfig.constant(\'tf.complex64\', tf.complex64)\nconfig.constant(\'tf.complex128\', tf.complex128)\nconfig.constant(\'tf.int8\', tf.int8)\nconfig.constant(\'tf.uint8\', tf.uint8)\nconfig.constant(\'tf.uint16\', tf.uint16)\nconfig.constant(\'tf.int16\', tf.int16)\nconfig.constant(\'tf.int32\', tf.int32)\nconfig.constant(\'tf.int64\', tf.int64)\nconfig.constant(\'tf.bool\', tf.bool)\nconfig.constant(\'tf.string\', tf.string)\nconfig.constant(\'tf.qint8\', tf.qint8)\nconfig.constant(\'tf.quint8\', tf.quint8)\nconfig.constant(\'tf.qint16\', tf.qint16)\nconfig.constant(\'tf.quint16\', tf.quint16)\nconfig.constant(\'tf.qint32\', tf.qint32)\nconfig.constant(\'tf.resource\', tf.resource)\nconfig.constant(\'tf.variant\', tf.variant)\n'"
gin/tf/utils.py,12,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Contains TensorFlow or Google-specific utilities for Gin configuration.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\n\nfrom gin import config\n\nimport tensorflow as tf\n\n# pylint: disable=g-direct-tensorflow-import\nfrom tensorflow.core.framework import summary_pb2\n# pylint: enable=g-direct-tensorflow-import\n\n\n# Register TF file reader for Gin\'s parse_config_file.\nconfig.register_file_reader(tf.io.gfile.GFile, tf.io.gfile.exists)\n\n\n@config.configurable\ndef singleton_per_graph(constructor):\n  key = (config.current_scope_str(), tf.compat.v1.get_default_graph())\n  return config.singleton_value(key, constructor)\n\n\nclass GinConfigSaverHook(tf.estimator.SessionRunHook):\n  """"""A SessionRunHook that saves and summarizes the operative config.\n\n  This hook will save Gin\'s operative configuration to a specified directory, as\n  well as optionally summarizing it so that it will appear in TensorBoard\'s\n  ""Text"" tab.\n\n  The hook should only be supplied to the chief worker in distributed training\n  setups to prevent multiple events files from being created. Similarly, if hook\n  methods are called explicitly (if not using tf.training.MonitoredSession),\n  they should only be called on the chief worker.\n  """"""\n\n  def __init__(self,\n               output_dir,\n               base_name=\'operative_config\',\n               summarize_config=True,\n               summary_writer=None,\n               include_step_in_filename=True):\n    """"""Construct the GinConfigSaverHook.\n\n    Args:\n      output_dir: The directory in which to save the operative config. This\n        should in general be the same as the directory in which summaries are\n        stored (and thus may be different for train vs. eval jobs.\n      base_name: The base name (name excluding path and extension) of the file\n        where this hook will write the operative config. Also used as the\n        summary tag if summarizing the config for display in TensorBoard.\n      summarize_config: Whether to save a summary of the operative config that\n        will be loaded by TensorBoard and displayed in its ""Text"" tab.\n      summary_writer: A tf.summary.FileWriter object to use for writing\n        summaries. If `None` (default), a FileWriter object for `output_dir`\n        will be created/retrieved by the tf.summary.FileWriterCache associated\n        with `output_dir` in `after_create_session`.\n      include_step_in_filename: A bool indicating whether to include the global\n        step when writing out the operative config file. When True, the filename\n        will be {base_name}-{global_step}.gin; when False the filename will be\n        {base_name}.gin.\n    """"""\n    self._output_dir = output_dir\n    self._base_name = base_name\n    self._summarize_config = summarize_config\n    self._summary_writer = summary_writer\n    self._include_step_in_filename = include_step_in_filename\n\n  def after_create_session(self, session=None, coord=None):\n    """"""Writes out Gin\'s operative config, and maybe adds a summary of it.""""""\n    config_str = config.operative_config_str()\n    if not tf.io.gfile.isdir(self._output_dir):\n      tf.io.gfile.makedirs(self._output_dir)\n    global_step_val = 0\n    if session is not None:\n      global_step = tf.compat.v1.train.get_global_step()\n      if global_step is not None:\n        global_step_val = session.run(global_step)\n    if self._include_step_in_filename:\n      filename = \'%s-%s.gin\' % (self._base_name, global_step_val)\n    else:\n      filename = \'%s.gin\' % self._base_name\n    config_path = os.path.join(self._output_dir, filename)\n    with tf.io.gfile.GFile(config_path, \'w\') as f:\n      f.write(config_str)\n\n    if self._summarize_config:\n      md_config_str = config.markdownify_operative_config_str(config_str)\n      summary_metadata = summary_pb2.SummaryMetadata()\n      summary_metadata.plugin_data.plugin_name = \'text\'\n      summary_metadata.plugin_data.content = b\'{}\'\n      text_tensor = tf.compat.v1.make_tensor_proto(md_config_str)\n      summary = summary_pb2.Summary()\n      summary.value.add(\n          tag=\'gin/\' + self._base_name,\n          tensor=text_tensor,\n          metadata=summary_metadata)\n      if not self._summary_writer:\n        # Creating the FileWriter also creates the events file, so it should be\n        # done here (where it is most likely to only occur on chief workers), as\n        # opposed to in the constructor.\n        self._summary_writer = tf.compat.v1.summary.FileWriterCache.get(\n            self._output_dir)\n      self._summary_writer.add_summary(summary, global_step_val)\n      self._summary_writer.flush()\n'"
gin/torch/__init__.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Init file for PyTorch-specific Gin-Config package.""""""\n\n# pylint: disable=g-import-not-at-top\n\n# Ensure PyTorch is importable and its version is sufficiently recent. This\n# needs to happen before anything else, since the imports below will try to\n# import torch, too.\nimport sys as _sys\n\n\ndef _ensure_torch_install():  # pylint: disable=g-statement-before-imports\n  """"""Attempt to import PyTorch, and ensure its version is sufficient.\n\n  Raises:\n    ImportError: If either PyTorch is not importable or its version is\n      inadequate.\n  """"""\n  try:\n    import torch\n  except ImportError:\n    # Print more informative error message, then reraise.\n    print(""\\n\\nFailed to import PyTorch. Please note that PyTorch is not ""\n          ""installed by default when you install Gin-Config. This is so that ""\n          ""users can decide whether to install TensorFlow, GPU-enabled ""\n          ""Tensorflow or Pytorch. To use Gin-Config with PyTorch, please ""\n          ""install the most recent version of PyTorch, by following ""\n          ""instructions at https://pytorch.org/get-started.\\n\\n"")\n    raise\n\n  # Update this whenever we need to depend on a newer PyTorch release.\n  required_torch_version = ""1.3.0""\n\n  import distutils.version\n\n  if (distutils.version.LooseVersion(torch.__version__) <\n      distutils.version.LooseVersion(required_torch_version)):\n    raise ImportError(\n        ""This version of Gin-Config requires PyTorch ""\n        ""version >= {required}; Detected an installation of version {present}. ""\n        ""Please upgrade PyTorch to proceed."".format(\n            required=required_torch_version, present=torch.__version__))\n\n\n_ensure_torch_install()\n\n# Cleanup symbols to avoid polluting namespace.\n# pylint: enable=g-import-not-at-top\nfor symbol in [""_ensure_torch_install"", ""_sys""]:\n  delattr(_sys.modules[__name__], symbol)\n'"
gin/torch/external_configurables.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Supplies a default set of configurables from core TensorFlow.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom gin import config\n\nimport torch\n\n# Losses.\n\nconfig.external_configurable(\n    torch.nn.modules.loss.BCELoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.BCEWithLogitsLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.CosineEmbeddingLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.CrossEntropyLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.CTCLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.HingeEmbeddingLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.KLDivLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.L1Loss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.MarginRankingLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.MSELoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.MultiLabelMarginLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.MultiLabelSoftMarginLoss,\n    module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.MultiMarginLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.NLLLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.NLLLoss2d, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.PoissonNLLLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.SmoothL1Loss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.SoftMarginLoss, module=\'torch.nn.modules.loss\')\nconfig.external_configurable(\n    torch.nn.modules.loss.TripletMarginLoss, module=\'torch.nn.modules.loss\')\n\n# Optimizers.\n\nconfig.external_configurable(torch.optim.Adadelta, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.Adagrad, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.Adam, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.Adamax, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.AdamW, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.ASGD, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.LBFGS, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.RMSprop, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.Rprop, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.SGD, module=\'torch.optim\')\nconfig.external_configurable(torch.optim.SparseAdam, module=\'torch.optim\')\n\n# Learning rate schedulers.\n\nconfig.external_configurable(\n    torch.optim.lr_scheduler.CosineAnnealingLR,\n    module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.CosineAnnealingWarmRestarts,\n    module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.CyclicLR, module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.ExponentialLR, module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.LambdaLR, module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.MultiStepLR, module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.OneCycleLR, module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.ReduceLROnPlateau,\n    module=\'torch.optim.lr_scheduler\')\nconfig.external_configurable(\n    torch.optim.lr_scheduler.StepLR, module=\'torch.optim.lr_scheduler\')\n\n# Activation functions.\n\nconfig.external_configurable(\n    torch.nn.modules.activation.CELU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.ELU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.GLU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Hardshrink,\n    module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Hardtanh, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.LeakyReLU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.LogSigmoid,\n    module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.LogSoftmax,\n    module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.MultiheadAttention,\n    module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.PReLU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.ReLU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.ReLU6, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.RReLU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.SELU, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Sigmoid, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Softmax, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Softmax2d, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Softmin, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Softplus, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Softshrink,\n    module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Softsign, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Tanh, module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Tanhshrink,\n    module=\'torch.nn.modules.activation\')\nconfig.external_configurable(\n    torch.nn.modules.activation.Threshold, module=\'torch.nn.modules.activation\')\n\n# Random distributions.\n\nconfig.external_configurable(\n    torch.distributions.bernoulli.Bernoulli,\n    module=\'torch.distributions.bernoulli\')\nconfig.external_configurable(\n    torch.distributions.beta.Beta, module=\'torch.distributions.beta\')\nconfig.external_configurable(\n    torch.distributions.binomial.Binomial,\n    module=\'torch.distributions.binomial\')\nconfig.external_configurable(\n    torch.distributions.categorical.Categorical,\n    module=\'torch.distributions.categorical\')\nconfig.external_configurable(\n    torch.distributions.cauchy.Cauchy, module=\'torch.distributions.cauchy\')\nconfig.external_configurable(\n    torch.distributions.chi2.Chi2, module=\'torch.distributions.chi2\')\nconfig.external_configurable(\n    torch.distributions.dirichlet.Dirichlet,\n    module=\'torch.distributions.dirichlet\')\nconfig.external_configurable(\n    torch.distributions.exponential.Exponential,\n    module=\'torch.distributions.exponential\')\nconfig.external_configurable(\n    torch.distributions.fishersnedecor.FisherSnedecor,\n    module=\'torch.distributions.fishersnedecor\')\nconfig.external_configurable(\n    torch.distributions.gamma.Gamma, module=\'torch.distributions.gamma\')\nconfig.external_configurable(\n    torch.distributions.geometric.Geometric,\n    module=\'torch.distributions.geometric\')\nconfig.external_configurable(\n    torch.distributions.gumbel.Gumbel, module=\'torch.distributions.gumbel\')\nconfig.external_configurable(\n    torch.distributions.half_cauchy.HalfCauchy,\n    module=\'torch.distributions.half_cauchy\')\nconfig.external_configurable(\n    torch.distributions.half_normal.HalfNormal,\n    module=\'torch.distributions.half_normal\')\nconfig.external_configurable(\n    torch.distributions.independent.Independent,\n    module=\'torch.distributions.independent\')\nconfig.external_configurable(\n    torch.distributions.laplace.Laplace, module=\'torch.distributions.laplace\')\nconfig.external_configurable(\n    torch.distributions.log_normal.LogNormal,\n    module=\'torch.distributions.log_normal\')\nconfig.external_configurable(\n    torch.distributions.lowrank_multivariate_normal.LowRankMultivariateNormal,\n    module=\'torch.distributions.lowrank_multivariate_normal\')\nconfig.external_configurable(\n    torch.distributions.multinomial.Multinomial,\n    module=\'torch.distributions.multinomial\')\nconfig.external_configurable(\n    torch.distributions.multivariate_normal.MultivariateNormal,\n    module=\'torch.distributions.multivariate_normal\')\nconfig.external_configurable(\n    torch.distributions.negative_binomial.NegativeBinomial,\n    module=\'torch.distributions.negative_binomial\')\nconfig.external_configurable(\n    torch.distributions.normal.Normal, module=\'torch.distributions.normal\')\nconfig.external_configurable(\n    torch.distributions.one_hot_categorical.OneHotCategorical,\n    module=\'torch.distributions.one_hot_categorical\')\nconfig.external_configurable(\n    torch.distributions.pareto.Pareto, module=\'torch.distributions.pareto\')\nconfig.external_configurable(\n    torch.distributions.poisson.Poisson, module=\'torch.distributions.poisson\')\nconfig.external_configurable(\n    torch.distributions.relaxed_bernoulli.LogitRelaxedBernoulli,\n    module=\'torch.distributions.relaxed_bernoulli\')\nconfig.external_configurable(\n    torch.distributions.relaxed_bernoulli.RelaxedBernoulli,\n    module=\'torch.distributions.relaxed_bernoulli\')\nconfig.external_configurable(\n    torch.distributions.relaxed_categorical.RelaxedOneHotCategorical,\n    module=\'torch.distributions.relaxed_categorical\')\nconfig.external_configurable(\n    torch.distributions.studentT.StudentT,\n    module=\'torch.distributions.studentT\')\nconfig.external_configurable(\n    torch.distributions.uniform.Uniform, module=\'torch.distributions.uniform\')\nconfig.external_configurable(\n    torch.distributions.weibull.Weibull, module=\'torch.distributions.weibull\')\n\n# Constants\n\nconfig.constant(\'torch.float16\', torch.float16)\nconfig.constant(\'torch.float32\', torch.float32)\nconfig.constant(\'torch.float64\', torch.float64)\nconfig.constant(\'torch.int8\', torch.int8)\nconfig.constant(\'torch.uint8\', torch.uint8)\nconfig.constant(\'torch.int16\', torch.int16)\nconfig.constant(\'torch.int32\', torch.int32)\nconfig.constant(\'torch.int64\', torch.int64)\n'"
tests/tf/config_test.py,7,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport gin.tf\n\nimport tensorflow as tf\n\n\nclass TFConfigTest(tf.test.TestCase):\n\n  def tearDown(self):\n    gin.clear_config()\n    super(TFConfigTest, self).tearDown()\n\n  def testAugmentExceptionMessageOnTFError(self):\n    @gin.configurable(\'config_name\')\n    def broken():\n      # Using tf.random.uniform here avoids TF optimizations around constants in\n      # graph mode (which can change the exception type vs. eager mode).\n      one_hundred = tf.random.uniform(\n          shape=(), minval=100, maxval=101, dtype=tf.int32)\n      return self.evaluate(tf.range(10)[one_hundred])\n\n    with self.assertRaises(tf.errors.InvalidArgumentError) as assert_raises:\n      broken()\n\n    self.assertIn(assert_raises.exception.message, str(assert_raises.exception))\n    # Note that in Python3 (but not Python2) the function name will be in\n    # the exception message, which is caught with the \'\\S*\'.\n    self.assertRegex(\n        str(assert_raises.exception), r""\'config_name\' \\(<function \\S*broken"")\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
tests/tf/external_configurables_test.py,22,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom gin import config\nfrom gin.tf import external_configurables  # pylint: disable=unused-import\n\nimport tensorflow as tf\n\n# Necessary for AdagradaDAOptimizer test.\nconfig.external_configurable(tf.compat.v1.train.get_global_step)\n\n\n@config.configurable\ndef fake_train_model(learning_rate, optimizer):\n  global_step = tf.compat.v1.train.get_or_create_global_step()\n  lr = learning_rate(global_step=global_step)\n  opt = optimizer(learning_rate=lr)\n  return lr, opt\n\n\n@config.configurable\ndef configurable(**kwargs):\n  return kwargs\n\n\nclass TFConfigTest(tf.test.TestCase):\n\n  def tearDown(self):\n    config.clear_config()\n    super(TFConfigTest, self).tearDown()\n\n  def testConfigureOptimizerAndLearningRate(self):\n    config_str = """"""\n      fake_train_model.learning_rate = @piecewise_constant\n      piecewise_constant.boundaries = [200000]\n      piecewise_constant.values = [0.01, 0.001]\n\n      fake_train_model.optimizer = @MomentumOptimizer\n      MomentumOptimizer.momentum = 0.95\n    """"""\n    config.parse_config(config_str)\n\n    lr, opt = fake_train_model()  # pylint: disable=no-value-for-parameter\n\n    self.assertIsInstance(opt, tf.compat.v1.train.MomentumOptimizer)\n    self.assertAlmostEqual(opt._momentum, 0.95)\n\n    global_step = tf.compat.v1.train.get_or_create_global_step()\n    self.evaluate(tf.compat.v1.global_variables_initializer())\n    self.assertAlmostEqual(self.evaluate(lr), 0.01)\n    self.evaluate(global_step.assign(300000))\n    self.assertAlmostEqual(self.evaluate(lr), 0.001)\n\n  def testOptimizersWithDefaults(self):\n    optimizers = [\n        tf.compat.v1.train.GradientDescentOptimizer,\n        tf.compat.v1.train.AdadeltaOptimizer,\n        tf.compat.v1.train.AdagradOptimizer,\n        (tf.compat.v1.train.AdagradDAOptimizer, {\n            \'global_step\': \'@get_global_step()\'\n        }),\n        (tf.compat.v1.train.MomentumOptimizer, {\n            \'momentum\': 0.9\n        }),\n        tf.compat.v1.train.AdamOptimizer,\n        tf.compat.v1.train.FtrlOptimizer,\n        tf.compat.v1.train.ProximalGradientDescentOptimizer,\n        tf.compat.v1.train.ProximalAdagradOptimizer,\n        tf.compat.v1.train.RMSPropOptimizer,\n    ]\n    constant_lr = lambda global_step: 0.01\n    for optimizer in optimizers:\n      extra_bindings = {}\n      if isinstance(optimizer, tuple):\n        optimizer, extra_bindings = optimizer\n\n      config.clear_config()\n      config_lines = [\'fake_train_model.optimizer = @%s\' % optimizer.__name__]\n      for param, val in extra_bindings.items():\n        config_lines.append(\'%s.%s = %s\' % (optimizer.__name__, param, val))\n      config.parse_config(config_lines)\n\n      # pylint: disable=no-value-for-parameter\n      _, configed_optimizer = fake_train_model(constant_lr)\n      # pylint: enable=no-value-for-parameter\n      self.assertIsInstance(configed_optimizer, optimizer)\n\n  def testDtypes(self):\n    # Spot check a few.\n    config_str = """"""\n      # Test without tf prefix, but using the prefix is strongly recommended!\n      configurable.float32 = %float32\n      # Test with tf prefix.\n      configurable.string = %tf.string\n      configurable.qint8 = %tf.qint8\n    """"""\n    config.parse_config(config_str)\n\n    vals = configurable()\n    self.assertIs(vals[\'float32\'], tf.float32)\n    self.assertIs(vals[\'string\'], tf.string)\n    self.assertIs(vals[\'qint8\'], tf.qint8)\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
tests/tf/utils_test.py,14,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n""""""Tests for gin.tf.utils.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tempfile\n\nfrom gin import config\nfrom gin.tf import utils\n\nfrom six.moves import zip\nimport tensorflow as tf\n\n# pylint: disable=g-direct-tensorflow-import\nfrom tensorflow.core.framework import summary_pb2\n# pylint: enable=g-direct-tensorflow-import\n\n\n@config.configurable\ndef configurable_fn(kwarg1=0, kwarg2=1):  # pylint: disable=unused-argument\n  pass\n\n\n@config.configurable\nclass ConfigurableClass(object):\n\n  def __init__(self, kwarg1=None, kwarg2=None):\n    self.kwarg1 = kwarg1\n    self.kwarg2 = kwarg2\n\n\n@config.configurable\ndef no_args_fn():\n  pass\n\n\n# pylint: disable=unused-argument,unused-variable\n@config.configurable\ndef not_called_fn(one=1, two=2):\n  pass\n# pylint: enable=unused-argument,unused-variable\n\n\n@config.configurable\ndef new_object():\n  return object()\n\n\nclass FakeSummaryWriter(object):\n\n  def __init__(self):\n    self._summaries = {}\n\n  @property\n  def summaries(self):\n    return self._summaries\n\n  def add_summary(self, summ, current_global_step):\n    """"""Add summary.""""""\n    if isinstance(summ, bytes):\n      summary_proto = summary_pb2.Summary()\n      summary_proto.ParseFromString(summ)\n      summ = summary_proto\n    if current_global_step in self._summaries:\n      step_summaries = self._summaries[current_global_step]\n    else:\n      step_summaries = []\n      self._summaries[current_global_step] = step_summaries\n    step_summaries.append(summ)\n\n  def flush(self):\n    pass\n\n\nclass GinConfigSaverHookTest(tf.test.TestCase):\n  CONFIG_STR = """"""\n    configurable_fn.kwarg1 = 10\n\n    ConfigurableClass.kwarg2 = None\n\n    not_called_fn.one = \'one\'\n  """"""\n\n  EXPECTED_MARKDOWN = """"""\n    #### Parameters for configurable_fn:\n\n        configurable_fn.kwarg1 = 10\n        configurable_fn.kwarg2 = 1\n\n    #### Parameters for ConfigurableClass:\n\n        ConfigurableClass.kwarg1 = None\n        ConfigurableClass.kwarg2 = None\n\n    #### Parameters for no_args_fn:\n\n        # None.\n  """"""\n\n  def setUp(self):\n    tf.compat.v1.disable_eager_execution()\n    tf.compat.v1.reset_default_graph()\n    config.clear_config()\n\n  def run_log_config_hook_maybe_with_summary(self, global_step_value, **kwargs):\n    config.parse_config(GinConfigSaverHookTest.CONFIG_STR)\n\n    configurable_fn()\n    ConfigurableClass()\n    no_args_fn()\n\n    output_dir = tempfile.mkdtemp()\n    summary_writer = FakeSummaryWriter()\n    h = utils.GinConfigSaverHook(\n        output_dir, summary_writer=summary_writer, **kwargs)\n    with self.session() as sess:\n      if global_step_value is not None:\n        global_step = tf.compat.v1.train.get_or_create_global_step()\n        sess.run(global_step.assign(global_step_value))\n      h.after_create_session(sess)\n\n    return output_dir, summary_writer\n\n  def testConstructingHookDoesntCreateEventFiles(self):\n    output_dir = tempfile.mkdtemp()\n    h1 = utils.GinConfigSaverHook(output_dir)\n    h2 = utils.GinConfigSaverHook(output_dir)\n    self.assertEqual(os.listdir(output_dir), [])\n\n    def create_event_files(hook):\n      with self.session() as sess:\n        hook.after_create_session(sess)\n      return [f for f in os.listdir(output_dir) if f.startswith(\'events\')]\n\n    self.assertEqual(len(create_event_files(h1)), 1)\n    # Check that the second hook doesn\'t create another events file.\n    self.assertEqual(len(create_event_files(h2)), 1)\n\n  def testGinConfigSaverHookWithoutSummary(self):\n    global_step_value = 7\n    output_dir, summary_writer = self.run_log_config_hook_maybe_with_summary(\n        global_step_value=global_step_value, summarize_config=False)\n    expected_file_name = \'operative_config-%d.gin\' % global_step_value\n    with tf.io.gfile.GFile(os.path.join(output_dir, expected_file_name)) as f:\n      operative_config_str = f.read()\n    self.assertEqual(operative_config_str, config.operative_config_str())\n    self.assertEmpty(summary_writer.summaries)\n\n  def testGinConfigSaverHookWithSummary(self):\n    global_step_value = 7\n    output_dir, summary_writer = self.run_log_config_hook_maybe_with_summary(\n        global_step_value=global_step_value,\n        base_name=\'custom_name\')\n    expected_file_name = \'custom_name-%d.gin\' % global_step_value\n    with tf.io.gfile.GFile(os.path.join(output_dir, expected_file_name)) as f:\n      operative_config_str = f.read()\n    self.assertEqual(operative_config_str, config.operative_config_str())\n\n    summary = summary_writer.summaries[global_step_value][0]\n    self.assertEqual(summary.value[0].tag, \'gin/custom_name\')\n\n    summary_lines = (\n        summary.value[0].tensor.string_val[0].decode(\'utf8\').splitlines())\n    markdown = GinConfigSaverHookTest.EXPECTED_MARKDOWN\n    markdown_lines = markdown.strip().splitlines()\n    self.assertEqual(len(summary_lines), len(markdown_lines))\n    for l1, l2 in zip(summary_lines, markdown_lines):\n      self.assertEqual(l1.strip(), l2.strip())\n\n  def testGinConfigSaverHookWithoutGlobalStep(self):\n    output_dir, summary_writer = self.run_log_config_hook_maybe_with_summary(\n        global_step_value=None)\n    expected_file_name = \'operative_config-0.gin\'\n    with tf.io.gfile.GFile(os.path.join(output_dir, expected_file_name)) as f:\n      operative_config_str = f.read()\n    self.assertEqual(operative_config_str, config.operative_config_str())\n\n    summary = summary_writer.summaries[0][0]\n    self.assertEqual(summary.value[0].tag, \'gin/operative_config\')\n\n  def testGinConfigSaverHookIncludeStepFalse(self):\n    output_dir, _ = self.run_log_config_hook_maybe_with_summary(\n        global_step_value=7, include_step_in_filename=False)\n    expected_file_name = \'operative_config.gin\'\n    with tf.io.gfile.GFile(os.path.join(output_dir, expected_file_name)) as f:\n      operative_config_str = f.read()\n    self.assertEqual(operative_config_str, config.operative_config_str())\n\n\nclass UtilsTest(tf.test.TestCase):\n\n  def setUp(self):\n    tf.compat.v1.reset_default_graph()\n    config.clear_config()\n\n  def testSingletonPerGraph(self):\n    config_str = """"""\n      ConfigurableClass.kwarg1 = @obj1/singleton_per_graph()\n      ConfigurableClass.kwarg2 = @obj2/singleton_per_graph()\n\n      obj1/singleton_per_graph.constructor = @new_object\n      obj2/singleton_per_graph.constructor = @new_object\n    """"""\n    config.parse_config(config_str)\n\n    with tf.Graph().as_default():\n      class1 = ConfigurableClass()\n      class2 = ConfigurableClass()\n\n    with tf.Graph().as_default():\n      class3 = ConfigurableClass()\n      class4 = ConfigurableClass()\n\n    self.assertIs(class1.kwarg1, class2.kwarg1)\n    self.assertIs(class1.kwarg2, class2.kwarg2)\n    self.assertIsNot(class1.kwarg1, class1.kwarg2)\n    self.assertIsNot(class2.kwarg1, class2.kwarg2)\n\n    self.assertIs(class3.kwarg1, class4.kwarg1)\n    self.assertIs(class3.kwarg2, class4.kwarg2)\n    self.assertIsNot(class3.kwarg1, class3.kwarg2)\n    self.assertIsNot(class4.kwarg1, class4.kwarg2)\n\n    self.assertIsNot(class1.kwarg1, class3.kwarg1)\n    self.assertIsNot(class1.kwarg2, class3.kwarg2)\n    self.assertIsNot(class2.kwarg1, class4.kwarg1)\n    self.assertIsNot(class2.kwarg2, class4.kwarg2)\n\n\nif __name__ == \'__main__\':\n  tf.test.main()\n'"
tests/torch/external_configurables_test.py,0,"b'# coding=utf-8\n# Copyright 2018 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# coding=utf-8\n# Copyright 2019 The Gin-Config Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import absltest\n\nfrom gin import config\nfrom gin.torch import external_configurables  # pylint: disable=unused-import\n\nimport torch\n\n\n@config.configurable\ndef fake_train_model(optimizer, scheduler=None):\n  # pylint: disable=E1101\n  opt = optimizer([torch.nn.Parameter(torch.rand(10))])\n  # pylint: enable=E1101\n  sch = None\n  if scheduler:\n    sch = scheduler(opt)\n  return opt, sch\n\n\n@config.configurable\ndef configurable(**kwargs):\n  return kwargs\n\n\nclass PyTorchConfigTest(absltest.TestCase):\n\n  def assertAlmostEqualList(self, xs, ys):\n    for i, (x, y) in enumerate(zip(xs, ys)):\n      print(i)\n      self.assertAlmostEqual(x, y)\n\n  def tearDown(self):\n    config.clear_config()\n    super(PyTorchConfigTest, self).tearDown()\n\n  def testConfigureOptimizerAndLearningRate(self):\n    config_str = """"""\n      fake_train_model.optimizer = @Adam\n      torch.optim.Adam.lr = 0.001\n      torch.optim.Adam.betas = (0.8, 0.888)\n      fake_train_model.scheduler = @StepLR\n      StepLR.step_size = 10\n    """"""\n    config.parse_config(config_str)\n\n    opt, sch = fake_train_model()  # pylint: disable=no-value-for-parameter\n\n    self.assertIsInstance(opt, torch.optim.Adam)\n    self.assertAlmostEqual(opt.param_groups[0][\'betas\'][0], 0.8)\n    self.assertAlmostEqual(opt.param_groups[0][\'betas\'][1], 0.888)\n    self.assertAlmostEqual(opt.defaults[\'betas\'][0], 0.8)\n    self.assertAlmostEqual(opt.defaults[\'betas\'][1], 0.888)\n    self.assertAlmostEqual(sch.step_size, 10)\n\n    lrs = []\n    for _ in range(15):\n      lrs.append(opt.param_groups[0][\'lr\'])\n      opt.step()\n      sch.step()\n\n    # Divide lr in tenth epoch by 10\n    target_lrs = [0.001] * 10 + [0.0001] * 5\n\n    self.assertAlmostEqualList(lrs, target_lrs)\n\n  def testOptimizersWithDefaults(self):\n    optimizers = [\n        torch.optim.Adadelta,\n        torch.optim.Adagrad,\n        torch.optim.Adam,\n        torch.optim.SparseAdam,\n        torch.optim.Adamax,\n        torch.optim.ASGD,\n        torch.optim.LBFGS,\n        torch.optim.RMSprop,\n        torch.optim.Rprop,\n        torch.optim.SGD,\n    ]\n    for optimizer in optimizers:\n      config.clear_config()\n      config_str = """"""\n        fake_train_model.optimizer = @{optimizer}\n        {optimizer}.lr = 0.001\n      """"""\n      config.parse_config(config_str.format(optimizer=optimizer.__name__))\n      configed_optimizer, _ = fake_train_model(config.REQUIRED)\n      self.assertIsInstance(configed_optimizer, optimizer)\n\n  def testDtypes(self):\n    # Spot check a few.\n    config_str = """"""\n      # Test without torch prefix, but using the\n      # prefix is strongly recommended!\n      configurable.float32 = %float32\n      # Test with torch prefix.\n      configurable.int8 = %torch.int8\n      configurable.float16 = %torch.float16\n    """"""\n    config.parse_config(config_str)\n\n    vals = configurable()\n    # pylint: disable=E1101\n    self.assertIs(vals[\'float32\'], torch.float32)\n    self.assertIs(vals[\'int8\'], torch.int8)\n    self.assertIs(vals[\'float16\'], torch.float16)\n    # pylint: disable=E1101\n\n\nif __name__ == \'__main__\':\n  absltest.main()\n'"
