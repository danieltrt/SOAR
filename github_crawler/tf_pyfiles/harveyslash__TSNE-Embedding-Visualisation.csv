file_path,api_count,code
main.py,0,"b'from PIL import Image\nimport glob\nfrom keras.applications.inception_v3 import InceptionV3\nfrom keras.applications.inception_v3 import preprocess_input, decode_predictions\nfrom keras.preprocessing import image\nimport numpy as np\nimport click\nimport json\n\n\ndef images_to_sprite(data):\n    """"""\n    Creates the sprite image along with any necessary padding\n    Source : https://github.com/tensorflow/tensorflow/issues/6322\n    Args:\n      data: NxHxW[x3] tensor containing the images.\n    Returns:\n      data: Properly shaped HxWx3 image with any necessary padding.\n    """"""\n    if len(data.shape) == 3:\n        data = np.tile(data[..., np.newaxis], (1, 1, 1, 3))\n    data = data.astype(np.float32)\n    min = np.min(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) - min).transpose(3, 0, 1, 2)\n    max = np.max(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) / max).transpose(3, 0, 1, 2)\n\n    n = int(np.ceil(np.sqrt(data.shape[0])))\n    padding = ((0, n ** 2 - data.shape[0]), (0, 0),\n               (0, 0)) + ((0, 0),) * (data.ndim - 3)\n    data = np.pad(data, padding, mode=\'constant\',\n                  constant_values=0)\n    # Tile the individual thumbnails into an image.\n    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3)\n                                                           + tuple(range(4, data.ndim + 1)))\n    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])\n    data = (data * 255).astype(np.uint8)\n    return data\n\n\ndef populate_img_arr(images_paths, size=(100, 100), should_preprocess=False):\n    """"""\n    Get an array of images for a list of image paths\n    Args:\n        size: the size of image , in pixels\n        should_preprocess: if the images should be processed (according to InceptionV3 requirements)\n    Returns:\n        arr: An array of the loaded images\n    """"""\n    arr = []\n    for i, img_path in enumerate(images_paths):\n        img = image.load_img(img_path, target_size=size)\n        x = image.img_to_array(img)\n        arr.append(x)\n    arr = np.array(arr)\n    if should_preprocess:\n        arr = preprocess_input(arr)\n    return arr\n\n\n@click.command()\n@click.option(\'--data\', help=\'Data folder,has to end with /\')\n@click.option(\'--name\', default=""Visualisation"", help=\'Name of visualisation\')\n@click.option(\'--sprite_size\', default=100, help=\'Size of sprite\')\n@click.option(\'--tensor_name\', default=""tensor.bytes"", help=\'Name of Tensor file\')\n@click.option(\'--sprite_name\', default=""sprites.png"", help=\'Name of sprites file\')\n@click.option(\'--model_input_size\', default=299, help=\'Size of inputs to model\')\ndef main(data, name, sprite_size, tensor_name, sprite_name, model_input_size):\n    \n    if not data.endswith(\'/\'):\n        raise ValueError(\'Makesure --name ends with a ""/""\')\n    \n    images_paths = glob.glob(data + ""*.jpg"")\n    images_paths.extend(glob.glob(data + ""*.JPG""))\n    images_paths.extend(glob.glob(data + ""*.png""))\n\n    model = InceptionV3(include_top=False, pooling=\'avg\')\n\n    img_arr = populate_img_arr(images_paths, size=(model_input_size, model_input_size), should_preprocess=True)\n    preds = model.predict(img_arr, batch_size=64)\n    preds.tofile(""./oss_data/"" + tensor_name)\n\n    raw_imgs = populate_img_arr(images_paths, size=(sprite_size, sprite_size), should_preprocess=False)\n    sprite = Image.fromarray(images_to_sprite(raw_imgs).astype(np.uint8))\n    sprite.save(\'./oss_data/\' + sprite_name)\n\n    oss_json = json.load(open(\'./oss_data/oss_demo_projector_config.json\'))\n    tensor_shape = [raw_imgs.shape[0], model.output_shape[1]]\n    single_image_dim = [raw_imgs.shape[1], raw_imgs.shape[2]]\n\n    json_to_append = {""tensorName"": name,\n                      ""tensorShape"": tensor_shape,\n                      ""tensorPath"": ""./oss_data/"" + tensor_name,\n                      ""sprite"": {""imagePath"": ""./oss_data/"" + sprite_name,\n                                 ""singleImageDim"": single_image_dim}}\n    oss_json[\'embeddings\'].append(json_to_append)\n    with open(\'oss_data/oss_demo_projector_config.json\', \'w+\') as f:\n        json.dump(oss_json, f, ensure_ascii=False, indent=4)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
