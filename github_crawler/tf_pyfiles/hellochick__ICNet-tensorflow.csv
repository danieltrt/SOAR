file_path,api_count,code
evaluate.py,9,"b'import argparse\nimport time\n\nimport tensorflow as tf\nimport numpy as np\nfrom tqdm import trange\n\nfrom utils.config import Config\nfrom utils.image_reader import ImageReader\nfrom model import ICNet, ICNet_BN\n\n# mapping different model\nmodel_config = {\'train\': ICNet, \'trainval\': ICNet, \'train_bn\': ICNet_BN, \'trainval_bn\': ICNet_BN, \'others\': ICNet_BN}\n\ndef get_arguments():\n    parser = argparse.ArgumentParser(description=""Reproduced ICNet"")\n\n    parser.add_argument(""--model"", type=str, default=\'\',\n                        help=""Model to use."",\n                        choices=[\'train\', \'trainval\', \'train_bn\', \'trainval_bn\', \'others\'],\n                        required=True)\n    parser.add_argument(""--dataset"", type=str, default=\'\',\n                        choices=[\'ade20k\', \'cityscapes\'],\n                        required=True)\n    parser.add_argument(""--filter-scale"", type=int, default=1,\n                        help=""1 for using pruned model, while 2 for using non-pruned model."",\n                        choices=[1, 2])\n\n    return parser.parse_args()\n\ndef main():\n    args = get_arguments()  \n    cfg = Config(dataset=args.dataset, is_training=False, filter_scale=args.filter_scale)\n    \n    model = model_config[args.model]\n\n    reader = ImageReader(cfg=cfg, mode=\'eval\')\n    net = model(image_reader=reader, cfg=cfg, mode=\'eval\')\n    \n    # mIoU\n    pred_flatten = tf.reshape(net.output, [-1,])\n    label_flatten = tf.reshape(net.labels, [-1,])\n\n    mask = tf.not_equal(label_flatten, cfg.param[\'ignore_label\'])\n    indices = tf.squeeze(tf.where(mask), 1)\n    gt = tf.cast(tf.gather(label_flatten, indices), tf.int32)\n    pred = tf.gather(pred_flatten, indices)\n\n    if cfg.dataset == \'ade20k\':\n        pred = tf.add(pred, tf.constant(1, dtype=tf.int64))\n        mIoU, update_op = tf.metrics.mean_iou(predictions=pred, labels=gt, num_classes=cfg.param[\'num_classes\']+1)\n    elif cfg.dataset == \'cityscapes\':\n        mIoU, update_op = tf.metrics.mean_iou(predictions=pred, labels=gt, num_classes=cfg.param[\'num_classes\'])\n    \n    net.create_session()\n    net.restore(cfg.model_paths[args.model])\n    \n    for i in trange(cfg.param[\'eval_steps\'], desc=\'evaluation\', leave=True):\n        _ = net.sess.run(update_op)\n             \n    print(\'mIoU: {}\'.format(net.sess.run(mIoU)))\n    \nif __name__ == \'__main__\':\n    main()\n'"
model.py,14,"b""import tensorflow as tf\nfrom network import Network\nfrom utils.image_reader import _infer_preprocess\nfrom utils.visualize import decode_labels\n\nclass ICNet(Network):\n    def __init__(self, cfg, mode, image_reader=None):\n        self.cfg = cfg\n        self.mode = mode\n\n        if mode == 'train':\n            self.images, self.labels = image_reader.next_image, image_reader.next_label    \n        \n            super().__init__(inputs={'data': self.images}, cfg=self.cfg)\n\n        elif mode == 'eval':\n            self.images, self.labels = image_reader.next_image, image_reader.next_label    \n        \n            super().__init__(inputs={'data': self.images}, cfg=self.cfg)\n            \n            self.output = self.get_output_node()\n\n        elif mode == 'inference':\n            # Create placeholder and pre-process here.\n            self.img_placeholder = tf.placeholder(dtype=tf.float32, shape=cfg.INFER_SIZE)\n            self.images, self.o_shape, self.n_shape = _infer_preprocess(self.img_placeholder)\n            \n            super().__init__(inputs={'data': self.images}, cfg=self.cfg)\n\n            self.output = self.get_output_node()\n\n    def get_output_node(self):\n        if self.mode == 'inference':\n            # Get logits from final layer\n            logits = self.layers['conv6_cls']\n\n            # Upscale the logits and decode prediction to get final result.\n            logits_up = tf.image.resize_bilinear(logits, size=self.n_shape, align_corners=True)\n            logits_up = tf.image.crop_to_bounding_box(logits_up, 0, 0, self.o_shape[0], self.o_shape[1])\n\n            output_classes = tf.argmax(logits_up, axis=3)\n            output = decode_labels(output_classes, self.o_shape, self.cfg.param['num_classes'])\n\n        elif self.mode == 'eval':\n            logits = self.layers['conv6_cls']\n\n            logits_up = tf.image.resize_bilinear(logits, size=tf.shape(self.labels)[1:3], align_corners=True)\n            output = tf.argmax(logits_up, axis=3)\n            output = tf.expand_dims(output, axis=3)\n\n        return output\n\n    def predict(self, image):\n        return self.sess.run(self.output, feed_dict={self.img_placeholder: image})\n\n    def setup(self):\n        (self.feed('data')\n             .interp(s_factor=0.5, name='data_sub2')\n             .conv(3, 3, 32, 2, 2, biased=True, padding='SAME', relu=True, name='conv1_1_3x3_s2')\n             .conv(3, 3, 32, 1, 1, biased=True, padding='SAME', relu=True, name='conv1_2_3x3')\n             .conv(3, 3, 64, 1, 1, biased=True, padding='SAME', relu=True, name='conv1_3_3x3')\n             .zero_padding(paddings=1, name='padding0')\n             .max_pool(3, 3, 2, 2, name='pool1_3x3_s2')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=False, name='conv2_1_1x1_proj'))\n\n        (self.feed('pool1_3x3_s2')\n             .conv(1, 1, 32, 1, 1, biased=True, relu=True, name='conv2_1_1x1_reduce')\n             .zero_padding(paddings=1, name='padding1')\n             .conv(3, 3, 32, 1, 1, biased=True, relu=True, name='conv2_1_3x3')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=False, name='conv2_1_1x1_increase'))\n\n        (self.feed('conv2_1_1x1_proj',\n                   'conv2_1_1x1_increase')\n             .add(name='conv2_1')\n             .relu(name='conv2_1/relu')\n             .conv(1, 1, 32, 1, 1, biased=True, relu=True, name='conv2_2_1x1_reduce')\n             .zero_padding(paddings=1, name='padding2')\n             .conv(3, 3, 32, 1, 1, biased=True, relu=True, name='conv2_2_3x3')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=False, name='conv2_2_1x1_increase'))\n\n        (self.feed('conv2_1/relu',\n                   'conv2_2_1x1_increase')\n             .add(name='conv2_2')\n             .relu(name='conv2_2/relu')\n             .conv(1, 1, 32, 1, 1, biased=True, relu=True, name='conv2_3_1x1_reduce')\n             .zero_padding(paddings=1, name='padding3')\n             .conv(3, 3, 32, 1, 1, biased=True, relu=True, name='conv2_3_3x3')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=False, name='conv2_3_1x1_increase'))\n\n        (self.feed('conv2_2/relu',\n                   'conv2_3_1x1_increase')\n             .add(name='conv2_3')\n             .relu(name='conv2_3/relu')\n             .conv(1, 1, 256, 2, 2, biased=True, relu=False, name='conv3_1_1x1_proj'))\n\n        (self.feed('conv2_3/relu')\n             .conv(1, 1, 64, 2, 2, biased=True, relu=True, name='conv3_1_1x1_reduce')\n             .zero_padding(paddings=1, name='padding4')\n             .conv(3, 3, 64, 1, 1, biased=True, relu=True, name='conv3_1_3x3')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=False, name='conv3_1_1x1_increase'))\n\n        (self.feed('conv3_1_1x1_proj',\n                   'conv3_1_1x1_increase')\n             .add(name='conv3_1')\n             .relu(name='conv3_1/relu')\n             .interp(s_factor=0.5, name='conv3_1_sub4')\n             .conv(1, 1, 64, 1, 1, biased=True, relu=True, name='conv3_2_1x1_reduce')\n             .zero_padding(paddings=1, name='padding5')\n             .conv(3, 3, 64, 1, 1, biased=True, relu=True, name='conv3_2_3x3')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=False, name='conv3_2_1x1_increase'))\n\n        (self.feed('conv3_1_sub4',\n                   'conv3_2_1x1_increase')\n             .add(name='conv3_2')\n             .relu(name='conv3_2/relu')\n             .conv(1, 1, 64, 1, 1, biased=True, relu=True, name='conv3_3_1x1_reduce')\n             .zero_padding(paddings=1, name='padding6')\n             .conv(3, 3, 64, 1, 1, biased=True, relu=True, name='conv3_3_3x3')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=False, name='conv3_3_1x1_increase'))\n\n        (self.feed('conv3_2/relu',\n                   'conv3_3_1x1_increase')\n             .add(name='conv3_3')\n             .relu(name='conv3_3/relu')\n             .conv(1, 1, 64, 1, 1, biased=True, relu=True, name='conv3_4_1x1_reduce')\n             .zero_padding(paddings=1, name='padding7')\n             .conv(3, 3, 64, 1, 1, biased=True, relu=True, name='conv3_4_3x3')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=False, name='conv3_4_1x1_increase'))\n\n        (self.feed('conv3_3/relu',\n                   'conv3_4_1x1_increase')\n             .add(name='conv3_4')\n             .relu(name='conv3_4/relu')\n             .conv(1, 1, 512, 1, 1, biased=True, relu=False, name='conv4_1_1x1_proj'))\n\n        (self.feed('conv3_4/relu')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=True, name='conv4_1_1x1_reduce')\n             .zero_padding(paddings=2, name='padding8')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=True, name='conv4_1_3x3')\n             .conv(1, 1, 512, 1, 1, biased=True, relu=False, name='conv4_1_1x1_increase'))\n\n        (self.feed('conv4_1_1x1_proj',\n                   'conv4_1_1x1_increase')\n             .add(name='conv4_1')\n             .relu(name='conv4_1/relu')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=True, name='conv4_2_1x1_reduce')\n             .zero_padding(paddings=2, name='padding9')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=True, name='conv4_2_3x3')\n             .conv(1, 1, 512, 1, 1, biased=True, relu=False, name='conv4_2_1x1_increase'))\n\n        (self.feed('conv4_1/relu',\n                   'conv4_2_1x1_increase')\n             .add(name='conv4_2')\n             .relu(name='conv4_2/relu')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=True, name='conv4_3_1x1_reduce')\n             .zero_padding(paddings=2, name='padding10')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=True, name='conv4_3_3x3')\n             .conv(1, 1, 512, 1, 1, biased=True, relu=False, name='conv4_3_1x1_increase'))\n\n        (self.feed('conv4_2/relu',\n                   'conv4_3_1x1_increase')\n             .add(name='conv4_3')\n             .relu(name='conv4_3/relu')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=True, name='conv4_4_1x1_reduce')\n             .zero_padding(paddings=2, name='padding11')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=True, name='conv4_4_3x3')\n             .conv(1, 1, 512, 1, 1, biased=True, relu=False, name='conv4_4_1x1_increase'))\n\n        (self.feed('conv4_3/relu',\n                   'conv4_4_1x1_increase')\n             .add(name='conv4_4')\n             .relu(name='conv4_4/relu')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=True, name='conv4_5_1x1_reduce')\n             .zero_padding(paddings=2, name='padding12')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=True, name='conv4_5_3x3')\n             .conv(1, 1, 512, 1, 1, biased=True, relu=False, name='conv4_5_1x1_increase'))\n\n        (self.feed('conv4_4/relu',\n                   'conv4_5_1x1_increase')\n             .add(name='conv4_5')\n             .relu(name='conv4_5/relu')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=True, name='conv4_6_1x1_reduce')\n             .zero_padding(paddings=2, name='padding13')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=True, name='conv4_6_3x3')\n             .conv(1, 1, 512, 1, 1, biased=True, relu=False, name='conv4_6_1x1_increase'))\n\n        (self.feed('conv4_5/relu',\n                   'conv4_6_1x1_increase')\n             .add(name='conv4_6')\n             .relu(name='conv4_6/relu')\n             .conv(1, 1, 1024, 1, 1, biased=True, relu=False, name='conv5_1_1x1_proj'))\n\n        (self.feed('conv4_6/relu')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=True, name='conv5_1_1x1_reduce')\n             .zero_padding(paddings=4, name='padding14')\n             .atrous_conv(3, 3, 256, 4, biased=True, relu=True, name='conv5_1_3x3')\n             .conv(1, 1, 1024, 1, 1, biased=True, relu=False, name='conv5_1_1x1_increase'))\n\n        (self.feed('conv5_1_1x1_proj',\n                   'conv5_1_1x1_increase')\n             .add(name='conv5_1')\n             .relu(name='conv5_1/relu')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=True, name='conv5_2_1x1_reduce')\n             .zero_padding(paddings=4, name='padding15')\n             .atrous_conv(3, 3, 256, 4, biased=True, relu=True, name='conv5_2_3x3')\n             .conv(1, 1, 1024, 1, 1, biased=True, relu=False, name='conv5_2_1x1_increase'))\n\n        (self.feed('conv5_1/relu',\n                   'conv5_2_1x1_increase')\n             .add(name='conv5_2')\n             .relu(name='conv5_2/relu')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=True, name='conv5_3_1x1_reduce')\n             .zero_padding(paddings=4, name='padding16')\n             .atrous_conv(3, 3, 256, 4, biased=True, relu=True, name='conv5_3_3x3')\n             .conv(1, 1, 1024, 1, 1, biased=True, relu=False, name='conv5_3_1x1_increase'))\n\n        (self.feed('conv5_2/relu',\n                   'conv5_3_1x1_increase')\n             .add(name='conv5_3')\n             .relu(name='conv5_3/relu'))\n\n        shape = self.layers['conv5_3/relu'].get_shape().as_list()[1:3]\n        h, w = shape\n\n        if self.mode == 'eval' and self.cfg.dataset == 'cityscapes': # Change to same configuration as original prototxt\n            (self.feed('conv5_3/relu')\n                .avg_pool(33, 65, 33, 65, name='conv5_3_pool1')\n                .resize_bilinear(shape, name='conv5_3_pool1_interp'))\n\n            (self.feed('conv5_3/relu')\n                .avg_pool(17, 33, 16, 32, name='conv5_3_pool2')\n                .resize_bilinear(shape, name='conv5_3_pool2_interp'))\n\n            (self.feed('conv5_3/relu')\n                .avg_pool(13, 25, 10, 20, name='conv5_3_pool3')\n                .resize_bilinear(shape, name='conv5_3_pool3_interp'))\n\n            (self.feed('conv5_3/relu')\n                .avg_pool(8, 15, 5, 10, name='conv5_3_pool6')\n                .resize_bilinear(shape, name='conv5_3_pool6_interp'))\n        else:       # In inference phase, we support different size of images as input.\n            (self.feed('conv5_3/relu')\n                .avg_pool(h, w, h, w, name='conv5_3_pool1')\n                .resize_bilinear(shape, name='conv5_3_pool1_interp'))\n\n            (self.feed('conv5_3/relu')\n                .avg_pool(h/2, w/2, h/2, w/2, name='conv5_3_pool2')\n                .resize_bilinear(shape, name='conv5_3_pool2_interp'))\n\n            (self.feed('conv5_3/relu')\n                .avg_pool(h/3, w/3, h/3, w/3, name='conv5_3_pool3')\n                .resize_bilinear(shape, name='conv5_3_pool3_interp'))\n\n            (self.feed('conv5_3/relu')\n                .avg_pool(h/6, w/6, h/6, w/6, name='conv5_3_pool6')\n                .resize_bilinear(shape, name='conv5_3_pool6_interp'))\n\n        (self.feed('conv5_3/relu',\n                   'conv5_3_pool6_interp',\n                   'conv5_3_pool3_interp',\n                   'conv5_3_pool2_interp',\n                   'conv5_3_pool1_interp')\n             .add(name='conv5_3_sum')\n             .conv(1, 1, 256, 1, 1, biased=True, relu=True, name='conv5_4_k1')\n             .interp(z_factor=2.0, name='conv5_4_interp')\n             .zero_padding(paddings=2, name='padding17')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=False, name='conv_sub4'))\n\n        (self.feed('conv3_1/relu')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=False, name='conv3_1_sub2_proj'))\n\n        (self.feed('conv_sub4',\n                   'conv3_1_sub2_proj')\n             .add(name='sub24_sum')\n             .relu(name='sub24_sum/relu')\n             .interp(z_factor=2.0, name='sub24_sum_interp')\n             .zero_padding(paddings=2, name='padding18')\n             .atrous_conv(3, 3, 128, 2, biased=True, relu=False, name='conv_sub2'))\n\n        (self.feed('data')\n             .conv(3, 3, 32, 2, 2, biased=True, padding='SAME', relu=True, name='conv1_sub1')\n             .conv(3, 3, 32, 2, 2, biased=True, padding='SAME', relu=True, name='conv2_sub1')\n             .conv(3, 3, 64, 2, 2, biased=True, padding='SAME', relu=True, name='conv3_sub1')\n             .conv(1, 1, 128, 1, 1, biased=True, relu=False, name='conv3_sub1_proj'))\n\n        (self.feed('conv_sub2',\n                   'conv3_sub1_proj')\n             .add(name='sub12_sum')\n             .relu(name='sub12_sum/relu')\n             .interp(z_factor=2.0, name='sub12_sum_interp')\n             .conv(1, 1, self.cfg.param['num_classes'], 1, 1, biased=True, relu=False, name='conv6_cls'))\n\n\nclass ICNet_BN(Network):\n    def __init__(self, cfg, mode, image_reader=None):\n        self.cfg = cfg\n        self.mode = mode\n\n        if mode == 'train':\n            self.images, self.labels = image_reader.next_image, image_reader.next_label    \n        \n            super().__init__(inputs={'data': self.images}, cfg=self.cfg)\n\n        elif mode == 'eval':\n            self.images, self.labels = image_reader.next_image, image_reader.next_label    \n        \n            super().__init__(inputs={'data': self.images}, cfg=self.cfg)\n            \n            self.output = self.get_output_node()\n\n        elif mode == 'inference':\n            # Create placeholder and pre-process here.\n            self.img_placeholder = tf.placeholder(dtype=tf.float32, shape=cfg.INFER_SIZE)\n            self.images, self.o_shape, self.n_shape = _infer_preprocess(self.img_placeholder)\n            \n            super().__init__(inputs={'data': self.images}, cfg=self.cfg)\n\n            self.output = self.get_output_node()\n\n    def get_output_node(self):\n        if self.mode == 'inference':\n            # Get logits from final layer\n            logits = self.layers['conv6_cls']\n\n            # Upscale the logits and decode prediction to get final result.\n            logits_up = tf.image.resize_bilinear(logits, size=self.n_shape, align_corners=True)\n            logits_up = tf.image.crop_to_bounding_box(logits_up, 0, 0, self.o_shape[0], self.o_shape[1])\n\n            output_classes = tf.argmax(logits_up, axis=3)\n            output = decode_labels(output_classes, self.o_shape, self.cfg.param['num_classes'])\n\n        elif self.mode == 'eval':\n            logits = self.layers['conv6_cls']\n\n            logits_up = tf.image.resize_bilinear(logits, size=tf.shape(self.labels)[1:3], align_corners=True)\n            output = tf.argmax(logits_up, axis=3)\n            output = tf.expand_dims(output, axis=3)\n\n        return output\n\n    def predict(self, image):\n        return self.sess.run(self.output, feed_dict={self.img_placeholder: image})\n\n    def setup(self):\n        (self.feed('data')\n             .interp(s_factor=0.5, name='data_sub2')\n             .conv(3, 3, 32, 2, 2, biased=False, padding='SAME', relu=False, name='conv1_1_3x3_s2')\n             .batch_normalization(relu=True, name='conv1_1_3x3_s2_bn')\n             .conv(3, 3, 32, 1, 1, biased=False, padding='SAME', relu=False, name='conv1_2_3x3')\n             .batch_normalization(relu=True, name='conv1_2_3x3_bn')\n             .conv(3, 3, 64, 1, 1, biased=False, padding='SAME', relu=False, name='conv1_3_3x3')\n             .batch_normalization(relu=True, name='conv1_3_3x3_bn')\n             .zero_padding(paddings=1, name='padding0')\n             .max_pool(3, 3, 2, 2, name='pool1_3x3_s2')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv2_1_1x1_proj')\n             .batch_normalization(relu=False, name='conv2_1_1x1_proj_bn'))\n\n        (self.feed('pool1_3x3_s2')\n             .conv(1, 1, 32, 1, 1, biased=False, relu=False, name='conv2_1_1x1_reduce')\n             .batch_normalization(relu=True, name='conv2_1_1x1_reduce_bn')\n             .zero_padding(paddings=1, name='padding1')\n             .conv(3, 3, 32, 1, 1, biased=False, relu=False, name='conv2_1_3x3')\n             .batch_normalization(relu=True, name='conv2_1_3x3_bn')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv2_1_1x1_increase')\n             .batch_normalization(relu=False, name='conv2_1_1x1_increase_bn'))\n\n        (self.feed('conv2_1_1x1_proj_bn',\n                   'conv2_1_1x1_increase_bn')\n             .add(name='conv2_1')\n             .relu(name='conv2_1/relu')\n             .conv(1, 1, 32, 1, 1, biased=False, relu=False, name='conv2_2_1x1_reduce')\n             .batch_normalization(relu=True, name='conv2_2_1x1_reduce_bn')\n             .zero_padding(paddings=1, name='padding2')\n             .conv(3, 3, 32, 1, 1, biased=False, relu=False, name='conv2_2_3x3')\n             .batch_normalization(relu=True, name='conv2_2_3x3_bn')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv2_2_1x1_increase')\n             .batch_normalization(relu=False, name='conv2_2_1x1_increase_bn'))\n\n        (self.feed('conv2_1/relu',\n                   'conv2_2_1x1_increase_bn')\n             .add(name='conv2_2')\n             .relu(name='conv2_2/relu')\n             .conv(1, 1, 32, 1, 1, biased=False, relu=False, name='conv2_3_1x1_reduce')\n             .batch_normalization(relu=True, name='conv2_3_1x1_reduce_bn')\n             .zero_padding(paddings=1, name='padding3')\n             .conv(3, 3, 32, 1, 1, biased=False, relu=False, name='conv2_3_3x3')\n             .batch_normalization(relu=True, name='conv2_3_3x3_bn')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv2_3_1x1_increase')\n             .batch_normalization(relu=False, name='conv2_3_1x1_increase_bn'))\n\n        (self.feed('conv2_2/relu',\n                   'conv2_3_1x1_increase_bn')\n             .add(name='conv2_3')\n             .relu(name='conv2_3/relu')\n             .conv(1, 1, 256, 2, 2, biased=False, relu=False, name='conv3_1_1x1_proj')\n             .batch_normalization(relu=False, name='conv3_1_1x1_proj_bn'))\n\n        (self.feed('conv2_3/relu')\n             .conv(1, 1, 64, 2, 2, biased=False, relu=False, name='conv3_1_1x1_reduce')\n             .batch_normalization(relu=True, name='conv3_1_1x1_reduce_bn')\n             .zero_padding(paddings=1, name='padding4')\n             .conv(3, 3, 64, 1, 1, biased=False, relu=False, name='conv3_1_3x3')\n             .batch_normalization(relu=True, name='conv3_1_3x3_bn')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv3_1_1x1_increase')\n             .batch_normalization(relu=False, name='conv3_1_1x1_increase_bn'))\n\n        (self.feed('conv3_1_1x1_proj_bn',\n                   'conv3_1_1x1_increase_bn')\n             .add(name='conv3_1')\n             .relu(name='conv3_1/relu')\n             .interp(s_factor=0.5, name='conv3_1_sub4')\n             .conv(1, 1, 64, 1, 1, biased=False, relu=False, name='conv3_2_1x1_reduce')\n             .batch_normalization(relu=True, name='conv3_2_1x1_reduce_bn')\n             .zero_padding(paddings=1, name='padding5')\n             .conv(3, 3, 64, 1, 1, biased=False, relu=False, name='conv3_2_3x3')\n             .batch_normalization(relu=True, name='conv3_2_3x3_bn')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv3_2_1x1_increase')\n             .batch_normalization(relu=False, name='conv3_2_1x1_increase_bn'))\n\n        (self.feed('conv3_1_sub4',\n                   'conv3_2_1x1_increase_bn')\n             .add(name='conv3_2')\n             .relu(name='conv3_2/relu')\n             .conv(1, 1, 64, 1, 1, biased=False, relu=False, name='conv3_3_1x1_reduce')\n             .batch_normalization(relu=True, name='conv3_3_1x1_reduce_bn')\n             .zero_padding(paddings=1, name='padding6')\n             .conv(3, 3, 64, 1, 1, biased=False, relu=False, name='conv3_3_3x3')\n             .batch_normalization(relu=True, name='conv3_3_3x3_bn')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv3_3_1x1_increase')\n             .batch_normalization(relu=False, name='conv3_3_1x1_increase_bn'))\n\n\n        (self.feed('conv3_2/relu',\n                   'conv3_3_1x1_increase_bn')\n             .add(name='conv3_3')\n             .relu(name='conv3_3/relu')\n             .conv(1, 1, 64, 1, 1, biased=False, relu=False, name='conv3_4_1x1_reduce')\n             .batch_normalization(relu=True, name='conv3_4_1x1_reduce_bn')\n             .zero_padding(paddings=1, name='padding7')\n             .conv(3, 3, 64, 1, 1, biased=False, relu=False, name='conv3_4_3x3')\n             .batch_normalization(relu=True, name='conv3_4_3x3_bn')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv3_4_1x1_increase')\n             .batch_normalization(relu=False, name='conv3_4_1x1_increase_bn'))\n\n        (self.feed('conv3_3/relu',\n                   'conv3_4_1x1_increase_bn')\n             .add(name='conv3_4')\n             .relu(name='conv3_4/relu')\n             .conv(1, 1, 512, 1, 1, biased=False, relu=False, name='conv4_1_1x1_proj')\n             .batch_normalization(relu=False, name='conv4_1_1x1_proj_bn'))\n\n        (self.feed('conv3_4/relu')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv4_1_1x1_reduce')\n             .batch_normalization(relu=True, name='conv4_1_1x1_reduce_bn')\n             .zero_padding(paddings=2, name='padding8')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv4_1_3x3')\n             .batch_normalization(relu=True, name='conv4_1_3x3_bn')\n             .conv(1, 1, 512, 1, 1, biased=False, relu=False, name='conv4_1_1x1_increase')\n             .batch_normalization(relu=False, name='conv4_1_1x1_increase_bn'))\n\n        (self.feed('conv4_1_1x1_proj_bn',\n                   'conv4_1_1x1_increase_bn')\n             .add(name='conv4_1')\n             .relu(name='conv4_1/relu')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv4_2_1x1_reduce')\n             .batch_normalization(relu=True, name='conv4_2_1x1_reduce_bn')\n             .zero_padding(paddings=2, name='padding9')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv4_2_3x3')\n             .batch_normalization(relu=True, name='conv4_2_3x3_bn')\n             .conv(1, 1, 512, 1, 1, biased=False, relu=False, name='conv4_2_1x1_increase')\n             .batch_normalization(relu=False, name='conv4_2_1x1_increase_bn'))\n\n        (self.feed('conv4_1/relu',\n                   'conv4_2_1x1_increase_bn')\n             .add(name='conv4_2')\n             .relu(name='conv4_2/relu')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv4_3_1x1_reduce')\n             .batch_normalization(relu=True, name='conv4_3_1x1_reduce_bn')\n             .zero_padding(paddings=2, name='padding10')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv4_3_3x3')\n             .batch_normalization(relu=True, name='conv4_3_3x3_bn')\n             .conv(1, 1, 512, 1, 1, biased=False, relu=False, name='conv4_3_1x1_increase')\n             .batch_normalization(relu=False, name='conv4_3_1x1_increase_bn'))\n\n        (self.feed('conv4_2/relu',\n                   'conv4_3_1x1_increase_bn')\n             .add(name='conv4_3')\n             .relu(name='conv4_3/relu')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv4_4_1x1_reduce')\n             .batch_normalization(relu=True, name='conv4_4_1x1_reduce_bn')\n             .zero_padding(paddings=2, name='padding11')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv4_4_3x3')\n             .batch_normalization(relu=True, name='conv4_4_3x3_bn')\n             .conv(1, 1, 512, 1, 1, biased=False, relu=False, name='conv4_4_1x1_increase')\n             .batch_normalization(relu=False, name='conv4_4_1x1_increase_bn'))\n\n        (self.feed('conv4_3/relu',\n                   'conv4_4_1x1_increase_bn')\n             .add(name='conv4_4')\n             .relu(name='conv4_4/relu')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv4_5_1x1_reduce')\n             .batch_normalization(relu=True, name='conv4_5_1x1_reduce_bn')\n             .zero_padding(paddings=2, name='padding12')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv4_5_3x3')\n             .batch_normalization(relu=True, name='conv4_5_3x3_bn')\n             .conv(1, 1, 512, 1, 1, biased=False, relu=False, name='conv4_5_1x1_increase')\n             .batch_normalization(relu=False, name='conv4_5_1x1_increase_bn'))\n\n        (self.feed('conv4_4/relu',\n                   'conv4_5_1x1_increase_bn')\n             .add(name='conv4_5')\n             .relu(name='conv4_5/relu')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv4_6_1x1_reduce')\n             .batch_normalization(relu=True, name='conv4_6_1x1_reduce_bn')\n             .zero_padding(paddings=2, name='padding13')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv4_6_3x3')\n             .batch_normalization(relu=True, name='conv4_6_3x3_bn')\n             .conv(1, 1, 512, 1, 1, biased=False, relu=False, name='conv4_6_1x1_increase')\n             .batch_normalization(relu=False, name='conv4_6_1x1_increase_bn'))\n\n        (self.feed('conv4_5/relu',\n                   'conv4_6_1x1_increase_bn')\n             .add(name='conv4_6')\n             .relu(name='conv4_6/relu')\n             .conv(1, 1, 1024, 1, 1, biased=False, relu=False, name='conv5_1_1x1_proj')\n             .batch_normalization(relu=False, name='conv5_1_1x1_proj_bn'))\n\n        (self.feed('conv4_6/relu')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv5_1_1x1_reduce')\n             .batch_normalization(relu=True, name='conv5_1_1x1_reduce_bn')\n             .zero_padding(paddings=4, name='padding14')\n             .atrous_conv(3, 3, 256, 4, biased=False, relu=False, name='conv5_1_3x3')\n             .batch_normalization(relu=True, name='conv5_1_3x3_bn')\n             .conv(1, 1, 1024, 1, 1, biased=False, relu=False, name='conv5_1_1x1_increase')\n             .batch_normalization(relu=False, name='conv5_1_1x1_increase_bn'))\n\n        (self.feed('conv5_1_1x1_proj_bn',\n                   'conv5_1_1x1_increase_bn')\n             .add(name='conv5_1')\n             .relu(name='conv5_1/relu')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv5_2_1x1_reduce')\n             .batch_normalization(relu=True, name='conv5_2_1x1_reduce_bn')\n             .zero_padding(paddings=4, name='padding15')\n             .atrous_conv(3, 3, 256, 4, biased=False, relu=False, name='conv5_2_3x3')\n             .batch_normalization(relu=True, name='conv5_2_3x3_bn')\n             .conv(1, 1, 1024, 1, 1, biased=False, relu=False, name='conv5_2_1x1_increase')\n             .batch_normalization(relu=False, name='conv5_2_1x1_increase_bn'))\n\n        (self.feed('conv5_1/relu',\n                   'conv5_2_1x1_increase_bn')\n             .add(name='conv5_2')\n             .relu(name='conv5_2/relu')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv5_3_1x1_reduce')\n             .batch_normalization(relu=True, name='conv5_3_1x1_reduce_bn')\n             .zero_padding(paddings=4, name='padding16')\n             .atrous_conv(3, 3, 256, 4, biased=False, relu=False, name='conv5_3_3x3')\n             .batch_normalization(relu=True, name='conv5_3_3x3_bn')\n             .conv(1, 1, 1024, 1, 1, biased=False, relu=False, name='conv5_3_1x1_increase')\n             .batch_normalization(relu=False, name='conv5_3_1x1_increase_bn'))\n\n        (self.feed('conv5_2/relu',\n                   'conv5_3_1x1_increase_bn')\n             .add(name='conv5_3')\n             .relu(name='conv5_3/relu'))\n\n        shape = self.layers['conv5_3/relu'].get_shape().as_list()[1:3]\n        h, w = shape\n\n        (self.feed('conv5_3/relu')\n             .avg_pool(h, w, h, w, name='conv5_3_pool1')\n             .resize_bilinear(shape, name='conv5_3_pool1_interp'))\n\n        (self.feed('conv5_3/relu')\n             .avg_pool(h/2, w/2, h/2, w/2, name='conv5_3_pool2')\n             .resize_bilinear(shape, name='conv5_3_pool2_interp'))\n\n        (self.feed('conv5_3/relu')\n             .avg_pool(h/3, w/3, h/3, w/3, name='conv5_3_pool3')\n             .resize_bilinear(shape, name='conv5_3_pool3_interp'))\n\n        (self.feed('conv5_3/relu')\n             .avg_pool(h/4, w/4, h/4, w/4, name='conv5_3_pool6')\n             .resize_bilinear(shape, name='conv5_3_pool6_interp'))\n\n        (self.feed('conv5_3/relu',\n                   'conv5_3_pool6_interp',\n                   'conv5_3_pool3_interp',\n                   'conv5_3_pool2_interp',\n                   'conv5_3_pool1_interp')\n             .add(name='conv5_3_sum')\n             .conv(1, 1, 256, 1, 1, biased=False, relu=False, name='conv5_4_k1')\n             .batch_normalization(relu=True, name='conv5_4_k1_bn')\n             .interp(z_factor=2.0, name='conv5_4_interp')\n             .zero_padding(paddings=2, name='padding17')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv_sub4')\n             .batch_normalization(relu=False, name='conv_sub4_bn'))\n\n        (self.feed('conv3_1/relu')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv3_1_sub2_proj')\n             .batch_normalization(relu=False, name='conv3_1_sub2_proj_bn'))\n\n        (self.feed('conv_sub4_bn',\n                   'conv3_1_sub2_proj_bn')\n             .add(name='sub24_sum')\n             .relu(name='sub24_sum/relu')\n             .interp(z_factor=2.0, name='sub24_sum_interp')\n             .zero_padding(paddings=2, name='padding18')\n             .atrous_conv(3, 3, 128, 2, biased=False, relu=False, name='conv_sub2')\n             .batch_normalization(relu=False, name='conv_sub2_bn'))\n\n        (self.feed('data')\n             .conv(3, 3, 32, 2, 2, biased=False, padding='SAME', relu=False, name='conv1_sub1')\n             .batch_normalization(relu=True, name='conv1_sub1_bn')\n             .conv(3, 3, 32, 2, 2, biased=False, padding='SAME', relu=False, name='conv2_sub1')\n             .batch_normalization(relu=True, name='conv2_sub1_bn')\n             .conv(3, 3, 64, 2, 2, biased=False, padding='SAME', relu=False, name='conv3_sub1')\n             .batch_normalization(relu=True, name='conv3_sub1_bn')\n             .conv(1, 1, 128, 1, 1, biased=False, relu=False, name='conv3_sub1_proj')\n             .batch_normalization(relu=False, name='conv3_sub1_proj_bn'))\n\n        (self.feed('conv_sub2_bn',\n                   'conv3_sub1_proj_bn')\n             .add(name='sub12_sum')\n             .relu(name='sub12_sum/relu')\n             .interp(z_factor=2.0, name='sub12_sum_interp')\n             .conv(1, 1, self.cfg.param['num_classes'], 1, 1, biased=True, relu=False, name='conv6_cls'))\n\n        (self.feed('conv5_4_interp')\n             .conv(1, 1, self.cfg.param['num_classes'], 1, 1, biased=True, relu=False, name='sub4_out'))\n\n        (self.feed('sub24_sum_interp')\n             .conv(1, 1, self.cfg.param['num_classes'], 1, 1, biased=True, relu=False, name='sub24_out'))"""
network.py,35,"b""import numpy as np\nimport tensorflow as tf\nimport os\n\nDEFAULT_PADDING = 'VALID'\nDEFAULT_DATAFORMAT = 'NHWC'\nlayer_name = []\nBN_param_map = {'scale':    'gamma',\n                'offset':   'beta',\n                'variance': 'moving_variance',\n                'mean':     'moving_mean'}\n                \ndef layer(op):\n    '''Decorator for composable network layers.'''\n    def layer_decorated(self, *args, **kwargs):\n        # Automatically set a name if not provided.\n        name = kwargs.setdefault('name', self.get_unique_name(op.__name__))\n        # Figure out the layer inputs.\n        if len(self.terminals) == 0:\n            raise RuntimeError('No input variables found for layer %s.' % name)\n        elif len(self.terminals) == 1:\n            layer_input = self.terminals[0]\n        else:\n            layer_input = list(self.terminals)\n        # Perform the operation and get the output.\n        layer_output = op(self, layer_input, *args, **kwargs)\n        # Add to layer LUT.\n        self.layers[name] = layer_output\n        layer_name.append(name)\n        # This output is now the input for the next layer.\n        self.feed(layer_output)\n        # Return self for chained calls.\n        return self\n\n    return layer_decorated\n\n\nclass Network(object):\n    def __init__(self, inputs, cfg, trainable=True):\n        # The input nodes for this network\n        self.inputs = inputs\n        # The current list of terminal nodes\n        self.terminals = []\n        # Mapping from layer names to layers\n        self.layers = dict(inputs)\n        \n        self.trainable = trainable\n\n        # Switch variable for dropout\n        self.use_dropout = tf.placeholder_with_default(tf.constant(1.0),\n                                                       shape=[],\n                                                       name='use_dropout')\n        self.filter_scale = cfg.filter_scale\n\n        # If true, the resulting variables are set as trainable\n        self.is_training = cfg.is_training\n\n        self.setup()\n\n    def setup(self, is_training):\n        '''Construct the network. '''\n        raise NotImplementedError('Must be implemented by the subclass.')\n    \n    def create_session(self):\n        # Set up tf session and initialize variables.\n        config = tf.ConfigProto()\n        config.gpu_options.allow_growth = True\n        \n        global_init = tf.global_variables_initializer()\n        local_init = tf.local_variables_initializer()\n        \n        self.sess = tf.Session(config=config)\n        self.sess.run([global_init, local_init])\n        \n    def restore(self, data_path, var_list=None):\n        if data_path.endswith('.npy'):\n            self.load_npy(data_path, self.sess)\n        else:\n            loader = tf.train.Saver(var_list=tf.global_variables())\n            loader.restore(self.sess, data_path)\n        \n        print('Restore from {}'.format(data_path))\n    \n    def save(self, saver, save_dir, step):\n        model_name = 'model.ckpt'\n        checkpoint_path = os.path.join(save_dir, model_name)\n        \n        if not os.path.exists(save_dir):\n           os.makedirs(save_dir)\n\n        saver.save(self.sess, checkpoint_path, global_step=step)\n        print('The checkpoint has been created, step: {}'.format(step))\n\n    ## Restore from .npy\n    def load_npy(self, data_path, session, ignore_missing=False):\n        '''Load network weights.\n        data_path: The path to the numpy-serialized network weights\n        session: The current TensorFlow session\n        ignore_missing: If true, serialized weights for missing layers are ignored.\n        '''\n        data_dict = np.load(data_path, encoding='latin1').item()\n        for op_name in data_dict:\n            with tf.variable_scope(op_name, reuse=True):\n                for param_name, data in data_dict[op_name].items():\n                    try:\n                        if 'bn' in op_name:\n                            param_name = BN_param_map[param_name]\n\n                        var = tf.get_variable(param_name)\n                        session.run(var.assign(data))\n                    except ValueError:\n                        if not ignore_missing:\n                            raise\n\n    def feed(self, *args):\n        '''Set the input(s) for the next operation by replacing the terminal nodes.\n        The arguments can be either layer names or the actual layers.\n        '''\n        assert len(args) != 0\n        self.terminals = []\n        for fed_layer in args:\n            if isinstance(fed_layer, str):\n                try:\n                    fed_layer = self.layers[fed_layer]\n                except KeyError:\n                    raise KeyError('Unknown layer name fed: %s' % fed_layer)\n            self.terminals.append(fed_layer)\n        return self\n\n    def get_output(self):\n        '''Returns the current network output.'''\n        return self.terminals[-1]\n\n    def get_unique_name(self, prefix):\n        '''Returns an index-suffixed unique name for the given prefix.\n        This is used for auto-generating layer names based on the type-prefix.\n        '''\n        ident = sum(t.startswith(prefix) for t, _ in self.layers.items()) + 1\n        return '%s_%d' % (prefix, ident)\n\n    def make_var(self, name, shape):\n        '''Creates a new TensorFlow variable.'''\n        return tf.get_variable(name, shape, trainable=self.trainable)\n\n    def get_layer_name(self):\n        return layer_name\n    def validate_padding(self, padding):\n        '''Verifies that the padding is one of the supported ones.'''\n        assert padding in ('SAME', 'VALID')\n    @layer\n    def zero_padding(self, input, paddings, name):\n        pad_mat = np.array([[0,0], [paddings, paddings], [paddings, paddings], [0, 0]])\n        return tf.pad(input, paddings=pad_mat, name=name)\n\n    @layer\n    def conv(self,\n             input,\n             k_h,\n             k_w,\n             c_o,\n             s_h,\n             s_w,\n             name,\n             relu=True,\n             padding=DEFAULT_PADDING,\n             group=1,\n             biased=True):\n        # Verify that the padding is acceptable\n        self.validate_padding(padding)\n        # Get the number of channels in the input\n        c_i = input.get_shape()[-1]\n\n        if 'out' not in name and 'cls' not in name:\n            c_o *= self.filter_scale\n\n        convolve = lambda i, k: tf.nn.conv2d(i, k, [1, s_h, s_w, 1], padding=padding,data_format=DEFAULT_DATAFORMAT)\n        with tf.variable_scope(name) as scope:\n            kernel = self.make_var('weights', shape=[k_h, k_w, c_i, c_o])\n            output = convolve(input, kernel)\n\n            if biased:\n                biases = self.make_var('biases', [c_o])\n                output = tf.nn.bias_add(output, biases)\n            if relu:\n                output = tf.nn.relu(output, name=scope.name)\n            return output\n\n    @layer\n    def atrous_conv(self,\n                    input,\n                    k_h,\n                    k_w,\n                    c_o,\n                    dilation,\n                    name,\n                    relu=True,\n                    padding=DEFAULT_PADDING,\n                    group=1,\n                    biased=True):\n        # Verify that the padding is acceptable\n        self.validate_padding(padding)\n        # Get the number of channels in the input\n        c_i = input.get_shape()[-1]\n        c_o *= self.filter_scale\n\n        convolve = lambda i, k: tf.nn.atrous_conv2d(i, k, dilation, padding=padding)\n        with tf.variable_scope(name) as scope:\n            kernel = self.make_var('weights', shape=[k_h, k_w, c_i, c_o])\n            output = convolve(input, kernel)\n\n            if biased:\n                biases = self.make_var('biases', [c_o])\n                output = tf.nn.bias_add(output, biases)\n            if relu:\n                output = tf.nn.relu(output, name=scope.name)\n            return output\n\n    @layer\n    def relu(self, input, name):\n        return tf.nn.relu(input, name=name)\n\n    @layer\n    def max_pool(self, input, k_h, k_w, s_h, s_w, name, padding=DEFAULT_PADDING):\n        self.validate_padding(padding)\n        return tf.nn.max_pool(input,\n                              ksize=[1, k_h, k_w, 1],\n                              strides=[1, s_h, s_w, 1],\n                              padding=padding,\n                              name=name,\n                              data_format=DEFAULT_DATAFORMAT)\n\n    @layer\n    def avg_pool(self, input, k_h, k_w, s_h, s_w, name, padding=DEFAULT_PADDING):\n        self.validate_padding(padding)\n\n        output = tf.nn.avg_pool(input,\n                              ksize=[1, k_h, k_w, 1],\n                              strides=[1, s_h, s_w, 1],\n                              padding=padding,\n                              name=name,\n                              data_format=DEFAULT_DATAFORMAT)\n        return output\n\n    @layer\n    def lrn(self, input, radius, alpha, beta, name, bias=1.0):\n        return tf.nn.local_response_normalization(input,\n                                                  depth_radius=radius,\n                                                  alpha=alpha,\n                                                  beta=beta,\n                                                  bias=bias,\n                                                  name=name)\n\n    @layer\n    def concat(self, inputs, axis, name):\n        return tf.concat(axis=axis, values=inputs, name=name)\n\n    @layer\n    def add(self, inputs, name):\n        inputs[0] = tf.image.resize_bilinear(inputs[0], size=tf.shape(inputs[1])[1:3])\n        \n        return tf.add_n(inputs, name=name)\n\n    @layer\n    def fc(self, input, num_out, name, relu=True):\n        with tf.variable_scope(name) as scope:\n            input_shape = input.get_shape()\n            if input_shape.ndims == 4:\n                # The input is spatial. Vectorize it first.\n                dim = 1\n                for d in input_shape[1:].as_list():\n                    dim *= d\n                feed_in = tf.reshape(input, [-1, dim])\n            else:\n                feed_in, dim = (input, input_shape[-1].value)\n            weights = self.make_var('weights', shape=[dim, num_out])\n            biases = self.make_var('biases', [num_out])\n            op = tf.nn.relu_layer if relu else tf.nn.xw_plus_b\n            fc = op(feed_in, weights, biases, name=scope.name)\n            return fc\n\n    @layer\n    def softmax(self, input, name):\n        input_shape = map(lambda v: v.value, input.get_shape())\n        if len(input_shape) > 2:\n            # For certain models (like NiN), the singleton spatial dimensions\n            # need to be explicitly squeezed, since they're not broadcast-able\n            # in TensorFlow's NHWC ordering (unlike Caffe's NCHW).\n            if input_shape[1] == 1 and input_shape[2] == 1:\n                input = tf.squeeze(input, squeeze_dims=[1, 2])\n            else:        return tf.nn.softmax(input, name)\n\n    @layer\n    def batch_normalization(self, input, name, scale_offset=True, relu=False):\n        output = tf.layers.batch_normalization(\n                    input,\n                    momentum=0.95,\n                    epsilon=1e-5,\n                    training=self.is_training,\n                    name=name\n                )\n\n        if relu:\n            output = tf.nn.relu(output)\n\n        return output\n\n    @layer\n    def dropout(self, input, keep_prob, name):\n        keep = 1 - self.use_dropout + (self.use_dropout * keep_prob)\n        return tf.nn.dropout(input, keep, name=name)\n\n    @layer\n    def resize_bilinear(self, input, size, name):\n        return tf.image.resize_bilinear(input, size=size, align_corners=True, name=name)\n\n    @layer\n    def interp(self, input, s_factor=1, z_factor=1, name=None):\n        ori_h, ori_w = input.get_shape().as_list()[1:3]\n        # shrink\n        ori_h = (ori_h - 1) * s_factor + 1\n        ori_w = (ori_w - 1) * s_factor + 1\n        # zoom\n        ori_h = ori_h + (ori_h - 1) * (z_factor - 1)\n        ori_w = ori_w + (ori_w - 1) * (z_factor - 1)\n        resize_shape = [int(ori_h), int(ori_w)]\n\n        return tf.image.resize_bilinear(input, size=resize_shape, align_corners=True, name=name)\n"""
train.py,26,"b'""""""\nThis code is based on DrSleep\'s framework: https://github.com/DrSleep/tensorflow-deeplab-resnet \n""""""\nimport argparse\nimport os\nimport sys\nimport time\n\nimport tensorflow as tf\nimport numpy as np\n\nfrom model import ICNet_BN\nfrom utils.config import Config\nfrom utils.visualize import decode_labels\nfrom utils.image_reader import ImageReader, prepare_label\n\ndef get_arguments():\n    parser = argparse.ArgumentParser(description=""Reproduced ICNet"")\n    \n    parser.add_argument(""--random-mirror"", action=""store_true"",\n                        help=""Whether to randomly mirror the inputs during the training."")\n    parser.add_argument(""--random-scale"", action=""store_true"",\n                        help=""Whether to randomly scale the inputs during the training."")\n    parser.add_argument(""--update-mean-var"", action=""store_true"",\n                        help=""whether to get update_op from tf.Graphic_Keys"")\n    parser.add_argument(""--train-beta-gamma"", action=""store_true"",\n                        help=""whether to train beta & gamma in bn layer"")\n    parser.add_argument(""--dataset"", required=True,\n                        help=""Which dataset to trained with"",\n                        choices=[\'cityscapes\', \'ade20k\', \'others\'])\n    parser.add_argument(""--filter-scale"", type=int, default=1,\n                        help=""1 for using pruned model, while 2 for using non-pruned model."",\n                        choices=[1, 2])\n    return parser.parse_args()\n\ndef get_mask(gt, num_classes, ignore_label):\n    less_equal_class = tf.less_equal(gt, num_classes-1)\n    not_equal_ignore = tf.not_equal(gt, ignore_label)\n    mask = tf.logical_and(less_equal_class, not_equal_ignore)\n    indices = tf.squeeze(tf.where(mask), 1)\n\n    return indices\n\ndef create_loss(output, label, num_classes, ignore_label):\n    raw_pred = tf.reshape(output, [-1, num_classes])\n    label = prepare_label(label, tf.stack(output.get_shape()[1:3]), num_classes=num_classes, one_hot=False)\n    label = tf.reshape(label, [-1,])\n\n    indices = get_mask(label, num_classes, ignore_label)\n    gt = tf.cast(tf.gather(label, indices), tf.int32)\n    pred = tf.gather(raw_pred, indices)\n\n    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=pred, labels=gt)\n    reduced_loss = tf.reduce_mean(loss)\n\n    return reduced_loss\n\ndef create_losses(net, label, cfg):\n    # Get output from different branches\n    sub4_out = net.layers[\'sub4_out\']\n    sub24_out = net.layers[\'sub24_out\']\n    sub124_out = net.layers[\'conv6_cls\']\n\n    loss_sub4 = create_loss(sub4_out, label, cfg.param[\'num_classes\'], cfg.param[\'ignore_label\'])\n    loss_sub24 = create_loss(sub24_out, label, cfg.param[\'num_classes\'], cfg.param[\'ignore_label\'])\n    loss_sub124 = create_loss(sub124_out, label, cfg.param[\'num_classes\'], cfg.param[\'ignore_label\'])\n\n    l2_losses = [cfg.WEIGHT_DECAY * tf.nn.l2_loss(v) for v in tf.trainable_variables() if \'weights\' in v.name]\n    \n    # Calculate weighted loss of three branches, you can tune LAMBDA values to get better results.\n    reduced_loss = cfg.LAMBDA1 * loss_sub4 +  cfg.LAMBDA2 * loss_sub24 + cfg.LAMBDA3 * loss_sub124 + tf.add_n(l2_losses)\n\n    return loss_sub4, loss_sub24, loss_sub124, reduced_loss\n\nclass TrainConfig(Config):\n    def __init__(self, dataset, is_training,  filter_scale=1, random_scale=None, random_mirror=None):\n        Config.__init__(self, dataset, is_training, filter_scale, random_scale, random_mirror)\n\n    # Set pre-trained weights here (You can download weight using `python script/download_weights.py`) \n    # Note that you need to use ""bnnomerge"" version.\n    model_weight = \'./model/cityscapes/icnet_cityscapes_train_30k_bnnomerge.npy\'\n    \n    # Set hyperparameters here, you can get much more setting in Config Class, see \'utils/config.py\' for details.\n    LAMBDA1 = 0.16\n    LAMBDA2 = 0.4\n    LAMBDA3 = 1.0\n    BATCH_SIZE = 8\n    LEARNING_RATE = 5e-4\n\ndef main():\n    """"""Create the model and start the training.""""""\n    args = get_arguments()\n\n    """"""\n    Get configurations here. We pass some arguments from command line to init configurations, for training hyperparameters, \n    you can set them in TrainConfig Class.\n\n    Note: we set filter scale to 1 for pruned model, 2 for non-pruned model. The filters numbers of non-pruned\n          model is two times larger than prunde model, e.g., [h, w, 64] <-> [h, w, 32].\n    """"""\n    cfg = TrainConfig(dataset=args.dataset, \n                is_training=True,\n                random_scale=args.random_scale,\n                random_mirror=args.random_mirror,\n                filter_scale=args.filter_scale)\n    cfg.display()\n\n    # Setup training network and training samples\n    train_reader = ImageReader(cfg=cfg, mode=\'train\')\n    train_net = ICNet_BN(image_reader=train_reader, \n                            cfg=cfg, mode=\'train\')\n\n    loss_sub4, loss_sub24, loss_sub124, reduced_loss = create_losses(train_net, train_net.labels, cfg)\n\n    # Setup validation network and validation samples\n    with tf.variable_scope(\'\', reuse=True):\n        val_reader = ImageReader(cfg, mode=\'eval\')\n        val_net = ICNet_BN(image_reader=val_reader, \n                            cfg=cfg, mode=\'train\')\n\n        val_loss_sub4, val_loss_sub24, val_loss_sub124, val_reduced_loss = create_losses(val_net, val_net.labels, cfg)\n\n    # Using Poly learning rate policy \n    base_lr = tf.constant(cfg.LEARNING_RATE)\n    step_ph = tf.placeholder(dtype=tf.float32, shape=())\n    learning_rate = tf.scalar_mul(base_lr, tf.pow((1 - step_ph / cfg.TRAINING_STEPS), cfg.POWER))\n    \n    # Set restore variable \n    restore_var = tf.global_variables()\n    all_trainable = [v for v in tf.trainable_variables() if (\'beta\' not in v.name and \'gamma\' not in v.name) or args.train_beta_gamma]\n\n    # Gets moving_mean and moving_variance update operations from tf.GraphKeys.UPDATE_OPS\n    if args.update_mean_var == False:\n        update_ops = None\n    else:\n        update_ops = tf.get_collection(tf.GraphKeys.UPDATE_OPS)\n\n    with tf.control_dependencies(update_ops):\n        opt_conv = tf.train.MomentumOptimizer(learning_rate, cfg.MOMENTUM)\n        grads = tf.gradients(reduced_loss, all_trainable)\n        train_op = opt_conv.apply_gradients(zip(grads, all_trainable))\n    \n    # Create session & restore weights (Here we only need to use train_net to create session since we reuse it)\n    train_net.create_session()\n    train_net.restore(cfg.model_weight, restore_var)\n    saver = tf.train.Saver(var_list=tf.global_variables(), max_to_keep=5)\n\n    # Iterate over training steps.\n    for step in range(cfg.TRAINING_STEPS):\n        start_time = time.time()\n            \n        feed_dict = {step_ph: step}\n        if step % cfg.SAVE_PRED_EVERY == 0:\n            loss_value, loss1, loss2, loss3, val_loss_value, _ = train_net.sess.run([reduced_loss, loss_sub4, loss_sub24, loss_sub124, val_reduced_loss, train_op], feed_dict=feed_dict)\n            train_net.save(saver, cfg.SNAPSHOT_DIR, step)\n        else:\n            loss_value, loss1, loss2, loss3, val_loss_value, _ = train_net.sess.run([reduced_loss, loss_sub4, loss_sub24, loss_sub124, val_reduced_loss, train_op], feed_dict=feed_dict)            \n\n        duration = time.time() - start_time\n        print(\'step {:d} \\t total loss = {:.3f}, sub4 = {:.3f}, sub24 = {:.3f}, sub124 = {:.3f}, val_loss: {:.3f} ({:.3f} sec/step)\'.\\\n                    format(step, loss_value, loss1, loss2, loss3, val_loss_value, duration))\n    \n    \nif __name__ == \'__main__\':\n    main()\n'"
script/download_weights.py,0,"b'from google_drive_downloader import GoogleDriveDownloader as gdd\r\nimport argparse\r\n\r\nparser = argparse.ArgumentParser(description=""Reproduced ICNet"")\r\n\r\nparser.add_argument(""--dataset"", type=str, default=\'\',\r\n                        choices=[\'ade20k\', \'cityscapes\'],\r\n                        required=True)\r\nargs = parser.parse_args()\r\n\r\nif args.dataset == \'cityscapes\':\r\n    ## Download cityscapes weight\r\n    gdd.download_file_from_google_drive(file_id=\'15S_vZoZZwBsORxtRAMcbdsI99o6Cvo5x\',\r\n                                        dest_path=\'./model/cityscapes/icnet_cityscapes_train_30k_bnnomerge.npy\',\r\n                                        unzip=False)\r\n    gdd.download_file_from_google_drive(file_id=\'17ZILbQ7Qazg7teb567CIPJ30FD57bVVg\',\r\n                                        dest_path=\'./model/cityscapes/icnet_cityscapes_train_30k.npy\',\r\n                                        unzip=False)\r\n    gdd.download_file_from_google_drive(file_id=\'1Z-slNrKYJpfpELeuh2UlueQG1krF9I4a\',\r\n                                        dest_path=\'./model/cityscapes/icnet_cityscapes_trainval_90k_bnnomerge.npy\',\r\n                                        unzip=False)\r\n    gdd.download_file_from_google_drive(file_id=\'1tZIHpppPcleamBlXKSzjOqL93gNjWGec\',\r\n                                        dest_path=\'./model/cityscapes/icnet_cityscapes_trainval_90k.npy\',\r\n                                        unzip=False)\r\nelif args.dataset == \'ade20k\':\r\n    ## Download ade20k weight\r\n    gdd.download_file_from_google_drive(file_id=\'1vh_JWy4lBM3A7QggQMIQLoJYZHEtUDi3\',\r\n                                        dest_path=\'./model/ade20k/model.ckpt-27150.data-00000-of-00001\',\r\n                                        unzip=False)\r\n    gdd.download_file_from_google_drive(file_id=\'1_YAwOiBlSxu9ynlopaLQ4yjuhVTiz_-f\',\r\n                                        dest_path=\'./model/ade20k/model.ckpt-27150.index\',\r\n                                        unzip=False)\r\n    gdd.download_file_from_google_drive(file_id=\'1ZeRnqKIoc3r6e8pezzT4xT-9FT0tudhd\',\r\n                                        dest_path=\'./model/ade20k/model.ckpt-27150.meta\',\r\n                                        unzip=False)\r\n    gdd.download_file_from_google_drive(file_id=\'1RjIuPJ-Vhs1EuXgK9sHeT-XFoO_Sba69\',\r\n                                        dest_path=\'./model/ade20k/checkpoint\',\r\n                                        unzip=False)\r\n'"
utils/__init__.py,0,b''
utils/config.py,0,"b'import numpy as np\nimport os\n\nclass Config(object):\n    # Setting dataset directory\n    CITYSCAPES_DATA_DIR = \'./data/cityscapes_dataset/cityscape/\'\n    ADE20K_DATA_DIR = \'./data/ADEChallengeData2016/\'\n      \n    ADE20K_eval_list = os.path.join(\'./data/list/ade20k_val_list.txt\')\n    CITYSCAPES_eval_list = os.path.join(\'./data/list/cityscapes_val_list.txt\')\n    \n    ADE20K_train_list = os.path.join(\'./data/list/ade20k_train_list.txt\')\n    CITYSCAPES_train_list = os.path.join(\'./data/list/cityscapes_train_list.txt\')\n    \n    IMG_MEAN = np.array((103.939, 116.779, 123.68), dtype=np.float32)\n    \n    ADE20k_param = {\'name\': \'ade20k\',\n                \'num_classes\': 150, # predict: [0~149] corresponding to label [1~150], ignore class 0 (background) \n                \'ignore_label\': 0,\n                \'eval_size\': [480, 480],\n                \'eval_steps\': 2000,\n                \'eval_list\': ADE20K_eval_list,\n                \'train_list\': ADE20K_train_list,\n                \'data_dir\': ADE20K_DATA_DIR}\n    \n    cityscapes_param = {\'name\': \'cityscapes\',\n                    \'num_classes\': 19,\n                    \'ignore_label\': 255,\n                    \'eval_size\': [1025, 2049],\n                    \'eval_steps\': 500,\n                    \'eval_list\': CITYSCAPES_eval_list,\n                    \'train_list\': CITYSCAPES_train_list,\n                    \'data_dir\': CITYSCAPES_DATA_DIR}\n    \n    model_paths = {\'train\': \'./model/cityscapes/icnet_cityscapes_train_30k.npy\', \n              \'trainval\': \'./model/cityscapes/icnet_cityscapes_trainval_90k.npy\',\n              \'train_bn\': \'./model/cityscapes/icnet_cityscapes_train_30k_bnnomerge.npy\',\n              \'trainval_bn\': \'./model/cityscapes/icnet_cityscapes_trainval_90k_bnnomerge.npy\',\n              \'others\': \'./model/ade20k/model.ckpt-27150\'}\n    \n    ## If you want to train on your own dataset, try to set these parameters.\n    others_param = {\'name\': \'YOUR_OWN_DATASET\',\n                    \'num_classes\': 0,\n                    \'ignore_label\': 0,\n                    \'eval_size\': [0, 0],\n                    \'eval_steps\': 0,\n                    \'eval_list\': \'/PATH/TO/YOUR_EVAL_LIST\',\n                    \'train_list\': \'/PATH/TO/YOUR_TRAIN_LIST\',\n                    \'data_dir\': \'/PATH/TO/YOUR_DATA_DIR\'}\n\n    ## You can modify following lines to train different training configurations.\n    INFER_SIZE = [1024, 2048, 3] \n    TRAINING_SIZE = [720, 720] \n    TRAINING_STEPS = 60001\n    \n    N_WORKERS = 8\n    BATCH_SIZE = 16\n    LEARNING_RATE = 1e-4\n    MOMENTUM = 0.9\n    POWER = 0.9\n    RANDOM_SEED = 1234\n    WEIGHT_DECAY = 0.0001\n    SNAPSHOT_DIR = \'./snapshots/\'\n    SAVE_NUM_IMAGES = 4\n    SAVE_PRED_EVERY = 500\n    \n    # Loss Function = LAMBDA1 * sub4_loss + LAMBDA2 * sub24_loss + LAMBDA3 * sub124_loss\n    LAMBDA1 = 0.16\n    LAMBDA2 = 0.4\n    LAMBDA3 = 1.0\n    \n    def __init__(self, dataset, is_training=False, filter_scale=1, random_scale=False, random_mirror=False):\n        print(\'Setup configurations...\')\n        \n        if dataset == \'ade20k\':\n            self.param = self.ADE20k_param\n        elif dataset == \'cityscapes\':\n            self.param = self.cityscapes_param\n        elif dataset == \'others\':\n            self.param = self.others_param\n\n        self.dataset = dataset\n        self.random_scale = random_scale\n        self.random_mirror = random_mirror\n        self.is_training = is_training\n        self.filter_scale = filter_scale\n        \n    def display(self):\n        """"""Display Configuration values.""""""\n        print(""\\nConfigurations:"")\n        for a in dir(self):\n            if not a.startswith(""__"") and not callable(getattr(self, a)) and not isinstance(getattr(self, a), dict):\n                print(""{:30} {}"".format(a, getattr(self, a)))\n\n            if a == (""param""):\n                print(a)\n                for k, v in getattr(self, a).items():\n                    print(""   {:27} {}"".format(k, v))\n\n        print(""\\n"")'"
utils/image_reader.py,40,"b'import os\nimport numpy as np\nimport tensorflow as tf\nimport glob\nimport cv2\n\ndef read_labeled_image_list(data_dir, data_list):\n    f = open(data_list, \'r\')\n    \n    images = []\n    masks = []\n    for line in f:\n        try:\n            image, mask = line[:-1].split(\' \')\n        except ValueError: # Adhoc for test.\n            image = mask = line.strip(""\\n"")\n\n        image = os.path.join(data_dir, image)\n        mask = os.path.join(data_dir, mask)\n        mask = mask.strip()\n        \n        if not tf.gfile.Exists(image):\n            raise ValueError(\'Failed to find file: \' + image)\n\n        if not tf.gfile.Exists(mask):\n            raise ValueError(\'Failed to find file: \' + mask)\n\n        images.append(image)\n        masks.append(mask)\n\n    return images, masks\n\ndef prepare_label(input_batch, new_size, num_classes, one_hot=True):\n    with tf.name_scope(\'label_encode\'):\n        input_batch = tf.image.resize_nearest_neighbor(input_batch, new_size) # as labels are integer numbers, need to use NN interp.\n        input_batch = tf.squeeze(input_batch, axis=[3]) # reducing the channel dimension.\n        if one_hot:\n            input_batch = tf.one_hot(input_batch, depth=num_classes)\n            \n    return input_batch\n\ndef _extract_mean(img, img_mean, swap_channel=False):\n    # swap channel and extract mean\n    \n    if swap_channel:\n        img_r, img_g, img_b = tf.split(axis=2, num_or_size_splits=3, value=img)\n        img = tf.cast(tf.concat(axis=2, values=[img_b, img_g, img_r]), dtype=tf.float32)\n\n    img -= img_mean\n    \n    return img\n\ndef _parse_function(image_filename, label_filename, img_mean):\n    img_contents = tf.read_file(image_filename)\n    label_contents = tf.read_file(label_filename)\n       \n    # Decode image & label\n    img = tf.image.decode_jpeg(img_contents, channels=3)\n    label = tf.image.decode_png(label_contents, channels=1)\n    \n    # swap channel and extract mean\n    img = _extract_mean(img, img_mean, swap_channel=True)\n\n    return img, label\n\ndef _image_mirroring(img, label):\n    distort_left_right_random = tf.random_uniform([1], 0, 1.0, dtype=tf.float32)[0]\n    mirror = tf.less(tf.stack([1.0, distort_left_right_random, 1.0]), 0.5)\n    mirror = tf.boolean_mask([0, 1, 2], mirror)\n    img = tf.reverse(img, mirror)\n    label = tf.reverse(label, mirror)\n\n    return img, label\n\ndef _image_scaling(img, label):\n    scale = tf.random_uniform([1], minval=0.5, maxval=2.0, dtype=tf.float32, seed=None)\n    h_new = tf.to_int32(tf.multiply(tf.to_float(tf.shape(img)[0]), scale))\n    w_new = tf.to_int32(tf.multiply(tf.to_float(tf.shape(img)[1]), scale))\n    new_shape = tf.squeeze(tf.stack([h_new, w_new]), axis=[1])\n    img = tf.image.resize_images(img, new_shape)\n    label = tf.image.resize_nearest_neighbor(tf.expand_dims(label, 0), new_shape)\n    label = tf.squeeze(label, axis=[0])\n\n    return img, label\n\ndef _random_crop_and_pad_image_and_labels(image, label, crop_h, crop_w, ignore_label):\n    label = tf.cast(label, dtype=tf.float32)\n    label = label - ignore_label # Needs to be subtracted and later added due to 0 padding.\n    combined = tf.concat(axis=2, values=[image, label])\n    image_shape = tf.shape(image)\n    combined_pad = tf.image.pad_to_bounding_box(\n                            combined,\n                            0,\n                            0,\n                            tf.maximum(crop_h, image_shape[0]),\n                            tf.maximum(crop_w, image_shape[1]))\n\n    last_image_dim = tf.shape(image)[-1]\n    last_label_dim = tf.shape(label)[-1]\n    combined_crop = tf.random_crop(combined_pad, [crop_h, crop_w, 4])\n    img_crop = combined_crop[:, :, :last_image_dim]\n    label_crop = combined_crop[:, :, last_image_dim:]\n    label_crop = label_crop + ignore_label\n    label_crop = tf.cast(label_crop, dtype=tf.uint8)\n\n    # Set static shape so that tensorflow knows shape at compile time.\n    img_crop.set_shape((crop_h, crop_w, 3))\n    label_crop.set_shape((crop_h, crop_w, 1))\n\n    return img_crop, label_crop\n\ndef _check_input(img):\n    ori_h, ori_w = img.get_shape().as_list()[1:3]\n    \n    if ori_h % 32 != 0 or ori_w % 32 != 0:\n        new_h = (int(ori_h/32) + 1) * 32\n        new_w = (int(ori_w/32) + 1) * 32\n        shape = [new_h, new_w]\n        \n        img = tf.image.pad_to_bounding_box(img, 0, 0, new_h, new_w)\n        \n        print(\'Image shape cannot divided by 32, padding to ({0}, {1})\'.format(new_h, new_w))\n    else:\n        shape = [ori_h, ori_w]\n\n    return img, shape\n\ndef _infer_preprocess(img, swap_channel=False):\n    o_shape = img.shape[0:2]\n        \n    img = _extract_mean(img, swap_channel)\n    img = tf.expand_dims(img, axis=0)\n    img, n_shape = _check_input(img)\n        \n    return img, o_shape, n_shape\n\ndef _eval_preprocess(img, label, shape, dataset):\n    if dataset == \'cityscapes\':\n        img = tf.image.pad_to_bounding_box(img, 0, 0, shape[0], shape[1])\n        img.set_shape([shape[0], shape[1], 3])\n    else:\n        img = tf.image.resize_images(img, shape, align_corners=True)\n     \n    return img, label\n\nclass ImageReader(object):\n    \'\'\'\n    Generic ImageReader which reads images and corresponding segmentation masks\n    from the disk, and enqueues them into a TensorFlow queue using tf.Dataset API.\n    \'\'\'\n\n    def __init__(self, cfg, img_path=None, mode=\'eval\'):\n        if mode == \'train\' or mode == \'eval\':\n            self.image_list, self.label_list = read_labeled_image_list(cfg.param[\'data_dir\'], cfg.param[mode+\'_list\'])\n            print(cfg.param[mode+\'_list\'])\n            self.dataset = self.create_tf_dataset(cfg)\n\n            self.next_image, self.next_label = self.dataset.make_one_shot_iterator().get_next() \n    \n    def create_tf_dataset(self, cfg):\n        dataset = tf.data.Dataset.from_tensor_slices((self.image_list, self.label_list))\n        dataset = dataset.map(lambda x, y: _parse_function(x, y, cfg.IMG_MEAN), num_parallel_calls=cfg.N_WORKERS)\n\n        if cfg.is_training: # Training phase\n            h, w = cfg.TRAINING_SIZE\n\n            if cfg.random_scale:\n                dataset = dataset.map(_image_scaling, num_parallel_calls=cfg.N_WORKERS)\n            if cfg.random_mirror:\n                dataset = dataset.map(_image_mirroring, num_parallel_calls=cfg.N_WORKERS)\n\n            dataset = dataset.map(lambda x, y: \n                                  _random_crop_and_pad_image_and_labels(x, y, h, w, cfg.param[\'ignore_label\']),\n                                  num_parallel_calls=cfg.N_WORKERS)\n            \n            dataset = dataset.shuffle(buffer_size=500)\n            dataset = dataset.batch(cfg.BATCH_SIZE, drop_remainder=True)\n            dataset = dataset.repeat()\n            \n        else: # Evaluation phase            \n            dataset = dataset.map(lambda x, y: \n                                  _eval_preprocess(x, y, cfg.param[\'eval_size\'], cfg.dataset),\n                                  num_parallel_calls=cfg.N_WORKERS)\n            dataset = dataset.batch(1)\n                \n        return dataset\n\n    \n    \n'"
utils/visualize.py,9,"b""import scipy.io as sio\nimport numpy as np\nimport tensorflow as tf\n\nlabel_colours = [[128, 64, 128], [244, 35, 231], [69, 69, 69]\n                # 0 = road, 1 = sidewalk, 2 = building\n                ,[102, 102, 156], [190, 153, 153], [153, 153, 153]\n                # 3 = wall, 4 = fence, 5 = pole\n                ,[250, 170, 29], [219, 219, 0], [106, 142, 35]\n                # 6 = traffic light, 7 = traffic sign, 8 = vegetation\n                ,[152, 250, 152], [69, 129, 180], [219, 19, 60]\n                # 9 = terrain, 10 = sky, 11 = person\n                ,[255, 0, 0], [0, 0, 142], [0, 0, 69]\n                # 12 = rider, 13 = car, 14 = truck\n                ,[0, 60, 100], [0, 79, 100], [0, 0, 230]\n                # 15 = bus, 16 = train, 17 = motocycle\n                ,[119, 10, 32]]\n                # 18 = bicycle\n\nmatfn = './utils/color150.mat'\ndef read_labelcolours(matfn):\n    mat = sio.loadmat(matfn)\n    color_table = mat['colors']\n    shape = color_table.shape\n    color_list = [tuple(color_table[i]) for i in range(shape[0])]\n\n    return color_list\n\ndef decode_labels(mask, img_shape, num_classes):\n    if num_classes == 150:\n        color_table = read_labelcolours(matfn)\n    else:\n        color_table = label_colours\n\n    color_mat = tf.constant(color_table, dtype=tf.float32)\n    onehot_output = tf.one_hot(mask, depth=num_classes)\n    onehot_output = tf.reshape(onehot_output, (-1, num_classes))\n    pred = tf.matmul(onehot_output, color_mat)\n    pred = tf.reshape(pred, (1, img_shape[0], img_shape[1], 3))\n    \n    return pred\n\ndef prepare_label(input_batch, new_size, num_classes, one_hot=True):\n    with tf.name_scope('label_encode'):\n        input_batch = tf.image.resize_nearest_neighbor(input_batch, new_size) # as labels are integer numbers, need to use NN interp.\n        input_batch = tf.squeeze(input_batch, squeeze_dims=[3]) # reducing the channel dimension.\n        if one_hot:\n            input_batch = tf.one_hot(input_batch, depth=num_classes)\n            \n    return input_batch\n"""
