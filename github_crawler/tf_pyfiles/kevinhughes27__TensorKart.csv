file_path,api_count,code
play.py,0,"b'#!/usr/bin/env python\n\nfrom utils import resize_image, XboxController\nfrom termcolor import cprint\n\nimport gym\nimport gym_mupen64plus\nfrom train import create_model\nimport numpy as np\n\n# Play\nclass Actor(object):\n\n    def __init__(self):\n        # Load in model from train.py and load in the trained weights\n        self.model = create_model(keep_prob=1) # no dropout\n        self.model.load_weights(\'model_weights.h5\')\n\n        # Init contoller for manual override\n        self.real_controller = XboxController()\n\n    def get_action(self, obs):\n\n        ### determine manual override\n        manual_override = self.real_controller.LeftBumper == 1\n\n        if not manual_override:\n            ## Look\n            vec = resize_image(obs)\n            vec = np.expand_dims(vec, axis=0) # expand dimensions for predict, it wants (1,66,200,3) not (66, 200, 3)\n            ## Think\n            joystick = self.model.predict(vec, batch_size=1)[0]\n\n        else:\n            joystick = self.real_controller.read()\n            joystick[1] *= -1 # flip y (this is in the config when it runs normally)\n\n\n        ## Act\n\n        ### calibration\n        output = [\n            int(joystick[0] * 80),\n            int(joystick[1] * 80),\n            int(round(joystick[2])),\n            int(round(joystick[3])),\n            int(round(joystick[4])),\n        ]\n\n        ### print to console\n        if manual_override:\n            cprint(""Manual: "" + str(output), \'yellow\')\n        else:\n            cprint(""AI: "" + str(output), \'green\')\n\n        return output\n\n\nif __name__ == \'__main__\':\n    env = gym.make(\'Mario-Kart-Royal-Raceway-v0\')\n\n    obs = env.reset()\n    env.render()\n    print(\'env ready!\')\n\n    actor = Actor()\n    print(\'actor ready!\')\n\n    print(\'beginning episode loop\')\n    total_reward = 0\n    end_episode = False\n    while not end_episode:\n        action = actor.get_action(obs)\n        obs, reward, end_episode, info = env.step(action)\n        env.render()\n        total_reward += reward\n\n    print(\'end episode... total reward: \' + str(total_reward))\n\n    obs = env.reset()\n    print(\'env ready!\')\n\n    input(\'press <ENTER> to quit\')\n\n    env.close()\n'"
record.py,0,"b'#!/usr/bin/env python\n\nimport numpy as np\nimport os\nimport shutil\nimport mss\nimport matplotlib\nmatplotlib.use(\'TkAgg\')\nfrom datetime import datetime\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg as FigCanvas\n\nfrom PIL import ImageTk, Image\n\nimport sys\n\nPY3_OR_LATER = sys.version_info[0] >= 3\n\nif PY3_OR_LATER:\n    # Python 3 specific definitions\n    import tkinter as tk\n    import tkinter.ttk as ttk\n    import tkinter.messagebox as tkMessageBox\nelse:\n    # Python 2 specific definitions\n    import Tkinter as tk\n    import ttk\n    import tkMessageBox\n\nfrom utils import Screenshot, XboxController\n\nIMAGE_SIZE = (320, 240)\nIDLE_SAMPLE_RATE = 1500\nSAMPLE_RATE = 200\n\nclass MainWindow():\n    """""" Main frame of the application\n    """"""\n\n    def __init__(self):\n        self.root = tk.Tk()\n        self.sct = mss.mss()\n\n        self.root.title(\'Data Acquisition\')\n        self.root.geometry(""660x325"")\n        self.root.resizable(False, False)\n\n        # Init controller\n        self.controller = XboxController()\n\n         # Create GUI\n        self.create_main_panel()\n\n        # Timer\n        self.rate = IDLE_SAMPLE_RATE\n        self.sample_rate = SAMPLE_RATE\n        self.idle_rate = IDLE_SAMPLE_RATE\n        self.recording = False\n        self.t = 0\n        self.pause_timer = False\n        self.on_timer()\n\n        self.root.mainloop()\n\n    def create_main_panel(self):\n        # Panels\n        top_half = tk.Frame(self.root)\n        top_half.pack(side=tk.TOP, expand=True, padx=5, pady=5)\n        message = tk.Label(self.root, text=""(Note: UI updates are disabled while recording)"")\n        message.pack(side=tk.TOP, padx=5)\n        bottom_half = tk.Frame(self.root)\n        bottom_half.pack(side=tk.LEFT, padx=5, pady=10)\n\n        # Images\n        self.img_panel = tk.Label(top_half, image=ImageTk.PhotoImage(""RGB"", size=IMAGE_SIZE)) # Placeholder\n        self.img_panel.pack(side = tk.LEFT, expand=False, padx=5)\n\n        # Joystick\n        self.init_plot()\n        self.PlotCanvas = FigCanvas(figure=self.fig, master=top_half)\n        self.PlotCanvas.get_tk_widget().pack(side=tk.RIGHT, expand=False, padx=5)\n\n        # Recording\n        textframe = tk.Frame(bottom_half, width=332, height=15, padx=5)\n        textframe.pack(side=tk.LEFT)\n        textframe.pack_propagate(0)\n        self.outputDirStrVar = tk.StringVar()\n        self.txt_outputDir = tk.Entry(textframe, textvariable=self.outputDirStrVar, width=100)\n        self.txt_outputDir.pack(side=tk.LEFT)\n        self.outputDirStrVar.set(""samples/"" + datetime.now().strftime(\'%Y-%m-%d_%H:%M:%S\'))\n\n        self.record_button = ttk.Button(bottom_half, text=""Record"", command=self.on_btn_record)\n        self.record_button.pack(side = tk.LEFT, padx=5)\n\n\n    def init_plot(self):\n        self.plotMem = 50 # how much data to keep on the plot\n        self.plotData = [[0] * (5)] * self.plotMem # mem storage for plot\n\n        self.fig = Figure(figsize=(4,3), dpi=80) # 320,240\n        self.axes = self.fig.add_subplot(111)\n\n\n    def on_timer(self):\n        self.poll()\n\n        # stop drawing if recording to avoid slow downs\n        if self.recording == False:\n            self.draw()\n\n        if not self.pause_timer:\n            self.root.after(self.rate, self.on_timer)\n\n\n    def poll(self):\n        self.img = self.take_screenshot()\n        self.controller_data = self.controller.read()\n        self.update_plot()\n\n        if self.recording == True:\n            self.save_data()\n            self.t += 1\n\n\n    def take_screenshot(self):\n        # Get raw pixels from the screen\n        sct_img = self.sct.grab({  ""top"": Screenshot.OFFSET_Y,\n                                  ""left"": Screenshot.OFFSET_X,\n                                 ""width"": Screenshot.SRC_W,\n                                ""height"": Screenshot.SRC_H})\n\n        # Create the Image\n        return Image.frombytes(\'RGB\', sct_img.size, sct_img.bgra, \'raw\', \'BGRX\')\n\n\n    def update_plot(self):\n        self.plotData.append(self.controller_data) # adds to the end of the list\n        self.plotData.pop(0) # remove the first item in the list, ie the oldest\n\n\n    def save_data(self):\n        image_file = self.outputDir+\'/\'+\'img_\'+str(self.t)+\'.png\'\n        self.img.save(image_file)\n\n        # write csv line\n        self.outfile.write( image_file + \',\' + \',\'.join(map(str, self.controller_data)) + \'\\n\' )\n\n\n    def draw(self):\n        # Image\n        self.img.thumbnail(IMAGE_SIZE, Image.ANTIALIAS) # Resize\n        self.img_panel.img = ImageTk.PhotoImage(self.img)\n        self.img_panel[\'image\'] = self.img_panel.img\n\n        # Joystick\n        x = np.asarray(self.plotData)\n        self.axes.clear()\n        self.axes.plot(range(0,self.plotMem), x[:,0], \'r\')\n        self.axes.plot(range(0,self.plotMem), x[:,1], \'b\')\n        self.axes.plot(range(0,self.plotMem), x[:,2], \'g\')\n        self.axes.plot(range(0,self.plotMem), x[:,3], \'k\')\n        self.axes.plot(range(0,self.plotMem), x[:,4], \'y\')\n        self.PlotCanvas.draw()\n\n\n    def on_btn_record(self):\n        # pause timer\n        self.pause_timer = True\n\n        if self.recording:\n            self.recording = False\n        else:\n            self.start_recording()\n\n        if self.recording:\n            self.t = 0 # Reset our counter for the new recording\n            self.record_button[""text""] = ""Stop""\n            self.rate = self.sample_rate\n            # make / open outfile\n            self.outfile = open(self.outputDir+\'/\'+\'data.csv\', \'a\')\n        else:\n            self.record_button[""text""] = ""Record""\n            self.rate = self.idle_rate\n            self.outfile.close()\n\n        # un pause timer\n        self.pause_timer = False\n        self.on_timer()\n\n\n    def start_recording(self):\n        should_record = True\n\n        # check that a dir has been specified\n        if not self.outputDirStrVar.get():\n            tkMessageBox.showerror(title=\'Error\', message=\'Specify the Output Directory\', parent=self.root)\n            should_record = False\n\n        else: # a directory was specified\n            self.outputDir = self.outputDirStrVar.get()\n\n            # check if path exists - i.e. may be saving over data\n            if os.path.exists(self.outputDir):\n\n                # overwrite the data, yes/no?\n                if tkMessageBox.askyesno(title=\'Warning!\', message=\'Output Directory Exists - Overwrite Data?\', parent=self.root):\n                    # delete & re-make the dir:\n                    shutil.rmtree(self.outputDir)\n                    os.mkdir(self.outputDir)\n\n                # answer was \'no\', so do not overwrite the data\n                else:\n                    should_record = False\n                    self.txt_outputDir.focus_set()\n\n            # directory doesn\'t exist, so make one\n            else:\n                os.mkdir(self.outputDir)\n\n        self.recording = should_record\n\n\nif __name__ == \'__main__\':\n    app = MainWindow()\n'"
train.py,0,"b'#!/usr/bin/env python\n\nimport numpy as np\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten\nfrom keras.layers import Conv2D\nfrom keras import optimizers\nfrom keras import backend as K\nfrom utils import Sample\n\n# Global variable\nOUT_SHAPE = 5\nINPUT_SHAPE = (Sample.IMG_H, Sample.IMG_W, Sample.IMG_D)\n\n\ndef customized_loss(y_true, y_pred, loss=\'euclidean\'):\n    # Simply a mean squared error that penalizes large joystick summed values\n    if loss == \'L2\':\n        L2_norm_cost = 0.001\n        val = K.mean(K.square((y_pred - y_true)), axis=-1) \\\n                    + K.sum(K.square(y_pred), axis=-1)/2 * L2_norm_cost\n    # euclidean distance loss\n    elif loss == \'euclidean\':\n        val = K.sqrt(K.sum(K.square(y_pred-y_true), axis=-1))\n    return val\n\n\ndef create_model(keep_prob = 0.8):\n    model = Sequential()\n\n    # NVIDIA\'s model\n    model.add(Conv2D(24, kernel_size=(5, 5), strides=(2, 2), activation=\'relu\', input_shape= INPUT_SHAPE))\n    model.add(Conv2D(36, kernel_size=(5, 5), strides=(2, 2), activation=\'relu\'))\n    model.add(Conv2D(48, kernel_size=(5, 5), strides=(2, 2), activation=\'relu\'))\n    model.add(Conv2D(64, kernel_size=(3, 3), activation=\'relu\'))\n    model.add(Conv2D(64, kernel_size=(3, 3), activation=\'relu\'))\n    model.add(Flatten())\n    model.add(Dense(1164, activation=\'relu\'))\n    drop_out = 1 - keep_prob\n    model.add(Dropout(drop_out))\n    model.add(Dense(100, activation=\'relu\'))\n    model.add(Dropout(drop_out))\n    model.add(Dense(50, activation=\'relu\'))\n    model.add(Dropout(drop_out))\n    model.add(Dense(10, activation=\'relu\'))\n    model.add(Dropout(drop_out))\n    model.add(Dense(OUT_SHAPE, activation=\'softsign\'))\n\n    return model\n\n\nif __name__ == \'__main__\':\n    # Load Training Data\n    x_train = np.load(""data/X.npy"")\n    y_train = np.load(""data/y.npy"")\n\n    print(x_train.shape[0], \'train samples\')\n\n    # Training loop variables\n    epochs = 100\n    batch_size = 50\n\n    model = create_model()\n    model.compile(loss=customized_loss, optimizer=optimizers.adam())\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, shuffle=True, validation_split=0.1)\n\n    model.save_weights(\'model_weights.h5\')\n'"
utils.py,0,"b'#!/usr/bin/env python\n\nimport sys\nimport array\n\nimport numpy as np\n\nfrom skimage.color import rgb2gray\nfrom skimage.transform import resize\nfrom skimage.io import imread\n\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nfrom inputs import get_gamepad\nimport math\nimport threading\n\n\ndef resize_image(img):\n    im = resize(img, (Sample.IMG_H, Sample.IMG_W, Sample.IMG_D))\n    im_arr = im.reshape((Sample.IMG_H, Sample.IMG_W, Sample.IMG_D))\n    return im_arr\n\n\nclass Screenshot(object):\n    SRC_W = 640\n    SRC_H = 480\n    SRC_D = 3\n\n    OFFSET_X = 0\n    OFFSET_Y = 0\n\n\nclass Sample:\n    IMG_W = 200\n    IMG_H = 66\n    IMG_D = 3\n\n\nclass XboxController(object):\n    MAX_TRIG_VAL = math.pow(2, 8)\n    MAX_JOY_VAL = math.pow(2, 15)\n\n    def __init__(self):\n\n        self.LeftJoystickY = 0\n        self.LeftJoystickX = 0\n        self.RightJoystickY = 0\n        self.RightJoystickX = 0\n        self.LeftTrigger = 0\n        self.RightTrigger = 0\n        self.LeftBumper = 0\n        self.RightBumper = 0\n        self.A = 0\n        self.X = 0\n        self.Y = 0\n        self.B = 0\n        self.LeftThumb = 0\n        self.RightThumb = 0\n        self.Back = 0\n        self.Start = 0\n        self.LeftDPad = 0\n        self.RightDPad = 0\n        self.UpDPad = 0\n        self.DownDPad = 0\n\n        self._monitor_thread = threading.Thread(target=self._monitor_controller, args=())\n        self._monitor_thread.daemon = True\n        self._monitor_thread.start()\n\n\n    def read(self):\n        x = self.LeftJoystickX\n        y = self.LeftJoystickY\n        a = self.A\n        b = self.X # b=1, x=2\n        rb = self.RightBumper\n        return [x, y, a, b, rb]\n\n\n    def _monitor_controller(self):\n        while True:\n            events = get_gamepad()\n            for event in events:\n                if event.code == \'ABS_Y\':\n                    self.LeftJoystickY = event.state / XboxController.MAX_JOY_VAL # normalize between -1 and 1\n                elif event.code == \'ABS_X\':\n                    self.LeftJoystickX = event.state / XboxController.MAX_JOY_VAL # normalize between -1 and 1\n                elif event.code == \'ABS_RY\':\n                    self.RightJoystickY = event.state / XboxController.MAX_JOY_VAL # normalize between -1 and 1\n                elif event.code == \'ABS_RX\':\n                    self.RightJoystickX = event.state / XboxController.MAX_JOY_VAL # normalize between -1 and 1\n                elif event.code == \'ABS_Z\':\n                    self.LeftTrigger = event.state / XboxController.MAX_TRIG_VAL # normalize between 0 and 1\n                elif event.code == \'ABS_RZ\':\n                    self.RightTrigger = event.state / XboxController.MAX_TRIG_VAL # normalize between 0 and 1\n                elif event.code == \'BTN_TL\':\n                    self.LeftBumper = event.state\n                elif event.code == \'BTN_TR\':\n                    self.RightBumper = event.state\n                elif event.code == \'BTN_SOUTH\':\n                    self.A = event.state\n                elif event.code == \'BTN_NORTH\':\n                    self.X = event.state\n                elif event.code == \'BTN_WEST\':\n                    self.Y = event.state\n                elif event.code == \'BTN_EAST\':\n                    self.B = event.state\n                elif event.code == \'BTN_THUMBL\':\n                    self.LeftThumb = event.state\n                elif event.code == \'BTN_THUMBR\':\n                    self.RightThumb = event.state\n                elif event.code == \'BTN_SELECT\':\n                    self.Back = event.state\n                elif event.code == \'BTN_START\':\n                    self.Start = event.state\n                elif event.code == \'BTN_TRIGGER_HAPPY1\':\n                    self.LeftDPad = event.state\n                elif event.code == \'BTN_TRIGGER_HAPPY2\':\n                    self.RightDPad = event.state\n                elif event.code == \'BTN_TRIGGER_HAPPY3\':\n                    self.UpDPad = event.state\n                elif event.code == \'BTN_TRIGGER_HAPPY4\':\n                    self.DownDPad = event.state\n\n\nclass Data(object):\n    def __init__(self):\n        self._X = np.load(""data/X.npy"")\n        self._y = np.load(""data/y.npy"")\n        self._epochs_completed = 0\n        self._index_in_epoch = 0\n        self._num_examples = self._X.shape[0]\n\n    @property\n    def num_examples(self):\n        return self._num_examples\n\n    def next_batch(self, batch_size):\n        start = self._index_in_epoch\n        self._index_in_epoch += batch_size\n        if self._index_in_epoch > self._num_examples:\n            # Finished epoch\n            self._epochs_completed += 1\n            # Start next epoch\n            start = 0\n            self._index_in_epoch = batch_size\n            assert batch_size <= self._num_examples\n        end = self._index_in_epoch\n        return self._X[start:end], self._y[start:end]\n\n\ndef load_sample(sample):\n    image_files = np.loadtxt(sample + \'/data.csv\', delimiter=\',\', dtype=str, usecols=(0,))\n    joystick_values = np.loadtxt(sample + \'/data.csv\', delimiter=\',\', usecols=(1,2,3,4,5))\n    return image_files, joystick_values\n\n\n# training data viewer\ndef viewer(sample):\n    image_files, joystick_values = load_sample(sample)\n\n    plotData = []\n\n    plt.ion()\n    plt.figure(\'viewer\', figsize=(16, 6))\n\n    for i in range(len(image_files)):\n\n        # joystick\n        print(i, "" "", joystick_values[i,:])\n\n        # format data\n        plotData.append( joystick_values[i,:] )\n        if len(plotData) > 30:\n            plotData.pop(0)\n        x = np.asarray(plotData)\n\n        # image (every 3rd)\n        if (i % 3 == 0):\n            plt.subplot(121)\n            image_file = image_files[i]\n            img = mpimg.imread(image_file)\n            plt.imshow(img)\n\n        # plot\n        plt.subplot(122)\n        plt.plot(range(i,i+len(plotData)), x[:,0], \'r\')\n        plt.hold(True)\n        plt.plot(range(i,i+len(plotData)), x[:,1], \'b\')\n        plt.plot(range(i,i+len(plotData)), x[:,2], \'g\')\n        plt.plot(range(i,i+len(plotData)), x[:,3], \'k\')\n        plt.plot(range(i,i+len(plotData)), x[:,4], \'y\')\n        plt.draw()\n        plt.hold(False)\n\n        plt.pause(0.0001) # seconds\n        i += 1\n\n\n# prepare training data\ndef prepare(samples):\n    print(""Preparing data"")\n\n    X = []\n    y = []\n\n    for sample in samples:\n        print(sample)\n\n        # load sample\n        image_files, joystick_values = load_sample(sample)\n\n        # add joystick values to y\n        y.append(joystick_values)\n\n        # load, prepare and add images to X\n        for image_file in image_files:\n            image = imread(image_file)\n            vec = resize_image(image)\n            X.append(vec)\n\n    print(""Saving to file..."")\n    X = np.asarray(X)\n    y = np.concatenate(y)\n\n    np.save(""data/X"", X)\n    np.save(""data/y"", y)\n\n    print(""Done!"")\n    return\n\n\nif __name__ == \'__main__\':\n    if sys.argv[1] == \'viewer\':\n        viewer(sys.argv[2])\n    elif sys.argv[1] == \'prepare\':\n        prepare(sys.argv[2:])\n'"
