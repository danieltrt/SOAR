file_path,api_count,code
__init__.py,0,b''
config.py,0,"b'import sys\nimport os\n\nimport argparse\nimport numpy as np\n\nIMG_MEAN = np.array((104.00698793,116.66876762,122.67891434), dtype=np.float32)\n\nBATCH_SIZE = 4\nBN_WEIGHT_DECAY = 0.9997\nCKPT = 0\nDATA_DIRECTORY = \'/storage/ndong/data/auto/VOC/VOCdevkit/VOC2012\'\nDATA_NAME = \'VOC12\'\nIGNORE_LABEL = 255\nIMAGENET = \'./data/pretrained_models\'\nINPUT_SIZE = 513\nLEARNING_RATE = 0.01\nMOMENTUM = 0.9\nNUM_CLASSES = 21\nNUM_GPUS = 1\nNUM_LAYERS = 101\nNUM_STEPS = 600000\nNUM_TRAIN = 10582\nNUM_VAL = 1449\nPOWER = 0.9\nRANDOM_SEED = 1234\nRESTORE_FROM = None\nSAVE_NUM_IMAGES = 1\nSAVE_PRED_EVERY = 1000\nSNAPSHOT_DIR = \'./snapshots\'\nSPLIT_NAME = \'train\'\nWEIGHT_DECAY = 1e-4\n\nparser = argparse.ArgumentParser(description=""DeepLabV3"")\nparser.add_argument(""--batch-size"", type=int, default=BATCH_SIZE,\n                    help=""Number of images sent to the network in one step."")\nparser.add_argument(""--bn-weight-decay"", type=float, default=BN_WEIGHT_DECAY,\n                    help=""Regularisation parameter for batch norm."")\nparser.add_argument(""--ckpt"", type=int, default=CKPT, \n                    help=""Checkpoint to restore."")\nparser.add_argument(""--data-dir"", type=str, default=DATA_DIRECTORY,\n                    help=""Path to the directory containing the PASCAL VOC dataset."")\nparser.add_argument(""--data-name"", type=str, default=DATA_NAME,\n                    help=""Name of the dataset."")\nparser.add_argument(""--freeze-bn"", action=""store_true"",\n                    help=""Whether to freeze batch norm params."")\nparser.add_argument(""--ignore-label"", type=int, default=IGNORE_LABEL,\n                    help=""The index of the label to ignore during the training."")\nparser.add_argument(""--imagenet"", type=str, default=IMAGENET,\n                    help=""Path to ImageNet pretrained weights."")\nparser.add_argument(""--input-size"", type=int, default=INPUT_SIZE,\n                    help=""height and width of images."")\nparser.add_argument(""--learning-rate"", type=float, default=LEARNING_RATE,\n                    help=""Base learning rate for training with polynomial decay."")\nparser.add_argument(""--momentum"", type=float, default=MOMENTUM,\n                    help=""Momentum component of the optimiser."")\nparser.add_argument(""--not-restore-last"", action=""store_true"",\n                    help=""Whether to not restore last (FC) layers."")\nparser.add_argument(""--num-classes"", type=int, default=NUM_CLASSES,\n                    help=""Number of classes to predict (including background)."")\nparser.add_argument(""--num-gpus"", type=int, default=NUM_GPUS,\n                    help=""Number of GPUs to use."")\nparser.add_argument(""--num-layers"", type=int, default=NUM_LAYERS,\n                    help=""Number of layes in ResNet)."")\nparser.add_argument(""--num-steps"", type=int, default=NUM_STEPS,\n                    help=""Number of training steps."")\nparser.add_argument(""--power"", type=float, default=POWER,\n                    help=""Decay parameter to compute the learning rate."")\nparser.add_argument(""--random-mirror"", action=""store_true"",\n                    help=""Whether to randomly mirror the inputs during the training."")\nparser.add_argument(""--random-scale"", action=""store_true"",\n                    help=""Whether to randomly scale the inputs during the training."")\nparser.add_argument(""--random-seed"", type=int, default=RANDOM_SEED,\n                    help=""Random seed to have reproducible results."")\nparser.add_argument(""--restore-from"", type=str, default=RESTORE_FROM,\n                    help=""Where restore model parameters from."")\nparser.add_argument(""--save-num-images"", type=int, default=SAVE_NUM_IMAGES,\n                    help=""How many images to save."")\nparser.add_argument(""--save-pred-every"", type=int, default=SAVE_PRED_EVERY,\n                    help=""Save summaries and checkpoint every often."")\nparser.add_argument(""--snapshot-dir"", type=str, default=SNAPSHOT_DIR,\n                    help=""Where to save snapshots of the model."")\nparser.add_argument(""--split-name"", type=str, default=SPLIT_NAME,\n                    help=""Split name."")\nparser.add_argument(""--weight-decay"", type=float, default=WEIGHT_DECAY,\n                    help=""Regularisation parameter for L2-loss."")\n\nargs = parser.parse_args()'"
convert_voc12.py,16,"b'import os\nimport sys\nimport numpy as np\nimport tensorflow as tf\n\nfrom config import *\nfrom PIL import Image\n\ndef _int64_feature(value):\n  """"""Wrapper for inserting int64 features into Example proto.""""""\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=value))\n\n\ndef _float64_feature(value):\n  """"""Wrapper for inserting float64 features into Example proto.""""""\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(float_list=tf.train.FloatList(value=value))\n\n\ndef _bytes_feature(value):\n  """"""Wrapper for inserting bytes features into Example proto.""""""\n  return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))\n\n\ndef _convert_to_example(filename, image_buffer, segmentation, height, width):\n  image_format = \'JPEG\'\n  segmentation_format = \'PNG\'\n  example = tf.train.Example(features=tf.train.Features(feature={\n    \'image/height\': _int64_feature(height),\n    \'image/width\': _int64_feature(width),\n    \'image/filename\': _bytes_feature(tf.compat.as_bytes(os.path.basename(filename))),\n    \'image/format\': _bytes_feature(tf.compat.as_bytes(image_format)),\n    \'image/encoded\': _bytes_feature(tf.compat.as_bytes(image_buffer)),\n    \'image/segmentation/format\': _bytes_feature(tf.compat.as_bytes(segmentation_format)),\n    \'image/segmentation/encoded\': _bytes_feature(tf.compat.as_bytes(segmentation)),\n    }))\n  return example\n\ndef _convert_to_tfrecord(record_dir):\n  """"""Loads image files and writes files to a TFRecord.\n  """"""\n  label_placeholder = tf.placeholder(dtype=tf.uint8)\n  encoded_label = tf.image.encode_png(tf.expand_dims(label_placeholder, 2))\n  with tf.Session(\'\') as sess:\n    record_filename = os.path.join(record_dir, \'{}_{}.tfrecord\'.format(args.data_name, args.split_name))\n    with tf.python_io.TFRecordWriter(record_filename) as tfrecord_writer:\n      with open(\'./libs/datasets/VOC12/{}.txt\'.format(args.split_name), \'r\') as f:\n        count = 1\n        if args.split_name == \'train\':\n          total = 10582\n        elif args.split_name == \'val\':\n          total = 1449\n\n        for line in f:\n          line = line.strip()\n          img, gt = line.split()\n          img_path = args.data_dir + img\n          gt_path = args.data_dir + gt\n          with tf.gfile.FastGFile(img_path, \'rb\') as ff:\n              image_data = ff.read()\n          segmentation = np.array(Image.open(gt_path))\n          h,w = segmentation.shape[0], segmentation.shape[1]\n          label_string = sess.run(encoded_label,\n            feed_dict={label_placeholder:segmentation})\n          example = _convert_to_example(img_path, image_data, label_string, \n            h, w)\n          tfrecord_writer.write(example.SerializeToString())\n          sys.stdout.write(\'Write {} {}/{}\\n\'.format(img_path, count, total))\n          sys.stdout.flush()\n          count += 1\n\n  sys.stdout.write(\'\\n\')\n  sys.stdout.flush()\n\n\nif __name__ == \'__main__\':\n  record_dir = os.path.join(args.data_dir, \'records\')\n\n  if not tf.gfile.Exists(record_dir):\n    tf.gfile.MakeDirs(record_dir)\n\n  # process the training, validation data:\n  _convert_to_tfrecord(record_dir)\n\n  print(\'\\nFinished converting the VOC12 dataset!\')'"
eval_voc12.py,22,"b'import sys\nimport argparse\nimport numpy as np\nimport tensorflow as tf\nimport time\n\nfrom config import *\nfrom datetime import datetime\nfrom libs.datasets.dataset_factory import read_data\nfrom libs.datasets.VOC12 import decode_labels, inv_preprocess, prepare_label\nfrom libs.nets import deeplabv3\n\nslim = tf.contrib.slim\nstreaming_mean_iou = tf.contrib.metrics.streaming_mean_iou\n\ndef save(saver, sess, logdir, step):\n   \'\'\'Save weights.\n   \n   Args:\n     saver: TensorFlow Saver object.\n     sess: TensorFlow session.\n     logdir: path to the snapshots directory.\n     step: current training step.\n   \'\'\'\n   model_name = \'model.ckpt\'\n   checkpoint_path = os.path.join(logdir, model_name)\n    \n   if not os.path.exists(logdir):\n      os.makedirs(logdir)\n   saver.save(sess, checkpoint_path, global_step=step)\n   print(\'The checkpoint has been created.\')\n\ndef load(saver, sess, ckpt_dir):\n    \'\'\'Load trained weights.\n    \n    Args:\n      saver: TensorFlow Saver object.\n      sess: TensorFlow session.\n      ckpt_path: path to checkpoint file with parameters.\n    \'\'\' \n    if args.ckpt == 0:\n        ckpt = tf.train.get_checkpoint_state(ckpt_dir)\n        ckpt_path = ckpt.model_checkpoint_path\n    else:\n        ckpt_path = ckpt_dir+\'/model.ckpt-%i\' % args.ckpt\n    saver.restore(sess, ckpt_path)\n    print(""Restored model parameters from {}"".format(ckpt_path))\n\ndef main():\n    """"""Create the model and start the training.""""""\n    tf.set_random_seed(args.random_seed)\n    \n    # Create queue coordinator.\n    coord = tf.train.Coordinator()\n\n    image_batch, label_batch = read_data(is_training=args.is_training)\n\n    # Create network.\n    net, end_points = deeplabv3(image_batch,\n                                num_classes=args.num_classes,\n                                depth=args.num_layers,\n                                is_training=False)\n\n    # For a small batch size, it is better to keep \n    # the statistics of the BN layers (running means and variances)\n    # frozen, and to not update the values provided by the pre-trained model. \n    # If is_training=True, the statistics will be updated during the training.\n    # Note that is_training=False still updates BN parameters gamma (scale) and beta (offset)\n    # if they are presented in var_list of the optimiser definition.\n\n    # Which variables to load. Running means and variances are not trainable,\n    # thus all_variables() should be restored.\n    restore_var = [v for v in tf.global_variables() if \'fc\' not in v.name or not args.not_restore_last]\n    \n    # Predictions.\n    raw_output = end_points[\'resnet{}/logits\'.format(args.num_layers)]\n    # Predictions: ignoring all predictions with labels greater or equal than n_classes\n    nh, nw = tf.shape(image_batch)[1], tf.shape(image_batch)[2]\n    seg_logits = tf.image.resize_bilinear(raw_output, [nh, nw])\n    seg_pred = tf.argmax(seg_logits, axis=3)\n    seg_pred = tf.expand_dims(seg_pred, 3)\n    seg_pred = tf.reshape(seg_pred, [-1,])\n\n    seg_gt = tf.cast(label_batch, tf.int32)\n    seg_gt = tf.reshape(seg_gt, [-1,])\n    mask = seg_gt <= args.num_classes - 1\n\n    seg_pred = tf.boolean_mask(seg_pred, mask)\n    seg_gt = tf.boolean_mask(seg_gt, mask)\n\n    mean_iou, update_mean_iou = streaming_mean_iou(seg_pred, seg_gt, num_classes=args.num_classes)\n    \n    # Set up tf session and initialize variables. \n    config = tf.ConfigProto()\n    config.gpu_options.allow_growth = True\n    sess = tf.Session(config=config)\n\n    sess.run(tf.global_variables_initializer())\n    sess.run(tf.local_variables_initializer())\n    \n    # Load variables if the checkpoint is provided.\n    if args.ckpt > 0 or args.restore_from is not None:\n        loader = tf.train.Saver(var_list=restore_var)\n        load(loader, sess, args.snapshot_dir)\n    \n    # Start queue threads.\n    threads = tf.train.start_queue_runners(coord=coord, sess=sess)\n    \n    tf.get_default_graph().finalize()\n    \n    for step in range(1449):\n        start_time = time.time()\n        mean_iou_float, _ = sess.run([mean_iou, update_mean_iou])\n        duration = time.time() - start_time\n        sys.stdout.write(\'step {:d}, mean_iou: {:.6f}({:.3f} sec/step)\\n\'.format(step, mean_iou_float, duration))\n        sys.stdout.flush()\n\n        if coord.should_stop():\n            coord.request_stop()\n            coord.join(threads)\n    \nif __name__ == \'__main__\':\n    main()\n'"
train_voc12.py,55,"b'""""""Training script for the DeepLab-ResNet network on the PASCAL VOC dataset\n   for semantic image segmentation.\n\nThis script trains the model using augmented PASCAL VOC,\nwhich contains approximately 10000 images for training and 1500 images for \nvalidation.\n""""""\nimport os\nimport sys\nimport argparse\nimport numpy as np\nimport tensorflow as tf\nimport time\n\nfrom config import *\nfrom datetime import datetime\nfrom libs.datasets.dataset_factory import read_data\nfrom libs.datasets.VOC12 import decode_labels, inv_preprocess, prepare_label\nfrom libs.nets import deeplabv3\n\nslim = tf.contrib.slim\nstreaming_mean_iou = tf.contrib.metrics.streaming_mean_iou\n\ndef save(saver, sess, logdir, step):\n    \'\'\'Save weights.\n   \n    Args:\n      saver: TensorFlow Saver object.\n      sess: TensorFlow session.\n      logdir: path to the snapshots directory.\n      step: current training step.\n    \'\'\'\n    model_name = \'model.ckpt\'\n    checkpoint_path = os.path.join(logdir, model_name)\n    \n    if not os.path.exists(logdir):\n       os.makedirs(logdir)\n    saver.save(sess, checkpoint_path, global_step=step)\n    print(\'The checkpoint has been created.\')\n\ndef load(saver, sess, ckpt_dir):\n    \'\'\'Load trained weights.\n    \n    Args:\n      saver: TensorFlow Saver object.\n      sess: TensorFlow session.\n      ckpt_path: path to checkpoint file with parameters.\n    \'\'\'\n    if args.ckpt == 0:\n        if args.imagenet is not None:\n            ckpt_path = os.path.join(args.imagenet, \'resnet_v1_{}.ckpt\'.format(args.num_layers).format(args.num_layers))\n        else:\n            ckpt = tf.train.get_checkpoint_state(ckpt_dir)\n            ckpt_path = ckpt.model_checkpoint_path\n    else:\n        ckpt_path = ckpt_dir+\'/model.ckpt-%i\' % args.ckpt\n    saver.restore(sess, ckpt_path)\n    print(""Restored model parameters from {}"".format(ckpt_path))\n\ndef main():\n    """"""Create the model and start the training.""""""\n    h = args.input_size\n    w = args.input_size\n    input_size = (h, w)\n    \n    tf.set_random_seed(args.random_seed)\n    \n    # Create queue coordinator.\n    coord = tf.train.Coordinator()\n\n    image_batch, label_batch = read_data(is_training=True, split_name=\'train\')\n    \n    # Create network.\n    net, end_points = deeplabv3(image_batch,\n                                num_classes=args.num_classes,\n                                depth=args.num_layers,\n                                is_training=True,\n                                )\n    # For a small batch size, it is better to keep \n    # the statistics of the BN layers (running means and variances)\n    # frozen, and to not update the values provided by the pre-trained model. \n    # If is_training=True, the statistics will be updated during the training.\n    # Note that is_training=False still updates BN parameters gamma (scale) \n    # and beta (offset)\n    # if they are presented in var_list of the optimizer definition.\n\n    # Predictions.\n    raw_output = end_points[\'resnet_v1_{}/logits\'.format(args.num_layers)]\n    # Which variables to load. Running means and variances are not trainable,\n    # thus all_variables() should be restored.\n    if args.imagenet is not None and args.ckpt == 0:\n        restore_var = [v for v in tf.global_variables() if \n          (\'aspp\' not in v.name) and \n          (\'img_pool\' not in v.name) and \n          (\'fusion\' not in v.name) and\n          (\'block5\' not in v.name) and\n          (\'block6\' not in v.name) and\n          (\'block7\' not in v.name) and\n          (\'logits\' not in v.name)]\n    else:\n        restore_var = [v for v in tf.global_variables()]\n        \n    if args.freeze_bn:\n        all_trainable = [v for v in tf.trainable_variables() if \'beta\' not in \n            v.name and \'gamma\' not in v.name]\n    else:\n        all_trainable = [v for v in tf.trainable_variables()]\n    conv_trainable = [v for v in all_trainable] \n    \n    # Upsample the logits instead of donwsample the ground truth\n    raw_output_up = tf.image.resize_bilinear(raw_output, [h, w])\n\n    # Predictions: ignoring all predictions with labels greater or equal than \n    # n_classes\n    label_proc = tf.squeeze(label_batch)\n    mask = label_proc <= args.num_classes\n    seg_logits = tf.boolean_mask(raw_output_up, mask)\n    seg_gt = tf.boolean_mask(label_proc, mask)\n    seg_gt = tf.cast(seg_gt, tf.int32)          \n                                                  \n    # Pixel-wise softmax loss.\n    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=seg_logits,\n        labels=seg_gt)\n    seg_loss = tf.reduce_mean(loss)\n    seg_loss_sum = tf.summary.scalar(\'loss/seg\', seg_loss)\n    reg_losses = tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)\n    reg_loss = tf.add_n(reg_losses)\n    reg_loss_sum = tf.summary.scalar(\'loss/reg\', reg_loss)\n    tot_loss = seg_loss + reg_loss\n    tot_loss_sum = tf.summary.scalar(\'loss/tot\', tot_loss)\n\n    seg_pred = tf.argmax(seg_logits, axis=1)\n    train_mean_iou, train_update_mean_iou = streaming_mean_iou(seg_pred, \n        seg_gt, args.num_classes, name=""train_iou"")  \n    train_iou_sum = tf.summary.scalar(\'accuracy/train_mean_iou\', \n        train_mean_iou)\n    train_initializer = tf.variables_initializer(var_list=tf.get_collection(\n        tf.GraphKeys.LOCAL_VARIABLES, scope=""train_iou""))\n\n    # Define loss and optimisation parameters.\n    base_lr = tf.constant(args.learning_rate)\n    step_ph = tf.placeholder(dtype=tf.float32, shape=())\n    learning_rate = tf.scalar_mul(base_lr, tf.pow((1 - step_ph / args.num_steps), args.power))\n    # learning_rate = base_lr\n    lr_sum = tf.summary.scalar(\'params/learning_rate\', learning_rate)\n\n    train_sum_op = tf.summary.merge([seg_loss_sum, reg_loss_sum, \n        tot_loss_sum, train_iou_sum, lr_sum])\n\n    image_batch_val, label_batch_val = read_data(is_training=False, split_name=\'val\')\n    _, end_points_val = deeplabv3(image_batch_val,\n                                  num_classes=args.num_classes,\n                                  depth=args.num_layers,\n                                  reuse=True,\n                                  is_training=False,\n                                  )\n    raw_output_val = end_points_val[\'resnet_v1_{}/logits\'.format(args.num_layers)]\n    nh, nw = tf.shape(image_batch_val)[1], tf.shape(image_batch_val)[2]\n\n    seg_logits_val = tf.image.resize_bilinear(raw_output_val, [nh, nw])\n    seg_pred_val = tf.argmax(seg_logits_val, axis=3)\n    seg_pred_val = tf.expand_dims(seg_pred_val, 3)\n    seg_pred_val = tf.reshape(seg_pred_val, [-1,])\n\n    seg_gt_val = tf.cast(label_batch_val, tf.int32)\n    seg_gt_val = tf.reshape(seg_gt_val, [-1,])\n    mask_val = seg_gt_val <= args.num_classes - 1\n\n    seg_pred_val = tf.boolean_mask(seg_pred_val, mask_val)\n    seg_gt_val = tf.boolean_mask(seg_gt_val, mask_val)\n\n    val_mean_iou, val_update_mean_iou = streaming_mean_iou(seg_pred_val, \n        seg_gt_val, num_classes=args.num_classes, name=""val_iou"")        \n    val_iou_sum = tf.summary.scalar(\'accuracy/val_mean_iou\', val_mean_iou)\n    val_initializer = tf.variables_initializer(var_list=tf.get_collection(\n        tf.GraphKeys.LOCAL_VARIABLES, scope=""val_iou""))\n    test_sum_op = tf.summary.merge([val_iou_sum])\n\n    global_step = tf.train.get_or_create_global_step()\n    \n    opt = tf.train.MomentumOptimizer(learning_rate, args.momentum)\n\n    grads_conv = tf.gradients(tot_loss, conv_trainable)\n    # train_op = opt.apply_gradients(zip(grads_conv, conv_trainable))\n    train_op = slim.learning.create_train_op(\n        tot_loss, opt,\n        global_step=global_step,\n        variables_to_train=conv_trainable,\n        summarize_gradients=True)\n    \n    # Set up tf session and initialize variables. \n    config = tf.ConfigProto()\n    config.gpu_options.allow_growth = True\n    sess = tf.Session(config=config)\n\n    sess.run(tf.global_variables_initializer())\n    sess.run(tf.local_variables_initializer())\n    \n    # Saver for storing checkpoints of the model.\n    saver = tf.train.Saver(var_list=tf.global_variables(), max_to_keep=20)\n    \n    # Load variables if the checkpoint is provided.\n    if args.ckpt > 0 or args.restore_from is not None or args.imagenet is not None:\n        loader = tf.train.Saver(var_list=restore_var)\n        load(loader, sess, args.snapshot_dir)\n    \n    # Start queue threads.\n    threads = tf.train.start_queue_runners(coord=coord, sess=sess)\n    \n    # tf.get_default_graph().finalize()\n    summary_writer = tf.summary.FileWriter(args.snapshot_dir,\n                                           sess.graph)\n    \n    # Iterate over training steps.\n    for step in range(args.ckpt, args.num_steps):\n        start_time = time.time()\n        feed_dict = { step_ph : step }\n        tot_loss_float, seg_loss_float, reg_loss_float, _, lr_float, _,train_summary = sess.run([tot_loss, seg_loss, reg_loss, train_op,\n            learning_rate, train_update_mean_iou, train_sum_op], \n            feed_dict=feed_dict)\n        train_mean_iou_float = sess.run(train_mean_iou)\n        duration = time.time() - start_time\n        sys.stdout.write(\'step {:d}, tot_loss = {:.6f}, seg_loss = {:.6f}, \' \\\n            \'reg_loss = {:.6f}, mean_iou = {:.6f}, lr: {:.6f}({:.3f}\' \\\n            \'sec/step)\\n\'.format(step, tot_loss_float, seg_loss_float,\n             reg_loss_float, train_mean_iou_float, lr_float, duration)\n            )\n        sys.stdout.flush()\n\n        if step % args.save_pred_every == 0 and step > args.ckpt:\n            sess.run(val_initializer)\n            for val_step in range(NUM_VAL):\n                _, test_summary = sess.run([val_update_mean_iou, test_sum_op],\n                feed_dict=feed_dict)\n            \n            summary_writer.add_summary(train_summary, step)\n            summary_writer.add_summary(test_summary, step)\n            val_mean_iou_float= sess.run(val_mean_iou)\n\n            save(saver, sess, args.snapshot_dir, step)\n            sys.stdout.write(\'step {:d}, train_mean_iou: {:.6f}, \' \\\n                \'val_mean_iou: {:.6f}\\n\'.format(step, train_mean_iou_float, \n                val_mean_iou_float))\n            sys.stdout.flush()\n            sess.run(train_initializer)\n\n        if coord.should_stop():\n            coord.request_stop()\n            coord.join(threads)\n    \nif __name__ == \'__main__\':\n    main()\n'"
libs/__init__.py,0,b''
libs/datasets/__init__.py,0,b''
libs/datasets/dataset_factory.py,14,"b'import glob\nimport libs.preprocess.voc as preprocess\nimport numpy as np\nimport tensorflow.contrib.slim as slim\nimport tensorflow as tf\n\nfrom config import *\nfrom libs.datasets.VOC12 import VOC_CATS\n\ndef get_dataset(tfrecord_path):\n  keys_to_features = {\n    \'image/encoded\': tf.FixedLenFeature((), tf.string, default_value=\'\'),\n    \'image/format\': tf.FixedLenFeature((), tf.string, default_value=\'JPEG\'),\n    \'image/segmentation/encoded\': tf.FixedLenFeature((), tf.string,\n      default_value=\'\'),\n    \'image/segmentation/format\': tf.FixedLenFeature((), tf.string,\n      default_value=\'RAW\')\n    }\n\n  items_to_handlers = {\n    \'image\': slim.tfexample_decoder.Image(\'image/encoded\', \n      \'image/format\', channels=3),\n    \'segmentation\': slim.tfexample_decoder.Image(\n      \'image/segmentation/encoded\', \'image/segmentation/format\', channels=1),\n    }\n\n  items_to_descriptions = {\n    \'image\': \'A color image of varying height and width.\',\n    \'segmentation\': \'A semantic segmentation.\',\n    }\n\n  if \'VOC12\' in tfrecord_path:\n    categories = VOC_CATS\n    num_samples = 14270\n\n  return slim.dataset.Dataset(\n    data_sources=[tfrecord_path],\n    reader=tf.TFRecordReader,\n    decoder=slim.tfexample_decoder.TFExampleDecoder(keys_to_features,\n      items_to_handlers),\n    num_samples=num_samples,\n    items_to_descriptions=items_to_descriptions,\n    num_classes=len(categories),\n    labels_to_names={i: cat for i, cat in enumerate(categories)})\n\ndef extract_batch(dataset, batch_size, is_training):\n  with tf.device(""/cpu:0""):\n    data_provider = slim.dataset_data_provider.DatasetDataProvider(\n      dataset, num_readers=4, shuffle=False, common_queue_capacity=512, common_queue_min=32)\n\n    image, gt_mask = data_provider.get([\'image\', \'segmentation\'])\n    image, gt_mask = preprocess.preprocess_image(image, gt_mask, is_training=is_training)\n \n    return tf.train.shuffle_batch([image, gt_mask], batch_size, 4096, 64, num_threads=4)\n\ndef read_data(is_training, split_name):\n  file_pattern = \'{}_{}.tfrecord\'.format(args.data_name, split_name)\n  tfrecord_path = os.path.join(args.data_dir,\'records\',file_pattern)\n\n  if is_training:\n    dataset = get_dataset(tfrecord_path)\n    image, gt_mask = extract_batch(dataset, args.batch_size, is_training)\n  else:\n    image, gt_mask = read_tfrecord(tfrecord_path)\n    image, gt_mask = preprocess.preprocess_image(image, gt_mask, is_training)\n  return image, gt_mask\n\ndef read_tfrecord(tfrecords_filename):\n  if not isinstance(tfrecords_filename, list):\n    tfrecords_filename = [tfrecords_filename]\n  filename_queue = tf.train.string_input_producer(\n    tfrecords_filename)\n\n  reader = tf.TFRecordReader()\n  _, serialized_example = reader.read(filename_queue)\n  features = tf.parse_single_example(\n    serialized_example,\n    features={\n      \'image/encoded\': tf.FixedLenFeature([], tf.string),\n      \'image/segmentation/encoded\': tf.FixedLenFeature([], tf.string),\n      })\n  image = tf.image.decode_jpeg(features[\'image/encoded\'], channels=3)\n  gt_mask = tf.image.decode_png(features[\'image/segmentation/encoded\'], channels=1)\n  \n  return image, gt_mask\n'"
libs/nets/__init__.py,0,b'from libs.nets.deeplabv3 import deeplabv3'
libs/nets/deeplabv3.py,32,"b'import tensorflow as tf\n\nfrom config import *\nfrom libs.nets import resnet_utils\nfrom libs.nets.resnet_v1 import bottleneck, resnet_arg_scope\n\nslim = tf.contrib.slim\n\n\'\'\'Commented out due to suspicious implementation. \n@slim.add_arg_scope\ndef bottleneck_hdc(inputs,\n               depth,\n               depth_bottleneck,\n               stride,\n               rate=1,\n               multi_grid=(1,2,4),\n               outputs_collections=None,\n               scope=None,\n               use_bounded_activations=False):\n  """"""Hybrid Dilated Convolution Bottleneck.\n  Multi_Grid = (1,2,4)\n  See Understanding Convolution for Semantic Segmentation.\n  When putting together two consecutive ResNet blocks that use this unit, one\n  should use stride = 2 in the last unit of the first block.\n  Args:\n    inputs: A tensor of size [batch, height, width, channels].\n    depth: The depth of the ResNet unit output.\n    depth_bottleneck: The depth of the bottleneck layers.\n    stride: The ResNet unit\'s stride. Determines the amount of downsampling of\n      the units output compared to its input.\n    rate: An integer, rate for atrous convolution.\n    multi_grid: multi_grid sturcture.\n    outputs_collections: Collection to add the ResNet unit output.\n    scope: Optional variable_scope.\n    use_bounded_activations: Whether or not to use bounded activations. Bounded\n      activations better lend themselves to quantized inference.\n  Returns:\n    The ResNet unit\'s output.\n  """"""\n  with tf.variable_scope(scope, \'bottleneck_v1\', [inputs]) as sc:\n    depth_in = slim.utils.last_dimension(inputs.get_shape(), min_rank=4)\n    if depth == depth_in:\n      shortcut = resnet_utils.subsample(inputs, stride, \'shortcut\')\n    else:\n      shortcut = slim.conv2d(\n          inputs,\n          depth, [1, 1],\n          stride=stride,\n          activation_fn=tf.nn.relu6 if use_bounded_activations else None,\n          scope=\'shortcut\')\n\n    residual = slim.conv2d(inputs, depth_bottleneck, [1, 1], stride=1, \n      rate=rate*multi_grid[0], scope=\'conv1\')\n    residual = resnet_utils.conv2d_same(residual, depth_bottleneck, 3, stride,\n      rate=rate*multi_grid[1], scope=\'conv2\')\n    residual = slim.conv2d(residual, depth, [1, 1], stride=1, \n      rate=rate*multi_grid[2], activation_fn=None, scope=\'conv3\')\n\n    if use_bounded_activations:\n      # Use clip_by_value to simulate bandpass activation.\n      residual = tf.clip_by_value(residual, -6.0, 6.0)\n      output = tf.nn.relu6(shortcut + residual)\n    else:\n      output = tf.nn.relu(shortcut + residual)\n\n    return slim.utils.collect_named_outputs(outputs_collections,\n                                            sc.name,\n                                            output)\n\'\'\'\n\ndef deeplabv3(inputs,\n              num_classes,\n              depth=50,\n              aspp=True,\n              reuse=None,\n              is_training=True):\n  """"""DeepLabV3\n  Args:\n    inputs: A tensor of size [batch, height, width, channels].\n    depth: The number of layers of the ResNet.\n    aspp: Whether to use ASPP module, if True, will use 4 blocks with \n      multi_grid=(1,2,4), if False, will use 7 blocks with multi_grid=(1,2,1).\n    reuse: Whether or not the network and its variables should be reused. To be\n      able to reuse \'scope\' must be given.\n  Returns:\n    net: A rank-4 tensor of size [batch, height_out, width_out, channels_out].\n    end_points: A dictionary from components of the network to the \n      corresponding activation.\n  """"""\n  if aspp:\n    multi_grid = (1,2,4)\n  else:\n    multi_grid = (1,2,1)\n  scope =\'resnet_v1_{}\'.format(depth)\n  with tf.variable_scope(scope, [inputs], reuse=reuse) as sc:\n    end_points_collection = sc.name + \'_end_points\'\n    with slim.arg_scope(resnet_arg_scope(weight_decay=args.weight_decay, \n      batch_norm_decay=args.bn_weight_decay)):\n      with slim.arg_scope([slim.conv2d, bottleneck],\n                          outputs_collections=end_points_collection):\n        with slim.arg_scope([slim.batch_norm], is_training=is_training):\n          net = inputs\n          net = resnet_utils.conv2d_same(net, 64, 7, stride=2, scope=\'conv1\')\n          net = slim.max_pool2d(net, [3, 3], stride=2, scope=\'pool1\')\n\n          with tf.variable_scope(\'block1\', [net]) as sc:\n            base_depth = 64\n            for i in range(2):\n              with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n                net = bottleneck(net, depth=base_depth * 4, \n                  depth_bottleneck=base_depth, stride=1)\n            with tf.variable_scope(\'unit_3\', values=[net]):\n              net = bottleneck(net, depth=base_depth * 4, \n                depth_bottleneck=base_depth, stride=2)\n            net = slim.utils.collect_named_outputs(end_points_collection, \n              sc.name, net)\n\n          with tf.variable_scope(\'block2\', [net]) as sc:\n            base_depth = 128\n            for i in range(3):\n              with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n                net = bottleneck(net, depth=base_depth * 4, \n                  depth_bottleneck=base_depth, stride=1)\n            with tf.variable_scope(\'unit_4\', values=[net]):\n              net = bottleneck(net, depth=base_depth * 4, \n                depth_bottleneck=base_depth, stride=2)\n            net = slim.utils.collect_named_outputs(end_points_collection, \n              sc.name, net)\n\n          with tf.variable_scope(\'block3\', [net]) as sc:\n            base_depth = 256\n\n            num_units = 6\n            if depth == 101:\n              num_units = 23\n            elif depth == 152:\n              num_units = 36\n\n            for i in range(num_units):\n              with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n                net = bottleneck(net, depth=base_depth * 4, \n                  depth_bottleneck=base_depth, stride=1)\n            net = slim.utils.collect_named_outputs(end_points_collection, \n              sc.name, net)\n\n          with tf.variable_scope(\'block4\', [net]) as sc:\n            base_depth = 512\n\n            for i in range(3):\n              with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n                net = bottleneck(net, depth=base_depth * 4, \n                  depth_bottleneck=base_depth, stride=1, rate=2*multi_grid[i])\n            net = slim.utils.collect_named_outputs(end_points_collection, \n              sc.name, net)\n\n          if aspp:\n            with tf.variable_scope(\'aspp\', [net]) as sc:\n              aspp_list = []\n              branch_1 = slim.conv2d(net, 256, [1,1], stride=1, \n                scope=\'1x1conv\')\n              branch_1 = slim.utils.collect_named_outputs(\n                end_points_collection, sc.name, branch_1)\n              aspp_list.append(branch_1)\n\n              for i in range(3):\n                branch_2 = slim.conv2d(net, 256, [3,3], stride=1, rate=6*(i+1), scope=\'rate{}\'.format(6*(i+1)))\n                branch_2 = slim.utils.collect_named_outputs(end_points_collection, sc.name, branch_2)\n                aspp_list.append(branch_2)\n\n              # aspp = tf.add_n(aspp_list)\n              # aspp = slim.utils.collect_named_outputs(end_points_collection, sc.name, aspp)\n\n            with tf.variable_scope(\'img_pool\', [net]) as sc:\n              """"""Image Pooling\n              See ParseNet: Looking Wider to See Better\n              """"""\n              pooled = tf.reduce_mean(net, [1, 2], name=\'avg_pool\', \n                keep_dims=True)\n              pooled = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, pooled)\n\n              pooled = slim.conv2d(pooled, 256, [1,1], stride=1, scope=\'1x1conv\')\n              pooled = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, pooled)\n\n              pooled = tf.image.resize_bilinear(pooled, tf.shape(net)[1:3])\n              pooled = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, pooled)\n\n            with tf.variable_scope(\'fusion\', [aspp_list, pooled]) as sc:\n              aspp_list.append(pooled)\n              net = tf.concat(aspp_list, 3)\n              net = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, net)\n\n              net = slim.conv2d(net, 256, [1,1], stride=1, scope=\'1x1conv\')\n              net = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, net)\n          else:\n            with tf.variable_scope(\'block5\', [net]) as sc:\n              base_depth = 512\n\n              for i in range(3):\n                with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n                  net = bottleneck(net, depth=base_depth * 4, \n                    depth_bottleneck=base_depth, stride=1, rate=4*multi_grid[i])\n              net = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, net)\n\n            with tf.variable_scope(\'block6\', [net]) as sc:\n              base_depth = 512\n\n              for i in range(3):\n                with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n                  net = bottleneck(net, depth=base_depth * 4, \n                    depth_bottleneck=base_depth, stride=1, rate=8*multi_grid[i])\n              net = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, net)\n\n            with tf.variable_scope(\'block7\', [net]) as sc:\n              base_depth = 512\n\n              for i in range(3):\n                with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n                  net = bottleneck(net, depth=base_depth * 4, \n                    depth_bottleneck=base_depth, stride=1, rate=16*multi_grid[i])\n              net = slim.utils.collect_named_outputs(end_points_collection, \n                sc.name, net)\n          \n          with tf.variable_scope(\'logits\',[net]) as sc:\n            net = slim.conv2d(net, num_classes, [1,1], stride=1, \n              activation_fn=None, normalizer_fn=None)\n            net = slim.utils.collect_named_outputs(end_points_collection, \n            sc.name, net)\n\n          end_points = slim.utils.convert_collection_to_dict(\n              end_points_collection)\n\n          return net, end_points\n\nif __name__ == ""__main__"":\n  x = tf.placeholder(tf.float32, [None, 512, 512, 3])\n\n  net, end_points = deeplabv3(x, 21)\n  for i in end_points:\n    print(i, end_points[i])\n'"
libs/nets/resnet_utils.py,6,"b'# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n""""""Contains building blocks for various versions of Residual Networks.\n\nResidual networks (ResNets) were proposed in:\n  Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun\n  Deep Residual Learning for Image Recognition. arXiv:1512.03385, 2015\n\nMore variants were introduced in:\n  Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun\n  Identity Mappings in Deep Residual Networks. arXiv: 1603.05027, 2016\n\nWe can obtain different ResNet variants by changing the network depth, width,\nand form of residual unit. This module implements the infrastructure for\nbuilding them. Concrete ResNet units and full ResNet networks are implemented in\nthe accompanying resnet_v1.py and resnet_v2.py modules.\n\nCompared to https://github.com/KaimingHe/deep-residual-networks, in the current\nimplementation we subsample the output activations in the last residual unit of\neach block, instead of subsampling the input activations in the first residual\nunit of each block. The two implementations give identical results but our\nimplementation is more memory efficient.\n""""""\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport tensorflow as tf\n\nslim = tf.contrib.slim\n\n\nclass Block(collections.namedtuple(\'Block\', [\'scope\', \'unit_fn\', \'args\'])):\n  """"""A named tuple describing a ResNet block.\n\n  Its parts are:\n    scope: The scope of the `Block`.\n    unit_fn: The ResNet unit function which takes as input a `Tensor` and\n      returns another `Tensor` with the output of the ResNet unit.\n    args: A list of length equal to the number of units in the `Block`. The list\n      contains one (depth, depth_bottleneck, stride) tuple for each unit in the\n      block to serve as argument to unit_fn.\n  """"""\n\n\ndef subsample(inputs, factor, scope=None):\n  """"""Subsamples the input along the spatial dimensions.\n\n  Args:\n    inputs: A `Tensor` of size [batch, height_in, width_in, channels].\n    factor: The subsampling factor.\n    scope: Optional variable_scope.\n\n  Returns:\n    output: A `Tensor` of size [batch, height_out, width_out, channels] with the\n      input, either intact (if factor == 1) or subsampled (if factor > 1).\n  """"""\n  if factor == 1:\n    return inputs\n  else:\n    return slim.max_pool2d(inputs, [1, 1], stride=factor, scope=scope)\n\n\ndef conv2d_same(inputs, num_outputs, kernel_size, stride, rate=1, scope=None):\n  """"""Strided 2-D convolution with \'SAME\' padding.\n\n  When stride > 1, then we do explicit zero-padding, followed by conv2d with\n  \'VALID\' padding.\n\n  Note that\n\n     net = conv2d_same(inputs, num_outputs, 3, stride=stride)\n\n  is equivalent to\n\n     net = slim.conv2d(inputs, num_outputs, 3, stride=1, padding=\'SAME\')\n     net = subsample(net, factor=stride)\n\n  whereas\n\n     net = slim.conv2d(inputs, num_outputs, 3, stride=stride, padding=\'SAME\')\n\n  is different when the input\'s height or width is even, which is why we add the\n  current function. For more details, see ResnetUtilsTest.testConv2DSameEven().\n\n  Args:\n    inputs: A 4-D tensor of size [batch, height_in, width_in, channels].\n    num_outputs: An integer, the number of output filters.\n    kernel_size: An int with the kernel_size of the filters.\n    stride: An integer, the output stride.\n    rate: An integer, rate for atrous convolution.\n    scope: Scope.\n\n  Returns:\n    output: A 4-D tensor of size [batch, height_out, width_out, channels] with\n      the convolution output.\n  """"""\n  if stride == 1:\n    return slim.conv2d(inputs, num_outputs, kernel_size, stride=1, rate=rate,\n                       padding=\'SAME\', scope=scope)\n  else:\n    kernel_size_effective = kernel_size + (kernel_size - 1) * (rate - 1)\n    pad_total = kernel_size_effective - 1\n    pad_beg = pad_total // 2\n    pad_end = pad_total - pad_beg\n    inputs = tf.pad(inputs,\n                    [[0, 0], [pad_beg, pad_end], [pad_beg, pad_end], [0, 0]])\n    return slim.conv2d(inputs, num_outputs, kernel_size, stride=stride,\n                       rate=rate, padding=\'VALID\', scope=scope)\n\n\n@slim.add_arg_scope\ndef stack_blocks_dense(net, blocks, output_stride=None,\n                       outputs_collections=None):\n  """"""Stacks ResNet `Blocks` and controls output feature density.\n\n  First, this function creates scopes for the ResNet in the form of\n  \'block_name/unit_1\', \'block_name/unit_2\', etc.\n\n  Second, this function allows the user to explicitly control the ResNet\n  output_stride, which is the ratio of the input to output spatial resolution.\n  This is useful for dense prediction tasks such as semantic segmentation or\n  object detection.\n\n  Most ResNets consist of 4 ResNet blocks and subsample the activations by a\n  factor of 2 when transitioning between consecutive ResNet blocks. This results\n  to a nominal ResNet output_stride equal to 8. If we set the output_stride to\n  half the nominal network stride (e.g., output_stride=4), then we compute\n  responses twice.\n\n  Control of the output feature density is implemented by atrous convolution.\n\n  Args:\n    net: A `Tensor` of size [batch, height, width, channels].\n    blocks: A list of length equal to the number of ResNet `Blocks`. Each\n      element is a ResNet `Block` object describing the units in the `Block`.\n    output_stride: If `None`, then the output will be computed at the nominal\n      network stride. If output_stride is not `None`, it specifies the requested\n      ratio of input to output spatial resolution, which needs to be equal to\n      the product of unit strides from the start up to some level of the ResNet.\n      For example, if the ResNet employs units with strides 1, 2, 1, 3, 4, 1,\n      then valid values for the output_stride are 1, 2, 6, 24 or None (which\n      is equivalent to output_stride=24).\n    outputs_collections: Collection to add the ResNet block outputs.\n\n  Returns:\n    net: Output tensor with stride equal to the specified output_stride.\n\n  Raises:\n    ValueError: If the target output_stride is not valid.\n  """"""\n  # The current_stride variable keeps track of the effective stride of the\n  # activations. This allows us to invoke atrous convolution whenever applying\n  # the next residual unit would result in the activations having stride larger\n  # than the target output_stride.\n  current_stride = 1\n\n  # The atrous convolution rate parameter.\n  rate = 1\n\n  for block in blocks:\n    with tf.variable_scope(block.scope, \'block\', [net]) as sc:\n      for i, unit in enumerate(block.args):\n        if output_stride is not None and current_stride > output_stride:\n          raise ValueError(\'The target output_stride cannot be reached.\')\n\n        with tf.variable_scope(\'unit_%d\' % (i + 1), values=[net]):\n          # If we have reached the target output_stride, then we need to employ\n          # atrous convolution with stride=1 and multiply the atrous rate by the\n          # current unit\'s stride for use in subsequent layers.\n          if output_stride is not None and current_stride == output_stride:\n            net = block.unit_fn(net, rate=rate, **dict(unit, stride=1))\n            rate *= unit.get(\'stride\', 1)\n\n          else:\n            net = block.unit_fn(net, rate=1, **unit)\n            current_stride *= unit.get(\'stride\', 1)\n      net = slim.utils.collect_named_outputs(outputs_collections, sc.name, net)\n\n  if output_stride is not None and current_stride != output_stride:\n    raise ValueError(\'The target output_stride cannot be reached.\')\n\n  return net\n\n\ndef resnet_arg_scope(weight_decay=0.0001,\n                     batch_norm_decay=0.9997,\n                     batch_norm_epsilon=1e-5,\n                     batch_norm_scale=True,\n                     activation_fn=tf.nn.relu,\n                     use_batch_norm=True):\n  """"""Defines the default ResNet arg scope.\n\n  TODO(gpapan): The batch-normalization related default values above are\n    appropriate for use in conjunction with the reference ResNet models\n    released at https://github.com/KaimingHe/deep-residual-networks. When\n    training ResNets from scratch, they might need to be tuned.\n\n  Args:\n    weight_decay: The weight decay to use for regularizing the model.\n    batch_norm_decay: The moving average decay when estimating layer activation\n      statistics in batch normalization.\n    batch_norm_epsilon: Small constant to prevent division by zero when\n      normalizing activations by their variance in batch normalization.\n    batch_norm_scale: If True, uses an explicit `gamma` multiplier to scale the\n      activations in the batch normalization layer.\n    activation_fn: The activation function which is used in ResNet.\n    use_batch_norm: Whether or not to use batch normalization.\n\n  Returns:\n    An `arg_scope` to use for the resnet models.\n  """"""\n  batch_norm_params = {\n      \'decay\': batch_norm_decay,\n      \'epsilon\': batch_norm_epsilon,\n      \'scale\': batch_norm_scale,\n      \'updates_collections\': tf.GraphKeys.UPDATE_OPS,\n      \'fused\': None,  # Use fused batch norm if possible.\n  }\n\n  with slim.arg_scope(\n      [slim.conv2d],\n      weights_regularizer=slim.l2_regularizer(weight_decay),\n      weights_initializer=slim.variance_scaling_initializer(),\n      activation_fn=activation_fn,\n      normalizer_fn=slim.batch_norm if use_batch_norm else None,\n      normalizer_params=batch_norm_params):\n    with slim.arg_scope([slim.batch_norm], **batch_norm_params):\n      # The following implies padding=\'SAME\' for pool1, which makes feature\n      # alignment easier for dense prediction tasks. This is also used in\n      # https://github.com/facebook/fb.resnet.torch. However the accompanying\n      # code of \'Deep Residual Learning for Image Recognition\' uses\n      # padding=\'VALID\' for pool1. You can switch to that choice by setting\n      # slim.arg_scope([slim.max_pool2d], padding=\'VALID\').\n      with slim.arg_scope([slim.max_pool2d], padding=\'SAME\') as arg_sc:\n        return arg_sc'"
libs/nets/resnet_v1.py,9,"b'# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n""""""Contains definitions for the original form of Residual Networks.\nThe \'v1\' residual networks (ResNets) implemented in this module were proposed\nby:\n[1] Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun\n    Deep Residual Learning for Image Recognition. arXiv:1512.03385\nOther variants were introduced in:\n[2] Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun\n    Identity Mappings in Deep Residual Networks. arXiv: 1603.05027\nThe networks defined in this module utilize the bottleneck building block of\n[1] with projection shortcuts only for increasing depths. They employ batch\nnormalization *after* every weight layer. This is the architecture used by\nMSRA in the Imagenet and MSCOCO 2016 competition models ResNet-101 and\nResNet-152. See [2; Fig. 1a] for a comparison between the current \'v1\'\narchitecture and the alternative \'v2\' architecture of [2] which uses batch\nnormalization *before* every weight layer in the so-called full pre-activation\nunits.\nTypical use:\n   from tensorflow.contrib.slim.nets import resnet_v1\nResNet-101 for image classification into 1000 classes:\n   # inputs has shape [batch, 224, 224, 3]\n   with slim.arg_scope(resnet_v1.resnet_arg_scope()):\n      net, end_points = resnet_v1.resnet_v1_101(inputs, 1000, is_training=False)\nResNet-101 for semantic segmentation into 21 classes:\n   # inputs has shape [batch, 513, 513, 3]\n   with slim.arg_scope(resnet_v1.resnet_arg_scope()):\n      net, end_points = resnet_v1.resnet_v1_101(inputs,\n                                                21,\n                                                is_training=False,\n                                                global_pool=False,\n                                                output_stride=16)\n""""""\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\n\nfrom libs.nets import resnet_utils\n\n\nresnet_arg_scope = resnet_utils.resnet_arg_scope\nslim = tf.contrib.slim\n\n\n@slim.add_arg_scope\ndef bottleneck(inputs,\n               depth,\n               depth_bottleneck,\n               stride,\n               rate=1,\n               outputs_collections=None,\n               scope=None,\n               use_bounded_activations=False):\n  """"""Bottleneck residual unit variant with BN after convolutions.\n  This is the original residual unit proposed in [1]. See Fig. 1(a) of [2] for\n  its definition. Note that we use here the bottleneck variant which has an\n  extra bottleneck layer.\n  When putting together two consecutive ResNet blocks that use this unit, one\n  should use stride = 2 in the last unit of the first block.\n  Args:\n    inputs: A tensor of size [batch, height, width, channels].\n    depth: The depth of the ResNet unit output.\n    depth_bottleneck: The depth of the bottleneck layers.\n    stride: The ResNet unit\'s stride. Determines the amount of downsampling of\n      the units output compared to its input.\n    rate: An integer, rate for atrous convolution.\n    outputs_collections: Collection to add the ResNet unit output.\n    scope: Optional variable_scope.\n    use_bounded_activations: Whether or not to use bounded activations. Bounded\n      activations better lend themselves to quantized inference.\n  Returns:\n    The ResNet unit\'s output.\n  """"""\n  with tf.variable_scope(scope, \'bottleneck_v1\', [inputs]) as sc:\n    depth_in = slim.utils.last_dimension(inputs.get_shape(), min_rank=4)\n    if depth == depth_in:\n      shortcut = resnet_utils.subsample(inputs, stride, \'shortcut\')\n    else:\n      shortcut = slim.conv2d(\n          inputs,\n          depth, [1, 1],\n          stride=stride,\n          activation_fn=tf.nn.relu6 if use_bounded_activations else None,\n          scope=\'shortcut\')\n\n    residual = slim.conv2d(inputs, depth_bottleneck, [1, 1], stride=1,\n                           scope=\'conv1\')\n    residual = resnet_utils.conv2d_same(residual, depth_bottleneck, 3, stride,\n                                        rate=rate, scope=\'conv2\')\n    residual = slim.conv2d(residual, depth, [1, 1], stride=1,\n                           activation_fn=None, scope=\'conv3\')\n\n    if use_bounded_activations:\n      # Use clip_by_value to simulate bandpass activation.\n      residual = tf.clip_by_value(residual, -6.0, 6.0)\n      output = tf.nn.relu6(shortcut + residual)\n    else:\n      output = tf.nn.relu(shortcut + residual)\n\n    return slim.utils.collect_named_outputs(outputs_collections,\n                                            sc.name,\n                                            output)\n\n\ndef resnet_v1(inputs,\n              blocks,\n              num_classes=None,\n              is_training=True,\n              global_pool=True,\n              output_stride=None,\n              include_root_block=True,\n              spatial_squeeze=True,\n              reuse=None,\n              scope=None):\n  """"""Generator for v1 ResNet models.\n  This function generates a family of ResNet v1 models. See the resnet_v1_*()\n  methods for specific model instantiations, obtained by selecting different\n  block instantiations that produce ResNets of various depths.\n  Training for image classification on Imagenet is usually done with [224, 224]\n  inputs, resulting in [7, 7] feature maps at the output of the last ResNet\n  block for the ResNets defined in [1] that have nominal stride equal to 32.\n  However, for dense prediction tasks we advise that one uses inputs with\n  spatial dimensions that are multiples of 32 plus 1, e.g., [321, 321]. In\n  this case the feature maps at the ResNet output will have spatial shape\n  [(height - 1) / output_stride + 1, (width - 1) / output_stride + 1]\n  and corners exactly aligned with the input image corners, which greatly\n  facilitates alignment of the features to the image. Using as input [225, 225]\n  images results in [8, 8] feature maps at the output of the last ResNet block.\n  For dense prediction tasks, the ResNet needs to run in fully-convolutional\n  (FCN) mode and global_pool needs to be set to False. The ResNets in [1, 2] all\n  have nominal stride equal to 32 and a good choice in FCN mode is to use\n  output_stride=16 in order to increase the density of the computed features at\n  small computational and memory overhead, cf. http://arxiv.org/abs/1606.00915.\n  Args:\n    inputs: A tensor of size [batch, height_in, width_in, channels].\n    blocks: A list of length equal to the number of ResNet blocks. Each element\n      is a resnet_utils.Block object describing the units in the block.\n    num_classes: Number of predicted classes for classification tasks.\n      If 0 or None, we return the features before the logit layer.\n    is_training: whether batch_norm layers are in training mode.\n    global_pool: If True, we perform global average pooling before computing the\n      logits. Set to True for image classification, False for dense prediction.\n    output_stride: If None, then the output will be computed at the nominal\n      network stride. If output_stride is not None, it specifies the requested\n      ratio of input to output spatial resolution.\n    include_root_block: If True, include the initial convolution followed by\n      max-pooling, if False excludes it.\n    spatial_squeeze: if True, logits is of shape [B, C], if false logits is\n        of shape [B, 1, 1, C], where B is batch_size and C is number of classes.\n        To use this parameter, the input images must be smaller than 300x300\n        pixels, in which case the output logit layer does not contain spatial\n        information and can be removed.\n    reuse: whether or not the network and its variables should be reused. To be\n      able to reuse \'scope\' must be given.\n    scope: Optional variable_scope.\n  Returns:\n    net: A rank-4 tensor of size [batch, height_out, width_out, channels_out].\n      If global_pool is False, then height_out and width_out are reduced by a\n      factor of output_stride compared to the respective height_in and width_in,\n      else both height_out and width_out equal one. If num_classes is 0 or None,\n      then net is the output of the last ResNet block, potentially after global\n      average pooling. If num_classes a non-zero integer, net contains the\n      pre-softmax activations.\n    end_points: A dictionary from components of the network to the corresponding\n      activation.\n  Raises:\n    ValueError: If the target output_stride is not valid.\n  """"""\n  with tf.variable_scope(scope, \'resnet_v1\', [inputs], reuse=reuse) as sc:\n    end_points_collection = sc.original_name_scope + \'_end_points\'\n    with slim.arg_scope([slim.conv2d, bottleneck,\n                         resnet_utils.stack_blocks_dense],\n                        outputs_collections=end_points_collection):\n      with slim.arg_scope([slim.batch_norm], is_training=is_training):\n        net = inputs\n        if include_root_block:\n          if output_stride is not None:\n            if output_stride % 4 != 0:\n              raise ValueError(\'The output_stride needs to be a multiple of 4.\')\n            output_stride /= 4\n          net = resnet_utils.conv2d_same(net, 64, 7, stride=2, scope=\'conv1\')\n          net = slim.max_pool2d(net, [3, 3], stride=2, scope=\'pool1\')\n        net = resnet_utils.stack_blocks_dense(net, blocks, output_stride)\n        # Convert end_points_collection into a dictionary of end_points.\n        end_points = slim.utils.convert_collection_to_dict(\n            end_points_collection)\n\n        if global_pool:\n          # Global average pooling.\n          net = tf.reduce_mean(net, [1, 2], name=\'pool5\', keep_dims=True)\n          end_points[\'global_pool\'] = net\n        if num_classes:\n          net = slim.conv2d(net, num_classes, [1, 1], activation_fn=None,\n                            normalizer_fn=None, scope=\'logits\')\n          end_points[sc.name + \'/logits\'] = net\n          if spatial_squeeze:\n            net = tf.squeeze(net, [1, 2], name=\'SpatialSqueeze\')\n            end_points[sc.name + \'/spatial_squeeze\'] = net\n          end_points[\'predictions\'] = slim.softmax(net, scope=\'predictions\')\n        return net, end_points\nresnet_v1.default_image_size = 224\n\n\ndef resnet_v1_block(scope, base_depth, num_units, stride):\n  """"""Helper function for creating a resnet_v1 bottleneck block.\n  Args:\n    scope: The scope of the block.\n    base_depth: The depth of the bottleneck layer for each unit.\n    num_units: The number of units in the block.\n    stride: The stride of the block, implemented as a stride in the last unit.\n      All other units have stride=1.\n  Returns:\n    A resnet_v1 bottleneck block.\n  """"""\n  return resnet_utils.Block(scope, bottleneck, [{\n      \'depth\': base_depth * 4,\n      \'depth_bottleneck\': base_depth,\n      \'stride\': 1\n  }] * (num_units - 1) + [{\n      \'depth\': base_depth * 4,\n      \'depth_bottleneck\': base_depth,\n      \'stride\': stride\n  }])\n\n\ndef resnet_v1_50(inputs,\n                 num_classes=None,\n                 is_training=True,\n                 global_pool=True,\n                 output_stride=None,\n                 spatial_squeeze=True,\n                 reuse=None,\n                 scope=\'resnet_v1_50\'):\n  """"""ResNet-50 model of [1]. See resnet_v1() for arg and return description.""""""\n  blocks = [\n      resnet_v1_block(\'block1\', base_depth=64, num_units=3, stride=2),\n      resnet_v1_block(\'block2\', base_depth=128, num_units=4, stride=2),\n      resnet_v1_block(\'block3\', base_depth=256, num_units=6, stride=2),\n      resnet_v1_block(\'block4\', base_depth=512, num_units=3, stride=1),\n  ]\n  return resnet_v1(inputs, blocks, num_classes, is_training,\n                   global_pool=global_pool, output_stride=output_stride,\n                   include_root_block=True, spatial_squeeze=spatial_squeeze,\n                   reuse=reuse, scope=scope)\nresnet_v1_50.default_image_size = resnet_v1.default_image_size\n\n\ndef resnet_v1_101(inputs,\n                  num_classes=None,\n                  is_training=True,\n                  global_pool=True,\n                  output_stride=None,\n                  spatial_squeeze=True,\n                  reuse=None,\n                  scope=\'resnet_v1_101\'):\n  """"""ResNet-101 model of [1]. See resnet_v1() for arg and return description.""""""\n  blocks = [\n      resnet_v1_block(\'block1\', base_depth=64, num_units=3, stride=2),\n      resnet_v1_block(\'block2\', base_depth=128, num_units=4, stride=2),\n      resnet_v1_block(\'block3\', base_depth=256, num_units=23, stride=2),\n      resnet_v1_block(\'block4\', base_depth=512, num_units=3, stride=1),\n  ]\n  return resnet_v1(inputs, blocks, num_classes, is_training,\n                   global_pool=global_pool, output_stride=output_stride,\n                   include_root_block=True, spatial_squeeze=spatial_squeeze,\n                   reuse=reuse, scope=scope)\nresnet_v1_101.default_image_size = resnet_v1.default_image_size\n\n\ndef resnet_v1_152(inputs,\n                  num_classes=None,\n                  is_training=True,\n                  global_pool=True,\n                  output_stride=None,\n                  spatial_squeeze=True,\n                  reuse=None,\n                  scope=\'resnet_v1_152\'):\n  """"""ResNet-152 model of [1]. See resnet_v1() for arg and return description.""""""\n  blocks = [\n      resnet_v1_block(\'block1\', base_depth=64, num_units=3, stride=2),\n      resnet_v1_block(\'block2\', base_depth=128, num_units=8, stride=2),\n      resnet_v1_block(\'block3\', base_depth=256, num_units=36, stride=2),\n      resnet_v1_block(\'block4\', base_depth=512, num_units=3, stride=1),\n  ]\n  return resnet_v1(inputs, blocks, num_classes, is_training,\n                   global_pool=global_pool, output_stride=output_stride,\n                   include_root_block=True, spatial_squeeze=spatial_squeeze,\n                   reuse=reuse, scope=scope)\nresnet_v1_152.default_image_size = resnet_v1.default_image_size\n\n\ndef resnet_v1_200(inputs,\n                  num_classes=None,\n                  is_training=True,\n                  global_pool=True,\n                  output_stride=None,\n                  spatial_squeeze=True,\n                  reuse=None,\n                  scope=\'resnet_v1_200\'):\n  """"""ResNet-200 model of [2]. See resnet_v1() for arg and return description.""""""\n  blocks = [\n      resnet_v1_block(\'block1\', base_depth=64, num_units=3, stride=2),\n      resnet_v1_block(\'block2\', base_depth=128, num_units=24, stride=2),\n      resnet_v1_block(\'block3\', base_depth=256, num_units=36, stride=2),\n      resnet_v1_block(\'block4\', base_depth=512, num_units=3, stride=1),\n  ]\n  return resnet_v1(inputs, blocks, num_classes, is_training,\n                   global_pool=global_pool, output_stride=output_stride,\n                   include_root_block=True, spatial_squeeze=spatial_squeeze,\n                   reuse=reuse, scope=scope)\nresnet_v1_200.default_image_size = resnet_v1.default_image_size'"
libs/preprocess/utils.py,17,"b'import os\n\nimport numpy as np\nimport tensorflow as tf\n\ndef random_crop_and_pad_image_and_labels(image, label, crop_h, crop_w, ignore_label=255):\n    """"""\n    Randomly crop and pads the input images.\n\n    Input:\n    image: [1, height, width, 3] uint8\n    gt_mask: [1, height, width, 1] uint8\n\n    Return:\n    image: [height, width, 3] float32\n    gt_mask: [height, width, 1] uint8\n    """"""\n\n    label = tf.cast(label, dtype=tf.float32)\n    label = label - ignore_label # Needs to be subtracted and later added due to 0 padding.\n    combined = tf.concat(axis=3, values=[image, label]) \n    image_shape = tf.shape(image)\n    combined_pad = tf.image.pad_to_bounding_box(combined, 0, 0, tf.maximum(crop_h, image_shape[1]), tf.maximum(crop_w, image_shape[2]))\n    \n    last_image_dim = tf.shape(image)[-1]\n    last_label_dim = tf.shape(label)[-1]\n    combined_pad = tf.squeeze(combined_pad, [0])\n    combined_crop = tf.random_crop(combined_pad, [crop_h,crop_w,4])\n    img_crop = combined_crop[:, :, :last_image_dim]\n    label_crop = combined_crop[:, :, last_image_dim:]\n    label_crop = label_crop + ignore_label\n    label_crop = tf.cast(label_crop, dtype=tf.uint8)\n    \n    # Set static shape so that tensorflow knows shape at compile time. \n    img_crop.set_shape((crop_h, crop_w, 3))\n    label_crop.set_shape((crop_h,crop_w, 1))\n    return img_crop, label_crop\n\ndef flip_image(image):\n    """"""\n    image: [height, width, 3]\n    """"""\n    return tf.reverse(image, axis=[1])\n\ndef rescale(image, gt_mask, h, w, scale):\n    """"""\n    Input:\n    image: [height, width, 3] uint8\n    gt_mask: [height, width, 1] uint8\n\n    Return:\n    image: [1, height, width, 3] float32\n    gt_mask: [1, height, width, 1] uint8\n    """"""\n    image = tf.to_float(image)\n    image = tf.expand_dims(image, 0)\n    gt_mask = tf.expand_dims(gt_mask, 0)\n    nh = tf.to_int32(tf.to_float(h) * scale)\n    nw = tf.to_int32(tf.to_float(w) * scale)\n    new_image = tf.image.resize_bilinear(image, [nh, nw])\n    new_mask = tf.image.resize_nearest_neighbor(gt_mask, [nh, nw])\n    return new_image, new_mask'"
libs/preprocess/voc.py,9,"b'import tensorflow as tf\n\nfrom config import *\nfrom libs.preprocess import utils as preprocess_utils\n\ndef preprocess_image(image, gt_mask, is_training=False):\n    if is_training:\n        return _preprocess_for_training(image, gt_mask)\n    else:\n        return _preprocess_for_test(image, gt_mask)\n\n\ndef _preprocess_for_training(image, gt_mask):\n    \n    ih, iw = tf.shape(image)[0], tf.shape(image)[1]\n\n    ## random flipping\n    coin = tf.to_float(tf.random_uniform([1]))[0]\n    image, gt_mask =\\\n            tf.cond(tf.greater_equal(coin, 0.5), \n                    lambda: (preprocess_utils.flip_image(image),\n                            preprocess_utils.flip_image(gt_mask)),\n                    lambda: (image, gt_mask))\n    \n    scale = tf.random_uniform(shape=[1], minval=0.5, maxval=2)[0]\n    image, gt_mask = preprocess_utils.rescale(image, gt_mask, ih, iw, scale)\n    \n    image, gt_mask = preprocess_utils.random_crop_and_pad_image_and_labels(image, gt_mask, args.input_size, args.input_size)\n\n    # rgb to bgr\n    image = tf.reverse(image, axis=[-1])\n    image -= IMG_MEAN\n\n    return image, gt_mask\n\ndef _preprocess_for_test(image, gt_mask):\n    image = tf.to_float(image)\n    image = tf.reverse(image, axis=[-1])\n    image -= IMG_MEAN\n    image = tf.expand_dims(image, 0)\n    gt_mask = tf.expand_dims(gt_mask, 0)\n    return image, gt_mask'"
libs/datasets/VOC12/__init__.py,0,"b""from libs.datasets.VOC12.image_reader import ImageReader\nfrom libs.datasets.VOC12.utils import decode_labels, inv_preprocess, prepare_label\n\nVOC_CATS = ['__background__', 'aeroplane', 'bicycle', 'bird', 'boat', 'bottle',\n            'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', 'horse',\n            'motorbike', 'person', 'pottedplant', 'sheep', 'sofa', 'train',\n            'tvmonitor']"""
libs/datasets/VOC12/image_reader.py,30,"b'import os\n\nimport numpy as np\nimport tensorflow as tf\n\ndef image_scaling(img, label):\n    """"""\n    Randomly scales the images between 0.5 to 2.0 times the original size.\n\n    Args:\n      img: Training image to scale.\n      label: Segmentation mask to scale.\n    """"""\n    \n    scale = tf.random_uniform([1], minval=0.5, maxval=2.0, dtype=tf.float32, seed=None)\n    h_new = tf.to_int32(tf.multiply(tf.to_float(tf.shape(img)[0]), scale))\n    w_new = tf.to_int32(tf.multiply(tf.to_float(tf.shape(img)[1]), scale))\n    new_shape = tf.squeeze(tf.stack([h_new, w_new]), squeeze_dims=[1])\n    img = tf.image.resize_images(img, new_shape)\n    label = tf.image.resize_nearest_neighbor(tf.expand_dims(label, 0), new_shape)\n    label = tf.squeeze(label, squeeze_dims=[0])\n   \n    return img, label\n\ndef image_mirroring(img, label):\n    """"""\n    Randomly mirrors the images.\n\n    Args:\n      img: Training image to mirror.\n      label: Segmentation mask to mirror.\n    """"""\n    \n    distort_left_right_random = tf.random_uniform([1], 0, 1.0, dtype=tf.float32)[0]\n    mirror = tf.less(tf.stack([1.0, distort_left_right_random, 1.0]), 0.5)\n    mirror = tf.boolean_mask([0, 1, 2], mirror)\n    img = tf.reverse(img, mirror)\n    label = tf.reverse(label, mirror)\n    return img, label\n\ndef random_crop_and_pad_image_and_labels(image, label, crop_h, crop_w, ignore_label=255):\n    """"""\n    Randomly crop and pads the input images.\n\n    Args:\n      image: Training image to crop/ pad.\n      label: Segmentation mask to crop/ pad.\n      crop_h: Height of cropped segment.\n      crop_w: Width of cropped segment.\n      ignore_label: Label to ignore during the training.\n    """"""\n\n    label = tf.cast(label, dtype=tf.float32)\n    label = label - ignore_label # Needs to be subtracted and later added due to 0 padding.\n    combined = tf.concat(axis=2, values=[image, label]) \n    image_shape = tf.shape(image)\n    combined_pad = tf.image.pad_to_bounding_box(combined, 0, 0, tf.maximum(crop_h, image_shape[0]), tf.maximum(crop_w, image_shape[1]))\n    \n    last_image_dim = tf.shape(image)[-1]\n    last_label_dim = tf.shape(label)[-1]\n    combined_crop = tf.random_crop(combined_pad, [crop_h,crop_w,4])\n    img_crop = combined_crop[:, :, :last_image_dim]\n    label_crop = combined_crop[:, :, last_image_dim:]\n    label_crop = label_crop + ignore_label\n    label_crop = tf.cast(label_crop, dtype=tf.uint8)\n    \n    # Set static shape so that tensorflow knows shape at compile time. \n    img_crop.set_shape((crop_h, crop_w, 3))\n    label_crop.set_shape((crop_h,crop_w, 1))\n    return img_crop, label_crop  \n\ndef read_labeled_image_list(data_dir, data_list):\n    """"""Reads txt file containing paths to images and ground truth masks.\n    \n    Args:\n      data_dir: path to the directory with images and masks.\n      data_list: path to the file with lines of the form \'/path/to/image /path/to/mask\'.\n       \n    Returns:\n      Two lists with all file names for images and masks, respectively.\n    """"""\n    f = open(data_list, \'r\')\n    images = []\n    masks = []\n    for line in f:\n        try:\n            image, mask = line.strip(""\\n"").split(\' \')\n        except ValueError: # Adhoc for test.\n            image = mask = line.strip(""\\n"")\n        images.append(data_dir + image)\n        masks.append(data_dir + mask)\n    return images, masks\n\ndef read_images_from_disk(input_queue, input_size, random_scale, random_mirror, ignore_label, img_mean): # optional pre-processing arguments\n    """"""Read one image and its corresponding mask with optional pre-processing.\n    \n    Args:\n      input_queue: tf queue with paths to the image and its mask.\n      input_size: a tuple with (height, width) values.\n                  If not given, return images of original size.\n      random_scale: whether to randomly scale the images prior\n                    to random crop.\n      random_mirror: whether to randomly mirror the images prior\n                    to random crop.\n      ignore_label: index of label to ignore during the training.\n      img_mean: vector of mean colour values.\n      \n    Returns:\n      Two tensors: the decoded image and its mask.\n    """"""\n\n    img_contents = tf.read_file(input_queue[0])\n    label_contents = tf.read_file(input_queue[1])\n    \n    img = tf.image.decode_jpeg(img_contents, channels=3)\n    img_r, img_g, img_b = tf.split(axis=2, num_or_size_splits=3, value=img)\n    img = tf.cast(tf.concat(axis=2, values=[img_b, img_g, img_r]), dtype=tf.float32)\n    # Extract mean.\n    img -= img_mean\n\n    label = tf.image.decode_png(label_contents, channels=1)\n\n    if input_size is not None:\n        h, w = input_size\n\n        # Randomly scale the images and labels.\n        if random_scale:\n            img, label = image_scaling(img, label)\n\n        # Randomly mirror the images and labels.\n        if random_mirror:\n            img, label = image_mirroring(img, label)\n\n        # Randomly crops the images and labels.\n        img, label = random_crop_and_pad_image_and_labels(img, label, h, w, ignore_label)\n\n    return img, label\n\nclass ImageReader(object):\n    \'\'\'Generic ImageReader which reads images and corresponding segmentation\n       masks from the disk, and enqueues them into a TensorFlow queue.\n    \'\'\'\n\n    def __init__(self, data_dir, data_list, input_size, \n                 random_scale, random_mirror, ignore_label, img_mean, coord):\n        \'\'\'Initialise an ImageReader.\n        \n        Args:\n          data_dir: path to the directory with images and masks.\n          data_list: path to the file with lines of the form \'/path/to/image /path/to/mask\'.\n          input_size: a tuple with (height, width) values, to which all the images will be resized.\n          random_scale: whether to randomly scale the images prior to random crop.\n          random_mirror: whether to randomly mirror the images prior to random crop.\n          ignore_label: index of label to ignore during the training.\n          img_mean: vector of mean colour values.\n          coord: TensorFlow queue coordinator.\n        \'\'\'\n        self.data_dir = data_dir\n        self.data_list = data_list\n        self.input_size = input_size\n        self.coord = coord\n        \n        self.image_list, self.label_list = read_labeled_image_list(self.data_dir, self.data_list)\n        self.images = tf.convert_to_tensor(self.image_list, dtype=tf.string)\n        self.labels = tf.convert_to_tensor(self.label_list, dtype=tf.string)\n        self.queue = tf.train.slice_input_producer([self.images, self.labels],\n                                                   shuffle=False) # not shuffling if it is val\n        self.image, self.label = read_images_from_disk(self.queue, self.input_size, random_scale, random_mirror, ignore_label, img_mean) \n\n    def dequeue(self, num_elements):\n        \'\'\'Pack images and labels into a batch.\n        \n        Args:\n          num_elements: the batch size.\n          \n        Returns:\n          Two tensors of size (batch_size, h, w, {3, 1}) for images and masks.\'\'\'\n        image_batch, label_batch = tf.train.shuffle_batch([self.image, self.label], num_elements, 2048, 64, num_threads=4)\n        return image_batch, label_batch\n'"
libs/datasets/VOC12/utils.py,4,"b'import numpy as np\nimport tensorflow as tf\n\nfrom PIL import Image\n\n# colour map\nlabel_colours = [(0,0,0)\n                # 0=background\n                ,(128,0,0),(0,128,0),(128,128,0),(0,0,128),(128,0,128)\n                # 1=aeroplane, 2=bicycle, 3=bird, 4=boat, 5=bottle\n                ,(0,128,128),(128,128,128),(64,0,0),(192,0,0),(64,128,0)\n                # 6=bus, 7=car, 8=cat, 9=chair, 10=cow\n                ,(192,128,0),(64,0,128),(192,0,128),(64,128,128),(192,128,128)\n                # 11=diningtable, 12=dog, 13=horse, 14=motorbike, 15=person\n                ,(0,64,0),(128,64,0),(0,192,0),(128,192,0),(0,64,128)]\n                # 16=potted plant, 17=sheep, 18=sofa, 19=train, 20=tv/monitor\n\ndef decode_labels(mask, num_images=1, num_classes=21):\n    """"""Decode batch of segmentation masks.\n    \n    Args:\n      mask: result of inference after taking argmax.\n      num_images: number of images to decode from the batch.\n      num_classes: number of classes to predict (including background).\n    \n    Returns:\n      A batch with num_images RGB images of the same size as the input. \n    """"""\n    n, h, w, c = mask.shape\n    assert(n >= num_images), \'Batch size %d should be greater or equal than number of images to save %d.\' % (n, num_images)\n    outputs = np.zeros((num_images, h, w, 3), dtype=np.uint8)\n    for i in range(num_images):\n      img = Image.new(\'RGB\', (len(mask[i, 0]), len(mask[i])))\n      pixels = img.load()\n      for j_, j in enumerate(mask[i, :, :, 0]):\n          for k_, k in enumerate(j):\n              if k < num_classes:\n                  pixels[k_,j_] = label_colours[k]\n      outputs[i] = np.array(img)\n    return outputs\n\ndef prepare_label(input_batch, new_size, num_classes, one_hot=True):\n    """"""Resize masks and perform one-hot encoding.\n\n    Args:\n      input_batch: input tensor of shape [batch_size H W 1].\n      new_size: a tensor with new height and width.\n      num_classes: number of classes to predict (including background).\n      one_hot: whether perform one-hot encoding.\n\n    Returns:\n      Outputs a tensor of shape [batch_size h w 21]\n      with last dimension comprised of 0\'s and 1\'s only.\n    """"""\n    with tf.name_scope(\'label_encode\'):\n        input_batch = tf.image.resize_nearest_neighbor(input_batch, new_size) # as labels are integer numbers, need to use NN interp.\n        input_batch = tf.squeeze(input_batch, squeeze_dims=[3]) # reducing the channel dimension.\n        if one_hot:\n            input_batch = tf.one_hot(input_batch, depth=num_classes)\n    return input_batch\n\ndef inv_preprocess(imgs, num_images, img_mean):\n    """"""Inverse preprocessing of the batch of images.\n       Add the mean vector and convert from BGR to RGB.\n       \n    Args:\n      imgs: batch of input images.\n      num_images: number of images to apply the inverse transformations on.\n      img_mean: vector of mean colour values.\n  \n    Returns:\n      The batch of the size num_images with the same spatial dimensions as the input.\n    """"""\n    n, h, w, c = imgs.shape\n    assert(n >= num_images), \'Batch size %d should be greater or equal than number of images to save %d.\' % (n, num_images)\n    outputs = np.zeros((num_images, h, w, c), dtype=np.uint8)\n    for i in range(num_images):\n        outputs[i] = (imgs[i] + img_mean)[:, :, ::-1].astype(np.uint8)\n    return outputs'"
