file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\r\nimport os\r\nimport io\r\nimport re\r\nfrom setuptools import setup\r\nfrom setuptools.command.install import install\r\nfrom setuptools.command.develop import develop\r\n\r\n\r\ndef read(*names, **kwargs):\r\n    with io.open(\r\n        os.path.join(os.path.dirname(__file__), *names),\r\n        encoding=kwargs.get(""encoding"", ""utf8"")\r\n    ) as fp:\r\n        return fp.read()\r\n\r\n\r\ndef find_version(*file_paths):\r\n    version_file = read(*file_paths)\r\n    version_match = re.search(r""^__version__ = [\'\\""]([^\'\\""]*)[\'\\""]"",\r\n                              version_file, re.M)\r\n    if version_match:\r\n        return version_match.group(1)\r\n    raise RuntimeError(""Unable to find version string."")\r\n\r\n\r\ndef enable_extension_after_install():\r\n    from jupyter_tensorboard.application import (\r\n        EnableJupyterTensorboardApp,\r\n    )\r\n    EnableJupyterTensorboardApp.launch_instance(argv=[])\r\n\r\n\r\nclass EnableExtensionDevelop(develop):\r\n\r\n    def run(self):\r\n        develop.run(self)\r\n        enable_extension_after_install()\r\n\r\n\r\nclass EnableExtensionInstall(install):\r\n\r\n    def run(self):\r\n        install.run(self)\r\n        enable_extension_after_install()\r\n\r\n\r\nname = \'jupyter_tensorboard\'\r\n\r\nsetup(\r\n    name=name,\r\n    version=find_version(name, \'__init__.py\'),\r\n    author=\'lspvic\',\r\n    author_email=\'lspvic@qq.com\',\r\n    url=\'http://github.com/lspvic/jupyter_tensorboard\',\r\n    license=\'MIT License\',\r\n    description=(\r\n        \'Start tensorboard in Jupyter! \'\r\n        \'Jupyter notebook integration for tensorboard.\'),\r\n    long_description=read(""README.rst""),\r\n    keywords=[\'Jupyter\', \'Notebook\', \'Tensorboard\', \'Tensorflow\', ],\r\n    packages=[name],\r\n    package_data={name: [""static/*""]},\r\n    platforms=""Linux, Mac OS X, Windows"",\r\n    entry_points={\r\n        \'console_scripts\': [\r\n            \'jupyter-tensorboard = jupyter_tensorboard.application:main\',\r\n         ],\r\n    },\r\n    scripts=[os.path.join(\'scripts\', p) for p in [\r\n        \'jupyter-tensorboard\',\r\n    ]],\r\n    install_requires=[\r\n        \'notebook>=5.0\',\r\n    ],\r\n    classifiers=[\r\n        \'Intended Audience :: Developers\',\r\n        \'Intended Audience :: Science/Research\',\r\n        \'License :: OSI Approved :: MIT License\',\r\n        \'Programming Language :: Python\',\r\n        \'Programming Language :: Python :: 3\',\r\n        \'Programming Language :: Python :: 3.4\',\r\n        \'Programming Language :: Python :: 3.5\',\r\n        \'Programming Language :: Python :: 3.6\',\r\n    ],\r\n    cmdclass={\r\n        \'install\': EnableExtensionInstall,\r\n        \'develop\': EnableExtensionDevelop,\r\n    },\r\n)\r\n'"
jupyter_tensorboard/__init__.py,0,"b'# -*- coding: utf-8 -*-\r\n\r\nfrom .handlers import load_jupyter_server_extension   # noqa\r\n\r\n__version__ = ""0.2.0""\r\n\r\n\r\ndef _jupyter_nbextension_paths():\r\n    name = __name__\r\n    section = ""tree""\r\n    src = ""static""\r\n    return [dict(\r\n        section=section,\r\n        src=src,\r\n        dest=name,\r\n        require=""%s/%s"" % (name, section))]\r\n\r\n\r\ndef _jupyter_server_extension_paths():\r\n    return [{\r\n        ""module"": __name__\r\n    }]\r\n'"
jupyter_tensorboard/api_handlers.py,0,"b'# -*- coding: utf-8 -*-\r\n\r\nimport json\r\nimport os\r\n\r\nfrom tornado import web\r\nfrom notebook.base.handlers import APIHandler\r\n\r\nfrom .handlers import notebook_dir\r\n\r\n\r\ndef _trim_notebook_dir(dir):\r\n    if not dir.startswith(""/""):\r\n        return os.path.join(\r\n            ""<notebook_dir>"", os.path.relpath(dir, notebook_dir)\r\n        )\r\n    return dir\r\n\r\n\r\nclass TbRootHandler(APIHandler):\r\n\r\n    @web.authenticated\r\n    def get(self):\r\n        terms = [\r\n            {\r\n                \'name\': entry.name,\r\n                \'logdir\': _trim_notebook_dir(entry.logdir),\r\n                ""reload_time"": entry.thread.reload_time,\r\n            } for entry in\r\n            self.settings[""tensorboard_manager""].values()\r\n        ]\r\n        self.finish(json.dumps(terms))\r\n\r\n    @web.authenticated\r\n    def post(self):\r\n        data = self.get_json_body()\r\n        reload_interval = data.get(""reload_interval"", None)\r\n        entry = (\r\n            self.settings[""tensorboard_manager""]\r\n            .new_instance(data[""logdir""], reload_interval=reload_interval)\r\n        )\r\n        self.finish(json.dumps({\r\n                \'name\': entry.name,\r\n                \'logdir\':  _trim_notebook_dir(entry.logdir),\r\n                \'reload_time\': entry.thread.reload_time}))\r\n\r\n\r\nclass TbInstanceHandler(APIHandler):\r\n\r\n    SUPPORTED_METHODS = (\'GET\', \'DELETE\')\r\n\r\n    @web.authenticated\r\n    def get(self, name):\r\n        manager = self.settings[""tensorboard_manager""]\r\n        if name in manager:\r\n            entry = manager[name]\r\n            self.finish(json.dumps({\r\n                \'name\': entry.name,\r\n                \'logdir\':  _trim_notebook_dir(entry.logdir),\r\n                \'reload_time\': entry.thread.reload_time}))\r\n        else:\r\n            raise web.HTTPError(\r\n                404, ""TensorBoard instance not found: %r"" % name)\r\n\r\n    @web.authenticated\r\n    def delete(self, name):\r\n        manager = self.settings[""tensorboard_manager""]\r\n        if name in manager:\r\n            manager.terminate(name, force=True)\r\n            self.set_status(204)\r\n            self.finish()\r\n        else:\r\n            raise web.HTTPError(\r\n                404, ""TensorBoard instance not found: %r"" % name)\r\n'"
jupyter_tensorboard/application.py,0,"b'# -*- coding: utf-8 -*-\r\n\r\nimport copy\r\nimport sys\r\n\r\nfrom notebook import nbextensions, serverextensions, extensions\r\n\r\nfrom . import __version__, __name__ as _pkg_name\r\n\r\n\r\nclass ToggleJupyterTensorboardApp(\r\n        nbextensions.ToggleNBExtensionApp,\r\n        serverextensions.ToggleServerExtensionApp):\r\n    """"""App to toggle server extension jupyter_nbextensions_configurator.""""""\r\n\r\n    flags = copy.deepcopy(serverextensions.ToggleServerExtensionApp.flags)\r\n    flags[\'sys-prefix\'] = ({\r\n        \'ToggleServerExtensionApp\': {\r\n            \'sys_prefix\': True,\r\n            \'user\': False,\r\n        }},\r\n        \'Use sys.prefix as the prefix for configuring extension\')\r\n    for f in (\'py\', \'python\'):\r\n        flags.pop(f, None)\r\n\r\n    def parse_command_line(self, argv=None):\r\n        """"""\r\n        Overriden to check for conflicting flags\r\n        Since notebook version doesn\'t do it well (or, indeed, at all)\r\n        """"""\r\n        conflicting_flags = set([\'--user\', \'--system\', \'--sys-prefix\'])\r\n\r\n        if len(conflicting_flags.intersection(set(argv))) > 1:\r\n            raise serverextensions.ArgumentConflict(\r\n                \'cannot specify more than one of user, sys_prefix, or system\')\r\n        return super(ToggleJupyterTensorboardApp,\r\n                     self).parse_command_line(argv)\r\n\r\n    @property\r\n    def name(self):\r\n        return \'jupyter_tensorboard {}\'.format(\r\n            \'enable\' if self._toggle_value else \'disable\')\r\n\r\n    @property\r\n    def description(self):\r\n        return """"""\r\n{} the jupyter_tensorboard extension in config.\r\nUsage\r\n    jupyter tensorboard {} [--system|--sys-prefix|--user]\r\n"""""".format(*((\'Enable\', \'enable\')\r\n             if self._toggle_value else (\'Disable\', \'disable\')))\r\n\r\n    def start(self):\r\n        """"""Perform the App\'s actions as configured.""""""\r\n        if self.extra_args:\r\n            sys.exit(\'{} takes no extra arguments\'.format(self.name))\r\n        else:\r\n\r\n            if self._toggle_value:\r\n                nbextensions.install_nbextension_python(\r\n                    _pkg_name, overwrite=True, symlink=False,\r\n                    user=self.user, sys_prefix=self.sys_prefix, prefix=None,\r\n                    nbextensions_dir=None, logger=None)\r\n            else:\r\n                nbextensions.uninstall_nbextension_python(\r\n                    _pkg_name, user=self.user, sys_prefix=self.sys_prefix,\r\n                    prefix=None, nbextensions_dir=None, logger=None)\r\n\r\n            self.toggle_nbextension_python(_pkg_name)\r\n            self.toggle_server_extension_python(_pkg_name)\r\n\r\n\r\nclass EnableJupyterTensorboardApp(\r\n        ToggleJupyterTensorboardApp):\r\n    """"""App to enable server extension jupyter_nbextensions_configurator.""""""\r\n    name = \'jupyter tensorboard enable\'\r\n    _toggle_value = True\r\n\r\n\r\nclass DisableJupyterTensorboardApp(\r\n        ToggleJupyterTensorboardApp):\r\n    """"""App to disable server extension jupyter_nbextensions_configurator.""""""\r\n    name = \'jupyter tensorboard disable\'\r\n    _toggle_value = False\r\n\r\n\r\nclass JupyterTensorboardApp(extensions.BaseExtensionApp):\r\n    """"""Root level jupyter_nbextensions_configurator app.""""""\r\n\r\n    name = \'jupyter tensorboard\'\r\n    version = __version__\r\n    description = (\r\n        \'Enable or disable \'\r\n        \'the jupyter_tensorboard extension\')\r\n    subcommands = dict(\r\n        enable=(\r\n            EnableJupyterTensorboardApp,\r\n            \'Enable the jupyter_tensorboard extension.\'),\r\n        disable=(\r\n            DisableJupyterTensorboardApp,\r\n            \'Disable the jupyter_tensorboard extension.\'),\r\n    )\r\n    examples = \'\\n\'.join([\r\n        \'jupyter tensorboard enable\'\r\n        \'  # Enable the jupyter_tensorboard extension.\',\r\n        \'jupyter tensorboard disable\'\r\n        \' # Disable the jupyter_tensorboard extension.\',\r\n    ])\r\n\r\n    def start(self):\r\n        """"""Perform the App\'s actions as configured""""""\r\n        super(JupyterTensorboardApp, self).start()\r\n\r\n        # The above should have called a subcommand and raised NoStart; if we\r\n        # get here, it didn\'t, so we should self.log.info a message.\r\n        subcmds = "", "".join(sorted(self.subcommands))\r\n        sys.exit(""Please supply at least one subcommand: %s"" % subcmds)\r\n\r\n\r\nmain = JupyterTensorboardApp.launch_instance\r\n\r\n\r\nif __name__ == \'__main__\':  # pragma: no cover\r\n    main()\r\n'"
jupyter_tensorboard/handlers.py,0,"b'# -*- coding: utf-8 -*-\r\n\r\nfrom tornado import web\r\nfrom tornado.wsgi import WSGIContainer\r\nfrom notebook.base.handlers import IPythonHandler\r\nfrom notebook.utils import url_path_join as ujoin\r\nfrom notebook.base.handlers import path_regex\r\n\r\nnotebook_dir = None\r\n\r\n\r\ndef load_jupyter_server_extension(nb_app):\r\n\r\n    global notebook_dir\r\n    # notebook_dir should be root_dir of contents_manager\r\n    notebook_dir = nb_app.contents_manager.root_dir\r\n\r\n    web_app = nb_app.web_app\r\n    base_url = web_app.settings[\'base_url\']\r\n\r\n    try:\r\n        from .tensorboard_manager import manager\r\n    except ImportError:\r\n        nb_app.log.info(""import tensorboard error, check tensorflow install"")\r\n        handlers = [\r\n            (ujoin(\r\n                base_url, r""/tensorboard.*""),\r\n                TensorboardErrorHandler),\r\n        ]\r\n    else:\r\n        web_app.settings[""tensorboard_manager""] = manager\r\n        from . import api_handlers\r\n\r\n        handlers = [\r\n            (ujoin(\r\n                base_url, r""/tensorboard/(?P<name>\\w+)%s"" % path_regex),\r\n                TensorboardHandler),\r\n            (ujoin(\r\n                base_url, r""/api/tensorboard""),\r\n                api_handlers.TbRootHandler),\r\n            (ujoin(\r\n                base_url, r""/api/tensorboard/(?P<name>\\w+)""),\r\n                api_handlers.TbInstanceHandler),\r\n        ]\r\n\r\n    web_app.add_handlers(\'.*$\', handlers)\r\n    nb_app.log.info(""jupyter_tensorboard extension loaded."")\r\n\r\n\r\nclass TensorboardHandler(IPythonHandler):\r\n\r\n    @web.authenticated\r\n    def get(self, name, path):\r\n\r\n        if path == """":\r\n            uri = self.request.path + ""/""\r\n            if self.request.query:\r\n                uri += ""?"" + self.request.query\r\n            self.redirect(uri, permanent=True)\r\n            return\r\n\r\n        self.request.path = (\r\n            path if self.request.query\r\n            else ""%s?%s"" % (path, self.request.query))\r\n\r\n        manager = self.settings[""tensorboard_manager""]\r\n        if name in manager:\r\n            tb_app = manager[name].tb_app\r\n            WSGIContainer(tb_app)(self.request)\r\n        else:\r\n            raise web.HTTPError(404)\r\n\r\n\r\nclass TensorboardErrorHandler(IPythonHandler):\r\n    pass\r\n'"
jupyter_tensorboard/tensorboard_manager.py,0,"b'# -*- coding: utf-8 -*-\r\n\r\nimport os\r\nimport sys\r\nimport threading\r\nimport time\r\nimport inspect\r\nimport itertools\r\nfrom collections import namedtuple\r\nimport logging\r\n\r\nimport six\r\n\r\nsys.argv = [""tensorboard""]\r\n\r\nfrom tensorboard.backend import application   # noqa\r\n\r\ntry:\r\n    # Tensorboard 0.4.x above series\r\n    from tensorboard import default\r\n\r\n    if not hasattr(application, ""reload_multiplexer""):\r\n        # Tensorflow 1.12 removed reload_multiplexer, patch it\r\n        def reload_multiplexer(multiplexer, path_to_run):\r\n            for path, name in six.iteritems(path_to_run):\r\n                multiplexer.AddRunsFromDirectory(path, name)\r\n            multiplexer.Reload()\r\n        application.reload_multiplexer = reload_multiplexer\r\n\r\n    if hasattr(default, \'PLUGIN_LOADERS\') or hasattr(default, \'_PLUGINS\'):\r\n        # Tensorflow 1.10 or above series\r\n        logging.debug(""Tensorboard 1.10 or above series detected"")\r\n        from tensorboard import program\r\n\r\n        def create_tb_app(logdir, reload_interval, purge_orphaned_data):\r\n            argv = [\r\n                        """",\r\n                        ""--logdir"", logdir,\r\n                        ""--reload_interval"", str(reload_interval),\r\n                        ""--purge_orphaned_data"", str(purge_orphaned_data),\r\n                   ]\r\n            tensorboard = program.TensorBoard()\r\n            tensorboard.configure(argv)\r\n            return application.standard_tensorboard_wsgi(\r\n                tensorboard.flags,\r\n                tensorboard.plugin_loaders,\r\n                tensorboard.assets_zip_provider)\r\n    else:\r\n        logging.debug(""Tensorboard 0.4.x series detected"")\r\n\r\n        def create_tb_app(logdir, reload_interval, purge_orphaned_data):\r\n            return application.standard_tensorboard_wsgi(\r\n                logdir=logdir, reload_interval=reload_interval,\r\n                purge_orphaned_data=purge_orphaned_data,\r\n                plugins=default.get_plugins())\r\n\r\nexcept ImportError:\r\n    # Tensorboard 0.3.x series\r\n    from tensorboard.plugins.audio import audio_plugin\r\n    from tensorboard.plugins.core import core_plugin\r\n    from tensorboard.plugins.distribution import distributions_plugin\r\n    from tensorboard.plugins.graph import graphs_plugin\r\n    from tensorboard.plugins.histogram import histograms_plugin\r\n    from tensorboard.plugins.image import images_plugin\r\n    from tensorboard.plugins.profile import profile_plugin\r\n    from tensorboard.plugins.projector import projector_plugin\r\n    from tensorboard.plugins.scalar import scalars_plugin\r\n    from tensorboard.plugins.text import text_plugin\r\n    logging.debug(""Tensorboard 0.3.x series detected"")\r\n\r\n    _plugins = [\r\n                core_plugin.CorePlugin,\r\n                scalars_plugin.ScalarsPlugin,\r\n                images_plugin.ImagesPlugin,\r\n                audio_plugin.AudioPlugin,\r\n                graphs_plugin.GraphsPlugin,\r\n                distributions_plugin.DistributionsPlugin,\r\n                histograms_plugin.HistogramsPlugin,\r\n                projector_plugin.ProjectorPlugin,\r\n                text_plugin.TextPlugin,\r\n                profile_plugin.ProfilePlugin,\r\n            ]\r\n\r\n    def create_tb_app(logdir, reload_interval, purge_orphaned_data):\r\n        return application.standard_tensorboard_wsgi(\r\n            logdir=logdir, reload_interval=reload_interval,\r\n            purge_orphaned_data=purge_orphaned_data,\r\n            plugins=_plugins)\r\n\r\n\r\nfrom .handlers import notebook_dir   # noqa\r\n\r\nTensorBoardInstance = namedtuple(\r\n    \'TensorBoardInstance\', [\'name\', \'logdir\', \'tb_app\', \'thread\'])\r\n\r\n\r\ndef start_reloading_multiplexer(multiplexer, path_to_run, reload_interval):\r\n    def _ReloadForever():\r\n        current_thread = threading.currentThread()\r\n        while not current_thread.stop:\r\n            application.reload_multiplexer(multiplexer, path_to_run)\r\n            current_thread.reload_time = time.time()\r\n            time.sleep(reload_interval)\r\n    thread = threading.Thread(target=_ReloadForever)\r\n    thread.reload_time = None\r\n    thread.stop = False\r\n    thread.daemon = True\r\n    thread.start()\r\n    return thread\r\n\r\n\r\ndef is_tensorboard_greater_than_or_equal_to20():\r\n    # tensorflow<1.4 will be\r\n    # (logdir, plugins, multiplexer, reload_interval)\r\n\r\n    # tensorflow>=1.4, <1.12 will be\r\n    # (logdir, plugins, multiplexer, reload_interval, path_prefix)\r\n\r\n    # tensorflow>=1.12, <1.14 will be\r\n    # (logdir, plugins, multiplexer, reload_interval,\r\n    #  path_prefix=\'\', reload_task=\'auto\')\r\n\r\n    # tensorflow 2.0 will be\r\n    # (flags, plugins, data_provider=None, assets_zip_provider=None,\r\n    #  deprecated_multiplexer=None)\r\n\r\n    s = inspect.signature(application.TensorBoardWSGIApp)\r\n    first_parameter_name = list(s.parameters.keys())[0]\r\n    return first_parameter_name == \'flags\'\r\n\r\n\r\ndef TensorBoardWSGIApp_2x(\r\n        flags, plugins,\r\n        data_provider=None,\r\n        assets_zip_provider=None,\r\n        deprecated_multiplexer=None):\r\n\r\n    logdir = flags.logdir\r\n    multiplexer = deprecated_multiplexer\r\n    reload_interval = flags.reload_interval\r\n\r\n    path_to_run = application.parse_event_files_spec(logdir)\r\n    if reload_interval:\r\n        thread = start_reloading_multiplexer(\r\n            multiplexer, path_to_run, reload_interval)\r\n    else:\r\n        application.reload_multiplexer(multiplexer, path_to_run)\r\n        thread = None\r\n\r\n    db_uri = None\r\n    db_connection_provider = None\r\n\r\n    plugin_name_to_instance = {}\r\n\r\n    from tensorboard.plugins import base_plugin\r\n    context = base_plugin.TBContext(\r\n        data_provider=data_provider,\r\n        db_connection_provider=db_connection_provider,\r\n        db_uri=db_uri,\r\n        flags=flags,\r\n        logdir=flags.logdir,\r\n        multiplexer=deprecated_multiplexer,\r\n        assets_zip_provider=assets_zip_provider,\r\n        plugin_name_to_instance=plugin_name_to_instance,\r\n        window_title=flags.window_title)\r\n\r\n    tbplugins = []\r\n    for loader in plugins:\r\n        plugin = loader.load(context)\r\n        if plugin is None:\r\n            continue\r\n        tbplugins.append(plugin)\r\n        plugin_name_to_instance[plugin.plugin_name] = plugin\r\n\r\n    tb_app = application.TensorBoardWSGI(tbplugins)\r\n    manager.add_instance(logdir, tb_app, thread)\r\n    return tb_app\r\n\r\n\r\ndef TensorBoardWSGIApp_1x(\r\n        logdir, plugins, multiplexer,\r\n        reload_interval, path_prefix="""", reload_task=""auto""):\r\n    path_to_run = application.parse_event_files_spec(logdir)\r\n    if reload_interval:\r\n        thread = start_reloading_multiplexer(\r\n            multiplexer, path_to_run, reload_interval)\r\n    else:\r\n        application.reload_multiplexer(multiplexer, path_to_run)\r\n        thread = None\r\n    tb_app = application.TensorBoardWSGI(plugins)\r\n    manager.add_instance(logdir, tb_app, thread)\r\n    return tb_app\r\n\r\n\r\nif is_tensorboard_greater_than_or_equal_to20():\r\n    application.TensorBoardWSGIApp = TensorBoardWSGIApp_2x\r\nelse:\r\n    application.TensorBoardWSGIApp = TensorBoardWSGIApp_1x\r\n\r\n\r\nclass TensorboardManger(dict):\r\n\r\n    def __init__(self):\r\n        self._logdir_dict = {}\r\n\r\n    def _next_available_name(self):\r\n        for n in itertools.count(start=1):\r\n            name = ""%d"" % n\r\n            if name not in self:\r\n                return name\r\n\r\n    def new_instance(self, logdir, reload_interval):\r\n        if not os.path.isabs(logdir) and notebook_dir:\r\n            logdir = os.path.join(notebook_dir, logdir)\r\n\r\n        if logdir not in self._logdir_dict:\r\n            purge_orphaned_data = True\r\n            reload_interval = reload_interval or 30\r\n            create_tb_app(\r\n                logdir=logdir, reload_interval=reload_interval,\r\n                purge_orphaned_data=purge_orphaned_data)\r\n\r\n        return self._logdir_dict[logdir]\r\n\r\n    def add_instance(self, logdir, tb_application, thread):\r\n        name = self._next_available_name()\r\n        instance = TensorBoardInstance(name, logdir, tb_application, thread)\r\n        self[name] = instance\r\n        self._logdir_dict[logdir] = instance\r\n\r\n    def terminate(self, name, force=True):\r\n        if name in self:\r\n            instance = self[name]\r\n            if instance.thread is not None:\r\n                instance.thread.stop = True\r\n            del self[name], self._logdir_dict[instance.logdir]\r\n        else:\r\n            raise Exception(""There\'s no tensorboard instance named %s"" % name)\r\n\r\n\r\nmanager = TensorboardManger()\r\n'"
tests/test_tensorboard_integration.py,12,"b'# -*- coding:utf-8 -*-\n\nimport sys\nimport time\nimport logging\nimport json\n\nimport pytest\nfrom tornado.testing import AsyncHTTPTestCase\n\n\n@pytest.fixture(scope=""session"")\ndef tf_logs(tmpdir_factory):\n\n    import numpy as np\n    try:\n        import tensorflow.compat.v1 as tf\n        tf.disable_v2_behavior()\n    except ImportError:\n        import tensorflow as tf\n\n    x = np.random.rand(5)\n    y = 3 * x + 1 + 0.05 * np.random.rand(5)\n\n    a = tf.Variable(0.1)\n    b = tf.Variable(0.)\n    err = a*x+b-y\n\n    loss = tf.norm(err)\n    tf.summary.scalar(""loss"", loss)\n    tf.summary.scalar(""a"", a)\n    tf.summary.scalar(""b"", b)\n    merged = tf.summary.merge_all()\n\n    optimizor = tf.train.GradientDescentOptimizer(0.01).minimize(loss)\n\n    with tf.Session() as sess:\n        log_dir = tmpdir_factory.mktemp(""logs"", numbered=False)\n        log_dir = str(log_dir)\n\n        train_write = tf.summary.FileWriter(log_dir, sess.graph)\n        tf.global_variables_initializer().run()\n        for i in range(1000):\n            _, merged_ = sess.run([optimizor, merged])\n            train_write.add_summary(merged_, i)\n\n    return log_dir\n\n\n@pytest.fixture(scope=""session"")\ndef nb_app():\n    sys.argv = [""--port=6005"", ""--ip=127.0.0.1"", ""--no-browser"", ""--debug""]\n    from notebook.notebookapp import NotebookApp\n    app = NotebookApp()\n    app.log_level = logging.DEBUG\n    app.ip = \'127.0.0.1\'\n    # TODO: Add auth check tests\n    app.token = \'\'\n    app.password = \'\'\n    app.disable_check_xsrf = True\n    app.initialize()\n    return app.web_app\n\n\nclass TestJupyterExtension(AsyncHTTPTestCase):\n\n    @pytest.fixture(autouse=True)\n    def init_jupyter(self, tf_logs, nb_app, tmpdir_factory):\n        self.app = nb_app\n        self.log_dir = tf_logs\n        self.tmpdir_factory = tmpdir_factory\n\n    def get_app(self):\n        return self.app\n\n    def test_tensorboard(self):\n\n        content = {""logdir"": self.log_dir}\n        content_type = {""Content-Type"": ""application/json""}\n        response = self.fetch(\n            \'/api/tensorboard\',\n            method=\'POST\',\n            body=json.dumps(content),\n            headers=content_type)\n\n        response = self.fetch(\'/api/tensorboard\')\n        instances = json.loads(response.body.decode())\n        assert len(instances) > 0\n\n        response = self.fetch(\'/api/tensorboard/1\')\n        instance = json.loads(response.body.decode())\n        instance2 = None\n        for inst in instances:\n            if inst[""name""] == instance[""name""]:\n                instance2 = inst\n        assert instance == instance2\n\n        response = self.fetch(\'/tensorboard/1/#graphs\')\n        assert response.code == 200\n\n        response = self.fetch(\'/tensorboard/1/data/plugins_listing\')\n        plugins_list = json.loads(response.body.decode())\n        assert plugins_list[""graphs""]\n        assert plugins_list[""scalars""]\n\n        response = self.fetch(\n            \'/api/tensorboard/1\',\n            method=\'DELETE\')\n        assert response.code == 204\n\n        response = self.fetch(\'/api/tensorboard/1\')\n        error_msg = json.loads(response.body.decode())\n        assert error_msg[""message""].startswith(\n            ""TensorBoard instance not found:"")\n\n    def test_instance_reload(self):\n        content = {""logdir"": self.log_dir, ""reload_interval"": 4}\n        content_type = {""Content-Type"": ""application/json""}\n        response = self.fetch(\n            \'/api/tensorboard\',\n            method=\'POST\',\n            body=json.dumps(content),\n            headers=content_type)\n        instance = json.loads(response.body.decode())\n        assert instance is not None\n        name = instance[""name""]\n        reload_time = instance[""reload_time""]\n\n        time.sleep(5)\n        response = self.fetch(\'/api/tensorboard/{}\'.format(name))\n        instance2 = json.loads(response.body.decode())\n        assert instance2[""reload_time""] != reload_time\n'"
