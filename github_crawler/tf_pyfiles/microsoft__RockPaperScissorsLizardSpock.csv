file_path,api_count,code
Source/Functions/RPSLS.Python.Api/NextMove/__init__.py,0,"b""import logging\nimport os\n\nimport azure.functions as func\n\nfrom .next_move import predict\n\ndef main(req: func.HttpRequest) -> func.HttpResponse:\n    logging.info('Python HTTP trigger function processed a request.')\n    # sample request url for testing in local\n    # http://localhost:7071/api/challenger/move?humanPlayerName=john\n    player_name = req.params.get('humanPlayerName', None)\n\n    try:\n        if player_name:\n            next_move = predict(player_name)\n            return func.HttpResponse(next_move)\n        else:\n            return func.HttpResponse(\n                'Please enter the required fields',\n                status_code=400\n            )\n    except Exception as ex:\n        logging.error(ex)\n        return func.HttpResponse('Error processing next move', status_code=500)\n\n"""
Source/Functions/RPSLS.Python.Api/NextMove/next_move.py,0,"b'import logging\nimport random\nimport os\nimport json\nfrom typing import Tuple, List\n\nimport requests\n\n\ndef predict(player_name: str) -> str:\n    next_move = _predict_next_move(*_get_player_games(player_name))\n    return _convert_game_to_json(next_move)\n\n\nR_rock, P_paper, S_scissors, V_spock, L_lizard = (\'R\', \'P\', \'S\', \'V\', \'L\')\nINTERNAL_MOVES_ENCODING = [R_rock, P_paper, S_scissors, V_spock, L_lizard]\n\n\ndef _get_player_games(player_name: str) -> Tuple[str, str]:\n    game_manager_uri = os.getenv(""GAME_MANAGER_URI"", None)\n    url = f\'{game_manager_uri}/game-manager/api/games?player={player_name}\'\n\n    logging.info(f\'requesting human moves: {url}\')\n    req = requests.get(url)\n    data = req.json()\n    return _convert_games_to_str(data[""challengerGames""]), _convert_games_to_str(data[""humanGames""])\n\n\ndef _convert_games_to_str(games) -> str:\n    SOURCE_MOVES_ENCODING = [R_rock, P_paper, S_scissors, L_lizard, V_spock]\n    return """".join([SOURCE_MOVES_ENCODING[game] for game in games])\n\n\ndef _convert_game_to_json(game: str) -> str:\n    JSON_MOVES_ENCODING = {R_rock: ""rock"", P_paper: ""paper"",\n                           S_scissors: ""scissors"", L_lizard: ""lizard"", V_spock: ""spock""}\n    return json.dumps({""prediction"": JSON_MOVES_ENCODING[game]})\n\n\ndef _zip_moves(challenger_moves: List[str], human_moves: List[str]) -> List[Tuple[str, str]]:\n    move_encoding_dict = {value: index for index, value in enumerate(INTERNAL_MOVES_ENCODING)}\n    history = [(move_encoding_dict[i], move_encoding_dict[j])\n               for i, j in zip(challenger_moves, human_moves)]\n    return history\n\n\ndef _predict_next_move(challenger_moves: str, human_moves: str) -> str:\n    history = _zip_moves(challenger_moves, human_moves)\n\n    # what would have been predicted in the last rounds?\n    pred_hist = [_best_next_moves_for_game(\n        history[:i]) for i in range(2, len(history)+1)]\n\n    # if no history prediction, then returns random\n    if not pred_hist:\n        return random.choice(INTERNAL_MOVES_ENCODING)\n\n    # how would the different predictions have scored?\n    # we have the pred_hist from moves i=2 to len(history) so we can check\n    # check https://i.stack.imgur.com/jILea.png for game rules\n    n_pred = len(pred_hist[0])\n    scores = [[0]*5 for i in range(n_pred)]\n    for pred, real in zip(pred_hist[:-1], history[2:]):\n        for i in range(n_pred):\n            # %5: When an int is negative it returns the count to the move\n            # to beat another, in (reverse order) counterclockwise\n            # i.e -1%5=4, -2%5=3\n            scores[i][(real[1]-pred[i]+1) % 5] += 1\n            scores[i][(real[1]-pred[i]+3) % 5] += 1\n            # 1 & 3 move to the other ""moves"" that beat another\n            # for example Rock is beaten with Paper and Spock,\n            # which are 1 & 3 positions away\n            scores[i][(real[1]-pred[i]+2) % 5] -= 1\n            scores[i][(real[1]-pred[i]+4) % 5] -= 1\n\n    # depending in predicted strategies, select best one with less risks\n    # return best counter move\n    best_scores = [list(max(enumerate(s), key=lambda x: x[1])) for s in scores]\n    best_scores[-1][1] *= 1.001   # bias towards the simplest strategy\n    if best_scores[-1][1] < 0.4*len(history):\n        best_scores[-1][1] *= 1.4\n    strat, (shift, _) = max(enumerate(best_scores), key=lambda x: x[1][1])\n\n    return INTERNAL_MOVES_ENCODING[(pred_hist[-1][strat]+shift) % 5]\n\n\ndef _best_next_moves_for_game(hist: List[str]) -> List[List[str]]:\n\n    N = len(hist)\n    # find longest match of the preceding moves in the earlier history\n    cand_m = cand_o = cand_b = range(N-1)\n\n    for l in range(1, min(N, 20)):\n        ref = hist[N-l]\n\n        # l = 1\n        # Looks for previous occurrences of the last move in my_moves, since hist[N-l] == hist[-1]\n        # l = 2\n        # it checks which of the possible candidates was preceded by the move previous to the last\n        # and so on... i.e loos for longest chain matching last moves to use the next move\n        cand_m_tmp = []\n        for c in cand_m:\n            if c >= l and hist[c-l+1][0] == ref[0]:\n                cand_m_tmp.append(c)\n        if not cand_m_tmp:\n            cand_m = cand_m[-1:]\n        else:\n            cand_m = cand_m_tmp[:]\n\n        # same for op_moves\n        cand_o_tmp = []\n        for c in cand_o:\n            if c >= l and hist[c-l+1][1] == ref[1]:\n                cand_o_tmp.append(c)\n        if not cand_o_tmp:\n            cand_o = cand_o[-1:]\n        else:\n            cand_o = cand_o_tmp[:]\n\n        # same for both_moves i.e directly the zipped tuples\n        cand_b_tmp = []\n        for c in cand_b:\n            if c >= l and hist[c-l+1] == ref:\n                cand_b_tmp.append(c)\n        if not cand_b_tmp:\n            cand_b = cand_b[-1:]\n        else:\n            cand_b = cand_b_tmp[:]\n\n    # analyze which moves were used how often, i.e a np.bincount\n    freq_m, freq_o = [0]*5, [0]*5\n    for m in hist:\n        freq_m[m[0]] += 1\n        freq_o[m[1]] += 1\n\n    # return predictions (or possible ""good"" strategies)\n    last_2_moves = [j for i in hist[:-3:-1] for j in i]\n    return (last_2_moves +   # repeat last moves\n            [hist[cand_m[-1]+1][0],     # history matching of my own moves\n                # history matching of opponent\'s moves\n                hist[cand_o[-1]+1][1],\n                hist[cand_b[-1]+1][0],     # history matching of both\n                hist[cand_b[-1]+1][1],\n                freq_m.index(max(freq_m)),  # my most frequent move\n                freq_o.index(max(freq_o)),  # opponent\'s most frequent move\n                0])\n'"
Source/Services/RPSLS.PythonPlayer.Api/app/__init__.py,0,"b'from flask import Flask, request\nfrom healthcheck import HealthCheck\nfrom applicationinsights.flask.ext import AppInsights\n\nimport logging\nimport os\n\nfrom .pick import Picker\n\napp = Flask(__name__)\nappinsightskey = os.getenv(\'APPLICATION_INSIGHTS_IKEY\', \'\')\nif appinsightskey:\n    app.config[\'APPINSIGHTS_INSTRUMENTATIONKEY\'] = appinsightskey\n    # log requests, traces and exceptions to the Application Insights service\n    appinsights = AppInsights(app)\n\nhealth = HealthCheck()\n\napp.add_url_rule(""/healthcheck"", ""healthcheck"", view_func=lambda: health.run())\napp.add_url_rule(\'/pick\', \'pick\', view_func=Picker.as_view(\'picker\'))\n\nif __name__ == ""__main__"":\n    app.run(threaded=True)\nelse:\n    gunicorn_logger = logging.getLogger(\'gunicorn.error\')\n    app.logger.handlers = gunicorn_logger.handlers\n    app.logger.setLevel(gunicorn_logger.level)\n\napp.logger.info(\'Configured pick strategy with \\\'%s\\\'\', Picker.get_strategy())\n'"
Source/Services/RPSLS.PythonPlayer.Api/app/pick/__init__.py,0,"b""from flask.views import View\nfrom flask import request, current_app as app\nimport os\n\nfrom .rpsls import RPSLS\nfrom .rpsls_dto import get_rpsls_dto_json\nfrom .strategies import fixed_strategy, random_strategy, iterative_strategy\nfrom .proxy_predictor import get_pick_predicted\n\nstrategy_map = {\n    'rock': fixed_strategy(RPSLS.rock),\n    'paper': fixed_strategy(RPSLS.paper),\n    'scissors': fixed_strategy(RPSLS.scissors),\n    'lizard': fixed_strategy(RPSLS.lizard),\n    'spock': fixed_strategy(RPSLS.spock),\n    'random': random_strategy(),\n    'iterative': iterative_strategy()\n}\n\nclass Picker(View):\n    def dispatch_request(self):\n        username = request.args.get('username', '')\n\n        if(username != ''):\n            try:\n                predicted_result = get_pick_predicted(username)\n                app.logger.info(f'Against user [{username}] predictor played {predicted_result.name}')\n                return get_rpsls_dto_json(predicted_result)\n            except Exception as ex:\n                app.logger.error(ex)\n\n        strategy = self.get_strategy()\n        pick = strategy_map[strategy]\n        result = pick()\n        app.logger.info(f'Against some user, strategy {strategy} played {result.name}')\n        return get_rpsls_dto_json(result)\n\n    @staticmethod\n    def get_strategy():\n        default_value = 'random'\n        return os.getenv('PICK_STRATEGY', default_value)"""
Source/Services/RPSLS.PythonPlayer.Api/app/pick/proxy_predictor.py,0,"b""import os\nimport json\nimport urllib.request\n\nfrom .rpsls import RPSLS\nfrom .rpsls_dto import get_rpsls_dto_json\n\ndef get_pick_predicted(user_name):\n    queried_url = _get_queried_url(user_name)\n    response = _get_response_from_predictor(queried_url)\n    predicted_pick = RPSLS[response['prediction'].lower()]\n    return get_rpsls_dto_json(predicted_pick)\n\ndef _get_queried_url(user_name):\n    predictor_url = os.getenv('PREDICTOR_URL')\n    return f'{predictor_url}&humanPlayerName={user_name}'\n\ndef _get_response_from_predictor(queried_url):    \n    req = urllib.request.urlopen(queried_url)\n    encoding = req.info().get_content_charset('utf-8')\n    data = req.read()\n    return json.loads(data.decode(encoding))"""
Source/Services/RPSLS.PythonPlayer.Api/app/pick/rpsls.py,0,b'from enum import Enum\n\nclass RPSLS(Enum):\n    rock = 0\n    paper = 1\n    scissors = 2\n    lizard = 3\n    spock = 4\n'
Source/Services/RPSLS.PythonPlayer.Api/app/pick/rpsls_dto.py,0,"b'import socket\nfrom flask import jsonify\n\ndef get_rpsls_dto_json(pick):\n    return jsonify(text = pick.name, value = pick.value, player=socket.gethostname(), playerType=""python"")'"
Source/Services/RPSLS.PythonPlayer.Api/app/pick/strategies.py,0,b'import random\nfrom flask import jsonify\n\nfrom .rpsls import RPSLS\n\n# Fixed pick Game Strategy\ndef fixed_strategy(pick_value):\n    pick_RPSLS=pick_value\n    def pick():\n        return pick_RPSLS\n    return pick\n\n# Random pick Game Strategy\ndef random_strategy():\n    def pick():\n        pick_RPSLS = random.choice(list(RPSLS))\n        return pick_RPSLS\n    return pick\n\n# Iterative pick Game Strategy\ndef iterative_generator(value):\n    while True:\n        yield value\n        value += 1\n        value = value % len(RPSLS)\n\ndef iterative_strategy():\n    pick_generator = iterative_generator(0)\n    def pick():\n        pick_RPSLS = RPSLS(next(pick_generator))\n        return pick_RPSLS\n    return pick\n\n    '
