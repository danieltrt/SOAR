file_path,api_count,code
tests/gen24bBMP.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file gen24bBMP.py\n# @brief Generate 24bpp .bmp files for test cases\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n\nfrom __future__ import print_function\n\nfrom struct import pack\nimport random\nimport sys\n\n##\n# @brief Convert given data to bytes\n# @param[in] data The data to be converted to bytes array\n# @return bytes converted from the data\n\ndef convert_to_bytes(data):\n    """"""\n    Convert given data to bytes\n\n    @param  data: The data to be converted to bytes\n    @rtype      : bytes\n    @return     : bytes converted from the data\n    """"""\n\n    if isinstance(data, bytes):\n        return data\n    else:\n        return pack(""<B"", data)\n\n##\n# @brief Save bitmap ""data"" to ""filename""\n# @param[in] filename The filename to be saves as a .bmp file.\n# @param[in] data string of RGB (packed in \'BBB\') or BGRx (packed in \'BBBB\')\n# @param[in] colorspace ""RGB"" or ""BGRx""\n# @param[in] width Width of the picture\n# @param[in] height Height of the picture\ndef saveBMP(filename, data, colorspace, width, height):\n    size = len(data)\n    graphics = b\'\'\n    # Default value of bytes per pixel value for RGB\n    bytes_per_px = 3\n\n    if colorspace == \'RGB\':\n        assert(size == (width * height * bytes_per_px))\n        # BMP is stored bottom to top. Reverse the order\n        for h in range(height-1, -1, -1):\n            for w in range(0, width):\n                pos = 3 * (w + width * h)\n                graphics += convert_to_bytes(data[pos + 2])\n                graphics += convert_to_bytes(data[pos + 1])\n                graphics += convert_to_bytes(data[pos])\n            for x in range(0, (width * 3) % 4):\n                graphics += pack(\'<B\', 0)\n    elif colorspace == \'BGRx\':\n        bytes_per_px = 4\n        assert(size == (width * height * bytes_per_px))\n        # BMP is stored bottom to top. Reverse the order\n        for h in range(height-1, -1, -1):\n            for w in range(0, width):\n                pos = bytes_per_px * (w + width * h)\n                graphics += convert_to_bytes(data[pos])\n                graphics += convert_to_bytes(data[pos + 1])\n                graphics += convert_to_bytes(data[pos + 2])\n            for x in range(0, (width * 3) % 4):\n                graphics += pack(\'<B\', 0)\n    elif colorspace == \'GRAY8\':\n        bytes_per_px = 1\n        assert(size == (width * height * bytes_per_px))\n        # BMP is stored bottom to top. Reverse the order\n        for h in range(height-1, -1, -1):\n            for w in range(0, width):\n                pos = bytes_per_px * (w + width * h)\n                graphics += convert_to_bytes(data[pos])\n            for x in range(0, (width * 3) % 4):\n                graphics += pack(\'<B\', 0)\n    else:\n        print(\'Unrecognized colorspace %\', colorspace)\n        sys.exit(1)\n\n    # BMP file header\n    if colorspace == \'GRAY8\':\n        header = pack(\'<HLHHL\', 19778, (26 + width * height), 0, 0, 26)\n        header += pack(\'<LHHHH\', 12, width, height, 1, 8)\n    else:\n        header = pack(\'<HLHHL\', 19778, (26 + width * height * 3), 0, 0, 26)\n        header += pack(\'<LHHHH\', 12, width, height, 1, 24)\n\n    with open(filename, \'wb\') as file:\n        file.write(header)\n        file.write(graphics)\n\n\n##\n# @brief Write the generated data\n#\ndef write(filename, data):\n    with open(filename, \'wb\') as file:\n        file.write(data)\n\n\n##\n# @brief Generate Golden Test Case, a single videosrctest frame of 280x40xRGB\n# @return (string, string_size, expected_size)\n#\n# If string_size < expected_size, you do not need to check the results offset >= string_size.\n# string: binary string (b\'\\xff\\x00....\')\ndef gen_RGB():\n    string = b\'\'\n    string_size = 0\n    expected_size = 280 * 40 * 3\n    for i in range(0, 26):\n        # White\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 255, 255, 255)\n        # Yellow\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 255, 255, 0)\n        # Light Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 255, 255)\n        # Green\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 255, 0)\n        # Purple\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 255, 0, 255)\n        # Red\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 255, 0, 0)\n        # Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 0, 255)\n    for i in range(26, 30):\n        # Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 0, 255)\n        # Black\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 0, 0)\n        # Purple\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 255, 0, 255)\n        # Black\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 0, 0)\n        # Light Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 255, 255)\n        # Black\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 0, 0, 0)\n        # White\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBB\', 255, 255, 255)\n    for i in range(0, 46):\n        # Dark Blue\n        string_size = string_size + 46\n        string += pack(\'BBB\', 0, 0, 128)\n    for i in range(46, 93):\n        # White\n        string_size = string_size + 47\n        string += pack(\'BBB\', 255, 255, 255)\n    for i in range(93, 140):\n        # Gray Blue\n        string_size = string_size + 47\n        string += pack(\'BBB\', 0, 128, 255)\n    for i in range(140, 186):\n        # Black\n        string_size = string_size + 46\n        string += pack(\'BBB\', 0, 0, 0)\n    for i in range(186, 210):\n        # Dark Gray\n        string_size = string_size + 24\n        string += pack(\'BBB\', 19, 19, 19)\n    # We do not check the reset pixels: they are randomly generated.\n    string_size = string_size * 3\n    return string, string_size, expected_size\n\n\n##\n# @brief Generate Golden Test Case, a single videosrctest frame of 280x40xBGRx\n# @return (string, string_size, expected_size)\n#\ndef gen_BGRx():\n    string = b\'\'\n    string_size = 0\n    expected_size = 280 * 40 * 4\n    for i in range(0, 26):\n        # White\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 255, 255, 255)\n        # Yellow\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 0, 255, 255, 255)\n        # Light Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 255, 0, 255)\n        # Green\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 0, 255, 0, 255)\n        # Purple\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 0, 255, 255)\n        # Red\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 0, 0, 255, 255)\n        # Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 0, 0, 255)\n    for i in range(26, 30):\n        # Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 0, 0, 255)\n        # Black\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 0, 0, 0, 255)\n        # Purple\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 0, 255, 255)\n        # Black\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 0, 0, 0, 255)\n        # Light Blue\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 255, 0, 255)\n        # Black\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 0, 0, 0, 255)\n        # White\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'BBBB\', 255, 255, 255, 255)\n    for i in range(0, 46):\n        # Dark Blue\n        string_size = string_size + 46\n        string += pack(\'BBBB\', 128, 0, 0, 255)\n    for i in range(46, 93):\n        # White\n        string_size = string_size + 47\n        string += pack(\'BBBB\', 255, 255, 255, 255)\n    for i in range(93, 140):\n        # Gray Blue\n        string_size = string_size + 47\n        string += pack(\'BBBB\', 255, 128, 0, 255)\n    for i in range(140, 186):\n        # Black\n        string_size = string_size + 46\n        string += pack(\'BBBB\', 0, 0, 0, 255)\n    for i in range(186, 210):\n        # Dark Gray\n        string_size = string_size + 24\n        string += pack(\'BBBB\', 19, 19, 19, 255)\n    # We do not check the reset pixels: they are randomly generated.\n    string_size = string_size * 4\n    return string, string_size, expected_size\n\n\n##\n# @brief Generate Golden Test Case, a single videosrctest frame of 280x40xGRAY8\n# @return (string, string_size, expected_size)\n#\n# If string_size < expected_size, you do not need to check the results offset >= string_size.\n# string: binary string (b\'\\xff\\x00....\')\ndef gen_GRAY8():\n    string = b\'\'\n    string_size = 0\n    expected_size = 280 * 40\n    for i in range(0, 26):\n        # 0xEB\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 235)\n        # 0xD2\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 210)\n        # 0xAA\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 170)\n        # 0x91\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 145)\n        # 0x6A\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 106)\n        # 0x51\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 81)\n        # 0x29\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 41)\n    for i in range(26, 30):\n        # 0x29\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 41)\n        # 0x10\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 16)\n        # 0x6A\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 106)\n        # 0x10\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 16)\n        # 0xAA\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 170)\n        # 0x10\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 16)\n        # 0xEB\n        string_size = string_size + 40\n        for j in range(0, 40):\n            string += pack(\'B\', 235)\n    for i in range(0, 46):\n        # 0x10\n        string_size = string_size + 46\n        string += pack(\'B\', 16)\n    for i in range(46, 93):\n        # 0xEB\n        string_size = string_size + 47\n        string += pack(\'B\', 235)\n    for i in range(93, 140):\n        # 0x10\n        string_size = string_size + 47\n        string += pack(\'B\', 16)\n    for i in range(140, 163):\n        # 0x00\n        string_size = string_size + 23\n        string += pack(\'B\', 0)\n    for i in range(163, 186):\n        # 0x10\n        string_size = string_size + 23\n        string += pack(\'B\', 16)\n    for i in range(186, 210):\n        # 0x20\n        string_size = string_size + 24\n        string += pack(\'B\', 32)\n    # We do not check the reset pixels: they are randomly generated.\n    return string, string_size, expected_size\n\n##\n# @brief Generate Golden Test Case, a randomly generated BMP image\n# @return (string, string_size, expected_size)\n#\ndef gen_BMP_random(color_type, width, height, filename_prefix):\n    string = b\'\'\n    string_size = 0\n    size_per_pixel = 3\n    if color_type == \'BGRx\':\n        size_per_pixel = 4\n    elif color_type == ""GRAY8"":\n        size_per_pixel = 1\n    expected_size = width * height * size_per_pixel\n    # The result has no stride for other/tensor types.\n\n    if color_type == \'BGRx\':\n        for y in range(0, height):\n            for x in range(0, width):\n                pval = (random.randrange(256), random.randrange(256), random.randrange(256))\n                pixel = pack(\'BBBB\', pval[2], pval[1], pval[0], 255)\n                string += pixel\n                string_size += 4\n    elif color_type == \'GRAY8\':\n        for y in range(0, height):\n            for x in range(0, width):\n                pval = random.randrange(256)\n                pixel = pack(\'B\', pval)\n                string += pixel\n                string_size += size_per_pixel\n    else:\n        # Assume RGB\n        for y in range(0, height):\n            for x in range(0, width):\n                pval = (random.randrange(256), random.randrange(256), random.randrange(256))\n                pixel = pack(\'BBB\', pval[0], pval[1], pval[2])\n                string += pixel\n                string_size += 3\n\n    saveBMP(filename_prefix + \'_\' + color_type + \'_\' + str(width) + \'x\' + str(height) + \'.bmp\',\n            string, color_type, width, height)\n    return string, string_size, expected_size\n\n\n##\n# @brief Generate a fixed BMP sequence for stream test\n# @return 0 if success. non-zero if failed.\n#\n# This gives ""16x16"", black, white, green, red, blue, wb-checker, rb-checker, gr-checker,\n# red-cross-on-white, blue-cross-on-black (4x4 x 16, left-top/right-bottom white/red/green).\n# ""10 files"" with 0 ~ 9 postfix in the filename\ndef gen_BMP_stream(filename_prefix, golden_filename, num_sink):\n    string = [b\'\' for _ in range(10)]\n    size_x = 16\n    size_y = 16\n\n    for y in range(0, size_y):\n        for x in range(0, size_x):\n            # black. Frame 0\n            string[0] += pack(\'BBB\', 0, 0, 0)\n            # white. Frame 1\n            string[1] += pack(\'BBB\', 255, 255, 255)\n            # green, Frame 2\n            string[2] += pack(\'BBB\', 0, 255, 0)\n            # red, Frame 3\n            string[3] += pack(\'BBB\', 255, 0, 0)\n            # blue, Frame 4\n            string[4] += pack(\'BBB\', 0, 0, 255)\n            # white-black checker, Frame 5\n            if (((x / 4) % 2) + ((y / 4) % 2)) == 1:\n                string[5] += pack(\'BBB\', 0, 0, 0)\n            else:\n                string[5] += pack(\'BBB\', 255, 255, 255)\n            # red-blue checker, Frame 6\n            if (((x / 4) % 2) + ((y / 4) % 2)) == 1:\n                string[6] += pack(\'BBB\', 0, 0, 255)\n            else:\n                string[6] += pack(\'BBB\', 255, 0, 0)\n            # green-red checker, Frame 7\n            if (((x / 4) % 2) + ((y / 4) % 2)) == 1:\n                string[7] += pack(\'BBB\', 255, 0, 0)\n            else:\n                string[7] += pack(\'BBB\', 0, 255, 0)\n            # red-cross-on-white, Frame 8\n            if x == y:\n                string[8] += pack(\'BBB\', 255, 0, 0)\n            else:\n                string[8] += pack(\'BBB\', 255, 255, 255)\n            # blue-cross-on-black, Frame 9\n            if x == y:\n                string[9] += pack(\'BBB\', 0, 0, 255)\n            else:\n                string[9] += pack(\'BBB\', 0, 0, 0)\n\n    with open(golden_filename, \'wb\') as file:\n        for i in range(0, 10):\n            saveBMP(filename_prefix + \'_\' + str(i) + \'.bmp\', string[i], \'RGB\', 16, 16)\n            for j in range(0, num_sink):\n                file.write(string[i])\n    return string\n'"
tools/nnstreamer-toolkit.py,0,"b'#!/usr/bin/env python\n\n##\n# NNStreamer Toolkit\n# Copyright (C) 2018 Samsung Electronics\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Library General Public\n# License as published by the Free Software Foundation;\n# version 2.1 of the License.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Library General Public License for more details.\n\n##\n# @file   nnstreamer-toolkit.py\n# @brief  A front-end GUI toolkit for tracing, debugging, and profiling NNStreamer.\n# @author Geunsik Lim <geunsik.lim@samsung.com>\n# @date   03 Dec 2018\n# @bug    No known bugs\n# @note   TODO/NYI: Interconnect a front-end GUI applicaiton and back-end tools.\n\nimport gtk\nimport pango\n\n##\n# @brief A GTK-based front-end GUI application\nclass PyApp(gtk.Window):\n   def __init__(self):\n      super(PyApp, self).__init__()\n      self.set_title(""NNStreamer Toolkits"")\n      self.set_default_size(500, 400)\n      self.set_position(gtk.WIN_POS_CENTER)\n      \n      mb = gtk.MenuBar()\n\n      # Tracing menu\n      menu1 = gtk.Menu()\n      tracing = gtk.MenuItem(""_Tracing"")\n      tracing.set_submenu(menu1)\n\n      msg_gstshark = gtk.MenuItem(""GstShark"")\n      menu1.append(msg_gstshark)\n\n      # Debugging menu\n      menu2 = gtk.Menu()\n      debugging = gtk.MenuItem(""_Debugging"")\n      debugging.set_submenu(menu2)\n\n      msg_gstdebug = gtk.MenuItem(""GST__DEBUG"")\n      menu2.append(msg_gstdebug)\n\n      msg_gstdebugdump = gtk.MenuItem(""GST__DEBUG__DUMP__DOT__DIR"")\n      menu2.append(msg_gstdebugdump)\n\n      msg_gstdebugger = gtk.MenuItem(""gst-debugger"")\n      menu2.append(msg_gstdebugger)\n\n      # Profiling menu\n      menu3 = gtk.Menu()\n      profiling = gtk.MenuItem(""_Profiling"")\n      profiling.set_submenu(menu3)\n\n      msg_gstinstruments = gtk.MenuItem(""gst-instruments"")\n      menu3.append(msg_gstinstruments)\n\n      msg_hawktracer = gtk.MenuItem(""HawkTracer"")\n      menu3.append(msg_hawktracer)\n\n      mb.append(tracing)\n      mb.append(debugging)\n      mb.append(profiling)\n\n      # Help menu\n      menu4 = gtk.Menu()\n      hlp = gtk.MenuItem(""_Help"")\n      hlp.set_submenu(menu4)\n\n      color = gtk.MenuItem(""Color widget"")\n      menu4.append(color)\n\n      abt = gtk.MenuItem(""About"")\n      menu4.append(abt)\n\n      mb.append(hlp)\n\n \n      vbox = gtk.VBox(False, 2)\n      vbox.pack_start(mb, False, False, 0)\n      self.add(vbox)\n      self.text = gtk.Label("""")\n      self.text.set_markup(""<b>      NNStreamer toolkit provides tracing, debugging, and profiling tool \\\n                             \\n      in order that developers can deploy NNStreamer on their own devices.</b>"")\n      vbox.pack_start(self.text, True, True, 0)\n\n      msg_gstshark.connect(""activate"",self.on_gstshark)\n      msg_gstdebug.connect(""activate"",self.on_gstdebug)\n      msg_gstdebugdump.connect(""activate"",self.on_gstdebugdump)\n      msg_gstdebugger.connect(""activate"",self.on_gstdebugger)\n      msg_gstinstruments.connect(""activate"",self.on_gstinstruments)\n      msg_hawktracer.connect(""activate"",self.on_hawktracer)\n      color.connect(""activate"",self.on_color)\n      abt.connect(""activate"",self.on_abtdlg)\n      \n      self.connect(""destroy"", gtk.main_quit)\n      self.show_all()\n\n   def on_gstshark(self, widget):\n      # MessageDialog usage code\n      md = gtk.MessageDialog(self,\n         gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,\n         gtk.BUTTONS_CLOSE, ""Welcome to GstShark."")\n      md.run()\n      md.destroy()\n\n   def on_gstdebug(self, widget):\n      # MessageDialog usage code\n      md = gtk.MessageDialog(self,\n         gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,\n         gtk.BUTTONS_CLOSE, ""Welcome to GST_DEBUG."")\n      md.run()\n      md.destroy()\n\n   def on_gstdebugdump(self, widget):\n      # MessageDialog usage code\n      md = gtk.MessageDialog(self,\n         gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,\n         gtk.BUTTONS_CLOSE, ""Welcome to GST_DEBUG_DUMP_DOT_DIR."")\n      md.run()\n      md.destroy()\n\n   def on_gstdebugger(self, widget):\n      # MessageDialog usage code\n      md = gtk.MessageDialog(self,\n         gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,\n         gtk.BUTTONS_CLOSE, ""Welcome to gst-debugger."")\n      md.run()\n      md.destroy()\n\n   def on_gstinstruments(self, widget):\n      # MessageDialog usage code\n      md = gtk.MessageDialog(self,\n         gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,\n         gtk.BUTTONS_CLOSE, ""Welcome to gst-instruments."")\n      md.run()\n      md.destroy()\n\n   def on_hawktracer(self, widget):\n      # MessageDialog usage code\n      md = gtk.MessageDialog(self,\n         gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,\n         gtk.BUTTONS_CLOSE, ""Welcome to HawkTracer."")\n      md.run()\n      md.destroy()\n\n   def on_color(self, widget):\n      #Color Chooser Dialog usage cde\n      dlg = gtk.ColorSelectionDialog(""Select color"")\n      col = dlg.run()\n      sel = dlg.colorsel.get_current_color()\n      self.text.modify_fg(gtk.STATE_NORMAL, sel)\n\n   def on_abtdlg(self, widget):\n      #About Dialog usage code\n      about = gtk.AboutDialog()\n      about.set_program_name(""NNStreamer Toolkit"")\n      about.set_version(""0.0.1"")\n      about.set_authors([\n            \'Geunsik Lim\',\n            \'Bug Reports and Patches:\',\n               \'   MyungJoo Ham\',\n               \'   Jijoong Moon\',\n               \'   Sangjung Woo\',\n               \'   Wook Song\',\n               \'   Jaeyun Jung\',\n               \'   Hyoungjoo Ahn\',\n            ])\n\n      about.set_copyright(""(c) Samsung Electronics"")\n      about.set_comments(""About NNStreamer Toolkit"")\n      about.set_website(""https://github.com/nnstreamer/nnstreamer"")\n      about.run()\n      about.destroy()\n\nif __name__ == \'__main__\':\n   PyApp()\n   gtk.main()\n'"
tests/nnstreamer_converter/generateGoldenTestResult.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file generateGoldenTestResult.py\n# @brief Generate golden test results for test cases\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n\nfrom __future__ import print_function\n\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nimport gen24bBMP as bmp\n\n\n# Allow to create specific cases only if proper argument is given\ntarget = -1  # -1 == ALL\nif len(sys.argv) >= 2:  # There\'s some arguments\n    target = int(sys.argv[1])\n\nif target == -1 or target == 1:\n    bmp.write(\'testcase01.rgb.golden\', bmp.gen_RGB()[0])\n    bmp.write(\'testcase01.bgrx.golden\', bmp.gen_BGRx()[0])\n    bmp.write(\'testcase01.gray8.golden\', bmp.gen_GRAY8()[0])\nif target == -1 or target == 2:\n    bmp.write(\'testcase02_RGB_640x480.golden\', bmp.gen_BMP_random(\'RGB\', 640, 480, \'testcase02\')[0])\n    bmp.write(\'testcase02_BGRx_640x480.golden\', bmp.gen_BMP_random(\'BGRx\', 640, 480, \'testcase02\')[0])\n    bmp.write(\'testcase02_GRAY8_640x480.golden\', bmp.gen_BMP_random(\'GRAY8\', 640, 480, \'testcase02\')[0])\n    bmp.write(\'testcase02_RGB_642x480.golden\', bmp.gen_BMP_random(\'RGB\', 642, 480, \'testcase02\')[0])\n    bmp.write(\'testcase02_BGRx_642x480.golden\', bmp.gen_BMP_random(\'BGRx\', 642, 480, \'testcase02\')[0])\n    bmp.write(\'testcase02_GRAY8_642x480.golden\', bmp.gen_BMP_random(\'GRAY8\', 642, 480, \'testcase02\')[0])\nif target == -1 or target == 8:\n    bmp.gen_BMP_stream(\'testsequence\', \'testcase08.golden\', 1)\nif target == -1 or target == 9:\n    buf = bmp.gen_BMP_random(\'RGB\', 100, 100, \'testcase02\')[0]\n    bmp.write(\'testcase01_RGB_100x100.golden\', buf)\n    bmp.write(\'testcase02_RGB_100x100.golden\', buf+buf)\n    bmp.write(\'testcase03_RGB_100x100.golden\', buf+buf+buf)\n    bmp.write(\'testcase04_RGB_100x100.golden\', buf+buf+buf+buf)\n    bmp.gen_BMP_stream(\'testsequence01\', \'testcase01.golden\', 1)\n    bmp.gen_BMP_stream(\'testsequence02\', \'testcase02.golden\', 2)\n    s=bmp.gen_BMP_stream(\'testsequence03\', \'testcase03.golden\', 3)\n    bmp.gen_BMP_stream(\'testsequence04\', \'testcase04.golden\', 4)\n    for i in range(0,4):\n        sink_0 = i*3\n        with open(""testsynch00_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[sink_0])\n            file.write(s[i])\n\n    for i in range(0,10):\n        sink_1 = i // 3;\n        with open(""testsynch03_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[i])\n            file.write(s[sink_1])\n\n    id=[0,1,1,2,3,3,4,5,5,6]\n    for i in range(0,10):\n        sink_1 = id[i]\n        with open(""testsynch04_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[i])\n            file.write(s[sink_1])\n\n    id=[0,2,3,5,6,8,9]\n    for i in range(0,7):\n        sink_0 = id[i]\n        with open(""testsynch01_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[sink_0])\n            file.write(s[i])\n\n    for i in range(0,4):\n        sink_0 = i*3\n        sink_1 = i*2\n        with open(""testsynch02_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[sink_0])\n            file.write(s[sink_1])\n            file.write(s[i])\n\n    id=[0,1,1,2,3,3,4,5,5,6]\n    for i in range(0,10):\n        sink_0 = id[i]\n        sink_1 = i // 3\n        with open(""testsynch05_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[i])\n            file.write(s[sink_0])\n            file.write(s[sink_1])\n\n    id=[0,4,7,9]\n    for i in range(0,4):\n        sink_0 = id[i]\n        with open(""testsynch07_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[i])\n            file.write(s[sink_0])\n\n    for i in range(0,4):\n        sink_0 = i*3\n        with open(""testsynch08_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[i])\n            file.write(s[sink_0])\n\n    for i in range(0,4):\n        sink_0 = i*2\n        sink_1 = i*3\n        with open(""testsynch17_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[i])\n            file.write(s[sink_0])\n            file.write(s[sink_1])\n\n    for i in range(0,4):\n        sink_0 = i*2\n        sink_1 = i*3\n        with open(""testsynch18_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[i])\n            file.write(s[sink_0])\n            file.write(s[sink_1])\n            file.write(s[sink_0])\n\n    id0_0=[0,0,1,1,2]\n    id0_1=[0,0,2,2,4]\n    id1_0=[0,2,3,5,6]\n    id1_1=[0,1,2,3,4]\n    for i in range(0,5):\n        sink0_0 = id0_0[i]\n        sink0_1 = id0_1[i]\n        sink1_0 = id1_0[i]\n        sink1_1 = id1_1[i]\n        with open(""testsynch19_""+str(i)+"".golden"",\'wb\') as file:\n            file.write(s[sink0_0])\n            file.write(s[sink0_1])\n            file.write(s[sink1_0])\n            file.write(s[sink1_1])\n\nif target == -1 or target == 10:\n    buf = bmp.gen_BMP_random(\'RGB\', 100, 100, \'testcase\')[0]\n    bmp.write(\'testcase.golden\', buf)\n    bmp.gen_BMP_stream(\'testsequence\', \'testcase_stream.golden\', 1)\nif target == -1 or target == 11:\n    buf = bmp.gen_BMP_random(\'RGB\', 100, 100, \'testcase\')[0]\n    bmp.write(\'testcase_0_0.golden\', buf)\n\n    s=b\'\'\n    for y in range(0,100):\n        for x in range(0,100):\n            s += bmp.convert_to_bytes(buf[y * 100 + x])\n    bmp.write(\'testcase_1_0.golden\', s);\n\n    s = b\'\'\n    for i in range(1, 3):\n        for y in range(0,100):\n            for x in range(0,100):\n                s += bmp.convert_to_bytes(buf[y*100+x + i*100*100]);\n    bmp.write(\'testcase_1_1.golden\', s);\n\n    for i in range(0,3):\n        s = b\'\'\n        for y in range(0,100):\n            for x in range(0,100):\n                s += bmp.convert_to_bytes(buf[y*100+x + i*100*100])\n        bmp.write(\'testcase_2_\'+str(i)+\'.golden\', s)\n\n    string = bmp.gen_BMP_stream(\'testsequence\', \'testcase_stream.golden\', 1)\n\n    s=b\'\'\n    for i in range (0,10):\n        for y in range(0,16):\n            for x in range(0,16):\n                s += bmp.convert_to_bytes(string[i][y*16+x])\n    bmp.write(\'testcase_stream_1_0.golden\',s)\n\n    s=b\'\'\n    for i in range (0,10):\n        for j in range (1,3):\n            for y in range(0,16):\n                for x in range(0,16):\n                    s += bmp.convert_to_bytes(string[i][j*16*16+ y*16+x])\n    bmp.write(\'testcase_stream_1_1.golden\',s)\n\n    for j in range (0,3):\n        s=b\'\'\n        for i in range (0,10):\n            for y in range(0,16):\n                for x in range(0,16):\n                    s += bmp.convert_to_bytes(string[i][j*16*16+ y*16+x])\n        bmp.write(\'testcase_stream_2_\'+str(j)+\'.golden\',s)\n\nif target == -1 or target == 12:\n    string=bmp.gen_BMP_stream(\'testsequence\',\'testsequence.golden\',1)\n    for i in range(1,11):\n        with open(\'testsequence_\'+str(i)+\'.golden\', \'wb\') as file:\n            file.write(string[i-1]);\n'"
tests/nnstreamer_decoder/generateGoldenTestResult.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file generateGoldenTestResult.py\n# @brief Generate golden test results for test cases\n# @author Jijoong Moon <jijoong.moon@samsung.com>\n#\n\nfrom __future__ import print_function\n\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nimport gen24bBMP as bmp\n\n\nbmp.gen_BMP_random('RGB', 640, 480, 'testcase01')\nbmp.gen_BMP_random('BGRx', 640, 480, 'testcase01')\nbmp.gen_BMP_random('RGB', 642, 480, 'testcase01')\nbmp.gen_BMP_random('BGRx', 642, 480, 'testcase01')\n"""
tests/nnstreamer_filter_caffe2/checkLabel.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file checkLabel.py\n# @brief Check the result label of caffe2 model\n# @author HyoungJoo Ahn <hello.ahn@samsung.com>\n\nimport sys\nimport os\nimport struct\nimport string\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom gen24bBMP  import convert_to_bytes\n\nif sys.version_info < (3,):\n    range = xrange\n\ndef readbyte (filename):\n    F = open(filename, 'rb')\n    readbyte = F.read()\n    F.close()\n    return readbyte\n\n\nbytearr = readbyte(sys.argv[1])\nsoftmax = []\nfor i in range(10):\n    byte = b''\n    byte += convert_to_bytes(bytearr[i * 4])\n    byte += convert_to_bytes(bytearr[i * 4 + 1])\n    byte += convert_to_bytes(bytearr[i * 4 + 2])\n    byte += convert_to_bytes(bytearr[i * 4 + 3])\n    softmax.append(struct.unpack('f', byte))\n\npred = softmax.index(max(softmax))\nanswer = int(sys.argv[2].strip())\n\nexit(pred != answer)\n"""
tests/nnstreamer_filter_custom/checkScaledTensor.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file checkScaledTensor.py\n# @brief Check if the scaled results are correct\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n\nimport sys\n\n\ndef compare (data1, width1, height1, data2, width2, height2, innerdim):\n  if (len(data1) * width2 * height2) != (len(data2) * width1 * height1):\n    print(str(len(data1) * width2 * height2)+"" / ""+str(len(data2) * width1 * height1))\n    return 1\n\n  count = 0\n  count2 = 0\n  while (count < len(data1)):\n    # Terminated incorrectly\n    if (count + (innerdim * width1 * height1)) > len(data1):\n      return 2\n    if (count2 + (innerdim * width2 * height2)) > len(data2):\n      return 3\n    if count2 >= len(data2):\n      return 4\n\n    for y in range(0, height2):\n      for x in range(0, width2):\n        for c in range(0, innerdim):\n          ix = x * width1 // width2\n          iy = y * height1 // height2\n          if data1[count + c + ix * innerdim + iy * width1 * innerdim] != data2[count2 + c + x * innerdim + y * width2 * innerdim]:\n            print(""At ""+str(x)+"",""+str(y))\n            return 5\n    count = count + innerdim * width1 * height1\n    count2 = count2 + innerdim * width2 * height2\n\n  if count > len(data1):\n    return 6\n  if count2 > len(data2):\n    return 7\n  return 0\n\ndef readfile (filename):\n  F = open(filename, \'rb\')\n  readfile = F.read()\n  F.close()\n  return readfile\n\n\nif len(sys.argv) != 8:\n  exit(9)\n\ndata1 = readfile(sys.argv[1])\nwidth1 = int(sys.argv[2])\nheight1 = int(sys.argv[3])\ndata2 = readfile(sys.argv[4])\nwidth2 = int(sys.argv[5])\nheight2 = int(sys.argv[6])\ninnerdim = int(sys.argv[7])\n\nexit(compare(data1, width1, height1, data2, width2, height2, innerdim))\n'"
tests/nnstreamer_filter_python/checkScaledTensor.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file   checkScaledTensor.py\n# @brief  Check if the scaled results are correct\n#         This script is imported from tests/nnstreamer_filter_custom/\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n\nimport sys\n\n## @brief Compare original content and scaled one\ndef compare (data1, width1, height1, data2, width2, height2, innerdim):\n  if (len(data1) * width2 * height2) != (len(data2) * width1 * height1):\n    print(str(len(data1) * width2 * height2)+"" / ""+str(len(data2) * width1 * height1))\n    return 1\n\n  count = 0\n  count2 = 0\n  while (count < len(data1)):\n    # Terminated incorrectly\n    if (count + (innerdim * width1 * height1)) > len(data1):\n      return 2\n    if (count2 + (innerdim * width2 * height2)) > len(data2):\n      return 3\n    if count2 >= len(data2):\n      return 4\n\n    for y in range(0, height2):\n      for x in range(0, width2):\n        for c in range(0, innerdim):\n          ix = x * width1 // width2\n          iy = y * height1 // height2\n          if data1[count + c + ix * innerdim + iy * width1 * innerdim] != data2[count2 + c + x * innerdim + y * width2 * innerdim]:\n            print(""At ""+str(x)+"",""+str(y))\n            return 5\n    count = count + innerdim * width1 * height1\n    count2 = count2 + innerdim * width2 * height2\n\n  if count > len(data1):\n    return 6\n  if count2 > len(data2):\n    return 7\n  return 0\n\n## @brief Read file and return its content\ndef readfile (filename):\n  F = open(filename, \'rb\')\n  readfile = F.read()\n  F.close()\n  return readfile\n\nif len(sys.argv) != 8:\n  exit(9)\n\ndata1 = readfile(sys.argv[1])\nwidth1 = int(sys.argv[2])\nheight1 = int(sys.argv[3])\ndata2 = readfile(sys.argv[4])\nwidth2 = int(sys.argv[5])\nheight2 = int(sys.argv[6])\ninnerdim = int(sys.argv[7])\n\nexit(compare(data1, width1, height1, data2, width2, height2, innerdim))\n'"
tests/nnstreamer_filter_pytorch/checkLabel.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2019 Samsung Electronics\n#\n# @file checkLabel.py\n# @brief Check the result label of pytorch model\n# @author Parichay Kapoor <pk.kapoor@samsung.com>\n\nimport sys\nimport os\nimport struct\nimport string\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom gen24bBMP import convert_to_bytes\n\n# Read the bytes from the file\ndef readbyte (filename):\n    with open(filename, 'rb') as f:\n      readbyte = f.read()\n    return readbyte\n\n# Verify that the output of test case verifies the filename of the input\nonehot = readbyte(sys.argv[1])\nonehot = [convert_to_bytes(x) for x in onehot]\nidx = onehot.index(max(onehot))\n\nlabel = str(idx)\n\nanswer = sys.argv[2].split('/')[-1].split('.')[0].strip()\nexit(label != answer)\n"""
tests/nnstreamer_filter_pytorch/create_mnist_jit.py,0,"b'#!/usr/bin/env python3\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2019 Samsung Electronics\n# License: LGPL-2.1\n#\n# @file checkLabel.py\n# @brief Check the result label of pytorch model\n# @author Parichay Kapoor <pk.kapoor@samsung.com>\n\nimport torch\nimport torch.nn as nn\nimport os\n\npytorch_save_file = ""mnist_cnn.pt""\n\n##\n# This code creates a wrapper around mnist model provided by pytorch.\n# The wrapper consists of preprocessing as well as converting to appropriate\n# type and format as a postprocessing step.\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(1, 6, 5, 1)\n        self.conv2 = nn.Conv2d(6, 16, 5, 1)\n        self.fc1 = nn.Linear(4*4*16, 120)\n        self.fc2 = nn.Linear(120, 10)\n        self.relu = nn.ReLU()\n        self.pool = nn.MaxPool2d(2, 2)\n\n    def forward(self, x):\n        x = self.relu(self.conv1(x))\n        x = self.pool(x)\n        x = self.relu(self.conv2(x))\n        x = self.pool(x)\n        x = x.reshape(x.size(0), -1)\n        x = self.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x\n\ndef mnist_loaded():\n    mnist_model = Net()\n    if (not os.path.isfile(pytorch_save_file)):\n        print(""Base pytorch save file is missing"")\n        print(""refer https://github.com/pytorch/examples/tree/master/mnist"")\n    mnist_model.load_state_dict(torch.load(pytorch_save_file))\n    mnist_model = mnist_model.to(""cpu"")\n    return mnist_model\n\nclass MyScriptModule(torch.jit.ScriptModule):\n    def __init__(self):\n        super(MyScriptModule, self).__init__()\n        self.means = torch.nn.Parameter(torch.tensor([0.1307])\n                                        .resize_(1, 1, 1, 1))\n        self.std_dev = torch.nn.Parameter(torch.tensor([0.3081])\n                                        .resize_(1, 1, 1, 1))\n        self.softmax = torch.nn.Softmax(dim=1)\n\n        mnist_model = mnist_loaded()\n        mnist_model.eval()\n        self.mnist = torch.jit.trace(mnist_model,\n                                      torch.rand(1, 1, 28, 28))\n\n    @torch.jit.script_method\n    def helper(self, input):\n      float_input = input.float() / 255\n      float_input = float_input.transpose_(2,3).transpose_(1,2)\n      float_output = self.mnist((float_input - self.means)/self.std_dev)\n      return (self.softmax(float_output) * 255).byte()\n\n    @torch.jit.script_method\n    def forward(self, input):\n        return self.helper(input)\n\nmodel = MyScriptModule()\n\ntraced_script_module = torch.jit.trace(model, torch.ones(size=(1,28,28,1)))\ntraced_script_module.save(""pytorch_lenet5.pt"")\n\n# This is testing code to verify that the generated model file is working correctly\nfrom PIL import Image\nimport numpy as np\n\nimage_file = \'img/9.png\'\nimg_pil = Image.open(image_file)\nimg_pil = Image.composite(img_pil, Image.new(\'L\', img_pil.size, \'white\'), img_pil)\nimg_np = np.array(img_pil).astype(np.uint8).reshape(1,28,28,1)\n\nout = traced_script_module(torch.ones(1,28,28,1)).data.numpy()\nout = traced_script_module(torch.Tensor(img_np)).data.numpy()\nprint(out.argmax())\n'"
tests/nnstreamer_filter_tensorflow/checkLabel.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file checkLabel.py\n# @brief Check the result label of tensorflow-lite model\n# @author HyoungJoo Ahn <hello.ahn@samsung.com>\n\nimport sys\nimport os\nimport struct\nimport string\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom gen24bBMP  import convert_to_bytes\n\nif sys.version_info < (3,):\n    range = xrange\n\ndef readbyte (filename):\n    F = open(filename, 'rb')\n    readbyte = F.read()\n    F.close()\n    return readbyte\n\n\ndef readlabel (filename):\n    F = open(filename, 'r')\n    line = F.readlines()\n    F.close()\n    return line\n\nbytearr = readbyte(sys.argv[1])\nsoftmax = []\nfor i in range(10):\n    byte = b''\n    byte += convert_to_bytes(bytearr[i * 4])\n    byte += convert_to_bytes(bytearr[i * 4 + 1])\n    byte += convert_to_bytes(bytearr[i * 4 + 2])\n    byte += convert_to_bytes(bytearr[i * 4 + 3])\n    softmax.append(struct.unpack('f', byte))\n\npred = softmax.index(max(softmax))\nanswer = int(sys.argv[2].strip())\nexit(pred != answer)\n"""
tests/nnstreamer_filter_tensorflow_lite/checkLabel.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file checkLabel.py\n# @brief Check the result label of tensorflow-lite model\n# @author HyoungJoo Ahn <hello.ahn@samsung.com>\n\nimport sys\nimport os\nimport struct\nimport string\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom gen24bBMP import convert_to_bytes\n\n\ndef readbyte (filename):\n  F = open(filename, 'rb')\n  readbyte = F.read()\n  F.close()\n  return readbyte\n\n\ndef readlabel (filename):\n  F = open(filename, 'r')\n  line = F.readlines()\n  F.close()\n  return line\n\nonehot = readbyte(sys.argv[1])\nonehot = [convert_to_bytes(x) for x in onehot]\nidx = onehot.index(max(onehot))\n\nlabel_list = readlabel(sys.argv[2])\nlabel = label_list[idx].strip()\n\nanswer = sys.argv[3].strip()\nexit(label != answer)\n"""
tests/nnstreamer_merge/generateTest.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file generateTest.py\n# @brief Generate golden test results for test cases\n# @author Jijoong Moon <jijoong.moon@samsung.com>\n\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom struct import pack\nimport random\n\nimport numpy as np\n\ndef saveTestData(filename, width, height, channel, batch):\n    string = b\'\'\n    data = []\n\n    for b in range(0,batch):\n        for h in range(0,height):\n            for w in range(0,width):\n                for c in range(0,channel):\n                    n = random.uniform(0.0, 10.0)\n                    string += pack(\'f\', n)\n                    data.append(n)\n\n    with open(filename,\'wb\') as file:\n        file.write(string)\n    file.close()\n\n    return data\n\n#merge with channel direction\nch = [3, 2, 4]\nwidth = 100\nheight= 50\nbatch= 1\n\nbuf=[]\n\nbuf.append(saveTestData(""channel_00.dat"", width, height, 3, batch))\nbuf.append(saveTestData(""channel_01.dat"", width, height, 2, batch))\nbuf.append(saveTestData(""channel_02.dat"", width, height, 4, batch))\n\nout = b\'\'\nfor b in range(0, batch):\n    for h in range(0,height):\n        for w in range(0,width):\n            for n in range(0,3):\n                for c in range(0,ch[n]):\n                    out += pack(\'f\',buf[n][b*height*width*ch[n]+h*width*ch[n] + w * ch[n] + c])\n\nwith open(""channel.golden"", \'wb\') as file:\n    file.write(out)\n\n#merge with width direction\nwidth = [100, 200, 300]\nch = 3\nheight= 50\nbatch= 1\n\nbuf=[]\n\nbuf.append(saveTestData(""width_100.dat"", width[0], height, ch, batch))\nbuf.append(saveTestData(""width_200.dat"", width[1], height, ch, batch))\nbuf.append(saveTestData(""width_300.dat"", width[2], height, ch, batch))\n\nout = b\'\'\n\nfor b in range(0, batch):\n    for h in range(0,height):\n        for n in range(0,3):\n            for w in range(0,width[n]):\n                for c in range(0,ch):\n                    out += pack(\'f\',buf[n][b*height*width[n]*ch + h*width[n]*ch + w * ch + c])\n\nwith open(""width.golden"", \'wb\') as file:\n    file.write(out)\n\n#merge with width direction\nbatch = [1, 2, 3]\nch = 3\nheight= 50\nwidth= 100\n\nbuf=[]\n\nbuf.append(saveTestData(""batch_1.dat"", width, height, ch, batch[0]))\nbuf.append(saveTestData(""batch_2.dat"", width, height, ch, batch[1]))\nbuf.append(saveTestData(""batch_3.dat"", width, height, ch, batch[2]))\n\nout = b\'\'\nfor n in range(0,3):\n    for b in range(0, batch[n]):\n        for h in range(0,height):\n            for w in range(0,width):\n                for c in range(0,ch):\n                    out += pack(\'f\',buf[n][b*height*width*ch + h*width*ch + w * ch + c])\n\nwith open(""batch.golden"", \'wb\') as file:\n    file.write(out)\n'"
tests/nnstreamer_repo_lstm/generateTestCase.py,0,"b'#!/usr/bin/env python\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file generateTestCase.py\n# @brief Generate a sequence of video/x-raw frames & golden\n# @todo Generate corresponding golden results\n# @author Jijoong Moon <jijoong.moon@samsung.com>\n# @url https://github.com/nnstreamer/nnstreamer/\n#\n\nfrom __future__ import print_function\n\nimport sys\nimport os\nimport array as arr\nimport numpy as np\n\ndef location(c, w, h):\n    return c+4*(w+4*h)\n\n##\n# @brief Generate a video/x-raw frame & update results\n# @return The frame buffer contents\ndef genFrame(seq, out0, out1):\n    frame = arr.array(\'f\', [0] * 64)\n    width = 4\n    height = 4\n    bpp = 4 # Byte per pixel\n\n    # (ALLCOLOR, 0, 0), 0 to 255\n    frame[bpp * ( 0 + width * 0 ) + 0] = seq # B\n    frame[bpp * ( 0 + width * 0 ) + 1] = seq # G\n    frame[bpp * ( 0 + width * 0 ) + 2] = seq # R\n\n    # (ALLCOLOR, 3, 3), 255 to 0\n    frame[bpp * ( 3 + width * 3 ) + 0] = 255 - seq # B\n    frame[bpp * ( 3 + width * 3 ) + 1] = 255 - seq # G\n    frame[bpp * ( 3 + width * 3 ) + 2] = 255 - seq # R\n\n    # (RED, 1, 1), 0 to 255\n    frame[bpp * ( 1 + width * 1 ) + 2] = seq # R\n\n    in0 = out0;\n    in1 = out1;\n    in2 = frame;\n\n    for h in range(0,4):\n        for w in range(0,4):\n            for c in range(0,4):\n                in2_tmp0 = (in2[location(c,w,h)] + in1[location(c,w,h)])/2\n                in2_tmp1 = np.tanh((in2[location(c,w,h)]))\n                in0[location(c,w,h)] = (in0[location(c,w,h)] * in2_tmp0)\n                in0[location(c,w,h)] += (in2_tmp0 * in2_tmp1)\n                out0[location(c,w,h)] = in0[location(c,w,h)]\n                out1[location(c,w,h)] = (np.tanh(in0[location(c,w,h)]) * in2_tmp0)\n\n    return frame.tostring(), out0, out1\n\nfilename = ""video_4x4xBGRx.xraw""\nf = open(filename, ""wb"")\n\nout0 = arr.array(\'f\',[0]*64)\nout1 = arr.array(\'f\',[0]*64)\n\nfor seq in range(0, 10):\n    outfilename = ""lstm.golden""\n    string, out0, out1=genFrame(seq,out0, out1)\n    if(seq == 9):\n        with open(outfilename,\'wb\') as file:\n            file.write(out1.tostring())\n\n    f.write(string)\n\nf.close()\n\nprint(""File (%s) is written.\\n"" % filename)\n'"
tests/nnstreamer_repo_rnn/generateTestCase.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n# License: LGPL-2.1\n#\n# @file generateTestCase.py\n# @brief Generate a sequence of video/x-raw frames\n# @todo Generate corresponding golden results\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n# @author Jijoong Moon <jijoong.moon@samsung.com>\n# @url https://github.com/nnstreamer/nnstreamer/issues/738\n\n\nfrom __future__ import print_function\n\nimport sys\nimport os\nimport array as arr\nimport struct\nimport string\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom gen24bBMP import convert_to_bytes\n\ndef location(c, w, h):\n    return c+4*(w+4*h)\n\n##\n# @brief Generate a video/x-raw single frame\n# @return The frame buffer contents\ndef genFrame(seq, out):\n    frame = arr.array(\'B\', [0] * 64)\n    width = 4\n    height = 4\n    bpp = 4 # Byte per pixel\n\n    # (ALLCOLOR, 0, 0), 0 to 255\n    frame[bpp * ( 0 + width * 0 ) + 0] = seq # B\n    frame[bpp * ( 0 + width * 0 ) + 1] = seq # G\n    frame[bpp * ( 0 + width * 0 ) + 2] = seq # R\n\n    # (ALLCOLOR, 3, 3), 255 to 0\n    frame[bpp * ( 3 + width * 3 ) + 0] = 255 - seq # B\n    frame[bpp * ( 3 + width * 3 ) + 1] = 255 - seq # G\n    frame[bpp * ( 3 + width * 3 ) + 2] = 255 - seq # R\n\n    # (RED, 1, 1), 0 to 255\n    frame[bpp * ( 1 + width * 1 ) + 2] = seq # R\n\n    for h in range(0,4):\n        w=0\n        for i in range(0,4):\n            out[location(i,w,h)] = frame[location(i,w,h)]\n        for w in range(1,3):\n            for c in range(0,4):\n                sum = frame[location(0,w,h)]\n                sum += out[location(0,w,h)]\n                out[location(0,w,h)] = sum // 2\n        w=3\n        for i in range(0,4):\n            out[location(i,w,h)] = out[location(i,w,h)]\n\n    return frame, out\n\nfilename = ""video_4x4xBGRx.xraw""\nf = open(filename, ""wb"")\n\nout = arr.array(\'B\',[0]*64)\n\nfor seq in range(0, 10):\n    outfilename = ""rnn.golden""\n    frame, out = genFrame(seq,out)\n\n    if(seq == 9):\n        with open(outfilename,\'wb\') as file:\n            file.write(out.tostring())\n\n    f.write(frame)\n\nf.close()\n\nprint(""File (%s) is written.\\n"" % filename)\n'"
tests/transform_arithmetic/checkResult.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n# License: LGPL-2.1\n#\n# @file checkResult.py\n# @brief Check if the tranform results are correct with typecast\n# @author Jijoong Moon <jijoong.moo@samsung.com>\n# @date 20 Jul 2018\n# @bug No known bugs\n\nimport sys\nimport struct\n\n##\n# @brief Get value of proper type corresponding to the unpack format string\n#\ndef getValue (val, unpack_format):\n    if unpack_format in ['b', 'B', 'h', 'H', 'i', 'I', 'q', 'Q']:\n        return int(val)\n    elif unpack_format in ['f', 'd']:\n        return float(val)\n    else:\n        return None\n\n##\n# @brief Check typecast from typea to typeb with file fna/fnb\n#\ndef testArithmetic (fna, fnb, typeasize, typebsize,typeapack, typebpack, mode, value1, value2):\n  lena = len(fna)\n  lenb = len(fnb)\n\n  if (0 < (lena % typeasize)) or (0 < (lenb % typebsize)):\n    return 10\n  num = lena / typeasize\n  if num != (lenb / typebsize):\n    return 11\n  value1 = getValue(value1, typeapack)\n  value2 = getValue(value2, typebpack)\n  if value1 is None or value2 is None:\n      return 12\n\n  for x in range(0, num):\n    vala = struct.unpack(typeapack, fna[x * typeasize: x * typeasize + typeasize])[0]\n    valb = struct.unpack(typebpack, fnb[x * typebsize: x * typebsize + typebsize])[0]\n    if (mode == 'add'):\n      diff = vala  + value1 - valb\n      if diff > 0.01 or diff < -0.01:\n        return 20\n    elif (mode == 'mul'):\n      diff = vala * value1 - valb\n      if diff > 0.01 or diff < -0.01:\n        return 20\n    elif (mode == 'add-mul'):\n      diff = (vala + value1) * value2 - valb\n      if diff > 0.01 or diff < -0.01:\n        return 20\n    elif (mode == 'mul-add'):\n      diff = (vala * value1) + value2 - valb\n      if diff > 0.01 or diff < -0.01:\n        return 20\n    else:\n      return 21\n  return 0\n\ndef readfile (filename):\n  F = open(filename, 'r')\n  readfile = F.read()\n  F.close\n  return readfile\n\nif len(sys.argv) < 2:\n  exit(5)\n\nif (sys.argv[1] == 'arithmetic'):\n  if len(sys.argv) < 11:\n    exit(5)\n  fna = readfile(sys.argv[2])\n  fnb = readfile(sys.argv[3])\n  typeasize = int(sys.argv[4])\n  typebsize = int(sys.argv[5])\n  typeapack = (sys.argv[6])\n  typebpack = (sys.argv[7])\n  mode = sys.argv[8]\n  value1 = sys.argv[9]\n  value2 = sys.argv[10]\n\n  exit(testArithmetic(fna, fnb, typeasize, typebsize, typeapack, typebpack, mode, value1, value2))\n\nexit(5)\n"""
tests/transform_dimchg/checkResult.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file checkResult.py\n# @brief Check if the tranform results are correct\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n# @date 11 Jul 2018\n# @bug No known bugs\n\nimport sys\n\n##\n# @brief Check dimchg mode with option 0:b, b>0.\n#\ndef testDimchgFirstDimGoHigher(dataA, dataB, dim1, repeatblocksize, elementsize):\n  if (len(dataA) != len(dataB)):\n    return 1\n  loop = len(dataA) // repeatblocksize\n  if ((loop * repeatblocksize) != len(dataA)):\n    return 2\n  ncpy = repeatblocksize // dim1 // elementsize\n  if ((ncpy * dim1 * elementsize) != repeatblocksize):\n    return 3\n  for x in range(0, loop):\n    for y in range(0, dim1):\n      for z in range(0, ncpy):\n        b = x * repeatblocksize + y * ncpy * elementsize + z * elementsize\n        a = x * repeatblocksize + z * dim1 * elementsize + y\n        if dataA[a:a+elementsize] != dataB[b:b+elementsize]:\n          return 4\n\ndef readfile (filename):\n  F = open(filename, 'rb')\n  readfile = F.read()\n  F.close\n  return readfile\n\nif len(sys.argv) < 2:\n  exit(5)\n\nif (sys.argv[1] == 'dimchg0:b'):\n  if len(sys.argv) < 7:\n    exit(5)\n  fna = readfile(sys.argv[2])\n  fnb = readfile(sys.argv[3])\n  dim1 = int(sys.argv[4])\n  rbs = int(sys.argv[5])\n  es = int(sys.argv[6])\n  exit(testDimchgFirstDimGoHigher(fna, fnb, dim1, rbs, es))\n\nexit(5)\n"""
tests/transform_stand/checkResult.py,0,"b""#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file checkResult.py\n# @brief Check if the tranform results are correct with typecast\n# @author Jijoong Moon <jijoong.moo@samsung.com>\n# @date 20 Jul 2018\n# @bug No known bugs\n\nimport sys\nimport struct\n\n##\n# @brief Check typecast from typea to typeb with file fna/fnb\n#\ndef testStandardization (fna, fnb, typeasize, typebsize,typeapack, typebpack):\n  lena = len(fna)\n  lenb = len(fnb)\n\n  if (0 < (lena % typeasize)) or (0 < (lenb % typebsize)):\n    return 10\n  num = lena // typeasize\n  if num != (lenb // typebsize):\n    return 11\n  limitb = 2 ** (8 * typebsize)\n  maskb = limitb - 1\n  for x in range(0, num):\n    vala = struct.unpack(typeapack, fna[x * typeasize: x * typeasize + typeasize])[0]\n    valb = struct.unpack(typebpack, fnb[x * typebsize: x * typebsize + typebsize])[0]\n    diff = vala - valb\n    if diff > 0.01 or diff < -0.01:\n      return 20\n  return 0\n\ndef readfile (filename):\n  F = open(filename, 'rb')\n  readfile = F.read()\n  F.close\n  return readfile\n\nif len(sys.argv) < 2:\n  exit(5)\n\nif (sys.argv[1] == 'standardization'):\n  if len(sys.argv) < 8:\n    exit(5)\n  fna = readfile(sys.argv[2])\n  fnb = readfile(sys.argv[3])\n  typeasize = int(sys.argv[4])\n  typebsize = int(sys.argv[5])\n  typeapack = (sys.argv[6])\n  typebpack = (sys.argv[7])\n\n  exit(testStandardization(fna, fnb, typeasize, typebsize, typeapack, typebpack))\n\nexit(5)\n"""
tests/transform_stand/generateTest.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file generateTest.py\n# @brief Generate golden test results for test cases\n# @author Jijoong Moon <jijoong.moon@samsung.com>\n\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom struct import pack\nimport random\n\nimport numpy as np\n\ndef saveTestData(filename, width, height):\n    string = b\'\'\n    data = []\n\n    for w in range(0,width):\n        for h in range(0,height):\n            n = random.uniform(0.0, 10.0)\n            string += pack(\'f\', n)\n            data.append(n)\n\n    with open(filename,\'wb\') as file:\n        file.write(string)\n\n    file.close()\n\n    a=np.array(data)\n    mean = np.mean(a)\n    standard = np.std(a)\n    result=abs((a-np.mean(a)) / (np.std(a)+1e-10))\n\n    s = b\'\'\n    for w in range(0,width):\n        for h in range(0,height):\n            s += pack(\'f\',result[w*height+h])\n\n    with open(filename+"".golden"",\'wb\') as file1:\n        file1.write(s)\n\n    return result, mean, standard\n\nbuf = saveTestData(""test_00.dat"", 100, 50)\n'"
tests/transform_transpose/generateTest.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file generateTest.py\n# @brief Generate golden test results for test cases\n# @author Jijoong Moon <jijoong.moon@samsung.com>\n\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))\nfrom struct import pack\nimport random\n\nimport numpy as np\n\ndef saveTestData(filename, channel, height, width, batch, idx_i, idx_j, idx_k, idx_l):\n    string = b\'\'\n    data = []\n\n    for b in range(0,batch):\n        for c in range(0,channel):\n            for h in range(0,height):\n                for w in range(0,width):\n                    n = random.uniform(0.0, 10.0)\n                    string += pack(\'f\', n)\n                    data.append(n)\n\n    with open(filename,\'wb\') as file:\n        file.write(string)\n\n    file.close()\n\n    a=np.ndarray((batch, channel, height, width), np.float32);\n\n    for b in range(0,batch):\n        for c in range(0,channel):\n            for h in range(0,height):\n                for w in range(0,width):\n                    a[b][c][h][w] = data[b*channel*height*width+c*height*width+h*width+w]\n\n    a=np.transpose(a, (idx_i,idx_j,idx_k,idx_l))\n\n    a=a.copy(order=\'C\')\n\n    with open(filename+"".golden"",\'wb\') as file1:\n        file1.write(a)\n    file1.close()\n\n    return a\n\nbuf = saveTestData(""test01_00.dat"", 3, 50, 100, 1, 0, 2, 3, 1)\n\nbuf = saveTestData(""test02_00.dat"", 3, 100, 200, 1, 0, 2, 3, 1)\n\nbuf = saveTestData(""test03_00.dat"", 3, 100, 200, 1, 0, 1, 3, 2)\n'"
tests/transform_typecast/checkResult.py,0,"b'#!/usr/bin/env python\n\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2018 Samsung Electronics\n#\n# @file checkResult.py\n# @brief Check if the tranform results are correct with typecast\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n# @date 20 Jul 2018\n# @bug No known bugs\n\nimport sys\nimport struct\n\n##\n# @brief Check typecast from typea to typeb with file fna/fnb\n#\ndef testTypeCast (fna, fnb, typea, typeasize, typeapack, typeb, typebsize, typebpack):\n  lena = len(fna)\n  lenb = len(fnb)\n\n  if (0 < (lena % typeasize)) or (0 < (lenb % typebsize)):\n    return 10\n  num = lena // typeasize\n  if num != (lenb // typebsize):\n    return 11\n  limitb = 2 ** (8 * typebsize)\n  maskb = limitb - 1\n\n  for x in range(0, num):\n    vala = struct.unpack(typeapack, fna[x * typeasize: x * typeasize + typeasize])[0]\n    valb = struct.unpack(typebpack, fnb[x * typebsize: x * typebsize + typebsize])[0]\n    if (typeb[0:5] == \'float\'):\n      diff = float(vala) - valb\n      if diff > 0.01 or diff < -0.01:\n        return 20\n    elif (typeb[0:4] == \'uint\' or typeb[0:3] == \'int\'):\n      vala = int(vala)\n      vala = vala & maskb\n      valb = int(valb)\n\n      # Remove the signedness characteristics!\n      diff = (vala ^ valb) & maskb\n      if (diff != 0):\n        print (""WTH?? ""+str(vala)+""->""+str(valb)+""\\n"")\n        return 20\n    else:\n      return 21\n  return 0\n\ndef readfile (filename):\n  F = open(filename, \'rb\')\n  readfile = F.read()\n  F.close\n  return readfile\n\nif len(sys.argv) < 2:\n  exit(5)\n\nif (sys.argv[1] == \'typecast\'):\n  if len(sys.argv) < 10:\n    exit(5)\n  fna = readfile(sys.argv[2])\n  fnb = readfile(sys.argv[3])\n  typea = sys.argv[4]\n  typeasize = int(sys.argv[5])\n  typeapack = sys.argv[6]\n  typeb = sys.argv[7]\n  typebsize = int(sys.argv[8])\n  typebpack = sys.argv[9]\n  exit(testTypeCast(fna, fnb, typea, typeasize, typeapack, typeb, typebsize, typebpack))\n\nexit(5)\n'"
tools/development/count_test_cases.py,0,"b'#!/usr/bin/env python\n##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# GTest / SSAT Test Result Aggregator\n# Copyright (c) 2019 Samsung Electronics\n#\n##\n# @file   count_test_cases.py\n# @brief  A unit test result aggregator\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n# @date   18 Dec 2019\n# @bug    No known bugs\n# @todo   WIP\n\nimport sys\nimport re\nimport os\n\n## @brief read results of GTest\'s result xml file\ndef readGtestXml(filename):\n    neg = 0\n    try:\n        with open(filename, ""r"") as f:\n            r = f.readlines()\n            for line in r:\n                res = re.match(r\'\\s*<testcase name=""([^""]+_n)""\', line)\n                if res:\n                    neg = neg + 1\n            f.seek(0)\n\n            r = f.readlines()\n            for line in r:\n                res = re.match(r\'<testsuites tests=""(\\d+)"" failures=""(\\d+)"" disabled=""(\\d+)""\', line)\n                if res:\n                    return (int(res.group(1)), int(res.group(1)) - int(res.group(2)) - int(res.group(3)), int(res.group(2)), int(res.group(3)), neg)\n    except:\n        print(""No gtest results."")\n    return (0, 0, 0, 0, 0)\n\n## @brief read results of SSAT summary file\ndef readSSAT(filename):\n    try:\n        with open(filename, ""r"") as f:\n            r = f.readlines()\n            for line in r:\n                res = re.match(r\'passed=(\\d+), failed=(\\d+), ignored=(\\d+), negative=(\\d+)\', line)\n                if res:\n                    return (int(res.group(1)) + int(res.group(2)) + int(res.group(3)), int(res.group(1)), int(res.group(2)), int(res.group(3)), int(res.group(4)))\n    except:\n        print(""No SSAT results."")\n    return (0, 0, 0, 0, 0)\n\nif __name__ == \'__main__\':\n    if len(sys.argv) != 3:\n        print(""Usage:"")\n        print("" $ ""+sys.argv[0]+"" <gtest xml path> <ssat summary path>"")\n        print("""")\n        sys.exit(1)\n\n    tg = 0\n    pg = 0\n    fg = 0\n    ig = 0\n    ng = 0\n    posg = 0\n\n    for r, d, f in os.walk(sys.argv[1]):\n        for file in f:\n            if os.path.splitext(file)[1] == \'.xml\':\n                (t, p, f, i, n) = readGtestXml(os.path.join(r, file))\n                tg = tg + t\n                pg = pg + p\n                fg = fg + f\n                ig = ig + i\n                ng = ng + n\n    posg = pg + fg + ig - ng\n\n    (t, p, f, i, n) = readSSAT(sys.argv[2])\n\n    print(""GTest (total "" + str(tg) + "" cases)"")\n    print(""  Passed: "" + str(pg) + "" / Failed: "" + str(fg) + "" / Ignored: "" + str(ig) + "" | Positive: "" + str(posg) + "" / Negative: "" + str(ng))\n    print(""SSAT (total "" + str(t) + "" cases)"")\n    print(""  Passed: "" + str(p) + "" / Failed: "" + str(f) + "" / Ignored: "" + str(i) + "" | Positive: "" + str(t - n) + "" / Negative: "" + str(n))\n    print(""Grand Total: "" + str(pg + t) + "" cases (negatives : "" + str(ng + n) + "")"")\n    print(""  Passed: "" + str(pg+p) + "" / Failed: "" + str(fg + f) + "" / Ignored: "" + str(ig + i))\n    sys.exit(0)\n\n'"
tools/development/nnstreamerCodeGenCustomFilter.py,0,"b'#!/usr/bin/env python\n\n##\n# NNStreamer Custom Filter Code Generator\n# Copyright (c) 2019 Samsung Electronics\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Library General Public\n# License as published by the Free Software Foundation;\n# version 2.1 of the License.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Library General Public License for more details.\n\n##\n# @file   nnstreamerCodeGenCustomFilter.py\n# @brief  A code generator for nnstreamer custom filters.\n# @author MyungJoo Ham <myungjoo.ham@samsung.com>\n# @date   04 Mar 2019\n# @bug    No known bugs\n\nfrom datetime import date\nimport sys\nimport string\nimport re\n\ndef getinput(text):\n  if sys.version_info[0] < 3:\n    return raw_input(text).strip()\n  return input(text).strip()\n\n##\n# Common variables for codegen strings\n# {name}\n# {fname}\n# {sname}\n# {today}\n\n# The code fragments for codegen\ncommon_head = """"""/**\n* NNStreamer Custom Filter, {name}, created by codegen\n* Copyright (C) 2019 Samsung Electronics\n*\n* SPDX-License-Identifier: LGPL-2.1-only\n*\n* @file     nnstreamer_customfilter_{fname}.c\n* @date     {today}\n* @brief    NNStreamer custom filter generated by codegen, {name}\n* @author   MyungJoo Ham <myungjoo.ham@samsung.com>\n* @bug      No known bugs\n*/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <tensor_filter_custom.h>\n#include <nnstreamer_plugin_api.h>\n\n/**\n * @brief Private Data Structure.\n * @todo Add your own data structure required for the custom filter\n */\ntypedef struct _{sname}_data\n{{\n  uint32_t id; /***< Example. Replace with yours */\n}} _{sname}_data;\n\n/**\n * @brief Init func called before all other functions.\n * Use this function to initialize data and prepare operations\n * or open/check related resource files\n * @todo Add your own init procedures and _{sname}_data init.\n * @param[in] prop The tensor filter properties (refer to tensor_typedef.h)\n */\nstatic void *\ncg_init (const GstTensorFilterProperties * prop)\n{{\n  _{sname}_data * data;\n\n  data = (_{sname}_data *) malloc (sizeof (_{sname}_data));\n  assert (data);\n\n  data->id = 0;\n  return data;\n}}\n\n/**\n * @brief Exit func called after all other functions.\n * Use this function to deallocate and close resources\n * @todo Add your own exit procedures and _{sname}_data exit.\n * @param[in/out] _data The private data for this custom filter.\n * @param[in] prop The tensor filter properties (refer to tensor_typedef.h)\n */\nstatic void\ncg_exit (void * _data, const GstTensorFilterProperties * prop)\n{{\n  _{sname}_data *data = _data;\n  assert (data);\n  if (data)\n    free (data);\n}}\n""""""\n\n##\n# @brief Fixed mode is applicable if input and output dimensions are fixed to single instances.\ndim_fixed = """"""\n/**\n * @brief Tell nnstreamer the fixed dimension/type of input tensors\n *\n * @warning Do not fix any internal values based on this function call.\n *          NNStreamer may call this function multiple times before fixing input/output dimensions\n *\n * @param[in/out] _data The private data for this custom filter. As noted, I recommend not to update this based on this function call unless you are aware of the pad-cap negotiation phases of GstBaseFilter class.\n * @param[in] prop The tensor filter properties (refer to tensor_typedef.h)\n * @param[out] in_info The input tensors metadata (number, type, and dimensions)\n * @return 0 if success. Non-zero if failed\n */\nstatic int\ncg_getInputDim (void * _data, const GstTensorFilterProperties * prop,\n                GstTensorsInfo * in_info)\n{{\n  _{sname}_data *data = _data;\n  /** @todo Apply the metadata of your input tensors */\n  int i;\n\n  assert (data);\n  in_info->num_tensors = 1; /** @todo MODIFY THIS! */\n  in_info->info[0].name = NULL; /** Optional, default is null. Set new memory for tensor name string. */\n  in_info->info[0].type = _NNS_UINT8; /** @todo MODIFY THIS! */\n  in_info->info[0].dimension[0] = 3; /** @todo MODIFY THIS! */\n  in_info->info[0].dimension[1] = 224; /** @todo MODIFY THIS! */\n  in_info->info[0].dimension[2] = 224; /** @todo MODIFY THIS! */\n\n  /**\n   * Check max dimension (NNS_TENSOR_RANK_LIMIT) and\n   * fill 1 to uninitialized dimension values.\n   */\n  for (i = 3; i < NNS_TENSOR_RANK_LIMIT; i++)\n    in_info->info[0].dimension[i] = 1;\n\n  return 0;\n}}\n\n/**\n * @brief Tell nnstreamer the fixed dimension/type of output tensors\n *\n * @warning Do not fix any internal values based on this function call.\n *          NNStreamer may call this function multiple times before fixing input/output dimensions\n *\n * @param[in/out] _data The private data for this custom filter. As noted, I recommend not to update this based on this function call unless you are aware of the pad-cap negotiation phases of GstBaseFilter class.\n * @param[in] prop The tensor filter properties (refer to tensor_typedef.h)\n * @param[out] out_info The output tensors metadata (number, type, and dimensions)\n * @return 0 if success. Non-zero if failed\n */\nstatic int\ncg_getOutputDim (void * _data, const GstTensorFilterProperties * prop,\n                GstTensorsInfo * out_info)\n{{\n  _{sname}_data *data = _data;\n  /** @todo Apply the metadata of your output tensors */\n  int i;\n\n  assert (data);\n  out_info->num_tensors = 1; /** @todo MODIFY THIS! */\n  out_info->info[0].name = NULL; /** Optional, default is null. Set new memory for tensor name string. */\n  out_info->info[0].type = _NNS_UINT8; /** @todo MODIFY THIS! */\n  out_info->info[0].dimension[0] = 3; /** @todo MODIFY THIS! */\n  out_info->info[0].dimension[1] = 224; /** @todo MODIFY THIS! */\n  out_info->info[0].dimension[2] = 224; /** @todo MODIFY THIS! */\n\n  /**\n   * Check max dimension (NNS_TENSOR_RANK_LIMIT) and\n   * fill 1 to uninitialized dimension values.\n   */\n  for (i = 3; i < NNS_TENSOR_RANK_LIMIT; i++)\n    out_info->info[0].dimension[i] = 1;\n\n  return 0;\n}}\n\n#define cg_setInputDim  (NULL)\n""""""\n\n##\n# @brief Variable mode is applicable if output dimension can be determined by the given input dimension.\ndim_variable = """"""\n/**\n * @brief With the given input dimension, return corresponding output dimension.\n *\n * @warning With nnstreamer 0.1.x, we cannot express desired ranges of input dimensions.\n *          Thus, the implementor needs to return error (return non-zero value) if the given\n *          input dimension is not tolerable.\n *\n * @warning Do not fix any internal values based on this function call.\n *          NNStreamer may call this function multiple times before fixing input/output dimensions\n *\n * @param[in/out] _data The private data for this custom filter. As noted, I recommend not to update this based on this function call unless you are aware of the pad-cap negotiation phases of GstBaseFilter class.\n * @param[in] prop The tensor filter properties (refer to tensor_typedef.h)\n * @param[in] in_info The given input tensors (number, type, and dimensions)\n * @param[out] out_info The corresponding output tensors (number, type, and dimensions). Allocated by invoker.\n * @return 0 if success. Non-zero if failed\n */\nstatic int\ncg_setInputDim (void * _data, const GstTensorFilterProperties *prop,\n                const GstTensorsInfo * in_info, GstTensorsInfo * out_info)\n{{\n  _{sname}_data *data = _data;\n  int i, j;\n\n  assert (data);\n  assert (in_info);\n  assert (out_info);\n\n  out_info->num_tensors = in_info->num_tensors; /** @todo Configure the number of tensors in a output frame */\n\n  /** @todo Configure the name/type/dimension of tensors in a output frame. */\n  for (i = 0; i < out_info->num_tensors; i++) {{\n    out_info->info[i].name = NULL; /** Optional, default is null. Set new memory for tensor name string. */\n    out_info->info[i].type = in_info->info[i].type;\n\n    for (j = 0; j < NNS_TENSOR_RANK_LIMIT; j++)\n      out_info->info[i].dimension[j] = in_info->info[i].dimension[j];\n  }}\n\n  return 0;\n}}\n\n#define cg_getInputDim  (NULL)\n#define cg_getOutputDim (NULL)\n""""""\n\n##\n# @brief Use allocate mode if you want to allocates output memory blocks internally.\ninvoke_allocate = """"""\n\n/**\n * @brief Allocate output buffer, process the input, write inference results at the output buffer\n *\n * @param[in/out] _data The private data for this custom filter.\n * @param[in] prop The tensor filter properties (refer to tensor_typedef.h)\n * @param[in] input The input tensors\n * @param[out] output The output tensors.\n * @return 0 if success. Non-zero if failed\n *\n * @note The intput / output dimensions, required for interpreting input/output\n *       pointers, are stored in prop.\n */\nstatic int\ncg_allocate_invoke (void * _data, const GstTensorFilterProperties * prop,\n                    const GstTensorMemory * input, GstTensorMemory * output)\n{{\n  int i;\n\n  /** If you want to look at input dimension/type, refer to prop->input_meta */\n  const GstTensorsInfo * in_info __attribute__ ((unused)) = &prop->input_meta;\n  /** If you want to look at output dimension/type, refer to prop->output_meta */\n  const GstTensorsInfo * out_info = &prop->output_meta;\n\n  /** Allocate output buffer */\n  for (i = 0; i < out_info->num_tensors; i++)\n    output[i].data = malloc (gst_tensor_info_get_size (&out_info->info[i]));\n\n  /** @todo Add your inference code/calls. Fill in the output buffer */\n  for (i = 0; i < out_info->num_tensors; i++) {{\n    int s, size = gst_tensor_info_get_size (&out_info->info[i]);\n    uint8_t *ptr = output[i].data;\n    for (s = 0; s < size; s++)\n      ptr[s] = (uint8_t) s;\n  }}\n\n  return 0;\n}}\n\n/**\n * @brief This is called when the pointer allocated by cg_allocate_invoke is to be destroyed.\n * @param[in] data The pointer to be destroyed\n */\nstatic void\ncg_destroy_notify (void * data)\n{{\n  assert (data);\n  if (data)\n    free (data);\n}}\n\n#define cg_invoke (NULL)\n""""""\n\n##\n# @brief Use no-allocate mode if you want to fill in pre-allocated output buffers.\ninvoke_no_allocate = """"""\n\n/**\n * @brief Invoke inference. Fill in pre-allocated output buffer.\n * @param[in/out] _data The private data for this custom filter.\n * @param[in] prop The tensor filter properties (refer to tensor_typedef.h)\n * @param[in] input The input tensors\n * @param[out] output The output tensors.\n * @return 0 if success. Non-zero if failed\n */\nstatic int\ncg_invoke (void * _data, const GstTensorFilterProperties *prop,\n           const GstTensorMemory * input, GstTensorMemory * output)\n{{\n  int i;\n\n  /** If you want to look at input dimension/type, refer to prop->input_meta */\n  const GstTensorsInfo * in_info __attribute__ ((unused)) = &prop->input_meta;\n  /** If you want to look at output dimension/type, refer to prop->output_meta */\n  const GstTensorsInfo * out_info __attribute__ ((unused)) = &prop->output_meta;\n\n  /** @note Caller will allocate output buffer accornding to out_info. */\n\n  /** @todo Add your inference code/calls. Fill in the output buffer */\n  for (i = 0; i < out_info->num_tensors; i++) {{\n    int s, size = gst_tensor_info_get_size (&out_info->info[i]);\n    uint8_t *ptr = output[i].data;\n    for (s = 0; s < size; s++)\n      ptr[s] = (uint8_t) s;\n  }}\n\n  return 0;\n}}\n\n#define cg_allocate_invoke (NULL)\n#define cg_destroy_notify (NULL)\n""""""\n\n##\n# @brief Common part finishing up the code.\n#\n# @todo With progress of #1182, this may need to be updated.\ncommon_tail = """"""\n\n/**\n * @brief The ""concrete class"" to be registered.\n */\nstatic NNStreamer_custom_class {sname}_body = {{\n  .initfunc = cg_init,\n  .exitfunc = cg_exit,\n  .getInputDim = cg_getInputDim,\n  .getOutputDim = cg_getOutputDim,\n  .setInputDim = cg_setInputDim,\n  .invoke = cg_invoke,\n  .allocate_invoke = cg_allocate_invoke,\n  .destroy_notify = cg_destroy_notify,\n}};\n\n/**\n * @brief The dyn-loaded object.\n *\n * @todo @warning With #1182, this is to be updated.\n */\nNNStreamer_custom_class *NNStreamer_custom = &{sname}_body;\n""""""\n\n##\n# @brief The meson build script for this custom filter\nmeson_script = """"""\nproject(\'{fname}\', \'c\',\n  version: \'1.0\',\n  license: [\'LGPL\'],\n  meson_version: \'>=0.50.0\',\n  default_options: [\n    \'warning_level=1\',\n  ]\n)\n\ncc = meson.get_compiler(\'c\')\n\n{fname}_prefix = get_option(\'prefix\')\n{fname}_libdir = join_paths({fname}_prefix, get_option(\'libdir\'))\n{fname}_bindir = join_paths({fname}_prefix, get_option(\'bindir\'))\n{fname}_includedir = join_paths({fname}_prefix, get_option(\'includedir\'))\n\nsubplugin_install_prefix = join_paths({fname}_prefix, \'lib\', \'nnstreamer\')\ncustomfilter_install_dir = join_paths(subplugin_install_prefix, \'customfilters\')\n\n# @todo Declare dependencies if you have libraries to use.\n# example: glib_dep = dependency(\'glib-2.0\')\n# then, add it to ""dependencies: ..."" later.\nglib_dep = dependency(\'glib-2.0\')\ngst_dep = dependency(\'gstreamer-1.0\')\nnnstreamer_dep = dependency(\'nnstreamer\')\n\n{fname}_srcfiles = [\n  \'{fname}.c\'\n]\n\n{fname}_srcfiles_fullpath = []\nforeach s : {fname}_srcfiles\n  {fname}_srcfiles_fullpath += join_paths(meson.current_source_dir(), s)\nendforeach\n\nshared_library(\'{fname}\',\n  {fname}_srcfiles_fullpath,\n  dependencies: [glib_dep, gst_dep, nnstreamer_dep],\n  install: true,\n  install_dir: customfilter_install_dir\n)\n\n# @warning NYI. Static library mode of custom filter is not supported yet.\n# This will be supported after fixing #1182.\n# static_library(\'{fname}\',\n#   {fname}_srcfiles_fullpath,\n#   dependencies: [glib_dep, gst_dep, nnstreamer_dep],\n#   install: true,\n#   install_dir: {fname}_libdir,\n# )\n""""""\n\n\nif __name__ == \'__main__\':\n  ## This is for debugging. To be removed.\n  today = date.today()\n\n  ## 1. Ask for name.\n  name = getinput(\'Please enter the name of the nnstreamer custom filter: \')\n  sname = \'\'.join(re.findall(r""([a-zA-Z0-9_]+)"", name))\n  def_fname = \'\'.join(re.findall(r""([a-zA-Z0-9_]+)"", name))\n  ## @todo @warning We may require prefix for all custom filter in later versions.\n  ## 2. Ask/Check for fname (file & official custom filter name)\n  print(\'Please enter the custom filter name registered to tensor_filter.\')\n  fname = getinput(\'Or press enter without name if [\'+def_fname+\'] is ok: \')\n  fname = \'\'.join(re.findall(r""([a-zA-Z0-9_]+)"", fname))\n  if len(fname) < 1:\n    fname = def_fname\n\n  result = common_head\n\n  ## 3. Ask for options (dimension configuration modes)\n  while 1:\n    option = getinput(\'Are dimensions of input/output tensors fixed? (yes/no):\')\n    option = option.lower()\n    if option == \'y\' or option == \'yes\':\n      result += dim_fixed\n      break\n    if option == \'n\' or option == \'no\':\n      result += dim_variable\n      break\n    print(""Please enter yes/y or no/n"")\n\n  ## 4. Ask for options (memory allocation modes)\n  while 1:\n    option = getinput(\'Are you going to allocate output buffer in your code? (yes/no):\')\n    option = option.lower()\n    if option == \'y\' or option == \'yes\':\n      result += invoke_allocate\n      break\n    if option == \'n\' or option == \'no\':\n      result += invoke_no_allocate\n      break\n    print(""Please enter yes/y or no/n"")\n\n  ## 5. Generate .C file\n  result += common_tail\n  ccode = result.format(fname=fname, name=name, sname=sname, today=today)\n  cfile = open(fname+"".c"", ""w"")\n  cfile.write(ccode)\n  cfile.close()\n\n  ## 6. Generate .meson file\n  mesoncode = meson_script.format(fname=fname, name=name, sname=sname, today=today)\n  mesonfile = open(""meson.build"", ""w"")\n  mesonfile.write(mesoncode)\n  mesonfile.close()\n'"
tests/test_models/models/passthrough.py,0,"b'##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2019 Samsung Electronics\n#\n# @file    Passthrough.py\n# @brief   Python custom filter example: passthrough\n# @author  Dongju Chae <dongju.chae@samsung.com>\n\nimport numpy as np\nimport nnstreamer_python as nns\n\nD1 = 3\nD2 = 280\nD3 = 40\nD4 = 1\n\n## @brief  User-defined custom filter; DO NOT CHANGE CLASS NAME\nclass CustomFilter(object):\n\n## @breif  The constructor for custom filter: passthrough\n#  @param  None\n  def __init__ (self, *args):\n    self.input_dims = [nns.TensorShape([D1, D2, D3, D4], np.uint8)]\n    self.output_dims = [nns.TensorShape([D1, D2, D3, D4], np.uint8)]\n\n## @breif  python callback: getInputDim\n#  @param  None\n#  @return user-assigned input dimensions\n  def getInputDim (self):\n    return self.input_dims\n\n## @breif  Python callback: getOutputDim\n#  @param  None\n#  @return user-assigned output dimensions\n  def getOutputDim (self):\n    return self.output_dims\n\n## @breif  Python callback: invoke\n#  @param  Input tensors: list of input numpy array\n#  @return output tensors: list of output numpy array\n  def invoke (self, input_array):\n    # passthrough; just return\n    return input_array;\n'"
tests/test_models/models/scaler.py,0,"b'##\n# SPDX-License-Identifier: LGPL-2.1-only\n#\n# Copyright (C) 2019 Samsung Electronics\n#\n# @file    Scaler.py\n# @brief   Python custom filter example: scaler\n# @author  Dongju Chae <dongju.chae@samsung.com>\n\nimport numpy as np\nimport nnstreamer_python as nns\n\n## @brief  User-defined custom filter; DO NOT CHANGE CLASS NAME\nclass CustomFilter(object):\n  new_x = 0\n  new_y = 0\n\n## @breif  The constructor for custom filter: scaler\n#  @param  Dimensions to scale\n  def __init__ (self, *args):\n    if len (args) == 1: \n      try:\n        (self.new_x, self.new_y) = [int (dim) for dim in args[0].split(\'x\')]\n      except:\n        print (""Dimension should have this format: AAAxBBB (e.g., 640x480)"")\n\n## @breif  Python callback: setInputDim\n#  @param  Input dimensions: list of nns.TensorShape\n  def setInputDim (self, input_dims):\n    if len(input_dims) != 1:\n      print (""One input tensor is allowed"")\n      return None\n \n    self.input_dims = input_dims\n    self.output_dims = [nns.TensorShape(self.input_dims[0].getDims(), \n                                        self.input_dims[0].getType())]\n\n    dims = self.output_dims[0].getDims()\n    if (self.new_x > 0):\n      dims[1] = self.new_x\n    if (self.new_y > 0):\n      dims[2] = self.new_y\n\n    return self.output_dims\n\n## @breif  Python callback: invoke\n#  @param  Input tensors: list of input numpy array\n#  @return Output tensors: list of output numpy array\n  def invoke (self, input_array):\n    # reshape to n-D array (in reverse order)\n    input_tensor = np.reshape(input_array[0], self.input_dims[0].getDims()[::-1]) \n    output_tensor = np.empty(self.output_dims[0].getDims()[::-1],\n                             dtype=self.output_dims[0].getType())\n    in_dims = self.input_dims[0].getDims()\n    out_dims = self.output_dims[0].getDims()\n    for z in range(out_dims[3]):\n      for y in range(out_dims[2]):\n        for x in range(out_dims[1]):\n          for c in range(out_dims[0]):\n            ix = int(x * in_dims[1] / out_dims[1]);\n            iy = int(y * in_dims[2] / out_dims[2]);\n            output_tensor[z][y][x][c] = input_tensor[z][iy][ix][c]\n\n    # to 1-D array\n    return [np.ravel(output_tensor)]\n'"
