file_path,api_count,code
battle_city.py,6,"b'""""""\n@author: Viet Nguyen <nhviet1009@gmail.com>\n""""""\nimport tensorflow as tf\nimport cv2\nimport numpy as np\nimport multiprocessing as _mp\nfrom src.utils import load_graph, detect_hands, predict, is_in_triangle\nfrom src.battle_city_utils import battle_city\nfrom src.config import RED, CYAN, YELLOW, BLUE, GREEN\n\ntf.flags.DEFINE_integer(""width"", 640, ""Screen width"")\ntf.flags.DEFINE_integer(""height"", 480, ""Screen height"")\ntf.flags.DEFINE_float(""threshold"", 0.6, ""Threshold for score"")\ntf.flags.DEFINE_float(""alpha"", 0.2, ""Transparent level"")\ntf.flags.DEFINE_string(""pre_trained_model_path"", ""src/pretrained_model.pb"", ""Path to pre-trained model"")\n\nFLAGS = tf.flags.FLAGS\n\n\ndef main():\n    graph, sess = load_graph(FLAGS.pre_trained_model_path)\n    cap = cv2.VideoCapture(0)\n    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FLAGS.width)\n    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FLAGS.height)\n    mp = _mp.get_context(""spawn"")\n    v = mp.Value(\'i\', 0)\n    lock = mp.Lock()\n    process = mp.Process(target=battle_city, args=(v, lock))\n    process.start()\n    x_center = int(FLAGS.width / 2)\n    y_center = int(FLAGS.height / 2)\n    radius = int(min(FLAGS.width, FLAGS.height) / 6)\n    while True:\n        key = cv2.waitKey(10)\n        if key == ord(""q""):\n            break\n        _, frame = cap.read()\n        frame = cv2.flip(frame, 1)\n        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        boxes, scores, classes = detect_hands(frame, graph, sess)\n        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)\n        results = predict(boxes, scores, classes, FLAGS.threshold, FLAGS.width, FLAGS.height)\n        if len(results) == 1:\n            x_min, x_max, y_min, y_max, category = results[0]\n            x = int((x_min + x_max) / 2)\n            y = int((y_min + y_max) / 2)\n            cv2.circle(frame, (x, y), 5, RED, -1)\n            if category == ""Closed"" and np.linalg.norm((x - x_center, y - y_center)) <= radius:\n                action = 0 # Stay\n                text = ""Stay""\n            elif category == ""Closed"" and is_in_triangle((x, y), [(0, 0), (FLAGS.width, 0),\n                                                                  (x_center, y_center)]):\n                action = 1  # Up\n                text = ""Up""\n            elif category == ""Closed"" and is_in_triangle((x, y), [(0, FLAGS.height),\n                                                                  (FLAGS.width, FLAGS.height), (x_center, y_center)]):\n                action = 2  # Down\n                text = ""Down""\n            elif category == ""Closed"" and is_in_triangle((x, y), [(0, 0),\n                                                                  (0, FLAGS.height),\n                                                                  (x_center, y_center)]):\n                action = 3  # Left\n                text = ""Left""\n            elif category == ""Closed"" and is_in_triangle((x, y), [(FLAGS.width, 0), (FLAGS.width, FLAGS.height),\n                                                                  (x_center, y_center)]):\n                action = 4  # Right\n                text = ""Right""\n            elif category == ""Open"":\n                action = 5  # Fire\n                text = ""Fire""\n            else:\n                action = 0\n                text = ""Stay""\n            with lock:\n                v.value = action\n            cv2.putText(frame, ""{}"".format(text), (x_min, y_min - 5),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, GREEN, 2)\n\n        overlay = frame.copy()\n        cv2.drawContours(overlay, [np.array([(0, 0), (FLAGS.width, 0), (x_center, y_center)])], 0,\n                         CYAN, -1)\n        cv2.drawContours(overlay, [\n            np.array([(0, FLAGS.height), (FLAGS.width, FLAGS.height), (x_center, y_center)])], 0,\n                         CYAN, -1)\n        cv2.drawContours(overlay, [\n            np.array([(0, 0), (0, FLAGS.height), (x_center, y_center)])], 0,\n                         YELLOW, -1)\n        cv2.drawContours(overlay, [np.array([(FLAGS.width, 0), (FLAGS.width, FLAGS.height), (x_center, y_center)])], 0,\n                         YELLOW, -1)\n        cv2.circle(overlay, (x_center, y_center), radius, BLUE, -1)\n        cv2.addWeighted(overlay, FLAGS.alpha, frame, 1 - FLAGS.alpha, 0, frame)\n\n        cv2.imshow(\'Detection\', frame)\n\n    cap.release()\n    cv2.destroyAllWindows()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
dinosaur.py,6,"b'""""""\n@author: Viet Nguyen <nhviet1009@gmail.com>\n""""""\nimport tensorflow as tf\nimport cv2\nimport multiprocessing as _mp\nfrom src.utils import load_graph, dinosaur, detect_hands, predict\nfrom src.config import RED, GREEN, YELLOW\n\ntf.flags.DEFINE_integer(""width"", 640, ""Screen width"")\ntf.flags.DEFINE_integer(""height"", 480, ""Screen height"")\ntf.flags.DEFINE_float(""threshold"", 0.6, ""Threshold for score"")\ntf.flags.DEFINE_float(""alpha"", 0.3, ""Transparent level"")\ntf.flags.DEFINE_string(""pre_trained_model_path"", ""src/pretrained_model.pb"", ""Path to pre-trained model"")\n\nFLAGS = tf.flags.FLAGS\n\n\ndef main():\n    graph, sess = load_graph(FLAGS.pre_trained_model_path)\n    cap = cv2.VideoCapture(0)\n    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FLAGS.width)\n    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FLAGS.height)\n    mp = _mp.get_context(""spawn"")\n    v = mp.Value(\'i\', 0)\n    lock = mp.Lock()\n    process = mp.Process(target=dinosaur, args=(v, lock))\n    process.start()\n    while True:\n        key = cv2.waitKey(10)\n        if key == ord(""q""):\n            break\n        _, frame = cap.read()\n        frame = cv2.flip(frame, 1)\n        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        boxes, scores, classes = detect_hands(frame, graph, sess)\n        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)\n        results = predict(boxes, scores, classes, FLAGS.threshold, FLAGS.width, FLAGS.height)\n\n        if len(results) == 1:\n            x_min, x_max, y_min, y_max, category = results[0]\n            x = int((x_min + x_max) / 2)\n            y = int((y_min + y_max) / 2)\n            cv2.circle(frame, (x, y), 5, RED, -1)\n            if category == ""Closed"":\n                action = 0  # Do nothing\n                text = ""Run""\n            elif category == ""Open"" and y < FLAGS.height/2:\n                action = 1 # Jump\n                text = ""Jump""\n            elif category == ""Open"" and y > FLAGS.height/2:\n                action = 2\n                text = ""Duck""\n            else:\n                action = 0\n                text = ""Run""\n\n            with lock:\n                v.value = action\n            cv2.putText(frame, ""{}"".format(text), (x_min, y_min - 5),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, GREEN, 2)\n        overlay = frame.copy()\n        cv2.rectangle(overlay, (0, 0), (FLAGS.width, int(FLAGS.height / 2)), YELLOW, -1)\n        cv2.addWeighted(overlay, FLAGS.alpha, frame, 1 - FLAGS.alpha, 0, frame)\n        cv2.imshow(\'Detection\', frame)\n\n    cap.release()\n    cv2.destroyAllWindows()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
mario.py,6,"b'""""""\n@author: Viet Nguyen <nhviet1009@gmail.com>\n""""""\nimport tensorflow as tf\nimport cv2\nimport multiprocessing as _mp\nfrom src.utils import load_graph, mario, detect_hands, predict\nfrom src.config import ORANGE, RED, GREEN\n\ntf.flags.DEFINE_integer(""width"", 640, ""Screen width"")\ntf.flags.DEFINE_integer(""height"", 480, ""Screen height"")\ntf.flags.DEFINE_float(""threshold"", 0.6, ""Threshold for score"")\ntf.flags.DEFINE_float(""alpha"", 0.3, ""Transparent level"")\ntf.flags.DEFINE_string(""pre_trained_model_path"", ""src/pretrained_model.pb"", ""Path to pre-trained model"")\n\nFLAGS = tf.flags.FLAGS\n\n\ndef main():\n    graph, sess = load_graph(FLAGS.pre_trained_model_path)\n    cap = cv2.VideoCapture(0)\n    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FLAGS.width)\n    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FLAGS.height)\n    mp = _mp.get_context(""spawn"")\n    v = mp.Value(\'i\', 0)\n    lock = mp.Lock()\n    process = mp.Process(target=mario, args=(v, lock))\n    process.start()\n    while True:\n        key = cv2.waitKey(10)\n        if key == ord(""q""):\n            break\n        _, frame = cap.read()\n        frame = cv2.flip(frame, 1)\n        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        boxes, scores, classes = detect_hands(frame, graph, sess)\n        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)\n        results = predict(boxes, scores, classes, FLAGS.threshold, FLAGS.width, FLAGS.height)\n\n        if len(results) == 1:\n            x_min, x_max, y_min, y_max, category = results[0]\n            x = int((x_min + x_max) / 2)\n            y = int((y_min + y_max) / 2)\n            cv2.circle(frame, (x, y), 5, RED, -1)\n\n            if category == ""Open"" and x <= FLAGS.width / 3:\n                action = 7  # Left jump\n                text = ""Jump left""\n            elif category == ""Closed"" and x <= FLAGS.width / 3:\n                action = 6  # Left\n                text = ""Run left""\n            elif category == ""Open"" and FLAGS.width / 3 < x <= 2 * FLAGS.width / 3:\n                action = 5  # Jump\n                text = ""Jump""\n            elif category == ""Closed"" and FLAGS.width / 3 < x <= 2 * FLAGS.width / 3:\n                action = 0  # Do nothing\n                text = ""Stay""\n            elif category == ""Open"" and x > 2 * FLAGS.width / 3:\n                action = 2  # Right jump\n                text = ""Jump right""\n            elif category == ""Closed"" and x > 2 * FLAGS.width / 3:\n                action = 1  # Right\n                text = ""Run right""\n            else:\n                action = 0\n                text = ""Stay""\n            with lock:\n                v.value = action\n            cv2.putText(frame, ""{}"".format(text), (x_min, y_min - 5),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, GREEN, 2)\n        overlay = frame.copy()\n        cv2.rectangle(overlay, (0, 0), (int(FLAGS.width / 3), FLAGS.height), ORANGE, -1)\n        cv2.rectangle(overlay, (int(2 * FLAGS.width / 3), 0), (FLAGS.width, FLAGS.height), ORANGE, -1)\n        cv2.addWeighted(overlay, FLAGS.alpha, frame, 1 - FLAGS.alpha, 0, frame)\n        cv2.imshow(\'Detection\', frame)\n\n    cap.release()\n    cv2.destroyAllWindows()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
src/battle_city_utils.py,0,"b'import os, pygame, time, random, uuid, sys\nimport numpy as np\nfrom src.config import *\n\nsprites = pygame.transform.scale(pygame.image.load(""resources/images/sprites.gif""), [192, 224])\nif IS_FULLSCREEN:\n    screen = pygame.display.set_mode(((WIDTH, HEIGHT)), pygame.FULLSCREEN)\nelse:\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n\nplayers = []\nenemies = []\nbullets = []\nbonuses = []\nlabels = []\nplay_sounds = True\nsounds = {}\n\n\nclass myRect(pygame.Rect):\n    def __init__(self, left, top, width, height, type):\n        pygame.Rect.__init__(self, left, top, width, height)\n        self.type = type\n\n\nclass Timer(object):\n    def __init__(self):\n        self.timers = []\n\n    def add(self, interval, f, repeat=-1):\n        options = {\n            ""interval"": interval,\n            ""callback"": f,\n            ""repeat"": repeat,\n            ""times"": 0,\n            ""time"": 0,\n            ""uuid"": uuid.uuid4()\n        }\n        self.timers.append(options)\n\n        return options[""uuid""]\n\n    def destroy(self, uuid_nr):\n        for timer in self.timers:\n            if timer[""uuid""] == uuid_nr:\n                self.timers.remove(timer)\n                return\n\n    def update(self, time_passed):\n        for timer in self.timers:\n            timer[""time""] += time_passed\n            if timer[""time""] > timer[""interval""]:\n                timer[""time""] -= timer[""interval""]\n                timer[""times""] += 1\n                if timer[""repeat""] > -1 and timer[""times""] == timer[""repeat""]:\n                    self.timers.remove(timer)\n                try:\n                    timer[""callback""]()\n                except:\n                    try:\n                        self.timers.remove(timer)\n                    except:\n                        pass\n\n\ngtimer = Timer()\n\n\nclass Castle():\n    """""" Player\'s castle/fortress """"""\n\n    (STATE_STANDING, STATE_DESTROYED, STATE_EXPLODING) = range(3)\n\n    def __init__(self):\n\n        global sprites\n\n        # images\n        self.img_undamaged = sprites.subsurface(0, 15 * 2, 16 * 2, 16 * 2)\n        self.img_destroyed = sprites.subsurface(16 * 2, 15 * 2, 16 * 2, 16 * 2)\n\n        # init position\n        self.rect = pygame.Rect(12 * 16, 24 * 16, 32, 32)\n\n        # start w/ undamaged and shiny castle\n        self.rebuild()\n\n    def draw(self):\n        """""" Draw castle """"""\n        global screen\n\n        screen.blit(self.image, self.rect.topleft)\n\n        if self.state == self.STATE_EXPLODING:\n            if not self.explosion.active:\n                self.state = self.STATE_DESTROYED\n                del self.explosion\n            else:\n                self.explosion.draw()\n\n    def rebuild(self):\n        """""" Reset castle """"""\n        self.state = self.STATE_STANDING\n        self.image = self.img_undamaged\n        self.active = True\n\n    def destroy(self):\n        """""" Destroy castle """"""\n        self.state = self.STATE_EXPLODING\n        self.explosion = Explosion(self.rect.topleft)\n        self.image = self.img_destroyed\n        self.active = False\n\n\ncastle = Castle()\n\n\nclass Bonus():\n    """""" Various power-ups\n    When bonus is spawned, it begins flashing and after some time dissapears\n\n    Available bonusses:\n        grenade\t: Picking up the grenade power up instantly wipes out ever enemy presently on the screen, including Armor Tanks regardless of how many times you\'ve hit them. You do not, however, get credit for destroying them during the end-stage bonus points.\n        helmet\t: The helmet power up grants you a temporary force field that makes you invulnerable to enemy shots, just like the one you begin every stage with.\n        shovel\t: The shovel power up turns the walls around your fortress from brick to stone. This makes it impossible for the enemy to penetrate the wall and destroy your fortress, ending the game prematurely. The effect, however, is only temporary, and will wear off eventually.\n        star\t\t: The star power up grants your tank with new offensive power each time you pick one up, up to three times. The first star allows you to fire your bullets as fast as the power tanks can. The second star allows you to fire up to two bullets on the screen at one time. And the third star allows your bullets to destroy the otherwise unbreakable steel walls. You carry this power with you to each new stage until you lose a life.\n        tank\t\t: The tank power up grants you one extra life. The only other way to get an extra life is to score 20000 points.\n        timer\t\t: The timer power up temporarily freezes time, allowing you to harmlessly approach every tank and destroy them until the time freeze wears off.\n    """"""\n\n    # bonus types\n    (BONUS_GRENADE, BONUS_HELMET, BONUS_SHOVEL, BONUS_STAR, BONUS_TANK, BONUS_TIMER) = range(6)\n\n    def __init__(self, level):\n        global sprites\n\n        # to know where to place\n        self.level = level\n\n        # bonus lives only for a limited period of time\n        self.active = True\n\n        # blinking state\n        self.visible = True\n\n        self.rect = pygame.Rect(random.randint(0, 416 - 32), random.randint(0, 416 - 32), 32, 32)\n\n        self.bonus = random.choice([\n            self.BONUS_GRENADE,\n            self.BONUS_HELMET,\n            self.BONUS_SHOVEL,\n            self.BONUS_STAR,\n            self.BONUS_TANK,\n            self.BONUS_TIMER\n        ])\n\n        self.image = sprites.subsurface(16 * 2 * self.bonus, 32 * 2, 16 * 2, 15 * 2)\n\n    def draw(self):\n        """""" draw bonus """"""\n        global screen\n        if self.visible:\n            screen.blit(self.image, self.rect.topleft)\n\n    def toggleVisibility(self):\n        """""" Toggle bonus visibility """"""\n        self.visible = not self.visible\n\n\nclass Bullet():\n    # direction constants\n    (DIR_UP, DIR_RIGHT, DIR_DOWN, DIR_LEFT) = range(4)\n\n    # bullet\'s stated\n    (STATE_REMOVED, STATE_ACTIVE, STATE_EXPLODING) = range(3)\n\n    (OWNER_PLAYER, OWNER_ENEMY) = range(2)\n\n    def __init__(self, level, position, direction, damage=100, speed=5):\n\n        global sprites\n\n        self.level = level\n        self.direction = direction\n        self.damage = damage\n        self.owner = None\n        self.owner_class = None\n\n        # 1-regular everyday normal bullet\n        # 2-can destroy steel\n        self.power = 1\n\n        self.image = sprites.subsurface(75 * 2, 74 * 2, 3 * 2, 4 * 2)\n\n        # position is player\'s top left corner, so we\'ll need to\n        # recalculate a bit. also rotate image itself.\n        if direction == self.DIR_UP:\n            self.rect = pygame.Rect(position[0] + 11, position[1] - 8, 6, 8)\n        elif direction == self.DIR_RIGHT:\n            self.image = pygame.transform.rotate(self.image, 270)\n            self.rect = pygame.Rect(position[0] + 26, position[1] + 11, 8, 6)\n        elif direction == self.DIR_DOWN:\n            self.image = pygame.transform.rotate(self.image, 180)\n            self.rect = pygame.Rect(position[0] + 11, position[1] + 26, 6, 8)\n        elif direction == self.DIR_LEFT:\n            self.image = pygame.transform.rotate(self.image, 90)\n            self.rect = pygame.Rect(position[0] - 8, position[1] + 11, 8, 6)\n\n        self.explosion_images = [\n            sprites.subsurface(0, 80 * 2, 32 * 2, 32 * 2),\n            sprites.subsurface(32 * 2, 80 * 2, 32 * 2, 32 * 2),\n        ]\n\n        self.speed = speed\n\n        self.state = self.STATE_ACTIVE\n\n    def draw(self):\n        """""" draw bullet """"""\n        global screen\n        if self.state == self.STATE_ACTIVE:\n            screen.blit(self.image, self.rect.topleft)\n        elif self.state == self.STATE_EXPLODING:\n            self.explosion.draw()\n\n    def update(self):\n        global castle, players, enemies, bullets\n\n        if self.state == self.STATE_EXPLODING:\n            if not self.explosion.active:\n                self.destroy()\n                del self.explosion\n\n        if self.state != self.STATE_ACTIVE:\n            return\n\n        """""" move bullet """"""\n        if self.direction == self.DIR_UP:\n            self.rect.topleft = [self.rect.left, self.rect.top - self.speed]\n            if self.rect.top < 0:\n                if play_sounds and self.owner == self.OWNER_PLAYER:\n                    sounds[""steel""].play()\n                self.explode()\n                return\n        elif self.direction == self.DIR_RIGHT:\n            self.rect.topleft = [self.rect.left + self.speed, self.rect.top]\n            if self.rect.left > (416 - self.rect.width):\n                if play_sounds and self.owner == self.OWNER_PLAYER:\n                    sounds[""steel""].play()\n                self.explode()\n                return\n        elif self.direction == self.DIR_DOWN:\n            self.rect.topleft = [self.rect.left, self.rect.top + self.speed]\n            if self.rect.top > (416 - self.rect.height):\n                if play_sounds and self.owner == self.OWNER_PLAYER:\n                    sounds[""steel""].play()\n                self.explode()\n                return\n        elif self.direction == self.DIR_LEFT:\n            self.rect.topleft = [self.rect.left - self.speed, self.rect.top]\n            if self.rect.left < 0:\n                if play_sounds and self.owner == self.OWNER_PLAYER:\n                    sounds[""steel""].play()\n                self.explode()\n                return\n\n        has_collided = False\n\n        # check for collisions with walls. one bullet can destroy several (1 or 2)\n        # tiles but explosion remains 1\n        rects = self.level.obstacle_rects\n        collisions = self.rect.collidelistall(rects)\n        if collisions != []:\n            for i in collisions:\n                if self.level.hitTile(rects[i].topleft, self.power, self.owner == self.OWNER_PLAYER):\n                    has_collided = True\n        if has_collided:\n            self.explode()\n            return\n\n        # check for collisions with other bullets\n        for bullet in bullets:\n            if self.state == self.STATE_ACTIVE and bullet.owner != self.owner and bullet != self and self.rect.colliderect(\n                    bullet.rect):\n                self.destroy()\n                self.explode()\n                return\n\n        # check for collisions with players\n        for player in players:\n            if player.state == player.STATE_ALIVE and self.rect.colliderect(player.rect):\n                if player.bulletImpact(self.owner == self.OWNER_PLAYER, self.damage, self.owner_class):\n                    self.destroy()\n                    return\n\n        # check for collisions with enemies\n        for enemy in enemies:\n            if enemy.state == enemy.STATE_ALIVE and self.rect.colliderect(enemy.rect):\n                if enemy.bulletImpact(self.owner == self.OWNER_ENEMY, self.damage, self.owner_class):\n                    self.destroy()\n                    return\n\n        # check for collision with castle\n        if castle.active and self.rect.colliderect(castle.rect):\n            castle.destroy()\n            self.destroy()\n            return\n\n    def explode(self):\n        """""" start bullets\'s explosion """"""\n        global screen\n        if self.state != self.STATE_REMOVED:\n            self.state = self.STATE_EXPLODING\n            self.explosion = Explosion([self.rect.left - 13, self.rect.top - 13], None, self.explosion_images)\n\n    def destroy(self):\n        self.state = self.STATE_REMOVED\n\n\nclass Label():\n    def __init__(self, position, text="""", duration=None):\n        self.position = position\n\n        self.active = True\n\n        self.text = text\n\n        self.font = pygame.font.SysFont(""Arial"", 13)\n\n        if duration != None:\n            gtimer.add(duration, lambda: self.destroy(), 1)\n\n    def draw(self):\n        """""" draw label """"""\n        global screen\n        screen.blit(self.font.render(self.text, False, (200, 200, 200)), [self.position[0] + 4, self.position[1] + 8])\n\n    def destroy(self):\n        self.active = False\n\n\nclass Explosion():\n    def __init__(self, position, interval=None, images=None):\n\n        global sprites\n\n        self.position = [position[0] - 16, position[1] - 16]\n        self.active = True\n\n        if interval == None:\n            interval = 100\n\n        if images == None:\n            images = [\n                sprites.subsurface(0, 80 * 2, 32 * 2, 32 * 2),\n                sprites.subsurface(32 * 2, 80 * 2, 32 * 2, 32 * 2),\n                sprites.subsurface(64 * 2, 80 * 2, 32 * 2, 32 * 2)\n            ]\n\n        images.reverse()\n\n        self.images = [] + images\n\n        self.image = self.images.pop()\n\n        gtimer.add(interval, lambda: self.update(), len(self.images) + 1)\n\n    def draw(self):\n        global screen\n        """""" draw current explosion frame """"""\n        screen.blit(self.image, self.position)\n\n    def update(self):\n        """""" Advace to the next image """"""\n        if len(self.images) > 0:\n            self.image = self.images.pop()\n        else:\n            self.active = False\n\n\nclass Level():\n    # tile constants\n    (TILE_EMPTY, TILE_BRICK, TILE_STEEL, TILE_WATER, TILE_GRASS, TILE_FROZE) = range(6)\n\n    # tile width/height in px\n    TILE_SIZE = 16\n\n    def __init__(self, level_nr=None):\n        """""" There are total 35 different levels. If level_nr is larger than 35, loop over\n        to next according level so, for example, if level_nr ir 37, then load level 2 """"""\n\n        global sprites\n\n        # max number of enemies simultaneously  being on map\n        self.max_active_enemies = 4\n\n        tile_images = [\n            pygame.Surface((8 * 2, 8 * 2)),\n            sprites.subsurface(48 * 2, 64 * 2, 8 * 2, 8 * 2),\n            sprites.subsurface(48 * 2, 72 * 2, 8 * 2, 8 * 2),\n            sprites.subsurface(56 * 2, 72 * 2, 8 * 2, 8 * 2),\n            sprites.subsurface(64 * 2, 64 * 2, 8 * 2, 8 * 2),\n            sprites.subsurface(64 * 2, 64 * 2, 8 * 2, 8 * 2),\n            sprites.subsurface(72 * 2, 64 * 2, 8 * 2, 8 * 2),\n            sprites.subsurface(64 * 2, 72 * 2, 8 * 2, 8 * 2)\n        ]\n        self.tile_empty = tile_images[0]\n        self.tile_brick = tile_images[1]\n        self.tile_steel = tile_images[2]\n        self.tile_grass = tile_images[3]\n        self.tile_water = tile_images[4]\n        self.tile_water1 = tile_images[4]\n        self.tile_water2 = tile_images[5]\n        self.tile_froze = tile_images[6]\n\n        self.obstacle_rects = []\n\n        level_nr = 1 if level_nr == None else level_nr % 35\n        if level_nr == 0:\n            level_nr = 35\n\n        self.loadLevel(level_nr)\n\n        # tiles\' rects on map, tanks cannot move over\n        self.obstacle_rects = []\n\n        # update these tiles\n        self.updateObstacleRects()\n\n        gtimer.add(400, lambda: self.toggleWaves())\n\n    def hitTile(self, pos, power=1, sound=False):\n        """"""\n            Hit the tile\n            @param pos Tile\'s x, y in px\n            @return True if bullet was stopped, False otherwise\n        """"""\n\n        global play_sounds, sounds\n\n        for tile in self.mapr:\n            if tile.topleft == pos:\n                if tile.type == self.TILE_BRICK:\n                    if play_sounds and sound:\n                        sounds[""brick""].play()\n                    self.mapr.remove(tile)\n                    self.updateObstacleRects()\n                    return True\n                elif tile.type == self.TILE_STEEL:\n                    if play_sounds and sound:\n                        sounds[""steel""].play()\n                    if power == 2:\n                        self.mapr.remove(tile)\n                        self.updateObstacleRects()\n                    return True\n                else:\n                    return False\n\n    def toggleWaves(self):\n        """""" Toggle water image """"""\n        if self.tile_water == self.tile_water1:\n            self.tile_water = self.tile_water2\n        else:\n            self.tile_water = self.tile_water1\n\n    def loadLevel(self, level_nr=1):\n        """""" Load specified level\n        @return boolean Whether level was loaded\n        """"""\n        filename = ""resources/levels/"" + str(level_nr)\n        if (not os.path.isfile(filename)):\n            return False\n        level = []\n        f = open(filename, ""r"")\n        data = f.read().split(""\\n"")\n        self.mapr = []\n        x, y = 0, 0\n        for row in data:\n            for ch in row:\n                if ch == ""#"":\n                    self.mapr.append(myRect(x, y, self.TILE_SIZE, self.TILE_SIZE, self.TILE_BRICK))\n                elif ch == ""@"":\n                    self.mapr.append(myRect(x, y, self.TILE_SIZE, self.TILE_SIZE, self.TILE_STEEL))\n                elif ch == ""~"":\n                    self.mapr.append(myRect(x, y, self.TILE_SIZE, self.TILE_SIZE, self.TILE_WATER))\n                elif ch == ""%"":\n                    self.mapr.append(myRect(x, y, self.TILE_SIZE, self.TILE_SIZE, self.TILE_GRASS))\n                elif ch == ""-"":\n                    self.mapr.append(myRect(x, y, self.TILE_SIZE, self.TILE_SIZE, self.TILE_FROZE))\n                x += self.TILE_SIZE\n            x = 0\n            y += self.TILE_SIZE\n        return True\n\n    def draw(self, tiles=None):\n        """""" Draw specified map on top of existing surface """"""\n\n        global screen\n\n        if tiles == None:\n            tiles = [TILE_BRICK, TILE_STEEL, TILE_WATER, TILE_GRASS, TILE_FROZE]\n\n        for tile in self.mapr:\n            if tile.type in tiles:\n                if tile.type == self.TILE_BRICK:\n                    screen.blit(self.tile_brick, tile.topleft)\n                elif tile.type == self.TILE_STEEL:\n                    screen.blit(self.tile_steel, tile.topleft)\n                elif tile.type == self.TILE_WATER:\n                    screen.blit(self.tile_water, tile.topleft)\n                elif tile.type == self.TILE_FROZE:\n                    screen.blit(self.tile_froze, tile.topleft)\n                elif tile.type == self.TILE_GRASS:\n                    screen.blit(self.tile_grass, tile.topleft)\n\n    def updateObstacleRects(self):\n        """""" Set self.obstacle_rects to all tiles\' rects that players can destroy\n        with bullets """"""\n\n        global castle\n\n        self.obstacle_rects = [castle.rect]\n\n        for tile in self.mapr:\n            if tile.type in (self.TILE_BRICK, self.TILE_STEEL, self.TILE_WATER):\n                self.obstacle_rects.append(tile)\n\n    def buildFortress(self, tile):\n        """""" Build walls around castle made from tile """"""\n\n        positions = [\n            (11 * self.TILE_SIZE, 23 * self.TILE_SIZE),\n            (11 * self.TILE_SIZE, 24 * self.TILE_SIZE),\n            (11 * self.TILE_SIZE, 25 * self.TILE_SIZE),\n            (14 * self.TILE_SIZE, 23 * self.TILE_SIZE),\n            (14 * self.TILE_SIZE, 24 * self.TILE_SIZE),\n            (14 * self.TILE_SIZE, 25 * self.TILE_SIZE),\n            (12 * self.TILE_SIZE, 23 * self.TILE_SIZE),\n            (13 * self.TILE_SIZE, 23 * self.TILE_SIZE)\n        ]\n\n        obsolete = []\n\n        for i, rect in enumerate(self.mapr):\n            if rect.topleft in positions:\n                obsolete.append(rect)\n        for rect in obsolete:\n            self.mapr.remove(rect)\n\n        for pos in positions:\n            self.mapr.append(myRect(pos[0], pos[1], self.TILE_SIZE, self.TILE_SIZE, tile))\n\n        self.updateObstacleRects()\n\n\nclass Tank():\n    # possible directions\n    (DIR_UP, DIR_RIGHT, DIR_DOWN, DIR_LEFT) = range(4)\n\n    # states\n    (STATE_SPAWNING, STATE_DEAD, STATE_ALIVE, STATE_EXPLODING) = range(4)\n\n    # sides\n    (SIDE_PLAYER, SIDE_ENEMY) = range(2)\n\n    def __init__(self, level, side, position=None, direction=None, filename=None):\n\n        global sprites\n\n        # health. 0 health means dead\n        self.health = 100\n\n        # tank can\'t move but can rotate and shoot\n        self.paralised = False\n\n        # tank can\'t do anything\n        self.paused = False\n\n        # tank is protected from bullets\n        self.shielded = False\n\n        # px per move\n        self.speed = 2\n\n        # how many bullets can tank fire simultaneously\n        self.max_active_bullets = 1\n\n        # friend or foe\n        self.side = side\n\n        # flashing state. 0-off, 1-on\n        self.flash = 0\n\n        # 0 - no superpowers\n        # 1 - faster bullets\n        # 2 - can fire 2 bullets\n        # 3 - can destroy steel\n        self.superpowers = 0\n\n        # each tank can pick up 1 bonus\n        self.bonus = None\n\n        # navigation keys: fire, up, right, down, left\n        self.controls = [pygame.K_SPACE, pygame.K_UP, pygame.K_RIGHT, pygame.K_DOWN, pygame.K_LEFT]\n\n        # currently pressed buttons (navigation only)\n        self.pressed = [False] * 4\n\n        self.shield_images = [\n            sprites.subsurface(0, 48 * 2, 16 * 2, 16 * 2),\n            sprites.subsurface(16 * 2, 48 * 2, 16 * 2, 16 * 2)\n        ]\n        self.shield_image = self.shield_images[0]\n        self.shield_index = 0\n\n        self.spawn_images = [\n            sprites.subsurface(32 * 2, 48 * 2, 16 * 2, 16 * 2),\n            sprites.subsurface(48 * 2, 48 * 2, 16 * 2, 16 * 2)\n        ]\n        self.spawn_image = self.spawn_images[0]\n        self.spawn_index = 0\n\n        self.level = level\n\n        if position != None:\n            self.rect = pygame.Rect(position, (26, 26))\n        else:\n            self.rect = pygame.Rect(0, 0, 26, 26)\n\n        if direction == None:\n            self.direction = random.choice([self.DIR_RIGHT, self.DIR_DOWN, self.DIR_LEFT])\n        else:\n            self.direction = direction\n\n        self.state = self.STATE_SPAWNING\n\n        # spawning animation\n        self.timer_uuid_spawn = gtimer.add(100, lambda: self.toggleSpawnImage())\n\n        # duration of spawning\n        self.timer_uuid_spawn_end = gtimer.add(1000, lambda: self.endSpawning())\n\n    def endSpawning(self):\n        """""" End spawning\n        Player becomes operational\n        """"""\n        self.state = self.STATE_ALIVE\n        gtimer.destroy(self.timer_uuid_spawn_end)\n\n    def toggleSpawnImage(self):\n        """""" advance to the next spawn image """"""\n        if self.state != self.STATE_SPAWNING:\n            gtimer.destroy(self.timer_uuid_spawn)\n            return\n        self.spawn_index += 1\n        if self.spawn_index >= len(self.spawn_images):\n            self.spawn_index = 0\n        self.spawn_image = self.spawn_images[self.spawn_index]\n\n    def toggleShieldImage(self):\n        """""" advance to the next shield image """"""\n        if self.state != self.STATE_ALIVE:\n            gtimer.destroy(self.timer_uuid_shield)\n            return\n        if self.shielded:\n            self.shield_index += 1\n            if self.shield_index >= len(self.shield_images):\n                self.shield_index = 0\n            self.shield_image = self.shield_images[self.shield_index]\n\n    def draw(self):\n        """""" draw tank """"""\n        global screen\n        if self.state == self.STATE_ALIVE:\n            screen.blit(self.image, self.rect.topleft)\n            if self.shielded:\n                screen.blit(self.shield_image, [self.rect.left - 3, self.rect.top - 3])\n        elif self.state == self.STATE_EXPLODING:\n            self.explosion.draw()\n        elif self.state == self.STATE_SPAWNING:\n            screen.blit(self.spawn_image, self.rect.topleft)\n\n    def explode(self):\n        """""" start tanks\'s explosion """"""\n        if self.state != self.STATE_DEAD:\n            self.state = self.STATE_EXPLODING\n            self.explosion = Explosion(self.rect.topleft)\n\n            if self.bonus:\n                self.spawnBonus()\n\n    def fire(self, forced=False):\n        """""" Shoot a bullet\n        @param boolean forced. If false, check whether tank has exceeded his bullet quota. Default: True\n        @return boolean True if bullet was fired, false otherwise\n        """"""\n\n        global bullets, labels\n\n        if self.state != self.STATE_ALIVE:\n            gtimer.destroy(self.timer_uuid_fire)\n            return False\n\n        if self.paused:\n            return False\n\n        if not forced:\n            self.active_bullets = 0\n            for bullet in bullets:\n                if bullet.owner_class == self and bullet.state == bullet.STATE_ACTIVE:\n                    self.active_bullets += 1\n            if self.active_bullets >= self.max_active_bullets:\n                return False\n\n        bullet = Bullet(self.level, self.rect.topleft, self.direction)\n\n        # if superpower level is at least 1\n        if self.superpowers > 0:\n            bullet.speed = 8\n\n        # if superpower level is at least 3\n        if self.superpowers > 2:\n            bullet.power = 2\n\n        if self.side == self.SIDE_PLAYER:\n            bullet.owner = self.SIDE_PLAYER\n        else:\n            bullet.owner = self.SIDE_ENEMY\n            self.bullet_queued = False\n\n        bullet.owner_class = self\n        bullets.append(bullet)\n        return True\n\n    def rotate(self, direction, fix_position=True):\n        """""" Rotate tank\n        rotate, update image and correct position\n        """"""\n        self.direction = direction\n\n        if direction == self.DIR_UP:\n            self.image = self.image_up\n        elif direction == self.DIR_RIGHT:\n            self.image = self.image_right\n        elif direction == self.DIR_DOWN:\n            self.image = self.image_down\n        elif direction == self.DIR_LEFT:\n            self.image = self.image_left\n\n        if fix_position:\n            new_x = self.nearest(self.rect.left, 8) + 3\n            new_y = self.nearest(self.rect.top, 8) + 3\n\n            if (abs(self.rect.left - new_x) < 5):\n                self.rect.left = new_x\n\n            if (abs(self.rect.top - new_y) < 5):\n                self.rect.top = new_y\n\n    def turnAround(self):\n        """""" Turn tank into opposite direction """"""\n        if self.direction in (self.DIR_UP, self.DIR_RIGHT):\n            self.rotate(self.direction + 2, False)\n        else:\n            self.rotate(self.direction - 2, False)\n\n    def update(self, time_passed):\n        """""" Update timer and explosion (if any) """"""\n        if self.state == self.STATE_EXPLODING:\n            if not self.explosion.active:\n                self.state = self.STATE_DEAD\n                del self.explosion\n\n    def nearest(self, num, base):\n        """""" Round number to nearest divisible """"""\n        return int(round(num / (base * 1.0)) * base)\n\n    def bulletImpact(self, friendly_fire=False, damage=100, tank=None):\n        """""" Bullet impact\n        Return True if bullet should be destroyed on impact. Only enemy friendly-fire\n        doesn\'t trigger bullet explosion\n        """"""\n\n        global play_sounds, sounds\n\n        if self.shielded:\n            return True\n\n        if not friendly_fire:\n            self.health -= damage\n            if self.health < 1:\n                if self.side == self.SIDE_ENEMY:\n                    tank.trophies[""enemy"" + str(self.type)] += 1\n                    points = (self.type + 1) * 100\n                    tank.score += points\n                    if play_sounds:\n                        sounds[""explosion""].play()\n\n                    labels.append(Label(self.rect.topleft, str(points), 500))\n\n                self.explode()\n            return True\n\n        if self.side == self.SIDE_ENEMY:\n            return False\n        elif self.side == self.SIDE_PLAYER:\n            if not self.paralised:\n                self.setParalised(True)\n                self.timer_uuid_paralise = gtimer.add(10000, lambda: self.setParalised(False), 1)\n            return True\n\n    def setParalised(self, paralised=True):\n        """""" set tank paralise state\n        @param boolean paralised\n        @return None\n        """"""\n        if self.state != self.STATE_ALIVE:\n            gtimer.destroy(self.timer_uuid_paralise)\n            return\n        self.paralised = paralised\n\n\nclass Enemy(Tank):\n    (TYPE_BASIC, TYPE_FAST, TYPE_POWER, TYPE_ARMOR) = range(4)\n\n    def __init__(self, level, type, position=None, direction=None, filename=None):\n\n        Tank.__init__(self, level, type, position=None, direction=None, filename=None)\n\n        global enemies, sprites\n\n        # if true, do not fire\n        self.bullet_queued = False\n\n        # chose type on random\n        if len(level.enemies_left) > 0:\n            self.type = level.enemies_left.pop()\n        else:\n            self.state = self.STATE_DEAD\n            return\n\n        if self.type == self.TYPE_BASIC:\n            self.speed = 1\n        elif self.type == self.TYPE_FAST:\n            self.speed = 3\n        elif self.type == self.TYPE_POWER:\n            self.superpowers = 1\n        elif self.type == self.TYPE_ARMOR:\n            self.health = 400\n\n        # 1 in 5 chance this will be bonus carrier, but only if no other tank is\n        if random.randint(1, 5) == 1:\n            self.bonus = True\n            for enemy in enemies:\n                if enemy.bonus:\n                    self.bonus = False\n                    break\n\n        images = [\n            sprites.subsurface(32 * 2, 0, 13 * 2, 15 * 2),\n            sprites.subsurface(48 * 2, 0, 13 * 2, 15 * 2),\n            sprites.subsurface(64 * 2, 0, 13 * 2, 15 * 2),\n            sprites.subsurface(80 * 2, 0, 13 * 2, 15 * 2),\n            sprites.subsurface(32 * 2, 16 * 2, 13 * 2, 15 * 2),\n            sprites.subsurface(48 * 2, 16 * 2, 13 * 2, 15 * 2),\n            sprites.subsurface(64 * 2, 16 * 2, 13 * 2, 15 * 2),\n            sprites.subsurface(80 * 2, 16 * 2, 13 * 2, 15 * 2)\n        ]\n\n        self.image = images[self.type + 0]\n\n        self.image_up = self.image;\n        self.image_left = pygame.transform.rotate(self.image, 90)\n        self.image_down = pygame.transform.rotate(self.image, 180)\n        self.image_right = pygame.transform.rotate(self.image, 270)\n\n        if self.bonus:\n            self.image1_up = self.image_up;\n            self.image1_left = self.image_left\n            self.image1_down = self.image_down\n            self.image1_right = self.image_right\n\n            self.image2 = images[self.type + 4]\n            self.image2_up = self.image2;\n            self.image2_left = pygame.transform.rotate(self.image2, 90)\n            self.image2_down = pygame.transform.rotate(self.image2, 180)\n            self.image2_right = pygame.transform.rotate(self.image2, 270)\n\n        self.rotate(self.direction, False)\n\n        if position == None:\n            self.rect.topleft = self.getFreeSpawningPosition()\n            if not self.rect.topleft:\n                self.state = self.STATE_DEAD\n                return\n\n        # list of map coords where tank should go next\n        self.path = self.generatePath(self.direction)\n\n        # 1000 is duration between shots\n        self.timer_uuid_fire = gtimer.add(1000, lambda: self.fire())\n\n        # turn on flashing\n        if self.bonus:\n            self.timer_uuid_flash = gtimer.add(200, lambda: self.toggleFlash())\n\n    def toggleFlash(self):\n        """""" Toggle flash state """"""\n        if self.state not in (self.STATE_ALIVE, self.STATE_SPAWNING):\n            gtimer.destroy(self.timer_uuid_flash)\n            return\n        self.flash = not self.flash\n        if self.flash:\n            self.image_up = self.image2_up\n            self.image_right = self.image2_right\n            self.image_down = self.image2_down\n            self.image_left = self.image2_left\n        else:\n            self.image_up = self.image1_up\n            self.image_right = self.image1_right\n            self.image_down = self.image1_down\n            self.image_left = self.image1_left\n        self.rotate(self.direction, False)\n\n    def spawnBonus(self):\n        """""" Create new bonus if needed """"""\n\n        global bonuses\n\n        if len(bonuses) > 0:\n            return\n        bonus = Bonus(self.level)\n        bonuses.append(bonus)\n        gtimer.add(500, lambda: bonus.toggleVisibility())\n        gtimer.add(10000, lambda: bonuses.remove(bonus), 1)\n\n    def getFreeSpawningPosition(self):\n\n        global players, enemies\n\n        available_positions = [\n            [(self.level.TILE_SIZE * 2 - self.rect.width) / 2, (self.level.TILE_SIZE * 2 - self.rect.height) / 2],\n            [12 * self.level.TILE_SIZE + (self.level.TILE_SIZE * 2 - self.rect.width) / 2,\n             (self.level.TILE_SIZE * 2 - self.rect.height) / 2],\n            [24 * self.level.TILE_SIZE + (self.level.TILE_SIZE * 2 - self.rect.width) / 2,\n             (self.level.TILE_SIZE * 2 - self.rect.height) / 2]\n        ]\n\n        random.shuffle(available_positions)\n\n        for pos in available_positions:\n\n            enemy_rect = pygame.Rect(pos, [26, 26])\n\n            # collisions with other enemies\n            collision = False\n            for enemy in enemies:\n                if enemy_rect.colliderect(enemy.rect):\n                    collision = True\n                    continue\n\n            if collision:\n                continue\n\n            # collisions with players\n            collision = False\n            for player in players:\n                if enemy_rect.colliderect(player.rect):\n                    collision = True\n                    continue\n\n            if collision:\n                continue\n\n            return pos\n        return False\n\n    def move(self):\n        """""" move enemy if possible """"""\n\n        global players, enemies, bonuses\n\n        if self.state != self.STATE_ALIVE or self.paused or self.paralised:\n            return\n\n        if self.path == []:\n            self.path = self.generatePath(None, True)\n\n        new_position = self.path.pop(0)\n\n        # move enemy\n        if self.direction == self.DIR_UP:\n            if new_position[1] < 0:\n                self.path = self.generatePath(self.direction, True)\n                return\n        elif self.direction == self.DIR_RIGHT:\n            if new_position[0] > (416 - 26):\n                self.path = self.generatePath(self.direction, True)\n                return\n        elif self.direction == self.DIR_DOWN:\n            if new_position[1] > (416 - 26):\n                self.path = self.generatePath(self.direction, True)\n                return\n        elif self.direction == self.DIR_LEFT:\n            if new_position[0] < 0:\n                self.path = self.generatePath(self.direction, True)\n                return\n\n        new_rect = pygame.Rect(new_position, [26, 26])\n\n        # collisions with tiles\n        if new_rect.collidelist(self.level.obstacle_rects) != -1:\n            self.path = self.generatePath(self.direction, True)\n            return\n\n        # collisions with other enemies\n        for enemy in enemies:\n            if enemy != self and new_rect.colliderect(enemy.rect):\n                self.turnAround()\n                self.path = self.generatePath(self.direction)\n                return\n\n        # collisions with players\n        for player in players:\n            if new_rect.colliderect(player.rect):\n                self.turnAround()\n                self.path = self.generatePath(self.direction)\n                return\n\n        # collisions with bonuses\n        for bonus in bonuses:\n            if new_rect.colliderect(bonus.rect):\n                bonuses.remove(bonus)\n\n        # if no collision, move enemy\n        self.rect.topleft = new_rect.topleft\n\n    def update(self, time_passed):\n        Tank.update(self, time_passed)\n        if self.state == self.STATE_ALIVE and not self.paused:\n            self.move()\n\n    def generatePath(self, direction=None, fix_direction=False):\n        """""" If direction is specified, try continue that way, otherwise choose at random\n        """"""\n\n        all_directions = [self.DIR_UP, self.DIR_RIGHT, self.DIR_DOWN, self.DIR_LEFT]\n\n        if direction == None:\n            if self.direction in [self.DIR_UP, self.DIR_RIGHT]:\n                opposite_direction = self.direction + 2\n            else:\n                opposite_direction = self.direction - 2\n            directions = all_directions\n            random.shuffle(directions)\n            directions.remove(opposite_direction)\n            directions.append(opposite_direction)\n        else:\n            if direction in [self.DIR_UP, self.DIR_RIGHT]:\n                opposite_direction = direction + 2\n            else:\n                opposite_direction = direction - 2\n\n            if direction in [self.DIR_UP, self.DIR_RIGHT]:\n                opposite_direction = direction + 2\n            else:\n                opposite_direction = direction - 2\n            directions = all_directions\n            random.shuffle(directions)\n            directions.remove(opposite_direction)\n            directions.remove(direction)\n            directions.insert(0, direction)\n            directions.append(opposite_direction)\n\n        # at first, work with general units (steps) not px\n        x = int(round(self.rect.left / 16))\n        y = int(round(self.rect.top / 16))\n\n        new_direction = None\n\n        for direction in directions:\n            if direction == self.DIR_UP and y > 1:\n                new_pos_rect = self.rect.move(0, -8)\n                if new_pos_rect.collidelist(self.level.obstacle_rects) == -1:\n                    new_direction = direction\n                    break\n            elif direction == self.DIR_RIGHT and x < 24:\n                new_pos_rect = self.rect.move(8, 0)\n                if new_pos_rect.collidelist(self.level.obstacle_rects) == -1:\n                    new_direction = direction\n                    break\n            elif direction == self.DIR_DOWN and y < 24:\n                new_pos_rect = self.rect.move(0, 8)\n                if new_pos_rect.collidelist(self.level.obstacle_rects) == -1:\n                    new_direction = direction\n                    break\n            elif direction == self.DIR_LEFT and x > 1:\n                new_pos_rect = self.rect.move(-8, 0)\n                if new_pos_rect.collidelist(self.level.obstacle_rects) == -1:\n                    new_direction = direction\n                    break\n\n        # if we can go anywhere else, turn around\n        if new_direction == None:\n            new_direction = opposite_direction\n            print(""nav izejas. griezhamies"")\n\n        # fix tanks position\n        if fix_direction and new_direction == self.direction:\n            fix_direction = False\n\n        self.rotate(new_direction, fix_direction)\n\n        positions = []\n\n        x = self.rect.left\n        y = self.rect.top\n\n        if new_direction in (self.DIR_RIGHT, self.DIR_LEFT):\n            axis_fix = self.nearest(y, 16) - y\n        else:\n            axis_fix = self.nearest(x, 16) - x\n        axis_fix = 0\n\n        pixels = self.nearest(random.randint(1, 12) * 32, 32) + axis_fix + 3\n\n        if new_direction == self.DIR_UP:\n            for px in range(0, pixels, self.speed):\n                positions.append([x, y - px])\n        elif new_direction == self.DIR_RIGHT:\n            for px in range(0, pixels, self.speed):\n                positions.append([x + px, y])\n        elif new_direction == self.DIR_DOWN:\n            for px in range(0, pixels, self.speed):\n                positions.append([x, y + px])\n        elif new_direction == self.DIR_LEFT:\n            for px in range(0, pixels, self.speed):\n                positions.append([x - px, y])\n\n        return positions\n\n\nclass Player(Tank):\n\n    def __init__(self, level, type, position=None, direction=None, filename=None):\n\n        Tank.__init__(self, level, type, position=None, direction=None, filename=None)\n\n        global sprites\n\n        if filename == None:\n            filename = (0, 0, 16 * 2, 16 * 2)\n\n        self.start_position = position\n        self.start_direction = direction\n\n        self.lives = 3\n\n        # total score\n        self.score = 0\n\n        # store how many bonuses in this stage this player has collected\n        self.trophies = {\n            ""bonus"": 0,\n            ""enemy0"": 0,\n            ""enemy1"": 0,\n            ""enemy2"": 0,\n            ""enemy3"": 0\n        }\n\n        self.image = sprites.subsurface(filename)\n        self.image_up = self.image;\n        self.image_left = pygame.transform.rotate(self.image, 90)\n        self.image_down = pygame.transform.rotate(self.image, 180)\n        self.image_right = pygame.transform.rotate(self.image, 270)\n\n        if direction == None:\n            self.rotate(self.DIR_UP, False)\n        else:\n            self.rotate(direction, False)\n\n    def move(self, direction):\n        """""" move player if possible """"""\n\n        global players, enemies, bonuses\n\n        if self.state == self.STATE_EXPLODING:\n            if not self.explosion.active:\n                self.state = self.STATE_DEAD\n                del self.explosion\n\n        if self.state != self.STATE_ALIVE:\n            return\n\n        # rotate player\n        if self.direction != direction:\n            self.rotate(direction)\n\n        if self.paralised:\n            return\n\n        # move player\n        if direction == self.DIR_UP:\n            new_position = [self.rect.left, self.rect.top - self.speed]\n            if new_position[1] < 0:\n                return\n        elif direction == self.DIR_RIGHT:\n            new_position = [self.rect.left + self.speed, self.rect.top]\n            if new_position[0] > (416 - 26):\n                return\n        elif direction == self.DIR_DOWN:\n            new_position = [self.rect.left, self.rect.top + self.speed]\n            if new_position[1] > (416 - 26):\n                return\n        elif direction == self.DIR_LEFT:\n            new_position = [self.rect.left - self.speed, self.rect.top]\n            if new_position[0] < 0:\n                return\n\n        player_rect = pygame.Rect(new_position, [26, 26])\n\n        # collisions with tiles\n        if player_rect.collidelist(self.level.obstacle_rects) != -1:\n            return\n\n        # collisions with other players\n        for player in players:\n            if player != self and player.state == player.STATE_ALIVE and player_rect.colliderect(player.rect) == True:\n                return\n\n        # collisions with enemies\n        for enemy in enemies:\n            if player_rect.colliderect(enemy.rect) == True:\n                return\n\n        # collisions with bonuses\n        for bonus in bonuses:\n            if player_rect.colliderect(bonus.rect) == True:\n                self.bonus = bonus\n\n        # if no collision, move player\n        self.rect.topleft = (new_position[0], new_position[1])\n\n    def reset(self):\n        """""" reset player """"""\n        self.rotate(self.start_direction, False)\n        self.rect.topleft = self.start_position\n        self.superpowers = 0\n        self.max_active_bullets = 1\n        self.health = 100\n        self.paralised = False\n        self.paused = False\n        self.pressed = [False] * 4\n        self.state = self.STATE_ALIVE\n\n\nclass Game():\n    # direction constants\n    (DIR_UP, DIR_RIGHT, DIR_DOWN, DIR_LEFT) = range(4)\n\n    TILE_SIZE = 16\n\n    def __init__(self):\n\n        global play_sounds, sounds\n\n        # center window\n        os.environ[\'SDL_VIDEO_WINDOW_POS\'] = \'center\'\n\n        if play_sounds:\n            pygame.mixer.pre_init(44100, -16, 1, 512)\n\n        pygame.init()\n\n        pygame.display.set_caption(""Battle City"")\n\n        self.clock = pygame.time.Clock()\n\n        # load sprites (funky version)\n        # sprites = pygame.transform.scale2x(pygame.image.load(""images/sprites.gif""))\n        # load sprites (pixely version)\n        # sprites = pygame.transform.scale(pygame.image.load(""images/sprites.gif""), [192, 224])\n        # screen.set_colorkey((0,138,104))\n\n        pygame.display.set_icon(sprites.subsurface(0, 0, 13 * 2, 13 * 2))\n\n        # load sounds\n        if play_sounds:\n            pygame.mixer.init(44100, -16, 1, 512)\n\n            sounds[""start""] = pygame.mixer.Sound(""resources/sounds/gamestart.ogg"")\n            sounds[""end""] = pygame.mixer.Sound(""resources/sounds/gameover.ogg"")\n            sounds[""score""] = pygame.mixer.Sound(""resources/sounds/score.ogg"")\n            sounds[""bg""] = pygame.mixer.Sound(""resources/sounds/background.ogg"")\n            sounds[""fire""] = pygame.mixer.Sound(""resources/sounds/fire.ogg"")\n            sounds[""bonus""] = pygame.mixer.Sound(""resources/sounds/bonus.ogg"")\n            sounds[""explosion""] = pygame.mixer.Sound(""resources/sounds/explosion.ogg"")\n            sounds[""brick""] = pygame.mixer.Sound(""resources/sounds/brick.ogg"")\n            sounds[""steel""] = pygame.mixer.Sound(""resources/sounds/steel.ogg"")\n\n        self.enemy_life_image = sprites.subsurface(81 * 2, 57 * 2, 7 * 2, 7 * 2)\n        self.player_life_image = sprites.subsurface(89 * 2, 56 * 2, 7 * 2, 8 * 2)\n        self.flag_image = sprites.subsurface(64 * 2, 49 * 2, 16 * 2, 15 * 2)\n\n        # this is used in intro screen\n        self.player_image = pygame.transform.rotate(sprites.subsurface(0, 0, 13 * 2, 13 * 2), 270)\n\n        # if true, no new enemies will be spawn during this time\n        self.timefreeze = False\n\n        # load custom font\n        self.font = pygame.font.Font(""resources/fonts/prstart.ttf"", 16)\n\n        # pre-render game over text\n        self.im_game_over = pygame.Surface((64, 40))\n        self.im_game_over.set_colorkey((0, 0, 0))\n        self.im_game_over.blit(self.font.render(""GAME"", False, (127, 64, 64)), [0, 0])\n        self.im_game_over.blit(self.font.render(""OVER"", False, (127, 64, 64)), [0, 20])\n        self.game_over_y = 416 + 40\n\n        # number of players. here is defined preselected menu value\n        self.nr_of_players = 1\n\n        del players[:]\n        del bullets[:]\n        del enemies[:]\n        del bonuses[:]\n\n    def triggerBonus(self, bonus, player):\n        """""" Execute bonus powers """"""\n\n        global enemies, labels, play_sounds, sounds\n\n        if play_sounds:\n            sounds[""bonus""].play()\n\n        player.trophies[""bonus""] += 1\n        player.score += 500\n\n        if bonus.bonus == bonus.BONUS_GRENADE:\n            for enemy in enemies:\n                enemy.explode()\n        elif bonus.bonus == bonus.BONUS_HELMET:\n            self.shieldPlayer(player, True, 10000)\n        elif bonus.bonus == bonus.BONUS_SHOVEL:\n            self.level.buildFortress(self.level.TILE_STEEL)\n            gtimer.add(10000, lambda: self.level.buildFortress(self.level.TILE_BRICK), 1)\n        elif bonus.bonus == bonus.BONUS_STAR:\n            player.superpowers += 1\n            if player.superpowers == 2:\n                player.max_active_bullets = 2\n        elif bonus.bonus == bonus.BONUS_TANK:\n            player.lives += 1\n        elif bonus.bonus == bonus.BONUS_TIMER:\n            self.toggleEnemyFreeze(True)\n            gtimer.add(10000, lambda: self.toggleEnemyFreeze(False), 1)\n        bonuses.remove(bonus)\n\n        labels.append(Label(bonus.rect.topleft, ""500"", 500))\n\n    def shieldPlayer(self, player, shield=True, duration=None):\n        """""" Add/remove shield\n        player: player (not enemy)\n        shield: true/false\n        duration: in ms. if none, do not remove shield automatically\n        """"""\n        player.shielded = shield\n        if shield:\n            player.timer_uuid_shield = gtimer.add(100, lambda: player.toggleShieldImage())\n        else:\n            gtimer.destroy(player.timer_uuid_shield)\n\n        if shield and duration != None:\n            gtimer.add(duration, lambda: self.shieldPlayer(player, False), 1)\n\n    def spawnEnemy(self):\n        """""" Spawn new enemy if needed\n        Only add enemy if:\n            - there are at least one in queue\n            - map capacity hasn\'t exceeded its quota\n            - now isn\'t timefreeze\n        """"""\n\n        global enemies\n\n        if len(enemies) >= self.level.max_active_enemies:\n            return\n        if len(self.level.enemies_left) < 1 or self.timefreeze:\n            return\n        enemy = Enemy(self.level, 1)\n\n        enemies.append(enemy)\n\n    def respawnPlayer(self, player, clear_scores=False):\n        """""" Respawn player """"""\n        player.reset()\n\n        if clear_scores:\n            player.trophies = {\n                ""bonus"": 0, ""enemy0"": 0, ""enemy1"": 0, ""enemy2"": 0, ""enemy3"": 0\n            }\n\n        self.shieldPlayer(player, True, 4000)\n\n    def gameOver(self):\n        """""" End game and return to menu """"""\n\n        global play_sounds, sounds\n\n        print(""Game Over"")\n        if play_sounds:\n            for sound in sounds:\n                sounds[sound].stop()\n            sounds[""end""].play()\n\n        self.game_over_y = 416 + 40\n\n        self.game_over = True\n        gtimer.add(3000, lambda: self.showScores(), 1)\n\n    def gameOverScreen(self):\n        """""" Show game over screen """"""\n\n        global screen\n\n        # stop game main loop (if any)\n        self.running = False\n\n        screen.fill([0, 0, 0])\n\n        self.writeInBricks(""game"", [125, 140])\n        self.writeInBricks(""over"", [125, 220])\n        pygame.display.flip()\n\n        while 1:\n            time_passed = self.clock.tick(50)\n            for event in pygame.event.get():\n                if event.type == pygame.QUIT:\n                    quit()\n                elif event.type == pygame.KEYDOWN:\n                    if event.key == pygame.K_RETURN:\n                        self.showMenu()\n                        return\n\n    def showMenu(self):\n        """""" Show game menu\n        Redraw screen only when up or down key is pressed. When enter is pressed,\n        exit from this screen and start the game with selected number of players\n        """"""\n\n        global players, screen\n\n        # stop game main loop (if any)\n        self.running = False\n\n        # clear all timers\n        del gtimer.timers[:]\n\n        # set current stage to 0\n        self.stage = 0\n\n        del players[:]\n        # self.nextLevel()\n\n    def reloadPlayers(self):\n        """""" Init players\n        If players already exist, just reset them\n        """"""\n\n        global players\n\n        if len(players) == 0:\n            # first player\n            x = 8 * self.TILE_SIZE + (self.TILE_SIZE * 2 - 26) / 2\n            y = 24 * self.TILE_SIZE + (self.TILE_SIZE * 2 - 26) / 2\n\n            player = Player(\n                self.level, 0, [x, y], self.DIR_UP, (0, 0, 13 * 2, 13 * 2)\n            )\n            players.append(player)\n\n            # second player\n            if self.nr_of_players == 2:\n                x = 16 * self.TILE_SIZE + (self.TILE_SIZE * 2 - 26) / 2\n                y = 24 * self.TILE_SIZE + (self.TILE_SIZE * 2 - 26) / 2\n                player = Player(\n                    self.level, 0, [x, y], self.DIR_UP, (16 * 2, 0, 13 * 2, 13 * 2)\n                )\n                player.controls = [102, 119, 100, 115, 97]\n                players.append(player)\n\n        for player in players:\n            player.level = self.level\n            self.respawnPlayer(player, True)\n\n    def showScores(self):\n        """""" Show level scores """"""\n\n        global screen, sprites, players, play_sounds, sounds\n\n        # stop game main loop (if any)\n        self.running = False\n\n        # clear all timers\n        del gtimer.timers[:]\n\n        if play_sounds:\n            for sound in sounds:\n                sounds[sound].stop()\n\n        hiscore = self.loadHiscore()\n\n        # update hiscore if needed\n        if players[0].score > hiscore:\n            hiscore = players[0].score\n            self.saveHiscore(hiscore)\n        if self.nr_of_players == 2 and players[1].score > hiscore:\n            hiscore = players[1].score\n            self.saveHiscore(hiscore)\n\n        img_tanks = [\n            sprites.subsurface(32 * 2, 0, 13 * 2, 15 * 2),\n            sprites.subsurface(48 * 2, 0, 13 * 2, 15 * 2),\n            sprites.subsurface(64 * 2, 0, 13 * 2, 15 * 2),\n            sprites.subsurface(80 * 2, 0, 13 * 2, 15 * 2)\n        ]\n\n        img_arrows = [\n            sprites.subsurface(81 * 2, 48 * 2, 7 * 2, 7 * 2),\n            sprites.subsurface(88 * 2, 48 * 2, 7 * 2, 7 * 2)\n        ]\n\n        screen.fill([0, 0, 0])\n\n        # colors\n        black = pygame.Color(""black"")\n        white = pygame.Color(""white"")\n        purple = pygame.Color(127, 64, 64)\n        pink = pygame.Color(191, 160, 128)\n\n        screen.blit(self.font.render(""HI-SCORE"", False, purple), [105, 35])\n        screen.blit(self.font.render(str(hiscore), False, pink), [295, 35])\n\n        screen.blit(self.font.render(""STAGE"" + str(self.stage).rjust(3), False, white), [170, 65])\n\n        screen.blit(self.font.render(""I-PLAYER"", False, purple), [25, 95])\n\n        # player 1 global score\n        screen.blit(self.font.render(str(players[0].score).rjust(8), False, pink), [25, 125])\n\n        if self.nr_of_players == 2:\n            screen.blit(self.font.render(""II-PLAYER"", False, purple), [310, 95])\n\n            # player 2 global score\n            screen.blit(self.font.render(str(players[1].score).rjust(8), False, pink), [325, 125])\n\n        # tanks and arrows\n        for i in range(4):\n            screen.blit(img_tanks[i], [226, 160 + (i * 45)])\n            screen.blit(img_arrows[0], [206, 168 + (i * 45)])\n            if self.nr_of_players == 2:\n                screen.blit(img_arrows[1], [258, 168 + (i * 45)])\n\n        screen.blit(self.font.render(""TOTAL"", False, white), [70, 335])\n\n        # total underline\n        pygame.draw.line(screen, white, [170, 330], [307, 330], 4)\n\n        pygame.display.flip()\n\n        self.clock.tick(2)\n\n        interval = 5\n\n        # points and kills\n        for i in range(4):\n\n            # total specific tanks\n            tanks = players[0].trophies[""enemy"" + str(i)]\n\n            for n in range(tanks + 1):\n                if n > 0 and play_sounds:\n                    sounds[""score""].play()\n\n                # erase previous text\n                screen.blit(self.font.render(str(n - 1).rjust(2), False, black), [170, 168 + (i * 45)])\n                # print new number of enemies\n                screen.blit(self.font.render(str(n).rjust(2), False, white), [170, 168 + (i * 45)])\n                # erase previous text\n                screen.blit(self.font.render(str((n - 1) * (i + 1) * 100).rjust(4) + "" PTS"", False, black),\n                            [25, 168 + (i * 45)])\n                # print new total points per enemy\n                screen.blit(self.font.render(str(n * (i + 1) * 100).rjust(4) + "" PTS"", False, white),\n                            [25, 168 + (i * 45)])\n                pygame.display.flip()\n                self.clock.tick(interval)\n\n            if self.nr_of_players == 2:\n                tanks = players[1].trophies[""enemy"" + str(i)]\n\n                for n in range(tanks + 1):\n\n                    if n > 0 and play_sounds:\n                        sounds[""score""].play()\n\n                    screen.blit(self.font.render(str(n - 1).rjust(2), False, black), [277, 168 + (i * 45)])\n                    screen.blit(self.font.render(str(n).rjust(2), False, white), [277, 168 + (i * 45)])\n\n                    screen.blit(self.font.render(str((n - 1) * (i + 1) * 100).rjust(4) + "" PTS"", False, black),\n                                [325, 168 + (i * 45)])\n                    screen.blit(self.font.render(str(n * (i + 1) * 100).rjust(4) + "" PTS"", False, white),\n                                [325, 168 + (i * 45)])\n\n                    pygame.display.flip()\n                    self.clock.tick(interval)\n\n            self.clock.tick(interval)\n\n        # total tanks\n        tanks = sum([i for i in players[0].trophies.values()]) - players[0].trophies[""bonus""]\n        screen.blit(self.font.render(str(tanks).rjust(2), False, white), [170, 335])\n        if self.nr_of_players == 2:\n            tanks = sum([i for i in players[1].trophies.values()]) - players[1].trophies[""bonus""]\n            screen.blit(self.font.render(str(tanks).rjust(2), False, white), [277, 335])\n\n        pygame.display.flip()\n\n        # do nothing for 2 seconds\n        self.clock.tick(1)\n        self.clock.tick(1)\n\n        if self.game_over:\n            self.gameOverScreen()\n        else:\n            self.nextLevel()\n\n    def draw(self):\n        global screen, castle, players, enemies, bullets, bonuses\n\n        screen.fill([0, 0, 0])\n\n        self.level.draw([self.level.TILE_EMPTY, self.level.TILE_BRICK, self.level.TILE_STEEL, self.level.TILE_FROZE,\n                         self.level.TILE_WATER])\n\n        castle.draw()\n\n        for enemy in enemies:\n            enemy.draw()\n\n        for label in labels:\n            label.draw()\n\n        for player in players:\n            player.draw()\n\n        for bullet in bullets:\n            bullet.draw()\n\n        for bonus in bonuses:\n            bonus.draw()\n\n        self.level.draw([self.level.TILE_GRASS])\n\n        if self.game_over:\n            if self.game_over_y > 188:\n                self.game_over_y -= 4\n            screen.blit(self.im_game_over, [176, self.game_over_y])  # 176=(416-64)/2\n\n        self.drawSidebar()\n\n        pygame.display.flip()\n\n    def drawSidebar(self):\n\n        global screen, players, enemies\n\n        x = 416\n        y = 0\n        screen.fill([100, 100, 100], pygame.Rect([416, 0], [64, 416]))\n\n        xpos = x + 16\n        ypos = y + 16\n\n        # draw enemy lives\n        for n in range(len(self.level.enemies_left) + len(enemies)):\n            screen.blit(self.enemy_life_image, [xpos, ypos])\n            if n % 2 == 1:\n                xpos = x + 16\n                ypos += 17\n            else:\n                xpos += 17\n\n        # players\' lives\n        if pygame.font.get_init():\n            text_color = pygame.Color(\'black\')\n            for n in range(len(players)):\n                if n == 0:\n                    screen.blit(self.font.render(str(n + 1) + ""P"", False, text_color), [x + 16, y + 200])\n                    screen.blit(self.font.render(str(players[n].lives), False, text_color), [x + 31, y + 215])\n                    screen.blit(self.player_life_image, [x + 17, y + 215])\n                else:\n                    screen.blit(self.font.render(str(n + 1) + ""P"", False, text_color), [x + 16, y + 240])\n                    screen.blit(self.font.render(str(players[n].lives), False, text_color), [x + 31, y + 255])\n                    screen.blit(self.player_life_image, [x + 17, y + 255])\n\n            screen.blit(self.flag_image, [x + 17, y + 280])\n            screen.blit(self.font.render(str(self.stage), False, text_color), [x + 17, y + 312])\n\n    def drawIntroScreen(self, put_on_surface=True):\n        """""" Draw intro (menu) screen\n        @param boolean put_on_surface If True, flip display after drawing\n        @return None\n        """"""\n\n        global screen\n\n        screen.fill([0, 0, 0])\n\n        if pygame.font.get_init():\n            hiscore = self.loadHiscore()\n\n            screen.blit(self.font.render(""HI- "" + str(hiscore), True, pygame.Color(\'white\')), [170, 35])\n\n            screen.blit(self.font.render(""1 PLAYER"", True, pygame.Color(\'white\')), [165, 250])\n            screen.blit(self.font.render(""2 PLAYERS"", True, pygame.Color(\'white\')), [165, 275])\n\n            screen.blit(self.font.render(""(c) 1980 1985 NAMCO LTD."", True, pygame.Color(\'white\')), [50, 350])\n            screen.blit(self.font.render(""ALL RIGHTS RESERVED"", True, pygame.Color(\'white\')), [85, 380])\n\n        if self.nr_of_players == 1:\n            screen.blit(self.player_image, [125, 245])\n        elif self.nr_of_players == 2:\n            screen.blit(self.player_image, [125, 270])\n\n        self.writeInBricks(""battle"", [65, 80])\n        self.writeInBricks(""city"", [129, 160])\n\n        if put_on_surface:\n            pygame.display.flip()\n\n    def animateIntroScreen(self):\n        """""" Slide intro (menu) screen from bottom to top\n        If Enter key is pressed, finish animation immediately\n        @return None\n        """"""\n\n        global screen\n\n        self.drawIntroScreen(False)\n        screen_cp = screen.copy()\n\n        screen.fill([0, 0, 0])\n\n        y = 416\n        while (y > 0):\n            time_passed = self.clock.tick(50)\n            for event in pygame.event.get():\n                if event.type == pygame.KEYDOWN:\n                    if event.key == pygame.K_RETURN:\n                        y = 0\n                        break\n\n            screen.blit(screen_cp, [0, y])\n            pygame.display.flip()\n            y -= 5\n\n        screen.blit(screen_cp, [0, 0])\n        pygame.display.flip()\n\n    def chunks(self, l, n):\n        """""" Split text string in chunks of specified size\n        @param string l Input string\n        @param int n Size (number of characters) of each chunk\n        @return list\n        """"""\n        return [l[i:i + n] for i in range(0, len(l), n)]\n\n    def writeInBricks(self, text, pos):\n        """""" Write specified text in ""brick font""\n        Only those letters are available that form words ""Battle City"" and ""Game Over""\n        Both lowercase and uppercase are valid input, but output is always uppercase\n        Each letter consists of 7x7 bricks which is converted into 49 character long string\n        of 1\'s and 0\'s which in turn is then converted into hex to save some bytes\n        @return None\n        """"""\n\n        global screen, sprites\n\n        bricks = sprites.subsurface(56 * 2, 64 * 2, 8 * 2, 8 * 2)\n        brick1 = bricks.subsurface((0, 0, 8, 8))\n        brick2 = bricks.subsurface((8, 0, 8, 8))\n        brick3 = bricks.subsurface((8, 8, 8, 8))\n        brick4 = bricks.subsurface((0, 8, 8, 8))\n\n        alphabet = {\n            ""a"": ""0071b63c7ff1e3"",\n            ""b"": ""01fb1e3fd8f1fe"",\n            ""c"": ""00799e0c18199e"",\n            ""e"": ""01fb060f98307e"",\n            ""g"": ""007d860cf8d99f"",\n            ""i"": ""01f8c183060c7e"",\n            ""l"": ""0183060c18307e"",\n            ""m"": ""018fbffffaf1e3"",\n            ""o"": ""00fb1e3c78f1be"",\n            ""r"": ""01fb1e3cff3767"",\n            ""t"": ""01f8c183060c18"",\n            ""v"": ""018f1e3eef8e08"",\n            ""y"": ""019b3667860c18""\n        }\n\n        abs_x, abs_y = pos\n\n        for letter in text.lower():\n\n            binstr = """"\n            for h in self.chunks(alphabet[letter], 2):\n                binstr += str(bin(int(h, 16)))[2:].rjust(8, ""0"")\n            binstr = binstr[7:]\n\n            x, y = 0, 0\n            letter_w = 0\n            surf_letter = pygame.Surface((56, 56))\n            for j, row in enumerate(self.chunks(binstr, 7)):\n                for i, bit in enumerate(row):\n                    if bit == ""1"":\n                        if i % 2 == 0 and j % 2 == 0:\n                            surf_letter.blit(brick1, [x, y])\n                        elif i % 2 == 1 and j % 2 == 0:\n                            surf_letter.blit(brick2, [x, y])\n                        elif i % 2 == 1 and j % 2 == 1:\n                            surf_letter.blit(brick3, [x, y])\n                        elif i % 2 == 0 and j % 2 == 1:\n                            surf_letter.blit(brick4, [x, y])\n                        if x > letter_w:\n                            letter_w = x\n                    x += 8\n                x = 0\n                y += 8\n            screen.blit(surf_letter, [abs_x, abs_y])\n            abs_x += letter_w + 16\n\n    def toggleEnemyFreeze(self, freeze=True):\n        """""" Freeze/defreeze all enemies """"""\n\n        global enemies\n\n        for enemy in enemies:\n            enemy.paused = freeze\n        self.timefreeze = freeze\n\n    def loadHiscore(self):\n        """""" Load hiscore\n        Really primitive version =] If for some reason hiscore cannot be loaded, return 20000\n        @return int\n        """"""\n        filename = "".hiscore""\n        if (not os.path.isfile(filename)):\n            return 20000\n\n        f = open(filename, ""r"")\n        hiscore = int(f.read())\n\n        if hiscore > 19999 and hiscore < 1000000:\n            return hiscore\n        else:\n            print(""cheater =["")\n            return 20000\n\n    def saveHiscore(self, hiscore):\n        """""" Save hiscore\n        @return boolean\n        """"""\n        try:\n            f = open("".hiscore"", ""w"")\n        except:\n            print(""Can\'t save hi-score"")\n            return False\n        f.write(str(hiscore))\n        f.close()\n        return True\n\n    def finishLevel(self):\n        """""" Finish current level\n        Show earned scores and advance to the next stage\n        """"""\n\n        global play_sounds, sounds\n\n        if play_sounds:\n            sounds[""bg""].stop()\n\n        self.active = False\n        gtimer.add(3000, lambda: self.showScores(), 1)\n\n        print(""Stage "" + str(self.stage) + "" completed"")\n\n    def nextLevel(self):\n        """""" Start next level """"""\n\n        global castle, players, bullets, bonuses, play_sounds, sounds\n\n        del bullets[:]\n        del enemies[:]\n        del bonuses[:]\n        castle.rebuild()\n        del gtimer.timers[:]\n\n        # load level\n        self.stage += 1\n        self.level = Level(self.stage)\n        self.timefreeze = False\n\n        # set number of enemies by types (basic, fast, power, armor) according to level\n        levels_enemies = (\n            (18, 2, 0, 0), (14, 4, 0, 2), (14, 4, 0, 2), (2, 5, 10, 3), (8, 5, 5, 2),\n            (9, 2, 7, 2), (7, 4, 6, 3), (7, 4, 7, 2), (6, 4, 7, 3), (12, 2, 4, 2),\n            (5, 5, 4, 6), (0, 6, 8, 6), (0, 8, 8, 4), (0, 4, 10, 6), (0, 2, 10, 8),\n            (16, 2, 0, 2), (8, 2, 8, 2), (2, 8, 6, 4), (4, 4, 4, 8), (2, 8, 2, 8),\n            (6, 2, 8, 4), (6, 8, 2, 4), (0, 10, 4, 6), (10, 4, 4, 2), (0, 8, 2, 10),\n            (4, 6, 4, 6), (2, 8, 2, 8), (15, 2, 2, 1), (0, 4, 10, 6), (4, 8, 4, 4),\n            (3, 8, 3, 6), (6, 4, 2, 8), (4, 4, 4, 8), (0, 10, 4, 6), (0, 6, 4, 10)\n        )\n\n        if self.stage <= 35:\n            enemies_l = levels_enemies[self.stage - 1]\n        else:\n            enemies_l = levels_enemies[34]\n\n        self.level.enemies_left = [0] * enemies_l[0] + [1] * enemies_l[1] + [2] * enemies_l[2] + [3] * enemies_l[3]\n        random.shuffle(self.level.enemies_left)\n\n        if play_sounds:\n            sounds[""start""].play()\n            gtimer.add(4330, lambda: sounds[""bg""].play(-1), 1)\n\n        self.reloadPlayers()\n\n        gtimer.add(3000, lambda: self.spawnEnemy())\n\n        # if True, start ""game over"" animation\n        self.game_over = False\n\n        # if False, game will end w/o ""game over"" bussiness\n        self.running = True\n\n        # if False, players won\'t be able to do anything\n        self.active = True\n\n        self.draw()\n\n\ndef battle_city(v, lock):\n    global play_sounds\n    while True:\n        game = Game()\n        game.showMenu()\n        game.nextLevel()\n        while game.running:\n            if game.game_over == True:\n                break\n            time_passed = game.clock.tick(50)\n\n            for event in pygame.event.get():\n                if event.type == pygame.MOUSEBUTTONDOWN:\n                    pass\n                elif event.type == pygame.QUIT:\n                    quit()\n                elif event.type == pygame.KEYDOWN and not game.game_over and game.active:\n\n                    if event.key == pygame.K_q:\n                        quit()\n                    # toggle sounds\n                    elif event.key == pygame.K_m:\n                        play_sounds = not play_sounds\n                        if not play_sounds:\n                            pygame.mixer.stop()\n                        else:\n                            sounds[""bg""].play(-1)\n\n                    for player in players:\n                        if player.state == player.STATE_ALIVE:\n                            try:\n                                index = player.controls.index(event.key)\n                            except:\n                                pass\n                            else:\n                                if index == 0:\n                                    if player.fire() and play_sounds:\n                                        sounds[""fire""].play()\n                                elif index == 1:\n                                    player.pressed[0] = True\n                                elif index == 2:\n                                    player.pressed[1] = True\n                                elif index == 3:\n                                    player.pressed[2] = True\n                                elif index == 4:\n                                    player.pressed[3] = True\n                elif event.type == pygame.KEYUP and not game.game_over and game.active:\n                    for player in players:\n                        if player.state == player.STATE_ALIVE:\n                            try:\n                                index = player.controls.index(event.key)\n                            except:\n                                pass\n                            else:\n                                if index == 1:\n                                    player.pressed[0] = False\n                                elif index == 2:\n                                    player.pressed[1] = False\n                                elif index == 3:\n                                    player.pressed[2] = False\n                                elif index == 4:\n                                    player.pressed[3] = False\n\n            for player in players:\n                if player.state == player.STATE_ALIVE and not game.game_over and game.active:\n                    with lock:\n                        if v.value == 1:\n                            player.move(game.DIR_UP)\n                        elif v.value == 4:\n                            player.move(game.DIR_RIGHT)\n                        elif v.value == 2:\n                            player.move(game.DIR_DOWN)\n                        elif v.value == 3:\n                            player.move(game.DIR_LEFT)\n                        elif v.value == 5:\n                            player.fire()\n                            if play_sounds and player.active_bullets == 0:\n                                sounds[""fire""].play()\n                player.update(time_passed)\n\n            for enemy in enemies:\n                if enemy.state == enemy.STATE_DEAD and not game.game_over and game.active:\n                    enemies.remove(enemy)\n                    if len(game.level.enemies_left) == 0 and len(enemies) == 0:\n                        game.finishLevel()\n                else:\n                    enemy.update(time_passed)\n\n            if not game.game_over and game.active:\n                for player in players:\n                    if player.state == player.STATE_ALIVE:\n                        if player.bonus != None and player.side == player.SIDE_PLAYER:\n                            game.triggerBonus(bonus, player)\n                            player.bonus = None\n                    elif player.state == player.STATE_DEAD:\n                        game.superpowers = 0\n                        player.lives -= 1\n                        if player.lives > 0:\n                            game.respawnPlayer(player)\n                        else:\n                            game.gameOver()\n\n            for bullet in bullets:\n                if bullet.state == bullet.STATE_REMOVED:\n                    bullets.remove(bullet)\n                else:\n                    bullet.update()\n\n            for bonus in bonuses:\n                if bonus.active == False:\n                    bonuses.remove(bonus)\n\n            for label in labels:\n                if not label.active:\n                    labels.remove(label)\n\n            if not game.game_over:\n                if not castle.active:\n                    game.gameOver()\n\n            gtimer.update(time_passed)\n\n            game.draw()\n\n\nif __name__ == ""__main__"":\n    battle_city()\n'"
src/config.py,0,"b'IS_FULLSCREEN = False\nWIDTH = 480\nHEIGHT = 416\nHAND_GESTURES = [""Open"", ""Closed""]\nBLUE = (255, 0, 0)\nGREEN = (0, 255, 0)\nRED = (0, 0, 255)\nORANGE = (0,128,255)\nYELLOW = (0,255,255)\nMAGENTA = (255,0,255)\nCYAN = (255,255,0)\nPURPLE = (128,0,128)'"
src/utils.py,5,"b'""""""\n@author: Viet Nguyen <nhviet1009@gmail.com>\n""""""\nimport numpy as np\nfrom nes_py.wrappers import JoypadSpace\nimport gym\nimport gym_super_mario_bros\nfrom gym_super_mario_bros.actions import COMPLEX_MOVEMENT\nfrom gym_chrome_dino.utils.wrappers import make_dino\nimport tensorflow as tf\nfrom time import sleep\nfrom src.config import HAND_GESTURES\n\n\ndef is_in_triangle(point, triangle):\n    # barycentric coordinate system\n    x, y = point\n    (xa, ya), (xb, yb), (xc, yc) = triangle\n    a = ((yb - yc)*(x - xc) + (xc - xb)*(y - yc)) / ((yb - yc)*(xa - xc) + (xc - xb)*(ya - yc))\n    b = ((yc - ya) * (x - xc) + (xa - xc) * (y - yc)) / ((yb - yc) * (xa - xc) + (xc - xb) * (ya - yc))\n    c = 1 - a - b\n    if 0 <= a <= 1 and 0 <= b <= 1 and 0 <= c <= 1:\n        return True\n    else:\n        return False\n\n\ndef load_graph(path):\n    detection_graph = tf.Graph()\n    with detection_graph.as_default():\n        graph_def = tf.GraphDef()\n        with tf.gfile.GFile(path, \'rb\') as fid:\n            graph_def.ParseFromString(fid.read())\n            tf.import_graph_def(graph_def, name=\'\')\n        sess = tf.Session(graph=detection_graph)\n    return detection_graph, sess\n\n\ndef detect_hands(image, graph, sess):\n    input_image = graph.get_tensor_by_name(\'image_tensor:0\')\n    detection_boxes = graph.get_tensor_by_name(\'detection_boxes:0\')\n    detection_scores = graph.get_tensor_by_name(\'detection_scores:0\')\n    detection_classes = graph.get_tensor_by_name(\'detection_classes:0\')\n    image = image[None, :, :, :]\n    boxes, scores, classes = sess.run([detection_boxes, detection_scores, detection_classes],\n                                      feed_dict={input_image: image})\n    return np.squeeze(boxes), np.squeeze(scores), np.squeeze(classes)\n\n\ndef predict(boxes, scores, classes, threshold, width, height, num_hands=2):\n    count = 0\n    results = {}\n    for box, score, class_ in zip(boxes[:num_hands], scores[:num_hands], classes[:num_hands]):\n        if score > threshold:\n            y_min = int(box[0] * height)\n            x_min = int(box[1] * width)\n            y_max = int(box[2] * height)\n            x_max = int(box[3] * width)\n            category = HAND_GESTURES[int(class_) - 1]\n            results[count] = [x_min, x_max, y_min, y_max, category]\n            count += 1\n    return results\n\n\ndef mario(v, lock):\n    env = gym_super_mario_bros.make(\'SuperMarioBros-1-1-v0\')\n    env = JoypadSpace(env, COMPLEX_MOVEMENT)\n    done = True\n    while True:\n        if done:\n            env.reset()\n            with lock:\n                v.value = 0\n        with lock:\n            u = v.value\n        _, _, done, _ = env.step(u)\n        env.render()\n        sleep(0.01)\n\ndef dinosaur(v,lock):\n    env = gym.make(\'ChromeDino-v0\')\n    env = make_dino(env, timer=True, frame_stack=True)\n    done = True\n    while True:\n        if done:\n            env.reset()\n            with lock:\n                v.value = 0\n        with lock:\n            u = v.value\n        _, _, done, _ = env.step(u)\n'"
