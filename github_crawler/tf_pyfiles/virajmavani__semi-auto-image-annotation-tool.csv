file_path,api_count,code
config.py,0,"b""labels_to_names = {0: 'person', 1: 'bicycle', 2: 'car', 3: 'motorcycle', 4: 'airplane', 5: 'bus', 6: 'train',\n                   7: 'truck', 8: 'boat', 9: 'traffic light', 10: 'fire hydrant', 11: 'stop sign', 12: 'parking meter',\n                   13: 'bench', 14: 'bird', 15: 'cat', 16: 'dog', 17: 'horse', 18: 'sheep', 19: 'cow', 20: 'elephant',\n                   21: 'bear', 22: 'zebra', 23: 'giraffe', 24: 'backpack', 25: 'umbrella', 26: 'handbag', 27: 'tie',\n                   28: 'suitcase', 29: 'frisbee', 30: 'skis', 31: 'snowboard', 32: 'sports ball', 33: 'kite',\n                   34: 'baseball bat', 35: 'baseball glove', 36: 'skateboard', 37: 'surfboard', 38: 'tennis racket',\n                   39: 'bottle', 40: 'wine glass', 41: 'cup', 42: 'fork', 43: 'knife', 44: 'spoon', 45: 'bowl',\n                   46: 'banana', 47: 'apple', 48: 'sandwich', 49: 'orange', 50: 'broccoli', 51: 'carrot', 52: 'hot dog',\n                   53: 'pizza', 54: 'donut', 55: 'cake', 56: 'chair', 57: 'couch', 58: 'potted plant', 59: 'bed',\n                   60: 'dining table', 61: 'toilet', 62: 'tv', 63: 'laptop', 64: 'mouse', 65: 'remote', 66: 'keyboard',\n                   67: 'cell phone', 68: 'microwave', 69: 'oven', 70: 'toaster', 71: 'sink', 72: 'refrigerator',\n                   73: 'book', 74: 'clock', 75: 'vase', 76: 'scissors', 77: 'teddy bear', 78: 'hair drier',\n                   79: 'toothbrush'}\nCOLORS = ['red', 'blue', 'yellow', 'pink', 'cyan', 'green', 'black']\n"""
main.py,7,"b'""""""\nCopyright {2018} {Viraj Mavani}\n   Licensed under the Apache License, Version 2.0 (the ""License"");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n""""""\n\nfrom tkinter import *\nfrom tkinter import filedialog\nfrom PIL import Image, ImageTk\nimport keras\nfrom keras_retinanet import models\nfrom keras_retinanet.utils.image import preprocess_image\n\n# import miscellaneous modules\nimport os\nimport numpy as np\nimport tensorflow as tf\nimport config\nimport tf_config\nimport math\nfrom pascal_voc_writer import Writer\n\n# make sure the file is inside semi-auto-image-annotation-tool-master\nimport pathlib\n# cur_path = pathlib.Path(__file__).parent.absolute()\ncur_path = pathlib.Path(__file__).parent.absolute().as_posix()\nsys.path.append(cur_path)\nos.chdir(cur_path)\n\n\nclass MainGUI:\n    def __init__(self, master):\n\n        # to choose between keras or tensorflow models\n        self.keras_ = 1  # default\n        self.tensorflow_ = 0\n        self.models_dir = \'\'  # gets updated as per user choice\n        self.model_path = \'\'\n        self.parent = master\n        self.parent.title(""Semi Automatic Image Annotation Tool"")\n        self.frame = Frame(self.parent)\n        self.frame.pack(fill=BOTH, expand=1)\n        self.parent.resizable(width=False, height=False)\n\n        # Initialize class variables\n        self.img = None\n        self.tkimg = None\n        self.imageDir = \'\'\n        self.imageDirPathBuffer = \'\'\n        self.imageList = []\n        self.imageTotal = 0\n        self.imageCur = 0\n        self.cur = 0\n        self.bboxIdList = []\n        self.bboxList = []\n        self.bboxPointList = []\n        self.o1 = None\n        self.o2 = None\n        self.o3 = None\n        self.o4 = None\n        self.bboxId = None\n        self.currLabel = None\n        self.editbboxId = None\n        self.currBboxColor = None\n        self.zoomImgId = None\n        self.zoomImg = None\n        self.zoomImgCrop = None\n        self.tkZoomImg = None\n        self.hl = None\n        self.vl = None\n        self.editPointId = None\n        self.filename = None\n        self.filenameBuffer = None\n        self.objectLabelList = []\n        self.EDIT = False\n        self.autoSuggest = StringVar()\n        self.writer = None\n        self.thresh = 0.5\n        self.org_h = 0\n        self.org_w = 0\n        # initialize mouse state\n        self.STATE = {\'x\': 0, \'y\': 0}\n        self.STATE_COCO = {\'click\': 0}\n\n        # initialize annotation file\n        self.anno_filename = \'annotations.csv\'\n        self.annotation_file = open(\'annotations/\' + self.anno_filename, \'w+\')\n        self.annotation_file.write("""")\n        self.annotation_file.close()\n\n        # ------------------ GUI ---------------------\n\n        # Control Panel\n        self.ctrlPanel = Frame(self.frame)\n        self.ctrlPanel.grid(row=0, column=0, sticky=W + N)\n        self.openBtn = Button(self.ctrlPanel, text=\'Open\', command=self.open_image)\n        self.openBtn.grid(columnspan=2, sticky=W + E)\n        self.openDirBtn = Button(self.ctrlPanel, text=\'Open Dir\', command=self.open_image_dir)\n        self.openDirBtn.grid(columnspan=2, sticky = W + E)\n\n        self.nextBtn = Button(self.ctrlPanel, text=\'Next -->\', command=self.open_next)\n        self.nextBtn.grid(columnspan=2, sticky=W + E)\n        self.previousBtn = Button(self.ctrlPanel, text=\'<-- Previous\', command=self.open_previous)\n        self.previousBtn.grid(columnspan=2, sticky=W + E)\n        self.saveBtn = Button(self.ctrlPanel, text=\'Save\', command=self.save)\n        self.saveBtn.grid(columnspan=2, sticky=W + E)\n        self.autoManualLabel = Label(self.ctrlPanel, text=""Suggestion Mode"")\n        self.autoManualLabel.grid(columnspan=2, sticky=W + E)\n        self.radioBtnAuto = Radiobutton(self.ctrlPanel, text=""Auto"", variable=self.autoSuggest, value=1)\n        self.radioBtnAuto.grid(row=7, column=0, sticky=W + E)\n        self.radioBtnManual = Radiobutton(self.ctrlPanel, text=""Manual"", variable=self.autoSuggest, value=2)\n        self.radioBtnManual.grid(row=7, column=1, sticky=W + E)\n        self.semiAutoBtn = Button(self.ctrlPanel, text=""Detect"", command=self.automate)\n        self.semiAutoBtn.grid(columnspan=2, sticky=W + E)\n        self.disp = Label(self.ctrlPanel, text=\'Coordinates:\')\n        self.disp.grid(columnspan=2, sticky=W + E)\n\n        self.mb = Menubutton(self.ctrlPanel, text=""COCO Classes for Suggestions"", relief=RAISED)\n        self.mb.grid(columnspan=2, sticky=W + E)\n        self.mb.menu = Menu(self.mb, tearoff=0)\n        self.mb[""menu""] = self.mb.menu\n\n        self.addCocoBtn = Button(self.ctrlPanel, text=""+"", command=self.add_labels_coco)\n        self.addCocoBtn.grid(columnspan=2, sticky=W + E)\n        self.addCocoBtnAllClasses = Button(self.ctrlPanel, text=""Add All Classes"", command=self.add_all_classes)\n        self.addCocoBtnAllClasses.grid(columnspan=2, sticky=W + E)\n\n        # options to add different models\n        self.mb1 = Menubutton(self.ctrlPanel, text=""Select models from here"", relief=RAISED)\n        self.mb1.grid(columnspan=2, sticky=W + E)\n        self.mb1.menu = Menu(self.mb1, tearoff=0)\n        self.mb1[""menu""] = self.mb1.menu\n\n        self.addModelBtn = Button(self.ctrlPanel, text=""Add model"", command=self.add_model)\n        self.addModelBtn.grid(columnspan=2, sticky=W + E)\n\n        self.zoomPanelLabel = Label(self.ctrlPanel, text=""Precision View Panel"")\n        self.zoomPanelLabel.grid(columnspan=2, sticky=W + E)\n        self.zoomcanvas = Canvas(self.ctrlPanel, width=150, height=150)\n        self.zoomcanvas.grid(columnspan=2, sticky=W + E)\n\n        # Image Editing Region\n        self.canvas = Canvas(self.frame, width=500, height=500)\n        self.canvas.grid(row=0, column=1, sticky=W + N)\n        self.canvas.bind(""<Button-1>"", self.mouse_click)\n        self.canvas.bind(""<Motion>"", self.mouse_move, ""+"")\n        self.canvas.bind(""<B1-Motion>"", self.mouse_drag)\n        self.canvas.bind(""<ButtonRelease-1>"", self.mouse_release)\n        self.parent.bind(""<Key-Left>"", self.open_previous)\n        self.parent.bind(""<Key-Right>"", self.open_next)\n        self.parent.bind(""Escape"", self.cancel_bbox)\n\n        # Labels and Bounding Box Lists Panel\n        self.listPanel = Frame(self.frame)\n        self.listPanel.grid(row=0, column=2, sticky=W + N)\n        self.listBoxNameLabel = Label(self.listPanel, text=""List of Objects"").pack(fill=X, side=TOP)\n        self.objectListBox = Listbox(self.listPanel, width=40)\n        self.objectListBox.pack(fill=X, side=TOP)\n        self.delObjectBtn = Button(self.listPanel, text=""Delete"", command=self.del_bbox)\n        self.delObjectBtn.pack(fill=X, side=TOP)\n        self.clearAllBtn = Button(self.listPanel, text=""Clear All"", command=self.clear_bbox)\n        self.clearAllBtn.pack(fill=X, side=TOP)\n        self.classesNameLabel = Label(self.listPanel, text=""Classes"").pack(fill=X, side=TOP)\n        self.textBox = Entry(self.listPanel, text=""Enter label"")\n        self.textBox.pack(fill=X, side=TOP)\n        self.addLabelBtn = Button(self.listPanel, text=""+"", command=self.add_label).pack(fill=X, side=TOP)\n        self.delLabelBtn = Button(self.listPanel, text=""-"", command=self.del_label).pack(fill=X, side=TOP)\n\n        self.labelListBox = Listbox(self.listPanel)\n        self.labelListBox.pack(fill=X, side=TOP)\n\n        self.addThresh = Label(self.listPanel, text=""Threshold"").pack(fill=X, side=TOP)\n        self.textBoxTh = Entry(self.listPanel, text=""Enter threshold value"")\n        self.textBoxTh.pack(fill=X, side=TOP)\n        self.enterthresh = Button(self.listPanel, text=""Set"", command=self.changeThresh).pack(fill=X, side=TOP)\n\n        if self.keras_:\n            self.cocoLabels = config.labels_to_names.values()\n        else:\n            self.cocoLabels = tf_config.labels_to_names.values()\n\n        self.cocoIntVars = []\n        for idxcoco, label_coco in enumerate(self.cocoLabels):\n            self.cocoIntVars.append(IntVar())\n            self.mb.menu.add_checkbutton(label=label_coco, variable=self.cocoIntVars[idxcoco])\n        # print(self.cocoIntVars)\n\n        self.modelIntVars = []\n        for idxmodel, modelname in enumerate(self.available_models()):\n            self.modelIntVars.append(IntVar())\n            self.mb1.menu.add_checkbutton(label=modelname, variable=self.modelIntVars[idxmodel])\n\n        # STATUS BAR\n        self.statusBar = Frame(self.frame, width=500)\n        self.statusBar.grid(row=1, column=1, sticky=W + N)\n        self.processingLabel = Label(self.statusBar, text=""                      "")\n        self.processingLabel.pack(side=""left"", fill=X)\n        self.imageIdxLabel = Label(self.statusBar, text=""                      "")\n        self.imageIdxLabel.pack(side=""right"", fill=X)\n\n    def get_session(self):\n        config = tf.ConfigProto()\n        config.gpu_options.allow_growth = True\n        return tf.Session(config=config)\n\n    def available_models(self):\n        self.models_dir = os.path.join(cur_path, \'snapshots\')\n        # only for keras and tf\n        model_categ = [dir_ for dir_ in os.listdir(self.models_dir) if os.path.isdir(os.path.join(self.models_dir, dir_))]\n        # creating all model options list\n        model_names = []\n        for categ in model_categ:\n            for name in os.listdir(os.path.join(self.models_dir , categ)):\n                model_names.append(os.path.join(categ,name))\n        return model_names\n\n\n    def changeThresh(self):\n        if(float(self.textBoxTh.get()) >0 and float(self.textBoxTh.get()) <1):\n            self.thresh = float(self.textBoxTh.get())\n\n    def open_image(self):\n        self.filename = filedialog.askopenfilename(title=""Select Image"", filetypes=((""jpeg files"", ""*.jpg""),\n                                                                                    (""all files"", ""*.*"")))\n        if not self.filename:\n            return None\n        self.filenameBuffer = self.filename\n        self.load_image(self.filenameBuffer)\n\n    def open_image_dir(self):\n        self.imageDir = filedialog.askdirectory(title=""Select Dataset Directory"")\n        if not self.imageDir:\n            return None\n        self.imageList = os.listdir(self.imageDir)\n        self.imageList = sorted(self.imageList)\n        self.imageTotal = len(self.imageList)\n        self.filename = None\n        self.imageDirPathBuffer = self.imageDir\n        self.load_image(self.imageDirPathBuffer + \'/\' + self.imageList[self.cur])\n\n    def open_video_file(self):\n        pass\n\n    def load_image(self, file):\n        self.img = Image.open(file)\n        self.imageCur = self.cur + 1\n        self.imageIdxLabel.config(text=\'  ||   Image Number: %d / %d\' % (self.imageCur, self.imageTotal))\n        # Resize to Pascal VOC format\n        w, h = self.img.size\n        self.org_w, self.org_h = self.img.size\n        if w >= h:\n            baseW = 500\n            wpercent = (baseW / float(w))\n            hsize = int((float(h) * float(wpercent)))\n            self.img = self.img.resize((baseW, hsize), Image.BICUBIC)\n        else:\n            baseH = 500\n            wpercent = (baseH / float(h))\n            wsize = int((float(w) * float(wpercent)))\n            self.img = self.img.resize((wsize, baseH), Image.BICUBIC)\n\n        self.tkimg = ImageTk.PhotoImage(self.img)\n        self.canvas.create_image(0, 0, image=self.tkimg, anchor=NW)\n        self.clear_bbox()\n\n    def open_next(self, event=None):\n        self.save()\n        if self.cur < len(self.imageList):\n            self.cur += 1\n            self.load_image(self.imageDirPathBuffer + \'/\' + self.imageList[self.cur])\n        self.processingLabel.config(text=""                      "")\n        self.processingLabel.update_idletasks()\n        if self.autoSuggest.get() == str(1):\n            self.automate()\n\n    def open_previous(self, event=None):\n        self.save()\n        if self.cur > 0:\n            self.cur -= 1\n            self.load_image(self.imageDirPathBuffer + \'/\' + self.imageList[self.cur])\n        self.processingLabel.config(text=""                      "")\n        self.processingLabel.update_idletasks()\n        if self.autoSuggest.get() == str(1):\n            self.automate()\n\n    def save(self):\n        if self.filenameBuffer is None:\n            w, h = self.img.size\n            self.writer = Writer(os.path.join(self.imageDirPathBuffer , self.imageList[self.cur]), w, h)\n            self.annotation_file = open(\'annotations/\' + self.anno_filename, \'a\')\n            for idx, item in enumerate(self.bboxList):\n                x1, y1, x2, y2 = self.bboxList[idx]\n                self.writer.addObject(str(self.objectLabelList[idx]), x1, y1, x2, y2)\n                self.annotation_file.write(self.imageDirPathBuffer + \'/\' + self.imageList[self.cur] + \',\' +\n                                           \',\'.join(map(str, self.bboxList[idx])) + \',\' + str(self.objectLabelList[idx])\n                                           + \'\\n\')\n            self.annotation_file.close()\n            baseName = os.path.splitext(self.imageList[self.cur])[0]\n            save_dir = \'annotations/annotations_voc/\'\n            save_path = save_dir + baseName + \'.xml\'\n            if(not os.path.exists(save_dir)):\n                os.mkdir(save_dir)\n\n            self.writer.save(save_path)\n            self.writer = None\n        else:\n            w, h = self.img.size\n            self.writer = Writer(self.filenameBuffer, w, h)\n            self.annotation_file = open(\'annotations/\' + self.anno_filename, \'a\')\n            for idx, item in enumerate(self.bboxList):\n                x1, y1, x2, y2 = self.bboxList[idx]\n                self.writer.addObject(str(self.objectLabelList[idx]), x1, y1, x2, y2)\n                self.annotation_file.write(self.filenameBuffer + \',\' + \',\'.join(map(str, self.bboxList[idx])) + \',\'\n                                           + str(self.objectLabelList[idx]) + \'\\n\')\n            self.annotation_file.close()\n            baseName = os.path.splitext(self.imageList[self.cur])[0]\n            self.writer.save(\'annotations/annotations_voc/\' + baseName + \'.xml\')\n            self.writer = None\n\n    def mouse_click(self, event):\n        # Check if Updating BBox\n        if self.canvas.find_enclosed(event.x - 5, event.y - 5, event.x + 5, event.y + 5):\n            self.EDIT = True\n            self.editPointId = int(self.canvas.find_enclosed(event.x - 5, event.y - 5, event.x + 5, event.y + 5)[0])\n        else:\n            self.EDIT = False\n\n        # Set the initial point\n        if self.EDIT:\n            idx = self.bboxPointList.index(self.editPointId)\n            self.editbboxId = self.bboxIdList[math.floor(idx/4.0)]\n            self.bboxId = self.editbboxId\n            pidx = self.bboxIdList.index(self.editbboxId)\n            pidx = pidx * 4\n            self.o1 = self.bboxPointList[pidx]\n            self.o2 = self.bboxPointList[pidx + 1]\n            self.o3 = self.bboxPointList[pidx + 2]\n            self.o4 = self.bboxPointList[pidx + 3]\n            if self.editPointId == self.o1:\n                a, b, c, d = self.canvas.coords(self.o3)\n            elif self.editPointId == self.o2:\n                a, b, c, d = self.canvas.coords(self.o4)\n            elif self.editPointId == self.o3:\n                a, b, c, d = self.canvas.coords(self.o1)\n            elif self.editPointId == self.o4:\n                a, b, c, d = self.canvas.coords(self.o2)\n            self.STATE[\'x\'], self.STATE[\'y\'] = int((a+c)/2), int((b+d)/2)\n        else:\n            self.STATE[\'x\'], self.STATE[\'y\'] = event.x, event.y\n\n    def mouse_drag(self, event):\n        self.mouse_move(event)\n        if self.bboxId:\n            self.currBboxColor = self.canvas.itemcget(self.bboxId, ""outline"")\n            self.canvas.delete(self.bboxId)\n            self.canvas.delete(self.o1)\n            self.canvas.delete(self.o2)\n            self.canvas.delete(self.o3)\n            self.canvas.delete(self.o4)\n        if self.EDIT:\n            self.bboxId = self.canvas.create_rectangle(self.STATE[\'x\'], self.STATE[\'y\'],\n                                                       event.x, event.y,\n                                                       width=2,\n                                                       outline=self.currBboxColor)\n        else:\n            self.currBboxColor = config.COLORS[len(self.bboxList) % len(config.COLORS)]\n            self.bboxId = self.canvas.create_rectangle(self.STATE[\'x\'], self.STATE[\'y\'],\n                                                       event.x, event.y,\n                                                       width=2,\n                                                       outline=self.currBboxColor)\n\n    def mouse_move(self, event):\n        self.disp.config(text=\'x: %d, y: %d\' % (event.x, event.y))\n        self.zoom_view(event)\n        if self.tkimg:\n            # Horizontal and Vertical Line for precision\n            if self.hl:\n                self.canvas.delete(self.hl)\n            self.hl = self.canvas.create_line(0, event.y, self.tkimg.width(), event.y, width=2)\n            if self.vl:\n                self.canvas.delete(self.vl)\n            self.vl = self.canvas.create_line(event.x, 0, event.x, self.tkimg.height(), width=2)\n            # elif (event.x, event.y) in self.bboxBRPointList:\n            #     pass\n\n    def mouse_release(self, event):\n        try:\n            labelidx = self.labelListBox.curselection()\n            self.currLabel = self.labelListBox.get(labelidx)\n        except:\n            pass\n        if self.EDIT:\n            self.update_bbox()\n            self.EDIT = False\n        x1, x2 = min(self.STATE[\'x\'], event.x), max(self.STATE[\'x\'], event.x)\n        y1, y2 = min(self.STATE[\'y\'], event.y), max(self.STATE[\'y\'], event.y)\n        self.bboxList.append((x1, y1, x2, y2))\n        o1 = self.canvas.create_oval(x1 - 3, y1 - 3, x1 + 3, y1 + 3, fill=""red"")\n        o2 = self.canvas.create_oval(x2 - 3, y1 - 3, x2 + 3, y1 + 3, fill=""red"")\n        o3 = self.canvas.create_oval(x2 - 3, y2 - 3, x2 + 3, y2 + 3, fill=""red"")\n        o4 = self.canvas.create_oval(x1 - 3, y2 - 3, x1 + 3, y2 + 3, fill=""red"")\n        self.bboxPointList.append(o1)\n        self.bboxPointList.append(o2)\n        self.bboxPointList.append(o3)\n        self.bboxPointList.append(o4)\n        self.bboxIdList.append(self.bboxId)\n        self.bboxId = None\n        self.objectLabelList.append(str(self.currLabel))\n        self.objectListBox.insert(END, \'(%d, %d) -> (%d, %d)\' % (x1, y1, x2, y2) + \': \' + str(self.currLabel))\n        self.objectListBox.itemconfig(len(self.bboxIdList) - 1,\n                                      fg=self.currBboxColor)\n        self.currLabel = None\n\n    def zoom_view(self, event):\n        try:\n            if self.zoomImgId:\n                self.zoomcanvas.delete(self.zoomImgId)\n            self.zoomImg = self.img.copy()\n            self.zoomImgCrop = self.zoomImg.crop(((event.x - 25), (event.y - 25), (event.x + 25), (event.y + 25)))\n            self.zoomImgCrop = self.zoomImgCrop.resize((150, 150))\n            self.tkZoomImg = ImageTk.PhotoImage(self.zoomImgCrop)\n            self.zoomImgId = self.zoomcanvas.create_image(0, 0, image=self.tkZoomImg, anchor=NW)\n            hl = self.zoomcanvas.create_line(0, 75, 150, 75, width=2)\n            vl = self.zoomcanvas.create_line(75, 0, 75, 150, width=2)\n        except:\n            pass\n\n    def update_bbox(self):\n        idx = self.bboxIdList.index(self.editbboxId)\n        self.bboxIdList.pop(idx)\n        self.bboxList.pop(idx)\n        self.objectListBox.delete(idx)\n        self.currLabel = self.objectLabelList[idx]\n        self.objectLabelList.pop(idx)\n        idx = idx*4\n        self.canvas.delete(self.bboxPointList[idx])\n        self.canvas.delete(self.bboxPointList[idx+1])\n        self.canvas.delete(self.bboxPointList[idx+2])\n        self.canvas.delete(self.bboxPointList[idx+3])\n        self.bboxPointList.pop(idx)\n        self.bboxPointList.pop(idx)\n        self.bboxPointList.pop(idx)\n        self.bboxPointList.pop(idx)\n\n    def cancel_bbox(self, event):\n        if self.STATE[\'click\'] == 1:\n            if self.bboxId:\n                self.canvas.delete(self.bboxId)\n                self.bboxId = None\n                self.STATE[\'click\'] = 0\n\n    def del_bbox(self):\n        sel = self.objectListBox.curselection()\n        if len(sel) != 1:\n            return\n        idx = int(sel[0])\n        self.canvas.delete(self.bboxIdList[idx])\n        self.canvas.delete(self.bboxPointList[idx * 4])\n        self.canvas.delete(self.bboxPointList[(idx * 4) + 1])\n        self.canvas.delete(self.bboxPointList[(idx * 4) + 2])\n        self.canvas.delete(self.bboxPointList[(idx * 4) + 3])\n        self.bboxPointList.pop(idx * 4)\n        self.bboxPointList.pop(idx * 4)\n        self.bboxPointList.pop(idx * 4)\n        self.bboxPointList.pop(idx * 4)\n        self.bboxIdList.pop(idx)\n        self.bboxList.pop(idx)\n        self.objectLabelList.pop(idx)\n        self.objectListBox.delete(idx)\n\n    def clear_bbox(self):\n        for idx in range(len(self.bboxIdList)):\n            self.canvas.delete(self.bboxIdList[idx])\n        for idx in range(len(self.bboxPointList)):\n            self.canvas.delete(self.bboxPointList[idx])\n        self.objectListBox.delete(0, len(self.bboxList))\n        self.bboxIdList = []\n        self.bboxList = []\n        self.objectLabelList = []\n        self.bboxPointList = []\n\n    def add_label(self):\n        if self.textBox.get() is not \'\':\n            curr_label_list = self.labelListBox.get(0, END)\n            curr_label_list = list(curr_label_list)\n            if self.textBox.get() not in curr_label_list:\n                self.labelListBox.insert(END, str(self.textBox.get()))\n            self.textBox.delete(0, \'end\')\n\n    def del_label(self):\n        labelidx = self.labelListBox.curselection()\n        self.labelListBox.delete(labelidx)\n\n    def add_model(self):\n        for listidxmodel, list_model_name in enumerate(self.available_models()):\n            if(self.modelIntVars[listidxmodel].get()):\n                # check which model is it keras or tensorflow\n                self.model_path = os.path.join(self.models_dir,list_model_name)\n                # if its Tensorflow model then modify path\n                if(\'keras\' in list_model_name):\n                    self.keras_ = 1\n                    self.tensorflow_ = 0\n                elif(\'tensorflow\' in list_model_name):\n                    self.model_path = os.path.join(self.model_path,\'frozen_inference_graph.pb\')\n                    self.keras_ = 0\n                    self.tensorflow_ = 1\n                    # change cocoLabels corresponding to tensorflow\n                    self.cocoLabels = tf_config.labels_to_names.values()\n                break\n\n\n    def add_labels_coco(self):\n        for listidxcoco, list_label_coco in enumerate(self.cocoLabels):\n            if self.cocoIntVars[listidxcoco].get():\n                curr_label_list = self.labelListBox.get(0, END)\n                curr_label_list = list(curr_label_list)\n                if list_label_coco not in curr_label_list:\n                    self.labelListBox.insert(END, str(list_label_coco))\n\n    def add_all_classes(self):\n        for listidxcoco, list_label_coco in enumerate(self.cocoLabels):\n            # if self.cocoIntVars[listidxcoco].get():\n            curr_label_list = self.labelListBox.get(0, END)\n            curr_label_list = list(curr_label_list)\n            if list_label_coco not in curr_label_list:\n                self.labelListBox.insert(END, str(list_label_coco))\n\n    def automate(self):\n        self.processingLabel.config(text=""Processing     "")\n        self.processingLabel.update_idletasks()\n        open_cv_image = np.array(self.img)\n        # Convert RGB to BGR\n        opencvImage = open_cv_image[:, :, ::-1].copy()\n        # if tensorflow\n        if self.tensorflow_ :\n            detection_graph = tf.Graph()\n            with detection_graph.as_default():\n                od_graph_def = tf.GraphDef()\n                with tf.gfile.GFile(self.model_path, \'rb\') as fid:\n                    serialized_graph = fid.read()\n                    od_graph_def.ParseFromString(serialized_graph)\n                    tf.import_graph_def(od_graph_def, name=\'\')\n\n                sess = tf.Session(graph=detection_graph)\n\n            image_tensor = detection_graph.get_tensor_by_name(\'image_tensor:0\')\n            detection_boxes = detection_graph.get_tensor_by_name(\'detection_boxes:0\')\n            detection_scores = detection_graph.get_tensor_by_name(\'detection_scores:0\')\n            detection_classes = detection_graph.get_tensor_by_name(\'detection_classes:0\')\n            num_detections = detection_graph.get_tensor_by_name(\'num_detections:0\')\n\n            image_expanded = np.expand_dims(opencvImage, axis=0)\n            (boxes, scores, labels, num) = sess.run(\n            [detection_boxes, detection_scores, detection_classes, num_detections],\n            feed_dict={image_tensor: image_expanded})\n            config_labels = tf_config.labels_to_names\n            m_name = os.path.split((os.path.split(self.model_path)[0]))[1]\n\n        else:\n            keras.backend.tensorflow_backend.set_session(self.get_session())\n            model_path = self.model_path\n            model = models.load_model(model_path, backbone_name=\'resnet50\')\n            image = preprocess_image(opencvImage)\n            boxes, scores, labels = model.predict_on_batch(np.expand_dims(image, axis=0))\n            config_labels = config.labels_to_names\n            m_name = os.path.split(self.model_path)[1]\n        for idx, (box, label, score) in enumerate(zip(boxes[0], labels[0], scores[0])):\n            curr_label_list = self.labelListBox.get(0, END)\n            curr_label_list = list(curr_label_list)\n            if score < self.thresh:\n                continue\n\n            if config_labels[label] not in curr_label_list:\n                continue\n\n            b = box\n            # only if using tf models as keras and tensorflow have different coordinate order\n            if(self.tensorflow_):\n                w, h = self.img.size\n                (b[0],b[1],b[2],b[3]) = (b[1]*w, b[0]*h, b[3]*w, b[2]*h)\n            b = b.astype(int)\n            self.bboxId = self.canvas.create_rectangle(b[0], b[1],\n                                                       b[2], b[3],\n                                                       width=2,\n                                                       outline=config.COLORS[len(self.bboxList) % len(config.COLORS)])\n            self.bboxList.append((b[0], b[1], b[2], b[3]))\n            o1 = self.canvas.create_oval(b[0] - 3, b[1] - 3, b[0] + 3, b[1] + 3, fill=""red"")\n            o2 = self.canvas.create_oval(b[2] - 3, b[1] - 3, b[2] + 3, b[1] + 3, fill=""red"")\n            o3 = self.canvas.create_oval(b[2] - 3, b[3] - 3, b[2] + 3, b[3] + 3, fill=""red"")\n            o4 = self.canvas.create_oval(b[0] - 3, b[3] - 3, b[0] + 3, b[3] + 3, fill=""red"")\n            self.bboxPointList.append(o1)\n            self.bboxPointList.append(o2)\n            self.bboxPointList.append(o3)\n            self.bboxPointList.append(o4)\n            self.bboxIdList.append(self.bboxId)\n            self.bboxId = None\n            self.objectLabelList.append(str(config_labels[label]))\n            self.objectListBox.insert(END, \'(%d, %d) -> (%d, %d)\' % (b[0], b[1], b[2], b[3]) + \': \' +\n                                  str(config_labels[label])+\' \'+str(int(score*100))+\'%\'\n                                      +\' \'+ m_name)\n            self.objectListBox.itemconfig(len(self.bboxIdList) - 1,\n                                          fg=config.COLORS[(len(self.bboxIdList) - 1) % len(config.COLORS)])\n        self.processingLabel.config(text=""Done              "")\n\n\nif __name__ == \'__main__\':\n    root = Tk()\n    imgicon = PhotoImage(file=\'icon.gif\')\n    root.tk.call(\'wm\', \'iconphoto\', root._w, imgicon)\n    tool = MainGUI(root)\n    root.mainloop()\n'"
tf_config.py,0,"b""labels_to_names = {1: 'person',\r\n                     2: 'bicycle',\r\n                     3: 'car',\r\n                     4: 'motorcycle',\r\n                     5: 'airplane',\r\n                     6: 'bus',\r\n                     7: 'train',\r\n                     8: 'truck',\r\n                     9: 'boat',\r\n                     10: 'traffic light',\r\n                     11: 'fire hydrant',\r\n                     13: 'stop sign',\r\n                     14: 'parking meter',\r\n                     15: 'bench',\r\n                     16: 'bird',\r\n                     17: 'cat',\r\n                     18: 'dog',\r\n                     19: 'horse',\r\n                     20: 'sheep',\r\n                     21: 'cow',\r\n                     22: 'elephant',\r\n                     23: 'bear',\r\n                     24: 'zebra',\r\n                     25: 'giraffe',\r\n                     27: 'backpack',\r\n                     28: 'umbrella',\r\n                     31: 'handbag',\r\n                     32: 'tie',\r\n                     33: 'suitcase',\r\n                     34: 'frisbee',\r\n                     35: 'skis',\r\n                     36: 'snowboard',\r\n                     37: 'sports ball',\r\n                     38: 'kite',\r\n                     39: 'baseball bat',\r\n                     40: 'baseball glove',\r\n                     41: 'skateboard',\r\n                     42: 'surfboard',\r\n                     43: 'tennis racket',\r\n                     44: 'bottle',\r\n                     46: 'wine glass',\r\n                     47: 'cup',\r\n                     48: 'fork',\r\n                     49: 'knife',\r\n                     50: 'spoon',\r\n                     51: 'bowl',\r\n                     52: 'banana',\r\n                     53: 'apple',\r\n                     54: 'sandwich',\r\n                     55: 'orange',\r\n                     56: 'broccoli',\r\n                     57: 'carrot',\r\n                     58: 'hot dog',\r\n                     59: 'pizza',\r\n                     60: 'donut',\r\n                     61: 'cake',\r\n                     62: 'chair',\r\n                     63: 'couch',\r\n                     64: 'potted plant',\r\n                     65: 'bed',\r\n                     67: 'dining table',\r\n                     70: 'toilet',\r\n                     72: 'tv',\r\n                     73: 'laptop',\r\n                     74: 'mouse',\r\n                     75: 'remote',\r\n                     76: 'keyboard',\r\n                     77: 'cell phone',\r\n                     78: 'microwave',\r\n                     79: 'oven',\r\n                     80: 'toaster',\r\n                     81: 'sink',\r\n                     82: 'refrigerator',\r\n                     84: 'book',\r\n                     85: 'clock',\r\n                     86: 'vase',\r\n                     87: 'scissors',\r\n                     88: 'teddy bear',\r\n                     89: 'hair drier',\r\n                     90: 'toothbrush'}\r\n\r\n\r\n\r\n\r\n\r\n"""
