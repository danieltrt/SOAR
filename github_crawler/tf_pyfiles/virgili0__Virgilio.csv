file_path,api_count,code
Tools/regex-bin/regexPrinter.py,0,"b'""""""Implements a parser for a subset of the regular expressions grammar\r\n        The parser returns a generator for all the strings recognized\r\n        by a given regular expression.\r\nThe grammar parsed is as follows:\r\nexpr := orexpr EOF\r\norexpr := word (OR word)*\r\nword := quantchar(quantchar)*\r\nquantchar := (char|digit)quant?\r\nchar := CHAR | (LPARENS orexpr RPARENS) | (LCHOOSE orexpr RCHOOSE)\r\ndigit := 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\r\nquant := PLUS | TIMES | QUESTION | CURLYQUANT\r\nwhere\r\n    LPARENS = (\r\n    RPARENS = )\r\n    LCHOOSE = [\r\n    RCHOOSE = ]\r\n    PLUS = +\r\n    TIMES = *\r\n    QUESTION = ?\r\n    CURLYQUANT = {NUM:NUM}\r\n        and NUM is a non-negative integer\r\n    OR = |\r\n    EOF represents end-of-file\r\n    CHAR is any other character other than the ones with special meaning above\r\nFor each production rule R, a function parse_R has been implemented,\r\n    which receives a stream of tokens and\r\n    returns the subtree generated by parsing such rule\r\n        and the remaining tokens\r\n""""""\r\n\r\nfrom enum import Enum\r\n\r\nclass Token(Enum):\r\n    # enumerator quantifiers\r\n    TIMES = ""*""\r\n    PLUS = ""+""\r\n    QUESTION = ""?""\r\n    LCURLY = ""{""\r\n    RCURLY = ""}""\r\n    CURLYQUANT = ""curlyquant""\r\n    \r\n    LPARENS = ""(""\r\n    RPARENS = "")""\r\n    LCHOOSE = ""[""\r\n    RCHOOSE = ""]""\r\n    OR = ""|""\r\n    COLON = "":""\r\n\r\n    DIGIT = ""digit""\r\n    CHARACTER = ""character""\r\n    EOF = ""eof""\r\n\r\nclass TreeNode(object):\r\n    def __init__(self, token, value, next_node):\r\n        self.token = token\r\n        self.value = value\r\n        self.next_node = next_node\r\n\r\n    def print(self):\r\n        raise NotImplementedError(""This should be overriden in subclasses"")\r\n\r\nclass LiteralNode(TreeNode):\r\n    def __init__(self, token, value, quantifier, next_node):\r\n        TreeNode.__init__(self, token, value, next_node)\r\n        self.quantifier = quantifier\r\n\r\n    def print(self):\r\n        printer = self.quantifier.get_printer(self.value)\r\n        for value in printer():\r\n            for sub in self.next_node.print():\r\n                yield value+sub\r\n\r\nclass ChooseNode(TreeNode):\r\n    def __init__(self, token, value, quantifier, value_range, next_node):\r\n        TreeNode.__init__(self, token, value, next_node)\r\n        self.quantifier = quantifier\r\n        self.value_range = value_range\r\n    \r\n    def print(self):\r\n        printer = self.quantifier.get_printer(self.value_range)\r\n        for value in printer():\r\n            for sub in self.next_node.print():\r\n                yield value+sub\r\n\r\nclass OrNode(TreeNode):\r\n    def __init__(self, token, value, children, quantifier, next_node):\r\n        TreeNode.__init__(self, token, value, next_node)\r\n        self.children = children\r\n        self.quantifier = quantifier\r\n\r\n    def print(self):\r\n        temp = [c for child in self.children for c in child.print()]\r\n        printer = self.quantifier.get_printer(temp)\r\n        for child_print in printer():\r\n            for sub in self.next_node.print():\r\n                yield child_print+sub\r\n\r\nclass NoQuantifierNode(TreeNode):\r\n    def __init__(self):\r\n        TreeNode.__init__(self, None, None, None)\r\n\r\n    def get_printer(self, values):\r\n        def printer():\r\n            for value in values:\r\n                yield value\r\n        return printer\r\n\r\nclass QuantifierNode(TreeNode):\r\n    def __init__(self, token, value):\r\n        TreeNode.__init__(self, token, value, None)\r\n\r\n    def get_printer(self, values):\r\n        if self.token == Token.QUESTION:\r\n            temp = [""""] + [v for v in values]\r\n            ss = sorted(temp)\r\n        elif self.token in (Token.TIMES, Token.PLUS):\r\n            sub_result = [v for v in values]\r\n            temp = sub_result[::]\r\n            sub_result = [v+sub for v in values for sub in sub_result]\r\n            temp += sub_result\r\n            temp += (self.token == Token.TIMES)*[""""]\r\n            ss = sorted(temp)\r\n            if isinstance(values, list) or len(values) > 1:\r\n                ss += [""[...]""]\r\n            else:\r\n                ss += [values+""...""+values]\r\n                \r\n        else:                \r\n            try:\r\n                l, r = self.value\r\n            except:\r\n                raise ValueError(""Was expecting a curly quantifier"")\r\n            sub_result = [""""]\r\n            temp = []\r\n            for i in range(1, r+1):\r\n                sub_result = [v+sub for v in values for sub in sub_result]\r\n                if i >= l:\r\n                    temp += sub_result\r\n            ss = sorted(temp)\r\n        def printer():\r\n            for s in ss:\r\n                yield s\r\n        return printer\r\n\r\nclass EOFNode(TreeNode):\r\n    def __init__(self):\r\n        TreeNode.__init__(self, None, None, None)\r\n\r\n    def print(self):\r\n        yield """"\r\n\r\ndef tokenize(s):\r\n    tokens = []\r\n    for char in s:\r\n        for token in Token:\r\n            if char == token.value:\r\n                tokens.append((token, char))\r\n                break\r\n        else:\r\n            if char in ""0123456789"":\r\n                tokens.append((Token.DIGIT, char))\r\n            else:\r\n                tokens.append((Token.CHARACTER, char))\r\n    tokens.append((Token.EOF, ""eof""))\r\n\r\n    i = 0\r\n    while i < len(tokens):\r\n        if tokens[i][0] == Token.LCURLY:\r\n            l, r, j = 0, 0, i+1\r\n            acc = """"\r\n            while j < len(tokens) and tokens[j][0] == Token.DIGIT:\r\n                acc += tokens[j][1]\r\n                tokens = tokens[:j] + tokens[j+1:]\r\n            try:\r\n                l = int(acc)\r\n            except ValueError:\r\n                raise SyntaxError(""Curly quantifier with no left integer"")\r\n            if j >= len(tokens) or tokens[j][0] != Token.COLON:\r\n                raise SyntaxError(""Could not tokenize the expression"")\r\n            tokens = tokens[:j] + tokens[j+1:]\r\n            acc = """"\r\n            while j < len(tokens) and tokens[j][0] == Token.DIGIT:\r\n                acc += tokens[j][1]\r\n                tokens = tokens[:j] + tokens[j+1:]\r\n            try:\r\n                r = int(acc)\r\n            except ValueError:\r\n                raise SyntaxError(""Curly quantifier with no right integer"")\r\n            if j >= len(tokens) or tokens[j][0] != Token.RCURLY:\r\n                raise SyntaxError(""Could not tokenize the expression"")\r\n            tokens = tokens[:j] + tokens[j+1:]\r\n            tokens[i] = (Token.CURLYQUANT, (l,r))\r\n        i += 1\r\n\r\n    return tokens\r\n\r\ndef printRegex(r):\r\n    return parse_expr(tokenize(r))\r\n\r\ndef parse_expr(tokens):\r\n    tree, tokens = parse_orexpr(tokens)\r\n    if tokens[0][0] == Token.EOF:\r\n        tree.next_node = EOFNode()\r\n        return tree\r\n    else:\r\n        raise SyntaxError(""expected eof!"")\r\n\r\ndef parse_orexpr(tokens):\r\n    temp, tokens = parse_word(tokens)\r\n    topOrNode = OrNode(Token.OR, Token.OR.value, [temp], NoQuantifierNode(), EOFNode())\r\n    ornode = topOrNode\r\n    while tokens[0][0] == Token.OR:\r\n        temp, tokens = parse_word(tokens[1:])\r\n        if temp is not None:\r\n            topOrNode.children.append(temp)\r\n    return topOrNode, tokens\r\n\r\ndef parse_word(tokens):\r\n    topnode, tokens = parse_quantchar(tokens)\r\n    if topnode is None:\r\n        raise SyntaxError(""Empty word :/"")\r\n    sub = node = topnode\r\n    # while the next token could start a quantified character, grab it\r\n    while tokens[0][0] in (Token.CHARACTER, Token.DIGIT, Token.LPARENS, Token.LCHOOSE):\r\n        sub, tokens = parse_quantchar(tokens)\r\n        node.next_node = sub\r\n        node = sub\r\n    return topnode, tokens\r\n\r\ndef parse_quantchar(tokens):\r\n    if tokens[0][0] == Token.DIGIT:\r\n        node, tokens = parse_digit(tokens)\r\n    else:\r\n        node, tokens = parse_char(tokens)\r\n        if node is None:\r\n            return None, tokens\r\n    quant, tokens = parse_quant(tokens)\r\n    node.quantifier = quant\r\n    return node, tokens\r\n\r\ndef parse_char(tokens):\r\n    if tokens[0][0] == Token.CHARACTER:\r\n        return LiteralNode(tokens[0][0], tokens[0][1], NoQuantifierNode(), EOFNode()), tokens[1:]\r\n    elif tokens[0][0] == Token.LPARENS:\r\n        node, temptokens = parse_orexpr(tokens[1:])\r\n        if temptokens[0][0] == Token.RPARENS:\r\n            return node, temptokens[1:]\r\n        else:\r\n            raise SyntaxError(""Could not parse parenthesized expression"")\r\n    elif tokens[0][0] == Token.LCHOOSE:\r\n        i = 1\r\n        value_range = """"\r\n        while i < len(tokens) and tokens[i][0] != Token.RCHOOSE:\r\n            value_range += tokens[i][1]\r\n            i += 1\r\n        if i >= len(tokens):\r\n            raise SyntaxError(""Could not close CHOOSE section"")\r\n        else:\r\n            tokens = tokens[i+1:]\r\n        return ChooseNode(Token.LCHOOSE, Token.LCHOOSE.value, NoQuantifierNode(), value_range, EOFNode()), tokens\r\n\r\ndef parse_quant(tokens):\r\n    if tokens[0][0] in (Token.PLUS, Token.TIMES, Token.QUESTION, Token.CURLYQUANT):\r\n        return QuantifierNode(tokens[0][0], tokens[0][1]), tokens[1:]\r\n    else:\r\n        return NoQuantifierNode(), tokens\r\n\r\ndef parse_digit(tokens):\r\n    if tokens[0][0] == Token.DIGIT:\r\n        return LiteralNode(tokens[0][0], tokens[0][1], NoQuantifierNode(), EOFNode()), tokens[1:]\r\n    else:\r\n        return None, tokens\r\n\r\nif __name__ == ""__main__"":\r\n    print(""regexPrinter: a printer of regular expressions"")\r\n    print(""\\tjust write a regex to get all its matches printed"")\r\n    print(""\\tto exit just hit Enter in the prompt"")\r\n    while True:\r\n        s = input("" >> "")\r\n        if not s:\r\n            break\r\n        i = 1\r\n        for v in printRegex(s).print():\r\n            print(""{}: {}"".format(i, v))\r\n            i += 1'"
