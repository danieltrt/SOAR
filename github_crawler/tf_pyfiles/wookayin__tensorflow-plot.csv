file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport codecs\nimport os\nimport re\nimport sys\nfrom setuptools import setup, Command\n\n\n__PATH__ = os.path.abspath(os.path.dirname(__file__))\n\n\ninstall_requires = [\n    \'six\',\n    \'numpy\',\n    \'biwrap==0.1.6\',\n    \'matplotlib>=2.0.0\',\n]\n\ntest_require = [\n    \'pytest\',\n    \'pytest-pudb\',\n    \'imgcat\',\n    \'termcolor\',\n    \'scipy\',\n    \'seaborn>=0.8.0\',\n]\n\n# temporarily redirect config directory to prevent matplotlib and skimage\n# cause a SandboxViolationError on Travis CI environments.\nos.environ[""MPLCONFIGDIR""] = "".""\n\n\n\ndef read_version():\n    # importing the package causes an ImportError :-)\n    with open(os.path.join(__PATH__, \'tfplot/__init__.py\')) as f:\n        version_match = re.search(r""^__version__ = [\'\\""]([^\'\\""]*)[\'\\""]"",\n                                  f.read(), re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(""Unable to find __version__ string"")\n\n__version__ = read_version()\nreadme = codecs.open(\'README.md\', encoding=\'utf-8\').read()\n\n\n# brought from https://github.com/kennethreitz/setup.py\nclass DeployCommand(Command):\n    description = \'Build and deploy the package to PyPI.\'\n    user_options = []\n\n    def initialize_options(self): pass\n    def finalize_options(self): pass\n\n    @staticmethod\n    def status(s):\n        print(s)\n\n    def run(self):\n        import twine  # we require twine locally\n\n        assert \'dev\' not in __version__, \\\n            ""Only non-devel versions are allowed. __version__ == {}"".format(__version__)\n\n        with os.popen(""git status --short"") as fp:\n            git_status = fp.read().strip()\n            if git_status:\n                print(""Error: git repository is not clean.\\n"")\n                os.system(""git status --short"")\n                sys.exit(1)\n\n        try:\n            from shutil import rmtree\n            self.status(\'Removing previous builds ...\')\n            rmtree(os.path.join(__PATH__, \'dist\'))\n        except OSError:\n            pass\n\n        self.status(\'Building Source and Wheel (universal) distribution ...\')\n        os.system(\'{0} setup.py sdist\'.format(sys.executable))\n\n        self.status(\'Uploading the package to PyPI via Twine ...\')\n        ret = os.system(\'twine upload dist/*\')\n        if ret != 0:\n            sys.exit(ret)\n\n        self.status(\'Creating git tags ...\')\n        os.system(\'git tag v{0}\'.format(read_version()))\n        os.system(\'git tag --list\')\n        sys.exit()\n\n\nsetup(\n    name=\'tensorflow-plot\',\n    version=__version__,\n    description=\'TensorFlow Plot\',\n    long_description=readme,\n    long_description_content_type=\'text/markdown\',\n    license=\'MIT License\',\n    url=\'https://github.com/wookayin/tensorflow-plot\',\n    author=\'Jongwook Choi\',\n    author_email=\'wookayin@gmail.com\',\n    keywords=\'tensorflow matplotlib tensorboard plot tfplot\',\n    packages=[\n        \'tfplot\',\n    ],\n    classifiers=[\n        # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n        \'Development Status :: 3 - Alpha\',\n        \'License :: OSI Approved :: MIT License\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: 3\',\n    ],\n    install_requires=install_requires,\n    tests_require=test_require,\n    setup_requires=[\n        \'pytest-runner\',\n    ],\n    cmdclass={\n        \'deploy\': DeployCommand,\n    },\n    include_package_data=True,\n    zip_safe=False,\n)\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# tfplot documentation build configuration file, created by\n# sphinx-quickstart on Mon Apr 10 23:45:52 2017.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\'.\'))\nimport re\n\n# for local build, make sure tfplot is importable\n# e.g. $ PYTHONPATH=. sphinx-build docs build/docs\nimport tfplot\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.napoleon\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.todo\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.githubpages\',\n    \'nbsphinx\',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# Use Markdown\nfrom recommonmark.parser import CommonMarkParser\n\nsource_parsers = {\n    \'.md\': CommonMarkParser,\n}\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\nsource_suffix = [\'.rst\', \'.md\']\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'TensorFlow Plot (tfplot)\'\ncopyright = u\'2017-2019, Jongwook Choi\'\nauthor = u\'Jongwook Choi\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = re.sub(r\'\\.dev\\d+$\', \'\', tfplot.__version__)\n# The full version, including alpha/beta/rc tags.\nrelease = tfplot.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\',\n                    \'**.ipynb_checkpoints\']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\nimport sphinx_rtd_theme\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n\n# -- Options for HTMLHelp output ------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'tfplotdoc\'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'tfplot.tex\', u\'tfplot Documentation\',\n     u\'Jongwook Choi\', \'manual\'),\n]\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'tfplot\', u\'tfplot Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'tfplot\', u\'tfplot Documentation\',\n     author, \'tfplot\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\'https://docs.python.org/\': None}\n'"
examples/summary_heatmap.py,11,"b'""""""\nAn example application that uses `tfplot` to create plot summaries and\nadd them into TensorBoard as image summaries.\n""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\nimport tfplot\nimport numpy as np\nimport os.path\nimport scipy.misc\nimport scipy.ndimage\nimport skimage.data\n\nimport seaborn.apionly as sns\n\ntry:\n    import better_exceptions\nexcept ImportError:\n    pass\n\n\ndef make_temp_directory():\n    t = \'./train_dir\'\n    if not os.path.exists(t):\n        os.makedirs(t)\n    return t\n\n\n# an example figure function for drawing heatmap\n# with overlaid background images\ndef heatmap_overlay(data, overlay_image=None, cmap=\'jet\',\n                    cbar=False, show_axis=False, alpha=0.5, **kwargs):\n    fig, ax = tfplot.subplots(figsize=(5, 4) if cbar else (4, 4))\n    fig.subplots_adjust(0, 0, 1, 1)  # use tight layout (no margins)\n    ax.axis(\'off\')\n\n    if overlay_image is None: alpha = 1.0\n    sns.heatmap(data, ax=ax, alpha=alpha, cmap=cmap, cbar=cbar, **kwargs)\n\n    if overlay_image is not None:\n        h, w = data.shape\n        ax.imshow(overlay_image, extent=[0, h, 0, w])\n\n    if show_axis:\n        ax.axis(\'on\')\n        fig.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95)\n    return fig\n\n\ndef main():\n    # (1) load image\n    image_0 = skimage.data.chelsea()\n    image_1 = skimage.data.coffee()\n\n    print (\'image_0 : %s\' % str(image_0.shape))\n    print (\'image_1 : %s\' % str(image_1.shape))\n\n    image_0 = tf.image.resize_image_with_crop_or_pad(image_0, 320, 320)\n    image_1 = tf.image.resize_image_with_crop_or_pad(image_1, 320, 320)\n    image_batch = tf.stack([image_0, image_1], name=\'image_batch\')\n    print (\'image_batch : %s\' % image_batch)\n    tf.summary.image(""image/batch"", image_batch)\n\n\n    # (2) generate fake attention (in a different scale)\n    attention = np.zeros([2, 16, 16], dtype=np.float32)\n    attention[(0, 12, 8)] = 1.0\n    attention[(0, 10, 9)] = 1.0\n    attention[1, :, :] = 1. / 256\n    attention[1, 0, 0] = 0.1\n    attention[1, 7, 9] = 0.2\n    attention[0] = scipy.ndimage.filters.gaussian_filter(attention[0], sigma=1.5)\n\n    attention_heatmap = tf.convert_to_tensor(attention)\n    tf.summary.image(""attention/image_summary"",\n                     tf.expand_dims(attention_heatmap, 3)  # make 4-d\n                     )\n\n\n    # (3) attention & heatmap plots\n    # build a summary factory which exposes a similar interface to tf.summary.xxx()\n    summary_heatmap = tfplot.summary.wrap(heatmap_overlay, batch=True)\n\n    summary_heatmap(""attention/heatmap"", attention_heatmap)\n    summary_heatmap(""attention/heatmap_cbar"", attention_heatmap,\n                    cbar=True)\n    summary_heatmap(""attention/heatmap_axis"", attention_heatmap,\n                    show_axis=True)\n    summary_heatmap(""attention/heatmap_cmap"", attention_heatmap,\n                    cbar=True, cmap=\'jet\')\n    summary_heatmap(""image/heatmap_overlay"", attention_heatmap, image_batch,\n                    cbar=True, show_axis=True, cmap=\'jet\')\n    summary_heatmap(""image/heatmap_overlay_bg"", attention_heatmap, image_batch,\n                    alpha=0.7, cmap=\'gray\')\n\n    summary_op = tf.summary.merge_all()\n\n    # -------------------------------------------------\n    # execute it\n\n    session = tf.Session(config=tf.ConfigProto(device_count={\'GPU\': 0}))\n    tmp_dir = make_temp_directory()\n\n    summary = session.run(summary_op)\n\n    summary_writer = tf.summary.FileWriter(tmp_dir)\n    summary_writer.add_summary(summary)\n\n    print (""Summary written at %s"" % tmp_dir)\n    print (""To open tensorboard: $ tensorboard --logdir %s"" % tmp_dir)\n\nif __name__ == \'__main__\':\n    main()\n'"
tfplot/__init__.py,0,"b""from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport matplotlib\nif not matplotlib.rcParams.get('backend', None):\n    matplotlib.use('Agg')\n\nfrom .ops import plot, plot_many\nfrom .wrapper import wrap, wrap_axesplot\nfrom .wrapper import autowrap\n\nfrom .figure import subplots\nfrom . import summary\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.axes import Axes\n\n\n__version__ = '0.3.2'\n"""
tfplot/contrib.py,1,"b'\'\'\'Some predefined plot functions.\'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom .wrapper import autowrap\n\n\n__all__ = (\n    \'probmap\',\n    \'probmap_simple\',\n    \'batch\',\n)\n\n\n@autowrap\ndef probmap(x, cmap=\'jet\', colorbar=True,\n            vmin=None, vmax=None, axis=True, ax=None):\n    \'\'\'\n    Display a heatmap in color. The resulting op will be a RGBA image Tensor.\n\n    Args:\n      x: A 2-D image-like tensor to draw.\n      cmap: Matplotlib colormap. Defaults \'jet\'\n      axis: If True (default), x-axis and y-axis will appear.\n      colorbar: If True (default), a colorbar will be placed on the right.\n      vmin: A scalar. Minimum value of the range. See ``matplotlib.axes.Axes.imshow``.\n      vmax: A scalar. Maximum value of the range. See ``matplotlib.axes.Axes.imshow``.\n\n    Returns:\n        A `uint8` `Tensor` of shape ``(?, ?, 4)`` containing the resulting plot.\n    \'\'\'\n    assert ax is not None, ""autowrap did not set ax""\n\n    axim = ax.imshow(x, cmap=cmap, vmin=vmin, vmax=vmax)\n    if colorbar:\n        ax.figure.colorbar(axim)\n    if not axis:\n        ax.axis(\'off\')\n\n    if not axis and not colorbar:\n        ax.figure.subplots_adjust(0, 0, 1, 1)\n    else:\n        ax.figure.tight_layout()\n\n\ndef probmap_simple(x, **kwargs):\n    \'\'\'\n    Display a heatmap in color, but only displays the image content.\n    The resulting op will be a RGBA image Tensor.\n\n    It reduces to ``probmap`` having `colorbar` and `axis` off.\n    See the documentation of ``probmap`` for available arguments.\n    \'\'\'\n    # pylint: disable=unexpected-keyword-arg\n    return probmap(x,\n                   colorbar=kwargs.pop(\'colorbar\', False),\n                   axis=kwargs.pop(\'axis\', False),\n                   figsize=kwargs.pop(\'figsize\', (3, 3)),\n                   **kwargs)\n    # pylint: enable=unexpected-keyword-arg\n\n\ndef batch(func):\n    \'\'\'\n    Make an autowrapped plot function (... -> RGBA tf.Tensor) work in a batch\n    manner.\n\n    Example:\n\n      >>> p\n      Tensor(""p:0"", shape=(batch_size, 16, 16, 4), dtype=uint8)\n      >>> tfplot.contrib.batch(tfplot.contrib.probmap)(p)\n      Tensor(""probmap/PlotImages:0"", shape=(batch_size, ?, ?, 4), dtype=uint8)\n    \'\'\'\n    if not hasattr(func, \'__unwrapped__\'):\n        raise ValueError(""The given function is not wrapped with tfplot.autowrap()!"")\n\n    func = func.__unwrapped__\n    return autowrap(func, batch=True)\n'"
tfplot/contrib_test.py,1,"b'\'\'\'Unit Test for tfplot.contrib\'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport unittest\nimport os\nimport scipy.misc\n\nimport numpy as np\nimport tensorflow as tf\nos.environ[\'TF_CPP_MIN_LOG_LEVEL\'] = \'3\'  # filter out INFO and WARN logs\n\nimport matplotlib\nmatplotlib.rcParams[\'figure.figsize\'] = (2.5, 2.5)\n\nfrom termcolor import cprint\nfrom imgcat import imgcat\n\nimport tfplot.contrib\nimport tfplot.test_util as test_util\n\ntest_util.configure_tf_verbosity()\n\n\nclass TestContrib(test_util.TestcaseBase):\n    \'\'\'\n    Tests tfplot.contrib module.\n    \'\'\'\n    def test_contrib_module(self):\n        print("""")\n        for name in tfplot.contrib.__all__:\n            fn = tfplot.contrib.__dict__[name]\n            print("" - contrib: {fn} -> module={module}"".format(\n                  fn=fn, module=fn.__module__))\n            self.assertTrue(fn.__module__.startswith(\'tfplot.contrib\'),\n                            msg=str(fn.__module__))\n            self.assertTrue(fn.__doc__, \'__doc__ is empty\')\n\n    def test_probmap(self):\n        image_tensor = tf.constant(scipy.misc.face())\n        attention_tensor = np.eye(5)\n        op = tfplot.contrib.probmap(attention_tensor, figsize=(4, 3))\n        self._execute_plot_op(op, print_image=True)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tfplot/figure.py,0,"b'\'\'\' Figure utilities. \'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport types\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\nimport six\nfrom io import BytesIO\n\ntry:\n    from tensorflow import Summary\nexcept ImportError:\n    # TF 2.0\n    import tensorflow\n    Summary = tensorflow.compat.v1.Summary\n\nfrom . import mpl_figure\n\n\ndef subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True,\n             subplot_kw=None, gridspec_kw=None, **fig_kw):\n    """"""\n    Create a figure and a set of subplots, as in `pyplot.subplots()`.\n\n    It works almost similar to `pyplot.subplots()`, but differ from it in that\n    it does not involve any side effect as pyplot does (e.g. modifying thread\n    states such as current figure or current subplot).\n\n    (docstrings inherited from `matplotlib.pyplot.subplots`)\n\n    """"""\n    FigureClass = fig_kw.pop(\'FigureClass\', Figure)\n    fig = FigureClass(**fig_kw)\n\n    # attach a new Agg canvas\n    FigureCanvasAgg(fig)\n\n    # create subplots, e.g. fig.subplots() in matplotlib 2.1+\n    if not hasattr(fig, \'subplots\'):\n        if six.PY2:\n            fig.subplots = types.MethodType(mpl_figure.subplots, fig, FigureClass)\n        else:\n            fig.subplots = types.MethodType(mpl_figure.subplots, fig)\n\n    axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\n                       squeeze=squeeze, subplot_kw=subplot_kw,\n                       gridspec_kw=gridspec_kw)\n    return fig, axs\n\n\n# inherit and append a part of the docstring from pyplot.subplots()\nsubplots.__doc__ += plt.subplots.__doc__[plt.subplots.__doc__.find(\'Parameters\'):]\\\n    .replace(\'plt.subplots\', \'tfplot.subplots\')\n\n\ndef to_array(fig):\n    """"""\n    Convert a matplotlib figure ``fig`` into a 3D numpy array.\n\n    Example:\n\n      >>> fig, ax = tfplot.subplots(figsize=(4, 4))\n      >>> # draw whatever, e.g. ax.text(0.5, 0.5, ""text"")\n\n      >>> im = to_array(fig)   # ndarray [288, 288, 4]\n\n    Args:\n      fig: A ``matplotlib.figure.Figure`` object.\n\n    Returns:\n      A numpy ``ndarray`` of shape ``(?, ?, 4)``, containing an RGB-A image of\n      the figure.\n    """"""\n\n    # attach a new agg canvas\n    _old_canvas = fig.canvas\n    try:\n        canvas = FigureCanvasAgg(fig)\n\n        canvas.draw()\n        w, h = canvas.get_width_height()\n\n        img = np.frombuffer(canvas.tostring_argb(), dtype=np.uint8)\n        img = img.reshape((h, w, 4))\n        img = img[:, :, (1, 2, 3, 0)]   # argb -> rgba\n        return img\n\n    finally:\n        # restore to the previous canvas, if any\n        fig.set_canvas(_old_canvas)\n\n\ndef to_summary(fig, tag):\n    """"""\n    Convert a matplotlib figure ``fig`` into a TensorFlow Summary object\n    that can be directly fed into ``Summary.FileWriter``.\n\n    Example:\n\n      >>> fig, ax = ...    # (as above)\n      >>> summary = to_summary(fig, tag=\'MyFigure/image\')\n\n      >>> type(summary)\n      tensorflow.core.framework.summary_pb2.Summary\n      >>> summary_writer.add_summary(summary, global_step=global_step)\n\n    Args:\n      fig: A ``matplotlib.figure.Figure`` object.\n      tag (string): The tag name of the created summary.\n\n    Returns:\n      A TensorFlow ``Summary`` protobuf object containing the plot image\n      as a image summary.\n    """"""\n    if not isinstance(tag, six.string_types):\n        raise TypeError(""tag must be a string type"")\n\n    # attach a new agg canvas\n    _old_canvas = fig.canvas\n    try:\n        canvas = FigureCanvasAgg(fig)\n\n        canvas.draw()\n        w, h = canvas.get_width_height()\n\n        # get PNG data from the figure\n        png_buffer = BytesIO()\n        canvas.print_png(png_buffer)\n        png_encoded = png_buffer.getvalue()\n        png_buffer.close()\n\n        summary_image = Summary.Image(height=h, width=w, colorspace=4,  # RGB-A\n                                    encoded_image_string=png_encoded)\n        summary = Summary(value=[Summary.Value(tag=tag, image=summary_image)])\n        return summary\n\n    finally:\n        fig.canvas = _old_canvas\n\n\n__all__ = (\n    \'to_array\',\n    \'to_summary\',\n    \'subplots\',\n)\n'"
tfplot/mpl_figure.py,0,"b'"""""" A cherry-pick from matplotlib implementation """"""\n\n# Copyright (c) 2012-2013 Matplotlib Development Team; All Rights Reserved\n# http://matplotlib.org/users/license.html\n#\n# All the code in this file was brought from matplotlib\n\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport warnings\n\nimport numpy as np\n\nfrom matplotlib.gridspec import GridSpec\n\n\n# should be attached to matplotlib.figure.Figure()\n# @see https://github.com/matplotlib/matplotlib/pull/5146\ndef subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,\n             squeeze=True, subplot_kw=None, gridspec_kw=None):\n    """"""\n    Add a set of subplots to this figure.\n    Parameters\n    ----------\n    nrows, ncols : int, default: 1\n        Number of rows/cols of the subplot grid.\n    sharex, sharey : bool or {\'none\', \'all\', \'row\', \'col\'}, default: False\n        Controls sharing of properties among x (`sharex`) or y (`sharey`)\n        axes:\n            - True or \'all\': x- or y-axis will be shared among all\n                subplots.\n            - False or \'none\': each subplot x- or y-axis will be\n                independent.\n            - \'row\': each subplot row will share an x- or y-axis.\n            - \'col\': each subplot column will share an x- or y-axis.\n        When subplots have a shared x-axis along a column, only the x tick\n        labels of the bottom subplot are visible.  Similarly, when\n        subplots have a shared y-axis along a row, only the y tick labels\n        of the first column subplot are visible.\n    squeeze : bool, default: True\n        - If True, extra dimensions are squeezed out from the returned\n            axis object:\n            - if only one subplot is constructed (nrows=ncols=1), the\n                resulting single Axes object is returned as a scalar.\n            - for Nx1 or 1xN subplots, the returned object is a 1D numpy\n                object array of Axes objects are returned as numpy 1D\n                arrays.\n            - for NxM, subplots with N>1 and M>1 are returned as a 2D\n                arrays.\n        - If False, no squeezing at all is done: the returned Axes object\n            is always a 2D array containing Axes instances, even if it ends\n            up being 1x1.\n    subplot_kw : dict, default: {}\n        Dict with keywords passed to the\n        :meth:`~matplotlib.figure.Figure.add_subplot` call used to create\n        each subplots.\n    gridspec_kw : dict, default: {}\n        Dict with keywords passed to the\n        :class:`~matplotlib.gridspec.GridSpec` constructor used to create\n        the grid the subplots are placed on.\n    Returns\n    -------\n    ax : single Axes object or array of Axes objects\n        The added axes.  The dimensions of the resulting array can be\n        controlled with the squeeze keyword, see above.\n    See Also\n    --------\n    pyplot.subplots : pyplot API; docstring includes examples.\n    """"""\n\n    # for backwards compatibility\n    if isinstance(sharex, bool):\n        sharex = ""all"" if sharex else ""none""\n    if isinstance(sharey, bool):\n        sharey = ""all"" if sharey else ""none""\n    share_values = [""all"", ""row"", ""col"", ""none""]\n    if sharex not in share_values:\n        # This check was added because it is very easy to type\n        # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\n        # In most cases, no error will ever occur, but mysterious behavior\n        # will result because what was intended to be the subplot index is\n        # instead treated as a bool for sharex.\n        if isinstance(sharex, int):\n            warnings.warn(\n                ""sharex argument to subplots() was an integer. ""\n                ""Did you intend to use subplot() (without \'s\')?"")\n\n        raise ValueError(""sharex [%s] must be one of %s"" %\n                            (sharex, share_values))\n    if sharey not in share_values:\n        raise ValueError(""sharey [%s] must be one of %s"" %\n                            (sharey, share_values))\n    if subplot_kw is None:\n        subplot_kw = {}\n    if gridspec_kw is None:\n        gridspec_kw = {}\n\n    gs = GridSpec(nrows, ncols, **gridspec_kw)\n\n    # Create array to hold all axes.\n    axarr = np.empty((nrows, ncols), dtype=object)\n    for row in range(nrows):\n        for col in range(ncols):\n            shared_with = {""none"": None, ""all"": axarr[0, 0],\n                            ""row"": axarr[row, 0], ""col"": axarr[0, col]}\n            subplot_kw[""sharex""] = shared_with[sharex]\n            subplot_kw[""sharey""] = shared_with[sharey]\n            axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)\n\n    # turn off redundant tick labeling\n    if sharex in [""col"", ""all""]:\n        # turn off all but the bottom row\n        for ax in axarr[:-1, :].flat:\n            for label in ax.get_xticklabels():\n                label.set_visible(False)\n            ax.xaxis.offsetText.set_visible(False)\n    if sharey in [""row"", ""all""]:\n        # turn off all but the first column\n        for ax in axarr[:, 1:].flat:\n            for label in ax.get_yticklabels():\n                label.set_visible(False)\n            ax.yaxis.offsetText.set_visible(False)\n\n    if squeeze:\n        # Discarding unneeded dimensions that equal 1.  If we only have one\n        # subplot, just return it instead of a 1-element array.\n        return axarr.item() if axarr.size == 1 else axarr.squeeze()\n    else:\n        # Returned axis array will be always 2-d, even if nrows=ncols=1.\n        return axarr\n'"
tfplot/ops.py,16,"b'\'\'\' Main plot operations. \'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport six\nimport re\nimport types\nimport logging\n\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.python.framework import tensor_util\n\nfrom . import figure\nfrom . import util\nfrom .util import merge_kwargs, decode_bytes_if_necessary\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.axes import Axes\n\n\nfrom distutils.version import LooseVersion\nif LooseVersion(tf.__version__) < LooseVersion(""2.0""):\n    # TF 1.x\n    _TF_2_ = False\n    py_func = tf.py_func\nelse:\n    # TF 2.x\n    _TF_2_ = True\n    py_func = tf.py_function  # pylint: disable=no-member\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef plot(plot_func, in_tensors, name=\'Plot\',\n         **kwargs):\n    \'\'\'\n    Create a TensorFlow op which draws plot in an image. The resulting\n    image is in a 3-D uint8 tensor.\n\n    Given a python function ``plot_func``, which takes numpy arrays as its\n    inputs (the evaluations of ``in_tensors``) and returns a matplotlib\n    `Figure` object as its outputs, wrap this function as a TensorFlow op.\n    The returning figure will be rendered as a RGB-A image upon execution.\n\n    Args:\n      plot_func: a python function or callable\n        The function which accepts numpy `ndarray` objects as an argument\n        that match the corresponding `tf.Tensor` objects in ``in_tensors``.\n        It should return a new instance of ``matplotlib.figure.Figure``,\n        which contains the resulting plot image.\n      in_tensors: A list of `tf.Tensor` objects.\n      name: A name for the operation (optional).\n      kwargs: Additional keyword arguments passed to ``plot_func`` (optional).\n\n    Returns:\n      A single `uint8` `Tensor` of shape ``(?, ?, 4)``, containing the plot\n      image that ``plot_func`` computes.\n    \'\'\'\n\n    if not hasattr(plot_func, \'__call__\'):\n        raise TypeError(""plot_func should be callable"")\n\n    if not isinstance(name, six.string_types):\n        raise TypeError(""name should be str or unicode, "" +\n                        ""given {}"".format(type(name)))\n\n    if not isinstance(in_tensors, (list, tuple)):\n        if isinstance(in_tensors, (tf.Tensor, np.ndarray, np.number)):\n            in_tensors = [in_tensors]\n        else:\n            raise TypeError(""in_tensors should be a list of Tensors, "" +\n                            ""given {}"".format(type(in_tensors)))\n\n    in_tensors = [tf.convert_to_tensor(t) for t in in_tensors]\n\n    def _render_image(*args):\n        # `args` is (a tuple of) python values\n        args = tuple(\n            arg.numpy() if tensor_util.is_tensor(arg) else arg \\\n            for arg in args\n        )\n\n        # for tf.string tensors, decode into unicode if necessary.\n        args = tuple(\n            (decode_bytes_if_necessary(arg) if t.dtype == tf.string else arg) \\\n            for (arg, t) in zip(args, in_tensors)\n        )\n        fig = plot_func(*args, **kwargs)\n\n        if not isinstance(fig, Figure):\n            raise TypeError(""The returned value should be a "" +\n                            ""matplotlib.figure.Figure object, "" +\n                            ""but given {}"".format(type(fig)))\n\n        # render fig into numpy array.\n        try:\n            image = figure.to_array(fig)\n        except KeyError as e:\n            # matplotlib is not thread-safe (see issue #17)\n            logger.warn(""KeyError during to_array(): {}"".format(str(e)))\n\n            # To workaround this, simply fallback to return a black screen\n            w, h = image = fig.canvas.get_width_height()\n            image = np.zeros([h, w, 4], dtype=np.uint8)\n            return image\n\n        return image\n\n    im = py_func(_render_image, in_tensors, Tout=tf.uint8,\n                 name=name)\n    im.set_shape([None, None, 4])\n    return im\n\n\ndef plot_many(plot_func, in_tensors, name=\'PlotMany\',\n              max_outputs=None,\n              **kwargs):\n    \'\'\'\n    A batch version of ``plot``.  Create a TensorFlow op which draws\n    a plot for each image. The resulting images are given in a 4-D `uint8`\n    Tensor of shape ``[batch_size, height, width, 4]``.\n\n    Args:\n      plot_func: A python function or callable, which accepts numpy\n        `ndarray` objects as an argument that match the corresponding\n        `tf.Tensor` objects in ``in_tensors``. It should return a new instance\n        of ``matplotlib.figure.Figure``, which contains the resulting plot image.\n        The shape (height, width) of generated figure for each plot should\n        be same.\n      in_tensors: A list of `tf.Tensor` objects.\n      name: A name for the operation (optional).\n      max_outputs: Max number of batch elements to generate plots for (optional).\n      kwargs: Additional keyword arguments passed to `plot_func` (optional).\n\n    Returns:\n      A single `uint8` `Tensor` of shape ``(B, ?, ?, 4)``, containing the B\n      plot images, each of which is computed by ``plot_func``, where B equals\n      ``batch_size``, the number of batch elements in the each tensor from\n      ``in_tensors``, or ``max_outputs`` (whichever is smaller).\n    \'\'\'\n\n    # unstack all the tensors in in_tensors\n    args = []\n    batch_size = None\n\n    with tf.name_scope(name):\n        for in_tensor in in_tensors:\n            in_tensor = tf.convert_to_tensor(in_tensor)\n            arg_unpacked = tf.unstack(in_tensor, name=in_tensor.op.name + \'_unstack\')\n            if batch_size is not None and batch_size != len(arg_unpacked):\n                raise ValueError(""All tensors in in_tensors should have "" +\n                                 ""the same batch size : %d != %d for %s"" % (\n                                     batch_size, len(arg_unpacked), in_tensor\n                                 ))\n            batch_size = len(arg_unpacked)\n            args.append(arg_unpacked)\n\n        # generate plots for each batch element\n        ims = []\n        for k, arg in enumerate(zip(*args)):\n            if max_outputs is not None and k >= max_outputs:\n                break\n            im = plot(plot_func, arg, name=(\'Plot_%d\' % k), **kwargs)\n            ims.append(im)\n\n        # combine the generated plots and use them as image summary\n        im_packed = tf.stack(ims, name=\'PlotImages\')\n\n    return im_packed\n\n\n\n__all__ = (\n    \'plot\',\n    \'plot_many\',\n)\n'"
tfplot/ops_test.py,7,"b'# -*- coding: utf-8 -*-\n\'\'\'Unit Test for tfplot.ops\'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport unittest\nimport types\nimport sys\nimport os\nimport hashlib\nimport six\n\nimport numpy as np\nimport scipy.misc\n\nimport tensorflow as tf\nos.environ[\'TF_CPP_MIN_LOG_LEVEL\'] = \'3\'  # filter out INFO and WARN logs\n\nimport matplotlib\nmatplotlib.rcParams[\'figure.figsize\'] = (2.5, 2.5)\n\nimport tfplot.figure\nimport tfplot.test_util as test_util\n\ntest_util.configure_tf_verbosity()\n\n\n\n\n# some fixtures as in showcases.ipynb\ndef fake_attention():\n    import scipy.ndimage\n    attention = np.zeros([16, 16], dtype=np.float32)\n    attention[(12, 8)] = 1.0\n    attention[(10, 9)] = 1.0\n    attention = scipy.ndimage.filters.gaussian_filter(attention, sigma=1.5)\n    return attention\n\n\n\n# the plot function can have additional kwargs for providing configuration points\ndef _overlay_attention(attention, image,\n                      alpha=0.5, cmap=\'jet\'):\n    fig = tfplot.Figure(figsize=(4, 4))\n    ax = fig.add_subplot(1, 1, 1)\n    ax.axis(\'off\')\n    fig.subplots_adjust(0, 0, 1, 1)  # get rid of margins\n\n    H, W = attention.shape\n    ax.imshow(image, extent=[0, H, 0, W])\n    ax.imshow(attention, cmap=cmap,\n                alpha=alpha, extent=[0, H, 0, W])\n    return fig\n\n\n\nclass TestOps(test_util.TestcaseBase):\n    \'\'\'\n    Tests tfplot.ops\n    \'\'\'\n\n    # ----------------------------------------------------------------------\n\n    def test_plot_basic(self):\n        \'\'\'1.1 A basic example\'\'\'\n\n        def test_figure():\n            fig, ax = tfplot.subplots(figsize=(4, 4))\n            ax.text(0.5, 0.5, ""Hello World!"", ha=\'center\', va=\'center\', size=24)\n            return fig\n\n        plot_op = tfplot.plot(test_figure, [])\n        r = self._execute_plot_op(plot_op, print_image=True)\n\n    def test_plot_with_arguments(self):\n        \'\'\'1.2 with Arguments that takes a tensor\'\'\'\n\n        def figure_attention(attention):\n            fig, ax = tfplot.subplots(figsize=(4, 3))\n            im = ax.imshow(attention, cmap=\'jet\')\n            fig.colorbar(im)\n            return fig\n\n        attention_tensor = tf.constant(fake_attention())\n        plot_op = tfplot.plot(figure_attention, [attention_tensor])\n        r = self._execute_plot_op(plot_op, print_image=True)\n\n        # TODO: how to compare images?\n\n    def test_plot_with_kwargs(self):\n        \'\'\'1.3 with kwargs\'\'\'\n\n        attention_tensor = fake_attention()\n        image_tensor = tf.constant(scipy.misc.face())\n\n        # (a) default execution\n        plot_op = tfplot.plot(_overlay_attention, [attention_tensor, image_tensor])\n        r = self._execute_plot_op(plot_op, print_image=True)\n        self.assertEqual(test_util.hash_image(r), \'c2d64dedd4aa54218e6df95bfeb03bbc17bd17fa\')\n\n        # (b) override cmap and alpha\n        plot_op = tfplot.plot(_overlay_attention, [attention_tensor, image_tensor],\n                              cmap=\'gray\', alpha=0.8)\n        r = self._execute_plot_op(plot_op, print_image=True)\n        self.assertEqual(test_util.hash_image(r), \'31c8029aed7bbafe37bb8c451a3220d573d2d0e0\')\n\n        # TODO: how to compare images?\n\n    def test_plot_with_unicode(self):\n        unicode_type = six.text_type\n\n        def fig_text_placeholder_scalar(text_scalar):\n            fig, ax = tfplot.subplots(figsize=(4, 1))\n            assert isinstance(text_scalar, unicode_type), str(type(text_scalar))\n            ax.text(0.5, 0.5, text_scalar, ha=\'center\', va=\'center\')\n            return fig\n        self._execute_plot_op(tfplot.plot(fig_text_placeholder_scalar,\n                                          [u""unicode should work here \xe2\x86\x91\xe2\x86\x93\xe2\x98\x85""]))\n\n        def fig_text_placeholder_tensor(text_tensor):\n            fig, ax = tfplot.subplots(figsize=(4, 1))\n            assert isinstance(text_tensor[0], unicode_type), str(type(text_tensor[0]))\n            assert isinstance(text_tensor[1], unicode_type), str(type(text_tensor[1]))\n            ax.text(0.5, 0.7, text_tensor[0], ha=\'center\', va=\'center\')\n            ax.text(0.5, 0.3, text_tensor[1], ha=\'center\', va=\'center\')\n            return fig\n        self._execute_plot_op(tfplot.plot(fig_text_placeholder_tensor, [\n            tf.convert_to_tensor([""ascii"", u""unicode \xe2\x98\x85""])\n        ]))\n\n    def test_plot_many(self):\n        \'\'\'1.4 plot_many\'\'\'\n        # make a fake batch\n        batch_size = 3\n        image_tensor = tf.constant(scipy.misc.face())\n        try:\n            attention_batch = tf.random.gamma([batch_size, 7, 7], alpha=0.3, seed=42)\n        except AttributeError:  # legacy TF versions\n            attention_batch = tf.random_gamma([batch_size, 7, 7], alpha=0.3, seed=42)\n\n        image_batch = tf.tile(tf.expand_dims(image_tensor, 0),\n                              [batch_size, 1, 1, 1], name=\'image_batch\') # copy\n\n        plot_op = tfplot.plot_many(_overlay_attention, [attention_batch, image_batch])\n        r = self._execute_plot_op(plot_op, print_image=False)\n        #for i in range(3): imgcat(r[i])\n        self.assertEqual(r.shape, (3, 400, 400, 4))\n'"
tfplot/summary.py,10,"b'\'\'\' Summary Op utilities. \'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport tensorflow as tf\nimport six\n\nfrom . import ops\nfrom . import wrapper\n\n\ntry:\n    summary_image_v1 = tf.compat.v1.summary.image\nexcept AttributeError:\n    summary_image_v1 = tf.summary.image\n\n\ndef plot(name, plot_func, in_tensors, collections=None, **kwargs):\n    """"""\n    Create a TensorFlow op that outpus a `Summary` protocol buffer,\n    to which a single plot operation is executed (i.e. image summary).\n\n    Basically, it is a one-liner wrapper of ``tfplot.ops.plot()`` and\n    ``tf.summary.image()`` calls.\n\n    The generated `Summary` object contains single image summary value\n    of the image of the plot drawn.\n\n    Args:\n      name: The name of scope for the generated ops and the summary op.\n        Will also serve as a series name prefix in TensorBoard.\n      plot_func: A python function or callable, specifying the plot operation\n        as in :func:`tfplot.plot`. See the documentation at :func:`tfplot.plot`.\n      in_tensors: A list of `Tensor` objects, as in :func:`~tfplot.plot`.\n      collections: Optional list of ``ops.GraphKeys``.  The collections to add the\n        summary to.  Defaults to ``[_ops.GraphKeys.SUMMARIES]``.\n      kwargs: Optional keyword arguments passed to :func:`~tfplot.plot`.\n\n    Returns:\n      A scalar `Tensor` of type `string`. The serialized `Summary` protocol\n      buffer (tensorflow operation).\n    """"""\n    with tf.name_scope(name):\n        im = ops.plot(plot_func, in_tensors, **kwargs)\n        im = tf.expand_dims(im, axis=0)\n        summary = summary_image_v1(name=""ImageSummary"", tensor=im, collections=collections)\n    return summary\n\n\ndef plot_many(name, plot_func, in_tensors,\n              max_outputs=3, collections=None, **kwargs):\n    """"""\n    Create a TensorFlow op that outputs a `Summary` protocol buffer,\n    where plots could be drawn in a batch manner. This is a batch version\n    of :func:`tfplot.summary.plot`.\n\n    Specifically, all the input tensors ``in_tensors`` to ``plot_func`` is\n    assumed to have the same batch size. Tensors corresponding to a single\n    batch element will be passed to ``plot_func`` as input.\n\n    The resulting `Summary` contains multiple (up to ``max_outputs``) image\n    summary values, each of which contains a plot rendered by ``plot_func``.\n\n    Args:\n      name: The name of scope for the generated ops and the summary op.\n        Will also serve as a series name prefix in TensorBoard.\n      plot_func: A python function or callable, specifying the plot operation\n        as in :func:`tfplot.plot`. See the documentation at :func:`tfplot.plot`.\n      in_tensors: A list of `Tensor` objects, the input to ``plot_func``\n        but each in a batch.\n      max_outputs: Max number of batch elements to generate plots for.\n      collections: Optional list of ``ops.GraphKeys``.  The collections to add the\n        sumamry to.  Defaults to ``[_ops.GraphKeys.SUMMARIES]``.\n      kwargs: Optional keyword arguments passed to :func:`~tfplot.plot`.\n\n    Returns:\n      A scalar `Tensor` of type `string`. The serialized `Summary` protocol\n      buffer (tensorflow operation).\n    """"""\n\n    with tf.name_scope(name=name) as scope:\n        im_batch = ops.plot_many(plot_func, in_tensors, name=scope,\n                                 max_outputs=max_outputs,\n                                 **kwargs)\n        summary = summary_image_v1(name=""ImageSummary"", tensor=im_batch,\n                                   max_outputs=max_outputs,\n                                   collections=collections)\n    return summary\n\n\ndef wrap(plot_func, _sentinel=None,\n         batch=False, name=None, **kwargs):\n    \'\'\'\n    Wrap a plot function as a TensorFlow summary builder. It will return a\n    python function that creates a TensorFlow op which evaluates to\n    ``Summary`` protocol buffer with image.\n\n    The resulting function (say ``summary_wrapped``) will have the following\n    signature:\n\n    .. code-block:: python\n\n       summary_wrapped(name, tensor, # [more input tensors ...],\n                       max_outputs=3, collections=None)\n\n    Examples:\n\n      Given a plot function which returns a matplotlib `Figure`,\n\n      >>> def figure_heatmap(data, cmap=\'jet\'):\n      >>>     fig, ax = tfplot.subplots()\n      >>>     ax.imshow(data, cmap=cmap)\n      >>>     return fig\n\n      we can wrap it as a summary builder function:\n\n      >>> summary_heatmap = tfplot.summary.wrap(figure_heatmap, batch=True)\n\n      Now, when building your computation graph, call it to build summary ops\n      like ``tf.summary.image``:\n\n      >>> heatmap_tensor\n      <tf.Tensor \'heatmap_tensor:0\' shape=(16, 128, 128) dtype=float32>\n      >>>\n      >>> summary_heatmap(""heatmap/original"", heatmap_tensor)\n      >>> summary_heatmap(""heatmap/cmap_gray"", heatmap_tensor, cmap=gray)\n      >>> summary_heatmap(""heatmap/no_default_collections"", heatmap_tensor, collections=[])\n\n\n    Args:\n      plot_func: A python function or callable to wrap. See the documentation\n        of :func:`tfplot.plot` for details.\n      batch: If True, all the tensors passed as argument will be\n        assumed to be batched. Default value is False.\n      name: A default name for the plot op (optional). If not given, the\n        name of ``plot_func`` will be used.\n      kwargs: Optional keyword arguments that will be passed by default to\n        :func:`~tfplot.plot`.\n\n    Returns:\n      A python function that will create a TensorFlow summary operation,\n      passing the provided arguments into plot op.\n    \'\'\'\n\n    if _sentinel is not None:\n        raise RuntimeError(""Invalid call: it can have only one unnamed argument, "" +\n                           ""please pass named arguments for batch, name, etc."")\n\n    factory_fn = wrapper.autowrap(plot_func, batch=batch, name=name, **kwargs)\n    def _summary_fn(summary_name, *args, **kwargs_call):\n        if not isinstance(summary_name, six.string_types):\n            raise TypeError(""summary_name should be a string"")\n\n        plot_op = factory_fn(*args, **kwargs_call)\n        if not batch:\n            # add batch dimension expected by tf.summary.image\n            plot_op = tf.expand_dims(plot_op, axis=0)\n        return summary_image_v1(summary_name, plot_op,\n                                max_outputs=kwargs_call.pop(\'max_outputs\', 3),\n                                collections=kwargs_call.pop(\'collections\', None),\n                                )\n\n    _summary_fn.__name__ = \'summary_fn[%s]\' % plot_func\n    return _summary_fn\n\n\n__all__ = (\n    \'wrap\',\n    \'plot\',\n    \'plot_many\',\n)\n'"
tfplot/summary_test.py,4,"b'\'\'\'Unit Test for tfplot.summary\'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport unittest\nimport types\nimport sys\nimport os\nimport re\n\nimport tensorflow as tf\nos.environ[\'TF_CPP_MIN_LOG_LEVEL\'] = \'3\'  # filter out INFO and WARN logs\n\ntry:\n    from tensorflow import Summary\nexcept ImportError:\n    # TF 2.0\n    import tensorflow\n    Summary = tensorflow.compat.v1.Summary\n\nimport matplotlib\nmatplotlib.rcParams[\'figure.figsize\'] = (2.5, 2.5)\n\nfrom imgcat import imgcat\nfrom termcolor import cprint\nimport seaborn as sns\nimport numpy as np\n\nimport tfplot.summary\nimport tfplot.test_util as test_util\n\ntest_util.configure_tf_verbosity()\n\n\nclass TestSummary(test_util.TestcaseBase):\n    \'\'\'\n    Tests tfplot.summary\n    \'\'\'\n\n    def _execute_summary_op(self, op, feed_dict={}):\n        \'\'\'\n        Execute the summary op, and parse the result into Summary proto object.\n        \'\'\'\n        with self.cached_session() as sess:\n            cprint(""\\n >>> "" + str(op), color=\'magenta\')\n            self.assertIsInstance(op, tf.Tensor)\n            self.assertTrue(op.dtype, tf.string)\n            ret = sess.run(op, feed_dict=feed_dict)\n\n            # check ret is a byte\n            self.assertIsInstance(ret, bytes)\n            summary = Summary()\n            summary.ParseFromString(ret)\n            return summary\n\n\n    def test_summary_plot(self):\n        \'\'\'tests tfplot.summary.plot\'\'\'\n\n        def test_figure(text):\n            fig, ax = tfplot.subplots(figsize=(3, 2))\n            ax.text(0.5, 0.5, text, ha=\'center\')\n            return fig\n\n        summary_op = tfplot.summary.plot(""text/hello"", test_figure, [""Hello Summary""])\n        s = self._execute_summary_op(summary_op)\n\n        # pylint: disable=no-member\n        self.assertTrue(s.value[0].tag.startswith(\'text/hello\'))\n        self.assertEqual(s.value[0].image.width, 300)    # default dpi = 100\n        self.assertEqual(s.value[0].image.height, 200)   # default dpi = 100\n        png = s.value[0].image.encoded_image_string\n        # pylint: enable=no-member\n\n        if sys.platform == \'darwin\':\n            imgcat(png)\n        self.assertEqual(test_util.hash_image(png), \'dbb47a3281626678894084fa58066f69a2570df4\')\n\n\n    def test_summary_wrap_batch(self):\n        \'\'\'tests tfplot.summary.wrap\'\'\'\n\n        summary_heatmap = tfplot.summary.wrap(sns.heatmap, figsize=(2, 2), cmap=\'jet\',\n                                              batch=True)\n\n        batch_size = 3\n        summary_op = summary_heatmap(""heatmap_1"",\n                                     tf.constant(np.random.RandomState(42).normal(size=[batch_size, 4, 4])),\n                                     max_outputs=2,\n                                     )\n        s = self._execute_summary_op(summary_op)\n\n        self.assertEqual(len(s.value), 2)\n        self.assertEqual(s.value[0].tag, (\'heatmap_1/image/0\'))\n        self.assertEqual(s.value[1].tag, (\'heatmap_1/image/1\'))\n\n        if sys.platform == \'darwin\':\n            imgcat(s.value[0].image.encoded_image_string)\n            imgcat(s.value[1].image.encoded_image_string)\n\n\n    def test_summary_wrap_nobatch(self):\n        \'\'\'tests tfplot.summary.wrap\'\'\'\n\n        summary_heatmap = tfplot.summary.wrap(sns.heatmap, figsize=(2, 2), cmap=\'jet\',\n                                              batch=False)\n\n        summary_op = summary_heatmap(""heatmap_1"",\n                                     tf.constant(np.random.RandomState(42).normal(size=[4, 4])),\n                                     )\n        s = self._execute_summary_op(summary_op)\n\n        self.assertEqual(len(s.value), 1)\n        self.assertEqual(s.value[0].tag, (\'heatmap_1/image/0\'))\n\n        if sys.platform == \'darwin\':\n            imgcat(s.value[0].image.encoded_image_string)\n\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tfplot/test_util.py,6,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\nimport tensorflow as tf\n\n# Disable eager mode until tfplot implements eager compatibility.\nif tf.__version__ >= \'2.0\':\n    tf.compat.v1.disable_eager_execution()\n\nimport hashlib\nfrom imgcat import imgcat\nfrom termcolor import cprint\n\ndef configure_tf_verbosity():\n    try:\n        tf_logging = tf.logging\n    except AttributeError:\n        # TF 2.0\n        tf_logging = tf.compat.v1.logging\n\n    tf_logging.set_verbosity(tf_logging.ERROR)\n\n\ndef hash_image(img):\n    if isinstance(img, bytes):\n        return hashlib.sha1(img).hexdigest()\n    else:\n        return hashlib.sha1(img.tobytes()).hexdigest()\n\n\nclass TestcaseBase(tf.test.TestCase):\n\n    def _execute_plot_op(self, op, print_image=True, feed_dict={}):\n        \'\'\'\n        Execute the op, and get the result (e.g. ndarray) under a test session\n        \'\'\'\n        with self.cached_session() as sess:\n            cprint(""\\n >>> "" + str(op), color=\'cyan\')\n            self.assertIsInstance(op, tf.Tensor)\n            ret = sess.run(op, feed_dict=feed_dict)\n            if print_image and sys.platform == \'darwin\':\n                print(\' \', end=\'\')\n                sys.stdout.flush()\n                imgcat(ret)\n                print(\'SHA1: \' + hash_image(ret))\n            return ret\n\n\nif not hasattr(TestcaseBase, \'cached_session\'):\n    TestcaseBase.cached_session = TestcaseBase.test_session\n'"
tfplot/util.py,0,"b'\'\'\'Miscellaneous utilities.\'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport inspect\nimport six\nimport numpy as np\n\n\ndef get_class_defining_method(m):\n    \'\'\'\n    Get the class type that defines `m`, if it is a method.  If m is not a\n    method, returns None. Should work both in python 2 and 3.\n\n    Code originated from https://stackoverflow.com/questions/3589311/\n    \'\'\'\n    if inspect.ismethod(m):\n        if hasattr(m, \'im_class\'):\n            return m.im_class\n        for cls in inspect.getmro(m.__self__.__class__):\n            if cls.__dict__.get(m.__name__) is m:\n                return cls\n        m = m.__func__\n\n    if inspect.isfunction(m):\n        try:\n            cls = getattr(inspect.getmodule(m),\n                          m.__qualname__.split(\'.<locals>\', 1)[0].rsplit(\'.\', 1)[0])\n            if isinstance(cls, type):\n                return cls\n        except AttributeError:\n            return None\n\n    return None\n\n\n# getargspec(fn)\nif six.PY2:\n    getargspec = inspect.getargspec\n\n    def getargspec_allargs(func):\n        argspec = getargspec(func)\n        return argspec.args\n\nelse: # Python 3\n    getargspec = inspect.getfullargspec\n\n    def getargspec_allargs(func):\n        argspec = getargspec(func)\n        return argspec.args + argspec.kwonlyargs\n\n\ndef merge_kwargs(kwargs, kwargs_new):\n    \'\'\'\n    Merge two kwargs.\n\n    One could simply use {**kwargs, **kwargs_new} to merge two kwargs dict,\n    but we should support old python versions too.\n\n    Moreover, values for duplicated key will be overwritten (in favor of kwargs_new).\n    \'\'\'\n    kwargs = kwargs.copy()\n    kwargs.update(kwargs_new)\n    return kwargs\n\n\n_np_decode = np.vectorize(lambda b: b.decode(\'utf8\'))\n\ndef decode_bytes_if_necessary(arg):\n    """"""\n    Decodes scalar bytes and ndarray of bytes into unicode counterparts.\n    """"""\n    if isinstance(arg, bytes):\n        # Regardless of python 2 and 3, return as unicode.\n        return arg.decode(\'utf8\')\n    if isinstance(arg, np.ndarray) and arg.dtype == object:\n        return _np_decode(arg)\n    else:\n        return arg\n\n\n__all__ = (\n    \'get_class_defining_method\',\n    \'getargspec\',\n    \'merge_kwargs\',\n    \'decode_bytes_if_necessary\',\n)\n'"
tfplot/wrapper.py,0,"b'\'\'\' Main plot operations. \'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\nimport re\n\nfrom . import figure\nfrom . import util\nfrom .ops import plot, plot_many\nfrom .util import merge_kwargs\n\nfrom biwrap import biwrap\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.axes import Axes\n\n\n# a dummy marker object to avoid pylint issues on decorators.\nREQUIRED = object()\n\n\n@biwrap\ndef wrap(plot_func=REQUIRED, _sentinel=None,\n         batch=False, name=None,\n         **kwargs):\n    \'\'\'\n    Wrap a plot function as a TensorFlow operation. It will return a python\n    function that creates a TensorFlow plot operation applying the arguments\n    as input. It can be also used as a decorator.\n\n    For example:\n\n      >>> @tfplot.wrap\n      >>> def plot_imshow(img):\n      >>>    fig, ax = tfplot.subplots()\n      >>>    ax.imshow(img)\n      >>>    return fig\n      >>>\n      >>> plot_imshow(an_image_tensor)\n      Tensor(""plot_imshow:0"", shape=(?, ?, 4), dtype=uint8)\n\n    Or, if ``plot_func`` is a python function that takes  numpy arrays as input\n    and draw a plot by returning a matplotlib Figure,\n    we can wrap this function as a `Tensor` factory, such as:\n\n      >>> tf_plot = tfplot.wrap(plot_func, name=""MyPlot"", batch=True)\n      >>> # x, y = get_batch_inputs(batch_size=4, ...)\n      >>> plot_x = tf_plot(x)\n      Tensor(""MyPlot:0"", shape=(4, ?, ?, 4), dtype=uint8)\n      >>> plot_y = tf_plot(y)\n      Tensor(""MyPlot_1:0"", shape=(4, ?, ?, 4), dtype=uint8)\n\n    Args:\n      plot_func: A python function or callable to wrap. See the documentation\n        of :func:`tfplot.plot()` for details.\n      batch: If True, all the tensors passed as argument will be\n        assumed to be batched. Default value is False.\n      name: A default name for the operation (optional). If not given, the\n        name of ``plot_func`` will be used.\n      kwargs: An optional kwargs that will be passed by default to\n        ``plot_func`` when executed inside a TensorFlow graph.\n\n    Returns:\n      A python function that will create a TensorFlow plot operation,\n      passing the provided arguments.\n    \'\'\'\n\n    if plot_func == REQUIRED:\n        raise TypeError(""Required argument \'plot_func\' (pos 1) not found"")\n    if not hasattr(plot_func, \'__call__\'):\n        raise TypeError(""plot_func should be callable"")\n    if _sentinel is not None:\n        raise RuntimeError(""Invalid call: it can have only one positional argument, "" +\n                           ""please pass named arguments for batch, name, etc."")\n\n    if name is None:\n        name = _clean_name(plot_func.__name__)\n\n    @functools.wraps(plot_func)\n    def _wrapped_fn(*args, **kwargs_call):\n        _plot = plot_many if batch else plot\n        _name = kwargs_call.pop(\'name\', name)\n        return _plot(plot_func, list(args), name=_name,\n                     **merge_kwargs(kwargs, kwargs_call))\n\n    _wrapped_fn.__name__ = \'wrap[%s]\' % plot_func.__name__\n    if hasattr(plot_func, \'__qualname__\'):\n        _wrapped_fn.__qualname__ = \'wrap[%s.%s]\' % (plot_func.__module__, plot_func.__qualname__)\n    return _wrapped_fn\n\n\ndef wrap_axesplot(axesplot_func, _sentinel=None,\n                  batch=False, name=None,\n                  figsize=None, tight_layout=False, **kwargs):\n    \'\'\'\n    DEPRECATED: Use ``tfplot.autowrap()`` instead. Will be removed\n    in the next version.\n\n    Wrap an axesplot function as a TensorFlow operation.  It will return a\n    python function that creates a TensorFlow plot operation applying the\n    arguments as input.\n\n    An axesplot function ``axesplot_func`` can be either:\n\n    - an unbounded method of matplotlib `Axes` (or `AxesSubplot`) class,\n      such as ``Axes.scatter()`` and ``Axes.text()``, etc, or\n    - a simple python function that takes the named argument ``ax``,\n      of type `Axes` or `AxesSubplot`, on which the plot will be drawn.\n      Some good examples of this family includes ``seaborn.heatmap(ax=...)``.\n\n    The resulting function can be used as a Tensor factory. When the created\n    tensorflow plot op is being executed, a new matplotlib figure which\n    consists of a single `AxesSubplot` will be created, and the axes plot\n    will be used as an argument for ``axesplot_func``. For example,\n\n      >>> import seaborn.apionly as sns\n      >>> tf_heatmap = tfplot.wrap_axesplot(sns.heatmap, name=""HeatmapPlot"", figsize=(4, 4), cmap=\'jet\')\n\n      >>> plot_op = tf_heatmap(attention_map, cmap)\n      Tensor(HeatmapPlot:0"", shape=(?, ?, 4), dtype=uint8)\n\n    Args:\n      axesplot_func: An unbounded method of matplotlib `Axes` or `AxesSubplot`,\n          or a python function or callable which has the `ax` parameter for\n          specifying the axis to draw on.\n      batch: If True, all the tensors passed as argument will be\n        assumed to be batched. Default value is False.\n      name: A default name for the operation (optional). If not given, the\n        name of ``axesplot_func`` will be used.\n      figsize: The figure size for the figure to be created.\n      tight_layout: If True, the resulting figure will have no margins for\n        axis. Equivalent to calling ``fig.subplots_adjust(0, 0, 1, 1)``.\n      kwargs: An optional kwargs that will be passed by default to\n        ``axesplot_func``.\n\n    Returns:\n      A python function that will create a TensorFlow plot operation,\n      passing the provied arguments and a new instance of `AxesSubplot` into\n      ``axesplot_func``.\n    \'\'\'\n\n    if not hasattr(axesplot_func, \'__call__\'):\n        raise TypeError(""axesplot_func should be callable"")\n    if _sentinel is not None:\n        raise RuntimeError(""Invalid call: it can have only one unnamed argument, "" +\n                           ""please pass named arguments for batch, name, etc."")\n\n    def _create_subplots():\n        if figsize is not None:\n            fig, ax = figure.subplots(figsize=figsize)\n        else:\n            fig, ax = figure.subplots()\n\n        if tight_layout:\n            fig.subplots_adjust(0, 0, 1, 1)\n        return fig, ax\n\n    # (1) instance method of Axes -- ax.xyz()\n    def _fig_axesplot_method(*args, **kwargs_call):\n        fig, ax = _create_subplots()\n        axesplot_func.__get__(ax)(*args, **merge_kwargs(kwargs, kwargs_call))\n        return fig\n\n    # (2) xyz(ax=...) style\n    def _fig_axesplot_fn(*args, **kwargs_call):\n        fig, ax = _create_subplots()\n        axesplot_func(*args, ax=ax, **merge_kwargs(kwargs, kwargs_call))\n        return fig\n\n    method_class = util.get_class_defining_method(axesplot_func)\n    if method_class is not None and issubclass(method_class, Axes):\n        # (1) Axes.xyz()\n        if hasattr(axesplot_func, \'__self__\') and axesplot_func.__self__:\n            raise ValueError(""axesplot_func should be a unbound method of "" +\n                             ""Axes or AxesSubplot, but given a bound method "" +\n                             str(axesplot_func))\n        fig_axesplot_func = _fig_axesplot_method\n    else:\n        # (2) xyz(ax=...)\n        if \'ax\' not in util.getargspec_allargs(axesplot_func):\n            raise TypeError(""axesplot_func must take \'ax\' parameter to specify Axes"")\n        fig_axesplot_func = _fig_axesplot_fn\n\n    if name is None:\n        name = _clean_name(axesplot_func.__name__)\n\n    @functools.wraps(axesplot_func)\n    def _wrapped_factory_fn(*args, **kwargs_call):\n        _plot = plot_many if batch else plot\n        _name = kwargs_call.pop(\'name\', name)\n        return _plot(fig_axesplot_func, list(args), name=_name,\n                     **kwargs_call)\n\n    _wrapped_factory_fn.__name__ = \'wrapped_axesplot_fn[%s]\' % axesplot_func\n    return _wrapped_factory_fn\n\n\n@biwrap\ndef autowrap(plot_func=REQUIRED, _sentinel=None,\n             batch=False, name=None, figsize=None, tight_layout=False,\n             **kwargs_default):\n    """"""\n    Wrap a function as a TensorFlow operation similar to :func:`tfplot.wrap()`\n    (as a decorator or with normal function call), but provides with additional\n    features such as auto-creating matplotlib figures.\n\n      - (``fig``, ``ax``) matplotlib objects are automatically created and\n        injected given that `plot_func` has a keyword argument named ``fig``\n        and/or ```ax``. In such cases, we do not need to manually call\n        :func:`tfplot.subplots()` to create matplotlib figure/axes objects.\n        If a manual creation of ``fig, ax`` is forced, please consider\n        using :func:`tfplot.wrap()` instead.\n\n      - It can automatically handle return values of the provided `plot_func`\n        function. If it returns nothing (None) but ``fig`` was automatically\n        injected then the resulting figure will be drawn, or returns ``Axes``\n        then the associated ``Figure`` will be used.\n\n    Example:\n\n      >>> @tfplot.autowrap(figsize=(3, 3))\n      >>> def plot_imshow(img, *, fig, ax):\n      >>>    ax.imshow(img)\n      >>>\n      >>> plot_imshow(an_image_tensor)\n      Tensor(""plot_imshow:0"", shape=(?, ?, 4), dtype=uint8)\n\n    Args:\n      plot_func: A python function or callable to wrap. See the documentation\n        of :func:`tfplot.plot()` for details. Additionally, if this function\n        has a parameter named ``fig`` and/or ``ax``, new instances of\n        ``Figure`` and/or ``AxesSubplot`` will be created and passed.\n\n      batch: If True, all the tensors passed as argument will be\n        assumed to be batched. Default value is False.\n      name: A default name for the operation (optional). If not given, the\n        name of ``plot_func`` will be used.\n\n      figsize: The figure size for the figure to be created.\n      tight_layout: If True, the resulting figure will have no margins for\n        axis. Equivalent to calling ``fig.subplots_adjust(0, 0, 1, 1)``.\n      kwargs_default: An optimal kwargs that will be passed by default to\n        ``plot_func`` when executed inside a TensorFlow graph.\n\n    """"""\n\n    if plot_func == REQUIRED:\n        raise TypeError(""Required argument \'plot_func\' (pos 1) not found"")\n\n    # check if func has `fig` or `ax` parameter\n    fig_ax_mode = tuple(\n        arg_name for arg_name in (\'ax\', \'fig\') \\\n        if arg_name in util.getargspec_allargs(plot_func)\n    )\n\n    # check if func is an instance method of Axes, e.g. ax.scatter()\n    method_class = util.get_class_defining_method(plot_func)\n    is_axesplot_bind = False\n    if method_class is not None and issubclass(method_class, Axes):\n        if hasattr(plot_func, \'__self__\') and plot_func.__self__:\n            raise ValueError(""plot_func should be a unbound method of "" +\n                             ""Axes or AxesSubplot, but given a bound method "" +\n                             str(plot_func))\n        is_axesplot_bind = True\n\n\n    def _create_subplots(_kwargs):\n        # recognize overriding parameters for creating subplots, e.g. figsize\n        _figsize = _kwargs.pop(\'figsize\', figsize)\n\n        fig, ax = figure.subplots(figsize=_figsize)\n        return fig, ax\n\n    # Decorates `plot_func` with additional aspects\n    # (e.g. auto-injection, return value handling)\n    @functools.wraps(plot_func)\n    def _wrapped_plot_fn(*args, **kwargs_call):\n        # (1) auto-inject fig, ax\n        if fig_ax_mode or is_axesplot_bind:\n            # auto-create rather than manually\n            fig, ax = _create_subplots(kwargs_call)\n        fig_ax_kwargs = dict(\n            ([(\'fig\', fig)] if \'fig\' in fig_ax_mode else []) + \\\n            ([(\'ax\', ax)] if \'ax\' in fig_ax_mode else [])\n        )\n\n        # (2) body\n        if is_axesplot_bind:   # e.g. Axesplot.scatter -> bind \'ax\' as self\n            ret = plot_func.__get__(ax)(*args, **kwargs_call)\n        else:\n            ret = plot_func(*args, **merge_kwargs(kwargs_call, fig_ax_kwargs))  # TODO conflict??\n\n        # (3) return value handling\n        if ret is None and fig_ax_mode:\n            # even if the function doesn\'t return anything,\n            # but we know that `fig` is what we just need to draw.\n            ret = fig\n        elif is_axesplot_bind:\n            # for Axesplot methods, ignore the return value\n            # and use the fig instance created before as target figure\n            ret = fig\n        elif isinstance(ret, Axes):\n            ret = fig = ret.figure\n        elif isinstance(ret, Figure):\n            fig = ret\n\n        if tight_layout:\n            fig.subplots_adjust(0, 0, 1, 1)\n\n        return ret\n\n    # return the wrapper (a factory of Tensor)\n    _wrapped_fn = wrap(_wrapped_plot_fn, batch=batch, name=name,\n                       **kwargs_default)\n\n    _wrapped_fn.__name__ = \'autowrap[%s]\' % plot_func.__name__\n    if hasattr(plot_func, \'__qualname__\'):\n        _wrapped_fn.__qualname__ = \'autowrap[%s.%s]\' % (plot_func.__module__, plot_func.__qualname__)\n\n\n    # expose the unwrapped python function as well\n    _wrapped_fn.__unwrapped__ = plot_func\n\n    return _wrapped_fn\n\n\ndef _clean_name(s):\n    """"""\n    Convert a string to a valid variable, function, or scope name.\n    """"""\n    return re.sub(\'[^0-9a-zA-Z_]\', \'\', s)\n\n\n__all__ = (\n    \'wrap\',\n    \'wrap_axesplot\',\n    \'autowrap\',\n)\n'"
tfplot/wrapper_test.py,5,"b'\'\'\'Unit Test for tfplot.ops\'\'\'\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport unittest\nimport types\nimport sys\nimport os\nimport re\n\nimport tensorflow as tf\nos.environ[\'TF_CPP_MIN_LOG_LEVEL\'] = \'3\'  # filter out INFO and WARN logs\n\nimport matplotlib\nmatplotlib.rcParams[\'figure.figsize\'] = (2.5, 2.5)\n\nfrom imgcat import imgcat\nfrom termcolor import cprint\nimport seaborn as sns\nimport numpy as np\n\nimport tfplot.figure\nimport tfplot.test_util as test_util\n\ntest_util.configure_tf_verbosity()\n\n\nclass TestWrap(test_util.TestcaseBase):\n    \'\'\'\n    Tests tfplot.wrap() and wrap_axesplot()\n    \'\'\'\n\n    def _check_plot_op_shape(self, op):\n        \'\'\'Check if op is a uint8 Tensor of shape [?, ?, 4]\'\'\'\n        cprint("" op: %s"" % op, color=\'cyan\')\n        self.assertIsInstance(op, tf.Tensor)\n\n        self.assertEqual(len(op.get_shape()), 3)\n        self.assertTrue(op.get_shape().is_compatible_with([None, None, 4]))   # RGB-A\n        self.assertEqual(op.dtype, tf.uint8)\n\n    def test_wrap_simplefunction(self):\n        \'\'\'Basic functionality test of tfplot.wrap() in successful cases.\'\'\'\n\n        def _fn_to_wrap(message=""str""):\n            fig, ax = tfplot.figure.subplots()\n            ax.text(0.5, 0.5, message)\n            return fig\n\n        # the function to create TensorFlow ops\n        tf_plot = tfplot.wrap(_fn_to_wrap, name=\'Wrapped\')\n        cprint(""\\n tf_plot: %s"" % tf_plot, color=\'magenta\')\n        self.assertIsInstance(tf_plot, types.FunctionType)\n\n        # TensorFlow plot_op\n        plot_op = tf_plot(""hello world"")\n        self._check_plot_op_shape(plot_op)\n        self.assertEqual(plot_op.name, \'Wrapped:0\')\n\n    def test_wrap_axesplot_axes(self):\n        \'\'\'Basic functionality test of tfplot.wrap_axesplot() in successful cases.\'\'\'\n\n        # (case i) an instance of matplotlib axes\n        from matplotlib.axes import Axes\n        tf_scatter = tfplot.wrap_axesplot(Axes.scatter)\n        cprint(""\\n tf_scatter: %s"" % tf_scatter, color=\'magenta\')\n\n        plot_op = tf_scatter([1, 2, 3], [1, 4, 9])\n        self._check_plot_op_shape(plot_op)\n        self.assertTrue(re.match(\'scatter(_\\d)?:0\', plot_op.name))\n\n    def test_wrap_axesplot_kwarg(self):\n        \'\'\'Basic functionality test of tfplot.wrap_axesplot() in successful cases.\'\'\'\n\n        # (case ii) any unbounded function that has \'ax=...\' keyword parameter\n        def fn_to_wrap(ax=None):\n            ax.text(0.5, 0.5, ""Hello!"")\n            return ax\n        # TODO: _fn_to_wrap has an error\n\n        tf_plot = tfplot.wrap_axesplot(fn_to_wrap)\n        cprint(""\\n tf_plot: %s"" % tf_plot, color=\'magenta\')\n        self.assertIsInstance(tf_plot, types.FunctionType)\n\n        # TensorFlow plot_op\n        plot_op = tf_plot(""hello world"")\n        self._check_plot_op_shape(plot_op)\n        self.assertEqual(plot_op.name, \'fn_to_wrap:0\')\n\n    def test_wrap_axesplot_invalid(self):\n        \'\'\'Invalid usage of tfplot.wrap_axesplot().\'\'\'\n        fig, ax = tfplot.figure.subplots()\n\n        with self.assertRaises(ValueError):\n            # it should raise a ValueError about bound method\n            tf_plot = tfplot.wrap_axesplot(ax.scatter)\n\n    def test_autowrap_call_axesplot(self):\n        \'\'\'Does autowrap also work with Axes.xxxx methods?\n        needs to handle binding (e.g. self) carefully! \'\'\'\n        from matplotlib.axes import Axes\n        tf_scatter = tfplot.autowrap(Axes.scatter, name=\'ScatterAutowrap\')\n        cprint(""\\n tf_scatter: %s"" % tf_scatter, color=\'magenta\')\n\n        op = tf_scatter([1, 2, 3], [1, 4, 9])\n        self._execute_plot_op(op)\n\n    def test_autowrap_call_extrakwargs(self):\n        \'\'\'when calling autowrap to wrap a seaborn plot function,\n        additional kwargs (non-standard) should be applied as default arguments\n        for the actual py.func invocation.\'\'\'\n        tf_heatmap = tfplot.autowrap(sns.heatmap, figsize=(2, 2),\n                                     tight_layout=True, cmap=\'jet\', cbar=False,\n                                     xticklabels=False, yticklabels=False)\n        op = tf_heatmap(tf.constant(np.eye(5)))\n        r = self._execute_plot_op(op)\n        self.assertEqual(test_util.hash_image(r), \'528047f739fe6dc4ba4ec1738b3a44b5bc95ecff\')\n\n    def test_autowrap_call_extrakwargs_unknownargswillerror(self):\n        \'\'\'additional kwargs should be applied to the py.func,\n        but unknown arguments should be trigger an error.\'\'\'\n        def known_func(x, ax=None):\n            assert (x is not None) and (ax is not None)\n        tf_heatmap = tfplot.autowrap(known_func, figsize=(2, 2),\n                                     unknown_arg_should_be_error=\'ERRRRRRRR\')\n        op = tf_heatmap(tf.constant(np.eye(5)))\n\n        from tensorflow.python.framework.errors_impl import InvalidArgumentError\n        with self.assertRaises(InvalidArgumentError):\n            r = self._execute_plot_op(op)\n\n\n\nclass TestDecorator(test_util.TestcaseBase):\n    """"""\n    Usage of tfplot.wrap() and tfplot.autowrap() as decorator.\n    """"""\n\n    def test_wrap_simple(self):\n        \'\'\'Use as decorator\'\'\'\n        @tfplot.wrap\n        def foo():\n            fig, ax = tfplot.subplots()\n            ax.plot([1, 2, 3])\n            fig.tight_layout()\n            return fig\n\n        self._execute_plot_op(op=foo())\n\n    def test_wrap_withcall(self):\n        \'\'\'Use as decorator, but with function call\'\'\'\n        @tfplot.wrap()\n        def foo():\n            fig, ax = tfplot.subplots()\n            ax.plot([1, 2, 3])\n            fig.tight_layout()\n            return fig\n\n        self._execute_plot_op(op=foo())\n\n    def test_wrap_withcall_argument(self):\n        \'\'\'Use as decorator, but with function call with arguments\'\'\'\n        @tfplot.wrap()\n        def foo(values):\n            fig, ax = tfplot.subplots()\n            ax.plot(values)\n            fig.tight_layout()\n            return fig\n\n        op = foo(tf.convert_to_tensor([2, 2, 3, 3]))\n        self._execute_plot_op(op)\n\n    def test_wrap_autoinject_figax(self):\n        """"""Tests whether @tfplot.autowrap work in many use cases""""""\n        @tfplot.autowrap\n        def foo_autoinject_return_fig(fig=None, ax=None):\n            # fig, ax should have been autoinjected\n            assert fig and isinstance(fig, matplotlib.figure.Figure)\n            assert ax and isinstance(ax, matplotlib.axes.Axes)\n\n            ax.text(0.5, 0.5, ""autoinject"", ha=\'center\')\n            return fig\n        self._execute_plot_op(foo_autoinject_return_fig())\n\n        @tfplot.autowrap\n        def foo_autoinject_return_ax(ax=None):\n            ax.text(0.5, 0.5, ""autoinject"", ha=\'center\')\n            return ax\n        self._execute_plot_op(foo_autoinject_return_ax())\n\n        @tfplot.autowrap\n        def foo_autoinject_return_nothing(fig=None, ax=None):\n            ax.text(0.5, 0.5, ""autoinject"", ha=\'center\')\n        self._execute_plot_op(foo_autoinject_return_nothing())\n\n        @tfplot.wrap\n        def foo_autoinject_shouldntwork(fig=None, ax=None):\n            ax.text(0.5, 0.5, ""autoinject"", ha=\'center\')\n        with self.assertRaises(Exception):\n            self._execute_plot_op(foo_autoinject_shouldntwork())\n\n    @unittest.skipIf(sys.version_info[0] < 3, ""Python 3+"")\n    def test_wrap_autoinject_kwonly_py3(self):\n        """"""Tests whether @tfplot.autowrap on functions with keyword-only argument""""""\n\n        # Python2 will raise a SyntaxError, so dynamically compile the code on runtime.\n        ctx = {}\n        exec(\'\'\'if ""this is Python2 SyntaxError workaround"":\n\n        @tfplot.autowrap\n        def foo_autoinject_kwonly(*, fig, ax):\n            ax.text(0.5, 0.5, ""autoinject-kwonly"", ha=\'center\')\n            return fig\n\n        ctx[\'foo_autoinject_kwonly\'] = foo_autoinject_kwonly\n        \'\'\')\n\n        foo_autoinject_kwonly = ctx[\'foo_autoinject_kwonly\']\n        self._execute_plot_op(foo_autoinject_kwonly())  # pylint: disable=missing-kwoa\n\n\n    def test_wrap_autowrap_arguments(self):\n        """"""Tests optional arguments (gigsize, tight_layouts) of @tfplot.autowrap""""""\n\n        @tfplot.autowrap(figsize=(4, 1))\n        def wrappee_figsize(fig=None):\n            return fig\n\n        im = self._execute_plot_op(wrappee_figsize())\n        assert im.shape[0] * 4 == im.shape[1], str(im.shape)     # e.g. 100x400\n\n        @tfplot.autowrap(tight_layout=True)\n        def wrappee_tight(fig=None):\n            return fig\n\n        im = self._execute_plot_op(wrappee_tight())\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
