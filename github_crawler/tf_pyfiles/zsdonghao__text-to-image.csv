file_path,api_count,code
data_loader.py,0,"b'\nimport os\nimport re\nimport time\nimport nltk\nimport re\nimport string\nimport tensorlayer as tl\nfrom utils import *\n\n\ndataset = \'102flowers\' #\nneed_256 = True # set to True for stackGAN\n\n\n\nif dataset == \'102flowers\':\n    """"""\n    images.shape = [8000, 64, 64, 3]\n    captions_ids = [80000, any]\n    """"""\n    cwd = os.getcwd()\n    img_dir = os.path.join(cwd, \'102flowers\')\n    caption_dir = os.path.join(cwd, \'text_c10\')\n    VOC_FIR = cwd + \'/vocab.txt\'\n\n    ## load captions\n    caption_sub_dir = load_folder_list( caption_dir )\n    captions_dict = {}\n    processed_capts = []\n    for sub_dir in caption_sub_dir: # get caption file list\n        with tl.ops.suppress_stdout():\n            files = tl.files.load_file_list(path=sub_dir, regx=\'^image_[0-9]+\\.txt\')\n            for i, f in enumerate(files):\n                file_dir = os.path.join(sub_dir, f)\n                key = int(re.findall(\'\\d+\', f)[0])\n                t = open(file_dir,\'r\')\n                lines = []\n                for line in t:\n                    line = preprocess_caption(line)\n                    lines.append(line)\n                    processed_capts.append(tl.nlp.process_sentence(line, start_word=""<S>"", end_word=""</S>""))\n                assert len(lines) == 10, ""Every flower image have 10 captions""\n                captions_dict[key] = lines\n    print("" * %d x %d captions found "" % (len(captions_dict), len(lines)))\n\n    ## build vocab\n    if not os.path.isfile(\'vocab.txt\'):\n        _ = tl.nlp.create_vocab(processed_capts, word_counts_output_file=VOC_FIR, min_word_count=1)\n    else:\n        print(""WARNING: vocab.txt already exists"")\n    vocab = tl.nlp.Vocabulary(VOC_FIR, start_word=""<S>"", end_word=""</S>"", unk_word=""<UNK>"")\n\n    ## store all captions ids in list\n    captions_ids = []\n    try: # python3\n        tmp = captions_dict.items()\n    except: # python3\n        tmp = captions_dict.iteritems()\n    for key, value in tmp:\n        for v in value:\n            captions_ids.append( [vocab.word_to_id(word) for word in nltk.tokenize.word_tokenize(v)] + [vocab.end_id])  # add END_ID\n            # print(v)              # prominent purple stigma,petals are white inc olor\n            # print(captions_ids)   # [[152, 19, 33, 15, 3, 8, 14, 719, 723]]\n            # exit()\n    captions_ids = np.asarray(captions_ids)\n    print("" * tokenized %d captions"" % len(captions_ids))\n\n    ## check\n    img_capt = captions_dict[1][1]\n    print(""img_capt: %s"" % img_capt)\n    print(""nltk.tokenize.word_tokenize(img_capt): %s"" % nltk.tokenize.word_tokenize(img_capt))\n    img_capt_ids = [vocab.word_to_id(word) for word in nltk.tokenize.word_tokenize(img_capt)]#img_capt.split(\' \')]\n    print(""img_capt_ids: %s"" % img_capt_ids)\n    print(""id_to_word: %s"" % [vocab.id_to_word(id) for id in img_capt_ids])\n\n    ## load images\n    with tl.ops.suppress_stdout():  # get image files list\n        imgs_title_list = sorted(tl.files.load_file_list(path=img_dir, regx=\'^image_[0-9]+\\.jpg\'))\n    print("" * %d images found, start loading and resizing ..."" % len(imgs_title_list))\n    s = time.time()\n\n    # time.sleep(10)\n    # def get_resize_image(name):   # fail\n    #         img = scipy.misc.imread( os.path.join(img_dir, name) )\n    #         img = tl.prepro.imresize(img, size=[64, 64])    # (64, 64, 3)\n    #         img = img.astype(np.float32)\n    #         return img\n    # images = tl.prepro.threading_data(imgs_title_list, fn=get_resize_image)\n    images = []\n    images_256 = []\n    for name in imgs_title_list:\n        # print(name)\n        img_raw = scipy.misc.imread( os.path.join(img_dir, name) )\n        img = tl.prepro.imresize(img_raw, size=[64, 64])    # (64, 64, 3)\n        img = img.astype(np.float32)\n        images.append(img)\n        if need_256:\n            img = tl.prepro.imresize(img_raw, size=[256, 256]) # (256, 256, 3)\n            img = img.astype(np.float32)\n\n            images_256.append(img)\n    # images = np.array(images)\n    # images_256 = np.array(images_256)\n    print("" * loading and resizing took %ss"" % (time.time()-s))\n\n    n_images = len(captions_dict)\n    n_captions = len(captions_ids)\n    n_captions_per_image = len(lines) # 10\n\n    print(""n_captions: %d n_images: %d n_captions_per_image: %d"" % (n_captions, n_images, n_captions_per_image))\n\n    captions_ids_train, captions_ids_test = captions_ids[: 8000*n_captions_per_image], captions_ids[8000*n_captions_per_image :]\n    images_train, images_test = images[:8000], images[8000:]\n    if need_256:\n        images_train_256, images_test_256 = images_256[:8000], images_256[8000:]\n    n_images_train = len(images_train)\n    n_images_test = len(images_test)\n    n_captions_train = len(captions_ids_train)\n    n_captions_test = len(captions_ids_test)\n    print(""n_images_train:%d n_captions_train:%d"" % (n_images_train, n_captions_train))\n    print(""n_images_test:%d  n_captions_test:%d"" % (n_images_test, n_captions_test))\n\n    ## check test image\n    # idexs = get_random_int(min=0, max=n_captions_test-1, number=64)\n    # temp_test_capt = captions_ids_test[idexs]\n    # for idx, ids in enumerate(temp_test_capt):\n    #     print(""%d %s"" % (idx, [vocab.id_to_word(id) for id in ids]))\n    # temp_test_img = images_train[np.floor(np.asarray(idexs).astype(\'float\')/n_captions_per_image).astype(\'int\')]\n    # save_images(temp_test_img, [8, 8], \'temp_test_img.png\')\n    # exit()\n\n    # ## check the first example\n    # tl.visualize.frame(I=images[0], second=5, saveable=True, name=\'temp\', cmap=None)\n    # for cap in captions_dict[1]:\n    #     print(cap)\n    # print(captions_ids[0:10])\n    # for ids in captions_ids[0:10]:\n    #     print([vocab.id_to_word(id) for id in ids])\n    # print_dict(captions_dict)\n\n    # ## generate a random batch\n    # batch_size = 64\n    # idexs = get_random_int(0, n_captions_test, batch_size)\n    # # idexs = [i for i in range(0,100)]\n    # print(idexs)\n    # b_seqs = captions_ids_test[idexs]\n    # b_images = images_test[np.floor(np.asarray(idexs).astype(\'float\')/n_captions_per_image).astype(\'int\')]\n    # print(""before padding %s"" % b_seqs)\n    # b_seqs = tl.prepro.pad_sequences(b_seqs, padding=\'post\')\n    # print(""after padding %s"" % b_seqs)\n    # # print(input_images.shape)   # (64, 64, 64, 3)\n    # for ids in b_seqs:\n    #     print([vocab.id_to_word(id) for id in ids])\n    # print(np.max(b_images), np.min(b_images), b_images.shape)\n    # from utils import *\n    # save_images(b_images, [8, 8], \'temp2.png\')\n    # # tl.visualize.images2d(b_images, second=5, saveable=True, name=\'temp2\')\n    # exit()\n\nimport pickle\ndef save_all(targets, file):\n    with open(file, \'wb\') as f:\n        pickle.dump(targets, f)\n\nsave_all(vocab, \'_vocab.pickle\')\nsave_all((images_train_256, images_train), \'_image_train.pickle\')\nsave_all((images_test_256, images_test), \'_image_test.pickle\')\nsave_all((n_captions_train, n_captions_test, n_captions_per_image, n_images_train, n_images_test), \'_n.pickle\')\nsave_all((captions_ids_train, captions_ids_test), \'_caption.pickle\')\n'"
downloads.py,3,"b'from __future__ import print_function\nimport os,sys,gzip,requests,zipfile,tarfile\nfrom tqdm import tqdm\nfrom six.moves import urllib\nimport time\n\n\'\'\'\nThis script is mainly used in cooperation with codes from https://github.com/zsdonghao/text-to-image\ndownload flower dataset from : http://www.robots.ox.ac.uk/~vgg/data/flowers/102/\ndownload caption dataset from : https://drive.google.com/uc?export=download&confirm=l7Ld&id=0B0ywwgffWnLLcms2WWJQRFNSWXM\n\'\'\'\n\n\ndef get_confirm_token(response):\n\tfor key, value in response.cookies.items():\n\t\tif key.startswith(\'download_warning\'):\n\t\t\treturn value\n\treturn None\n\ndef save_response_content(response, destination, chunk_size=32*1024):\n\ttotal_size = int(response.headers.get(\'content-length\', 0))\n\twith open(destination, ""wb"") as f:\n\t\tfor chunk in tqdm(response.iter_content(chunk_size), total=total_size,\n\t\t\t\tunit=\'B\', unit_scale=True, desc=destination):\n\t\t\tif chunk: # filter out keep-alive new chunks\n\t\t\t\tf.write(chunk)\n\ndef download_file_from_google_drive(id, destination):    \n\tURL = ""https://docs.google.com/uc?export=download""\n\tsession = requests.Session()\n\n\tresponse = session.get(URL, params={ \'id\': id }, stream=True)\n\ttoken = get_confirm_token(response)\n\n\tif token:\n\t\tparams = { \'id\' : id, \'confirm\' : token }\n\t\tresponse = session.get(URL, params=params, stream=True)\n\tsave_response_content(response, destination)\n\ndef download_caption(dirpath):\n\tdata_dir = \'cvpr2016_flowers.tar.gz\'\n\tif os.path.exists(os.path.join(dirpath, data_dir)):\n\t\tprint(\'Found cvpr2016_flowers.tar.gz - skip\')\n\t\treturn\n\n\tfilename, drive_id  = ""cvpr2016_flowers.tar.gz"", ""0B0ywwgffWnLLcms2WWJQRFNSWXM""\n\tsave_path = os.path.join(dirpath, filename)\n\n\tif os.path.exists(save_path):\n\t\tprint(\'[*] {} already exists\'.format(save_path))\n\telse:\n\t\tdownload_file_from_google_drive(drive_id, save_path)\n\n\ndef download(url, dirpath):\n\tfilepath = dirpath\n\tu = urllib.request.urlopen(url)\n\tf = open(filepath, \'wb\')\n\tfilesize = int(u.headers[""Content-Length""])\n\tprint(""Downloading: %s Bytes: %s"" % (""102flowers"", filesize))\n\n\tdownloaded = 0\n\tblock_sz = 8192\n\tstatus_width = 70\n\twhile True:\n\t\tbuf = u.read(block_sz)\n\t\tif not buf:\n\t\t\tprint(\'\')\n\t\t\tbreak\n\t\telse:\n\t\t\tprint(\'\', end=\'\\r\')\n\t\tdownloaded += len(buf)\n\t\tf.write(buf)\n\n\t\tstatus = ((""[{}  "" + "" ***progress: {:03.1f}% ]"").format(\'=\' * int(float(downloaded) / \n\t\t\tfilesize * status_width) + \'>\', downloaded * 100. / filesize))\n\t\tprint(status, end=\'\')\n\n\t\tsys.stdout.flush()\n\tf.close()\n\treturn filepath\n\ndef unzip(src_dir,new_name = None):\n\t# extract to current directory\n\tdirpath = \'.\'\n\ttry:\n\t\tif src_dir.endswith(\'.zip\'):\n\t\t\tprint(\'unzipping \' + src_dir)\n\t\t\twith zipfile.ZipFile(src_dir) as zf:\n\t\t\t\tzip_dir = zf.namelist()[0]\n\t\t\t\tzf.extractall(dirpath)\n\t\telif src_dir.endswith(\'.tgz\') or src_dir.endswith(\'tar.gz\'):\n\t\t\tprint(\'unzipping \' + src_dir)\n\t\t\ttar = tarfile.open(src_dir)\n\t\t\ttar.extractall()\n\t\t\ttar.close()\n\t\t# os.remove(save_path)\n\t\tif new_name is None:\n\t\t\tpass\n\t\telse:\n\t\t\tos.rename(\'jpg\', os.path.join(dirpath, new_name))\n\texcept:\n\t\traise(\'wrong format\')\n\ndef main():\n\turl = ""http://www.robots.ox.ac.uk/~vgg/data/flowers/102/102flowers.tgz""\n\tcur_dir = os.getcwd()\n\timage_dir = os.path.join(cur_dir,""102flowers.tgz"")\n\tif os.path.exists(image_dir):\n\t\tprint(\'dataset already exists\')\n\telse:\n\t\tdownload(url,image_dir)\n\tunzip(image_dir,\'102flowers\')\n\n\tcaption_dir = os.path.join(cur_dir,""cvpr2016_flowers.tar.gz"")\n\tif os.path.exists(caption_dir):\n\t\tprint(\'dataset already exists\')\n\telse:\n\t\tdownload_caption(cur_dir)\n\tunzip(caption_dir)\n\nif __name__ == \'__main__\':\n\tmain()\n\t\n\t'"
inception_score.py,8,"b'# Code derived from tensorflow/tensorflow/models/image/imagenet/classify_image.py\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os.path\nimport sys\nimport tarfile\n\nimport numpy as np\nfrom six.moves import urllib\nimport tensorflow as tf\nimport glob\nimport scipy.misc\nimport math\nimport sys\n\nMODEL_DIR = \'/tmp/imagenet\'\nDATA_URL = \'http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz\'\nsoftmax = None\n\n# Call this function with list of images. Each of elements should be a\n# numpy array with values ranging from 0 to 255.\ndef get_inception_score(images, splits=10):\n  assert(type(images) == list)\n  assert(type(images[0]) == np.ndarray)\n  assert(len(images[0].shape) == 3)\n  assert(np.max(images[0]) > 10)\n  assert(np.min(images[0]) >= 0.0)\n  inps = []\n  for img in images:\n    img = img.astype(np.float32)\n    inps.append(np.expand_dims(img, 0))\n  bs = 100\n  with tf.Session() as sess:\n    preds = []\n    n_batches = int(math.ceil(float(len(inps)) / float(bs)))\n    for i in range(n_batches):\n        sys.stdout.write(""."")\n        sys.stdout.flush()\n        inp = inps[(i * bs):min((i + 1) * bs, len(inps))]\n        inp = np.concatenate(inp, 0)\n        pred = sess.run(softmax, {\'ExpandDims:0\': inp})\n        preds.append(pred)\n    preds = np.concatenate(preds, 0)\n    scores = []\n    for i in range(splits):\n      part = preds[(i * preds.shape[0] // splits):((i + 1) * preds.shape[0] // splits), :]\n      kl = part * (np.log(part) - np.log(np.expand_dims(np.mean(part, 0), 0)))\n      kl = np.mean(np.sum(kl, 1))\n      scores.append(np.exp(kl))\n    return np.mean(scores), np.std(scores)\n\n# This function is called automatically.\ndef _init_inception():\n  global softmax\n  if not os.path.exists(MODEL_DIR):\n    os.makedirs(MODEL_DIR)\n  filename = DATA_URL.split(\'/\')[-1]\n  filepath = os.path.join(MODEL_DIR, filename)\n  if not os.path.exists(filepath):\n    def _progress(count, block_size, total_size):\n      sys.stdout.write(\'\\r>> Downloading %s %.1f%%\' % (\n          filename, float(count * block_size) / float(total_size) * 100.0))\n      sys.stdout.flush()\n    filepath, _ = urllib.request.urlretrieve(DATA_URL, filepath, _progress)\n    print()\n    statinfo = os.stat(filepath)\n    print(\'Succesfully downloaded\', filename, statinfo.st_size, \'bytes.\')\n  tarfile.open(filepath, \'r:gz\').extractall(MODEL_DIR)\n  with tf.gfile.FastGFile(os.path.join(\n      MODEL_DIR, \'classify_image_graph_def.pb\'), \'rb\') as f:\n    graph_def = tf.GraphDef()\n    graph_def.ParseFromString(f.read())\n    _ = tf.import_graph_def(graph_def, name=\'\')\n  # Works with an arbitrary minibatch size.\n  with tf.Session() as sess:\n    pool3 = sess.graph.get_tensor_by_name(\'pool_3:0\')\n    ops = pool3.graph.get_operations()\n    for op_idx, op in enumerate(ops):\n        for o in op.outputs:\n            shape = o.get_shape()\n            shape = [s.value for s in shape]\n            new_shape = []\n            for j, s in enumerate(shape):\n                if s == 1 and j == 0:\n                    new_shape.append(None)\n                else:\n                    new_shape.append(s)\n            o._shape = tf.TensorShape(new_shape)\n    w = sess.graph.get_operation_by_name(""softmax/logits/MatMul"").inputs[1]\n    logits = tf.matmul(tf.squeeze(pool3), w)\n    softmax = tf.nn.softmax(logits)\n\nif softmax is None:\n    _init_inception()\n    ###======================== PREPARE DATA ====================================###\n    ## Load Oxford 102 flowers dataset\n    # from data_loader import *\n    import pickle\n\n    # with open(""_vocab.pickle"", \'rb\') as f:\n    #     vocab = pickle.load(f)\n    with open(""_image_train.pickle"", \'rb\') as f:\n        images_train_256, images_train = pickle.load(f)\n    # with open(""_image_test.pickle"", \'rb\') as f:\n    #     images_test_256, images_test = pickle.load(f)\n    # with open(""_n.pickle"", \'rb\') as f:\n    #     n_captions_train, n_captions_test, n_captions_per_image, n_images_train, n_images_test = pickle.load(f)\n    # with open(""_caption.pickle"", \'rb\') as f:\n    #     captions_ids_train, captions_ids_test = pickle.load(f)\n    # images_train_256 = np.array(images_train_256)\n    # images_test_256 = np.array(images_test_256)\n    # images_train = np.array(images_train)\n    # images_test = np.array(images_test)\n    # print(np.max(images_test_256[0]))\n    # exit()\n    score_mean, score_std = get_inception_score(images_train_256)\n    print(""\\nscore:"",score_mean, score_std)\n'"
model.py,133,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\nimport tensorflow as tf\nimport tensorlayer as tl\nfrom tensorlayer.layers import *\nimport os\n\n""""""Adversarially Learned Inference\nPage 14: CelebA model hyperparameters\nOptimizer Adam (\xce\xb1 = 10\xe2\x88\x924, \xce\xb21 = 0.5)\nBatch size 100 Epochs 123\nLeaky ReLU slope 0.02\nWeight, bias initialization Isotropic gaussian (\xc2\xb5 = 0, \xcf\x83 = 0.01), Constant(0)\n""""""\nbatch_size = 64\n\nz_dim = 512         # Noise dimension\nimage_size = 64     # 64 x 64\nc_dim = 3           # for rgb\n\n\ndef generator(input_z, input_txt=None, is_train=True, reuse=False, batch_size=batch_size):\n    """""" G(z) or G(z, RNN(txt)) / output (64, 64, 3) """"""\n    s = image_size\n    s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n    gf_dim = 128\n\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    gamma_init = tf.random_normal_initializer(1., 0.02)\n    lrelu = lambda x: tl.act.lrelu(x, 0.2)\n\n    with tf.variable_scope(""generator"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        net_in = InputLayer(input_z, name=\'g_inputz\')\n\n        if input_txt is not None:\n            net_txt = InputLayer(input_txt, name=\'g_input_txt\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim,\n                    act=lrelu,\n                    W_init = w_init, b_init=None, name=\'g_reduce_text/dense\')\n            net_in = ConcatLayer([net_in, net_txt], concat_dim=1, name=\'g_concat_z_txt\')\n\n        net_h0 = DenseLayer(net_in, gf_dim*8*s16*s16, act=tf.identity,\n                W_init=w_init, b_init=None, name=\'g_h0/dense\')\n        net_h0 = BatchNormLayer(net_h0, #act=tf.identity,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h0/batch_norm\')\n        net_h0 = ReshapeLayer(net_h0, [-1, s16, s16, gf_dim*8], name=\'g_h0/reshape\')\n\n        net = Conv2d(net_h0, gf_dim*2, (1, 1), (1, 1),\n                padding=\'VALID\', act=None, W_init=w_init, b_init=None, name=\'g_h1_res/conv2d\')\n        net = BatchNormLayer(net, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h1_res/batch_norm\')\n        net = Conv2d(net, gf_dim*2, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h1_res/conv2d2\')\n        net = BatchNormLayer(net, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h1_res/batch_norm2\')\n        net = Conv2d(net, gf_dim*8, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h1_res/conv2d3\')\n        net = BatchNormLayer(net, # act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h1_res/batch_norm3\')\n        net_h1 = ElementwiseLayer(layer=[net_h0, net], combine_fn=tf.add, name=\'g_h1_res/add\')\n        net_h1.outputs = lrelu(net_h1.outputs)\n\n        net_h2 = DeConv2d(net_h1, gf_dim*4, (4, 4), out_size=(s8, s8), strides=(2, 2),\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=None, name=\'g_h2/decon2d\')\n        # net_h2 = UpSampling2dLayer(net_h1, size=[s8, s8], is_scale=False, method=1,\n        #         align_corners=False, name=\'g_h2/upsample2d\')\n        # net_h2 = Conv2d(net_h2, gf_dim*4, (3, 3), (1, 1),\n        #         padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2,# act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h2/batch_norm\')\n\n        net = Conv2d(net_h2, gf_dim, (1, 1), (1, 1),\n                padding=\'VALID\', act=None, W_init=w_init, b_init=None, name=\'g_h3_res/conv2d\')\n        net = BatchNormLayer(net, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h3_res/batch_norm\')\n        net = Conv2d(net, gf_dim, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h3_res/conv2d2\')\n        net = BatchNormLayer(net, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h3_res/batch_norm2\')\n        net = Conv2d(net, gf_dim*4, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h3_res/conv2d3\')\n        net = BatchNormLayer(net, #act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h3_res/batch_norm3\')\n        net_h3 = ElementwiseLayer(layer=[net_h2, net], combine_fn=tf.add, name=\'g_h3_res/add\')\n        net_h3.outputs = lrelu(net_h3.outputs)\n\n        net_h4 = DeConv2d(net_h3, gf_dim*2, (4, 4), out_size=(s4, s4), strides=(2, 2),\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=None, name=\'g_h4/decon2d\')\n        # net_h4 = UpSampling2dLayer(net_h3, size=[s4, s4], is_scale=False, method=1,\n        #         align_corners=False, name=\'g_h4/upsample2d\')\n        # net_h4 = Conv2d(net_h4, gf_dim*2, (3, 3), (1, 1),\n        #         padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h4/conv2d\')\n        net_h4 = BatchNormLayer(net_h4, act=lrelu,#tf.nn.relu,#lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h4/batch_norm\')\n\n        net_h5 = DeConv2d(net_h4, gf_dim, (4, 4), out_size=(s2, s2), strides=(2, 2),\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=None, name=\'g_h5/decon2d\')\n        # net_h5 = UpSampling2dLayer(net_h4, size=[s2, s2], is_scale=False, method=1,\n        #         align_corners=False, name=\'g_h5/upsample2d\')\n        # net_h5 = Conv2d(net_h5, gf_dim, (3, 3), (1, 1),\n        #         padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h5/conv2d\')\n        net_h5 = BatchNormLayer(net_h5, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h5/batch_norm\')\n\n        net_ho = DeConv2d(net_h5, c_dim, (4, 4), out_size=(s, s), strides=(2, 2),\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, name=\'g_ho/decon2d\')\n        # net_ho = UpSampling2dLayer(net_h9, size=[s, s], is_scale=False, method=1,\n        #         align_corners=False, name=\'g_ho/upsample2d\')\n        # net_ho = Conv2d(net_ho, c_dim, (3, 3), (1, 1),\n        #         padding=\'SAME\', act=None, W_init=w_init, name=\'g_ho/conv2d\')\n        logits = net_ho.outputs\n        net_ho.outputs = tf.nn.tanh(net_ho.outputs)\n    return net_ho, logits\n\ndef encoder_simple(input_images, input_txt=None, is_train=True, reuse=False):\n    """""" E(x) input (64, 64, 3), output z """"""\n    s = image_size\n    s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n    # 32 16 8 4\n    w_init = tf.random_normal_initializer(stddev=0.01)\n    gamma_init = tf.random_normal_initializer(1., 0.01)\n    df_dim = 64\n    lrelu = lambda x: tl.act.lrelu(x, 0.2)\n\n    with tf.variable_scope(""encoder"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        net_in = InputLayer(input_images, name=\'ig_inputz\')\n        # print(net_in.outputs)\n        # exit()\n        net_h0 = Conv2d(net_in, df_dim, (2, 2), (1, 1), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_h0/conv2d\')\n        net_h0 = BatchNormLayer(net_h0, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h0/batchnorm\')\n\n        net_h1 = Conv2d(net_h0, df_dim*2, (7, 7), (2, 2), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_h1/conv2d\')\n        net_h1 = BatchNormLayer(net_h1, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h1/batchnorm\')\n\n        net_h2 = Conv2d(net_h1, df_dim*4, (5, 5), (2, 2), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h2/batchnorm\')\n\n        net_h3 = Conv2d(net_h2, df_dim*4, (7, 7), (2, 2), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_h3/conv2d\')\n        net_h3 = BatchNormLayer(net_h3, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h3/batchnorm\')\n\n        net_h4 = Conv2d(net_h3, df_dim*8, (4, 4), (1, 1), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_h4/conv2d\')\n        net_h4 = BatchNormLayer(net_h4, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h4/batchnorm\')\n\n        if input_txt is not None:\n            net_txt = InputLayer(input_txt, name=\'ig_input_txt\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                   W_init=w_init, b_init=None, name=\'ig_reduce_txt/dense\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'ig_txt/expanddim1\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'ig_txt/expanddim2\')\n            net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'ig_txt/tile\')\n            net_h4_concat = ConcatLayer([net_h4, net_txt], concat_dim=3, name=\'ig_txt/concat\')\n            net_h4 = Conv2d(net_h4_concat, df_dim*8, (1, 1), (1, 1),\n                   padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_txt/conv2d_2\')\n            net_h4 = BatchNormLayer(net_h4, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                   is_train=is_train, gamma_init=gamma_init, name=\'ig_txt/batch_norm_2\')\n        # print(net_h4.outputs) # (100, 8, 8, 512)\n        # exit()\n        # net_ho = Conv2d(net_h4, df_dim*8, (1, 1), (1, 1), act=None,\n        #         padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_ho/conv2d\')  # DH\n        # print(net_h4.outputs) # (100, 1, 1, 512)\n        # exit()\n        net_ho = FlattenLayer(net_h4, name=\'ig_ho/flatten\')\n        net_ho = DenseLayer(net_ho, n_units=z_dim, name=\'ig_ho/dense\')\n        # print(net_ho.outputs)\n        # exit()\n        return net_ho\n\n# def encoder(input_images, is_train=True, reuse=False):\n#     """""" E(x) input (64, 64, 3), output z """"""\n#     w_init = tf.random_normal_initializer(stddev=0.02)\n#     gamma_init=tf.random_normal_initializer(1., 0.02)\n#     df_dim = 128#64\n#     with tf.variable_scope(""encoder"", reuse=reuse):\n#         tl.layers.set_name_reuse(reuse)\n#         # (nc) x 64 x 64\n#         net_in = InputLayer(input_images, name=\'ig_input/images\')\n#         net_h0 = Conv2d(net_in, df_dim, (4, 4), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n#                 padding=\'SAME\', W_init=w_init, name=\'p_h0/conv2d\')\n#\n#         net_h1 = Conv2d(net_h0, df_dim*2, (4, 4), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h1/conv2d\')\n#         net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig_h1/batchnorm\')\n#         net_h2 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h2/conv2d\')\n#         net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig_h2/batchnorm\')\n#         net_h3 = Conv2d(net_h2, df_dim*8, (4, 4), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h3/conv2d\')\n#         net_h3 = BatchNormLayer(net_h3, #act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig_h3/batchnorm\')\n#\n#         net_h = Conv2d(net_h3, df_dim*2, (1, 1), (1, 1), act=None,\n#                 padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_h3/conv2d2\')\n#         net_h = BatchNormLayer(net_h, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig_h3/batchnorm2\')\n#         net_h = Conv2d(net_h, df_dim*2, (3, 3), (1, 1), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h3/conv2d3\')\n#         net_h = BatchNormLayer(net_h, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig_h3/batchnorm3\')\n#         net_h = Conv2d(net_h, df_dim*8, (3, 3), (1, 1), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h3/conv2d4\')\n#         net_h = BatchNormLayer(net_h, #act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig_h3/batchnorm4\')\n#         net_h3 = ElementwiseLayer(layer=[net_h3, net_h], combine_fn=tf.add, name=\'ig_h3/add\')\n#         net_h3.outputs = tl.act.lrelu(net_h3.outputs, 0.2)\n#\n#         net_h4 = Conv2d(net_h3, df_dim*2, (4, 4), (1, 1), padding=\'SAME\',\n#                 W_init=w_init, name=\'ig_h4/conv2d_2\')\n#         # print(net_h4.outputs)   # (100, 4, 4, 256)\n#         # exit()\n#         # 1 x 1 x 1\n#         net_h4 = FlattenLayer(net_h4, name=\'ig_h4/flatten\')\n#         net_h4 = DenseLayer(net_h4, n_units=z_dim,\n#                 act=tf.identity, W_init=w_init, b_init = None, name=\'ig/h4/embed\')\n#     return net_h4\n\ndef encoder_resnet(input_images, input_txt=None, is_train=True, reuse=False):\n    """""" E(x) 64x64 --> z """"""\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    gamma_init=tf.random_normal_initializer(1., 0.02)\n    lrelu = lambda x: tl.act.lrelu(x, 0.2)\n\n    df_dim = 128#64\n    with tf.variable_scope(""encoder"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        # (nc) x 64 x 64\n        net_in = InputLayer(input_images, name=\'ig_input/images\')\n        net_h0 = Conv2d(net_in, df_dim, (4, 4), (2, 2), act=lrelu,\n                padding=\'SAME\', W_init=w_init, name=\'p_h0/conv2d\')\n        # print(net_h0.outputs) # (100, 32, 32, 128)\n        # exit()\n        net_h1 = Conv2d(net_h0, df_dim*2, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h1/conv2d\')\n        net_h1 = BatchNormLayer(net_h1, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h1/batchnorm\')\n        net_h1 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h1/conv2d2\')\n        net_h1 = BatchNormLayer(net_h1, #act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h1/batchnorm2\')\n        # print(net_h1.outputs) # (100, 8, 8, 512)\n        # exit()\n        net = Conv2d(net_h1, df_dim*1, (1, 1), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h1_res/conv2d\')\n        net = BatchNormLayer(net, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h1_res/batchnorm\')\n        net = Conv2d(net, df_dim*1, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h1_res/conv2d2\')\n        net = BatchNormLayer(net, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h1_res/batchnorm2\')\n        net = Conv2d(net, df_dim*4, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h1_res/conv2d3\')\n        net = BatchNormLayer(net, #act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h1_res/batchnorm3\')\n        net_h1 = ElementwiseLayer(layer=[net_h1, net], combine_fn=tf.add, name=\'ig_h1_res/add\')\n        net_h1.outputs = lrelu(net_h1.outputs)\n\n        # print(net_h1.outputs) # (100, 8, 8, 512)\n        # exit()\n\n        # net_h2 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n        #         padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h2/conv2d\')\n        # net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n        #         is_train=is_train, gamma_init=gamma_init, name=\'ig_h2/batchnorm\')\n        # print(net_h2.outputs)\n        # exit()\n\n        net_h2 = Conv2d(net_h1, df_dim*8, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2, #act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h2/batchnorm\')\n        # print(net_h3.outputs)\n        # exit()\n\n        net = Conv2d(net_h2, df_dim*2, (1, 1), (1, 1), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'ig_h3_res/conv2d2\')\n        net = BatchNormLayer(net, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h3_res/batchnorm2\')\n        net = Conv2d(net, df_dim*2, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h3_res/conv2d3\')\n        net = BatchNormLayer(net, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h3_res/batchnorm3\')\n        net = Conv2d(net, df_dim*8, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_h3_res/conv2d4\')\n        net = BatchNormLayer(net, #act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'ig_h3_res/batchnorm4\')\n        net_h3 = ElementwiseLayer(layer=[net_h2, net], combine_fn=tf.add, name=\'ig_h3_res/add\')\n        net_h3.outputs = lrelu(net_h3.outputs)\n        # print(net_h3.outputs)\n        # exit()\n        if input_txt is not None:\n            net_txt = InputLayer(input_txt, name=\'ig_input_txt\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                   W_init=w_init, b_init=None, name=\'ig_reduce_txt/dense\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'ig_txt/expanddim1\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'ig_txt/expanddim2\')\n            net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'ig_txt/tile\')\n            net_h3_concat = ConcatLayer([net_h3, net_txt], concat_dim=3, name=\'ig_txt/concat\')\n            net_h3 = Conv2d(net_h3_concat, df_dim*8, (1, 1), (1, 1),\n                   padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_txt/conv2d_2\')\n            net_h3 = BatchNormLayer(net_h3, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                   is_train=is_train, gamma_init=gamma_init, name=\'ig_txt/batch_norm_2\')\n\n        net_h3 = Conv2d(net_h3, df_dim*4, (4, 4), (1, 1), padding=\'SAME\',\n                W_init=w_init, name=\'ig_h3/conv2d_2\')\n        # print(net_h3.outputs)\n        # exit()\n        net_ho = FlattenLayer(net_h3, name=\'ig_ho/flatten\')\n        net_ho = DenseLayer(net_ho, n_units=z_dim, act=tf.identity,\n                W_init=w_init, b_init = None, name=\'ig/ho/embed\')\n    return net_ho\n\ndef discriminator_x(input_images, input_txt=None, is_train=True, reuse=False):\n    """""" D(x) input (64, 64, 3) """"""\n    w_init = tf.random_normal_initializer(stddev=0.01)\n    # w_init1 = tf.random_normal_initializer(stddev=0.01 * 2 * 2)\n    # w_init2 = tf.random_normal_initializer(stddev=0.01 * 7 * 7)\n    # w_init3 = tf.random_normal_initializer(stddev=0.01 * 5 * 5)\n    # w_init4 = tf.random_normal_initializer(stddev=0.01 * 7 * 7)\n    # w_init5 = tf.random_normal_initializer(stddev=0.01 * 4 * 4)\n    gamma_init=tf.random_normal_initializer(1., 0.01)\n\n    with tf.variable_scope(""discriminator_x"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n\n        net_in = InputLayer(input_images, name=\'dx_input/images\')\n        net_h0 = Conv2d(net_in, df_dim, (2, 2), (1, 1), act=lrelu,\n                padding=\'VALID\', W_init=w_init, name=\'dx_h0/conv2d\')\n\n        net_h1 = Conv2d(net_h0, df_dim*2, (7, 7), (2, 2), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'dx_h1/conv2d\')\n        net_h1 = BatchNormLayer(net_h1, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'dx_h1/batchnorm\')\n\n        net_h2 = Conv2d(net_h1, df_dim*4, (5, 5), (2, 2), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'dx_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'dx_h2/batchnorm\')\n\n        net_h3 = Conv2d(net_h2, df_dim*4, (7, 7), (2, 2), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'dx_h3/conv2d\')\n        net_h3 = BatchNormLayer(net_h3, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'dx_h3/batchnorm\')\n\n        net_h4 = Conv2d(net_h3, df_dim*8, (4, 4), (1, 1), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'dx_h4/conv2d\')\n        net_h4 = BatchNormLayer(net_h4, act=lrelu,\n                is_train=is_train, gamma_init=gamma_init, name=\'dx_h4/batchnorm\')\n\n        if input_txt is not None:\n            net_txt = InputLayer(input_txt, name=\'dx_input_txt\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                   W_init=w_init, b_init=None, name=\'dx_reduce_txt/dense\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'dx_txt/expanddim1\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'dx_txt/expanddim2\')\n            net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'d_txt/tile\')\n            net_h4_concat = ConcatLayer([net_h4, net_txt], concat_dim=3, name=\'dx_txt/concat\')\n            net_h4 = Conv2d(net_h4_concat, df_dim*8, (1, 1), (1, 1),\n                   padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_txt/conv2d_2\')\n            net_h4 = BatchNormLayer(net_h4, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n                   is_train=is_train, gamma_init=gamma_init, name=\'dx_txt/batch_norm_2\')\n\n        # print(net_h4.outputs, df_dim*8)\n        # exit()\n        net_ho = FlattenLayer(net_h4, name=\'dx_ho/flatten\')\n        # net_ho = DenseLayer(net_ho, n_units=z_dim, act=tf.identity,\n        #         W_init = w_init, name=\'dx_ho/dense\') # 512\n        # print(net_ho.outputs)\n        # exit()\n        return net_ho\n\n# def discriminator_x(input_images, input_txt=None, is_train=True, reuse=False): # cnn_encoder_resnet\n#     """""" D(x) or D(x, RNN(txt)) / x=(64, 64, 3), output z """"""\n#     # https://github.com/hanzhanggit/StackGAN/blob/master/stageI/model.py  d_encode_image\n#     w_init = tf.random_normal_initializer(stddev=0.02)\n#     gamma_init=tf.random_normal_initializer(1., 0.02)\n#     lrelu = lambda x: tl.act.lrelu(x, 0.2)\n#\n#     df_dim = 64\n#     with tf.variable_scope(""discriminator_x"", reuse=reuse):\n#         tl.layers.set_name_reuse(reuse)\n#         # (nc) x 64 x 64\n#         net_in = InputLayer(input_images, name=\'dx_input/images\')\n#\n#         # net_in = DropoutLayer(net_in, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_in\')\n#         net_h0 = Conv2d(net_in, df_dim, (4, 4), (2, 2), act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                 padding=\'SAME\', W_init=w_init, name=\'dx_h0/conv2d\')\n#\n#         # net_h0 = DropoutLayer(net_h0, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_h0\')\n#         net_h1 = Conv2d(net_h0, df_dim*2, (4, 4), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h1/conv2d\')\n#         net_h1 = BatchNormLayer(net_h1, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h1/batchnorm\')\n#         # net_h1 = DropoutLayer(net_h1, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_h1\')\n#         net_h1 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h1/conv2d2\')\n#         net_h1 = BatchNormLayer(net_h1, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h1/batchnorm2\')\n#         # net_h1 = DropoutLayer(net_h1, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_h2\')\n#         net_h1 = Conv2d(net_h1, df_dim*8, (4, 4), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h1/conv2d3\')\n#         net_h1 = BatchNormLayer(net_h1, #act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h1/batchnorm3\')\n#\n#         # net_h3 = DropoutLayer(net_h3, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_h3\')\n#         net_h = Conv2d(net_h1, df_dim*2, (1, 1), (1, 1), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h_res/conv2d2\')\n#         net_h = BatchNormLayer(net_h, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h_res/batchnorm2\')\n#         # net_h = DropoutLayer(net_h, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_resh1\')\n#         net_h = Conv2d(net_h, df_dim*2, (3, 3), (1, 1), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h_res/conv2d3\')\n#         net_h = BatchNormLayer(net_h, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h_res/batchnorm3\')\n#         # net_h = DropoutLayer(net_h, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_resh2\')\n#         net_h = Conv2d(net_h, df_dim*8, (3, 3), (1, 1), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h_res/conv2d4\')\n#         net_h = BatchNormLayer(net_h, #act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h_res/batchnorm4\')\n#         net_h2 = ElementwiseLayer(layer=[net_h1, net_h], combine_fn=tf.add, name=\'dx_h_res/add\')\n#         net_h2.outputs = tl.act.lrelu(net_h2.outputs, 0.2)\n#\n#         if input_txt is not None:\n#             net_txt = InputLayer(input_txt, name=\'dx_input_txt\')\n#             net_txt = DenseLayer(net_txt, n_units=t_dim, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                    W_init=w_init, b_init=None, name=\'dx_reduce_txt/dense\')\n#             net_txt = ExpandDimsLayer(net_txt, 1, name=\'dx_txt/expanddim1\')\n#             net_txt = ExpandDimsLayer(net_txt, 1, name=\'dx_txt/expanddim2\')\n#             net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'d_txt/tile\')\n#             net_h2_concat = ConcatLayer([net_h2, net_txt], concat_dim=3, name=\'dx_txt/concat\')\n#             net_h2 = Conv2d(net_h2_concat, df_dim*8, (1, 1), (1, 1),\n#                    padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_txt/conv2d_2\')\n#             net_h2 = BatchNormLayer(net_h2, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                    is_train=is_train, gamma_init=gamma_init, name=\'dx_txt/batch_norm_2\')\n#\n#         # net_h2 = DropoutLayer(net_h2, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_after_concat\')\n#         net_ho = Conv2d(net_h2, df_dim*2, (4, 4), (1, 1), padding=\'SAME\',\n#                 W_init=w_init, name=\'dx_ho/conv2d_2\')\n#         # print(net_ho.outputs)   # (100, 4, 4, 128)\n#         # 1 x 1 x 1\n#         # net_ho = DropoutLayer(net_ho, keep=0.8, is_fix=True, is_train=is_train, name=\'dx_drop_ho\')\n#         net_ho = FlattenLayer(net_ho, name=\'dx_ho/flatten\')\n#         # exit()\n#         net_ho = DenseLayer(net_ho, n_units=z_dim, act=tf.identity,\n#                 W_init=w_init, b_init = None, name=\'dx/h4/embed\')\n#     return net_ho\n\ndef discriminator_z(input_z, is_train=True, reuse=False):\n    """""" D(z) input z """"""\n    w_init = tf.random_normal_initializer(stddev=0.01)\n    lrelu = lambda x: tl.act.lrelu(x, 0.02)\n\n    with tf.variable_scope(""discriminator_z"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        net_in = InputLayer(input_z, name=\'dz_input/z\')\n        # net_in = ReshapeLayer(net_in, [-1, 1, 1, z_dim], name=\'dz_reshape\')\n\n        net_in = DropoutLayer(net_in, keep=0.8, is_fix=True, is_train=is_train, name=\'dz_in/drop\')\n            # net_h0 = Conv2d(net_in, 1024, (1, 1), (1, 1), act=lrelu,\n            #         padding=\'VALID\', W_init=w_init, name=\'dz_h0/conv2d\')\n        net_h0 = DenseLayer(net_in, n_units=1024, act=lrelu,\n                W_init=w_init, name=\'dz_h0/conv2d\')\n\n        net_h0 = DropoutLayer(net_h0, keep=0.8, is_fix=True, is_train=is_train, name=\'dz_h0/drop\')\n            # net_h1 = Conv2d(net_h0, 1024, (1, 1), (1, 1), act=lrelu,\n            #         padding=\'VALID\', W_init=w_init, name=\'dz_h1/conv2d\')\n        net_h1 = DenseLayer(net_h0, n_units=1024, act=lrelu,\n                W_init=w_init, name=\'dz_h1/conv2d\')\n\n        # net_h1 = FlattenLayer(net_h1, name=\'dz_flatten\')\n        # print(net_h1.outputs) # 1024\n        # exit()\n        return net_h1\n\ndef discriminator_combine_xz(x, z, is_train=True, reuse=False):\n    """""" combine D(x) or D(x, RNN(txt)) with D(z), output real/fake """"""\n    w_init = tf.random_normal_initializer(stddev=0.01)\n    lrelu = lambda x: tl.act.lrelu(x, 0.02)\n\n    with tf.variable_scope(""discriminator_xz"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        net_in_x = InputLayer(x, name=\'d_input/x\')\n        net_in_z = InputLayer(z, name=\'d_input/z\')\n        net_in = ConcatLayer([net_in_z, net_in_x], concat_dim=1, name=\'d/concat\')\n        # print(net_in.outputs)\n        # exit()\n        # net_in = ExpandDimsLayer(net_in, 1 , name=\'d/expanddim1\')\n        # net_in = ExpandDimsLayer(net_in, 1 , name=\'d/expanddim2\')\n\n        net_in = DropoutLayer(net_in, keep=0.8, is_fix=True, is_train=is_train, name=\'d_in/drop\')\n        # net_h0 = Conv2d(net_in, 2048, (1, 1), (1, 1), act=lrelu,\n        #         padding=\'VALID\', W_init=w_init, name=\'d_h0/conv2d\')\n        net_h0 = DenseLayer(net_in, n_units=1024,#2048,\n                act=lrelu,\n                W_init=w_init, name=\'d_h0/conv2d\')\n\n        net_h0 = DropoutLayer(net_h0, keep=0.8, is_fix=True, is_train=is_train, name=\'d_h0/drop\')\n        # net_h1 = Conv2d(net_h0, 2048, (1, 1), (1, 1), act=lrelu,\n        #         padding=\'VALID\', W_init=w_init, name=\'d_h1/conv2d\')\n        net_h1 = DenseLayer(net_h0, n_units=1024,#2048,\n                act=lrelu,\n                W_init=w_init, name=\'d_h1/conv2d\')\n\n        net_h1 = DropoutLayer(net_h1, keep=0.8, is_fix=True, is_train=is_train, name=\'d_h1/drop\')\n        # net_ho = Conv2d(net_h1, 1, (1, 1), (1, 1), act=None,\n        #         padding=\'VALID\', W_init=w_init, name=\'d_ho/conv2d\')\n        net_ho = DenseLayer(net_h1, n_units=1, act=tf.identity,\n                W_init=w_init, name=\'d_ho/conv2d\')\n        # print(net_ho.outputs) # 1\n        # exit()\n        # net_ho = FlattenLayer(net_ho, name=\'d_ho/flatten\')\n        # print(net_ho.outputs) # 1\n        # exit()\n        logits = net_ho.outputs\n        net_ho.outputs = tf.nn.sigmoid(net_ho.outputs)\n        return net_ho, logits\n\ndef discriminator(x, z, input_txt=None, is_train=True, reuse=False):\n    """""" D(x, z) or D(x, z, text)\n    x=64x64\n    """"""\n    net_z = discriminator_z(z, is_train=is_train, reuse=reuse)\n    net_x = discriminator_x(x, input_txt=input_txt, is_train=is_train, reuse=reuse)\n    net_d, logits = discriminator_combine_xz(net_x.outputs, net_z.outputs, is_train=is_train, reuse=reuse)\n    net_d.all_params.extend(net_x.all_params)\n    net_d.all_params.extend(net_z.all_params)\n    return net_d, logits\n\n## follow DCGAN architecture / WORK but no deep enough for flower dataset\n# def generator(input_z, input_txt=None, is_train=True, reuse=False, batch_size=batch_size):\n#     """""" G(z) input z, output (64, 64, 3) """"""\n#     s = image_size\n#     s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n#     # 32 16 8 4\n#     w_init = tf.random_normal_initializer(stddev=0.01)\n#     gamma_init = tf.random_normal_initializer(1., 0.01)\n#     gf_dim = 128\n#\n#     with tf.variable_scope(""generator"", reuse=reuse):\n#         tl.layers.set_name_reuse(reuse)\n#         net_in = InputLayer(input_z, name=\'g_inputz\')\n#\n#         if input_txt is not None:\n#             net_txt = InputLayer(input_txt, name=\'g_input_txt\')\n#             net_txt = DenseLayer(net_txt, n_units=t_dim,\n#                     act=lambda x: tl.act.lrelu(x, 0.2),\n#                     W_init = w_init, b_init=None, name=\'g_reduce_text/dense\')\n#             # paper 4.1 : and then concatenated to the noise vector z\n#             net_in = ConcatLayer([net_in, net_txt], concat_dim=1, name=\'g_concat_z_txt\')\n#\n#         net_h0 = DenseLayer(net_in, gf_dim*8*s16*s16, act=tf.identity,\n#                 W_init=w_init, b_init=None, name=\'g_h0/dense\')\n#         net_h0 = ReshapeLayer(net_h0, [-1, s16, s16, gf_dim*8], name=\'g_h0/reshape\')\n#         net_h0 = BatchNormLayer(net_h0, act=tf.nn.relu, is_train=is_train,\n#                 gamma_init=gamma_init, name=\'g_h0/batch_norm\')\n#\n#         net_h1 = DeConv2d(net_h0, gf_dim*4, (5, 5), out_size=(s8, s8), strides=(2, 2),\n#                 padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=None, name=\'g_h1/decon2d\')\n#         net_h1 = BatchNormLayer(net_h1, act=tf.nn.relu, is_train=is_train,\n#                 gamma_init=gamma_init, name=\'g_h1/batch_norm\')\n#\n#         net_h2 = DeConv2d(net_h1, gf_dim*2, (5, 5), out_size=(s4, s4), strides=(2, 2),\n#                 padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=None, name=\'g_h2/decon2d\')\n#         net_h2 = BatchNormLayer(net_h2, act=tf.nn.relu, is_train=is_train,\n#                 gamma_init=gamma_init, name=\'g_h2/batch_norm\')\n#\n#         net_h3 = DeConv2d(net_h2, gf_dim, (5, 5), out_size=(s2, s2), strides=(2, 2),\n#                 padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=None, name=\'g_h3/decon2d\')\n#         net_h3 = BatchNormLayer(net_h3, act=tf.nn.relu, is_train=is_train,\n#                 gamma_init=gamma_init, name=\'g_h3/batch_norm\')\n#\n#         net_h4 = DeConv2d(net_h3, c_dim, (5, 5), out_size=(s, s), strides=(2, 2),\n#                 padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, name=\'g_h4/decon2d\')\n#         logits = net_h4.outputs\n#         net_h4.outputs = tf.nn.tanh(net_h4.outputs)\n#     return net_h4, logits\n#\n# def encoder(input_images, input_txt=None, is_train=True, reuse=False):\n#     """""" E(x) input (64, 64, 3), output z """"""\n#     s = image_size\n#     s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n#     # 32 16 8 4\n#     w_init = tf.random_normal_initializer(stddev=0.01)\n#     gamma_init = tf.random_normal_initializer(1., 0.01)\n#     df_dim = 128\n#\n#     with tf.variable_scope(""encoder"", reuse=reuse):\n#         tl.layers.set_name_reuse(reuse)\n#         net_in = InputLayer(input_images, name=\'ig_inputz\')\n#\n#         net_h0 = Conv2d(net_in, df_dim, (5, 5), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n#                 padding=\'SAME\', W_init=w_init, name=\'ig/h0/conv2d\')\n#\n#         net_h1 = Conv2d(net_h0, df_dim*2, (5, 5), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig/h1/conv2d\')\n#         net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig/h1/batch_norm\')\n#\n#         # if name != \'cnn\': # debug for training image encoder in step 2\n#         #     net_h1 = DropoutLayer(net_h1, keep=0.8, is_fix=True, name=\'p/h1/drop\')\n#\n#         net_h2 = Conv2d(net_h1, df_dim*4, (5, 5), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig/h2/conv2d\')\n#         net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig/h2/batch_norm\')\n#\n#         # if name != \'cnn\': # debug for training image encoder in step 2\n#         #     net_h2 = DropoutLayer(net_h2, keep=0.8, is_fix=True, name=\'p/h2/drop\')\n#\n#         net_h3 = Conv2d(net_h2, df_dim*8, (5, 5), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig/h3/conv2d\')\n#         net_h3 = BatchNormLayer(net_h3, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'ig/h3/batch_norm\')\n#\n#         # if name != \'cnn\': # debug for training image encoder in step 2\n#         #     net_h3 = DropoutLayer(net_h3, keep=0.8, is_fix=True, name=\'p/h3/drop\')\n#         # print(net_h3.outputs)\n#         # exit()\n#\n#         if input_txt is not None:\n#             net_txt = InputLayer(input_txt, name=\'ig_input_txt\')\n#             net_txt = DenseLayer(net_txt, n_units=t_dim, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                    W_init=w_init, b_init=None, name=\'ig_reduce_txt/dense\')\n#             net_txt = ExpandDimsLayer(net_txt, 1, name=\'ig_txt/expanddim1\')\n#             net_txt = ExpandDimsLayer(net_txt, 1, name=\'ig_txt/expanddim2\')\n#             net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'ig_txt/tile\')\n#             net_h3_concat = ConcatLayer([net_h3, net_txt], concat_dim=3, name=\'ig_txt/concat\')\n#             net_h3 = Conv2d(net_h3_concat, df_dim*8, (1, 1), (1, 1),\n#                    padding=\'SAME\', W_init=w_init, b_init=None, name=\'ig_txt/conv2d_2\')\n#             net_h3 = BatchNormLayer(net_h3, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                    is_train=is_train, gamma_init=gamma_init, name=\'ig_txt/batch_norm_2\')\n#\n#         net_h4 = FlattenLayer(net_h3, name=\'ig/h4/flatten\')\n#         net_h4 = DenseLayer(net_h4, n_units=z_dim, act=tf.identity,\n#                 W_init = w_init, b_init = None, name=\'ig/h4/embed\')\n#\n#         ## DH add\n#         # print(""WARNING: FORCE ENCODER OUTPUT GAUSSIAN DISTRIBUTION !"")\n#         # mean, var = tf.nn.moments(net_h4.outputs, axes=[1])\n#         # mean = tf.expand_dims(mean, 1)\n#         # var = tf.expand_dims(var, 1)\n#         # net_h4.outputs = (net_h4.outputs - mean) / tf.sqrt(var)\n#     return net_h4\n#\n# def discriminator_x(input_images, input_txt=None, is_train=True, reuse=False):\n#     """""" D(x) input (64, 64, 3) """"""\n#     w_init = tf.random_normal_initializer(stddev=0.01)\n#     gamma_init=tf.random_normal_initializer(1., 0.01)\n#     df_dim = 64\n#\n#     with tf.variable_scope(""discriminator_x"", reuse=reuse):\n#         tl.layers.set_name_reuse(reuse)\n#\n#         net_in = InputLayer(input_images, name=\'dx_input/images\')\n#         net_h0 = Conv2d(net_in, df_dim, (5, 5), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n#                 padding=\'SAME\', W_init=w_init, name=\'dx_h0/conv2d\')  # (64, 32, 32, 64)\n#\n#         net_h1 = Conv2d(net_h0, df_dim*2, (5, 5), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h1/conv2d\')\n#         net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h1/batchnorm\') # (64, 16, 16, 128)\n#\n#         net_h2 = Conv2d(net_h1, df_dim*4, (5, 5), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h2/conv2d\')\n#         net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h2/batchnorm\')    # (64, 8, 8, 256)\n#\n#         net_h3 = Conv2d(net_h2, df_dim*8, (5, 5), (2, 2), act=None,\n#                 padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_h3/conv2d\')\n#         net_h3 = BatchNormLayer(net_h3, act=lambda x: tl.act.lrelu(x, 0.2),\n#                 is_train=is_train, gamma_init=gamma_init, name=\'dx_h3/batchnorm\') # (64, 4, 4, 512)  paper 4.1: when the spatial dim of the D is 4x4, we replicate the description embedding spatially and perform a depth concatenation\n#\n#         if input_txt is not None:\n#             net_txt = InputLayer(input_txt, name=\'dx_input_txt\')\n#             net_txt = DenseLayer(net_txt, n_units=t_dim, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                    W_init=w_init, b_init=None, name=\'dx_reduce_txt/dense\')\n#             net_txt = ExpandDimsLayer(net_txt, 1, name=\'dx_txt/expanddim1\')\n#             net_txt = ExpandDimsLayer(net_txt, 1, name=\'dx_txt/expanddim2\')\n#             net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'d_txt/tile\')\n#             net_h3_concat = ConcatLayer([net_h3, net_txt], concat_dim=3, name=\'dx_txt/concat\')\n#             net_h3 = Conv2d(net_h3_concat, df_dim*8, (1, 1), (1, 1),\n#                    padding=\'SAME\', W_init=w_init, b_init=None, name=\'dx_txt/conv2d_2\')\n#             net_h3 = BatchNormLayer(net_h3, act=lrelu,#lambda x: tl.act.lrelu(x, 0.2),\n#                    is_train=is_train, gamma_init=gamma_init, name=\'dx_txt/batch_norm_2\')\n#\n#         net_h4 = FlattenLayer(net_h3, name=\'dx_h4/flatten\')          # (64, 8192)\n#\n#         net_h4 = DenseLayer(net_h4, n_units=512, act=tf.identity,\n#                 W_init = w_init, name=\'dx_h4/dense\')\n#         # print(net_h4.outputs)\n#         # exit()\n#         # net_h4 = DenseLayer(net_h4, n_units=1, act=tf.identity,\n#         #         W_init = w_init, name=\'d_h4/dense\')\n#         # logits = net_h4.outputs\n#         # net_h4.outputs = tf.nn.sigmoid(net_h4.outputs)  # (64, 1)\n#     return net_h4\n#\n# def discriminator_z(input_z, is_train=True, reuse=False):\n#     """""" D(z) input z """"""\n#     w_init = tf.random_normal_initializer(stddev=0.01)\n#     lrelu = lambda x: tl.act.lrelu(x, 0.2)\n#     with tf.variable_scope(""discriminator_z"", reuse=reuse):\n#         tl.layers.set_name_reuse(reuse)\n#         net_in = InputLayer(input_z, name=\'dz_input/z\')\n#         # net_in = ReshapeLayer(net_in, [-1, 1, 1, z_dim], name=\'dz_reshape\')\n#\n#         # if is_train:\n#         #     net_in = DropoutLayer(net_in, keep=0.8, is_fix=True, name=\'dz_in/drop\')\n#         # net_h0 = Conv2d(net_in, 1024, (1, 1), (1, 1), act=lrelu,\n#         #         padding=\'VALID\', W_init=w_init, name=\'dz_h0/conv2d\')\n#         net_h0 = DenseLayer(net_in, n_units=512, act=lrelu, W_init=w_init, name=\'dz_h0/conv2d\')\n#\n#         # if is_train:\n#         #     net_h0 = DropoutLayer(net_h0, keep=0.8, is_fix=True, name=\'dz_h0/drop\')\n#         # net_h1 = Conv2d(net_h0, 1024, (1, 1), (1, 1), act=lrelu,\n#         #         padding=\'VALID\', W_init=w_init, name=\'dz_h1/conv2d\')\n#         net_h1 = DenseLayer(net_h0, n_units=512, act=lrelu, W_init=w_init, name=\'dz_h1/conv2d\')\n#\n#         # net_h1 = FlattenLayer(net_h1, name=\'dz_flatten\')\n#         # print(net_h1.outputs) # 512\n#         # exit()\n#         return net_h1\n#\n# def discriminator_combine_xz(x, z, is_train=True, reuse=False):\n#     """""" input D(x), D(z), output real/fake """"""\n#     w_init = tf.random_normal_initializer(stddev=0.01)\n#     lrelu = lambda x: tl.act.lrelu(x, 0.2)\n#\n#     with tf.variable_scope(""discriminator"", reuse=reuse):\n#         tl.layers.set_name_reuse(reuse)\n#         net_in_x = InputLayer(x, name=\'d_input/x\')\n#         net_in_z = InputLayer(z, name=\'d_input/z\')\n#         net_in = ConcatLayer([net_in_z, net_in_x], concat_dim=1, name=\'d/concat\')\n#         # print(net_in.outputs)\n#         # exit()\n#         # net_in = ExpandDimsLayer(net_in, 1 , name=\'d/expanddim1\')\n#         # net_in = ExpandDimsLayer(net_in, 1 , name=\'d/expanddim2\')\n#\n#         # if is_train:\n#         #     net_in = DropoutLayer(net_in, keep=0.8, is_fix=True, name=\'d_in/drop\')\n#         # net_h0 = Conv2d(net_in, 2048, (1, 1), (1, 1), act=lrelu,\n#         #         padding=\'VALID\', W_init=w_init, name=\'d_h0/conv2d\')\n#         net_h0 = DenseLayer(net_in, n_units=1024, act=lrelu, W_init=w_init, name=\'d_h0/conv2d\')\n#\n#         # if is_train:\n#         #     net_h0 = DropoutLayer(net_h0, keep=0.8, is_fix=True, name=\'d_h0/drop\')\n#         # net_h1 = Conv2d(net_h0, 2048, (1, 1), (1, 1), act=lrelu,\n#         #         padding=\'VALID\', W_init=w_init, name=\'d_h1/conv2d\')\n#         net_h1 = DenseLayer(net_h0, n_units=1024, act=lrelu, W_init=w_init, name=\'d_h1/conv2d\')\n#\n#         # if is_train:\n#         #     net_h1 = DropoutLayer(net_h1, keep=0.8, is_fix=True, name=\'d_h1/drop\')\n#         # net_ho = Conv2d(net_h1, 1, (1, 1), (1, 1), act=None,\n#         #         padding=\'VALID\', W_init=w_init, name=\'d_ho/conv2d\')\n#         net_ho = DenseLayer(net_h1, n_units=1, act=tf.identity,#lrelu,\n#                 W_init=w_init, name=\'d_ho/conv2d\')\n#         # print(net_ho.outputs) # 1\n#         # exit()\n#         # net_ho = FlattenLayer(net_ho, name=\'d_ho/flatten\')\n#         # print(net_ho.outputs) # 1\n#         # exit()\n#         logits = net_ho.outputs\n#         net_ho.outputs = tf.nn.sigmoid(net_ho.outputs)\n#         return net_ho, logits\n#\n# def discriminator(x, z, is_train=True, reuse=False):\n#     """""" D(x, z) """"""\n#     net_z = discriminator_z(z, is_train=is_train, reuse=reuse)\n#     net_x = discriminator_x(x, is_train=is_train, reuse=reuse)\n#     net_d, logits = discriminator_combine_xz(net_x.outputs, net_z.outputs, is_train=is_train, reuse=reuse)\n#     net_d.all_params.extend(net_x.all_params)\n#     net_d.all_params.extend(net_z.all_params)\n#     return net_d, logits\n\n\n\n## for text-to-image mapping ===================================================\nt_dim = 128         # text feature dimension\nrnn_hidden_size = t_dim\nvocab_size = 8000\nword_embedding_size = 256\nkeep_prob = 1.0\n\ndef rnn_embed(input_seqs, is_train=True, reuse=False, return_embed=False):\n    """""" txt --> t_dim """"""\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    if tf.__version__ <= \'0.12.1\':\n        LSTMCell = tf.nn.rnn_cell.LSTMCell\n    else:\n        LSTMCell = tf.contrib.rnn.BasicLSTMCell\n    with tf.variable_scope(""rnnftxt"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        network = EmbeddingInputlayer(\n                     inputs = input_seqs,\n                     vocabulary_size = vocab_size,\n                     embedding_size = word_embedding_size,\n                     E_init = w_init,\n                     name = \'rnn/wordembed\')\n        network = DynamicRNNLayer(network,\n                     cell_fn = LSTMCell,\n                     cell_init_args = {\'state_is_tuple\' : True, \'reuse\': reuse},  # for TF1.1, TF1.2 dont need to set reuse\n                     n_hidden = rnn_hidden_size,\n                     dropout = (keep_prob if is_train else None),\n                     initializer = w_init,\n                     sequence_length = tl.layers.retrieve_seq_length_op2(input_seqs),\n                     return_last = True,\n                     name = \'rnn/dynamic\')\n        return network\n\ndef cnn_encoder(inputs, is_train=True, reuse=False, name=\'cnnftxt\', return_h3=False):\n    """""" 64x64 --> t_dim, for text-image mapping """"""\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    gamma_init = tf.random_normal_initializer(1., 0.02)\n    df_dim = 64\n\n    with tf.variable_scope(name, reuse=reuse):\n        tl.layers.set_name_reuse(True)\n\n        net_in = InputLayer(inputs, name=\'/in\')\n        net_h0 = Conv2d(net_in, df_dim, (4, 4), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n                padding=\'SAME\', W_init=w_init, name=\'cnnf/h0/conv2d\')\n\n        net_h1 = Conv2d(net_h0, df_dim*2, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'cnnf/h1/conv2d\')\n        net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'cnnf/h1/batch_norm\')\n\n        # if name != \'cnn\': # debug for training image encoder in step 2\n        #     net_h1 = DropoutLayer(net_h1, keep=0.8, is_fix=True, name=\'p/h1/drop\')\n\n        net_h2 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'cnnf/h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'cnnf/h2/batch_norm\')\n\n        # if name != \'cnn\': # debug for training image encoder in step 2\n        #     net_h2 = DropoutLayer(net_h2, keep=0.8, is_fix=True, name=\'p/h2/drop\')\n\n        net_h3 = Conv2d(net_h2, df_dim*8, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'cnnf/h3/conv2d\')\n        net_h3 = BatchNormLayer(net_h3, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'cnnf/h3/batch_norm\')\n\n        # if name != \'cnn\': # debug for training image encoder in step 2\n        #     net_h3 = DropoutLayer(net_h3, keep=0.8, is_fix=True, name=\'p/h3/drop\')\n\n        net_h4 = FlattenLayer(net_h3, name=\'cnnf/h4/flatten\')\n        net_h4 = DenseLayer(net_h4, n_units= (z_dim if name == \'z_encoder\' else t_dim),\n                act=tf.identity,\n                W_init = w_init, b_init = None, name=\'cnnf/h4/embed\')\n    if return_h3:\n        return net_h4, net_h3\n    else:\n        return net_h4\n\n\n## simple g1, d1 ===============================================================\ndef generator_txt2img_simple(input_z, input_rnn_embed=None, is_train=True, reuse=False, batch_size=64):\n    """""" z + (txt) --> 64x64 """"""\n    s = image_size\n    s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    b_init = None # tf.constant_initializer(value=0.0)\n    gamma_init = tf.random_normal_initializer(1., 0.02)\n    gf_dim = 128\n\n    with tf.variable_scope(""generator"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        net_in = InputLayer(input_z, name=\'g_inputz\')\n\n        if input_rnn_embed is not None:\n            net_txt = InputLayer(input_rnn_embed, name=\'g_rnn_embed_input\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim,\n                    act=lambda x: tl.act.lrelu(x, 0.2),\n                    W_init = w_init, b_init=None, name=\'g_reduce_text/dense\')\n            net_in = ConcatLayer([net_in, net_txt], concat_dim=1, name=\'g_concat_z_seq\')\n        else:\n            print(""No text info will be used, i.e. normal DCGAN"")\n\n        net_h0 = DenseLayer(net_in, gf_dim*8*s16*s16, act=tf.identity,\n                W_init=w_init, b_init=b_init, name=\'g_h0/dense\')\n        net_h0 = ReshapeLayer(net_h0, [-1, s16, s16, gf_dim*8], name=\'g_h0/reshape\')\n        net_h0 = BatchNormLayer(net_h0, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h0/batch_norm\')\n\n        net_h1 = DeConv2d(net_h0, gf_dim*4, (4, 4), out_size=(s8, s8), strides=(2, 2), # stackGI use (4, 4) https://github.com/hanzhanggit/StackGAN/blob/master/stageI/model.py\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=b_init, name=\'g_h1/decon2d\')\n        net_h1 = BatchNormLayer(net_h1, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h1/batch_norm\')\n\n        net_h2 = DeConv2d(net_h1, gf_dim*2, (4, 4), out_size=(s4, s4), strides=(2, 2),\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=b_init, name=\'g_h2/decon2d\')\n        net_h2 = BatchNormLayer(net_h2, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h2/batch_norm\')\n\n        net_h3 = DeConv2d(net_h2, gf_dim, (4, 4), out_size=(s2, s2), strides=(2, 2),\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=b_init, name=\'g_h3/decon2d\')\n        net_h3 = BatchNormLayer(net_h3, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h3/batch_norm\')\n\n        net_h4 = DeConv2d(net_h3, c_dim, (4, 4), out_size=(s, s), strides=(2, 2),\n                padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, name=\'g_h4/decon2d\')\n        logits = net_h4.outputs\n        net_h4.outputs = tf.nn.tanh(net_h4.outputs)\n    return net_h4, logits\n\ndef discriminator_txt2img_simple(input_images, input_rnn_embed=None, is_train=True, reuse=False):\n    """""" 64x64 + (txt) --> real/fake """"""\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    b_init = None # tf.constant_initializer(value=0.0)\n    gamma_init=tf.random_normal_initializer(1., 0.02)\n    df_dim = 64\n\n    with tf.variable_scope(""discriminator"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n\n        net_in = InputLayer(input_images, name=\'d_input/images\')\n        net_h0 = Conv2d(net_in, df_dim, (4, 4), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n                padding=\'SAME\', W_init=w_init, name=\'d_h0/conv2d\')\n\n        net_h1 = Conv2d(net_h0, df_dim*2, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'d_h1/conv2d\')\n        net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h1/batchnorm\')\n\n        net_h2 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'d_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h2/batchnorm\')\n\n        net_h3 = Conv2d(net_h2, df_dim*8, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'d_h3/conv2d\')\n        net_h3 = BatchNormLayer(net_h3, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h3/batchnorm\')\n\n        if input_rnn_embed is not None:\n            net_txt = InputLayer(input_rnn_embed, name=\'d_rnn_embed_input\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim,\n                   act=lambda x: tl.act.lrelu(x, 0.2),\n                   W_init=w_init, b_init=None, name=\'d_reduce_txt/dense\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'d_txt/expanddim1\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'d_txt/expanddim2\')\n            net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'d_txt/tile\')\n            net_h3_concat = ConcatLayer([net_h3, net_txt], concat_dim=3, name=\'d_h3_concat\')\n            # net_h3_concat = net_h3 # no text info\n            net_h3 = Conv2d(net_h3_concat, df_dim*8, (1, 1), (1, 1),\n                   padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'d_h3/conv2d_2\')\n            net_h3 = BatchNormLayer(net_h3, act=lambda x: tl.act.lrelu(x, 0.2),\n                   is_train=is_train, gamma_init=gamma_init, name=\'d_h3/batch_norm_2\')\n        else:\n            print(""No text info will be used, i.e. normal DCGAN"")\n\n        net_h4 = FlattenLayer(net_h3, name=\'d_h4/flatten\')\n        net_h4 = DenseLayer(net_h4, n_units=1, act=tf.identity,\n                W_init = w_init, name=\'d_h4/dense\')\n        logits = net_h4.outputs\n        net_h4.outputs = tf.nn.sigmoid(net_h4.outputs)\n    return net_h4, logits\n\n\n## default g1, d1 ==============================================================\ndef generator_txt2img_resnet(input_z, t_txt=None, is_train=True, reuse=False, batch_size=batch_size):\n    """""" z + (txt) --> 64x64 """"""\n    # https://github.com/hanzhanggit/StackGAN/blob/master/stageI/model.py\n    s = image_size # output image size [64]\n    s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n    gf_dim = 128\n\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    gamma_init = tf.random_normal_initializer(1., 0.02)\n\n    with tf.variable_scope(""generator"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        net_in = InputLayer(input_z, name=\'g_inputz\')\n\n        if t_txt is not None:\n            net_txt = InputLayer(t_txt, name=\'g_input_txt\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim,\n                act=lambda x: tl.act.lrelu(x, 0.2), W_init=w_init, name=\'g_reduce_text/dense\')\n            net_in = ConcatLayer([net_in, net_txt], concat_dim=1, name=\'g_concat_z_txt\')\n\n        net_h0 = DenseLayer(net_in, gf_dim*8*s16*s16, act=tf.identity,\n                W_init=w_init, b_init=None, name=\'g_h0/dense\')\n        net_h0 = BatchNormLayer(net_h0,  #act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h0/batch_norm\')\n        net_h0 = ReshapeLayer(net_h0, [-1, s16, s16, gf_dim*8], name=\'g_h0/reshape\')\n\n        net = Conv2d(net_h0, gf_dim*2, (1, 1), (1, 1),\n                padding=\'VALID\', act=None, W_init=w_init, b_init=None, name=\'g_h1_res/conv2d\')\n        net = BatchNormLayer(net, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h1_res/batch_norm\')\n        net = Conv2d(net, gf_dim*2, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h1_res/conv2d2\')\n        net = BatchNormLayer(net, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h1_res/batch_norm2\')\n        net = Conv2d(net, gf_dim*8, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h1_res/conv2d3\')\n        net = BatchNormLayer(net, # act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h1_res/batch_norm3\')\n        net_h1 = ElementwiseLayer(layer=[net_h0, net], combine_fn=tf.add, name=\'g_h1_res/add\')\n        net_h1.outputs = tf.nn.relu(net_h1.outputs)\n\n        # Note: you can also use DeConv2d to replace UpSampling2dLayer and Conv2d\n        # net_h2 = DeConv2d(net_h1, gf_dim*4, (4, 4), out_size=(s8, s8), strides=(2, 2),\n        #         padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=b_init, name=\'g_h2/decon2d\')\n        net_h2 = UpSampling2dLayer(net_h1, size=[s8, s8], is_scale=False, method=1,\n                align_corners=False, name=\'g_h2/upsample2d\')\n        net_h2 = Conv2d(net_h2, gf_dim*4, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2,# act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h2/batch_norm\')\n\n        net = Conv2d(net_h2, gf_dim, (1, 1), (1, 1),\n                padding=\'VALID\', act=None, W_init=w_init, b_init=None, name=\'g_h3_res/conv2d\')\n        net = BatchNormLayer(net, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h3_res/batch_norm\')\n        net = Conv2d(net, gf_dim, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h3_res/conv2d2\')\n        net = BatchNormLayer(net, act=tf.nn.relu, is_train=is_train,\n                gamma_init=gamma_init, name=\'g_h3_res/batch_norm2\')\n        net = Conv2d(net, gf_dim*4, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h3_res/conv2d3\')\n        net = BatchNormLayer(net, #act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h3_res/batch_norm3\')\n        net_h3 = ElementwiseLayer(layer=[net_h2, net], combine_fn=tf.add, name=\'g_h3/add\')\n        net_h3.outputs = tf.nn.relu(net_h3.outputs)\n\n        # net_h4 = DeConv2d(net_h3, gf_dim*2, (4, 4), out_size=(s4, s4), strides=(2, 2),\n        #         padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=b_init, name=\'g_h4/decon2d\'),\n        net_h4 = UpSampling2dLayer(net_h3, size=[s4, s4], is_scale=False, method=1,\n                align_corners=False, name=\'g_h4/upsample2d\')\n        net_h4 = Conv2d(net_h4, gf_dim*2, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h4/conv2d\')\n        net_h4 = BatchNormLayer(net_h4, act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h4/batch_norm\')\n\n        # net_h5 = DeConv2d(net_h4, gf_dim, (4, 4), out_size=(s2, s2), strides=(2, 2),\n        #         padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, b_init=b_init, name=\'g_h5/decon2d\')\n        net_h5 = UpSampling2dLayer(net_h4, size=[s2, s2], is_scale=False, method=1,\n                align_corners=False, name=\'g_h5/upsample2d\')\n        net_h5 = Conv2d(net_h5, gf_dim, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, b_init=None, name=\'g_h5/conv2d\')\n        net_h5 = BatchNormLayer(net_h5, act=tf.nn.relu,\n                is_train=is_train, gamma_init=gamma_init, name=\'g_h5/batch_norm\')\n\n        # net_ho = DeConv2d(net_h5, c_dim, (4, 4), out_size=(s, s), strides=(2, 2),\n        #         padding=\'SAME\', batch_size=batch_size, act=None, W_init=w_init, name=\'g_ho/decon2d\')\n        net_ho = UpSampling2dLayer(net_h5, size=[s, s], is_scale=False, method=1,\n                align_corners=False, name=\'g_ho/upsample2d\')\n        net_ho = Conv2d(net_ho, c_dim, (3, 3), (1, 1),\n                padding=\'SAME\', act=None, W_init=w_init, name=\'g_ho/conv2d\')\n        logits = net_ho.outputs\n        net_ho.outputs = tf.nn.tanh(net_ho.outputs)\n    return net_ho, logits\n\ndef discriminator_txt2img_resnet(input_images, t_txt=None, is_train=True, reuse=False):\n    """""" 64x64 + (txt) --> real/fake """"""\n    # https://github.com/hanzhanggit/StackGAN/blob/master/stageI/model.py\n    # Discriminator with ResNet : line 197 https://github.com/reedscot/icml2016/blob/master/main_cls.lua\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    gamma_init=tf.random_normal_initializer(1., 0.02)\n    df_dim = 64  # 64 for flower, 196 for MSCOCO\n    s = 64 # output image size [64]\n    s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n\n    with tf.variable_scope(""discriminator"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n        net_in = InputLayer(input_images, name=\'d_input/images\')\n        net_h0 = Conv2d(net_in, df_dim, (4, 4), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n                padding=\'SAME\', W_init=w_init, name=\'d_h0/conv2d\')\n\n        net_h1 = Conv2d(net_h0, df_dim*2, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h1/conv2d\')\n        net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h1/batchnorm\')\n        net_h2 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h2/batchnorm\')\n        net_h3 = Conv2d(net_h2, df_dim*8, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h3/conv2d\')\n        net_h3 = BatchNormLayer(net_h3, #act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h3/batchnorm\')\n\n        net = Conv2d(net_h3, df_dim*2, (1, 1), (1, 1), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'d_h4_res/conv2d\')\n        net = BatchNormLayer(net, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h4_res/batchnorm\')\n        net = Conv2d(net, df_dim*2, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h4_res/conv2d2\')\n        net = BatchNormLayer(net, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h4_res/batchnorm2\')\n        net = Conv2d(net, df_dim*8, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h4_res/conv2d3\')\n        net = BatchNormLayer(net, #act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h4_res/batchnorm3\')\n        net_h4 = ElementwiseLayer(layer=[net_h3, net], combine_fn=tf.add, name=\'d_h4/add\')\n        net_h4.outputs = tl.act.lrelu(net_h4.outputs, 0.2)\n\n        if t_txt is not None:\n            net_txt = InputLayer(t_txt, name=\'d_input_txt\')\n            net_txt = DenseLayer(net_txt, n_units=t_dim,\n                   act=lambda x: tl.act.lrelu(x, 0.2),\n                   W_init=w_init, name=\'d_reduce_txt/dense\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'d_txt/expanddim1\')\n            net_txt = ExpandDimsLayer(net_txt, 1, name=\'d_txt/expanddim2\')\n            net_txt = TileLayer(net_txt, [1, 4, 4, 1], name=\'d_txt/tile\')\n            net_h4_concat = ConcatLayer([net_h4, net_txt], concat_dim=3, name=\'d_h3_concat\')\n            # 243 (ndf*8 + 128 or 256) x 4 x 4\n            net_h4 = Conv2d(net_h4_concat, df_dim*8, (1, 1), (1, 1),\n                    padding=\'VALID\', W_init=w_init, b_init=None, name=\'d_h3/conv2d_2\')\n            net_h4 = BatchNormLayer(net_h4, act=lambda x: tl.act.lrelu(x, 0.2),\n                    is_train=is_train, gamma_init=gamma_init, name=\'d_h3/batch_norm_2\')\n\n        net_ho = Conv2d(net_h4, 1, (s16, s16), (s16, s16), padding=\'VALID\', W_init=w_init, name=\'d_ho/conv2d\')\n        # 1 x 1 x 1\n        # net_ho = FlattenLayer(net_h4, name=\'d_ho/flatten\')\n        logits = net_ho.outputs\n        net_ho.outputs = tf.nn.sigmoid(net_ho.outputs)\n    return net_ho, logits\n\ndef z_encoder(input_images, is_train=True, reuse=False):\n    """""" 64x64 -> z """"""\n    w_init = tf.random_normal_initializer(stddev=0.02)\n    gamma_init=tf.random_normal_initializer(1., 0.02)\n    df_dim = 64  # 64 for flower, 196 for MSCOCO\n    s = 64 # output image size [64]\n    s2, s4, s8, s16 = int(s/2), int(s/4), int(s/8), int(s/16)\n\n    with tf.variable_scope(""z_encoder"", reuse=reuse):\n        tl.layers.set_name_reuse(reuse)\n\n        net_in = InputLayer(input_images, name=\'d_input/images\')\n        net_h0 = Conv2d(net_in, df_dim, (4, 4), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n                padding=\'SAME\', W_init=w_init, name=\'d_h0/conv2d\')\n\n        net_h1 = Conv2d(net_h0, df_dim*2, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h1/conv2d\')\n        net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h1/batchnorm\')\n        net_h2 = Conv2d(net_h1, df_dim*4, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h2/conv2d\')\n        net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h2/batchnorm\')\n        net_h3 = Conv2d(net_h2, df_dim*8, (4, 4), (2, 2), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h3/conv2d\')\n        net_h3 = BatchNormLayer(net_h3, #act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h3/batchnorm\')\n\n        net = Conv2d(net_h3, df_dim*2, (1, 1), (1, 1), act=None,\n                padding=\'VALID\', W_init=w_init, b_init=None, name=\'d_h4_res/conv2d\')\n        net = BatchNormLayer(net, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h4_res/batchnorm\')\n        net = Conv2d(net, df_dim*2, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h4_res/conv2d2\')\n        net = BatchNormLayer(net, act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h4_res/batchnorm2\')\n        net = Conv2d(net, df_dim*8, (3, 3), (1, 1), act=None,\n                padding=\'SAME\', W_init=w_init, b_init=None, name=\'d_h4_res/conv2d3\')\n        net = BatchNormLayer(net, #act=lambda x: tl.act.lrelu(x, 0.2),\n                is_train=is_train, gamma_init=gamma_init, name=\'d_h4_res/batchnorm3\')\n        net_h4 = ElementwiseLayer(layer=[net_h3, net], combine_fn=tf.add, name=\'d_h4/add\')\n        net_h4.outputs = tl.act.lrelu(net_h4.outputs, 0.2)\n\n        net_ho = FlattenLayer(net_h4, name=\'d_ho/flatten\')\n        net_ho = DenseLayer(net_ho, n_units=z_dim, act=tf.identity,\n                W_init = w_init, name=\'d_ho/dense\')\n\n        # w_init = tf.random_normal_initializer(stddev=0.02)\n        # b_init = None\n        # gamma_init = tf.random_normal_initializer(1., 0.02)\n        #\n        # net_in = InputLayer(input_images, name=\'p/in\')\n        # net_h0 = Conv2d(net_in, df_dim, (5, 5), (2, 2), act=lambda x: tl.act.lrelu(x, 0.2),\n        #         padding=\'SAME\', W_init=w_init, name=\'p/h0/conv2d\')\n        #\n        # net_h1 = Conv2d(net_h0, df_dim*2, (5, 5), (2, 2), act=None,\n        #         padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'p/h1/conv2d\')\n        # net_h1 = BatchNormLayer(net_h1, act=lambda x: tl.act.lrelu(x, 0.2),\n        #         is_train=is_train, gamma_init=gamma_init, name=\'p/h1/batch_norm\')\n        #\n        # net_h2 = Conv2d(net_h1, df_dim*4, (5, 5), (2, 2), act=None,\n        #         padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'p/h2/conv2d\')\n        # net_h2 = BatchNormLayer(net_h2, act=lambda x: tl.act.lrelu(x, 0.2),\n        #         is_train=is_train, gamma_init=gamma_init, name=\'p/h2/batch_norm\')\n        #\n        # net_h3 = Conv2d(net_h2, df_dim*8, (5, 5), (2, 2), act=None,\n        #         padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'p/h3/conv2d\')\n        # net_h3 = BatchNormLayer(net_h3, act=lambda x: tl.act.lrelu(x, 0.2),\n        #         is_train=is_train, gamma_init=gamma_init, name=\'p/h3/batch_norm\')\n        #\n        # net_h4 = FlattenLayer(net_h3, name=\'p/h4/flatten\')\n        # net_ho = DenseLayer(net_h4, n_units=z_dim,\n        #         act=tf.identity,\n        #         # act=tf.nn.tanh,\n        #         W_init = w_init, name=\'p/h4/output_real_fake\')\n    return net_ho\n'"
train_txt2im.py,35,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n"""""" GAN-CLS """"""\nimport tensorflow as tf\nimport tensorlayer as tl\nfrom tensorlayer.layers import *\nfrom tensorlayer.prepro import *\nfrom tensorlayer.cost import *\nimport numpy as np\nimport scipy\nfrom scipy.io import loadmat\nimport time, os, re, nltk\n\nfrom utils import *\nfrom model import *\nimport model\n\n###======================== PREPARE DATA ====================================###\nprint(""Loading data from pickle ..."")\nimport pickle\nwith open(""_vocab.pickle"", \'rb\') as f:\n    vocab = pickle.load(f)\nwith open(""_image_train.pickle"", \'rb\') as f:\n    _, images_train = pickle.load(f)\nwith open(""_image_test.pickle"", \'rb\') as f:\n    _, images_test = pickle.load(f)\nwith open(""_n.pickle"", \'rb\') as f:\n    n_captions_train, n_captions_test, n_captions_per_image, n_images_train, n_images_test = pickle.load(f)\nwith open(""_caption.pickle"", \'rb\') as f:\n    captions_ids_train, captions_ids_test = pickle.load(f)\n# images_train_256 = np.array(images_train_256)\n# images_test_256 = np.array(images_test_256)\nimages_train = np.array(images_train)\nimages_test = np.array(images_test)\n\n# print(n_captions_train, n_captions_test)\n# exit()\n\nni = int(np.ceil(np.sqrt(batch_size)))\n# os.system(""mkdir samples"")\n# os.system(""mkdir samples/step1_gan-cls"")\n# os.system(""mkdir checkpoint"")\ntl.files.exists_or_mkdir(""samples/step1_gan-cls"")\ntl.files.exists_or_mkdir(""samples/step_pretrain_encoder"")\ntl.files.exists_or_mkdir(""checkpoint"")\nsave_dir = ""checkpoint""\n\n\ndef main_train():\n    ###======================== DEFIINE MODEL ===================================###\n    t_real_image = tf.placeholder(\'float32\', [batch_size, image_size, image_size, 3], name = \'real_image\')\n    t_wrong_image = tf.placeholder(\'float32\', [batch_size ,image_size, image_size, 3], name = \'wrong_image\')\n    t_real_caption = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=\'real_caption_input\')\n    t_wrong_caption = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=\'wrong_caption_input\')\n    t_z = tf.placeholder(tf.float32, [batch_size, z_dim], name=\'z_noise\')\n\n    ## training inference for text-to-image mapping\n    net_cnn = cnn_encoder(t_real_image, is_train=True, reuse=False)\n    x = net_cnn.outputs\n    v = rnn_embed(t_real_caption, is_train=True, reuse=False).outputs\n    x_w = cnn_encoder(t_wrong_image, is_train=True, reuse=True).outputs\n    v_w = rnn_embed(t_wrong_caption, is_train=True, reuse=True).outputs\n\n    alpha = 0.2 # margin alpha\n    rnn_loss = tf.reduce_mean(tf.maximum(0., alpha - cosine_similarity(x, v) + cosine_similarity(x, v_w))) + \\\n                tf.reduce_mean(tf.maximum(0., alpha - cosine_similarity(x, v) + cosine_similarity(x_w, v)))\n\n    ## training inference for txt2img\n    generator_txt2img = model.generator_txt2img_resnet\n    discriminator_txt2img = model.discriminator_txt2img_resnet\n\n    net_rnn = rnn_embed(t_real_caption, is_train=False, reuse=True)\n    net_fake_image, _ = generator_txt2img(t_z,\n                    net_rnn.outputs,\n                    is_train=True, reuse=False, batch_size=batch_size)\n                    #+ tf.random_normal(shape=net_rnn.outputs.get_shape(), mean=0, stddev=0.02), # NOISE ON RNN\n    net_d, disc_fake_image_logits = discriminator_txt2img(\n                    net_fake_image.outputs, net_rnn.outputs, is_train=True, reuse=False)\n    _, disc_real_image_logits = discriminator_txt2img(\n                    t_real_image, net_rnn.outputs, is_train=True, reuse=True)\n    _, disc_mismatch_logits = discriminator_txt2img(\n                    # t_wrong_image,\n                    t_real_image,\n                    # net_rnn.outputs,\n                    rnn_embed(t_wrong_caption, is_train=False, reuse=True).outputs,\n                    is_train=True, reuse=True)\n\n    ## testing inference for txt2img\n    net_g, _ = generator_txt2img(t_z,\n                    rnn_embed(t_real_caption, is_train=False, reuse=True).outputs,\n                    is_train=False, reuse=True, batch_size=batch_size)\n\n    d_loss1 = tl.cost.sigmoid_cross_entropy(disc_real_image_logits, tf.ones_like(disc_real_image_logits), name=\'d1\')\n    d_loss2 = tl.cost.sigmoid_cross_entropy(disc_mismatch_logits,  tf.zeros_like(disc_mismatch_logits), name=\'d2\')\n    d_loss3 = tl.cost.sigmoid_cross_entropy(disc_fake_image_logits, tf.zeros_like(disc_fake_image_logits), name=\'d3\')\n    d_loss = d_loss1 + (d_loss2 + d_loss3) * 0.5\n    g_loss = tl.cost.sigmoid_cross_entropy(disc_fake_image_logits, tf.ones_like(disc_fake_image_logits), name=\'g\')\n\n    ####======================== DEFINE TRAIN OPTS ==============================###\n    lr = 0.0002\n    lr_decay = 0.5      # decay factor for adam, https://github.com/reedscot/icml2016/blob/master/main_cls_int.lua  https://github.com/reedscot/icml2016/blob/master/scripts/train_flowers.sh\n    decay_every = 100   # https://github.com/reedscot/icml2016/blob/master/main_cls.lua\n    beta1 = 0.5\n\n    cnn_vars = tl.layers.get_variables_with_name(\'cnn\', True, True)\n    rnn_vars = tl.layers.get_variables_with_name(\'rnn\', True, True)\n    d_vars = tl.layers.get_variables_with_name(\'discriminator\', True, True)\n    g_vars = tl.layers.get_variables_with_name(\'generator\', True, True)\n\n    with tf.variable_scope(\'learning_rate\'):\n        lr_v = tf.Variable(lr, trainable=False)\n    d_optim = tf.train.AdamOptimizer(lr_v, beta1=beta1).minimize(d_loss, var_list=d_vars )\n    g_optim = tf.train.AdamOptimizer(lr_v, beta1=beta1).minimize(g_loss, var_list=g_vars )\n    # e_optim = tf.train.AdamOptimizer(lr_v, beta1=beta1).minimize(e_loss, var_list=e_vars + c_vars)\n    grads, _ = tf.clip_by_global_norm(tf.gradients(rnn_loss, rnn_vars + cnn_vars), 10)\n    optimizer = tf.train.AdamOptimizer(lr_v, beta1=beta1)# optimizer = tf.train.GradientDescentOptimizer(lre)\n    rnn_optim = optimizer.apply_gradients(zip(grads, rnn_vars + cnn_vars))\n\n    # adam_vars = tl.layers.get_variables_with_name(\'Adam\', False, True)\n\n    ###============================ TRAINING ====================================###\n    sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True))\n    tl.layers.initialize_global_variables(sess)\n\n    # load the latest checkpoints\n    net_rnn_name = os.path.join(save_dir, \'net_rnn.npz\')\n    net_cnn_name = os.path.join(save_dir, \'net_cnn.npz\')\n    net_g_name = os.path.join(save_dir, \'net_g.npz\')\n    net_d_name = os.path.join(save_dir, \'net_d.npz\')\n\n    load_and_assign_npz(sess=sess, name=net_rnn_name, model=net_rnn)\n    load_and_assign_npz(sess=sess, name=net_cnn_name, model=net_cnn)\n    load_and_assign_npz(sess=sess, name=net_g_name, model=net_g)\n    load_and_assign_npz(sess=sess, name=net_d_name, model=net_d)\n\n    ## seed for generation, z and sentence ids\n    sample_size = batch_size\n    sample_seed = np.random.normal(loc=0.0, scale=1.0, size=(sample_size, z_dim)).astype(np.float32)\n        # sample_seed = np.random.uniform(low=-1, high=1, size=(sample_size, z_dim)).astype(np.float32)]\n    n = int(sample_size / ni)\n    sample_sentence = [""the flower shown has yellow anther red pistil and bright red petals.""] * n + \\\n                      [""this flower has petals that are yellow, white and purple and has dark lines""] * n + \\\n                      [""the petals on this flower are white with a yellow center""] * n + \\\n                      [""this flower has a lot of small round pink petals.""] * n + \\\n                      [""this flower is orange in color, and has petals that are ruffled and rounded.""] * n + \\\n                      [""the flower has yellow petals and the center of it is brown.""] * n + \\\n                      [""this flower has petals that are blue and white.""] * n +\\\n                      [""these white flowers have petals that start off white in color and end in a white towards the tips.""] * n\n\n    # sample_sentence = captions_ids_test[0:sample_size]\n    for i, sentence in enumerate(sample_sentence):\n        print(""seed: %s"" % sentence)\n        sentence = preprocess_caption(sentence)\n        sample_sentence[i] = [vocab.word_to_id(word) for word in nltk.tokenize.word_tokenize(sentence)] + [vocab.end_id]    # add END_ID\n        # sample_sentence[i] = [vocab.word_to_id(word) for word in sentence]\n        # print(sample_sentence[i])\n    sample_sentence = tl.prepro.pad_sequences(sample_sentence, padding=\'post\')\n\n    n_epoch = 100 # 600\n    print_freq = 1\n    n_batch_epoch = int(n_images_train / batch_size)\n    # exit()\n    for epoch in range(0, n_epoch+1):\n        start_time = time.time()\n\n        if epoch !=0 and (epoch % decay_every == 0):\n            new_lr_decay = lr_decay ** (epoch // decay_every)\n            sess.run(tf.assign(lr_v, lr * new_lr_decay))\n            log = "" ** new learning rate: %f"" % (lr * new_lr_decay)\n            print(log)\n            # logging.debug(log)\n        elif epoch == 0:\n            log = "" ** init lr: %f  decay_every_epoch: %d, lr_decay: %f"" % (lr, decay_every, lr_decay)\n            print(log)\n\n        for step in range(n_batch_epoch):\n            step_time = time.time()\n            ## get matched text\n            idexs = get_random_int(min=0, max=n_captions_train-1, number=batch_size)\n            b_real_caption = captions_ids_train[idexs]\n            b_real_caption = tl.prepro.pad_sequences(b_real_caption, padding=\'post\')\n            ## get real image\n            b_real_images = images_train[np.floor(np.asarray(idexs).astype(\'float\')/n_captions_per_image).astype(\'int\')]\n            # save_images(b_real_images, [ni, ni], \'samples/step1_gan-cls/train_00.png\')\n            ## get wrong caption\n            idexs = get_random_int(min=0, max=n_captions_train-1, number=batch_size)\n            b_wrong_caption = captions_ids_train[idexs]\n            b_wrong_caption = tl.prepro.pad_sequences(b_wrong_caption, padding=\'post\')\n            ## get wrong image\n            idexs2 = get_random_int(min=0, max=n_images_train-1, number=batch_size)\n            b_wrong_images = images_train[idexs2]\n            ## get noise\n            b_z = np.random.normal(loc=0.0, scale=1.0, size=(sample_size, z_dim)).astype(np.float32)\n                # b_z = np.random.uniform(low=-1, high=1, size=[batch_size, z_dim]).astype(np.float32)\n\n            b_real_images = threading_data(b_real_images, prepro_img, mode=\'train\')   # [0, 255] --> [-1, 1] + augmentation\n            b_wrong_images = threading_data(b_wrong_images, prepro_img, mode=\'train\')\n            ## updates text-to-image mapping\n            if epoch < 50:\n                errRNN, _ = sess.run([rnn_loss, rnn_optim], feed_dict={\n                                                t_real_image : b_real_images,\n                                                t_wrong_image : b_wrong_images,\n                                                t_real_caption : b_real_caption,\n                                                t_wrong_caption : b_wrong_caption})\n            else:\n                errRNN = 0\n\n            ## updates D\n            errD, _ = sess.run([d_loss, d_optim], feed_dict={\n                            t_real_image : b_real_images,\n                            # t_wrong_image : b_wrong_images,\n                            t_wrong_caption : b_wrong_caption,\n                            t_real_caption : b_real_caption,\n                            t_z : b_z})\n            ## updates G\n            errG, _ = sess.run([g_loss, g_optim], feed_dict={\n                            t_real_caption : b_real_caption,\n                            t_z : b_z})\n\n            print(""Epoch: [%2d/%2d] [%4d/%4d] time: %4.4fs, d_loss: %.8f, g_loss: %.8f, rnn_loss: %.8f"" \\\n                        % (epoch, n_epoch, step, n_batch_epoch, time.time() - step_time, errD, errG, errRNN))\n\n        if (epoch + 1) % print_freq == 0:\n            print("" ** Epoch %d took %fs"" % (epoch, time.time()-start_time))\n            img_gen, rnn_out = sess.run([net_g.outputs, net_rnn.outputs], feed_dict={\n                                        t_real_caption : sample_sentence,\n                                        t_z : sample_seed})\n\n            # img_gen = threading_data(img_gen, prepro_img, mode=\'rescale\')\n            save_images(img_gen, [ni, ni], \'samples/step1_gan-cls/train_{:02d}.png\'.format(epoch))\n\n        ## save model\n        if (epoch != 0) and (epoch % 10) == 0:\n            tl.files.save_npz(net_cnn.all_params, name=net_cnn_name, sess=sess)\n            tl.files.save_npz(net_rnn.all_params, name=net_rnn_name, sess=sess)\n            tl.files.save_npz(net_g.all_params, name=net_g_name, sess=sess)\n            tl.files.save_npz(net_d.all_params, name=net_d_name, sess=sess)\n            print(""[*] Save checkpoints SUCCESS!"")\n\n        if (epoch != 0) and (epoch % 100) == 0:\n            tl.files.save_npz(net_cnn.all_params, name=net_cnn_name+str(epoch), sess=sess)\n            tl.files.save_npz(net_rnn.all_params, name=net_rnn_name+str(epoch), sess=sess)\n            tl.files.save_npz(net_g.all_params, name=net_g_name+str(epoch), sess=sess)\n            tl.files.save_npz(net_d.all_params, name=net_d_name+str(epoch), sess=sess)\n\n        # if (epoch != 0) and (epoch % 200) == 0:\n        #     sess.run(tf.initialize_variables(adam_vars))\n        #     print(""Re-initialize Adam"")\n\n#\n# def main_train_encoder():\n#     """""" for Style Transfer """"""\n#     generator_txt2img = model.generator_txt2img_resnet\n#\n#     ## for training\n#     t_real_caption = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=\'real_caption_input\')\n#     t_z = tf.placeholder(tf.float32, [batch_size, z_dim], name=\'z_noise\')\n#\n#     net_rnn = rnn_embed(t_real_caption, is_train=False, reuse=False)\n#     net_fake_image, _ = generator_txt2img(t_z,\n#                     net_rnn.outputs + tf.random_normal(shape=net_rnn.outputs.get_shape(), mean=0, stddev=0.02), # NOISE ON RNN\n#                     is_train=True, reuse=False, batch_size=batch_size)\n#     net_encoder = z_encoder(net_fake_image.outputs, is_train=True, reuse=False)\n#\n#     ## for evaluation\n#     t_real_image = tf.placeholder(\'float32\', [batch_size, image_size, image_size, 3], name = \'real_image\')\n#     net_z = z_encoder(t_real_image, is_train=False, reuse=True)\n#     net_g2, _ = generator_txt2img(net_z.outputs, net_rnn.outputs, is_train=False, reuse=True, batch_size=batch_size)\n#\n#     loss = tf.reduce_mean( tf.square( tf.sub( net_encoder.outputs, t_z) ))\n#     e_vars = tl.layers.get_variables_with_name(\'z_encoder\', True, True)\n#\n#     lr = 0.0002\n#     lr_decay = 0.5      # decay factor for adam, https://github.com/reedscot/icml2016/blob/master/main_cls_int.lua  https://github.com/reedscot/icml2016/blob/master/scripts/train_flowers.sh\n#     decay_every = 100   # https://github.com/reedscot/icml2016/blob/master/main_cls.lua\n#     beta1 = 0.5\n#\n#     with tf.variable_scope(\'learning_rate\'):\n#         lr_v = tf.Variable(lr, trainable=False)\n#\n#     e_optim = tf.train.AdamOptimizer(lr_v, beta1=beta1).minimize(loss, var_list=e_vars )\n#\n#\n#     ###============================ TRAINING ====================================###\n#     sess = tf.InteractiveSession()\n#     tl.layers.initialize_global_variables(sess)\n#\n#     net_g_name = os.path.join(save_dir, \'net_g.npz\')\n#     net_encoder_name = os.path.join(save_dir, \'net_encoder.npz\')\n#\n#     if load_and_assign_npz(sess=sess, name=net_g_name, model=net_fake_image) is False:\n#         raise Exception(""Cannot find net_g.npz"")\n#     load_and_assign_npz(sess=sess, name=net_encoder_name, model=net_encoder)\n#\n#     sample_size = batch_size\n#     idexs = get_random_int(min=0, max=n_captions_train-1, number=sample_size, seed=100)\n#     sample_sentence = captions_ids_train[idexs]\n#     sample_sentence = tl.prepro.pad_sequences(sample_sentence, padding=\'post\')\n#     sample_image = images_train[np.floor(np.asarray(idexs).astype(\'float\')/n_captions_per_image).astype(\'int\')]\n#     # print(sample_image.shape, np.min(sample_image), np.max(sample_image), image_size)\n#     # exit()\n#     sample_image = threading_data(sample_image, prepro_img, mode=\'translation\')    # central crop first\n#     save_images(sample_image, [ni, ni], \'samples/step_pretrain_encoder/train__x.png\')\n#\n#\n#     n_epoch = 160 * 100\n#     print_freq = 1\n#     n_batch_epoch = int(n_images_train / batch_size)\n#\n#     for epoch in range(0, n_epoch+1):\n#         start_time = time.time()\n#\n#         if epoch !=0 and (epoch % decay_every == 0):\n#             new_lr_decay = lr_decay ** (epoch // decay_every)\n#             sess.run(tf.assign(lr_v, lr * new_lr_decay))\n#             log = "" ** new learning rate: %f"" % (lr * new_lr_decay)\n#             print(log)\n#             # logging.debug(log)\n#         elif epoch == 0:\n#             log = "" ** init lr: %f  decay_every_epoch: %d, lr_decay: %f"" % (lr, decay_every, lr_decay)\n#             print(log)\n#\n#         for step in range(n_batch_epoch):\n#             step_time = time.time()\n#             ## get matched text\n#             idexs = get_random_int(min=0, max=n_captions_train-1, number=batch_size)\n#             b_real_caption = captions_ids_train[idexs]\n#             b_real_caption = tl.prepro.pad_sequences(b_real_caption, padding=\'post\')\n#             # ## get real image\n#             # b_real_images = images_train[np.floor(np.asarray(idexs).astype(\'float\')/n_captions_per_image).astype(\'int\')]\n#             # ## get wrong caption\n#             # idexs = get_random_int(min=0, max=n_captions_train-1, number=batch_size)\n#             # b_wrong_caption = captions_ids_train[idexs]\n#             # b_wrong_caption = tl.prepro.pad_sequences(b_wrong_caption, padding=\'post\')\n#             # ## get wrong image\n#             # idexs2 = get_random_int(min=0, max=n_images_train-1, number=batch_size)\n#             # b_wrong_images = images_train[idexs2]\n#             # ## get noise\n#             b_z = np.random.normal(loc=0.0, scale=1.0, size=(sample_size, z_dim)).astype(np.float32)\n#                 # b_z = np.random.uniform(low=-1, high=1, size=[batch_size, z_dim]).astype(np.float32)\n#\n#             ## update E\n#             errE, _ = sess.run([loss, e_optim], feed_dict={\n#                             t_real_caption : b_real_caption,\n#                             t_z : b_z})\n#                             # t_real_image : b_real_images,})\n#\n#             print(""Epoch: [%2d/%2d] [%4d/%4d] time: %4.4fs, e_loss: %8f"" \\\n#                         % (epoch, n_epoch, step, n_batch_epoch, time.time() - step_time, errE))\n#\n#         if (epoch + 1) % 10 == 0:\n#             print("" ** Epoch %d took %fs"" % (epoch, time.time()-start_time))\n#             # print(sample_image.shape, t_real_image)\n#             img_gen = sess.run(net_g2.outputs, feed_dict={\n#                                         t_real_caption : sample_sentence,\n#                                         t_real_image : sample_image,})\n#             img_gen = threading_data(img_gen, imresize, size=[64, 64], interp=\'bilinear\')\n#             save_images(img_gen, [ni, ni], \'samples/step_pretrain_encoder/train_{:02d}_g(e(x))).png\'.format(epoch))\n#\n#         if (epoch != 0) and (epoch % 5) == 0:\n#             tl.files.save_npz(net_encoder.all_params, name=net_encoder_name, sess=sess)\n#             print(""[*] Save checkpoints SUCCESS!"")\n#\n#\n# def main_transaltion():\n#     generator_txt2img = model.generator_txt2img_resnet\n#\n#     t_real_caption = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=\'real_caption_input\')\n#     t_real_image = tf.placeholder(\'float32\', [batch_size, image_size, image_size, 3], name = \'real_image\')\n#\n#     net_rnn = rnn_embed(t_real_caption, is_train=False, reuse=False)\n#     net_z = z_encoder(t_real_image, is_train=False, reuse=False)\n#     net_g, _ = generator_txt2img(net_z.outputs, net_rnn.outputs, is_train=False, reuse=False)\n#\n#     sess = tf.InteractiveSession()\n#     tl.layers.initialize_global_variables(sess)\n#\n#     net_rnn_name = os.path.join(save_dir, \'net_rnn.npz\')\n#     net_g_name = os.path.join(save_dir, \'net_g.npz\')\n#     net_e_name = os.path.join(save_dir, \'net_encoder.npz\')\n#\n#     load_and_assign_npz(sess=sess, name=net_rnn_name, model=net_rnn)\n#     load_and_assign_npz(sess=sess, name=net_g_name, model=net_g)\n#     load_and_assign_npz(sess=sess, name=net_e_name, model=net_z)\n#\n#     ## random images\n#     # idexs = get_random_int(min=0, max=n_captions_train-1, number=batch_size, seed=100)  # train set\n#     # images = images_train[np.floor(np.asarray(idexs).astype(\'float\')/n_captions_per_image).astype(\'int\')]\n#     # sample_sentence = captions_ids_train[idexs]\n#     idexs = get_random_int(min=0, max=n_captions_test-1, number=batch_size, seed=100) # test set\n#     images = images_test[np.floor(np.asarray(idexs).astype(\'float\')/n_captions_per_image).astype(\'int\')]\n#     for i in [0,8,16,24,32,40,48,56]:\n#         images[i] = images_test[1834]     # DONE easy 226\n#         images[i+1] = images_test[620]    # stand on big staff\n#         images[i+2] = images_test[653]    # 653\n#         images[i+3] = images_test[77]   # DONE flying 16 20 2166big 2303ok 2306ok 2311good 2313soso 2317soso  2311(want to change)\n#         images[i+4] = images_test[2167]   # brunch 275 559 2101\n#\n#         images[i+5] = images_test[235]\n#         images[i+6] = images_test[1455]  # 717 402\n#         images[i+7] = images_test[159]  # fat 300  125  159  612\n#         # # train set\n#         # images[i] = images_train[620]\n#         # images[i+1] = images_train[653]\n#         # images[i+2] = images_train[300]\n#         # images[i+3] = images_train[350]\n#         # images[i+4] = images_train[550]\n#         # images[i+5] = images_train[700]\n#         # images[i+6] = images_train[717]\n#         # images[i+7] = images_train[275]\n#     # sample_sentence = captions_ids_test[idexs]\n#     images = threading_data(images, prepro_img, mode=\'translation\')\n#     save_images(images, [ni, ni], \'samples/translation/_reed_method_ori.png\')\n#\n#     # all done\n#     sample_sentence = [""This small bird has a blue crown and white belly.""] * ni + \\\n#                       [""This small yellow bird has grey wings, and a black bill.""] * ni + \\\n#                       [""This particular bird with a red head and breast and features grey wings.""] * ni + \\\n#                       [""This black bird has no other colors with a short bill.""] * ni + \\\n#                       [""An orange bird with green wings and blue head.""] * ni + \\\n#                       [""A black bird with a red head.""] * ni + \\\n#                       [""A red body bird with black wings and a gray beak.""] * ni + \\\n#                       [""A small brown bird with a brown crown has a white belly.""] * ni\n#\n#     for i, sentence in enumerate(sample_sentence):\n#         print(""seed: %s"" % sentence)\n#         sentence = preprocess_caption(sentence)\n#         sample_sentence[i] = [vocab.word_to_id(word) for word in nltk.tokenize.word_tokenize(sentence)] #+ [vocab.end_id]    # add END_ID\n#         # sample_sentence[i] = [vocab.word_to_id(word) for word in sentence]\n#         # print(sample_sentence[i])\n#     sample_sentence = tl.prepro.pad_sequences(sample_sentence, padding=\'post\')\n#\n#     for i in range(1):\n#         img_trans = sess.run(net_g.outputs, feed_dict={\n#                                     t_real_caption : sample_sentence,\n#                                     t_real_image : images,\n#                                     })\n#\n#         save_images(img_trans, [ni, ni], \'samples/translation/_reed_method_tran%d.png\' % i)\n#         print(""completed %s"" % i)\n\nif __name__ == \'__main__\':\n    import argparse\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\'--mode\', type=str, default=""train"",\n                       help=\'train, train_encoder, translation\')\n\n    args = parser.parse_args()\n\n    if args.mode == ""train"":\n        main_train()\n\n    ## you would not use this part, unless you want to try style transfer on GAN-CLS paper\n    # elif args.mode == ""train_encoder"":\n    #     main_train_encoder()\n    #\n    # elif args.mode == ""translation"":\n    #     main_transaltion()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n'"
utils.py,0,"b'import tensorflow as tf\nimport os\nimport random\nimport scipy\nimport scipy.misc\nimport numpy as np\nimport re\nimport string\n\n"""""" The functions here will be merged into TensorLayer after finishing this project.\n""""""\n\ndef load_and_assign_npz(sess=None, name="""", model=None):\n    assert model is not None\n    assert sess is not None\n    if not os.path.exists(name):\n        print(""[!] Loading {} model failed!"".format(name))\n        return False\n    else:\n        params = tl.files.load_npz(name=name)\n        tl.files.assign_params(sess, params, model)\n        print(""[*] Loading {} model SUCCESS!"".format(name))\n        return model\n\n\n#files\ndef load_folder_list(path=""""):\n    """"""Return a folder list in a folder by given a folder path.\n\n    Parameters\n    ----------\n    path : a string or None\n        A folder path.\n    """"""\n    return [os.path.join(path,o) for o in os.listdir(path) if os.path.isdir(os.path.join(path,o))]\n\n#utils\ndef print_dict(dictionary={}):\n    """"""Print all keys and items in a dictionary.\n    """"""\n    for key, value in dictionary.iteritems():\n        print(""key: %s  value: %s"" % (str(key), str(value)))\n\n#prepro ?\ndef get_random_int(min=0, max=10, number=5):\n    """"""Return a list of random integer by the given range and quantity.\n\n    Examples\n    ---------\n    >>> r = get_random_int(min=0, max=10, number=5)\n    ... [10, 2, 3, 3, 7]\n    """"""\n    return [random.randint(min,max) for p in range(0,number)]\n\ndef preprocess_caption(line):\n    prep_line = re.sub(\'[%s]\' % re.escape(string.punctuation), \' \', line.rstrip())\n    prep_line = prep_line.replace(\'-\', \' \')\n    return prep_line\n\n\n## Save images\ndef merge(images, size):\n    h, w = images.shape[1], images.shape[2]\n    img = np.zeros((h * size[0], w * size[1], 3))\n    for idx, image in enumerate(images):\n        i = idx % size[1]\n        j = idx // size[1]\n        img[j*h:j*h+h, i*w:i*w+w, :] = image\n    return img\n\ndef imsave(images, size, path):\n    return scipy.misc.imsave(path, merge(images, size))\n\ndef save_images(images, size, image_path):\n    return imsave(images, size, image_path)\n\nfrom tensorlayer.prepro import *\ndef prepro_img(x, mode=None):\n    if mode==\'train\':\n    # rescale [0, 255] --> (-1, 1), random flip, crop, rotate\n    #   paper 5.1: During mini-batch selection for training we randomly pick\n    #   an image view (e.g. crop, flip) of the image and one of the captions\n    # flip, rotate, crop, resize : https://github.com/reedscot/icml2016/blob/master/data/donkey_folder_coco.lua\n    # flip : https://github.com/paarthneekhara/text-to-image/blob/master/Utils/image_processing.py\n        x = flip_axis(x, axis=1, is_random=True)\n        x = rotation(x, rg=16, is_random=True, fill_mode=\'nearest\')\n            # x = crop(x, wrg=50, hrg=50, is_random=True)\n            # x = imresize(x, size=[64, 64], interp=\'bilinear\', mode=None)\n        x = imresize(x, size=[64+15, 64+15], interp=\'bilinear\', mode=None)\n        x = crop(x, wrg=64, hrg=64, is_random=True)\n        x = x / (255. / 2.)\n        x = x - 1.\n        # x = x * 0.9999\n    elif mode==\'train_stackGAN\':\n        x = flip_axis(x, axis=1, is_random=True)\n        x = rotation(x, rg=16, is_random=True, fill_mode=\'nearest\')\n            # x = crop(x, wrg=50, hrg=50, is_random=True)\n            # x = imresize(x, size=[64, 64], interp=\'bilinear\', mode=None)\n        x = imresize(x, size=[316, 316], interp=\'bilinear\', mode=None)\n        x = crop(x, wrg=256, hrg=256, is_random=True)\n        x = x / (255. / 2.)\n        x = x - 1.\n        # x = x * 0.9999\n    elif mode==\'rescale\':\n    # rescale (-1, 1) --> (0, 1) for display\n        x = (x + 1.) / 2.\n    elif mode==\'debug\':\n        x = flip_axis(x, axis=1, is_random=False)\n        # x = rotation(x, rg=16, is_random=False, fill_mode=\'nearest\')\n        # x = crop(x, wrg=50, hrg=50, is_random=True)\n        # x = imresize(x, size=[64, 64], interp=\'bilinear\', mode=None)\n        x = x / 255.\n    elif mode==\'translation\':\n        x = x / (255. / 2.)\n        x = x - 1.\n        # from skimage.filters import gaussian\n        # print(x.shape, np.min(x), np.max(x))\n        # x = x * 0.9999\n        # x = gaussian(x, sigma=0.6, multichannel=True)\n    else:\n        raise Exception(""Not support : %s"" % mode)\n    return x\n\n\n\n\ndef combine_and_save_image_sets(image_sets, directory):\n    for i in range(len(image_sets[0])):\n        combined_image = []\n        for set_no in range(len(image_sets)):\n            combined_image.append( image_sets[set_no][i] )\n            combined_image.append( np.zeros((image_sets[set_no][i].shape[0], 5, 3)) )\n        combined_image = np.concatenate( combined_image, axis = 1 )\n\n        scipy.misc.imsave( os.path.join( directory,  \'combined_{}.jpg\'.format(i) ), combined_image)\n\n\n\n\n\n\n\n\n\n\n#\n'"
tensorlayer/__init__.py,0,"b'""""""\nDeep learning and Reinforcement learning library for Researchers and Engineers\n""""""\n# from __future__ import absolute_import\n\n\ntry:\n    install_instr = ""Please make sure you install a recent enough version of TensorFlow.""\n    import tensorflow\nexcept ImportError:\n    raise ImportError(""__init__.py : Could not import TensorFlow."" + install_instr)\n\nfrom . import activation\nact = activation\nfrom . import cost\nfrom . import files\n# from . import init\nfrom . import iterate\nfrom . import layers\nfrom . import ops\nfrom . import utils\nfrom . import visualize\nfrom . import prepro        # was preprocesse\nfrom . import nlp\nfrom . import rein\n\n\n__version__ = ""1.4.3""\n\nglobal_flag = {}\nglobal_dict = {}\n'"
tensorlayer/activation.py,12,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\nimport tensorflow as tf\n\ndef identity(x, name=None):\n    """"""The identity activation function, Shortcut is ``linear``.\n\n    Parameters\n    ----------\n    x : a tensor input\n        input(s)\n\n\n    Returns\n    --------\n    A `Tensor` with the same type as `x`.\n    """"""\n    return x\n\n# Shortcut\nlinear = identity\n\ndef ramp(x=None, v_min=0, v_max=1, name=None):\n    """"""The ramp activation function.\n\n    Parameters\n    ----------\n    x : a tensor input\n        input(s)\n    v_min : float\n        if input(s) smaller than v_min, change inputs to v_min\n    v_max : float\n        if input(s) greater than v_max, change inputs to v_max\n    name : a string or None\n        An optional name to attach to this activation function.\n\n\n    Returns\n    --------\n    A `Tensor` with the same type as `x`.\n    """"""\n    return tf.clip_by_value(x, clip_value_min=v_min, clip_value_max=v_max, name=name)\n\ndef leaky_relu(x=None, alpha=0.1, name=""LeakyReLU""):\n    """"""The LeakyReLU, Shortcut is ``lrelu``.\n\n    Modified version of ReLU, introducing a nonzero gradient for negative\n    input.\n\n    Parameters\n    ----------\n    x : A `Tensor` with type `float`, `double`, `int32`, `int64`, `uint8`,\n        `int16`, or `int8`.\n    alpha : `float`. slope.\n    name : a string or None\n        An optional name to attach to this activation function.\n\n    Examples\n    ---------\n    >>> network = tl.layers.DenseLayer(network, n_units=100, name = \'dense_lrelu\',\n    ...                 act= lambda x : tl.act.lrelu(x, 0.2))\n\n    References\n    ------------\n    - `Rectifier Nonlinearities Improve Neural Network Acoustic Models, Maas et al. (2013) <http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf>`_\n    """"""\n    with tf.name_scope(name) as scope:\n        # x = tf.nn.relu(x)\n        # m_x = tf.nn.relu(-x)\n        # x -= alpha * m_x\n        x = tf.maximum(x, alpha * x)\n    return x\n\n#Shortcut\nlrelu = leaky_relu\n\ndef pixel_wise_softmax(output, name=\'pixel_wise_softmax\'):\n    """"""Return the softmax outputs of images, every pixels have multiple label, the sum of a pixel is 1.\n    Usually be used for image segmentation.\n\n    Parameters\n    ------------\n    output : tensor\n        - For 2d image, 4D tensor [batch_size, height, weight, channel], channel >= 2.\n        - For 3d image, 5D tensor [batch_size, depth, height, weight, channel], channel >= 2.\n\n    Examples\n    ---------\n    >>> outputs = pixel_wise_softmax(network.outputs)\n    >>> dice_loss = 1 - dice_coe(outputs, y_, epsilon=1e-5)\n\n    References\n    -----------\n    - `tf.reverse <https://www.tensorflow.org/versions/master/api_docs/python/array_ops.html#reverse>`_\n    """"""\n    with tf.name_scope(name) as scope:\n        return tf.nn.softmax(output)\n        ## old implementation\n        # exp_map = tf.exp(output)\n        # if output.get_shape().ndims == 4:   # 2d image\n        #     evidence = tf.add(exp_map, tf.reverse(exp_map, [False, False, False, True]))\n        # elif output.get_shape().ndims == 5: # 3d image\n        #     evidence = tf.add(exp_map, tf.reverse(exp_map, [False, False, False, False, True]))\n        # else:\n        #     raise Exception(""output parameters should be 2d or 3d image, not %s"" % str(output._shape))\n        # return tf.div(exp_map, evidence)\n'"
tensorlayer/cost.py,64,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\nimport tensorflow as tf\nimport numbers\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import standard_ops\n\n## Cost Functions\n\ndef cross_entropy(output, target, name=None):\n    """"""It is a softmax cross-entropy operation, returns the TensorFlow expression of cross-entropy of two distributions, implement\n    softmax internally. See ``tf.nn.sparse_softmax_cross_entropy_with_logits``.\n\n    Parameters\n    ----------\n    output : Tensorflow variable\n        A distribution with shape: [batch_size, n_feature].\n    target : Tensorflow variable\n        A batch of index with shape: [batch_size, ].\n    name : string\n        Name of this loss.\n\n    Examples\n    --------\n    >>> ce = tl.cost.cross_entropy(y_logits, y_target_logits, \'my_loss\')\n\n    References\n    -----------\n    - About cross-entropy: `wiki <https://en.wikipedia.org/wiki/Cross_entropy>`_.\\n\n    - The code is borrowed from: `here <https://en.wikipedia.org/wiki/Cross_entropy>`_.\n    """"""\n    try: # old\n        return tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=output, targets=target))\n    except: # TF 1.0\n        assert name is not None, ""Please give a unique name to tl.cost.cross_entropy for TF1.0+""\n        return tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target, logits=output, name=name))\n\ndef sigmoid_cross_entropy(output, target, name=None):\n    """"""It is a sigmoid cross-entropy operation, see ``tf.nn.sigmoid_cross_entropy_with_logits``.\n    """"""\n    try: # TF 1.0\n        return tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(labels=target, logits=output, name=name))\n    except:\n        return tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=output, targets=target))\n\n\ndef binary_cross_entropy(output, target, epsilon=1e-8, name=\'bce_loss\'):\n    """"""Computes binary cross entropy given `output`.\n\n    For brevity, let `x = output`, `z = target`.  The binary cross entropy loss is\n\n        loss(x, z) = - sum_i (x[i] * log(z[i]) + (1 - x[i]) * log(1 - z[i]))\n\n    Parameters\n    ----------\n    output : tensor of type `float32` or `float64`.\n    target : tensor of the same type and shape as `output`.\n    epsilon : float\n        A small value to avoid output is zero.\n    name : string\n        An optional name to attach to this layer.\n\n    References\n    -----------\n    - `DRAW <https://github.com/ericjang/draw/blob/master/draw.py#L73>`_\n    """"""\n#     from tensorflow.python.framework import ops\n#     with ops.op_scope([output, target], name, ""bce_loss"") as name:\n#         output = ops.convert_to_tensor(output, name=""preds"")\n#         target = ops.convert_to_tensor(targets, name=""target"")\n    with tf.name_scope(name):\n        return tf.reduce_mean(-(target * tf.log(output + epsilon) +\n                              (1. - target) * tf.log(1. - output + epsilon)))\n\n\ndef mean_squared_error(output, target, is_mean=False):\n    """"""Return the TensorFlow expression of mean-squre-error of two distributions.\n\n    Parameters\n    ----------\n    output : 2D or 4D tensor.\n    target : 2D or 4D tensor.\n    is_mean : boolean, if True, use ``tf.reduce_mean`` to compute the loss of one data, otherwise, use ``tf.reduce_sum`` (default).\n\n    References\n    ------------\n    - `Wiki Mean Squared Error <https://en.wikipedia.org/wiki/Mean_squared_error>`_\n    """"""\n    with tf.name_scope(""mean_squared_error_loss""):\n        if output.get_shape().ndims == 2:   # [batch_size, n_feature]\n            if is_mean:\n                mse = tf.reduce_mean(tf.reduce_mean(tf.squared_difference(output, target), 1))\n            else:\n                mse = tf.reduce_mean(tf.reduce_sum(tf.squared_difference(output, target), 1))\n        elif output.get_shape().ndims == 4: # [batch_size, w, h, c]\n            if is_mean:\n                mse = tf.reduce_mean(tf.reduce_mean(tf.squared_difference(output, target), [1, 2, 3]))\n            else:\n                mse = tf.reduce_mean(tf.reduce_sum(tf.squared_difference(output, target), [1, 2, 3]))\n        return mse\n\n\n\ndef dice_coe(output, target, epsilon=1e-10):\n    """"""S\xc3\xb8rensen\xe2\x80\x93Dice coefficient for comparing the similarity of two distributions,\n    usually be used for binary image segmentation i.e. labels are binary.\n    The coefficient = [0, 1], 1 if totally match.\n\n    Parameters\n    -----------\n    output : tensor\n        A distribution with shape: [batch_size, ....], (any dimensions).\n    target : tensor\n        A distribution with shape: [batch_size, ....], (any dimensions).\n    epsilon : float\n        An optional name to attach to this layer.\n\n    Examples\n    ---------\n    >>> outputs = tl.act.pixel_wise_softmax(network.outputs)\n    >>> dice_loss = 1 - tl.cost.dice_coe(outputs, y_, epsilon=1e-5)\n\n    References\n    -----------\n    - `wiki-dice <https://en.wikipedia.org/wiki/S\xc3\xb8rensen\xe2\x80\x93Dice_coefficient>`_\n    """"""\n    # inse = tf.reduce_sum( tf.mul(output, target) )\n    # l = tf.reduce_sum( tf.mul(output, output) )\n    # r = tf.reduce_sum( tf.mul(target, target) )\n    inse = tf.reduce_sum( output * target )\n    l = tf.reduce_sum( output * output )\n    r = tf.reduce_sum( target * target )\n    dice = 2 * (inse) / (l + r)\n    if epsilon == 0:\n        return dice\n    else:\n        return tf.clip_by_value(dice, 0, 1.0-epsilon)\n\n\ndef dice_hard_coe(output, target, epsilon=1e-10):\n    """"""Non-differentiable S\xc3\xb8rensen\xe2\x80\x93Dice coefficient for comparing the similarity of two distributions,\n    usually be used for binary image segmentation i.e. labels are binary.\n    The coefficient = [0, 1], 1 if totally match.\n\n    Parameters\n    -----------\n    output : tensor\n        A distribution with shape: [batch_size, ....], (any dimensions).\n    target : tensor\n        A distribution with shape: [batch_size, ....], (any dimensions).\n    epsilon : float\n        An optional name to attach to this layer.\n\n    Examples\n    ---------\n    >>> outputs = pixel_wise_softmax(network.outputs)\n    >>> dice_loss = 1 - dice_coe(outputs, y_, epsilon=1e-5)\n\n    References\n    -----------\n    - `wiki-dice <https://en.wikipedia.org/wiki/S\xc3\xb8rensen\xe2\x80\x93Dice_coefficient>`_\n    """"""\n    output = tf.cast(output > 0.5, dtype=tf.float32)\n    target = tf.cast(target > 0.5, dtype=tf.float32)\n    inse = tf.reduce_sum( output * target )\n    l = tf.reduce_sum( output * output )\n    r = tf.reduce_sum( target * target )\n    dice = 2 * (inse) / (l + r)\n    if epsilon == 0:\n        return dice\n    else:\n        return tf.clip_by_value(dice, 0, 1.0-epsilon)\n\ndef iou_coe(output, target, threshold=0.5, epsilon=1e-10):\n    """"""Non-differentiable Intersection over Union, usually be used for evaluating binary image segmentation.\n    The coefficient = [0, 1], 1 means totally match.\n\n    Parameters\n    -----------\n    output : tensor\n        A distribution with shape: [batch_size, ....], (any dimensions).\n    target : tensor\n        A distribution with shape: [batch_size, ....], (any dimensions).\n    threshold : float\n        The threshold value to be true.\n    epsilon : float\n        A small value to avoid zero denominator when both output and target output nothing.\n\n    Examples\n    ---------\n    >>> outputs = tl.act.pixel_wise_softmax(network.outputs)\n    >>> iou = tl.cost.iou_coe(outputs[:,:,:,0], y_[:,:,:,0])\n\n    Notes\n    ------\n    - IOU cannot be used as training loss, people usually use dice coefficient for training, and IOU for evaluating.\n    """"""\n    pre = tf.cast(output > threshold, dtype=tf.float32)\n    truth = tf.cast(target > threshold, dtype=tf.float32)\n    intersection = tf.reduce_sum(pre * truth)\n    union = tf.reduce_sum(tf.cast((pre + truth) > threshold, dtype=tf.float32))\n    return tf.reduce_sum(intersection) / (tf.reduce_sum(union) + epsilon)\n\n\ndef cross_entropy_seq(logits, target_seqs, batch_size=None):#, batch_size=1, num_steps=None):\n    """"""Returns the expression of cross-entropy of two sequences, implement\n    softmax internally. Normally be used for Fixed Length RNN outputs.\n\n    Parameters\n    ----------\n    logits : Tensorflow variable\n        2D tensor, ``network.outputs``, [batch_size*n_steps (n_examples), number of output units]\n    target_seqs : Tensorflow variable\n        target : 2D tensor [batch_size, n_steps], if the number of step is dynamic, please use ``cross_entropy_seq_with_mask`` instead.\n    batch_size : None or int.\n        If not None, the return cost will be divided by batch_size.\n\n    Examples\n    --------\n    >>> see PTB tutorial for more details\n    >>> input_data = tf.placeholder(tf.int32, [batch_size, num_steps])\n    >>> targets = tf.placeholder(tf.int32, [batch_size, num_steps])\n    >>> cost = tf.cost.cross_entropy_seq(network.outputs, targets)\n    """"""\n    try: # TF 1.0\n        sequence_loss_by_example_fn = tf.contrib.legacy_seq2seq.sequence_loss_by_example\n    except:\n        sequence_loss_by_example_fn = tf.nn.seq2seq.sequence_loss_by_example\n\n    loss = sequence_loss_by_example_fn(\n        [logits],\n        [tf.reshape(target_seqs, [-1])],\n        [tf.ones_like(tf.reshape(target_seqs, [-1]), dtype=tf.float32)])\n        # [tf.ones([batch_size * num_steps])])\n    cost = tf.reduce_sum(loss) #/ batch_size\n    if batch_size is not None:\n        cost = cost / batch_size\n    return cost\n\n\ndef cross_entropy_seq_with_mask(logits, target_seqs, input_mask, return_details=False, name=None):\n    """"""Returns the expression of cross-entropy of two sequences, implement\n    softmax internally. Normally be used for Dynamic RNN outputs.\n\n    Parameters\n    -----------\n    logits : network identity outputs\n        2D tensor, ``network.outputs``, [batch_size, number of output units].\n    target_seqs : int of tensor, like word ID.\n        [batch_size, ?]\n    input_mask : the mask to compute loss\n        The same size with target_seqs, normally 0 and 1.\n    return_details : boolean\n        - If False (default), only returns the loss.\n        - If True, returns the loss, losses, weights and targets (reshape to one vetcor).\n\n    Examples\n    --------\n    - see Image Captioning Example.\n    """"""\n    targets = tf.reshape(target_seqs, [-1])   # to one vector\n    weights = tf.to_float(tf.reshape(input_mask, [-1]))   # to one vector like targets\n    losses = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=targets, name=name) * weights\n    #losses = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=targets, name=name)) # for TF1.0 and others\n\n    try: ## TF1.0\n        loss = tf.divide(tf.reduce_sum(losses),   # loss from mask. reduce_sum before element-wise mul with mask !!\n                        tf.reduce_sum(weights),\n                        name=""seq_loss_with_mask"")\n    except: ## TF0.12\n        loss = tf.div(tf.reduce_sum(losses),   # loss from mask. reduce_sum before element-wise mul with mask !!\n                        tf.reduce_sum(weights),\n                        name=""seq_loss_with_mask"")\n    if return_details:\n        return loss, losses, weights, targets\n    else:\n        return loss\n\n\ndef cosine_similarity(v1, v2):\n    """"""Cosine similarity [-1, 1], `wiki <https://en.wikipedia.org/wiki/Cosine_similarity>`_.\n\n    Parameters\n    -----------\n    v1, v2 : tensor of [batch_size, n_feature], with the same number of features.\n\n    Returns\n    -----------\n    a tensor of [batch_size, ]\n    """"""\n    try: ## TF1.0\n        cost = tf.reduce_sum(tf.multiply(v1, v2), 1) / (tf.sqrt(tf.reduce_sum(tf.multiply(v1, v1), 1)) * tf.sqrt(tf.reduce_sum(tf.multiply(v2, v2), 1)))\n    except: ## TF0.12\n        cost = tf.reduce_sum(tf.mul(v1, v2), reduction_indices=1) / (tf.sqrt(tf.reduce_sum(tf.mul(v1, v1), reduction_indices=1)) * tf.sqrt(tf.reduce_sum(tf.mul(v2, v2), reduction_indices=1)))\n    return cost\n\n\n## Regularization Functions\ndef li_regularizer(scale, scope=None):\n  """"""li regularization removes the neurons of previous layer, `i` represents `inputs`.\\n\n  Returns a function that can be used to apply group li regularization to weights.\\n\n  The implementation follows `TensorFlow contrib <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/layers/python/layers/regularizers.py>`_.\n\n  Parameters\n  ----------\n  scale : float\n    A scalar multiplier `Tensor`. 0.0 disables the regularizer.\n  scope: An optional scope name for TF12+.\n\n  Returns\n  --------\n  A function with signature `li(weights, name=None)` that apply Li regularization.\n\n  Raises\n  ------\n  ValueError : if scale is outside of the range [0.0, 1.0] or if scale is not a float.\n  """"""\n  import numbers\n  from tensorflow.python.framework import ops\n  from tensorflow.python.ops import standard_ops\n  # from tensorflow.python.platform import tf_logging as logging\n\n  if isinstance(scale, numbers.Integral):\n    raise ValueError(\'scale cannot be an integer: %s\' % scale)\n  if isinstance(scale, numbers.Real):\n    if scale < 0.:\n      raise ValueError(\'Setting a scale less than 0 on a regularizer: %g\' %\n                       scale)\n    if scale >= 1.:\n      raise ValueError(\'Setting a scale greater than 1 on a regularizer: %g\' %\n                       scale)\n    if scale == 0.:\n      logging.info(\'Scale of 0 disables regularizer.\')\n      return lambda _, name=None: None\n\n  def li(weights, name=None):\n    """"""Applies li regularization to weights.""""""\n    with tf.name_scope(\'li_regularizer\') as scope:\n        my_scale = ops.convert_to_tensor(scale,\n                                           dtype=weights.dtype.base_dtype,\n                                           name=\'scale\')\n        if tf.__version__ <= \'0.12\':\n            standard_ops_fn = standard_ops.mul\n        else:\n            standard_ops_fn = standard_ops.multiply\n            return standard_ops_fn(\n              my_scale,\n              standard_ops.reduce_sum(standard_ops.sqrt(standard_ops.reduce_sum(tf.square(weights), 1))),\n              name=scope)\n  return li\n\n\n\ndef lo_regularizer(scale, scope=None):\n  """"""lo regularization removes the neurons of current layer, `o` represents `outputs`\\n\n  Returns a function that can be used to apply group lo regularization to weights.\\n\n  The implementation follows `TensorFlow contrib <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/layers/python/layers/regularizers.py>`_.\n\n  Parameters\n  ----------\n  scale : float\n    A scalar multiplier `Tensor`. 0.0 disables the regularizer.\n  scope: An optional scope name for TF12+.\n\n  Returns\n  -------\n  A function with signature `lo(weights, name=None)` that apply Lo regularization.\n\n  Raises\n  ------\n  ValueError : If scale is outside of the range [0.0, 1.0] or if scale is not a float.\n  """"""\n  import numbers\n  from tensorflow.python.framework import ops\n  from tensorflow.python.ops import standard_ops\n  # from tensorflow.python.platform import tf_logging as logging\n\n  if isinstance(scale, numbers.Integral):\n    raise ValueError(\'scale cannot be an integer: %s\' % scale)\n  if isinstance(scale, numbers.Real):\n    if scale < 0.:\n      raise ValueError(\'Setting a scale less than 0 on a regularizer: %g\' %\n                       scale)\n    if scale >= 1.:\n      raise ValueError(\'Setting a scale greater than 1 on a regularizer: %g\' %\n                       scale)\n    if scale == 0.:\n      logging.info(\'Scale of 0 disables regularizer.\')\n      return lambda _, name=None: None\n\n  def lo(weights, name=\'lo_regularizer\'):\n    """"""Applies group column regularization to weights.""""""\n    with tf.name_scope(name) as scope:\n        my_scale = ops.convert_to_tensor(scale,\n                                       dtype=weights.dtype.base_dtype,\n                                       name=\'scale\')\n        if tf.__version__ <= \'0.12\':\n            standard_ops_fn = standard_ops.mul\n        else:\n            standard_ops_fn = standard_ops.multiply\n        return standard_ops_fn(\n          my_scale,\n          standard_ops.reduce_sum(standard_ops.sqrt(standard_ops.reduce_sum(tf.square(weights), 0))),\n          name=scope)\n  return lo\n\ndef maxnorm_regularizer(scale=1.0, scope=None):\n  """"""Max-norm regularization returns a function that can be used\n  to apply max-norm regularization to weights.\n  About max-norm: `wiki <https://en.wikipedia.org/wiki/Matrix_norm#Max_norm>`_.\\n\n  The implementation follows `TensorFlow contrib <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/layers/python/layers/regularizers.py>`_.\n\n  Parameters\n  ----------\n  scale : float\n    A scalar multiplier `Tensor`. 0.0 disables the regularizer.\n  scope: An optional scope name.\n\n  Returns\n  ---------\n  A function with signature `mn(weights, name=None)` that apply Lo regularization.\n\n  Raises\n  --------\n  ValueError : If scale is outside of the range [0.0, 1.0] or if scale is not a float.\n  """"""\n  import numbers\n  from tensorflow.python.framework import ops\n  from tensorflow.python.ops import standard_ops\n\n  if isinstance(scale, numbers.Integral):\n    raise ValueError(\'scale cannot be an integer: %s\' % scale)\n  if isinstance(scale, numbers.Real):\n    if scale < 0.:\n      raise ValueError(\'Setting a scale less than 0 on a regularizer: %g\' %\n                       scale)\n    # if scale >= 1.:\n    #   raise ValueError(\'Setting a scale greater than 1 on a regularizer: %g\' %\n    #                    scale)\n    if scale == 0.:\n      logging.info(\'Scale of 0 disables regularizer.\')\n      return lambda _, name=None: None\n\n  def mn(weights, name=\'max_regularizer\'):\n    """"""Applies max-norm regularization to weights.""""""\n    with tf.name_scope(name) as scope:\n          my_scale = ops.convert_to_tensor(scale,\n                                           dtype=weights.dtype.base_dtype,\n                                           name=\'scale\')\n          if tf.__version__ <= \'0.12\':\n              standard_ops_fn = standard_ops.mul\n          else:\n              standard_ops_fn = standard_ops.multiply\n          return standard_ops_fn(my_scale, standard_ops.reduce_max(standard_ops.abs(weights)), name=scope)\n  return mn\n\ndef maxnorm_o_regularizer(scale, scope):\n  """"""Max-norm output regularization removes the neurons of current layer.\\n\n  Returns a function that can be used to apply max-norm regularization to each column of weight matrix.\\n\n  The implementation follows `TensorFlow contrib <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/layers/python/layers/regularizers.py>`_.\n\n  Parameters\n  ----------\n  scale : float\n    A scalar multiplier `Tensor`. 0.0 disables the regularizer.\n  scope: An optional scope name.\n\n  Returns\n  ---------\n  A function with signature `mn_o(weights, name=None)` that apply Lo regularization.\n\n  Raises\n  ---------\n  ValueError : If scale is outside of the range [0.0, 1.0] or if scale is not a float.\n  """"""\n  import numbers\n  from tensorflow.python.framework import ops\n  from tensorflow.python.ops import standard_ops\n\n  if isinstance(scale, numbers.Integral):\n    raise ValueError(\'scale cannot be an integer: %s\' % scale)\n  if isinstance(scale, numbers.Real):\n    if scale < 0.:\n      raise ValueError(\'Setting a scale less than 0 on a regularizer: %g\' %\n                       scale)\n    # if scale >= 1.:\n    #   raise ValueError(\'Setting a scale greater than 1 on a regularizer: %g\' %\n    #                    scale)\n    if scale == 0.:\n      logging.info(\'Scale of 0 disables regularizer.\')\n      return lambda _, name=None: None\n\n  def mn_o(weights, name=\'maxnorm_o_regularizer\'):\n     """"""Applies max-norm regularization to weights.""""""\n     with tf.name_scope(name) as scope:\n          my_scale = ops.convert_to_tensor(scale,\n                                           dtype=weights.dtype.base_dtype,\n                                                   name=\'scale\')\n          if tf.__version__ <= \'0.12\':\n             standard_ops_fn = standard_ops.mul\n          else:\n             standard_ops_fn = standard_ops.multiply\n          return standard_ops_fn(my_scale, standard_ops.reduce_sum(standard_ops.reduce_max(standard_ops.abs(weights), 0)), name=scope)\n  return mn_o\n\ndef maxnorm_i_regularizer(scale, scope=None):\n  """"""Max-norm input regularization removes the neurons of previous layer.\\n\n  Returns a function that can be used to apply max-norm regularization to each row of weight matrix.\\n\n  The implementation follows `TensorFlow contrib <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/layers/python/layers/regularizers.py>`_.\n\n  Parameters\n  ----------\n  scale : float\n    A scalar multiplier `Tensor`. 0.0 disables the regularizer.\n  scope: An optional scope name.\n\n  Returns\n  ---------\n  A function with signature `mn_i(weights, name=None)` that apply Lo regularization.\n\n  Raises\n  ---------\n  ValueError : If scale is outside of the range [0.0, 1.0] or if scale is not a float.\n  """"""\n  import numbers\n  from tensorflow.python.framework import ops\n  from tensorflow.python.ops import standard_ops\n\n  if isinstance(scale, numbers.Integral):\n    raise ValueError(\'scale cannot be an integer: %s\' % scale)\n  if isinstance(scale, numbers.Real):\n    if scale < 0.:\n      raise ValueError(\'Setting a scale less than 0 on a regularizer: %g\' %\n                       scale)\n    # if scale >= 1.:\n    #   raise ValueError(\'Setting a scale greater than 1 on a regularizer: %g\' %\n    #                    scale)\n    if scale == 0.:\n      logging.info(\'Scale of 0 disables regularizer.\')\n      return lambda _, name=None: None\n\n  def mn_i(weights, name=\'maxnorm_i_regularizer\'):\n     """"""Applies max-norm regularization to weights.""""""\n     with tf.name_scope(name) as scope:\n          my_scale = ops.convert_to_tensor(scale,\n                                           dtype=weights.dtype.base_dtype,\n                                                   name=\'scale\')\n          if tf.__version__ <= \'0.12\':\n             standard_ops_fn = standard_ops.mul\n          else:\n             standard_ops_fn = standard_ops.multiply\n          return standard_ops_fn(my_scale, standard_ops.reduce_sum(standard_ops.reduce_max(standard_ops.abs(weights), 1)), name=scope)\n  return mn_i\n\n\n\n\n\n#\n'"
tensorlayer/db.py,0,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\nimport tensorflow as tf\nimport tensorlayer as tl\nfrom . import iterate\nimport numpy as np\nimport time\nimport math\n\n\nimport pymongo\nimport gridfs\nimport pickle\nfrom pymongo import MongoClient\nfrom datetime import datetime\n\nclass TensorDB(object):\n    """"""TensorDB is a MongoDB based manager that help you to manage data, model and logging.\n\n    Parameters\n    -------------\n    ip : string, localhost or IP address.\n    port : int, port number.\n    db_name : string, database name.\n    user_name : string, set to None if it donnot need authentication.\n    password : string.\n\n    Properties\n    ------------\n    db : ``pymongo.MongoClient[db_name]``, xxxxxx\n    datafs : ``gridfs.GridFS(self.db, collection=""datafs"")``, xxxxxxxxxx\n    modelfs : ``gridfs.GridFS(self.db, collection=""modelfs"")``,\n    paramsfs : ``gridfs.GridFS(self.db, collection=""paramsfs"")``,\n    db.Params : Collection for\n    db.TrainLog : Collection for\n    db.ValidLog : Collection for\n    db.TestLog : Collection for\n\n    Dependencies\n    -------------\n    1 : MongoDB, as TensorDB is based on MongoDB, you need to install it in your\n       local machine or remote machine.\n    2 : pip install pymongo, for MongoDB python API.\n\n    Optional Tools\n    ----------------\n    1 : You may like to install MongoChef or Mongo Management Studo APP for\n       visualizing or testing your MongoDB.\n    """"""\n    def __init__(\n        self,\n        ip = \'localhost\',\n        port = 27017,\n        db_name = \'db_name\',\n        user_name = None,\n        password = \'password\',\n    ):\n        ## connect mongodb\n        client = MongoClient(ip, port)\n        self.db = client[db_name]\n        if user_name != None:\n            self.db.authenticate(user_name, password)\n        ## define file system (Buckets)\n        self.datafs = gridfs.GridFS(self.db, collection=""datafs"")\n        self.modelfs = gridfs.GridFS(self.db, collection=""modelfs"")\n        self.paramsfs = gridfs.GridFS(self.db, collection=""paramsfs"")\n        ##\n        print(""[TensorDB] Connect SUCCESS {}:{} {} {}"".format(ip, port, db_name, user_name))\n\n        self.ip = ip\n        self.port = port\n        self.db_name = db_name\n        self.user_name = user_name\n\n    # def save_bulk_data(self, data=None, filename=\'filename\'):\n    #     """""" Put bulk data into TensorDB.datafs, return file ID.\n    #     When you have a very large data, you may like to save it into GridFS Buckets\n    #     instead of Collections, then when you want to load it, XXXX\n    #\n    #     Parameters\n    #     -----------\n    #     data : serialized data.\n    #     filename : string, GridFS Buckets.\n    #\n    #     References\n    #     -----------\n    #     - MongoDB find, xxxxx\n    #     """"""\n    #     s = time.time()\n    #     f_id = self.datafs.put(data, filename=filename)\n    #     print(""[TensorDB] save_bulk_data: {} took: {}s"".format(filename, round(time.time()-s, 2)))\n    #     return f_id\n    #\n    # def save_collection(self, data=None, collect_name=\'collect_name\'):\n    #     """""" Insert data into MongoDB Collections, return xx.\n    #\n    #     Parameters\n    #     -----------\n    #     data : serialized data.\n    #     collect_name : string, MongoDB collection name.\n    #\n    #     References\n    #     -----------\n    #     - MongoDB find, xxxxx\n    #     """"""\n    #     s = time.time()\n    #     rl = self.db[collect_name].insert_many(data)\n    #     print(""[TensorDB] save_collection: {} took: {}s"".format(collect_name, round(time.time()-s, 2)))\n    #     return rl\n    #\n    # def find(self, args={}, collect_name=\'collect_name\'):\n    #     """""" Find data from MongoDB Collections.\n    #\n    #     Parameters\n    #     -----------\n    #     args : dictionary, arguments for finding.\n    #     collect_name : string, MongoDB collection name.\n    #\n    #     References\n    #     -----------\n    #     - MongoDB find, xxxxx\n    #     """"""\n    #     s = time.time()\n    #\n    #     pc = self.db[collect_name].find(args)  # pymongo.cursor.Cursor object\n    #     flist = pc.distinct(\'f_id\')\n    #     fldict = {}\n    #     for f in flist: # you may have multiple Buckets files\n    #         # fldict[f] = pickle.loads(self.datafs.get(f).read())\n    #         # s2 = time.time()\n    #         tmp = self.datafs.get(f).read()\n    #         # print(time.time()-s2)\n    #         fldict[f] = pickle.loads(tmp)\n    #         # print(time.time()-s2)\n    #         # exit()\n    #     # print(round(time.time()-s, 2))\n    #     data = [fldict[x[\'f_id\']][x[\'id\']] for x in pc]\n    #     data = np.asarray(data)\n    #     print(""[TensorDB] find: {} get: {} took: {}s"".format(collect_name, pc.count(), round(time.time()-s, 2)))\n    #     return data\n\n    # def del_data(self, data, args={}):\n    #     pass\n    #\n    # def save_model(self):\n    #     pass\n    #\n    # def load_model(self):\n    #     pass\n    #\n    # def del_model(self):\n    #     pass\n\n    def save_params(self, params=[], args={}):#, file_name=\'parameters\'):\n        """""" Save parameters into MongoDB Buckets, and save the file ID into Params Collections.\n\n        Parameters\n        ----------\n        params : a list of parameters\n        args : dictionary, item meta data.\n\n        Returns\n        ---------\n        f_id : the Buckets ID of the parameters.\n        """"""\n        s = time.time()\n        f_id = self.paramsfs.put(pickle.dumps(params, protocol=2))#, file_name=file_name)\n        args.update({\'f_id\': f_id, \'time\': datetime.utcnow()})\n        self.db.Params.insert_one(args)\n        # print(""[TensorDB] Save params: {} SUCCESS, took: {}s"".format(file_name, round(time.time()-s, 2)))\n        print(""[TensorDB] Save params: SUCCESS, took: {}s"".format(round(time.time()-s, 2)))\n        return f_id\n\n    def find_one_params(self, args={}):\n        """""" Find one parameter from MongoDB Buckets.\n\n        Parameters\n        ----------\n        args : dictionary, find items.\n\n        Returns\n        --------\n        params : the parameters, return False if nothing found.\n        f_id : the Buckets ID of the parameters, return False if nothing found.\n        """"""\n        s = time.time()\n        d = self.db.Params.find_one(args)\n\n        if d is not None:\n            f_id = d[\'f_id\']\n        else:\n            print(""[TensorDB] FAIL! Cannot find: {}"".format(args))\n            return False, False\n        try:\n            params = pickle.loads(self.paramsfs.get(f_id).read())\n            print(""[TensorDB] Find one params SUCCESS, {} took: {}s"".format(args, round(time.time()-s, 2)))\n            return params, f_id\n        except:\n            return False, False\n\n    def find_all_params(self, args={}):\n        """""" Find all parameter from MongoDB Buckets\n\n        Parameters\n        ----------\n        args : dictionary, find items\n\n        Returns\n        --------\n        params : the parameters, return False if nothing found.\n        """"""\n        s = time.time()\n        pc = self.db.Params.find(args)\n\n        if pc is not None:\n            f_id_list = pc.distinct(\'f_id\')\n            params = []\n            for f_id in f_id_list: # you may have multiple Buckets files\n                tmp = self.paramsfs.get(f_id).read()\n                params.append(pickle.loads(tmp))\n        else:\n            print(""[TensorDB] FAIL! Cannot find any: {}"".format(args))\n            return False\n\n        print(""[TensorDB] Find all params SUCCESS, took: {}s"".format(round(time.time()-s, 2)))\n        return params\n\n    def del_params(self, args={}):\n        """""" Delete params in MongoDB uckets.\n\n        Parameters\n        -----------\n        args : dictionary, find items to delete, leave it empty to delete all parameters.\n        """"""\n        pc = self.db.Params.find(args)\n        f_id_list = pc.distinct(\'f_id\')\n        # remove from Buckets\n        for f in f_id_list:\n            self.paramsfs.delete(f)\n        # remove from Collections\n        self.db.Params.remove(args)\n\n        print(""[TensorDB] Delete params SUCCESS: {}"".format(args))\n\n    def _print_dict(self, args):\n        # return "" / "".join(str(key) + "": ""+ str(value) for key, value in args.items())\n        string = \'\'\n        for key, value in args.items():\n            if key is not \'_id\':\n                string += str(key) + "": ""+ str(value) + "" / ""\n        return string\n\n    def save_job(self, script=None, args={}):\n        """"""Save the job.\n\n        Parameters\n        -----------\n        script : a script file name or None.\n        args : dictionary, items to save.\n\n        Examples\n        ---------\n        >>> # Save your job\n        >>> db.save_job(\'your_script.py\', {\'job_id\': 1, \'learning_rate\': 0.01, \'n_units\': 100})\n        >>> # Run your job\n        >>> temp = db.find_one_job(args={\'job_id\': 1})\n        >>> print(temp[\'learning_rate\'])\n        ... 0.01\n        >>> import _your_script\n        ... running your script\n        """"""\n        if script is None:\n            _script = open(script, \'rb\').read()\n            args.update({\'script\': _script, \'script_name\': script})\n        _result = self.db.Job.insert_one(args)\n        _log = self._print_dict(args)\n        print(""[TensorDB] Save Job: {}"".format(script))\n        return _result\n\n    def find_one_job(self, args={}):\n        """""" Find one job from MongoDB Job Collections.\n\n        Parameters\n        ----------\n        args : dictionary, find items.\n\n        Returns\n        --------\n        dictionary : contains all meta data and script.\n        """"""\n        temp = self.db.Job.find_one(args)\n\n        if \'script_name\' in temp.keys():\n            f = open(\'_\' + temp[\'script_name\'], \'wb\')\n            f.write(temp[\'script\'])\n            f.close()\n        print(""[TensorDB] Find Job: {}"".format(args))\n        return temp\n\n    def train_log(self, args={}):\n        """"""Save the training log.\n\n        Parameters\n        -----------\n        args : dictionary, items to save.\n\n        Examples\n        ---------\n        >>> db.train_log(time=time.time(), {\'loss\': loss, \'acc\': acc})\n        """"""\n        _result = self.db.TrainLog.insert_one(args)\n        _log = self._print_dict(args)\n        print(""[TensorDB] TrainLog: "" +_log)\n        return _result\n\n    def del_train_log(self, args={}):\n        """""" Delete train log.\n\n        Parameters\n        -----------\n        args : dictionary, find items to delete, leave it empty to delete all log.\n        """"""\n        self.db.TrainLog.delete_many(args)\n        print(""[TensorDB] Delete TrainLog SUCCESS"")\n\n    def valid_log(self, args={}):\n        """"""Save the validating log.\n\n        Parameters\n        -----------\n        args : dictionary, items to save.\n\n        Examples\n        ---------\n        >>> db.valid_log(time=time.time(), {\'loss\': loss, \'acc\': acc})\n        """"""\n        _result = self.db.ValidLog.insert_one(args)\n        # _log = """".join(str(key) + "": "" + str(value) for key, value in args.items())\n        _log = self._print_dict(args)\n        print(""[TensorDB] ValidLog: "" +_log)\n        return _result\n\n    def del_valid_log(self, args={}):\n        """""" Delete validation log.\n\n        Parameters\n        -----------\n        args : dictionary, find items to delete, leave it empty to delete all log.\n        """"""\n        self.db.ValidLog.delete_many(args)\n        print(""[TensorDB] Delete ValidLog SUCCESS"")\n\n    def test_log(self, args={}):\n        """"""Save the testing log.\n\n        Parameters\n        -----------\n        args : dictionary, items to save.\n\n        Examples\n        ---------\n        >>> db.test_log(time=time.time(), {\'loss\': loss, \'acc\': acc})\n        """"""\n        _result = self.db.TestLog.insert_one(args)\n        # _log = """".join(str(key) + str(value) for key, value in args.items())\n        _log = self._print_dict(args)\n        print(""[TensorDB] TestLog: "" +_log)\n        return _result\n\n    def del_test_log(self, args={}):\n        """""" Delete test log.\n\n        Parameters\n        -----------\n        args : dictionary, find items to delete, leave it empty to delete all log.\n        """"""\n        self.db.TestLog.delete_many(args)\n        print(""[TensorDB] Delete TestLog SUCCESS"")\n\n    def __str__(self):\n        _s = ""[TensorDB] Info:\\n""\n        _t = _s + ""    "" + str(self.db)\n        return _t\n\n\n\n\n\nif __name__ == \'__main__\':\n\n    db = TensorDB(ip=\'localhost\', port=27017, db_name=\'mnist\', user_name=None, password=None)\n\n    db.save_job(\'your_script.py\', {\'job_id\': 1, \'learning_rate\': 0.01, \'n_units\': 100})\n    temp = db.find_one_job(args={\'job_id\': 1})\n\n    print(temp[\'learning_rate\'])\n\n    import _your_script\n    print(""import _your_script SUCCESS"")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n'"
tensorlayer/files.py,1,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\nimport tensorflow as tf\nimport os\nimport numpy as np\nimport re\nimport sys\nimport tarfile\nimport gzip\nimport zipfile\nfrom . import visualize\nfrom . import nlp\nimport pickle\nfrom six.moves import urllib\nfrom six.moves import cPickle\nfrom six.moves import zip\nfrom tensorflow.python.platform import gfile\n\n\n## Load dataset functions\ndef load_mnist_dataset(shape=(-1,784), path=""data/mnist/""):\n    """"""Automatically download MNIST dataset\n    and return the training, validation and test set with 50000, 10000 and 10000\n    digit images respectively.\n\n    Parameters\n    ----------\n    shape : tuple\n        The shape of digit images, defaults to (-1,784)\n    path : string\n        Path to download data to, defaults to data/mnist/\n\n    Examples\n    --------\n    >>> X_train, y_train, X_val, y_val, X_test, y_test = tl.files.load_mnist_dataset(shape=(-1,784))\n    >>> X_train, y_train, X_val, y_val, X_test, y_test = tl.files.load_mnist_dataset(shape=(-1, 28, 28, 1))\n    """"""\n    # We first define functions for loading MNIST images and labels.\n    # For convenience, they also download the requested files if needed.\n    def load_mnist_images(path, filename):\n        filepath = maybe_download_and_extract(filename, path, \'http://yann.lecun.com/exdb/mnist/\')\n\n        print(filepath)\n        # Read the inputs in Yann LeCun\'s binary format.\n        with gzip.open(filepath, \'rb\') as f:\n            data = np.frombuffer(f.read(), np.uint8, offset=16)\n        # The inputs are vectors now, we reshape them to monochrome 2D images,\n        # following the shape convention: (examples, channels, rows, columns)\n        data = data.reshape(shape)\n        # The inputs come as bytes, we convert them to float32 in range [0,1].\n        # (Actually to range [0, 255/256], for compatibility to the version\n        # provided at http://deeplearning.net/data/mnist/mnist.pkl.gz.)\n        return data / np.float32(256)\n\n    def load_mnist_labels(path, filename):\n        filepath = maybe_download_and_extract(filename, path, \'http://yann.lecun.com/exdb/mnist/\')\n        # Read the labels in Yann LeCun\'s binary format.\n        with gzip.open(filepath, \'rb\') as f:\n            data = np.frombuffer(f.read(), np.uint8, offset=8)\n        # The labels are vectors of integers now, that\'s exactly what we want.\n        return data\n\n    # Download and read the training and test set images and labels.\n    print(""Load or Download MNIST > {}"".format(path))\n    X_train = load_mnist_images(path, \'train-images-idx3-ubyte.gz\')\n    y_train = load_mnist_labels(path, \'train-labels-idx1-ubyte.gz\')\n    X_test = load_mnist_images(path, \'t10k-images-idx3-ubyte.gz\')\n    y_test = load_mnist_labels(path, \'t10k-labels-idx1-ubyte.gz\')\n\n    # We reserve the last 10000 training examples for validation.\n    X_train, X_val = X_train[:-10000], X_train[-10000:]\n    y_train, y_val = y_train[:-10000], y_train[-10000:]\n\n    # We just return all the arrays in order, as expected in main().\n    # (It doesn\'t matter how we do this as long as we can read them again.)\n    X_train = np.asarray(X_train, dtype=np.float32)\n    y_train = np.asarray(y_train, dtype=np.int32)\n    X_val = np.asarray(X_val, dtype=np.float32)\n    y_val = np.asarray(y_val, dtype=np.int32)\n    X_test = np.asarray(X_test, dtype=np.float32)\n    y_test = np.asarray(y_test, dtype=np.int32)\n    return X_train, y_train, X_val, y_val, X_test, y_test\n\n\ndef load_cifar10_dataset(shape=(-1, 32, 32, 3), path=\'data/cifar10/\', plotable=False, second=3):\n    """"""The CIFAR-10 dataset consists of 60000 32x32 colour images in 10 classes, with\n    6000 images per class. There are 50000 training images and 10000 test images.\n\n    The dataset is divided into five training batches and one test batch, each with\n    10000 images. The test batch contains exactly 1000 randomly-selected images from\n    each class. The training batches contain the remaining images in random order,\n    but some training batches may contain more images from one class than another.\n    Between them, the training batches contain exactly 5000 images from each class.\n\n    Parameters\n    ----------\n    shape : tupe\n        The shape of digit images: e.g. (-1, 3, 32, 32) , (-1, 32, 32, 3) , (-1, 32*32*3)\n    plotable : True, False\n        Whether to plot some image examples.\n    second : int\n        If ``plotable`` is True, ``second`` is the display time.\n    path : string\n        Path to download data to, defaults to data/cifar10/\n\n    Examples\n    --------\n    >>> X_train, y_train, X_test, y_test = tl.files.load_cifar10_dataset(shape=(-1, 32, 32, 3), plotable=True)\n\n    Notes\n    ------\n    CIFAR-10 images can only be display without color change under uint8.\n    >>> X_train = np.asarray(X_train, dtype=np.uint8)\n    >>> plt.ion()\n    >>> fig = plt.figure(1232)\n    >>> count = 1\n    >>> for row in range(10):\n    >>>     for col in range(10):\n    >>>         a = fig.add_subplot(10, 10, count)\n    >>>         plt.imshow(X_train[count-1], interpolation=\'nearest\')\n    >>>         plt.gca().xaxis.set_major_locator(plt.NullLocator())    # \xe4\xb8\x8d\xe6\x98\xbe\xe7\xa4\xba\xe5\x88\xbb\xe5\xba\xa6(tick)\n    >>>         plt.gca().yaxis.set_major_locator(plt.NullLocator())\n    >>>         count = count + 1\n    >>> plt.draw()\n    >>> plt.pause(3)\n\n    References\n    ----------\n    - `CIFAR website <https://www.cs.toronto.edu/~kriz/cifar.html>`_\n    - `Data download link <https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz>`_\n    - `Code references <https://teratail.com/questions/28932>`_\n    """"""\n\n    print(""Load or Download cifar10 > {}"".format(path))\n\n    #Helper function to unpickle the data\n    def unpickle(file):\n        fp = open(file, \'rb\')\n        if sys.version_info.major == 2:\n            data = pickle.load(fp)\n        elif sys.version_info.major == 3:\n            data = pickle.load(fp, encoding=\'latin-1\')\n        fp.close()\n        return data\n\n    filename = \'cifar-10-python.tar.gz\'\n    url = \'https://www.cs.toronto.edu/~kriz/\'\n    #Download and uncompress file\n    maybe_download_and_extract(filename, path, url, extract=True)\n\n    #Unpickle file and fill in data\n    X_train = None\n    y_train = []\n    for i in range(1,6):\n        data_dic = unpickle(os.path.join(path, \'cifar-10-batches-py/\', ""data_batch_{}"".format(i)))\n        if i == 1:\n            X_train = data_dic[\'data\']\n        else:\n            X_train = np.vstack((X_train, data_dic[\'data\']))\n        y_train += data_dic[\'labels\']\n\n    test_data_dic = unpickle(os.path.join(path,  \'cifar-10-batches-py/\', ""test_batch""))\n    X_test = test_data_dic[\'data\']\n    y_test = np.array(test_data_dic[\'labels\'])\n\n    if shape == (-1, 3, 32, 32):\n        X_test = X_test.reshape(shape)\n        X_train = X_train.reshape(shape)\n    elif shape == (-1, 32, 32, 3):\n        X_test = X_test.reshape(shape, order=\'F\')\n        X_train = X_train.reshape(shape, order=\'F\')\n        X_test = np.transpose(X_test, (0, 2, 1, 3))\n        X_train = np.transpose(X_train, (0, 2, 1, 3))\n    else:\n        X_test = X_test.reshape(shape)\n        X_train = X_train.reshape(shape)\n\n    y_train = np.array(y_train)\n\n    if plotable == True:\n        print(\'\\nCIFAR-10\')\n        import matplotlib.pyplot as plt\n        fig = plt.figure(1)\n\n        print(\'Shape of a training image: X_train[0]\',X_train[0].shape)\n\n        plt.ion()       # interactive mode\n        count = 1\n        for row in range(10):\n            for col in range(10):\n                a = fig.add_subplot(10, 10, count)\n                if shape == (-1, 3, 32, 32):\n                    # plt.imshow(X_train[count-1], interpolation=\'nearest\')\n                    plt.imshow(np.transpose(X_train[count-1], (1, 2, 0)), interpolation=\'nearest\')\n                    # plt.imshow(np.transpose(X_train[count-1], (2, 1, 0)), interpolation=\'nearest\')\n                elif shape == (-1, 32, 32, 3):\n                    plt.imshow(X_train[count-1], interpolation=\'nearest\')\n                    # plt.imshow(np.transpose(X_train[count-1], (1, 0, 2)), interpolation=\'nearest\')\n                else:\n                    raise Exception(""Do not support the given \'shape\' to plot the image examples"")\n                plt.gca().xaxis.set_major_locator(plt.NullLocator())    # \xe4\xb8\x8d\xe6\x98\xbe\xe7\xa4\xba\xe5\x88\xbb\xe5\xba\xa6(tick)\n                plt.gca().yaxis.set_major_locator(plt.NullLocator())\n                count = count + 1\n        plt.draw()      # interactive mode\n        plt.pause(3)   # interactive mode\n\n        print(""X_train:"",X_train.shape)\n        print(""y_train:"",y_train.shape)\n        print(""X_test:"",X_test.shape)\n        print(""y_test:"",y_test.shape)\n\n    X_train = np.asarray(X_train, dtype=np.float32)\n    X_test = np.asarray(X_test, dtype=np.float32)\n    y_train = np.asarray(y_train, dtype=np.int32)\n    y_test = np.asarray(y_test, dtype=np.int32)\n\n    return X_train, y_train, X_test, y_test\n\n\ndef load_ptb_dataset(path=\'data/ptb/\'):\n    """"""Penn TreeBank (PTB) dataset is used in many LANGUAGE MODELING papers,\n    including ""Empirical Evaluation and Combination of Advanced Language\n    Modeling Techniques"", ""Recurrent Neural Network Regularization"".\n\n    It consists of 929k training words, 73k validation words, and 82k test\n    words. It has 10k words in its vocabulary.\n\n    In ""Recurrent Neural Network Regularization"", they trained regularized LSTMs\n    of two sizes; these are denoted the medium LSTM and large LSTM. Both LSTMs\n    have two layers and are unrolled for 35 steps. They initialize the hidden\n    states to zero. They then use the final hidden states of the current\n    minibatch as the initial hidden state of the subsequent minibatch\n    (successive minibatches sequentially traverse the training set).\n    The size of each minibatch is 20.\n\n    The medium LSTM has 650 units per layer and its parameters are initialized\n    uniformly in [\xe2\x88\x920.05, 0.05]. They apply 50% dropout on the non-recurrent\n    connections. They train the LSTM for 39 epochs with a learning rate of 1,\n    and after 6 epochs they decrease it by a factor of 1.2 after each epoch.\n    They clip the norm of the gradients (normalized by minibatch size) at 5.\n\n    The large LSTM has 1500 units per layer and its parameters are initialized\n    uniformly in [\xe2\x88\x920.04, 0.04]. We apply 65% dropout on the non-recurrent\n    connections. They train the model for 55 epochs with a learning rate of 1;\n    after 14 epochs they start to reduce the learning rate by a factor of 1.15\n    after each epoch. They clip the norm of the gradients (normalized by\n    minibatch size) at 10.\n\n    Parameters\n    ----------\n    path : : string\n        Path to download data to, defaults to data/ptb/\n\n    Returns\n    --------\n    train_data, valid_data, test_data, vocabulary size\n\n    Examples\n    --------\n    >>> train_data, valid_data, test_data, vocab_size = tl.files.load_ptb_dataset()\n\n    Code References\n    ---------------\n    - ``tensorflow.models.rnn.ptb import reader``\n\n    Download Links\n    ---------------\n    - `Manual download <http://www.fit.vutbr.cz/~imikolov/rnnlm/simple-examples.tgz>`_\n    """"""\n    print(""Load or Download Penn TreeBank (PTB) dataset > {}"".format(path))\n\n    #Maybe dowload and uncompress tar, or load exsisting files\n    filename = \'simple-examples.tgz\'\n    url = \'http://www.fit.vutbr.cz/~imikolov/rnnlm/\'\n    maybe_download_and_extract(filename, path, url, extract=True)\n\n    data_path = os.path.join(path, \'simple-examples\', \'data\')\n    train_path = os.path.join(data_path, ""ptb.train.txt"")\n    valid_path = os.path.join(data_path, ""ptb.valid.txt"")\n    test_path = os.path.join(data_path, ""ptb.test.txt"")\n\n    word_to_id = nlp.build_vocab(nlp.read_words(train_path))\n\n    train_data = nlp.words_to_word_ids(nlp.read_words(train_path), word_to_id)\n    valid_data = nlp.words_to_word_ids(nlp.read_words(valid_path), word_to_id)\n    test_data = nlp.words_to_word_ids(nlp.read_words(test_path), word_to_id)\n    vocabulary = len(word_to_id)\n\n    # print(nlp.read_words(train_path))     # ... \'according\', \'to\', \'mr.\', \'<unk>\', \'<eos>\']\n    # print(train_data)                 # ...  214,         5,    23,    1,       2]\n    # print(word_to_id)                 # ... \'beyond\': 1295, \'anti-nuclear\': 9599, \'trouble\': 1520, \'<eos>\': 2 ... }\n    # print(vocabulary)                 # 10000\n    # exit()\n    return train_data, valid_data, test_data, vocabulary\n\n\ndef load_matt_mahoney_text8_dataset(path=\'data/mm_test8/\'):\n    """"""Download a text file from Matt Mahoney\'s website\n    if not present, and make sure it\'s the right size.\n    Extract the first file enclosed in a zip file as a list of words.\n    This dataset can be used for Word Embedding.\n\n    Parameters\n    ----------\n    path : : string\n        Path to download data to, defaults to data/mm_test8/\n\n    Returns\n    --------\n    word_list : a list\n        a list of string (word).\\n\n        e.g. [.... \'their\', \'families\', \'who\', \'were\', \'expelled\', \'from\', \'jerusalem\', ...]\n\n    Examples\n    --------\n    >>> words = tl.files.load_matt_mahoney_text8_dataset()\n    >>> print(\'Data size\', len(words))\n    """"""\n\n    print(""Load or Download matt_mahoney_text8 Dataset> {}"".format(path))\n\n    filename = \'text8.zip\'\n    url = \'http://mattmahoney.net/dc/\'\n    maybe_download_and_extract(filename, path, url, expected_bytes=31344016)\n\n    with zipfile.ZipFile(os.path.join(path, filename)) as f:\n        word_list = f.read(f.namelist()[0]).split()\n\n    return word_list\n\n\ndef load_imdb_dataset(path=\'data/imdb/\', nb_words=None, skip_top=0,\n              maxlen=None, test_split=0.2, seed=113,\n              start_char=1, oov_char=2, index_from=3):\n    """"""Load IMDB dataset\n\n    Parameters\n    ----------\n    path : : string\n        Path to download data to, defaults to data/imdb/\n\n    Examples\n    --------\n    >>> X_train, y_train, X_test, y_test = tl.files.load_imbd_dataset(\n    ...                                 nb_words=20000, test_split=0.2)\n    >>> print(\'X_train.shape\', X_train.shape)\n    ... (20000,)  [[1, 62, 74, ... 1033, 507, 27],[1, 60, 33, ... 13, 1053, 7]..]\n    >>> print(\'y_train.shape\', y_train.shape)\n    ... (20000,)  [1 0 0 ..., 1 0 1]\n\n    References\n    -----------\n    - `Modified from keras. <https://github.com/fchollet/keras/blob/master/keras/datasets/imdb.py>`_\n    """"""\n\n    filename = ""imdb.pkl""\n    url = \'https://s3.amazonaws.com/text-datasets/\'\n    maybe_download_and_extract(filename, path, url)\n\n    if filename.endswith("".gz""):\n        f = gzip.open(os.path.join(path, filename), \'rb\')\n    else:\n        f = open(os.path.join(path, filename), \'rb\')\n\n    X, labels = cPickle.load(f)\n    f.close()\n\n    np.random.seed(seed)\n    np.random.shuffle(X)\n    np.random.seed(seed)\n    np.random.shuffle(labels)\n\n    if start_char is not None:\n        X = [[start_char] + [w + index_from for w in x] for x in X]\n    elif index_from:\n        X = [[w + index_from for w in x] for x in X]\n\n    if maxlen:\n        new_X = []\n        new_labels = []\n        for x, y in zip(X, labels):\n            if len(x) < maxlen:\n                new_X.append(x)\n                new_labels.append(y)\n        X = new_X\n        labels = new_labels\n    if not X:\n        raise Exception(\'After filtering for sequences shorter than maxlen=\' +\n                        str(maxlen) + \', no sequence was kept. \'\n                        \'Increase maxlen.\')\n    if not nb_words:\n        nb_words = max([max(x) for x in X])\n\n    # by convention, use 2 as OOV word\n    # reserve \'index_from\' (=3 by default) characters: 0 (padding), 1 (start), 2 (OOV)\n    if oov_char is not None:\n        X = [[oov_char if (w >= nb_words or w < skip_top) else w for w in x] for x in X]\n    else:\n        nX = []\n        for x in X:\n            nx = []\n            for w in x:\n                if (w >= nb_words or w < skip_top):\n                    nx.append(w)\n            nX.append(nx)\n        X = nX\n\n    X_train = np.array(X[:int(len(X) * (1 - test_split))])\n    y_train = np.array(labels[:int(len(X) * (1 - test_split))])\n\n    X_test = np.array(X[int(len(X) * (1 - test_split)):])\n    y_test = np.array(labels[int(len(X) * (1 - test_split)):])\n\n    return X_train, y_train, X_test, y_test\n\ndef load_nietzsche_dataset(path=\'data/nietzsche/\'):\n    """"""Load Nietzsche dataset.\n    Returns a string.\n\n    Parameters\n    ----------\n    path : string\n        Path to download data to, defaults to data/nietzsche/\n\n    Examples\n    --------\n    >>> see tutorial_generate_text.py\n    >>> words = tl.files.load_nietzsche_dataset()\n    >>> words = basic_clean_str(words)\n    >>> words = words.split()\n    """"""\n    print(""Load or Download nietzsche dataset > {}"".format(path))\n\n    filename = ""nietzsche.txt""\n    url = \'https://s3.amazonaws.com/text-datasets/\'\n    filepath = maybe_download_and_extract(filename, path, url)\n\n    with open(filepath, ""r"") as f:\n        words = f.read()\n        return words\n\ndef load_wmt_en_fr_dataset(path=\'data/wmt_en_fr/\'):\n    """"""It will download English-to-French translation data from the WMT\'15\n    Website (10^9-French-English corpus), and the 2013 news test from\n    the same site as development set.\n    Returns the directories of training data and test data.\n\n    Parameters\n    ----------\n    path : string\n        Path to download data to, defaults to data/wmt_en_fr/\n\n    References\n    ----------\n    - Code modified from /tensorflow/models/rnn/translation/data_utils.py\n\n    Notes\n    -----\n    Usually, it will take a long time to download this dataset.\n    """"""\n    # URLs for WMT data.\n    _WMT_ENFR_TRAIN_URL = ""http://www.statmt.org/wmt10/""\n    _WMT_ENFR_DEV_URL = ""http://www.statmt.org/wmt15/""\n\n    def gunzip_file(gz_path, new_path):\n        """"""Unzips from gz_path into new_path.""""""\n        print(""Unpacking %s to %s"" % (gz_path, new_path))\n        with gzip.open(gz_path, ""rb"") as gz_file:\n            with open(new_path, ""wb"") as new_file:\n                for line in gz_file:\n                    new_file.write(line)\n\n    def get_wmt_enfr_train_set(path):\n        """"""Download the WMT en-fr training corpus to directory unless it\'s there.""""""\n        filename = ""training-giga-fren.tar""\n        maybe_download_and_extract(filename, path, _WMT_ENFR_TRAIN_URL, extract=True)\n        train_path = os.path.join(path, ""giga-fren.release2.fixed"")\n        gunzip_file(train_path + "".fr.gz"", train_path + "".fr"")\n        gunzip_file(train_path + "".en.gz"", train_path + "".en"")\n        return train_path\n\n    def get_wmt_enfr_dev_set(path):\n        """"""Download the WMT en-fr training corpus to directory unless it\'s there.""""""\n        filename = ""dev-v2.tgz""\n        dev_file = maybe_download_and_extract(filename, path, _WMT_ENFR_DEV_URL, extract=False)\n        dev_name = ""newstest2013""\n        dev_path = os.path.join(path, ""newstest2013"")\n        if not (gfile.Exists(dev_path + "".fr"") and gfile.Exists(dev_path + "".en"")):\n            print(""Extracting tgz file %s"" % dev_file)\n            with tarfile.open(dev_file, ""r:gz"") as dev_tar:\n              fr_dev_file = dev_tar.getmember(""dev/"" + dev_name + "".fr"")\n              en_dev_file = dev_tar.getmember(""dev/"" + dev_name + "".en"")\n              fr_dev_file.name = dev_name + "".fr""  # Extract without ""dev/"" prefix.\n              en_dev_file.name = dev_name + "".en""\n              dev_tar.extract(fr_dev_file, path)\n              dev_tar.extract(en_dev_file, path)\n        return dev_path\n\n    print(""Load or Download WMT English-to-French translation > {}"".format(path))\n\n    train_path = get_wmt_enfr_train_set(path)\n    dev_path = get_wmt_enfr_dev_set(path)\n\n    return train_path, dev_path\n\n\n## Load and save network\ndef save_npz(save_list=[], name=\'model.npz\', sess=None):\n    """"""Input parameters and the file name, save parameters into .npz file. Use tl.utils.load_npz() to restore.\n\n    Parameters\n    ----------\n    save_list : a list\n        Parameters want to be saved.\n    name : a string or None\n        The name of the .npz file.\n    sess : None or Session\n\n    Examples\n    --------\n    >>> tl.files.save_npz(network.all_params, name=\'model_test.npz\', sess=sess)\n    ... File saved to: model_test.npz\n    >>> load_params = tl.files.load_npz(name=\'model_test.npz\')\n    ... Loading param0, (784, 800)\n    ... Loading param1, (800,)\n    ... Loading param2, (800, 800)\n    ... Loading param3, (800,)\n    ... Loading param4, (800, 10)\n    ... Loading param5, (10,)\n    >>> put parameters into a TensorLayer network, please see assign_params()\n\n    Notes\n    -----\n    If you got session issues, you can change the value.eval() to value.eval(session=sess)\n\n    References\n    ----------\n    - `Saving dictionary using numpy <http://stackoverflow.com/questions/22315595/saving-dictionary-of-header-information-using-numpy-savez>`_\n    """"""\n    ## save params into a list\n    save_list_var = []\n    if sess:\n        save_list_var = sess.run(save_list)\n    else:\n        try:\n            for k, value in enumerate(save_list):\n                save_list_var.append(value.eval())\n        except:\n            print("" Fail to save model, Hint: pass the session into this function, save_npz(network.all_params, name=\'model.npz\', sess=sess)"")\n    np.savez(name, params=save_list_var)\n    save_list_var = None\n    del save_list_var\n    print(""[*] %s saved"" % name)\n\n    ## save params into a dictionary\n    # rename_dict = {}\n    # for k, value in enumerate(save_dict):\n    #     rename_dict.update({\'param\'+str(k) : value.eval()})\n    # np.savez(name, **rename_dict)\n    # print(\'Model is saved to: %s\' % name)\n\ndef load_npz(path=\'\', name=\'model.npz\'):\n    """"""Load the parameters of a Model saved by tl.files.save_npz().\n\n    Parameters\n    ----------\n    path : a string\n        Folder path to .npz file.\n    name : a string or None\n        The name of the .npz file.\n\n    Returns\n    --------\n    params : list\n        A list of parameters in order.\n\n    Examples\n    --------\n    - See save_npz and assign_params\n\n    References\n    ----------\n    - `Saving dictionary using numpy <http://stackoverflow.com/questions/22315595/saving-dictionary-of-header-information-using-numpy-savez>`_\n    """"""\n    ## if save_npz save params into a dictionary\n    # d = np.load( path+name )\n    # params = []\n    # print(\'Load Model\')\n    # for key, val in sorted( d.items() ):\n    #     params.append(val)\n    #     print(\'Loading %s, %s\' % (key, str(val.shape)))\n    # return params\n    ## if save_npz save params into a list\n    d = np.load( path+name )\n    # for val in sorted( d.items() ):\n    #     params = val\n    #     return params\n    return d[\'params\']\n    # print(d.items()[0][1][\'params\'])\n    # exit()\n    # return d.items()[0][1][\'params\']\n\ndef assign_params(sess, params, network):\n    """"""Assign the given parameters to the TensorLayer network.\n\n    Parameters\n    ----------\n    sess : TensorFlow Session\n    params : a list\n        A list of parameters in order.\n    network : a :class:`Layer` class\n        The network to be assigned\n\n    Examples\n    --------\n    >>> Save your network as follow:\n    >>> tl.files.save_npz(network.all_params, name=\'model_test.npz\')\n    >>> network.print_params()\n    ...\n    ... Next time, load and assign your network as follow:\n    >>> sess.run(tf.initialize_all_variables()) # re-initialize, then save and assign\n    >>> load_params = tl.files.load_npz(name=\'model_test.npz\')\n    >>> tl.files.assign_params(sess, load_params, network)\n    >>> network.print_params()\n\n    References\n    ----------\n    - `Assign value to a TensorFlow variable <http://stackoverflow.com/questions/34220532/how-to-assign-value-to-a-tensorflow-variable>`_\n    """"""\n    ops = []\n    for idx, param in enumerate(params):\n        ops.append(network.all_params[idx].assign(param))\n    sess.run(ops)\n\ndef load_and_assign_npz(sess=None, name=None, network=None):\n    """"""Load model from npz and assign to a network.\n\n    Parameters\n    -------------\n    sess : TensorFlow Session\n    name : string\n        Model path.\n    network : a :class:`Layer` class\n        The network to be assigned\n\n    Returns\n    --------\n    Returns False if faild to model is not exist.\n\n    Examples\n    ---------\n    >>> tl.files.load_and_assign_npz(sess=sess, name=\'net.npz\', network=net)\n    """"""\n    assert network is not None\n    assert sess is not None\n    if not os.path.exists(name):\n        print(""[!] Load {} failed!"".format(name))\n        return False\n    else:\n        params = load_npz(name=name)\n        assign_params(sess, params, network)\n        print(""[*] Load {} SUCCESS!"".format(name))\n        return network\n\n# Load and save variables\ndef save_any_to_npy(save_dict={}, name=\'file.npy\'):\n    """"""Save variables to .npy file.\n\n    Examples\n    ---------\n    >>> tl.files.save_any_to_npy(save_dict={\'data\': [\'a\',\'b\']}, name=\'test.npy\')\n    >>> data = tl.files.load_npy_to_any(name=\'test.npy\')\n    >>> print(data)\n    ... {\'data\': [\'a\',\'b\']}\n    """"""\n    np.save(name, save_dict)\n\ndef load_npy_to_any(path=\'\', name=\'file.npy\'):\n    """"""Load .npy file.\n\n    Examples\n    ---------\n    - see save_any_to_npy()\n    """"""\n    file_path = os.path.join(path, name)\n    try:\n        npy = np.load(file_path).item()\n    except:\n        npy = np.load(file_path)\n    finally:\n        try:\n            return npy\n        except:\n            print(""[!] Fail to load %s"" % file_path)\n            exit()\n\n\n# Visualizing npz files\ndef npz_to_W_pdf(path=None, regx=\'w1pre_[0-9]+\\.(npz)\'):\n    """"""Convert the first weight matrix of .npz file to .pdf by using tl.visualize.W().\n\n    Parameters\n    ----------\n    path : a string or None\n        A folder path to npz files.\n    regx : a string\n        Regx for the file name.\n\n    Examples\n    --------\n    >>> Convert the first weight matrix of w1_pre...npz file to w1_pre...pdf.\n    >>> tl.files.npz_to_W_pdf(path=\'/Users/.../npz_file/\', regx=\'w1pre_[0-9]+\\.(npz)\')\n    """"""\n    file_list = load_file_list(path=path, regx=regx)\n    for f in file_list:\n        W = load_npz(path, f)[0]\n        print(""%s --> %s"" % (f, f.split(\'.\')[0]+\'.pdf\'))\n        visualize.W(W, second=10, saveable=True, name=f.split(\'.\')[0], fig_idx=2012)\n\n\n## Helper functions\ndef load_file_list(path=None, regx=\'\\.npz\', printable=True):\n    """"""Return a file list in a folder by given a path and regular expression.\n\n    Parameters\n    ----------\n    path : a string or None\n        A folder path.\n    regx : a string\n        The regx of file name.\n    printable : boolean, whether to print the files infomation.\n\n    Examples\n    ----------\n    >>> file_list = tl.files.load_file_list(path=None, regx=\'w1pre_[0-9]+\\.(npz)\')\n    """"""\n    if path == False:\n        path = os.getcwd()\n    file_list = os.listdir(path)\n    return_list = []\n    for idx, f in enumerate(file_list):\n        if re.search(regx, f):\n            return_list.append(f)\n    # return_list.sort()\n    if printable:\n        print(\'Match file list = %s\' % return_list)\n        print(\'Number of files = %d\' % len(return_list))\n    return return_list\n\ndef load_folder_list(path=""""):\n    """"""Return a folder list in a folder by given a folder path.\n\n    Parameters\n    ----------\n    path : a string or None\n        A folder path.\n    """"""\n    return [os.path.join(path,o) for o in os.listdir(path) if os.path.isdir(os.path.join(path,o))]\n\ndef exists_or_mkdir(path, verbose=True):\n    """"""Check a folder by given name, if not exist, create the folder and return False,\n    if directory exists, return True.\n\n    Parameters\n    ----------\n    path : a string\n        A folder path.\n    verbose : boolean\n        If True, prints results, deaults is True\n\n    Returns\n    --------\n    True if folder exist, otherwise, returns False and create the folder\n\n    Examples\n    --------\n    >>> tl.files.exists_or_mkdir(""checkpoints/train"")\n    """"""\n    if not os.path.exists(path):\n        if verbose:\n            print(""[*] creates %s ..."" % path)\n        os.makedirs(path)\n        return False\n    else:\n        if verbose:\n            print(""[!] %s exists ..."" % path)\n        return True\n\ndef maybe_download_and_extract(filename, working_directory, url_source, extract=False, expected_bytes=None):\n    """"""Checks if file exists in working_directory otherwise tries to dowload the file,\n    and optionally also tries to extract the file if format is "".zip"" or "".tar""\n\n    Parameters\n    ----------\n    filename : string\n        The name of the (to be) dowloaded file.\n    working_directory : string\n        A folder path to search for the file in and dowload the file to\n    url : string\n        The URL to download the file from\n    extract : bool, defaults to False\n        If True, tries to uncompress the dowloaded file is "".tar.gz/.tar.bz2"" or "".zip"" file\n    expected_bytes : int/None\n        If set tries to verify that the downloaded file is of the specified size, otherwise raises an Exception,\n        defaults to None which corresponds to no check being performed\n    Returns\n    ----------\n    filepath to dowloaded (uncompressed) file\n\n    Examples\n    --------\n    >>> down_file = tl.files.maybe_download_and_extract(filename = \'train-images-idx3-ubyte.gz\',\n                                                        working_directory = \'data/\',\n                                                        url_source = \'http://yann.lecun.com/exdb/mnist/\')\n    >>> tl.files.maybe_download_and_extract(filename = \'ADEChallengeData2016.zip\',\n                                            working_directory = \'data/\',\n                                            url_source = \'http://sceneparsing.csail.mit.edu/data/\',\n                                            extract=True)\n    """"""\n    # We first define a download function, supporting both Python 2 and 3.\n    def _download(filename, working_directory, url_source):\n        def _dlProgress(count, blockSize, totalSize):\n            if(totalSize != 0):\n                percent = float(count * blockSize) / float(totalSize) * 100.0\n                sys.stdout.write(""\\r"" ""Downloading "" + filename + ""...%d%%"" % percent)\n                sys.stdout.flush()\n        if sys.version_info[0] == 2:\n            from urllib import urlretrieve\n        else:\n            from urllib.request import urlretrieve\n        filepath = os.path.join(working_directory, filename)\n        urlretrieve(url_source+filename, filepath, reporthook=_dlProgress)\n\n    exists_or_mkdir(working_directory, verbose=False)\n    filepath = os.path.join(working_directory, filename)\n\n    if not os.path.exists(filepath):\n        _download(filename, working_directory, url_source)\n        print()\n        statinfo = os.stat(filepath)\n        print(\'Succesfully downloaded\', filename, statinfo.st_size, \'bytes.\')\n        if(not(expected_bytes is None) and (expected_bytes != statinfo.st_size)):\n            raise Exception(\'Failed to verify \' + filename + \'. Can you get to it with a browser?\')\n        if(extract):\n            if tarfile.is_tarfile(filepath):\n                print(\'Trying to extract tar file\')\n                tarfile.open(filepath, \'r\').extractall(working_directory)\n                print(\'... Success!\')\n            elif zipfile.is_zipfile(filepath):\n                print(\'Trying to extract zip file\')\n                with zipfile.ZipFile(filepath) as zf:\n                    zf.extractall(working_directory)\n                print(\'... Success!\')\n            else:\n                print(""Unknown compression_format only .tar.gz/.tar.bz2/.tar and .zip supported"")\n    return filepath\n'"
tensorlayer/iterate.py,0,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\nimport numpy as np\nfrom six.moves import xrange\n\ndef minibatches(inputs=None, targets=None, batch_size=None, shuffle=False):\n    """"""Generate a generator that input a group of example in numpy.array and\n    their labels, return the examples and labels by the given batchsize.\n\n    Parameters\n    ----------\n    inputs : numpy.array\n        (X) The input features, every row is a example.\n    targets : numpy.array\n        (y) The labels of inputs, every row is a example.\n    batch_size : int\n        The batch size.\n    shuffle : boolean\n        Indicating whether to use a shuffling queue, shuffle the dataset before return.\n\n    Hints\n    -------\n    - If you have two inputs, e.g. X1 (1000, 100) and X2 (1000, 80), you can ``np.hstack((X1, X2))\n    into (1000, 180) and feed into ``inputs``, then you can split a batch of X1 and X2.\n\n    Examples\n    --------\n    >>> X = np.asarray([[\'a\',\'a\'], [\'b\',\'b\'], [\'c\',\'c\'], [\'d\',\'d\'], [\'e\',\'e\'], [\'f\',\'f\']])\n    >>> y = np.asarray([0,1,2,3,4,5])\n    >>> for batch in tl.iterate.minibatches(inputs=X, targets=y, batch_size=2, shuffle=False):\n    >>>     print(batch)\n    ... (array([[\'a\', \'a\'],\n    ...        [\'b\', \'b\']],\n    ...         dtype=\'<U1\'), array([0, 1]))\n    ... (array([[\'c\', \'c\'],\n    ...        [\'d\', \'d\']],\n    ...         dtype=\'<U1\'), array([2, 3]))\n    ... (array([[\'e\', \'e\'],\n    ...        [\'f\', \'f\']],\n    ...         dtype=\'<U1\'), array([4, 5]))\n    """"""\n    assert len(inputs) == len(targets)\n    if shuffle:\n        indices = np.arange(len(inputs))\n        np.random.shuffle(indices)\n    for start_idx in range(0, len(inputs) - batch_size + 1, batch_size):\n        if shuffle:\n            excerpt = indices[start_idx:start_idx + batch_size]\n        else:\n            excerpt = slice(start_idx, start_idx + batch_size)\n        yield inputs[excerpt], targets[excerpt]\n\ndef seq_minibatches(inputs, targets, batch_size, seq_length, stride=1):\n    """"""Generate a generator that return a batch of sequence inputs and targets.\n    If ``batch_size = 100, seq_length = 5``, one return will have ``500`` rows (examples).\n\n    Examples\n    --------\n    - Synced sequence input and output.\n    >>> X = np.asarray([[\'a\',\'a\'], [\'b\',\'b\'], [\'c\',\'c\'], [\'d\',\'d\'], [\'e\',\'e\'], [\'f\',\'f\']])\n    >>> y = np.asarray([0, 1, 2, 3, 4, 5])\n    >>> for batch in tl.iterate.seq_minibatches(inputs=X, targets=y, batch_size=2, seq_length=2, stride=1):\n    >>>     print(batch)\n    ... (array([[\'a\', \'a\'],\n    ...        [\'b\', \'b\'],\n    ...         [\'b\', \'b\'],\n    ...         [\'c\', \'c\']],\n    ...         dtype=\'<U1\'), array([0, 1, 1, 2]))\n    ... (array([[\'c\', \'c\'],\n    ...         [\'d\', \'d\'],\n    ...         [\'d\', \'d\'],\n    ...         [\'e\', \'e\']],\n    ...         dtype=\'<U1\'), array([2, 3, 3, 4]))\n    ...\n    ...\n\n    - Many to One\n    >>> return_last = True\n    >>> num_steps = 2\n    >>> X = np.asarray([[\'a\',\'a\'], [\'b\',\'b\'], [\'c\',\'c\'], [\'d\',\'d\'], [\'e\',\'e\'], [\'f\',\'f\']])\n    >>> Y = np.asarray([0,1,2,3,4,5])\n    >>> for batch in tl.iterate.seq_minibatches(inputs=X, targets=Y, batch_size=2, seq_length=num_steps, stride=1):\n    >>>     x, y = batch\n    >>>     if return_last:\n    >>>         tmp_y = y.reshape((-1, num_steps) + y.shape[1:])\n    >>>     y = tmp_y[:, -1]\n    >>>     print(x, y)\n    ... [[\'a\' \'a\']\n    ... [\'b\' \'b\']\n    ... [\'b\' \'b\']\n    ... [\'c\' \'c\']] [1 2]\n    ... [[\'c\' \'c\']\n    ... [\'d\' \'d\']\n    ... [\'d\' \'d\']\n    ... [\'e\' \'e\']] [3 4]\n    """"""\n    assert len(inputs) == len(targets)\n    n_loads = (batch_size * stride) + (seq_length - stride)\n    for start_idx in range(0, len(inputs) - n_loads + 1, (batch_size * stride)):\n        seq_inputs = np.zeros((batch_size, seq_length) + inputs.shape[1:],\n                              dtype=inputs.dtype)\n        seq_targets = np.zeros((batch_size, seq_length) + targets.shape[1:],\n                               dtype=targets.dtype)\n        for b_idx in xrange(batch_size):\n            start_seq_idx = start_idx + (b_idx * stride)\n            end_seq_idx = start_seq_idx + seq_length\n            seq_inputs[b_idx] = inputs[start_seq_idx:end_seq_idx]\n            seq_targets[b_idx] = targets[start_seq_idx:end_seq_idx]\n        flatten_inputs = seq_inputs.reshape((-1,) + inputs.shape[1:])\n        flatten_targets = seq_targets.reshape((-1,) + targets.shape[1:])\n        yield flatten_inputs, flatten_targets\n\ndef seq_minibatches2(inputs, targets, batch_size, num_steps):\n    """"""Generate a generator that iterates on two list of words. Yields (Returns) the source contexts and\n    the target context by the given batch_size and num_steps (sequence_length),\n    see ``PTB tutorial``. In TensorFlow\'s tutorial, this generates the batch_size pointers into the raw\n    PTB data, and allows minibatch iteration along these pointers.\n\n    - Hint, if the input data are images, you can modify the code as follow.\n\n    .. code-block:: python\n\n        from\n        data = np.zeros([batch_size, batch_len)\n        to\n        data = np.zeros([batch_size, batch_len, inputs.shape[1], inputs.shape[2], inputs.shape[3]])\n\n    Parameters\n    ----------\n    inputs : a list\n            the context in list format; note that context usually be\n            represented by splitting by space, and then convert to unique\n            word IDs.\n    targets : a list\n            the context in list format; note that context usually be\n            represented by splitting by space, and then convert to unique\n            word IDs.\n    batch_size : int\n            the batch size.\n    num_steps : int\n            the number of unrolls. i.e. sequence_length\n\n    Yields\n    ------\n    Pairs of the batched data, each a matrix of shape [batch_size, num_steps].\n\n    Raises\n    ------\n    ValueError : if batch_size or num_steps are too high.\n\n    Examples\n    --------\n    >>> X = [i for i in range(20)]\n    >>> Y = [i for i in range(20,40)]\n    >>> for batch in tl.iterate.seq_minibatches2(X, Y, batch_size=2, num_steps=3):\n    ...     x, y = batch\n    ...     print(x, y)\n    ...\n    ... [[  0.   1.   2.]\n    ... [ 10.  11.  12.]]\n    ... [[ 20.  21.  22.]\n    ... [ 30.  31.  32.]]\n    ...\n    ... [[  3.   4.   5.]\n    ... [ 13.  14.  15.]]\n    ... [[ 23.  24.  25.]\n    ... [ 33.  34.  35.]]\n    ...\n    ... [[  6.   7.   8.]\n    ... [ 16.  17.  18.]]\n    ... [[ 26.  27.  28.]\n    ... [ 36.  37.  38.]]\n\n    Code References\n    ---------------\n    - ``tensorflow/models/rnn/ptb/reader.py``\n    """"""\n    assert len(inputs) == len(targets)\n    data_len = len(inputs)\n    batch_len = data_len // batch_size\n    # data = np.zeros([batch_size, batch_len])\n    data = np.zeros((batch_size, batch_len) + inputs.shape[1:],\n                          dtype=inputs.dtype)\n    data2 = np.zeros([batch_size, batch_len])\n\n    for i in range(batch_size):\n        data[i] = inputs[batch_len * i:batch_len * (i + 1)]\n        data2[i] = targets[batch_len * i:batch_len * (i + 1)]\n\n    epoch_size = (batch_len - 1) // num_steps\n\n    if epoch_size == 0:\n        raise ValueError(""epoch_size == 0, decrease batch_size or num_steps"")\n\n    for i in range(epoch_size):\n        x = data[:, i*num_steps:(i+1)*num_steps]\n        x2 = data2[:, i*num_steps:(i+1)*num_steps]\n        yield (x, x2)\n\n\ndef ptb_iterator(raw_data, batch_size, num_steps):\n    """"""\n    Generate a generator that iterates on a list of words, see PTB tutorial. Yields (Returns) the source contexts and\n    the target context by the given batch_size and num_steps (sequence_length).\\n\n    see ``PTB tutorial``.\n\n    e.g. x = [0, 1, 2]  y = [1, 2, 3] , when batch_size = 1, num_steps = 3,\n    raw_data = [i for i in range(100)]\n\n    In TensorFlow\'s tutorial, this generates batch_size pointers into the raw\n    PTB data, and allows minibatch iteration along these pointers.\n\n    Parameters\n    ----------\n    raw_data : a list\n            the context in list format; note that context usually be\n            represented by splitting by space, and then convert to unique\n            word IDs.\n    batch_size : int\n            the batch size.\n    num_steps : int\n            the number of unrolls. i.e. sequence_length\n\n    Yields\n    ------\n    Pairs of the batched data, each a matrix of shape [batch_size, num_steps].\n    The second element of the tuple is the same data time-shifted to the\n    right by one.\n\n    Raises\n    ------\n    ValueError : if batch_size or num_steps are too high.\n\n    Examples\n    --------\n    >>> train_data = [i for i in range(20)]\n    >>> for batch in tl.iterate.ptb_iterator(train_data, batch_size=2, num_steps=3):\n    >>>     x, y = batch\n    >>>     print(x, y)\n    ... [[ 0  1  2] <---x                       1st subset/ iteration\n    ...  [10 11 12]]\n    ... [[ 1  2  3] <---y\n    ...  [11 12 13]]\n    ...\n    ... [[ 3  4  5]  <--- 1st batch input       2nd subset/ iteration\n    ...  [13 14 15]] <--- 2nd batch input\n    ... [[ 4  5  6]  <--- 1st batch target\n    ...  [14 15 16]] <--- 2nd batch target\n    ...\n    ... [[ 6  7  8]                             3rd subset/ iteration\n    ...  [16 17 18]]\n    ... [[ 7  8  9]\n    ...  [17 18 19]]\n\n    Code References\n    ----------------\n    - ``tensorflow/models/rnn/ptb/reader.py``\n    """"""\n    raw_data = np.array(raw_data, dtype=np.int32)\n\n    data_len = len(raw_data)\n    batch_len = data_len // batch_size\n    data = np.zeros([batch_size, batch_len], dtype=np.int32)\n    for i in range(batch_size):\n        data[i] = raw_data[batch_len * i:batch_len * (i + 1)]\n\n    epoch_size = (batch_len - 1) // num_steps\n\n    if epoch_size == 0:\n        raise ValueError(""epoch_size == 0, decrease batch_size or num_steps"")\n\n    for i in range(epoch_size):\n        x = data[:, i*num_steps:(i+1)*num_steps]\n        y = data[:, i*num_steps+1:(i+1)*num_steps+1]\n        yield (x, y)\n\n\n\n# def minibatches_for_sequence2D(inputs, targets, batch_size, sequence_length, stride=1):\n#     """"""\n#     Input a group of example in 2D numpy.array and their labels.\n#     Return the examples and labels by the given batchsize, sequence_length.\n#     Use for RNN.\n#\n#     Parameters\n#     ----------\n#     inputs : numpy.array\n#         (X) The input features, every row is a example.\n#     targets : numpy.array\n#         (y) The labels of inputs, every row is a example.\n#     batchsize : int\n#         The batch size must be a multiple of sequence_length: int(batch_size % sequence_length) == 0\n#     sequence_length : int\n#         The sequence length\n#     stride : int\n#         The stride step\n#\n#     Examples\n#     --------\n#     >>> sequence_length = 2\n#     >>> batch_size = 4\n#     >>> stride = 1\n#     >>> X_train = np.asarray([[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,24]])\n#     >>> y_train = np.asarray([\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\'])\n#     >>> print(\'X_train = %s\' % X_train)\n#     >>> print(\'y_train = %s\' % y_train)\n#     >>> for batch in minibatches_for_sequence2D(X_train, y_train, batch_size=batch_size, sequence_length=sequence_length, stride=stride):\n#     >>>     inputs, targets = batch\n#     >>>     print(inputs)\n#     >>>     print(targets)\n#     ... [[ 1.  2.  3.]\n#     ... [ 4.  5.  6.]\n#     ... [ 4.  5.  6.]\n#     ... [ 7.  8.  9.]]\n#     ... [1 2]\n#     ... [[  4.   5.   6.]\n#     ... [  7.   8.   9.]\n#     ... [  7.   8.   9.]\n#     ... [ 10.  11.  12.]]\n#     ... [2 3]\n#     ... ...\n#     ... [[ 16.  17.  18.]\n#     ... [ 19.  20.  21.]\n#     ... [ 19.  20.  21.]\n#     ... [ 22.  23.  24.]]\n#     ... [6 7]\n#     """"""\n#     print(\'len(targets)=%d batch_size=%d sequence_length=%d stride=%d\' % (len(targets), batch_size, sequence_length, stride))\n#     assert len(inputs) == len(targets), \'1 feature vector have 1 target vector/value\' #* sequence_length\n#     # assert int(batch_size % sequence_length) == 0, \'batch_size % sequence_length must == 0\\\n#     # batch_size is number of examples rather than number of targets\'\n#\n#     # print(inputs.shape, len(inputs), len(inputs[0]))\n#\n#     n_targets = int(batch_size/sequence_length)\n#     # n_targets = int(np.ceil(batch_size/sequence_length))\n#     X = np.empty(shape=(0,len(inputs[0])), dtype=np.float32)\n#     y = np.zeros(shape=(1, n_targets), dtype=np.int32)\n#\n#     for idx in range(sequence_length, len(inputs), stride):  # go through all example during 1 epoch\n#         for n in range(n_targets):   # for num of target\n#             X = np.concatenate((X, inputs[idx-sequence_length+n:idx+n]))\n#             y[0][n] = targets[idx-1+n]\n#             # y = np.vstack((y, targets[idx-1+n]))\n#         yield X, y[0]\n#         X = np.empty(shape=(0,len(inputs[0])))\n#         # y = np.empty(shape=(1,0))\n#\n#\n# def minibatches_for_sequence4D(inputs, targets, batch_size, sequence_length, stride=1): #\n#     """"""\n#     Input a group of example in 4D numpy.array and their labels.\n#     Return the examples and labels by the given batchsize, sequence_length.\n#     Use for RNN.\n#\n#     Parameters\n#     ----------\n#     inputs : numpy.array\n#         (X) The input features, every row is a example.\n#     targets : numpy.array\n#         (y) The labels of inputs, every row is a example.\n#     batchsize : int\n#         The batch size must be a multiple of sequence_length: int(batch_size % sequence_length) == 0\n#     sequence_length : int\n#         The sequence length\n#     stride : int\n#         The stride step\n#\n#     Examples\n#     --------\n#     >>> sequence_length = 2\n#     >>> batch_size = 2\n#     >>> stride = 1\n#     >>> X_train = np.asarray([[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,24]])\n#     >>> y_train = np.asarray([\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\'])\n#     >>> X_train = np.expand_dims(X_train, axis=1)\n#     >>> X_train = np.expand_dims(X_train, axis=3)\n#     >>> for batch in minibatches_for_sequence4D(X_train, y_train, batch_size=batch_size, sequence_length=sequence_length, stride=stride):\n#     >>>     inputs, targets = batch\n#     >>>     print(inputs)\n#     >>>     print(targets)\n#     ... [[[[ 1.]\n#     ...    [ 2.]\n#     ...    [ 3.]]]\n#     ... [[[ 4.]\n#     ...   [ 5.]\n#     ...   [ 6.]]]]\n#     ... [1]\n#     ... [[[[ 4.]\n#     ...    [ 5.]\n#     ...    [ 6.]]]\n#     ... [[[ 7.]\n#     ...   [ 8.]\n#     ...   [ 9.]]]]\n#     ... [2]\n#     ... ...\n#     ... [[[[ 19.]\n#     ...    [ 20.]\n#     ...    [ 21.]]]\n#     ... [[[ 22.]\n#     ...   [ 23.]\n#     ...   [ 24.]]]]\n#     ... [7]\n#     """"""\n#     print(\'len(targets)=%d batch_size=%d sequence_length=%d stride=%d\' % (len(targets), batch_size, sequence_length, stride))\n#     assert len(inputs) == len(targets), \'1 feature vector have 1 target vector/value\' #* sequence_length\n#     # assert int(batch_size % sequence_length) == 0, \'in LSTM, batch_size % sequence_length must == 0\\\n#     # batch_size is number of X_train rather than number of targets\'\n#     assert stride >= 1, \'stride must be >=1, at least move 1 step for each iternation\'\n#\n#     n_example, n_channels, width, height = inputs.shape\n#     print(\'n_example=%d n_channels=%d width=%d height=%d\' % (n_example, n_channels, width, height))\n#\n#     n_targets = int(np.ceil(batch_size/sequence_length)) # \xe5\xae\x9e\xe9\x99\x85\xe4\xb8\xba batchsize/sequence_length + 1\n#     print(n_targets)\n#     X = np.zeros(shape=(batch_size, n_channels, width, height), dtype=np.float32)\n#     # X = np.zeros(shape=(n_targets, sequence_length, n_channels, width, height), dtype=np.float32)\n#     y = np.zeros(shape=(1,n_targets), dtype=np.int32)\n#     # y = np.empty(shape=(0,1), dtype=np.float32)\n#     # time.sleep(2)\n#     for idx in range(sequence_length, n_example-n_targets+2, stride):  # go through all example during 1 epoch\n#         for n in range(n_targets):   # for num of target\n#             # print(idx+n, inputs[idx-sequence_length+n : idx+n].shape)\n#             X[n*sequence_length : (n+1)*sequence_length] = inputs[idx+n-sequence_length : idx+n]\n#             # X[n] = inputs[idx-sequence_length+n:idx+n]\n#             y[0][n] = targets[idx+n-1]\n#             # y = np.vstack((y, targets[idx-1+n]))\n#         # y = targets[idx: idx+n_targets]\n#         yield X, y[0]\n'"
tensorlayer/layers.py,638,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\nimport tensorflow as tf\nimport time\nfrom . import visualize\nfrom . import utils\nfrom . import files\nfrom . import cost\nfrom . import iterate\nfrom . import ops\nimport numpy as np\nfrom six.moves import xrange\nimport random, warnings\nimport copy\n\n# __all__ = [\n#     ""Layer"",\n#     ""DenseLayer"",\n# ]\n\n\n# set_keep = locals()\nset_keep = globals()\nset_keep[\'_layers_name_list\'] =[]\nset_keep[\'name_reuse\'] = False\n\ntry:  # For TF12 and later\n    TF_GRAPHKEYS_VARIABLES = tf.GraphKeys.GLOBAL_VARIABLES\nexcept:  # For TF11 and before\n    TF_GRAPHKEYS_VARIABLES = tf.GraphKeys.VARIABLES\n\n## Variable Operation\ndef flatten_reshape(variable, name=\'\'):\n    """"""Reshapes high-dimension input to a vector.\n    [batch_size, mask_row, mask_col, n_mask] ---> [batch_size, mask_row * mask_col * n_mask]\n\n    Parameters\n    ----------\n    variable : a tensorflow variable\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    >>> W_conv2 = weight_variable([5, 5, 100, 32])   # 64 features for each 5x5 patch\n    >>> b_conv2 = bias_variable([32])\n    >>> W_fc1 = weight_variable([7 * 7 * 32, 256])\n\n    >>> h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n    >>> h_pool2 = max_pool_2x2(h_conv2)\n    >>> h_pool2.get_shape()[:].as_list() = [batch_size, 7, 7, 32]\n    ...         [batch_size, mask_row, mask_col, n_mask]\n    >>> h_pool2_flat = tl.layers.flatten_reshape(h_pool2)\n    ...         [batch_size, mask_row * mask_col * n_mask]\n    >>> h_pool2_flat_drop = tf.nn.dropout(h_pool2_flat, keep_prob)\n    ...\n    """"""\n    dim = 1\n    for d in variable.get_shape()[1:].as_list():\n        dim *= d\n    return tf.reshape(variable, shape=[-1, dim], name=name)\n\ndef clear_layers_name():\n    """"""Clear all layer names in set_keep[\'_layers_name_list\'],\n    enable layer name reuse.\n\n    Examples\n    ---------\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.DenseLayer(network, n_units=800, name=\'relu1\')\n    ...\n    >>> tl.layers.clear_layers_name()\n    >>> network2 = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network2 = tl.layers.DenseLayer(network2, n_units=800, name=\'relu1\')\n    ...\n    """"""\n    set_keep[\'_layers_name_list\'] =[]\n\ndef set_name_reuse(enable=True):\n    """"""Enable or disable reuse layer name. By default, each layer must has unique\n    name. When you want two or more input placeholder (inference) share the same\n    model parameters, you need to enable layer name reuse, then allow the\n    parameters have same name scope.\n\n    Parameters\n    ------------\n    enable : boolean, enable name reuse.\n\n    Examples\n    ------------\n    >>> def embed_seq(input_seqs, is_train, reuse):\n    >>>    with tf.variable_scope(""model"", reuse=reuse):\n    >>>         tl.layers.set_name_reuse(reuse)\n    >>>         network = tl.layers.EmbeddingInputlayer(\n    ...                     inputs = input_seqs,\n    ...                     vocabulary_size = vocab_size,\n    ...                     embedding_size = embedding_size,\n    ...                     name = \'e_embedding\')\n    >>>        network = tl.layers.DynamicRNNLayer(network,\n    ...                     cell_fn = tf.nn.rnn_cell.BasicLSTMCell,\n    ...                     n_hidden = embedding_size,\n    ...                     dropout = (0.7 if is_train else None),\n    ...                     initializer = w_init,\n    ...                     sequence_length = tl.layers.retrieve_seq_length_op2(input_seqs),\n    ...                     return_last = True,\n    ...                     name = \'e_dynamicrnn\',)\n    >>>    return network\n    >>>\n    >>> net_train = embed_seq(t_caption, is_train=True, reuse=False)\n    >>> net_test = embed_seq(t_caption, is_train=False, reuse=True)\n\n    - see ``tutorial_ptb_lstm.py`` for example.\n    """"""\n    set_keep[\'name_reuse\'] = enable\n\ndef initialize_rnn_state(state):\n    """"""Return the initialized RNN state.\n    The input is LSTMStateTuple or State of RNNCells.\n\n    Parameters\n    -----------\n    state : a RNN state.\n    """"""\n    try: # TF1.0\n        LSTMStateTuple = tf.contrib.rnn.LSTMStateTuple\n    except:\n        LSTMStateTuple = tf.nn.rnn_cell.LSTMStateTuple\n\n    if isinstance(state, LSTMStateTuple):\n        c = state.c.eval()\n        h = state.h.eval()\n        return (c, h)\n    else:\n        new_state = state.eval()\n        return new_state\n\ndef print_all_variables(train_only=False):\n    """"""Print all trainable and non-trainable variables\n    without tl.layers.initialize_global_variables(sess)\n\n    Parameters\n    ----------\n    train_only : boolean\n        If True, only print the trainable variables, otherwise, print all variables.\n    """"""\n    # tvar = tf.trainable_variables() if train_only else tf.all_variables()\n    if train_only:\n        t_vars = tf.trainable_variables()\n        print(""  [*] printing trainable variables"")\n    else:\n        try: # TF1.0\n            t_vars = tf.global_variables()\n        except: # TF0.12\n            t_vars = tf.all_variables()\n        print(""  [*] printing global variables"")\n    for idx, v in enumerate(t_vars):\n        print(""  var {:3}: {:15}   {}"".format(idx, str(v.get_shape()), v.name))\n\ndef get_variables_with_name(name, train_only=True, printable=False):\n    """"""Get variable list by a given name scope.\n\n    Examples\n    ---------\n    >>> dense_vars = tl.layers.get_variable_with_name(\'dense\', True, True)\n    """"""\n    print(""  [*] geting variables with %s"" % name)\n    # tvar = tf.trainable_variables() if train_only else tf.all_variables()\n    if train_only:\n        t_vars = tf.trainable_variables()\n    else:\n        try: # TF1.0\n            t_vars = tf.global_variables()\n        except: # TF0.12\n            t_vars = tf.all_variables()\n\n    d_vars = [var for var in t_vars if name in var.name]\n    if printable:\n        for idx, v in enumerate(d_vars):\n            print(""  got {:3}: {:15}   {}"".format(idx, v.name, str(v.get_shape())))\n    return d_vars\n\ndef get_layers_with_name(network=None, name="""", printable=False):\n    """"""Get layer list in a network by a given name scope.\n\n    Examples\n    ---------\n    >>> layers = tl.layers.get_layers_with_name(network, ""CNN"", True)\n    """"""\n    assert network is not None\n    print(""  [*] geting layers with %s"" % name)\n\n    layers = []\n    i = 0\n    for layer in network.all_layers:\n        # print(type(layer.name))\n        if name in layer.name:\n            layers.append(layer)\n            if printable:\n                # print(layer.name)\n                print(""  got {:3}: {:15}   {}"".format(i, layer.name, str(layer.get_shape())))\n                i = i + 1\n    return layers\n\ndef list_remove_repeat(l=None):\n    """"""Remove the repeated items in a list, and return the processed list.\n    You may need it to create merged layer like Concat, Elementwise and etc.\n\n    Parameters\n    ----------\n    l : a list\n\n    Examples\n    ---------\n    >>> l = [2, 3, 4, 2, 3]\n    >>> l = list_remove_repeat(l)\n    ... [2, 3, 4]\n    """"""\n    l2 = []\n    [l2.append(i) for i in l if not i in l2]\n    return l2\n\ndef initialize_global_variables(sess=None):\n    """"""Excute ``sess.run(tf.global_variables_initializer())`` for TF12+ or\n    sess.run(tf.initialize_all_variables()) for TF11.\n\n    Parameters\n    ----------\n    sess : a Session\n    """"""\n    assert sess is not None\n    try:    # TF12\n        sess.run(tf.global_variables_initializer())\n    except: # TF11\n        sess.run(tf.initialize_all_variables())\n\n\n## Basic layer\nclass Layer(object):\n    """"""\n    The :class:`Layer` class represents a single layer of a neural network. It\n    should be subclassed when implementing new types of layers.\n    Because each layer can keep track of the layer(s) feeding into it, a\n    network\'s output :class:`Layer` instance can double as a handle to the full\n    network.\n\n    Parameters\n    ----------\n    inputs : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        inputs = None,\n        name =\'layer\'\n    ):\n        self.inputs = inputs\n        scope_name=tf.get_variable_scope().name\n        if scope_name:\n            name = scope_name + \'/\' + name\n        if (name in set_keep[\'_layers_name_list\']) and name_reuse == False:\n            raise Exception(""Layer \'%s\' already exists, please choice other \'name\' or reuse this layer\\\n            \\nHint : Use different name for different \'Layer\' (The name is used to control parameter sharing)"" % name)\n        else:\n            self.name = name\n            if name not in [\'\', None, False]:\n                set_keep[\'_layers_name_list\'].append(name)\n\n\n    def print_params(self, details=True):\n        \'\'\' Print all info of parameters in the network\'\'\'\n        for i, p in enumerate(self.all_params):\n            if details:\n                try:\n                    print(""  param {:3}: {:15} (mean: {:<18}, median: {:<18}, std: {:<18})   {}"".format(i, str(p.eval().shape), p.eval().mean(), np.median(p.eval()), p.eval().std(), p.name))\n                except Exception as e:\n                    print(str(e))\n                    raise Exception(""Hint: print params details after tl.layers.initialize_global_variables(sess) or use network.print_params(False)."")\n            else:\n                print(""  param {:3}: {:15}    {}"".format(i, str(p.get_shape()), p.name))\n        print(""  num of params: %d"" % self.count_params())\n\n    def print_layers(self):\n        \'\'\' Print all info of layers in the network \'\'\'\n        for i, p in enumerate(self.all_layers):\n            print(""  layer %d: %s"" % (i, str(p)))\n\n    def count_params(self):\n        \'\'\' Return the number of parameters in the network \'\'\'\n        n_params = 0\n        for i, p in enumerate(self.all_params):\n            n = 1\n            # for s in p.eval().shape:\n            for s in p.get_shape():\n                try:\n                    s = int(s)\n                except:\n                    s = 1\n                if s:\n                    n = n * s\n            n_params = n_params + n\n        return n_params\n\n    def __str__(self):\n        # print(""\\nIt is a Layer class"")\n        # self.print_params(False)\n        # self.print_layers()\n        return ""  Last layer is: %s"" % self.__class__.__name__\n\n## Input layer\nclass InputLayer(Layer):\n    """"""\n    The :class:`InputLayer` class is the starting layer of a neural network.\n\n    Parameters\n    ----------\n    inputs : a placeholder or tensor\n        The input tensor data.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        inputs = None,\n        name =\'input_layer\'\n    ):\n        Layer.__init__(self, inputs=inputs, name=name)\n        print(""  [TL] InputLayer  %s: %s"" % (self.name, inputs.get_shape()))\n        self.outputs = inputs\n        self.all_layers = []\n        self.all_params = []\n        self.all_drop = {}\n\n## OneHot layer\nclass OneHotInputLayer(Layer):\n    """"""\n    The :class:`OneHotInputLayer` class is the starting layer of a neural network, see ``tf.one_hot``.\n\n    Parameters\n    ----------\n    inputs : a placeholder or tensor\n        The input tensor data.\n    name : a string or None\n        An optional name to attach to this layer.\n    depth : If the input indices is rank N, the output will have rank N+1. The new axis is created at dimension axis (default: the new axis is appended at the end).\n    on_value : If on_value is not provided, it will default to the value 1 with type dtype.\n        default, None\n    off_value : If off_value is not provided, it will default to the value 0 with type dtype.\n        default, None\n    axis : default, None\n    dtype : default, None\n    """"""\n    def __init__(\n        self,\n        inputs = None,\n        depth = None,\n        on_value = None,\n        off_value = None,\n        axis = None,\n        dtype=None,\n        name =\'input_layer\'\n    ):\n        Layer.__init__(self, inputs=inputs, name=name)\n        assert depth != None, ""depth is not given""\n        print(""  [TL]:Instantiate OneHotInputLayer  %s: %s"" % (self.name, inputs.get_shape()))\n        self.outputs = tf.one_hot(inputs, depth, on_value=on_value, off_value=off_value, axis=axis, dtype=dtype)\n        self.all_layers = []\n        self.all_params = []\n        self.all_drop = {}\n\n## Word Embedding Input layer\nclass Word2vecEmbeddingInputlayer(Layer):\n    """"""\n    The :class:`Word2vecEmbeddingInputlayer` class is a fully connected layer,\n    for Word Embedding. Words are input as integer index.\n    The output is the embedded word vector.\n\n    Parameters\n    ----------\n    inputs : placeholder\n        For word inputs. integer index format.\n    train_labels : placeholder\n        For word labels. integer index format.\n    vocabulary_size : int\n        The size of vocabulary, number of words.\n    embedding_size : int\n        The number of embedding dimensions.\n    num_sampled : int\n        The Number of negative examples for NCE loss.\n    nce_loss_args : a dictionary\n        The arguments for tf.nn.nce_loss()\n    E_init : embedding initializer\n        The initializer for initializing the embedding matrix.\n    E_init_args : a dictionary\n        The arguments for embedding initializer\n    nce_W_init : NCE decoder biases initializer\n        The initializer for initializing the nce decoder weight matrix.\n    nce_W_init_args : a dictionary\n        The arguments for initializing the nce decoder weight matrix.\n    nce_b_init : NCE decoder biases initializer\n        The initializer for tf.get_variable() of the nce decoder bias vector.\n    nce_b_init_args : a dictionary\n        The arguments for tf.get_variable() of the nce decoder bias vector.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Variables\n    --------------\n    nce_cost : a tensor\n        The NCE loss.\n    outputs : a tensor\n        The outputs of embedding layer.\n    normalized_embeddings : tensor\n        Normalized embedding matrix\n\n    Examples\n    --------\n    - Without TensorLayer : see tensorflow/examples/tutorials/word2vec/word2vec_basic.py\n    >>> train_inputs = tf.placeholder(tf.int32, shape=[batch_size])\n    >>> train_labels = tf.placeholder(tf.int32, shape=[batch_size, 1])\n    >>> embeddings = tf.Variable(\n    ...     tf.random_uniform([vocabulary_size, embedding_size], -1.0, 1.0))\n    >>> embed = tf.nn.embedding_lookup(embeddings, train_inputs)\n    >>> nce_weights = tf.Variable(\n    ...     tf.truncated_normal([vocabulary_size, embedding_size],\n    ...                    stddev=1.0 / math.sqrt(embedding_size)))\n    >>> nce_biases = tf.Variable(tf.zeros([vocabulary_size]))\n    >>> cost = tf.reduce_mean(\n    ...    tf.nn.nce_loss(weights=nce_weights, biases=nce_biases,\n    ...               inputs=embed, labels=train_labels,\n    ...               num_sampled=num_sampled, num_classes=vocabulary_size,\n    ...               num_true=1))\n\n    - With TensorLayer : see tutorial_word2vec_basic.py\n    >>> train_inputs = tf.placeholder(tf.int32, shape=[batch_size])\n    >>> train_labels = tf.placeholder(tf.int32, shape=[batch_size, 1])\n    >>> emb_net = tl.layers.Word2vecEmbeddingInputlayer(\n    ...         inputs = train_inputs,\n    ...         train_labels = train_labels,\n    ...         vocabulary_size = vocabulary_size,\n    ...         embedding_size = embedding_size,\n    ...         num_sampled = num_sampled,\n    ...        name =\'word2vec_layer\',\n    ...    )\n    >>> cost = emb_net.nce_cost\n    >>> train_params = emb_net.all_params\n    >>> train_op = tf.train.GradientDescentOptimizer(learning_rate).minimize(\n    ...                                             cost, var_list=train_params)\n    >>> normalized_embeddings = emb_net.normalized_embeddings\n\n    References\n    ----------\n    - `tensorflow/examples/tutorials/word2vec/word2vec_basic.py <https://github.com/tensorflow/tensorflow/blob/r0.7/tensorflow/examples/tutorials/word2vec/word2vec_basic.py>`_\n    """"""\n    def __init__(\n        self,\n        inputs = None,\n        train_labels = None,\n        vocabulary_size = 80000,\n        embedding_size = 200,\n        num_sampled = 64,\n        nce_loss_args = {},\n        E_init = tf.random_uniform_initializer(minval=-1.0, maxval=1.0),\n        E_init_args = {},\n        nce_W_init = tf.truncated_normal_initializer(stddev=0.03),\n        nce_W_init_args = {},\n        nce_b_init = tf.constant_initializer(value=0.0),\n        nce_b_init_args = {},\n        name =\'word2vec_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = inputs\n        print(""  [TL] Word2vecEmbeddingInputlayer %s: (%d, %d)"" % (self.name, vocabulary_size, embedding_size))\n        # Look up embeddings for inputs.\n        # Note: a row of \'embeddings\' is the vector representation of a word.\n        # for the sake of speed, it is better to slice the embedding matrix\n        # instead of transfering a word id to one-hot-format vector and then\n        # multiply by the embedding matrix.\n        # embed is the outputs of the hidden layer (embedding layer), it is a\n        # row vector with \'embedding_size\' values.\n        with tf.variable_scope(name) as vs:\n            embeddings = tf.get_variable(name=\'embeddings\',\n                                    shape=(vocabulary_size, embedding_size),\n                                    initializer=E_init,\n                                    **E_init_args)\n            embed = tf.nn.embedding_lookup(embeddings, self.inputs)\n            # Construct the variables for the NCE loss (i.e. negative sampling)\n            nce_weights = tf.get_variable(name=\'nce_weights\',\n                                    shape=(vocabulary_size, embedding_size),\n                                    initializer=nce_W_init,\n                                    **nce_W_init_args)\n            nce_biases = tf.get_variable(name=\'nce_biases\',\n                                    shape=(vocabulary_size),\n                                    initializer=nce_b_init,\n                                    **nce_b_init_args)\n\n        # Compute the average NCE loss for the batch.\n        # tf.nce_loss automatically draws a new sample of the negative labels\n        # each time we evaluate the loss.\n        self.nce_cost = tf.reduce_mean(\n            tf.nn.nce_loss(weights=nce_weights, biases=nce_biases,\n                           inputs=embed, labels=train_labels,\n                           num_sampled=num_sampled, num_classes=vocabulary_size,\n                           **nce_loss_args))\n\n        self.outputs = embed\n        self.normalized_embeddings = tf.nn.l2_normalize(embeddings, 1)\n\n        self.all_layers = [self.outputs]\n        self.all_params = [embeddings, nce_weights, nce_biases]\n        self.all_drop = {}\n\nclass EmbeddingInputlayer(Layer):\n    """"""\n    The :class:`EmbeddingInputlayer` class is a fully connected layer,\n    for Word Embedding. Words are input as integer index.\n    The output is the embedded word vector.\n\n    If you have a pre-train matrix, you can assign the matrix into it.\n    To train a word embedding matrix, you can used class:`Word2vecEmbeddingInputlayer`.\n\n    Note that, do not update this embedding matrix.\n\n    Parameters\n    ----------\n    inputs : placeholder\n        For word inputs. integer index format.\n        a 2D tensor : [batch_size, num_steps(num_words)]\n    vocabulary_size : int\n        The size of vocabulary, number of words.\n    embedding_size : int\n        The number of embedding dimensions.\n    E_init : embedding initializer\n        The initializer for initializing the embedding matrix.\n    E_init_args : a dictionary\n        The arguments for embedding initializer\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Variables\n    ------------\n    outputs : a tensor\n        The outputs of embedding layer.\n        the outputs 3D tensor : [batch_size, num_steps(num_words), embedding_size]\n\n    Examples\n    --------\n    >>> vocabulary_size = 50000\n    >>> embedding_size = 200\n    >>> model_file_name = ""model_word2vec_50k_200""\n    >>> batch_size = None\n    ...\n    >>> all_var = tl.files.load_npy_to_any(name=model_file_name+\'.npy\')\n    >>> data = all_var[\'data\']; count = all_var[\'count\']\n    >>> dictionary = all_var[\'dictionary\']\n    >>> reverse_dictionary = all_var[\'reverse_dictionary\']\n    >>> tl.files.save_vocab(count, name=\'vocab_\'+model_file_name+\'.txt\')\n    >>> del all_var, data, count\n    ...\n    >>> load_params = tl.files.load_npz(name=model_file_name+\'.npz\')\n    >>> x = tf.placeholder(tf.int32, shape=[batch_size])\n    >>> y_ = tf.placeholder(tf.int32, shape=[batch_size, 1])\n    >>> emb_net = tl.layers.EmbeddingInputlayer(\n    ...                inputs = x,\n    ...                vocabulary_size = vocabulary_size,\n    ...                embedding_size = embedding_size,\n    ...                name =\'embedding_layer\')\n    >>> tl.layers.initialize_global_variables(sess)\n    >>> tl.files.assign_params(sess, [load_params[0]], emb_net)\n    >>> word = b\'hello\'\n    >>> word_id = dictionary[word]\n    >>> print(\'word_id:\', word_id)\n    ... 6428\n    ...\n    >>> words = [b\'i\', b\'am\', b\'hao\', b\'dong\']\n    >>> word_ids = tl.files.words_to_word_ids(words, dictionary)\n    >>> context = tl.files.word_ids_to_words(word_ids, reverse_dictionary)\n    >>> print(\'word_ids:\', word_ids)\n    ... [72, 1226, 46744, 20048]\n    >>> print(\'context:\', context)\n    ... [b\'i\', b\'am\', b\'hao\', b\'dong\']\n    ...\n    >>> vector = sess.run(emb_net.outputs, feed_dict={x : [word_id]})\n    >>> print(\'vector:\', vector.shape)\n    ... (1, 200)\n    >>> vectors = sess.run(emb_net.outputs, feed_dict={x : word_ids})\n    >>> print(\'vectors:\', vectors.shape)\n    ... (4, 200)\n\n    """"""\n    def __init__(\n        self,\n        inputs = None,\n        vocabulary_size = 80000,\n        embedding_size = 200,\n        E_init = tf.random_uniform_initializer(-0.1, 0.1),\n        E_init_args = {},\n        name =\'embedding_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = inputs\n        print(""  [TL] EmbeddingInputlayer %s: (%d, %d)"" % (self.name, vocabulary_size, embedding_size))\n\n        with tf.variable_scope(name) as vs:\n            embeddings = tf.get_variable(name=\'embeddings\',\n                                    shape=(vocabulary_size, embedding_size),\n                                    initializer=E_init,\n                                    **E_init_args)\n            embed = tf.nn.embedding_lookup(embeddings, self.inputs)\n\n        self.outputs = embed\n\n        self.all_layers = [self.outputs]\n        self.all_params = [embeddings]\n        self.all_drop = {}\n\n## Dense layer\nclass DenseLayer(Layer):\n    """"""\n    The :class:`DenseLayer` class is a fully connected layer.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    n_units : int\n        The number of units of the layer.\n    act : activation function\n        The function that is applied to the layer activations.\n    W_init : weights initializer\n        The initializer for initializing the weight matrix.\n    b_init : biases initializer or None\n        The initializer for initializing the bias vector. If None, skip biases.\n    W_init_args : dictionary\n        The arguments for the weights tf.get_variable.\n    b_init_args : dictionary\n        The arguments for the biases tf.get_variable.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.DenseLayer(\n    ...                 network,\n    ...                 n_units=800,\n    ...                 act = tf.nn.relu,\n    ...                 W_init=tf.truncated_normal_initializer(stddev=0.1),\n    ...                 name =\'relu_layer\'\n    ...                 )\n\n    >>> Without TensorLayer, you can do as follow.\n    >>> W = tf.Variable(\n    ...     tf.random_uniform([n_in, n_units], -1.0, 1.0), name=\'W\')\n    >>> b = tf.Variable(tf.zeros(shape=[n_units]), name=\'b\')\n    >>> y = tf.nn.relu(tf.matmul(inputs, W) + b)\n\n    Notes\n    -----\n    If the input to this layer has more than two axes, it need to flatten the\n    input by using :class:`FlattenLayer` in this case.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        n_units = 100,\n        act = tf.identity,\n        W_init = tf.truncated_normal_initializer(stddev=0.1),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name =\'dense_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        if self.inputs.get_shape().ndims != 2:\n            raise Exception(""The input dimension must be rank 2, please reshape or flatten it"")\n\n        n_in = int(self.inputs.get_shape()[-1])\n        self.n_units = n_units\n        print(""  [TL] DenseLayer  %s: %d %s"" % (self.name, self.n_units, act.__name__))\n        with tf.variable_scope(name) as vs:\n            W = tf.get_variable(name=\'W\', shape=(n_in, n_units), initializer=W_init, **W_init_args )\n            if b_init:\n                b = tf.get_variable(name=\'b\', shape=(n_units), initializer=b_init, **b_init_args )\n                self.outputs = act(tf.matmul(self.inputs, W) + b)\n            else:\n                self.outputs = act(tf.matmul(self.inputs, W))\n\n        # Hint : list(), dict() is pass by value (shallow), without them, it is\n        # pass by reference.\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        if b_init:\n            self.all_params.extend( [W, b] )\n        else:\n            self.all_params.extend( [W] )\n\nclass ReconLayer(DenseLayer):\n    """"""\n    The :class:`ReconLayer` class is a reconstruction layer `DenseLayer` which\n    use to pre-train a `DenseLayer`.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    x_recon : tensorflow variable\n        The variables used for reconstruction.\n    name : a string or None\n        An optional name to attach to this layer.\n    n_units : int\n        The number of units of the layer, should be equal to x_recon\n    act : activation function\n        The activation function that is applied to the reconstruction layer.\n        Normally, for sigmoid layer, the reconstruction activation is sigmoid;\n        for rectifying layer, the reconstruction activation is softplus.\n\n    Examples\n    --------\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.DenseLayer(network, n_units=196,\n    ...                                 act=tf.nn.sigmoid, name=\'sigmoid1\')\n    >>> recon_layer1 = tl.layers.ReconLayer(network, x_recon=x, n_units=784,\n    ...                                 act=tf.nn.sigmoid, name=\'recon_layer1\')\n    >>> recon_layer1.pretrain(sess, x=x, X_train=X_train, X_val=X_val,\n    ...                         denoise_name=None, n_epoch=1200, batch_size=128,\n    ...                         print_freq=10, save=True, save_name=\'w1pre_\')\n\n    Methods\n    -------\n    pretrain(self, sess, x, X_train, X_val, denoise_name=None, n_epoch=100, batch_size=128, print_freq=10, save=True, save_name=\'w1pre_\')\n        Start to pre-train the parameters of previous DenseLayer.\n\n    Notes\n    -----\n    The input layer should be `DenseLayer` or a layer has only one axes.\n    You may need to modify this part to define your own cost function.\n    By default, the cost is implemented as follow:\n    - For sigmoid layer, the implementation can be `UFLDL <http://deeplearning.stanford.edu/wiki/index.php/UFLDL_Tutorial>`_\n    - For rectifying layer, the implementation can be `Glorot (2011). Deep Sparse Rectifier Neural Networks <http://doi.org/10.1.1.208.6449>`_\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        x_recon = None,\n        name = \'recon_layer\',\n        n_units = 784,\n        act = tf.nn.softplus,\n    ):\n        DenseLayer.__init__(self, layer=layer, n_units=n_units, act=act, name=name)\n        print(""     [TL] %s is a ReconLayer"" % self.name)\n\n        # y : reconstruction outputs; train_params : parameters to train\n        # Note that: train_params = [W_encoder, b_encoder, W_decoder, b_encoder]\n        y = self.outputs\n        self.train_params = self.all_params[-4:]\n\n        # =====================================================================\n        #\n        # You need to modify the below cost function and optimizer so as to\n        # implement your own pre-train method.\n        #\n        # =====================================================================\n        lambda_l2_w = 0.004\n        learning_rate = 0.0001\n        print(""     lambda_l2_w: %f"" % lambda_l2_w)\n        print(""     learning_rate: %f"" % learning_rate)\n\n        # Mean-squre-error i.e. quadratic-cost\n        mse = tf.reduce_sum(tf.squared_difference(y, x_recon),  1)\n        mse = tf.reduce_mean(mse)            # in theano: mse = ((y - x) ** 2 ).sum(axis=1).mean()\n            # mse = tf.reduce_mean(tf.reduce_sum(tf.square(tf.sub(y, x_recon)),  1))\n            # mse = tf.reduce_mean(tf.squared_difference(y, x_recon)) # <haodong>: Error\n            # mse = tf.sqrt(tf.reduce_mean(tf.square(y - x_recon)))   # <haodong>: Error\n        # Cross-entropy\n            # ce = cost.cross_entropy(y, x_recon)                                               # <haodong>: list , list , Error (only be used for softmax output)\n            # ce = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(y, x_recon))          # <haodong>: list , list , Error (only be used for softmax output)\n            # ce = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(y, x_recon))   # <haodong>: list , index , Error (only be used for softmax output)\n        L2_w = tf.contrib.layers.l2_regularizer(lambda_l2_w)(self.train_params[0]) \\\n                + tf.contrib.layers.l2_regularizer(lambda_l2_w)(self.train_params[2])           # faster than the code below\n            # L2_w = lambda_l2_w * tf.reduce_mean(tf.square(self.train_params[0])) + lambda_l2_w * tf.reduce_mean( tf.square(self.train_params[2]))\n        # DropNeuro\n        P_o = cost.lo_regularizer(0.03)(self.train_params[0])   # + cost.lo_regularizer(0.5)(self.train_params[2])    # <haodong>: if add lo on decoder, no neuron will be broken\n        P_i = cost.li_regularizer(0.03)(self.train_params[0])  # + cost.li_regularizer(0.001)(self.train_params[2])\n\n        # L1 of activation outputs\n        activation_out = self.all_layers[-2]\n        L1_a = 0.001 * tf.reduce_mean(activation_out)   # <haodong>:  theano: T.mean( self.a[i] )         # some neuron are broken, white and black\n            # L1_a = 0.001 * tf.reduce_mean( tf.reduce_sum(activation_out, 0) )         # <haodong>: some neuron are broken, white and black\n            # L1_a = 0.001 * 100 * tf.reduce_mean( tf.reduce_sum(activation_out, 1) )   # <haodong>: some neuron are broken, white and black\n        # KL Divergence\n        beta = 4\n        rho = 0.15\n        p_hat = tf.reduce_mean(activation_out, 0)   # theano: p_hat = T.mean( self.a[i], axis=0 )\n        try: ## TF1.0\n            KLD = beta * tf.reduce_sum( rho * tf.log(tf.divide(rho, p_hat)) + (1- rho) * tf.log((1- rho)/ (tf.subtract(float(1), p_hat))) )\n        except: ## TF0.12\n            KLD = beta * tf.reduce_sum( rho * tf.log(tf.div(rho, p_hat)) + (1- rho) * tf.log((1- rho)/ (tf.sub(float(1), p_hat))) )\n            # KLD = beta * tf.reduce_sum( rho * tf.log(rho/ p_hat) + (1- rho) * tf.log((1- rho)/(1- p_hat)) )\n            # theano: L1_a = l1_a[i] * T.sum( rho[i] * T.log(rho[i]/ p_hat) + (1- rho[i]) * T.log((1- rho[i])/(1- p_hat)) )\n        # Total cost\n        if act == tf.nn.softplus:\n            print(\'     use: mse, L2_w, L1_a\')\n            self.cost = mse + L1_a + L2_w\n        elif act == tf.nn.sigmoid:\n            # ----------------------------------------------------\n            # Cross-entropy was used in Denoising AE\n            # print(\'     use: ce, L2_w, KLD\')\n            # self.cost = ce + L2_w + KLD\n            # ----------------------------------------------------\n            # Mean-squared-error was used in Vanilla AE\n            print(\'     use: mse, L2_w, KLD\')\n            self.cost = mse + L2_w + KLD\n            # ----------------------------------------------------\n            # Add DropNeuro penalty (P_o) can remove neurons of AE\n            # print(\'     use: mse, L2_w, KLD, P_o\')\n            # self.cost = mse + L2_w + KLD + P_o\n            # ----------------------------------------------------\n            # Add DropNeuro penalty (P_i) can remove neurons of previous layer\n            #   If previous layer is InputLayer, it means remove useless features\n            # print(\'     use: mse, L2_w, KLD, P_i\')\n            # self.cost = mse + L2_w + KLD + P_i\n        else:\n            raise Exception(""Don\'t support the given reconstruct activation function"")\n\n        self.train_op = tf.train.AdamOptimizer(learning_rate, beta1=0.9, beta2=0.999,\n                                        epsilon=1e-08, use_locking=False).minimize(self.cost, var_list=self.train_params)\n                # self.train_op = tf.train.GradientDescentOptimizer(1.0).minimize(self.cost, var_list=self.train_params)\n\n    def pretrain(self, sess, x, X_train, X_val, denoise_name=None, n_epoch=100, batch_size=128, print_freq=10,\n                  save=True, save_name=\'w1pre_\'):\n        # ====================================================\n        #\n        # You need to modify the cost function in __init__() so as to\n        # get your own pre-train method.\n        #\n        # ====================================================\n        print(""     [*] %s start pretrain"" % self.name)\n        print(""     batch_size: %d"" % batch_size)\n        if denoise_name:\n            print(""     denoising layer keep: %f"" % self.all_drop[set_keep[denoise_name]])\n            dp_denoise = self.all_drop[set_keep[denoise_name]]\n        else:\n            print(""     no denoising layer"")\n\n        for epoch in range(n_epoch):\n            start_time = time.time()\n            for X_train_a, _ in iterate.minibatches(X_train, X_train, batch_size, shuffle=True):\n                dp_dict = utils.dict_to_one( self.all_drop )\n                if denoise_name:\n                    dp_dict[set_keep[denoise_name]] = dp_denoise\n                feed_dict = {x: X_train_a}\n                feed_dict.update(dp_dict)\n                sess.run(self.train_op, feed_dict=feed_dict)\n\n            if epoch + 1 == 1 or (epoch + 1) % print_freq == 0:\n                print(""Epoch %d of %d took %fs"" % (epoch + 1, n_epoch, time.time() - start_time))\n                train_loss, n_batch = 0, 0\n                for X_train_a, _ in iterate.minibatches(X_train, X_train, batch_size, shuffle=True):\n                    dp_dict = utils.dict_to_one( self.all_drop )\n                    feed_dict = {x: X_train_a}\n                    feed_dict.update(dp_dict)\n                    err = sess.run(self.cost, feed_dict=feed_dict)\n                    train_loss += err\n                    n_batch += 1\n                print(""   train loss: %f"" % (train_loss/ n_batch))\n                val_loss, n_batch = 0, 0\n                for X_val_a, _ in iterate.minibatches(X_val, X_val, batch_size, shuffle=True):\n                    dp_dict = utils.dict_to_one( self.all_drop )\n                    feed_dict = {x: X_val_a}\n                    feed_dict.update(dp_dict)\n                    err = sess.run(self.cost, feed_dict=feed_dict)\n                    val_loss += err\n                    n_batch += 1\n                print(""   val loss: %f"" % (val_loss/ n_batch))\n                if save:\n                    try:\n                        visualize.W(self.train_params[0].eval(), second=10, saveable=True, shape=[28,28], name=save_name+str(epoch+1), fig_idx=2012)\n                        files.save_npz([self.all_params[0]] , name=save_name+str(epoch+1)+\'.npz\')\n                    except:\n                        raise Exception(""You should change the visualize.W() in ReconLayer.pretrain(), if you want to save the feature images for different dataset"")\n\n## Noise layer\nclass DropoutLayer(Layer):\n    """"""\n    The :class:`DropoutLayer` class is a noise layer which randomly set some\n    values to zero by a given keeping probability.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    keep : float\n        The keeping probability, the lower more values will be set to zero.\n    is_fix : boolean\n        Default False, if True, the keeping probability is fixed and cannot be changed via feed_dict.\n    is_train : boolean\n        If False, skip this layer, default is True.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    - Define network\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.DropoutLayer(network, keep=0.8, name=\'drop1\')\n    >>> network = tl.layers.DenseLayer(network, n_units=800, act = tf.nn.relu, name=\'relu1\')\n    >>> ...\n\n    - For training, enable dropout as follow.\n    >>> feed_dict = {x: X_train_a, y_: y_train_a}\n    >>> feed_dict.update( network.all_drop )     # enable noise layers\n    >>> sess.run(train_op, feed_dict=feed_dict)\n    >>> ...\n\n    - For testing, disable dropout as follow.\n    >>> dp_dict = tl.utils.dict_to_one( network.all_drop ) # disable noise layers\n    >>> feed_dict = {x: X_val_a, y_: y_val_a}\n    >>> feed_dict.update(dp_dict)\n    >>> err, ac = sess.run([cost, acc], feed_dict=feed_dict)\n    >>> ...\n\n    Notes\n    -------\n    - A frequent question regarding :class:`DropoutLayer` is that why it donot have `is_train` like :class:`BatchNormLayer`.\n    In many simple cases, user may find it is better to use one inference instead of two inferences for training and testing seperately, :class:`DropoutLayer`\n    allows you to control the dropout rate via `feed_dict`. However, you can fix the keeping probability by setting `is_fix` to True.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        keep = 0.5,\n        is_fix = False,\n        is_train = True,\n        name = \'dropout_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        if is_train is False:\n            print(""  [TL] skip DropoutLayer"")\n            self.outputs = layer.outputs\n            self.all_layers = list(layer.all_layers)\n            self.all_params = list(layer.all_params)\n            self.all_drop = dict(layer.all_drop)\n        else:\n            self.inputs = layer.outputs\n            print(""  [TL] DropoutLayer %s: keep:%f is_fix:%s"" % (self.name, keep, is_fix))\n\n            # The name of placeholder for keep_prob is the same with the name\n            # of the Layer.\n            if is_fix:\n                self.outputs = tf.nn.dropout(self.inputs, keep, name=name)\n            else:\n                set_keep[name] = tf.placeholder(tf.float32)\n                self.outputs = tf.nn.dropout(self.inputs, set_keep[name], name=name) # 1.2\n\n            self.all_layers = list(layer.all_layers)\n            self.all_params = list(layer.all_params)\n            self.all_drop = dict(layer.all_drop)\n            if is_fix is False:\n                self.all_drop.update( {set_keep[name]: keep} )\n            self.all_layers.extend( [self.outputs] )\n\n        # print(set_keep[name])\n        #   Tensor(""Placeholder_2:0"", dtype=float32)\n        # print(denoising1)\n        #   Tensor(""Placeholder_2:0"", dtype=float32)\n        # print(self.all_drop[denoising1])\n        #   0.8\n        #\n        # https://www.tensorflow.org/versions/r0.8/tutorials/mnist/tf/index.html\n        # The optional feed_dict argument allows the caller to override the\n        # value of tensors in the graph. Each key in feed_dict can be one of\n        # the following types:\n        # If the key is a Tensor, the value may be a Python scalar, string,\n        # list, or numpy ndarray that can be converted to the same dtype as that\n        # tensor. Additionally, if the key is a placeholder, the shape of the\n        # value will be checked for compatibility with the placeholder.\n        # If the key is a SparseTensor, the value should be a SparseTensorValue.\n\nclass GaussianNoiseLayer(Layer):\n    """"""\n    The :class:`GaussianNoiseLayer` class is noise layer that adding noise with\n    normal distribution to the activation.\n\n    Parameters\n    ------------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    mean : float\n    stddev : float\n    is_train : boolean\n        If False, skip this layer, default is True.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        mean = 0.0,\n        stddev = 1.0,\n        is_train = True,\n        name = \'gaussian_noise_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        if is_train is False:\n            print(""  [TL] skip GaussianNoiseLayer"")\n            self.outputs = layer.outputs\n            self.all_layers = list(layer.all_layers)\n            self.all_params = list(layer.all_params)\n            self.all_drop = dict(layer.all_drop)\n        else:\n            self.inputs = layer.outputs\n            print(""  [TL] GaussianNoiseLayer %s: mean:%f stddev:%f"" % (self.name, mean, stddev))\n            with tf.variable_scope(name) as vs:\n                # noise = np.random.normal(0.0 , sigma , tf.to_int64(self.inputs).get_shape())\n                noise = tf.random_normal(shape = self.inputs.get_shape(), mean=mean, stddev=stddev)\n                self.outputs = self.inputs + noise\n            self.all_layers = list(layer.all_layers)\n            self.all_params = list(layer.all_params)\n            self.all_drop = dict(layer.all_drop)\n\nclass DropconnectDenseLayer(Layer):\n    """"""\n    The :class:`DropconnectDenseLayer` class is ``DenseLayer`` with DropConnect\n    behaviour which randomly remove connection between this layer to previous\n    layer by a given keeping probability.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    keep : float\n        The keeping probability, the lower more values will be set to zero.\n    n_units : int\n        The number of units of the layer.\n    act : activation function\n        The function that is applied to the layer activations.\n    W_init : weights initializer\n        The initializer for initializing the weight matrix.\n    b_init : biases initializer\n        The initializer for initializing the bias vector.\n    W_init_args : dictionary\n        The arguments for the weights tf.get_variable().\n    b_init_args : dictionary\n        The arguments for the biases tf.get_variable().\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.DropconnectDenseLayer(network, keep = 0.8,\n    ...         n_units=800, act = tf.nn.relu, name=\'dropconnect_relu1\')\n    >>> network = tl.layers.DropconnectDenseLayer(network, keep = 0.5,\n    ...         n_units=800, act = tf.nn.relu, name=\'dropconnect_relu2\')\n    >>> network = tl.layers.DropconnectDenseLayer(network, keep = 0.5,\n    ...         n_units=10, act = tl.activation.identity, name=\'output_layer\')\n\n    References\n    ----------\n    - `Wan, L. (2013). Regularization of neural networks using dropconnect <http://machinelearning.wustl.edu/mlpapers/papers/icml2013_wan13>`_\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        keep = 0.5,\n        n_units = 100,\n        act = tf.identity,\n        W_init = tf.truncated_normal_initializer(stddev=0.1),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name =\'dropconnect_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        if self.inputs.get_shape().ndims != 2:\n            raise Exception(""The input dimension must be rank 2"")\n        n_in = int(self.inputs.get_shape()[-1])\n        self.n_units = n_units\n        print(""  [TL] DropconnectDenseLayer %s: %d %s"" % (self.name, self.n_units, act.__name__))\n\n        with tf.variable_scope(name) as vs:\n            W = tf.get_variable(name=\'W\', shape=(n_in, n_units), initializer=W_init, **W_init_args )\n            b = tf.get_variable(name=\'b\', shape=(n_units), initializer=b_init, **b_init_args )\n            self.outputs = act(tf.matmul(self.inputs, W) + b)#, name=name)    # 1.2\n\n        set_keep[name] = tf.placeholder(tf.float32)\n        W_dropcon = tf.nn.dropout(W,  set_keep[name])\n        self.outputs = act(tf.matmul(self.inputs, W_dropcon) + b)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_drop.update( {set_keep[name]: keep} )\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( [W, b] )\n\n## Convolutional layer (Pro)\n\nclass Conv1dLayer(Layer):\n    """"""\n    The :class:`Conv1dLayer` class is a 1D CNN layer, see `tf.nn.conv1d <https://www.tensorflow.org/versions/master/api_docs/python/nn.html#conv1d>`_.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer, [batch, in_width, in_channels].\n    act : activation function, None for identity.\n    shape : list of shape\n        shape of the filters, [filter_length, in_channels, out_channels].\n    stride : an int.\n        The number of entries by which the filter is moved right at each step.\n    padding : a string from: ""SAME"", ""VALID"".\n        The type of padding algorithm to use.\n    use_cudnn_on_gpu : An optional bool. Defaults to True.\n    data_format : An optional string from ""NHWC"", ""NCHW"". Defaults to ""NHWC"", the data is stored in the order of [batch, in_width, in_channels]. The ""NCHW"" format stores data as [batch, in_channels, in_width].\n    W_init : weights initializer\n        The initializer for initializing the weight matrix.\n    b_init : biases initializer or None\n        The initializer for initializing the bias vector. If None, skip biases.\n    W_init_args : dictionary\n        The arguments for the weights tf.get_variable().\n    b_init_args : dictionary\n        The arguments for the biases tf.get_variable().\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        act = tf.identity,\n        shape = [5, 1, 5],\n        stride = 1,\n        padding=\'SAME\',\n        use_cudnn_on_gpu=None,\n        data_format=None,\n        W_init = tf.truncated_normal_initializer(stddev=0.02),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name =\'cnn_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] Conv1dLayer %s: shape:%s stride:%s pad:%s act:%s"" %\n                            (self.name, str(shape), str(stride), padding, act.__name__))\n        if act is None:\n            act = tf.identity\n        with tf.variable_scope(name) as vs:\n            W = tf.get_variable(name=\'W_conv1d\', shape=shape, initializer=W_init, **W_init_args )\n            if b_init:\n                b = tf.get_variable(name=\'b_conv1d\', shape=(shape[-1]), initializer=b_init, **b_init_args )\n                self.outputs = act( tf.nn.conv1d(self.inputs, W, stride=stride, padding=padding,\n                            use_cudnn_on_gpu=use_cudnn_on_gpu, data_format=data_format) + b ) #1.2\n            else:\n                self.outputs = act( tf.nn.conv1d(self.inputs, W, stride=stride, padding=padding,\n                            use_cudnn_on_gpu=use_cudnn_on_gpu, data_format=data_format))\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        if b_init:\n            self.all_params.extend( [W, b] )\n        else:\n            self.all_params.extend( [W] )\n\nclass Conv2dLayer(Layer):\n    """"""\n    The :class:`Conv2dLayer` class is a 2D CNN layer, see `tf.nn.conv2d <https://www.tensorflow.org/versions/master/api_docs/python/nn.html#conv2d>`_.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    act : activation function\n        The function that is applied to the layer activations.\n    shape : list of shape\n        shape of the filters, [filter_height, filter_width, in_channels, out_channels].\n    strides : a list of ints.\n        The stride of the sliding window for each dimension of input.\\n\n        It Must be in the same order as the dimension specified with format.\n    padding : a string from: ""SAME"", ""VALID"".\n        The type of padding algorithm to use.\n    W_init : weights initializer\n        The initializer for initializing the weight matrix.\n    b_init : biases initializer or None\n        The initializer for initializing the bias vector. If None, skip biases.\n    W_init_args : dictionary\n        The arguments for the weights tf.get_variable().\n    b_init_args : dictionary\n        The arguments for the biases tf.get_variable().\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Notes\n    ------\n    - shape = [h, w, the number of output channel of previous layer, the number of output channels]\n    - the number of output channel of a layer is its last dimension.\n\n    Examples\n    --------\n    >>> x = tf.placeholder(tf.float32, shape=[None, 28, 28, 1])\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.Conv2dLayer(network,\n    ...                   act = tf.nn.relu,\n    ...                   shape = [5, 5, 1, 32],  # 32 features for each 5x5 patch\n    ...                   strides=[1, 1, 1, 1],\n    ...                   padding=\'SAME\',\n    ...                   W_init=tf.truncated_normal_initializer(stddev=5e-2),\n    ...                   W_init_args={},\n    ...                   b_init = tf.constant_initializer(value=0.0),\n    ...                   b_init_args = {},\n    ...                   name =\'cnn_layer1\')     # output: (?, 28, 28, 32)\n    >>> network = tl.layers.PoolLayer(network,\n    ...                   ksize=[1, 2, 2, 1],\n    ...                   strides=[1, 2, 2, 1],\n    ...                   padding=\'SAME\',\n    ...                   pool = tf.nn.max_pool,\n    ...                   name =\'pool_layer1\',)   # output: (?, 14, 14, 32)\n\n    >>> Without TensorLayer, you can implement 2d convolution as follow.\n    >>> W = tf.Variable(W_init(shape=[5, 5, 1, 32], ), name=\'W_conv\')\n    >>> b = tf.Variable(b_init(shape=[32], ), name=\'b_conv\')\n    >>> outputs = tf.nn.relu( tf.nn.conv2d(inputs, W,\n    ...                       strides=[1, 1, 1, 1],\n    ...                       padding=\'SAME\') + b )\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        act = tf.identity,\n        shape = [5, 5, 1, 100],\n        strides=[1, 1, 1, 1],\n        padding=\'SAME\',\n        W_init = tf.truncated_normal_initializer(stddev=0.02),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name =\'cnn_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] Conv2dLayer %s: shape:%s strides:%s pad:%s act:%s"" %\n                            (self.name, str(shape), str(strides), padding, act.__name__))\n\n        with tf.variable_scope(name) as vs:\n            W = tf.get_variable(name=\'W_conv2d\', shape=shape, initializer=W_init, **W_init_args )\n            if b_init:\n                b = tf.get_variable(name=\'b_conv2d\', shape=(shape[-1]), initializer=b_init, **b_init_args )\n                self.outputs = act( tf.nn.conv2d(self.inputs, W, strides=strides, padding=padding) + b ) #1.2\n            else:\n                self.outputs = act( tf.nn.conv2d(self.inputs, W, strides=strides, padding=padding))\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        if b_init:\n            self.all_params.extend( [W, b] )\n        else:\n            self.all_params.extend( [W] )\n\nclass DeConv2dLayer(Layer):\n    """"""\n    The :class:`DeConv2dLayer` class is deconvolutional 2D layer, see `tf.nn.conv2d_transpose <https://www.tensorflow.org/versions/master/api_docs/python/nn.html#conv2d_transpose>`_.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    act : activation function\n        The function that is applied to the layer activations.\n    shape : list of shape\n        shape of the filters, [height, width, output_channels, in_channels], filter\'s in_channels dimension must match that of value.\n    output_shape : list of output shape\n        representing the output shape of the deconvolution op.\n    strides : a list of ints.\n        The stride of the sliding window for each dimension of the input tensor.\n    padding : a string from: ""SAME"", ""VALID"".\n        The type of padding algorithm to use.\n    W_init : weights initializer\n        The initializer for initializing the weight matrix.\n    b_init : biases initializer\n        The initializer for initializing the bias vector. If None, skip biases.\n    W_init_args : dictionary\n        The arguments for the weights initializer.\n    b_init_args : dictionary\n        The arguments for the biases initializer.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Notes\n    -----\n    - shape = [h, w, the number of output channels of this layer, the number of output channel of previous layer]\n    - output_shape = [batch_size, any, any, the number of output channels of this layer]\n    - the number of output channel of a layer is its last dimension.\n\n    Examples\n    ---------\n    - A part of the generator in DCGAN example\n    >>> batch_size = 64\n    >>> inputs = tf.placeholder(tf.float32, [batch_size, 100], name=\'z_noise\')\n    >>> net_in = tl.layers.InputLayer(inputs, name=\'g/in\')\n    >>> net_h0 = tl.layers.DenseLayer(net_in, n_units = 8192,\n    ...                            W_init = tf.random_normal_initializer(stddev=0.02),\n    ...                            act = tf.identity, name=\'g/h0/lin\')\n    >>> print(net_h0.outputs._shape)\n    ... (64, 8192)\n    >>> net_h0 = tl.layers.ReshapeLayer(net_h0, shape = [-1, 4, 4, 512], name=\'g/h0/reshape\')\n    >>> net_h0 = tl.layers.BatchNormLayer(net_h0, act=tf.nn.relu, is_train=is_train, name=\'g/h0/batch_norm\')\n    >>> print(net_h0.outputs._shape)\n    ... (64, 4, 4, 512)\n    >>> net_h1 = tl.layers.DeConv2dLayer(net_h0,\n    ...                            shape = [5, 5, 256, 512],\n    ...                            output_shape = [batch_size, 8, 8, 256],\n    ...                            strides=[1, 2, 2, 1],\n    ...                            act=tf.identity, name=\'g/h1/decon2d\')\n    >>> net_h1 = tl.layers.BatchNormLayer(net_h1, act=tf.nn.relu, is_train=is_train, name=\'g/h1/batch_norm\')\n    >>> print(net_h1.outputs._shape)\n    ... (64, 8, 8, 256)\n\n    - U-Net\n    >>> ....\n    >>> conv10 = tl.layers.Conv2dLayer(conv9, act=tf.nn.relu,\n    ...        shape=[3,3,1024,1024], strides=[1,1,1,1], padding=\'SAME\',\n    ...        W_init=w_init, b_init=b_init, name=\'conv10\')\n    >>> print(conv10.outputs)\n    ... (batch_size, 32, 32, 1024)\n    >>> deconv1 = tl.layers.DeConv2dLayer(conv10, act=tf.nn.relu,\n    ...         shape=[3,3,512,1024], strides=[1,2,2,1], output_shape=[batch_size,64,64,512],\n    ...         padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'devcon1_1\')\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        act = tf.identity,\n        shape = [3, 3, 128, 256],\n        output_shape = [1, 256, 256, 128],\n        strides = [1, 2, 2, 1],\n        padding = \'SAME\',\n        W_init = tf.truncated_normal_initializer(stddev=0.02),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name =\'decnn2d_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] DeConv2dLayer %s: shape:%s out_shape:%s strides:%s pad:%s act:%s"" %\n                            (self.name, str(shape), str(output_shape), str(strides), padding, act.__name__))\n        # print(""  DeConv2dLayer: Untested"")\n        with tf.variable_scope(name) as vs:\n            W = tf.get_variable(name=\'W_deconv2d\', shape=shape, initializer=W_init, **W_init_args )\n            if b_init:\n                b = tf.get_variable(name=\'b_deconv2d\', shape=(shape[-2]), initializer=b_init, **b_init_args )\n                self.outputs = act( tf.nn.conv2d_transpose(self.inputs, W, output_shape=output_shape, strides=strides, padding=padding) + b )\n            else:\n                self.outputs = act( tf.nn.conv2d_transpose(self.inputs, W, output_shape=output_shape, strides=strides, padding=padding))\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        if b_init:\n            self.all_params.extend( [W, b] )\n        else:\n            self.all_params.extend( [W] )\n\nclass Conv3dLayer(Layer):\n    """"""\n    The :class:`Conv3dLayer` class is a 3D CNN layer, see `tf.nn.conv3d <https://www.tensorflow.org/versions/master/api_docs/python/nn.html#conv3d>`_.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    act : activation function\n        The function that is applied to the layer activations.\n    shape : list of shape\n        shape of the filters, [filter_depth, filter_height, filter_width, in_channels, out_channels].\n    strides : a list of ints. 1-D of length 4.\n        The stride of the sliding window for each dimension of input. Must be in the same order as the dimension specified with format.\n    padding : a string from: ""SAME"", ""VALID"".\n        The type of padding algorithm to use.\n    W_init : weights initializer\n        The initializer for initializing the weight matrix.\n    b_init : biases initializer\n        The initializer for initializing the bias vector.\n    W_init_args : dictionary\n        The arguments for the weights initializer.\n    b_init_args : dictionary\n        The arguments for the biases initializer.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        act = tf.identity,\n        shape = [2, 2, 2, 64, 128],\n        strides=[1, 2, 2, 2, 1],\n        padding=\'SAME\',\n        W_init = tf.truncated_normal_initializer(stddev=0.02),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name =\'cnn3d_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] Conv3dLayer %s: shape:%s strides:%s pad:%s act:%s"" % (self.name, str(shape), str(strides), padding, act.__name__))\n\n        with tf.variable_scope(name) as vs:\n            # W = tf.Variable(W_init(shape=shape, **W_init_args), name=\'W_conv\')\n            # b = tf.Variable(b_init(shape=[shape[-1]], **b_init_args), name=\'b_conv\')\n            W = tf.get_variable(name=\'W_conv3d\', shape=shape, initializer=W_init, **W_init_args )\n            b = tf.get_variable(name=\'b_conv3d\', shape=(shape[-1]), initializer=b_init, **b_init_args )\n            self.outputs = act( tf.nn.conv3d(self.inputs, W, strides=strides, padding=padding, name=None) + b )\n\n        # self.outputs = act( tf.nn.conv3d(self.inputs, W, strides=strides, padding=padding, name=None) + b )\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( [W, b] )\n\nclass DeConv3dLayer(Layer):\n    """"""The :class:`DeConv3dLayer` class is deconvolutional 3D layer, see `tf.nn.conv3d_transpose <https://www.tensorflow.org/versions/master/api_docs/python/nn.html#conv3d_transpose>`_.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    act : activation function\n        The function that is applied to the layer activations.\n    shape : list of shape\n        shape of the filters, [depth, height, width, output_channels, in_channels], filter\'s in_channels dimension must match that of value.\n    output_shape : list of output shape\n        representing the output shape of the deconvolution op.\n    strides : a list of ints.\n        The stride of the sliding window for each dimension of the input tensor.\n    padding : a string from: ""SAME"", ""VALID"".\n        The type of padding algorithm to use.\n    W_init : weights initializer\n        The initializer for initializing the weight matrix.\n    b_init : biases initializer\n        The initializer for initializing the bias vector.\n    W_init_args : dictionary\n        The arguments for the weights initializer.\n    b_init_args : dictionary\n        The arguments for the biases initializer.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        act = tf.identity,\n        shape = [2, 2, 2, 128, 256],\n        output_shape = [1, 12, 32, 32, 128],\n        strides = [1, 2, 2, 2, 1],\n        padding = \'SAME\',\n        W_init = tf.truncated_normal_initializer(stddev=0.02),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name =\'decnn3d_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] DeConv3dLayer %s: shape:%s out_shape:%s strides:%s pad:%s act:%s"" %\n                            (self.name, str(shape), str(output_shape), str(strides), padding, act.__name__))\n\n        with tf.variable_scope(name) as vs:\n            W = tf.get_variable(name=\'W_deconv3d\', shape=shape, initializer=W_init, **W_init_args )\n            b = tf.get_variable(name=\'b_deconv3d\', shape=(shape[-2]), initializer=b_init, **b_init_args )\n\n            self.outputs = act( tf.nn.conv3d_transpose(self.inputs, W, output_shape=output_shape, strides=strides, padding=padding) + b )\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( [W, b] )\n\nclass UpSampling2dLayer(Layer):\n    """"""The :class:`UpSampling2dLayer` class is upSampling 2d layer, see `tf.image.resize_images <https://www.tensorflow.org/versions/master/api_docs/python/image/resizing#resize_images>`_.\n\n    Parameters\n    -----------\n    layer : a layer class with 4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor of shape [height, width, channels].\n    size : a tupe of int or float.\n        (height, width) scale factor or new size of height and width.\n    is_scale : boolean, if True (default), size is scale factor, otherwise, size is number of pixels of height and width.\n    method : 0, 1, 2, 3. ResizeMethod. Defaults to ResizeMethod.BILINEAR.\n        - ResizeMethod.BILINEAR, Bilinear interpolation.\n        - ResizeMethod.NEAREST_NEIGHBOR, Nearest neighbor interpolation.\n        - ResizeMethod.BICUBIC, Bicubic interpolation.\n        - ResizeMethod.AREA, Area interpolation.\n    align_corners : bool. If true, exactly align all 4 corners of the input and output. Defaults to false.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        size = [],\n        is_scale = True,\n        method = 0,\n        align_corners = False,\n        name =\'upsample2d_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        if len(self.inputs.get_shape()) == 3:\n            if is_scale:\n                size_h = size[0] * int(self.inputs.get_shape()[0])\n                size_w = size[1] * int(self.inputs.get_shape()[1])\n                size = [size_h, size_w]\n        elif len(self.inputs.get_shape()) == 4:\n            if is_scale:\n                size_h = size[0] * int(self.inputs.get_shape()[1])\n                size_w = size[1] * int(self.inputs.get_shape()[2])\n                size = [size_h, size_w]\n        else:\n            raise Exception(""Donot support shape %s"" % self.inputs.get_shape())\n        print(""  [TL] UpSampling2dLayer %s: is_scale:%s size:%s method:%d align_corners:%s"" %\n                                (name, is_scale, size, method, align_corners))\n        with tf.variable_scope(name) as vs:\n            try:\n                self.outputs = tf.image.resize_images(self.inputs, size=size, method=method, align_corners=align_corners)\n            except: # for TF 0.10\n                self.outputs = tf.image.resize_images(self.inputs, new_height=size[0], new_width=size[1], method=method, align_corners=align_corners)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n\nclass DownSampling2dLayer(Layer):\n    """"""The :class:`DownSampling2dLayer` class is downSampling 2d layer, see `tf.image.resize_images <https://www.tensorflow.org/versions/master/api_docs/python/image/resizing#resize_images>`_.\n\n    Parameters\n    -----------\n    layer : a layer class with 4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor of shape [height, width, channels].\n    size : a tupe of int or float.\n        (height, width) scale factor or new size of height and width.\n    is_scale : boolean, if True (default), size is scale factor, otherwise, size is number of pixels of height and width.\n    method : 0, 1, 2, 3. ResizeMethod. Defaults to ResizeMethod.BILINEAR.\n        - ResizeMethod.BILINEAR, Bilinear interpolation.\n        - ResizeMethod.NEAREST_NEIGHBOR, Nearest neighbor interpolation.\n        - ResizeMethod.BICUBIC, Bicubic interpolation.\n        - ResizeMethod.AREA, Area interpolation.\n    align_corners : bool. If true, exactly align all 4 corners of the input and output. Defaults to false.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        size = [],\n        is_scale = True,\n        method = 0,\n        align_corners = False,\n        name =\'downsample2d_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        if len(self.inputs.get_shape()) == 3:\n            if is_scale:\n                size_h = size[0] * int(self.inputs.get_shape()[0])\n                size_w = size[1] * int(self.inputs.get_shape()[1])\n                size = [size_h, size_w]\n        elif len(self.inputs.get_shape()) == 4:\n            if is_scale:\n                size_h = size[0] * int(self.inputs.get_shape()[1])\n                size_w = size[1] * int(self.inputs.get_shape()[2])\n                size = [size_h, size_w]\n        else:\n            raise Exception(""Donot support shape %s"" % self.inputs.get_shape())\n        print(""  [TL] DownSampling2dLayer %s: is_scale:%s size:%s method:%d, align_corners:%s"" %\n                                (name, is_scale, size, method, align_corners))\n        with tf.variable_scope(name) as vs:\n            try:\n                self.outputs = tf.image.resize_images(self.inputs, size=size, method=method, align_corners=align_corners)\n            except: # for TF 0.10\n                self.outputs = tf.image.resize_images(self.inputs, new_height=size[0], new_width=size[1], method=method, align_corners=align_corners)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n\nclass AtrousConv2dLayer(Layer):\n    """"""The :class:`AtrousConv2dLayer` class is Atrous convolution (a.k.a. convolution with holes or dilated convolution) 2D layer, see `tf.nn.atrous_conv2d <https://www.tensorflow.org/versions/master/api_docs/python/nn.html#atrous_conv2d>`_.\n\n    Parameters\n    -----------\n    layer : a layer class with 4-D Tensor of shape [batch, height, width, channels].\n    filters : A 4-D Tensor with the same type as value and shape [filter_height, filter_width, in_channels, out_channels]. filters\' in_channels dimension must match that of value. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height filter_height + (filter_height - 1) * (rate - 1) and effective width filter_width + (filter_width - 1) * (rate - 1), produced by inserting rate - 1 zeros along consecutive elements across the filters\' spatial dimensions.\n    n_filter : number of filter.\n    filter_size : tuple (height, width) for filter size.\n    rate : A positive int32. The stride with which we sample input values across the height and width dimensions. Equivalently, the rate by which we upsample the filter values by inserting zeros across the height and width dimensions. In the literature, the same parameter is sometimes called input stride or dilation.\n    act : activation function, None for linear.\n    padding : A string, either \'VALID\' or \'SAME\'. The padding algorithm.\n    W_init : weights initializer. The initializer for initializing the weight matrix.\n    b_init : biases initializer or None. The initializer for initializing the bias vector. If None, skip biases.\n    W_init_args : dictionary. The arguments for the weights tf.get_variable().\n    b_init_args : dictionary. The arguments for the biases tf.get_variable().\n    name : a string or None, an optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        n_filter = 32,\n        filter_size = (3,3),\n        rate = 2,\n        act = None,\n        padding = \'SAME\',\n        W_init = tf.truncated_normal_initializer(stddev=0.02),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {},\n        b_init_args = {},\n        name = \'atrou2d\'\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] AtrousConv2dLayer %s: n_filter:%d filter_size:%s rate:%d pad:%s act:%s"" %\n                            (self.name, n_filter, filter_size, rate, padding, act.__name__))\n        if act is None:\n            act = tf.identity\n        with tf.variable_scope(name) as vs:\n            shape = [filter_size[0], filter_size[1], int(self.inputs.get_shape()[-1]), n_filter]\n            filters = tf.get_variable(name=\'filter\', shape=shape, initializer=W_init, **W_init_args )\n            if b_init:\n                b = tf.get_variable(name=\'b\', shape=(n_filter), initializer=b_init, **b_init_args )\n                self.outputs = act(tf.nn.atrous_conv2d(self.inputs, filters, rate, padding) + b)\n            else:\n                self.outputs = act(tf.nn.atrous_conv2d(self.inputs, filters, rate, padding))\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        if b_init:\n            self.all_params.extend( [filters, b] )\n        else:\n            self.all_params.extend( [filters] )\n\nclass SeparableConv2dLayer(Layer):# Untested\n    """"""The :class:`SeparableConv2dLayer` class is 2-D convolution with separable filters, see `tf.layers.separable_conv2d <https://www.tensorflow.org/api_docs/python/tf/layers/separable_conv2d>`_.\n\n    Parameters\n    -----------\n    layer : a layer class\n    filters : integer, the dimensionality of the output space (i.e. the number output of filters in the convolution).\n    kernel_size : a tuple or list of N positive integers specifying the spatial dimensions of of the filters. Can be a single integer to specify the same value for all spatial dimensions.\n    strides : a tuple or list of N positive integers specifying the strides of the convolution. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1.\n    padding : one of ""valid"" or ""same"" (case-insensitive).\n    data_format : A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shapedata_format = \'NWHC\' (batch, width, height, channels) while channels_first corresponds to inputs with shape (batch, channels, width, height).\n    dilation_rate : an integer or tuple/list of 2 integers, specifying the dilation rate to use for dilated convolution. Can be a single integer to specify the same value for all spatial dimensions. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any stride value != 1.\n    depth_multiplier : The number of depthwise convolution output channels for each input channel. The total number of depthwise convolution output channels will be equal to num_filters_in * depth_multiplier.\n    act (activation) : Activation function. Set it to None to maintain a linear activation.\n    use_bias : Boolean, whether the layer uses a bias.\n    depthwise_initializer : An initializer for the depthwise convolution kernel.\n    pointwise_initializer : An initializer for the pointwise convolution kernel.\n    bias_initializer : An initializer for the bias vector. If None, no bias will be applied.\n    depthwise_regularizer : Optional regularizer for the depthwise convolution kernel.\n    pointwise_regularizer : Optional regularizer for the pointwise convolution kernel.\n    bias_regularizer : Optional regularizer for the bias vector.\n    activity_regularizer : Regularizer function for the output.\n    name : a string or None, an optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        filters = None,\n        kernel_size=5,\n        strides=(1, 1),\n        padding=\'valid\',\n        data_format=\'channels_last\',\n        dilation_rate=(1, 1),\n        depth_multiplier=1,\n        act=None,\n        use_bias=True,\n        depthwise_initializer=None,\n        pointwise_initializer=None,\n        bias_initializer=tf.zeros_initializer,\n        depthwise_regularizer=None,\n        pointwise_regularizer=None,\n        bias_regularizer=None,\n        activity_regularizer=None,\n        name = \'atrou2d\'\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        assert filters is not None\n        assert tf.__version__ > ""0.12.1"", ""This layer only supports for TF 1.0+""\n        if act is None:\n            act = tf.identity\n\n        bias_initializer = bias_initializer()\n\n        print(""  [TL] SeparableConv2dLayer %s: filters:%s kernel_size:%s strides:%s padding:%s dilation_rate:%s depth_multiplier:%s act:%s"" %\n                            (self.name, str(filters), str(kernel_size), str(strides), padding, str(dilation_rate), str(depth_multiplier), act.__name__))\n\n        with tf.variable_scope(name) as vs:\n            self.outputs = tf.layers.separable_conv2d(self.inputs, filters, kernel_size,\n                 strides=strides, padding=padding, data_format=data_format,\n                 dilation_rate=dilation_rate, depth_multiplier=depth_multiplier, activation=act,\n                 use_bias=use_bias, depthwise_initializer=depthwise_initializer, pointwise_initializer=pointwise_initializer,\n                 bias_initializer=bias_initializer, depthwise_regularizer=depthwise_regularizer,\n                 pointwise_regularizer=pointwise_regularizer, bias_regularizer=bias_regularizer, activity_regularizer=activity_regularizer,)\n                 #trainable=True, name=None, reuse=None)\n\n            variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( variables )\n\n## Initializers for Convuolutional Layers\ndef deconv2d_bilinear_upsampling_initializer(shape):\n    """"""Returns initializer that can be passed to DeConv2dLayer to initalize the\n    weights to correspond to channel wise bilinear upsampling.\n    Used in some segmantic segmentation approches such as [FCN](https://arxiv.org/abs/1605.06211)\n\n    Parameters\n    ----------\n        shape : list of shape\n            shape of the filters, [height, width, output_channels, in_channels], must match that passed to DeConv2dLayer\n\n    Returns\n    ----------\n        tf.constant_initializer\n            with weights set to correspond to per channel bilinear upsampling when passed as W_int in DeConv2dLayer\n\n    Examples\n    --------\n    >>> rescale_factor = 2 #upsampling by a factor of 2, ie e.g 100->200\n    >>> filter_size = (2 * rescale_factor - rescale_factor % 2) #Corresponding bilinear filter size\n    >>> num_in_channels = 3\n    >>> num_out_channels = 3\n    >>> deconv_filter_shape = [filter_size, filter_size, num_out_channels, num_in_channels]\n    >>> x = tf.placeholder(tf.float32, [1, imsize, imsize, num_channels])\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> bilinear_init = deconv2d_bilinear_upsampling_initializer(shape=filter_shape)\n    >>> network = tl.layers.DeConv2dLayer(network,\n                            shape = filter_shape,\n                            output_shape = [1, imsize*rescale_factor, imsize*rescale_factor, num_out_channels],\n                            strides=[1, rescale_factor, rescale_factor, 1],\n                            W_init=bilinear_init,\n                            padding=\'SAME\',\n                            act=tf.identity, name=\'g/h1/decon2d\')\n    """"""\n    if shape[0] != shape[1]:\n        raise Exception(\'deconv2d_bilinear_upsampling_initializer only supports symmetrical filter sizes\')\n    if shape[3] < shape [2]:\n        raise Exception(\'deconv2d_bilinear_upsampling_initializer behaviour is not defined for num_in_channels < num_out_channels \')\n\n    filter_size = shape[0]\n    num_out_channels = shape[2]\n    num_in_channels = shape[3]\n\n    #Create bilinear filter kernel as numpy array\n    bilinear_kernel = np.zeros([filter_size, filter_size], dtype=np.float32)\n    scale_factor = (filter_size + 1) // 2\n    if filter_size % 2 == 1:\n        center = scale_factor - 1\n    else:\n        center = scale_factor - 0.5\n    for x in range(filter_size):\n        for y in range(filter_size):\n            bilinear_kernel[x,y] = (1 - abs(x - center) / scale_factor) * \\\n                                   (1 - abs(y - center) / scale_factor)\n    weights = np.zeros((filter_size, filter_size, num_out_channels, num_in_channels))\n    for i in range(num_out_channels):\n        weights[:, :, i, i] = bilinear_kernel\n\n    #assign numpy array to constant_initalizer and pass to get_variable\n    bilinear_weights_init = tf.constant_initializer(value=weights, dtype=tf.float32)\n    return bilinear_weights_init\n\n## Convolutional layer (Simplified)\ndef Conv1d(net, n_filter=32, filter_size=5, stride=1, act=None,\n        padding=\'SAME\', use_cudnn_on_gpu=None,data_format=None,\n        W_init = tf.truncated_normal_initializer(stddev=0.02),\n        b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {}, b_init_args = {}, name =\'conv1d\',):\n    """"""Wrapper for :class:`Conv1dLayer`, if you don\'t understand how to use :class:`Conv1dLayer`, this function may be easier.\n\n    Parameters\n    ----------\n    net : TensorLayer layer.\n    n_filter : number of filter.\n    filter_size : an int.\n    stride : an int.\n    act : None or activation function.\n    others : see :class:`Conv1dLayer`.\n    """"""\n    if act is None:\n        act = tf.identity\n    net = Conv1dLayer(layer = net,\n            act = act,\n            shape = [filter_size, int(net.outputs.get_shape()[-1]), n_filter],\n            stride = stride,\n            padding = padding,\n            use_cudnn_on_gpu = use_cudnn_on_gpu,\n            data_format = data_format,\n            W_init = W_init,\n            b_init = b_init,\n            W_init_args = W_init_args,\n            b_init_args = b_init_args,\n            name = name,\n        )\n    return net\n\ndef Conv2d(net, n_filter=32, filter_size=(3, 3), strides=(1, 1), act = None,\n        padding=\'SAME\', W_init = tf.truncated_normal_initializer(stddev=0.02), b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {}, b_init_args = {}, name =\'conv2d\',):\n    """"""Wrapper for :class:`Conv2dLayer`, if you don\'t understand how to use :class:`Conv2dLayer`, this function may be easier.\n\n    Parameters\n    ----------\n    net : TensorLayer layer.\n    n_filter : number of filter.\n    filter_size : tuple (height, width) for filter size.\n    strides : tuple (height, width) for strides.\n    act : None or activation function.\n    others : see :class:`Conv2dLayer`.\n\n    Examples\n    --------\n    >>> w_init = tf.truncated_normal_initializer(stddev=0.01)\n    >>> b_init = tf.constant_initializer(value=0.0)\n    >>> inputs = InputLayer(x, name=\'inputs\')\n    >>> conv1 = Conv2d(inputs, 64, (3, 3), act=tf.nn.relu, padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'conv1_1\')\n    >>> conv1 = Conv2d(conv1, 64, (3, 3), act=tf.nn.relu, padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'conv1_2\')\n    >>> pool1 = MaxPool2d(conv1, (2, 2), padding=\'SAME\', name=\'pool1\')\n    >>> conv2 = Conv2d(pool1, 128, (3, 3), act=tf.nn.relu, padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'conv2_1\')\n    >>> conv2 = Conv2d(conv2, 128, (3, 3), act=tf.nn.relu, padding=\'SAME\', W_init=w_init, b_init=b_init, name=\'conv2_2\')\n    >>> pool2 = MaxPool2d(conv2, (2, 2), padding=\'SAME\', name=\'pool2\')\n    """"""\n    assert len(strides) == 2, ""len(strides) should be 2, Conv2d and Conv2dLayer are different.""\n    if act is None:\n        act = tf.identity\n    net = Conv2dLayer(net,\n                       act = act,\n                       shape = [filter_size[0], filter_size[1], int(net.outputs.get_shape()[-1]), n_filter],  # 32 features for each 5x5 patch\n                       strides = [1, strides[0], strides[1], 1],\n                       padding = padding,\n                       W_init = W_init,\n                       W_init_args = W_init_args,\n                       b_init = b_init,\n                       b_init_args = b_init_args,\n                       name = name)\n    return net\n\ndef DeConv2d(net, n_out_channel = 32, filter_size=(3, 3),\n        out_size = (30, 30), strides = (2, 2), padding = \'SAME\', batch_size = None, act = None,\n        W_init = tf.truncated_normal_initializer(stddev=0.02), b_init = tf.constant_initializer(value=0.0),\n        W_init_args = {}, b_init_args = {}, name =\'decnn2d\'):\n    """"""Wrapper for :class:`DeConv2dLayer`, if you don\'t understand how to use :class:`DeConv2dLayer`, this function may be easier.\n\n    Parameters\n    ----------\n    net : TensorLayer layer.\n    n_out_channel : int, number of output channel.\n    filter_size : tuple of (height, width) for filter size.\n    out_size :  tuple of (height, width) of output.\n    batch_size : int or None, batch_size. If None, try to find the batch_size from the first dim of net.outputs (you should tell the batch_size when define the input placeholder).\n    strides : tuple of (height, width) for strides.\n    act : None or activation function.\n    others : see :class:`DeConv2dLayer`.\n    """"""\n    assert len(strides) == 2, ""len(strides) should be 2, DeConv2d and DeConv2dLayer are different.""\n    if act is None:\n        act = tf.identity\n    if batch_size is None:\n        batch_size = tf.shape(net.outputs)[0]\n    net = DeConv2dLayer(layer = net,\n                    act = act,\n                    shape = [filter_size[0], filter_size[1], n_out_channel, int(net.outputs.get_shape()[-1])],\n                    output_shape = [batch_size, int(out_size[0]), int(out_size[1]), n_out_channel],\n                    strides = [1, strides[0], strides[1], 1],\n                    padding = padding,\n                    W_init = W_init,\n                    b_init = b_init,\n                    W_init_args = W_init_args,\n                    b_init_args = b_init_args,\n                    name = name)\n    return net\n\ndef MaxPool1d(net, filter_size, strides, padding=\'valid\', data_format=\'channels_last\', name=None): #Untested\n    """"""Wrapper for `tf.layers.max_pooling1d <https://www.tensorflow.org/api_docs/python/tf/layers/max_pooling1d>`_ .\n\n    Parameters\n    ------------\n    net : TensorLayer layer, the tensor over which to pool. Must have rank 3.\n    filter_size (pool_size) : An integer or tuple/list of a single integer, representing the size of the pooling window.\n    strides : An integer or tuple/list of a single integer, specifying the strides of the pooling operation.\n    padding : A string. The padding method, either \'valid\' or \'same\'. Case-insensitive.\n    data_format : A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, length, channels) while channels_first corresponds to inputs with shape (batch, channels, length).\n    name : A string, the name of the layer.\n\n    Returns\n    --------\n    - A :class:`Layer` which the output tensor, of rank 3.\n    """"""\n    print(""  [TL] MaxPool1d %s: filter_size:%s strides:%s padding:%s"" %\n                        (name, str(filter_size), str(strides), str(padding)))\n    outputs = tf.layers.max_pooling1d(net.outputs, filter_size, strides, padding=padding, data_format=data_format, name=name)\n\n    net_new = copy.copy(net)\n    net_new.outputs = outputs\n    net_new.all_layers.extend( [outputs] )\n    return net_new\n\ndef MeanPool1d(net, filter_size, strides, padding=\'valid\', data_format=\'channels_last\', name=None): #Untested\n    """"""Wrapper for `tf.layers.average_pooling1d <https://www.tensorflow.org/api_docs/python/tf/layers/average_pooling1d>`_ .\n\n    Parameters\n    ------------\n    net : TensorLayer layer, the tensor over which to pool. Must have rank 3.\n    filter_size (pool_size) : An integer or tuple/list of a single integer, representing the size of the pooling window.\n    strides : An integer or tuple/list of a single integer, specifying the strides of the pooling operation.\n    padding : A string. The padding method, either \'valid\' or \'same\'. Case-insensitive.\n    data_format : A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch, length, channels) while channels_first corresponds to inputs with shape (batch, channels, length).\n    name : A string, the name of the layer.\n\n    Returns\n    --------\n    - A :class:`Layer` which the output tensor, of rank 3.\n    """"""\n    print(""  [TL] MeanPool1d %s: filter_size:%s strides:%s padding:%s"" %\n                        (name, str(filter_size), str(strides), str(padding)))\n    outputs = tf.layers.average_pooling1d(net.outputs, filter_size, strides, padding=padding, data_format=data_format, name=name)\n\n    net_new = copy.copy(net)\n    net_new.outputs = outputs\n    net_new.all_layers.extend( [outputs] )\n    return net_new\n\ndef MaxPool2d(net, filter_size=(2, 2), strides=None, padding=\'SAME\', name=\'maxpool\'):\n    """"""Wrapper for :class:`PoolLayer`.\n\n    Parameters\n    -----------\n    net : TensorLayer layer.\n    filter_size : tuple of (height, width) for filter size.\n    strides : tuple of (height, width). Default is the same with filter_size.\n    others : see :class:`PoolLayer`.\n    """"""\n    if strides is None:\n        strides = filter_size\n    assert len(strides) == 2, ""len(strides) should be 2, MaxPool2d and PoolLayer are different.""\n    net = PoolLayer(net, ksize=[1, filter_size[0], filter_size[1], 1],\n            strides=[1, strides[0], strides[1], 1],\n            padding=padding,\n            pool = tf.nn.max_pool,\n            name = name)\n    return net\n\ndef MeanPool2d(net, filter_size=(2, 2), strides=None, padding=\'SAME\', name=\'meanpool\'):\n    """"""Wrapper for :class:`PoolLayer`.\n\n    Parameters\n    -----------\n    net : TensorLayer layer.\n    filter_size : tuple of (height, width) for filter size.\n    strides : tuple of (height, width). Default is the same with filter_size.\n    others : see :class:`PoolLayer`.\n    """"""\n    if strides is None:\n        strides = filter_size\n    assert len(strides) == 2, ""len(strides) should be 2, MeanPool2d and PoolLayer are different.""\n    net = PoolLayer(net, ksize=[1, filter_size[0], filter_size[1], 1],\n            strides=[1, strides[0], strides[1], 1],\n            padding=padding,\n            pool = tf.nn.avg_pool,\n            name = name)\n    return net\n\ndef MaxPool3d(net, filter_size, strides, padding=\'valid\', data_format=\'channels_last\', name=None): #Untested\n    """"""Wrapper for `tf.layers.max_pooling3d <https://www.tensorflow.org/api_docs/python/tf/layers/max_pooling3d>`_ .\n\n    Parameters\n    ------------\n    net : TensorLayer layer, the tensor over which to pool. Must have rank 5.\n    filter_size (pool_size) : An integer or tuple/list of 3 integers: (pool_depth, pool_height, pool_width) specifying the size of the pooling window. Can be a single integer to specify the same value for all spatial dimensions.\n    strides : An integer or tuple/list of 3 integers, specifying the strides of the pooling operation. Can be a single integer to specify the same value for all spatial dimensions.\n    padding : A string. The padding method, either \'valid\' or \'same\'. Case-insensitive.\n    data_format : A string. The ordering of the dimensions in the inputs. channels_last (default) and channels_first are supported. channels_last corresponds to inputs with shape (batch, depth, height, width, channels) while channels_first corresponds to inputs with shape (batch, channels, depth, height, width).\n    name : A string, the name of the layer.\n    """"""\n    print(""  [TL] MaxPool3d %s: filter_size:%s strides:%s padding:%s"" %\n                        (name, str(filter_size), str(strides), str(padding)))\n    outputs = tf.layers.max_pooling3d(net.outputs, filter_size, strides, padding=padding, data_format=data_format, name=name)\n\n    net_new = copy.copy(net)\n    net_new.outputs = outputs\n    net_new.all_layers.extend( [outputs] )\n    return net_new\n\ndef MeanPool3d(net, filter_size, strides, padding=\'valid\', data_format=\'channels_last\', name=None): #Untested\n    """"""Wrapper for `tf.layers.average_pooling3d <https://www.tensorflow.org/api_docs/python/tf/layers/average_pooling3d>`_\n\n    Parameters\n    ------------\n    net : TensorLayer layer, the tensor over which to pool. Must have rank 5.\n    filter_size (pool_size) : An integer or tuple/list of 3 integers: (pool_depth, pool_height, pool_width) specifying the size of the pooling window. Can be a single integer to specify the same value for all spatial dimensions.\n    strides : An integer or tuple/list of 3 integers, specifying the strides of the pooling operation. Can be a single integer to specify the same value for all spatial dimensions.\n    padding : A string. The padding method, either \'valid\' or \'same\'. Case-insensitive.\n    data_format : A string. The ordering of the dimensions in the inputs. channels_last (default) and channels_first are supported. channels_last corresponds to inputs with shape (batch, depth, height, width, channels) while channels_first corresponds to inputs with shape (batch, channels, depth, height, width).\n    name : A string, the name of the layer.\n    """"""\n    print(""  [TL] MeanPool3d %s: filter_size:%s strides:%s padding:%s name:%s"" %\n                        (name, str(filter_size), str(strides), str(padding)))\n    outputs = tf.layers.average_pooling3d(net.outputs, filter_size, strides, padding=padding, data_format=data_format, name=name)\n\n    net_new = copy.copy(net)\n    net_new.outputs = outputs\n    net_new.all_layers.extend( [outputs] )\n    return net_new\n\n## Super resolution\ndef SubpixelConv2d(net, scale=2, n_out_channel=None, act=tf.identity, name=\'subpixel_conv2d\'):\n    """"""The :class:`SubpixelConv2d` class is a sub-pixel 2d convolutional ayer, usually be used\n    for super-resolution application.\n\n    Parameters\n    ------------\n    net : TensorLayer layer.\n    scale : int, upscaling ratio, a wrong setting will lead to Dimension size error.\n    n_out_channel : int or None, the number of output channels.\n        Note that, the number of input channels == (scale x scale) x The number of output channels.\n        If None, automatically set n_out_channel == the number of input channels / (scale x scale).\n    act : activation function.\n    name : string.\n        An optional name to attach to this layer.\n\n    Examples\n    ---------\n    >>> # examples here just want to tell you how to set the n_out_channel.\n    >>> x = np.random.rand(2, 16, 16, 4)\n    >>> X = tf.placeholder(""float32"", shape=(2, 16, 16, 4), name=""X"")\n    >>> net = InputLayer(X, name=\'input\')\n    >>> net = SubpixelConv2d(net, scale=2, n_out_channel=1, name=\'subpixel_conv2d\')\n    >>> y = sess.run(net.outputs, feed_dict={X: x})\n    >>> print(x.shape, y.shape)\n    ... (2, 16, 16, 4) (2, 32, 32, 1)\n    >>>\n    >>> x = np.random.rand(2, 16, 16, 4*10)\n    >>> X = tf.placeholder(""float32"", shape=(2, 16, 16, 4*10), name=""X"")\n    >>> net = InputLayer(X, name=\'input2\')\n    >>> net = SubpixelConv2d(net, scale=2, n_out_channel=10, name=\'subpixel_conv2d2\')\n    >>> y = sess.run(net.outputs, feed_dict={X: x})\n    >>> print(x.shape, y.shape)\n    ... (2, 16, 16, 40) (2, 32, 32, 10)\n    >>>\n    >>> x = np.random.rand(2, 16, 16, 25*10)\n    >>> X = tf.placeholder(""float32"", shape=(2, 16, 16, 25*10), name=""X"")\n    >>> net = InputLayer(X, name=\'input3\')\n    >>> net = SubpixelConv2d(net, scale=5, n_out_channel=None, name=\'subpixel_conv2d3\')\n    >>> y = sess.run(net.outputs, feed_dict={X: x})\n    >>> print(x.shape, y.shape)\n    ... (2, 16, 16, 250) (2, 80, 80, 10)\n\n    References\n    ------------\n    - `Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network <https://arxiv.org/pdf/1609.05158.pdf>`_\n    """"""\n    # github/Tetrachrome/subpixel  https://github.com/Tetrachrome/subpixel/blob/master/subpixel.py\n\n    _err_log = ""SubpixelConv2d: The number of input channels == (scale x scale) x The number of output channels""\n\n    scope_name = tf.get_variable_scope().name\n    if scope_name:\n        name = scope_name + \'/\' + name\n\n    def _phase_shift(I, r):\n        if tf.__version__ < \'1.0\':\n            raise Exception(""Only support TF1.0+"")\n        bsize, a, b, c = I.get_shape().as_list()\n        bsize = tf.shape(I)[0] # Handling Dimension(None) type for undefined batch dim\n        X = tf.reshape(I, (bsize, a, b, r, r))\n        X = tf.transpose(X, (0, 1, 2, 4, 3))  # bsize, a, b, 1, 1 # tf 0.12\n        # X = tf.split(1, a, X)  # a, [bsize, b, r, r] # tf 0.12\n        X = tf.split(X, a, 1)\n        # X = tf.concat(2, [tf.squeeze(x, axis=1) for x in X])  # bsize, b, a*r, r # tf 0.12\n        X = tf.concat([tf.squeeze(x, axis=1) for x in X], 2)\n        # X = tf.split(1, b, X)  # b, [bsize, a*r, r] # tf 0.12\n        X = tf.split(X, b, 1)\n        # X = tf.concat(2, [tf.squeeze(x, axis=1) for x in X])  # bsize, a*r, b*r # tf 0.12\n        X = tf.concat([tf.squeeze(x, axis=1) for x in X], 2)\n        return tf.reshape(X, (bsize, a*r, b*r, 1))\n\n    def _PS(X, r, n_out_channel):\n        if n_out_channel > 1:\n            assert int(X.get_shape()[-1]) == (r ** 2) * n_out_channel, _err_log\n            Xc = tf.split(X, n_out_channel, 3)\n            X = tf.concat([_phase_shift(x, r) for x in Xc], 3)\n        elif n_out_channel == 1:\n            assert int(X.get_shape()[-1]) == (r ** 2), _err_log\n            X = _phase_shift(X, r)\n        else:\n            print(_err_log)\n        return X\n\n    inputs = net.outputs\n\n    if n_out_channel is None:\n        assert int(inputs.get_shape()[-1])/ (scale ** 2) % 1 == 0, _err_log\n        n_out_channel = int(int(inputs.get_shape()[-1])/ (scale ** 2))\n\n    print(""  [TL] SubpixelConv2d  %s: scale: %d n_out_channel: %s act: %s"" % (name, scale, n_out_channel, act.__name__))\n\n    net_new = Layer(inputs, name=name)\n    # with tf.name_scope(name):\n    with tf.variable_scope(name) as vs:\n        net_new.outputs = act(_PS(inputs, r=scale, n_out_channel=n_out_channel))\n\n    net_new.all_layers = list(net.all_layers)\n    net_new.all_params = list(net.all_params)\n    net_new.all_drop = dict(net.all_drop)\n    net_new.all_layers.extend( [net_new.outputs] )\n    return net_new\n\n\n# ## Normalization layer\nclass LocalResponseNormLayer(Layer):\n    """"""The :class:`LocalResponseNormLayer` class is for Local Response Normalization, see ``tf.nn.local_response_normalization``.\n    The 4-D input tensor is treated as a 3-D array of 1-D vectors (along the last dimension), and each vector is normalized independently.\n    Within a given vector, each component is divided by the weighted, squared sum of inputs within depth_radius.\n\n    Parameters\n    -----------\n    layer : a layer class. Must be one of the following types: float32, half. 4-D.\n    depth_radius : An optional int. Defaults to 5. 0-D. Half-width of the 1-D normalization window.\n    bias : An optional float. Defaults to 1. An offset (usually positive to avoid dividing by 0).\n    alpha : An optional float. Defaults to 1. A scale factor, usually positive.\n    beta : An optional float. Defaults to 0.5. An exponent.\n    name : A string or None, an optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        depth_radius = None,\n        bias = None,\n        alpha = None,\n        beta = None,\n        name =\'lrn_layer\',\n    ):\n        self.inputs = layer.outputs\n        print(""  [TL] LocalResponseNormLayer %s: depth_radius: %d, bias: %f, alpha: %f, beta: %f"" %\n                            (self.name, depth_radius, bias, alpha, beta))\n        with tf.variable_scope(name) as vs:\n            self.outputs = tf.nn.local_response_normalization(self.inputs, depth_radius=depth_radius, bias=bias, alpha=alpha, beta=beta)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n\nclass BatchNormLayer(Layer):\n    """"""\n    The :class:`BatchNormLayer` class is a normalization layer, see ``tf.nn.batch_normalization`` and ``tf.nn.moments``.\n\n    Batch normalization on fully-connected or convolutional maps.\n\n    Parameters\n    -----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    decay : float, default is 0.9.\n        A decay factor for ExponentialMovingAverage, use larger value for large dataset.\n    epsilon : float\n        A small float number to avoid dividing by 0.\n    act : activation function.\n    is_train : boolean\n        Whether train or inference.\n    beta_init : beta initializer\n        The initializer for initializing beta\n    gamma_init : gamma initializer\n        The initializer for initializing gamma\n    name : a string or None\n        An optional name to attach to this layer.\n\n    References\n    ----------\n    - `Source <https://github.com/ry/tensorflow-resnet/blob/master/resnet.py>`_\n    - `stackoverflow <http://stackoverflow.com/questions/38312668/how-does-one-do-inference-with-batch-normalization-with-tensor-flow>`_\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        decay = 0.9,\n        epsilon = 0.00001,\n        act = tf.identity,\n        is_train = False,\n        beta_init = tf.zeros_initializer,\n        gamma_init = tf.random_normal_initializer(mean=1.0, stddev=0.002), # tf.ones_initializer,\n        name =\'batchnorm_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] BatchNormLayer %s: decay:%f epsilon:%f act:%s is_train:%s"" %\n                            (self.name, decay, epsilon, act.__name__, is_train))\n        x_shape = self.inputs.get_shape()\n        params_shape = x_shape[-1:]\n\n        from tensorflow.python.training import moving_averages\n        from tensorflow.python.ops import control_flow_ops\n\n        with tf.variable_scope(name) as vs:\n            axis = list(range(len(x_shape) - 1))\n\n            ## 1. beta, gamma\n            if tf.__version__ > \'0.12.1\' and beta_init == tf.zeros_initializer:\n                beta_init = beta_init()\n            beta = tf.get_variable(\'beta\', shape=params_shape,\n                               initializer=beta_init,\n                               trainable=is_train)#, restore=restore)\n\n            gamma = tf.get_variable(\'gamma\', shape=params_shape,\n                                initializer=gamma_init, trainable=is_train,\n                                )#restore=restore)\n\n            ## 2.\n            if tf.__version__ > \'0.12.1\':\n                moving_mean_init = tf.zeros_initializer()\n            else:\n                moving_mean_init = tf.zeros_initializer\n            moving_mean = tf.get_variable(\'moving_mean\',\n                                      params_shape,\n                                      initializer=moving_mean_init,\n                                      trainable=False,)#   restore=restore)\n            moving_variance = tf.get_variable(\'moving_variance\',\n                                          params_shape,\n                                          initializer=tf.constant_initializer(1.),\n                                          trainable=False,)#   restore=restore)\n\n            ## 3.\n            # These ops will only be preformed when training.\n            mean, variance = tf.nn.moments(self.inputs, axis)\n            try:    # TF12\n                update_moving_mean = moving_averages.assign_moving_average(\n                                moving_mean, mean, decay, zero_debias=False)     # if zero_debias=True, has bias\n                update_moving_variance = moving_averages.assign_moving_average(\n                                moving_variance, variance, decay, zero_debias=False) # if zero_debias=True, has bias\n                # print(""TF12 moving"")\n            except Exception as e:  # TF11\n                update_moving_mean = moving_averages.assign_moving_average(\n                                moving_mean, mean, decay)\n                update_moving_variance = moving_averages.assign_moving_average(\n                                moving_variance, variance, decay)\n                # print(""TF11 moving"")\n\n            def mean_var_with_update():\n                with tf.control_dependencies([update_moving_mean, update_moving_variance]):\n                    return tf.identity(mean), tf.identity(variance)\n\n            if is_train:\n                mean, var = mean_var_with_update()\n                self.outputs = act( tf.nn.batch_normalization(self.inputs, mean, var, beta, gamma, epsilon) )\n            else:\n                self.outputs = act( tf.nn.batch_normalization(self.inputs, moving_mean, moving_variance, beta, gamma, epsilon) )\n\n            variables = [beta, gamma, moving_mean, moving_variance]\n\n            # print(len(variables))\n            # for idx, v in enumerate(variables):\n            #     print(""  var {:3}: {:15}   {}"".format(idx, str(v.get_shape()), v))\n            # exit()\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( variables )\n\n# class BatchNormLayer_TF(Layer):   # Work well TF contrib https://github.com/tensorflow/tensorflow/blob/b826b79718e3e93148c3545e7aa3f90891744cc0/tensorflow/contrib/layers/python/layers/layers.py#L100\n#     """"""\n#     The :class:`BatchNormLayer` class is a normalization layer, see ``tf.nn.batch_normalization`` and ``tf.nn.moments``.\n#\n#     Batch normalization on fully-connected or convolutional maps.\n#\n#     Parameters\n#     -----------\n#     layer : a :class:`Layer` instance\n#         The `Layer` class feeding into this layer.\n#     decay : float\n#         A decay factor for ExponentialMovingAverage.\n#     center: If True, subtract `beta`. If False, `beta` is ignored.\n#     scale: If True, multiply by `gamma`. If False, `gamma` is\n#         not used. When the next layer is linear (also e.g. `nn.relu`), this can be\n#         disabled since the scaling can be done by the next layer.\n#     epsilon : float\n#         A small float number to avoid dividing by 0.\n#     act : activation function.\n#     is_train : boolean\n#         Whether train or inference.\n#     beta_init : beta initializer\n#         The initializer for initializing beta\n#     gamma_init : gamma initializer\n#         The initializer for initializing gamma\n#     name : a string or None\n#         An optional name to attach to this layer.\n#\n#     References\n#     ----------\n#     - `Source <https://github.com/ry/tensorflow-resnet/blob/master/resnet.py>`_\n#     - `stackoverflow <http://stackoverflow.com/questions/38312668/how-does-one-do-inference-with-batch-normalization-with-tensor-flow>`_\n#     """"""\n#     def __init__(\n#         self,\n#         layer = None,\n#         decay = 0.95,#.999,\n#         center = True,\n#         scale = True,\n#         epsilon = 0.00001,\n#         act = tf.identity,\n#         is_train = False,\n#         beta_init = tf.zeros_initializer,\n#         # gamma_init = tf.ones_initializer,\n#         gamma_init = tf.random_normal_initializer(mean=1.0, stddev=0.002),\n#         name =\'batchnorm_layer\',\n#     ):\n#         Layer.__init__(self, name=name)\n#         self.inputs = layer.outputs\n#         print(""  [TL] BatchNormLayer %s: decay: %f, epsilon: %f, act: %s, is_train: %s"" %\n#                             (self.name, decay, epsilon, act.__name__, is_train))\n#         from tensorflow.contrib.layers.python.layers import utils\n#         from tensorflow.contrib.framework.python.ops import variables\n#         from tensorflow.python.ops import init_ops\n#         from tensorflow.python.ops import nn\n#         from tensorflow.python.training import moving_averages\n#         from tensorflow.python.framework import ops\n#         from tensorflow.python.ops import variable_scope\n#         variables_collections = None\n#         outputs_collections=None\n#         updates_collections=None#ops.GraphKeys.UPDATE_OPS\n#         # with variable_scope.variable_op_scope([inputs],\n#         #                                     scope, \'BatchNorm\', reuse=reuse) as sc:\n#         # with variable_scope.variable_op_scope([self.inputs], None, name) as vs:\n#         with tf.variable_scope(name) as vs:\n#             inputs_shape = self.inputs.get_shape()\n#             dtype = self.inputs.dtype.base_dtype\n#             axis = list(range(len(inputs_shape) - 1)) # [0, 1, 2]\n#             params_shape = inputs_shape[-1:]\n#             # Allocate parameters for the beta and gamma of the normalization.\n#             beta, gamma = None, None\n#             if center:\n#               beta_collections = utils.get_variable_collections(variables_collections,\n#                                                                 \'beta\')\n#               beta = variables.model_variable(\'beta\',\n#                                               shape=params_shape,\n#                                               dtype=dtype,\n#                                             #   initializer=init_ops.zeros_initializer,\n#                                               initializer=beta_init,\n#                                               collections=beta_collections,)\n#                                             #   trainable=trainable)\n#             if scale:\n#               gamma_collections = utils.get_variable_collections(variables_collections,\n#                                                                  \'gamma\')\n#               gamma = variables.model_variable(\'gamma\',\n#                                                shape=params_shape,\n#                                                dtype=dtype,\n#                                             #    initializer=init_ops.ones_initializer,\n#                                                initializer=gamma_init,\n#                                                collections=gamma_collections,)\n#                                             #    trainable=trainable)\n#             # Create moving_mean and moving_variance variables and add them to the\n#             # appropiate collections.\n#             moving_mean_collections = utils.get_variable_collections(\n#                 variables_collections,\n#                 \'moving_mean\')\n#             moving_mean = variables.model_variable(\n#                 \'moving_mean\',\n#                 shape=params_shape,\n#                 dtype=dtype,\n#                 # initializer=init_ops.zeros_initializer,\n#                 initializer=tf.zeros_initializer,\n#                 trainable=False,\n#                 collections=moving_mean_collections)\n#             moving_variance_collections = utils.get_variable_collections(\n#                 variables_collections,\n#                 \'moving_variance\')\n#             moving_variance = variables.model_variable(\n#                 \'moving_variance\',\n#                 shape=params_shape,\n#                 dtype=dtype,\n#                 # initializer=init_ops.ones_initializer,\n#                 initializer=tf.constant_initializer(1.),\n#                 trainable=False,\n#                 collections=moving_variance_collections)\n#             if is_train:\n#               # Calculate the moments based on the individual batch.\n#               mean, variance = nn.moments(self.inputs, axis, shift=moving_mean)\n#               # Update the moving_mean and moving_variance moments.\n#             #   update_moving_mean = moving_averages.assign_moving_average(\n#             #       moving_mean, mean, decay)\n#             #   update_moving_variance = moving_averages.assign_moving_average(\n#             #       moving_variance, variance, decay)\n#             #   if updates_collections is None:\n#             #     # Make sure the updates are computed here.\n#             #       with ops.control_dependencies([update_moving_mean,\n#             #                                        update_moving_variance]):\n#             #          outputs = nn.batch_normalization(\n#             #               self.inputs, mean, variance, beta, gamma, epsilon)\n#\n#               update_moving_mean = tf.assign(moving_mean,\n#                                    moving_mean * decay + mean * (1 - decay))\n#               update_moving_variance = tf.assign(moving_variance,\n#                                   moving_variance * decay + variance * (1 - decay))\n#               with tf.control_dependencies([update_moving_mean, update_moving_variance]):\n#                   outputs = nn.batch_normalization(\n#                               self.inputs, mean, variance, beta, gamma, epsilon)\n#             #   else:\n#             #     # Collect the updates to be computed later.\n#             #     ops.add_to_collections(updates_collections, update_moving_mean)\n#             #     ops.add_to_collections(updates_collections, update_moving_variance)\n#             #     outputs = nn.batch_normalization(\n#             #         self.inputs, mean, variance, beta, gamma, epsilon)\n#             else:\n#             #   mean, variance = nn.moments(self.inputs, axis, shift=moving_mean)\n#               outputs = nn.batch_normalization(\n#                   self.inputs, moving_mean, moving_variance, beta, gamma, epsilon)\n#                 # self.inputs, mean, variance, beta, gamma, epsilon)\n#             outputs.set_shape(self.inputs.get_shape())\n#             # if activation_fn:\n#             self.outputs = act(outputs)\n#\n#             # variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n#             # return utils.collect_named_outputs(outputs_collections, sc.name, outputs)\n#             variables = [beta, gamma, moving_mean, moving_variance]\n#\n#         mean, variance = nn.moments(self.inputs, axis, shift=moving_mean)\n#         self.check_mean = mean\n#         self.check_variance = variance\n#\n#         self.all_layers = list(layer.all_layers)\n#         self.all_params = list(layer.all_params)\n#         self.all_drop = dict(layer.all_drop)\n#         self.all_layers.extend( [self.outputs] )\n#         self.all_params.extend( variables )\n#\n# class BatchNormLayer5(Layer):   # Akara Work well\n#     """"""\n#     The :class:`BatchNormLayer` class is a normalization layer, see ``tf.nn.batch_normalization`` and ``tf.nn.moments``.\n#\n#     Batch normalization on fully-connected or convolutional maps.\n#\n#     Parameters\n#     -----------\n#     layer : a :class:`Layer` instance\n#         The `Layer` class feeding into this layer.\n#     decay : float\n#         A decay factor for ExponentialMovingAverage.\n#     epsilon : float\n#         A small float number to avoid dividing by 0.\n#     act : activation function.\n#     is_train : boolean\n#         Whether train or inference.\n#     beta_init : beta initializer\n#         The initializer for initializing beta\n#     gamma_init : gamma initializer\n#         The initializer for initializing gamma\n#     name : a string or None\n#         An optional name to attach to this layer.\n#\n#     References\n#     ----------\n#     - `Source <https://github.com/ry/tensorflow-resnet/blob/master/resnet.py>`_\n#     - `stackoverflow <http://stackoverflow.com/questions/38312668/how-does-one-do-inference-with-batch-normalization-with-tensor-flow>`_\n#     """"""\n#     def __init__(\n#         self,\n#         layer = None,\n#         decay = 0.9,\n#         epsilon = 0.00001,\n#         act = tf.identity,\n#         is_train = False,\n#         beta_init = tf.zeros_initializer,\n#         # gamma_init = tf.ones_initializer,\n#         gamma_init = tf.random_normal_initializer(mean=1.0, stddev=0.002),\n#         name =\'batchnorm_layer\',\n#     ):\n#         Layer.__init__(self, name=name)\n#         self.inputs = layer.outputs\n#         print(""  [TL] BatchNormLayer %s: decay: %f, epsilon: %f, act: %s, is_train: %s"" %\n#                             (self.name, decay, epsilon, act.__name__, is_train))\n#         x_shape = self.inputs.get_shape()\n#         params_shape = x_shape[-1:]\n#\n#         from tensorflow.python.training import moving_averages\n#         from tensorflow.python.ops import control_flow_ops\n#\n#         with tf.variable_scope(name) as vs:\n#             axis = list(range(len(x_shape) - 1))\n#\n#             ## 1. beta, gamma\n#             beta = tf.get_variable(\'beta\', shape=params_shape,\n#                                initializer=beta_init,\n#                                trainable=is_train)#, restore=restore)\n#\n#             gamma = tf.get_variable(\'gamma\', shape=params_shape,\n#                                 initializer=gamma_init, trainable=is_train,\n#                                 )#restore=restore)\n#\n#             ## 2. moving variables during training (not update by gradient!)\n#             moving_mean = tf.get_variable(\'moving_mean\',\n#                                       params_shape,\n#                                       initializer=tf.zeros_initializer,\n#                                       trainable=False,)#   restore=restore)\n#             moving_variance = tf.get_variable(\'moving_variance\',\n#                                           params_shape,\n#                                           initializer=tf.constant_initializer(1.),\n#                                           trainable=False,)#   restore=restore)\n#\n#             batch_mean, batch_var = tf.nn.moments(self.inputs, axis)\n#             ## 3.\n#             # These ops will only be preformed when training.\n#             def mean_var_with_update():\n#                 try:    # TF12\n#                     update_moving_mean = moving_averages.assign_moving_average(\n#                                     moving_mean, batch_mean, decay, zero_debias=False)     # if zero_debias=True, has bias\n#                     update_moving_variance = moving_averages.assign_moving_average(\n#                                     moving_variance, batch_var, decay, zero_debias=False) # if zero_debias=True, has bias\n#                     # print(""TF12 moving"")\n#                 except Exception as e:  # TF11\n#                     update_moving_mean = moving_averages.assign_moving_average(\n#                                     moving_mean, batch_mean, decay)\n#                     update_moving_variance = moving_averages.assign_moving_average(\n#                                     moving_variance, batch_var, decay)\n#                     # print(""TF11 moving"")\n#\n#             # def mean_var_with_update():\n#                 with tf.control_dependencies([update_moving_mean, update_moving_variance]):\n#                     # return tf.identity(update_moving_mean), tf.identity(update_moving_variance)\n#                     return tf.identity(batch_mean), tf.identity(batch_var)\n#\n#             # if not is_train:\n#             if is_train:\n#                 mean, var = mean_var_with_update()\n#             else:\n#                 mean, var = (moving_mean, moving_variance)\n#\n#             normed = tf.nn.batch_normalization(\n#               x=self.inputs,\n#               mean=mean,\n#               variance=var,\n#               offset=beta,\n#               scale=gamma,\n#               variance_epsilon=epsilon,\n#               name=""tf_bn""\n#             )\n#             self.outputs = act( normed )\n#\n#             variables = [beta, gamma, moving_mean, moving_variance]\n#             # print(len(variables))\n#             # for idx, v in enumerate(variables):\n#             #     print(""  var {:3}: {:15}   {}"".format(idx, str(v.get_shape()), v))\n#             # exit()\n#\n#         self.all_layers = list(layer.all_layers)\n#         self.all_params = list(layer.all_params)\n#         self.all_drop = dict(layer.all_drop)\n#         self.all_layers.extend( [self.outputs] )\n#         self.all_params.extend( variables )\n#         # self.all_params.extend( [beta, gamma] )\n#\n# class BatchNormLayer4(Layer): # work TFlearn https://github.com/tflearn/tflearn/blob/master/tflearn/layers/normalization.py\n#     """"""\n#     The :class:`BatchNormLayer` class is a normalization layer, see ``tf.nn.batch_normalization`` and ``tf.nn.moments``.\n#\n#     Batch normalization on fully-connected or convolutional maps.\n#\n#     Parameters\n#     -----------\n#     layer : a :class:`Layer` instance\n#         The `Layer` class feeding into this layer.\n#     decay : float\n#         A decay factor for ExponentialMovingAverage.\n#     epsilon : float\n#         A small float number to avoid dividing by 0.\n#     act : activation function.\n#     is_train : boolean\n#         Whether train or inference.\n#     beta_init : beta initializer\n#         The initializer for initializing beta\n#     gamma_init : gamma initializer\n#         The initializer for initializing gamma\n#     name : a string or None\n#         An optional name to attach to this layer.\n#\n#     References\n#     ----------\n#     - `Source <https://github.com/ry/tensorflow-resnet/blob/master/resnet.py>`_\n#     - `stackoverflow <http://stackoverflow.com/questions/38312668/how-does-one-do-inference-with-batch-normalization-with-tensor-flow>`_\n#     """"""\n#     def __init__(\n#         self,\n#         layer = None,\n#         decay = 0.999,\n#         epsilon = 0.00001,\n#         act = tf.identity,\n#         is_train = None,\n#         beta_init = tf.zeros_initializer,\n#         # gamma_init = tf.ones_initializer,\n#         gamma_init = tf.random_normal_initializer(mean=1.0, stddev=0.002),\n#         name =\'batchnorm_layer\',\n#     ):\n#         Layer.__init__(self, name=name)\n#         self.inputs = layer.outputs\n#         print(""  [TL] BatchNormLayer %s: decay: %f, epsilon: %f, act: %s, is_train: %s"" %\n#                             (self.name, decay, epsilon, act.__name__, is_train))\n#         input_shape = self.inputs.get_shape()\n#         # params_shape = input_shape[-1:]\n#         input_ndim = len(input_shape)\n#         from tensorflow.python.training import moving_averages\n#         from tensorflow.python.ops import control_flow_ops\n#\n#         # gamma_init = tf.random_normal_initializer(mean=gamma, stddev=stddev)\n#\n#         # Variable Scope fix for older TF\n#         scope = name\n#         try:\n#             vscope = tf.variable_scope(scope, default_name=name, values=[self.inputs],)\n#                                     #    reuse=reuse)\n#         except Exception:\n#             vscope = tf.variable_op_scope([self.inputs], scope, name)#, reuse=reuse)\n#\n#         with vscope as scope:\n#             name = scope.name\n#         # with tf.variable_scope(name) as vs:\n#             beta = tf.get_variable(\'beta\', shape=[input_shape[-1]],\n#                                 initializer=beta_init,)\n#                             #    initializer=tf.constant_initializer(beta),)\n#                             #    trainable=trainable, )#restore=restore)\n#             gamma = tf.get_variable(\'gamma\', shape=[input_shape[-1]],\n#                                 initializer=gamma_init, )#trainable=trainable,)\n#                                 # restore=restore)\n#\n#             axis = list(range(input_ndim - 1))\n#             moving_mean = tf.get_variable(\'moving_mean\',\n#                                       input_shape[-1:],\n#                                       initializer=tf.zeros_initializer,\n#                                       trainable=False,)\n#                                     #   restore=restore)\n#             moving_variance = tf.get_variable(\'moving_variance\',\n#                                           input_shape[-1:],\n#                                           initializer=tf.constant_initializer(1.),\n#                                           trainable=False,)\n#                                         #   restore=restore)\n#\n#             # Define a function to update mean and variance\n#             def update_mean_var():\n#                 mean, variance = tf.nn.moments(self.inputs, axis)\n#\n#                 # Fix TF 0.12\n#                 try:\n#                     update_moving_mean = moving_averages.assign_moving_average(\n#                         moving_mean, mean, decay, zero_debias=False)            # if zero_debias=True, accuracy is high ..\n#                     update_moving_variance = moving_averages.assign_moving_average(\n#                         moving_variance, variance, decay, zero_debias=False)\n#                 except Exception as e:  # TF 11\n#                     update_moving_mean = moving_averages.assign_moving_average(\n#                         moving_mean, mean, decay)\n#                     update_moving_variance = moving_averages.assign_moving_average(\n#                         moving_variance, variance, decay)\n#\n#                 with tf.control_dependencies(\n#                         [update_moving_mean, update_moving_variance]):\n#                     return tf.identity(mean), tf.identity(variance)\n#\n#             # Retrieve variable managing training mode\n#             # is_training = tflearn.get_training_mode()\n#             if not is_train:    # test : mean=0, std=1\n#             # if is_train:      # train : mean=0, std=1\n#                 is_training = tf.cast(tf.ones([]), tf.bool)\n#             else:\n#                 is_training = tf.cast(tf.zeros([]), tf.bool)\n#             mean, var = tf.cond(\n#                 is_training, update_mean_var, lambda: (moving_mean, moving_variance))\n#                             #  ones                 zeros\n#             try:\n#                 inference = tf.nn.batch_normalization(\n#                     self.inputs, mean, var, beta, gamma, epsilon)\n#                 inference.set_shape(input_shape)\n#             # Fix for old Tensorflow\n#             except Exception as e:\n#                 inference = tf.nn.batch_norm_with_global_normalization(\n#                     self.inputs, mean, var, beta, gamma, epsilon,\n#                     scale_after_normalization=True,\n#                 )\n#                 inference.set_shape(input_shape)\n#\n#             variables = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope=scope.name)    # 2 params beta, gamma\n#                 # variables = [beta, gamma, moving_mean, moving_variance]\n#\n#             # print(len(variables))\n#             # for idx, v in enumerate(variables):\n#             #     print(""  var {:3}: {:15}   {}"".format(idx, str(v.get_shape()), v.name))\n#             # exit()\n#\n#         # Add attributes for easy access\n#         # inference.scope = scope\n#         inference.scope = name\n#         inference.beta = beta\n#         inference.gamma = gamma\n#\n#         self.outputs = act( inference )\n#\n#         self.all_layers = list(layer.all_layers)\n#         self.all_params = list(layer.all_params)\n#         self.all_drop = dict(layer.all_drop)\n#         self.all_layers.extend( [self.outputs] )\n#         self.all_params.extend( variables )\n\n# class BatchNormLayer2(Layer):   # don\'t work http://r2rt.com/implementing-batch-normalization-in-tensorflow.html\n#     """"""\n#     The :class:`BatchNormLayer` class is a normalization layer, see ``tf.nn.batch_normalization`` and ``tf.nn.moments``.\n#\n#     Batch normalization on fully-connected or convolutional maps.\n#\n#     Parameters\n#     -----------\n#     layer : a :class:`Layer` instance\n#         The `Layer` class feeding into this layer.\n#     decay : float\n#         A decay factor for ExponentialMovingAverage.\n#     epsilon : float\n#         A small float number to avoid dividing by 0.\n#     act : activation function.\n#     is_train : boolean\n#         Whether train or inference.\n#     beta_init : beta initializer\n#         The initializer for initializing beta\n#     gamma_init : gamma initializer\n#         The initializer for initializing gamma\n#     name : a string or None\n#         An optional name to attach to this layer.\n#\n#     References\n#     ----------\n#     - `Source <https://github.com/ry/tensorflow-resnet/blob/master/resnet.py>`_\n#     - `stackoverflow <http://stackoverflow.com/questions/38312668/how-does-one-do-inference-with-batch-normalization-with-tensor-flow>`_\n#     """"""\n#     def __init__(\n#         self,\n#         layer = None,\n#         decay = 0.999,\n#         epsilon = 0.00001,\n#         act = tf.identity,\n#         is_train = None,\n#         beta_init = tf.zeros_initializer,\n#         # gamma_init = tf.ones_initializer,\n#         gamma_init = tf.random_normal_initializer(mean=1.0, stddev=0.002),\n#         name =\'batchnorm_layer\',\n#     ):\n#         Layer.__init__(self, name=name)\n#         self.inputs = layer.outputs\n#         print(""  [TL] BatchNormLayer %s: decay: %f, epsilon: %f, act: %s, is_train: %s"" %\n#                             (self.name, decay, epsilon, act.__name__, is_train))\n#         x_shape = self.inputs.get_shape()\n#         params_shape = x_shape[-1:]\n#\n#         with tf.variable_scope(name) as vs:\n#             gamma = tf.get_variable(""gamma"", shape=params_shape,\n#                         initializer=gamma_init)\n#             beta = tf.get_variable(""beta"", shape=params_shape,\n#                         initializer=beta_init)\n#             pop_mean = tf.get_variable(""pop_mean"", shape=params_shape,\n#                         initializer=tf.zeros_initializer, trainable=False)\n#             pop_var = tf.get_variable(""pop_var"", shape=params_shape,\n#                         initializer=tf.constant_initializer(1.), trainable=False)\n#\n#             if is_train:\n#                 batch_mean, batch_var = tf.nn.moments(self.inputs, list(range(len(x_shape) - 1)))\n#                 train_mean = tf.assign(pop_mean,\n#                                        pop_mean * decay + batch_mean * (1 - decay))\n#                 train_var = tf.assign(pop_var,\n#                                       pop_var * decay + batch_var * (1 - decay))\n#                 with tf.control_dependencies([train_mean, train_var]):\n#                     self.outputs = act(tf.nn.batch_normalization(self.inputs,\n#                         batch_mean, batch_var, beta, gamma, epsilon))\n#             else:\n#                 self.outputs = act(tf.nn.batch_normalization(self.inputs,\n#                     pop_mean, pop_var, beta, gamma, epsilon))\n#                     # self.outputs = act( tf.nn.batch_normalization(self.inputs, mean, variance, beta, gamma, epsilon) )\n#             # variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)  # 8 params in TF12 if zero_debias=True\n#             variables = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope=vs.name)    # 2 params beta, gamma\n#                 # variables = [beta, gamma, moving_mean, moving_variance]\n#\n#             # print(len(variables))\n#             # for idx, v in enumerate(variables):\n#             #     print(""  var {:3}: {:15}   {}"".format(idx, str(v.get_shape()), v.name))\n#             # exit()\n#\n#         self.all_layers = list(layer.all_layers)\n#         self.all_params = list(layer.all_params)\n#         self.all_drop = dict(layer.all_drop)\n#         self.all_layers.extend( [self.outputs] )\n#         self.all_params.extend( variables )\n\n# class BatchNormLayer3(Layer):   # don\'t work http://r2rt.com/implementing-batch-normalization-in-tensorflow.html\n#     """"""\n#     The :class:`BatchNormLayer` class is a normalization layer, see ``tf.nn.batch_normalization`` and ``tf.nn.moments``.\n#\n#     Batch normalization on fully-connected or convolutional maps.\n#\n#     Parameters\n#     -----------\n#     layer : a :class:`Layer` instance\n#         The `Layer` class feeding into this layer.\n#     decay : float\n#         A decay factor for ExponentialMovingAverage.\n#     epsilon : float\n#         A small float number to avoid dividing by 0.\n#     act : activation function.\n#     is_train : boolean\n#         Whether train or inference.\n#     beta_init : beta initializer\n#         The initializer for initializing beta\n#     gamma_init : gamma initializer\n#         The initializer for initializing gamma\n#     name : a string or None\n#         An optional name to attach to this layer.\n#\n#     References\n#     ----------\n#     - `Source <https://github.com/ry/tensorflow-resnet/blob/master/resnet.py>`_\n#     - `stackoverflow <http://stackoverflow.com/questions/38312668/how-does-one-do-inference-with-batch-normalization-with-tensor-flow>`_\n#     """"""\n#     def __init__(\n#         self,\n#         layer = None,\n#         decay = 0.999,\n#         epsilon = 0.00001,\n#         act = tf.identity,\n#         is_train = None,\n#         beta_init = tf.zeros_initializer,\n#         # gamma_init = tf.ones_initializer,\n#         gamma_init = tf.random_normal_initializer(mean=1.0, stddev=0.002),\n#         name =\'batchnorm_layer\',\n#     ):\n#         """"""\n#         Batch normalization on convolutional maps.\n#         Ref.: http://stackoverflow.com/questions/33949786/how-could-i-use-batch-normalization-in-tensorflow\n#         Args:\n#             x:           Tensor, 4D BHWD input maps\n#             n_out:       integer, depth of input maps\n#             phase_train: boolean tf.Varialbe, true indicates training phase\n#             scope:       string, variable scope\n#         Return:\n#             normed:      batch-normalized maps\n#         """"""\n#         Layer.__init__(self, name=name)\n#         self.inputs = layer.outputs\n#         print(""  [TL] BatchNormLayer %s: decay: %f, epsilon: %f, act: %s, is_train: %s"" %\n#                             (self.name, decay, epsilon, act.__name__, is_train))\n#         x_shape = self.inputs.get_shape()\n#         params_shape = x_shape[-1:]\n#\n#         if is_train:\n#             phase_train = tf.cast(tf.ones([]), tf.bool)\n#         else:\n#             phase_train = tf.cast(tf.zeros([]), tf.bool)\n#\n#         with tf.variable_scope(name) as vs:\n#             gamma = tf.get_variable(""gamma"", shape=params_shape,\n#                         initializer=gamma_init)\n#             beta = tf.get_variable(""beta"", shape=params_shape,\n#                         initializer=beta_init)\n#             batch_mean, batch_var = tf.nn.moments(self.inputs, list(range(len(x_shape) - 1)),#[0,1,2],\n#                             name=\'moments\')\n#             ema = tf.train.ExponentialMovingAverage(decay=decay)\n#\n#             def mean_var_with_update():\n#                 ema_apply_op = ema.apply([batch_mean, batch_var])\n#                 with tf.control_dependencies([ema_apply_op]):\n#                     return tf.identity(batch_mean), tf.identity(batch_var)\n#\n#             mean, var = tf.cond(phase_train,\n#                                 mean_var_with_update,\n#                                 lambda: (ema.average(batch_mean), ema.average(batch_var)))\n#             normed = tf.nn.batch_normalization(self.inputs, mean, var, beta, gamma, epsilon)\n#             self.outputs = act( normed )\n#             variables = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope=vs.name)    # 2 params beta, gamma\n#                 # variables = [beta, gamma, moving_mean, moving_variance]\n#\n#             # print(len(variables))\n#             # for idx, v in enumerate(variables):\n#             #     print(""  var {:3}: {:15}   {}"".format(idx, str(v.get_shape()), v.name))\n#             # exit()\n#\n#         self.all_layers = list(layer.all_layers)\n#         self.all_params = list(layer.all_params)\n#         self.all_drop = dict(layer.all_drop)\n#         self.all_layers.extend( [self.outputs] )\n#         self.all_params.extend( variables )\n\n# class BatchNormLayer_old(Layer):  # don\'t work\n#     """"""\n#     The :class:`BatchNormLayer` class is a normalization layer, see ``tf.nn.batch_normalization``.\n#\n#     Batch normalization on fully-connected or convolutional maps.\n#\n#     Parameters\n#     -----------\n#     layer : a :class:`Layer` instance\n#         The `Layer` class feeding into this layer.\n#     decay : float\n#         A decay factor for ExponentialMovingAverage.\n#     epsilon : float\n#         A small float number to avoid dividing by 0.\n#     is_train : boolean\n#         Whether train or inference.\n#     name : a string or None\n#         An optional name to attach to this layer.\n#\n#     References\n#     ----------\n#     - `tf.nn.batch_normalization <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/g3doc/api_docs/python/functions_and_classes/shard8/tf.nn.batch_normalization.md>`_\n#     - `stackoverflow <http://stackoverflow.com/questions/33949786/how-could-i-use-batch-normalization-in-tensorflow>`_\n#     - `tensorflow.contrib <https://github.com/tensorflow/tensorflow/blob/b826b79718e3e93148c3545e7aa3f90891744cc0/tensorflow/contrib/layers/python/layers/layers.py#L100>`_\n#     """"""\n#     def __init__(\n#         self,\n#         layer = None,\n#         act = tf.identity,\n#         decay = 0.999,\n#         epsilon = 0.001,\n#         is_train = None,\n#         name =\'batchnorm_layer\',\n#     ):\n#         Layer.__init__(self, name=name)\n#         self.inputs = layer.outputs\n#         print(""  [TL] BatchNormLayer %s: decay: %f, epsilon: %f, is_train: %s"" %\n#                             (self.name, decay, epsilon, is_train))\n#         if is_train == None:\n#             raise Exception(""is_train must be True or False"")\n#\n#         # (name, input_var, decay, epsilon, is_train)\n#         inputs_shape = self.inputs.get_shape()\n#         axis = list(range(len(inputs_shape) - 1))\n#         params_shape = inputs_shape[-1:]\n#\n#         with tf.variable_scope(name) as vs:\n#             beta = tf.get_variable(name=\'beta\', shape=params_shape,\n#                                  initializer=tf.constant_initializer(0.0))\n#             gamma = tf.get_variable(name=\'gamma\', shape=params_shape,\n#                                   initializer=tf.constant_initializer(1.0))\n#             batch_mean, batch_var = tf.nn.moments(self.inputs,\n#                                                 axis,\n#                                                 name=\'moments\')\n#             ema = tf.train.ExponentialMovingAverage(decay=decay)\n#\n#             def mean_var_with_update():\n#               ema_apply_op = ema.apply([batch_mean, batch_var])\n#               with tf.control_dependencies([ema_apply_op]):\n#                   return tf.identity(batch_mean), tf.identity(batch_var)\n#\n#             if is_train:\n#                 is_train = tf.cast(tf.ones(1), tf.bool)\n#             else:\n#                 is_train = tf.cast(tf.zeros(1), tf.bool)\n#\n#             is_train = tf.reshape(is_train, [])\n#\n#             # print(is_train)\n#             # exit()\n#\n#             mean, var = tf.cond(\n#               is_train,\n#               mean_var_with_update,\n#               lambda: (ema.average(batch_mean), ema.average(batch_var))\n#             )\n#             normed = tf.nn.batch_normalization(\n#               x=self.inputs,\n#               mean=mean,\n#               variance=var,\n#               offset=beta,\n#               scale=gamma,\n#               variance_epsilon=epsilon,\n#               name=\'tf_bn\'\n#             )\n#         self.outputs = act( normed )\n#\n#         self.all_layers = list(layer.all_layers)\n#         self.all_params = list(layer.all_params)\n#         self.all_drop = dict(layer.all_drop)\n#         self.all_layers.extend( [self.outputs] )\n#         self.all_params.extend( [beta, gamma] )\n\n## Pooling layer\nclass PoolLayer(Layer):\n    """"""\n    The :class:`PoolLayer` class is a Pooling layer, you can choose\n    ``tf.nn.max_pool`` and ``tf.nn.avg_pool`` for 2D or\n    ``tf.nn.max_pool3d`` and ``tf.nn.avg_pool3d`` for 3D.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    ksize : a list of ints that has length >= 4.\n        The size of the window for each dimension of the input tensor.\n    strides : a list of ints that has length >= 4.\n        The stride of the sliding window for each dimension of the input tensor.\n    padding : a string from: ""SAME"", ""VALID"".\n        The type of padding algorithm to use.\n    pool : a pooling function\n        - see `TensorFlow pooling APIs <https://www.tensorflow.org/versions/master/api_docs/python/nn.html#pooling>`_\n        - class ``tf.nn.max_pool``\n        - class ``tf.nn.avg_pool``\n        - class ``tf.nn.max_pool3d``\n        - class ``tf.nn.avg_pool3d``\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    - see :class:`Conv2dLayer`.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 2, 1],\n        padding=\'SAME\',\n        pool = tf.nn.max_pool,\n        name =\'pool_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] PoolLayer   %s: ksize:%s strides:%s padding:%s pool:%s"" %\n                            (self.name, str(ksize), str(strides), padding, pool.__name__))\n\n        self.outputs = pool(self.inputs, ksize=ksize, strides=strides, padding=padding, name=name)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n\n## Padding layer\nclass PadLayer(Layer):\n    """"""\n    The :class:`PadLayer` class is a Padding layer for any modes and dimensions.\n    Please see `tf.pad <https://www.tensorflow.org/api_docs/python/tf/pad>`_ for usage.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    padding : a Tensor of type int32.\n    mode : one of ""CONSTANT"", ""REFLECT"", or ""SYMMETRIC"" (case-insensitive)\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        paddings = None,\n        mode = \'CONSTANT\',\n        name = \'pad_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        assert paddings is not None, ""paddings should be a Tensor of type int32. see https://www.tensorflow.org/api_docs/python/tf/pad""\n        self.inputs = layer.outputs\n        print(""  [TL] PoolLayer   %s: paddings:%s mode:%s"" %\n                            (self.name, list(paddings.get_shape()), mode))\n\n        self.outputs = tf.pad(self.inputs, paddings=paddings, mode=mode, name=name)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n\n## TimeDistributedLayer\nclass TimeDistributedLayer(Layer):\n    """"""\n    The :class:`TimeDistributedLayer` class that applies a function to every timestep of the input tensor.\n    For example, if using :class:`DenseLayer` as the ``layer_class``, inputs [batch_size , length, dim]\n    outputs [batch_size , length, new_dim].\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer, [batch_size , length, dim]\n    layer_class : a :class:`Layer` class\n    args : dictionary\n        The arguments for the ``layer_class``.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    >>> batch_size = 32\n    >>> timestep = 20\n    >>> input_dim = 100\n    >>> x = tf.placeholder(dtype=tf.float32, shape=[batch_size, timestep,  input_dim], name=""encode_seqs"")\n    >>> net = InputLayer(x, name=\'input\')\n    >>> net = TimeDistributedLayer(net, layer_class=DenseLayer, args={\'n_units\':50, \'name\':\'dense\'}, name=\'time_dense\')\n    ... [TL] InputLayer  input: (32, 20, 100)\n    ... [TL] TimeDistributedLayer time_dense: layer_class:DenseLayer\n    >>> print(net.outputs._shape)\n    ... (32, 20, 50)\n    >>> net.print_params(False)\n    ... param   0: (100, 50)          time_dense/dense/W:0\n    ... param   1: (50,)              time_dense/dense/b:0\n    ... num of params: 5050\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        layer_class = None,\n        args = {},\n        name =\'time_distributed\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] TimeDistributedLayer %s: layer_class:%s args:%s"" %\n                            (self.name, layer_class.__name__, args))\n\n        if not args: args = dict()\n        assert isinstance(args, dict), ""\'args\' must be a dict.""\n\n        if not isinstance(self.inputs, tf.Tensor):\n            self.inputs = tf.transpose(tf.stack(self.inputs), [1, 0, 2])\n\n        input_shape = self.inputs.get_shape()\n\n        timestep = input_shape[1]\n        x = tf.unstack(self.inputs, axis=1)\n\n        with ops.suppress_stdout():\n            for i in range(0, timestep):\n                with tf.variable_scope(name, reuse=(False if i==0 else True)) as vs:\n                    set_name_reuse((False if i==0 else True))\n                    net = layer_class(InputLayer(x[i], name=args[\'name\']+str(i)), **args)\n                    # net = layer_class(InputLayer(x[i], name=""input_""+args[\'name\']), **args)\n                    x[i] = net.outputs\n                    variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n        self.outputs = tf.stack(x, axis=1, name=name)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( variables )\n\n\n\n## Recurrent layer\nclass RNNLayer(Layer):\n    """"""\n    The :class:`RNNLayer` class is a RNN layer, you can implement vanilla RNN,\n    LSTM and GRU with it.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    cell_fn : a TensorFlow\'s core RNN cell as follow (Note TF1.0+ and TF1.0- are different).\n        - see `RNN Cells in TensorFlow <https://www.tensorflow.org/api_docs/python/>`_\n    cell_init_args : a dictionary\n        The arguments for the cell initializer.\n    n_hidden : a int\n        The number of hidden units in the layer.\n    initializer : initializer\n        The initializer for initializing the parameters.\n    n_steps : a int\n        The sequence length.\n    initial_state : None or RNN State\n        If None, initial_state is zero_state.\n    return_last : boolean\n        - If True, return the last output, ""Sequence input and single output""\n        - If False, return all outputs, ""Synced sequence input and output""\n        - In other word, if you want to apply one or more RNN(s) on this layer, set to False.\n    return_seq_2d : boolean\n        - When return_last = False\n        - If True, return 2D Tensor [n_example, n_hidden], for stacking DenseLayer after it.\n        - If False, return 3D Tensor [n_example/n_steps, n_steps, n_hidden], for stacking multiple RNN after it.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Variables\n    --------------\n    outputs : a tensor\n        The output of this RNN.\n        return_last = False, outputs = all cell_output, which is the hidden state.\n            cell_output.get_shape() = (?, n_hidden)\n\n    final_state : a tensor or StateTuple\n        When state_is_tuple = False,\n        it is the final hidden and cell states, states.get_shape() = [?, 2 * n_hidden].\\n\n        When state_is_tuple = True, it stores two elements: (c, h), in that order.\n        You can get the final state after each iteration during training, then\n        feed it to the initial state of next iteration.\n\n    initial_state : a tensor or StateTuple\n        It is the initial state of this RNN layer, you can use it to initialize\n        your state at the begining of each epoch or iteration according to your\n        training procedure.\n\n    batch_size : int or tensor\n        Is int, if able to compute the batch_size, otherwise, tensor for ``?``.\n\n    Examples\n    --------\n    - For words\n    >>> input_data = tf.placeholder(tf.int32, [batch_size, num_steps])\n    >>> network = tl.layers.EmbeddingInputlayer(\n    ...                 inputs = input_data,\n    ...                 vocabulary_size = vocab_size,\n    ...                 embedding_size = hidden_size,\n    ...                 E_init = tf.random_uniform_initializer(-init_scale, init_scale),\n    ...                 name =\'embedding_layer\')\n    >>> if is_training:\n    >>>     network = tl.layers.DropoutLayer(network, keep=keep_prob, name=\'drop1\')\n    >>> network = tl.layers.RNNLayer(network,\n    ...             cell_fn=tf.nn.rnn_cell.BasicLSTMCell,\n    ...             cell_init_args={\'forget_bias\': 0.0},# \'state_is_tuple\': True},\n    ...             n_hidden=hidden_size,\n    ...             initializer=tf.random_uniform_initializer(-init_scale, init_scale),\n    ...             n_steps=num_steps,\n    ...             return_last=False,\n    ...             name=\'basic_lstm_layer1\')\n    >>> lstm1 = network\n    >>> if is_training:\n    >>>     network = tl.layers.DropoutLayer(network, keep=keep_prob, name=\'drop2\')\n    >>> network = tl.layers.RNNLayer(network,\n    ...             cell_fn=tf.nn.rnn_cell.BasicLSTMCell,\n    ...             cell_init_args={\'forget_bias\': 0.0}, # \'state_is_tuple\': True},\n    ...             n_hidden=hidden_size,\n    ...             initializer=tf.random_uniform_initializer(-init_scale, init_scale),\n    ...             n_steps=num_steps,\n    ...             return_last=False,\n    ...             return_seq_2d=True,\n    ...             name=\'basic_lstm_layer2\')\n    >>> lstm2 = network\n    >>> if is_training:\n    >>>     network = tl.layers.DropoutLayer(network, keep=keep_prob, name=\'drop3\')\n    >>> network = tl.layers.DenseLayer(network,\n    ...             n_units=vocab_size,\n    ...             W_init=tf.random_uniform_initializer(-init_scale, init_scale),\n    ...             b_init=tf.random_uniform_initializer(-init_scale, init_scale),\n    ...             act = tl.activation.identity, name=\'output_layer\')\n\n    - For CNN+LSTM\n    >>> x = tf.placeholder(tf.float32, shape=[batch_size, image_size, image_size, 1])\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.Conv2dLayer(network,\n    ...                         act = tf.nn.relu,\n    ...                         shape = [5, 5, 1, 32],  # 32 features for each 5x5 patch\n    ...                         strides=[1, 2, 2, 1],\n    ...                         padding=\'SAME\',\n    ...                         name =\'cnn_layer1\')\n    >>> network = tl.layers.PoolLayer(network,\n    ...                         ksize=[1, 2, 2, 1],\n    ...                         strides=[1, 2, 2, 1],\n    ...                         padding=\'SAME\',\n    ...                         pool = tf.nn.max_pool,\n    ...                         name =\'pool_layer1\')\n    >>> network = tl.layers.Conv2dLayer(network,\n    ...                         act = tf.nn.relu,\n    ...                         shape = [5, 5, 32, 10], # 10 features for each 5x5 patch\n    ...                         strides=[1, 2, 2, 1],\n    ...                         padding=\'SAME\',\n    ...                         name =\'cnn_layer2\')\n    >>> network = tl.layers.PoolLayer(network,\n    ...                         ksize=[1, 2, 2, 1],\n    ...                         strides=[1, 2, 2, 1],\n    ...                         padding=\'SAME\',\n    ...                         pool = tf.nn.max_pool,\n    ...                         name =\'pool_layer2\')\n    >>> network = tl.layers.FlattenLayer(network, name=\'flatten_layer\')\n    >>> network = tl.layers.ReshapeLayer(network, shape=[-1, num_steps, int(network.outputs._shape[-1])])\n    >>> rnn1 = tl.layers.RNNLayer(network,\n    ...                         cell_fn=tf.nn.rnn_cell.LSTMCell,\n    ...                         cell_init_args={},\n    ...                         n_hidden=200,\n    ...                         initializer=tf.random_uniform_initializer(-0.1, 0.1),\n    ...                         n_steps=num_steps,\n    ...                         return_last=False,\n    ...                         return_seq_2d=True,\n    ...                         name=\'rnn_layer\')\n    >>> network = tl.layers.DenseLayer(rnn1, n_units=3,\n    ...                         act = tl.activation.identity, name=\'output_layer\')\n\n    Notes\n    -----\n    Input dimension should be rank 3 : [batch_size, n_steps, n_features], if no, please see :class:`ReshapeLayer`.\n\n    References\n    ----------\n    - `Neural Network RNN Cells in TensorFlow <https://www.tensorflow.org/api_docs/python/rnn_cell/>`_\n    - `tensorflow/python/ops/rnn.py <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn.py>`_\n    - `tensorflow/python/ops/rnn_cell.py <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell.py>`_\n    - see TensorFlow tutorial ``ptb_word_lm.py``, TensorLayer tutorials ``tutorial_ptb_lstm*.py`` and ``tutorial_generate_text.py``\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        cell_fn = None,#tf.nn.rnn_cell.BasicRNNCell,\n        cell_init_args = {},\n        n_hidden = 100,\n        initializer = tf.random_uniform_initializer(-0.1, 0.1),\n        n_steps = 5,\n        initial_state = None,\n        return_last = False,\n        # is_reshape = True,\n        return_seq_2d = False,\n        name = \'rnn_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        if cell_fn is None:\n            raise Exception(""Please put in cell_fn"")\n        if \'GRU\' in cell_fn.__name__:\n            try:\n                cell_init_args.pop(\'state_is_tuple\')\n            except:\n                pass\n\n        self.inputs = layer.outputs\n\n        print(""  [TL] RNNLayer %s: n_hidden:%d n_steps:%d in_dim:%d in_shape:%s cell_fn:%s "" % (self.name, n_hidden,\n            n_steps, self.inputs.get_shape().ndims, self.inputs.get_shape(), cell_fn.__name__))\n        # You can get the dimension by .get_shape() or ._shape, and check the\n        # dimension by .with_rank() as follow.\n        # self.inputs.get_shape().with_rank(2)\n        # self.inputs.get_shape().with_rank(3)\n\n        # Input dimension should be rank 3 [batch_size, n_steps(max), n_features]\n        try:\n            self.inputs.get_shape().with_rank(3)\n        except:\n            raise Exception(""RNN : Input dimension should be rank 3 : [batch_size, n_steps, n_features]"")\n\n\n        # is_reshape : boolean (deprecate)\n        #     Reshape the inputs to 3 dimension tensor.\\n\n        #     If input is\xef\xbc\xbbbatch_size, n_steps, n_features], we do not need to reshape it.\\n\n        #     If input is [batch_size * n_steps, n_features], we need to reshape it.\n        # if is_reshape:\n        #     self.inputs = tf.reshape(self.inputs, shape=[-1, n_steps, int(self.inputs._shape[-1])])\n\n        fixed_batch_size = self.inputs.get_shape().with_rank_at_least(1)[0]\n\n        if fixed_batch_size.value:\n            batch_size = fixed_batch_size.value\n            print(""       RNN batch_size (concurrent processes): %d"" % batch_size)\n        else:\n            from tensorflow.python.ops import array_ops\n            batch_size = array_ops.shape(self.inputs)[0]\n            print(""       non specified batch_size, uses a tensor instead."")\n        self.batch_size = batch_size\n\n        # Simplified version of tensorflow.models.rnn.rnn.py\'s rnn().\n        # This builds an unrolled LSTM for tutorial purposes only.\n        # In general, use the rnn() or state_saving_rnn() from rnn.py.\n        #\n        # The alternative version of the code below is:\n        #\n        # from tensorflow.models.rnn import rnn\n        # inputs = [tf.squeeze(input_, [1])\n        #           for input_ in tf.split(1, num_steps, inputs)]\n        # outputs, state = rnn.rnn(cell, inputs, initial_state=self._initial_state)\n        outputs = []\n        self.cell = cell = cell_fn(num_units=n_hidden, **cell_init_args)\n        if initial_state is None:\n            self.initial_state = cell.zero_state(batch_size, dtype=tf.float32)  # 1.2.3\n        state = self.initial_state\n        # with tf.variable_scope(""model"", reuse=None, initializer=initializer):\n        with tf.variable_scope(name, initializer=initializer) as vs:\n            for time_step in range(n_steps):\n                if time_step > 0: tf.get_variable_scope().reuse_variables()\n                (cell_output, state) = cell(self.inputs[:, time_step, :], state)\n                outputs.append(cell_output)\n\n            # Retrieve just the RNN variables.\n            # rnn_variables = [v for v in tf.all_variables() if v.name.startswith(vs.name)]\n            rnn_variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n        print(""     n_params : %d"" % (len(rnn_variables)))\n\n        if return_last:\n            # 2D Tensor [batch_size, n_hidden]\n            self.outputs = outputs[-1]\n        else:\n            if return_seq_2d:\n                # PTB tutorial: stack dense layer after that, or compute the cost from the output\n                # 2D Tensor [n_example, n_hidden]\n                try: # TF1.0\n                    self.outputs = tf.reshape(tf.concat(outputs, 1), [-1, n_hidden])\n                except: # TF0.12\n                    self.outputs = tf.reshape(tf.concat(1, outputs), [-1, n_hidden])\n\n\n            else:\n                # <akara>: stack more RNN layer after that\n                # 3D Tensor [n_example/n_steps, n_steps, n_hidden]\n                try: # TF1.0\n                    self.outputs = tf.reshape(tf.concat(outputs, 1), [-1, n_steps, n_hidden])\n                except: # TF0.12\n                    self.outputs = tf.reshape(tf.concat(1, outputs), [-1, n_steps, n_hidden])\n\n        self.final_state = state\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        # print(type(self.outputs))\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( rnn_variables )\n\nclass BiRNNLayer(Layer):\n    """"""\n    The :class:`BiRNNLayer` class is a Bidirectional RNN layer.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    cell_fn : a TensorFlow\'s core RNN cell as follow (Note TF1.0+ and TF1.0- are different).\n        - see `RNN Cells in TensorFlow <https://www.tensorflow.org/api_docs/python/>`_\n    cell_init_args : a dictionary\n        The arguments for the cell initializer.\n    n_hidden : a int\n        The number of hidden units in the layer.\n    initializer : initializer\n        The initializer for initializing the parameters.\n    n_steps : a int\n        The sequence length.\n    fw_initial_state : None or forward RNN State\n        If None, initial_state is zero_state.\n    bw_initial_state : None or backward RNN State\n        If None, initial_state is zero_state.\n    dropout : `tuple` of `float`: (input_keep_prob, output_keep_prob).\n        The input and output keep probability.\n    n_layer : a int, default is 1.\n        The number of RNN layers.\n    return_last : boolean\n        - If True, return the last output, ""Sequence input and single output""\n        - If False, return all outputs, ""Synced sequence input and output""\n        - In other word, if you want to apply one or more RNN(s) on this layer, set to False.\n    return_seq_2d : boolean\n        - When return_last = False\n        - If True, return 2D Tensor [n_example, n_hidden], for stacking DenseLayer after it.\n        - If False, return 3D Tensor [n_example/n_steps, n_steps, n_hidden], for stacking multiple RNN after it.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Variables\n    --------------\n    outputs : a tensor\n        The output of this RNN.\n        return_last = False, outputs = all cell_output, which is the hidden state.\n            cell_output.get_shape() = (?, n_hidden)\n\n    fw(bw)_final_state : a tensor or StateTuple\n        When state_is_tuple = False,\n        it is the final hidden and cell states, states.get_shape() = [?, 2 * n_hidden].\\n\n        When state_is_tuple = True, it stores two elements: (c, h), in that order.\n        You can get the final state after each iteration during training, then\n        feed it to the initial state of next iteration.\n\n    fw(bw)_initial_state : a tensor or StateTuple\n        It is the initial state of this RNN layer, you can use it to initialize\n        your state at the begining of each epoch or iteration according to your\n        training procedure.\n\n    batch_size : int or tensor\n        Is int, if able to compute the batch_size, otherwise, tensor for ``?``.\n\n    Notes\n    -----\n    - Input dimension should be rank 3 : [batch_size, n_steps, n_features], if no, please see :class:`ReshapeLayer`.\n    - For predicting, the sequence length has to be the same with the sequence length of training, while, for normal\n    RNN, we can use sequence length of 1 for predicting.\n\n    References\n    ----------\n    - `Source <https://github.com/akaraspt/deepsleep/blob/master/deepsleep/model.py>`_\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        cell_fn = None, #tf.nn.rnn_cell.LSTMCell,\n        cell_init_args = {\'use_peepholes\':True, \'state_is_tuple\':True},\n        n_hidden = 100,\n        initializer = tf.random_uniform_initializer(-0.1, 0.1),\n        n_steps = 5,\n        fw_initial_state = None,\n        bw_initial_state = None,\n        dropout = None,\n        n_layer = 1,\n        return_last = False,\n        return_seq_2d = False,\n        name = \'birnn_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        if cell_fn is None:\n            raise Exception(""Please put in cell_fn"")\n        if \'GRU\' in cell_fn.__name__:\n            try:\n                cell_init_args.pop(\'state_is_tuple\')\n            except:\n                pass\n\n        self.inputs = layer.outputs\n\n        print(""  [TL] BiRNNLayer %s: n_hidden:%d n_steps:%d in_dim:%d in_shape:%s cell_fn:%s dropout:%s n_layer:%d "" % (self.name, n_hidden,\n            n_steps, self.inputs.get_shape().ndims, self.inputs.get_shape(), cell_fn.__name__, dropout, n_layer))\n\n        fixed_batch_size = self.inputs.get_shape().with_rank_at_least(1)[0]\n\n        if fixed_batch_size.value:\n            self.batch_size = fixed_batch_size.value\n            print(""       RNN batch_size (concurrent processes): %d"" % self.batch_size)\n        else:\n            from tensorflow.python.ops import array_ops\n            self.batch_size = array_ops.shape(self.inputs)[0]\n            print(""       non specified batch_size, uses a tensor instead."")\n\n        # Input dimension should be rank 3 [batch_size, n_steps(max), n_features]\n        try:\n            self.inputs.get_shape().with_rank(3)\n        except:\n            raise Exception(""RNN : Input dimension should be rank 3 : [batch_size, n_steps, n_features]"")\n\n        with tf.variable_scope(name, initializer=initializer) as vs:\n            self.fw_cell = cell_fn(num_units=n_hidden, **cell_init_args)\n            self.bw_cell = cell_fn(num_units=n_hidden, **cell_init_args)\n            # Apply dropout\n            if dropout:\n                if type(dropout) in [tuple, list]:\n                    in_keep_prob = dropout[0]\n                    out_keep_prob = dropout[1]\n                elif isinstance(dropout, float):\n                    in_keep_prob, out_keep_prob = dropout, dropout\n                else:\n                    raise Exception(""Invalid dropout type (must be a 2-D tuple of ""\n                                    ""float)"")\n                try: # TF 1.0\n                    DropoutWrapper_fn = tf.contrib.rnn.DropoutWrapper\n                except:\n                    DropoutWrapper_fn = tf.nn.rnn_cell.DropoutWrapper\n                self.fw_cell = DropoutWrapper_fn(\n                          self.fw_cell,\n                          input_keep_prob=in_keep_prob,\n                          output_keep_prob=out_keep_prob)\n                self.bw_cell = DropoutWrapper_fn(\n                          self.bw_cell,\n                          input_keep_prob=in_keep_prob,\n                          output_keep_prob=out_keep_prob)\n            # Apply multiple layers\n            if n_layer > 1:\n                try: # TF1.0\n                    MultiRNNCell_fn = tf.contrib.rnn.MultiRNNCell\n                except:\n                    MultiRNNCell_fn = tf.nn.rnn_cell.MultiRNNCell\n\n                try:\n                    self.fw_cell = MultiRNNCell_fn([self.fw_cell] * n_layer,\n                                                          state_is_tuple=True)\n                    self.bw_cell = MultiRNNCell_fn([self.bw_cell] * n_layer,\n                                                          state_is_tuple=True)\n                except:\n                    self.fw_cell = MultiRNNCell_fn([self.fw_cell] * n_layer)\n                    self.bw_cell = MultiRNNCell_fn([self.bw_cell] * n_layer)\n\n            # Initial state of RNN\n            if fw_initial_state is None:\n                self.fw_initial_state = self.fw_cell.zero_state(self.batch_size, dtype=tf.float32)\n            else:\n                self.fw_initial_state = fw_initial_state\n            if bw_initial_state is None:\n                self.bw_initial_state = self.bw_cell.zero_state(self.batch_size, dtype=tf.float32)\n            else:\n                self.bw_initial_state = bw_initial_state\n            # exit()\n            # Feedforward to MultiRNNCell\n            try: ## TF1.0\n                list_rnn_inputs = tf.unstack(self.inputs, axis=1)\n            except: ## TF0.12\n                list_rnn_inputs = tf.unpack(self.inputs, axis=1)\n\n            try: # TF1.0\n                bidirectional_rnn_fn = tf.contrib.rnn.static_bidirectional_rnn\n            except:\n                bidirectional_rnn_fn = tf.nn.bidirectional_rnn\n            outputs, fw_state, bw_state = bidirectional_rnn_fn(               # outputs, fw_state, bw_state = tf.contrib.rnn.static_bidirectional_rnn(\n                cell_fw=self.fw_cell,\n                cell_bw=self.bw_cell,\n                inputs=list_rnn_inputs,\n                initial_state_fw=self.fw_initial_state,\n                initial_state_bw=self.bw_initial_state\n            )\n\n            if return_last:\n                self.outputs = outputs[-1]\n            else:\n                self.outputs = outputs\n                if return_seq_2d:\n                    # 2D Tensor [n_example, n_hidden]\n                    try: # TF1.0\n                        self.outputs = tf.reshape(tf.concat(outputs, 1), [-1, n_hidden*2])\n                    except: # TF0.12\n                        self.outputs = tf.reshape(tf.concat(1, outputs), [-1, n_hidden*2])\n                else:\n                    # <akara>: stack more RNN layer after that\n                    # 3D Tensor [n_example/n_steps, n_steps, n_hidden]\n\n                    try: # TF1.0\n                        self.outputs = tf.reshape(tf.concat(outputs,1), [-1, n_steps, n_hidden*2])\n                    except: # TF0.12\n                        self.outputs = tf.reshape(tf.concat(1, outputs), [-1, n_steps, n_hidden*2])\n            self.fw_final_state = fw_state\n            self.bw_final_state = bw_state\n\n            # Retrieve just the RNN variables.\n            rnn_variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n        print(""     n_params : %d"" % (len(rnn_variables)))\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( rnn_variables )\n\n# Advanced Ops for Dynamic RNN\ndef advanced_indexing_op(input, index):\n    """"""Advanced Indexing for Sequences, returns the outputs by given sequence lengths.\n    When return the last output :class:`DynamicRNNLayer` uses it to get the last outputs with the sequence lengths.\n\n    Parameters\n    -----------\n    input : tensor for data\n        [batch_size, n_step(max), n_features]\n    index : tensor for indexing, i.e. sequence_length in Dynamic RNN.\n        [batch_size]\n\n    Examples\n    ---------\n    >>> batch_size, max_length, n_features = 3, 5, 2\n    >>> z = np.random.uniform(low=-1, high=1, size=[batch_size, max_length, n_features]).astype(np.float32)\n    >>> b_z = tf.constant(z)\n    >>> sl = tf.placeholder(dtype=tf.int32, shape=[batch_size])\n    >>> o = advanced_indexing_op(b_z, sl)\n    >>>\n    >>> sess = tf.InteractiveSession()\n    >>> tl.layers.initialize_global_variables(sess)\n    >>>\n    >>> order = np.asarray([1,1,2])\n    >>> print(""real"",z[0][order[0]-1], z[1][order[1]-1], z[2][order[2]-1])\n    >>> y = sess.run([o], feed_dict={sl:order})\n    >>> print(""given"",order)\n    >>> print(""out"", y)\n    ... real [-0.93021595  0.53820813] [-0.92548317 -0.77135968] [ 0.89952248  0.19149846]\n    ... given [1 1 2]\n    ... out [array([[-0.93021595,  0.53820813],\n    ...             [-0.92548317, -0.77135968],\n    ...             [ 0.89952248,  0.19149846]], dtype=float32)]\n\n    References\n    -----------\n    - Modified from TFlearn (the original code is used for fixed length rnn), `references <https://github.com/tflearn/tflearn/blob/master/tflearn/layers/recurrent.py>`_.\n    """"""\n    batch_size = tf.shape(input)[0]\n    # max_length = int(input.get_shape()[1])    # for fixed length rnn, length is given\n    max_length = tf.shape(input)[1]             # for dynamic_rnn, length is unknown\n    dim_size = int(input.get_shape()[2])\n    index = tf.range(0, batch_size) * max_length + (index - 1)\n    flat = tf.reshape(input, [-1, dim_size])\n    relevant = tf.gather(flat, index)\n    return relevant\n\ndef retrieve_seq_length_op(data):\n    """"""An op to compute the length of a sequence from input shape of [batch_size, n_step(max), n_features],\n    it can be used when the features of padding (on right hand side) are all zeros.\n\n    Parameters\n    -----------\n    data : tensor\n        [batch_size, n_step(max), n_features] with zero padding on right hand side.\n\n    Examples\n    ---------\n    >>> data = [[[1],[2],[0],[0],[0]],\n    ...         [[1],[2],[3],[0],[0]],\n    ...         [[1],[2],[6],[1],[0]]]\n    >>> data = np.asarray(data)\n    >>> print(data.shape)\n    ... (3, 5, 1)\n    >>> data = tf.constant(data)\n    >>> sl = retrieve_seq_length_op(data)\n    >>> sess = tf.InteractiveSession()\n    >>> tl.layers.initialize_global_variables(sess)\n    >>> y = sl.eval()\n    ... [2 3 4]\n\n    - Multiple features\n    >>> data = [[[1,2],[2,2],[1,2],[1,2],[0,0]],\n    ...         [[2,3],[2,4],[3,2],[0,0],[0,0]],\n    ...         [[3,3],[2,2],[5,3],[1,2],[0,0]]]\n    >>> sl\n    ... [4 3 4]\n\n    References\n    ------------\n    - Borrow from `TFlearn <https://github.com/tflearn/tflearn/blob/master/tflearn/layers/recurrent.py>`_.\n    """"""\n    with tf.name_scope(\'GetLength\'):\n        ## TF 1.0 change reduction_indices to axis\n        used = tf.sign(tf.reduce_max(tf.abs(data), 2))\n        length = tf.reduce_sum(used, 1)\n        ## TF < 1.0\n        # used = tf.sign(tf.reduce_max(tf.abs(data), reduction_indices=2))\n        # length = tf.reduce_sum(used, reduction_indices=1)\n        length = tf.cast(length, tf.int32)\n    return length\n\ndef retrieve_seq_length_op2(data):\n    """"""An op to compute the length of a sequence, from input shape of [batch_size, n_step(max)],\n    it can be used when the features of padding (on right hand side) are all zeros.\n\n    Parameters\n    -----------\n    data : tensor\n        [batch_size, n_step(max)] with zero padding on right hand side.\n\n    Examples\n    --------\n    >>> data = [[1,2,0,0,0],\n    ...         [1,2,3,0,0],\n    ...         [1,2,6,1,0]]\n    >>> o = retrieve_seq_length_op2(data)\n    >>> sess = tf.InteractiveSession()\n    >>> tl.layers.initialize_global_variables(sess)\n    >>> print(o.eval())\n    ... [2 3 4]\n    """"""\n    return tf.reduce_sum(tf.cast(tf.greater(data, tf.zeros_like(data)), tf.int32), 1)\n\n\ndef retrieve_seq_length_op3(data, pad_val=0):\n    data_shape_size = data.get_shape().ndims\n    if data_shape_size == 3:\n        return tf.reduce_sum(tf.cast(tf.reduce_any(tf.not_equal(data, pad_val), axis=2), dtype=tf.int32), 1)\n    elif data_shape_size == 2:\n        return tf.reduce_sum(tf.cast(tf.not_equal(data, pad_val), dtype=tf.int32), 1)\n    elif data_shape_size == 1:\n        raise ValueError(""retrieve_seq_length_op3: data has wrong shape!"")\n    else:\n        raise ValueError(""retrieve_seq_length_op3: handling data_shape_size %s hasn\'t been implemented!"" % (data_shape_size))\n\n\ndef target_mask_op(data, pad_val=0):\n    data_shape_size = data.get_shape().ndims\n    if data_shape_size == 3:\n        return tf.cast(tf.reduce_any(tf.not_equal(data, pad_val), axis=2), dtype=tf.int32)\n    elif data_shape_size == 2:\n        return tf.cast(tf.not_equal(data, pad_val), dtype=tf.int32)\n    elif data_shape_size == 1:\n        raise ValueError(""target_mask_op: data has wrong shape!"")\n    else:\n        raise ValueError(""target_mask_op: handling data_shape_size %s hasn\'t been implemented!"" % (data_shape_size))\n\n\n# Dynamic RNN\nclass DynamicRNNLayer(Layer):\n    """"""\n    The :class:`DynamicRNNLayer` class is a Dynamic RNN layer, see ``tf.nn.dynamic_rnn``.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    cell_fn : a TensorFlow\'s core RNN cell as follow (Note TF1.0+ and TF1.0- are different).\n        - see `RNN Cells in TensorFlow <https://www.tensorflow.org/api_docs/python/>`_\n    cell_init_args : a dictionary\n        The arguments for the cell initializer.\n    n_hidden : a int\n        The number of hidden units in the layer.\n    initializer : initializer\n        The initializer for initializing the parameters.\n    sequence_length : a tensor, array or None. The sequence length of each row of input data, see ``Advanced Ops for Dynamic RNN``.\n        - If None, it uses ``retrieve_seq_length_op`` to compute the sequence_length, i.e. when the features of padding (on right hand side) are all zeros.\n        - If using word embedding, you may need to compute the sequence_length from the ID array (the integer features before word embedding) by using ``retrieve_seq_length_op2`` or ``retrieve_seq_length_op``.\n        - You can also input an numpy array.\n        - More details about TensorFlow dynamic_rnn in `Wild-ML Blog <http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/>`_.\n    initial_state : None or RNN State\n        If None, initial_state is zero_state.\n    dropout : `tuple` of `float`: (input_keep_prob, output_keep_prob).\n        The input and output keep probability.\n    n_layer : a int, default is 1.\n        The number of RNN layers.\n    return_last : boolean\n        - If True, return the last output, ""Sequence input and single output""\n        - If False, return all outputs, ""Synced sequence input and output""\n        - In other word, if you want to apply one or more RNN(s) on this layer, set to False.\n    return_seq_2d : boolean\n        - When return_last = False\n        - If True, return 2D Tensor [n_example, n_hidden], for stacking DenseLayer or computing cost after it.\n        - If False, return 3D Tensor [n_example/n_steps(max), n_steps(max), n_hidden], for stacking multiple RNN after it.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Variables\n    ------------\n    outputs : a tensor\n        The output of this RNN.\n        return_last = False, outputs = all cell_output, which is the hidden state.\n            cell_output.get_shape() = (?, n_hidden)\n\n    final_state : a tensor or StateTuple\n        When state_is_tuple = False,\n        it is the final hidden and cell states, states.get_shape() = [?, 2 * n_hidden].\\n\n        When state_is_tuple = True, it stores two elements: (c, h), in that order.\n        You can get the final state after each iteration during training, then\n        feed it to the initial state of next iteration.\n\n    initial_state : a tensor or StateTuple\n        It is the initial state of this RNN layer, you can use it to initialize\n        your state at the begining of each epoch or iteration according to your\n        training procedure.\n\n    sequence_length : a tensor or array, shape = [batch_size]\n        The sequence lengths computed by Advanced Opt or the given sequence lengths.\n\n    Notes\n    -----\n    Input dimension should be rank 3 : [batch_size, n_steps(max), n_features], if no, please see :class:`ReshapeLayer`.\n\n    Examples\n    --------\n    >>> input_seqs = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=""input_seqs"")\n    >>> network = tl.layers.EmbeddingInputlayer(\n    ...             inputs = input_seqs,\n    ...             vocabulary_size = vocab_size,\n    ...             embedding_size = embedding_size,\n    ...             name = \'seq_embedding\')\n    >>> network = tl.layers.DynamicRNNLayer(network,\n    ...             cell_fn = tf.contrib.rnn.BasicLSTMCell, # for TF0.2 tf.nn.rnn_cell.BasicLSTMCell,\n    ...             n_hidden = embedding_size,\n    ...             dropout = 0.7,\n    ...             sequence_length = tl.layers.retrieve_seq_length_op2(input_seqs),\n    ...             return_seq_2d = True,     # stack denselayer or compute cost after it\n    ...             name = \'dynamic_rnn\')\n    ... network = tl.layers.DenseLayer(network, n_units=vocab_size,\n    ...             act=tf.identity, name=""output"")\n\n    References\n    ----------\n    - `Wild-ML Blog <http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/>`_\n    - `dynamic_rnn.ipynb <https://github.com/dennybritz/tf-rnn/blob/master/dynamic_rnn.ipynb>`_\n    - `tf.nn.dynamic_rnn <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/g3doc/api_docs/python/functions_and_classes/shard8/tf.nn.dynamic_rnn.md>`_\n    - `tflearn rnn <https://github.com/tflearn/tflearn/blob/master/tflearn/layers/recurrent.py>`_\n    - ``tutorial_dynamic_rnn.py``\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        cell_fn = None,#tf.nn.rnn_cell.LSTMCell,\n        cell_init_args = {\'state_is_tuple\' : True},\n        n_hidden = 256,\n        initializer = tf.random_uniform_initializer(-0.1, 0.1),\n        sequence_length = None,\n        initial_state = None,\n        dropout = None,\n        n_layer = 1,\n        return_last = False,\n        return_seq_2d = False,\n        dynamic_rnn_init_args={},\n        name = \'dyrnn_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        if cell_fn is None:\n            raise Exception(""Please put in cell_fn"")\n        if \'GRU\' in cell_fn.__name__:\n            try:\n                cell_init_args.pop(\'state_is_tuple\')\n            except:\n                pass\n        self.inputs = layer.outputs\n\n        print(""  [TL] DynamicRNNLayer %s: n_hidden:%d, in_dim:%d in_shape:%s cell_fn:%s dropout:%s n_layer:%d"" % (self.name, n_hidden,\n             self.inputs.get_shape().ndims, self.inputs.get_shape(), cell_fn.__name__, dropout, n_layer))\n\n        # Input dimension should be rank 3 [batch_size, n_steps(max), n_features]\n        try:\n            self.inputs.get_shape().with_rank(3)\n        except:\n            raise Exception(""RNN : Input dimension should be rank 3 : [batch_size, n_steps(max), n_features]"")\n\n        # Get the batch_size\n        fixed_batch_size = self.inputs.get_shape().with_rank_at_least(1)[0]\n        if fixed_batch_size.value:\n            batch_size = fixed_batch_size.value\n            print(""       batch_size (concurrent processes): %d"" % batch_size)\n        else:\n            from tensorflow.python.ops import array_ops\n            batch_size = array_ops.shape(self.inputs)[0]\n            print(""       non specified batch_size, uses a tensor instead."")\n        self.batch_size = batch_size\n\n        # Creats the cell function\n        # cell_instance_fn=lambda: cell_fn(num_units=n_hidden, **cell_init_args) # HanSheng\n        self.cell = cell_fn(num_units=n_hidden, **cell_init_args)\n\n        # Apply dropout\n        if dropout:\n            if type(dropout) in [tuple, list]:\n                in_keep_prob = dropout[0]\n                out_keep_prob = dropout[1]\n            elif isinstance(dropout, float):\n                in_keep_prob, out_keep_prob = dropout, dropout\n            else:\n                raise Exception(""Invalid dropout type (must be a 2-D tuple of ""\n                                ""float)"")\n            try: # TF1.0\n                DropoutWrapper_fn = tf.contrib.rnn.DropoutWrapper\n            except:\n                DropoutWrapper_fn = tf.nn.rnn_cell.DropoutWrapper\n\n            # cell_instance_fn1=cell_instance_fn        # HanSheng\n            # cell_instance_fn=DropoutWrapper_fn(\n            #                     cell_instance_fn1(),\n            #                     input_keep_prob=in_keep_prob,\n            #                     output_keep_prob=out_keep_prob)\n            self.cell = DropoutWrapper_fn(self.cell,\n                      input_keep_prob=in_keep_prob, output_keep_prob=1.0)#out_keep_prob)\n\n        # Apply multiple layers\n        if n_layer > 1:\n            try:\n                MultiRNNCell_fn = tf.contrib.rnn.MultiRNNCell\n            except:\n                MultiRNNCell_fn = tf.nn.rnn_cell.MultiRNNCell\n\n            # cell_instance_fn2=cell_instance_fn # HanSheng\n            try:\n                # cell_instance_fn=lambda: MultiRNNCell_fn([cell_instance_fn2() for _ in range(n_layer)], state_is_tuple=True) # HanSheng\n                self.cell = MultiRNNCell_fn([self.cell] * n_layer, state_is_tuple=True)\n            except: # when GRU\n                # cell_instance_fn=lambda: MultiRNNCell_fn([cell_instance_fn2() for _ in range(n_layer)]) # HanSheng\n                self.cell = MultiRNNCell_fn([self.cell] * n_layer)\n\n        if dropout:\n            self.cell = DropoutWrapper_fn(self.cell,\n                      input_keep_prob=1.0, output_keep_prob=out_keep_prob)\n\n        # self.cell=cell_instance_fn() # HanSheng\n\n        # Initialize initial_state\n        if initial_state is None:\n            self.initial_state = self.cell.zero_state(batch_size, dtype=tf.float32)\n        else:\n            self.initial_state = initial_state\n\n        # Computes sequence_length\n        if sequence_length is None:\n            try: ## TF1.0\n                sequence_length = retrieve_seq_length_op(\n                            self.inputs if isinstance(self.inputs, tf.Tensor) else tf.stack(self.inputs))\n            except: ## TF0.12\n                sequence_length = retrieve_seq_length_op(\n                            self.inputs if isinstance(self.inputs, tf.Tensor) else tf.pack(self.inputs))\n\n        # Main - Computes outputs and last_states\n        with tf.variable_scope(name, initializer=initializer) as vs:\n            outputs, last_states = tf.nn.dynamic_rnn(\n                cell=self.cell,\n                # inputs=X\n                inputs = self.inputs,\n                # dtype=tf.float64,\n                sequence_length=sequence_length,\n                initial_state = self.initial_state,\n                **dynamic_rnn_init_args\n                )\n            rnn_variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n            # print(""     n_params : %d"" % (len(rnn_variables)))\n            # Manage the outputs\n            if return_last:\n                # [batch_size, n_hidden]\n                # outputs = tf.transpose(tf.pack(outputs), [1, 0, 2]) # TF1.0 tf.pack --> tf.stack\n                self.outputs = advanced_indexing_op(outputs, sequence_length)\n            else:\n                # [batch_size, n_step(max), n_hidden]\n                # self.outputs = result[0][""outputs""]\n                # self.outputs = outputs    # it is 3d, but it is a list\n                if return_seq_2d:\n                    # PTB tutorial:\n                    # 2D Tensor [n_example, n_hidden]\n                    try: # TF1.0\n                        self.outputs = tf.reshape(tf.concat(outputs, 1), [-1, n_hidden])\n                    except: # TF0.12\n                        self.outputs = tf.reshape(tf.concat(1, outputs), [-1, n_hidden])\n                else:\n                    # <akara>:\n                    # 3D Tensor [batch_size, n_steps(max), n_hidden]\n                    max_length = tf.shape(outputs)[1]\n                    batch_size = tf.shape(outputs)[0]\n\n\n                    try: # TF1.0\n                        self.outputs = tf.reshape(tf.concat(outputs, 1), [batch_size, max_length, n_hidden])\n                    except: # TF0.12\n                        self.outputs = tf.reshape(tf.concat(1, outputs), [batch_size, max_length, n_hidden])\n                    # self.outputs = tf.reshape(tf.concat(1, outputs), [-1, max_length, n_hidden])\n\n        # Final state\n        self.final_state = last_states\n\n        self.sequence_length = sequence_length\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( rnn_variables )\n\n# Bidirectional Dynamic RNN\nclass BiDynamicRNNLayer(Layer):\n    """"""\n    The :class:`BiDynamicRNNLayer` class is a RNN layer, you can implement vanilla RNN,\n    LSTM and GRU with it.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    cell_fn : a TensorFlow\'s core RNN cell as follow (Note TF1.0+ and TF1.0- are different).\n        - see `RNN Cells in TensorFlow <https://www.tensorflow.org/api_docs/python/>`_\n    cell_init_args : a dictionary\n        The arguments for the cell initializer.\n    n_hidden : a int\n        The number of hidden units in the layer.\n    initializer : initializer\n        The initializer for initializing the parameters.\n    sequence_length : a tensor, array or None\n        The sequence length of each row of input data, see ``Advanced Ops for Dynamic RNN``.\n            - If None, it uses ``retrieve_seq_length_op`` to compute the sequence_length, i.e. when the features of padding (on right hand side) are all zeros.\n            - If using word embedding, you may need to compute the sequence_length from the ID array (the integer features before word embedding) by using ``retrieve_seq_length_op2`` or ``retrieve_seq_length_op``.\n            - You can also input an numpy array.\n            - More details about TensorFlow dynamic_rnn in `Wild-ML Blog <http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/>`_.\n    fw_initial_state : None or forward RNN State\n        If None, initial_state is zero_state.\n    bw_initial_state : None or backward RNN State\n        If None, initial_state is zero_state.\n    dropout : `tuple` of `float`: (input_keep_prob, output_keep_prob).\n        The input and output keep probability.\n    n_layer : a int, default is 1.\n        The number of RNN layers.\n    return_last : boolean\n        If True, return the last output, ""Sequence input and single output""\\n\n        If False, return all outputs, ""Synced sequence input and output""\\n\n        In other word, if you want to apply one or more RNN(s) on this layer, set to False.\n    return_seq_2d : boolean\n        - When return_last = False\n        - If True, return 2D Tensor [n_example, 2 * n_hidden], for stacking DenseLayer or computing cost after it.\n        - If False, return 3D Tensor [n_example/n_steps(max), n_steps(max), 2 * n_hidden], for stacking multiple RNN after it.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Variables\n    -----------------------\n    outputs : a tensor\n        The output of this RNN.\n        return_last = False, outputs = all cell_output, which is the hidden state.\n            cell_output.get_shape() = (?, 2 * n_hidden)\n\n    fw(bw)_final_state : a tensor or StateTuple\n        When state_is_tuple = False,\n        it is the final hidden and cell states, states.get_shape() = [?, 2 * n_hidden].\\n\n        When state_is_tuple = True, it stores two elements: (c, h), in that order.\n        You can get the final state after each iteration during training, then\n        feed it to the initial state of next iteration.\n\n    fw(bw)_initial_state : a tensor or StateTuple\n        It is the initial state of this RNN layer, you can use it to initialize\n        your state at the begining of each epoch or iteration according to your\n        training procedure.\n\n    sequence_length : a tensor or array, shape = [batch_size]\n        The sequence lengths computed by Advanced Opt or the given sequence lengths.\n\n    Notes\n    -----\n    Input dimension should be rank 3 : [batch_size, n_steps(max), n_features], if no, please see :class:`ReshapeLayer`.\n\n\n    References\n    ----------\n    - `Wild-ML Blog <http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/>`_\n    - `bidirectional_rnn.ipynb <https://github.com/dennybritz/tf-rnn/blob/master/bidirectional_rnn.ipynb>`_\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        cell_fn = None,#tf.nn.rnn_cell.LSTMCell,\n        cell_init_args = {\'state_is_tuple\':True},\n        n_hidden = 256,\n        initializer = tf.random_uniform_initializer(-0.1, 0.1),\n        sequence_length = None,\n        fw_initial_state = None,\n        bw_initial_state = None,\n        dropout = None,\n        n_layer = 1,\n        return_last = False,\n        return_seq_2d = False,\n        dynamic_rnn_init_args={},\n        name = \'bi_dyrnn_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        if cell_fn is None:\n            raise Exception(""Please put in cell_fn"")\n        if \'GRU\' in cell_fn.__name__:\n            try:\n                cell_init_args.pop(\'state_is_tuple\')\n            except:\n                pass\n        self.inputs = layer.outputs\n\n        print(""  [TL] BiDynamicRNNLayer %s: n_hidden:%d in_dim:%d in_shape:%s cell_fn:%s dropout:%s n_layer:%d"" %\n              (self.name, n_hidden, self.inputs.get_shape().ndims, self.inputs.get_shape(), cell_fn.__name__, dropout, n_layer))\n\n        # Input dimension should be rank 3 [batch_size, n_steps(max), n_features]\n        try:\n            self.inputs.get_shape().with_rank(3)\n        except:\n            raise Exception(""RNN : Input dimension should be rank 3 : [batch_size, n_steps(max), n_features]"")\n\n        # Get the batch_size\n        fixed_batch_size = self.inputs.get_shape().with_rank_at_least(1)[0]\n        if fixed_batch_size.value:\n            batch_size = fixed_batch_size.value\n            print(""       batch_size (concurrent processes): %d"" % batch_size)\n        else:\n            from tensorflow.python.ops import array_ops\n            batch_size = array_ops.shape(self.inputs)[0]\n            print(""       non specified batch_size, uses a tensor instead."")\n        self.batch_size = batch_size\n\n        with tf.variable_scope(name, initializer=initializer) as vs:\n            # Creats the cell function\n            # cell_instance_fn=lambda: cell_fn(num_units=n_hidden, **cell_init_args) # HanSheng\n            self.fw_cell = cell_fn(num_units=n_hidden, **cell_init_args)\n            self.bw_cell = cell_fn(num_units=n_hidden, **cell_init_args)\n\n            # Apply dropout\n            if dropout:\n                if type(dropout) in [tuple, list]:\n                    in_keep_prob = dropout[0]\n                    out_keep_prob = dropout[1]\n                elif isinstance(dropout, float):\n                    in_keep_prob, out_keep_prob = dropout, dropout\n                else:\n                    raise Exception(""Invalid dropout type (must be a 2-D tuple of ""\n                                    ""float)"")\n                try:\n                    DropoutWrapper_fn = tf.contrib.rnn.DropoutWrapper\n                except:\n                    DropoutWrapper_fn = tf.nn.rnn_cell.DropoutWrapper\n\n                    # cell_instance_fn1=cell_instance_fn            # HanSheng\n                    # cell_instance_fn=lambda: DropoutWrapper_fn(\n                    #                     cell_instance_fn1(),\n                    #                     input_keep_prob=in_keep_prob,\n                    #                     output_keep_prob=out_keep_prob)\n\n                self.fw_cell = DropoutWrapper_fn(\n                    self.fw_cell,\n                    input_keep_prob=in_keep_prob,\n                    output_keep_prob=out_keep_prob)\n                self.bw_cell = DropoutWrapper_fn(\n                    self.bw_cell,\n                    input_keep_prob=in_keep_prob,\n                    output_keep_prob=out_keep_prob)\n            # Apply multiple layers\n            if n_layer > 1:\n                try:\n                    MultiRNNCell_fn = tf.contrib.rnn.MultiRNNCell\n                except:\n                    MultiRNNCell_fn = tf.nn.rnn_cell.MultiRNNCell\n\n                # cell_instance_fn2=cell_instance_fn            # HanSheng\n                # cell_instance_fn=lambda: MultiRNNCell_fn([cell_instance_fn2() for _ in range(n_layer)])\n                self.fw_cell = MultiRNNCell_fn([self.fw_cell] * n_layer)\n                self.bw_cell = MultiRNNCell_fn([self.bw_cell] * n_layer)\n            # self.fw_cell=cell_instance_fn()\n            # self.bw_cell=cell_instance_fn()\n            # Initial state of RNN\n            if fw_initial_state is None:\n                self.fw_initial_state = self.fw_cell.zero_state(self.batch_size, dtype=tf.float32)\n            else:\n                self.fw_initial_state = fw_initial_state\n            if bw_initial_state is None:\n                self.bw_initial_state = self.bw_cell.zero_state(self.batch_size, dtype=tf.float32)\n            else:\n                self.bw_initial_state = bw_initial_state\n            # Computes sequence_length\n            if sequence_length is None:\n                try: ## TF1.0\n                    sequence_length = retrieve_seq_length_op(\n                        self.inputs if isinstance(self.inputs, tf.Tensor) else tf.stack(self.inputs))\n                except: ## TF0.12\n                    sequence_length = retrieve_seq_length_op(\n                        self.inputs if isinstance(self.inputs, tf.Tensor) else tf.pack(self.inputs))\n\n            outputs, (states_fw, states_bw) = tf.nn.bidirectional_dynamic_rnn(\n                cell_fw=self.fw_cell,\n                cell_bw=self.bw_cell,\n                inputs=self.inputs,\n                sequence_length=sequence_length,\n                initial_state_fw=self.fw_initial_state,\n                initial_state_bw=self.bw_initial_state,\n                **dynamic_rnn_init_args\n            )\n            rnn_variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n            print(""     n_params : %d"" % (len(rnn_variables)))\n            # Manage the outputs\n            try: # TF1.0\n                outputs = tf.concat(outputs, 2)\n            except: # TF0.12\n                outputs = tf.concat(2, outputs)\n            if return_last:\n                # [batch_size, 2 * n_hidden]\n                self.outputs = advanced_indexing_op(outputs, sequence_length)\n            else:\n                # [batch_size, n_step(max), 2 * n_hidden]\n                if return_seq_2d:\n                    # PTB tutorial:\n                    # 2D Tensor [n_example, 2 * n_hidden]\n                    try: # TF1.0\n                        self.outputs = tf.reshape(tf.concat(outputs, 1), [-1, 2 * n_hidden])\n                    except: # TF0.12\n                        self.outputs = tf.reshape(tf.concat(1, outputs), [-1, 2 * n_hidden])\n                else:\n                    # <akara>:\n                    # 3D Tensor [batch_size, n_steps(max), 2 * n_hidden]\n                    max_length = tf.shape(outputs)[1]\n                    batch_size = tf.shape(outputs)[0]\n                    try: # TF1.0\n                        self.outputs = tf.reshape(tf.concat(outputs, 1), [batch_size, max_length, 2 * n_hidden])\n                    except: # TF0.12\n                        self.outputs = tf.reshape(tf.concat(1, outputs), [batch_size, max_length, 2 * n_hidden])\n                    # self.outputs = tf.reshape(tf.concat(1, outputs), [-1, max_length, 2 * n_hidden])\n\n        # Final state\n        self.fw_final_states = states_fw\n        self.bw_final_states = states_bw\n\n        self.sequence_length = sequence_length\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( rnn_variables )\n\n# Seq2seq\nclass Seq2Seq(Layer):\n    """"""\n    The :class:`Seq2Seq` class is a simple :class:`DynamicRNNLayer` based Seq2seq layer,\n    both encoder and decoder are :class:`DynamicRNNLayer`, network details\n    see `Model <https://camo.githubusercontent.com/242210d7d0151cae91107ee63bff364a860db5dd/687474703a2f2f6936342e74696e797069632e636f6d2f333031333674652e706e67>`_\n    and `Sequence to Sequence Learning with Neural Networks <https://arxiv.org/abs/1409.3215>`_ .\n\n    Parameters\n    ----------\n    net_encode_in : a :class:`Layer` instance\n        Encode sequences, [batch_size, None, n_features].\n    net_decode_in : a :class:`Layer` instance\n        Decode sequences, [batch_size, None, n_features].\n    cell_fn : a TensorFlow\'s core RNN cell as follow (Note TF1.0+ and TF1.0- are different).\n        - see `RNN Cells in TensorFlow <https://www.tensorflow.org/api_docs/python/>`_\n    cell_init_args : a dictionary\n        The arguments for the cell initializer.\n    n_hidden : a int\n        The number of hidden units in the layer.\n    initializer : initializer\n        The initializer for initializing the parameters.\n    encode_sequence_length : tensor for encoder sequence length, see :class:`DynamicRNNLayer` .\n    decode_sequence_length : tensor for decoder sequence length, see :class:`DynamicRNNLayer` .\n    initial_state : None or forward RNN State\n        If None, initial_state is of encoder zero_state.\n    dropout : `tuple` of `float`: (input_keep_prob, output_keep_prob).\n        The input and output keep probability.\n    n_layer : a int, default is 1.\n        The number of RNN layers.\n    return_seq_2d : boolean\n        - When return_last = False\n        - If True, return 2D Tensor [n_example, n_hidden], for stacking DenseLayer or computing cost after it.\n        - If False, return 3D Tensor [n_example/n_steps(max), n_steps(max), n_hidden], for stacking multiple RNN after it.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Variables\n    ------------\n    outputs : a tensor\n        The output of RNN decoder.\n\n    final_state : a tensor or StateTuple\n        Final state of decoder, see :class:`DynamicRNNLayer` .\n\n    Examples\n    ----------\n    >>> from tensorlayer.layers import *\n    >>> batch_size = 32\n    >>> encode_seqs = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=""encode_seqs"")\n    >>> decode_seqs = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=""decode_seqs"")\n    >>> target_seqs = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=""target_seqs"")\n    >>> target_mask = tf.placeholder(dtype=tf.int64, shape=[batch_size, None], name=""target_mask"") # tl.prepro.sequences_get_mask()\n    >>> with tf.variable_scope(""model""):\n    ...     # for chatbot, you can use the same embedding layer,\n    ...     # for translation, you may want to use 2 seperated embedding layers\n    >>>     with tf.variable_scope(""embedding"") as vs:\n    >>>         net_encode = EmbeddingInputlayer(\n    ...                 inputs = encode_seqs,\n    ...                 vocabulary_size = 10000,\n    ...                 embedding_size = 200,\n    ...                 name = \'seq_embedding\')\n    >>>         vs.reuse_variables()\n    >>>         tl.layers.set_name_reuse(True)\n    >>>         net_decode = EmbeddingInputlayer(\n    ...                 inputs = decode_seqs,\n    ...                 vocabulary_size = 10000,\n    ...                 embedding_size = 200,\n    ...                 name = \'seq_embedding\')\n    >>>     net = Seq2Seq(net_encode, net_decode,\n    ...             cell_fn = tf.contrib.rnn.BasicLSTMCell,\n    ...             n_hidden = 200,\n    ...             initializer = tf.random_uniform_initializer(-0.1, 0.1),\n    ...             encode_sequence_length = retrieve_seq_length_op2(encode_seqs),\n    ...             decode_sequence_length = retrieve_seq_length_op2(decode_seqs),\n    ...             initial_state = None,\n    ...             dropout = None,\n    ...             n_layer = 1,\n    ...             return_seq_2d = True,\n    ...             name = \'seq2seq\')\n    >>> net_out = DenseLayer(net, n_units=10000, act=tf.identity, name=\'output\')\n    >>> e_loss = tl.cost.cross_entropy_seq_with_mask(logits=net_out.outputs, target_seqs=target_seqs, input_mask=target_mask, return_details=False, name=\'cost\')\n    >>> y = tf.nn.softmax(net_out.outputs)\n    >>> net_out.print_params(False)\n\n    Notes\n    --------\n    - How to feed data: `Sequence to Sequence Learning with Neural Networks <https://arxiv.org/pdf/1409.3215v3.pdf>`_\n    - input_seqs : ``[\'how\', \'are\', \'you\', \'<PAD_ID\'>]``\n    - decode_seqs : ``[\'<START_ID>\', \'I\', \'am\', \'fine\', \'<PAD_ID\'>]``\n    - target_seqs : ``[\'I\', \'am\', \'fine\', \'<END_ID\']``\n    - target_mask : ``[1, 1, 1, 1, 0]``\n    - related functions : tl.prepro <pad_sequences, precess_sequences, sequences_add_start_id, sequences_get_mask>\n    """"""\n    def __init__(\n        self,\n        net_encode_in = None,\n        net_decode_in = None,\n        cell_fn = None,#tf.nn.rnn_cell.LSTMCell,\n        cell_init_args = {\'state_is_tuple\':True},\n        n_hidden = 256,\n        initializer = tf.random_uniform_initializer(-0.1, 0.1),\n        encode_sequence_length = None,\n        decode_sequence_length = None,\n        initial_state = None,\n        dropout = None,\n        n_layer = 1,\n        # return_last = False,\n        return_seq_2d = False,\n        name = \'seq2seq\',\n    ):\n        Layer.__init__(self, name=name)\n        if cell_fn is None:\n            raise Exception(""Please put in cell_fn"")\n        if \'GRU\' in cell_fn.__name__:\n            try:\n                cell_init_args.pop(\'state_is_tuple\')\n            except:\n                pass\n        # self.inputs = layer.outputs\n        print(""  [**] Seq2Seq %s: n_hidden:%d cell_fn:%s dropout:%s n_layer:%d"" %\n              (self.name, n_hidden, cell_fn.__name__, dropout, n_layer))\n\n        with tf.variable_scope(name) as vs:#, reuse=reuse):\n            # tl.layers.set_name_reuse(reuse)\n            # network = InputLayer(self.inputs, name=name+\'/input\')\n            network_encode = DynamicRNNLayer(net_encode_in,\n                     cell_fn = cell_fn,\n                     cell_init_args = cell_init_args,\n                     n_hidden = n_hidden,\n                     initial_state = initial_state,\n                     dropout = dropout,\n                     n_layer = n_layer,\n                     sequence_length = encode_sequence_length,\n                     return_last = False,\n                     return_seq_2d = True,\n                     name = name+\'_encode\')\n            # vs.reuse_variables()\n            # tl.layers.set_name_reuse(True)\n            network_decode = DynamicRNNLayer(net_decode_in,\n                     cell_fn = cell_fn,\n                     cell_init_args = cell_init_args,\n                     n_hidden = n_hidden,\n                     initial_state = network_encode.final_state,\n                     dropout = dropout,\n                     n_layer = n_layer,\n                     sequence_length = decode_sequence_length,\n                     return_last = False,\n                     return_seq_2d = return_seq_2d,\n                     name = name+\'_decode\')\n            self.outputs = network_decode.outputs\n\n            rnn_variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n        # Final state\n        self.final_state = network_decode.final_state\n\n        # self.sequence_length = sequence_length\n        self.all_layers = list(network_decode.all_layers)\n        self.all_params = list(network_decode.all_params)\n        self.all_drop = dict(network_decode.all_drop)\n\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( rnn_variables )\n\n        self.all_layers = list_remove_repeat(self.all_layers)\n        self.all_params = list_remove_repeat(self.all_params)\n\nclass PeekySeq2Seq(Layer):\n    """"""\n    Waiting for contribution.\n    The :class:`PeekySeq2Seq` class, see `Model <https://camo.githubusercontent.com/7f690d451036938a51e62feb77149c8bb4be6675/687474703a2f2f6936342e74696e797069632e636f6d2f333032617168692e706e67>`_\n    and `Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation <https://arxiv.org/abs/1406.1078>`_ .\n    """"""\n    def __init__(\n        self,\n        net_encode_in = None,\n        net_decode_in = None,\n        cell_fn = None,#tf.nn.rnn_cell.LSTMCell,\n        cell_init_args = {\'state_is_tuple\':True},\n        n_hidden = 256,\n        initializer = tf.random_uniform_initializer(-0.1, 0.1),\n        in_sequence_length = None,\n        out_sequence_length = None,\n        initial_state = None,\n        dropout = None,\n        n_layer = 1,\n        # return_last = False,\n        return_seq_2d = False,\n        name = \'peeky_seq2seq\',\n    ):\n        Layer.__init__(self, name=name)\n        if cell_fn is None:\n            raise Exception(""Please put in cell_fn"")\n        # self.inputs = layer.outputs\n        print(""  [TL] PeekySeq2seq %s: n_hidden:%d cell_fn:%s dropout:%s n_layer:%d"" %\n              (self.name, n_hidden, cell_fn.__name__, dropout, n_layer))\n\nclass AttentionSeq2Seq(Layer):\n    """"""\n    Waiting for contribution.\n    The :class:`AttentionSeq2Seq` class, see `Model <https://camo.githubusercontent.com/0e2e4e5fb2dd47846c2fe027737a5df5e711df1b/687474703a2f2f6936342e74696e797069632e636f6d2f6132727733642e706e67>`_\n    and `Neural Machine Translation by Jointly Learning to Align and Translate <https://arxiv.org/pdf/1409.0473v6.pdf>`_ .\n    """"""\n    def __init__(\n        self,\n        net_encode_in = None,\n        net_decode_in = None,\n        cell_fn = None,#tf.nn.rnn_cell.LSTMCell,\n        cell_init_args = {\'state_is_tuple\':True},\n        n_hidden = 256,\n        initializer = tf.random_uniform_initializer(-0.1, 0.1),\n        in_sequence_length = None,\n        out_sequence_length = None,\n        initial_state = None,\n        dropout = None,\n        n_layer = 1,\n        # return_last = False,\n        return_seq_2d = False,\n        name = \'attention_seq2seq\',\n    ):\n        Layer.__init__(self, name=name)\n        if cell_fn is None:\n            raise Exception(""Please put in cell_fn"")\n        # self.inputs = layer.outputs\n        print(""  [TL] PeekySeq2seq %s: n_hidden:%d cell_fn:%s dropout:%s n_layer:%d"" %\n              (self.name, n_hidden, cell_fn.__name__, dropout, n_layer))\n\n## Shape layer\nclass FlattenLayer(Layer):\n    """"""\n    The :class:`FlattenLayer` class is layer which reshape high-dimension\n    input to a vector. Then we can apply DenseLayer, RNNLayer, ConcatLayer and\n    etc on the top of it.\n\n    [batch_size, mask_row, mask_col, n_mask] ---> [batch_size, mask_row * mask_col * n_mask]\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    >>> x = tf.placeholder(tf.float32, shape=[None, 28, 28, 1])\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = tl.layers.Conv2dLayer(network,\n    ...                    act = tf.nn.relu,\n    ...                    shape = [5, 5, 32, 64],\n    ...                    strides=[1, 1, 1, 1],\n    ...                    padding=\'SAME\',\n    ...                    name =\'cnn_layer\')\n    >>> network = tl.layers.Pool2dLayer(network,\n    ...                    ksize=[1, 2, 2, 1],\n    ...                    strides=[1, 2, 2, 1],\n    ...                    padding=\'SAME\',\n    ...                    pool = tf.nn.max_pool,\n    ...                    name =\'pool_layer\',)\n    >>> network = tl.layers.FlattenLayer(network, name=\'flatten_layer\')\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        name =\'flatten_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        self.outputs = flatten_reshape(self.inputs, name=name)\n        self.n_units = int(self.outputs.get_shape()[-1])\n        print(""  [TL] FlattenLayer %s: %d"" % (self.name, self.n_units))\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n\nclass ReshapeLayer(Layer):\n    """"""\n    The :class:`ReshapeLayer` class is layer which reshape the tensor.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    shape : a list\n        The output shape.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    - The core of this layer is ``tf.reshape``.\n    - Use TensorFlow only :\n    >>> x = tf.placeholder(tf.float32, shape=[None, 3])\n    >>> y = tf.reshape(x, shape=[-1, 3, 3])\n    >>> sess = tf.InteractiveSession()\n    >>> print(sess.run(y, feed_dict={x:[[1,1,1],[2,2,2],[3,3,3],[4,4,4],[5,5,5],[6,6,6]]}))\n    ... [[[ 1.  1.  1.]\n    ... [ 2.  2.  2.]\n    ... [ 3.  3.  3.]]\n    ... [[ 4.  4.  4.]\n    ... [ 5.  5.  5.]\n    ... [ 6.  6.  6.]]]\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        shape = [],\n        name =\'reshape_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        self.outputs = tf.reshape(self.inputs, shape=shape, name=name)\n        print(""  [TL] ReshapeLayer %s: %s"" % (self.name, self.outputs.get_shape()))\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n\nclass LambdaLayer(Layer):\n    """"""\n    The :class:`LambdaLayer` class is a layer which is able to use the provided function.\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    fn : a function\n        The function that applies to the outputs of previous layer.\n    fn_args : a dictionary\n        The arguments for the function (option).\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    ---------\n    >>> x = tf.placeholder(tf.float32, shape=[None, 1], name=\'x\')\n    >>> network = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> network = LambdaLayer(network, lambda x: 2*x, name=\'lambda_layer\')\n    >>> y = network.outputs\n    >>> sess = tf.InteractiveSession()\n    >>> out = sess.run(y, feed_dict={x : [[1],[2]]})\n    ... [[2],[4]]\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        fn = None,\n        fn_args = {},\n        name = \'lambda_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        assert layer is not None\n        assert fn is not None\n        self.inputs = layer.outputs\n        print(""  [TL] LambdaLayer  %s"" % self.name)\n        with tf.variable_scope(name) as vs:\n            self.outputs = fn(self.inputs, **fn_args)\n            variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( variables )\n\n## Merge layer\nclass ConcatLayer(Layer):\n    """"""\n    The :class:`ConcatLayer` class is layer which concat (merge) two or more\n    :class:`DenseLayer` to a single class:`DenseLayer`.\n\n    Parameters\n    ----------\n    layer : a list of :class:`Layer` instances\n        The `Layer` class feeding into this layer.\n    concat_dim : int\n        Dimension along which to concatenate.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    >>> sess = tf.InteractiveSession()\n    >>> x = tf.placeholder(tf.float32, shape=[None, 784])\n    >>> inputs = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> net1 = tl.layers.DenseLayer(inputs, n_units=800, act = tf.nn.relu, name=\'relu1_1\')\n    >>> net2 = tl.layers.DenseLayer(inputs, n_units=300, act = tf.nn.relu, name=\'relu2_1\')\n    >>> network = tl.layers.ConcatLayer(layer = [net1, net2], name =\'concat_layer\')\n    ...     [TL] InputLayer input_layer (?, 784)\n    ...     [TL] DenseLayer relu1_1: 800, <function relu at 0x1108e41e0>\n    ...     [TL] DenseLayer relu2_1: 300, <function relu at 0x1108e41e0>\n    ...     [TL] ConcatLayer concat_layer, 1100\n    ...\n    >>> tl.layers.initialize_global_variables(sess)\n    >>> network.print_params()\n    ...     param 0: (784, 800) (mean: 0.000021, median: -0.000020 std: 0.035525)\n    ...     param 1: (800,) (mean: 0.000000, median: 0.000000 std: 0.000000)\n    ...     param 2: (784, 300) (mean: 0.000000, median: -0.000048 std: 0.042947)\n    ...     param 3: (300,) (mean: 0.000000, median: 0.000000 std: 0.000000)\n    ...     num of params: 863500\n    >>> network.print_layers()\n    ...     layer 0: Tensor(""Relu:0"", shape=(?, 800), dtype=float32)\n    ...     layer 1: Tensor(""Relu_1:0"", shape=(?, 300), dtype=float32)\n    ...\n    """"""\n    def __init__(\n        self,\n        layer = [],\n        concat_dim = 1,\n        name =\'concat_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = []\n        for l in layer:\n            self.inputs.append(l.outputs)\n        try: # TF1.0\n            self.outputs = tf.concat(self.inputs, concat_dim, name=name)\n        except: # TF0.12\n            self.outputs = tf.concat(concat_dim, self.inputs, name=name)\n        self.n_units = int(self.outputs.get_shape()[-1])\n        print(""  [TL] ConcatLayer %s: %d"" % (self.name, self.n_units))\n\n        self.all_layers = list(layer[0].all_layers)\n        self.all_params = list(layer[0].all_params)\n        self.all_drop = dict(layer[0].all_drop)\n\n        for i in range(1, len(layer)):\n            self.all_layers.extend(list(layer[i].all_layers))\n            self.all_params.extend(list(layer[i].all_params))\n            self.all_drop.update(dict(layer[i].all_drop))\n\n        self.all_layers = list_remove_repeat(self.all_layers)\n        self.all_params = list_remove_repeat(self.all_params)\n        #self.all_drop = list_remove_repeat(self.all_drop) # it is a dict\n\nclass ElementwiseLayer(Layer):\n    """"""\n    The :class:`ElementwiseLayer` class combines multiple :class:`Layer` which have the same output shapes by a given elemwise-wise operation.\n\n    Parameters\n    ----------\n    layer : a list of :class:`Layer` instances\n        The `Layer` class feeding into this layer.\n    combine_fn : a TensorFlow elemwise-merge function\n        e.g. AND is ``tf.minimum`` ;  OR is ``tf.maximum`` ; ADD is ``tf.add`` ; MUL is ``tf.multiply`` and so on.\n        See `TensorFlow Math API <https://www.tensorflow.org/versions/master/api_docs/python/math_ops.html#math>`_ .\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    - AND Logic\n    >>> net_0 = tl.layers.DenseLayer(net_0, n_units=500,\n    ...                        act = tf.nn.relu, name=\'net_0\')\n    >>> net_1 = tl.layers.DenseLayer(net_1, n_units=500,\n    ...                        act = tf.nn.relu, name=\'net_1\')\n    >>> net_com = tl.layers.ElementwiseLayer(layer = [net_0, net_1],\n    ...                         combine_fn = tf.minimum,\n    ...                         name = \'combine_layer\')\n    """"""\n    def __init__(\n        self,\n        layer = [],\n        combine_fn = tf.minimum,\n        name =\'elementwise_layer\',\n    ):\n        Layer.__init__(self, name=name)\n\n        print(""  [TL] ElementwiseLayer %s: size:%s fn:%s"" % (self.name, layer[0].outputs.get_shape(), combine_fn.__name__))\n\n        self.outputs = layer[0].outputs\n        # print(self.outputs._shape, type(self.outputs._shape))\n        for l in layer[1:]:\n            assert str(self.outputs.get_shape()) == str(l.outputs.get_shape()), ""Hint: the input shapes should be the same. %s != %s"" %  (self.outputs.get_shape() , str(l.outputs.get_shape()))\n            self.outputs = combine_fn(self.outputs, l.outputs, name=name)\n\n        self.all_layers = list(layer[0].all_layers)\n        self.all_params = list(layer[0].all_params)\n        self.all_drop = dict(layer[0].all_drop)\n\n        for i in range(1, len(layer)):\n            self.all_layers.extend(list(layer[i].all_layers))\n            self.all_params.extend(list(layer[i].all_params))\n            self.all_drop.update(dict(layer[i].all_drop))\n\n        self.all_layers = list_remove_repeat(self.all_layers)\n        self.all_params = list_remove_repeat(self.all_params)\n        # self.all_drop = list_remove_repeat(self.all_drop)\n\n# Extend\nclass ExpandDimsLayer(Layer):\n    """"""\n    The :class:`ExpandDimsLayer` class inserts a dimension of 1 into a tensor\'s shape,\n    see `tf.expand_dims() <https://www.tensorflow.org/api_docs/python/array_ops/shapes_and_shaping#expand_dims>`_ .\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    axis : int, 0-D (scalar).\n        Specifies the dimension index at which to expand the shape of input.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        axis = None,\n        name = \'expand_dims\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n\n        print(""  [TL] ExpandDimsLayer  %s: axis:%d"" % (self.name, axis))\n        with tf.variable_scope(name) as vs:\n            try:    # TF12 TF1.0\n                self.outputs = tf.expand_dims(self.inputs, axis=axis)\n            except: # TF11\n                self.outputs = tf.expand_dims(self.inputs, dim=axis)\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        # self.all_params.extend( variables )\n\nclass TileLayer(Layer):\n    """"""\n    The :class:`TileLayer` class constructs a tensor by tiling a given tensor,\n    see `tf.tile() <https://www.tensorflow.org/api_docs/python/array_ops/slicing_and_joining#tile>`_ .\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    multiples: a list of int\n        Must be one of the following types: int32, int64. 1-D. Length must be the same as the number of dimensions in input\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        multiples = None,\n        name = \'tile\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n\n        print(""  [TL] TileLayer  %s: multiples:%s"" % (self.name, multiples))\n        with tf.variable_scope(name) as vs:\n            self.outputs = tf.tile(self.inputs, multiples=multiples)\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        # self.all_params.extend( variables )\n\n## TF-Slim layer\nclass SlimNetsLayer(Layer):\n    """"""\n    The :class:`SlimNetsLayer` class can be used to merge all TF-Slim nets into\n    TensorLayer. Model can be found in `slim-model <https://github.com/tensorflow/models/tree/master/slim#pre-trained-models>`_ , more about slim\n    see `slim-git <https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim>`_ .\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    slim_layer : a slim network function\n        The network you want to stack onto, end with ``return net, end_points``.\n    slim_args : dictionary\n        The arguments for the slim model.\n    name : a string or None\n        An optional name to attach to this layer.\n\n    Examples\n    --------\n    - see Inception V3 example on `Github <https://github.com/zsdonghao/tensorlayer>`_\n\n    Notes\n    -----\n    The due to TF-Slim stores the layers as dictionary, the ``all_layers`` in this\n    network is not in order ! Fortunately, the ``all_params`` are in order.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        slim_layer = None,\n        slim_args = {},\n        name =\'tfslim_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        assert slim_layer is not None\n        assert slim_args is not None\n        self.inputs = layer.outputs\n        print(""  [TL] SlimNetsLayer %s: %s"" % (self.name, slim_layer.__name__))\n\n        # with tf.variable_scope(name) as vs:\n        #     net, end_points = slim_layer(self.inputs, **slim_args)\n        #     slim_variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n        net, end_points = slim_layer(self.inputs, **slim_args)\n\n        slim_variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=name)\n        if slim_variables == []:\n            print(""No variables found under %s : the name of SlimNetsLayer should be matched with the begining of the ckpt file, see tutorial_inceptionV3_tfslim.py for more details"" % name)\n\n\n        self.outputs = net\n\n        slim_layers = []\n        for v in end_points.values():\n            # tf.contrib.layers.summaries.summarize_activation(v)\n            slim_layers.append(v)\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n\n        self.all_layers.extend( slim_layers )\n        self.all_params.extend( slim_variables )\n\n## Keras layer\nclass KerasLayer(Layer):\n    """"""\n    The :class:`KerasLayer` class can be used to merge all Keras layers into\n    TensorLayer. Example can be found here `tutorial_keras.py <https://github.com/zsdonghao/tensorlayer/blob/master/example/tutorial_keras.py>`_\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    keras_layer : a keras network function\n    keras_args : dictionary\n        The arguments for the keras model.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        keras_layer = None,\n        keras_args = {},\n        name =\'keras_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        assert layer is not None\n        assert keras_layer is not None\n        self.inputs = layer.outputs\n        print(""  [TL] KerasLayer %s: %s"" % (self.name, keras_layer))\n        print(""       This API will be removed, please use LambdaLayer instead."")\n        with tf.variable_scope(name) as vs:\n            self.outputs = keras_layer(self.inputs, **keras_args)\n            variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( variables )\n\n## Estimator layer\nclass EstimatorLayer(Layer):\n    """"""\n    The :class:`EstimatorLayer` class accepts ``model_fn`` that described the model.\n    It is similar with :class:`KerasLayer`, see `tutorial_keras.py <https://github.com/zsdonghao/tensorlayer/blob/master/example/tutorial_keras.py>`_\n\n    Parameters\n    ----------\n    layer : a :class:`Layer` instance\n        The `Layer` class feeding into this layer.\n    model_fn : a function that described the model.\n    args : dictionary\n        The arguments for the model_fn.\n    name : a string or None\n        An optional name to attach to this layer.\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        model_fn = None,\n        args = {},\n        name =\'estimator_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        assert layer is not None\n        assert model_fn is not None\n        self.inputs = layer.outputs\n        print(""  [TL] EstimatorLayer %s: %s"" % (self.name, model_fn))\n        print(""       This API will be removed, please use LambdaLayer instead."")\n        with tf.variable_scope(name) as vs:\n            self.outputs = model_fn(self.inputs, **args)\n            variables = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( variables )\n\n## Special activation\nclass PReluLayer(Layer):\n    """"""\n    The :class:`PReluLayer` class is Parametric Rectified Linear layer.\n\n    Parameters\n    ----------\n    x : A `Tensor` with type `float`, `double`, `int32`, `int64`, `uint8`,\n        `int16`, or `int8`.\n    channel_shared : `bool`. Single weight is shared by all channels\n    a_init : alpha initializer, default zero constant.\n        The initializer for initializing the alphas.\n    a_init_args : dictionary\n        The arguments for the weights initializer.\n    name : A name for this activation op (optional).\n\n    References\n    -----------\n    - `Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification <http://arxiv.org/pdf/1502.01852v1.pdf>`_\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        channel_shared = False,\n        a_init = tf.constant_initializer(value=0.0),\n        a_init_args = {},\n        # restore = True,\n        name=""prelu_layer""\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n        print(""  [TL] PReluLayer %s: channel_shared:%s"" % (self.name, channel_shared))\n        if channel_shared:\n            w_shape = (1,)\n        else:\n            w_shape = int(self.inputs.get_shape()[-1])\n\n        # with tf.name_scope(name) as scope:\n        with tf.variable_scope(name) as vs:\n            alphas = tf.get_variable(name=\'alphas\', shape=w_shape, initializer=a_init, **a_init_args )\n            try:  ## TF 1.0\n                self.outputs = tf.nn.relu(self.inputs) + tf.multiply(alphas, (self.inputs - tf.abs(self.inputs))) * 0.5\n            except: ## TF 0.12\n                self.outputs = tf.nn.relu(self.inputs) + tf.mul(alphas, (self.inputs - tf.abs(self.inputs))) * 0.5\n\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( [alphas] )\n\n## Flow control layer\nclass MultiplexerLayer(Layer):\n    """"""\n    The :class:`MultiplexerLayer` selects one of several input and forwards the selected input into the output,\n    see `tutorial_mnist_multiplexer.py`.\n\n    Parameters\n    ----------\n    layer : a list of :class:`Layer` instances\n        The `Layer` class feeding into this layer.\n    name : a string or None\n        An optional name to attach to this layer.\n\n\n    Variables\n    -----------------------\n    sel : a placeholder\n        Input an int [0, inf], which input is the output\n\n    Examples\n    --------\n    >>> x = tf.placeholder(tf.float32, shape=[None, 784], name=\'x\')\n    >>> y_ = tf.placeholder(tf.int64, shape=[None, ], name=\'y_\')\n    >>> # define the network\n    >>> net_in = tl.layers.InputLayer(x, name=\'input_layer\')\n    >>> net_in = tl.layers.DropoutLayer(net_in, keep=0.8, name=\'drop1\')\n    >>> # net 0\n    >>> net_0 = tl.layers.DenseLayer(net_in, n_units=800,\n    ...                                act = tf.nn.relu, name=\'net0/relu1\')\n    >>> net_0 = tl.layers.DropoutLayer(net_0, keep=0.5, name=\'net0/drop2\')\n    >>> net_0 = tl.layers.DenseLayer(net_0, n_units=800,\n    ...                                act = tf.nn.relu, name=\'net0/relu2\')\n    >>> # net 1\n    >>> net_1 = tl.layers.DenseLayer(net_in, n_units=800,\n    ...                                act = tf.nn.relu, name=\'net1/relu1\')\n    >>> net_1 = tl.layers.DropoutLayer(net_1, keep=0.8, name=\'net1/drop2\')\n    >>> net_1 = tl.layers.DenseLayer(net_1, n_units=800,\n    ...                                act = tf.nn.relu, name=\'net1/relu2\')\n    >>> net_1 = tl.layers.DropoutLayer(net_1, keep=0.8, name=\'net1/drop3\')\n    >>> net_1 = tl.layers.DenseLayer(net_1, n_units=800,\n    ...                                act = tf.nn.relu, name=\'net1/relu3\')\n    >>> # multiplexer\n    >>> net_mux = tl.layers.MultiplexerLayer(layer = [net_0, net_1], name=\'mux_layer\')\n    >>> network = tl.layers.ReshapeLayer(net_mux, shape=[-1, 800], name=\'reshape_layer\') #\n    >>> network = tl.layers.DropoutLayer(network, keep=0.5, name=\'drop3\')\n    >>> # output layer\n    >>> network = tl.layers.DenseLayer(network, n_units=10,\n    ...                                act = tf.identity, name=\'output_layer\')\n\n    References\n    ------------\n    - See ``tf.pack() for TF0.12 or tf.stack() for TF1.0`` and ``tf.gather()`` at `TensorFlow - Slicing and Joining <https://www.tensorflow.org/versions/master/api_docs/python/array_ops.html#slicing-and-joining>`_\n    """"""\n    def __init__(self,\n               layer = [],\n               name=\'mux_layer\'):\n        Layer.__init__(self, name=name)\n        self.n_inputs = len(layer)\n\n        self.inputs = []\n        for l in layer:\n            self.inputs.append(l.outputs)\n        try: ## TF1.0\n            all_inputs = tf.stack(self.inputs, name=name) # pack means concat a list of tensor in a new dim  # 1.2\n        except:\n            all_inputs = tf.pack(self.inputs, name=name) # pack means concat a list of tensor in a new dim  # 1.2\n\n        print(""  [TL] MultiplexerLayer %s: n_inputs:%d"" % (self.name, self.n_inputs))\n\n        self.sel = tf.placeholder(tf.int32)\n        self.outputs = tf.gather(all_inputs, self.sel, name=name) # [sel, :, : ...] # 1.2\n\n        # print(self.outputs, vars(self.outputs))\n        #         # tf.reshape(self.outputs, shape=)\n        # exit()\n        # the same with ConcatLayer\n        self.all_layers = list(layer[0].all_layers)\n        self.all_params = list(layer[0].all_params)\n        self.all_drop = dict(layer[0].all_drop)\n\n        for i in range(1, len(layer)):\n            self.all_layers.extend(list(layer[i].all_layers))\n            self.all_params.extend(list(layer[i].all_params))\n            self.all_drop.update(dict(layer[i].all_drop))\n\n        self.all_layers = list_remove_repeat(self.all_layers)\n        self.all_params = list_remove_repeat(self.all_params)\n        # self.all_drop = list_remove_repeat(self.all_drop)\n## We can Duplicate the network instead of DemultiplexerLayer\n# class DemultiplexerLayer(Layer):\n#     """"""\n#     The :class:`DemultiplexerLayer` takes a single input and select one of many output lines, which is connected to the input.\n#\n#     Parameters\n#     ----------\n#     layer : a list of :class:`Layer` instances\n#         The `Layer` class feeding into this layer.\n#     n_outputs : a int\n#         The number of output\n#     name : a string or None\n#         An optional name to attach to this layer.\n#\n#     Field (Class Variables)\n#     -----------------------\n#     sel : a placeholder\n#         Input int [0, inf], the\n#     outputs : a list of Tensor\n#         A list of outputs\n#\n#     Examples\n#     --------\n#     >>>\n#     """"""\n#     def __init__(self,\n#            layer = None,\n#            name=\'demux_layer\'):\n#         Layer.__init__(self, name=name)\n#         self.outputs = []\n\n## Wrapper\nclass EmbeddingAttentionSeq2seqWrapper(Layer):\n  """"""Sequence-to-sequence model with attention and for multiple buckets (Deprecated after TF0.12).\n\n    This example implements a multi-layer recurrent neural network as encoder,\n    and an attention-based decoder. This is the same as the model described in\n    this paper:\n    - `Grammar as a Foreign Language <http://arxiv.org/abs/1412.7449>`_\n    please look there for details,\n    or into the seq2seq library for complete model implementation.\n    This example also allows to use GRU cells in addition to LSTM cells, and\n    sampled softmax to handle large output vocabulary size. A single-layer\n    version of this model, but with bi-directional encoder, was presented in\n    - `Neural Machine Translation by Jointly Learning to Align and Translate <http://arxiv.org/abs/1409.0473>`_\n    The sampled softmax is described in Section 3 of the following paper.\n    - `On Using Very Large Target Vocabulary for Neural Machine Translation <http://arxiv.org/abs/1412.2007>`_\n\n    Parameters\n    ----------\n    source_vocab_size : size of the source vocabulary.\n    target_vocab_size : size of the target vocabulary.\n    buckets : a list of pairs (I, O), where I specifies maximum input length\n        that will be processed in that bucket, and O specifies maximum output\n        length. Training instances that have inputs longer than I or outputs\n        longer than O will be pushed to the next bucket and padded accordingly.\n        We assume that the list is sorted, e.g., [(2, 4), (8, 16)].\n    size : number of units in each layer of the model.\n    num_layers : number of layers in the model.\n    max_gradient_norm : gradients will be clipped to maximally this norm.\n    batch_size : the size of the batches used during training;\n        the model construction is independent of batch_size, so it can be\n        changed after initialization if this is convenient, e.g., for decoding.\n    learning_rate : learning rate to start with.\n    learning_rate_decay_factor : decay learning rate by this much when needed.\n    use_lstm : if true, we use LSTM cells instead of GRU cells.\n    num_samples : number of samples for sampled softmax.\n    forward_only : if set, we do not construct the backward pass in the model.\n    name : a string or None\n        An optional name to attach to this layer.\n  """"""\n  def __init__(self,\n               source_vocab_size,\n               target_vocab_size,\n               buckets,\n               size,\n               num_layers,\n               max_gradient_norm,\n               batch_size,\n               learning_rate,\n               learning_rate_decay_factor,\n               use_lstm=False,\n               num_samples=512,\n               forward_only=False,\n               name=\'wrapper\'):\n    Layer.__init__(self)#, name=name)\n\n    self.source_vocab_size = source_vocab_size\n    self.target_vocab_size = target_vocab_size\n    self.buckets = buckets\n    self.batch_size = batch_size\n    self.learning_rate = tf.Variable(float(learning_rate), trainable=False, name=\'learning_rate\')\n    self.learning_rate_decay_op = self.learning_rate.assign(\n        self.learning_rate * learning_rate_decay_factor)\n    self.global_step = tf.Variable(0, trainable=False, name=\'global_step\')\n\n    if tf.__version__ >= ""0.12"":\n        raise Exception(""Deprecated after TF0.12 : use other seq2seq layers instead."")\n\n    # =========== Fake output Layer for compute cost ======\n    # If we use sampled softmax, we need an output projection.\n    with tf.variable_scope(name) as vs:\n        output_projection = None\n        softmax_loss_function = None\n        # Sampled softmax only makes sense if we sample less than vocabulary size.\n        if num_samples > 0 and num_samples < self.target_vocab_size:\n          w = tf.get_variable(""proj_w"", [size, self.target_vocab_size])\n          w_t = tf.transpose(w)\n          b = tf.get_variable(""proj_b"", [self.target_vocab_size])\n          output_projection = (w, b)\n\n          def sampled_loss(inputs, labels):\n            labels = tf.reshape(labels, [-1, 1])\n            return tf.nn.sampled_softmax_loss(w_t, b, inputs, labels, num_samples,\n                    self.target_vocab_size)\n          softmax_loss_function = sampled_loss\n\n        # ============ Seq Encode Layer =============\n        # Create the internal multi-layer cell for our RNN.\n        try: # TF1.0\n          single_cell = tf.contrib.rnn.GRUCell(size)\n        except:\n          single_cell = tf.nn.rnn_cell.GRUCell(size)\n\n        if use_lstm:\n          try: # TF1.0\n            single_cell = tf.contrib.rnn.BasicLSTMCell(size)\n          except:\n            single_cell = tf.nn.rnn_cell.BasicLSTMCell(size)\n\n        cell = single_cell\n        if num_layers > 1:\n          try: # TF1.0\n            cell = tf.contrib.rnn.MultiRNNCell([single_cell] * num_layers)\n          except:\n            cell = tf.nn.rnn_cell.MultiRNNCell([single_cell] * num_layers)\n\n        # ============== Seq Decode Layer ============\n        # The seq2seq function: we use embedding for the input and attention.\n        def seq2seq_f(encoder_inputs, decoder_inputs, do_decode):\n          return tf.nn.seq2seq.embedding_attention_seq2seq(\n              encoder_inputs, decoder_inputs, cell,\n              num_encoder_symbols=source_vocab_size,\n              num_decoder_symbols=target_vocab_size,\n              embedding_size=size,\n              output_projection=output_projection,\n              feed_previous=do_decode)\n\n        #=============================================================\n        # Feeds for inputs.\n        self.encoder_inputs = []\n        self.decoder_inputs = []\n        self.target_weights = []\n        for i in xrange(buckets[-1][0]):  # Last bucket is the biggest one.\n          self.encoder_inputs.append(tf.placeholder(tf.int32, shape=[None],\n                                                    name=""encoder{0}"".format(i)))\n        for i in xrange(buckets[-1][1] + 1):\n          self.decoder_inputs.append(tf.placeholder(tf.int32, shape=[None],\n                                                    name=""decoder{0}"".format(i)))\n          self.target_weights.append(tf.placeholder(tf.float32, shape=[None],\n                                                    name=""weight{0}"".format(i)))\n\n        # Our targets are decoder inputs shifted by one.\n        targets = [self.decoder_inputs[i + 1]\n                   for i in xrange(len(self.decoder_inputs) - 1)]\n        self.targets = targets  # DH add for debug\n\n\n        # Training outputs and losses.\n        if forward_only:\n          self.outputs, self.losses = tf.nn.seq2seq.model_with_buckets(\n              self.encoder_inputs, self.decoder_inputs, targets,\n              self.target_weights, buckets, lambda x, y: seq2seq_f(x, y, True),\n              softmax_loss_function=softmax_loss_function)\n          # If we use output projection, we need to project outputs for decoding.\n          if output_projection is not None:\n            for b in xrange(len(buckets)):\n              self.outputs[b] = [\n                  tf.matmul(output, output_projection[0]) + output_projection[1]\n                  for output in self.outputs[b]\n              ]\n        else:\n          self.outputs, self.losses = tf.nn.seq2seq.model_with_buckets(\n              self.encoder_inputs, self.decoder_inputs, targets,\n              self.target_weights, buckets,\n              lambda x, y: seq2seq_f(x, y, False),\n              softmax_loss_function=softmax_loss_function)\n\n        # Gradients and SGD update operation for training the model.\n        params = tf.trainable_variables()\n        if not forward_only:\n          self.gradient_norms = []\n          self.updates = []\n          opt = tf.train.GradientDescentOptimizer(self.learning_rate)\n          for b in xrange(len(buckets)):\n            gradients = tf.gradients(self.losses[b], params)\n            clipped_gradients, norm = tf.clip_by_global_norm(gradients,\n                                                             max_gradient_norm)\n            self.gradient_norms.append(norm)\n            self.updates.append(opt.apply_gradients(\n                zip(clipped_gradients, params), global_step=self.global_step))\n\n        # if save into npz\n        self.all_params = tf.get_collection(TF_GRAPHKEYS_VARIABLES, scope=vs.name)\n\n    # if save into ckpt\n    self.saver = tf.train.Saver(tf.all_variables())\n\n  def step(self, session, encoder_inputs, decoder_inputs, target_weights,\n           bucket_id, forward_only):\n    """"""Run a step of the model feeding the given inputs.\n\n    Parameters\n    ----------\n    session : tensorflow session to use.\n    encoder_inputs : list of numpy int vectors to feed as encoder inputs.\n    decoder_inputs : list of numpy int vectors to feed as decoder inputs.\n    target_weights : list of numpy float vectors to feed as target weights.\n    bucket_id : which bucket of the model to use.\n    forward_only : whether to do the backward step or only forward.\n\n    Returns\n    --------\n    A triple consisting of gradient norm (or None if we did not do backward),\n    average perplexity, and the outputs.\n\n    Raises\n    --------\n    ValueError : if length of encoder_inputs, decoder_inputs, or\n        target_weights disagrees with bucket size for the specified bucket_id.\n    """"""\n    # Check if the sizes match.\n    encoder_size, decoder_size = self.buckets[bucket_id]\n    if len(encoder_inputs) != encoder_size:\n      raise ValueError(""Encoder length must be equal to the one in bucket,""\n                       "" %d != %d."" % (len(encoder_inputs), encoder_size))\n    if len(decoder_inputs) != decoder_size:\n      raise ValueError(""Decoder length must be equal to the one in bucket,""\n                       "" %d != %d."" % (len(decoder_inputs), decoder_size))\n    if len(target_weights) != decoder_size:\n      raise ValueError(""Weights length must be equal to the one in bucket,""\n                       "" %d != %d."" % (len(target_weights), decoder_size))\n    # print(\'in model.step()\')\n    # print(\'a\',bucket_id, encoder_size, decoder_size)\n\n    # Input feed: encoder inputs, decoder inputs, target_weights, as provided.\n    input_feed = {}\n    for l in xrange(encoder_size):\n      input_feed[self.encoder_inputs[l].name] = encoder_inputs[l]\n    for l in xrange(decoder_size):\n      input_feed[self.decoder_inputs[l].name] = decoder_inputs[l]\n      input_feed[self.target_weights[l].name] = target_weights[l]\n    # print(self.encoder_inputs[l].name)\n    # print(self.decoder_inputs[l].name)\n    # print(self.target_weights[l].name)\n\n    # Since our targets are decoder inputs shifted by one, we need one more.\n    last_target = self.decoder_inputs[decoder_size].name\n    input_feed[last_target] = np.zeros([self.batch_size], dtype=np.int32)\n    # print(\'last_target\', last_target)\n\n    # Output feed: depends on whether we do a backward step or not.\n    if not forward_only:\n      output_feed = [self.updates[bucket_id],  # Update Op that does SGD.\n                     self.gradient_norms[bucket_id],  # Gradient norm.\n                     self.losses[bucket_id]]  # Loss for this batch.\n    else:\n      output_feed = [self.losses[bucket_id]]  # Loss for this batch.\n      for l in xrange(decoder_size):  # Output logits.\n        output_feed.append(self.outputs[bucket_id][l])\n\n    outputs = session.run(output_feed, input_feed)\n    if not forward_only:\n      return outputs[1], outputs[2], None  # Gradient norm, loss, no outputs.\n    else:\n      return None, outputs[0], outputs[1:]  # No gradient norm, loss, outputs.\n\n  def get_batch(self, data, bucket_id, PAD_ID=0, GO_ID=1, EOS_ID=2, UNK_ID=3):\n    """""" Get a random batch of data from the specified bucket, prepare for step.\n\n    To feed data in step(..) it must be a list of batch-major vectors, while\n    data here contains single length-major cases. So the main logic of this\n    function is to re-index data cases to be in the proper format for feeding.\n\n    Parameters\n    ----------\n    data : a tuple of size len(self.buckets) in which each element contains\n        lists of pairs of input and output data that we use to create a batch.\n    bucket_id : integer, which bucket to get the batch for.\n    PAD_ID : int\n        Index of Padding in vocabulary\n    GO_ID : int\n        Index of GO in vocabulary\n    EOS_ID : int\n        Index of End of sentence in vocabulary\n    UNK_ID : int\n        Index of Unknown word in vocabulary\n\n    Returns\n    -------\n    The triple (encoder_inputs, decoder_inputs, target_weights) for\n    the constructed batch that has the proper format to call step(...) later.\n    """"""\n    encoder_size, decoder_size = self.buckets[bucket_id]\n    encoder_inputs, decoder_inputs = [], []\n\n    # Get a random batch of encoder and decoder inputs from data,\n    # pad them if needed, reverse encoder inputs and add GO to decoder.\n    for _ in xrange(self.batch_size):\n      encoder_input, decoder_input = random.choice(data[bucket_id])\n\n      # Encoder inputs are padded and then reversed.\n      encoder_pad = [PAD_ID] * (encoder_size - len(encoder_input))\n      encoder_inputs.append(list(reversed(encoder_input + encoder_pad)))\n\n      # Decoder inputs get an extra ""GO"" symbol, and are padded then.\n      decoder_pad_size = decoder_size - len(decoder_input) - 1\n      decoder_inputs.append([GO_ID] + decoder_input +\n                            [PAD_ID] * decoder_pad_size)\n\n    # Now we create batch-major vectors from the data selected above.\n    batch_encoder_inputs, batch_decoder_inputs, batch_weights = [], [], []\n\n    # Batch encoder inputs are just re-indexed encoder_inputs.\n    for length_idx in xrange(encoder_size):\n      batch_encoder_inputs.append(\n          np.array([encoder_inputs[batch_idx][length_idx]\n                    for batch_idx in xrange(self.batch_size)], dtype=np.int32))\n\n    # Batch decoder inputs are re-indexed decoder_inputs, we create weights.\n    for length_idx in xrange(decoder_size):\n      batch_decoder_inputs.append(\n          np.array([decoder_inputs[batch_idx][length_idx]\n                    for batch_idx in xrange(self.batch_size)], dtype=np.int32))\n\n      # Create target_weights to be 0 for targets that are padding.\n      batch_weight = np.ones(self.batch_size, dtype=np.float32)\n      for batch_idx in xrange(self.batch_size):\n        # We set weight to 0 if the corresponding target is a PAD symbol.\n        # The corresponding target is decoder_input shifted by 1 forward.\n        if length_idx < decoder_size - 1:\n          target = decoder_inputs[batch_idx][length_idx + 1]\n        if length_idx == decoder_size - 1 or target == PAD_ID:\n          batch_weight[batch_idx] = 0.0\n      batch_weights.append(batch_weight)\n    return batch_encoder_inputs, batch_decoder_inputs, batch_weights\n\n## Developing or Untested\nclass MaxoutLayer(Layer):\n    """"""\n    Waiting for contribution\n\n    Single DenseLayer with Max-out behaviour, work well with Dropout.\n\n    References\n    -----------\n    `Goodfellow (2013) Maxout Networks <http://arxiv.org/abs/1302.4389>`_\n    """"""\n    def __init__(\n        self,\n        layer = None,\n        n_units = 100,\n        name =\'maxout_layer\',\n    ):\n        Layer.__init__(self, name=name)\n        self.inputs = layer.outputs\n\n        print(""  [TL] MaxoutLayer %s: %d"" % (self.name, self.n_units))\n        print(""    Waiting for contribution"")\n        with tf.variable_scope(name) as vs:\n            pass\n            # W = tf.Variable(init.xavier_init(n_inputs=n_in, n_outputs=n_units, uniform=True), name=\'W\')\n            # b = tf.Variable(tf.zeros([n_units]), name=\'b\')\n\n        # self.outputs = act(tf.matmul(self.inputs, W) + b)\n        # https://www.tensorflow.org/versions/r0.9/api_docs/python/array_ops.html#pack\n        # http://stackoverflow.com/questions/34362193/how-to-explicitly-broadcast-a-tensor-to-match-anothers-shape-in-tensorflow\n        # tf.concat tf.pack  tf.tile\n\n        self.all_layers = list(layer.all_layers)\n        self.all_params = list(layer.all_params)\n        self.all_drop = dict(layer.all_drop)\n        self.all_layers.extend( [self.outputs] )\n        self.all_params.extend( [W, b] )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n'"
tensorlayer/nlp.py,10,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\n\nimport tensorflow as tf\nimport os\nfrom sys import platform as _platform\nimport collections\nimport random\nimport numpy as np\nimport warnings\nfrom six.moves import xrange\nfrom tensorflow.python.platform import gfile\nimport re\n\n## Iteration functions\ndef generate_skip_gram_batch(data, batch_size, num_skips, skip_window, data_index=0):\n    """"""Generate a training batch for the Skip-Gram model.\n\n    Parameters\n    ----------\n    data : a list\n        To present context.\n    batch_size : an int\n        Batch size to return.\n    num_skips : an int\n        How many times to reuse an input to generate a label.\n    skip_window : an int\n        How many words to consider left and right.\n    data_index : an int\n        Index of the context location.\n        without using yield, this code use data_index to instead.\n\n    Returns\n    --------\n    batch : a list\n        Inputs\n    labels : a list\n        Labels\n    data_index : an int\n        Index of the context location.\n\n    Examples\n    --------\n    >>> Setting num_skips=2, skip_window=1, use the right and left words.\n    >>> In the same way, num_skips=4, skip_window=2 means use the nearby 4 words.\n\n    >>> data = [1,2,3,4,5,6,7,8,9,10,11]\n    >>> batch, labels, data_index = tl.nlp.generate_skip_gram_batch(data=data, batch_size=8, num_skips=2, skip_window=1, data_index=0)\n    >>> print(batch)\n    ... [2 2 3 3 4 4 5 5]\n    >>> print(labels)\n    ... [[3]\n    ... [1]\n    ... [4]\n    ... [2]\n    ... [5]\n    ... [3]\n    ... [4]\n    ... [6]]\n\n    References\n    -----------\n    - `TensorFlow word2vec tutorial <https://www.tensorflow.org/versions/r0.9/tutorials/word2vec/index.html#vector-representations-of-words>`_\n    """"""\n    # global data_index   # you can put data_index outside the function, then\n    #       modify the global data_index in the function without return it.\n    # note: without using yield, this code use data_index to instead.\n    assert batch_size % num_skips == 0\n    assert num_skips <= 2 * skip_window\n    batch = np.ndarray(shape=(batch_size), dtype=np.int32)\n    labels = np.ndarray(shape=(batch_size, 1), dtype=np.int32)\n    span = 2 * skip_window + 1 # [ skip_window target skip_window ]\n    buffer = collections.deque(maxlen=span)\n    for _ in range(span):\n        buffer.append(data[data_index])\n        data_index = (data_index + 1) % len(data)\n    for i in range(batch_size // num_skips):\n        target = skip_window  # target label at the center of the buffer\n        targets_to_avoid = [ skip_window ]\n        for j in range(num_skips):\n            while target in targets_to_avoid:\n                target = random.randint(0, span - 1)\n            targets_to_avoid.append(target)\n            batch[i * num_skips + j] = buffer[skip_window]\n            labels[i * num_skips + j, 0] = buffer[target]\n        buffer.append(data[data_index])\n        data_index = (data_index + 1) % len(data)\n    return batch, labels, data_index\n\n\n## Sampling functions\ndef sample(a=[], temperature=1.0):\n    """"""Sample an index from a probability array.\n\n    Parameters\n    ----------\n    a : a list\n        List of probabilities.\n    temperature : float or None\n        The higher the more uniform.\\n\n        When a = [0.1, 0.2, 0.7],\\n\n            temperature = 0.7, the distribution will be sharpen [ 0.05048273  0.13588945  0.81362782]\\n\n            temperature = 1.0, the distribution will be the same [0.1    0.2    0.7]\\n\n            temperature = 1.5, the distribution will be filtered [ 0.16008435  0.25411807  0.58579758]\\n\n        If None, it will be ``np.argmax(a)``\n\n    Notes\n    ------\n    No matter what is the temperature and input list, the sum of all probabilities will be one.\n    Even if input list = [1, 100, 200], the sum of all probabilities will still be one.\n\n    For large vocabulary_size, choice a higher temperature to avoid error.\n    """"""\n    b = np.copy(a)\n    try:\n        if temperature == 1:\n            return np.argmax(np.random.multinomial(1, a, 1))\n        if temperature is None:\n            return np.argmax(a)\n        else:\n            a = np.log(a) / temperature\n            a = np.exp(a) / np.sum(np.exp(a))\n            return np.argmax(np.random.multinomial(1, a, 1))\n    except:\n        # np.set_printoptions(threshold=np.nan)\n        # print(a)\n        # print(np.sum(a))\n        # print(np.max(a))\n        # print(np.min(a))\n        # exit()\n        message = ""For large vocabulary_size, choice a higher temperature\\\n         to avoid log error. Hint : use ``sample_top``. ""\n        warnings.warn(message, Warning)\n        # print(a)\n        # print(b)\n        return np.argmax(np.random.multinomial(1, b, 1))\n\ndef sample_top(a=[], top_k=10):\n    """"""Sample from ``top_k`` probabilities.\n\n    Parameters\n    ----------\n    a : a list\n        List of probabilities.\n    top_k : int\n        Number of candidates to be considered.\n    """"""\n    idx = np.argpartition(a, -top_k)[-top_k:]\n    probs = a[idx]\n    # print(""new"", probs)\n    probs = probs / np.sum(probs)\n    choice = np.random.choice(idx, p=probs)\n    return choice\n    ## old implementation\n    # a = np.array(a)\n    # idx = np.argsort(a)[::-1]\n    # idx = idx[:top_k]\n    # # a = a[idx]\n    # probs = a[idx]\n    # print(""prev"", probs)\n    # # probs = probs / np.sum(probs)\n    # # choice = np.random.choice(idx, p=probs)\n    # # return choice\n\n\n## Vector representations of words (Advanced)  UNDOCUMENT\nclass SimpleVocabulary(object):\n  """"""Simple vocabulary wrapper, see create_vocab().\n\n  Parameters\n  ------------\n  vocab : A dictionary of word to word_id.\n  unk_id : Id of the special \'unknown\' word.\n  """"""\n\n  def __init__(self, vocab, unk_id):\n    """"""Initializes the vocabulary.""""""\n\n\n    self._vocab = vocab\n    self._unk_id = unk_id\n\n  def word_to_id(self, word):\n    """"""Returns the integer id of a word string.""""""\n    if word in self._vocab:\n      return self._vocab[word]\n    else:\n      return self._unk_id\n\nclass Vocabulary(object):\n  """"""Create Vocabulary class from a given vocabulary and its id-word, word-id convert,\n  see create_vocab() and ``tutorial_tfrecord3.py``.\n\n  Parameters\n  -----------\n  vocab_file : File containing the vocabulary, where the words are the first\n        whitespace-separated token on each line (other tokens are ignored) and\n        the word ids are the corresponding line numbers.\n  start_word : Special word denoting sentence start.\n  end_word : Special word denoting sentence end.\n  unk_word : Special word denoting unknown words.\n\n  Properties\n  ------------\n  vocab : a dictionary from word to id.\n  reverse_vocab : a list from id to word.\n  start_id : int of start id\n  end_id : int of end id\n  unk_id : int of unk id\n  pad_id : int of padding id\n\n  Vocab_files\n  -------------\n  >>> Look as follow, includes `start_word` , `end_word` but no `unk_word` .\n  >>> a 969108\n  >>> <S> 586368\n  >>> </S> 586368\n  >>> . 440479\n  >>> on 213612\n  >>> of 202290\n  >>> the 196219\n  >>> in 182598\n  >>> with 152984\n  >>> and 139109\n  >>> is 97322\n  """"""\n\n  def __init__(self,\n               vocab_file,\n               start_word=""<S>"",\n               end_word=""</S>"",\n               unk_word=""<UNK>"",\n               pad_word=""<PAD>""):\n    if not tf.gfile.Exists(vocab_file):\n      tf.logging.fatal(""Vocab file %s not found."", vocab_file)\n    tf.logging.info(""Initializing vocabulary from file: %s"", vocab_file)\n\n    with tf.gfile.GFile(vocab_file, mode=""r"") as f:\n      reverse_vocab = list(f.readlines())\n    reverse_vocab = [line.split()[0] for line in reverse_vocab]\n    assert start_word in reverse_vocab\n    assert end_word in reverse_vocab\n    if unk_word not in reverse_vocab:\n      reverse_vocab.append(unk_word)\n    vocab = dict([(x, y) for (y, x) in enumerate(reverse_vocab)])\n\n    print(""  [TL] Vocabulary from %s : %s %s %s"" % (vocab_file, start_word, end_word, unk_word))\n    print(""    vocabulary with %d words (includes start_word, end_word, unk_word)"" % len(vocab))\n    # tf.logging.info(""     vocabulary with %d words"" % len(vocab))\n\n    self.vocab = vocab  # vocab[word] = id\n    self.reverse_vocab = reverse_vocab  # reverse_vocab[id] = word\n\n    # Save special word ids.\n    self.start_id = vocab[start_word]\n    self.end_id = vocab[end_word]\n    self.unk_id = vocab[unk_word]\n    self.pad_id = vocab[pad_word]\n    print(""      start_id: %d"" % self.start_id)\n    print(""      end_id: %d"" % self.end_id)\n    print(""      unk_id: %d"" % self.unk_id)\n    print(""      pad_id: %d"" % self.pad_id)\n\n  def word_to_id(self, word):\n    """"""Returns the integer word id of a word string.""""""\n    if word in self.vocab:\n      return self.vocab[word]\n    else:\n      return self.unk_id\n\n  def id_to_word(self, word_id):\n    """"""Returns the word string of an integer word id.""""""\n    if word_id >= len(self.reverse_vocab):\n      return self.reverse_vocab[self.unk_id]\n    else:\n      return self.reverse_vocab[word_id]\n\ndef process_sentence(sentence, start_word=""<S>"", end_word=""</S>""):\n    """"""Converts a sentence string into a list of string words, add start_word and end_word,\n    see ``create_vocab()`` and ``tutorial_tfrecord3.py``.\n\n    Parameter\n    ---------\n    sentence : a sentence in string.\n    start_word : a string or None, if None, non start word will be appended.\n    end_word : a string or None, if None, non end word will be appended.\n\n    Returns\n    ---------\n    A list of strings; the processed caption.\n\n    Examples\n    -----------\n    >>> c = ""how are you?""\n    >>> c = tl.nlp.process_sentence(c)\n    >>> print(c)\n    ... [\'<S>\', \'how\', \'are\', \'you\', \'?\', \'</S>\']\n    """"""\n    try:\n        import nltk\n    except:\n        raise Exception(""Hint : NLTK is required."")\n    if start_word is not None:\n        process_sentence = [start_word]\n    else:\n        process_sentence = []\n    process_sentence.extend(nltk.tokenize.word_tokenize(sentence.lower()))\n    if end_word is not None:\n        process_sentence.append(end_word)\n    return process_sentence\n\ndef create_vocab(sentences, word_counts_output_file, min_word_count=1):\n    """"""Creates the vocabulary of word to word_id, see create_vocab() and ``tutorial_tfrecord3.py``.\n\n    The vocabulary is saved to disk in a text file of word counts. The id of each\n    word in the file is its corresponding 0-based line number.\n\n    Parameters\n    ------------\n    sentences : a list of lists of strings.\n    word_counts_output_file : A string\n        The file name.\n    min_word_count : a int\n        Minimum number of occurrences for a word.\n\n    Returns\n    --------\n    - tl.nlp.SimpleVocabulary object.\n\n    Mores\n    -----\n    - ``tl.nlp.build_vocab()``\n\n    Examples\n    --------\n    >>> captions = [""one two , three"", ""four five five""]\n    >>> processed_capts = []\n    >>> for c in captions:\n    >>>     c = tl.nlp.process_sentence(c, start_word=""<S>"", end_word=""</S>"")\n    >>>     processed_capts.append(c)\n    >>> print(processed_capts)\n    ...[[\'<S>\', \'one\', \'two\', \',\', \'three\', \'</S>\'], [\'<S>\', \'four\', \'five\', \'five\', \'</S>\']]\n\n    >>> tl.nlp.create_vocab(processed_capts, word_counts_output_file=\'vocab.txt\', min_word_count=1)\n    ...   [TL] Creating vocabulary.\n    ...   Total words: 8\n    ...   Words in vocabulary: 8\n    ...   Wrote vocabulary file: vocab.txt\n    >>> vocab = tl.nlp.Vocabulary(\'vocab.txt\', start_word=""<S>"", end_word=""</S>"", unk_word=""<UNK>"")\n    ...   [TL] Instantiate Vocabulary from vocab.txt : <S> </S> <UNK>\n    ...   vocabulary with 9 words (includes unk_word)\n    """"""\n    from collections import Counter\n    print(""  [TL] Creating vocabulary."")\n    counter = Counter()\n    for c in sentences:\n        counter.update(c)\n        # print(\'c\',c)\n    print(""    Total words: %d"" % len(counter))\n\n    # Filter uncommon words and sort by descending count.\n    word_counts = [x for x in counter.items() if x[1] >= min_word_count]\n    word_counts.sort(key=lambda x: x[1], reverse=True)\n    word_counts = [(""<PAD>"", 0)] + word_counts # 1st id should be reserved for padding\n    # print(word_counts)\n    print(""    Words in vocabulary: %d"" % len(word_counts))\n\n    # Write out the word counts file.\n    with tf.gfile.FastGFile(word_counts_output_file, ""w"") as f:\n        f.write(""\\n"".join([""%s %d"" % (w, c) for w, c in word_counts]))\n    print(""    Wrote vocabulary file: %s"" % word_counts_output_file)\n\n    # Create the vocabulary dictionary.\n    reverse_vocab = [x[0] for x in word_counts]\n    unk_id = len(reverse_vocab)\n    vocab_dict = dict([(x, y) for (y, x) in enumerate(reverse_vocab)])\n    vocab = SimpleVocabulary(vocab_dict, unk_id)\n\n    return vocab\n\n\n## Vector representations of words\ndef simple_read_words(filename=""nietzsche.txt""):\n    """"""Read context from file without any preprocessing.\n\n    Parameters\n    ----------\n    filename : a string\n        A file path (like .txt file)\n\n    Returns\n    --------\n    The context in a string\n    """"""\n    with open(""nietzsche.txt"", ""r"") as f:\n        words = f.read()\n        return words\n\ndef read_words(filename=""nietzsche.txt"", replace = [\'\\n\', \'<eos>\']):\n    """"""File to list format context. Note that, this script can not handle punctuations.\n    For customized read_words method, see ``tutorial_generate_text.py``.\n\n    Parameters\n    ----------\n    filename : a string\n        A file path (like .txt file),\n    replace : a list\n        [original string, target string], to disable replace use [\'\', \'\']\n\n    Returns\n    --------\n    The context in a list, split by space by default, and use ``\'<eos>\'`` to represent ``\'\\n\'``,\n    e.g. ``[... \'how\', \'useful\', \'it\', ""\'s"" ... ]``.\n\n    Code References\n    ---------------\n    - `tensorflow.models.rnn.ptb.reader <https://github.com/tensorflow/tensorflow/tree/master/tensorflow/models/rnn/ptb>`_\n    """"""\n    with tf.gfile.GFile(filename, ""r"") as f:\n        try:    # python 3.4 or older\n            context_list = f.read().replace(*replace).split()\n        except: # python 3.5\n            f.seek(0)\n            replace = [x.encode(\'utf-8\') for x in replace]\n            context_list = f.read().replace(*replace).split()\n        return context_list\n\ndef read_analogies_file(eval_file=\'questions-words.txt\', word2id={}):\n    """"""Reads through an analogy question file, return its id format.\n\n    Parameters\n    ----------\n    eval_data : a string\n        The file name.\n    word2id : a dictionary\n        Mapping words to unique IDs.\n\n    Returns\n    --------\n    analogy_questions : a [n, 4] numpy array containing the analogy question\'s\n             word ids.\n             questions_skipped: questions skipped due to unknown words.\n\n    Examples\n    ---------\n    >>> eval_file should be in this format :\n    >>> : capital-common-countries\n    >>> Athens Greece Baghdad Iraq\n    >>> Athens Greece Bangkok Thailand\n    >>> Athens Greece Beijing China\n    >>> Athens Greece Berlin Germany\n    >>> Athens Greece Bern Switzerland\n    >>> Athens Greece Cairo Egypt\n    >>> Athens Greece Canberra Australia\n    >>> Athens Greece Hanoi Vietnam\n    >>> Athens Greece Havana Cuba\n    ...\n\n    >>> words = tl.files.load_matt_mahoney_text8_dataset()\n    >>> data, count, dictionary, reverse_dictionary = \\\n                tl.nlp.build_words_dataset(words, vocabulary_size, True)\n    >>> analogy_questions = tl.nlp.read_analogies_file( \\\n                eval_file=\'questions-words.txt\', word2id=dictionary)\n    >>> print(analogy_questions)\n    ... [[ 3068  1248  7161  1581]\n    ... [ 3068  1248 28683  5642]\n    ... [ 3068  1248  3878   486]\n    ... ...,\n    ... [ 1216  4309 19982 25506]\n    ... [ 1216  4309  3194  8650]\n    ... [ 1216  4309   140   312]]\n    """"""\n    questions = []\n    questions_skipped = 0\n    with open(eval_file, ""rb"") as analogy_f:\n      for line in analogy_f:\n          if line.startswith(b"":""):  # Skip comments.\n                continue\n          words = line.strip().lower().split(b"" "")  # lowercase\n          ids = [word2id.get(w.strip()) for w in words]\n          if None in ids or len(ids) != 4:\n              questions_skipped += 1\n          else:\n              questions.append(np.array(ids))\n    print(""Eval analogy file: "", eval_file)\n    print(""Questions: "", len(questions))\n    print(""Skipped: "", questions_skipped)\n    analogy_questions = np.array(questions, dtype=np.int32)\n    return analogy_questions\n\ndef build_vocab(data):\n    """"""Build vocabulary.\n    Given the context in list format.\n    Return the vocabulary, which is a dictionary for word to id.\n    e.g. {\'campbell\': 2587, \'atlantic\': 2247, \'aoun\': 6746 .... }\n\n    Parameters\n    ----------\n    data : a list of string\n        the context in list format\n\n    Returns\n    --------\n    word_to_id : a dictionary\n        mapping words to unique IDs. e.g. {\'campbell\': 2587, \'atlantic\': 2247, \'aoun\': 6746 .... }\n\n    Code References\n    ---------------\n    - `tensorflow.models.rnn.ptb.reader <https://github.com/tensorflow/tensorflow/tree/master/tensorflow/models/rnn/ptb>`_\n\n    Examples\n    --------\n    >>> data_path = os.getcwd() + \'/simple-examples/data\'\n    >>> train_path = os.path.join(data_path, ""ptb.train.txt"")\n    >>> word_to_id = build_vocab(read_txt_words(train_path))\n    """"""\n    # data = _read_words(filename)\n    counter = collections.Counter(data)\n    # print(\'counter\', counter)   # dictionary for the occurrence number of each word, e.g. \'banknote\': 1, \'photography\': 1, \'kia\': 1\n    count_pairs = sorted(counter.items(), key=lambda x: (-x[1], x[0]))\n    # print(\'count_pairs\',count_pairs)  # convert dictionary to list of tuple, e.g. (\'ssangyong\', 1), (\'swapo\', 1), (\'wachter\', 1)\n    words, _ = list(zip(*count_pairs))\n    word_to_id = dict(zip(words, range(len(words))))\n    # print(words)    # list of words\n    # print(word_to_id) # dictionary for word to id, e.g. \'campbell\': 2587, \'atlantic\': 2247, \'aoun\': 6746\n    return word_to_id\n\ndef build_reverse_dictionary(word_to_id):\n    """"""Given a dictionary for converting word to integer id.\n    Returns a reverse dictionary for converting a id to word.\n\n    Parameters\n    ----------\n    word_to_id : dictionary\n        mapping words to unique ids\n\n    Returns\n    --------\n    reverse_dictionary : a dictionary\n        mapping ids to words\n    """"""\n    reverse_dictionary = dict(zip(word_to_id.values(), word_to_id.keys()))\n    return reverse_dictionary\n\ndef build_words_dataset(words=[], vocabulary_size=50000, printable=True, unk_key = \'UNK\'):\n    """"""Build the words dictionary and replace rare words with \'UNK\' token.\n    The most common word has the smallest integer id.\n\n    Parameters\n    ----------\n    words : a list of string or byte\n        The context in list format. You may need to do preprocessing on the words,\n        such as lower case, remove marks etc.\n    vocabulary_size : an int\n        The maximum vocabulary size, limiting the vocabulary size.\n        Then the script replaces rare words with \'UNK\' token.\n    printable : boolean\n        Whether to print the read vocabulary size of the given words.\n    unk_key : a string\n        Unknown words = unk_key\n\n    Returns\n    --------\n    data : a list of integer\n        The context in a list of ids\n    count : a list of tuple and list\n        count[0] is a list : the number of rare words\\n\n        count[1:] are tuples : the number of occurrence of each word\\n\n        e.g. [[\'UNK\', 418391], (b\'the\', 1061396), (b\'of\', 593677), (b\'and\', 416629), (b\'one\', 411764)]\n    dictionary : a dictionary\n        word_to_id, mapping words to unique IDs.\n    reverse_dictionary : a dictionary\n        id_to_word, mapping id to unique word.\n\n    Examples\n    --------\n    >>> words = tl.files.load_matt_mahoney_text8_dataset()\n    >>> vocabulary_size = 50000\n    >>> data, count, dictionary, reverse_dictionary = tl.nlp.build_words_dataset(words, vocabulary_size)\n\n    Code References\n    -----------------\n    - `tensorflow/examples/tutorials/word2vec/word2vec_basic.py <https://github.com/tensorflow/tensorflow/blob/r0.7/tensorflow/examples/tutorials/word2vec/word2vec_basic.py>`_\n    """"""\n    import collections\n    count = [[unk_key, -1]]\n    count.extend(collections.Counter(words).most_common(vocabulary_size - 1))\n    dictionary = dict()\n    for word, _ in count:\n        dictionary[word] = len(dictionary)\n    data = list()\n    unk_count = 0\n    for word in words:\n        if word in dictionary:\n            index = dictionary[word]\n        else:\n            index = 0  # dictionary[\'UNK\']\n            unk_count += 1\n        data.append(index)\n    count[0][1] = unk_count\n    reverse_dictionary = dict(zip(dictionary.values(), dictionary.keys()))\n    if printable:\n        print(\'Real vocabulary size    %d\' % len(collections.Counter(words).keys()))\n        print(\'Limited vocabulary size {}\'.format(vocabulary_size))\n    assert len(collections.Counter(words).keys()) >= vocabulary_size , \\\n            ""the limited vocabulary_size must be less than or equal to the read vocabulary_size""\n    return data, count, dictionary, reverse_dictionary\n\ndef words_to_word_ids(data=[], word_to_id={}, unk_key = \'UNK\'):\n    """"""Given a context (words) in list format and the vocabulary,\n    Returns a list of IDs to represent the context.\n\n    Parameters\n    ----------\n    data : a list of string or byte\n        the context in list format\n    word_to_id : a dictionary\n        mapping words to unique IDs.\n    unk_key : a string\n        Unknown words = unk_key\n\n    Returns\n    --------\n    A list of IDs to represent the context.\n\n    Examples\n    --------\n    >>> words = tl.files.load_matt_mahoney_text8_dataset()\n    >>> vocabulary_size = 50000\n    >>> data, count, dictionary, reverse_dictionary = \\\n    ...         tl.nlp.build_words_dataset(words, vocabulary_size, True)\n    >>> context = [b\'hello\', b\'how\', b\'are\', b\'you\']\n    >>> ids = tl.nlp.words_to_word_ids(words, dictionary)\n    >>> context = tl.nlp.word_ids_to_words(ids, reverse_dictionary)\n    >>> print(ids)\n    ... [6434, 311, 26, 207]\n    >>> print(context)\n    ... [b\'hello\', b\'how\', b\'are\', b\'you\']\n\n    Code References\n    ---------------\n    - `tensorflow.models.rnn.ptb.reader <https://github.com/tensorflow/tensorflow/tree/master/tensorflow/models/rnn/ptb>`_\n    """"""\n    # if isinstance(data[0], six.string_types):\n    #     print(type(data[0]))\n    #     # exit()\n    #     print(data[0])\n    #     print(word_to_id)\n    #     return [word_to_id[str(word)] for word in data]\n    # else:\n\n    word_ids = []\n    for word in data:\n        if word_to_id.get(word) is not None:\n            word_ids.append(word_to_id[word])\n        else:\n            word_ids.append(word_to_id[unk_key])\n    return word_ids\n    # return [word_to_id[word] for word in data]    # this one\n\n    # if isinstance(data[0], str):\n    #     # print(\'is a string object\')\n    #     return [word_to_id[word] for word in data]\n    # else:#if isinstance(s, bytes):\n    #     # print(\'is a unicode object\')\n    #     # print(data[0])\n    #     return [word_to_id[str(word)] f\n\ndef word_ids_to_words(data, id_to_word):\n    """"""Given a context (ids) in list format and the vocabulary,\n    Returns a list of words to represent the context.\n\n    Parameters\n    ----------\n    data : a list of integer\n        the context in list format\n    id_to_word : a dictionary\n        mapping id to unique word.\n\n    Returns\n    --------\n    A list of string or byte to represent the context.\n\n    Examples\n    ---------\n    >>> see words_to_word_ids\n    """"""\n    return [id_to_word[i] for i in data]\n\ndef save_vocab(count=[], name=\'vocab.txt\'):\n    """"""Save the vocabulary to a file so the model can be reloaded.\n\n    Parameters\n    ----------\n    count : a list of tuple and list\n        count[0] is a list : the number of rare words\\n\n        count[1:] are tuples : the number of occurrence of each word\\n\n        e.g. [[\'UNK\', 418391], (b\'the\', 1061396), (b\'of\', 593677), (b\'and\', 416629), (b\'one\', 411764)]\n\n    Examples\n    ---------\n    >>> words = tl.files.load_matt_mahoney_text8_dataset()\n    >>> vocabulary_size = 50000\n    >>> data, count, dictionary, reverse_dictionary = \\\n    ...     tl.nlp.build_words_dataset(words, vocabulary_size, True)\n    >>> tl.nlp.save_vocab(count, name=\'vocab_text8.txt\')\n    >>> vocab_text8.txt\n    ... UNK 418391\n    ... the 1061396\n    ... of 593677\n    ... and 416629\n    ... one 411764\n    ... in 372201\n    ... a 325873\n    ... to 316376\n    """"""\n    pwd = os.getcwd()\n    vocabulary_size = len(count)\n    with open(os.path.join(pwd, name), ""w"") as f:\n        for i in xrange(vocabulary_size):\n            f.write(""%s %d\\n"" % (tf.compat.as_text(count[i][0]), count[i][1]))\n    print(""%d vocab saved to %s in %s"" % (vocabulary_size, name, pwd))\n\n## Functions for translation\ndef basic_tokenizer(sentence, _WORD_SPLIT=re.compile(b""([.,!?\\""\':;)(])"")):\n  """"""Very basic tokenizer: split the sentence into a list of tokens.\n\n  Parameters\n  -----------\n  sentence : tensorflow.python.platform.gfile.GFile Object\n  _WORD_SPLIT : regular expression for word spliting.\n\n\n  Examples\n  --------\n  >>> see create_vocabulary\n  >>> from tensorflow.python.platform import gfile\n  >>> train_path = ""wmt/giga-fren.release2""\n  >>> with gfile.GFile(train_path + "".en"", mode=""rb"") as f:\n  >>>    for line in f:\n  >>>       tokens = tl.nlp.basic_tokenizer(line)\n  >>>       print(tokens)\n  >>>       exit()\n  ... [b\'Changing\', b\'Lives\', b\'|\', b\'Changing\', b\'Society\', b\'|\', b\'How\',\n  ...   b\'It\', b\'Works\', b\'|\', b\'Technology\', b\'Drives\', b\'Change\', b\'Home\',\n  ...   b\'|\', b\'Concepts\', b\'|\', b\'Teachers\', b\'|\', b\'Search\', b\'|\', b\'Overview\',\n  ...   b\'|\', b\'Credits\', b\'|\', b\'HHCC\', b\'Web\', b\'|\', b\'Reference\', b\'|\',\n  ...   b\'Feedback\', b\'Virtual\', b\'Museum\', b\'of\', b\'Canada\', b\'Home\', b\'Page\']\n\n  References\n  ----------\n  - Code from ``/tensorflow/models/rnn/translation/data_utils.py``\n  """"""\n  words = []\n  sentence = tf.compat.as_bytes(sentence)\n  for space_separated_fragment in sentence.strip().split():\n    words.extend(re.split(_WORD_SPLIT, space_separated_fragment))\n  return [w for w in words if w]\n\ndef create_vocabulary(vocabulary_path, data_path, max_vocabulary_size,\n                      tokenizer=None, normalize_digits=True,\n                      _DIGIT_RE=re.compile(br""\\d""),\n                      _START_VOCAB=[b""_PAD"", b""_GO"", b""_EOS"", b""_UNK""]):\n  """"""Create vocabulary file (if it does not exist yet) from data file.\n\n  Data file is assumed to contain one sentence per line. Each sentence is\n  tokenized and digits are normalized (if normalize_digits is set).\n  Vocabulary contains the most-frequent tokens up to max_vocabulary_size.\n  We write it to vocabulary_path in a one-token-per-line format, so that later\n  token in the first line gets id=0, second line gets id=1, and so on.\n\n  Parameters\n  -----------\n  vocabulary_path : path where the vocabulary will be created.\n  data_path : data file that will be used to create vocabulary.\n  max_vocabulary_size : limit on the size of the created vocabulary.\n  tokenizer : a function to use to tokenize each data sentence.\n        if None, basic_tokenizer will be used.\n  normalize_digits : Boolean\n        if true, all digits are replaced by 0s.\n\n  References\n  ----------\n  - Code from ``/tensorflow/models/rnn/translation/data_utils.py``\n  """"""\n  if not gfile.Exists(vocabulary_path):\n    print(""Creating vocabulary %s from data %s"" % (vocabulary_path, data_path))\n    vocab = {}\n    with gfile.GFile(data_path, mode=""rb"") as f:\n      counter = 0\n      for line in f:\n        counter += 1\n        if counter % 100000 == 0:\n          print(""  processing line %d"" % counter)\n        tokens = tokenizer(line) if tokenizer else basic_tokenizer(line)\n        for w in tokens:\n          word = re.sub(_DIGIT_RE, b""0"", w) if normalize_digits else w\n          if word in vocab:\n            vocab[word] += 1\n          else:\n            vocab[word] = 1\n      vocab_list = _START_VOCAB + sorted(vocab, key=vocab.get, reverse=True)\n      if len(vocab_list) > max_vocabulary_size:\n        vocab_list = vocab_list[:max_vocabulary_size]\n      with gfile.GFile(vocabulary_path, mode=""wb"") as vocab_file:\n        for w in vocab_list:\n          vocab_file.write(w + b""\\n"")\n  else:\n    print(""Vocabulary %s from data %s exists"" % (vocabulary_path, data_path))\n\ndef initialize_vocabulary(vocabulary_path):\n  """"""Initialize vocabulary from file, return the word_to_id (dictionary)\n  and id_to_word (list).\n\n  We assume the vocabulary is stored one-item-per-line, so a file:\\n\n    dog\\n\n    cat\\n\n  will result in a vocabulary {""dog"": 0, ""cat"": 1}, and this function will\n  also return the reversed-vocabulary [""dog"", ""cat""].\n\n  Parameters\n  -----------\n  vocabulary_path : path to the file containing the vocabulary.\n\n  Returns\n  --------\n  vocab : a dictionary\n        Word to id. A dictionary mapping string to integers.\n  rev_vocab : a list\n        Id to word. The reversed vocabulary (a list, which reverses the vocabulary mapping).\n\n  Examples\n  ---------\n  >>> Assume \'test\' contains\n  ... dog\n  ... cat\n  ... bird\n  >>> vocab, rev_vocab = tl.nlp.initialize_vocabulary(""test"")\n  >>> print(vocab)\n  >>> {b\'cat\': 1, b\'dog\': 0, b\'bird\': 2}\n  >>> print(rev_vocab)\n  >>> [b\'dog\', b\'cat\', b\'bird\']\n\n  Raises\n  -------\n  ValueError : if the provided vocabulary_path does not exist.\n  """"""\n  if gfile.Exists(vocabulary_path):\n    rev_vocab = []\n    with gfile.GFile(vocabulary_path, mode=""rb"") as f:\n      rev_vocab.extend(f.readlines())\n    rev_vocab = [tf.compat.as_bytes(line.strip()) for line in rev_vocab]\n    vocab = dict([(x, y) for (y, x) in enumerate(rev_vocab)])\n    return vocab, rev_vocab\n  else:\n    raise ValueError(""Vocabulary file %s not found."", vocabulary_path)\n\ndef sentence_to_token_ids(sentence, vocabulary,\n                          tokenizer=None, normalize_digits=True,\n                          UNK_ID=3, _DIGIT_RE=re.compile(br""\\d"")):\n  """"""Convert a string to list of integers representing token-ids.\n\n  For example, a sentence ""I have a dog"" may become tokenized into\n  [""I"", ""have"", ""a"", ""dog""] and with vocabulary {""I"": 1, ""have"": 2,\n  ""a"": 4, ""dog"": 7""} this function will return [1, 2, 4, 7].\n\n  Parameters\n  -----------\n  sentence :  tensorflow.python.platform.gfile.GFile Object\n        The sentence in bytes format to convert to token-ids.\\n\n        see basic_tokenizer(), data_to_token_ids()\n  vocabulary : a dictionary mapping tokens to integers.\n  tokenizer : a function to use to tokenize each sentence;\n        If None, basic_tokenizer will be used.\n  normalize_digits : Boolean\n        If true, all digits are replaced by 0s.\n\n  Returns\n  --------\n  A list of integers, the token-ids for the sentence.\n  """"""\n\n  if tokenizer:\n    words = tokenizer(sentence)\n  else:\n    words = basic_tokenizer(sentence)\n  if not normalize_digits:\n    return [vocabulary.get(w, UNK_ID) for w in words]\n  # Normalize digits by 0 before looking words up in the vocabulary.\n  return [vocabulary.get(re.sub(_DIGIT_RE, b""0"", w), UNK_ID) for w in words]\n\ndef data_to_token_ids(data_path, target_path, vocabulary_path,\n                      tokenizer=None, normalize_digits=True,\n                      UNK_ID=3, _DIGIT_RE=re.compile(br""\\d"")):\n  """"""Tokenize data file and turn into token-ids using given vocabulary file.\n\n  This function loads data line-by-line from data_path, calls the above\n  sentence_to_token_ids, and saves the result to target_path. See comment\n  for sentence_to_token_ids on the details of token-ids format.\n\n  Parameters\n  -----------\n  data_path : path to the data file in one-sentence-per-line format.\n  target_path : path where the file with token-ids will be created.\n  vocabulary_path : path to the vocabulary file.\n  tokenizer : a function to use to tokenize each sentence;\n      if None, basic_tokenizer will be used.\n  normalize_digits : Boolean; if true, all digits are replaced by 0s.\n\n  References\n  ----------\n  - Code from ``/tensorflow/models/rnn/translation/data_utils.py``\n  """"""\n  if not gfile.Exists(target_path):\n    print(""Tokenizing data in %s"" % data_path)\n    vocab, _ = initialize_vocabulary(vocabulary_path)\n    with gfile.GFile(data_path, mode=""rb"") as data_file:\n      with gfile.GFile(target_path, mode=""w"") as tokens_file:\n        counter = 0\n        for line in data_file:\n          counter += 1\n          if counter % 100000 == 0:\n            print(""  tokenizing line %d"" % counter)\n          token_ids = sentence_to_token_ids(line, vocab, tokenizer,\n                                            normalize_digits, UNK_ID=UNK_ID,\n                                            _DIGIT_RE=_DIGIT_RE)\n          tokens_file.write("" "".join([str(tok) for tok in token_ids]) + ""\\n"")\n  else:\n    print(""Target path %s exists"" % target_path)\n'"
tensorlayer/ops.py,2,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\n\nimport tensorflow as tf\nimport os\nimport sys\nfrom sys import platform as _platform\n\n\ndef exit_tf(sess=None):\n    """"""Close tensorboard and nvidia-process if available\n\n    Parameters\n    ----------\n    sess : a session instance of TensorFlow\n        TensorFlow session\n    """"""\n    text = ""[tl] Close tensorboard and nvidia-process if available""\n    sess.close()\n    # import time\n    # time.sleep(2)\n    if _platform == ""linux"" or _platform == ""linux2"":\n        print(\'linux: %s\' % text)\n        os.system(\'nvidia-smi\')\n        os.system(\'fuser 6006/tcp -k\')  # kill tensorboard 6006\n        os.system(""nvidia-smi | grep python |awk \'{print $3}\'|xargs kill"") # kill all nvidia-smi python process\n    elif _platform == ""darwin"":\n        print(\'OS X: %s\' % text)\n        os.system(""lsof -i tcp:6006 | grep -v PID | awk \'{print $2}\' | xargs kill"") # kill tensorboard 6006\n    elif _platform == ""win32"":\n        print(\'Windows: %s\' % text)\n    else:\n        print(_platform)\n    exit()\n\ndef clear_all(printable=True):\n    """"""Clears all the placeholder variables of keep prob,\n    including keeping probabilities of all dropout, denoising, dropconnect etc.\n\n    Parameters\n    ----------\n    printable : boolean\n        If True, print all deleted variables.\n    """"""\n    print(\'clear all .....................................\')\n    gl = globals().copy()\n    for var in gl:\n        if var[0] == \'_\': continue\n        if \'func\' in str(globals()[var]): continue\n        if \'module\' in str(globals()[var]): continue\n        if \'class\' in str(globals()[var]): continue\n\n        if printable:\n            print("" clear_all ------- %s"" % str(globals()[var]))\n\n        del globals()[var]\n\n# def clear_all2(vars, printable=True):\n#     """"""\n#     The :function:`clear_all()` Clears all the placeholder variables of keep prob,\n#     including keeping probabilities of all dropout, denoising, dropconnect\n#     Parameters\n#     ----------\n#     printable : if True, print all deleted variables.\n#     """"""\n#     print(\'clear all .....................................\')\n#     for var in vars:\n#         if var[0] == \'_\': continue\n#         if \'func\' in str(var): continue\n#         if \'module\' in str(var): continue\n#         if \'class\' in str(var): continue\n#\n#         if printable:\n#             print("" clear_all ------- %s"" % str(var))\n#\n#         del var\n\ndef set_gpu_fraction(sess=None, gpu_fraction=0.3):\n    """"""Set the GPU memory fraction for the application.\n\n    Parameters\n    ----------\n    sess : a session instance of TensorFlow\n        TensorFlow session\n    gpu_fraction : a float\n        Fraction of GPU memory, (0 ~ 1]\n\n    References\n    ----------\n    - `TensorFlow using GPU <https://www.tensorflow.org/versions/r0.9/how_tos/using_gpu/index.html>`_\n    """"""\n    print(""  tensorlayer: GPU MEM Fraction %f"" % gpu_fraction)\n    gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=gpu_fraction)\n    sess = tf.Session(config = tf.ConfigProto(gpu_options = gpu_options))\n    return sess\n\n\n\n\n\ndef disable_print():\n    """"""Disable console output, ``suppress_stdout`` is recommended.\n\n    Examples\n    ---------\n    >>> print(""You can see me"")\n    >>> tl.ops.disable_print()\n    >>> print("" You can\'t see me"")\n    >>> tl.ops.enable_print()\n    >>> print(""You can see me"")\n    """"""\n    # sys.stdout = os.devnull   # this one kill the process\n    sys.stdout = None\n    sys.stderr = os.devnull\n\ndef enable_print():\n    """"""Enable console output, ``suppress_stdout`` is recommended.\n\n    Examples\n    --------\n    - see tl.ops.disable_print()\n    """"""\n    sys.stdout = sys.__stdout__\n    sys.stderr = sys.__stderr__\n\n\n# class temporary_disable_print:\n#     """"""Temporarily disable console output.\n#\n#     Examples\n#     ---------\n#     >>> print(""You can see me"")\n#     >>> with tl.ops.temporary_disable_print() as t:\n#     >>>     print(""You can\'t see me"")\n#     >>> print(""You can see me"")\n#     """"""\n#     def __init__(self):\n#         pass\n#     def __enter__(self):\n#         sys.stdout = None\n#         sys.stderr = os.devnull\n#     def __exit__(self, type, value, traceback):\n#         sys.stdout = sys.__stdout__\n#         sys.stderr = sys.__stderr__\n#         return isinstance(value, TypeError)\n\n\nfrom contextlib import contextmanager\n@contextmanager\ndef suppress_stdout():\n    """"""Temporarily disable console output.\n\n    Examples\n    ---------\n    >>> print(""You can see me"")\n    >>> with tl.ops.suppress_stdout():\n    >>>     print(""You can\'t see me"")\n    >>> print(""You can see me"")\n\n    References\n    -----------\n    - `stackoverflow <http://stackoverflow.com/questions/2125702/how-to-suppress-console-output-in-python>`_\n    """"""\n    with open(os.devnull, ""w"") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:\n            yield\n        finally:\n            sys.stdout = old_stdout\n\n\n\ndef get_site_packages_directory():\n    """"""Print and return the site-packages directory.\n\n    Examples\n    ---------\n    >>> loc = tl.ops.get_site_packages_directory()\n    """"""\n    import site\n    try:\n        loc = site.getsitepackages()\n        print(""  tl.ops : site-packages in "", loc)\n        return loc\n    except:\n        print(""  tl.ops : Cannot find package dir from virtual environment"")\n        return False\n\n\n\ndef empty_trash():\n    """"""Empty trash folder.\n\n    """"""\n    text = ""[tl] Empty the trash""\n    if _platform == ""linux"" or _platform == ""linux2"":\n        print(\'linux: %s\' % text)\n        os.system(""rm -rf ~/.local/share/Trash/*"")\n    elif _platform == ""darwin"":\n        print(\'OS X: %s\' % text)\n        os.system(""sudo rm -rf ~/.Trash/*"")\n    elif _platform == ""win32"":\n        print(\'Windows: %s\' % text)\n        try:\n            os.system(""rd /s c:\\$Recycle.Bin"")  # Windows 7 or Server 2008\n        except:\n            pass\n        try:\n            os.system(""rd /s c:\\recycler"")  #  Windows XP, Vista, or Server 2003\n        except:\n            pass\n    else:\n        print(_platform)\n\n#\n'"
tensorlayer/prepro.py,39,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\nimport tensorflow as tf\nimport tensorlayer as tl\nimport numpy as np\n\nimport time\nimport numbers\nimport random\nimport os\nimport re\nimport sys\n\nimport threading\n# import Queue  # <-- donot work for py3\nis_py2 = sys.version[0] == \'2\'\nif is_py2:\n    import Queue as queue\nelse:\n    import queue as queue\n\nfrom six.moves import range\nimport scipy\nfrom scipy import linalg\nimport scipy.ndimage as ndi\n\nfrom skimage import transform\nfrom skimage import exposure\nimport skimage\n\n# linalg https://docs.scipy.org/doc/scipy/reference/linalg.html\n# ndimage https://docs.scipy.org/doc/scipy/reference/ndimage.html\n\n## Threading\ndef threading_data(data=None, fn=None, **kwargs):\n    """"""Return a batch of result by given data.\n    Usually be used for data augmentation.\n\n    Parameters\n    -----------\n    data : numpy array or zip of numpy array, see Examples below.\n    fn : the function for data processing.\n    more args : the args for fn, see Examples below.\n\n    Examples\n    --------\n    - Single array\n    >>> X --> [batch_size, row, col, 1] greyscale\n    >>> results = threading_data(X, zoom, zoom_range=[0.5, 1], is_random=True)\n    ... results --> [batch_size, row, col, channel]\n    >>> tl.visualize.images2d(images=np.asarray(results), second=0.01, saveable=True, name=\'after\', dtype=None)\n    >>> tl.visualize.images2d(images=np.asarray(X), second=0.01, saveable=True, name=\'before\', dtype=None)\n\n    - List of array (e.g. functions with ``multi``)\n    >>> X, Y --> [batch_size, row, col, 1]  greyscale\n    >>> data = threading_data([_ for _ in zip(X, Y)], zoom_multi, zoom_range=[0.5, 1], is_random=True)\n    ... data --> [batch_size, 2, row, col, 1]\n    >>> X_, Y_ = data.transpose((1,0,2,3,4))\n    ... X_, Y_ --> [batch_size, row, col, 1]\n    >>> tl.visualize.images2d(images=np.asarray(X_), second=0.01, saveable=True, name=\'after\', dtype=None)\n    >>> tl.visualize.images2d(images=np.asarray(Y_), second=0.01, saveable=True, name=\'before\', dtype=None)\n\n    - Customized function for image segmentation\n    >>> def distort_img(data):\n    ...     x, y = data\n    ...     x, y = flip_axis_multi([x, y], axis=0, is_random=True)\n    ...     x, y = flip_axis_multi([x, y], axis=1, is_random=True)\n    ...     x, y = crop_multi([x, y], 100, 100, is_random=True)\n    ...     return x, y\n    >>> X, Y --> [batch_size, row, col, channel]\n    >>> data = threading_data([_ for _ in zip(X, Y)], distort_img)\n    >>> X_, Y_ = data.transpose((1,0,2,3,4))\n\n    References\n    ----------\n    - `python queue <https://pymotw.com/2/Queue/index.html#module-Queue>`_\n    - `run with limited queue <http://effbot.org/librarybook/queue.htm>`_\n    """"""\n    ## plot function info\n    # for name, value in kwargs.items():\n    #     print(\'{0} = {1}\'.format(name, value))\n    # exit()\n    # define function for threading\n    def apply_fn(results, i, data, kwargs):\n        results[i] = fn(data, **kwargs)\n\n    ## start multi-threaded reading.\n    results = [None] * len(data) ## preallocate result list\n    threads = []\n    for i in range(len(data)):\n        t = threading.Thread(\n                        name=\'threading_and_return\',\n                        target=apply_fn,\n                        args=(results, i, data[i], kwargs)\n                        )\n        t.start()\n        threads.append(t)\n\n    ## <Milo> wait for all threads to complete\n    for t in threads:\n        t.join()\n\n    return np.asarray(results)\n\n    ## old implementation\n    # define function for threading\n    # def function(q, i, data, kwargs):\n    #     result = fn(data, **kwargs)\n    #     q.put([i, result])\n    # ## start threading\n    # q = queue.Queue()\n    # threads = []\n    # for i in range(len(data)):\n    #     t = threading.Thread(\n    #                     name=\'threading_and_return\',\n    #                     target=function,\n    #                     args=(q, i, data[i], kwargs)\n    #                     )\n    #     t.start()\n    #     threads.append(t)\n    #\n    # ## <Milo> wait for all threads to complete\n    # for t in threads:\n    #     t.join()\n    #\n    # ## get results\n    # results = []\n    # for i in range(len(data)):\n    #     result = q.get()\n    #     results.append(result)\n    # results = sorted(results)\n    # for i in range(len(results)):\n    #     results[i] = results[i][1]\n    # return np.asarray(results)\n\n\n## Image\ndef rotation(x, rg=20, is_random=False, row_index=0, col_index=1, channel_index=2,\n                    fill_mode=\'nearest\', cval=0.):\n    """"""Rotate an image randomly or non-randomly.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    rg : int or float\n        Degree to rotate, usually 0 ~ 180.\n    is_random : boolean, default False\n        If True, randomly rotate.\n    row_index, col_index, channel_index : int\n        Index of row, col and channel, default (0, 1, 2), for theano (1, 2, 0).\n    fill_mode : string\n        Method to fill missing pixel, default \xe2\x80\x98nearest\xe2\x80\x99, more options \xe2\x80\x98constant\xe2\x80\x99, \xe2\x80\x98reflect\xe2\x80\x99 or \xe2\x80\x98wrap\xe2\x80\x99\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    cval : scalar, optional\n        Value used for points outside the boundaries of the input if mode=\'constant\'. Default is 0.0\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n\n    Examples\n    ---------\n    >>> x --> [row, col, 1] greyscale\n    >>> x = rotation(x, rg=40, is_random=False)\n    >>> tl.visualize.frame(x[:,:,0], second=0.01, saveable=True, name=\'temp\',cmap=\'gray\')\n    """"""\n    if is_random:\n        theta = np.pi / 180 * np.random.uniform(-rg, rg)\n    else:\n        theta = np.pi /180 * rg\n    rotation_matrix = np.array([[np.cos(theta), -np.sin(theta), 0],\n                                [np.sin(theta), np.cos(theta), 0],\n                                [0, 0, 1]])\n\n    h, w = x.shape[row_index], x.shape[col_index]\n    transform_matrix = transform_matrix_offset_center(rotation_matrix, h, w)\n    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n    return x\n\ndef rotation_multi(x, rg=20, is_random=False, row_index=0, col_index=1, channel_index=2,\n                    fill_mode=\'nearest\', cval=0.):\n    """"""Rotate multiple images with the same arguments, randomly or non-randomly.\n    Usually be used for image segmentation which x=[X, Y], X and Y should be matched.\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``rotation``.\n\n    Examples\n    --------\n    >>> x, y --> [row, col, 1]  greyscale\n    >>> x, y = rotation_multi([x, y], rg=90, is_random=False)\n    >>> tl.visualize.frame(x[:,:,0], second=0.01, saveable=True, name=\'x\',cmap=\'gray\')\n    >>> tl.visualize.frame(y[:,:,0], second=0.01, saveable=True, name=\'y\',cmap=\'gray\')\n    """"""\n    if is_random:\n        theta = np.pi / 180 * np.random.uniform(-rg, rg)\n    else:\n        theta = np.pi /180 * rg\n    rotation_matrix = np.array([[np.cos(theta), -np.sin(theta), 0],\n                                [np.sin(theta), np.cos(theta), 0],\n                                [0, 0, 1]])\n\n    h, w = x[0].shape[row_index], x[0].shape[col_index]\n    transform_matrix = transform_matrix_offset_center(rotation_matrix, h, w)\n    results = []\n    for data in x:\n        results.append( apply_transform(data, transform_matrix, channel_index, fill_mode, cval))\n    return np.asarray(results)\n\n# crop\ndef crop(x, wrg, hrg, is_random=False, row_index=0, col_index=1, channel_index=2):\n    """"""Randomly or centrally crop an image.\n\n    Parameters\n    ----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    wrg : float\n        Size of weight.\n    hrg : float\n        Size of height.\n    is_random : boolean, default False\n        If True, randomly crop, else central crop.\n    row_index, col_index, channel_index : int\n        Index of row, col and channel, default (0, 1, 2), for theano (1, 2, 0).\n    """"""\n    h, w = x.shape[row_index], x.shape[col_index]\n    assert (h > hrg) and (w > wrg), ""The size of cropping should smaller than the original image""\n    if is_random:\n        h_offset = int(np.random.uniform(0, h-hrg) -1)\n        w_offset = int(np.random.uniform(0, w-wrg) -1)\n        # print(h_offset, w_offset, x[h_offset: hrg+h_offset ,w_offset: wrg+w_offset].shape)\n        return x[h_offset: hrg+h_offset ,w_offset: wrg+w_offset]\n    else:   # central crop\n        h_offset = int(np.floor((h - hrg)/2.))\n        w_offset = int(np.floor((w - wrg)/2.))\n        h_end = h_offset + hrg\n        w_end = w_offset + wrg\n        return x[h_offset: h_end, w_offset: w_end]\n        # old implementation\n        # h_offset = (h - hrg)/2\n        # w_offset = (w - wrg)/2\n        # # print(x[h_offset: h-h_offset ,w_offset: w-w_offset].shape)\n        # return x[h_offset: h-h_offset ,w_offset: w-w_offset]\n        # central crop\n\n\ndef crop_multi(x, wrg, hrg, is_random=False, row_index=0, col_index=1, channel_index=2):\n    """"""Randomly or centrally crop multiple images.\n\n    Parameters\n    ----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``crop``.\n    """"""\n    h, w = x[0].shape[row_index], x[0].shape[col_index]\n    assert (h > hrg) and (w > wrg), ""The size of cropping should smaller than the original image""\n    if is_random:\n        h_offset = int(np.random.uniform(0, h-hrg) -1)\n        w_offset = int(np.random.uniform(0, w-wrg) -1)\n        results = []\n        for data in x:\n            results.append( data[h_offset: hrg+h_offset ,w_offset: wrg+w_offset])\n        return np.asarray(results)\n    else:\n        # central crop\n        h_offset = (h - hrg)/2\n        w_offset = (w - wrg)/2\n        results = []\n        for data in x:\n            results.append( data[h_offset: h-h_offset ,w_offset: w-w_offset] )\n        return np.asarray(results)\n\n# flip\ndef flip_axis(x, axis, is_random=False):\n    """"""Flip the axis of an image, such as flip left and right, up and down, randomly or non-randomly,\n\n    Parameters\n    ----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    axis : int\n        - 0, flip up and down\n        - 1, flip left and right\n        - 2, flip channel\n    is_random : boolean, default False\n        If True, randomly flip.\n    """"""\n    if is_random:\n        factor = np.random.uniform(-1, 1)\n        if factor > 0:\n            x = np.asarray(x).swapaxes(axis, 0)\n            x = x[::-1, ...]\n            x = x.swapaxes(0, axis)\n            return x\n        else:\n            return x\n    else:\n        x = np.asarray(x).swapaxes(axis, 0)\n        x = x[::-1, ...]\n        x = x.swapaxes(0, axis)\n        return x\n\ndef flip_axis_multi(x, axis, is_random=False):\n    """"""Flip the axises of multiple images together, such as flip left and right, up and down, randomly or non-randomly,\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``flip_axis``.\n    """"""\n    if is_random:\n        factor = np.random.uniform(-1, 1)\n        if factor > 0:\n            # x = np.asarray(x).swapaxes(axis, 0)\n            # x = x[::-1, ...]\n            # x = x.swapaxes(0, axis)\n            # return x\n            results = []\n            for data in x:\n                data = np.asarray(data).swapaxes(axis, 0)\n                data = data[::-1, ...]\n                data = data.swapaxes(0, axis)\n                results.append( data )\n            return np.asarray(results)\n        else:\n            return np.asarray(x)\n    else:\n        # x = np.asarray(x).swapaxes(axis, 0)\n        # x = x[::-1, ...]\n        # x = x.swapaxes(0, axis)\n        # return x\n        results = []\n        for data in x:\n            data = np.asarray(data).swapaxes(axis, 0)\n            data = data[::-1, ...]\n            data = data.swapaxes(0, axis)\n            results.append( data )\n        return np.asarray(results)\n\n# shift\ndef shift(x, wrg=0.1, hrg=0.1, is_random=False, row_index=0, col_index=1, channel_index=2,\n                 fill_mode=\'nearest\', cval=0.):\n    """"""Shift an image randomly or non-randomly.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    wrg : float\n        Percentage of shift in axis x, usually -0.25 ~ 0.25.\n    hrg : float\n        Percentage of shift in axis y, usually -0.25 ~ 0.25.\n    is_random : boolean, default False\n        If True, randomly shift.\n    row_index, col_index, channel_index : int\n        Index of row, col and channel, default (0, 1, 2), for theano (1, 2, 0).\n    fill_mode : string\n        Method to fill missing pixel, default \xe2\x80\x98nearest\xe2\x80\x99, more options \xe2\x80\x98constant\xe2\x80\x99, \xe2\x80\x98reflect\xe2\x80\x99 or \xe2\x80\x98wrap\xe2\x80\x99.\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    cval : scalar, optional\n        Value used for points outside the boundaries of the input if mode=\'constant\'. Default is 0.0.\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    """"""\n    h, w = x.shape[row_index], x.shape[col_index]\n    if is_random:\n        tx = np.random.uniform(-hrg, hrg) * h\n        ty = np.random.uniform(-wrg, wrg) * w\n    else:\n        tx, ty = hrg * h, wrg * w\n    translation_matrix = np.array([[1, 0, tx],\n                                   [0, 1, ty],\n                                   [0, 0, 1]])\n\n    transform_matrix = translation_matrix  # no need to do offset\n    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n    return x\n\ndef shift_multi(x, wrg=0.1, hrg=0.1, is_random=False, row_index=0, col_index=1, channel_index=2,\n                 fill_mode=\'nearest\', cval=0.):\n    """"""Shift images with the same arguments, randomly or non-randomly.\n    Usually be used for image segmentation which x=[X, Y], X and Y should be matched.\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``shift``.\n    """"""\n    h, w = x[0].shape[row_index], x[0].shape[col_index]\n    if is_random:\n        tx = np.random.uniform(-hrg, hrg) * h\n        ty = np.random.uniform(-wrg, wrg) * w\n    else:\n        tx, ty = hrg * h, wrg * w\n    translation_matrix = np.array([[1, 0, tx],\n                                   [0, 1, ty],\n                                   [0, 0, 1]])\n\n    transform_matrix = translation_matrix  # no need to do offset\n    results = []\n    for data in x:\n        results.append( apply_transform(data, transform_matrix, channel_index, fill_mode, cval))\n    return np.asarray(results)\n\n# shear\ndef shear(x, intensity=0.1, is_random=False, row_index=0, col_index=1, channel_index=2,\n                 fill_mode=\'nearest\', cval=0.):\n    """"""Shear an image randomly or non-randomly.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    intensity : float\n        Percentage of shear, usually -0.5 ~ 0.5 (is_random==True), 0 ~ 0.5 (is_random==False),\n        you can have a quick try by shear(X, 1).\n    is_random : boolean, default False\n        If True, randomly shear.\n    row_index, col_index, channel_index : int\n        Index of row, col and channel, default (0, 1, 2), for theano (1, 2, 0).\n    fill_mode : string\n        Method to fill missing pixel, default \xe2\x80\x98nearest\xe2\x80\x99, more options \xe2\x80\x98constant\xe2\x80\x99, \xe2\x80\x98reflect\xe2\x80\x99 or \xe2\x80\x98wrap\xe2\x80\x99.\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    cval : scalar, optional\n        Value used for points outside the boundaries of the input if mode=\'constant\'. Default is 0.0.\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    """"""\n    if is_random:\n        shear = np.random.uniform(-intensity, intensity)\n    else:\n        shear = intensity\n    shear_matrix = np.array([[1, -np.sin(shear), 0],\n                             [0, np.cos(shear), 0],\n                             [0, 0, 1]])\n\n    h, w = x.shape[row_index], x.shape[col_index]\n    transform_matrix = transform_matrix_offset_center(shear_matrix, h, w)\n    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n    return x\n\ndef shear_multi(x, intensity=0.1, is_random=False, row_index=0, col_index=1, channel_index=2,\n                 fill_mode=\'nearest\', cval=0.):\n    """"""Shear images with the same arguments, randomly or non-randomly.\n    Usually be used for image segmentation which x=[X, Y], X and Y should be matched.\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``shear``.\n    """"""\n    if is_random:\n        shear = np.random.uniform(-intensity, intensity)\n    else:\n        shear = intensity\n    shear_matrix = np.array([[1, -np.sin(shear), 0],\n                             [0, np.cos(shear), 0],\n                             [0, 0, 1]])\n\n    h, w = x[0].shape[row_index], x[0].shape[col_index]\n    transform_matrix = transform_matrix_offset_center(shear_matrix, h, w)\n    results = []\n    for data in x:\n        results.append( apply_transform(data, transform_matrix, channel_index, fill_mode, cval))\n    return np.asarray(results)\n\n# swirl\ndef swirl(x, center=None, strength=1, radius=100, rotation=0, output_shape=None, order=1, mode=\'constant\', cval=0, clip=True, preserve_range=False, is_random=False):\n    """"""Swirl an image randomly or non-randomly, see `scikit-image swirl API <http://scikit-image.org/docs/dev/api/skimage.transform.html#skimage.transform.swirl>`_\n    and `example <http://scikit-image.org/docs/dev/auto_examples/plot_swirl.html>`_.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    center : (row, column) tuple or (2,) ndarray, optional\n        Center coordinate of transformation.\n    strength : float, optional\n        The amount of swirling applied.\n    radius : float, optional\n        The extent of the swirl in pixels. The effect dies out rapidly beyond radius.\n    rotation : float, (degree) optional\n        Additional rotation applied to the image, usually [0, 360], relates to center.\n    output_shape : tuple (rows, cols), optional\n        Shape of the output image generated. By default the shape of the input image is preserved.\n    order : int, optional\n        The order of the spline interpolation, default is 1. The order has to be in the range 0-5. See skimage.transform.warp for detail.\n    mode : {\xe2\x80\x98constant\xe2\x80\x99, \xe2\x80\x98edge\xe2\x80\x99, \xe2\x80\x98symmetric\xe2\x80\x99, \xe2\x80\x98reflect\xe2\x80\x99, \xe2\x80\x98wrap\xe2\x80\x99}, optional\n        Points outside the boundaries of the input are filled according to the given mode, with \xe2\x80\x98constant\xe2\x80\x99 used as the default. Modes match the behaviour of numpy.pad.\n    cval : float, optional\n        Used in conjunction with mode \xe2\x80\x98constant\xe2\x80\x99, the value outside the image boundaries.\n    clip : bool, optional\n        Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.\n    preserve_range : bool, optional\n        Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of img_as_float.\n    is_random : boolean, default False\n        If True, random swirl.\n            - random center = [(0 ~ x.shape[0]), (0 ~ x.shape[1])]\n            - random strength = [0, strength]\n            - random radius = [1e-10, radius]\n            - random rotation = [-rotation, rotation]\n\n    Examples\n    ---------\n    >>> x --> [row, col, 1] greyscale\n    >>> x = swirl(x, strength=4, radius=100)\n    """"""\n    assert radius != 0, Exception(""Invalid radius value"")\n    rotation = np.pi / 180 * rotation\n    if is_random:\n        center_h = int(np.random.uniform(0, x.shape[0]))\n        center_w = int(np.random.uniform(0, x.shape[1]))\n        center = (center_h, center_w)\n        strength = np.random.uniform(0, strength)\n        radius = np.random.uniform(1e-10, radius)\n        rotation = np.random.uniform(-rotation, rotation)\n\n    max_v = np.max(x)\n    if max_v > 1:   # Note: the input of this fn should be [-1, 1], rescale is required.\n        x = x / max_v\n    swirled = skimage.transform.swirl(x, center=center, strength=strength, radius=radius, rotation=rotation,\n        output_shape=output_shape, order=order, mode=mode, cval=cval, clip=clip, preserve_range=preserve_range)\n    if max_v > 1:\n        swirled = swirled * max_v\n    return swirled\n\ndef swirl_multi(x, center=None, strength=1, radius=100, rotation=0, output_shape=None, order=1, mode=\'constant\', cval=0, clip=True, preserve_range=False, is_random=False):\n    """"""Swirl multiple images with the same arguments, randomly or non-randomly.\n    Usually be used for image segmentation which x=[X, Y], X and Y should be matched.\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``swirl``.\n    """"""\n    assert radius != 0, Exception(""Invalid radius value"")\n    rotation = np.pi / 180 * rotation\n    if is_random:\n        center_h = int(np.random.uniform(0, x[0].shape[0]))\n        center_w = int(np.random.uniform(0, x[0].shape[1]))\n        center = (center_h, center_w)\n        strength = np.random.uniform(0, strength)\n        radius = np.random.uniform(1e-10, radius)\n        rotation = np.random.uniform(-rotation, rotation)\n\n    results = []\n    for data in x:\n        max_v = np.max(data)\n        if max_v > 1:   # Note: the input of this fn should be [-1, 1], rescale is required.\n            data = data / max_v\n        swirled = skimage.transform.swirl(data, center=center, strength=strength, radius=radius, rotation=rotation,\n            output_shape=output_shape, order=order, mode=mode, cval=cval, clip=clip, preserve_range=preserve_range)\n        if max_v > 1:\n            swirled = swirled * max_v\n        results.append( swirled )\n    return np.asarray(results)\n\n# elastic_transform\n\nfrom scipy.ndimage.interpolation import map_coordinates\nfrom scipy.ndimage.filters import gaussian_filter\ndef elastic_transform(x, alpha, sigma, mode=""constant"", cval=0, is_random=False):\n    """"""Elastic deformation of images as described in `[Simard2003] <http://deeplearning.cs.cmu.edu/pdfs/Simard.pdf>`_ .\n\n    Parameters\n    -----------\n    x : numpy array, a greyscale image.\n    alpha : scalar factor.\n    sigma : scalar or sequence of scalars, the smaller the sigma, the more transformation.\n        Standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes.\n    mode : default constant, see `scipy.ndimage.filters.gaussian_filter <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.filters.gaussian_filter.html>`_.\n    cval : float, optional. Used in conjunction with mode \xe2\x80\x98constant\xe2\x80\x99, the value outside the image boundaries.\n    is_random : boolean, default False\n\n    Examples\n    ---------\n    >>> x = elastic_transform(x, alpha = x.shape[1] * 3, sigma = x.shape[1] * 0.07)\n\n    References\n    ------------\n    - `Github <https://gist.github.com/chsasank/4d8f68caf01f041a6453e67fb30f8f5a>`_.\n    - `Kaggle <https://www.kaggle.com/pscion/ultrasound-nerve-segmentation/elastic-transform-for-data-augmentation-0878921a>`_\n    """"""\n    if is_random is False:\n        random_state = np.random.RandomState(None)\n    else:\n        random_state = np.random.RandomState(int(time.time()))\n    #\n    is_3d = False\n    if len(x.shape) == 3 and x.shape[-1] == 1:\n        x = x[:,:,0]\n        is_3d = True\n    elif len(x.shape) == 3 and x.shape[-1] != 1:\n        raise Exception(""Only support greyscale image"")\n    assert len(x.shape)==2\n\n    shape = x.shape\n\n    dx = gaussian_filter((random_state.rand(*shape) * 2 - 1), sigma, mode=mode, cval=cval) * alpha\n    dy = gaussian_filter((random_state.rand(*shape) * 2 - 1), sigma, mode=mode, cval=cval) * alpha\n\n    x_, y_ = np.meshgrid(np.arange(shape[0]), np.arange(shape[1]), indexing=\'ij\')\n    indices = np.reshape(x_ + dx, (-1, 1)), np.reshape(y_ + dy, (-1, 1))\n    if is_3d:\n        return map_coordinates(x, indices, order=1).reshape((shape[0], shape[1], 1))\n    else:\n        return map_coordinates(x, indices, order=1).reshape(shape)\n\ndef elastic_transform_multi(x, alpha, sigma, mode=""constant"", cval=0, is_random=False):\n    """"""Elastic deformation of images as described in `[Simard2003] <http://deeplearning.cs.cmu.edu/pdfs/Simard.pdf>`_.\n\n    Parameters\n    -----------\n    x : list of numpy array\n    others : see ``elastic_transform``.\n    """"""\n    if is_random is False:\n        random_state = np.random.RandomState(None)\n    else:\n        random_state = np.random.RandomState(int(time.time()))\n\n    shape = x[0].shape\n    if len(shape) == 3:\n        shape = (shape[0], shape[1])\n    new_shape = random_state.rand(*shape)\n\n    results = []\n    for data in x:\n        is_3d = False\n        if len(data.shape) == 3 and data.shape[-1] == 1:\n            data = data[:,:,0]\n            is_3d = True\n        elif len(data.shape) == 3 and data.shape[-1] != 1:\n            raise Exception(""Only support greyscale image"")\n        assert len(data.shape)==2\n\n        dx = gaussian_filter((new_shape * 2 - 1), sigma, mode=mode, cval=cval) * alpha\n        dy = gaussian_filter((new_shape * 2 - 1), sigma, mode=mode, cval=cval) * alpha\n\n        x_, y_ = np.meshgrid(np.arange(shape[0]), np.arange(shape[1]), indexing=\'ij\')\n        indices = np.reshape(x_ + dx, (-1, 1)), np.reshape(y_ + dy, (-1, 1))\n        # print(data.shape)\n        if is_3d:\n            results.append( map_coordinates(data, indices, order=1).reshape((shape[0], shape[1], 1)))\n        else:\n            results.append( map_coordinates(data, indices, order=1).reshape(shape) )\n    return np.asarray(results)\n\n# zoom\ndef zoom(x, zoom_range=(0.9, 1.1), is_random=False, row_index=0, col_index=1, channel_index=2,\n                fill_mode=\'nearest\', cval=0.):\n    """"""Zoom in and out of a single image, randomly or non-randomly.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    zoom_range : list or tuple\n        - If is_random=False, (h, w) are the fixed zoom factor for row and column axies, factor small than one is zoom in.\n        - If is_random=True, (min zoom out, max zoom out) for x and y with different random zoom in/out factor.\n        e.g (0.5, 1) zoom in 1~2 times.\n    is_random : boolean, default False\n        If True, randomly zoom.\n    row_index, col_index, channel_index : int\n        Index of row, col and channel, default (0, 1, 2), for theano (1, 2, 0).\n    fill_mode : string\n        Method to fill missing pixel, default \xe2\x80\x98nearest\xe2\x80\x99, more options \xe2\x80\x98constant\xe2\x80\x99, \xe2\x80\x98reflect\xe2\x80\x99 or \xe2\x80\x98wrap\xe2\x80\x99.\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    cval : scalar, optional\n        Value used for points outside the boundaries of the input if mode=\'constant\'. Default is 0.0.\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    """"""\n    if len(zoom_range) != 2:\n        raise Exception(\'zoom_range should be a tuple or list of two floats. \'\n                        \'Received arg: \', zoom_range)\n    if is_random:\n        if zoom_range[0] == 1 and zoom_range[1] == 1:\n            zx, zy = 1, 1\n            print("" random_zoom : not zoom in/out"")\n        else:\n            zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n    else:\n        zx, zy = zoom_range\n    # print(zx, zy)\n    zoom_matrix = np.array([[zx, 0, 0],\n                            [0, zy, 0],\n                            [0, 0, 1]])\n\n    h, w = x.shape[row_index], x.shape[col_index]\n    transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n    return x\n\ndef zoom_multi(x, zoom_range=(0.9, 1.1), is_random=False,\n        row_index=0, col_index=1, channel_index=2, fill_mode=\'nearest\', cval=0.):\n    """"""Zoom in and out of images with the same arguments, randomly or non-randomly.\n    Usually be used for image segmentation which x=[X, Y], X and Y should be matched.\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``zoom``.\n    """"""\n    if len(zoom_range) != 2:\n        raise Exception(\'zoom_range should be a tuple or list of two floats. \'\n                        \'Received arg: \', zoom_range)\n\n    if is_random:\n        if zoom_range[0] == 1 and zoom_range[1] == 1:\n            zx, zy = 1, 1\n            print("" random_zoom : not zoom in/out"")\n        else:\n            zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n    else:\n        zx, zy = zoom_range\n\n    zoom_matrix = np.array([[zx, 0, 0],\n                            [0, zy, 0],\n                            [0, 0, 1]])\n\n    h, w = x[0].shape[row_index], x[0].shape[col_index]\n    transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n    # x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n    # return x\n    results = []\n    for data in x:\n        results.append( apply_transform(data, transform_matrix, channel_index, fill_mode, cval))\n    return np.asarray(results)\n\n# image = tf.image.random_brightness(image, max_delta=32. / 255.)\n# image = tf.image.random_saturation(image, lower=0.5, upper=1.5)\n# image = tf.image.random_hue(image, max_delta=0.032)\n# image = tf.image.random_contrast(image, lower=0.5, upper=1.5)\n\n# brightness\ndef brightness(x, gamma=1, gain=1, is_random=False):\n    """"""Change the brightness of a single image, randomly or non-randomly.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    gamma : float, small than 1 means brighter.\n        Non negative real number. Default value is 1.\n\n        - If is_random is True, gamma in a range of (1-gamma, 1+gamma).\n    gain : float\n        The constant multiplier. Default value is 1.\n    is_random : boolean, default False\n        - If True, randomly change brightness.\n\n    References\n    -----------\n    - `skimage.exposure.adjust_gamma <http://scikit-image.org/docs/dev/api/skimage.exposure.html>`_\n    - `chinese blog <http://www.cnblogs.com/denny402/p/5124402.html>`_\n    """"""\n    if is_random:\n        gamma = np.random.uniform(1-gamma, 1+gamma)\n    x = exposure.adjust_gamma(x, gamma, gain)\n    return x\n\ndef brightness_multi(x, gamma=1, gain=1, is_random=False):\n    """"""Change the brightness of multiply images, randomly or non-randomly.\n    Usually be used for image segmentation which x=[X, Y], X and Y should be matched.\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``brightness``.\n    """"""\n    if is_random:\n        gamma = np.random.uniform(1-gamma, 1+gamma)\n\n    results = []\n    for data in x:\n        results.append( exposure.adjust_gamma(data, gamma, gain) )\n    return np.asarray(results)\n\n\n# contrast\ndef constant(x, cutoff=0.5, gain=10, inv=False, is_random=False):\n    # TODO\n    x = exposure.adjust_sigmoid(x, cutoff=cutoff, gain=gain, inv=inv)\n    return x\n\ndef constant_multi():\n    #TODO\n    pass\n\n# resize\ndef imresize(x, size=[100, 100], interp=\'bilinear\', mode=None):\n    """"""Resize an image by given output size and method. Warning, this function\n    will rescale the value to [0, 255].\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    size : int, float or tuple (h, w)\n        - int, Percentage of current size.\n        - float, Fraction of current size.\n        - tuple, Size of the output image.\n    interp : str, optional\n        Interpolation to use for re-sizing (\xe2\x80\x98nearest\xe2\x80\x99, \xe2\x80\x98lanczos\xe2\x80\x99, \xe2\x80\x98bilinear\xe2\x80\x99, \xe2\x80\x98bicubic\xe2\x80\x99 or \xe2\x80\x98cubic\xe2\x80\x99).\n    mode : str, optional\n        The PIL image mode (\xe2\x80\x98P\xe2\x80\x99, \xe2\x80\x98L\xe2\x80\x99, etc.) to convert arr before resizing.\n\n    Returns\n    --------\n    imresize : ndarray\n    The resized array of image.\n\n    References\n    ------------\n    - `scipy.misc.imresize <https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.imresize.html>`_\n    """"""\n    if x.shape[-1] == 1:\n        # greyscale\n        x = scipy.misc.imresize(x[:,:,0], size, interp=interp, mode=mode)\n        return x[:, :, np.newaxis]\n    elif x.shape[-1] == 3:\n        # rgb, bgr ..\n        return scipy.misc.imresize(x, size, interp=interp, mode=mode)\n    else:\n        raise Exception(""Unsupported channel %d"" % x.shape[-1])\n\n# normailization\ndef samplewise_norm(x, rescale=None, samplewise_center=False, samplewise_std_normalization=False,\n            channel_index=2, epsilon=1e-7):\n    """"""Normalize an image by rescale, samplewise centering and samplewise centering in order.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    rescale : rescaling factor.\n            If None or 0, no rescaling is applied, otherwise we multiply the data by the value provided (before applying any other transformation)\n    samplewise_center : set each sample mean to 0.\n    samplewise_std_normalization : divide each input by its std.\n    epsilon : small position value for dividing standard deviation.\n\n    Examples\n    --------\n    >>> x = samplewise_norm(x, samplewise_center=True, samplewise_std_normalization=True)\n    >>> print(x.shape, np.mean(x), np.std(x))\n    ... (160, 176, 1), 0.0, 1.0\n\n    Notes\n    ------\n    When samplewise_center and samplewise_std_normalization are True.\n\n    - For greyscale image, every pixels are subtracted and divided by the mean and std of whole image.\n    - For RGB image, every pixels are subtracted and divided by the mean and std of this pixel i.e. the mean and std of a pixel is 0 and 1.\n    """"""\n    if rescale:\n        x *= rescale\n\n    if x.shape[channel_index] == 1:\n        # greyscale\n        if samplewise_center:\n            x = x - np.mean(x)\n        if samplewise_std_normalization:\n            x = x / np.std(x)\n        return x\n    elif x.shape[channel_index] == 3:\n        # rgb\n        if samplewise_center:\n            x = x - np.mean(x, axis=channel_index, keepdims=True)\n        if samplewise_std_normalization:\n            x = x / (np.std(x, axis=channel_index, keepdims=True) + epsilon)\n        return x\n    else:\n        raise Exception(""Unsupported channels %d"" % x.shape[channel_index])\n\ndef featurewise_norm(x, mean=None, std=None, epsilon=1e-7):\n    """"""Normalize every pixels by the same given mean and std, which are usually\n    compute from all examples.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    mean : value for subtraction.\n    std : value for division.\n    epsilon : small position value for dividing standard deviation.\n    """"""\n    if mean:\n        x = x - mean\n    if std:\n        x = x / (std + epsilon)\n    return x\n\n# whitening\ndef get_zca_whitening_principal_components_img(X):\n    """"""Return the ZCA whitening principal components matrix.\n\n    Parameters\n    -----------\n    x : numpy array\n        Batch of image with dimension of [n_example, row, col, channel] (default).\n    """"""\n    flatX = np.reshape(X, (X.shape[0], X.shape[1] * X.shape[2] * X.shape[3]))\n    print(""zca : computing sigma .."")\n    sigma = np.dot(flatX.T, flatX) / flatX.shape[0]\n    print(""zca : computing U, S and V .."")\n    U, S, V = linalg.svd(sigma)\n    print(""zca : computing principal components .."")\n    principal_components = np.dot(np.dot(U, np.diag(1. / np.sqrt(S + 10e-7))), U.T)\n    return principal_components\n\ndef zca_whitening(x, principal_components):\n    """"""Apply ZCA whitening on an image by given principal components matrix.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    principal_components : matrix from ``get_zca_whitening_principal_components_img``.\n    """"""\n    # flatx = np.reshape(x, (x.size))\n    print(principal_components.shape, x.shape)  # ((28160, 28160), (160, 176, 1))\n    # flatx = np.reshape(x, (x.shape))\n    # flatx = np.reshape(x, (x.shape[0], ))\n    print(flatx.shape)  # (160, 176, 1)\n    whitex = np.dot(flatx, principal_components)\n    x = np.reshape(whitex, (x.shape[0], x.shape[1], x.shape[2]))\n    return x\n\n# developing\n# def barrel_transform(x, intensity):\n#     # https://github.com/fchollet/keras/blob/master/keras/preprocessing/image.py\n#     # TODO\n#     pass\n#\n# def barrel_transform_multi(x, intensity):\n#     # https://github.com/fchollet/keras/blob/master/keras/preprocessing/image.py\n#     # TODO\n#     pass\n\n# channel shift\ndef channel_shift(x, intensity, is_random=False, channel_index=2):\n    """"""Shift the channels of an image, randomly or non-randomly, see `numpy.rollaxis <https://docs.scipy.org/doc/numpy/reference/generated/numpy.rollaxis.html>`_.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    intensity : float\n        Intensity of shifting.\n    is_random : boolean, default False\n        If True, randomly shift.\n    channel_index : int\n        Index of channel, default 2.\n    """"""\n    if is_random:\n        factor = np.random.uniform(-intensity, intensity)\n    else:\n        factor = intensity\n    x = np.rollaxis(x, channel_index, 0)\n    min_x, max_x = np.min(x), np.max(x)\n    channel_images = [np.clip(x_channel + factor, min_x, max_x)\n                      for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x\n    # x = np.rollaxis(x, channel_index, 0)\n    # min_x, max_x = np.min(x), np.max(x)\n    # channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n    #                   for x_channel in x]\n    # x = np.stack(channel_images, axis=0)\n    # x = np.rollaxis(x, 0, channel_index+1)\n    # return x\n\ndef channel_shift_multi(x, intensity, channel_index=2):\n    """"""Shift the channels of images with the same arguments, randomly or non-randomly, see `numpy.rollaxis <https://docs.scipy.org/doc/numpy/reference/generated/numpy.rollaxis.html>`_ .\n    Usually be used for image segmentation which x=[X, Y], X and Y should be matched.\n\n    Parameters\n    -----------\n    x : list of numpy array\n        List of images with dimension of [n_images, row, col, channel] (default).\n    others : see ``channel_shift``.\n    """"""\n    if is_random:\n        factor = np.random.uniform(-intensity, intensity)\n    else:\n        factor = intensity\n\n    results = []\n    for data in x:\n        data = np.rollaxis(data, channel_index, 0)\n        min_x, max_x = np.min(data), np.max(data)\n        channel_images = [np.clip(x_channel + factor, min_x, max_x)\n                          for x_channel in x]\n        data = np.stack(channel_images, axis=0)\n        data = np.rollaxis(x, 0, channel_index+1)\n        results.append( data )\n    return np.asarray(results)\n\n# noise\ndef drop(x, keep=0.5):\n    """"""Randomly set some pixels to zero by a given keeping probability.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] or [row, col].\n    keep : float (0, 1)\n        The keeping probability, the lower more values will be set to zero.\n    """"""\n    if len(x.shape) == 3:\n        if x.shape[-1]==3: # color\n            img_size = x.shape\n            mask = np.random.binomial(n=1, p=keep, size=x.shape[:-1])\n            for i in range(3):\n                x[:,:,i] = np.multiply(x[:,:,i] , mask)\n        elif x.shape[-1]==1: # greyscale image\n            img_size = x.shape\n            x = np.multiply(x , np.random.binomial(n=1, p=keep, size=img_size))\n        else:\n            raise Exception(""Unsupported shape {}"".format(x.shape))\n    elif len(x.shape) == 2 or 1: # greyscale matrix (image) or vector\n        img_size = x.shape\n        x = np.multiply(x , np.random.binomial(n=1, p=keep, size=img_size))\n    else:\n        raise Exception(""Unsupported shape {}"".format(x.shape))\n    return x\n\n# x = np.asarray([[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]])\n# x = np.asarray([x,x,x,x,x,x])\n# x.shape = 10, 4, 3\n# # print(x)\n# # exit()\n# print(x.shape)\n# # exit()\n# print(drop(x, keep=1.))\n# exit()\n\n# manual transform\ndef transform_matrix_offset_center(matrix, x, y):\n    """"""Return transform matrix offset center.\n\n    Parameters\n    ----------\n    matrix : numpy array\n        Transform matrix\n    x, y : int\n        Size of image.\n\n    Examples\n    --------\n    - See ``rotation``, ``shear``, ``zoom``.\n    """"""\n    o_x = float(x) / 2 + 0.5\n    o_y = float(y) / 2 + 0.5\n    offset_matrix = np.array([[1, 0, o_x], [0, 1, o_y], [0, 0, 1]])\n    reset_matrix = np.array([[1, 0, -o_x], [0, 1, -o_y], [0, 0, 1]])\n    transform_matrix = np.dot(np.dot(offset_matrix, matrix), reset_matrix)\n    return transform_matrix\n\n\ndef apply_transform(x, transform_matrix, channel_index=2, fill_mode=\'nearest\', cval=0.):\n    """"""Return transformed images by given transform_matrix from ``transform_matrix_offset_center``.\n\n    Parameters\n    ----------\n    x : numpy array\n        Batch of images with dimension of 3, [batch_size, row, col, channel].\n    transform_matrix : numpy array\n        Transform matrix (offset center), can be generated by ``transform_matrix_offset_center``\n    channel_index : int\n        Index of channel, default 2.\n    fill_mode : string\n        Method to fill missing pixel, default \xe2\x80\x98nearest\xe2\x80\x99, more options \xe2\x80\x98constant\xe2\x80\x99, \xe2\x80\x98reflect\xe2\x80\x99 or \xe2\x80\x98wrap\xe2\x80\x99\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n    cval : scalar, optional\n        Value used for points outside the boundaries of the input if mode=\'constant\'. Default is 0.0\n\n        - `scipy ndimage affine_transform <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.interpolation.affine_transform.html>`_\n\n    Examples\n    --------\n    - See ``rotation``, ``shift``, ``shear``, ``zoom``.\n    """"""\n    x = np.rollaxis(x, channel_index, 0)\n    final_affine_matrix = transform_matrix[:2, :2]\n    final_offset = transform_matrix[:2, 2]\n    channel_images = [ndi.interpolation.affine_transform(x_channel, final_affine_matrix,\n                      final_offset, order=0, mode=fill_mode, cval=cval) for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x\n\n\ndef projective_transform_by_points(x, src, dst, map_args={}, output_shape=None, order=1, mode=\'constant\', cval=0.0, clip=True, preserve_range=False):\n    """"""Projective transform by given coordinates, usually 4 coordinates. see `scikit-image <http://scikit-image.org/docs/dev/auto_examples/applications/plot_geometric.html>`_.\n\n    Parameters\n    -----------\n    x : numpy array\n        An image with dimension of [row, col, channel] (default).\n    src : list or numpy\n        The original coordinates, usually 4 coordinates of (x, y).\n    dst : list or numpy\n        The coordinates after transformation, the number of coordinates is the same with src.\n    map_args : dict, optional\n        Keyword arguments passed to inverse_map.\n    output_shape : tuple (rows, cols), optional\n        Shape of the output image generated. By default the shape of the input image is preserved. Note that, even for multi-band images, only rows and columns need to be specified.\n    order : int, optional\n        The order of interpolation. The order has to be in the range 0-5:\n\n        - 0 Nearest-neighbor\n        - 1 Bi-linear (default)\n        - 2 Bi-quadratic\n        - 3 Bi-cubic\n        - 4 Bi-quartic\n        - 5 Bi-quintic\n    mode : {\xe2\x80\x98constant\xe2\x80\x99, \xe2\x80\x98edge\xe2\x80\x99, \xe2\x80\x98symmetric\xe2\x80\x99, \xe2\x80\x98reflect\xe2\x80\x99, \xe2\x80\x98wrap\xe2\x80\x99}, optional\n        Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of numpy.pad.\n    cval : float, optional\n        Used in conjunction with mode \xe2\x80\x98constant\xe2\x80\x99, the value outside the image boundaries.\n    clip : bool, optional\n        Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.\n    preserve_range : bool, optional\n        Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of img_as_float.\n\n    Examples\n    --------\n    >>> Assume X is an image from CIFAR 10, i.e. shape == (32, 32, 3)\n    >>> src = [[0,0],[0,32],[32,0],[32,32]]\n    >>> dst = [[10,10],[0,32],[32,0],[32,32]]\n    >>> x = projective_transform_by_points(X, src, dst)\n\n    References\n    -----------\n    - `scikit-image : geometric transformations <http://scikit-image.org/docs/dev/auto_examples/applications/plot_geometric.html>`_\n    - `scikit-image : examples <http://scikit-image.org/docs/dev/auto_examples/index.html>`_\n    """"""\n    if type(src) is list:   # convert to numpy\n        src = np.array(src)\n    if type(dst) is list:\n        dst = np.array(dst)\n    if np.max(x)>1:         # convert to [0, 1]\n        x = x/255\n\n    m = transform.ProjectiveTransform()\n    m.estimate(dst, src)\n    warped = transform.warp(x, m,  map_args=map_args, output_shape=output_shape, order=order, mode=mode, cval=cval, clip=clip, preserve_range=preserve_range)\n    return warped\n\n# Numpy and PIL\ndef array_to_img(x, dim_ordering=(0,1,2), scale=True):\n    """"""Converts a numpy array to PIL image object (uint8 format).\n\n    Parameters\n    ----------\n    x : numpy array\n        A image with dimension of 3 and channels of 1 or 3.\n    dim_ordering : list or tuple of 3 int\n        Index of row, col and channel, default (0, 1, 2), for theano (1, 2, 0).\n    scale : boolean, default is True\n        If True, converts image to [0, 255] from any range of value like [-1, 2].\n\n    References\n    -----------\n    - `PIL Image.fromarray <http://pillow.readthedocs.io/en/3.1.x/reference/Image.html?highlight=fromarray>`_\n    """"""\n    from PIL import Image\n    # if dim_ordering == \'default\':\n    #     dim_ordering = K.image_dim_ordering()\n    # if dim_ordering == \'th\':  # theano\n    #     x = x.transpose(1, 2, 0)\n    x = x.transpose(dim_ordering)\n    if scale:\n        x += max(-np.min(x), 0)\n        x_max = np.max(x)\n        if x_max != 0:\n            # print(x_max)\n            # x /= x_max\n            x = x / x_max\n        x *= 255\n    if x.shape[2] == 3:\n        # RGB\n        return Image.fromarray(x.astype(\'uint8\'), \'RGB\')\n    elif x.shape[2] == 1:\n        # grayscale\n        return Image.fromarray(x[:, :, 0].astype(\'uint8\'), \'L\')\n    else:\n        raise Exception(\'Unsupported channel number: \', x.shape[2])\n\n\n## Sequence\ndef pad_sequences(sequences, maxlen=None, dtype=\'int32\', padding=\'post\', truncating=\'pre\', value=0.):\n    """"""Pads each sequence to the same length:\n    the length of the longest sequence.\n    If maxlen is provided, any sequence longer\n    than maxlen is truncated to maxlen.\n    Truncation happens off either the beginning (default) or\n    the end of the sequence.\n    Supports post-padding and pre-padding (default).\n\n    Parameters\n    ----------\n    sequences : list of lists where each element is a sequence\n    maxlen : int, maximum length\n    dtype : type to cast the resulting sequence.\n    padding : \'pre\' or \'post\', pad either before or after each sequence.\n    truncating : \'pre\' or \'post\', remove values from sequences larger than\n        maxlen either in the beginning or in the end of the sequence\n    value : float, value to pad the sequences to the desired value.\n\n    Returns\n    ----------\n    x : numpy array with dimensions (number_of_sequences, maxlen)\n\n    Examples\n    ----------\n    >>> sequences = [[1,1,1,1,1],[2,2,2],[3,3]]\n    >>> sequences = pad_sequences(sequences, maxlen=None, dtype=\'int32\',\n    ...                  padding=\'post\', truncating=\'pre\', value=0.)\n    ... [[1 1 1 1 1]\n    ...  [2 2 2 0 0]\n    ...  [3 3 0 0 0]]\n    """"""\n    lengths = [len(s) for s in sequences]\n\n    nb_samples = len(sequences)\n    if maxlen is None:\n        maxlen = np.max(lengths)\n\n    # take the sample shape from the first non empty sequence\n    # checking for consistency in the main loop below.\n    sample_shape = tuple()\n    for s in sequences:\n        if len(s) > 0:\n            sample_shape = np.asarray(s).shape[1:]\n            break\n\n    x = (np.ones((nb_samples, maxlen) + sample_shape) * value).astype(dtype)\n    for idx, s in enumerate(sequences):\n        if len(s) == 0:\n            continue  # empty list was found\n        if truncating == \'pre\':\n            trunc = s[-maxlen:]\n        elif truncating == \'post\':\n            trunc = s[:maxlen]\n        else:\n            raise ValueError(\'Truncating type ""%s"" not understood\' % truncating)\n\n        # check `trunc` has expected shape\n        trunc = np.asarray(trunc, dtype=dtype)\n        if trunc.shape[1:] != sample_shape:\n            raise ValueError(\'Shape of sample %s of sequence at position %s is different from expected shape %s\' %\n                             (trunc.shape[1:], idx, sample_shape))\n\n        if padding == \'post\':\n            x[idx, :len(trunc)] = trunc\n        elif padding == \'pre\':\n            x[idx, -len(trunc):] = trunc\n        else:\n            raise ValueError(\'Padding type ""%s"" not understood\' % padding)\n    return x\n\ndef process_sequences(sequences, end_id=0, pad_val=0, is_shorten=True, remain_end_id=False):\n    """"""Set all tokens(ids) after END token to the padding value, and then shorten (option) it to the maximum sequence length in this batch.\n\n    Parameters\n    -----------\n    sequences : numpy array or list of list with token IDs.\n        e.g. [[4,3,5,3,2,2,2,2], [5,3,9,4,9,2,2,3]]\n    end_id : int, the special token for END.\n    pad_val : int, replace the end_id and the ids after end_id to this value.\n    is_shorten : boolean, default True.\n        Shorten the sequences.\n    remain_end_id : boolean, default False.\n        Keep an end_id in the end.\n\n    Examples\n    ---------\n    >>> sentences_ids = [[4, 3, 5, 3, 2, 2, 2, 2],  <-- end_id is 2\n    ...                  [5, 3, 9, 4, 9, 2, 2, 3]]  <-- end_id is 2\n    >>> sentences_ids = precess_sequences(sentences_ids, end_id=vocab.end_id, pad_val=0, is_shorten=True)\n    ... [[4, 3, 5, 3, 0], [5, 3, 9, 4, 9]]\n    """"""\n    max_length = 0\n    for i_s, seq in enumerate(sequences):\n        is_end = False\n        for i_w, n in enumerate(seq):\n            if n == end_id and is_end == False: # 1st time to see end_id\n                is_end = True\n                if max_length < i_w:\n                    max_length = i_w\n                if remain_end_id is False:\n                    seq[i_w] = pad_val      # set end_id to pad_val\n            elif is_end == True:\n                seq[i_w] = pad_val\n\n    if remain_end_id is True:\n        max_length += 1\n    if is_shorten:\n        for i, seq in enumerate(sequences):\n            sequences[i] = seq[:max_length]\n    return sequences\n\ndef sequences_add_start_id(sequences, start_id=0, remove_last=False):\n    """"""Add special start token(id) in the beginning of each sequence.\n\n    Examples\n    ---------\n    >>> sentences_ids = [[4,3,5,3,2,2,2,2], [5,3,9,4,9,2,2,3]]\n    >>> sentences_ids = sequences_add_start_id(sentences_ids, start_id=2)\n    ... [[2, 4, 3, 5, 3, 2, 2, 2, 2], [2, 5, 3, 9, 4, 9, 2, 2, 3]]\n    >>> sentences_ids = sequences_add_start_id(sentences_ids, start_id=2, remove_last=True)\n    ... [[2, 4, 3, 5, 3, 2, 2, 2], [2, 5, 3, 9, 4, 9, 2, 2]]\n\n    - For Seq2seq\n    >>> input = [a, b, c]\n    >>> target = [x, y, z]\n    >>> decode_seq = [start_id, a, b] <-- sequences_add_start_id(input, start_id, True)\n    """"""\n    sequences_out = [[] for _ in range(len(sequences))]#[[]] * len(sequences)\n    for i in range(len(sequences)):\n        if remove_last:\n            sequences_out[i] = [start_id] + sequences[i][:-1]\n        else:\n            sequences_out[i] = [start_id] + sequences[i]\n    return sequences_out\n\ndef sequences_get_mask(sequences, pad_val=0):\n    """"""Return mask for sequences.\n\n    Examples\n    ---------\n    >>> sentences_ids = [[4, 0, 5, 3, 0, 0],\n    ...                  [5, 3, 9, 4, 9, 0]]\n    >>> mask = sequences_get_mask(sentences_ids, pad_val=0)\n    ... [[1 1 1 1 0 0]\n    ...  [1 1 1 1 1 0]]\n    """"""\n    mask = np.ones_like(sequences)\n    for i, seq in enumerate(sequences):\n        for i_w in reversed(range(len(seq))):\n            if seq[i_w] == pad_val:\n                mask[i, i_w] = 0\n            else:\n                break   # <-- exit the for loop, prepcess next sequence\n    return mask\n\n\n## Text\n# see tensorlayer.nlp\n\n\n## Tensor Opt\ndef distorted_images(images=None, height=24, width=24):\n    """"""Distort images for generating more training data.\n\n    Features\n    ---------\n    They are cropped to height * width pixels randomly.\n\n    They are approximately whitened to make the model insensitive to dynamic range.\n\n    Randomly flip the image from left to right.\n\n    Randomly distort the image brightness.\n\n    Randomly distort the image contrast.\n\n    Whiten (Normalize) the images.\n\n    Parameters\n    ----------\n    images : 4D Tensor\n        The tensor or placeholder of images\n    height : int\n        The height for random crop.\n    width : int\n        The width for random crop.\n\n    Returns\n    -------\n    result : tuple of Tensor\n        (Tensor for distorted images, Tensor for while loop index)\n\n    Examples\n    --------\n    >>> X_train, y_train, X_test, y_test = tl.files.load_cifar10_dataset(shape=(-1, 32, 32, 3), plotable=False)\n    >>> sess = tf.InteractiveSession()\n    >>> batch_size = 128\n    >>> x = tf.placeholder(tf.float32, shape=[batch_size, 32, 32, 3])\n    >>> distorted_images_op = tl.preprocess.distorted_images(images=x, height=24, width=24)\n    >>> sess.run(tf.initialize_all_variables())\n    >>> feed_dict={x: X_train[0:batch_size,:,:,:]}\n    >>> distorted_images, idx = sess.run(distorted_images_op, feed_dict=feed_dict)\n    >>> tl.visualize.images2d(X_train[0:9,:,:,:], second=2, saveable=False, name=\'cifar10\', dtype=np.uint8, fig_idx=20212)\n    >>> tl.visualize.images2d(distorted_images[1:10,:,:,:], second=10, saveable=False, name=\'distorted_images\', dtype=None, fig_idx=23012)\n\n    Notes\n    ------\n    - The first image in \'distorted_images\' should be removed.\n\n    References\n    -----------\n    - `tensorflow.models.image.cifar10.cifar10_input <https://github.com/tensorflow/tensorflow/blob/r0.9/tensorflow/models/image/cifar10/cifar10_input.py>`_\n    """"""\n    print(""This function is deprecated, please use tf.map_fn instead, e.g:\\n   \\\n            t_image = tf.map_fn(lambda img: tf.image.random_brightness(img, max_delta=32. / 255.), t_image)\\n \\\n            t_image = tf.map_fn(lambda img: tf.image.random_contrast(img, lower=0.5, upper=1.5), t_image)\\n \\\n            t_image = tf.map_fn(lambda img: tf.image.random_saturation(img, lower=0.5, upper=1.5), t_image)\\n \\\n            t_image = tf.map_fn(lambda img: tf.image.random_hue(img, max_delta=0.032), t_image)"")\n    exit()\n    # print("" [Warning] distorted_images will be deprecated due to speed, see TFRecord tutorial for more info..."")\n    try:\n        batch_size = int(images._shape[0])\n    except:\n        raise Exception(\'unknow batch_size of images\')\n    distorted_x = tf.Variable(tf.constant(0.1, shape=[1, height, width, 3]))\n    i = tf.Variable(tf.constant(0))\n\n    c = lambda distorted_x, i: tf.less(i, batch_size)\n\n    def body(distorted_x, i):\n        # 1. Randomly crop a [height, width] section of the image.\n        image = tf.random_crop(tf.gather(images, i), [height, width, 3])\n        # 2. Randomly flip the image horizontally.\n        image = tf.image.random_flip_left_right(image)\n        # 3. Randomly change brightness.\n        image = tf.image.random_brightness(image, max_delta=63)\n        # 4. Randomly change contrast.\n        image = tf.image.random_contrast(image, lower=0.2, upper=1.8)\n        # 5. Subtract off the mean and divide by the variance of the pixels.\n        image = tf.image.per_image_whitening(image)\n        # 6. Append the image to a batch.\n        image = tf.expand_dims(image, 0)\n        return tf.concat(0, [distorted_x, image]), tf.add(i, 1)\n\n    result = tf.while_loop(cond=c, body=body, loop_vars=(distorted_x, i), parallel_iterations=16)\n    return result\n\n\ndef crop_central_whiten_images(images=None, height=24, width=24):\n    """"""Crop the central of image, and normailize it for test data.\n\n    They are cropped to central of height * width pixels.\n\n    Whiten (Normalize) the images.\n\n    Parameters\n    ----------\n    images : 4D Tensor\n        The tensor or placeholder of images\n    height : int\n        The height for central crop.\n    width : int\n        The width for central crop.\n\n    Returns\n    -------\n    result : tuple Tensor\n        (Tensor for distorted images, Tensor for while loop index)\n\n    Examples\n    --------\n    >>> X_train, y_train, X_test, y_test = tl.files.load_cifar10_dataset(shape=(-1, 32, 32, 3), plotable=False)\n    >>> sess = tf.InteractiveSession()\n    >>> batch_size = 128\n    >>> x = tf.placeholder(tf.float32, shape=[batch_size, 32, 32, 3])\n    >>> central_images_op = tl.preprocess.crop_central_whiten_images(images=x, height=24, width=24)\n    >>> sess.run(tf.initialize_all_variables())\n    >>> feed_dict={x: X_train[0:batch_size,:,:,:]}\n    >>> central_images, idx = sess.run(central_images_op, feed_dict=feed_dict)\n    >>> tl.visualize.images2d(X_train[0:9,:,:,:], second=2, saveable=False, name=\'cifar10\', dtype=np.uint8, fig_idx=20212)\n    >>> tl.visualize.images2d(central_images[1:10,:,:,:], second=10, saveable=False, name=\'central_images\', dtype=None, fig_idx=23012)\n\n    Notes\n    ------\n    The first image in \'central_images\' should be removed.\n\n    Code References\n    ----------------\n    - ``tensorflow.models.image.cifar10.cifar10_input``\n    """"""\n    print(""This function is deprecated, please use tf.map_fn instead, e.g:\\n   \\\n            t_image = tf.map_fn(lambda img: tf.image.random_brightness(img, max_delta=32. / 255.), t_image)\\n \\\n            t_image = tf.map_fn(lambda img: tf.image.random_contrast(img, lower=0.5, upper=1.5), t_image)\\n \\\n            t_image = tf.map_fn(lambda img: tf.image.random_saturation(img, lower=0.5, upper=1.5), t_image)\\n \\\n            t_image = tf.map_fn(lambda img: tf.image.random_hue(img, max_delta=0.032), t_image)"")\n    exit()\n    # print("" [Warning] crop_central_whiten_images will be deprecated due to speed, see TFRecord tutorial for more info..."")\n    try:\n        batch_size = int(images._shape[0])\n    except:\n        raise Exception(\'unknow batch_size of images\')\n    central_x = tf.Variable(tf.constant(0.1, shape=[1, height, width, 3]))\n    i = tf.Variable(tf.constant(0))\n\n    c = lambda central_x, i: tf.less(i, batch_size)\n\n    def body(central_x, i):\n        # 1. Crop the central [height, width] of the image.\n        image = tf.image.resize_image_with_crop_or_pad(tf.gather(images, i), height, width)\n        # 2. Subtract off the mean and divide by the variance of the pixels.\n        image = tf.image.per_image_whitening(image)\n        # 5. Append the image to a batch.\n        image = tf.expand_dims(image, 0)\n        return tf.concat(0, [central_x, image]), tf.add(i, 1)\n\n    result = tf.while_loop(cond=c, body=body, loop_vars=(central_x, i), parallel_iterations=16)\n    return result\n\n\n\n\n\n\n\n\n\n\n\n\n#\n'"
tensorlayer/rein.py,11,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\n\nimport tensorflow as tf\nimport numpy as np\nfrom six.moves import xrange\n\ndef discount_episode_rewards(rewards=[], gamma=0.99, mode=0):\n    """""" Take 1D float array of rewards and compute discounted rewards for an\n    episode. When encount a non-zero value, consider as the end a of an episode.\n\n    Parameters\n    ----------\n    rewards : numpy list\n        a list of rewards\n    gamma : float\n        discounted factor\n    mode : int\n        if mode == 0, reset the discount process when encount a non-zero reward (Ping-pong game).\n        if mode == 1, would not reset the discount process.\n\n    Examples\n    ----------\n    >>> rewards = np.asarray([0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1])\n    >>> gamma = 0.9\n    >>> discount_rewards = tl.rein.discount_episode_rewards(rewards, gamma)\n    >>> print(discount_rewards)\n    ... [ 0.72899997  0.81        0.89999998  1.          0.72899997  0.81\n    ... 0.89999998  1.          0.72899997  0.81        0.89999998  1.        ]\n    >>> discount_rewards = tl.rein.discount_episode_rewards(rewards, gamma, mode=1)\n    >>> print(discount_rewards)\n    ... [ 1.52110755  1.69011939  1.87791049  2.08656716  1.20729685  1.34144104\n    ... 1.49048996  1.65610003  0.72899997  0.81        0.89999998  1.        ]\n    """"""\n    discounted_r = np.zeros_like(rewards, dtype=np.float32)\n    running_add = 0\n    for t in reversed(xrange(0, rewards.size)):\n        if mode == 0:\n            if rewards[t] != 0: running_add = 0\n\n        running_add = running_add * gamma + rewards[t]\n        discounted_r[t] = running_add\n    return discounted_r\n\n\ndef cross_entropy_reward_loss(logits, actions, rewards, name=None):\n    """""" Calculate the loss for Policy Gradient Network.\n\n    Parameters\n    ----------\n    logits : tensor\n        The network outputs without softmax. This function implements softmax\n        inside.\n    actions : tensor/ placeholder\n        The agent actions.\n    rewards : tensor/ placeholder\n        The rewards.\n\n    Examples\n    ----------\n    >>> states_batch_pl = tf.placeholder(tf.float32, shape=[None, D])   # observation for training\n    >>> network = tl.layers.InputLayer(states_batch_pl, name=\'input_layer\')\n    >>> network = tl.layers.DenseLayer(network, n_units=H, act = tf.nn.relu, name=\'relu1\')\n    >>> network = tl.layers.DenseLayer(network, n_units=3, act = tl.activation.identity, name=\'output_layer\')\n    >>> probs = network.outputs\n    >>> sampling_prob = tf.nn.softmax(probs)\n    >>> actions_batch_pl = tf.placeholder(tf.int32, shape=[None])\n    >>> discount_rewards_batch_pl = tf.placeholder(tf.float32, shape=[None])\n    >>> loss = cross_entropy_reward_loss(probs, actions_batch_pl, discount_rewards_batch_pl)\n    >>> train_op = tf.train.RMSPropOptimizer(learning_rate, decay_rate).minimize(loss)\n    """"""\n\n    try: # TF 1.0\n        cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=actions, logits=logits, name=name)\n    except:\n        cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, targets=actions)\n        # cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits, actions)\n\n    try: ## TF1.0\n        loss = tf.reduce_sum(tf.multiply(cross_entropy, rewards))\n    except: ## TF0.12\n        loss = tf.reduce_sum(tf.mul(cross_entropy, rewards))   # element-wise mul\n    return loss\n'"
tensorlayer/utils.py,16,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\nimport tensorflow as tf\nimport tensorlayer as tl\nfrom . import iterate\nimport numpy as np\nimport time\nimport math\nimport random\n\n\ndef fit(sess, network, train_op, cost, X_train, y_train, x, y_, acc=None, batch_size=100,\n        n_epoch=100, print_freq=5, X_val=None, y_val=None, eval_train=True,\n        tensorboard=False, tensorboard_epoch_freq=5, tensorboard_weight_histograms=True, tensorboard_graph_vis=True):\n    """"""Traing a given non time-series network by the given cost function, training data, batch_size, n_epoch etc.\n\n    Parameters\n    ----------\n    sess : TensorFlow session\n        sess = tf.InteractiveSession()\n    network : a TensorLayer layer\n        the network will be trained\n    train_op : a TensorFlow optimizer\n        like tf.train.AdamOptimizer\n    X_train : numpy array\n        the input of training data\n    y_train : numpy array\n        the target of training data\n    x : placeholder\n        for inputs\n    y_ : placeholder\n        for targets\n    acc : the TensorFlow expression of accuracy (or other metric) or None\n        if None, would not display the metric\n    batch_size : int\n        batch size for training and evaluating\n    n_epoch : int\n        the number of training epochs\n    print_freq : int\n        display the training information every ``print_freq`` epochs\n    X_val : numpy array or None\n        the input of validation data\n    y_val : numpy array or None\n        the target of validation data\n    eval_train : boolean\n        if X_val and y_val are not None, it refects whether to evaluate the training data\n    tensorboard : boolean\n        if True summary data will be stored to the log/ direcory for visualization with tensorboard.\n        See also detailed tensorboard_X settings for specific configurations of features. (default False)\n        Also runs tl.layers.initialize_global_variables(sess) internally in fit() to setup the summary nodes, see Note:\n    tensorboard_epoch_freq : int\n        how many epochs between storing tensorboard checkpoint for visualization to log/ directory (default 5)\n    tensorboard_weight_histograms : boolean\n        if True updates tensorboard data in the logs/ directory for visulaization\n        of the weight histograms every tensorboard_epoch_freq epoch (default True)\n    tensorboard_graph_vis : boolean\n        if True stores the graph in the tensorboard summaries saved to log/ (default True)\n\n    Examples\n    --------\n    >>> see tutorial_mnist_simple.py\n    >>> tl.utils.fit(sess, network, train_op, cost, X_train, y_train, x, y_,\n    ...            acc=acc, batch_size=500, n_epoch=200, print_freq=5,\n    ...            X_val=X_val, y_val=y_val, eval_train=False)\n    >>> tl.utils.fit(sess, network, train_op, cost, X_train, y_train, x, y_,\n    ...            acc=acc, batch_size=500, n_epoch=200, print_freq=5,\n    ...            X_val=X_val, y_val=y_val, eval_train=False,\n    ...            tensorboard=True, tensorboard_weight_histograms=True, tensorboard_graph_vis=True)\n\n    Note\n    --------\n        If tensorboard=True, the global_variables_initializer will be run inside the fit function\n        in order to initalize the automatically generated summary nodes used for tensorboard visualization,\n        thus tf.global_variables_initializer().run() before the fit() call will be undefined.\n    """"""\n    assert X_train.shape[0] >= batch_size, ""Number of training examples should be bigger than the batch size""\n\n    if(tensorboard):\n        print(""Setting up tensorboard ..."")\n        #Set up tensorboard summaries and saver\n        tl.files.exists_or_mkdir(\'logs/\')\n\n        #Only write summaries for more recent TensorFlow versions\n        if hasattr(tf, \'summary\') and hasattr(tf.summary, \'FileWriter\'):\n            if tensorboard_graph_vis:\n                train_writer = tf.summary.FileWriter(\'logs/train\',sess.graph)\n                val_writer = tf.summary.FileWriter(\'logs/validation\',sess.graph)\n            else:\n                train_writer = tf.summary.FileWriter(\'logs/train\')\n                val_writer = tf.summary.FileWriter(\'logs/validation\')\n\n        #Set up summary nodes\n        if(tensorboard_weight_histograms):\n            for param in network.all_params:\n                if hasattr(tf, \'summary\') and hasattr(tf.summary, \'histogram\'):\n                    print(\'Param name \', param.name)\n                    tf.summary.histogram(param.name, param)\n\n        if hasattr(tf, \'summary\') and hasattr(tf.summary, \'histogram\'):\n            tf.summary.scalar(\'cost\', cost)\n\n        merged = tf.summary.merge_all()\n\n        #Initalize all variables and summaries\n        tl.layers.initialize_global_variables(sess)\n        print(""Finished! use $tensorboard --logdir=logs/ to start server"")\n\n    print(""Start training the network ..."")\n    start_time_begin = time.time()\n    tensorboard_train_index, tensorboard_val_index = 0, 0\n    for epoch in range(n_epoch):\n        start_time = time.time()\n        loss_ep = 0; n_step = 0\n        for X_train_a, y_train_a in iterate.minibatches(X_train, y_train,\n                                                    batch_size, shuffle=True):\n            feed_dict = {x: X_train_a, y_: y_train_a}\n            feed_dict.update( network.all_drop )    # enable noise layers\n            loss, _ = sess.run([cost, train_op], feed_dict=feed_dict)\n            loss_ep += loss\n            n_step += 1\n        loss_ep = loss_ep/ n_step\n\n        if tensorboard and hasattr(tf, \'summary\'):\n            if epoch+1 == 1 or (epoch+1) % tensorboard_epoch_freq == 0:\n                for X_train_a, y_train_a in iterate.minibatches(\n                                        X_train, y_train, batch_size, shuffle=True):\n                    dp_dict = dict_to_one( network.all_drop )    # disable noise layers\n                    feed_dict = {x: X_train_a, y_: y_train_a}\n                    feed_dict.update(dp_dict)\n                    result = sess.run(merged, feed_dict=feed_dict)\n                    train_writer.add_summary(result, tensorboard_train_index)\n                    tensorboard_train_index += 1\n\n                for X_val_a, y_val_a in iterate.minibatches(\n                                        X_val, y_val, batch_size, shuffle=True):\n                    dp_dict = dict_to_one( network.all_drop )    # disable noise layers\n                    feed_dict = {x: X_val_a, y_: y_val_a}\n                    feed_dict.update(dp_dict)\n                    result = sess.run(merged, feed_dict=feed_dict)\n                    val_writer.add_summary(result, tensorboard_val_index)\n                    tensorboard_val_index += 1\n\n        if epoch + 1 == 1 or (epoch + 1) % print_freq == 0:\n            if (X_val is not None) and (y_val is not None):\n                print(""Epoch %d of %d took %fs"" % (epoch + 1, n_epoch, time.time() - start_time))\n                if eval_train is True:\n                    train_loss, train_acc, n_batch = 0, 0, 0\n                    for X_train_a, y_train_a in iterate.minibatches(\n                                            X_train, y_train, batch_size, shuffle=True):\n                        dp_dict = dict_to_one( network.all_drop )    # disable noise layers\n                        feed_dict = {x: X_train_a, y_: y_train_a}\n                        feed_dict.update(dp_dict)\n                        if acc is not None:\n                            err, ac = sess.run([cost, acc], feed_dict=feed_dict)\n                            train_acc += ac\n                        else:\n                            err = sess.run(cost, feed_dict=feed_dict)\n                        train_loss += err;  n_batch += 1\n                    print(""   train loss: %f"" % (train_loss/ n_batch))\n                    if acc is not None:\n                        print(""   train acc: %f"" % (train_acc/ n_batch))\n                val_loss, val_acc, n_batch = 0, 0, 0\n                for X_val_a, y_val_a in iterate.minibatches(\n                                            X_val, y_val, batch_size, shuffle=True):\n                    dp_dict = dict_to_one( network.all_drop )    # disable noise layers\n                    feed_dict = {x: X_val_a, y_: y_val_a}\n                    feed_dict.update(dp_dict)\n                    if acc is not None:\n                        err, ac = sess.run([cost, acc], feed_dict=feed_dict)\n                        val_acc += ac\n                    else:\n                        err = sess.run(cost, feed_dict=feed_dict)\n                    val_loss += err; n_batch += 1\n                print(""   val loss: %f"" % (val_loss/ n_batch))\n                if acc is not None:\n                    print(""   val acc: %f"" % (val_acc/ n_batch))\n            else:\n                print(""Epoch %d of %d took %fs, loss %f"" % (epoch + 1, n_epoch, time.time() - start_time, loss_ep))\n    print(""Total training time: %fs"" % (time.time() - start_time_begin))\n\n\ndef test(sess, network, acc, X_test, y_test, x, y_, batch_size, cost=None):\n    """"""\n    Test a given non time-series network by the given test data and metric.\n\n    Parameters\n    ----------\n    sess : TensorFlow session\n        sess = tf.InteractiveSession()\n    network : a TensorLayer layer\n        the network will be trained\n    acc : the TensorFlow expression of accuracy (or other metric) or None\n        if None, would not display the metric\n    X_test : numpy array\n        the input of test data\n    y_test : numpy array\n        the target of test data\n    x : placeholder\n        for inputs\n    y_ : placeholder\n        for targets\n    batch_size : int or None\n        batch size for testing, when dataset is large, we should use minibatche for testing.\n        when dataset is small, we can set it to None.\n    cost : the TensorFlow expression of cost or None\n        if None, would not display the cost\n\n    Examples\n    --------\n    >>> see tutorial_mnist_simple.py\n    >>> tl.utils.test(sess, network, acc, X_test, y_test, x, y_, batch_size=None, cost=cost)\n    """"""\n    print(\'Start testing the network ...\')\n    if batch_size is None:\n        dp_dict = dict_to_one( network.all_drop )\n        feed_dict = {x: X_test, y_: y_test}\n        feed_dict.update(dp_dict)\n        if cost is not None:\n            print(""   test loss: %f"" % sess.run(cost, feed_dict=feed_dict))\n        print(""   test acc: %f"" % sess.run(acc, feed_dict=feed_dict))\n            # print(""   test acc: %f"" % np.mean(y_test == sess.run(y_op,\n            #                                           feed_dict=feed_dict)))\n    else:\n        test_loss, test_acc, n_batch = 0, 0, 0\n        for X_test_a, y_test_a in iterate.minibatches(\n                                    X_test, y_test, batch_size, shuffle=True):\n            dp_dict = dict_to_one( network.all_drop )    # disable noise layers\n            feed_dict = {x: X_test_a, y_: y_test_a}\n            feed_dict.update(dp_dict)\n            if cost is not None:\n                err, ac = sess.run([cost, acc], feed_dict=feed_dict)\n                test_loss += err\n            else:\n                ac = sess.run(acc, feed_dict=feed_dict)\n            test_acc += ac; n_batch += 1\n        if cost is not None:\n            print(""   test loss: %f"" % (test_loss/ n_batch))\n        print(""   test acc: %f"" % (test_acc/ n_batch))\n\n\ndef predict(sess, network, X, x, y_op):\n    """"""\n    Return the predict results of given non time-series network.\n\n    Parameters\n    ----------\n    sess : TensorFlow session\n        sess = tf.InteractiveSession()\n    network : a TensorLayer layer\n        the network will be trained\n    X : numpy array\n        the input\n    x : placeholder\n        for inputs\n    y_op : placeholder\n        the argmax expression of softmax outputs\n\n    Examples\n    --------\n    >>> see tutorial_mnist_simple.py\n    >>> y = network.outputs\n    >>> y_op = tf.argmax(tf.nn.softmax(y), 1)\n    >>> print(tl.utils.predict(sess, network, X_test, x, y_op))\n    """"""\n    dp_dict = dict_to_one( network.all_drop )    # disable noise layers\n    feed_dict = {x: X,}\n    feed_dict.update(dp_dict)\n    return sess.run(y_op, feed_dict=feed_dict)\n\n## Evaluation\ndef evaluation(y_test=None, y_predict=None, n_classes=None):\n    """"""\n    Input the predicted results, targets results and\n    the number of class, return the confusion matrix, F1-score of each class,\n    accuracy and macro F1-score.\n\n    Parameters\n    ----------\n    y_test : numpy.array or list\n        target results\n    y_predict : numpy.array or list\n        predicted results\n    n_classes : int\n        number of classes\n\n    Examples\n    --------\n    >>> c_mat, f1, acc, f1_macro = evaluation(y_test, y_predict, n_classes)\n    """"""\n    from sklearn.metrics import confusion_matrix, f1_score, accuracy_score\n    c_mat = confusion_matrix(y_test, y_predict, labels = [x for x in range(n_classes)])\n    f1    = f1_score(y_test, y_predict, average = None, labels = [x for x in range(n_classes)])\n    f1_macro = f1_score(y_test, y_predict, average=\'macro\')\n    acc   = accuracy_score(y_test, y_predict)\n    print(\'confusion matrix: \\n\',c_mat)\n    print(\'f1-score:\',f1)\n    print(\'f1-score(macro):\',f1_macro)   # same output with > f1_score(y_true, y_pred, average=\'macro\')\n    print(\'accuracy-score:\', acc)\n    return c_mat, f1, acc, f1_macro\n\ndef dict_to_one(dp_dict={}):\n    """"""\n    Input a dictionary, return a dictionary that all items are set to one,\n    use for disable dropout, dropconnect layer and so on.\n\n    Parameters\n    ----------\n    dp_dict : dictionary\n        keeping probabilities\n\n    Examples\n    --------\n    >>> dp_dict = dict_to_one( network.all_drop )\n    >>> dp_dict = dict_to_one( network.all_drop )\n    >>> feed_dict.update(dp_dict)\n    """"""\n    return {x: 1 for x in dp_dict}\n\ndef flatten_list(list_of_list=[[],[]]):\n    """"""\n    Input a list of list, return a list that all items are in a list.\n\n    Parameters\n    ----------\n    list_of_list : a list of list\n\n    Examples\n    --------\n    >>> tl.utils.flatten_list([[1, 2, 3],[4, 5],[6]])\n    ... [1, 2, 3, 4, 5, 6]\n    """"""\n    return sum(list_of_list, [])\n\n\ndef class_balancing_oversample(X_train=None, y_train=None, printable=True):\n    """"""Input the features and labels, return the features and labels after oversampling.\n\n    Parameters\n    ----------\n    X_train : numpy.array\n        Features, each row is an example\n    y_train : numpy.array\n        Labels\n\n    Examples\n    --------\n    - One X\n    >>> X_train, y_train = class_balancing_oversample(X_train, y_train, printable=True)\n\n    - Two X\n    >>> X, y = tl.utils.class_balancing_oversample(X_train=np.hstack((X1, X2)), y_train=y, printable=False)\n    >>> X1 = X[:, 0:5]\n    >>> X2 = X[:, 5:]\n    """"""\n    # ======== Classes balancing\n    if printable:\n        print(""Classes balancing for training examples..."")\n    from collections import Counter\n    c = Counter(y_train)\n    if printable:\n        print(\'the occurrence number of each stage: %s\' % c.most_common())\n        print(\'the least stage is Label %s have %s instances\' % c.most_common()[-1])\n        print(\'the most stage is  Label %s have %s instances\' % c.most_common(1)[0])\n    most_num = c.most_common(1)[0][1]\n    if printable:\n        print(\'most num is %d, all classes tend to be this num\' % most_num)\n\n    locations = {}\n    number = {}\n\n    for lab, num in c.most_common():    # find the index from y_train\n        number[lab] = num\n        locations[lab] = np.where(np.array(y_train)==lab)[0]\n    if printable:\n        print(\'convert list(np.array) to dict format\')\n    X = {}  # convert list to dict\n    for lab, num in number.items():\n        X[lab] = X_train[locations[lab]]\n\n    # oversampling\n    if printable:\n        print(\'start oversampling\')\n    for key in X:\n        temp = X[key]\n        while True:\n            if len(X[key]) >= most_num:\n                break\n            X[key] = np.vstack((X[key], temp))\n    if printable:\n        print(\'first features of label 0 >\', len(X[0][0]))\n        print(\'the occurrence num of each stage after oversampling\')\n    for key in X:\n        print(key, len(X[key]))\n    if printable:\n        print(\'make each stage have same num of instances\')\n    for key in X:\n        X[key] = X[key][0:most_num,:]\n        print(key, len(X[key]))\n\n    # convert dict to list\n    if printable:\n        print(\'convert from dict to list format\')\n    y_train = []\n    X_train = np.empty(shape=(0,len(X[0][0])))\n    for key in X:\n        X_train = np.vstack( (X_train, X[key] ) )\n        y_train.extend([key for i in range(len(X[key]))])\n    # print(len(X_train), len(y_train))\n    c = Counter(y_train)\n    if printable:\n        print(\'the occurrence number of each stage after oversampling: %s\' % c.most_common())\n    # ================ End of Classes balancing\n    return X_train, y_train\n\n## Random\ndef get_random_int(min=0, max=10, number=5, seed=None):\n    """"""Return a list of random integer by the given range and quantity.\n\n    Examples\n    ---------\n    >>> r = get_random_int(min=0, max=10, number=5)\n    ... [10, 2, 3, 3, 7]\n    """"""\n    rnd = random.Random()\n    if seed:\n        rnd = random.Random(seed)\n    # return [random.randint(min,max) for p in range(0, number)]\n    return [rnd.randint(min,max) for p in range(0, number)]\n\n#\n# def class_balancing_sequence_4D(X_train, y_train, sequence_length, model=\'downsampling\' ,printable=True):\n#     \'\'\' \xe8\xbe\x93\xe5\x85\xa5\xe3\x80\x81\xe8\xbe\x93\xe5\x87\xba\xe9\x83\xbd\xe6\x98\xafsequence format\n#         oversampling or downsampling\n#     \'\'\'\n#     n_features = X_train.shape[2]\n#     # ======== Classes balancing for sequence\n#     if printable:\n#         print(""Classes balancing for 4D sequence training examples..."")\n#     from collections import Counter\n#     c = Counter(y_train)    # Counter({2: 454, 4: 267, 3: 124, 1: 57, 0: 48})\n#     if printable:\n#         print(\'the occurrence number of each stage: %s\' % c.most_common())\n#         print(\'the least Label %s have %s instances\' % c.most_common()[-1])\n#         print(\'the most  Label %s have %s instances\' % c.most_common(1)[0])\n#     # print(c.most_common()) # [(2, 454), (4, 267), (3, 124), (1, 57), (0, 48)]\n#     most_num = c.most_common(1)[0][1]\n#     less_num = c.most_common()[-1][1]\n#\n#     locations = {}\n#     number = {}\n#     for lab, num in c.most_common():\n#         number[lab] = num\n#         locations[lab] = np.where(np.array(y_train)==lab)[0]\n#     # print(locations)\n#     # print(number)\n#     if printable:\n#         print(\'  convert list to dict\')\n#     X = {}  # convert list to dict\n#     ### a sequence\n#     for lab, _ in number.items():\n#         X[lab] = np.empty(shape=(0,1,n_features,1)) # 4D\n#     for lab, _ in number.items():\n#         #X[lab] = X_train[locations[lab]\n#         for l in locations[lab]:\n#             X[lab] = np.vstack((X[lab], X_train[l*sequence_length : (l+1)*(sequence_length)]))\n#         # X[lab] = X_train[locations[lab]*sequence_length : locations[lab]*(sequence_length+1)]    # a sequence\n#     # print(X)\n#\n#     if model==\'oversampling\':\n#         if printable:\n#             print(\'  oversampling -- most num is %d, all classes tend to be this num\\nshuffle applied\' % most_num)\n#         for key in X:\n#             temp = X[key]\n#             while True:\n#                 if len(X[key]) >= most_num * sequence_length:   # sequence\n#                     break\n#                 X[key] = np.vstack((X[key], temp))\n#             # print(key, len(X[key]))\n#         if printable:\n#             print(\'  make each stage have same num of instances\')\n#         for key in X:\n#             X[key] = X[key][0:most_num*sequence_length,:]   # sequence\n#             if printable:\n#                 print(key, len(X[key]))\n#     elif model==\'downsampling\':\n#         import random\n#         if printable:\n#             print(\'  downsampling -- less num is %d, all classes tend to be this num by randomly choice without replacement\\nshuffle applied\' % less_num)\n#         for key in X:\n#             # print(key, len(X[key]))#, len(X[key])/sequence_length)\n#             s_idx = [ i for i in range(int(len(X[key])/sequence_length))]\n#             s_idx = np.asarray(s_idx)*sequence_length   # start index of sequnce in X[key]\n#             # print(\'s_idx\',s_idx)\n#             r_idx = np.random.choice(s_idx, less_num, replace=False)    # random choice less_num of s_idx\n#             # print(\'r_idx\',r_idx)\n#             temp = X[key]\n#             X[key] = np.empty(shape=(0,1,n_features,1)) # 4D\n#             for idx in r_idx:\n#                 X[key] = np.vstack((X[key], temp[idx:idx+sequence_length]))\n#             # print(key, X[key])\n#             # np.random.choice(l, len(l), replace=False)\n#     else:\n#         raise Exception(\'  model should be oversampling or downsampling\')\n#\n#     # convert dict to list\n#     if printable:\n#         print(\'  convert dict to list\')\n#     y_train = []\n#     # X_train = np.empty(shape=(0,len(X[0][0])))\n#     # X_train = np.empty(shape=(0,len(X[1][0])))    # 2D\n#     X_train = np.empty(shape=(0,1,n_features,1))    # 4D\n#     l_key = list(X.keys())  # shuffle\n#     random.shuffle(l_key)   # shuffle\n#     # for key in X:     # no shuffle\n#     for key in l_key:   # shuffle\n#         X_train = np.vstack( (X_train, X[key] ) )\n#         # print(len(X[key]))\n#         y_train.extend([key for i in range(int(len(X[key])/sequence_length))])\n#     # print(X_train,y_train, type(X_train), type(y_train))\n#     # ================ End of Classes balancing for sequence\n#     # print(X_train.shape, len(y_train))\n#     return X_train, np.asarray(y_train)\n'"
tensorlayer/visualize.py,0,"b'#! /usr/bin/python\n# -*- coding: utf8 -*-\n\n\nimport matplotlib\nmatplotlib.use(\'Agg\')\nimport matplotlib.pyplot as plt\n# import matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n\n## Save images\nimport scipy.misc\ndef save_images(images, size, image_path):\n    """"""Save mutiple images into one single image.\n\n    Parameters\n    -----------\n    images : numpy array [batch, w, h, c]\n    size : list of two int, row and column number.\n        number of images should be equal or less than size[0] * size[1]\n    image_path : string.\n\n    Examples\n    ---------\n    >>> images = np.random.rand(64, 100, 100, 3)\n    >>> tl.visualize.save_images(images, [8, 8], \'temp.png\')\n    """"""\n    def merge(images, size):\n        h, w = images.shape[1], images.shape[2]\n        img = np.zeros((h * size[0], w * size[1], 3))\n        for idx, image in enumerate(images):\n            i = idx % size[1]\n            j = idx // size[1]\n            img[j*h:j*h+h, i*w:i*w+w, :] = image\n        return img\n\n    def imsave(images, size, path):\n        return scipy.misc.imsave(path, merge(images, size))\n\n    assert len(images) <= size[0] * size[1], ""number of images should be equal or less than size[0] * size[1] {}"".format(len(images))\n    return imsave(images, size, image_path)\n\ndef W(W=None, second=10, saveable=True, shape=[28,28], name=\'mnist\', fig_idx=2396512):\n    """"""Visualize every columns of the weight matrix to a group of Greyscale img.\n\n    Parameters\n    ----------\n    W : numpy.array\n        The weight matrix\n    second : int\n        The display second(s) for the image(s), if saveable is False.\n    saveable : boolean\n        Save or plot the figure.\n    shape : a list with 2 int\n        The shape of feature image, MNIST is [28, 80].\n    name : a string\n        A name to save the image, if saveable is True.\n    fig_idx : int\n        matplotlib figure index.\n\n    Examples\n    --------\n    >>> tl.visualize.W(network.all_params[0].eval(), second=10, saveable=True, name=\'weight_of_1st_layer\', fig_idx=2012)\n    """"""\n    if saveable is False:\n        plt.ion()\n    fig = plt.figure(fig_idx)      # show all feature images\n    size = W.shape[0]\n    n_units = W.shape[1]\n\n    num_r = int(np.sqrt(n_units))  # \xe6\xaf\x8f\xe8\xa1\x8c\xe6\x98\xbe\xe7\xa4\xba\xe7\x9a\x84\xe4\xb8\xaa\xe6\x95\xb0   \xe8\x8b\xa525\xe4\xb8\xaahidden unit -> \xe6\xaf\x8f\xe8\xa1\x8c\xe6\x98\xbe\xe7\xa4\xba5\xe4\xb8\xaa\n    num_c = int(np.ceil(n_units/num_r))\n    count = int(1)\n    for row in range(1, num_r+1):\n        for col in range(1, num_c+1):\n            if count > n_units:\n                break\n            a = fig.add_subplot(num_r, num_c, count)\n            # ------------------------------------------------------------\n            # plt.imshow(np.reshape(W[:,count-1],(28,28)), cmap=\'gray\')\n            # ------------------------------------------------------------\n            feature = W[:,count-1] / np.sqrt( (W[:,count-1]**2).sum())\n            # feature[feature<0.0001] = 0   # value threshold\n            # if count == 1 or count == 2:\n            #     print(np.mean(feature))\n            # if np.std(feature) < 0.03:      # condition threshold\n            #     feature = np.zeros_like(feature)\n            # if np.mean(feature) < -0.015:      # condition threshold\n            #     feature = np.zeros_like(feature)\n            plt.imshow(np.reshape(feature ,(shape[0],shape[1])),\n                    cmap=\'gray\', interpolation=""nearest"")#, vmin=np.min(feature), vmax=np.max(feature))\n            # plt.title(name)\n            # ------------------------------------------------------------\n            # plt.imshow(np.reshape(W[:,count-1] ,(np.sqrt(size),np.sqrt(size))), cmap=\'gray\', interpolation=""nearest"")\n            plt.gca().xaxis.set_major_locator(plt.NullLocator())    # distable tick\n            plt.gca().yaxis.set_major_locator(plt.NullLocator())\n            count = count + 1\n    if saveable:\n        plt.savefig(name+\'.pdf\',format=\'pdf\')\n    else:\n        plt.draw()\n        plt.pause(second)\n\ndef frame(I=None, second=5, saveable=True, name=\'frame\', cmap=None, fig_idx=12836):\n    """"""Display a frame(image). Make sure OpenAI Gym render() is disable before using it.\n\n    Parameters\n    ----------\n    I : numpy.array\n        The image\n    second : int\n        The display second(s) for the image(s), if saveable is False.\n    saveable : boolean\n        Save or plot the figure.\n    name : a string\n        A name to save the image, if saveable is True.\n    cmap : None or string\n        \'gray\' for greyscale, None for default, etc.\n    fig_idx : int\n        matplotlib figure index.\n\n    Examples\n    --------\n    >>> env = gym.make(""Pong-v0"")\n    >>> observation = env.reset()\n    >>> tl.visualize.frame(observation)\n    """"""\n    if saveable is False:\n        plt.ion()\n    fig = plt.figure(fig_idx)      # show all feature images\n\n    if len(I.shape) and I.shape[-1]==1:     # (10,10,1) --> (10,10)\n        I = I[:,:,0]\n\n    plt.imshow(I, cmap)\n    plt.title(name)\n    # plt.gca().xaxis.set_major_locator(plt.NullLocator())    # distable tick\n    # plt.gca().yaxis.set_major_locator(plt.NullLocator())\n\n    if saveable:\n        plt.savefig(name+\'.pdf\',format=\'pdf\')\n    else:\n        plt.draw()\n        plt.pause(second)\n\ndef CNN2d(CNN=None, second=10, saveable=True, name=\'cnn\', fig_idx=3119362):\n    """"""Display a group of RGB or Greyscale CNN masks.\n\n    Parameters\n    ----------\n    CNN : numpy.array\n        The image. e.g: 64 5x5 RGB images can be (5, 5, 3, 64).\n    second : int\n        The display second(s) for the image(s), if saveable is False.\n    saveable : boolean\n        Save or plot the figure.\n    name : a string\n        A name to save the image, if saveable is True.\n    fig_idx : int\n        matplotlib figure index.\n\n    Examples\n    --------\n    >>> tl.visualize.CNN2d(network.all_params[0].eval(), second=10, saveable=True, name=\'cnn1_mnist\', fig_idx=2012)\n    """"""\n    # print(CNN.shape)    # (5, 5, 3, 64)\n    # exit()\n    n_mask = CNN.shape[3]\n    n_row = CNN.shape[0]\n    n_col = CNN.shape[1]\n    n_color = CNN.shape[2]\n    row = int(np.sqrt(n_mask))\n    col = int(np.ceil(n_mask/row))\n    plt.ion()   # active mode\n    fig = plt.figure(fig_idx)\n    count = 1\n    for ir in range(1, row+1):\n        for ic in range(1, col+1):\n            if count > n_mask:\n                break\n            a = fig.add_subplot(col, row, count)\n            # print(CNN[:,:,:,count-1].shape, n_row, n_col)   # (5, 1, 32) 5 5\n            # exit()\n            # plt.imshow(\n            #         np.reshape(CNN[count-1,:,:,:], (n_row, n_col)),\n            #         cmap=\'gray\', interpolation=""nearest"")     # theano\n            if n_color == 1:\n                plt.imshow(\n                        np.reshape(CNN[:,:,:,count-1], (n_row, n_col)),\n                        cmap=\'gray\', interpolation=""nearest"")\n            elif n_color == 3:\n                plt.imshow(\n                        np.reshape(CNN[:,:,:,count-1], (n_row, n_col, n_color)),\n                        cmap=\'gray\', interpolation=""nearest"")\n            else:\n                raise Exception(""Unknown n_color"")\n            plt.gca().xaxis.set_major_locator(plt.NullLocator())    # distable tick\n            plt.gca().yaxis.set_major_locator(plt.NullLocator())\n            count = count + 1\n    if saveable:\n        plt.savefig(name+\'.pdf\',format=\'pdf\')\n    else:\n        plt.draw()\n        plt.pause(second)\n\n\ndef images2d(images=None, second=10, saveable=True, name=\'images\', dtype=None,\n                                                            fig_idx=3119362):\n    """"""Display a group of RGB or Greyscale images.\n\n    Parameters\n    ----------\n    images : numpy.array\n        The images.\n    second : int\n        The display second(s) for the image(s), if saveable is False.\n    saveable : boolean\n        Save or plot the figure.\n    name : a string\n        A name to save the image, if saveable is True.\n    dtype : None or numpy data type\n        The data type for displaying the images.\n    fig_idx : int\n        matplotlib figure index.\n\n    Examples\n    --------\n    >>> X_train, y_train, X_test, y_test = tl.files.load_cifar10_dataset(shape=(-1, 32, 32, 3), plotable=False)\n    >>> tl.visualize.images2d(X_train[0:100,:,:,:], second=10, saveable=False, name=\'cifar10\', dtype=np.uint8, fig_idx=20212)\n    """"""\n    # print(images.shape)    # (50000, 32, 32, 3)\n    # exit()\n    if dtype:\n        images = np.asarray(images, dtype=dtype)\n    n_mask = images.shape[0]\n    n_row = images.shape[1]\n    n_col = images.shape[2]\n    n_color = images.shape[3]\n    row = int(np.sqrt(n_mask))\n    col = int(np.ceil(n_mask/row))\n    plt.ion()   # active mode\n    fig = plt.figure(fig_idx)\n    count = 1\n    for ir in range(1, row+1):\n        for ic in range(1, col+1):\n            if count > n_mask:\n                break\n            a = fig.add_subplot(col, row, count)\n            # print(images[:,:,:,count-1].shape, n_row, n_col)   # (5, 1, 32) 5 5\n            # plt.imshow(\n            #         np.reshape(images[count-1,:,:,:], (n_row, n_col)),\n            #         cmap=\'gray\', interpolation=""nearest"")     # theano\n            if n_color == 1:\n                plt.imshow(\n                        np.reshape(images[count-1,:,:], (n_row, n_col)),\n                        cmap=\'gray\', interpolation=""nearest"")\n                # plt.title(name)\n            elif n_color == 3:\n                plt.imshow(images[count-1,:,:],\n                        cmap=\'gray\', interpolation=""nearest"")\n                # plt.title(name)\n            else:\n                raise Exception(""Unknown n_color"")\n            plt.gca().xaxis.set_major_locator(plt.NullLocator())    # distable tick\n            plt.gca().yaxis.set_major_locator(plt.NullLocator())\n            count = count + 1\n    if saveable:\n        plt.savefig(name+\'.pdf\',format=\'pdf\')\n    else:\n        plt.draw()\n        plt.pause(second)\n\ndef tsne_embedding(embeddings, reverse_dictionary, plot_only=500,\n                        second=5, saveable=False, name=\'tsne\', fig_idx=9862):\n    """"""Visualize the embeddings by using t-SNE.\n\n    Parameters\n    ----------\n    embeddings : a matrix\n        The images.\n    reverse_dictionary : a dictionary\n        id_to_word, mapping id to unique word.\n    plot_only : int\n        The number of examples to plot, choice the most common words.\n    second : int\n        The display second(s) for the image(s), if saveable is False.\n    saveable : boolean\n        Save or plot the figure.\n    name : a string\n        A name to save the image, if saveable is True.\n    fig_idx : int\n        matplotlib figure index.\n\n    Examples\n    --------\n    >>> see \'tutorial_word2vec_basic.py\'\n    >>> final_embeddings = normalized_embeddings.eval()\n    >>> tl.visualize.tsne_embedding(final_embeddings, labels, reverse_dictionary,\n    ...                   plot_only=500, second=5, saveable=False, name=\'tsne\')\n    """"""\n    def plot_with_labels(low_dim_embs, labels, figsize=(18, 18), second=5,\n                                    saveable=True, name=\'tsne\', fig_idx=9862):\n        assert low_dim_embs.shape[0] >= len(labels), ""More labels than embeddings""\n        if saveable is False:\n            plt.ion()\n            plt.figure(fig_idx)\n        plt.figure(figsize=figsize)  #in inches\n        for i, label in enumerate(labels):\n            x, y = low_dim_embs[i,:]\n            plt.scatter(x, y)\n            plt.annotate(label,\n                     xy=(x, y),\n                     xytext=(5, 2),\n                     textcoords=\'offset points\',\n                     ha=\'right\',\n                     va=\'bottom\')\n        if saveable:\n            plt.savefig(name+\'.pdf\',format=\'pdf\')\n        else:\n            plt.draw()\n            plt.pause(second)\n\n    try:\n        from sklearn.manifold import TSNE\n        import matplotlib.pyplot as plt\n        from six.moves import xrange\n\n        tsne = TSNE(perplexity=30, n_components=2, init=\'pca\', n_iter=5000)\n        # plot_only = 500\n        low_dim_embs = tsne.fit_transform(embeddings[:plot_only,:])\n        labels = [reverse_dictionary[i] for i in xrange(plot_only)]\n        plot_with_labels(low_dim_embs, labels, second=second, saveable=saveable, \\\n                                                    name=name, fig_idx=fig_idx)\n    except ImportError:\n        print(""Please install sklearn and matplotlib to visualize embeddings."")\n\n\n#\n'"
