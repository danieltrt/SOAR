file_path,api_count,code
pytorchtools.py,1,"b'import numpy as np\nimport torch\n\nclass EarlyStopping:\n    """"""Early stops the training if validation loss doesn\'t improve after a given patience.""""""\n    def __init__(self, patience=7, verbose=False, delta=0, path=\'checkpoint.pt\'):\n        """"""\n        Args:\n            patience (int): How long to wait after last time validation loss improved.\n                            Default: 7\n            verbose (bool): If True, prints a message for each validation loss improvement. \n                            Default: False\n            delta (float): Minimum change in the monitored quantity to qualify as an improvement.\n                            Default: 0\n            path (str): Path for the checkpoint to be saved to.\n                            Default: \'checkpoint.pt\'\n        """"""\n        self.patience = patience\n        self.verbose = verbose\n        self.counter = 0\n        self.best_score = None\n        self.early_stop = False\n        self.val_loss_min = np.Inf\n        self.delta = delta\n        self.path = path\n\n    def __call__(self, val_loss, model):\n\n        score = -val_loss\n\n        if self.best_score is None:\n            self.best_score = score\n            self.save_checkpoint(val_loss, model)\n        elif score < self.best_score + self.delta:\n            self.counter += 1\n            print(f\'EarlyStopping counter: {self.counter} out of {self.patience}\')\n            if self.counter >= self.patience:\n                self.early_stop = True\n        else:\n            self.best_score = score\n            self.save_checkpoint(val_loss, model)\n            self.counter = 0\n\n    def save_checkpoint(self, val_loss, model):\n        \'\'\'Saves model when validation loss decrease.\'\'\'\n        if self.verbose:\n            print(f\'Validation loss decreased ({self.val_loss_min:.6f} --> {val_loss:.6f}).  Saving model ...\')\n        torch.save(model.state_dict(), self.path)\n        self.val_loss_min = val_loss\n'"
