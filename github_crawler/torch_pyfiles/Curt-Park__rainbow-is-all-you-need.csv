file_path,api_count,code
segment_tree.py,0,"b'# -*- coding: utf-8 -*-\n""""""Segment tree for Prioritized Replay Buffer.""""""\n\nimport operator\nfrom typing import Callable\n\n\nclass SegmentTree:\n    """""" Create SegmentTree.\n\n    Taken from OpenAI baselines github repository:\n    https://github.com/openai/baselines/blob/master/baselines/common/segment_tree.py\n\n    Attributes:\n        capacity (int)\n        tree (list)\n        operation (function)\n\n    """"""\n\n    def __init__(self, capacity: int, operation: Callable, init_value: float):\n        """"""Initialization.\n\n        Args:\n            capacity (int)\n            operation (function)\n            init_value (float)\n\n        """"""\n        assert (\n            capacity > 0 and capacity & (capacity - 1) == 0\n        ), ""capacity must be positive and a power of 2.""\n        self.capacity = capacity\n        self.tree = [init_value for _ in range(2 * capacity)]\n        self.operation = operation\n\n    def _operate_helper(\n        self, start: int, end: int, node: int, node_start: int, node_end: int\n    ) -> float:\n        """"""Returns result of operation in segment.""""""\n        if start == node_start and end == node_end:\n            return self.tree[node]\n        mid = (node_start + node_end) // 2\n        if end <= mid:\n            return self._operate_helper(start, end, 2 * node, node_start, mid)\n        else:\n            if mid + 1 <= start:\n                return self._operate_helper(start, end, 2 * node + 1, mid + 1, node_end)\n            else:\n                return self.operation(\n                    self._operate_helper(start, mid, 2 * node, node_start, mid),\n                    self._operate_helper(mid + 1, end, 2 * node + 1, mid + 1, node_end),\n                )\n\n    def operate(self, start: int = 0, end: int = 0) -> float:\n        """"""Returns result of applying `self.operation`.""""""\n        if end <= 0:\n            end += self.capacity\n        end -= 1\n\n        return self._operate_helper(start, end, 1, 0, self.capacity - 1)\n\n    def __setitem__(self, idx: int, val: float):\n        """"""Set value in tree.""""""\n        idx += self.capacity\n        self.tree[idx] = val\n\n        idx //= 2\n        while idx >= 1:\n            self.tree[idx] = self.operation(self.tree[2 * idx], self.tree[2 * idx + 1])\n            idx //= 2\n\n    def __getitem__(self, idx: int) -> float:\n        """"""Get real value in leaf node of tree.""""""\n        assert 0 <= idx < self.capacity\n\n        return self.tree[self.capacity + idx]\n\n\nclass SumSegmentTree(SegmentTree):\n    """""" Create SumSegmentTree.\n\n    Taken from OpenAI baselines github repository:\n    https://github.com/openai/baselines/blob/master/baselines/common/segment_tree.py\n\n    """"""\n\n    def __init__(self, capacity: int):\n        """"""Initialization.\n\n        Args:\n            capacity (int)\n\n        """"""\n        super(SumSegmentTree, self).__init__(\n            capacity=capacity, operation=operator.add, init_value=0.0\n        )\n\n    def sum(self, start: int = 0, end: int = 0) -> float:\n        """"""Returns arr[start] + ... + arr[end].""""""\n        return super(SumSegmentTree, self).operate(start, end)\n\n    def retrieve(self, upperbound: float) -> int:\n        """"""Find the highest index `i` about upper bound in the tree""""""\n        # TODO: Check assert case and fix bug\n        assert 0 <= upperbound <= self.sum() + 1e-5, ""upperbound: {}"".format(upperbound)\n\n        idx = 1\n\n        while idx < self.capacity:  # while non-leaf\n            left = 2 * idx\n            right = left + 1\n            if self.tree[left] > upperbound:\n                idx = 2 * idx\n            else:\n                upperbound -= self.tree[left]\n                idx = right\n        return idx - self.capacity\n\n\nclass MinSegmentTree(SegmentTree):\n    """""" Create SegmentTree.\n\n    Taken from OpenAI baselines github repository:\n    https://github.com/openai/baselines/blob/master/baselines/common/segment_tree.py\n\n    """"""\n\n    def __init__(self, capacity: int):\n        """"""Initialization.\n\n        Args:\n            capacity (int)\n\n        """"""\n        super(MinSegmentTree, self).__init__(\n            capacity=capacity, operation=min, init_value=float(""inf"")\n        )\n\n    def min(self, start: int = 0, end: int = 0) -> float:\n        """"""Returns min(arr[start], ...,  arr[end]).""""""\n        return super(MinSegmentTree, self).operate(start, end)\n'"
