file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\nimport os\nfrom datetime import date\nfrom setuptools import setup, find_packages\n\n# --- import your package ---\npackageName = \'boxx\'\n\npyPath = \'%s/__init__.py\'%packageName if os.path.isdir(packageName) else \'%s.py\'%packageName\n\nwith open(pyPath) as f:\n    lines = f.readlines()\ncode = \'\'.join(filter(lambda l: \'import \' not in l, lines))\nclass Pack():\n    pass\npackage = Pack()\npackage.__name__ = packageName\nexec(code, package.__dict__)\n\nif __name__ == ""__main__"":\n    # --- Automatically generate setup parameters ---\n    # Your package name\n    PKG_NAME = package.__name__\n\n    # Your GitHub user name\n    try:\n        GITHUB_USERNAME = package.__github_username__\n    except:\n        GITHUB_USERNAME = ""Unknown-Github-Username""\n\n    # Short description will be the description on PyPI\n    try:\n        SHORT_DESCRIPTION = package.__short_description__  # GitHub Short Description\n    except:\n        print(\n            ""\'__short_description__\' not found in \'%s.__init__.py\'!"" % PKG_NAME)\n        SHORT_DESCRIPTION = ""No short description!""\n\n    # Long description will be the body of content on PyPI page\n    try:\n        LONG_DESCRIPTION = open(""README.md"", ""rb"").read().decode(""utf-8"")\n    except:\n        LONG_DESCRIPTION = ""No long description!""\n\n    # Version number, VERY IMPORTANT!\n    VERSION = package.__version__\n\n    # Author and Maintainer\n    try:\n        AUTHOR = package.__author__\n    except:\n        AUTHOR = ""Unknown""\n\n    try:\n        AUTHOR_EMAIL = package.__author_email__\n    except:\n        AUTHOR_EMAIL = None\n\n    try:\n        MAINTAINER = package.__maintainer__\n    except:\n        MAINTAINER = ""Unknown""\n\n    try:\n        MAINTAINER_EMAIL = package.__maintainer_email__\n    except:\n        MAINTAINER_EMAIL = None\n\n    PACKAGES, INCLUDE_PACKAGE_DATA, PACKAGE_DATA, PY_MODULES = (\n        None, None, None, None,\n    )\n\n    # It\'s a directory style package\n    if os.path.exists(__file__[:-8] + PKG_NAME):\n        # Include all sub packages in package directory\n        PACKAGES = [PKG_NAME] + [""%s.%s"" % (PKG_NAME, i)\n                                 for i in find_packages(PKG_NAME)]\n\n        # Include everything in package directory\n        INCLUDE_PACKAGE_DATA = None\n        PACKAGE_DATA = {\n            """": [""*.*""],\n        }\n\n    # It\'s a single script style package\n    elif os.path.exists(__file__[:-8] + PKG_NAME + "".py""):\n        PY_MODULES = [PKG_NAME, ]\n\n    # The project directory name is the GitHub repository name\n    repository_name = os.path.basename(os.path.dirname(__file__))\n\n    # Project Url\n    URL = ""https://github.com/{0}/{1}"".format(GITHUB_USERNAME, repository_name)\n    # Use todays date as GitHub release tag\n    github_release_tag = str(date.today())\n    # Source code download url\n    DOWNLOAD_URL = ""https://github.com/{0}/{1}/tarball/{2}"".format(\n        GITHUB_USERNAME, repository_name, github_release_tag)\n\n    try:\n        LICENSE = package.__license__\n    except:\n        print(""\'__license__\' not found in \'%s.__init__.py\'!"" % PKG_NAME)\n        LICENSE = """"\n\n    PLATFORMS = [\n        ""Windows"",\n        ""MacOS"",\n        ""Unix"",\n    ]\n\n    CLASSIFIERS = [\n        ""Development Status :: 4 - Beta"",\n        ""Intended Audience :: Developers"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Natural Language :: English"",\n        ""Operating System :: Microsoft :: Windows"",\n        ""Operating System :: MacOS"",\n        ""Operating System :: Unix"",\n        ""Programming Language :: Python"",\n        ""Programming Language :: Python :: 2.7"",\n        ""Programming Language :: Python :: 3.4"",\n        ""Programming Language :: Python :: 3.5"",\n        ""Programming Language :: Python :: 3.6"",\n    ]\n\n    # Read requirements.txt, ignore comments\n    try:\n        REQUIRES = list()\n        f = open(""requirements.txt"", ""rb"")\n        for line in f.read().decode(""utf-8"").split(""\\n""):\n            line = line.strip()\n            if ""#"" in line:\n                line = line[:line.find(""#"")].strip()\n            if line:\n                REQUIRES.append(line)\n    except:\n        print(""\'requirements.txt\' not found!"")\n        REQUIRES = list()\n    setup(\n        name=PKG_NAME,\n        description=SHORT_DESCRIPTION,\n#        long_description=LONG_DESCRIPTION,\n        long_description=SHORT_DESCRIPTION+\'\\nMore information on github: %s\'%package.__github_url__,\n        version=VERSION,\n        author=AUTHOR,\n        author_email=AUTHOR_EMAIL,\n        maintainer=MAINTAINER,\n        maintainer_email=MAINTAINER_EMAIL,\n        packages=PACKAGES,\n        include_package_data=INCLUDE_PACKAGE_DATA,\n#        package_data=PACKAGE_DATA,\n        py_modules=PY_MODULES,\n        url=package.__github_url__,\n        download_url=package.__github_url__,\n        classifiers=CLASSIFIERS,\n        platforms=PLATFORMS,\n        license=LICENSE,\n        install_requires=REQUIRES,\n    )\n\n""""""\nAppendix\n--------\n::\n\nFrequent used classifiers List = [\n    ""Development Status :: 1 - Planning"",\n    ""Development Status :: 2 - Pre-Alpha"",\n    ""Development Status :: 3 - Alpha"",\n    ""Development Status :: 4 - Beta"",\n    ""Development Status :: 5 - Production/Stable"",\n    ""Development Status :: 6 - Mature"",\n    ""Development Status :: 7 - Inactive"",\n\n    ""Intended Audience :: Customer Service"",\n    ""Intended Audience :: Developers"",\n    ""Intended Audience :: Education"",\n    ""Intended Audience :: End Users/Desktop"",\n    ""Intended Audience :: Financial and Insurance Industry"",\n    ""Intended Audience :: Healthcare Industry"",\n    ""Intended Audience :: Information Technology"",\n    ""Intended Audience :: Legal Industry"",\n    ""Intended Audience :: Manufacturing"",\n    ""Intended Audience :: Other Audience"",\n    ""Intended Audience :: Religion"",\n    ""Intended Audience :: Science/Research"",\n    ""Intended Audience :: System Administrators"",\n    ""Intended Audience :: Telecommunications Industry"",\n\n    ""License :: OSI Approved :: BSD License"",\n    ""License :: OSI Approved :: MIT License"",\n    ""License :: OSI Approved :: Apache Software License"",\n    ""License :: OSI Approved :: GNU General Public License (GPL)"",\n    ""License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)"",\n\n    ""Natural Language :: English"",\n    ""Natural Language :: Chinese (Simplified)"",\n\n    ""Operating System :: Microsoft :: Windows"",\n    ""Operating System :: MacOS"",\n    ""Operating System :: Unix"",\n\n    ""Programming Language :: Python"",\n    ""Programming Language :: Python :: 2"",\n    ""Programming Language :: Python :: 2.7"",\n    ""Programming Language :: Python :: 2 :: Only"",\n    ""Programming Language :: Python :: 3"",\n    ""Programming Language :: Python :: 3.4"",\n    ""Programming Language :: Python :: 3.5"",\n    ""Programming Language :: Python :: 3.6"",\n    ""Programming Language :: Python :: 3 :: Only"",\n]\n""""""\n'"
yllab.py,0,"b""# -*- coding: utf-8 -*-\n\n#import sys\n#from os.path import abspath,join,dirname\n#_path = (abspath(__file__))\n#absLibpPath = join(dirname(_path),'yl')\n#    \n#if absLibpPath not in sys.path:\n#    sys.path = [absLibpPath]+sys.path\n\n# print absLibpPath\nfrom boxx.tool import *\nfrom boxx.ylimg import *\nfrom boxx.ylml import * \nfrom boxx.ylsci import *\nfrom boxx import tool\nfrom boxx import ylimg\nfrom boxx import ylml\nfrom boxx import ylnp\n\n\nif __name__ == '__main__':\n\n    pass\n"""
boxx/__init__.py,0,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\n\'\'\'\nTool-box for efficient build and debug in Python. \nEspacially for Scientific Computing and Computer Vision.\n\'\'\'\n__version__ = ""0.9.2.28""\n__short_description__ = ""Tool-box for efficient build and debug in Python. Especially for Scientific Computing and Computer Vision.""\n__license__ = ""MIT""\n__author__ = ""DIYer22""\n__author_email__ = ""ylxx@live.com""\n__maintainer__ = ""DIYer22""\n__maintainer_email__ = ""ylxx@live.com""\n__github_username__ = ""DIYer22""\n__github_url__ = ""https://github.com/DIYer22/boxx""\n__support__ = ""https://github.com/DIYer22/boxx/issues""\n\nfrom . import ylsys\nfrom . import ylcompat\nfrom . import tool\nfrom . import ylimg\nfrom . import ylsci\nfrom . import ylml\nfrom . import yldb\nfrom . import undetermined\n\n\n\nfrom .tool import *\nfrom .ylsys import *\nfrom .ylcompat import *\nfrom .ylimg import *\nfrom .ylml import *\nfrom .ylsci import *\nfrom .yldb import *\n\nif __name__ == \'__main__\':\n    pass\n\n'"
boxx/cp.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\nsample a small data set.\nFor each types files in dir, only copy 50 files to target.\nwon\'t copy size > 512MB file\n\nCreated on Sat Jun 30 14:58:44 2018\n\n@author: yanglei\n""""""\n\nimport argparse, os\nimport shutil\nfrom collections import defaultdict\n\nfrom os.path import join, isdir, basename\npathjoin = join\n\nparser = argparse.ArgumentParser(description=""""""\nsample a small data set.\nFor each types files in dir, only copy 50 files to target.\nwon\'t copy size > 512MB file"""""")\nparser.add_argument(\'source_target\', nargs=\'*\', default=None, type=str)\nparser.add_argument(\'-n\', default=10, type=float, \n                    help=\'How many data to copy\')\nparser.add_argument(\'-x\', \'--max\', default=50, type=int, \n                    help=\'max numbers of the file if number > max: only copy top n file \')\n\nparser.add_argument(\'-s\', \'--max_size\', default=512, type=int, \n                    help=""max size of the file if size > max_size won\'t copy, The unit is MB"")\n\n\n#parser.add_argument(\'source\', nargs=\'*\', default=\'boxx\', type=str)\n#parser.add_argument(\'target\', nargs=\'0\', default=\'/tmp/\', type=str)\n\n\ndef path2type(path):\n    if isdir(path):\n        return ""/dir""\n    try:\n        ind = path.rindex(\'.\')\n    except ValueError:\n        return ""/~.""\n    return path[ind+1:]\n\ndef filterFileList(l):\n    if len(l) < arg.max:\n        return l    \n    n = arg.n\n    if n < 1:\n        n = len(l) * n\n    n = int(n)\n    l = sorted(l)\n    return l[:n] \n\ndef copyfile(src, dst):\n    size = os.path.getsize(src)/float(1024**2)\n    if size > arg.max_size:\n        new = \'%s_%sMB.fake\'%(dst, int(size))\n        with open(new ,\'w\',) as f:\n            f.write(\'size = %s MB\'%size)\n        return \n    shutil.copyfile(src, dst)\n    \ndef listdirWithFun(source=\'.\', target=\'/tmp\', __first=True):\n    \'\'\'\xe5\xaf\xb9source\xe8\xb7\xaf\xe5\xbe\x84\xe5\x8f\x8a\xe5\xad\x90\xe8\xb7\xaf\xe5\xbe\x84\xe4\xb8\x8b\xe7\x9a\x84\xe6\xaf\x8f\xe4\xb8\xaapath \xe6\x89\xa7\xe8\xa1\x8cfun\n    \n    Parameters\n    ----------\n    source : str, default \'.\'\n        \xe8\xb7\xaf\xe5\xbe\x84\n    fun : function\n        \xe5\xaf\xb9\xe6\xaf\x8f\xe4\xb8\xaa\xe5\xad\x90\xe8\xb7\xaf\xe5\xbe\x84\xe6\x89\xa7\xe8\xa1\x8cfun(path)\n    \'\'\'\n    if __first:\n        source = os.path.abspath(source)\n        if isdir(target):\n            target = pathjoin(target, basename(source))\n        if not isdir(target):\n            os.makedirs(target, exist_ok=True)    \n        \n#    paths = [pathjoin(source, p) for p in os.listdir(source)]\n    paths = os.listdir(source)\n    \n    d = defaultdict(lambda :[])\n    [d[path2type(pathjoin(source, p))].append(p) for p in paths]\n    \n    d = {k:filterFileList(v) for k,v in d.items()}\n    \n    dirs = d.pop(\'/dir\') if \'/dir\' in d else []\n    \n    [[copyfile(pathjoin(source, p), pathjoin(target, p))  for p in l] for l in d.values()]\n    \n    for dirr in dirs:\n        targetd = pathjoin(target, dirr)\n        if not isdir(targetd):\n            os.makedirs(targetd, exist_ok=True)\n        listdirWithFun(pathjoin(source, dirr), target=targetd, __first=False)\n\nif __name__ == \'__main__\':\n    arg = parser.parse_args()\n    arg.max = max(arg.max, arg.n)\n    arg.source = arg.source_target[0] if len(arg.source_target) else \'.\'\n    arg.target = arg.source_target[1] if len(arg.source_target)>=2 else \'/tmp/\'\n    print(arg)\n    listdirWithFun(arg.source, arg.target)\n\n\n\n\n\n'"
boxx/g.py,0,"b""#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n'''\n`import boxx.g` act same as `g()`\n\nuseage:\n    >>> import boxx.g\n        \nInstruct\n----------\n    your can exec `g()`, `p()` in any function or module\n    all vars that belong the function will transport to\n    Python interactive shell. and `globals()` will in `p` which is a dicto\n    the differtent between `g` and `gg` is that `gg` will auto print the vars's information\n    \n    BTW, `import boxx.g`, `import boxx.p` is convenient way to use `g()` without `from boxx import g`\n    \nNotice\n-----------\n    For Python 2 only first time import works \n\n    \xe5\x9c\xa8\xe5\x87\xbd\xe6\x95\xb0\xe5\x86\x85\xe8\xbf\x90\xe8\xa1\x8c`p()` or `lc()`  \n    \xe5\x88\x99\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84global\xe5\x92\x8clocal \xe5\x8f\x98\xe9\x87\x8f\xe4\xbc\x9a\xe8\xbd\xbd\xe5\x85\xa5\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f p \xe4\xb8\xad\n    \xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84 frame\xe7\xad\x89\xe5\x85\xb6\xe4\xbb\x96\xe4\xbf\xa1\xe6\x81\xaf \xe5\x88\x99\xe6\x94\xbe\xe5\x85\xa5\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f lc\n\n'''\nfrom .ylsys import  py2\nfrom .tool import out\n\ndeep = 6\nif py2:\n    deep = 1\n\nout(deep, printt=False)\n\nif py2:\n    import sys\n    from .tool import g\n    sys.modules['boxx.g'] = g\nelse:\n    from .tool import removeImportSelf\n    removeImportSelf('boxx.g')\n\n\nif __name__ == '__main__':\n    pass\n"""
boxx/gg.py,0,"b""#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n'''\n`import boxx.gg` act same as `gg()`\n\nuseage:\n    >>> import boxx.gg\n        \nInstruct\n----------\n    your can exec `g()`, `p()` in any function or module\n    all vars that belong the function will transport to\n    Python interactive shell. and `globals()` will in `p` which is a dicto\n    the differtent between `g` and `gg` is that `gg` will auto print the vars's information\n    \n    BTW, `import boxx.gg`, `import boxx.p` is convenient way to use `gg()` without `from boxx import gg`\n    \nNotice\n-----------\n    For Python 2 only first time import works \n\n    \xe5\x9c\xa8\xe5\x87\xbd\xe6\x95\xb0\xe5\x86\x85\xe8\xbf\x90\xe8\xa1\x8c`p()` or `lc()`  \n    \xe5\x88\x99\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84global\xe5\x92\x8clocal \xe5\x8f\x98\xe9\x87\x8f\xe4\xbc\x9a\xe8\xbd\xbd\xe5\x85\xa5\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f p \xe4\xb8\xad\n    \xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84 frame\xe7\xad\x89\xe5\x85\xb6\xe4\xbb\x96\xe4\xbf\xa1\xe6\x81\xaf \xe5\x88\x99\xe6\x94\xbe\xe5\x85\xa5\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f lc\n\n'''\nfrom .ylsys import  py2\nfrom .tool import out\n\ndeep = 6\nif py2:\n    deep = 1\n\nout(deep)\n\nif py2:\n    import sys\n    from .tool import gg\n    sys.modules['boxx.gg'] = gg\nelse:\n    from .tool import removeImportSelf\n    removeImportSelf('boxx.gg')\n\n\nif __name__ == '__main__':\n    pass\n"""
boxx/p.py,0,"b""#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n'''\n`import boxx.p` act same as `p()`\n\nNotice: For Python 2 only first time import works \n\nuseage:\n    >>> import boxx.p\n    \n        \nInstruct\n----------\n    your can use `out()`, `p()` in any function or module\n    exec `out()`, all vars that belong the function will transport to\n    Python interactive shell. and `globals()` will in `p` which is a dicto\n    \n    BTW, `import boxx.out`, `import boxx.p` is convenient way to use `out()` without `from boxx import out`\n    \n    \xe5\x9c\xa8\xe5\x87\xbd\xe6\x95\xb0\xe5\x86\x85\xe8\xbf\x90\xe8\xa1\x8c`p()` or `lc()`  \n    \xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84 frame\xe7\xad\x89\xe5\x85\xb6\xe4\xbb\x96\xe4\xbf\xa1\xe6\x81\xaf \xe5\x88\x99\xe6\x94\xbe\xe5\x85\xa5\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f lc\n\n'''\nfrom .ylsys import  py2\nfrom .tool import p\n\ndeep = 6\nif py2:\n    deep = 1\n\np(deep)\n\nif py2:\n    import sys\n    sys.modules['boxx.p'] = p\nelse:\n    from .tool import removeImportSelf\n    removeImportSelf('boxx.p')\n#from . import *\n#print(prettyFrameStack())\n#fs = getFatherFrames(endByMain=1)\n#list(map(pipe(prettyFrameLocation,log),fs))\n\n\nif __name__ == '__main__':\n    pass\n\n"""
boxx/script.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\n@author: DIYer22@github\n@mail: ylxx@live.com\nCreated on Mon Mar  2 12:52:18 2020\n\nMake python script as easy to use as shell script.\n\nUsage:\n    python -m boxx.script \'[print(i) for i in range(10)]\'\n    \n    # add ""tmp_"" as prefix for all file in \'.\' \n    python -m boxx.script \'[mv(fname, ""tmp_""+fname) for fname in ls()]\'\n\nalias ""ls, mv, ln, lns, cp, cpr"" as funcation.\n\n""""""\n\nfrom boxx import *\nfrom boxx import listdir\n\ntry:\n    import cv2\n    #from boxx.ylth import *\nexcept Exception:\n    pass\n\nimport sys\nimport shutil\nfrom os import rename, link, symlink, remove\n\nmv = rename\nrm = remove\nln = link\nlns = symlink\ncp = shutil.copy\ncpr = shutil.copytree\nls = listdir\n\n\nclass GetKey(dict):\n    def __getitem__(self, k):\n        if k in self:\n            return dict.__getitem__(self, k)\n        elif k in __builtins__.__dict__:\n            return __builtins__.__dict__[k]\n        else:\n            print(\'Set %s as string:""%s""\' % (k, k))\n            self[k] = k\n            return dict.__getitem__(self, k)\n\n\ncontext = GetKey(globals())\n\ndef main():\n    code = "" "".join(sys.argv[1:])\n    print(\'Code: ""%s""\' % code)\n    print()\n\n    exec(code, context, context)\n\nif __name__ == ""__main__"":\n    main()'"
boxx/undetermined.py,0,"b""# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\n\nif __name__ == '__main__':\n    \n    pass\n\n"""
boxx/ylcompat.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nA module provide ability to be compatible with Python 2.7\n\n@author: yanglei\n""""""\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\n\nfrom .ylsys import py2, pyi\nimport os, sys\nfrom functools import reduce, wraps\n\nif py2:\n    import __builtin__ as builtins\nelse:\n    import builtins\n    \nprintf = print\n\n\nif py2:\n    unicode = __builtins__[\'unicode\']\nelse:\n    unicode = str\n\ndef isstr(s):\n    \'\'\'\n    `isinstance(s, str)` for compatibility both python 2/3\n    \'\'\'\n    return isinstance(s, (str, unicode))\n\n\nclass Classobj:\n    \'\'\' \xe5\x85\xbc\xe5\xae\xb9 python 2 \xe7\x9a\x84 classobj\'\'\'\n    pass\nclassobj = type(Classobj)\ndef istype(objOrType):\n    \'\'\' \n    `isinstance(objOrType, type)` for compatibility both python 2/3\n    \'\'\'\n    return isinstance(objOrType, (type, classobj))\n\n\ndef setFunction2ForAutoList():\n    \'\'\'\n    add function \'range2\', \'map2\', \'reduce2\', \'zip2\' that retrun a list like python2\n    \'\'\'\n    funForAutoList = [\'range\', \'map\', \'reduce\', \'filter\', \'zip\', \'enumerate\']\n    if py2:\n        addListAfter = lambda x:x\n    else:    \n        def addListAfter(f):\n            @wraps(f)\n            def innerF(*l, **kv):\n                r = f(*l, **kv)\n                return list(r)\n            return innerF\n    reduce\n    glob = globals()\n    for name in funForAutoList:\n        rawf = glob[name] if name in glob else  __builtins__[name]\n        glob[name+\'2\'] = addListAfter(rawf)\n\nsetFunction2ForAutoList()\n\n\ndef __setDisplayEnv():\n    msg = \'\'\'%s\n        os.environ[""DISPLAY""] not found, may cuse error like this \n        [QXcbConnection Error](https://github.com/ipython/ipython/issues/10627)\n        so, we auto set os.environ[""QT_QPA_PLATFORM""] = ""offscreen""    \'\'\'%\'\\x1b[36m%s\\x1b[0m\'% \'warning from boxx\'\n    msg = \'\'\'os.environ[""DISPLAY""] is not found\n    plt.show() are redirect to plt.savefig(tmp)\n    function: show, loga, crun, heatmap, plot will be affected\'\'\'\n    \n    from .tool import warn\n    warn(msg)\n    os.environ[""QT_QPA_PLATFORM""] = ""offscreen""\n    os.environ[\'DISPLAY\'] = \':0\'\n    \ndef __noDisplayEnv():\n    __setDisplayEnv()\n    import matplotlib.pyplot as plt\n    def savefig(*l, **kv):\n        from .ylsys import tmpboxx\n        from .tool import increase, warn, OffScreenWarning\n        showtmp = os.path.join(tmpboxx(), \'showtmp\')\n        if not os.path.isdir(showtmp):\n            os.makedirs(showtmp, exist_ok=True)\n        png = os.path.join(showtmp,\'%d_show.png\'%increase(\'showtmp\'))\n        warn(\'\'\'os.environ[""DISPLAY""] is not found\n    plt.show() are redirect to plt.savefig(""%s"")\'\'\'%png, OffScreenWarning)\n        plt.savefig(png)\n        plt.cla()\n        plt.clf()\n#    pltshow = plt.show\n    plt.show = savefig\ndef beforImportPlt():\n    \'\'\'\n    cause `import matplotlib.pyplot` often lead to Exit Error\n    I do `import plt` when function need, this would avoid exit error.\n    if os.environ[""DISPLAY""] is not found, then  we auto set os.environ[""QT_QPA_PLATFORM""] = ""offscreen""\n    and plt.show() are redirect to plt.savefig(\'/tmp/boxxTmp/showtmp\')\n    \n    Farther more, if pyi.gui is False, the plt.show() are replace to plt.savefig(\'/tmp/boxxTmp/showtmp\')\n    \'\'\'\n    if not pyi.plt and not pyi.reloadplt:\n        __noDisplayEnv()\n        import matplotlib.pyplot as plt\n#        import seaborn\n        pyi.reloadplt = plt\n\nclass SetPltActivateInWith():\n    \'\'\'\n    set plt to interactivate mode while use plt.show() inner boxx\n    \'\'\'\n    def __enter__(self):\n        if pyi.gui or not pyi.plt:\n            return \n        import matplotlib.pyplot as plt\n        self.interactivePlot = plt.rcParams[\'interactive\']\n        if not self.interactivePlot and pyi.interactive:\n            plt.ion()\n    def __exit__(self, *l):\n        if pyi.gui or not pyi.plt:\n            return \n        import matplotlib.pyplot as plt\n        if not self.interactivePlot and pyi.interactive:\n            plt.ioff()\n    \ndef interactivePlot(fun):\n    \'\'\'\n    turn interactive plot mode if enviroment is interactive\n    \'\'\'\n    @wraps(fun)\n    def innerf(*l, **kv):\n        beforImportPlt()\n        with SetPltActivateInWith():\n            r = fun(*l, **kv)\n        return r\n    return innerf\n\nif py2:\n    execfile = builtins.execfile\nelse:\n    def execfile(filename, globals=None, locals=None):\n        \'\'\'\n        same usage as python2 execfile\n        \'\'\'\n        frame = sys._getframe(1)\n        if globals is None:\n            globals = frame.f_globals\n        if locals is None:\n            locals = frame.f_locals\n        with open(filename) as f:\n            code = f.read()\n        exec(code, globals, locals)\n\ndef runpyfile(filename, main=True, globals=None, locals=None):\n    \'\'\'\n    add __file__ and __name__ to globals then runpyfile\n    like runfile in spyder \n    \'\'\'\n    default = {\n            \'__file__\':os.path.abspath(filename),\n            \'__name__\':main and \'__main__\',\n            }\n    if globals is None:\n        globals = {}\n    if locals is None:\n        locals = {}\n    default.update(globals)\n    with open(filename) as f:\n        code = f.read()\n    exec(code, default, locals)\n\ntry:\n    ModuleNotFoundError = ModuleNotFoundError\nexcept NameError:\n    ModuleNotFoundError = ImportError\n\nif not py2 and 0:\n    __rawOpen__ = open\n    open = lambda *l:__rawOpen__(l[0],\'r\',-1,\'utf8\') if len(l) == 1 else __rawOpen__(l[0],l[1],-1,\'utf8\')\n\n'"
boxx/yllab.py,0,"b""# -*- coding: utf-8 -*-\nfrom .tool import *\nfrom .ylimg import *\nfrom .ylml import *\nfrom .ylnp import *\nfrom . import tool\nfrom . import ylimg\nfrom . import ylml\nfrom . import ylnp\n\n\nif __name__ == '__main__':\n    \n    pass\n\n"""
boxx/ylsys.py,0,"b'#!/usr/bin/env python2\n# -*- coding: utf-8 -*-\n""""""\nA module provide system info and Python Info for boxx\n\n@author: yanglei\n""""""\n\nimport sys, os\nfrom os import environ\n\ndef jupyterNotebookOrQtConsole():\n    env = \'Unknow\'\n    cmd = \'ps -ef\'\n    try:\n        with os.popen(cmd) as stream:\n            if not py2:\n                stream = stream._stream\n            s = stream.read()\n        pid = os.getpid()\n        ls = list(filter(lambda l:\'jupyter\' in l and str(pid) in l.split(\' \'), s.split(\'\\n\')))\n        if len(ls) == 1:\n            l = ls[0]\n            import re\n            pa = re.compile(r\'kernel-([-a-z0-9]*)\\.json\')\n            rs = pa.findall(l)\n            if len(rs):\n                r = rs[0]\n                if len(r)<12:\n                    env = \'qtipython\'\n                else :\n                    env = \'jn\'\n        return env\n    except:\n        return env\n    print(r, env)\n\npyv = sys.version_info.major\npy3 = (pyv == 3)\npy2 = (pyv == 2)\n\n\nlinuxYl = sys.platform.startswith(\'linux\')\nwinYl = sys.platform.startswith(\'win\')\nosxYl = sys.platform.startswith(\'darwin\')\n\nimport multiprocessing as __module\ncpun = __module.cpu_count()\n\ncloud = cpun > 8\n\nif linuxYl or osxYl:\n    cuda = not os.system(\'nvidia-smi> /dev/null 2>&1\')\nelif winYl:\n    import subprocess\n    try:\n        cuda = not subprocess.call(\'nvidia-smi\', creationflags=0x00000008)\n    except FileNotFoundError:\n        cuda = False\nusecuda = \'auto\' # auto: auto, False: not use\n    \nif linuxYl or osxYl:\n    homeYl = os.getenv(\'HOME\') + \'/\'\n    tmpYl = \'/tmp/\'\nelif winYl:\n    homeYl = os.path.expanduser(""~"")\n    tmpYl = os.getenv(\'TMP\') + \'\\\\\'\n\nclass __TmpboxxWithCall(str):\n    \'\'\'\n    the tmp dir for boxx \n    use tmpboxx() to get tmpdir \n    use tmpboxx({dirname}) to get tmpdir/{dirname}\n    if not exist then will auto mkdir of boxxTmp in `/tmp`\n    \'\'\'\n    def __call__(self, dirName=None):\n        dirr = os.path.join(self, dirName) if dirName else self\n        \n        if not os.path.isdir(dirr):\n            os.makedirs(dirr, exist_ok=True)\n        return dirr\ntmpboxx = __TmpboxxWithCall(os.path.join(tmpYl,\'boxxTmp/\'))\n\nclass PythonInfo():\n    \'\'\'\n    python info\n    \n    plt : Bool\n        mean plt avaliable\n    env :\n        belong [cmd, cmdipython, qtipython, spyder, jn]\n    \'\'\'\n    pid = os.getpid()\n    gui = \'ipykernel\' in sys.modules\n    cmdipython = \'IPython\' in sys.modules and not gui\n    ipython = cmdipython or gui\n    spyder = \'spyder\' in sys.modules\n    if gui:\n        env = \'spyder\' if spyder else jupyterNotebookOrQtConsole()\n    else:\n        env = \'cmdipython\' if ipython else \'cmd\'\n    \n    cmd = not ipython\n    qtipython = env == \'qtipython\'\n    jn = env == \'jn\'\n    \n    interactive = bool(getattr(sys, \'ps1\', sys.flags.interactive))\n    \n    plt = True\n    if not gui and linuxYl and \'DISPLAY\' not in os.environ :\n        plt =  False\n    reloadplt = False\n    def __str__(self):\n        from boxx import strMethodForDiraAttrs\n        return strMethodForDiraAttrs(self)\n    __repr__ = __str__\npyi = PythonInfo()\n\nclass SystemInfo():\n    \'\'\'\n    sys info\n    \'\'\'\n    pyv = pyv\n    cpun = cpun\n    cuda = cuda\n    tmp = tmpYl\n    \n    linux = linuxYl\n    win = winYl\n    osx = osxYl\n    \n    os = sys.platform\n    display = True\n    if linuxYl:\n        display = \'DISPLAY\' in environ and environ[\'DISPLAY\']\n        from os.path import expanduser\n        home = expanduser(\'~\')\n    gui = pyi.gui or display\n    if 0:\n        @property\n        def ip(self):\n            \'\'\'\n            TODO:\n            \'\'\'\n            return \'127.0.0.1\'\n    @property\n    def user(self):\n        import getpass\n        return getpass.getuser()\n    @property\n    def host(self):\n        import platform\n        return platform.node()\n    def __str__(self):\n        from boxx import strMethodForDiraAttrs\n        return strMethodForDiraAttrs(self)\n    __repr__ = __str__\nsysi = SystemInfo()\n'"
boxx/ylweb.py,0,"b""# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\n\nclass dictToObj(dict):\n    '''\n    \xe5\xb0\x86dic\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba\xe5\x8f\xaf\xe4\xbb\xa5\xe7\x94\xa8dic\xe6\xa8\xa1\xe5\xbc\x8f\xe8\xae\xbf\xe9\x97\xae\xe7\x9a\x84obj\n    '''\n    def __init__(self, dic):\n        dict.__init__(self)\n#        self.dic = dic\n        for k,v in list(dic.items()):\n            setattr(self,k,v)\n    def __getitem__(self,k):\n        return getattr(self,k)\n    def __setitem__(self,k,v):\n        return setattr(self,k,v)\n\n\n\n\n\n\n"""
other/generate_table_of_contents_for_ipynb.py,0,"b""#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nfrom boxx import *\nimport json\nipynb = json.loads(openread('../tutorial_for_boxx.ipynb'))\n\nfirstLines = [d['source'][0] for d in ipynb['cells'] \n            if d['cell_type'] == 'markdown' and len(d['source'])]\nheads = filter2(lambda x:x.strip().startswith('##') and x.strip()[3] != '#' \n                , firstLines)\n\nmd = '''\n<!-- START `./other/generate_table_of_contents_for_ipynb.py` generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN `./other/generate_table_of_contents_for_ipynb.py` TO UPDATE -->\n\n<h2>Table of Contents</h2>\n'''\nfor h in heads:\n    if h[-1] == '\\n':\n        h = h[:-1]\n    if '### ' in h:\n        bais = 4\n    elif '## ' in h:\n        bais = 3\n    s = h[h.index('#') + bais:]\n    href = s.replace('`', '').replace(' ', '-')\n    mds = '[%s](#%s)\\n'%(s, href)\n#    if ')' in href:\n#        mds = s+'\\n'\n    md += (bais-2)*'  ' + '- ' + mds\n    \nimport markdown2\nhtml = markdown2.markdown(md) \nhtml = html.replace('&lt;','<').replace('&gt;','>')\nprint(html)\n"""
test/testAll.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\nCreated on Wed May  9 00:55:51 2018\n\n@author: leiYang\n""""""\nfrom __future__ import unicode_literals, print_function\n\n#what-\nfrom boxx import *\nimport boxx\ntest = True\ntest = False\nif test:\n    from toolTest import *\n    \n    from ylimgTest import *\n    \n    from ylmlTest import *\n\npattern = \'TODO\'\nfindinRoot(pattern,root=\'..\')\n#findinRoot(up=pattern,root=\'..\')\n#replaceAllInRoot(pattern,\'Function\',root=\'..\')\n\n\nif __name__ == \'__main__0\':\n    pass\n    from boxx.ylth import *\n    \n    def f(self,*l, **kv):\n        init = self.__init__\n        code = init.__code__\n        ca = code.co_argcount\n        cv = code.co_varnames\n#        type(self)()\n        \n#        log-prettyFrameStack()\n        frames = getFatherFrames(1)\n        for f in frames:\n            log-f.f_code.co_name\n            if f.f_code.co_name != \'__init__\':\n                break\n            loc = f.f_locals\n#        tree-loc\n        args = {k:loc[k] for k in cv}\n        tree-args\n        rawModuleInit(self)\n#        out()\n#        g.f = frames = getFatherFrames()\n#        p/map2(lambda f:f.f_locals.get(\'self\'),frames[::])\n#        tree-locals()\n    nn.Module.__init__\n    \n#    class nnModule(nn.Module):\n#        def __init__(self, *l, **kv):\n#            log-prettyFrameStack()\n    if \'__init__\' in str(nn.Module.__init__):\n        rawModuleInit = nn.Module.__init__\n    nn.Module.__init__ = f\n#        nn.Module = nnModule\n#    conv = nn.Conv2d(1,2,(3,3))\n    class Mo(nn.Module):\n        def __init__(self,b=\'b\',**l):\n            super(Mo, self).__init__()\n    a= Mo(\'a\')\n    \n#    what- a.__init__.__code__\n\n\n    fs=g.f\n\n\n'"
test/toolTest.py,0,"b'# -*- coding: utf-8 -*-\nfrom boxx import *\nfrom boxx.tool.toolSystem import *\n\'\'\'\n\xe4\xbd\xbf\xe7\x94\xa8`ifTest([funName]) or 0:`\xe6\x9d\xa5\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe6\x89\xa7\xe8\xa1\x8c\xe6\xb5\x8b\xe8\xaf\x95\n\xe8\xbf\x99\xe6\xa0\xb7 \xe5\x9c\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8iPython \xe6\x9f\xa5\xe7\x9c\x8b\xe6\xaf\x8f\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8f\x98\xe9\x87\x8f\n\'\'\'\ndef ifTest(fun):\n    shouldTest = fun is tests or (isinstance(tests,list) and fun in tests) or TEST_ALL \n    if shouldTest:\n        try:\n            pred(\'Test:\'+ fun.__name__);log(\'Type:\'+ str(type(fun)))\n            log(\'Doc :\'+ fun.__doc__)\n        except Exception:\n            pass\n    return shouldTest\n\nTEST_ALL = True\n#TEST_ALL = False\n \n\ntestFun = None\n\ntests = [testFun]\ndf=pd.DataFrame([{\'a\':5,\'b\':3},{1:1}]*20)\n    \n\n#tests = gg    \nif ifTest(gg):\n    def funForWgg():\n        with gg:\n            ia = 517\n            ib = 222\n    funForWgg()\n    \n#tests = withattr    \nif ifTest(withattr):\n    with withattr(dict(), {\'attr\':1}) as d:\n        assert (d[\'attr\'] == 1)\n    assert \'attr\' not in d\n\n#tests = getArgvDic    \nif ifTest(getArgvDic):    \n    argv = [\'toolTest.py\', \n    \'--name\', \'name\', \n    \'--lr\', \'.23\',\n    \'--resume\', \'21\',\n    \'--posi\',\'-50\',\n    \'--pf\',\'-6.98\',]\n    argv = [\'toolTest.py\', \n            \'name.config\', \n            \'abc\',\n    \'--lr\', \'.23\',\n    \'--resume\', \n    \'--pf\',\'-6.98\',\n    \'--posi\',]\n    getArgvDic(argv)\n\n\n#tests = heatmap    \nif ifTest(heatmap):    \n    code = \'\'\'\nn=1000\nb=map(pow,range(n),range(n))\nc=map(divmod,b,b)\n    \'\'\'\n    heatmap(code)\n#    heatmap(\'ylimgTest.py\')\n    \n#tests = listdirWithFun\nif ifTest(listdirWithFun): \n    def f(path):\n        if \'.py\' not in path:\n            log(path)\n    listdirWithFun(root=\'..\',fun=f)\n\ndef logr(s):\n    sys.stdout.flush()\n    log(\'\\r%s\'%s, end=\' \')\n#tests = logr\nif ifTest(logr): \n    n=5\n    for i in range(n):\n        logr(\'%s [%s>%s]\'%(i,\'=\'*(i+1),\' \'*(n-i-1)))\n        time.sleep(.2)\n        \n#tests = multiThread\nif ifTest(multiThread) and __name__ == \'__main__\': \n    mt = multiThread(5)\n    def f(i):\n        time.sleep(.01)\n#        if i==20:\n#            raise Exception,\'test\'\n        log(\'%d \'%i, end=\' \')\n    for i in range(100):\n        mt(f,i)\n    pred(\'[fanished befor join]\')\n    mt.join()\n    pred(\'[fanished after join]\')\n    l=[]\n    def ff(i):\n#        if i==4:\n#            raise Exception,\'test ff\'\n        l.append(i)\n        time.sleep(.1)\n    for i in range(12):\n        mt(ff,i)\n    l.append(\'b\')\n    mt.join()\n    l.append(\'a\')\n    print(l)\n    \n\n#tests = mapmp\nif ifTest(mapmp): \n    def npt(rr):\n        for i in range(int(4e3)):\n            rr = abs(rr**0.9-rr)\n        return rr.sum()\n    n = 10\n    rrs = [np.float64(randomm(20,90)) for i in range(n)]\n    ms = {\'map\':map,\'mapmt\':mapmt,}\n    if __name__ == \'__main__\':\n        ms.update({\'mapmp\':mapmp})\n        for name,mapp in list(ms.items()):\n            with timeit():\n                list(mapp(npt,rrs))\n                log(name, end=\' \')\n\n#tests = dira\nif ifTest(dira): \n    import pandas\n    dira(tool, pattern=""^[A-Z]"")\n    dira(pandas.DataFrame(), pattern=""^[A-Z]"")\n    dira(dicto(a=5,b=6), pattern=""^va"")\n    class A:\n        d = [0,{\'k\':\'v\'}]\n        pass\n    what(A)\n\n#tests = pipe\n#if ifTest(pipe):\n    funList = [lambda x:x+\'[f1]\',lambda x:x+\'[f2]\',lambda x:x+\'[f3]\']\n    do = pipe(funList)\n    print((do(\'start\')))\n\n#tests = [wp, p]\nif ifTest(wp):\n    def fff( a=5):\n        inf = 6\n        p()\n#        log-prettyFrameLocation(4)\n    def ff():\n        with wp:\n            fff()\n            fout=0\n            with wp:\n                fin = 1\n    ff()\n\n#tests = [wp, p]\nif ifTest(p):\n    def fff(argfff=55):\n        inf = 66\n        out()\n    def ff():\n        fff()\n    ff()\n    \n\n#tests = strnum\nif ifTest(strnum):\n    tree-[strnum(i) for i in (0., 1, .99, 100., e*1e9,-pi*1e-9,)]\n    tree-[percentStr(i) for i in (0., 1.,  e/10, pi)]\n\n#tests = getExcept\nif ifTest(getExcept):\n    re = getExcept(lambda x=1:1/0)\n    assert re[-1].f_locals.get(\'x\') == 1\nif __name__ == \'__main__\':\n    pass\n\n'"
test/yldbTest.py,0,"b""# -*- coding: utf-8 -*-\nfrom boxx.yldb import *\n\n'''\n\xe4\xbd\xbf\xe7\x94\xa8`ifTest([funName]) or 0:`\xe6\x9d\xa5\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe6\x89\xa7\xe8\xa1\x8c\xe6\xb5\x8b\xe8\xaf\x95\n\xe8\xbf\x99\xe6\xa0\xb7 \xe5\x9c\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8iPython \xe6\x9f\xa5\xe7\x9c\x8b\xe6\xaf\x8f\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8f\x98\xe9\x87\x8f\n'''\ndef ifTest(fun):\n    shouldTest = fun is tests or (isinstance(tests,list) and fun in tests) or TEST_ALL \n    if shouldTest:\n        try:\n            pred('Test:'+ fun.__name__);log('Type:'+ str(type(fun)))\n            log('Doc :'+ fun.__doc__)\n        except Exception:\n            pass\n    return shouldTest\n\nTEST_ALL = True\nTEST_ALL = False\n\n\ntestFun = None\n\ntests = [testFun]\n\n#tests = GenSimg    \nif ifTest(Evalu) or 0:\n    \n    pass\n\n\nif __name__ == '__main__':\n\n    pass\n\n\n\n\n"""
test/ylimgTest.py,0,"b""# -*- coding: utf-8 -*-\nfrom boxx.ylimg.ylimgTool import *\nfrom boxx.ylimg.ylimgVideoAndGif import *\nfrom boxx import *\n'''\n\xe4\xbd\xbf\xe7\x94\xa8`ifTest([funName]) or 0:`\xe6\x9d\xa5\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe6\x89\xa7\xe8\xa1\x8c\xe6\xb5\x8b\xe8\xaf\x95\n\xe8\xbf\x99\xe6\xa0\xb7 \xe5\x9c\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8iPython \xe6\x9f\xa5\xe7\x9c\x8b\xe6\xaf\x8f\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8f\x98\xe9\x87\x8f\n'''\ndirr = dirname(__file__)\nimgGlob = pathjoin(dirr,'imgForTest/*')\n#imgGlob = ''\njpg,png= pathjoin(dirr,'imgForTest/img.jpg'), pathjoin(dirr,'imgForTest/gt_seg.png')\nimg,gt = imread(jpg),imread(png)\ngt = gt>0\nre = gt.copy()\n# \xe5\xa4\x9a\xe5\x88\x86\xe7\xb1\xbb\xe6\x95\xb0\xe6\x8d\xae\ngtm = np.zeros(img.shape[:2],img.dtype)\ngtm[gt>.5] =1 \ngtm[15:55] = 2\ngtm[250:265] = 3\nrem = gtm.copy()\nrem[:,10:50] = 0\nrem[:,100:150] = 1\nrem[:,200:250] = 2\nrem[:,300:350] = 3\ncolors = npa([[.5,.5,.5],[1,0,0],[0,1,0],[0,0,1],])\nrec,gtc = (labelToColor(rem,colors),labelToColor(gtm,colors))\n\ndef ifTest(fun):\n    shouldTest = fun is tests or (isinstance(tests,list) and fun in tests) or TEST_ALL \n    if shouldTest:\n        try:\n            pred('Test:'+ fun.__name__);log('Type:'+ str(type(fun)))\n            log('Doc :'+ fun.__doc__)\n        except Exception:\n            pass\n    return shouldTest\n\nTEST_ALL = True\n#TEST_ALL = False\n\ntestFun = None\ntests = [testFun]\n\n#tests = generateBigImgForPaper\nif ifTest(generateBigImgForPaper) and 0:\n    gtmod = classDiff(rem,gtm,colors)\n    remod = classDiff(rem,gtm,colors,reMod=True)\n    remn,gtmn = list(map(normalizing,(rem,gtm)))\n    imgMa = ((gt,remn,gtmn,remn,),\n            (re,rec,gtc,rec,),\n            (img,gtmod,remod,gtmod,))\n    generateBigImgForPaper(imgMa,lengh=1980,border=20,saveName='')\n\n#tests = ndarrayToImgLists\nif ifTest(ndarrayToImgLists):\n    re = npa-[[gt,gt],[gt,gt]]\n    tree(ndarrayToImgLists(re))\n    gt = img\n    re = npa-[[gt,gt],[gt,gt]]\n    tree(ndarrayToImgLists(re))\n    tree(ndarrayToImgLists(gt))\n    \n#tests = show\nif ifTest(show):\n    re = [{1:rec,2:gtc},\n          [(gt,)],\n          [img,gt],\n          gt,gtm\n          ]\n    show(re)\n    \ntests = loga\nif ifTest(loga):\n#    loga([(np.inf,5,7,np.nan)]*10)\n    loga([(np.inf,np.nan)]*10)\n    loga(npa-[r]*30+r**2.2+[nan,inf,0,0])\n#tests = tree\nif ifTest(tree):\n    re = [{'a':1,'b':3},\n          [],\n          [5,6,(gt,'string! ^_^')],\n          [img,gt],\n          gt,\n          ]\n    se = re   \n    tree(se)\n\n\n\n#tests = treem\nif ifTest(treem):\n    import boxx\n    treem(os,[type],2)\n#tests = shows\nif ifTest(shows):\n#    shows(jpg,png,rec,gtc)\n    shows(jpg,png,rec,gtc,rem*5,gtm*5)\n    \n#tests = getShapes\nif ifTest(getShapes) and len(glob(imgGlob)):\n    if __name__ == '__main__':\n        with timeit():\n            shapes = getShapes(imgGlob)\n        \n#tests = autoSegmentWholeImg\nif ifTest(autoSegmentWholeImg):\n    img = sda.astronaut()\n    hh,ww = 256,256\n    hh,ww = 128,128\n    resoult = autoSegmentWholeImg(img,(hh,ww),lambda x:x.mean(2)*getWeightCore(hh,ww),\n                                  step=100,weightCore='gauss')\n    show(resoult)\n\n#tests = plot3dSurface\nif ifTest(plot3dSurface):\n    with timeit():\n        hh,ww = 256,256\n        print('seta=2\xe9\xab\x98\xe6\x96\xaf\xe5\x88\x86\xe5\xb8\x83')\n        core = getWeightCore(hh,ww,seta=2)\n        plot3dSurface(core)\n        print('\xe8\xb7\x9d\xe7\xa6\xbb\xe5\x88\x86\xe5\xb8\x83')\n        core = getWeightCore(hh,ww,lambda i,j:((i*1./hh-.5)**2+(j*1./ww-.5)**2)**.5)\n        plot3dSurface(core)\n        \n#tests = labelToColor\nif ifTest(labelToColor):\n    show(rem,labelToColor(rem,includeBackGround=1))\n    \n#tests = getDefaultColorList\nif ifTest(getDefaultColorList):\n    toi = lambda p:(npa([[p]*4]*4))*1.\n    colorNum=3\n    includeBackGround=-1\n    colors = getDefaultColorList(colorNum,includeBackGround)\n    print(colorNum,len(colors))\n    show -list(map(toi,colors))\nif __name__ == '__main__':\n    pass\n\n\n\n\n"""
test/ylmlTest.py,0,"b""# -*- coding: utf-8 -*-\nfrom boxx import *\n'''\n\xe4\xbd\xbf\xe7\x94\xa8`ifTest([funName]):`\xe6\x9d\xa5\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe6\x89\xa7\xe8\xa1\x8c\xe6\xb5\x8b\xe8\xaf\x95\n\xe8\xbf\x99\xe6\xa0\xb7 \xe5\x9c\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8iPython \xe6\x9f\xa5\xe7\x9c\x8b\xe6\xaf\x8f\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8f\x98\xe9\x87\x8f\n'''\nimg,gt = imread(pathjoin(dirname(__file__),'imgForTest/img.jpg')),imread(pathjoin(dirname(__file__),'imgForTest/gt_seg.png'))\ngt = gt>0\n# \xe5\xa4\x9a\xe5\x88\x86\xe7\xb1\xbb\xe6\x95\xb0\xe6\x8d\xae\ngtm = np.zeros(img.shape[:2],img.dtype)\ngtm[gt>.5] =1 \ngtm[15:55] = 2\ngtm[250:265] = 3\nrem = gtm.copy()\nrem[:,10:50] = 0\nrem[:,100:150] = 1\nrem[:,200:250] = 2\nrem[:,300:350] = 3\ncolors = npa([[.5,.5,.5],[1,0,0],[0,1,0],[0,0,1],])\nrec,gtc = (labelToColor(rem,colors),labelToColor(gtm,colors))\n\ndef ifTest(fun):\n    shouldTest = fun is tests or (isinstance(tests,list) and fun in tests) or TEST_ALL \n    if shouldTest:\n        try:\n            pred('Test:'+ fun.__name__);log('Type:'+ str(type(fun)))\n            log('Doc :'+ fun.__doc__)\n        except Exception:\n            pass\n    return shouldTest\n\nTEST_ALL = True\n#TEST_ALL = False\n\ntestFun = None\ntests = [testFun]\n\n#tests = GenSimg\nif (ifTest(GenSimg)) and 0:\n    imgPath = 'G:\\\\experiment\\\\Data\\\\HKU-IS\\\\Imgs\\\\*.jpg'\n    imggts = [(jpg,jpg.replace('.jpg','.png')) for jpg in  glob(imgPath)[:180]]\n    simgShape = (100,100)\n    cache = 6;batch = 3\n    gen = GenSimg(imggts,simgShape,cache=cache,batch=batch)\n    n=len(list(gen))\n    print('\xe5\xae\x9e\xe9\x99\x85\xe7\x9a\x84\xe9\x9d\xa2\xe7\xa7\xaf\xe6\xaf\x94\xe5\x80\xbc%d*%d=%d'%(n,batch,n*batch),'\xe8\xae\xa1\xe7\xae\x97\xe7\x9a\x84\xe4\xb8\x80\xe8\xbd\xae\xe7\x9a\x84\xe6\x80\xbb\xe9\x9d\xa2\xe7\xa7\xaf\xe6\xaf\x94\xe5\x80\xbc', 300*400/1e4*len(imggts))\n    \n    batch = 12\n    gen = GenSimg(imggts,simgShape,cache=cache,batch=batch,timesPerRead=3)\n    n=len(list(gen))\n    print('timesPerRead=3\xe5\xae\x9e\xe9\x99\x85\xe7\x9a\x84\xe9\x9d\xa2\xe7\xa7\xaf\xe6\xaf\x94\xe5\x80\xbc%d*%d=%d'%(n,batch,n*batch),'\xe8\xae\xa1\xe7\xae\x97\xe7\x9a\x84\xe4\xb8\x80\xe8\xbd\xae\xe7\x9a\x84\xe6\x80\xbb\xe9\x9d\xa2\xe7\xa7\xaf\xe6\xaf\x94\xe5\x80\xbc', 300*400/1e4*len(imggts))\n    \n    genn = GenSimg(imggts,simgShape,cache=cache,batch=batch,timesPerRead=3,iters=300)\n    n=len(list(genn))\n    print('iter=300\xe5\xae\x9e\xe9\x99\x85\xe7\x9a\x84\xe9\x9d\xa2\xe7\xa7\xaf\xe6\xaf\x94\xe5\x80\xbc%d*%d=%d'%(n,batch,n*batch),'\xe8\xae\xa1\xe7\xae\x97\xe7\x9a\x84\xe4\xb8\x80\xe8\xbd\xae\xe7\x9a\x84\xe6\x80\xbb\xe9\x9d\xa2\xe7\xa7\xaf\xe6\xaf\x94\xe5\x80\xbc', 300)\n\n    print('''\xe6\xa3\x80\xe6\x9f\xa5\xe9\x9a\x8f\xe6\x9c\xba\xe6\x80\xa7''')\n    gen = GenSimg(imggts,simgShape,None,cache=2,batch=batch,iters=10)\n    for ne in gen:\n        show(ne[0])\n    print(gen)\n\n#tests = binaryDiff\nif ifTest(binaryDiff):\n    print('Tet binaryDiff')\n    re = gt.copy()\n    re[125:175] = 0\n    re[:,250:300] = 1\n    diff = binaryDiff(re,gt)\n    show(re,gt)\n    show(img,diff)\n\n\n#tests = drawBoundAndBackground\nif ifTest(drawBoundAndBackground):\n    imgg = drawBoundAndBackground(greyToRgb(gt*255).astype(np.uint8),gt,img,size=.5)\n    show(img,imgg)\n    print('Test skimage.segmentation.find_boundaries,mark_boundaries!')\n    from skimage.segmentation import find_boundaries,mark_boundaries\n    #gt = (80<img[...,0])*img[...,0]<100\n    #imgg = mark_boundaries(img,gt)\n    imgg = find_boundaries(gt,mode='inner',background=1)\n    show(img,imgg)\n\n \n#tests = classDiff\nif ifTest(classDiff):\n    gtmod = classDiff(rem,gtm,colors)\n    remod = classDiff(rem,gtm,colors,reMod=True)\n    show(gtm,rem)\n    show(gtc,rec)\n    show(gtmod,remod)\n    pass\n\n\n#tests = confusionMatrix\nif ifTest(confusionMatrix):\n    gt = npa-[[1, 1, 3, 0],\n           [0, 3, 0, 0],\n           [0, 1, 2, 2],\n           [2, 0, 2, 2]]\n    re= gt.copy()\n    re[0,0] = 0;classn = 4\n    print(confusionMatrix(re,gt,classn))\n\n\n\n\n\n#tests = f1Score\nif ifTest(f1Score):\n    gt = npa-[[1, 1, 3, 0],\n           [0, 3, 0, 0],\n           [0, 1, 2, 2],\n           [2, 0, 2, 2]]\n    re= gt.copy()\n    re[0,0] = 0;classn = 4\n    print('f1Score:',f1Score(re,gt,classn))\n\n\n\n\ntests = autoSegmentWholeImg\nif ifTest(autoSegmentWholeImg):\n    simgShape=(100,100)\n    core = getWeightCore(*simgShape)\n    step = .2\n    def f(img):\n        img=img/255.\n        return getWeightCore(*simgShape)[:,:,None]*img\n    re=autoSegmentWholeImg(img, simgShape, handleSimg=f, step=step, weightCore=None)\n    re2=autoSegmentWholeImg(img, simgShape, handleSimg=f, step=step, weightCore='gauss')\n    re3=autoSegmentWholeImg(img, simgShape, handleSimg=f, step=step, weightCore='avg')\n    show(img,re)\n    show(re2,re3)\nif __name__ == '__main__':\n    pass\n\n\n\n\n"""
boxx/tool/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nGeneral Python Tools for Debugging, Logging, Magic .etc\n\n@author: yanglei\n""""""\n\nfrom __future__ import unicode_literals\n\nimport os, sys, time\nfrom ..ylsys import py2\n\nfrom .toolLog import (stdout, log, logc, printt, PrintStrCollect, printToStr, logg, tounicode, tostrpy2,\n                      shortDiscrib, shortStr, discrib, getDoc, tabstr, ignoreWarning, LogException, \n                      LogLoopTime, SuperG, sg, g, mg, gg, cf, p, pp, lc, out)\nfrom .toolLog import colorFormat, clf, pblue, pred, pdanger, perr, pinfo, decolor\nfrom .toolLog import strnum, percentStr, notationScientifique\nfrom .toolLog import prettyClassFathers, prettyFrameLocation, prettyFrameStack, wp, wg, wgg\nfrom .toolLog import localTimeStr, gmtTimeStr, timeGap, timegap, logGap\n\nfrom .toolStructObj import (dicToObj, dicto, typeNameOf, typestr, strMethodForDiraAttrs, \n                            getfathers, getfather, generator, nextiter, listToBatch, \n                            sliceInt, sliceLimit, ll, FunAddMagicMethod, mf, fnone, addCall,\n                            setself, unfoldself, withfun, withattr, isinstancestr)\n\nfrom .toolIo import (getsize, getsizem, listdir, filename, relfile, openread, openwrite, validFilename,\n                    first_exist_dir, saveData, loadData, loadjson, savejson, fileJoinPath,  warn, \n                    replaceTabInPy, warn1time, BoxxException, BoxxWarning, OffScreenWarning,\n                    Except, excep, getExcept, browserOpen)\nsave_data = saveData\nload_data = loadData\n\nfrom .toolSystem import (crun, performance, timeit, heatmap, getArgvDic, \n                         softInPath, makedirs, execmd, addPathToSys)\nfrom .toolSystem import importAllFunCode, impt, inpkg, importByPath, tryImport, FakeModule, removeImportSelf,  removeimp\nfrom .toolSystem import getMainFrame, getRootFrame, getFatherFrames#, exceptionHook\n\nfrom .toolFunction import (getFunName, SaveArguments, dynamicWraps, setTimeout, pipe,\n                           setInterval, multiThread, mapmp, mapmt, maptry, retry)\n\nfrom .toolTools import (intround, increase, filterList, findints, randint, randfloat, randchoice,\n                       listdirWithFun, replaceAllInRoot, findinRoot, iscn, zipTar,\n                       camel2snake, snake2camel)\n\nfrom .toolMarkdown import Markdown\n\nfrom .toolGui import ter, nau\n\n# Compatible with previous `boxx.glob` and `glob module`\nimport glob as globModule\nglob = globModule.glob\nglob.__dict__.update(globModule.__dict__)\n\nfrom os.path import join as pathjoin\nfrom os.path import basename, isfile, isdir, dirname, abspath, expanduser\n\nfrom collections import namedtuple, defaultdict, Counter, OrderedDict\ndictd = defaultdict\nodict = OrderedDict\n\nfrom time import sleep\nfrom functools import reduce, wraps\nfrom operator import add, sub, mul\nif py2:\n    from operator import div\nelse :\n    from operator import truediv as div\nfrom fn import _ as x_\n# x = x_\n\nfrom functools import wraps\n\nif __name__ == ""__main__"":\n    pass'"
boxx/tool/toolFunction.py,0,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals, print_function\nimport time\n\nfrom ..ylsys import cpun, winYl\nfrom .toolStructObj import typestr\n\nfrom functools import reduce\n\ndef getFunName(fun):\n    \'\'\'\n    \xe8\x8e\xb7\xe5\xbe\x97\xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84\xe5\x90\x8d\xe7\xa7\xb0\n    \'\'\'\n    if \'__name__\' in dir(fun):\n        return fun.__name__\n    return \'[unkonw]\'\n\nclass SaveArguments:\n    """"""\n    Save Arguments in funcation and apply those arguments to fun\n    """"""\n    def __init__(self, *l, **kv):\n        self.l = l\n        self.kv = kv\n\n    def apply(self, function):\n        """"""\n        Apply the saved arguments to the function\n        """"""\n        return function(*self.l, **self.kv)\n\n    def __str__(self):\n        ls = "", "".join(map(str, self.l))\n        if len(self.l) and len(self.kv):\n            ls += "", ""\n        kvs = "", "".join([""%s=%s"" % (kv) for kv in self.kv.items()])\n        return ""SaveArguments(%s)"" % (ls + kvs)\n\n    __repr__ = __str__\n\ndef dynamicWraps(func):\n    \'\'\'\n    decorator \xe5\x8a\xa8\xe6\x80\x81\xe8\xa7\x84\xe5\x88\x92 \xe8\xa3\x85\xe9\xa5\xb0\xe5\x99\xa8\n    \'\'\'\n    cache={}\n    from functools import wraps\n    @wraps(func)\n    def wrap(*args,**kv):\n        key = args+tuple(sorted(kv.items())) if len(kv) else args\n        if key not in cache:\n            cache[key]=func(*args, **kv)\n        return cache[key]\n    return wrap\n\ndef pipe(*funList):\n    \'\'\'\n    \xe5\xb0\x86\xe4\xb8\x80\xe7\xbb\x84\xe5\x87\xbd\xe6\x95\xb0\xe7\xbb\x84\xe6\x88\x90\xe4\xb8\x80\xe4\xb8\xaa\xe7\xae\xa1\xe9\x81\x93\xe5\x87\xbd\xe6\x95\xb0\n    \n    Parameters\n    ----------\n    funList : Function or list of Function\n        \xe5\x87\xbd\xe6\x95\xb0list\n    \'\'\'\n    if len(funList) == 1 and  \'__iter__\' in dir(funList[0]):\n        funList = funList[0]\n    return reduce(lambda f1,f2:(lambda x:f2(f1(x))), funList, lambda x:x)\n    \ndef setTimeout(fun, t=0):\n    \'\'\'\n    same to setTimeout in JavaScript\n    \'\'\'\n    from threading import Timer\n    thread = Timer(t,fun)\n    thread.start()\n    return thread\n\ndef setInterval(fun, inter, maxTimes=None):\n    \'\'\'\n    same to setInterval in JavaScript\n    \'\'\'\n    maxTimes = [maxTimes]\n    def interFun(): \n        fun()\n        if maxTimes[0] is not None:\n            maxTimes[0] -= 1\n            if maxTimes[0] <= 0:\n                return \n        setTimeOut(interFun, inter)\n    interFun()\n\nfrom multiprocessing import Pool as PoolMp\nfrom multiprocessing.dummy import Pool as PoolThread\ndef __multiprocessingFun__(args):\n    \'\'\'\n    \xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b\xe4\xb8\x93\xe7\x94\xa8\n    \'\'\'\n    return args[0](*args[1:])\n\ndef __multiprocessLogFun__(args):\n    \'\'\'\n    \'\'\'\n    \n    fun, args, ind, lenn, logf = args\n    if ind is None:\n        return fun(*args)\n    from .toolLog import percentStr, shortStr\n    from .toolSystem import timeit\n    with timeit(None) as t:\n        re = fun(*args)\n    if logf:\n        logf([fun, args, ind, lenn, logf])\n    else:\n        print(\'%s/%s(%s) time: %s, args[0]: %s\'%(ind,lenn,isinstance(lenn, int) and percentStr(ind*1./lenn),t.s,shortStr(args[0])), end=\'\\n\')\n    return re\n\ndef mapmp(fun, *iterables, **kv):\n    \'\'\'\n    Map with Multi Processing\n    mapmp(fun, sequence[, sequence, ...], pool=None, thread=False)->list\n    \n    !Important, multi processing must do in `__name__ == \'__main__\'`\'s block \n    see more at https://docs.python.org/3/library/multiprocessing.html\n    \n    >>> mapmp(np.add, range(3), range(3), pool=3)\n    [0, 2, 4]\n    \n    \n    Parameters\n    ----------\n    fun : function\n        *mulit processing* only support`def` in globls() function can\'t be lambda and inner function \n        which will raise PicklingError: Can\'t pickle \n    *iterables : list \n        Make an iterator that computes the function using arguments from each of the iterables. \n        Stops when the shortest iterable is exhausted.\n    pool : int, default None\n        the number of Process or Threading\n        the default is the number of CPUs in the system\n        \xe8\xbf\x9b\xe7\xa8\x8b\xe6\x95\xb0\xe7\x9b\xae\xef\xbc\x8c\xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbaCPU\xe8\xbf\x9b\xe7\xa8\x8b\xe6\x95\xb0\n    printfreq : int or float, default None\n        short of `print frequent`, auto print program progress in `mapmt` and `mapmp`   \n        if `printfreq < 1` then `printfreq = len(iterables[0])*printfreq`\n        \xe6\x89\x93\xe5\x8d\xb0\xe8\xbf\x9b\xe5\xba\xa6\xe7\x9a\x84\xe9\xa2\x91\xe6\xac\xa1 \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\x8d\xe6\x89\x93\xe5\x8d\xb0\n    logf : function, default None\n        Hook Function For log , every printfreq\n        do logf([fun, args, ind, lenn, logf])\n    thread : bool, default False\n        \xe6\x98\xaf\xe5\x90\xa6\xe4\xbb\xa5*\xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b*\xe5\xbd\xa2\xe5\xbc\x8f\xe6\x9b\xbf\xe6\x8d\xa2\xe5\xa4\x9a\xe8\xbf\x9b\xe7\xa8\x8b\n\n    Notice\n    ----------\n    *  mapmp(fun, *iterables,pool=None, **kv) will raise Error in Python 2.7.13\n    * \xe5\xa4\x9a\xe8\xbf\x9b\xe7\xa8\x8b\xe4\xb8\xad \xe5\xbc\x82\xe5\xb8\xb8\xe6\x97\xa0\xe6\xb3\x95\xe7\xb2\xbe\xe7\xa1\xae\xe5\xae\x9a\xe4\xbd\x8d\n    * numpy\xe6\x93\x8d\xe4\xbd\x9c \xe7\x94\xb1\xe4\xba\x8e\xe6\x8c\x87\xe4\xbb\xa4\xe9\x9b\x86\xe4\xbc\x98\xe5\x8c\x96 \xe5\x8f\x8anumpy\xe7\x89\x88\xe6\x9c\xac\xe5\x8e\x9f\xe5\x9b\xa0 \xe5\x8f\xaf\xe8\x83\xbd\xe5\xa4\x9a\xe8\xbf\x9b\xe7\xa8\x8b\xe5\x8f\xaf\xe8\x83\xbd\xe4\xbc\x9a\xe6\x9b\xb4\xe6\x85\xa2\n    * \xe5\xa4\x9a\xe8\xbf\x9b\xe7\xa8\x8b\xe4\xb8\xad list, dict\xe7\xad\x89\xe5\x85\x83\xe7\xb4\xa0\xe4\xbc\x9a\xe8\xa2\xab\xe7\x9b\xb4\xe6\x8e\xa5\xe5\xa4\x8d\xe5\x88\xb6\xef\xbc\x8c\xe6\x97\xa0\xe6\xb3\x95\xe6\x94\xb9\xe5\x8f\x98\xe5\x86\x85\xe9\x83\xa8\xe5\x85\x83\xe7\xb4\xa0\n    \'\'\'    \n    if winYl and not kv.get(\'thread\'):\n        from boxx import warn1time\n        warn1time(""""""detection your Platform is Windows,   multiprocessing maybe slower cause os.fork is disable.\nEven multiprocessing can\'t work on Windows sometimes"""""")\n    Pool = PoolMp\n    if \'thread\' in kv and kv[\'thread\']:\n        Pool = PoolThread\n    pool = Pool(kv[\'pool\']) if \'pool\' in kv and kv[\'pool\'] else Pool()\n    \n    pooln = kv[\'pool\'] if \'pool\' in kv else cpun\n    logf = kv[\'logf\'] if \'logf\' in kv else None\n    \n    iterables = list(iterables)\n    if \'printfreq\' in kv and kv[\'printfreq\']:\n        printfreq = kv[\'printfreq\']\n        l = iterables[-1] = list(iterables[-1])\n        lenn = len(l)\n        if printfreq < 1:\n            printfreq = int(round(lenn*printfreq))\n            printfreq = max(1, printfreq)\n        def yieldWithIndFun(fun, iterables, lenn, logf, printfreq):\n            for i,args in enumerate(zip(*iterables)):\n                yield (fun, args, None if i%printfreq else i, lenn, logf)\n        chunksize = kv[\'chunksize\'] if \'chunksize\' in kv else min(max(1, printfreq*2//3), lenn//pooln)\n        re = pool.map(__multiprocessLogFun__, yieldWithIndFun(fun, iterables, lenn, logf, printfreq), chunksize=chunksize)\n    else:\n        def yieldWithFun(fun, iterables):\n            for args in zip(*iterables):\n                yield (fun,)+args\n        re = pool.map(__multiprocessingFun__,  yieldWithFun(fun, iterables))\n    pool.close()\n    pool.join()\n    return re\n\ndef mapmt(fun, *mapArgList, **kv):\n    \'\'\'\n    Map with Multi Threading:\xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b\xe7\x89\x88\xe6\x9c\xac\xe7\x9a\x84map\xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8c \xe9\x80\x82\xe7\x94\xa8\xe4\xba\x8eIO\xe5\xaf\x86\xe9\x9b\x86\xe5\x9e\x8b\xe4\xbb\xbb\xe5\x8a\xa1\n    mapmt(fun, sequence[, sequence, ...], pool=None)->list\n    \n    >>> mapmt(np.add, range(3), range(3), pool=3)\n    [0, 2, 4]\n    \n    \n    Parameters\n    ----------\n    fun : function\n        \xe4\xb8\x8e map \xe4\xbd\xbf\xe7\x94\xa8\xe7\x9b\xb8\xe5\x90\x8c\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0 \n    *mapArgList : list \n        \xe7\x94\xa8\xe4\xba\x8efun\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0list, fun\xe9\x9c\x80\xe8\xa6\x81N\xe4\xb8\xaa\xe5\x8f\x82\xe6\x95\xb0\xe5\x88\x99\xe6\x9c\x89N\xe4\xb8\xaa\xe5\x88\x97\xe8\xa1\xa8\n    pool : int, default None\n        \xe7\xba\xbf\xe7\xa8\x8b\xe6\x95\xb0\xe7\x9b\xae\xef\xbc\x8c\xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbaCPU\xe8\xbf\x9b\xe7\xa8\x8b\xe6\x95\xb0\n    \'\'\'\n    return mapmp(fun, *mapArgList,thread=True, **kv)\n\ndef maptry(fun, *mapArgList, **kv):\n    \'\'\'\n    test spend time while use `map`, `mapmt`, `mapmp`\n    \'\'\'\n    from boxx import timeit, pblue\n    pblue(\'Begin test map!\')\n    with timeit(\'map2\'):\n        list(map(fun, *mapArgList))\n    with timeit(\'mapmt\'):\n        list(mapmt(fun, *mapArgList, **kv))\n    with timeit(\'mapmp\'):\n        list(mapmp(fun, *mapArgList, **kv))\n\n\nclass multiThread():\n    \'\'\'\n    \xe5\xb0\x86\xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b\xe5\xb0\x81\xe8\xa3\x85\xe6\x88\x90\xe4\xb8\xba\xe7\xb1\xbb\xe7\x9a\x84\xe5\xbd\xa2\xe5\xbc\x8f\n    \n    Example\n    ----------\n    >>> mt = multiThread(pool=8)\n    >>> for arg in args:\n            mt(f,*arg)\n    >>> mt.join()\n    \n    Init Parameters\n    ----------\n    pool : int, default 8\n        \xe7\xba\xbf\xe7\xa8\x8b\xe6\xb1\xa0\xe7\x9a\x84\xe6\x9c\x80\xe5\xa4\xa7\xe7\xba\xbf\xe7\xa8\x8b\xe6\x95\xb0\xe7\x9b\xae\n        \n    Method\n    ----------\n    __call__(fun,*l,**kv):\n        fun : \xe9\x9c\x80\xe8\xa6\x81\xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0 \n        *l,**kv : \xe4\xbc\xa0\xe7\xbb\x99\xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xe4\xbb\xac\n        \xe6\x96\xb0\xe5\xbb\xba\xe4\xb8\x80\xe4\xb8\xaa\xe7\xba\xbf\xe7\xa8\x8b \xe5\xb9\xb6\xe8\xbf\x90\xe8\xa1\x8cfun(*l,**kv)\n    join(): \n        \xe7\xad\x89\xe5\xbe\x85\xe8\x87\xb3\xe6\x89\x80\xe6\x9c\x89\xe7\xba\xbf\xe7\xa8\x8b\xe4\xb8\xad\xe6\xad\xa2\xe3\x80\x82\xe9\x98\xbb\xe5\xa1\x9e\xe4\xb8\xbb\xe7\xba\xbf\xe7\xa8\x8b\xe7\x9b\xb4\xe8\x87\xb3\xe6\xb2\xa1\xe6\x9c\x89\xe5\xad\x90\xe7\xba\xbf\xe7\xa8\x8b\xe8\xbf\x90\xe8\xa1\x8c\xe3\x80\x82 \n    \'\'\'\n    TIME_GAP = .001\n    def __init__(self,pool=8):\n        self.pool = pool\n        self.left = pool\n        self.l=[]\n    def __call__(self,fun,*l,**kv):\n        while not self.left:\n            time.sleep(self.TIME_GAP)\n        self.left -=1\n        def f():\n            try:\n                r = fun(*l,**kv)\n            finally:\n                self.left += 1\n        self.l.append(setTimeOut(f))\n        if len(self.l)>100:\n            self.l = self.l[-90:]\n    f = lambda fun,*l,**kv:fun(*l,**kv) #\xe7\x94\xa8\xe4\xba\x8e\xe6\xb5\x8b\xe8\xaf\x95\xe5\x8d\x95\xe7\xba\xbf\xe7\xa8\x8b\xe7\x9a\x84\xe6\x80\xa7\xe8\x83\xbd\n    def join(self):\n        while self.left!=self.pool:\n            time.sleep(self.TIME_GAP)\n#        print(\'pool\',self.pool)\n\ndef retry(fun, times=None, exception=Exception, timeGap=0, log=True):\n    \'\'\'\n    \xe9\x87\x8d\xe8\xaf\x95\xe4\xb8\x80\xe4\xb8\xaa\xe5\xae\xb9\xe6\x98\x93raise Exception\xe7\x9a\x84\xe6\x97\xa0\xe5\x8f\x82\xe6\x95\xb0\xe5\x87\xbd\xe6\x95\xb0fun times\xe6\xac\xa1\xe6\x95\xb0\xef\xbc\x8c\xe8\xa2\xab\xe6\x8d\x95\xe8\x8e\xb7\xe7\x9a\x84exception \xe4\xbf\x9d\xe5\xad\x98\xe5\x9c\xa8 retry.e \xe4\xb8\xad\n    \xe6\x9c\x80\xe5\x90\x8e\xe8\xbf\x94\xe5\x9b\x9e fun() \n    \n    Parameters\n    ----------\n    fun : function\n        \xe6\xb2\xa1\xe6\x9c\x89\xe5\x8f\x82\xe6\x95\xb0\xe7\x9a\x84\xe8\xbf\x87\xe7\xa8\x8b\xe5\x87\xbd\xe6\x95\xb0\n    times : int, default None\n        try \xe7\x9a\x84\xe6\xac\xa1\xe6\x95\xb0 \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba\xe6\x97\xa0\xe9\x99\x90\xe6\xac\xa1\n    exception : Exception Class, default builtins.Exception\n        \xe9\x9c\x80\xe8\xa6\x81\xe8\xa2\xab\xe6\x8d\x95\xe8\x8e\xb7\xe7\x9a\x84\xe5\xbc\x82\xe5\xb8\xb8\xef\xbc\x8c \xe9\xbb\x98\xe8\xae\xa4\xe6\x8d\x95\xe8\x8e\xb7\xe6\x89\x80\xe6\x9c\x89\xe5\xbc\x82\xe5\xb8\xb8 \n    timeGap : float, default 0\n        retry \xe9\x9c\x80\xe8\xa6\x81\xe7\xad\x89\xe5\xbe\x85\xe5\xa4\x9a\xe5\xb0\x91\xe7\xa7\x92\xe6\x97\xb6\xe9\x97\xb4\n    log : bool, default True\n        \xe6\x98\xaf\xe5\x90\xa6\xe6\x89\x93\xe5\x8d\xb0\xe9\x94\x99\xe8\xaf\xaf\xe4\xbf\xa1\xe6\x81\xaf    \n    Returns\n    -------\n    fun() : anything\n    \'\'\'\n    count = 0\n    while (True if times is None else times - 1):\n        try:\n            r = fun()\n            return r\n        except exception as e:\n            retry.e = e\n            if log:\n                fname = fun.__name__ if \'func_name\' in dir(fun) else str(fun)\n                print(((\'\\x1b[31m%s\\x1b[0m\'%""%dth\'s Exception: %s of %s"")%(count, typestr(e), fname)))\n                print(e)\n                print(\'\')\n        if timeGap:\n            time.sleep(timeGap)\n        if times is not None:\n            times -= 1    \n        count += 1\n    return fun()\n\nif __name__ == ""__main__"":\n    \n    def fun():\n        for i in range(10):\n            print(i)\n            time.sleep(1)\n    from threading import Timer\n    thread = Timer(0,fun)\n    thread.start()\n    pass'"
boxx/tool/toolGui.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\n@author: DIYer22@github\n@mail: ylxx@live.com\nCreated on Fri Jun 21 13:38:11 2019\n""""""\nfrom __future__ import unicode_literals\nimport os\n\nfrom .toolStructObj import FunAddMagicMethod\n\ndef startGnomeTerminal(dirr=None):\n    from ..ylsys import linuxYl\n    assert linuxYl\n    if dirr is None:\n        os.system(\'gnome-terminal \')\n    elif os.path.isfile(dirr):\n        os.system(\'gnome-terminal  --working-directory %s\'%os.path.abspath(os.path.dirname(dirr)))\n    else:\n        os.system(\'gnome-terminal  --working-directory %s\'%os.path.abspath(dirr))\n        \nter = FunAddMagicMethod(startGnomeTerminal)\n\n\ndef startNautilus(dirr=None):\n    from ..ylsys import linuxYl\n    assert linuxYl\n    if dirr is None:\n        os.system(\'nautilus .\')\n    elif os.path.isfile(dirr):\n        os.system(\'nautilus %s\'%os.path.dirname(dirr))\n    else:\n        os.system(\'nautilus %s\'%dirr)\nnau = FunAddMagicMethod(startNautilus)\n\n\nif __name__ == ""__main__"":\n    pass\n    \n    \n    \n'"
boxx/tool/toolIo.py,0,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\nimport os, sys\nimport warnings\nfrom functools import wraps\n\nfrom ..ylsys import py2, sysi\n\nclass BoxxException(Exception):\n    \'\'\'\n    root Exception for boxx\n    \'\'\'\n    pass\n\nclass BoxxWarning(Warning):\n    \'\'\'\n    root warninng for boxx\n    \'\'\'\n    pass\n\nclass OffScreenWarning(BoxxWarning):\n    pass\n\nclass Except():\n    \'\'\'\n    get traceback frame in with \n    \n    >>> with excep:\n    >>>     1/0\n    >>> dira(excep)\n    \'\'\'\n    def __init__(self, deep=0):\n        self.deep = deep\n    def __enter__(self):\n        pass\n    def __exit__(self, typee, value, traceback):\n        deep = self.deep\n        while deep:\n            deep -= 1\n            traceback = traceback.tb_next\n        self.type = typee\n        self.value = self.v = value\n        self.traceback = self.t = traceback\n        self.frame = self.f = traceback.tb_frame\nexcep = Except()\n\n\ndef getExcept(fun):\n    \'\'\'\n    exec `fun()` and return (Exception, trace, frame)\n    \'\'\'\n    try:\n        exc = Except(1) \n        with exc:\n            fun()\n    except Exception as ee:\n        e = ee\n        return e, exc.traceback, exc.frame\n    \ndef warn(msg, warnType=BoxxWarning, filename=None, line=None, module=\'boxx\', blue=False):\n    \'\'\'\n    log a warning of type warnType warn will auto fill filename and line \n    \'\'\'\n    msg = \'\'\'%s\n    %s\'\'\'%((\'\\x1b[36m%s\\x1b[0m\' if blue else \'%s\')% \'warning from boxx\', msg)\n    if filename is None or line is None:\n        f = sys._getframe(1)\n        c = f.f_code\n        filename = c.co_filename if filename is None else filename\n        line = c.co_firstlineno if line is None else line \n    warnings.warn_explicit(msg, warnType, filename, line, module)\n\nwarn1timeCache = {}\n@wraps(warn)\ndef warn1time(msg, *l, **kv):\n    \'\'\'\n    log a warning of type warnType warn will auto fill filename and line \n    \n    warn only one time\n    \'\'\'\n    if not warn1timeCache.get(msg):\n        warn(msg, *l, **kv)\n        warn1timeCache[msg] = True\n    \ngetsize = os.path.getsize\n\ndef getsizem(path=\'.\'):\n    \'\'\'\n    \xe8\xbf\x94\xe5\x9b\x9e path \xe7\x9a\x84\xe5\xa4\xa7\xe5\xb0\x8f \xe6\x94\xaf\xe6\x8c\x81\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xb9 \xe5\x8d\x95\xe4\xbd\x8d\xe4\xb8\xba MB\n    \'\'\'\n    if os.path.isdir(path):\n        return sum([getsizem(os.path.join(path, p)) for p in os.listdir(path)])\n    return os.path.getsize(path)/float(1024**2)\n\n\ndef fileJoinPath(_file_,path=\'.\'):\n    \'\'\'\n    \xe8\xbf\x94\xe5\x9b\x9e __file__ + \xe7\x9b\xb8\xe5\xaf\xb9\xe8\xb7\xaf\xe5\xbe\x84 path \xe5\x90\x8e\xe7\x9a\x84\xe7\xbb\x9d\xe5\xaf\xb9\xe8\xb7\xaf\xe5\xbe\x84\n    \'\'\'\n    from os.path import abspath,join,dirname\n    apath = abspath(join(dirname(abspath(_file_)),path))\n    return apath\n\ndef filename(path):\n    \'\'\'\n    \xe5\xb0\x86\xe8\xb7\xaf\xe5\xbe\x84\xe5\x92\x8c\xe5\x90\x8e\xe7\xbc\x80\xe5\x90\x8d\xe9\x99\xa4\xe5\x8e\xbb \xe5\x8f\xaa\xe7\x95\x99\xe4\xb8\x8b\xe6\x96\x87\xe4\xbb\xb6\xe5\x90\x8d\xe5\xad\x97\n    \'\'\'\n    filen = name = os.path.basename(path)\n    if \'.\' in name:\n        filen = name[:name.rindex(\'.\')]\n    return filen\n\ndef relfile(relative_path):\n    \'\'\'\n    Return a absolute version of a relative_path relative the __file__\n    \'\'\'\n    frame = sys._getframe(1)\n    if \'__file__\' not in frame.f_globals:\n        return relative_path\n    _file_ = frame.f_globals[\'__file__\']\n    abspath = os.path.abspath(os.path.join(_file_, \'..\', relative_path))\n    return abspath\n\ndef listdir(path=None):\n    path = path or \'.\'\n    return os.listdir(path)\n\ndef openread(path, encoding=\'utf-8\'):\n    \'\'\'\n    \xe8\xbf\x94\xe5\x9b\x9epath\xe6\x96\x87\xe4\xbb\xb6\xe7\x9a\x84\xe6\x96\x87\xe6\x9c\xac\xe5\x86\x85\xe5\xae\xb9\n    \'\'\'\n    if py2:\n        with open(path, \'r\') as f:\n            return f.read()\n    with open(path, \'r\', encoding=encoding) as f:\n        strr = f.read()\n    return strr\ndef openwrite(strr, path, mode=\'w\', encoding=\'utf-8\'):\n    \'\'\'\n    \xe5\xb0\x86strr\xe5\x86\x99\xe5\x85\xa5path\n    \'\'\'\n    if py2:\n        with open(path, mode) as f:\n            f.write(strr)\n        return path\n    with open(path, mode, encoding=encoding) as f:\n        f.write(strr)\n    return path\n\n\ndef validFilename(filename, replaceBy=\'_\'):\n    \'\'\'\n    return validate filename \n    \'\'\'\n    import re\n    if sysi.win:\n        rstr = r""[\\/\\\\\\:\\*\\?\\""\\<\\>\\|]""  # \'/ \\ : * ? "" < > |\'\n    else:\n        rstr = r""[\\/]"" # \' / \'\n    newName = re.sub(rstr, replaceBy, filename)\n    return newName\n\ndef first_exist_dir(*dirs):\n    """"""Input dirs and return the first exist dir.\n    If none dir exist, return First\n    """"""\n    if len(dirs) == 1 and isinstance(dirs[0], (list, tuple)):\n        dirs = dirs[0]\n    for dirr in dirs:\n        if os.path.isdir(dirr):\n            return dirr\n    return dirs[0]\n\ndef loadjson(path):\n    import json\n    with open(path, \'r\') as f:\n        js = json.load(f)\n    return js\n\ndef savejson(obj, path, indent=None):\n    import json\n    import numpy as np\n    \n    class NumpyEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, (np.ndarray, np.number)):\n                return obj.tolist()\n            return json.JSONEncoder.default(self, obj)\n    with open(path, \'w\') as f:\n        json.dump(obj, f, indent=indent, cls=NumpyEncoder)\n    return path \n    \ndef replaceTabInPy(dirr=\'.\'):\n    \'\'\'\n    \xe5\xb0\x86\xe6\x89\x80\xe6\x9c\x89tab\xe6\x8d\xa2\xe6\x88\x904\xe4\xb8\xaa\xe7\xa9\xba\xe6\xa0\xbc\n    \'\'\'\n    from glob import glob\n    from .toolLog import log\n    pys = glob(os.path.join(dirr, \'*.py\'))\n    for py in pys:\n        code = openread(py)\n        log(py,code.count(\'\\t\'))\n        new = code.replace(\'\\t\',\' \'*4)\n        openwrite(new, py)\n\ndef saveData(data, name=\'pickle_of_boxx\', log=False):  #\xe4\xbf\x9d\xe5\xad\x98\xe8\xbf\x9b\xe5\xba\xa6\n    \'\'\'\n    \xe4\xbf\x9d\xe5\xad\x98\xe4\xba\x8c\xe8\xbf\x9b\xe5\x88\xb6\xe6\x95\xb0\xe6\x8d\xae\n    \'\'\'\n    import pickle\n    if log:\n        print(\'\xe6\xad\xa3\xe5\x9c\xa8\xe5\xb0\x86\xe6\x95\xb0\xe6\x8d\xae\xe5\x86\x99\xe5\x85\xa5\',os.path.abspath(\'.\'),\'\xe4\xb8\x8b\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6:\xe2\x80\x9c\'+name+\'\xe2\x80\x9d\xef\xbc\x8c\xe8\xaf\xb7\xe7\xa8\x8d\xe7\xad\x89\xe3\x80\x82\xe3\x80\x82\xe3\x80\x82\')\n    with open(name, ""wb"") as f:\n        pickle.dump(data,f)\n    if log:\n        print(\'\\n\xe6\x96\x87\xe4\xbb\xb6\xe2\x80\x9c\'+name+\'\xe2\x80\x9d\xe5\xb7\xb2\xe4\xbf\x9d\xe5\xad\x98\xe5\x9c\xa8\',os.path.abspath(\'.\'),\'\xe7\x9b\xae\xe5\xbd\x95\xe4\xb8\x8b!\')\n\ndef loadData(name=\'pickle_of_boxx\', log=False):  #\xe8\xbd\xbd\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\n    import pickle\n    if not os.path.isfile(name):\n        print(\'\xe5\x9c\xa8\',os.path.abspath(\'.\'),\'\xe7\x9b\xae\xe5\xbd\x95\xe4\xb8\x8b,\xe2\x80\x9c\'+name+\'\xe2\x80\x9d\xe6\x96\x87\xe4\xbb\xb6\xe4\xb8\x8d\xe5\xad\x98\xe5\x9c\xa8\xef\xbc\x8c\xe6\x93\x8d\xe4\xbd\x9c\xe5\xa4\xb1\xe8\xb4\xa5\xef\xbc\x81\')\n    if log:\n        print(\'\xe6\xad\xa3\xe5\x9c\xa8\xe8\xaf\xbb\xe5\x8f\x96\',os.path.abspath(\'.\'),\'\xe7\x9b\xae\xe5\xbd\x95\xe4\xb8\x8b\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6:\xe2\x80\x9c\'+name+\'\xe2\x80\x9d\\n\xe8\xaf\xb7\xe7\xa8\x8d\xe7\xad\x89\xe3\x80\x82\xe3\x80\x82\xe3\x80\x82\')\n    with open(name,""rb"") as f:\n        data = pickle.load(f)\n    f.close()\n    if log:\n        print(\'\xe6\x96\x87\xe4\xbb\xb6:\xe2\x80\x9c\'+name+\'\xe2\x80\x9d\xe8\xaf\xbb\xe5\x8f\x96\xe6\x88\x90\xe5\x8a\x9f\xef\xbc\x81\')\n    return data\n\ndef browserOpen(url):\n    \'\'\'\n    open url with browser\n    if can\'t open browser raise warn\n    \'\'\'\n    import webbrowser\n    if not webbrowser.open_new_tab(url):\n        from boxx import warn\n        warn(\'\'\'can\'t open url with web browser, plaese open url:""%s"" in your browser\'\'\'%url)\n        \nif __name__ == ""__main__"":\n\n    pass'"
boxx/tool/toolLog.py,1,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\n\nfrom .toolStructObj import addCall, dicto, FunAddMagicMethod, getfathers, typeNameOf, typestr\nfrom .toolSystem import getRootFrame, getFatherFrames\nfrom ..ylsys import py2\nfrom ..ylcompat import printf, unicode\nfrom ..ylcompat import istype\n\nimport os,sys,time\nimport math\nimport re\nfrom collections import defaultdict\n\ndef _str_struct_time(t, st, int_sec=False):\n    s = ""%d-%02d-%02d-%02d_%02d_%02d""%(st[:6])\n    if int_sec:\n        return s\n    s = s + (""%.5f""%(t%1))[1:]\n    return s\n\ndef localTimeStr(int_sec=False, asctime=False):\n    \'\'\'\n    get local time in string format like \'2020y_02m_26d_04h_05m_41.38258s\'\n    \xe8\x8e\xb7\xe5\xbe\x97\xe6\x9c\xac\xe5\x9c\xb0\xe6\x97\xb6\xe9\x97\xb4(GM+8 \xe5\x8c\x97\xe4\xba\xac\xe6\x97\xb6\xe9\x97\xb4)\n    \'\'\'\n    t = time.time()\n    local_struct_time = time.localtime(t)\n    \n    if asctime:\n        return time.asctime(local_struct_time)\n    return _str_struct_time(t, local_struct_time, int_sec)\n\ndef gmtTimeStr(asctime=False):\n    \'\'\'\n    get GMT(global) time in string format like \'2020y_02m_26d_04h_05m_41.38258s\'\n    \xe8\x8e\xb7\xe5\xbe\x97gmt\xe6\x97\xb6\xe9\x97\xb4(GM0 \xe6\xa0\xbc\xe6\x9e\x97\xe5\xa8\x81\xe6\xb2\xbb\xe6\x97\xb6\xe9\x97\xb4)\n    \'\'\'\n    t = time.time()\n    gmt_struct_time = time.gmtime(t)\n    if asctime:\n        return time.asctime(gmt_struct_time)\n    return _str_struct_time(t, gmt_struct_time)\n\n\nclass timeGap:\n    \'\'\'\n    \xe5\xae\x9a\xe6\x97\xb6log\xe5\x99\xa8 \xe9\x9a\x94\xe5\x9b\xba\xe5\xae\x9a\xe7\x9a\x84\xe4\xb8\x80\xe6\xae\xb5\xe6\x97\xb6\xe9\x97\xb4 \xe8\xbf\x94\xe5\x9b\x9e \xe5\xbd\x93\xe5\x89\x8d\xe8\xbd\xae\xe6\x95\xb0(True)\n    \n    Init Parameters\n    ----------\n    gap : float\n        \xe9\x9a\x94\xe5\xa4\x9a\xe5\xb0\x91\xe7\xa7\x92\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe4\xb8\xaa True\n    fun : function, default None\n        \xe6\xaf\x8f\xe4\xb8\x80\xe6\xac\xa1\xe8\xa6\x81\xe6\x89\xa7\xe8\xa1\x8cfun()\n    quickBegin : bool, default True\n        First time call will return True\n    \n    Attribute\n    ----------\n    __call__ : \n        \xe8\xbf\x94\xe8\xbf\x98 \xe5\xbd\x93\xe5\x89\x8d\xe8\xbd\xae\xe6\x95\xb0(True)\n    time : @property\n        is @property \xe8\xbf\x94\xe5\x9b\x9e\xe5\xb7\xb2\xe8\xae\xb0\xe5\xbd\x95\xe7\x9a\x84\xe6\x97\xb6\xe9\x95\xbf\n    \'\'\'\n    def __init__(self, gap=1,fun=False, quickBegin=True):\n        self.n = 0\n        self.gap = gap\n        self.begin = time.time()\n        self.last = self.begin - (quickBegin and gap)\n        self.fun = fun\n    def __call__(self,):\n        t = time.time()\n        if t - self.last >= self.gap:\n            self.last = t\n            self.n += 1\n            if self.fun:\n                self.fun()\n            return self.n\n        return False\n    @property\n    def time(self):\n        return time.time() - self.begin\n\nTimeGapDic = {}\ndef timegap(gap=10, key=\'boxx.default\', quickBegin=True):\n    \'\'\'\n    \xe5\xae\x9a\xe6\x97\xb6\xe5\x99\xa8 \xe9\x9a\x94\xe5\x9b\xba\xe5\xae\x9a\xe7\x9a\x84\xe4\xb8\x80\xe6\xae\xb5\xe6\x97\xb6\xe9\x97\xb4 \xe8\xbf\x94\xe5\x9b\x9e \xe5\xbd\x93\xe5\x89\x8d\xe8\xbd\xae\xe6\x95\xb0(True), use to log in loop\n    This is light version of timeGap, for More Infomation help(timeGap)\n    \n    Init Parameters\n    ----------\n    gap : number\n        \xe9\x9a\x94\xe5\xa4\x9a\xe5\xb0\x91\xe7\xa7\x92\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe4\xb8\xaa True\n    key : hashable, default \'boxx.default\'\n        the namespace to count\n    \'\'\'\n    keyt = (gap, key)\n    if keyt not in TimeGapDic:\n        TimeGapDic[keyt] = timeGap(gap, quickBegin=quickBegin)\n    return TimeGapDic[keyt]()\n\n__logGapDic = {}\ndef logGap(key=\'gap\'):\n    \'\'\'\n    log time gap in loop\n    \'\'\'\n    d = __logGapDic\n    l = d.get(key)\n    now = time.time()\n    if not l :\n        pblue(\'Begin to log time gap of ""%s""!\'%key)\n        d[key] = [0, now]\n    else :\n        dt = now - l[1]\n        pblue(\'%dst loop, ""%s"" spend %ss.\'%(l[0] ,key, strnum(dt)))\n        l[0] += 1\n        l[1] = now\n\nfrontColorDic = dicto({   # \xe5\x89\x8d\xe6\x99\xaf\xe8\x89\xb2\n        \'black\'    : 30,   #  \xe9\xbb\x91\xe8\x89\xb2\n        \'red\'      : 31,   #  \xe7\xba\xa2\xe8\x89\xb2\n        \'green\'    : 32,   #  \xe7\xbb\xbf\xe8\x89\xb2\n        \'yellow\'   : 33,   #  \xe9\xbb\x84\xe8\x89\xb2\n        \'blue\'     : 34,   #  \xe8\x93\x9d\xe8\x89\xb2\n        \'purple\'   : 35,   #  \xe7\xb4\xab\xe7\xba\xa2\xe8\x89\xb2\n        \'cyan\'     : 36,   #  \xe9\x9d\x92\xe8\x93\x9d\xe8\x89\xb2\n        \'white\'    : 37,   #  \xe7\x99\xbd\xe8\x89\xb2\n    })\nclass colorFormat:\n    \'\'\'\n    \xe5\x90\x8c\xe6\x97\xb6\xe5\x85\xbc\xe5\xae\xb9windows\xe5\x92\x8cLinux\xe5\x8f\x8a\xe5\x90\x84\xe7\xb1\xbb\xe6\x98\x8e\xe6\x9a\x97\xe8\x89\xb2\xe8\xb0\x83\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2str temple\n    \xe5\x8f\xaa\xe6\x9c\x89 red, cyan(==blue), purple\n    \xe4\xbd\xbf\xe7\x94\xa8colorFormat.printAllColor()\xe6\x9f\xa5\xe7\x9c\x8b\xe6\x95\x88\xe6\x9e\x9c\n    \xe7\x94\xa8\xe6\xb3\x95: print colorFormat.blue%strr\n    \'\'\'\n    red = \'\\x1b[\'+str(frontColorDic[\'red\'])+\'m%s\\x1b[0m\'\n    cyan= \'\\x1b[\'+str(frontColorDic[\'cyan\'])+\'m%s\\x1b[0m\'\n    purple = \'\\x1b[\'+str(frontColorDic[\'purple\'])+\'m%s\\x1b[0m\'\n    black = \'\\x1b[\'+str(frontColorDic[\'black\'])+\'m%s\\x1b[0m\'\n    blue = cyan\n    info = blue\n    danger = red\n    err = red\n    b = blue\n    r = red\n    p = purple\n    @staticmethod\n    def printAllColor(s=\'printAllColor\'):\n        return [stdout((c+\' \'*10)[:7]) and pcolor(c,"": ""+str(s)) for c in frontColorDic] and None\n    pall = printAllColor\nclf = colorFormat\n\ndef decolor(colored):\n    \'\'\'\n    remove color of str\n    \'\'\'\n    pa = re.compile(\'\\x1b\\[3[0-9]m|\\x1b\\[0m\')\n    new = pa.sub(\'\', colored)\n    new = pa.sub(\'\', new)\n    return new\n\ndef tounicode(strr):\n    \'\'\'\n    Python2 \xe4\xb8\xad\xe6\x96\x87\xe7\xbc\x96\xe7\xa0\x81\xe9\x94\x99\xe8\xaf\xaf\xe8\xa7\xa3\xe5\x86\xb3\xe6\x96\xb9\xe6\xa1\x88\xef\xbc\x8c\xe7\x94\xa8\xe4\xba\x8e\xe4\xbb\xa3\xe6\x9b\xbfstr\xe7\xb1\xbb\xe5\x8f\x8a\xe5\x87\xbd\xe6\x95\xb0, \xe5\x85\xa8\xe9\x83\xa8\xe6\x8d\xa2\xe6\x88\x90unicode\n    \'\'\'\n    if not py2:\n        if isinstance(strr,str):\n            return strr\n        if isinstance(strr,bytes):\n            return strr.decode(\'utf-8\',\'replace\')\n        return str(strr)\n    else:\n        if isinstance(strr,unicode):\n            return strr\n        strr = str(strr)\n        if isinstance(strr,str):\n            return strr.decode(\'utf-8\',\'replace\')\n        return unicode(strr)\n\ndef tostrpy2(x):\n    \'\'\'\n    only work py2 return a str to avoid \n    UnicodeEncodeError when `str(u\'\xe4\xb8\xad\xe6\x96\x87\')`\n    \'\'\'\n    if not py2:\n        return str(x)\n    if isinstance(x,unicode):\n        return x.encode(\'utf-8\',\'replace\')\n    s = str(x)\n    return s\n\ndef shortDiscrib(x):\n    \'\'\'\n    short Discrib of anything for logc number is better \n    \'\'\'\n    if isinstance(x, int):\n        return str(x)\n    typee = typestr(x)\n    from ..ylimg import StructLogFuns\n    fund = StructLogFuns\n    f = shortStr\n    if typee in fund:\n        f = fund[typee]\n        if \'torch.\' in typee and \'ensor\' in typee and (not x.shape):\n            f = strnum\n    elif \'__float__\' in dir(x):\n        try:\n            x = float(x)\n            f = strnum\n        except:\n            pass\n    try:\n        return decolor(f(x))\n    except:\n        return str((x))\n\ndef shortStr(x, maxlen=60):\n    \'\'\'\n    genrate one line discrib str shorter than maxlen.\n    if len(s)> maxlen then slice additional str and append \'...\' \n    BTW. function will replace \'\\n\' to \'\xe2\x86\xb3\'\n    \n    if bool(maxlen) is False, not be short\n    \'\'\'\n    s = tounicode(x).strip()\n    if maxlen and len(s) > maxlen:\n        s = s[:maxlen-3]\n        s +=  \'...\'\n        if \'\\x1b[\' in s :\n            s += \'\\x1b[0m\' * (list(s).count(\'\\x1b\'))\n    s = s.replace(\'\\n\',\'\xe2\x86\xb3\')\n    return s\n\ndef discrib(x, maxline=20):\n    \'\'\'\n    return discrib of x less than maxline.\n    if len(s)> maxline*80 then slice additional str and append \'...\' \n    \n    if bool(maxline) is False, return s\n    \'\'\'\n    s = tounicode(x)\n    if not maxline:\n        return s\n    enters = s.count(\'\\n\')+1\n    n  = len(s)\n    maxlen = maxline * 80\n    if n > maxlen:\n        s = s[:maxlen-6]+\'......\'\n    elif enters > maxline:\n        s = \'\\n\'.join(s.split(\'\\n\')[:maxline]) + \'\\n......\'\n    else:\n        return s\n    if \'\\x1b[\' in s :\n        s += \'\\x1b[0m\' * (list(s).count(\'\\x1b\'))\n    return s\n\n\ndef logc(code, exe=None):\n    \'\'\'\n    short of log code\n    pretty print expression by show every var\'s value in expression\n    \n    Parameters\n    ----------\n    code : str\n        the expression code that want to print\n    exe : bool, default None\n        wether exec(code) befor print\n        when exe is None:\n            try not exec(code)\n            but if some var in expression can\'t find in locals() and globls()\n                then exec(code)\n    \n    TODO:\n        1. use re to replace vars name avoid the same names\n        2. use Abstract Syntax Tree and re \n           to distinguish .attr, function call []\n    \'\'\'\n    frame = sys._getframe(2)\n    local = frame.f_locals\n    glob = frame.f_globals\n    \n    if exe:\n        exec(code, local, glob)\n    \n    varss = re.findall(\'[a-zA-Z_][a-zA-Z0-9_]*\',code)\n    dic = {}\n    for name in varss:\n        if name in local:\n            dic[name] = local[name]\n        elif name in glob:\n            dic[name] = glob[name]\n        elif exe is None:\n            exec(code, local, glob)\n            if name in local:\n                dic[name] = local[name]\n            else:\n                dic[name] = addCall(name)\n    coder = numr = code\n    \n    toNotVarName = lambda name: \'$_%s_$\'% \'\'.join([str(ord(c)) for c in name])\n    addSpaceBothSide = lambda s, n: (n//2)*\' \' + str(s) + (n-n//2)*\' \'\n    \n    for k, v in sorted(dic.items(), key=lambda x:-len(x[0])):\n        vstr = shortDiscrib(v)\n        if callable(v):\n            vstr = k\n        maxs = max(len(vstr), len(k))\n        \n        dic[k] = dict(\n                vstr=vstr,\n                maxs=maxs,\n                v=v,\n                ks=addSpaceBothSide(k, maxs-len(k)),\n                vs=addSpaceBothSide(vstr, maxs-len(vstr)),\n                )\n        coder = coder.replace(k, toNotVarName(k))\n        numr = numr.replace(k, toNotVarName(k))\n    \n    for k, d in sorted(list(dic.items()), key=lambda x:-len(x[0])):\n        coder = coder.replace(toNotVarName(k), clf.b%d[\'ks\'])\n        numr = numr.replace(toNotVarName(k), clf.r%d[\'vs\'])\n    \n    s = (\'Code: %s\\n  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 %s\'%(coder, numr))   \n    print(s)\nlogc = FunAddMagicMethod(logc)\n\ndef tabstr(s, head=4, firstline=False):\n    \'\'\'\n    to tab a block of str for pretty print\n    \n    Parameters\n    ----------\n    head : str or int, default 4\n        the str that to fill the head of each line\n        if value is int, head = \' \'*head\n    firstline : bool, default False\n        whether fill the first line \n    \'\'\'\n    if isinstance(head, int):\n        head = \' \'*head\n    if firstline:\n        s = head + s\n    return s.replace(\'\\n\',\'\\n\'+head)\n\ndef getDoc(f):\n    \'\'\'\n    get document of f, if f don\'t have __doc__, return None\n    \'\'\'\n    if \'__doc__\' in dir(f) and f.__doc__:\n        return f.__doc__\n    return None\n        \ndef pcolor(color, *s):\n    \'\'\'\n    \xe7\x94\xa8\xe9\xa2\x9c\xe8\x89\xb2\xe6\x89\x93\xe5\x8d\xb0 \xe4\xb8\x8d\xe8\xbf\x94\xe5\x9b\x9e\n    \'\'\'\n    if not isinstance(color,int):\n        color = frontColorDic[color]\n    print((\'\\x1b[%dm%s\\x1b[0m\'%(color, \' \'.join(map(tounicode,s)))))\n    return \n    if len(s) == 1:\n        return s[0]\n    return s\npcyan = lambda *s:pcolor(\'cyan\',*s) #  \xe9\x9d\x92\xe8\x93\x9d\xe8\x89\xb2\npred = lambda *s:pcolor(\'red\',*s) #  \xe7\xba\xa2\xe8\x89\xb2\nppurple = lambda *s:pcolor(\'purple\',*s) #  \xe7\xb4\xab\xe7\xba\xa2\xe8\x89\xb2\npblue = pcyan \n\ndef stdout(*l):\n    sys.stdout.write((\'%s\'%(\' \'.join(map(tounicode,l)))))\n    if len(l) == 1:\n        return l[0]\n    return l\n\nclass Log():\n    def __call__(self,*l, **kv):\n        printf(*l, **kv)\n    def __div__(self, x):\n        printf(x)\n        return x\n    __sub__ = __call__\n    __truediv__ = __div__\nlog = FunAddMagicMethod(printf)\nprintt = log\n\ndef printToStr(value=\'\', *l, **kv):\n#def printToStr(value=\'\', *l, sep=\' \', end=\'\\n\', file=None, flush=False): # for py version < 2.7.16\n    \'\'\'\n    same usage to print function, but replace stdout to return str\n    \'\'\'\n    sep=\' \'\n    end=\'\\n\'\n    file=None\n    flush=False\n    locals().update(kv)\n    l = (value,)+l\n    s = sep.join([tounicode(v) for v in l]) + end\n    return s\n\nclass PrintStrCollect():\n    from functools import wraps\n    def __init__(self, ):\n        self.s = \'\'\n    @wraps(printToStr)\n    def __call__(self, *l, **kv):\n        s = printToStr(*l, **kv)\n        self.s += s\n    def __str__(self):\n        s = self.s\n        return tostrpy2(s)\n    pass\n\nclass LogAndSaveToList(list):\n    \'\'\'\n    \xe5\xad\x98\xe5\x82\xa8\xe6\x9c\x80\xe8\xbf\x91\xe7\x94\xa8\xe4\xba\x8elogg\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c, \xe5\xb9\xb6\xe8\xbf\x94\xe5\x9b\x9ex\xe7\x9a\x84class, list\xe7\x89\x88\xe6\x9c\xacSuperG\n    \'\'\'\n    def __init__(self,printFun=None,cache=5):\n        self.p = printFun or pblue\n        self.cache = cache\n    @property\n    def i(self):\n        return self[-1]\n    _ = i\n    @property\n    def ii(self):\n        return self[-2]\n    __ = ii\n    @property\n    def iii(self):\n        return self[-3]\n    ___ = iii\n    @property\n    def iiii(self):\n        return self[-4]\n    ____ = iiii\n    def __call__(self,*l,**dic):\n        while self.cache < len(self):\n            self.remove(self[0])\n        if len(l) == 1:\n            self.p(l[0])\n            self.append(l[0])\n            return l[0]\n        self.p(\'\\n\'.join(map(tounicode,l)))\n        if len(dic):\n            for k in dic:\n                self.p(\'%s = %s\'%(k,tounicode(dic[k])))\n            self.append(dic)\n        self.append(l)\n        return l\n    __sub__ = __lshift__ = __rshift__  = __div__ = __truediv__ =__call__\n    def __repr__(self):\n        blue  = \'\\x1b[%dm%s\\x1b[0m\'%(frontColorDic[\'red\'],tounicode(len(self) and self[len(self)-1]))\n        return \'\'\'LogAndSaveToList(printFun=%s, cache=%s) log[-1]: %s\'\'\'%(\n        str(self.p),self.cache,blue)\n    __str__ = __repr__\n\nlogg = LogAndSaveToList()\npcyan,pred,ppurple,stdout = list(map(FunAddMagicMethod,\n                                        [pcyan,pred,ppurple,stdout]))\n    \npblue = pcyan \npinfo = pblue\npdanger = pred\nperr = pred\n\n\ndef notationScientifique(num, roundn=None, tuple=False):\n    \'\'\'\n    \xe7\xa7\x91\xe5\xad\xa6\xe8\xae\xa1\xe6\x95\xb0\xe6\xb3\x95 \n\n    roundn : int, default None\n        Notation Scientifique\n        \xe4\xbf\x9d\xe7\x95\x99\xe6\x9c\x89\xe6\x95\x88\xe4\xbd\x8d\xe6\x95\xb0 \n    tuple : bool, default False\n        if True, return a tuple(head, pow) instead of string\n    \'\'\'\n    if num == 0:\n        head, pow = 0,0\n    else:\n        loged = (math.log(abs(num),10))\n        pow = int(loged) + (loged < 0 and -1)\n        head = num*10**-pow\n        if roundn is not None:\n            head = round(head, roundn-1)\n    if tuple:\n        return (head, pow)\n    s = \'%se%d\'%(str(head),pow)\n    return s\n\ndef strnum(num, roundn=4):\n    \'\'\'\n    better str(num) avoid to long round\n    support nan inf\n    \'\'\'\n    try:\n        if isinstance(num, int):\n            return str(num)\n        elif not isinstance(num, float) and \'__float__\' in dir(num):\n            num = float(num)\n        head, pow = notationScientifique(num, roundn=roundn, tuple=True)\n        if pow > roundn or pow < -min(3,roundn):\n            s = \'%se%d\'%(str(head),pow)\n        else:\n            s = str(round(num, -pow+roundn))\n        return s\n    except (OverflowError, ValueError) as e:\n        import numpy as np\n        if np.isnan(num) or np.isinf(num):\n            return str(num)\n        raise e\n\ndef percentStr(num, roundn=2, sign=False):\n    \'\'\'\n    float to percent string\n    roundn mean round to percent\n    \'\'\'\n    num = round(num*100, roundn)\n    tabn = (2 if num <10 else 1 )if num <100 else 0\n    s = (\' \'*tabn+\'%.\'+str(roundn)+\'f\')%(num)\n    if sign:\n        s += ""%""\n    return s\n               \ndef ignoreWarning():\n    from warnings import filterwarnings\n    filterwarnings(\'ignore\')\n\n\nclass LogLoopTime():\n    \'\'\'\n    \xe8\xae\xb0\xe5\xbd\x95\xe5\xbe\xaa\xe7\x8e\xaf\xe4\xbf\xa1\xe6\x81\xaf\xe7\x9a\x84\xe5\xaf\xb9\xe8\xb1\xa1 \xe4\xb8\xbb\xe8\xa6\x81\xe7\x9a\x84\xe4\xbf\xa1\xe6\x81\xaf\xe6\x9c\x89\xe6\xaf\x8f\xe4\xb8\xaa\xe5\xbe\xaa\xe7\x8e\xaf\xe6\x97\xb6\xe9\x97\xb4\xe5\x92\x8c\xe8\xbf\x9b\xe5\xba\xa6\n    names: \xe7\x94\xa8\xe4\xba\x8e\xe5\xbe\xaa\xe7\x8e\xaf\xe7\x9a\x84list\xef\xbc\x8ctuple\n    digits: \xe6\x97\xb6\xe9\x97\xb4\xe7\x9a\x84\xe4\xbf\x9d\xe7\x95\x99\xe4\xbd\x8d\xe6\x95\xb0 \xe5\x8f\xaf\xe4\xb8\xba\xe8\xb4\x9f\xe6\x95\xb0\n    loged: \xe6\x98\xaf\xe5\x90\xa6\xe7\x9b\xb4\xe6\x8e\xa5\xe6\x89\x93\xe5\x8d\xb0\n    \n    \xe4\xbd\xbf\xe7\x94\xa8\xe6\x97\xb6\xe5\x80\x99 \xe5\x9c\xa8\xe5\xbe\xaa\xe7\x8e\xaf\xe6\x9c\x80\xe5\x90\x8e\xe5\x8a\xa0\xe4\xb8\x8a logLoopTime(name) \xe5\x8d\xb3\xe5\x8f\xaf\n    \'\'\'\n    def __init__(self,names=None,digits=3,loged=True):\n        self.ns = names\n        self.begin = self.t = time.time()\n        self.digits = digits\n        self.loged = loged\n        self.count = 0\n    def __call__(self,name):\n        digits = self.digits\n        t = time.time()\n        dt = t - self.t\n        self.t = t\n        times = (\'%.\'+str(digits)+\'f\')%dt if digits > 0 else \'%.2fE%d\'%(dt/10**abs(digits-1),abs(digits-1))\n        if self.ns is None:\n            s = \'No.%d  %s time:%s\'%(self.count,name, times)\n            self.count += 1\n        else:\n            names = self.ns\n            ind = float(names.index(name))\n            self.n = len(names)\n            s = \'%d/%d %.2f%%  %s time:%s\'%(ind,self.n,\n                                            (ind*100./self.n),name, times)\n        if self.loged:\n            log(s)\n        return s\n    log = __call__\n\nclass LogException():\n    \'\'\'\n    \xe7\x94\xa8\xe4\xba\x8e\xe6\x89\x91\xe6\x8d\x89\xe5\x92\x8c\xe8\xae\xb0\xe5\xbd\x95\xe5\x87\xbd\xe6\x95\xb0\xe4\xb8\xad\xe7\x9a\x84\xe5\xbc\x82\xe5\xb8\xb8\xe9\x94\x99\xe8\xaf\xaf\n    usage:\n        loge = LogException(logFilePath,otherFun) # \xe5\x85\x88\xe5\xae\x9e\xe4\xbe\x8b\xe4\xb8\x80\xe4\xb8\xaa\xe5\xaf\xb9\xe8\xb1\xa1\n        loge.listen(f,*l,**args) # \xe7\x94\xa8 .listen \xe8\xbf\x90\xe8\xa1\x8c\xe5\x87\xbd\xe6\x95\xb0\n        @loge.decorator  # \xe8\xa3\x85\xe9\xa5\xb0\xe8\xa2\xab\xe7\x9b\x91\xe5\x90\xac\xe5\x87\xbd\xe6\x95\xb0\n    \'\'\'\n    def __init__(self,\n                 logFilePath=None, \n                 otherFun=None,\n                 printOnCmd=True, \n                 logBegin=False,\n                 localTime=False,\n                 isOn=True):\n        \'\'\'logFilePath  log\xe6\x96\x87\xe4\xbb\xb6\xe4\xbf\x9d\xe5\xad\x98\xe8\xb7\xaf\xe5\xbe\x84,\xe4\xb8\xbaFalse\xe6\x97\xb6 \xe4\xb8\x8d\xe5\x86\x99\xe5\x85\xa5\xe6\x96\x87\xe4\xbb\xb6\n        otherFun  \xe4\xb8\x80\xe4\xb8\xaa\xe8\xbf\x94\xe5\x9b\x9e\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8c\xe6\xaf\x8f\xe6\xac\xa1\xe9\x94\x99\xe8\xaf\xaf\xe8\xbf\x90\xe8\xa1\x8c\xe4\xb8\x80\xe6\xac\xa1\xef\xbc\x8c\xe7\xbb\x93\xe6\x9e\x9c\xe5\x86\x99\xe5\x85\xa5log\n        printOnCmd   \xe6\x97\xb6\xe5\x80\x99\xe5\x9c\xa8\xe5\xb1\x8f\xe5\xb9\x95\xe4\xb8\x8a\xe6\x89\x93\xe5\x8d\xb0\n        logBegin     \xe6\x98\xaf\xe5\x90\xa6\xe8\xae\xb0\xe5\xbd\x95\xe5\xbc\x80\xe5\xa7\x8b\xe7\x9b\x91\xe5\x90\xac\xe4\xba\x8b\xe4\xbb\xb6\n        localTime    \xe6\x98\xaf\xe5\x90\xa6\xe4\xb8\xba\xe5\xbd\x93\xe5\x9c\xb0\xe6\x97\xb6\xe9\x97\xb4 \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbaGMT\xe6\x97\xb6\xe9\x97\xb4\n        \'\'\'\n        \n        self.splitLine = \'/*----------*/\'\n        self.path = logFilePath\n        self.fun = otherFun if otherFun else lambda :\'\'\n        self.printt = printOnCmd\n        self.localTime = localTime\n        self.format = (\n\'\'\'     Index :{index}, {time}\n{timeClass} :{timeStr}\n Exception :{exceptionName}\n   Message :{message}\n      Args :{args}\n{otherInfo}\n{splitLine}\n\'\'\')\n        self.index = 0\n        self.isOn = isOn\n        if logFilePath:\n            if os.path.isfile(logFilePath):\n                with open(self.path,\'r\') as f:     \n                    strr = f.read()\n                self.index = strr.count(self.splitLine)\n        if logBegin:\n            class beginLogException(Exception):\n                pass\n            def f ():\n                raise beginLogException(\'LogException is begin to log Exception!\')\n            self.listen(f)\n        \n    def listen(self,f,*l,**args):\n        \'\'\'\n        f        : \xe7\x9b\x91\xe5\x90\xac\xe5\x87\xbd\xe6\x95\xb0\n        *l,**args: \xe5\x87\xbd\xe6\x95\xb0f\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\n        \'\'\'\n        import time\n        if not self.isOn:\n            f(*l,**args)\n            return\n        try:\n            f(*l,**args)\n        except Exception as e:\n            exceptionName = tounicode(type(e))\n            exceptionName = exceptionName[exceptionName.index(\'.\')+1:-2]\n            \n            timeClass = \'Local time\' if self.localTime else \'  GMT time\'\n            t = time.asctime( time.localtime(time.time())) if self.localTime  else time.asctime(time.gmtime(time.time()))\n            \n            otherInfo = self.fun()\n            \n            erroStr = self.format.format(\n                                         index=self.index,\n                                         timeStr=t,\n                                         timeClass=timeClass,\n                                         time=time.time(),\n                                         exceptionName=exceptionName,\n                                         message=e.message,\n                                         args=tounicode(e.args),\n                                         otherInfo=otherInfo,\n                                         splitLine=self.splitLine,\n                                         )\n            self.__writeLog(erroStr)\n            self.index += 1\n            self.last = self.e = e\n\n    def __writeLog(self,strr):\n        \'\'\'\n        \xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe6\x89\x93\xe5\x8d\xb0\xe5\x92\x8c\xe5\x86\x99\xe5\x85\xa5\n        \'\'\'\n        if self.printt:\n            print(strr)\n        if self.path:\n            with open(self.path,\'a\') as f:     \n                f.write(strr)\n    def decorator(self,f):\n        \'\'\'\n        \xe5\x87\xbd\xe6\x95\xb0\xe8\xa3\x85\xe9\xa5\xb0\xe5\x99\xa8\xe5\xb0\x81\xe8\xa3\x85\n        \'\'\'\n        def ff(*l,**arg):\n            r = self.listen(f,*l,**arg)\n            return r\n        return ff\n\ngsAttrDic = {}\nclass Gs(dict):\n    \'\'\'debug\xe7\x9a\x84\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8fG\xe7\x9a\x84\xe5\xad\x90\xe7\xb1\xbb\n    \'\'\'\n    pass\n    def __init__(self,name, log ,*l,**kv):\n        idd = id(self)\n        gsAttrDic[idd] = dicto()\n        gsAttrDic[idd].log = log\n        gsAttrDic[idd].name = name if name else \'g\'\n        dict.__init__(self,*l,**kv)\n    def __setitem__(self, k, v):\n        idd = id(self)\n        if isinstance(v,tuple) and len(v) == 2 and (v[1] is self):\n            v,tag = v\n            if gsAttrDic[idd].log or (gsAttrDic[idd].log is None):\n                pblue(\'%s[%s] =\'%(gsAttrDic[idd].name, str(k)),v)\n        else:\n            if gsAttrDic[idd].log:\n                pblue(\'%s[%s] =\'%(gsAttrDic[idd].name, str(k)),v)\n        dict.__setitem__(self, k, v)\n        pass\n    def logWhenSet(self, on=\'nothing\'):\n        idd = id(self)\n        if on == \'nothing\':\n            gsAttrDic[idd].log = not gsAttrDic[idd].log\n        else:\n            gsAttrDic[idd].log = on\n    def __call__(self, x=None):\n        pretty = False\n        if pretty:\n            loc = prettyFrameLocation(1)\n            pblue(\'Print by g from %s:\'%loc)\n        else:\n            pblue(\'%s: %s\'%(clf.p%\'Print by g\', x))\n        return x\n    __sub__ = __call__\n    __lshift__ = __call__\n    __rshift__ = __call__\n    __truediv__ = __div__ = __call__\n    \n    def __del__(self):\n        idd = id(self)\n        if gsAttrDic and idd in gsAttrDic:\n            del gsAttrDic[idd]\n        \n            \n    \n\nclass SuperG(Gs):\n    \'\'\'\n    Author: DIYer22@GitHub (ylxx@live.com)\n    **\xe7\x94\xa8\xe4\xba\x8edebug\xe7\x9a\x84\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f**, \xe7\x94\xa8\xe4\xba\x86\xe4\xb8\x8d\xe5\xb0\x91\xe6\x97\x81\xe9\x97\xa8\xe5\xb7\xa6\xe9\x81\x93\xe4\xbb\xa5\xe8\xbe\xbe\xe5\x88\xb0\xe6\x9c\x80\xe4\xbd\x8e\xe4\xbd\xbf\xe7\x94\xa8\xe8\xb4\x9f\xe6\x8b\x85\n    \xe6\x9c\xac\xe8\xba\xab\xe6\x98\xaf\xe7\xb1\xbb\xe4\xbc\xbcJavaScript\xe5\xaf\xb9\xe8\xb1\xa1\xe7\x9a\x84\xe8\xb6\x85\xe7\xba\xa7\xe5\xad\x97\xe5\x85\xb8\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x8a\xa8\xe6\x80\x81\xe6\xb7\xbb\xe5\x8a\xa0\xe5\xb1\x9e\xe6\x80\xa7\n    \xe5\x85\xb6\xe4\xb8\xad g.keys,g.values,g.items \xe6\xb7\xbb\xe5\x8a\xa0\xe4\xba\x86property\n    \xe7\x94\xa8\xe6\xb3\x95:\n        1.\xe8\x8e\xb7\xe5\x8f\x96\xe5\x8f\x98\xe9\x87\x8f\n            g[0] = v \n            g.a = v\n        2.\xe5\x9c\xa8\xe8\xb5\x8b\xe5\x80\xbc\xe6\x97\xb6 \xe5\x90\x8c\xe6\x97\xb6\xe6\x89\x93\xe5\x8d\xb0\n            g.a = v,g \n        3.\xe5\xa7\x8b\xe7\xbb\x88\xe5\x9c\xa8\xe8\xb5\x8b\xe5\x80\xbc\xe6\x97\xb6\xe6\x89\x93\xe5\x8d\xb0\n            g.logWhenSet(True)\n        4.\xe6\x9b\xbf\xe6\x8d\xa2print\n            g(x)\n            g<<x\n            g-x\n            g==x\n        5.\xe6\x9b\xbf\xe6\x8d\xa2print \xe4\xb8\x94\xe8\xbf\x94\xe5\x9b\x9e\xe6\x9c\xac\xe8\xba\xab\n            g/x\n    \'\'\'\n    def __init__(self,name=None, log=None, *l, **kv):\n        \'\'\'\n        name: \xe5\x8f\x98\xe9\x87\x8f\xe5\x90\x8d\n        log: \xe6\x97\xb6\xe5\x80\x99\xe6\x89\x93\xe5\x8d\xb0 \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbaNone\n            True: \xe9\x83\xbd\xe6\x89\x93\xe5\x8d\xb0\n            None: \xe8\xb7\x9f\xe7\x9d\x80g\xe6\x89\x8d\xe6\x89\x93\xe5\x8d\xb0\n            False: \xe9\x83\xbd\xe4\xb8\x8d\xe6\x89\x93\xe5\x8d\xb0\n        \'\'\'\n        Gs.__init__(self,name, log, *l, **kv)\n    def __getattribute__(self, name=None, *l):\n        if name in self:\n            return self[name]\n        if name in dir(Gs):\n            return Gs.__getattribute__(self,name, *l)\n        def keyError(x):\n            self[name] = x\n            return x\n        return keyError\n    def __setattr__(self, name, v):\n        if name in dir(Gs):\n            return Gs.__setattr__(self,name,v)\n        self[name] = v\n    if py2:\n        @property\n        def keys(self):\n            return addCall(dict.keys(self))\n        @property\n        def values(self):\n            return addCall(dict.values(self))\n        @property\n        def items(self):\n            return addCall(dict.items(self))\n\nsg = SuperG()\n\n\nclass withOperation():\n    \'\'\'\n    `w{operation}` is mulitple variables version of ""{operation}/x"", and work in ""with statement"".\n    {usage}\n    `w{operation}` only act on assignment variables that under `with w{operation}:` statement.\n    \n    Usage\n    --------\n        >>> with w{operation}:\n        >>>     pi = 3.14\n        >>>     e = 2.71\n    \n    Note\n    --------\n        If var\'s name in locals() and `id(var)` not change ,var may not be detected \n        Especially following cases\xef\xbc\x9a\n            1. var is int and < 256\n            2. `id(var)` not change\n\n    \'\'\'\n    def __init__(self, operation=\'p\', printt=False, transport=False, deep=0):\n        self.locs = defaultdict(lambda:[])\n        self.operation = operation\n        self.printt = printt\n        self.transport = transport\n        self.deep = deep\n    def __enter__(self):\n        f = sys._getframe(self.deep+1)\n        ind = id(f)\n        self.locs[ind].append((f.f_locals).copy())\n        return self\n    def __exit__(self, typee, value, traceback):\n        f = sys._getframe(self.deep+1)\n        ind = id(f)\n        locsb = self.locs[ind].pop()\n        locs = f.f_locals\n        kvs = []\n        newVars = []\n        for k in locs:\n            if k in locsb:\n                if not (locsb[k] is locs[k]):\n                    kvs.append((k, locs[k]))\n            else:\n                kvs.append((k, locs[k]))\n                newVars.append(k)\n        if self.transport:\n            root = getRootFrame()\n            root.f_locals.update(kvs)\n        \n        printf = lambda *l, **kv: 0\n        if self.printt:\n            printf = log\n        printf("""")\n        printf(colorFormat.b%\'withprint from %s\'%prettyFrameLocation(f))\n\n        if len(kvs):\n            tag = \'\'\n            if locs.get(\'__name__\') == \'__main__\':\n                printf(colorFormat.b% \'New Vars: \', end=\'\')\n                if len(newVars):\n                    printf((\', \'.join([colorFormat.p%k for k in newVars])))\n                else:\n                    printf((colorFormat.b% \'None\'))\n                    \n                tag = (""\\nP.S. code run in __main__, some vars may not detected if id(var) not change."")\n            printf((colorFormat.b% ""All Vars\'s Values :""))#(P.S.some base object may not detected):""))\n            if self.printt:\n                from boxx import tree\n                tree(dict(kvs))\n                tag and printf(tag)\n            \n        else:\n            print((colorFormat.r% \'\\n\\nNot detected any Vars:\'+\n                   \'\\n    id(var) may not change in interactive mod if var is int and < 256 \\n\'+\n                   \'    `help(withprint)` for more infomation\\n\'+\n                   \'     P.S assignment self is not work for with statement.\\n\'+\n                   \'     Instead, `new_var = old_var` is OK!\'))\n    def __str__(self):\n        s = self.__doc__\n        if py2:\n            return str(s.encode(\'utf-8\'))\n        return s\n    __repr__ = __str__\n\nclass withPrint(withOperation):\n    operation = \'p\'\n    usage = \'\'\'\n    pretty print variables with their variable name.\n    \'\'\'\n    __doc__ = withOperation.__doc__.format(operation=operation, usage=usage)\n    def __init__(self):\n        withOperation.__init__(self, self.operation, True, False)\n    \nclass withTransport(withOperation):\n    operation = \'g\'\n    usage = \'\'\'\n    `wg` will transport variable to Python interactive console.\n    \'\'\'\n    __doc__ = withOperation.__doc__.format(operation=operation, usage=usage)\n    def __init__(self):\n        withOperation.__init__(self, self.operation, False, True)\n\nclass withPrintAndTransport(withOperation):\n    operation = \'gg\'\n    usage = \'\'\'\n    `wgg` will transport variable to Python interactive console and pretty print they.\n    \'\'\'\n    __doc__ = withOperation.__doc__.format(operation=operation, usage=usage)\n    def __init__(self):\n        withOperation.__init__(self, self.operation, True, True)\n\nwp = withPrint()\nwg = withTransport()\nwgg = withPrintAndTransport()\n\nclass TransportToRootFrame():\n    def __init__(self, name=None, log=False):\n        self.name = name\n        self.log = log\n    def __call__(self, value):\n        frame = getRootFrame()\n        frame.f_globals[self.name] = value\n        if self.log:\n            name = str(self.name)\n            s = (clf.r%\'gg.%s:""\'+\'%s\'+clf.r%\'""\')%(name, tabstr(str(value), len(name)+5))\n            print(s)\n        return value\n    __sub__ = __truediv__ = __div__ = __mul__ = __add__ = __eq__ = __pow__ = __call__\n    def __str__(self):\n        return \'TransportToRootFrame(name=%s, log=%s)\'%(self.name, self.log)\n    __repr__ = __str__\n    \nglobal_g_paras = {}\nclass GlobalGCore(object):\n    def __init__(self, log=False):\n        object.__init__(self)\n        d = global_g_paras[id(self)] = dicto()\n        d.log = log\n        \n        d.wo = withOperation([\'g\', \'gg\'][log], printt=log, transport=True, deep=1)\n    def __call__(self, deep=0):\n        d = global_g_paras[id(self)]\n        log = d.log\n        out(depth=deep+1, printt=log)\n        return True\n        \n    def __del__(self):\n        idd = id(self)\n        if global_g_paras and idd in global_g_paras:\n            del global_g_paras[idd]\n\n    def __enter__(self):\n        d = global_g_paras[id(self)]\n        return withOperation.__enter__(d.wo)\n    def __exit__(self, typee, value, traceback):\n        d = global_g_paras[id(self)]\n        withOperation.__exit__(d.wo, typee, value, traceback)\nclass GlobalG(GlobalGCore):\n    # TODO: add Decorators(\xe8\xa3\x85\xe9\xa5\xb0\xe5\x99\xa8) to catch error in with and export vars\n    \'\'\'\n    TODO:\n        \n    for dev-tips:\n        after every operating in IPython@spyder, will read this instance 10+ times\n        some times will read attr like ""__xx__"" but not in dir(object): in this case\n        don\'t return anything just raise the Exception\n        \n        if is instance.__getattribute__(name) try to use getattr(instance, name) instead\n    \'\'\'\n    def __init__(self, log=False):\n        GlobalGCore.__init__(self, log)\n    def __getattribute__(self, name=\'x\', *l):\n#        print(id(self),name)\n        if name.startswith(\'__\') and name.endswith(\'__\') or name in dir(GlobalGCore): \n            return GlobalGCore.__getattribute__(self, name, *l)\n        log = global_g_paras[id(self)].log\n        return TransportToRootFrame(name,log)\n    def __setattr__(self, name, v):\n        log = global_g_paras[id(self)].log\n        transport = TransportToRootFrame(name,log)\n        transport(v)\ng = GlobalG()\ngg = GlobalG(log=True)\n\nconfig = dicto()\ncf = config\nboxxcf = dicto()\n\ndef if_main_then_g_call():\n    \'\'\'`mg` is short of if_main_then_g_call\n    Will transport `locals()` to Python interactive console when __name__ == \'__main__\'.\n    Then return  __name__ == \'__main__\'\n    \n    >>> mg() \n    # equl to      \n    >>> if __name__ == \'__main__\':\n    >>>     g()\n    \'\'\'\n    frame = sys._getframe(1)\n    _name_ = frame.f_globals.get(\'__name__\')\n    is_main = _name_ == \'__main__\'\n    if is_main:\n        g(1)\n    return is_main\nmg = if_main_then_g_call\n\ndef prettyClassFathers(obj):\n    \'\'\'\n    get object or type, return pretty str\n    \n    >>> prettyClassFathers(cf)\n    Instance of boxx.tool.toolStructObj.dicto <-dict <-object\n    \'\'\'\n    fas = getfathers(obj)\n    fas = [colorFormat.p%typeNameOf(fa) for fa in fas]\n    s = \'Type\' if istype(obj)  else \'Instance\'\n    s = colorFormat.r % s\n    s += \' of \'+ (\' <-\').join(fas)\n    return s\n\ndef prettyFrameLocation(frame=0):\n    \'\'\'\n    get frame return pretty str\n    \n    >>> prettyFrameLocation(frame)\n    ""/home/dl/junk/printtAndRootFarme-2018.03.py"", line 109, in wlf\n    \n    Parameters\n    ----------\n    frame : frame or int, default 0\n        if int:\xe7\x9b\xb8\xe5\xaf\xb9\xe4\xba\x8e\xe8\xb0\x83\xe7\x94\xa8\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0frame\xe7\x9a\x84 int \xe6\xb7\xb1\xe5\xba\xa6\xe7\x9a\x84\xe5\xaf\xb9\xe5\xba\x94frame\n    \'\'\'\n    if isinstance(frame, int):\n        frame = sys._getframe(1 + frame)\n    c = frame.f_code\n    return ((colorFormat.b%\'File: ""%s"", line %s, in %s\')%\n            (\'\\x1b[32m%s\\x1b[0m\'% c.co_filename, \'\\x1b[32m%s\\x1b[0m\'% c.co_firstlineno, colorFormat.purple% c.co_name))\n\ndef getNameFromCodeObj(code, pretty=True):\n    name = code.co_name\n    filee = code.co_filename\n    if pretty:\n        if name == \'<module>\':\n            if filee.startswith(\'<ipython-input-\'):\n                name = \'ipython-input\'\n            else:\n                name = \'%s\'%os.path.basename(filee)\n            name = \'\\x1b[36m%s\\x1b[0m\'%name\n        if name == \'<lambda>\':\n            return \'lambda\'\n    return name\ndef prettyFrameStack(frame=0, endByMain=True, maxprint=None):\n    \'\'\'\n    get frame return pretty str of stack\n    \n    >>> prettyFrameLocation(frame)\n    __init__ <-f <-ff <-demo.py\n    \n    Parameters\n    ----------\n    frame : frame or int, default 0\n        if int:\xe7\x9b\xb8\xe5\xaf\xb9\xe4\xba\x8e\xe8\xb0\x83\xe7\x94\xa8\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0frame\xe7\x9a\x84 int \xe6\xb7\xb1\xe5\xba\xa6\xe7\x9a\x84\xe5\xaf\xb9\xe5\xba\x94frame\n    endByMain : bool, default True\n        \xe4\xb8\xba True \xe5\x88\x99\xe5\x9c\xa8\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa frame.f_locals[\xe2\x80\x98__name__\xe2\x80\x99] == \xe2\x80\x98__main__\xe2\x80\x99 \xe5\xa4\x84\xe5\x81\x9c\xe6\xad\xa2\xe6\x90\x9c\xe5\xaf\xbb \n        \xe7\x9b\xae\xe7\x9a\x84\xe6\x98\xaf\xe5\x8e\xbb\xe9\x99\xa4 IPython \xe8\x87\xaa\xe8\xba\xab\xe5\xa4\x9a\xe4\xbd\x99\xe7\x9a\x84 Call Stack\n    \'\'\'\n    if frame is False and endByMain:\n        frame, endByMain = 0, False\n    if isinstance(frame, int):\n        frame = sys._getframe(1 + frame)\n    fs = getFatherFrames(frame, endByMain=endByMain)\n    ns = [getNameFromCodeObj(f.f_code) for f in fs]\n    if endByMain:\n        if \'execfile\' in ns:\n            ns = ns[:ns.index(\'execfile\')]\n        if \'_call_with_frames_removed\' in ns:\n            ns = ns[:ns.index(\'_call_with_frames_removed\')]\n    s = \' <-\'.join(ns)\n    s = shortStr(s, maxlen=maxprint)\n    return s\n\ndef generaPAndLc():\n    saveOut = {}\n    class LocalAndGlobal(dicto):\n        \'\'\'\n        your can use `out()`, `p()` in any function or module\n        exec `out()`, all vars that belong the function will transport to\n        Python interactive shell. and `globals()` will in `p` which is a dicto\n        \n        BTW, `import boxx.out`, `import boxx.p` is Convenient way to use `out()` without `from boxx import out`\n        \n        \xe5\x9c\xa8\xe5\x87\xbd\xe6\x95\xb0\xe5\x86\x85\xe8\xbf\x90\xe8\xa1\x8c`p()` or `lc()`  \n        \xe5\x88\x99\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84global\xe5\x92\x8clocal \xe5\x8f\x98\xe9\x87\x8f\xe4\xbc\x9a\xe8\xbd\xbd\xe5\x85\xa5\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f p \xe4\xb8\xad\n        \xe5\x87\xbd\xe6\x95\xb0\xe7\x9a\x84 frame\xe7\xad\x89\xe5\x85\xb6\xe4\xbb\x96\xe4\xbf\xa1\xe6\x81\xaf \xe5\x88\x99\xe6\x94\xbe\xe5\x85\xa5\xe5\x85\xa8\xe5\xb1\x80\xe5\x8f\x98\xe9\x87\x8f lc\n        \n        Parameters\n        ----------\n        depth : int or bool, default 0\n            \xe7\x9b\xb8\xe5\xaf\xb9\xe4\xba\x8e`p()`\xe6\x89\x80\xe5\x9c\xa8frame\xe7\x9a\x84\xe6\xb7\xb1\xe5\xba\xa6\n            ps.\xe4\xb8\xba\xe4\xba\x86\xe4\xbd\xbf\xe5\x85\xb3\xe9\x97\xadprintt\xe7\xae\x80\xe4\xbe\xbf \xe8\x8b\xa5`p(False)` \xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba`p(0, False)`\n        printt : bool, default True\n            \xe6\x98\xaf\xe5\x90\xa6\xe6\x89\x93\xe5\x8d\xb0\n            \n        Effect\n        ----------\n        out() : dicto\n            copy current frame\'s locals() and globals() to your \n            Python interactive shell\n            That\'s mean any var befor `out()` will Transport to Python shell,\n            Even your are exec `out()` in Thearding\n            ps. `out(False)` will turn off the info print\n        p() : dicto\n            \xe5\xb0\x86\xe5\xbd\x93\xe5\x89\x8dframe\xe7\x9a\x84locals()\xe5\x92\x8cglobals()\xe5\xad\x98\xe5\x85\xa5p\n            p.var_name is the var\'s value in locals() and globals()\n        lc : callabel dicto\n            lc\xe5\x88\x99\xe5\xad\x98\xe5\x82\xa8\xe6\x9b\xb4\xe5\xa4\x9a\xe3\x80\x81\xe6\x9b\xb4\xe7\xbb\x86\xe8\x87\xb4\xe7\x9a\x84\xe4\xbf\xa1\xe6\x81\xaf \xe5\x8c\x85\xe5\x90\xabcode, frame, frames\xe6\xa0\x88\n            lc \xe7\x9a\x84 items\xef\xbc\x9a\n                self.c = self.code = frame.f_code\n                self.l = self.local = locals()\n                self.f = self.frame = frame\n                self.fs = getFatherFrames(frame) \n        \'\'\'\n        def __init__(self, out=False):\n            saveOut[id(self)] = out\n        def __call__(self, depth=0, printt=True):\n            if depth is False:\n                printt = depth\n                depth = 0\n            frame = sys._getframe(depth+1)\n            code = frame.f_code\n            p.clear()\n            glob = frame.f_globals\n            local = frame.f_locals\n                \n            self.c = self.code = code\n            self.f = self.frame = frame\n            self.l = self.local = local\n            if printt:\n                print(\'\')\n                prettyStr = prettyFrameLocation(frame)\n                print(prettyStr)\n                fs = getFatherFrames(frame)\n                self.fs = fs\n                s = prettyFrameStack(frame)\n                print((colorFormat.b%\'Stacks: \'+colorFormat.r%s))\n                print((colorFormat.b%\'Locals: \'))\n                from boxx import tree\n                tree(local, maxprint=100)\n                \n            if saveOut[id(self)]:\n                p.update(glob)\n                p.update(local)\n                root = getRootFrame()\n                addDic = dict(\n#                        code=code,\n#                        frame=frame,\n#                        local=local,\n#                        glob=glob,\n#                        gl=glob,\n#                        rootGlob=root.f_globals,\n                        )\n                \n                \n                addDic.update(local)\n                same = set(addDic).intersection(set(root.f_globals))\n                \n                if printt:\n                    print("""")\n                    addVarStr = \', \'.join([colorFormat.p%k for k in addDic if k not in same])\n                    if addVarStr:\n                        print(colorFormat.b% \'\\nVars add to Console Frame: \'+\'\\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 \'+ addVarStr)\n                    if len(same):\n                        print(colorFormat.r% \'\\nVars that replaced in Console Frame: \'+\'\\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 \'+\', \'.join([colorFormat.p%k for k in same]))\n                root.f_globals.update(addDic)\n                lc.c = lc.code = code\n                lc.f = lc.frame = frame\n                lc.l = lc.local = local\n                self.clear()\n                self.update(local)\n    \n    \n    __P_CACHE__ = dicto()\n    class Pdicto(dicto):\n        \'\'\'\n        # print(x) and return x\n        >>> p/517 \n        517\n        517\n        \n        # p() to pretty print all variables in function with thier name\n        >>> def f(arg=517):\n                l = [1, 2]\n                p()\n        \n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 l: list  2\n            \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 0: 1\n            \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 1: 2\n            \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 arg: 517\n        import boxx.p has same usage\n        \n        # p will pretty print mulit variables under ""with statement""\n        \n        >>> with p:\n            \n        \'\'\'\n        def __call__(self, depth=0, printt=True):\n            if depth is False:\n                printt = depth\n                depth = 0\n            lc(depth+1, printt)\n        def printt(self, x=None):\n            pretty = False\n#            root = getRootFrame()\n#            root.f_globals[\'pp\'] = x\n            if pretty:\n                loc = prettyFrameLocation(1)\n                pblue(\'Print by p from %s:\'%loc)\n            else:\n                pass\n#                pblue(\'%s: %s\'%(clf.p%\'As pp by p\', x))\n                print(x)\n            return x\n        __sub__ = printt\n        __lshift__ = printt\n        __rshift__ = printt\n        __truediv__ = __div__ = printt\n        __pow__ = printt\n        \n        def __enter__(self):\n            d = __P_CACHE__\n            if \'wo\' not in d:\n                d.wo = withOperation(\'p\', printt=True, transport=False, deep=1)\n            return withOperation.__enter__(d.wo)\n        def __exit__(self, typee, value, traceback):\n            d = __P_CACHE__\n            withOperation.__exit__(d.wo, typee, value, traceback)\n    p = Pdicto()\n    lc = LocalAndGlobal()\n    out = LocalAndGlobal(out = True)\n    return p, lc, out\np, lc, out = generaPAndLc()\npp = ""registered `pp` var name that will be used by `p/x`""\n#pp, lcc, outt = generaPAndLc()\n\n'"
boxx/tool/toolMarkdown.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\n@author: DIYer22@github\n@mail: ylxx@live.com\nCreated on Wed Jan  9 23:24:20 2019\n""""""\nimport pandas as pd\nimport numpy as np\n\n\nclass Markdown(pd.DataFrame):\n    """"""\n    Markdown class base on DataFrame\n    """"""\n\n    def round(self, decimals=0, **kv):\n        self._decimals = decimals\n        redf = pd.DataFrame.round(self, decimals, **kv)\n        md = Markdown(redf)\n        md._decimals = decimals\n        return md\n\n    __round__ = round\n\n    def to_md(self, nblankBetweenCell=1, tableMidSymbol=""---:""):\n        """"""\n        Transfer DataFrame to markdown\n        \n        Parameters\n        ----------\n        df : DataFrame\n            pandas.DataFrame\n        \n        nblankBetweenCell : int, default 1\n            How many blanks between 2 cells\n        tableMidSymbol : str, default ""---:""\n            ""-:"", "":-"", "":-:"" for markdown \n        \n        """"""\n        df = self\n\n        blanks = nblankBetweenCell * "" ""\n        betweenCell = blanks + ""|"" + blanks\n        rowFormat = ""|%s%s%s|"" % (blanks, ""%s"", blanks)\n        ncols = len(df.columns)\n        strcols = df.columns.map(str)\n        lencols = np.array(strcols.map(len))\n\n        def try_round(v):\n            if ""_decimals"" in self.__dict__:\n                try:\n                    format_str = ""%."" + str(self._decimals) + ""f""\n                    s = format_str % v\n                    return s\n                except:\n                    pass\n            return str(v)\n\n        strdf = df.applymap(try_round)\n        lendf = np.array(strdf.applymap(len))\n\n        maxLens = np.array(\n            list(zip(lendf.max(0), lencols, [len(tableMidSymbol)] * ncols))\n        ).max(1)\n\n        vMulBlank = np.vectorize(lambda x: x * "" "")\n\n        mdcols = vMulBlank(maxLens - lencols) + strcols\n        mddf = vMulBlank(maxLens - lendf) + strdf\n\n        headstr = rowFormat % betweenCell.join(mdcols)\n\n        tableMidStr = rowFormat % betweenCell.join(\n            map(lambda x: x + tableMidSymbol, vMulBlank(maxLens - len(tableMidSymbol)))\n        )\n\n        bodystr = ""\\n"".join(\n            map(lambda kv: rowFormat % betweenCell.join(kv[-1]), mddf.iterrows())\n        )\n\n        tablestr = ""\\n"".join([headstr, tableMidStr, bodystr])\n        return tablestr\n\n    def __str__(self):\n        return self.to_md()\n\n    @staticmethod\n    def test():\n        df = pd.DataFrame(\n            [\n                {""a"": 1, ""b"": 1, ""d"": ""str""},\n                {""a"": 1, ""b"": 1, ""c"": 0.1},\n                {""a"": 1, ""b"": 1 / 2, ""c"": 1 / 3},\n            ]\n        )\n        md = Markdown(df).round(2)\n        print(md)\n        print(""-"" * 20)\n        print(md.round(2))\n        return df\n\n\nif __name__ == ""__main__"":\n    Markdown.test()\n'"
boxx/tool/toolStructObj.py,1,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nfrom ..ylsys import py2\nfrom ..ylcompat import istype\n\nimport sys\nimport inspect\nfrom collections import defaultdict\n\ndef listToBatch(listt, batch):\n    \'\'\'\n    \xe5\xb0\x86\xe4\xb8\x80\xe6\xae\xb5\xe5\xba\x8f\xe5\x88\x97\xe6\x8c\x89\xe7\x85\xa7\xe6\xaf\x8fbatch\xe4\xb8\xaa\xe5\x85\x83\xe7\xb4\xa0\xe7\xbb\x84\xe6\x88\x90\xe4\xb8\x80\xe7\xbb\x84\n    \n    >>> listToBatch(range(8),3)\n    [(0, 1, 2), (3, 4, 5), (6, 7)]\n    \'\'\'\n    n = len(listt)\n    left = n % batch\n    if left:\n        ind  = n - left\n        listt, tail = listt[:ind], tuple(listt[ind:])\n    ziped = list(zip(*[iter(listt)]*batch))\n    if left:\n        ziped.append(tail)\n    return ziped\n\nclass _SliceToInt():\n    \'\'\' convert float to int when in slice\n    >>> range(5)[sliceInt[3.3]]\n    3\n    \n    >>> range(5)[sliceInt[-0.1: 3.3]]\n    range(0, 3)\n    \'\'\'\n    def intround(self, v):\n        if v is None:\n            return v\n        return int(round(v))\n    def __intSlice(self, s):\n        intround = self.intround\n        return slice(intround(s.start), intround(s.stop), intround(s.step),)\n    def __getitem__(self, index):\n        def f(t):\n            if isinstance(t, tuple):\n                return tuple(f(i) for i in t)\n            else:\n                if isinstance(t, slice):\n                    return self.__intSlice(t)\n                if isinstance(t, float):\n                    return int(round(t))\n                return t\n        if isinstance(index, (tuple, slice)):\n            return f(index)\n        return int(round(index))\n    @staticmethod\n    def test():\n        print(range(5)[sliceInt[3.3]])\n        print(range(5)[sliceInt[3.3:]])\nsliceInt = _SliceToInt()\n\nclass sliceLimit():\n    \'\'\' limit the value in slice by given numpy array\n    \n    >>> rr = np.zeros((4,4,4))\n    >>> sliceLimit(rr)[-1:2, :1000]\n    r[0:2, :4, :]\n    \n    >>> sliceLimit(rr, True)[-1:2, :1000]\n    (slice(0, 2, None), slice(None, 4, None))\n    \n    >>> sliceLimit(rr, True)[-1:2, ..., :1000]\n    (slice(0, 2, None), Ellipsis, slice(None, 4, None))\n    \'\'\'\n    def __init__(self, arr, returnSlice=False):\n        self.arr = arr\n        self.shape = arr.shape\n        self.returnSlice = returnSlice\n    def getitem(self, index):\n        shape = self.shape\n        def sliceTupleLimit(slicee, maxx):\n            if not isinstance(slicee, slice):\n                return slicee\n            return slice(\n                    None if slicee.start is None else max(0, slicee.start), \n                    None if slicee.stop is None else min(maxx, slicee.stop), \n                    slicee.step)\n        if isinstance(index, slice):\n            return sliceTupleLimit(index, shape[0])\n        if isinstance(index, tuple):\n            splitInd = index.index(Ellipsis) if Ellipsis in index else len(index)\n            left = tuple(sliceTupleLimit(slicee, n)  for slicee, n  in zip(index[:splitInd], shape))    \n            right = tuple(sliceTupleLimit(slicee, n)  for slicee, n  in zip(index[splitInd+1:][::-1], shape[::-1]))[::-1]\n            middle = (Ellipsis,) if Ellipsis in index else ()\n            return left + middle + right\n        return index\n    def __getitem__(self, index):\n        new_index = self.getitem(index)\n        if self.returnSlice:\n            return new_index\n        return self.arr[new_index]\n    @staticmethod\n    def test():\n        import numpy as np\n        rr = np.zeros((4,4,4))\n        print(sliceLimit(rr, True)[-1:2, :1000])\n        print(sliceLimit(rr, True)[-3:80, ..., -3:80])\n\nclass Ll(list):\n    \'\'\'\n    a tool for convenient list operate\n    \n    1. quick exec `list(range(int))` buy ll*int:\n    >>> ll*4\n    [0, 1, 2, 3] \n    \n    2. `ll-Iterable`, `ll/Iterable` is a convenient way to exec `list(Iterable)`\n    \'\'\'\n    def __init__(self):\n        list.__init__(self, [0, 1])\n    def __sub__(self, intOrLazyIter):\n        if isinstance(intOrLazyIter, int):\n            return self * intOrLazyIter\n        return list(intOrLazyIter)\n    def __mul__(self, intt):\n        return list(range(intt))\n    __call__ = __truediv__ = __div__ = __sub__\nll = Ll()\n\nCALL_CLASS_CACHE={}\ndef addCall(instance):\n    \'\'\'\n    instance\xe5\xa2\x9e\xe5\x8a\xa0__call__ \xe8\xbf\x94\xe5\x9b\x9e\xe8\x87\xaa\xe5\xb7\xb1\n    \'\'\'\n    t = type(instance)\n    if t not in CALL_CLASS_CACHE:\n        class T(t):\n            def __call__(self):\n                return self\n        CALL_CLASS_CACHE[t]=T\n    return CALL_CLASS_CACHE[t](instance)\n\n\nfun_add_magic_paras = defaultdict(lambda :{})\nclass FunAddMagicMethodCore(object):\n    \'\'\'magic \xe6\x9c\xaa\xe8\xa7\xa3\xe4\xb9\x8b\xe8\xb0\x9c \xe7\x96\x91\xe6\x83\x91\n    \n    >>> z=FunAddMagicMethod(zip)\n    >>> isinstance(z,type(zip)) => True\n    >>> isinstance(z,object) => True\n    \'\'\'\n    def __init__(self, fun, returnArg=False):\n        fun_add_magic_paras[id(self)][\'fun\'] = fun\n        fun_add_magic_paras[id(self)][\'returnArg\'] = returnArg\n    def __call__(self, *args, **kv):\n        resoult = fun_add_magic_paras[id(self)][\'fun\']( *args, **kv)\n        if fun_add_magic_paras[id(self)][\'returnArg\'] and len(args)==1:\n            return args[0]\n        return resoult\n    __sub__ = __call__\n    __mul__ = __call__\n    __pow__ = __call__\n#    __add__ = __call__\n#    __eq__ = __call__\n#    __invert__ = __call__\n    def __div__(self, *args, **kv):\n        fun_add_magic_paras[id(self)][\'fun\']( *args, **kv)\n        if len(args)==1:\n            return args[0]\n        return args\n    __truediv__ = __div__\n    def __str__(self):\n        return \'FunAddMagicMethod(%s)\'%fun_add_magic_paras[id(self)][\'fun\']\n    __repr__ = __str__\nclass FunAddMagicMethod(FunAddMagicMethodCore):\n    \'\'\'\n    add magic method to any callable instance or types,\n    then you can call they buy sub, mul, pow operator to call they conveniently\n    \n    >>> from math import sqrt\n    >>> magic_sqrt = mf - sqrt\n    >>> (magic_sqrt-9, magic_sqrt*9, magic_sqrt**9) \n    (3.0, 3.0, 3.0)\n    \n    >>> magic_sqrt/9\n    9\n    \n    the div operator is speacial, cause use div will return arg self\n    \n    magic_fun (- | * | **) arg => return fun(arg) \n    \n    magic_fun / arg = exec fun(arg) but return arg itself\n    \n    \n    \n    \xe5\xb0\x86\xe5\x87\xbd\xe6\x95\xb0\xe5\x8f\x98\xe4\xb8\xba\xe5\xb8\xa6\xe6\x9c\x89\xe9\xad\x94\xe6\xb3\x95\xe5\x87\xbd\xe6\x95\xb0 \xe4\xb8\x94\xe5\x8f\xaf\xe4\xbb\xa5__call__\xe7\x9a\x84\xe5\xaf\xb9\xe8\xb1\xa1\n    fun : \xe9\x9c\x80\xe8\xa6\x81\xe5\xa2\x9e\xe5\x8a\xa0\xe4\xb8\xba\xe9\xad\x94\xe6\xb3\x95\xe5\xaf\xb9\xe8\xb1\xa1\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0\n    self - arg = fun(arg)\n    self / arg = fun(arg) return arg\n    \'\'\'\n    def __getattribute__(self, name=None, *l):\n        fun = fun_add_magic_paras[id(self)][\'fun\']\n#        from boxx import gg, tree\n        if name in dir(fun):\n#            tree-[gg.n/name ,gg.f/fun, gg.l/l]\n            return getattr(fun,name, *l)\n        if name in [\'__call__\', \'__class__\', \'__delattr__\', \'__dict__\', \'__dir__\', \'__div__\', \'__doc__\', \'__eq__\', \'__ge__\', \'__getattribute__\', \'__gt__\', \'__hash__\', \'__init__\', \'__init_subclass__\', \'__le__\', \'__lt__\', \'__module__\', \'__mul__\', \'__ne__\', \'__new__\', \'__pow__\', \'__reduce__\', \'__repr__\', \'__setattr__\', \'__str__\', \'__sub__\', \'__truediv__\']:\n            return FunAddMagicMethodCore.__getattribute__(self, name, *l)\n        return getattr(fun,name, *l)\nmf = FunAddMagicMethod(FunAddMagicMethod)\n\n# invalid a function\nfnone = mf(lambda *l, **kv: l[0] if len(l)==1 else l)\n\nclass dicto(dict):\n    \'\'\'\n    a subclass of dict for convenient, like object in JavaScript\n    \n    >>> d = dicto(a=0)\n    >>> d.b = 1\n    >>> print(d)\n    {\'a\': 0, \'b\': 1}\n    \n    \xe7\xb1\xbb\xe4\xbc\xbc JavaScript \xe5\xaf\xb9\xe8\xb1\xa1\xe7\x9a\x84\xe8\xb6\x85\xe7\xba\xa7\xe5\xad\x97\xe5\x85\xb8\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x8a\xa8\xe6\x80\x81\xe6\xb7\xbb\xe5\x8a\xa0\xe5\xb1\x9e\xe6\x80\xa7\n    \xe5\x85\xb6\xe4\xb8\xad dicto.keys,dicto.values,dicto.items \xe6\xb7\xbb\xe5\x8a\xa0\xe4\xba\x86property\n    \xe8\xbf\x99\xe4\xb8\xaa\xe5\x8f\x8d\xe5\xb0\x84\xe6\x9c\xba\xe5\x88\xb6\xe6\x98\xaf\xe8\xaf\x95\xe5\x87\xba\xe6\x9d\xa5\xe7\x9a\x84 \xe5\x8e\x9f\xe7\x90\x86\xe8\xbf\x98\xe4\xb8\x8d\xe6\xb8\x85\xe6\xa5\x9a\n    \'\'\'\n    def __init__(self, *l, **kv):\n        dict.__init__(self,*l,**kv)\n    def __getattribute__(self, name=None):\n        if name in dir(dict):\n            return dict.__getattribute__(self,name)\n        if name in self:\n            return self[name]\n        return None\n    def __setattr__(self, name, v):\n        if name in dir(dict):\n            return dict.__setattr__(self,name,v)\n        self[name] = v\n    if py2:\n        @property\n        def keys(self):\n            return addCall(dict.keys(self))\n        @property\n        def values(self):\n            return addCall(dict.values(self))\n        @property\n        def items(self):\n            return addCall(dict.items(self))\nSuperDict = dicto\n\ndef _yield():\n    yield 0\ngenerator = type(_yield())\n\ndef dicToObj(dic):  \n    \'\'\'\n    \xe5\xb0\x86 dict \xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba\xe6\x98\x93\xe4\xba\x8e\xe8\xb0\x83\xe7\x94\xa8\xe7\x9a\x84 Object\n    \'\'\'\n    top = type(\'MyObject\'.encode(\'utf-8\'), (object,), dic)  \n    seqs = tuple, list, set, frozenset  \n    for i, j in list(dic.items()):  \n        if isinstance(j, dict):  \n            setattr(top, i, dicToObj(j))  \n        elif isinstance(j, seqs):  \n            setattr(top, i,   \n                type(j)(dicToObj(sj) if isinstance(sj, dict) else sj for sj in j))  \n        else:  \n            setattr(top, i, j)  \n    return top  \n    \n\ndef typeNameOf(classOrType):\n    \'\'\'\n    \xe4\xbb\xa5str \xe8\xbf\x94\xe5\x9b\x9eclassOrType\xe7\x9a\x84\xe6\x89\x80\xe5\xb1\x9e\xe7\xb1\xbb\xe5\x88\xab  \n    \n    >>> typeNameOf(dict) \n    u\'dict\'\n    \'\'\'\n    ss = str(classOrType).split(""\'"")\n    if len(ss)>=3:\n        return ss[-2]\n    return str(classOrType)\n\ndef typestr(instance):\n    \'\'\'\n    \xe4\xbb\xa5str \xe8\xbf\x94\xe5\x9b\x9einstance\xe7\x9a\x84\xe6\x89\x80\xe5\xb1\x9e\xe7\xb1\xbb\xe5\x88\xab  \n    \n    >>> typestr({}) \n    u\'dict\'\n    \'\'\'\n    return typeNameOf(type(instance))\ntypestr = FunAddMagicMethod(typestr)\n\ndef strMethodForDiraAttrs(self, pattern=\'^[^_]\'):\n    \'\'\'\n    the default of __str__ method in Class\n    \n    will return string of dira(self) \n    \n    \'\'\'\n    from boxx import dira, PrintStrCollect\n    printf = PrintStrCollect()\n    dira(self, pattern=pattern, printf=printf, printClassFathers=False)\n    s = str(printf)\n    if py2:\n        s = s[s.index(u\'\xe2\x94\x94\'.encode(\'utf-8\')):]\n        return s\n    s = s[s.index(\'\xe2\x94\x94\'):]\n    return s\n\ndef nextiter(iterr, raiseException=True):\n    \'\'\'\n    do next(iter(iterAble)) then return resoult\n    \n    while iterr is empty and raiseException is False, just return  \'\xe3\x80\x90Iterable is empty!\xe3\x80\x91\'\n    \'\'\'\n    re = default = \'\xe3\x80\x90Iterable is empty!\xe3\x80\x91\'\n    for i in iterr:\n        re = i\n        break\n    if raiseException and re is default:\n        raise StopIteration(\'Iterable is empty!\')\n    return re\nnextiter = FunAddMagicMethod(nextiter)\n\ndef getfathers(objOrType):\n    \'\'\'\n    \xe8\x8e\xb7\xe5\xbe\x97 objOrType \xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe7\x88\xb6\xe7\xb1\xbb\xef\xbc\x8c\xe4\xbb\xa5 tuple \xe8\xbf\x94\xe5\x9b\x9e\n    \n    Parameters\n    ----------\n    objOrType : obj or type (includ classobj in python 2)\n        if is obj, \xe5\x88\x99\xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba type(obj)\n    \'\'\'\n    if not istype(objOrType):\n        objOrType = type(objOrType)\n    return inspect.getmro((objOrType))\ngetfathers = FunAddMagicMethod(getfathers)\n\ndef getfather(objOrType): \n    \'\'\'\n    \xe8\x8e\xb7\xe5\xbe\x97 objOrType \xe7\x9a\x84\xe7\x88\xb6\xe7\xb1\xbb\n    \n    Parameters\n    ----------\n    objOrType : obj or type (includ classobj in python 2)\n        if is obj, \xe5\x88\x99\xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba type(obj)\n    \'\'\'\n    return getfathers(objOrType)[0]\ngetfather = FunAddMagicMethod(getfather)\n    \n\ndef setself(self=None):\n    \'\'\'\n    set all method(*args)  to self.__dict__ \n    \n    >>> class A():\n    ...     def __init__(self, attr=\'attr\'):\n    ...         setself()\n    >>> a=A()\n    >>> a.attr\n    \'attr\'\n    \'\'\'\n    local = sys._getframe(1).f_locals\n    if self is None:\n        self = local[\'self\']\n    self.__dict__.update(local)\n#    tree-local\n\ndef unfoldself(self=None):\n    \'\'\'\n    set all self.__dict__ to locals()\n    \n    >>> class A():\n    ...     def __init__(self):\n    ...         self.attr=\'attr\'\n    ...     def get_attr(self):\n    ...         unfoldself()\n    ...         return attr\n    >>> a=A()\n    >>> a.get_attr()\n    \'attr\'\n    \n    ps. if vars name in locals(), the vars won\'t be cover\n    \'\'\'\n    local = sys._getframe(1).f_locals\n    if self is None:\n        self = local[\'self\']\n    for k, v in self.__dict__.items():\n        if k not in local:\n            local[k] = v\n\nclass withfun():\n    \'\'\'\n    Convenient way to use `with statement` without build a Class\n    enterFun and exitFun are no parameter function\n    \n    Parameters\n    ----------\n    enterFun : function, default None\n        No parameter function\n    exitFun : function, default None\n        No parameter function or parameter are (exc_type, exc_value, exc_traceback)\n    exception : bool, default False\n        Whether send (exc_type, exc_value, exc_traceback) to exitFun\n    \'\'\'\n    def __init__(self, enterFun=None, exitFun=None, exception=False):\n        self.enterFun = enterFun\n        self.exitFun = exitFun\n        self.exception = exception\n    def __enter__(self):\n        if self.enterFun:\n            return self.enterFun()\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        if self.exitFun:\n            if self.exception:\n                self.exitFun(exc_type, exc_value, exc_traceback)\n            else:\n                self.exitFun()\n\n\nclass withattr():\n    """"""\n    set attr or item in `with statement`, after __exit__ the obj or dict will recovery like befor \n    \n    Parameters\n    ----------\n    obj : obj or dict\n        the thing that will change attr or item in with statement\n    attrs_or_key : dict or str\n        dict: the attrs or items that will change during with statement\n        str: the key of the attr\n    value: anything, default None\n        when attrs_or_key is string(key), this arg as value\n    \n    Usage\n    ----------\n    \n    >>> with withattr(dict(), \'attr\', \'value\') as d:\n    ...     print(d[\'attr\'])\n    ""value""\n    >>> \'attr\' in d\n    False\n    \n    >>> with withattr(dict(), {\'attr\':\'value\'}) as d:\n    ...     print(d[\'attr\'])\n    ""value""\n    >>> \'attr\' in d\n    False\n        \n    ps. `withattr` will detect whther the obj is dict, then choose setattr or setitem.\n    """"""\n\n    def __init__(self, obj, attrs_or_key, value=None):\n        self.obj = obj\n\n        if isinstance(attrs_or_key, str):\n            attrs = {attrs_or_key: value}\n        else:\n            attrs = attrs_or_key\n\n        d = obj\n\n        sett = (\n            (lambda d, k, v: d.__setitem__(k, v)) if isinstance(obj, dict) else setattr\n        )\n        get = (lambda d, k: d[k]) if isinstance(obj, dict) else getattr\n        pop = (lambda d, k: d.pop(k)) if isinstance(obj, dict) else delattr\n        has = (lambda d, k: k in d) if isinstance(obj, dict) else hasattr\n\n        def enter_func():\n            self.old = {}\n            for k, v in attrs.items():\n                if has(d, k):\n                    self.old[k] = get(d, k)\n                sett(d, k, v)\n            return d\n\n        def exit_func():\n            for k in attrs.keys():\n                if k in self.old:\n                    sett(d, k, self.old[k])\n                else:\n                    pop(d, k)\n\n        self.enter_func = enter_func\n        self.exit_func = exit_func\n    def __enter__(self):\n        return self.enter_func()\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        return self.exit_func()\n    \ndef isinstancestr(obj, typeStrList):\n    \'\'\'\n    same as isinstance but only use type name strs to avoid `import torch.tensor` .etc\n    \n    Parameters\n    ----------\n    obj : object\n        anything\n    typeStrList : str or list of strs\n        like tuple of types for isinstance\n    \n    Return\n    ----------\n    if True return the type name str\n    \'\'\'\n    if isinstance(typeStrList, str):\n        typeStrList = [typeStrList]\n    types = getfathers(obj)\n    typestrs = list(map(typeNameOf, types))\n    for t in typeStrList:\n        if t in typestrs:\n            typestrs.index(t)\n            return t\n    return False\n\nif __name__ == ""__main__"":\n\n    pass'"
boxx/tool/toolSystem.py,0,"b'# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nimport sys, os, time\nfrom ..ylsys import py2, tmpYl, sysi\nfrom ..ylcompat import isstr, beforImportPlt, ModuleNotFoundError\n\nfrom .toolIo import filename\n\n\ndef importAllFunCode(mod=None):\n    \'\'\'\n    mod \xe4\xb8\xba\xe5\x8c\x85\xe5\x90\x8d(type(mod)==\'str\')\xe6\x88\x96\xe5\x8c\x85\xe6\x9c\xac\xe8\xba\xab(type(mod)==module)\n    \xe8\x87\xaa\xe5\x8a\xa8\xe7\x94\x9f\xe6\x88\x90\xe5\xaf\xbc\xe5\x85\xa5\xe6\x89\x80\xe6\x9c\x89\xe6\xa8\xa1\xe5\x9d\x97\xe8\xaf\xad\xe5\x8f\xa5 \xe5\xb9\xb6\xe8\xbf\x87\xe6\xbb\xa4\xe6\x8e\x89__name__\xe7\xad\x89\n    \'\'\'\n    if mod is None:\n        mod = \'yllab\'\n    if isinstance(mod,str):\n        exec (\'import %s as mod\'%mod)\n\n    names = [name for name in dir(mod) if not ((len(name)>2 and name[:2]==\'__\') or \n                                  name in [\'unicode_literals\',])]\n    n = 5\n    lines = []\n    while len(names) > n:\n        l,names = names[:n],names[n:]\n        lines += [\', \'.join(l)]\n    lines += [\', \'.join(names)]\n    lines = \',\\n          \'.join(lines)\n    \n    strr = ((""from %s import *\\n    from %s import (%s)""%(mod.__name__,mod.__name__,lines)))\n    strr = \'\'\'from %s import *\ntry:\n    from %s import (%s)\nexcept ImportError:\n    pass\'\'\'%(mod.__name__,mod.__name__,lines)\n    print(strr)\n\nclass impt():\n    \'\'\'\n    Only one import to support both environments : __name__ == \'__main__\' or in a package.\n    And no need relative import.\n        \n    usage\xef\xbc\x9a \n        using: \n            >>> with impt():\n            >>>     import local_py\n        instead of :\n            >>> if __name__ == \'__main__\':\n            >>>     import local_py\n            >>> else:\n            >>>     from . import local_py\n            \n    Principle\xef\xbc\x9a\n        temporary add the relpath in sys.path during with statement\n        \n    Parameters\n    ----------\n    relpath: str, default\n        the dir path of the .py file that you want to import\n        \n    Zh-cn: \n        \xe5\x9c\xa8\xe5\x8c\x85\xe5\x86\x85\xe6\x88\x96 __name__ == \'__main__\' \xe9\x83\xbd\xe8\x83\xbd\xe7\x9b\xb4\xe6\x8e\xa5\xe5\xaf\xbc\xe5\x85\xa5\xe6\x96\x87\xe4\xbb\xb6.\n    \'\'\'\n    from multiprocessing import Lock\n    lock = Lock() # ensure work fine in multi threding\n    def __init__(self, relpath=\'.\'):\n        frame = sys._getframe(1)\n        _file_ = frame.f_globals[\'__file__\']\n        dirr = os.path.dirname(_file_)\n        self.d = os.path.abspath(os.path.join(dirr, relpath))\n    def __enter__(self):\n        with self.lock:\n            sys.path.insert(0, self.d)\n    def __exit__(self,*l):\n        with self.lock:\n            if sys.path[0] == self.d:\n                assert sys.path.pop(0)==self.d, \'impt sys.path error\'\n            else:\n                ind = sys.path.index(self.d)\n                assert sys.path.pop(ind)==self.d, \'impt sys.path error\'\n\n\nclass inpkg():\n    \'\'\'\n    inpkg = in package\n    \n    Execute relative import under __name__ == \'__main__\' enviroment in a package.\n        \n    usage\xef\xbc\x9a \n        using: \n            >>> with inpkg():\n            >>>     from . import local_py\n            \n    Principle\xef\xbc\x9a\n        auto search and import ""top level package"". Then, temporary replace __name__ to ""module name under top level package"" during with statement\n        \n    Zh-cn: \n        \xe5\x8f\xaf\xe4\xbb\xa5\xe8\x83\xbd\xe7\x9b\xb4\xe6\x8e\xa5\xe8\xbf\x90\xe8\xa1\x8c\xe5\x8c\x85\xe5\x86\x85\xe5\x90\xab\xe6\x9c\x89 relative import code \xe7\x9a\x84 py \xe6\x96\x87\xe4\xbb\xb6\n    \'\'\'\n    def __init__(self):\n        frame = sys._getframe(1)\n        self.frame = frame\n        self._file_ = frame.f_globals[\'__file__\']\n        self._name_ = frame.f_globals[\'__name__\']\n        # NOTICE: second time %run will no \'__package__\' key\n        self._package_ = self.frame.f_globals.get(\'__package__\', None)  \n        self.importTopLevelPackage = self._name_ == \'__main__\' or self._name_ == filename(self._file_)\n        \n    def findPackageRoot(self):\n        dirr  = os.path.abspath(self._file_)\n        files = []\n        while len(dirr) > 1:\n            files.append(filename(dirr))\n            dirr = os.path.dirname(dirr)\n            _init_p = os.path.join(dirr, \'__init__.py\')\n            if not os.path.isfile(_init_p):\n                return dirr, files\n        raise Exception(\'Has __init__.py in root ""/__init__.py""\')\n        \n    def __enter__(self):\n        if self.importTopLevelPackage:\n            packageroot, files = self.findPackageRoot()\n            importByPath(os.path.join(packageroot, files[-1]))\n            self.frame.f_globals[\'__name__\'] = \'.\'.join(files[::-1])\n            self.frame.f_globals[\'__package__\'] = \'.\'.join(files[1:][::-1])\n            \n    def __exit__(self,*l):\n        if self.importTopLevelPackage:\n            self.frame.f_globals[\'__name__\'] = self._name_\n            if self._package_ is None:\n                self.frame.f_globals.pop(\'__package__\')\n            else:\n                self.frame.f_globals[\'__package__\'] = self._package_\n\n\ndef importByPath(pyPath):\n    \'\'\'\n    import `.py` file by a python file path, return the py file as a moudle\n\n    >>> module = importByPath(\'far/away.py\')\n    \'\'\'\n    from boxx import os, dirname, sys, withfun\n    pyFile = pyPath\n    assert os.path.isfile(pyFile) or os.path.isdir(pyFile), pyFile\n    dirr = dirname(pyFile)\n    import importlib\n    def exitFun():\n        assert sys.path.pop(0)==dirr\n    with withfun(lambda :sys.path.insert(0, dirr), exitFun):\n        module = importlib.import_module(os.path.basename(pyFile).replace(\'.py\',\'\'))\n        return module\n    \ndef tryImport(moduleName):\n    \'\'\'\n    try `import @moduleName`. if @moduleName is not installed, return a FakeModule to placeholder the module name\n    \'\'\'\n    module = None\n    try:\n        exec(\'import %s as module\' % moduleName)\n        return module\n    except (ModuleNotFoundError, ImportError):\n        return  \'\'\'""%s"" is not install in your Python Enveroment! \nThis is a fake one. Please install ""%s"" and retry\'\'\' % (moduleName, moduleName)\n        return FakeModule(moduleName)\n__FAKE_DIC__ = {}\nclass FakeModule():\n    \'\'\'\n    a fake Module to placeholder the module name that some module may not installed.\n    once use this module, will raise ImportError\n    \'\'\'\n    def __init__(self, name):\n        __FAKE_DIC__[id(self)] = \'""%s"" is not install in your Python Enveroment! This is a fake one. Please install ""%s"" and retry\' % (name, name)\n    def __getattribute__(self, name=None, *l):\n        raise ImportError(__FAKE_DIC__[id(self)])\n    def __getattr__(self, name):\n        raise ImportError(__FAKE_DIC__[id(self)])\n    def __setattr__(self, name, v, *l):\n        raise ImportError(__FAKE_DIC__[id(self)])\n    def __str__(self):\n        errorMsg = __FAKE_DIC__[id(self)]\n        raise ImportError(errorMsg)\n    __repr__ = __str__\n\ndef removeImportSelf(modelName=\'boxx.out\'):\n    \'\'\'\n    remove a model while import itself\n    that mean every time import model will exec model again\n    \n    Notice: Only support Python 3, For Python 2 only first time import works \n    \'\'\'\n    if py2 :\n        return \n    sys.modules.pop(modelName)\n    \n    f = sys._getframe(4)\n    if \'spec\' in f.f_locals:\n        f.f_locals[\'spec\'].name = \'sys\'\n\ndef removeimp(modulesName=\'boxx\'):\n    \'\'\'\n    remove all module by name\n    \'\'\'\n    [sys.modules.pop(k) for k,v in list(sys.modules.items()) if k.startswith(modulesName + \'.\') or k == modulesName]\n\ndef crun(pycode, snakeviz=True):\n    \'\'\'\n    use snakeviz and cProfile to analyse the code performance\n    a visualization flame graph web page will be opened in your web browser\n    \n    Parameters\n    ----------\n    pycode : str\n        Python code\n    snakeviz : bool, default True\n        use snakeviz to get flame graph in web page\n        otherwise, print cProfile result sorted by time\n    \'\'\'\n    from cProfile import run\n\n    if not snakeviz:\n        return run(pycode,sort=\'time\')\n    import webbrowser\n    if not webbrowser.open(\'\'):\n        from boxx import warn\n        msg = \'\'\'**Can\'t detect browser** in operating environment.\nso, we use cProfile.run(pycode,sort=\'time\'),\ninstead of using snakeviz to visualization code perfomance in web page\'\'\'\n        warn(msg)\n        run(pycode,sort=\'time\')\n        print(\'\\n\\n\'+msg)\n        return \n    run(pycode, os.path.join(tmpYl, ""snakeviz.result""))\n    if not sysi.win:\n        from . import softInPath\n        assert softInPath(\'snakeviz\'),\'run `pip install snakeviz`\'\n        os.system(\'snakeviz %s &\'% os.path.join(tmpYl,\'snakeviz.result\'))\n    elif sysi.win:\n        os.system(\'start /b  snakeviz.exe %s \'% os.path.join(tmpYl,\'snakeviz.result\'))\n        \n    \ndef performance(pyfileOrCode, snakeviz=True):\n    \'\'\'\n    use snakeviz and cProfile to analyse the python file or python code performance\n    a visualization flame graph web page will be opened in your web browser\n    \n    Parameters\n    ----------\n    pyfileOrCode : str\n        Python file\'s path or python code\n    snakeviz : bool, default True\n        use snakeviz to get flame graph in web page\n        otherwise, print cProfile result sorted by time\n    \'\'\'\n    if pyfileOrCode.endswith(\'.py\'):\n        crun(""from boxx import runpyfile;runpyfile(\'%s\')""%pyfileOrCode)\n    else:\n        crun(pyfileOrCode)\n\nclass timeit():\n    \'\'\'\n    usage 1 :\n        >>> with timeit():\n        >>>     fun()\n    usage 2 :\n        >>> ti = timeit()\n        # run your code\n        >>> print ti()\n        \n    P.S `with timeit(0)` will convenient stop print \n    \'\'\'\n    def __init__(self,name=\'timeit\'):\n        self.last = self.begin = time.time()\n        self.log = isstr(name) or bool(name)\n        self.key = name\n        self.log_str = name\n        if callable(name):\n            if ""__qualname__"" in dir(name):\n                self.log_str = name.__qualname__\n            elif ""__name__"" in dir(name):\n                self.log_str = name.__name__\n\n    def __call__(self):\n        \'\'\'\xe8\xbf\x94\xe5\x9b\x9e\xe6\x97\xb6\xe9\x97\xb4\xe5\xb7\xae\'\'\'\n        t = time.time()\n        r = t -self.last\n        self.last = t\n        return r\n    def __enter__(self):\n        return self\n    def __exit__(self, typee, value, traceback):\n        self.t = time.time()-self.begin\n        self.p\n    @property\n    def s(self):\n        from .toolLog import strnum\n        if \'t\' not in self.__dict__:\n            self.t = self()\n        return strnum(self.t,6)\n    def __str__(self):\n        s=\'\\x1b[36m""%s"" spend time: %s\\x1b[0m\'%(self.log_str, self.s)\n        return s\n    @property\n    def p(self):\n        \'\'\'\xe7\x9b\xb4\xe6\x8e\xa5\xe6\x89\x93\xe5\x8d\xb0\xe5\x87\xba\xe6\x9d\xa5\'\'\'\n        if self.log:\n            print(self)\n\n\ndef heatmap(pathOrCode):\n    \'\'\'show the heatmap of code or python file\n    if raise UnicodeDecodeError in Python 2 which may cause by Chinese, Japaneses\n    then will replace all symbol not belong ascii to ""?$""\n    \n    Parameters\n    ----------\n    pathOrCode : str\n        .py file path or Python code\n    \n    Chinese:\n    \xe4\xbc\x9a\xe8\xae\xa9\xe4\xbb\xa3\xe7\xa0\x81\xe9\x87\x8c\xe9\x9d\xa2\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe5\x85\xa8\xe9\x83\xa8\xe5\xa4\xb1\xe6\x95\x88\n    \n    Parameters\n    ----------\n    pathOrCode : str of code or path of .py\n        .py\xe6\x96\x87\xe4\xbb\xb6\xe8\xb7\xaf\xe5\xbe\x84\xe6\x88\x96\xe7\x9d\x80python\xe4\xbb\xa3\xe7\xa0\x81\n    \'\'\'\n    beforImportPlt()\n    from pyheat import PyHeat\n    import matplotlib.pyplot as plt\n    tmppath = \'code-tmp-pyheat-boxx.py\'\n    \n    ispath = pathOrCode.endswith(\'.py\')\n    path = pathOrCode if ispath else tmppath\n    try :\n        if not ispath:\n            with open(tmppath,\'w\') as f:\n                f.write(pathOrCode)\n        ph = PyHeat(path)\n        ph.create_heatmap()\n        ph.show_heatmap()\n    except UnicodeDecodeError:\n        plt.show()\n        msg = \'\'\'UnicodeDecodeError! try to replace not ascii symbol to \'$?\' and retry\'\'\'\n        from boxx import warn\n        warn(msg)\n        \n        with open(path) as f:\n            code = f.read()\n        code = code.decode(\'ascii\',\'replace\').replace(\'\\ufffd\',\'$?\')\n        with open(tmppath,\'w\') as f:\n            f.write(code.encode(\'utf-8\'))\n        \n        ph = PyHeat(tmppath)\n        ph.create_heatmap()\n        ph.show_heatmap()\n    finally:\n        if os.path.isfile(tmppath):\n            os.remove(tmppath)\n\ndef strIsInt(s):\n    \'\'\'\xe5\x88\xa4\xe6\x96\xad\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe6\x98\xaf\xe4\xb8\x8d\xe6\x98\xaf\xe6\x95\xb4\xe6\x95\xb0\xe5\x9e\x8b\'\'\'\n    s = s.replace(\' \',\'\')\n    return s.isdigit() or (s[0]==(\'-\') and s[1:].isdigit())\n\ndef strIsFloat(s):\n    \'\'\'\xe5\x88\xa4\xe6\x96\xad\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe6\x98\xaf\xe4\xb8\x8d\xe6\x98\xaf\xe6\xb5\xae\xe7\x82\xb9\'\'\'\n    s = s.replace(\' \',\'\')\n    return s.count(\'.\')==1 and strIsInt(s.replace(\'.\',\'\'))\ndef strToNum(s):\n    \'\'\' \xe8\x8b\xa5\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe6\x98\xaffloat or int \xe6\x98\xaf\xe5\x88\x99\xe8\xbf\x94\xe5\x9b\x9e \xe6\x95\xb0\xe5\xad\x97 \xe5\x90\xa6\xe5\x88\x99\xe8\xbf\x94\xe5\x9b\x9e\xe6\x9c\xac\xe8\xba\xab\'\'\'\n    if strIsInt(s):\n        return int(s)\n    if strIsFloat(s):\n        return float(s)\n    return s\n\ndef getArgvDic(argvTest=None):\n    \'\'\'\n    \xe5\xb0\x86cmd\xe7\x9a\x84`python main.py arg1 arg2 --k v --tag`\xe5\xbd\xa2\xe5\xbc\x8f\xe7\x9a\x84\xe5\x91\xbd\xe4\xbb\xa4\xe8\xa1\x8c\xe5\x8f\x82\xe6\x95\xb0\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba(list, dict)\n    \xe8\x8b\xa5v\xe6\x98\xaf\xe6\x95\xb0\xe5\xad\x97 \xe5\xb0\x86\xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba int or float, --tag \xe5\xb0\x86\xe8\xa1\xa8\xe7\xa4\xba\xe4\xb8\xba dic[tag]=True\n    \n    Return\n    ----------\n    l : list\n        \xe5\x8e\xbb\xe9\x99\xa4\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8f\x82\xe6\x95\xb0 \xe6\x96\x87\xe4\xbb\xb6\xe5\x9c\xb0\xe5\x9d\x80\xe5\xa4\x96\xe7\x9a\x84 \xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa \'--\'\xe4\xb9\x8b\xe5\x89\x8d\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe5\x8f\x82\xe6\x95\xb0\n    dic : dict\n        `--k v` \xe5\xb0\x86\xe4\xbb\xa5{k: v}\xe5\xbd\xa2\xe5\xbc\x8f\xe5\xad\x98\xe6\x94\xbe\xe5\x9c\xa8dic\xe4\xb8\xad\n        `--tag` \xe5\xb0\x86\xe4\xbb\xa5{k: True}\xe5\xbd\xa2\xe5\xbc\x8f\xe5\xad\x98\xe6\x94\xbe\xe5\x9c\xa8dic\xe4\xb8\xad\n    \'\'\'\n    from .toolLog import  pred\n    argv = sys.argv\n    if argvTest:\n        argv = argvTest\n    l = argv = list(map(strToNum,argv[1:]))\n    code = [(isinstance(x,str) \n        and len(x) >2 and x[:2]==\'--\') for x in argv]\n    dic = {}\n    if True in code:\n        l = argv[:code.index(True)]\n        n = len(code)\n        for i,s in enumerate(code):\n            x = argv[i]\n            if int(s):\n                k = x.replace(\'--\',\'\')\n                if (i<=n-2 and code[i+1]) or i==n-1: # \xe4\xb8\x8d\xe5\xb8\xa6\xe5\x8f\x82\xe6\x95\xb0\n                    dic[k] = True\n                else:  # \xe5\xb8\xa6\xe5\x8f\x82\xe6\x95\xb0\n                    dic[k] = argv[i+1]\n    if len(dic) or len(l):\n        pred(\'command-line arguments are:\\n  %s and %s\'%(l,dic))\n    return l,dic\n\n\ndef softInPath(softName):\n    \'\'\'\n    \xe6\x98\xaf\xe5\x90\xa6\xe5\xae\x89\xe8\xa3\x85\xe5\x91\xbd\xe4\xbb\xa4\xe4\xb8\xbasoftName\xe7\x9a\x84\xe8\xbd\xaf\xe4\xbb\xb6\xef\xbc\x8c\xe5\x8d\xb3 \xe5\x88\xa4\xe6\x96\xadsoftName \xe6\x98\xaf\xe5\x90\xa6\xe5\x9c\xa8\xe7\x8e\xaf\xe5\xa2\x83\xe5\x8f\x98\xe9\x87\x8f\xe9\x87\x8c\xe9\x9d\xa2\n    \'\'\'\n    for p in os.environ[\'PATH\'].split(\';\' if sysi.win else \':\'):\n        if os.path.isdir(p) and softName in os.listdir(p):\n            return True\n    return False\n\ndef makedirs(dirr, randomDelay=0.0001):\n    os.makedirs(dirr, exist_ok=True)\n    return dirr\n\ndef execmd(cmd):\n    \'\'\'\n    execuld cmd and reutrn str(stdout)\n    \'\'\'\n    with os.popen(cmd) as stream:\n        if not py2:\n            stream = stream._stream\n        s = stream.read()\n    return s\n\ndef addPathToSys(_file_, pathToJoin=\'.\'):\n    \'\'\'\n    \xe5\xb0\x86 join(__file__, pathToJoin)  \xe5\x8a\xa0\xe5\x85\xa5 sys.path\n\n    Parameters\n    ----------\n    _file_ : str\n        .py \xe6\x96\x87\xe4\xbb\xb6\xe7\x9a\x84\xe8\xb7\xaf\xe5\xbe\x84 \xe5\x8d\xb3__file__ \xe5\x8f\x98\xe9\x87\x8f\n    pathToJoin : str, default \'.\'\n        \xe7\x9b\xb8\xe5\xaf\xb9\xe8\xb7\xaf\xe5\xbe\x84\n    \'\'\'\n    from os.path import abspath,join,dirname\n    apath = abspath(join(dirname(abspath(_file_)),pathToJoin))\n    if apath not in sys.path:\n        sys.path.append(apath)\n    return apath\n\ndef getFatherFrames(frame=0, endByMain=True):\n    \'\'\'\n    \xe8\xbf\x94\xe8\xbf\x98 frame \xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe7\x88\xb6 frame \xe5\x8d\xb3 Call Stack\n    \n    Parameters\n    ----------\n    frame : frame or int, default 0\n        if int:\xe7\x9b\xb8\xe5\xaf\xb9\xe4\xba\x8e\xe8\xb0\x83\xe7\x94\xa8\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0frame\xe7\x9a\x84 int \xe6\xb7\xb1\xe5\xba\xa6\xe7\x9a\x84\xe5\xaf\xb9\xe5\xba\x94frame\n    endByMain : bool, default True\n        \xe4\xb8\xba True \xe5\x88\x99\xe5\x9c\xa8\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa frame.f_locals[\'__name__\'] == \'__main__\' \xe5\xa4\x84\xe5\x81\x9c\xe6\xad\xa2\xe6\x90\x9c\xe5\xaf\xbb\n        \xe7\x9b\xae\xe7\x9a\x84\xe6\x98\xaf\xe5\x8e\xbb\xe9\x99\xa4 IPython \xe8\x87\xaa\xe8\xba\xab\xe5\xa4\x9a\xe4\xbd\x99\xe7\x9a\x84 Call Stack\n    \'\'\'\n    if frame is False and endByMain:\n        frame, endByMain = 0, False\n    if isinstance(frame, int):\n        frame = sys._getframe(1 + frame)\n    fs = []\n    while frame:\n        fs.append(frame)\n        if endByMain:\n            if \'__name__\' in frame.f_locals and frame.f_locals[\'__name__\'] == \'__main__\':\n                break\n        frame = frame.f_back\n    return fs\n\n\n\nmainFrame = []\ndef getMainFrame(frame=0):\n    \'\'\'\n    return a main frame from father frames that first frame.f_locals[\'__name__\'] == \'__main__\' \n    \n    Parameters\n    ----------\n    frame : frame or int, default 0\n        if int:\xe7\x9b\xb8\xe5\xaf\xb9\xe4\xba\x8e\xe8\xb0\x83\xe7\x94\xa8\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0frame\xe7\x9a\x84 int \xe6\xb7\xb1\xe5\xba\xa6\xe7\x9a\x84\xe5\xaf\xb9\xe5\xba\x94frame\n    \'\'\'\n    if len(mainFrame):\n        return mainFrame[0]\n    fs = getFatherFrames(frame=frame+1, endByMain=True)\n    main = fs[-1]\n    mainFrame.append(main)\n    return main\ngetMainFrame()\n\n\nrootFrame = []\ndef getRootFrame():\n    \'\'\'\n    return interactive frame\n    \'\'\'\n    if len(rootFrame):\n        return rootFrame[0]\n    frame=0\n    endByMain=False\n    fs = getFatherFrames(frame=frame+1, endByMain=endByMain)\n    root = getMainFrame()\n    \n    for f in fs:\n        if f.f_code.co_filename.startswith(\'<ipython-input-\'):\n            root = f\n            break\n    rootFrame.append(root)\n    return root\ngetRootFrame()\n\nif __name__ == ""__main__"":\n\n    pass'"
boxx/tool/toolTools.py,0,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\nimport re\nimport os\nimport random\nfrom os.path import join,isdir,isfile\nfrom glob import glob\nfrom collections import defaultdict\n\nfrom .toolIo import openread, openwrite, getsizem\nfrom .toolLog import log\n\nfrom ..ylsys import py2\n\nintround = lambda floatt: int(round(floatt))\n\n__increase_recording = defaultdict(lambda:-1)\ndef increase(namespace=None):\n    \'\'\'\n    \xe4\xbb\x8e0\xe5\xbc\x80\xe5\xa7\x8b \xe6\xaf\x8f\xe8\xb0\x83\xe7\x94\xa8\xe4\xb8\x80\xe6\xac\xa1\xe8\xbf\x94\xe5\x9b\x9e\xe7\x9a\x84\xe6\x95\xb0\xe5\x80\xbc\xe8\x87\xaa\xe5\xa2\x9e 1\xef\xbc\x8c \xe7\xb1\xbb\xe4\xbc\xbc SQL \xe4\xb8\xad\xe7\x9a\x84 AUTO_INCREMENT \xe5\xad\x97\xe6\xae\xb5\n    \n    Parameters\n    ----------\n    namespace : hashable, default None\n        \xe7\x94\xa8\xe4\xba\x8e\xe8\xae\xa1\xe6\x95\xb0\xe7\x9a\x84\xe5\x91\xbd\xe5\x90\x8d\xe7\xa9\xba\xe9\x97\xb4\n    \'\'\'\n    __increase_recording[namespace] += 1\n    return __increase_recording[namespace]\nincrease.d = __increase_recording\ndef filterList(key, strs):\n    \'\'\'\n    \xe5\xaf\xb9\xe4\xb8\x80\xe4\xb8\xaastr\xe5\x88\x97\xe8\xa1\xa8 \xe6\x89\xbe\xe5\x87\xba\xe5\x85\xb6\xe4\xb8\xad\xe5\xad\x98\xe5\x9c\xa8\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2 key\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe5\x85\x83\xe7\xb4\xa0\n    \'\'\'\n    return list(filter((lambda strr: key in strr),strs))\n\ndef findints(strr):\n    \'\'\'\n    \xe8\xbf\x94\xe5\x9b\x9e\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe6\x88\x96\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe5\x88\x97\xe8\xa1\xa8\xe4\xb8\xad\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe6\x95\xb4\xe6\x95\xb0 ,r""\\d+\\d*""\n    \'\'\'\n    if isinstance(strr,(list,tuple)):\n        return list(map(findints, strr))\n    return list(map(int,re.findall(r""-?\\d+\\d*"",strr)))\n\ndef randint(maxx=100):\n    return random.randint(0, maxx)\n\ndef randfloat():\n    return random.random()\n\ndef randchoice(seq, num=None):\n    \'\'\'\n    \xe9\x9a\x8f\xe6\x9c\xba\xe9\x80\x89\xe6\x8b\xa9\xe4\xb8\x80\xe4\xb8\xaa\xe5\x88\x97\xe8\xa1\xa8\xe5\x86\x85\xe7\x9a\x84\xe4\xb8\x80\xe4\xb8\xaa\xe6\x88\x96num\xe4\xb8\xaa\xe5\x85\x83\xe7\xb4\xa0\n    \'\'\'\n    if num is None:\n        return random.choice(seq)\n    return random.sample(seq, num)\n\ndef listdirWithFun(root=\'.\',fun=None):\n    \'\'\'\xe5\xaf\xb9root\xe8\xb7\xaf\xe5\xbe\x84\xe5\x8f\x8a\xe5\xad\x90\xe8\xb7\xaf\xe5\xbe\x84\xe4\xb8\x8b\xe7\x9a\x84\xe6\xaf\x8f\xe4\xb8\xaapath \xe6\x89\xa7\xe8\xa1\x8cfun\n    \n    Parameters\n    ----------\n    root : str, default \'.\'\n        \xe8\xb7\xaf\xe5\xbe\x84\n    fun : function\n        \xe5\xaf\xb9\xe6\xaf\x8f\xe4\xb8\xaa\xe5\xad\x90\xe8\xb7\xaf\xe5\xbe\x84\xe6\x89\xa7\xe8\xa1\x8cfun(path)\n    \'\'\'\n    paths = glob(join(root,\'*\'))\n    for path in paths:\n        if isdir(path):\n            listdirWithFun(path,fun)\n        if fun :\n            fun(path)\n\ndef replaceAllInRoot(old, new, root=\'.\', types=\'py\'):\n    \'\'\'\xe5\xaf\xb9root\xe8\xb7\xaf\xe5\xbe\x84\xe5\x8f\x8a\xe5\xad\x90\xe8\xb7\xaf\xe5\xbe\x84\xe4\xb8\x8b\xe7\x9a\x84\xe6\xaf\x8f\xe4\xb8\xaatypes\xe6\x96\x87\xe4\xbb\xb6\xe7\xb1\xbb\xe5\x9e\x8b \xe6\x89\xa7\xe8\xa1\x8c\xe6\x9b\xbf\xe6\x8d\xa2old\xe5\x88\xb0new\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c \n    ps. old,new \xe5\xba\x94\xe5\xb0\xbd\xe5\x8f\xaf\xe8\x83\xbd\xe7\x9a\x84\xe9\x95\xbf \xe5\x8c\x85\xe5\x90\xab\xe6\x9b\xb4\xe5\xa4\x9a\xe7\x9a\x84\xe4\xb8\x8a\xe4\xb8\x8b\xe6\x96\x87\xe4\xbf\xa1\xe6\x81\xaf \xe4\xbb\xa5\xe9\x81\xbf\xe5\x85\x8d\xe9\x94\x99\xe8\xaf\xaf\xe7\x9a\x84\xe6\x9b\xbf\xe6\x8d\xa2\n    \n    Parameters\n    ----------\n    old : str\n        \xe8\xa2\xab\xe6\x9b\xbf\xe6\x8d\xa2\xe9\x83\xa8\xe5\x88\x86\n    new : str\n        \xe6\x9b\xbf\xe6\x8d\xa2\xe7\x9a\x84\xe6\x96\xb0\xe7\x9a\x84\xe5\x86\x85\xe5\xae\xb9\n    root : str, default \'.\'\n        \xe8\xb7\xaf\xe5\xbe\x84 \xe5\x8d\xb3\xe6\xa0\xb9\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xb9\n    types : str or list, default \'py\'\n        \xe9\x9c\x80\xe8\xa6\x81\xe8\xa2\xab\xe6\x9b\xbf\xe6\x8d\xa2\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6\xe7\xb1\xbb\xe5\x9e\x8b\n        str:\xe5\x8d\x95\xe4\xb8\xaa\xe7\xb1\xbb\xe5\x9e\x8b, list:\xe5\xa4\x9a\xe4\xb8\xaa\xe7\xb1\xbb\xe5\x9e\x8b \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba \'py\'\xe6\x96\x87\xe4\xbb\xb6\n    \'\'\'\n    if not isinstance(types,(list,tuple)):\n        types = [types]\n    def replace(path):\n        if isfile(path):\n            if \'.\' in path and path.split(\'.\')[-1] in types:\n                code = openread(path)\n                if old in code:\n                    log(\'replaceAllInRoot: %s  old=%s  new=%s\'%(path, old, new))\n                    openwrite(code.replace(old,new),path)\n    listdirWithFun(root, replace)\n\ndef findinRoot(pattern=\'\', root=\'.\', maxsize=1, types=None, var=None, up=None, re=None, \n               exclude=None):\n    \'\'\'\n    \xe5\x9c\xa8root\xe5\x8f\x8a\xe5\xad\x90\xe8\xb7\xaf\xe5\xbe\x84\xe4\xb8\x8b\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe6\x96\x87\xe4\xbb\xb6\xe4\xb8\xad \xe6\x9f\xa5\xe6\x89\xbe pattern\xe3\x80\x82\xe5\xad\x98\xe5\x9c\xa8 \xe5\x88\x99\xe6\x89\x93\xe5\x8d\xb0\xe5\x87\xba\xe5\xaf\xb9\xe5\xba\x94\xe6\x96\x87\xe4\xbb\xb6\xe7\x9a\x84\xe9\x82\xa3\xe4\xb8\x80\xe8\xa1\x8c\xe3\x80\x82\n    \n    Parameters\n    ----------\n    pattern : str\n        \xe8\xa6\x81\xe6\x9f\xa5\xe6\x89\xbe\xe7\x9a\x84\xe5\x86\x85\xe5\xae\xb9\n    root : str, default \'.\'\n        \xe8\xb7\xaf\xe5\xbe\x84 \xe5\x8d\xb3\xe6\xa0\xb9\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xb9\n    maxsize : number, default 1\n        \xe8\xa2\xab\xe6\x9f\xa5\xe6\x89\xbe\xe6\x96\x87\xe4\xbb\xb6\xe7\x9a\x84\xe6\x9c\x80\xe5\xa4\xa7\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xa7\xe5\xb0\x8f\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xe4\xb8\xba MB\n        \xe4\xb8\xba\xe9\x81\xbf\xe5\x85\x8d\xe4\xb8\x8d\xe5\xb0\x8f\xe5\xbf\x83\xe6\x9f\xa5\xe6\x89\xbe\xe5\xa4\xaa\xe5\xa4\xa7\xe7\x9a\x84\xe4\xba\x8c\xe8\xbf\x9b\xe5\x88\xb6\xe6\x96\x87\xe4\xbb\xb6\xef\xbc\x8c\xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\x8d\xe8\xb6\x85\xe8\xbf\x87 1MB\n        \xe8\xae\xbe\xe4\xb8\xba None\xef\xbc\x8c\xe5\x88\x99\xe4\xb8\x8d\xe8\xae\xbe\xe5\xa4\xa7\xe5\xb0\x8f\xe9\x99\x90\xe5\x88\xb6\n    types : str or list, default None\n        \xe8\xa2\xab\xe6\x9f\xa5\xe6\x89\xbe\xe6\x96\x87\xe4\xbb\xb6\xe7\x9a\x84\xe7\xb1\xbb\xe5\x9e\x8b\xe9\x99\x90\xe5\x88\xb6\n        str:\xe5\x8d\x95\xe4\xb8\xaa\xe7\xb1\xbb\xe5\x9e\x8b, list:\xe5\xa4\x9a\xe4\xb8\xaa\xe7\xb1\xbb\xe5\x9e\x8b \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba\xe6\x89\x80\xe6\x9c\x89\xe6\x96\x87\xe4\xbb\xb6\n    var : str or bool, default None\n        use re.compile(\'(^|[^a-zA-Z0-9_])%s([^a-zA-Z0-9_]|$)\'%var) to find var name\n    up : str or bool, default None\n        Ignoring letter case of variable names\n    re : str or bool, default None\n        use re.compile(re) to search each line\n    exclude : list , default [\'pyc\', \'swp\', \'swo\',]\n        exclude file types in this list\n    \'\'\'\n    from re import compile as recompile\n    if types is not None :\n        if not isinstance(types,(list,tuple)):\n            types = [types]\n        types = [t.replace(\'.\', \'\') for t in types]\n    if exclude is None:\n        exclude = []\n    exclude += [\'pyc\', \'swp\', \'swo\', \'gz\', \'whl\', \'jpg\', \'png\', \'npz\', \'bin\']\n    def intypes(path):\n        typee = \'.\' in path and path.split(\'.\')[-1].lower()\n        if types is None:\n            return typee not in exclude\n        return typee in types\n    if not pattern:\n        pattern = var or up or re\n    searchin = lambda strr: pattern in strr\n    if var:\n        pa = \'\'\'(^|[^a-zA-Z0-9_\'""])%s([^a-zA-Z0-9_\'""]|$)\'\'\'%pattern\n        pa = recompile(pa)\n        searchin = lambda strr: pa.search(strr)\n    elif up:\n        lower = pattern.lower()\n        searchin = lambda strr: lower in strr.lower()\n    elif re:\n        pa = recompile(pattern)\n        searchin = lambda strr: pa.search(strr)\n    def find(path):\n        if isfile(path):\n            if (getsizem(path) <= maxsize or maxsize is None) and intypes(path):\n                try:\n                    s = openread(path)\n                    if py2:\n                        from .toolLog import tounicode\n                        s = tounicode(s)\n                    lines = [(i, l) for i,l in enumerate(s.split(\'\\n\'), 1) if searchin(l)]\n                    if not len(lines):\n                        return \n                    print(\'""%s"" in ""%s"" with %s\'%(\'\\x1b[31m%s\\x1b[0m\'%pattern, \'\\x1b[36m%s\\x1b[0m\'%path, \'\\x1b[35m%s Lines\\x1b[0m\'%len(lines)))\n                    for (i, l) in lines:\n                        if l.startswith(\'   \'):\n                            l = \'... \'+l.strip()\n                        if len(l) > 83:\n                            l = l[:80] +\' ...\'\n                        print(\'\\t%s:%s\'%(\'\\x1b[35m%s\\x1b[0m\'%i, \'\\x1b[31m%s\\x1b[0m\'%l))\n                    print("""")\n                except:\n                    return \n    listdirWithFun(root, find)\n\ndef iscn(char):\n    \'\'\'\n    Does a char is chinese? \n    \'\'\'\n    if u\'\\u4e00\' <= char <= u\'\\u9fff\':\n        return True\n    return False\n    \n\ndef zipTar(paths, tarp):\n    \'\'\'\n    tar file for ,especially for label++\n    \'\'\'\n    import tarfile  \n    with tarfile.open(tarp,\'w\') as tar:\n        for path in paths:\n            tar.add(path, arcname=os.path.basename(path))\n\ndef camel2snake(variable_name):\n    s = variable_name[0].lower()\n    for c in variable_name[1:]:\n        if c.isupper():\n            s += \'_\' + c.lower()\n        else:\n            s += c\n    return s\n\ndef snake2camel(variable_name, lower_camel_case=False):\n    s = variable_name[0].lower() if lower_camel_case else variable_name[0].upper()\n    for idx, c in enumerate(variable_name[1:]):\n        if variable_name[idx] == \'_\':\n            s += c.upper()\n        elif c != \'_\':\n            s += c\n    return s\n\nif __name__ == ""__main__"":\n     \n    string=[""A001.45\xef\xbc\x8cb5\xef\xbc\x8c6.45\xef\xbc\x8c8.82"",\'sd4 dfg77\']\n    print(findints(string))\n    pass'"
boxx/yldb/__init__.py,0,b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nfrom . import yldf\nfrom . import ylmysql\nfrom . import ylsqlite\n\n\nfrom .yldf import df2dicts\n\n'
boxx/yldb/dbPublicFuncation.py,0,b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\n\n\n'
boxx/yldb/yldf.py,0,"b'# -*- coding: utf-8 -*-\n""""""\ntools for pandas \n\n@author: yl\n""""""\n\nfrom __future__ import unicode_literals\n\ndef df2dicts(df, inculdeIndex=False):\n    \'\'\'\n    input a df, return to a list of dict\n    \n    Parameters\n    ----------\n    df : DataFrame\n        pandas.DataFrame\n    inculdeIndex : bool, default False\n        return dic include index\n    \'\'\'\n    dicts = [dict(row) for index,row in df.iterrows()]\n    if inculdeIndex:\n        for index, dic in zip(df.index, dicts):\n            dic[\'index\'] = index\n    return dicts\n\nif __name__ == \'__main__\':\n    pass\n    import pandas as pd\n    df = pd.DataFrame({\n                       0:list(range(5)),\n                       1:list(range(10,15)),\n                       \'a\':list(""abcde""),\n                       })\n    df.set_index(0,inplace=True)\n\n'"
boxx/yldb/ylmysql.py,0,b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\n\n'
boxx/yldb/ylsqlite.py,0,"b""# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n'''\nTodo List:\n    1. \xe4\xbd\xbf\xe7\x94\xa8ORM \xe6\x98\xa0\xe5\xb0\x84\n'''\nimport sqlite3,os\n\nclass Sqlite():\n    def __init__(self, creatSql, dbpath='sqlite3.db'):\n        '''\n        \xe5\x88\x9b\xe5\xbb\xba\xe4\xb8\x80\xe4\xb8\xaasqlite3 \xe7\xae\xa1\xe7\x90\x86\xe5\x99\xa8\n        creatSql: \xe6\x9e\x84\xe5\xbb\xba\xe6\x95\xb0\xe6\x8d\xae\xe5\xba\x93\xe4\xbb\xa3\xe7\xa0\x81\n        dbPath: \xe6\x95\xb0\xe6\x8d\xae\xe5\xba\x93\xe8\xb7\xaf\xe5\xbe\x84\n        '''\n        self.creatSql = creatSql\n        self.dbpath = dbpath\n        self.creatDbIfNot()\n    def creatDbIfNot(self):\n        '''\n        \xe6\xb3\xa8\xe6\x84\x8f\xef\xbc\x9a\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe5\x8f\xa5\xe4\xb8\x8d\xe8\x83\xbd\xe4\xbb\xa5\xe9\x80\x97\xe5\x8f\xb7\xe7\xbb\x93\xe5\xb0\xbe\n        '''\n        dbpath = self.dbpath\n        if not os.path.isfile(dbpath):\n            dirr = os.path.dirname(dbpath)\n            if not os.path.isdir(dirr) and dirr:\n                os.makedirs(dirr, exist_ok=True)\n            self.exe(self.creatSql)\n        \n    def exe(self, sql, values=None):\n        with sqlite3.connect(self.dbpath) as conn:\n            cursor = conn.cursor() \n            if values is None :\n                cursor.execute(sql)\n            else:\n                cursor.execute(sql,values)\n            cursor.close()\n            conn.commit()\n    def insert(self, sql, value):\n        self.inserts(sql, [value])\n    def inserts(self, sql, values):\n        '''\n        \xe4\xb8\x80\xe6\xac\xa1\xe6\x80\xa7\xe6\x8f\x92\xe5\x85\xa5\xe5\xa4\x9a\xe6\x9d\xa1\xe8\xaf\xad\xe5\x8f\xa5\xe5\x86\x8dcommit\xe6\x80\xa7\xe8\x83\xbd\xe5\xa5\xbd\n        '''\n        with sqlite3.connect(self.dbpath) as conn:\n            cursor = conn.cursor() \n            for value in values:\n                if not isinstance(value,(tuple,list)):\n                    value = (value,)\n                cursor.execute(sql,value)\n            cursor.close()\n            conn.commit()\n    def select(self, sql, values=None):\n        '''\n        \xe6\x89\xa7\xe8\xa1\x8cselect \xe8\xbf\x94\xe5\x9b\x9e\xe7\xbb\x93\xe6\x9e\x9c\n        '''\n        dbpath = self.dbpath\n        with sqlite3.connect(dbpath) as conn:\n            cursor = conn.cursor() \n            conn = sqlite3.connect(dbpath)\n            if values is None :\n                cursor.execute(sql)\n            else:\n                cursor.execute(sql,values)\n            resoult = cursor.fetchall()\n            cursor.close()\n        return resoult\n        \nif __name__ == '__main__':\n    import random as rd\n    creat = '''CREATE TABLE t(\n    no INTEGER PRIMARY KEY ,\n    id INTEGER NOT NULL\n);'''\n    s = Sqlite(creat)\n    insert = 'insert into t (id) values (?)'\n    v = rd.randint(0,100)\n    s.insert(insert,v)\n    \n    select = 'select * from t'\n    r = s.select(select)\n    print(v,r)\n    \n    pass\n"""
boxx/ylimg/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\ntools for Image Processing and Visualization\n\n@author: yanglei\n""""""\nfrom .ylimgTool import sk, np, plot, sda\nfrom .ylimgTool import (show, showb, shows, loga, tree, treem, treea, dira, what, wtf,\n                        tprgb, torgb, frombgr, mapp, normalizing, norma, imsave, imread, npa, \n                       getShapes, greyToRgb, warpResize, resize, histEqualize, StructLogFuns)\nfrom .ylimgTool import (uint8, padding, toPng, randomm , r, labelToColor,getDefaultColorList,\n                       standImg, getMeanStd, boolToIndex, discribArray, prettyArray)\n\n#from .ylimgVideoAndGif import gifSave, videoToImgs, base64Img, generateBigImgForPaper\nfrom . import ylimgVideoAndGif \n\n\nif __name__ == \'__main__\':\n\n    pass\n'"
boxx/ylimg/showImgsInBrowser.py,0,"b'# -*- coding: utf-8 -*-\n\nimport os,glob\nfrom ..ylsys import tmpboxx\n\ndef showImgsInBrowser(paths, htmlp=None):\n    \'\'\'\xe5\x9b\xbe\xe7\x89\x87\xe5\xb1\x95\xe7\xa4\xba\xe5\x88\x86\xe6\x9e\x90\xe5\xb7\xa5\xe5\x85\xb7  \xe4\xbd\xbf\xe7\x94\xa8\xe6\xb5\x8f\xe8\xa7\x88\xe5\x99\xa8\xe5\x90\x8c\xe6\xad\xa5\xe6\x98\xbe\xe7\xa4\xba\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84image,gt,resoult \xe7\xad\x89\n    \xe6\x94\xaf\xe6\x8c\x81\xe6\x94\xbe\xe5\xa4\xa7\xe7\xbc\xa9\xe5\xb0\x8f\xe4\xb8\x8e\xe6\x8b\x96\xe6\x8b\xbd\n    \n    Parameters\n    ----------\n    paths : list of path\n        \xe5\x9b\xbe\xe7\x89\x87\xe5\x9c\xb0\xe5\x9d\x80\xe7\xbb\x84\xe6\x88\x90\xe7\x9a\x84\xe6\x95\xb0\xe7\xbb\x84\n    \'\'\'\n#    paths = list(map(os.path.abspath,paths))\n    html = getShowsHtml()\n    s = \'srcs = [%s]\'%("","".join([\'""%s""\'%p for p in paths]))\n    html = html.replace(\'//replaceTagForPython\',s.replace(\'\\\\\',r\'\\\\\'))\n    if not htmlp:\n        htmlp = os.path.join(tmpboxx(), \'shows-%s.html\') %len(glob.glob(os.path.join(tmpboxx(), \'shows-*.html\')))\n    with open(htmlp,\'w\') as f:\n        f.write(html)\n    from boxx import browserOpen\n    browserOpen(htmlp)\n\ndef getShowsHtml():\n    return \'\'\'\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=""UTF-8"">\n      <title>quickSeg image</title>\n      <script src=""http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js""></script>\n\n      <script src=""https://cdn.bootcss.com/dat-gui/0.6.5/dat.gui.js""></script>\n      <!-- <script src=""./leiYangFuns.js""></script> -->\n      <style>\n      </style>\n      <script>\n      log = console.log\n      int = parseInt\n      float = parseFloat\n      pow = Math.pow\n      max=(x)=>{\n        var m=x[0]\n        for (var i = 0; i < x.length; i++) {\n            m=x[i]>m?x[i]:m\n        };\n        return m\n      }\n      min=(l)=>-max(l.map((x)=>-x))\n      len= (x)=>x.length\n      </script>\n    </head>\n    <body style=""margin:0;padding:0"">\n    \t<canvas id=""canvas"" width="""" height="""" style=""top:0px;left:0px"">\n    \t</canvas>\n    </body>\n    <script>\n    canvas = document.getElementById(\'canvas\')\n    var ctx = canvas.getContext(\'2d\');\n\n    window.addEventListener(""resize"", resizeCanvas, false);\n\n    function resizeCanvas() {\n        canvas.width = window.innerWidth;\n        var n = len(srcs)\n        bys = int(n/bxs)+Boolean(n%bxs)\n        if(bys<=bxs){\n          canvas.height = window.innerHeight;\n        }else(\n          canvas.height = window.innerWidth*bys/bxs\n        )\n        var w=canvas.width\n        var h=canvas.height\n\n        sw = w/bxs\n        sh = h/bys\n        flash();\n    }\n    busy = 0\n    roundTag = 0\n    flashInner = ()=>{\n      roundTag += 1\n      if (busy){\n        return\n      }\n      var tag = roundTag\n      busy = 1\n      var bx=0\n      var by=0\n      for (var src of srcs) {\n        if (roundTag!=tag){\n          busy=0;\n          flash()\n          return\n        }\n        drawImage(src,bx,by)\n        bx += 1\n        if(bx==bxs){\n          by+=1\n          bx=0\n        }\n      }\n      busy=0;\n      if (roundTag!=tag){\n        flash()\n      }\n    }\n    flash = ()=>{setTimeout(flashInner,0)}\n\n    drawImage = (src,bx,by)=>{\n      var img = new Image();\n      img.onload = function(){\n        imgh = img.height\n        imgw = img.width\n        if(scale == -1){\n          sca = min([sw/imgw,sh/imgh])\n          scale = Math.log2(sca)\n        }\n        sca = pow(2,scale)\n        var left = max([0,imgw*fx-sw/sca/2])\n        var right = min([imgw,imgw*fx+sw/sca/2])\n        var up = max([0,imgh*fy-sh/sca/2])\n        var down = min([imgh,imgh*fy+sh/sca/2])\n        var leftt = max([0,sw/2-imgw*fx*sca])\n        var rightt = min([sw,sw/2+imgw*(1-fx)*sca])\n        var upp = max([0,sh/2-imgh*fy*sca])\n        var downn = min([sh,sh/2+imgh*(1-fy)*sca])\n        ctx.clearRect(bx*sw,by*sh,sw,sh);\n        ctx.drawImage(img,left,up,right-left,down-up,   bx*sw+leftt,by*sh+upp,rightt-leftt,downn-upp);\n          // ctx.drawImage(img,0,0,6000,6000,   0,0,1000,1000);\n      }\n      img.src = src;\n    }\n\n    var view = {\n        scroll:(e)=>{\n            e.preventDefault()\n            var x=e.offsetX\n            var y=e.offsetY\n            var change = int(e.deltaY)\n            var zoomSpeed = 0.2\n            if (change<0){\n                scale += (zoomSpeed)\n            }\n            if (change>=0){\n                scale -= (zoomSpeed)\n            }\n            flash()\n        },\n        onMove:(e)=>{\n            e.preventDefault()\n            var x = e.clientX-xBegin\n            var y = e.clientY-yBegin\n            fx = fxBegin - x/sca/imgw\n            fx = min([1,max([0,fx])])\n            fy = fyBegin - y/sca/imgh\n            fy = min([1,max([0,fy])])\n            flash()\n        },\n\n        onDown:(e)=>{\n            e.preventDefault()\n            var x = e.clientX\n            var y = e.clientY\n            xBegin = x\n            yBegin = y\n            fxBegin = fx\n            fyBegin = fy\n            canvas.onmousemove = view.onMove\n        },\n        onUp:()=>{\n            canvas.onmousemove = null\n        },\n        mouseBegin:()=>{\n            window.onmousewheel=view.scroll\n            window.onmousedown = view.onDown\n            window.onmouseup = view.onUp\n            onmouseup()\n        }\n    }\n    scale = -1\n    fx = .5\n    fy = .5\n\n    var srcs = []\n    //replaceTagForPython\n    bxs = 2\n\n    resizeCanvas()\n    view.mouseBegin()\n    var gui = new dat.GUI();\n    var con = gui.add(window, \'scale\',-10,5).listen();\n    con.onChange( (v)=>{\n        flash()\n    })\n\n    // var con2 = gui.add(window, \'fx\',0.,1.0).listen();\n    // var con3 = gui.add(window, \'fy\',0.,1.0).listen();\n    // con2.onFinishChange = con3.onFinishChange = con.onFinishChange\n\n    var con4 = gui.add(window, \'bxs\',1,5).step(1).listen();\n    con4.onChange ( function(v){\n      bxs = int(v)\n      resizeCanvas()\n    })\n    </script>\n    </html>\n\n    \'\'\'\nif __name__ == \'__main__\':\n    pass\n'"
boxx/ylimg/ylimgTool.py,54,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals, print_function\n\nfrom ..tool.toolStructObj import FunAddMagicMethod, typeNameOf, typestr, dicto\nfrom ..tool.toolStructObj import generator, nextiter, getfathers, isinstancestr\nfrom ..tool.toolLog import log, PrintStrCollect, colorFormat, clf, tounicode, LogLoopTime, prettyClassFathers\nfrom ..tool.toolLog import tabstr, getDoc, shortStr, discrib, strnum\nfrom ..tool.toolFunction import mapmp, pipe\nfrom ..tool.toolSystem import tryImport\nfrom ..ylsys import tmpYl, pyi, py2, sysi\nfrom ..ylsci.ylnp import isNumpyType\nfrom ..ylcompat import interactivePlot, beforImportPlt\n\nimport os\nimport glob\nimport math\nimport types\nimport numpy as np\nimport skimage as sk\nfrom functools import reduce\nfrom collections import defaultdict\nfrom operator import add\n#cv2 = tryImport(\'cv2\')\n\n#from skimage import io as sio\n#from skimage.io import imread\n#from skimage.io import imsave\n#from skimage import data as sda\n\ndef imsave(fname, arr, plugin=None, **plugin_args):\n    \'\'\'\n    same usage of skimage.io.imsave, for lazy import skimage.io and matplotlib.pyplot\n    \'\'\'\n    beforImportPlt()\n    from skimage.io import imsave\n    return imsave(fname, arr, plugin, **plugin_args)\n\ndef imread(fname, as_grey=False, plugin=None, flatten=None, **plugin_args):\n    \'\'\'\n    same usage of skimage.io.imread, for lazy import skimage.io and matplotlib.pyplot\n    \'\'\'\n    beforImportPlt()\n    from skimage.io import imread\n    if flatten is None:\n        return imread(fname, as_grey, plugin, **plugin_args)\n    return imread(fname, as_grey, plugin, flatten, **plugin_args)\n\n#class FakeSkimageData(types.ModuleType): # raise SystemError: nameless module when dir(sda)\nclass FakeSkimageData():\n    __all__ = [\'load\', \'astronaut\', \'camera\', \'checkerboard\', \'chelsea\', \'clock\', \'coffee\', \'coins\', \'horse\', \'hubble_deep_field\', \'immunohistochemistry\', \'logo\', \'moon\', \'page\', \'text\', \'rocket\', \'stereo_motorcycle\']\n    def __init__(self):\n        pass\n    def __getattr__(self, k, *l):\n        beforImportPlt()\n        from skimage import data as sda\n        return getattr(sda, k)\n    def __call__(self):\n        beforImportPlt()\n        from skimage import data as sda\n        return sda.astronaut()\nsda = FakeSkimageData()\n\n# randomm((m, n), max) => m*n matrix\n# randomm(n, max) => n*n matrix\nrandomm = lambda shape,maxx:(np.random.random(\nshape if (isinstance(shape,tuple) or isinstance(shape,list)\n)else (shape,shape))*maxx).astype(int)\nr = randomm(4,4)\n\ndef normalizing(arr):\n    if isinstance(arr, np.ndarray) and not isNumpyType(arr, \'float\'):\n        arr = arr.astype(float)\n    minn = arr.min()\n    return (arr-minn)/(arr.max() - minn)\nnormalizing = FunAddMagicMethod(normalizing)\nnorma = normalizing\n\ndef warpResize(img, hw, interpolation=None):\n    \'\'\'\n    resize by cv2.warpAffine to avoid cv2.resize()\'s BUG(not align when resize bigger)\n    \'\'\'\n    import cv2\n    from ..ylsci import Vector\n    if interpolation is None:\n        interpolation = cv2.INTER_NEAREST\n    h, w = hw\n    rhw = Vector(img.shape[:2])\n    dhw = hw/rhw\n    M = np.array([[dhw.w*1.,0,0],[0,dhw.h*1,0]])\n    dst = cv2.warpAffine(img, M, (w, h), flags=interpolation,)\n    return dst\n\ndef resize(img, arg2, interpolation=None):\n    \'\'\'\n    resize the np.ndarray or torch.Tensor\n        \n    Parameters\n    ----------\n    arg2: float, int, shape, ndarray, torch.Tensor\n        the size or target ndarray \n        \n    \'\'\'\n    hw = arg2\n    if isinstance(arg2, np.ndarray):\n        if not(arg2.ndim == 1 and arg2.shape == (2,)):\n            hw = arg2.shape[:2]\n    elif typestr(arg2) in [\'torch.Tensor\']:\n        hw = arg2.shape[-2:]\n    elif isinstance(arg2, (float, int)):\n        hw = img.shape[:2] if isinstance(img, np.ndarray) else img.shape[-2:]\n        hw = [int(round(size * arg2)) for size in hw]\n    if isinstance(img, np.ndarray):\n        dst = warpResize(img, hw, interpolation=interpolation)\n    elif typestr(img) in [\'torch.Tensor\']:\n        interpolation =  interpolation or \'nearest\'\n        from torch import nn\n        dst = nn.functional.interpolate(img, tuple(hw), mode=interpolation)\n    return dst\n\ndef uint8(img):\n    \'\'\'\xe5\xb0\x860\xef\xbd\x9e1\xe7\x9a\x84float\xe6\x88\x96bool\xe5\x80\xbc\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xbauint8\xe6\xa0\xbc\xe5\xbc\x8f\'\'\'\n    return ((img)*255.999).astype(np.uint8)\n\ngreyToRgb = lambda grey:grey.repeat(3).reshape(grey.shape+(3,)) \n\ndef histEqualize(img):\n    from skimage.exposure import equalize_hist\n    img = equalize_hist(img)\n    minn = img.min()\n    return (img-minn)/(img.max()-minn)\nhistEqualize = FunAddMagicMethod(histEqualize)\n\nboolToIndex = lambda boolMa1d:np.arange(len(boolMa1d))[npa(boolMa1d).squeeze()>0]\nboolToIndex = FunAddMagicMethod(boolToIndex)\n\ndef tprgb(ndarray):\n    \'\'\'\n    transpose to RGB, \xe5\xb0\x863*h*w\xe7\x9a\x84ndarray\xe5\x8c\x96\xe4\xb8\xba h*w*3\xe7\x9a\x84RGB\xe5\x9b\xbe\n    \xe5\x8d\xb3shape\xe4\xb8\xba (...,3 , h, w)\xe7\x9a\x84ndarray\xe8\xbd\xac\xe5\x8c\x96\xe4\xb8\xba(..., h, w, 3)\n    \'\'\'\n    shape = ndarray.shape\n    ndim = ndarray.ndim\n    if ndim >= 3 and shape[-3] == 3:\n        axes = list(range(ndim))[:-3]+[ndim-2,ndim-1,ndim-3]\n        return ndarray.transpose(*axes)\n    return ndarray\ntprgb = FunAddMagicMethod(tprgb)\n\n\ndef padding(img, urdl=1):\n    \'\'\'\n    padding image for up, right, down, left\n    \'\'\'\n    if not isinstance(urdl, list):\n        urdl = [urdl] * 4\n    from ..tool import intround\n    u, r, d, l = map(intround, urdl)\n    h, w = img.shape[:2]\n    hh = h + u + d\n    ww = w + r + l\n    bimg = np.zeros((hh, ww,) + img.shape[2:], img.dtype)\n    bimg[u:hh-d, l:ww-r] = img\n    return bimg\n\ndef toPng(img):\n    \'\'\'\n    add alpha channel to be a png picture\n    \'\'\'\n    if img.shape[-1] == 3:\n        return np.append(img, np.ones(img.shape[:-1]+(1,), img.dtype)* (255 if isNumpyType(img, \'int\') else 1), 2)\n    return img\n\ndef torgb(img):\n    \'\'\'\n    try to transfer a tensor to normalized RGB image\n    \n    normalizing img value to 0~1\n    and transpose (..., 3, w, h) to (..., w, h, 3)\n    \n    \'\'\'\n    img = npa(img)\n    if img.min() < 0:\n        img = norma(img)\n    return tprgb(img)\n\ndef frombgr(img):\n    img = torgb(img)\n    if img.ndim >= 3 and img.shape[-1] == 3 :\n        img = img[...,[2,1,0]]\n    return img\n\ntorgb = FunAddMagicMethod(torgb)\n\ndef mapp(f, matrix, need_i_j=False):\n    \'\'\'\n    for each item of a 2-D matrix\n    return a new matrix consist of f:f(it) or f(it, i, j)\n    \xe6\x80\xa7\xe8\x83\xbd\xe5\xb7\xae \xe5\xb0\xbd\xe9\x87\x8f\xe7\x94\xa8y, x = np.mgrid[:10,:10]\n    \'\'\'\n    m, n = matrix.shape[:2]\n    listt = [[None]*n for i in range(m)]\n    for i in range(m):\n        for j in range(n):\n            it = matrix[i][j]\n            listt[i][j] = f(it,i,j) if need_i_j else f(it)\n    return np.array(listt)\n\ndef __torchVar2Tensor(t):\n    \'\'\'\n    \xe5\x90\x8c\xe6\x97\xb6\xe5\x85\xbc\xe5\xae\xb9 PyTorch 3.0 \xe5\x92\x8c 4.0 \xe7\x9a\x84 Tensor \xe5\x92\x8c Var\n    \'\'\'\n    try:\n        t = t.data\n    except:\n        pass\n    finally:\n        return t\n__torchToNumpy = lambda x:__torchVar2Tensor(x).numpy()\n__torchCudaToNumpy = lambda x:__torchVar2Tensor(x).cpu().numpy()\n__todense = lambda x:x.todense()\n\ntypesToNumpyFuns = {\n    \'scipy.sparse.csr.csr_matrix\':__todense,\n    \'scipy.sparse.coo.coo_matrix\':__todense,\n    \'scipy.sparse.csc.csc_matrix\':__todense,\n    \'PIL.Image.Image\':lambda x:np.array(x),\n    \'mxnet.ndarray.NDArray\':lambda x:x.asnumpy(),\n    \'mxnet.ndarray.ndarray.NDArray\':lambda x:x.asnumpy(),\n    \n    \'torch.Tensor\':__torchCudaToNumpy,\n    \n    \'torch.FloatTensor\':__torchToNumpy,\n    \'torch.DoubleTensor\':__torchToNumpy,\n    \'torch.IntTensor\':__torchToNumpy,\n    \'torch.LongTensor\':__torchToNumpy,\n    \'torch.ShortTensor\':__torchToNumpy,\n    \'torch.ByteTensor\':__torchToNumpy,\n    \'torch.HalfTensor\':__torchToNumpy,\n    \'torch.CharTensor\':__torchToNumpy,\n    \n    ""torch.cuda.LongTensor"":__torchCudaToNumpy,\n    ""torch.cuda.DoubleTensor"":__torchCudaToNumpy,\n    ""torch.cuda.IntTensor"":__torchCudaToNumpy,\n    ""torch.cuda.ShortTensor"":__torchCudaToNumpy,\n    ""torch.cuda.ByteTensor"":__torchCudaToNumpy,\n    ""torch.cuda.HalfTensor"":__torchCudaToNumpy,\n    ""torch.cuda.CharTensor"":__torchCudaToNumpy,\n    ""torch.cuda.FloatTensor"":__torchCudaToNumpy,\n    \n    ""torch.autograd.variable.Variable"":lambda x:__torchCudaToNumpy(x.data),\n    ""torch.nn.parameter.Parameter"":lambda x:__torchCudaToNumpy(x.data),\n}\n\n__strToNumpy = lambda x: imread(x) if os.path.isfile(x) else np.array(list(x))\n__generatorToNumpy = lambda x:np.array(list(x))\ntryToNumpyFunsForNpa = {\n    ""dict_values"":__generatorToNumpy,\n    ""dict_keys"":__generatorToNumpy,\n    ""dict_items"":__generatorToNumpy,\n    ""map"":__generatorToNumpy,\n    ""filter"":__generatorToNumpy,\n    ""zip"":__generatorToNumpy,\n    \n    ""str"":__strToNumpy,\n    ""unicode"":__strToNumpy,\n    }\ntryToNumpyFunsForNpa.update(typesToNumpyFuns)\n\ndef npa(array):\n    \'\'\'\n    try to transfer other data to np.ndarray\n    \n    support types inculde:\n        numpy, torch.tensor, mxnet.ndarray, PIL.Image\n        list, tuple, dict, range, zip, map\n        str, image_path\n    \n    Parameters\n    ----------\n    array : list/tuple, torch.Tensor, mxnet.NDArray ...\n        support types in boxx.ylimg.ylimgTool.typesToNumpyFuns and boxx.ylimg.ylimgTool.tryToNumpyFunsForNpa\n    \'\'\'\n    if isinstance(array, np.ndarray):\n        if type(array) is not np.ndarray:\n            return np.array(array)\n        return array\n    \n    typeNameForNpa = isinstancestr(array, tryToNumpyFunsForNpa)\n    if typeNameForNpa:\n        ndarray = tryToNumpyFunsForNpa[typeNameForNpa](array)\n    else:\n        ndarray = np.array(array)\n    return ndarray\nnpa = FunAddMagicMethod(npa)\n\n\ndef discribArray(array):\n    \'\'\'\n    return str of discrib for array, include shape type max min\n    \'\'\'\n    typeName = typestr(array)\n    array = npa(array)\n    strr = (clf.r%tounicode(array.shape),\n          clf.r%typeNameOf(array.dtype.type)[6:], \n          clf.r%typeName,\n          clf.r%( strnum(array.max()) if (array.size) else \'Empty\'), \n          clf.r%( strnum(array.min()) if (array.size) else \'Empty\'), \n          clf.r%( strnum(array.mean()) if (array.size) else \'Empty\') )\n    return ((\'shape:%s type:(%s of %s) max: %s, min: %s, mean: %s\'%tuple(strr)))\n    \n    \ndef prettyArray(array):\n    \'\'\'\n    return str of pretty discrib for array, include nan inf (shape type max min)  \n    \'\'\'\n    discrib = discribArray(array)\n    array = npa(array)\n    unique = np.unique(array)\n    finiteInd = np.isfinite(array)\n    nan = np.isnan(array).sum()\n    \n    discribNan = \'\'\n    if not (finiteInd).all():\n        finite = array[finiteInd]\n        size = array.size\n        nan = np.isnan(array).sum()\n        nans = clf.p%\'""nan"":%s (%.2f%%), \'%(nan,100.*nan/size) if nan else \'\'\n        inf = np.isinf(array).sum()\n        infs = clf.p%\'""inf"":%s (%.2f%%), \'%(inf,100.*inf/size) if inf else \'\'\n        discribNan = (clf.r%\'\\nNotice: \' + \'%s%s finite max: %s, finite min: %s, finite mean: %s\'%(\n                nans,infs, len(finite) and strnum(finite.max()), len(finite) and strnum(finite.min()), \n                len(finite) and strnum(finite.mean())))\n    if len(unique)<10:\n        dic = defaultdict(lambda : 0)\n        for i in array.ravel():\n            dic[i] += 1\n        listt = list(dic.items())\n        listt.sort(key=lambda x:x[0])\n        x = np.array([k for k,v in listt]).astype(float)\n        if len(x) == 0:\n            discrib += (clf.p%\'\\nEmpty array\')\n        elif len(x) == 1:\n            discrib += (clf.p%\'\\nAll value is %s\' % x[0])\n        else:\n            discrib += (\'\\nOnly %s unique values are %s\'%(len(x), \', \'.join([clf.p%v for v in x])))\n    discrib += discribNan\n    return discrib\n\n#interactivePlot = lambda x:x\n@interactivePlot\ndef plot(array, sort=False, maxline=10):\n    \'\'\'\n    plot line or top @maxline lines\n    \'\'\'    \n    import matplotlib.pyplot as plt\n    plt.figure()\n    if callable(array) and \'__iter__\' not in dir(array):\n        x = np.linspace(np.e*-1.5,np.e*1.5,100)\n        array = array(x)\n    discrib = prettyArray(array).replace(\'\\n\',\'\\n\\n\')\n    print(discrib)\n    array = npa(array).squeeze()\n    n = array.shape[-1]\n    if array.ndim >= 2:\n        array = np.resize(array, (array.size//n, n))\n        arrays = array[:maxline]\n    else:\n        arrays = [array]\n    for arr in arrays:\n        if sort:\n            arr = sorted(arr, reverse=True)\n        plt.plot(arr)\n    plt.show()        \nplot = FunAddMagicMethod(plot)\n\n@interactivePlot\ndef loga(array):\n    \'\'\'\n    Analysis any array like thing .\n    the shape, max, min, distribute of the array\n    \n    support numpy, torch.tensor, mxnet.ndarray, PIL.Image .etc\n    \'\'\'\n    import matplotlib.pyplot as plt\n    plt.figure()\n    discrib = prettyArray(array)\n    print(discrib.replace(\'\\n\',\'\\n\\n\'))\n    \n    array = npa(array)\n    unique = np.unique(array)\n    finiteInd = np.isfinite(array)\n    if not (finiteInd).all():\n        finite = array[finiteInd]\n        data, x = np.histogram(finite,8)\n    if len(unique)<10:\n        dic = defaultdict(lambda : 0)\n        for i in array.ravel():\n            dic[i] += 1\n        listt = list(dic.items())\n        listt.sort(key=lambda x:x[0])\n        data,x=[v for k,v in listt],np.array([k for k,v in listt]).astype(float)\n        if len(x) <= 1:\n            return\n        width = (x[0]-x[1])*0.7\n        x -=  (x[0]-x[1])*0.35\n    elif not (finiteInd).all():\n        x=x[1:]\n        width = (x[0]-x[1])\n    else:\n        data, x = np.histogram(array.ravel(),8)\n        x=x[1:]\n        width = (x[0]-x[1])\n    plt.plot(x, data, color = \'orange\')\n    plt.bar(x, data,width = width, alpha = 0.5, color = \'b\')\n    plt.show()\n    \nloga = FunAddMagicMethod(loga)\n\ndef ndarrayToImgLists(arr):\n    \'\'\'\n    \xe5\xb0\x86\xe6\x89\x80\xe6\x9c\x89ndarray\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xbaimgList\n    \'\'\'\n    arr = np.squeeze(arr)\n    ndim = arr.ndim\n    if ndim <= 1:\n        return []\n    if arr.ndim==2 or (arr.ndim ==3 and arr.shape[-1] in [3,4]):\n         return [arr]\n    if arr.shape[-1] == 2 and arr.ndim >= 3: # \xe4\xba\x8c\xe5\x88\x86\xe7\xb1\xbb\xe6\x83\x85\xe5\x86\xb5\xe4\xb8\x8b\xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\n        arr = arr.transpose(list(range(ndim))[:-3]+[ndim-1,ndim-3,ndim-2])\n    imgdim = 3 if arr.shape[-1] in [3,4] else 2\n    ls = list(arr)\n    while ndim-1>imgdim:\n        ls = reduce(add,list(map(list,ls)),[])\n        ndim -=1\n    return ls\n\ndef listToImgLists(l, res=None,doNumpy=ndarrayToImgLists):\n    \'\'\'\n    \xe5\xb0\x86 ndarray\xe5\x92\x8clist\xe7\x9a\x84\xe6\xb7\xb7\xe5\x90\x88\xe7\xbb\x93\xe6\x9e\x9c\xe6\xa0\x91\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba \xe4\xb8\x80\xe7\xbb\xb4 img list\n    \'\'\'\n    if res is None:\n        res = []\n    for x in l:\n        typeName = isinstancestr(x, typesToNumpyFuns)\n        fathersStr = str(getfathers(x))\n        if typeName:\n            ndarray = typesToNumpyFuns[typeName](x)\n            res.extend(doNumpy(ndarray))\n        elif isinstance(x,(list,tuple)):\n            listToImgLists(x,res=res,doNumpy=doNumpy)\n        elif isinstance(x,dict):\n            listToImgLists(list(x.values()),res=res,doNumpy=doNumpy)\n        elif isinstance(x,np.ndarray):\n            res.extend(doNumpy(x))\n        elif (\'torch.utils.data\') in fathersStr or (\'torchvision.datasets\') in fathersStr:\n            seq = unfoldTorchData(x, fathersStr)\n            if seq is not False:\n                listToImgLists(seq,res=res,doNumpy=doNumpy)\n    return res\n\n@interactivePlot\ndef showImgLists(imgs,**kv):\n    import matplotlib.pyplot as plt\n    n = len(imgs)\n    if ""ncols"" in kv:\n        ncols = kv[""ncols""]\n        if n >= 2*ncols:\n            showImgLists(imgs[:ncols], **kv)\n            showImgLists(imgs[ncols:], **kv)\n            return\n        elif n > ncols:\n            showImgLists(imgs[:math.ceil(n/2.)], **kv)\n            showImgLists(imgs[math.ceil(n/2.):], **kv)\n            return\n        del kv[""ncols""]\n    elif n == 4:\n        showImgLists(imgs[:2],**kv)\n        showImgLists(imgs[2:],**kv)\n        return\n    elif n > 4:\n        showImgLists(imgs[:3],**kv)\n        showImgLists(imgs[3:],**kv)\n        return\n    if ""figsize"" in kv:\n        figsize = kv.pop(""figsize"")\n        fig, axes = plt.subplots(ncols=n, figsize=figsize)\n    else:\n        fig, axes = plt.subplots(ncols=n)\n    count = 0\n    axes = [axes] if n==1 else axes\n    for img in imgs:\n        axes[count].imshow(img,**kv)\n        count += 1\n    plt.show()\n    \ndef show(*imgsAndFuns,**kv):\n    \'\'\'\n    show could find every image in complex struct and show they\n    could sample images from torch.DataLoader and DataSet\n    \n    if imgsAndFuns inculde function. those functions will process all numpys befor imshow\n    \n    Parameters\n    ----------\n    imgsAndFuns : numpy/list/tuple/dict/torch.tensor/PIL.Image/function\n        if imgsAndFuns inculde function . \n        those functions will process all numpys befor imshow\n    kv : args\n        args for plt.imshow\n    \xe6\x89\xbe\xe5\x87\xba\xe4\xb8\x80\xe4\xb8\xaa\xe5\xa4\x8d\xe6\x9d\x82\xe7\xbb\x93\xe6\x9e\x84\xe4\xb8\xad\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89numpy \xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe5\xb9\xb6plt.show()\xe5\x87\xba\xe6\x9d\xa5\n    \'\'\'\n    if \'cmap\' not in kv:\n        kv[\'cmap\'] = \'gray\'\n    funs = [arg for arg in imgsAndFuns[1:] if callable(arg)]\n    doNumpy = pipe(funs+[ndarrayToImgLists])\n    imgls = listToImgLists(imgsAndFuns,doNumpy=doNumpy)\n    imgls = [img for img in imgls if img.ndim >= 2 and min(img.shape) > 2]\n    assert len(imgls)!=0,""function `show`\'s args `imgs`  has no any np.ndarray that ndim >= 2! ""\n    showImgLists(imgls,**kv)\nshow = FunAddMagicMethod(show)\n\n\ndef showb(*arr,**__kv):\n    \'\'\'\n    use shotwell to show picture\n    Parameters\n    ----------\n    arr : np.ndarray or path\n    \'\'\'\n    \n    if len(arr)!=1:\n        list(map(lambda ia:showb(ia[1],tag=ia[0]),enumerate(arr)))\n        return \n    arr = arr[0]\n    if isinstance(arr,np.ndarray):\n        if arr.ndim == 3 and arr.shape[-1] == 3:\n            path = tmpYl + \'tmp-%s.jpg\'%len(glob.glob(tmpYl + \'tmp-*.jpg\'))\n        else:\n            path = tmpYl + \'tmp-%s.png\'%len(glob.glob(tmpYl + \'tmp-*.png\'))\n        if arr.dtype == np.bool:\n            arr = np.uint8(arr) * 255\n        imsave(path,arr)\n        arr = path\n    cmd = \'shotwell ""%s"" &\'%arr\n    if sysi.win:\n        cmd = \'""%s""\'%arr\n    os.system(cmd)\nshowb = FunAddMagicMethod(showb)\n\n\nimgExtNames = [\'jpg\', \'jpeg\', \'png\', \'gif\', \'tif\', \'bmp\']\ndef isImgFileName(fname):\n    return \'.\' in fname and fname.split(\'.\')[-1].lower() in imgExtNames\n\ndef shows(*imgs):\n    \'\'\'\xe5\x9b\xbe\xe7\x89\x87\xe5\xb1\x95\xe7\xa4\xba\xe5\x88\x86\xe6\x9e\x90\xe5\xb7\xa5\xe5\x85\xb7  \xe4\xbd\xbf\xe7\x94\xa8\xe6\xb5\x8f\xe8\xa7\x88\xe5\x99\xa8\xe5\x90\x8c\xe6\xad\xa5\xe6\x98\xbe\xe7\xa4\xba\xe5\x90\x8c\xe4\xb8\x80\xe5\x9b\xbe\xe5\x83\x8f\xe7\x9a\x84\xe4\xb8\x8d\xe5\x90\x8c\xe6\x95\xb0\xe6\x8d\xae\xe8\xa1\xa8\xe7\xa4\xba \xe5\xa6\x82\xe4\xb8\x8d\xe5\x90\x8c\xe9\x80\x9a\xe9\x81\x93\xe7\x9a\x84image,gt,resoult \n    \xe6\x94\xaf\xe6\x8c\x81\xe6\x94\xbe\xe5\xa4\xa7\xe7\xbc\xa9\xe5\xb0\x8f\xe4\xb8\x8e\xe6\x8b\x96\xe6\x8b\xbd\n    \n    Parameters\n    ----------\n    imgs : list include path or np.ndarray \n        \xe5\x9b\xbe\xe7\x89\x87\xe5\x9c\xb0\xe5\x9d\x80\xe6\x88\x96\xe5\x9b\xbe\xe7\x89\x87np.ndarray \xe7\xbb\x84\xe6\x88\x90\xe7\x9a\x84list \xe8\xa6\x81\xe6\xb1\x82\xe6\x89\x80\xe6\x9c\x89\xe5\x9b\xbe\xe7\x89\x87\xe5\xae\xbd\xe9\xab\x98\xe7\x9b\xb8\xe5\x90\x8c\n    \'\'\'\n    \n    def _listToImgLists(l, res=None,doNumpy=ndarrayToImgLists):\n        \'\'\'\n        \xe5\xb0\x86 ndarray\xe5\x92\x8clist\xe7\x9a\x84\xe6\xb7\xb7\xe5\x90\x88\xe7\xbb\x93\xe6\x9e\x9c\xe6\xa0\x91\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba \xe4\xb8\x80\xe7\xbb\xb4 img list\n        \'\'\'\n        if res is None:\n            res = []\n        for x in l:\n            typeName = isinstancestr(x, typesToNumpyFuns)\n            if typeName:\n                ndarray = typesToNumpyFuns[typeName](x)\n                res.extend(doNumpy(ndarray))\n            elif isinstance(x,(list,tuple)):\n                _listToImgLists(x,res=res,doNumpy=doNumpy)\n            elif isinstance(x,dict):\n                _listToImgLists(list(x.values()),res=res,doNumpy=doNumpy)\n            elif isinstance(x,np.ndarray):\n                res.extend(doNumpy(x))\n            elif isinstance(x,str):\n                if os.path.isfile(x) and isImgFileName(x):\n                    res.append(x)\n        return res\n    \n    \n    funs = [arg for arg in imgs[1:] if callable(arg)]\n    doNumpy = pipe(funs+[ndarrayToImgLists])\n    imgs = _listToImgLists(imgs,doNumpy=doNumpy)\n    \n    \n    showsDir = os.path.join(tmpYl, \'shows\')\n    dirr = showsDir + \'/shows-%s.html\' % len(glob.glob(showsDir + \'/shows-*.html\'))\n    os.makedirs(dirr, exist_ok=True)\n    \n    paths = []\n    for idx, x in enumerate(imgs):\n        if isinstance(x,str):\n            x = imread(x)\n        if x.ndim == 3 and x.shape[-1] == 3:\n            fname = \'%s.jpg\'%idx\n        else:\n            fname = \'%s.png\'%idx\n        imgp = os.path.join(dirr, fname)\n        imsave(imgp, x)\n        paths.append(fname)\n    htmlp = os.path.join(dirr, \'index.html\')\n    from .showImgsInBrowser import showImgsInBrowser\n    showImgsInBrowser(paths, htmlp)\nshows = FunAddMagicMethod(shows)\n\n\n    \ndef __torchShape(x):\n    if x.shape:\n        s = ""%s of %s @ %s""%(tuple(x.shape), x.type(), str(x.device))\n    else:\n        s = ""%s of %s @ %s""%(strnum(float(x)), x.type(), str(x.device))\n    return colorFormat.r%s\n\n__numpy_struch_log_fun = lambda x:colorFormat.r%(\'%s%s\'%\n                                    (str(x.shape).replace(\'L,\',\'\').replace(\'L\',\'\'),x.dtype))\n\nStructLogFuns = {\n    \'list\':lambda x:colorFormat.b%(\'list  %d\'%len(x)),\n    \'tuple\':lambda x:colorFormat.b%(\'tuple %d\'%len(x)),\n    \'dict\':lambda x:colorFormat.b%(\'dict  %s\'%len(x)),\n    \'mappingproxy\':lambda x:colorFormat.b%(\'mappingproxy  %s\'%len(x)),\n    \'set\':lambda x:(colorFormat.r%\'set %s = \'%len(x) + colorFormat.b%str(x)),\n    \'collections.defaultdict\':lambda x:colorFormat.b%(\'defaultDict  %s\'%len(x)),\n    \'dicto\':lambda x:colorFormat.b%(\'dicto  %s\'%len(x)),\n    \'tool.toolStructObj.dicto\':lambda x:colorFormat.b%(\'dicto  %s\'%len(x)),\n    \'tool.toolLog.SuperG\':lambda x:colorFormat.b%(\'SuperG  %s\'%len(x)),\n    \'collections.OrderedDict\':lambda x:colorFormat.b%(\'OrderedDict  %s\'%len(x)),\n    \'dictoSub\':lambda x:colorFormat.b%(\'dictoSub  %s\'%len(x)),\n    \n    \'numpy.ndarray\':__numpy_struch_log_fun,\n    \'imageio.core.util.Array\':__numpy_struch_log_fun,\n    \'scipy.sparse.csr.csr_matrix\':lambda x:__numpy_struch_log_fun(x) + colorFormat.r%"" of sparse.csr"",\n    \'scipy.sparse.coo.coo_matrix\':lambda x:__numpy_struch_log_fun(x) + colorFormat.r%"" of sparse.coo"",\n    \'scipy.sparse.csc.csc_matrix\':lambda x:__numpy_struch_log_fun(x) + colorFormat.r%"" of sparse.csc"",\n    \n    \'torch.Tensor\':__torchShape,\n    \n    \'torch.FloatTensor\':__torchShape,\n    \'torch.DoubleTensor\':__torchShape,\n    \'torch.IntTensor\':__torchShape,\n    \'torch.LongTensor\':__torchShape,\n    \'torch.ShortTensor\':__torchShape,\n    \'torch.ByteTensor\':__torchShape,\n    \'torch.HalfTensor\':__torchShape,\n    \'torch.CharTensor\':__torchShape,\n    \n    ""torch.cuda.LongTensor"":__torchShape,\n    ""torch.cuda.DoubleTensor"":__torchShape,\n    ""torch.cuda.IntTensor"":__torchShape,\n    ""torch.cuda.ShortTensor"":__torchShape,\n    ""torch.cuda.ByteTensor"":__torchShape,\n    ""torch.cuda.HalfTensor"":__torchShape,\n    ""torch.cuda.CharTensor"":__torchShape,\n    ""torch.cuda.FloatTensor"":__torchShape,\n    ""torch.autograd.variable.Variable"":lambda x:__torchShape(x.data),\n    ""torch.nn.parameter.Parameter"":lambda x:__torchShape(x.data),\n    \n    \'torch.utils.data.dataloader.DataLoader\':lambda x:(colorFormat.b%\'DataLoader(len=%d, batch=%d, worker=%d)\'%\n                                                       (len(x.dataset), x.batch_size, x.num_workers)),\n    \n    \'mxnet.ndarray.NDArray\':lambda x:colorFormat.r % \'%s of mxnet.%s\'%(str(x.shape), str(x.dtype)),\n    \'mxnet.ndarray.ndarray.NDArray\':lambda x:colorFormat.r % \'%s of mxnet.%s\'%(str(x.shape), str(x.dtype)),\n    \n    \'pandas.core.frame.DataFrame\':lambda x:clf.r%\'DataFrame(col=%d, Index=[%s], dtype=""%s"")\'%(x.shape[0], \', \'.join(map(str,x.columns)), x.columns.dtype)\n    }\n\ndef discribOfInstance(instance,leafColor=None,MAX_LEN=45):\n    typee = type(instance)\n    typen = typeNameOf(typee)\n#    print typen,typen in StructLogFuns\n    if isinstance(instance,dicto) and typen not in StructLogFuns:\n        typen = \'dictoSub\'\n    if typen in StructLogFuns:\n        s = StructLogFuns[typen](instance)\n        return shortStr(s, MAX_LEN+18)\n    s = tounicode(instance)\n    if len(s) > MAX_LEN:\n        s = s[:MAX_LEN-3]+\'...\'\n    return (leafColor or \'%s\')%s\n\n\ndef unfoldTorchData(seq, fathersStr=\'\'):\n    \'\'\'\n    unfold torch.Dataset and Dataloader use next(iter()) for tree  \n    \'\'\'\n    import torch\n    if isinstance(seq, torch.utils.data.DataLoader) or \'DataLoader\' in fathersStr:\n        seq = [(\'DataLoader.next\', nextiter(seq, raiseException=False))]\n    elif isinstance(seq, torch.utils.data.Dataset) or \'Dataset\' in fathersStr:\n        seq = [(colorFormat.b%\'Dataset[0/%d]\'%len(seq), seq[0])]\n    else:\n        return False\n    return seq\n\nMappingProxyType = dict if py2 else types.MappingProxyType \n    \niterAbleTypes = (list,tuple,dict,types.GeneratorType, MappingProxyType)\ndef unfoldAble(seq):\n    \'\'\'\n    \xe8\x83\xbd\xe5\xb1\x95\xe5\xbc\x80\xe7\x9a\x84 object \n    \'\'\'\n    if isinstance(seq,iterAbleTypes) :\n        if isinstance(seq,(list,tuple)):\n            seq = list(enumerate(seq))\n        elif isinstance(seq,(dict, MappingProxyType)):\n            seq = list(seq.items())\n        elif isinstance(seq, types.GeneratorType):\n            seq = [(\'Generator.next\', nextiter(seq, raiseException=False))]\n        return seq\n    fathersStr = str(getfathers(seq))\n    if (\'torch.utils.data\') in fathersStr or (\'torchvision.datasets\') in fathersStr:\n        return unfoldTorchData(seq, fathersStr)\n    return False\n\nclass HiddenForTree():\n    def __init__(self, lenn, maxprint):\n        self.n = lenn\n        self.m = maxprint\n        self.s = colorFormat.r%\'Hidden %s of all %d\'%((lenn-maxprint//2*2), lenn)\n        self.repeat = max(4,min(1,maxprint//2))\n    def __str__(self):\n        return self.s\n    def strr(self, leftStr):\n        lineTempl = \'\'.join(leftStr)\n        lineTempl += \'\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 \'\n        half = (lineTempl + colorFormat.r%\'\xc2\xb7\xc2\xb7\xc2\xb7\\n\')*self.repeat\n        mid = lineTempl + colorFormat.b%self.s+\'\\n\'\n        s = half + mid + half\n        return s \n    \ndef tree(seq,maxprint=50,deep=None,logLen=45,printf=log,leafColor=\'\\x1b[31m%s\\x1b[0m\',__key=\'/\',__leftStr=None, __islast=None,__deepNow=0, __sets=None):\n    \'\'\'\n    \xe7\xb1\xbb\xe4\xbc\xbcbash\xe4\xb8\xad\xe7\x9a\x84tree\xe5\x91\xbd\xe4\xbb\xa4 \n    \xe7\x9b\xb4\xe8\xa7\x82\xe5\x9c\xb0\xe6\x9f\xa5\xe7\x9c\x8blist, tuple, dict, numpy, tensor, dataset, dataloader \xe7\xad\x89\xe7\xbb\x84\xe6\x88\x90\xe7\x9a\x84\xe6\xa0\x91\xe7\x9a\x84\xe6\xaf\x8f\xe4\xb8\x80\xe5\xb1\x82\xe7\xbb\x93\xe6\x9e\x84   \n    \xe5\x8f\xaf\xe8\xbf\xad\xe4\xbb\xa3\xe9\x83\xa8\xe5\x88\x86\xe7\x94\xa8\xe8\x93\x9d\xe8\x89\xb2 \xe5\x8f\xb6\xe5\xad\x90\xe7\x94\xa8\xe7\xba\xa2\xe8\x89\xb2\xe6\x89\x93\xe5\x8d\xb0   \n    \xe4\xbb\xa5\xe4\xb8\x8b\xe5\x91\xbd\xe4\xbb\xa4\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x9f\xa5\xe7\x9c\x8b\xe6\x94\xaf\xe6\x8c\x81\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xe7\xbb\x93\xe6\x9e\x84\xe7\xb1\xbb\xe5\x9e\x8b   \n    \n    >>> tree(boxx.ylimg.ylimgTool.StructLogFuns)\n    \n    Parameters\n    ----------\n    seq : list or tuple or dict or numpy or tensor or torch.Dataset or torch.Dataloader or any Object\n        \xe6\x89\x93\xe5\x8d\xb0\xe5\x87\xba \xe4\xbb\xa5\xe6\xa0\x91\xe7\xbb\x93\xe6\x9e\x84\xe5\xb1\x95\xe5\xbc\x80\xe6\x89\x80\xe6\x9c\x89\xe5\x8f\xaf\xe8\xbf\xad\xe4\xbb\xa3\xe9\x83\xa8\xe5\x88\x86\n    maxprint : int, default 50\n        \xe6\xaf\x8f\xe4\xb8\xaa seq \xe5\x86\x85\xe9\x83\xa8\xef\xbc\x8c\xe6\x9c\x80\xe5\xa4\xa7\xe5\x85\x81\xe8\xae\xb8\xe7\x9a\x84\xe6\x95\xb0\xe7\x9b\xae \xe9\xbb\x98\xe8\xae\xa4\xe6\x9c\x80\xe5\xa4\x9a\xe5\xb1\x95\xe7\xa4\xba 50 \xe4\xb8\xaa   \n        \xe8\x8b\xa5 bool(maxprint) \xe4\xb8\xba False \xe5\x88\x99\xe4\xb8\x8d\xe5\x81\x9a\xe9\x99\x90\xe5\x88\xb6\n    deep : int, default None\n        \xe8\x83\xbd\xe6\x98\xbe\xe7\xa4\xba\xe7\x9a\x84\xe6\x9c\x80\xe6\xb7\xb1\xe6\xb7\xb1\xe5\xba\xa6, \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\x8d\xe9\x99\x90\xe5\x88\xb6\n    logLen : int, default 45\n        \xe8\x83\xbd\xe6\x98\xbe\xe7\xa4\xba\xe7\x9a\x84\xe6\x9c\x80\xe9\x95\xbf\xe5\xad\x97\xe7\xac\xa6\xe6\x95\xb0\n    printf : function, default print function\n        a function that could replace print \n    \n    ps.\xe5\x8f\xaf\xe5\x9c\xa8StructLogFuns\xe4\xb8\xad \xe6\x96\xb0\xe5\xa2\x9e\xe7\xb1\xbb\xe5\x88\xab\n    \'\'\'\n    if deep and __deepNow > deep:\n        return\n    if __leftStr is None:\n        __leftStr = [] \n        __islast = 1\n        __sets = set()\n    if maxprint and isinstance(seq, HiddenForTree):\n        printf(seq.strr(__leftStr), end=\'\')\n        return \n#    s = StructLogFuns.get(type(seq),lambda x:colorFormat.r%tounicode(x)[:60])(seq)\n    try:\n        s = discribOfInstance(seq,leafColor=leafColor,MAX_LEN=logLen)\n    except Exception as e:\n        s = colorFormat.r%""\xe3\x80\x90%s\xe3\x80\x91""%e.__repr__()\n    s = s.replace(\'\\n\',\'\xe2\x86\xb3\')\n#    printf \'\'.join(__leftStr)+u\'\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 \'+tounicode(k)+\': \'+s\n    printf(\'%s%s %s: %s\'%(\'\'.join(__leftStr), \'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\' if __islast else \'\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\',tounicode(__key),s))\n    \n    unfold = unfoldAble(seq)\n    if unfold is False :\n        return \n    else:\n        if id(seq) in __sets:\n            seq=[(colorFormat.p%\'\xe3\x80\x90printed befor\xe3\x80\x91\',\'\')]\n        else:\n            __sets.add(id(seq))\n            seq = unfold\n    __leftStr.append(\'    \'if __islast else \'\xe2\x94\x82   \')\n    if maxprint : \n        lenn = len(seq)\n        if lenn > maxprint:\n            head = maxprint//2\n            seq = seq[:head] + [(\'HiddenForTree\',HiddenForTree(lenn=lenn, maxprint=maxprint))] + seq[-head:]\n    for i,kv in enumerate(seq):\n        __key,v = kv\n        tree(v,maxprint=maxprint,deep=deep,logLen=logLen, printf=printf,leafColor=leafColor, __key=__key, __leftStr=__leftStr, \n             __islast=(i==len(seq)-1),__deepNow=__deepNow+1,__sets=__sets)\n    __leftStr.pop()\ntree = FunAddMagicMethod(tree)\n\ndef __typee__(x):\n    return tounicode(type(x)).split(""\'"")[1]\n\nlogModFuns = {\n type(os):lambda x:colorFormat.r%(__typee__(x)),\n }\nlogMod = lambda mod:logModFuns.get(type(mod),lambda x:colorFormat.b%tounicode(__typee__(x))[:60])(mod)\ndef treem(mod, types=None, deep=None, __leftStrs=None, __name=\'/\', \n          __islast=None, __deepNow=0, __rootDir=None, __sets=None):\n    \'\'\'\n    \xe7\xb1\xbb\xe4\xbc\xbcbash\xe4\xb8\xad\xe7\x9a\x84tree\xe5\x91\xbd\xe4\xbb\xa4 \xe6\x9f\xa5\xe7\x9c\x8bmodule\xe5\x8f\x8a\xe5\xad\x90module\xe7\x9a\x84\xe6\xaf\x8f\xe4\xb8\x80\xe5\xb1\x82\xe7\xbb\x93\xe6\x9e\x84\n    \xe4\xb8\x80\xe7\x9b\xae\xe4\xba\x86\xe7\x84\xb6module\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x84\xe5\x92\x8capi\n    module\xe7\x94\xa8\xe7\xba\xa2\xe8\x89\xb2\xe6\x98\xbe\xe7\xa4\xba \xe5\x85\xb6\xe4\xbd\x99\xe9\x83\xa8\xe5\x88\x86\xe7\x94\xa8\xe8\x93\x9d\xe8\x89\xb2\xe6\x98\xbe\xe7\xa4\xba\n    >>>treem(os)\n    \n    Parameters\n    ----------\n    mod : module\n        \xe6\x98\xbe\xe7\xa4\xba\xe5\x87\xba \xe4\xbb\xa5\xe6\xa0\x91\xe7\xbb\x93\xe6\x9e\x84\xe5\xb1\x95\xe5\xbc\x80module\xe5\x8f\x8a\xe5\x85\xb6\xe5\xad\x90module\n        type(mod) should => module\n    types : list of types, default None\n        \xe9\x9c\x80\xe8\xa6\x81\xe6\x98\xbe\xe7\xa4\xba\xe5\x87\xba\xe6\x9d\xa5\xe7\x9a\x84\xe7\xb1\xbb\xe5\x9e\x8b(module \xe7\xb1\xbb\xe5\x9e\x8b\xe4\xbc\x9a\xe8\x87\xaa\xe5\x8a\xa8\xe6\xb7\xbb\xe5\x8a\xa0)\n        \xe9\xbb\x98\xe8\xae\xa4\xe6\x98\xbe\xe7\xa4\xba\xe6\x89\x80\xe6\x9c\x89\xe7\xb1\xbb\xe5\x9e\x8b\n        ps.\xe4\xb8\xba\xe4\xba\x86\xe4\xbd\xbf\xe7\x94\xa8deep\xe6\x9b\xb4\xe7\xae\x80\xe4\xbe\xbf \xe8\x8b\xa5`treem(mod, [int])` \n           \xe5\x88\x99\xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba`treem(mod, types=None, deep=[int])`\n    deep : int, default None\n        \xe8\x83\xbd\xe6\x98\xbe\xe7\xa4\xba\xe7\x9a\x84\xe6\x9c\x80\xe6\xb7\xb1\xe6\xb7\xb1\xe5\xba\xa6\n        \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\x8d\xe9\x99\x90\xe5\x88\xb6\n    \'\'\'\n    if isinstance(types, int):\n        deep = types\n        types = None\n    if deep and __deepNow > deep:\n        return\n    if __leftStrs is None:\n        __leftStrs = [] \n        __islast = 1\n        if \'__file__\' not in dir(mod): \n            print(\'type(%s: %s) is not module!\'%(logMod(mod),tounicode(mod)))\n            return \n        __rootDir = os.path.dirname(mod.__file__)\n        __sets = set()\n    typeStr = logMod(mod)\n    modKinds = [\'\',\'\',\'(not sub-module)\',\'(printed befor)\']\n    modKind = 0\n    if isinstance(mod,type(os)):\n        if \'__name__\' in dir(mod) :\n            __name = mod.__name__\n        modKind = 1\n        dirMod = dir(mod)\n        if  mod in __sets:\n            modKind = 3 \n        elif \'__file__\' not in dir(mod) or __rootDir not in mod.__file__:\n            modKind = 2\n    names = (tounicode(__name)+(\'   \' if modKind<2 else \'  \xc2\xb7\' )*20)[:40]+modKinds[modKind]\n    \n    print(\'%s%s %s: %s\'%(\'\'.join(__leftStrs), \'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\' if __islast else \'\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\',typeStr,names))\n    \n    if modKind !=1:\n        return\n    __sets.add(mod)\n    dirMod = [i for i in dirMod if i not in [\'__name__\',\'__file__\',\'unicode_literals\']]\n    if types is not None:\n        dirMod=[i for i in dirMod if type(mod.__getattribute__(i)) in  list(types)+[type(os)]] \n    __leftStrs.append(\'    \'if __islast else \'\xe2\x94\x82   \')\n    for i,name in enumerate(dirMod):\n        e = mod.__getattribute__(name)\n        treem(e,types,deep,__leftStrs,name,__islast=(i==len(dirMod)-1),__deepNow=__deepNow+1,__rootDir=__rootDir,__sets=__sets)\n    __leftStrs.pop()\ntreem = FunAddMagicMethod(treem)\n\ndef getFunDocForDira(f):\n    d = getDoc(f)\n    if d:\n        return \' : %s\'%(colorFormat.black%tounicode(d.strip()))\n    return \'\'\n\nattrLogFuns = {\n\'method-wrapper\': lambda x:\'method-wrapper%s\'%getFunDocForDira(x),\n\'builtin_function_or_method\':lambda x:\'builtin-method%s\'%getFunDocForDira(x),\n\'instancemethod\':lambda x:\'instancemethod%s\'%getFunDocForDira(x),\n\'buffer\':lambda x:\'buffer : %s\'%(colorFormat.b%tounicode(x)),\n}\n\ndef __dira(seq,instance=None, maxDocLen=50, deep=None, printf=print, __leftStr=None,__key=\'/\',__islast=None,__deepNow=0, __sets=None):\n    \'\'\'\n    \xe7\xb1\xbb\xe4\xbc\xbcbash\xe4\xb8\xad\xe7\x9a\x84tree\xe5\x91\xbd\xe4\xbb\xa4 \xe7\xae\x80\xe5\x8d\x95\xe6\x9f\xa5\xe7\x9c\x8binstance\xe7\x9a\x84 __attrs__ \xe7\xbb\x84\xe6\x88\x90\xe7\x9a\x84\xe6\xa0\x91\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x84\n    attr name\xe7\x94\xa8\xe7\xba\xa2\xe8\x89\xb2\xef\xbc\x9bstr(instance.attr)\xe7\x94\xa8\xe8\x93\x9d\xe8\x89\xb2\xef\xbc\x9b\n    \xe5\xa6\x82\xe6\x9e\x9cattr \xe4\xb8\xbainstancemethod\xef\xbc\x8cbuiltin_function_or_method\xef\xbc\x8cmethod-wrapper\xe4\xb9\x8b\xe4\xb8\x80\n    instance.attr.__doc__\xe7\x94\xa8\xe9\xbb\x91\xe8\x89\xb2 \n    \n    ps.\xe5\x8f\xaf\xe5\x9c\xa8__attrLogFuns\xe4\xb8\xad \xe6\x96\xb0\xe5\xa2\x9e\xe5\xb8\xb8\xe8\xa7\x81\xe7\xb1\xbb\xe5\x88\xab\n    \'\'\'\n    if deep and __deepNow > deep:\n        return\n    s = discribOfInstance(seq,colorFormat.b,MAX_LEN=maxDocLen)\n    if maxDocLen < 100:\n        s = s.replace(\'\\n\',\'\xe2\x86\xb3\')\n    if __leftStr is None:\n        __leftStr = [] \n        __islast = 1\n        __sets = set()\n        doc = \'\' if instance is None else getFunDocForDira(instance)\n        if len(doc) > maxDocLen:\n            doc = doc[:maxDocLen-3]+\'...\'\n        s=colorFormat.b%(\'%d attrs%s\'%(len(seq), doc.replace(\'\\n\',\'\xe2\x86\xb3\').replace(\' :\',\',\',1)))\n#    printf \'\'.join(__leftStr)+u\'\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 \'+tounicode(k)+\': \'+s\n    printf(\'%s%s %s: %s\'%(\'\'.join(__leftStr), \'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\' if __islast else \'\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\',colorFormat.r%tounicode(__key),s))\n    if isinstance(seq,(list,tuple,dict)) :\n        if id(seq) in __sets:\n            seq=[(colorFormat.p%\'\xe3\x80\x90printed befor\xe3\x80\x91\',\'\')]\n        else:\n            __sets.add(id(seq))\n            if isinstance(seq,(list,tuple)):\n                seq = list(enumerate(seq))\n            elif isinstance(seq,(dict)):\n                seq = list(seq.items())\n                try: # key may not be sort\n                    seq.sort(key=lambda x:x[0])\n                except:\n                    pass\n    else:\n        return \n    __leftStr.append(\'    \'if __islast else \'\xe2\x94\x82   \')\n    seq =  [(k,filterMethodName(k,v)) for k,v in seq]\n    for i,kv in enumerate(seq):\n        __key,v = kv\n        __dira(v,maxDocLen=maxDocLen,deep=deep, printf=printf,__leftStr=__leftStr,__key=__key,\n               __islast=(i==len(seq)-1), __deepNow=__deepNow+1,__sets=__sets)#leafColor=colorFormat.black)\n    __leftStr.pop()\n\ndef filterMethodName(attrName, attr):\n    typee = type(attr)\n    typn = typeNameOf(typee)\n    if typn in attrLogFuns:\n        return attrLogFuns[typn](attr)\n    if attrName in (\'__globals__\', \'func_globals\'):\n        return colorFormat.b%(\'\xe3\x80\x90globals-dict %d omitted\xe3\x80\x91\'%len(attr))\n    elif attrName in (\'__builtins__\', ) and isinstance(attr, dict):\n        return colorFormat.b%(\'\xe3\x80\x90builtins-dict %d omitted\xe3\x80\x91\'%len(attr))\n    elif attrName in (\'__all__\',):\n        return colorFormat.b%(\'\xe3\x80\x90all-list %d omitted\xe3\x80\x91\'%len(attr))\n    elif attrName == (\'f_builtins\'):\n        return colorFormat.b%(\'\xe3\x80\x90f_builtins %d omitted\xe3\x80\x91\'%len(attr))\n    return attr\n\ndef dira(instance, pattern=None, deep=None, maxDocLen=50, printf=print, printClassFathers=True):\n    \'\'\'\n    `dira(x)` is supplement of `dir(x)`. \n    `dira(x)` will pretty print `x`\'s all attribute in tree struct.    \n    And `dira(x)` will print `x`\'s Father Classes too.    \n    \n    Parameters\n    ----------\n    instance : Anything\n        Anything, Instance better\n    pattern : re.pattern\n        use re.search to filter attrs\n    deep : int, default None\n        max deep of struct object\n    maxDocLen : int, default 50\n        max len of doc\n    printf : function, default print function\n        a function that could replace print \n        \n    P.S.unfold (\'__globals__\', \'func_globals\', __builtins__, __all__, f_builtins)\n    \n    \n    Old Chinese\n    ---------\n    \n    \xe4\xbb\xa5\xe6\xa0\x91\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x84 \xe5\x88\x86\xe6\x9e\x90instance\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89 attrs, \xe5\xb9\xb6\xe5\xb1\x95\xe7\xa4\xba\xe7\x88\xb6\xe7\xb1\xbb\xe7\x9a\x84\xe7\xbb\xa7\xe6\x89\xbf\xe9\x93\xbe\n    attr name\xe7\x94\xa8\xe7\xba\xa2\xe8\x89\xb2\xef\xbc\x9bstr(instance.attr)\xe7\x94\xa8\xe8\x93\x9d\xe8\x89\xb2\xef\xbc\x9b\n    \xe5\xa6\x82\xe6\x9e\x9cattr \xe4\xb8\xbainstancemethod\xef\xbc\x8cbuiltin_function_or_method\xef\xbc\x8cmethod-wrapper\xe4\xb9\x8b\xe4\xb8\x80\n    instance.attr.__doc__\xe7\x94\xa8\xe9\xbb\x91\xe8\x89\xb2 \n    \n    Parameters\n    ----------\n    instance : Anything\n        Anything, Instance better\n    pattern : re.pattern\n        \xe7\x94\xa8\xe4\xba\x8e\xe5\x8c\xb9\xe9\x85\x8dre.search\xe5\x8f\x82\xe6\x95\xb0 \xe8\xbf\x9b\xe8\xa1\x8cfilter\n        ps.\xe4\xb8\xba\xe4\xba\x86\xe4\xbd\xbf\xe7\x94\xa8deep\xe6\x9b\xb4\xe7\xae\x80\xe4\xbe\xbf \xe8\x8b\xa5`dira(instance, [int])` \n           \xe5\x88\x99\xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba`dira(instance, pattern=None, deep=[int])`\n    maxDocLen : int, default 50\n        \xe8\x8b\xa5\xe6\x9c\x89\xe6\x96\x87\xe6\xa1\xa3\xe6\x98\xbe\xe7\xa4\xba\xe6\x96\x87\xe6\xa1\xa3\xe7\x9a\x84\xe5\xad\x97\xe6\x95\xb0\xe9\x95\xbf\xe5\xba\xa6\n    deep : int, default None\n        \xe8\x83\xbd\xe6\x98\xbe\xe7\xa4\xba\xe7\x9a\x84\xe6\x9c\x80\xe6\xb7\xb1\xe6\xb7\xb1\xe5\xba\xa6, \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\x8d\xe9\x99\x90\xe5\x88\xb6\n    printf : function, default print function\n        a function that could replace print \n        \n    ps.\xe5\x8f\xaf\xe5\x9c\xa8__attrLogFuns\xe4\xb8\xad \xe6\x96\xb0\xe5\xa2\x9e\xe5\xb8\xb8\xe8\xa7\x81\xe7\xb1\xbb\xe5\x88\xab\n    pps.\xe4\xb8\x8d\xe5\xb1\x95\xe5\xbc\x80 (\'__globals__\', \'func_globals\', __builtins__, __all__, f_builtins)\n    \'\'\'\n    if printClassFathers:\n        s = prettyClassFathers(instance)\n        printf((colorFormat.b%\'Classes: \\n\'+\'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 \'+s+\'\'))\n    \n    printf((colorFormat.b%\'Attrs: \'))\n    if isinstance(pattern, int):\n        deep = pattern\n        pattern = None\n    dirs = dir(instance)\n    if pattern is not None:\n        import re\n        dirs = [name for name in dirs if re.search(pattern,name)]\n        printf(\'Filter by pattern: ""%s""\'%(colorFormat.r%pattern))\n    def getAttr(attr):\n        try:\n            try :\n                return getattr(instance, attr)\n            except :\n                pass\n            try:\n    #            if \'__getattribute__\' in dirs or 1:\n                return instance.__getattribute__(attr)\n            except (TypeError): # may be type\n                try :\n                    return instance.__getattribute__(instance, attr)\n                except :\n                    pass\n                \n            except (AttributeError, KeyError):\n                pass\n            try:\n                if \'__getattr__\' in dirs:\n                    return instance.__getattr__(attr)\n            except (AttributeError, TypeError):\n                return colorFormat.p % \'\xe3\x80\x90""getattr""/""getattribute"" are not work\xe3\x80\x91\'\n            return  colorFormat.p % \'\xe3\x80\x90No ""getattr"" or ""getattribute""\xe3\x80\x91\'\n        except Exception as e:\n            return colorFormat.p % \'\xe3\x80\x90""getAttr"" fail, %s(%s)\xe3\x80\x91\'%(typestr(e),e)\n    l = list(map(getAttr,dirs))\n    l = list(map(filterMethodName,dirs,l))\n    dic = dict(list(zip(dirs,l)))    \n    __dira(dic,instance=instance, maxDocLen=maxDocLen, deep=deep,__key=typeNameOf(type(instance)), printf=printf, )\n\ndira = FunAddMagicMethod(dira)\ntreea = dira\n\ndef what(anything, full=False):\n    \'\'\'\n    tell you what\'s this by\n    pretty print `Document`, `Classes`, `Inner Struct`, `Attributes` of anything.\n    \n    a magic tool to learn new Python Package\n\n    Parameters\n    ----------\n    anything : anything in Python\n        decompose all of anything\n    full : bool, default False\n        in default, print lines is less than 10\n        set full to True, print all lines\n    \'\'\'\n    tostr = discrib(anything, maxline=not(full) and 10)\n    doc = getDoc(anything) or clf.p%""\xe3\x80\x90Not found document\xe3\x80\x91""\n    doc = discrib(doc, maxline=not(full) and 15)\n    classes = prettyClassFathers(anything)\n    doStr = print\n    if pyi.jn:\n        strs = []\n        doStr = strs.append\n        \n    doStr(\'-\'*10+clf.b%\'end of what(\' + clf.p%(\'""%s""\'%shortStr(tostr, 30)) + clf.b%\')\'+\'-\'*10)\n    diraPrintf = PrintStrCollect()\n    dira(anything, deep=2, printClassFathers=False, printf=diraPrintf)\n    doStr(diraPrintf)\n    doStr("""")\n    doStr((colorFormat.b%\'Document: \\n\'+\'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 \'+tabstr(doc, 5)+\'\\n\'))    \n\n    innerStruct = isinstance(anything, (list,tuple,dict)) or (typestr(anything) in StructLogFuns)\n    if innerStruct:\n        treePrintf = PrintStrCollect()\n        tree(anything, maxprint=not(full) and 12, printf=treePrintf)\n        doStr((colorFormat.b%\'Inner Struct:\\n\')+tounicode(treePrintf))\n        doStr("""")\n        \n    doStr((colorFormat.b%\'Classes: \\n\'+\'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 \'+classes+\'\\n\'))    \n    doStr((colorFormat.b%\'To Str: \\n\'+\'\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 ""\'+tabstr(tostr, 5)+\'""\\n\'))\n    if pyi.jn:\n        [print(s) for s in strs[::-1]]\nwhat = FunAddMagicMethod(what)\nwtf = what\n\ndef __readShape(n):\n    return imread(n).shape\ndef getShapes(imgGlob, returnn=False):\n    \'\'\'\n    \xe4\xbb\xa5\xe5\xa4\x9a\xe7\xba\xbf\xe7\xa8\x8b\xe8\x8e\xb7\xe5\xbe\x97\xe5\x8c\xb9\xe9\x85\x8dimgGlob\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84shapes\n    \xe5\xb9\xb6print\xe5\x87\xbashapes\xe7\x9a\x84\xe6\x9c\x80\xe5\xa4\xa7\xe6\x9c\x80\xe5\xb0\x8f\xe5\x80\xbc\n    \n    Parameters\n    ----------\n    imgGlob : str\n        \xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84\xe5\x8c\xb9\xe9\x85\x8d\xe8\xb7\xaf\xe5\xbe\x84\n        \xe5\xa6\x82 ""/img_data/*.png""\n    returnn : bool ,default False\n        \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\x8d\xe8\xbf\x94\xe5\x9b\x9eshapes\n        \xe4\xb8\xbaTrue\xef\xbc\x8c\xe5\x88\x99\xe8\xbf\x94\xe5\x9b\x9eshapes\n    \'\'\'\n    names = glob.glob(imgGlob)\n    shapes = mapmp(__readShape,names)\n    lens = list(map(len,shapes))\n    dims = np.unique(lens)\n    arr = shapes\n    print(\'Dims:\')\n    for dim in dims:\n        print(\'\\t %s dim: %d\'%(dim,lens.count(dim)))\n    if len(dims)!=1:\n        maxx = max(dims)\n        arr=[s+(-1,)*(maxx-len(s)) for s in shapes]\n    arr=np.array(arr)\n    maxx, minn = [],[]\n    for dim in range(max(dims)):\n        a = arr[:,dim]\n        maxx.append(a[a!=-1].max())\n        minn.append(a[a!=-1].min())\n    \n    print(\'Shape:\\n \\t max shape: %s\\n \\t min shape: %s\'%(maxx,minn))\n    if returnn:\n        return shapes\n\n__color10 = [\n (1.0, 1.0, 1.0),\n (0.8666666666666667, 1.0, 1.0),\n (0.8, 1.0, 1.0),\n (0.6666666666666667, 1.0, 1.0),\n (0.5333333333333333, 1.0, 1.0),\n (0.4666666666666667, 1.0, 1.0),\n (0.33333333333333337, 1.0, 1.0),\n (0.19999999999999996, 1.0, 1.0),\n (0.1333333333333333, 1.0, 1.0),\n (0.06666666666666665, 1.0, 1.0)]\n\ndef getHsvColors(hn,sn,vn):\n    \'\'\'\n    \xe5\x9c\xa8hsv\xe7\xa9\xba\xe9\x97\xb4\xe4\xba\xa7\xe7\x94\x9f\xe5\xb0\xbd\xe5\x8f\xaf\xe8\x83\xbd\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\xe9\x9b\x86\n    hn,sn,vn \xe5\x88\x86\xe5\x88\xab\xe8\xa1\xa8\xe7\xa4\xba h\xef\xbc\x8cs\xef\xbc\x8cv\xe5\xaf\xb9\xe5\xba\x94\xe6\xaf\x8f\xe4\xb8\xaa\xe9\x80\x9a\xe9\x81\x93\xe7\x9a\x84\xe5\x8f\xaf\xe9\x80\x89\xe5\x80\xbc\xe7\x9a\x84\xe6\x95\xb0\xe7\x9b\xae\n    return `hn*sn*vn`\xe4\xb8\xaa \xe4\xbb\xa5float\xe4\xb8\x89\xe5\x85\x83\xe7\xbb\x84\xe4\xb8\xbaHSV\xe9\xa2\x9c\xe8\x89\xb2\xe5\xbd\xa2\xe5\xbc\x8f\xe7\x9a\x84list\n    \'\'\'\n    def toNcolor(n,incloud0=False):\n        if incloud0:\n            n -= 1\n        l = [1.-i*1./n for i in range(n)]\n        if incloud0:\n            return l+[0.]\n        return l\n    \n    hs,ss,vs = list(map(toNcolor,[hn,sn,vn]))\n    cs = []\n    for s in ss:\n        for v in vs:\n            for h in hs:\n                c = (h,s,v)\n                cs += [c]\n    return cs\n\ndef getDefaultColorList(colorNum=None, includeBackGround=None,uint8=False):\n    \'\'\'\n    \xe4\xba\xa7\xe7\x94\x9f\xe5\xb0\xbd\xe5\x8f\xaf\xe8\x83\xbd\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\xe9\x9b\x86\xef\xbc\x8c\xe7\x94\xa8\xe4\xba\x8e\xe5\xa4\x9alabel\xe4\xb8\x8a\xe8\x89\xb2\n    \n    Parameters\n    ----------\n    colorNum : int, default None\n        \xe9\xa2\x9c\xe8\x89\xb2\xe6\x95\xb0\xe7\x9b\xae,default 21\n    includeBackGround : bool or int, default None\n        None: \xe6\xb2\xa1\xe6\x9c\x89\xe8\x83\x8c\xe6\x99\xaf\xe8\x89\xb2 \xe5\x8d\xb3\xe4\xb8\x8d\xe5\x8c\x85\xe5\x90\xab\xe9\xbb\x91\xe8\x89\xb2\n        1 : \xe7\xac\xac\xe4\xb8\x80\xe7\xb1\xbb\xe4\xb8\xba\xe8\x83\x8c\xe6\x99\xaf\xe5\x8d\xb3\xe9\xbb\x91\xe8\x89\xb2 \n        -1: \xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe7\xb1\xbb\xe4\xb8\xba\xe8\x83\x8c\xe6\x99\xaf\xe5\x8d\xb3\xe9\xbb\x91\xe8\x89\xb2\n    uint8 : bool, default False\n        \xe6\x98\xaf\xe5\x90\xa6\xe8\xbf\x94\xe8\xbf\x98 np.uint8 \xe6\xa0\xbc\xe5\xbc\x8f\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\n        \n    Return\n    ----------\n    \xe4\xbb\xa5float\xe4\xb8\x89\xe5\x85\x83\xe7\xbb\x84\xe4\xb8\xbaRGB\xe9\xa2\x9c\xe8\x89\xb2\xe5\xbd\xa2\xe5\xbc\x8f\xe7\x9a\x84list\n    \'\'\'\n    if colorNum is None:\n        colorNum=21\n        includeBackGround=1\n    if includeBackGround is not None:\n        colorNum -= 1\n    \n    if colorNum <= 12:\n        colors = getHsvColors(6, 1, 2)\n        \n    elif colorNum <= 20:\n        colors = __color10+[(c[0],1.0,.5) for c in __color10]\n    elif colorNum <= 30:\n        colors = __color10+[(c[0],1.0,.66666) for c in __color10]+[(c[0],1.0,.333333) for c in __color10]\n        \n    elif colorNum <= 60:\n        colors = getHsvColors(colorNum//3+1 if colorNum%3 else colorNum//3,1,3)\n    else :\n        colors = getHsvColors(colorNum//6+1,2,3)\n    \n    if includeBackGround == -1:\n        colors = colors[:colorNum] + [(0.,0.,0.)]\n    elif includeBackGround is not None:\n        colors = [(0.,0.,0.)] + colors[:colorNum]\n    else:\n        colors = colors[:colorNum] \n    if uint8 :\n        return list((np.array(colors)*255).astype(np.uint8))\n    \n    from colorsys import hsv_to_rgb\n    toRgb = lambda hsv:hsv_to_rgb(*hsv)\n    return list(map(toRgb,colors))\n\ndef labelToColor(label, colors=None, includeBackGround=None):\n    \'\'\'\n    \xe5\xb0\x86\xe9\xa2\x9c\xe8\x89\xb2\xe9\x9b\x86colors\xe6\x98\xa0\xe5\xb0\x84\xe5\x88\xb0label\xe4\xb8\x8a \xe8\xbf\x94\xe5\x9b\x9e\xe5\xbd\xa9\xe8\x89\xb2\xe7\x9a\x84label\xe5\x9b\xbe\n\n    Parameters\n    ----------\n    label : W*H of int\n        W*H\xe7\x9a\x84labelMap\n    colors : list of RGB color, default None\n        \xe5\xaf\xb9\xe5\xba\x94k\xe7\xb1\xbb\xe7\x9a\x84RGB\xe9\xa2\x9c\xe8\x89\xb2\xe9\x9b\x86\xef\xbc\x8c\xe8\x8b\xa5\xe4\xb8\xbaNone \xe5\x88\x99\xe4\xbc\x9a\xe8\x87\xaa\xe5\x8a\xa8\xe7\x94\x9f\xe6\x88\x90\xe5\xb0\xbd\xe5\x8f\xaf\xe8\x83\xbd\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\xe9\x9b\x86\n    includeBackGround : bool or int, default None\n        \xe8\x8b\xa5colors\xe4\xb8\xbaNone \xe6\x83\x85\xe5\x86\xb5\xe4\xb8\x8b\xe6\x89\x8d\xe7\x94\x9f\xe6\x95\x88:\n            None: \xe7\x94\x9f\xe6\x88\x90\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\xe9\x9b\x86\xe6\xb2\xa1\xe6\x9c\x89\xe8\x83\x8c\xe6\x99\xaf\xe8\x89\xb2 \xe5\x8d\xb3\xe4\xb8\x8d\xe5\x8c\x85\xe5\x90\xab\xe9\xbb\x91\xe8\x89\xb2\n            1   : \xe7\xac\xac\xe4\xb8\x80\xe7\xb1\xbb\xe4\xb8\xba\xe8\x83\x8c\xe6\x99\xaf\xe5\x8d\xb3\xe9\xbb\x91\xe8\x89\xb2 \n            -1  : \xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe7\xb1\xbb\xe4\xb8\xba\xe8\x83\x8c\xe6\x99\xaf\xe5\x8d\xb3\xe9\xbb\x91\xe8\x89\xb2\n    \'\'\'\n    if colors is None:\n        colors = getDefaultColorList(label.max()+1, includeBackGround=includeBackGround)\n    colors = np.array(colors)\n    if 1.1>(colors).max()>0:\n        colors = uint8(colors)\n    rgb = np.zeros(label.shape+(3,), np.uint8)\n    for c in np.unique(label):\n        rgb[label==c] = colors[int(c)]\n    return rgb\n\ndef standImg(img):\n    \'\'\'\n    \xe4\xbb\xbb\xe4\xbd\x95\xe8\xbe\x93\xe5\x85\xa5img\xe9\x83\xbd\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba shape is (m, n, 3) dtype == Float\n    \'\'\'\n    from ..ylnp import isNumpyType\n    if img.ndim == 2:\n        img = greyToRgb(img)\n    if img.dtype == np.uint8:\n        img = img/255.\n    if isNumpyType(img, bool):\n        img = img*1.0\n    if isNumpyType(img, float):\n        return img\n    \ndef getMeanStd(imgPaths):\n    \'\'\'\n    map reduce\xe7\x9a\x84\xe6\x96\xb9\xe5\xbc\x8f \xe8\x8e\xb7\xe5\x8f\x96 \xe6\x89\x80\xe6\x9c\x89uint8\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84 mean \xe5\x92\x8c std\n    \'\'\'\n    paths = imgPaths\n    reduceDim = lambda img,axis=0:reduce(lambda x,y:np.append(x,y,axis),img)\n    logg = LogLoopTime(paths)\n    n = 0\n    squre = np.float128([0,0,0])\n    summ = np.float128([0,0,0])\n    for p in paths:\n        pixs = reduceDim(imread(p))/255.\n        n += len(pixs)\n        squre += (pixs**2).sum(0)\n        summ += pixs.sum(0)\n        logg(p)\n    mean = summ/float(n)\n    var = (squre/float(n) - mean**2)\n    std = var**.5\n    return mean, std\n\n    \nif __name__ == \'__main__\':\n\n    pass\n'"
boxx/ylimg/ylimgVideoAndGif.py,0,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\n\nfrom .ylimgTool import sk, np, sda\nfrom .ylimgTool import (show, loga, mapp, normalizing, imsave, imread,\n                       standImg, resize)\n\nfrom ..ylcompat import py2\n\ndef base64Img(arr):\n    import base64,cv2\n    cnt = cv2.imencode(\'.jpg\',arr[:,:,[2,1,0]])[1]\n    if not py2:\n        return base64.encodebytes(cnt[...,0]).decode(\'utf-8\')\n    return base64.encodestring(cnt)\n\ndef gifSave(imgs, name=\'a\', fps=None,**kargs):\n    \'\'\'\n    \xe5\x9b\xbe\xe7\x89\x87\xe5\xba\x8f\xe5\x88\x97 \xe4\xbf\x9d\xe5\xad\x98\xe4\xb8\xbaGIF\n    loop : int\n        The number of iterations. Default 0 (meaning loop indefinitely)\n    duration : {float, list}\n        The duration (in seconds) of each frame. Either specify one value\n        that is used for all frames, or one value for each frame.\n    fps : float\n        The number of frames per second. If duration is not given, the\n        duration for each frame is set to 1/fps. Default 10.\n    palettesize : int\n        The number of colors to quantize the image to. Is rounded to\n        the nearest power of two. Default 256.\n    \'\'\'\n    if name.lower()[-4:] != \'.gif\':\n        name += \'.gif\'\n    import imageio\n    if fps :\n        imageio.mimsave(name, imgs, fps=fps,**kargs)    \n    else:\n        imageio.mimsave(name, imgs,**kargs)    \n        \ndef videoToImgs(videoPath,begin=0,end=0):\n    import cv2\n    cap = cv2.VideoCapture(videoPath)  \n    if not cap.isOpened():\n        raise NameError(\'video ""%s"" can\\\'t read by open CV !\'%videoPath)\n    number = 0\n    frames = []\n    while(cap.isOpened()):  \n        ret, frame = cap.read()  \n        if number>=begin:\n            frame = frame[...,[2,1,0]]\n            frames.append(frame)\n        number+= 1\n        if number >= end:\n            break\n    return frames\n    \ndef generateBigImgForPaper(imgMa,lengh=1980,border=20,saveName=\'bigImgForPaper.png\'):\n    \'\'\'\n    \xe7\x94\x9f\xe6\x88\x90\xe7\xa7\x91\xe7\xa0\x94\xe5\x86\x99\xe4\xbd\x9c\xe7\x94\xa8\xe7\x9a\x84\xe6\xa0\xb7\xe6\x9c\xac\xe5\xaf\xb9\xe6\xaf\x94\xe5\x9b\xbe\n    imgMa: \xe5\x9b\xbe\xe7\x89\x87\xe8\xa1\x8c\xe7\xa8\x8b\xe7\x9a\x84\xe4\xba\x8c\xe7\xbb\xb4\xe5\x88\x97\xe8\xa1\xa8\n    lengh: \xe5\xa4\xa7\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84\xe5\xae\xbd\xe5\xba\xa6, \xe9\x95\xbf\xe5\xba\xa6\xe6\xa0\xb9\xe6\x8d\xaeimgMa\xe7\x9f\xa9\xe9\x98\xb5\xe7\x9a\x84\xe9\xab\x98\xe8\x87\xaa\xe5\x8a\xa8\xe7\xae\x97\xe5\x87\xba\n    border: \xe5\x9b\xbe\xe7\x89\x87\xe4\xb8\x8e\xe5\x9b\xbe\xe7\x89\x87\xe9\x97\xb4\xe7\x9a\x84\xe9\x97\xb4\xe9\x9a\x94\n    \'\'\'\n    big = None\n    for rr in imgMa:\n        rr = list(map(standImg,rr))\n        nn = len(rr)\n        a = int((lengh-nn*border)/nn)\n        m,n = rr[0].shape[:2]\n        b = int(a*m/n)\n        row = None\n        rr = [resize(r,(b,a)) for r in rr]\n        for r in rr:\n\n            if row is None:\n                row = r\n            else:\n                row = np.append(row,np.ones((b,border,3)),1)\n                row = np.append(row,r,1)\n        if big is None:\n            big = row\n        else:\n            big = np.append(big,np.ones((border,big.shape[1],3)),0)\n            big = np.append(big,row,0)\n\n    show(big)\n    if saveName:\n        imsave(saveName,big)\n    return big\n\nif __name__ == \'__main__\':\n    pass\n'"
boxx/ylml/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\ntools for Machine Learning and Image Processing\n\n@author: yanglei\n""""""\nfrom __future__ import unicode_literals\n\nfrom .ylmlTrain import GenSimg\n\nfrom .ylmlTest import (binaryDiff, classDiff, drawBoundAndBackground, \n                      confusionMatrix, f1Score,\n                      getWeightCore, smallImg, autoSegmentWholeImg,\n                      ArgList, autoFindBestEpoch, autoFindBestParams)\n\nfrom .ylmlEvalu import (Evalu, accEvalu, lplrEvalu, diceEvalu, pd)\n\nfrom .ylDete import Bbox, Canvas, cropMinAreaRect, loadCoco, saveCoco\n\nif __name__ == ""__main__"":\n    pass\n'"
boxx/ylml/ylDete.py,0,"b'# -*- coding: utf-8 -*-\n""""""\ntools for detection and bounding box\n\n@author: yl\n""""""\nimport numpy as np\n\nfrom ..ylsci import Vector, cos, sin\nfrom ..tool import sliceInt, dicto\nfrom ..ylimg import toPng, padding\n\ndef saveCoco(jsp, cocoDic, imgdf=None, anndf=None, catdf=None):\n    \'\'\'\n    save coco format annotation json according to 3 pandas.DataFrame\n    \n    Parameters\n    ----------\n    jsp : string \n        string: path for coco format annaotation json\n    cocoDic : dict\n        coco format dict\n    **df : pandas.DataFrame\n        replace the corresponding table in cocoDic \n    \'\'\'\n    from .. import df2dicts\n    cocoDic = cocoDic.copy()\n    if imgdf is not None:\n        cocoDic[\'images\'] = df2dicts(imgdf)\n    if anndf is not None:\n        cocoDic[\'annotations\'] = df2dicts(anndf)\n    if catdf is not None:\n        cocoDic[\'categories\'] = df2dicts(catdf)\n    import json\n    with open(jsp, \'w\') as f:\n        json.dump(cocoDic, f)\n    return jsp\n\ndef loadCoco(jsp):\n    \'\'\'\n    load coco format annotation json to 3 pandas.DataFrame\n    \n    >>> cocoDic, imgdf, anndf, catdf = loadCoco(jsp)\n    \n    Parameters\n    ----------\n    jsp : string or dict\n        string: path for coco format annaotation json\n        dict: a coco format json\n    Return\n    ----------\n    cocoDic, imgdf, anndf, catdf\n    \'\'\'\n    import json\n    import pandas as pd\n    if not isinstance(jsp, dict):\n        with open(jsp, \'r\') as f:\n            cocoDic = json.load(f)\n    else:\n        cocoDic = jsp\n    imgdf = pd.DataFrame(cocoDic[\'images\']).set_index(\'file_name\', False)\n    anndf = pd.DataFrame(cocoDic[\'annotations\'])\n    catdf = pd.DataFrame(cocoDic[\'categories\']).set_index(\'id\', False)\n    return cocoDic, imgdf, anndf, catdf\n\n#inttuple = mf - inttuple\ndef cropMinAreaRect(img, rect, borderValue=None):\n    import cv2\n    # rotate img\n    angle = rect[2]\n    rows,cols = img.shape[0], img.shape[1]\n    M = cv2.getRotationMatrix2D((cols/2,rows/2),angle,1)\n    img_rot = cv2.warpAffine(img,M,(cols,rows),borderValue=borderValue)\n    \n    # rotate bounding box\n#    rect0 = (rect[0], rect[1], 0.0)\n    box = cv2.boxPoints(rect)\n    pts = np.int0(cv2.transform(np.array([box]), M))[0]    \n    pts[pts < 0] = 0\n\n    # crop\n    img_crop = img_rot[pts[1][1]:pts[0][1], \n                       pts[1][0]:pts[2][0]]\n    return img_crop\n\n    if 0 == \'test\':\n        # generate image\n        img = np.zeros((1000, 1000), dtype=np.uint8)\n        img = cv2.line(img,(400,400),(511,511),1,120)\n        img = cv2.line(img,(300,300),(700,500),1,120)\n        img = cv2.line(img,(0,0),(1000,100)[::-1],2,200)\n        \n        # find contours / rectangle\n        _,contours,_ = cv2.findContours(img, 1, 1)\n        \n        # rect = ((middle_point), (w, h), angle)\n        rect = cv2.minAreaRect(contours[0])\n    #    rect = ((100.0, 499.5), (1999.0, 200.0), -90.0)\n        print(rect)\n        from boxx import timeit, show\n        # crop\n        with timeit():\n            img_croped = cropMinAreaRect(img, rect)\n        show(img)\n        show(img_croped)\n    \nclass Bbox():\n    \'\'\'\n    \n    sbox:\n        \xe5\xb0\x8f\xe6\x96\xb9\xe5\x9d\x97 ,1. \xe5\x87\x8f\xe5\xb0\x91\xe6\x97\x8b\xe8\xbd\xac\xe7\x9a\x84\xe8\xae\xa1\xe7\xae\x97\xe9\x87\x8f;2. \xe6\x96\xb9\xe4\xbe\xbf\xe8\xb4\xb4\xe5\x9b\xbe\n    urdl:\n        mean up, right, down, left\n    expandPara:\n        face bbox to head bbox, evalue by Bbox.getExpandFun(imgBox, sbox, rate=256/286.)\n    vx, vy:\n        vx: w \xe6\x96\xb9\xe5\x90\x91\xe7\x9a\x84\xe5\x90\x91\xe9\x87\x8f; vy: h \xe6\x96\xb9\xe5\x90\x91\xe7\x9a\x84\xe5\x90\x91\xe9\x87\x8f\n    ps, p0:\n        ps: bbox \xe7\x9a\x84\xe5\x9b\x9b\xe4\xb8\xaa\xe5\xae\x9a\xe7\x82\xb9, p0 \xe5\xb7\xa6\xe4\xb8\x8a\xe8\xa7\x92\xe4\xb8\xba p0 \xe9\xa1\xba\xe6\x97\xb6\xe9\x92\x88\xe4\xbe\x9d\xe6\xac\xa1\xe7\xb1\xbb\xe6\x8e\xa8\n    \n    \'\'\'\n    def __init__(self, p0, w, h, deg=None, canvas=None, expandPara=None, **kv):\n        vx, vy = Bbox.getVxVy(w, h, deg)\n        pNose = p0 + vx/2 + vy/2\n        if expandPara :\n            unit = (w + h)/2\n            delta = unit * expandPara.vRate\n            if deg:\n                delta = delta.rotation(deg)\n            p0 = delta + pNose\n            w = unit * expandPara.wRate\n            h = unit * expandPara.hRate\n            vx, vy = Bbox.getVxVy(w, h, deg)\n        ps = np.array([p0, p0+vx, p0+vx+vy, p0+vy])\n        \n        urdl = u, r, d, l = [min(ps[:, 1]), max(ps[:, 0]), max(ps[:, 1]), min(ps[:, 0])]\n        self.offsetToSbox = Vector([l, u])\n        self.boxUrdl = None\n        self.__dict__.update(locals())\n    def __str__(self, ):\n        p0, w, h, deg = self.p0, self.w, self.h, self.deg\n        return ""p0:{p0}, w:{w}, h:{h}, deg:{deg}"".format(p0=p0, w=w, h=h, deg=deg)\n    __repr__ = __str__\n    \n    @staticmethod\n    def getVxVy(w, h, deg=None):\n        if deg is None:\n            vx, vy = Vector([w, 0]), Vector([0, h])\n        else:\n            sinn, coss = sin(deg), cos(deg)\n            vx = Vector([coss*w, sinn*w])\n            vy = Vector([-sinn*h, coss*h])\n        return vx, vy\n\n#        def expand(d_urdl=[98, 44, 42, 44]):\n#            178 * 218\n\n#    @staticmethod\n    def _getUrdlForCanvas(self):\n        \'\'\'get sbox urdl in canvas\n        \'\'\'\n        if self.boxUrdl is None: \n            dx, dy = self.canvas.offset\n            u, r, d, l = self.urdl\n            self.boxUrdl = u+dy, r+dx, d+dy, l+dx\n        return self.boxUrdl\n    def cropSbox(self):\n        u, r, d, l = self._getUrdlForCanvas()\n        sboxImg = self.canvas.canvas[sliceInt[u:d, l:r]]\n        sboxImgPng = toPng(sboxImg)\n        return sboxImgPng\n    def paste(self, rimg):\n        \'\'\'\n        rimg: result img\'\'\'\n        u, r, d, l = self.u, self.r, self.d, self.l \n        if self.deg is None:\n            mask = slice(None)\n            if rimg.shape[-1] == 4:\n                rimg, mask = rimg[...,:3], rimg[...,3] > 0 \n            self.canvas.canvas[sliceInt[u:d, l:r]][mask] = rimg[mask]\n            return \n        rimg = toPng(rimg)\n        w, h = r-l, d-u\n        deg = - self.deg\n        p2 = Vector((rimg).shape)[[1,0]]\n        pad = max([w,h]-p2)/2\n        padedImg = padding(rimg, pad)\n        rect = (p2/2+pad, (w, h), deg)\n        simgPng = cropMinAreaRect(padedImg, rect, borderValue=(0,0,0,0))\n        simg, mask = simgPng[...,:3], simgPng[...,3]>simgPng[...,3].max()/2\n        u, r, d, l = self._getUrdlForCanvas()\n#        g()\n#        self.canvas.canvas[sliceInt[u:d, l:r]][mask] = simg[mask]\n        self.canvas.canvas[sliceInt[u:u+mask.shape[0], l:l+mask.shape[1]]][mask] = simg[mask]\n        return self.canvas.canvas\n    def crop(self, cropSboxFirst=False):\n        if cropSboxFirst :\n            img = self.cropSbox()\n            p0 = self.p0 - self.offsetToSbox\n        else:\n            img = self.canvas.canvas\n            p0 = self.p0\n        w, h, deg = self.w, self.h, self.deg\n        l, u = p0\n        vx, vy = self.vx, self.vy\n        if deg is None:\n            deg = 0\n        \n        pm = p0 + vx/2. + vy/2.\n        rect = (pm, (w, h), deg)\n        img_croped = cropMinAreaRect(img, rect, borderValue=(0,0,0,0))\n        return (img_croped)\n    @staticmethod\n    def test():\n        pass\n    \n\nclass Canvas():\n    \'\'\'\n    a canvas to padding bound, draw bbox, paste new patch\n    raw, img:\n        \xe5\x8e\x9f\xe5\xa7\x8b\xe5\x9b\xbe\xe5\x83\x8f\n    canvas: \n        \xe6\xa0\xb9\xe6\x8d\xae\xe6\x89\xa9\xe5\xbc\xa0\xe5\x90\x8e\xe7\x9a\x84bbox padding \xe7\x9a\x84\xe7\x94\xbb\xe5\xb8\x83\n    offset:\n        canvas \xe5\x92\x8c raw \xe7\x9a\x84\xe5\x9d\x90\xe6\xa0\x87\xe8\xbd\xac\xe6\x8d\xa2: v_canvas = v_raw + offset\n    \'\'\'\n    BboxClass = Bbox\n    def __init__(self, img, bboxList=None, expandPara=None):\n        if bboxList is None:\n            bboxList = []\n        self.raw = img\n        self.bboxs = bboxs = []\n        for bboxDic in bboxList:\n            dic = dicto(canvas=self, expandPara=expandPara,)\n            if isinstance(bboxDic, Bbox):\n                bbox = bboxDic\n                bbox.__init__(bbox.p0, bbox.w, bbox.h, deg=bbox.deg, **dic)\n            else:\n                dic.update(dict(bboxDic))\n                bbox = self.BboxClass( **dic)\n#            g()\n            bboxs.append(bbox)\n        h, w = img.shape[:2]\n        self.urdl = np.array([[0, w, h, 0]] + [b.urdl for b in bboxs])\n        self.offset = dx, dy = -Vector(self.urdl[:, [3, 0]].min(0), )\n        self.leftDown = self.urdl[:, [1,2]].max(0)\n        ww, hh = (self.offset + self.leftDown).intround()\n        self.canvas = np.zeros((hh, ww,) + img.shape[2:], img.dtype)\n        self.canvas[sliceInt[dy:dy+h, dx:dx+w]] = img\n#        self.bias = Vector([0, 0])\n        self.__dict__.update(locals())\n#        g()\n\n    def getResult(self):\n        dy, dx, h, w = self.dy, self.dx, self.h, self.w\n        return self.canvas[sliceInt[dy:dy+h, dx:dx+w]]\n    def show(self):\n        from boxx import show, pblue\n        canvas = self\n        result = canvas.getResult()\n        pblue(\'show canvas.getResult()\')\n        show-result\n        pblue(\'show Bboxs.crop(): crop from canvas.raw\')\n        show-[b.crop() for b in canvas.bboxs]\n        if canvas.bboxs and canvas.bboxs[0].deg:\n            pblue(\'show Bboxs.crop(cropSboxFirst=True):\')\n            show-[b.crop(cropSboxFirst=True) for b in canvas.bboxs]\n            pblue(\'show Bboxs.cropSbox():\')\n            show-[b.cropSbox() for b in canvas.bboxs]\n    \nif __name__ == ""__main__"":\n    pass\n    \n    \n'"
boxx/ylml/ylmlEvalu.py,0,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\nimport os\nfrom ..ylcompat import interactivePlot\nfrom ..tool.toolLog import LogLoopTime,log\nfrom ..tool import pathjoin, getFunName\nfrom ..ylsci import savenp, loadnp\nimport pandas as pd\nimport numpy as np\n\n\ndef accEvalu(re, gt):\n    \'\'\'\xe8\xaf\x84\xe4\xbc\xb0\xe4\xba\x8c\xe5\x88\x86\xe7\xb1\xbb\xe5\x88\x86\xe5\x89\xb2\xe9\x97\xae\xe9\xa2\x98 \xe8\xbf\x94\xe5\x9b\x9edict \xe5\x8c\x85\xe5\x90\xab acc \xe5\x92\x8c loss\n    \n    Parameters\n    ----------\n    re : np.ndarray\n        resoult or prob, \xe6\xa0\x87\xe7\xad\xbe\xe6\x88\x96h*w*n \xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xe7\x9f\xa9\xe9\x98\xb5\n    gt : np.ndarray of bool\n        ground Truth, \xe5\x80\xbc\xe4\xb8\xba\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x83\x8f\xe7\xb4\xa0\xe7\x9a\x84\xe7\xb1\xbb\xe5\x88\xab\n    \'\'\'\n    if re.ndim == 3:\n        re = re.argmax(2)\n    acc = (re==gt).sum()/float(gt.shape[0]*gt.shape[1])*100\n    return {\'acc\':acc,\'loss\':100-acc}\n    \n\ndef lplrEvalu(re, gt):\n    \'\'\'\xe8\xaf\x84\xe4\xbc\xb0\xe4\xba\x8c\xe5\x88\x86\xe7\xb1\xbb\xe5\x88\x86\xe5\x89\xb2\xe9\x97\xae\xe9\xa2\x98 \xe8\xbf\x94\xe5\x9b\x9edict \xe5\x8c\x85\xe5\x90\xab [\'LP\', \'LR\', \'OP\', \'OR\',\'me\']\'\'\'\n    re = re > 0\n    TPl = (re==0)*(gt==0) #(re+gt) == 0\n    FPl = (re==0)*(gt==1)\n    FNl = (re==1)*(gt==0)\n    \n\n    TPs = (re==1)*(gt==1) \n    FPs = (re==1)*(gt==0)\n    FNs = (re==0)*(gt==1)\n#    show([TPs,FPs,FNs])\n    TPl,FPl,FNl,TPs,FPs,FNs = [float(i.sum()) for i in [TPl,FPl,FNl,TPs,FPs,FNs]]\n    LP = TPl/(TPl+FPl)\n    LR = TPl/(TPl+FNl)\n    OP = (TPl+TPs)/(TPl+FPl+TPs+FPs)\n    OR = (TPl+TPs)/(TPl+FNl+TPs+FNs)\n#    return (LP*100,LR*100,OP*100,OR*100)\n    mean = np.mean([LP,LR,OP,OR])\n    return {k:100*(1-v) for k,v in zip([\'LP\', \'LR\', \'OP\', \'OR\',\'me\'],[LP,LR,OP,OR,mean])}\n\ndef diceEvalu(re,gt):\n    \'\'\' Dice coefficient \xe6\x96\xb9\xe6\xb3\x95\xe8\xaf\x84\xe4\xbc\xb0\xe4\xba\x8c\xe5\x88\x86\xe7\xb1\xbb\xe5\x88\x86\xe5\x89\xb2\xe9\x97\xae\xe9\xa2\x98 \xe8\xbf\x94\xe5\x9b\x9edict \xe5\x8c\x85\xe5\x90\xab [\'dice\', \'loss\']\n    \n    Parameters\n    ----------\n    re : np.ndarray\n        resoult or prob, \xe6\xa0\x87\xe7\xad\xbe\xe6\x88\x96h*w*n \xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xe7\x9f\xa9\xe9\x98\xb5\n    gt : np.ndarray of bool\n        ground Truth, \xe5\x80\xbc\xe4\xb8\xba\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x83\x8f\xe7\xb4\xa0\xe7\x9a\x84\xe7\xb1\xbb\xe5\x88\xab\n        \'\'\'\n    if re.ndim == 3:\n        re = re.argmax(2)\n    dice = (re*gt).sum()*2/float(re.sum()+gt.sum())*100\n    return {\'dice\':dice,\'loss\':100-dice,}\n\n\n\nclass Evalu(pd.DataFrame):\n    \'\'\'\n# \xe7\x94\xa8\xe4\xba\x8e\xe9\xaa\x8c\xe8\xaf\x81\xe7\x9a\x84\xe5\xb7\xa5\xe5\x85\xb7\xe7\xb1\xbbEvalu\n\xe7\xbb\xa7\xe6\x89\xbf\xe8\x87\xaapandas.DataFrame\xef\xbc\x8c \xe4\xbc\x9a\xe8\x87\xaa\xe5\x8a\xa8\xe4\xbf\x9d\xe5\xad\x98\xe6\xaf\x8f\xe4\xb8\xaa\xe6\xa0\xb7\xe6\x9c\xac resoult \xe5\x8f\x8a\xe5\x85\xb6\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9c\xef\xbc\x8c\xe8\x83\xbd\xe5\xaf\xb9\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9c\xe8\xbf\x9b\xe8\xa1\x8c\xe5\x88\x86\xe6\x9e\x90\n\xe5\xb9\xb6\xe8\x83\xbd\xe4\xbb\xa5DataFrame\xe7\x9a\x84\xe5\xbd\xa2\xe4\xbc\xbc\xe5\xaf\xb9\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9c\xe6\x93\x8d\xe4\xbd\x9c\xe4\xb8\x8e\xe5\x88\x86\xe6\x9e\x90\n\xe5\xb8\xb8\xe7\x94\xa8\xe7\xbc\xa9\xe5\x86\x99\xef\xbc\x9a\n    * evalu = Evalu\xe7\x9a\x84\xe5\xae\x9e\xe4\xbe\x8b\n    * re = resoult, \xe9\x9c\x80\xe8\xa6\x81\xe8\xaf\x84\xe6\xb5\x8b\xe7\x9a\x84\xe6\xa0\xb7\xe6\x9c\xac \n    * gt = GroundTruth, \xe7\x94\xa8\xe4\xba\x8e\xe8\xaf\x84\xe6\xb5\x8b\xe7\x9a\x84\xe7\x9c\x9f\xe5\x80\xbc \n    * key = \xe8\xaf\x84\xe6\xb5\x8b\xe9\xa1\xb9\xe7\x9a\x84\xe5\x90\x8d\xe7\xa7\xb0 \xe5\x8d\xb3\xe5\x88\x97\xe7\x9a\x84\xe5\x90\x8d\xe7\xa7\xb0 \xe5\xb1\x9e\xe4\xba\x8e self.columns\n    * df = pd.DataFrame \xe5\xae\x9e\xe4\xbe\x8b\n    * prob = \xe5\x88\x86\xe5\x89\xb2\xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xe7\x9f\xa9\xe9\x98\xb5 \xef\xbc\x8c\xe5\x8d\xb3shape\xe4\xb8\xba h*w*n \xe7\x9a\x84\xe7\x9f\xa9\xe9\x98\xb5(n \xe8\xa1\xa8\xe7\xa4\xba\xe7\xb1\xbb\xe5\x88\xab\xe6\x95\xb0)\n    \n\xe5\x8a\x9f\xe8\x83\xbd\n--------\n\xe8\x87\xaa\xe5\x8a\xa8log :\n    \xe5\xaf\xb9\xe6\xaf\x8f\xe4\xb8\xaa\xe6\xa0\xb7\xe6\x9c\xac \xe8\x87\xaa\xe5\x8a\xa8log\xe5\x87\xba\xe5\xbd\x93\xe5\x89\x8d\xe8\xbf\x9b\xe5\xba\xa6\xef\xbc\x8c\xe5\xbd\x93\xe5\x89\x8d\xe8\xbf\xad\xe4\xbb\xa3\xe8\x8a\xb1\xe8\xb4\xb9\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8f\x8a\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9c\n\xe4\xbf\x9d\xe5\xad\x98resoult :\n    \xe5\xb0\x86\xe7\x94\xa8\xe6\x9d\xa5\xe8\xaf\x84\xe4\xbc\xb0\xe7\x9a\x84resoult\xe4\xbf\x9d\xe5\xad\x98\xe4\xb8\xba\xe5\x8e\x8b\xe7\xbc\xa9\xe7\x9a\x84npz\xe6\xa0\xbc\xe5\xbc\x8f\n    \xe9\x80\x9a\xe8\xbf\x87 evalu.re(name) \xe6\x88\x96\xe8\x80\x85evalu[name] \xe6\x9d\xa5\xe8\xb0\x83\xe7\x94\xa8\n\xe8\xbd\xbd\xe5\x85\xa5\xe4\xb9\x8b\xe5\x89\x8d\xe7\x9a\x84\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9c :\n    \xe5\xb0\x86loadcsv=True \xe6\x88\x96\xe8\x80\x85 \xe5\xaf\xb9\xe5\xba\x94\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9ccsv\xe7\x9a\x84\xe8\xb7\xaf\xe5\xbe\x84\xe5\x8d\xb3\xe5\x8f\xaf\xe8\xbd\xbd\xe5\x85\xa5\n\xe5\x88\x86\xe6\x9e\x90\xe4\xb8\x8e\xe5\x8f\xaf\xe8\xa7\x86\xe5\x8c\x96 :\n    \xe6\x80\xbb\xe7\xbb\x93 :evalu.summary()\n    \xe5\x8f\xaf\xe8\xa7\x86\xe5\x8c\x96\xe8\xaf\x84\xe4\xbc\xb0\xe9\xa1\xb9\xe7\x9a\x84\xe5\x88\x86\xe5\xb8\x83 :evalu.distr(key)\n\xe4\xb8\x80\xe9\x94\xae\xe5\x88\xa0\xe9\x99\xa4\xe9\xaa\x8c\xe8\xaf\x81\xe4\xba\xa7\xe7\x94\x9f\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe6\x96\x87\xe4\xbb\xb6 :\n    evalu.removeFiles()\n\xe7\xbb\xa7\xe6\x89\xbf pandas.DataFrame \xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe6\x93\x8d\xe4\xbd\x9c :\n    \xe4\xbb\xa5df\xe5\xbd\xa2\xe4\xbc\xbc \xe5\x88\x86\xe6\x9e\x90evalu\xe5\x90\x8e\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c \n    ps:pandas\xe5\xbf\xab\xe9\x80\x9f\xe5\x85\xa5\xe9\x97\xa8 http://wiki.jikexueyuan.com/project/start-learning-python/311.html\n\nExamples\n--------\n>>> names = glob(""/home/[to val path]/*.jpg"")\ne = Evalu(binaryEvalu,\n          evaluName=\'try-example\',\n          valNames=names,\n          logFormat=\'acc:{acc:.4f}, loss:{loss:.4f}\',\n          sortkey=\'acc\'\n          )\nfor name in names:\n    [get re,gt code]\n    e.evalu(re,gt,name)\ne.summary()\ne.distr()\n    \'\'\'\n    def __init__(self,evaluFun,\n                 evaluName=\'null\',\n                 valNames=None,\n                 logFormat=None,\n                 sortkey=None,\n                 loadcsv=False,\n                 saveResoult = False,\n                 loged=True,\n                 savepath=\'./val/\',\n                 ):\n        \'\'\'\nParameters\n----------\nevaluFun : function\n    \xe7\x94\xa8\xe4\xba\x8e\xe8\xaf\x84\xe4\xbc\xb0resoult\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8c\xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0\xe9\xa1\xbb\xe6\x8e\xa5\xe5\x8f\x97\xe4\xb8\xa4\xe4\xb8\xaa\xe5\x8f\x82\xe6\x95\xb0 (re,gt),\xe5\xb9\xb6\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe4\xb8\xaadict\n    dict \xe5\x8c\x85\xe5\x90\xab\xe6\xaf\x8f\xe4\xb8\x80\xe4\xb8\xaa\xe8\xaf\x84\xe4\xbc\xb0\xe9\xa1\xb9\xe7\x9a\x84\xe5\x80\xbc\n    \xe4\xbe\x8b\xe5\xa6\x82 evaluFun(re,gt) => return {\'key1\':value1,\'key2\':value2}\nevaluName : str, default \'null\'\n    \xe5\xae\x9e\xe4\xbe\x8b\xe7\x9a\x84\xe5\x90\x8d\xe7\xa7\xb0\nvalNames : list or tuple, default None\n    \xe9\xaa\x8c\xe8\xaf\x81\xe9\x9b\x86\xe6\x89\x80\xe6\x9c\x89\xe6\xa0\xb7\xe6\x9c\xac\xe7\x9a\x84\xe5\x90\x8d\xe5\xad\x97\nlogFormat : str, default None\n    fromat\xe6\xa0\xbc\xe5\xbc\x8f \xe7\x94\xa8\xe4\xba\x8e\xe8\xa7\x84\xe8\x8c\x83\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9c\xe7\x9a\x84\xe6\x98\xbe\xe7\xa4\xba\xe6\x95\x88\xe6\x9e\x9c  \n    \xe4\xbc\x9a\xe6\x89\xa7\xe8\xa1\x8c print logFormat.format(**evaluFun(re,gt))\n    \xe5\xa6\x82: \'key1 is {key1:.2f}, key2 is {key2:.2f},\'\n    \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba\xe7\x9b\xb4\xe6\x8e\xa5\xe6\x89\x93\xe5\x8d\xb0 evaluFun(re,gt)\nsortkey : str, default None\n    \xe7\x94\xa8\xe4\xba\x8e\xe6\x8e\x92\xe5\xba\x8f\xe6\x97\xb6\xe5\x80\x99\xe7\x9a\x84key \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbadf.columns[-1]\nloadcsv : bool or str, default False\n    \xe8\xbd\xbd\xe5\x85\xa5\xe5\xb7\xb2\xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84csv \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\x8d\xe8\xbd\xbd\xe5\x85\xa5\xef\xbc\x8c\xe4\xb8\xbaTrue\xe6\x97\xb6\xe5\x80\x99\xe5\x88\x99\xe8\xbd\xbd\xe5\x85\xa5\xef\xbc\x8c\n    \xe4\xb8\xbastr\xe6\x97\xb6\xe5\x80\x99\xe5\x88\x99\xe8\xbd\xbd\xe5\x85\xa5str\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84path\xe7\x9a\x84csv\nsaveResoult : bool or function, default False\n    \xe6\x98\xaf\xe5\x90\xa6\xe4\xbf\x9d\xe5\xad\x98resoult \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbaFalse ,True  \xe5\x88\x99\xe4\xbf\x9d\xe5\xad\x98 re\n    \xe8\x8b\xa5\xe4\xb8\xbafunction \xe5\x88\x99\xe4\xbf\x9d\xe5\xad\x98 saveResoult(re) \xe4\xb8\xba .npz\xe6\xa0\xbc\xe5\xbc\x8f\nloged : bool, default True\n    \xe6\x98\xaf\xe5\x90\xa6\xe6\xaf\x8f\xe6\xac\xa1\xe8\xaf\x84\xe4\xbc\xb0\xe9\x83\xbd\xe6\x89\x93\xe5\x8d\xb0\xe5\x87\xba\xe7\xbb\x93\xe6\x9e\x9c \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba\xe6\x89\x93\xe5\x8d\xb0\nsavepath : str, default \'./val/\'\n    \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe8\xb7\xaf\xe5\xbe\x84 \xe8\x8b\xa5loadcsv \xe4\xb8\xbapath \xe5\x88\x99\xe4\xb8\xba dirname(loadcsv)\n\nExamples\n--------\ne = Evalu(accEvalu,\n          evaluName=\'binary segment evalu\',\n          valNames=names,\n          logFormat=\'acc:{acc:.4f}, loss:{loss:.4f}\',\n          sortkey=\'loss\'\n          )\n        \'\'\'\n        pd.DataFrame.__init__(self,)\n        self._inited = False\n        self.evaluName = evaluName\n        self.evaluFun = evaluFun\n        self.logFormat = logFormat\n        self.logLoop = LogLoopTime(valNames,loged=False)\n        self.n = -1 if valNames is None else len(valNames)\n        self.sortkey = sortkey\n        self.loged = loged\n        self.saveResoult = saveResoult\n        self.__isTuple = False\n        \n        if isinstance(loadcsv,str):\n            self.evaluDir = os.path.dirname(loadcsv)\n        else:\n            self.evaluDir = os.path.join(savepath,\'Evalu-%s\'%evaluName)\n        self._defaultCsvPath = pathjoin(self.evaluDir,self.evaluName+\'.csv\')\n        if loadcsv :\n            if isinstance(loadcsv,str):\n                self._defaultCsvPath = loadcsv \n            self._loaddf()\n    def _initdf(self,name,dic):\n        self._inited = True\n        dic[\'name\'] = name\n        pd.DataFrame.__init__(self,[pd.Series(dic)])\n        self.set_index(\'name\',inplace=True)\n        if self.sortkey is None:\n            self.sortkey = self.columns[-1]\n    def _loaddf(self):\n        self._inited = True\n        pd.DataFrame.__init__(self,pd.read_csv(self._defaultCsvPath,index_col=\'name\'))\n        if self.sortkey is None:\n            self.sortkey = self.columns[-1]\n        \n    def __makedirs(self):\n        path = pathjoin(self.evaluDir,\'npzs\')\n        if not os.path.isdir(path):\n            os.makedirs(path, exist_ok=True)\n    def _log(self,s):\n        if self.loged:\n            log(\'%s\'%s)\n    def evalu(self, re, gt, name=None):\n        \'\'\'\xe4\xbd\xbf\xe7\x94\xa8 self.evaluFun \xe8\xaf\x84\xe4\xbc\xb0 resoult GrountdTruth\n        \n        Parameters\n        ----------\n        re : as parameters of self.evaluFun\n            \xe9\x9c\x80\xe8\xa6\x81\xe8\xaf\x84\xe6\xb5\x8b\xe7\x9a\x84resoult\n        gt : as parameters of self.evaluFun\n            \xe7\x94\xa8\xe4\xba\x8e\xe8\xaf\x84\xe6\xb5\x8b\xe7\x9a\x84\xe7\x9c\x9f\xe5\x80\xbc GroundTruth\n        name : str, default None\n            \xe8\xae\xb0\xe5\xbd\x95\xe6\xad\xa4\xe6\xac\xa1\xe8\xaf\x84\xe4\xbc\xb0\xe6\xa0\xb7\xe6\x9c\xac\xe7\x9a\x84\xe5\x90\x8d\xe7\xa7\xb0 \xe4\xb8\xba\xe7\xa9\xba\xe5\x88\x99\xe4\xb8\x8d\xe8\xae\xb0\xe5\xbd\x95    \n        \'\'\'\n        dic = self.evaluFun(re,gt)\n        s = self._formatDic(dic)\n        if name is None:\n            self._log(s)\n            return dic\n        if not self._inited:\n            self._initdf(name,dic)\n        else:\n            self.loc[name] = dic\n        if self.logLoop:\n            loopLog = self.logLoop(name)\n            s = (loopLog+\' Evalu:\'+s)\n        self._log(s)\n        if len(self)==self.n and self.index[-1] == name and (\n                self.loged or self.saveResoult):\n            self.savecsv()\n        if self.saveResoult:\n            self._savere(name,re)\n        return dic\n    def savecsv(self,):\n        self.__makedirs()\n        self.to_csv(self._defaultCsvPath)\n    def _savere(self,name,re):\n        self.__makedirs()\n        npname = pathjoin(self.evaluDir,\'npzs\',name)\n        if \'__call__\' in dir(self.saveResoult) :\n            savenp(npname,self.saveResoult(re))\n        else:\n            if re.ndim == 3:\n                re = np.uint8(re.argmax(2))\n            savenp(npname,re)\n    def re(self,name=-1):\n        \'\'\'return np.array, \xe8\xbf\x94\xe5\x9b\x9e\xe8\x87\xaa\xe5\x8a\xa8\xe4\xbf\x9d\xe5\xad\x98\xe4\xb8\x8b\xe6\x9d\xa5\xe7\x9a\x84np.array \xe6\xa0\xb7\xe6\x9c\xac\n        \n        Parameters\n        ----------\n        name : str or int, default -1\n            \xe5\xbd\x93\xe4\xb8\xbaint \xe6\x97\xb6 name=df.index[int]    \n        \'\'\'\n        if isinstance(name,int):\n            name = self.index[name]\n        npname = pathjoin(self.evaluDir,\'npzs\',name)\n        re = loadnp(npname)\n        return re\n    def __getitem__(self,name):\n        \'\'\'\xe5\x90\x8c Evalu.re\n        return np.array, \xe8\xbf\x94\xe5\x9b\x9e\xe8\x87\xaa\xe5\x8a\xa8\xe4\xbf\x9d\xe5\xad\x98\xe4\xb8\x8b\xe6\x9d\xa5\xe7\x9a\x84np.array \xe6\xa0\xb7\xe6\x9c\xac\n        \n        Parameters\n        ----------\n        name : str or int, default -1\n            \xe5\xbd\x93\xe4\xb8\xbaint \xe6\x97\xb6 name=self.index[int]  \n        \'\'\'\n        if name in self.columns:\n            return pd.DataFrame.__getitem__(self,name)\n        return  self.re(name)\n    \n    def _sorted(self,key,ascending=True):\n        if isinstance(key,int) and key not in self.columns:\n            key = self.columns[key]\n        if key is None:\n            key = self.sortkey\n        return self.sort_values(key,ascending=ascending)\n    @property\n    def highh(self):\n        return self.high()\n    def high(self,n=10,key=None):\n        \'\'\'return df, \xe8\xaf\x84\xe4\xbc\xb0\xe9\xa1\xb9key \xe6\x9c\x80\xe9\xab\x98\xe7\x9a\x84n\xe4\xb8\xaa\xe6\xa0\xb7\xe6\x9c\xac\xe7\xbb\x84\xe6\x88\x90\xe7\x9a\x84df\n        \n        Parameters\n        ----------\n        n : int, default 10\n            \xe8\xbf\x94\xe5\x9b\x9e\xe7\x9a\x84\xe6\xa0\xb7\xe6\x9c\xac\xe6\x95\xb0\xe7\x9b\xae   \n        key: key in self.columns, default self.sortkey\n            \xe7\x94\xa8\xe4\xba\x8e\xe8\xae\xa1\xe7\xae\x97\xe6\x8e\x92\xe5\x90\x8d\xe7\x9a\x84 key\n        \'\'\'\n        df = self._sorted(key,ascending=False)\n        return df.head(n)\n    @property\n    def loww(self):\n        return self.low()\n    def low(self,n=10,key=None):\n        \'\'\'\xe4\xb8\x8eevalu.high \xe7\x9b\xb8\xe5\x8f\x8d \xe5\x8f\x82\xe8\xa7\x81evalu.high\n        \'\'\'\n        df = self._sorted(key)\n        return df.head(n)\n    @interactivePlot\n    def distr(self, key=None):\n        \'\'\'\xe5\x88\x86\xe6\x9e\x90key \xe7\x9a\x84\xe5\x88\x86\xe5\xb8\x83\xef\xbc\x8cdescribe + \xe5\x88\x86\xe5\xb8\x83\xe5\x9b\xbe\n        \n        Parameters\n        ----------\n        key : str or int, default self.sortkey\n            \xe5\xbd\x93\xe4\xb8\xbaint \xe6\x97\xb6 key=df.columns[int]\n        \'\'\'\n        import matplotlib.pyplot as plt\n        if isinstance(key,int) and key not in self.columns:\n            key = self.columns[key]\n        key = self.sortkey if key is None else key \n        df = self._sorted(key,False)\n        print((df[key].describe()))\n        df[\'_index_\'] = list(range(1,len(df)+1)) \n        df[\'__mean\'] = mean = df[key].mean()\n        df.set_index(\'_index_\',inplace=True)\n        df[\'__mean\'].plot(style=\'orange\')\n        df[key].plot.bar(title=\'mean = %s\'%mean)\n        plt.show()\n    \n    def _formatDic(self,dic):\n        formatt = self.logFormat\n        if formatt:\n            s=(formatt.format(**dic))\n        else:\n            s=(\', \'.join([\'%s: %s\'%(k,v) for k,v in list(dic.items())]))\n        return s\n    def __topAndLowStr(self,n=10):\n        top = self.high(n)\n        low = self.low(n)\n        tops = str(top[self.sortkey]).split(\'\\n\')\n        title , tops = tops[-1], tops[1:-1]\n        lows = str(low[self.sortkey]).split(\'\\n\')[1:-1]\n        strn = len(lows[0])+1\n        second = (\'high %d\'%n+strn*\' \')[:strn]+\'| \'+(\'low %d\'%n)\n        body=\'\\n\'.join([t+\' | \'+l for t,l in zip(tops,lows)])\n        s= \'\'\'evaluName: %s, sortkey%s\n%s\n%s\n\'\'\'%(self.evaluName, title[4:], second, body)\n        return (s)\n    def __str__(self,n=3):\n        funName = getFunName(self.evaluFun)\n        describe = self.describe()\n        s = \'\'\'Evalu name       : %s\ncache resoult dir: %s\nsort key         : %s\nevalu function  : %s\nlogFormat        : %s\n        \'\'\' %(self.evaluName,self.evaluDir,self.sortkey,funName,self.logFormat)\n        \n        return s+\'\\n\'+self.__topAndLowStr(n)+str(describe)\n    __repr__ = pd.DataFrame.__str__\n    def summary(self,n=10):\n        \'\'\'various summary \n        n:\xe5\x90\x8c\xe6\x97\xb6\xe6\x98\xbe\xe7\xa4\xbahigh\xe5\x92\x8clow\xe7\x9a\x84\xe6\x95\xb0\xe9\x87\x8f\'\'\'\n        print(self.__str__(n))\n        \n    class Series(pd.Series):\n        \'\'\'\xe6\x94\xb9\xe9\x80\xa0\xe4\xba\x86 __str__ \xe7\x9a\x84 pd.Series\'\'\'\n        def __init__(self,series,strr):\n            pd.Series.__init__(self,series)\n            self.strr = strr\n        def __str__(self):\n            return self.strr\n        __repr__ = __str__\n    def __call__(self,name=-1,sortkey=None):\n        \'\'\'return pd.Series, \xe5\xaf\xb9\xe5\xba\x94name\xe7\x9a\x84\xe8\xaf\x84\xe4\xbc\xb0\xe7\xbb\x93\xe6\x9e\x9c\n        \n        Parameters\n        ----------\n        name : str or int, default -1\n            \xe5\xbd\x93\xe4\xb8\xbaint \xe6\x97\xb6 name=df.index[int]    \n        sortkey: key in self.columns, default self.sortkey\n            \xe7\x94\xa8\xe4\xba\x8e\xe8\xae\xa1\xe7\xae\x97\xe6\x8e\x92\xe5\x90\x8d\xe7\x9a\x84 key\n        \'\'\'\n        if isinstance(name,int):\n            name = self.index[name]\n        key = sortkey or self.sortkey\n        row = self.loc[name]\n        small,n = (self[key]<=row[key]).sum(),float(len(self))\n#        row[\'high_in_[%s]\'%key] = \'%d/%d (%.2f%%)\'%(small,n,small/n*100)\n        dic = dict(row)\n        s = ""Name: %s  High in [\'%s\']:""%(name,key) + \'%d/%d(%.2f%%)  Evalu:\'%(small,n,small/n*100)\n        s += self._formatDic(dic)\n        return Evalu.Series(row,s)\n    @property\n    def df(self):\n        return pd.DataFrame(self)\n    \n    def removeFiles(self):\n        \'\'\'\xe5\x88\xa0\xe9\x99\xa4\xe4\xbd\xbf\xe7\x94\xa8\xe6\xad\xa4Evalu\xe4\xba\xa7\xe7\x94\x9f\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6 \xe5\x8d\xb3\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xb9 self.evaluDir\'\'\'\n        import shutil\n        shutil.rmtree(self.evaluDir)\nif __name__ == \'__main__\':\n    e = Evalu(int)\n    import pandas as pd\n    df = pd.DataFrame({\n                       0:list(range(5)),\n                       1:list(range(10,15)),\n                       \'a\':list(""abcde""),\n                       })\n    df.set_index(0,inplace=True)\n\n\n    pass\n'"
boxx/ylml/ylmlTest.py,0,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\nimport numpy as np\nimport pandas as pd\n\nfrom ..tool import dynamicWraps, findints, glob,dicto\nfrom ..ylsci import isNumpyType\nfrom ..ylimg import (mapp, labelToColor)\n\nfrom .ylmlEvalu import Evalu\nimport imp\n\ndef binaryDiff(re,gt,size=0.5,lines=50,bound=False):\n    \'\'\'\n    \xe5\xaf\xb9\xe4\xba\x8c\xe5\x88\x86\xe7\xb1\xbb\xe9\x97\xae\xe9\xa2\x98\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c\xe4\xb8\x8a\xe8\x89\xb2\n    False Positive: red mgrid\n    False Negative: blue mgrid\n    lines: \xe7\xbd\x91\xe6\xa0\xbc\xe7\xba\xbf\xe6\x9d\xa1\xe7\x9a\x84\xe9\x97\xb4\xe8\xb7\x9d\n    size:\xe7\xba\xbf\xe6\x9d\xa1\xe5\xa4\x9a\xe7\xb2\x97 \xe5\x8d\xb3\xe7\xba\xbf\xe6\x9d\xa1\xe6\x98\xaf\xe9\x97\xb4\xe8\xb7\x9d\xe7\x9a\x84\xe5\xa4\x9a\xe5\xb0\x91\xe5\x80\x8d\n    bound:\xe6\x98\xaf\xe5\x90\xa6\xe7\x94\xbb\xe5\x87\xba\xe8\xbe\xb9\xe7\xbc\x98\n    \'\'\'\n    re, gt = re > 0.5, gt > 0.5\n    rem = np.zeros(gt.shape,int)\n    tp = (re) * (gt)\n#    tn = (~re) * (~gt)\n    fp = re*(~gt)\n    fn = (~re)*gt\n#    show(tp,tn,fp,fn)\n    rem[tp] = 1\n    rem[fp] = 2\n    rem[fn] = 3\n    c=[[0]*3,[1]*3,[1,0,0],[.1,.1,.6]]\n    diff = classDiff(rem,re,c,size=size,lines=lines,bound=bound)\n    return diff\n\ndef drawBoundAndBackground(img,mask,bg=None,replace=False,lines=50,\n                           size=0.2,bound=True,boundmode=\'thick\'):\n    \'\'\'\n    \xe7\xbb\x99\xe5\x87\xbamask \xe5\xb0\x86\xe7\xbb\x99mask\xe5\x8c\xba\xe5\x9f\x9f\xe5\xa1\xab\xe5\x85\x85\xe8\x83\x8c\xe6\x99\xaf\xe8\x89\xb2bg\xe7\x9a\x84\xe7\xba\xbf\xe6\x9d\xa1 \xe5\xb9\xb6\xe5\x8a\xa0\xe4\xb8\x8a\xe9\xbb\x91\xe7\x99\xbd\xe8\xbe\xb9\xe6\xa1\x86\n    mask: \xe6\x89\x80\xe8\xa6\x81\xe6\xa0\x87\xe6\xb3\xa8\xe5\x8c\xba\xe5\x9f\x9f\n    bg : \xe8\x83\x8c\xe6\x99\xaf\xe5\xa1\xab\xe5\x85\x85 \xe5\x8f\xaf\xe4\xbb\xa5\xe4\xb8\xba\xe9\xa2\x9c\xe8\x89\xb2|\xe5\x9b\xbe\xe7\x89\x87 \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba\xe7\xba\xa2\xe8\x89\xb2\n    replace : \xe6\x98\xaf\xe5\x90\xa6\xe5\x9c\xa8\xe5\x8e\x9f\xe5\x9b\xbe\xe4\xb8\x8a\xe6\x93\x8d\xe4\xbd\x9c\n    lines: \xe7\xba\xbf\xe6\x9d\xa1\xe7\x9a\x84\xe9\x97\xb4\xe8\xb7\x9d\n    size:\xe7\xba\xbf\xe6\x9d\xa1\xe5\xa4\x9a\xe7\xb2\x97 \xe5\x8d\xb3\xe7\xba\xbf\xe6\x9d\xa1\xe6\x98\xaf\xe9\x97\xb4\xe8\xb7\x9d\xe7\x9a\x84\xe5\xa4\x9a\xe5\xb0\x91\xe5\x80\x8d\n    bound:\xe6\x98\xaf\xe5\x90\xa6\xe7\x94\xbb\xe5\x87\xba\xe8\xbe\xb9\xe7\xbc\x98\n    boundmode: thick \xe7\xb2\x97\xe6\xad\xa3\xe5\xa5\xbd\xe5\x9c\xa8\xe8\xbe\xb9\xe7\x95\x8c \'inner\'\xe5\x8f\xaa\xe5\x9c\xa8\xe5\x89\x8d\xe6\x99\xaf\xe9\x87\x8c\xe9\x9d\xa2 \xe4\xbd\x86\xe6\x98\xaf\xe8\xbe\x83\xe7\xbb\x86\n    \'\'\'\n    assert mask.ndim ==2, \'mask \xe5\xbf\x85\xe9\xa1\xbb\xe4\xb8\xba\xe5\xb8\x83\xe5\xb0\x94\xe5\x80\xbc\'\n    if not mask.any():\n        return img\n    isint = isNumpyType(img,int)\n    if not replace:\n        img = img.copy()\n    if bg is None:\n        bg =  [max(255,img.max()),128,0]if isint else [1.,.5,0]\n    white = max(255,img.max()) if isint else 1.\n    m,n=img.shape[:2]\n    i,j = np.mgrid[:m,:n]\n    \n    step = (m+n)//2//lines\n    a = int(step*(1-size))\n    drawInd = ~np.where(((i%step<a)& (j%step<a)),True,False)\n#    from tool import g\n#    g.x = mask,drawInd, bg,img\n    if isinstance(bg,np.ndarray) and bg.ndim >=2:\n        img[mask*drawInd] = bg[mask*drawInd]\n    else:\n        img[mask*drawInd] = bg\n    if bound:\n        from skimage.segmentation import find_boundaries\n        boundind = find_boundaries(mask, mode=boundmode,background=True)\n        boundBg = np.where((i+j)%10<5,white,0)\n        img[boundind] = boundBg[boundind][...,None]\n    return (img)\n   \ndef classDiff(rem,gtm,colors=None,size=.15,reMod=False,lines=50,bound=True):\n    \'\'\'\n    \xe5\xaf\xb9\xe5\xa4\x9a\xe5\x88\x86\xe7\xb1\xbb\xe9\x97\xae\xe9\xa2\x98\xe7\x9a\x84gt\xe8\xbf\x9b\xe8\xa1\x8c\xe4\xb8\x8a\xe8\x89\xb2\n    \xe5\xaf\xb9\xe4\xba\x8e\xe9\x94\x99\xe8\xaf\xaf\xe5\x88\x86\xe7\xb1\xbb \xe5\x8a\xa0\xe7\xbd\x91\xe6\xa0\xbc(\xe7\xbd\x91\xe6\xa0\xbc\xe9\xa2\x9c\xe8\x89\xb2\xe6\x98\xafresoult\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2) \xe5\x8a\xa0\xe6\x9c\x89\xe8\xbe\xb9\xe6\xa1\x86\n    rem :\xe5\xa4\x9a\xe5\x88\x86\xe7\xb1\xbb\xe7\xbb\x93\xe6\x9e\x9c \xe4\xba\x8c\xe7\xbb\xb4\xe7\x9f\xa9\xe9\x98\xb5\n    gtm :GroundTruth\n    colors:\xe6\xa0\x87\xe7\xad\xbe\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\n    size:\xe7\xbd\x91\xe6\xa0\xbc\xe6\x89\x80\xe5\x8d\xa0\xe7\x94\xa8\xe7\x9a\x84\xe6\xaf\x94\xe9\x87\x8d\n    reMod:\xe5\xaf\xb9resoult\xe4\xb8\x8a\xe8\x89\xb2, \xe5\xaf\xb9\xe4\xba\x8e\xe9\x94\x99\xe8\xaf\xaf\xe5\x88\x86\xe7\xb1\xbb \xe7\xbd\x91\xe6\xa0\xbc\xe9\xa2\x9c\xe8\x89\xb2\xe6\x98\xaf GroundTruth\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\n    lines:\xe7\xbd\x91\xe6\xa0\xbc\xe7\xba\xbf\xe7\x9a\x84\xe6\x95\xb0\xe9\x87\x8f\n    bound:\xe6\x98\xaf\xe5\x90\xa6\xe7\x94\xbb\xe5\x87\xba\xe8\xbe\xb9\xe7\xbc\x98\n    \'\'\'\n    assert rem.ndim==2 and gtm.ndim==2,""rem,gtm \'s dim must be 2""\n    rgb = labelToColor(rem if reMod else gtm, colors) \n    clas = list(range(len(colors)))\n    for c,color in enumerate((colors)): #c mean iter every Class\n        for oc in clas: # oc means OtherClass\n            if oc==c:\n                continue\n            mask = (rem==c)*(gtm==oc)\n            if mask.any():\n                bg = colors[oc if reMod else c]\n#                print bg,c,oc\n                drawBoundAndBackground(rgb,mask,bg,bound=bound,\n                                       size=size,replace=True,lines=lines)\n    return rgb\n\ndef confusionMatrix(re,gt,classn=None):\n    \'\'\'\xe6\xb1\x82\xe6\xb7\xb7\xe6\xb7\x86\xe7\x9f\xa9\xe9\x98\xb5\xef\xbc\x88confusion matrix\xef\xbc\x89\n    \n    Parameters\n    ----------\n    re : np.ndarray\n        resoult , \xe9\xa2\x84\xe6\xb5\x8b\xe7\x9a\x84\xe6\xa0\x87\xe7\xad\xbe\n    gt : np.ndarray \n        ground Truth, \xe5\x80\xbc\xe4\xb8\xba\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x83\x8f\xe7\xb4\xa0\xe7\x9a\x84\xe7\xb1\xbb\xe5\x88\xab\n    classn : int,  default None\n        \xe6\x80\xbb\xe7\xb1\xbb\xe5\x88\xab\xe6\x95\xb0\xe7\x9b\xae \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba max(re.max(), gt.max())+1\n    \'\'\'\n    if classn is None:\n        classn = max(re.max(), gt.max())+1\n    ma = np.zeros((classn,classn),int)\n    for ind in range(classn):\n        row = np.histogram(re[(gt==ind)],classn,range=(0,classn))[0]\n        ma[ind][:] = row[:]\n    return ma\n\n\n\ndef f1Score(re,gt,classn):\n    \'\'\'\xe6\xb1\x82\xe5\x90\x84\xe4\xb8\xaa\xe7\xb1\xbb\xe5\x88\xab\xe7\x9a\x84f1Score \n    \xe5\x85\x88\xe6\xb1\x82\xe6\xb7\xb7\xe6\xb7\x86\xe7\x9f\xa9\xe9\x98\xb5\xef\xbc\x88confusion matrix\xef\xbc\x89\n    \n    Parameters\n    ----------\n    re : np.ndarray\n        resoult or prob, \xe9\xa2\x84\xe6\xb5\x8b\xe7\x9a\x84\xe6\xa0\x87\xe7\xad\xbe\xe6\x88\x96h*w*n \xe7\x9a\x84\xe6\xa6\x82\xe7\x8e\x87\xe7\x9f\xa9\xe9\x98\xb5\n    gt : np.ndarray \n        ground Truth, \xe5\x80\xbc\xe4\xb8\xba\xe6\xaf\x8f\xe4\xb8\xaa\xe5\x83\x8f\xe7\xb4\xa0\xe7\x9a\x84\xe7\xb1\xbb\xe5\x88\xab\n    classn : int\n        \xe6\x80\xbb\xe7\xb1\xbb\xe5\x88\xab\xe6\x95\xb0\xe7\x9b\xae\n    \'\'\'\n    if re.ndim == 3:\n        re = re.argmax(2)\n    cma = confusionMatrix(re,gt,classn)\n    ma = np.float64(cma)\n    tp = ma[list(range(classn)),list(range(classn))]\n    fp = ma.sum(0)-tp\n    fn = ma.sum(1)-tp\n    precision = tp/(tp+fp)\n    recall = tp/(tp+fn)\n    f1 = 2*precision*recall/(precision+recall)\n    return f1\n\n@dynamicWraps\ndef getWeightCore(hh,ww=None,mappFun=None,seta=0.5):\n    \'\'\'\n    \xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe4\xb8\xaa\xe6\x9d\x83\xe9\x87\x8d\xe4\xba\x8c\xe7\xbb\xb4\xe7\x9f\xa9\xe9\x98\xb5 \xef\xbc\x8c\xe9\xbb\x98\xe8\xae\xa4\xe6\x98\xafseta=0.5\xe7\x9a\x84\xe4\xba\x8c\xe7\xbb\xb4\xe9\xab\x98\xe6\x96\xaf\xe5\x88\x86\xe5\xb8\x83\n    mappFun: \xe5\xaf\xb9\xe7\x9f\xa9\xe9\x98\xb5\xe6\xaf\x8f\xe4\xb8\xaa\xe7\x82\xb9\xe6\x89\xa7\xe8\xa1\x8cmappFun(i,j) \xe8\xbf\x94\xe5\x9b\x9e\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c\xe6\x9e\x84\xe6\x88\x90\xe4\xba\x8c\xe7\xbb\xb4\xe7\x9f\xa9\xe9\x98\xb5\n    \'\'\'\n    if ww is None:\n        ww = hh\n    if mappFun is None:\n#        ijToCenter = lambda x,i,j:(((i/float(hh)-1/2.)**2+(j/float(ww)-1/2.)**2))\n#        wc = weightCore = mapp(ijToCenter,weightCore,need_i_j=True)\n        i,j = np.mgrid[:hh,:ww]\n        wc = (((i/float(hh)-1/2.)**2+(j/float(ww)-1/2.)**2))\n        wc = 1./(2*np.pi*seta**2)*np.e**(-wc/(2*seta**2))\n        wc = wc/wc.max()\n        #show(normalizing(img[:hh,:ww]*wc[...,None]),img[:hh,:ww])\n#        polt3dSurface(wc)\n        return wc\n    weightCore = np.zeros((hh,ww))\n    return mapp(lambda x,i,j:mappFun(i,j),weightCore,need_i_j=True)\n\ndef smallImg(img,simgShape, step=None,f=None):\n    \'\'\'\n    \xe5\xb0\x86\xe5\xa4\xa7\xe5\x9b\xbe\xe5\x88\x87\xe5\x89\xb2\xe6\x88\x90\xe5\x9b\xba\xe5\xae\x9a\xe5\xa4\xa7\xe5\xb0\x8f\xe7\x9a\x84\xe5\xb0\x8f\xe5\x9b\xbe,\xe4\xbd\xbf\xe4\xba\xa7\xe7\x94\x9f\xe7\x9a\x84\xe5\xb0\x8f\xe5\x9b\xbe\xe8\x83\xbd\xe8\xa6\x86\xe7\x9b\x96\xe5\xa4\xa7\xe5\x9b\xbe\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe9\x9d\xa2\xe7\xa7\xaf\n\n    Parameters\n    ----------\n    simgShape : int or tuple or float\n        \xe5\xb0\x8f\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84shape,\xe4\xb8\xbaint\xe6\x97\xb6\xe5\x80\x99 \xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba(simgShape, simgShape)\n        \xe4\xb8\xbafloat\xe6\x97\xb6\xe5\x80\x99 \xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba (int(h*simgShape),int(w*simgShape))\n    step : float or int or tuple(steph,stepw),defalut None\n        h\xe5\x92\x8cw\xe6\x96\xb9\xe5\x90\x91\xe4\xb8\x8a \xe7\x9b\xb8\xe9\x82\xbb\xe5\x88\x87\xe5\x89\xb2\xe7\x9a\x84\xe6\xad\xa5\xe9\x95\xbf, \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbasimgShape \n        float : (int(step*simgShape[0]),int(step*simgShape[1]))\n        int : (step, step)\n    fun : funcatin, default None\n        \xe8\x8b\xa5\xe6\x9c\x89fun \xe5\x88\x99\xe6\x89\xa7\xe8\xa1\x8cfun(simg,i,j)\n        \xe5\x85\xb6\xe4\xb8\xad\xef\xbc\x9a\n            simg:\xe8\xa2\xab\xe5\x88\x87\xe5\x89\xb2\xe7\x9a\x84\xe5\xb0\x8f\xe5\x9b\xbe\xe7\x89\x87\n            i: simg\xe6\x89\x80\xe5\x9c\xa8img\xe7\x9a\x84row\n            j: simg\xe6\x89\x80\xe5\x9c\xa8img\xe7\x9a\x84col\n    \n    Returns\n    -------\n    simgs : list of ndarray\n        \xe5\x88\x87\xe5\x89\xb2\xe5\x87\xba\xe6\x9d\xa5\xe7\x9a\x84\xe5\xb0\x8f\xe5\x9b\xbe\xe7\x9a\x84list\n    \'\'\'\n    h,w = img.shape[:2]\n    if isinstance(simgShape,float):\n        hh,ww = (int(h*simgShape),int(w*simgShape))\n    if isinstance(simgShape,int):\n        hh,ww = simgShape,simgShape\n    if isinstance(simgShape,(tuple,list)):\n        hh,ww = simgShape\n    if step is None:\n        steph,stepw = hh,ww\n    if isinstance(step,int):\n        steph,stepw = step,step\n    if isinstance(step,float):\n        steph,stepw = int(hh*step),int(ww*step)\n    if isinstance(step,(tuple,list)):\n        steph,stepw = step\n    simgs = []\n    for i in list(range(0,h-hh,steph))[:]+[h-hh]:\n        for j in list(range(0,w-ww,stepw))[:]+[w-ww]:\n            simg = img[i:i+hh,j:j+ww]\n            simgs.append(simg)\n            if f:\n                f(simg,i,j)\n    return simgs\n\n\ndef autoSegmentWholeImg(img,simgShape,handleSimg,step=None,weightCore=None):\n    \'\'\'\n    \xe5\xb0\x86img\xe5\x88\x86\xe5\x89\xb2\xe5\x88\xb0 shape\xe4\xb8\xbasimgShape \xe7\x9a\x84\xe5\xb0\x8f\xe5\x9b\xbesimg\xef\xbc\x8c\xe6\x89\xa7\xe8\xa1\x8chandleSimg(simg)\n    \xe5\xb0\x86\xe6\x89\x80\xe6\x9c\x89handleSimg(simg)\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c\xe8\x87\xaa\xe5\x8a\xa8\xe6\x8b\xbc\xe6\x8e\xa5\xe6\x88\x90img\xe5\xbd\xa2\xe7\x8a\xb6\xe7\x9a\x84ndarray\xe5\xb9\xb6\xe8\xbf\x94\xe5\x9b\x9e\n    \n    Parameters\n    ----------\n    img : ndarray\n        \xe9\x9c\x80\xe8\xa6\x81\xe8\xa2\xab\xe5\x88\x86\xe5\x89\xb2\xe5\xa4\x84\xe7\x90\x86\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\n    simgShape : int or tuple\n        \xe5\xb0\x8f\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84shape,\xe4\xb8\xbaint\xe6\x97\xb6\xe5\x80\x99 \xe8\x87\xaa\xe5\x8a\xa8\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba(simgShape, simgShape)\n    handleSimg : function\n        \xe7\x94\xa8\xe4\xba\x8e\xe5\xa4\x84\xe7\x90\x86shape\xe4\xb8\xbasimgShape\xe7\x9a\x84\xe5\xb0\x8f\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0 \n        \xe6\xad\xa4\xe5\x87\xbd\xe6\x95\xb0\xe9\x9c\x80\xe8\xa6\x81\xe6\x8e\xa5\xe5\x8f\x97\xe4\xb8\x80\xe4\xb8\xaandarray\xe4\xbd\x9c\xe4\xb8\xba\xe5\x8f\x82\xe6\x95\xb0\xe5\xb9\xb6\xe8\xbf\x94\xe5\x9b\x9eshape[:2]\xe5\x90\x8c\xe4\xb8\xba\xe4\xb8\xba(h,w)\xe7\x9a\x84ndarray\n        \xe5\x8d\xb3\xef\xbc\x9ahandleSimg(simg)=>ndarray\xef\xbc\x8c\xe6\xaf\x94\xe5\xa6\x82 net.pridict(simg)\n    step : float or int or tuple(steph,stepw),defalut None\n        h\xe5\x92\x8cw\xe6\x96\xb9\xe5\x90\x91\xe4\xb8\x8a \xe7\x9b\xb8\xe9\x82\xbb\xe5\x88\x87\xe5\x89\xb2\xe7\x9a\x84\xe6\xad\xa5\xe9\x95\xbf, \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbasimgShape \n        float : (int(step*simgShape[0]),int(step*simgShape[1]))\n        int : (step, step)\n    weightCore : {None,\'avg\',\'gauss\',ndarray}, defalut None \n        \xe5\xaf\xb9\xe4\xba\x8e\xe4\xb8\xa4\xe4\xb8\xaasimg\xe5\x9b\xbe\xe7\x89\x87\xe9\x87\x8d\xe5\x8f\xa0\xe9\x83\xa8\xe5\x88\x86\xe8\xbf\x9b\xe8\xa1\x8c\xe8\x9e\x8d\xe5\x90\x88\xe6\x97\xb6\xe5\x80\x99\xe7\x9a\x84\xe5\x90\x84\xe8\x87\xaa\xe6\x9d\x83\xe9\x87\x8d\n        \xe9\xbb\x98\xe8\xae\xa4\xe5\x8f\x96\xe8\xb7\x9d\xe7\xa6\xbbsimg\xe4\xb8\xad\xe5\xbf\x83\xe6\x9c\x80\xe8\xbf\x91\xe7\x9a\x84\xe9\x83\xa8\xe5\x88\x86\n       \'gauss\':\xe5\x9c\xa8\xe9\x87\x8d\xe5\x8f\xa0\xe9\x83\xa8\xe5\x88\x86 \xe9\x87\x87\xe7\x94\xa8\xe9\xab\x98\xe6\x96\xaf\xe5\x88\x86\xe5\xb8\x83 \xe4\xbd\xbf\xe4\xb9\x8b\xe7\xa6\xbbsimg\xe4\xb8\xad\xe5\xbf\x83\xe8\xb6\x8a\xe8\xbf\x9c\xef\xbc\x8c\xe6\x9d\x83\xe9\x87\x8d\xe8\xb6\x8a\xe4\xbd\x8e\n       \'avg\':\xe9\x87\x8d\xe5\x8f\xa0\xe9\x83\xa8\xe5\x88\x86\xe5\x8f\x96\xe5\xb9\xb3\xe5\x9d\x87\n    \n    Returns\n    -------\n    result : ndarray\n        shape[:2]\xe7\xad\x89\xe4\xba\x8eimg.shape[:2]\xe7\x9a\x84ndarray\n    \'\'\'\n    if isinstance(simgShape,int):\n        hh,ww = simgShape,simgShape\n    hh,ww = simgShape\n    h,w = img.shape[:2]\n    if weightCore is None:\n        pass\n    elif isinstance(weightCore,np.ndarray):\n        pass\n    elif weightCore in [\'avg\']:\n        weightCore = np.ones((hh,ww))\n    elif weightCore in [\'guss\',\'gauss\']:\n        weightCore = getWeightCore(hh,ww)\n    else:\n        raise Exception(\'Illegal argus `weightCore` in `autoSegmentWholeImg`!\')\n    weight = np.zeros((h,w))\n    class c:\n        re=None\n        near=None\n    def f(simg,i,j):\n        sre = handleSimg(simg)\n        if c.re is None:\n            c.re = np.zeros((h,w)+sre.shape[2:],sre.dtype)\n        if weightCore is None:\n            if c.near is None:\n                y,x = np.mgrid[:hh,:ww]\n                c.near = 1-((x*1./ww-1./2)**2+(y*1./hh-1./2)**2)**.5\n            ind = c.near > weight[i:i+hh,j:j+ww]\n            c.re[i:i+hh,j:j+ww][ind]= sre[ind]\n            weight[i:i+hh,j:j+ww][ind]= c.near[ind]\n            return\n        oldw = weight[i:i+hh,j:j+ww]\n        ws = weightCore\n        if sre.ndim!=2:\n            ws = ws[...,None]\n            oldw = oldw[...,None]\n    #    map(loga,[ws,sre,c.re,oldw,c.re[i:i+hh,j:j+ww]*oldw])\n        c.re[i:i+hh,j:j+ww] = (ws*sre + c.re[i:i+hh,j:j+ww]*oldw)/(ws+oldw)\n        weight[i:i+hh,j:j+ww] += weightCore\n    #    show(c.re,weight)\n    (smallImg(img,(hh,ww),step=step,f=f))\n    return c.re\n\nclass ArgList(list):\n    \'\'\'\n    \xe6\xa0\x87\xe8\xae\xb0\xe7\xb1\xbb \xe7\x94\xa8\xe4\xba\x8e\xe6\xa0\x87\xe8\xae\xb0\xe9\x9c\x80\xe8\xa6\x81\xe8\xa2\xabautoFindBestParams\xe5\x87\xbd\xe6\x95\xb0\xe8\xbf\xad\xe4\xbb\xa3\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xe5\x88\x97\xe8\xa1\xa8\n    \'\'\'\n    pass\n\n    \ndef autoFindBestParams(c, args,evaluFun,sortkey=None, savefig=False):\n    \'\'\'\xe9\x81\x8d\xe5\x8e\x86args\xe9\x87\x8c\xe9\x9d\xa2 ArgList\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe5\x8f\x82\xe6\x95\xb0\xe7\xbb\x84\xe5\x90\x88 \xe5\xb9\xb6\xe9\x80\x9a\xe8\xbf\x87sortkey \xe6\x89\xbe\xe5\x87\xba\xe6\x9c\x80\xe4\xbd\xb3\xe5\x8f\x82\xe6\x95\xb0\xe7\xbb\x84\xe5\x90\x88\n    \n    Parameters\n    ----------\n    c : dicto\n        \xe5\x8d\xb3configManager \xe7\x94\x9f\xe6\x88\x90\xe7\x9a\x84\xe6\xb5\x8b\xe8\xaf\x95\xe9\x9b\x86\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe7\x8e\xaf\xe5\xa2\x83\xe9\x85\x8d\xe7\xbd\xae c\n        \xe5\x8c\x85\xe5\x90\xabargs\xef\xbc\x8c\xe6\x95\xb0\xe6\x8d\xae\xe9\x85\x8d\xe7\xbd\xae\xef\xbc\x8c\xe5\x90\x84\xe7\xb1\xbb\xe5\x87\xbd\xe6\x95\xb0\xe7\xad\x89\n    args : dicto\n        predict\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8c\xe4\xbd\x86\xe9\x9c\x80\xe8\xa6\x81\xe5\x8c\x85\xe5\x90\xab ArgList \xe7\xb1\xbb \xe5\xb0\x86\xe9\x81\x8d\xe5\x8e\x86ArgList\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe5\x8f\x82\xe6\x95\xb0\xe7\xbb\x84\xe5\x90\x88 \xe5\xb9\xb6\xe6\x89\xbe\xe5\x87\xba\xe6\x9c\x80\xe4\xbd\xb3\xe5\x8f\x82\xe6\x95\xb0\xe7\xbb\x84\xe5\x90\x88\n    evaluFun : Function\n        \xe7\x94\xa8\xe4\xba\x8e\xe8\xaf\x84\xe6\xb5\x8b\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8c\xe7\x94\xa8\xe4\xba\x8eEvalu\xe7\xb1\xbb \xe9\x9c\x80\xe8\xa6\x81\xe8\xbf\x94\xe5\x9b\x9edict\xe5\xaf\xb9\xe8\xb1\xa1\n    sortkey : str, default None\n        \xe7\x94\xa8\xe4\xba\x8e\xe7\xad\x9b\xe9\x80\x89\xe6\x97\xb6\xe5\x80\x99\xe7\x9a\x84key \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbadf.columns[-1]\n    \n    Return: DataFrame\n        \xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\x82\xe6\x95\xb0\xe7\xbb\x84\xe5\x90\x88\xe5\x8f\x8a\xe5\x85\xb6\xe8\xaf\x84\xe4\xbb\xb7\xe7\x9a\x84\xe5\xb9\xb3\xe5\x9d\x87\xe5\x80\xbc\n    \'\'\'\n    iters = [it for it in list(args.items()) if isinstance(it[1],ArgList)]\n    iters = sorted(iters,key=lambda x:len(x[1]),reverse=True)\n    argsraw = args.copy()\n    argsl = []\n    args = dicto()\n    \n    k,vs = iters[0]\n    lenn = len(iters)\n    deep = 0\n    tags = [0,]*lenn\n    while deep>=0:\n        vs = iters[deep][1]\n        ind = tags[deep]\n        if ind != len(vs):\n            v = vs[ind]\n            tags[deep]+=1\n            key = iters[deep][0]\n            args[key] = v\n            if deep == lenn-1:\n                argsl.append(args.copy())\n            else:\n                deep+=1\n        else:\n            tags[deep:]=[0]*(lenn-deep)\n            deep -= 1\n    assert len(argsl),""args don\'t have ArgList Values!!""\n    pds,pddf = pd.Series, pd.DataFrame\n    edic={}\n    for arg in argsl:\n        argsraw.update(arg)\n        c.args.update(argsraw)\n        e = Evalu(evaluFun,\n                  evaluName=\'tmp\',\n                  sortkey=sortkey,\n                  loged=False,\n                  saveResoult=False,\n                  )\n        if \'reload\' in c:\n            imp.reload(c.reload)\n            inference = c.reload.inference\n        elif \'predictInterface\' in c:\n            imp.reload(c.predictInterface)\n            inference = c.predictInterface.predict\n        else:\n            raise Exception(""don\'t reload get c.reload"")\n        for name in c.names[::]:\n            gt = c.readgt(name)\n            prob = inference(c.toimg(name))\n            re = prob.argmax(2)\n#            from boxx import g\n#            g.re,g.gt = re,gt\n            e.evalu(re,gt,name)\n    #        img = readimg(name)\n    #        show(re,gt)\n    #        show(img)\n        if sortkey is None:\n            sortkey = e.columns[-1]\n        keys = tuple(arg.values())\n        for k,v in list(arg.items()):\n            e[k] = v\n        edic[keys] = e\n        print(\'arg: %s\\n\'%str(arg), e.mean())\n    es = pddf([pds(x.mean()) for x in list(edic.values())])\n    print(\'-\'*20+\'\\nmax %s:\\n\'%sortkey,es.loc[es[sortkey].argmax()])\n    print(\'\\nmin %s:\\n\'%sortkey,es.loc[es[sortkey].argmin()])\n    if len(iters) == 1:\n        k = iters[0][0]\n        import matplotlib.pyplot as plt\n        df = es.copy()\n        df = df.sort_values(k)\n        plt.plot(df[k],df[sortkey],\'--\');plt.plot(df[k],df[sortkey],\'rx\')\n        plt.xlabel(k);plt.ylabel(sortkey);plt.grid()\n        if savefig:\n            plt.savefig(savefig)\n            plt.close()\n        else:\n            plt.show()    \n    return es\n\ndef autoFindBestEpoch(c, evaluFun,sortkey=None,epochs=None, savefig=False):\n    \'\'\'\xe9\x81\x8d\xe5\x8e\x86\xe6\x89\x80\xe6\x9c\x89epoch\xe7\x9a\x84weight  \xe5\xb9\xb6\xe9\x80\x9a\xe8\xbf\x87\xe6\xb5\x8b\xe8\xaf\x95\xe9\x9b\x86\xe8\xaf\x84\xe4\xbc\xb0\xe9\xa1\xb9sortkey \xe6\x89\xbe\xe5\x87\xba\xe6\x9c\x80\xe4\xbd\xb3epoch\n    \n    Parameters\n    ----------\n    c : dicto\n        \xe5\x8d\xb3configManager \xe7\x94\x9f\xe6\x88\x90\xe7\x9a\x84\xe6\xb5\x8b\xe8\xaf\x95\xe9\x9b\x86\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe7\x8e\xaf\xe5\xa2\x83\xe9\x85\x8d\xe7\xbd\xae c\n        \xe5\x8c\x85\xe5\x90\xabargs\xef\xbc\x8c\xe6\x95\xb0\xe6\x8d\xae\xe9\x85\x8d\xe7\xbd\xae\xef\xbc\x8c\xe5\x90\x84\xe7\xb1\xbb\xe5\x87\xbd\xe6\x95\xb0\xe7\xad\x89\n    evaluFun : Function\n        \xe7\x94\xa8\xe4\xba\x8e\xe8\xaf\x84\xe6\xb5\x8b\xe7\x9a\x84\xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8c\xe7\x94\xa8\xe4\xba\x8eEvalu\xe7\xb1\xbb \xe9\x9c\x80\xe8\xa6\x81\xe8\xbf\x94\xe5\x9b\x9edict\xe5\xaf\xb9\xe8\xb1\xa1\n    sortkey : str, default None\n        \xe7\x94\xa8\xe4\xba\x8e\xe7\xad\x9b\xe9\x80\x89\xe6\x97\xb6\xe5\x80\x99\xe7\x9a\x84key \xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xbadf.columns[-1]\n    \n    Return: DataFrame\n        \xe6\xaf\x8f\xe4\xb8\xaa\xe5\x8f\x82\xe6\x95\xb0\xe7\xbb\x84\xe5\x90\x88\xe5\x8f\x8a\xe5\x85\xb6\xe8\xaf\x84\xe4\xbb\xb7\xe7\x9a\x84\xe5\xb9\xb3\xe5\x9d\x87\xe5\x80\xbc\n    \'\'\'\n    args = c.args\n    if not isinstance(epochs,(tuple,list)) :\n        pas = [p[len(args.prefix):] for p in glob(args.prefix+\'*\') if p[-4:]!=\'json\']\n        eps = [len(findints(s)) and findints(s)[-1] for s in pas]\n        maxx = len(eps) and max(eps)\n        minn = len(eps) and min(eps)\n        if isinstance(epochs,int):\n            epochs = list(range(minn,maxx))[::epochs]+[maxx]\n        else:\n            epochs = list(range(minn,maxx+1))\n    args[\'restore\'] = ArgList(epochs)\n#    print epochs\n    df = autoFindBestParams(c, args, evaluFun,sortkey=sortkey,savefig=savefig)\n    return df\n\nif __name__ == \'__main__\':\n    pass\n'"
boxx/ylml/ylmlTrain.py,0,"b""# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\n\nimport os\nimport numpy as np\nfrom ..ylimg import imread\n\n\nfrom collections import Iterator \nclass GenSimg(Iterator):\n    '''\n    \xe9\x9a\x8f\xe6\x9c\xba\xe7\x94\x9f\xe6\x88\x90\xe5\xb0\x8f\xe5\x9b\xbe\xe7\x89\x87simg\xe5\x8f\x8agt \xe7\x9a\x84\xe8\xbf\xad\xe4\xbb\xa3\xe5\x99\xa8\xef\xbc\x8c\xe9\xbb\x98\xe8\xae\xa4\xe4\xbd\xbf\xe7\x94\xa81Gb\xe5\x86\x85\xe5\xad\x98\xe4\xbd\x9c\xe4\xb8\xba\xe5\x9b\xbe\xe7\x89\x87\xe7\xbc\x93\xe5\xad\x98\n    \xe9\xbb\x98\xe8\xae\xa4\xe7\x94\x9f\xe6\x88\x90simg\xe6\x80\xbb\xe9\x9d\xa2\xe7\xa7\xaf\xe2\x89\x88\xe6\x89\x80\xe6\x9c\x89\xe5\x9b\xbe\xe5\x83\x8f\xe6\x80\xbb\xe9\x9d\xa2\xe7\xa7\xaf\xe6\x97\xb6 \xe5\x8d\xb3\xe7\xbb\x93\xe6\x9d\x9f\n    '''\n    def __init__(self, imggts, simgShape, handleImgGt=None,\n                 batch=1, cache=None,iters=None,\n                 timesPerRead=1,infinity=False):\n        '''\n        imggts: zip(jpgs,pngs)\n        simgShape: simg\xe7\x9a\x84shape\n        handleImgGt: \xe5\xaf\xb9\xe8\xbe\x93\xe5\x87\xba\xe7\xbb\x93\xe6\x9e\x9c\xe8\xbf\x90\xe8\xa1\x8chandleImgGt(img,gt)\xe5\xa4\x84\xe7\x90\x86\xe5\x90\x8e\xe5\x86\x8d\xe8\xbf\x94\xe5\x9b\x9e\n        batch: \xe6\xaf\x8f\xe6\xac\xa1\xe8\xbf\x94\xe5\x9b\x9e\xe7\x9a\x84batch\xe4\xb8\xaa\xe6\x95\xb0\n        cache: \xe7\xbc\x93\xe5\xad\x98\xe5\x9b\xbe\xe7\x89\x87\xe6\x95\xb0\xe7\x9b\xae, \xe9\xbb\x98\xe8\xae\xa4\xe7\xbc\x93\xe5\xad\x981Gb\xe7\x9a\x84\xe6\x95\xb0\xe7\x9b\xae\n        timesPerRead: \xe5\xb9\xb3\xe5\x9d\x87\xe6\xaf\x8f\xe6\xac\xa1\xe8\xaf\xbb\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe4\xbd\xbf\xe7\x94\xa8\xe5\xa4\x9a\xe5\xb0\x91\xe6\xac\xa1(\xe4\xb8\x8d\xe4\xbc\x9a\xe5\xbd\xb1\xe5\x93\x8d\xe6\x80\xbb\xe8\xbf\xad\xe4\xbb\xa3\xe6\xac\xa1\xe6\x95\xb0),\xe9\xbb\x98\xe8\xae\xa41\xe6\xac\xa1\n        iters: \xe5\x9b\xba\xe5\xae\x9a\xe8\xbe\x93\xe5\x87\xba\xe5\xb0\x8f\xe5\x9b\xbe\xe7\x89\x87\xe7\x9a\x84\xe6\x80\xbb\xe6\x95\xb0\xe7\x9b\xae\xef\xbc\x8c\xe4\xb8\x8ebatch\xe6\x97\xa0\xe5\x85\xb3\n        infinity: \xe6\x97\xa0\xe9\x99\x90\xe8\xbf\xad\xe4\xbb\xa3\n        '''\n        if isinstance(simgShape,int):\n            simgShape = (simgShape,simgShape)\n        self.handleImgGt = handleImgGt\n        self.imggts = imggts\n        self.simgShape = simgShape\n        self.batch = batch\n        self._iters = iters\n        self.iters = self._iters\n        self.infinity = infinity\n        \n        hh,ww = simgShape\n        jpg,png = imggts[0]\n        img = imread(jpg)\n        h,w = img.shape[:2]\n        if cache is None:\n            cache = max(1,int(1e9/img.nbytes))\n        cache = min(cache,len(imggts))\n        self.maxPerCache = int(cache*(h*w)*1./(hh*ww))* timesPerRead/batch\n        self.cache = cache\n        self.n = len(imggts)\n        self._times = max(1,int(round(self.n*1./cache/timesPerRead)))\n        self.times = self._times\n        self.totaln = self.sn = iters or int((h*w)*self.n*1./(hh*ww))\n        self.willn = iters or self.maxPerCache*self.times*batch\n        self.count = 0\n        self.reset()\n        \n        self.bytes = img.nbytes\n        argsStr = '''imggts=%s pics in dir: %s, \n        simgShape=%s, \n        handleImgGt=%s,\n        batch=%s, cache=%s,iters=%s,\n        timesPerRead=%s, infinity=%s'''%(self.n , os.path.dirname(jpg) or './', simgShape, handleImgGt,\n                                 batch, cache,iters,\n                                 timesPerRead,infinity)\n        generatorStr = '''maxPerCache=%s, readTimes=%s\n        Will generator maxPerCache*readTimes*batch=%s'''%(self.maxPerCache, self.times,\n                                                          self.willn)\n        if iters:\n            generatorStr = 'Will generator iters=%s'%iters\n        self.__describe = '''GenSimg(%s)\n        \n        Total imgs Could generator %s simgs,\n        %s simgs.\n        '''%(argsStr,self.totaln,\n             generatorStr,)\n    def reset(self):\n        if (self.times<=0 and self.iters is None) and not self.infinity:\n            self.times = self._times\n            raise StopIteration\n        self.now = self.maxPerCache\n        inds = np.random.choice(list(range(len(self.imggts))),self.cache,replace=False)\n        datas = {}\n        for ind in inds:\n            jpg,png = self.imggts[ind]\n            img,gt = imread(jpg),imread(png)\n            datas[jpg] = img,gt\n        self.data = self.datas = datas\n        self.times -= 1\n    def __next__(self):\n        self.count += 1\n        if (self.iters is not None) and not self.infinity:\n            if self.iters <= 0:\n                self.iters = self._iters\n                raise StopIteration\n            self.iters -= self.batch\n        if self.now <= 0:\n            self.reset()\n        self.now -= 1\n        hh,ww = self.simgShape\n        datas = self.datas\n        imgs, gts = [], []\n        for t in range(self.batch):\n            img,gt = datas[np.random.choice(list(datas.keys()),1,replace=False)[0]]\n            h,w = img.shape[:2]\n            i= np.random.randint(h-hh+1)\n            j= np.random.randint(w-ww+1)\n            (img,gt) =  img[i:i+hh,j:j+ww],gt[i:i+hh,j:j+ww]\n            imgs.append(img), gts.append(gt)\n        (imgs,gts) = list(map(np.array,(imgs,gts)))\n        if self.handleImgGt:\n            return self.handleImgGt(imgs,gts)\n        return (imgs,gts)\n    @property\n    def imgs(self):\n        return [img for img,gt in list(self.datas.values())]\n    @property\n    def gts(self):\n        return [gt for img,gt in list(self.datas.values())]\n    def __str__(self):\n        batch = self.batch\n        n = len(self.datas)\n        return self.__describe + \\\n        '''\n    status:\n        iter  in %s/%s(%.2f)\n        batch in %s/%s(%.2f)\n        cache imgs: %s\n        cache size: %.2f MB\n        '''%(self.count*batch,self.willn,self.count*1.*batch/self.willn,\n            self.count,self._times*self.maxPerCache,\n            self.count*1./(self._times*self.maxPerCache),\n            n, (n*self.bytes/2**20))\n    def __len__(self):\n        return self.willn\n    __repr__ = __str__\n\nif __name__ == '__main__':\n    pass\n"""
boxx/ylsci/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nMath and Scientific Computing module\n\n@author: yl\n""""""\n\nfrom __future__ import unicode_literals\n\nfrom .ylnp import  e, pi, nan, inf, eps\nfrom .ylnp import getNumpyType, mapping_array\nfrom .ylnp import savenp, loadnp, plot3dSurface, isNumpyType, testNumpyMultiprocessing\n\nfrom .ylvector import sin, cos, tan, arcsin, arccos, arctan, deg2rad, rad2deg\nfrom .ylvector import Vector, v0\n\nfrom .ylstatistics import distavg, distnorm, DiscreteSample, HeatmapSample'"
boxx/ylsci/ylnp.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nsome numpy function\n\n@author: yanglei\n""""""\n\nfrom __future__ import unicode_literals\n\nfrom ..ylsys import sysi\nfrom ..ylcompat import interactivePlot\n\nfrom ..tool.toolTools import filterList\n\nimport numpy as np\nfrom numpy import e, pi, nan, inf\nnan = nan * .22\ninf = inf * .22\neps = 1e-5\n\ndef savenp(path, arr=None):\n    \'\'\'\xe5\x8e\x8b\xe7\xbc\xa9\xe5\xad\x98\xe5\x82\xa8 np.array \xe4\xb8\xbapath\xe8\xb7\xaf\xe5\xbe\x84 \n    ps: int, bool \xe5\x8e\x8b\xe7\xbc\xa9\xe6\x95\x88\xe6\x9e\x9c\xe4\xbd\xb3 \xe5\x8f\xaf\xe8\xbe\xbe\xe5\x88\xb020\xe5\x80\x8d\'\'\'\n    if isinstance(path,np.ndarray) and arr is None:\n        path,arr = \'savenp_default.npz\',path\n    np.savez_compressed(path, arr)\ndef loadnp(path=\'savenp_default.npz\'):\n    \'\'\'\xe8\xaf\xbb\xe5\x8f\x96path\xe8\xb7\xaf\xe5\xbe\x84\xe4\xb8\x8b\xe7\x9a\x84 .npz \xe8\xbf\x94\xe5\x9b\x9e np.array\'\'\'\n    if path[-4:] != \'.npz\':\n        path += \'.npz\'\n    compress = np.load(path)\n    arr = compress[compress.files[0]]\n    compress.close()\n    return arr \n\ndef mapping_array(array, mapping, strict=True):\n    """"""Element-wise mapping array by a kv mapping\n    \n    Parameters\n    ----------\n    array : np.array\n        array that content are mapping\'s key \n    mapping: dict, list, tuple .etc\n        a kv mapping struct\n    strict : bool, default True\n        if strict is False, when k not in mapping, will return k\n    """"""\n    ks, idx_array = np.unique(array, return_inverse=True)\n    if strict:\n        idx_to_v = np.array([mapping[k] for k in ks])\n    else:\n        idx_to_v = np.array([mapping[k] if k in mapping else k for k in ks])\n    mappinged_array = idx_to_v[idx_array.reshape(array.shape)]\n    return mappinged_array\n\n@interactivePlot    \ndef __draw3dSurface(X,Y,Z):    \n    import matplotlib.pyplot as plt\n    from mpl_toolkits.mplot3d import Axes3D\n    from matplotlib import cm\n    from matplotlib.ticker import LinearLocator, FormatStrFormatter\n    fig = plt.figure()\n    ax = fig.gca(projection=\'3d\')\n    \n    surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm, linewidth=0, antialiased=False)\n    #\xe7\x94\xbb\xe8\xa1\xa8\xe9\x9d\xa2,x,y,z\xe5\x9d\x90\xe6\xa0\x87\xef\xbc\x8c \xe6\xa8\xaa\xe5\x90\x91\xe6\xad\xa5\xe9\x95\xbf\xef\xbc\x8c\xe7\xba\xb5\xe5\x90\x91\xe6\xad\xa5\xe9\x95\xbf\xef\xbc\x8c\xe9\xa2\x9c\xe8\x89\xb2\xef\xbc\x8c\xe7\xba\xbf\xe5\xae\xbd\xef\xbc\x8c\xe6\x98\xaf\xe5\x90\xa6\xe6\xb8\x90\xe5\x8f\x98\n    \n    #ax.set_zlim(-1.01, 1.01)#\xe5\x9d\x90\xe6\xa0\x87\xe7\xb3\xbb\xe7\x9a\x84\xe4\xb8\x8b\xe8\xbe\xb9\xe7\x95\x8c\xe5\x92\x8c\xe4\xb8\x8a\xe8\xbe\xb9\xe7\x95\x8c\n    ax.zaxis.set_major_locator(LinearLocator(10))#\xe8\xae\xbe\xe7\xbd\xaeZ\xe8\xbd\xb4\xe6\xa0\x87\xe5\xba\xa6\n    ax.zaxis.set_major_formatter(FormatStrFormatter(\'%.02f\'))#Z\xe8\xbd\xb4\xe7\xb2\xbe\xe5\xba\xa6\n    fig.colorbar(surf, shrink=0.5, aspect=5)#shrink\xe9\xa2\x9c\xe8\x89\xb2\xe6\x9d\xa1\xe4\xbc\xb8\xe7\xbc\xa9\xe6\xaf\x94\xe4\xbe\x8b\xef\xbc\x880-1\xef\xbc\x89\xef\xbc\x8caspect\xe9\xa2\x9c\xe8\x89\xb2\xe6\x9d\xa1\xe5\xae\xbd\xe5\xba\xa6\xef\xbc\x88\xe5\x8f\x8d\xe6\xaf\x94\xe4\xbe\x8b\xef\xbc\x8c\xe6\x95\xb0\xe5\x80\xbc\xe8\xb6\x8a\xe5\xa4\xa7\xe5\xae\xbd\xe5\xba\xa6\xe8\xb6\x8a\xe7\xaa\x84\xef\xbc\x89\n    \n    plt.show()\n\n\ndef plot3dSurface(Z):\n    \'\'\'\n    \xe5\xaf\xb9\xe4\xba\x8c\xe7\xbb\xb4\xe6\x95\xb0\xe7\xbb\x84Z \xe7\x94\xbb\xe5\x87\xba3d\xe7\x9b\xb4\xe6\x96\xb9\xe5\x9b\xbe \n    \'\'\'\n    m, n = Z.shape\n    X = list(range(n))\n    Y = list(range(m))\n    X, Y = np.meshgrid(X, Y)\n    __draw3dSurface(X,Y,Z)\n\n__numpyTypeCache = dict()\ndef getNumpyType(typee=\'int\'):\n    if typee in __numpyTypeCache:\n        return __numpyTypeCache[typee]\n    finds = eval(\'(\'+\', \'.join([\'np.\'+mu for mu in filterList(typee, dir(np))])+\')\')\n    types = [x for x in finds if type(x)==type]\n    if typee == ""str"":\n        types = tuple(types) + getNumpyType(\'unicode\')\n    types = tuple(types)\n    __numpyTypeCache[typee] = types\n    return types\ndef isNumpyType(array, typee=\'int\'):\n    \'\'\'\n    \xe5\x92\x8cisinstance\xe4\xb8\x80\xe6\xa0\xb7\xe7\x9a\x84\xe7\x94\xa8\xe6\xb3\x95 \xe5\x88\xa4\xe6\x96\xadnp.array.dtype \xe5\xaf\xb9\xe8\xb1\xa1\xe5\xaf\xb9\xe5\xba\x94 [bool, int, float, str]\xe7\x9a\x84\xe7\xb1\xbb\n    \xe6\xb3\xa8\xe6\x84\x8f isNumpyType([bool],int) \xe4\xb8\xbaTrue \n    \'\'\'\n    npFloatTypes = getNumpyType(\'float\')\n    npIntTypes = getNumpyType(\'int\')\n    npBoolTypes = getNumpyType(\'bool\')\n    npStrTypes = getNumpyType(\'str\')\n    if isinstance(typee,tuple):\n        return any([isNumpyType(array, t) for t in typee])\n    if typee in [bool,\'bool\']:\n        return array.dtype in (npBoolTypes)\n    if typee in [int,\'int\']:\n        return array.dtype in (npIntTypes+npBoolTypes)\n    if typee in [float,\'float\']:\n        return array.dtype in (npFloatTypes)\n    if typee in [str,\'str\',\'unicode\']:\n        return array.dtype in (npStrTypes)\n    raise Exception(""isNumpyType(array, typee) array must be numpy,""+\\\n    ""typee must be tuple or [bool, int, float, str, unicode] "")\n\ndef testNumpyMultiprocessing(n=16, nn=1500):\n    \'\'\'\n    test numpy Multiprocessing performance in your enviroment\n    \n    Parameters\n    ----------\n    n : int\n        How many times to do np.dot\n    nn : int\n        the shape of the np.ndarray is (nn, nn)\n    \'\'\'\n    from boxx import timeit, mapmp\n    ass = [np.random.rand(nn , nn) for i in range(n)]\n    bs = [np.random.rand(nn , nn) for i in range(n)]\n    s = \'np.dot%s for %s times\'%(str(([nn,nn],[nn,nn])), n )\n    name = \'map\'\n    print(\'\\n\\nTesting %s in %s ...\'%(s, name))\n    with timeit(name):\n        l = map(np.dot, ass, bs)\n        l = list(l)\n    \n    name = \'mapmp with pool=%d\'%sysi.cpun\n    print(\'\\n\\nTesting %s in %s ...\'%(s, name))\n    with timeit(name):\n        l = mapmp(np.dot, ass, bs)\n\nif __name__ == \'__main__\':\n    \n    \n    \n    pass\n    \n    \n    \n'"
boxx/ylsci/ylstatistics.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\nstatistics tools \n\n@author: yl\n""""""\nimport random\nimport numpy as np\nfrom functools import wraps\nfrom collections import Counter\n\n\ndef Distribution(f):\n    """"""\n    return  distribution of bias round v and max bias is @maxratio*v.mean() or @maxbias\n    """"""\n\n    @wraps(f)\n    def innerF(v, maxbias=None, maxratio=0.2, *l, **kv):\n        mean = v\n        if maxbias is None:\n            if isinstance(v, np.ndarray):\n                mean = v.mean()\n            maxbias = maxratio * mean\n        biass = f(v=v, maxbias=maxbias, maxratio=maxratio, *l, **kv)\n        return v + biass\n\n    return innerF\n\n\n@Distribution\ndef distnorm(v, maxbias=None, maxratio=0.2, std=2):\n    """"""\n    return normal distribution of bias round v and max bias is @maxratio*v.mean() or @maxbias\n    """"""\n    shape = None\n    if isinstance(v, np.ndarray):\n        shape = v.shape\n    normaBiass = np.random.normal(loc=1, scale=1.0 / std, size=shape) % (2) - 1\n\n    biass = normaBiass * maxbias\n    return biass\n\n\n@Distribution\ndef distavg(v, maxbias=None, maxratio=0.2):\n    """"""\n    return uniform distribution of bias round v and max bias is @maxratio*v.mean() or @maxbias\n    """"""\n    shape = None\n    if isinstance(v, np.ndarray):\n        shape = v.shape\n    biass = np.random.uniform(-maxbias, maxbias, size=shape)\n    return biass\n\n\nclass DiscreteSample(dict):\n    def sample(self):\n        summ = sum(self.values())\n        random_number = random.random() * summ\n        for k, v in self.items():\n            random_number -= v\n            if random_number <= 0:\n                return k\n\n    @staticmethod\n    def test():\n        ds = DiscreteSample({""a"": 1, ""b"": 2, ""c"": 0})\n        print(Counter([ds.sample() for _ in range(1000000)]))\n\n\nclass HeatmapSample:\n    def __init__(self, heatmap):\n        h, w = heatmap.shape\n        hs, ws = np.mgrid[:h, :w]\n        hs, ws = hs.reshape(-1), ws.reshape(-1)\n        self.discrete_sample = DiscreteSample(zip(zip(hs, ws), heatmap.reshape(-1)))\n\n    def sample(self):\n        return self.discrete_sample.sample()\n\n\nif __name__ == ""__main__"":\n    from boxx import loga\n\n    loga(distavg(np.ones((517, 111))))\n    loga(distnorm(np.ones((517, 111)), 3, std=4))\n    DiscreteSample.test()\n    pass\n'"
boxx/ylsci/ylvector.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nVector Class\n\nNote:\n    we use deg rather than rad, for human\n\n@author: yl\n""""""\nfrom functools import wraps\n\nimport numpy as np\nfrom numpy import pi\n\nfrom ..tool import strnum\nfrom ..ylcompat import py2\n\nrad2deg = lambda rad: rad / pi * 180\ndeg2rad = lambda deg: deg / 180 * pi\n\n# TODO mv to ylTriFun.py\ndef degShift(triFun, arc=False):\n    funForInfo = lambda: 0 if py2 else triFun\n    @wraps(funForInfo)\n    def innerfun(inp):\n        if not arc:\n            inp = deg2rad(inp)\n        r = triFun(inp)\n        if arc:\n            r = rad2deg(r)\n        return r\n    return innerfun\n\nsin = degShift(np.sin)\ncos = degShift(np.cos)\ntan = degShift(np.tan)\n\narcsin = degShift(np.arcsin, arc=True)\narccos = degShift(np.arccos, arc=True)\narctan = degShift(np.arctan, arc=True)\n\n\nclass Vector(np.ndarray):\n    #    def __init__(self, point):\n    #        np.ndarray.__init__(self, point)\n    #        self._norm = None\n    def __new__(self, point):\n        obj = np.asarray(point).view(self)\n        self._norm = None\n        return obj\n\n    @property\n    def x(self):\n        return self[0]\n\n    @property\n    def y(self):\n        return self[1]\n\n    @property\n    def z(self):\n        return self[2]\n\n    @x.setter\n    def x(self, v, *l):\n        self[0] = v\n\n    @y.setter\n    def y(self, v, *l):\n        self[1] = v\n\n    @z.setter\n    def z(self, v, *l):\n        self[2] = v\n\n    @property\n    def h(self):\n        return self[0]\n\n    @property\n    def w(self):\n        return self[1]\n\n    @h.setter\n    def h(self, v, *l):\n        self[0] = v\n\n    @w.setter\n    def w(self, v, *l):\n        self[1] = v\n\n    def intround(self):\n        return self.round().astype(int)\n\n    @property\n    def norm(self):\n        if self._norm is None:\n            self._norm = (np.array(self) ** 2).sum() ** 0.5\n        return self._norm\n\n    def angleWith(self, v):\n        cosin = (self * v).sum() / (self.norm * v.norm)\n        deg = arccos(cosin)\n        return deg\n\n    def rotation(self, deg):\n        assert self.shape == (2,)\n        transferMatrix = [[cos(deg), -sin(deg)], [sin(deg), cos(deg)]]\n        after = np.dot(transferMatrix, self.T).T\n        return Vector(after)\n\n    def __str__(self,):\n        if (self).shape == (2,):\n            if ""int"" in str(self.dtype):\n                return ""Vector(x|h=%s, y|w=%s)%s"" % ((self[0]), (self[1]), self.dtype)\n            return ""Vector(x|h=%s, y|w=%s)%s"" % (\n                strnum(self[0]),\n                strnum(self[1]),\n                self.dtype,\n            )\n        if (self).shape == (3,):\n            if ""int"" in str(self.dtype):\n                return ""Vector(x|h=%s, y|w=%s, z=%s)%s"" % (\n                    (self[0]),\n                    (self[1]),\n                    (self[2]),\n                    self.dtype,\n                )\n            return ""Vector(x|h=%s, y|w=%s, z=%s)%s"" % (\n                strnum(self[0]),\n                strnum(self[1]),\n                strnum(self[2]),\n                self.dtype,\n            )\n        return np.ndarray.__str__(self) + "" (Vector)""\n\n    __repr__ = __str__\n\n    @staticmethod\n    def test():\n        a = Vector([4, 0])\n        b = Vector([4, 4 * 3 ** 0.5])\n        print(a.angleWith(b))\n        print(a.rotation(45).norm)\n\n\nv0 = Vector([0, 0])\n\nif __name__ == ""__main__"":\n    Vector.test()\n    pass\n'"
boxx/ylth/__init__.py,43,"b'#!/usr/bin/env python2\n# -*- coding: utf-8 -*-\n\'\'\'\nsysc.py: system config\n\'\'\'\nfrom __future__ import unicode_literals\nimport numpy as np\nfrom .. import *\nfrom ..ylsys import cpun, cloud, cuda, usecuda\nfrom ..ylimg import npa, r\nfrom ..tool import FunAddMagicMethod, nextiter, withfun, pred\n\nfrom ..ylcompat import py2, ModuleNotFoundError\n\ndef importYlthRequire(exc_type, exc_value, exc_traceback):\n    if exc_type is ModuleNotFoundError:\n        pred(\'\'\'\\n\\nMesage from boxx:\\n\\tTo use boxx.ylth, you should run: \\n\\t`pip install torchvision torchsummary torchviz`\\n\'\'\')\nwith withfun(exitFun=importYlthRequire, exception=True):\n    from torchsummary import summary\n#    import torchviz\n\n#import matplotlib.pyplot as plt\n#import skimage.io as sio\n#import skimage.data as sda\nfrom collections import OrderedDict\nfrom functools import wraps\nimport matplotlib.pyplot as plt\nimport skimage.data as sda\n\n#if \'torch\' in sys.modules:\n#    del sys.modules[(\'torch\')]\n#    sys.modules.pop(\'torch\')\n#from imp import reload  \n#reload(torch)\n#reload(torch.nn)\n#reload(torch.nn.modules.module)\n#import importlib\n#torch = importlib.reload(torch)\nfrom torch.autograd import Variable\nimport torch.utils.data\nth = torch\nnn = th.nn\nfrom torch.nn import (Conv2d, Linear, ConvTranspose2d, BatchNorm2d, ReLU, Tanh, \n                      Softmax2d, CrossEntropyLoss, DataParallel, MSELoss, \n                      MaxPool2d, AvgPool2d, Module, functional, Sequential)\nTensor = torch.Tensor\nF = functional\n\nimport torchvision\nimport torchvision.transforms as transforms\nimport torchvision.datasets as datasets\n\n# default whether choose cuda\n#th.long = torch.cuda.LongTensor \n#th.double = torch.cuda.DoubleTensor \n#th.int = torch.cuda.IntTensor \n#th.short = torch.cuda.ShortTensor \n#th.byte = torch.cuda.ByteTensor \n#th.half = torch.cuda.HalfTensor \n#th.char = torch.cuda.CharTensor \n#th.float = torch.cuda.FloatTensor \n\n# add summary to torch.nn.Module\nnn.Module.summary = lambda self, inputShape=None, group=None, ganNoise=False:summary(self, inputShape or getModelDefaultInputShape(self, group, ganNoise) ,device=[\'cuda\', \'cpu\'][\'cpu\' in str(getpara(self).device)])\n\n\ndef dedp(model):\n    \'\'\'get raw model instead of torch.nn.DataParallel \'\'\'\n    return model.module if isinstance(model, torch.nn.DataParallel) else model\n\nif \'Module\' in str(torch.nn.Module.load_state_dict):\n    torch.rawModule = rawModule = torch.nn.Module.load_state_dict\nelse :\n    rawModule = torch.rawModule \ndef tryLoad(self, state_dict, strict=True):\n    try:\n        rawModule(self, state_dict, strict)\n    except (KeyError,RuntimeError) :\n        print(\'\\x1b[31m%s\\x1b[0m\' % \'\\n""try strict=False! in Module.load_state_dict() "" messge from boxx.ylth \\n\')\n        para = state_dict\n        para = OrderedDict(\n                    [(k.replace(\'module.\', \'\'),v) for k,v in para.items()]\n            )\n        rawModule(self, para, strict)\ndef toCpu():            \n    cudaAttri =  lambda self,*l,**kv:self\n    nn.Module.cuda = cudaAttri\n    Variable.cuda = cudaAttri\n    torch.Tensor.cuda = cudaAttri\n    torch.Tensor.to = cudaAttri\n    \n#    class FakeDataParallel(torch.nn.DataParallel):\n#        def __init__(self, x):\n#            super(FakeDataParallel, self).__init__()\n    torch.nn.DataParallel = cudaAttri\n    \n    class withh():\n        def __init__(self, *l):\n            pass\n        def __call__(self):\n            return self\n        def __enter__(self):\n            return self\n        def __exit__(self, typee, value, traceback):\n            pass\n    torch.cuda.device = withh\n    from boxx import fnone\n    torch.cuda.set_device = fnone\n    torch.cuda.is_available = lambda :True\n    \n\n    th.cuda.LongTensor = th.LongTensor\n    th.cuda.DoubleTensor = th.DoubleTensor\n    th.cuda.IntTensor = th.IntTensor\n    th.cuda.ShortTensor = th.ShortTensor\n    th.cuda.ByteTensor = th.ByteTensor\n    th.cuda.HalfTensor = th.HalfTensor\n    th.cuda.CharTensor = th.CharTensor\n    th.cuda.FloatTensor = th.FloatTensor\n    \n    rawDataLoader = th.utils.data.DataLoader\n#    def warp(f):\n#        @wraps(f)\n#        def DataLoader(*l, **kv):\n#            if \'pin_memory\' in kv:\n#                kv.pop(\'pin_memory\')\n#            r = f(*l, **kv)\n#            return r\n#        return DataLoader\n    \n    class DataLoaderForCPU(rawDataLoader):\n        def __init__(self, *l, **kv):\n            rawDataLoader.__init__(self, *l, **kv)\n            self.pin_memory = False\n        \n    th.utils.data.DataLoader = DataLoaderForCPU\n    \n    rawThLoad = torch.load\n    def torchLoad(*l, **kv):\n        return rawThLoad(*l,**(kv.update({\'map_location\':\'cpu\'}) or kv))\n    torch.load = torchLoad\n\n            \n    nn.Module.load_state_dict = tryLoad\n    torch.nn.modules.module.Module.load_state_dict = tryLoad\n\nusecpu = (not cuda and usecuda==\'auto\') or not usecuda\nif usecpu:\n    toCpu()\n_TensorBase = torch._TensorBase if \'_TensorBase\' in dir(torch) else torch._C._TensorBase\n\ndef tht(t):\n    \'\'\'\n    anything t to torch.Tensor\n    \'\'\'\n    if not isinstance(t, _TensorBase):\n        t = th.from_numpy(npa-t).cuda()\n    return t.cuda()\ntht = FunAddMagicMethod(tht)\n\n#t = tht(r).float()\nt = th.from_numpy(r).float()\nif cuda:\n    t = t.cuda()\n\ndef recursive_func(func):\n    def inner_func(batch, device=None):\n        if isinstance(batch, dict):\n            return {k:inner_func(v) for k,v in batch.items()}\n        elif isinstance(batch, (list,tuple)):\n            return type(batch)([inner_func(x) for x in batch])\n        else:\n            return func(batch, device=device)\n    \n    return inner_func\n    \ndef to_tensor(x, device=None): \n    if isinstance(x, np.ndarray):\n        x = torch.from_numpy(x)\n    if isinstance(x, torch.Tensor):\n        x = x.cuda() if device is None else x.to(device)\n    return x\n\nbatch_to_tensor = recursive_func(to_tensor)\n\ndef to_numpy(x, device=None): \n    if isinstance(x, torch.Tensor):\n        x = x.cpu().numpy()\n    return x\n\nbatch_to_numpy = recursive_func(to_numpy)\n    \n\ndef batchToTensor(batch, device=None):\n    \'\'\'\n    turn a dataloader\'s batch to tensor (from dpflow).\n    support dict, list, tuple as a batch\n    \'\'\'\n    def to_tensor(x): \n        if isinstance(x, np.ndarray):\n            x = torch.from_numpy(x)\n        if isinstance(x, torch.Tensor):\n            x = x.cuda() if device is None else x.to(device)\n        return x\n    if isinstance(batch, dict):\n        return {\n            k: to_tensor(v)  for k, v in batch.items()\n        }\n    if isinstance(batch, (list, tuple)):\n        return [to_tensor(v) for v in batch]\n\ndef batchToNumpy(batch):\n    \'\'\'\n    turn a dataloader\'s batch to numpy (for dpflow).\n    support dict, list, tuple as a batch\n    \'\'\'\n    if isinstance(batch, dict):\n        return {k: (v.cpu()).numpy() if isinstance(v, torch.Tensor) else v   for k,v in batch.items()}\n    if isinstance(batch, (list,tuple)):\n        return [(v.cpu()).numpy() if isinstance(v, torch.Tensor) else v   for v in batch]\n\n\n@wraps(torch.autograd.Variable)\ndef var(t, *l,  **kv):\n    t = tht(t)\n    t = Variable(t, *l, **kv)\n    return t.cuda()\nvar = FunAddMagicMethod(var)\n\n\ndef kaimingInit(model):\n    stateDict = model.state_dict()\n    for key in stateDict:\n        tag = 0\n        t = stateDict[key]\n        \n        if (t.ndimension()==4 and t.shape[-1]>2) or \'conv\' in key:\n            nn.init.kaiming_normal(stateDict[key], mode=\'fan_out\')\n            tag = 1\n        elif \'bn\' in key and \'weight\' in key:\n            stateDict[key][...] = 1\n            tag = 1\n        elif \'bias\' in key :\n            stateDict[key][...] = 0\n            tag = 1\n        elif \'fc\' in key and t.ndimension()==2:\n            nn.init.kaiming_normal(t)\n\n\ndef getModelDefaultInputShape(model, group=None, ganNoise=False):\n    para = nextiter(model.parameters())\n    shape = para.shape\n    if len(shape) == 4 and shape[-1]>2 :\n        default = (shape[1], 244, 244)\n    elif len(shape) == 4 and shape[-1] == shape[-2] == 1  :\n        default = (shape[1], 244, 244)\n        if ganNoise:\n            default = (shape[1], 1, 1)\n    elif len(shape) == 2:\n        default = (shape[1],)\n    if group:\n        default = (shape[1]*group, 244, 244)\n    return default\n\ndef genModelInput(model, inputShape=None,group=None, ganNoise=False, batchn=2):\n    \'\'\'\n    Auto generate a Tensor that could as model\'s input\n    \n    Usage\n    -----\n    >>> inp = genModelInput(model)\n    >>> result = model(inp)\n    >>> tree(result)\n    \n    Parameters\n    ----------\n    model: nn.Module\n        nn.Module\n    inputShape: tuple or list, default None\n        By default, inputShape will auto calculate through model\'s first parameters \n    group: int, default None\n        If the first conv has is a group conv, please provide the group num\n    ganNoise: bool, default False\n        set True, if input is a 1dim vector of noise for GAN\n    batchn: int, default 2\n        batch number, consider the BatchNorma opr, default of batchn is 2\n    \'\'\'\n    inputShape = inputShape or getModelDefaultInputShape(model, group, ganNoise)\n    para = getpara(model)\n    inp = th.rand((batchn,)+inputShape, dtype=para.dtype, device=para.device)\n    if not ganNoise:\n        from skimage.data import astronaut\n        img = astronaut().mean(-1)/255.\n        mean = img.mean()\n        std = ((img-mean)**2).mean()**.5\n        normaed = (img-mean)/std\n        feat = nn.functional.interpolate(tht-[[normaed]], inputShape[-2:], mode=\'bilinear\',)\n        inp[:] = feat.to(para.device)\n    return inp\n\nclass HookRegister():\n    def __init__(self, module, hook, direct=\'f\'):\n        self.hook = hook\n        self.hooks = hooks = []\n        self.module = module\n        \n        def apply(module):\n            if direct == \'f\':\n                hooks.append(module.register_forward_hook(hook))\n            elif direct == \'b\':\n                hooks.append(module.register_backward_hook(hook))\n        module.apply(apply)\n    def remove(self):\n        for h in self.hooks:\n            h.remove()\n    def __enter__(self):\n        return self\n    def __exit__(self,*l):\n        self.remove()\ndef removeAllHook(module):\n    def apply(module):\n        module._forward_hooks=OrderedDict()\n    module.apply(apply)\n\nfrom boxx import log, ylimgTool, g\nar= FunAddMagicMethod(lambda x: log-ylimgTool.prettyArray(x))\n\ndef nanDete(t, globalg=False):\n    nan = th.isnan(t).sum()\n    if nan :\n        if globalg:\n            g(1)\n        ar(t)\n        raise LookupError(\'Has torch.nan\')\n\n\ndef getpara(m):\n    \'\'\'get first parameter\'\'\'\n    return nextiter(m.parameters())\n\ndef getpara0(m):\n    return getpara(m).view(-1)[0]\ndef getgrad(m):\n    return getpara(m).grad\ndef getgrad0(m):\n    grad = getpara(m).grad\n    return None if grad is None else grad.view(-1)[0]\ngetpara, getpara0, getgrad, getgrad0 = map(FunAddMagicMethod, [getpara, getpara0, getgrad, getgrad0])\n\ndef get_loss(model_output):\n    if isinstance(model_output, (list, tuple)):\n        loss = sum([i.sum() for i in model_output])\n        return loss\n    if isinstance(model_output, dict):\n        loss = sum([i.sum() for i in model_output.values()])\n        return loss\n    return model_output.sum()\n\ndef vizmodel(m, inputShape=None,group=None, ganNoise=False, batchn=2, output=""""):\n    x = genModelInput(m, inputShape=inputShape,group=group, ganNoise=ganNoise, batchn=batchn)\n    from torchviz import make_dot\n    x.to(getpara(m))\n    model_output = m(x)\n    loss = get_loss(model_output)\n    graph = make_dot(loss, params=dict(m.named_parameters()))\n    if output:\n        graph.render(output, format=\'png\')\n    return graph\n\ndef flatten(t, dim=-1):\n    \'\'\'\n    >>> t = shape(1,2,3,4) \n    >>> flatten(t, dim=-2)\n    shape(1,6,4)\n    \'\'\'\n    shape = list(t.shape)\n    shape[dim-1] *= shape[dim]\n    shape.pop(dim)\n    return t.reshape(tuple(shape))\n\n\ndef hasnan(tensor):\n    return not bool(torch.isfinite(tensor).all())\n\ndef pthnan(pth=\'/home/dl/github/maskrcnn/output/mix_11/model_final.pth\'):\n    dic = torch.load(pth)\n    from collections import OrderedDict\n    \n    def getOrderedDict(seq):\n        if isinstance(seq, OrderedDict):\n            return seq\n        if isinstance(seq, dict):\n            seq = list(seq.values())\n        if not isinstance(seq, (tuple, list)):\n            return None\n        for s in seq:\n            re = getOrderedDict(s)\n            if re is not None:\n                return re\n    od = getOrderedDict(dic)\n    tensor = list(od.values())[-1]\n    print(\'""%s""has nan: %s\'%(tensor[...,:10], hasnan(tensor)))\n\nif __name__ == \'__main__\':\n    l = [\'LongTensor\',\n     \'DoubleTensor\',\n     \'IntTensor\',\n     \'ShortTensor\',\n     \'ByteTensor\',\n     \'HalfTensor\',\n     \'CharTensor\',\n     \'FloatTensor\']\n    formatt = \'th.cuda.%s = th.%s\'\n    print(\'\\n\'.join([formatt%(i,i) for i in l]))\n\n        \n    \n'"
boxx/ylth/pthnan.py,1,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n""""""\n@author: DIYer22@github\n@mail: ylxx@live.com\nCreated on Fri Feb 15 20:20:59 2019\n""""""\nfrom . import torch, hasnan\n\n\ndef pthnan(pth):\n    dic = torch.load(pth, map_location=\'cpu\')\n    from collections import OrderedDict\n    \n    def getOrderedDict(seq):\n        if isinstance(seq, OrderedDict):\n            return seq\n        if isinstance(seq, dict):\n            seq = list(seq.values())\n        if not isinstance(seq, (tuple, list)):\n            return None\n        for s in seq:\n            re = getOrderedDict(s)\n            if re is not None:\n                return re\n    od = getOrderedDict(dic)\n    tensor = list(od.values())[-1]\n    print(\'\\n""%s""\\n\\nHas nan: %s\\n\'%(\'\\x1b[36m%s\\x1b[0m\'%tensor[...,:10], \'\\x1b[31m%s\\x1b[0m\'%hasnan(tensor)))\n\n\nif __name__ == ""__main__"":\n    import argparse\n    \n    parser = argparse.ArgumentParser(description=""""""\n    detect a pth file ""Does it has nan?"" """""")\n    parser.add_argument(\'pth\', default=\'/home/dl/github/maskrcnn/output/mix_11/model_final.pth\', type=str)\n    args = parser.parse_args()\n    \n    pthnan(pth=args.pth)\n    \n'"
other/gif/g.py,0,"b'from boxx import g, gg\ndef f():\n    listt = g.by_div/[1,2]  # transport listt to console\n    gg.l = listt\n    return listt\nlistt = f()\n\n\n\n\n'"
other/gif/g_call.py,0,"b'\ndef f(arg=517):\n    l = [1,2]\n    import boxx.gg # gg is same as g, but gg will \n    # print all vars in f\nf()\n\n\n\n'"
other/gif/loga.py,0,"b'import numpy as np\narray = np.random.normal(size=(4,3, 244, 244))\n\n# I want to know every thing about `array`\n\narray[0] = np.inf\narray[1] = np.nan\n\n'"
other/gif/mapmp.py,0,"b""def bad_fibonacci(x): # simulation Complex calculations\n    return x<=1 or x*bad_fibonacci(x-1)\n\nxs = [800]*10000\n\nfrom boxx import mapmp\nfrom boxx import timeit # for timing\nwith timeit('map'):\n    resoult = map(bad_fibonacci, xs, )\n    resoult = list(resoult)\n\n#Note: I test this code on i5 CPU"""
other/gif/p.py,0,"b'from random import randint\nfrom boxx import p\ns = \'ABCD\'\nsample = s[p/randint(0, 3)] \n# print the output of randint(0, 3)\np-(\'sample is ""%s""\'%sample)\n'"
other/gif/show.py,0,"b""\nimport numpy as np\nfrom skimage.io import imread\n\nimg = imread('../../test/imgForTest/Lenna.jpg')\n\nfrom boxx import show\nshow(img)\nimgs = np.array([img, img, img])\nshow(imgs)\ncomplex_struct = [dict(img=img, imgs=imgs)]\nshow(complex_struct)\n\nfrom torch_data import dataloader\ndataloader\nshow(dataloader)\n\n\n\nfrom boxx import loga, torgb\n# torgb is a function that \n# try to transfer a tensor to normalized RGB image\nbatch = next(iter(dataloader))[0]\nloga(batch)\nloga-torgb(batch)\n\nshow(dataloader, torgb)"""
other/gif/torch_data.py,4,"b'# -*- coding: utf-8 -*-\n""""""\ncode and data from:\n    [PyTorch Transfer Learning tutorial](https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html)\n\nDownload the data from\n    `here <https://download.pytorch.org/tutorial/hymenoptera_data.zip>`_\n    and extract it to the current directory.\n""""""\nimport os\nimport torch\nfrom torchvision import datasets, transforms\n\ndata_transforms = {\n    \'train\': transforms.Compose([\n        transforms.RandomResizedCrop(224),\n        transforms.RandomHorizontalFlip(),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n    ]),\n    \'val\': transforms.Compose([\n        transforms.Resize(256),\n        transforms.CenterCrop(224),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n    ]),\n}\n\ndata_dir = \'hymenoptera_data\'\ndata_dir = \'/home/yanglei/tutorial/pytorch/hymenoptera_data\'\n\nimage_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),\n                                          data_transforms[x])\n                  for x in [\'train\', \'val\']}\ndataloaders = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=2,\n                                             shuffle=True, num_workers=0)\n              for x in [\'train\', \'val\']}\ndataset_sizes = {x: len(image_datasets[x]) for x in [\'train\', \'val\']}\nclass_names = image_datasets[\'train\'].classes\n\nuse_gpu = torch.cuda.is_available()\n\n\ndataset = image_datasets[\'train\']\ndataloader = dataloaders[\'train\']\n\nif __name__ == \'__main__\':\n    from boxx.ylth import *\n    from boxx import tree, show\n    tree - dataloaders\n    show - dataloaders\n\n    from boxx import torgb\n    show(image_datasets, torgb)\n'"
other/gif/tree.py,1,"b""from skimage.io import imread\nimg = imread('../../test/imgForTest/Lenna.jpg')\n\nimport torch\ntensor = torch.rand((5, 1, 7))\ncomplex_struct = {\n    'str':'this is string! ^_^',\n    'list':['img', img],\n    'batch':{\n        'tensor':tensor,\n        'label':1,\n            },\n    'tuple_of_torch':tuple(tensor[0,0]),\n        }\n"""
other/gif/w.py,0,"b'from boxx import gg\nfrom random import randint\ndef f():\n    other_vars = ""No need to pay attention""\n    with gg:\n        a = randint(1, 9)\n        l = [a, a*2]\n    \n    others = ""No need to pay attention"" \nf()\n\n# I want to transport and print `a` and `l` in f\n\n'"
