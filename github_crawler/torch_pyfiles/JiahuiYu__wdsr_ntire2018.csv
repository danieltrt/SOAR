file_path,api_count,code
wdsr_a.py,4,"b'import math\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn.parameter import Parameter\n\nclass Block(nn.Module):\n    def __init__(\n        self, n_feats, kernel_size, block_feats, wn, res_scale=1, act=nn.ReLU(True)):\n        super(Block, self).__init__()\n        self.res_scale = res_scale\n        body = []\n        body.append(\n            wn(nn.Conv2d(n_feats, block_feats, kernel_size, padding=kernel_size//2)))\n        body.append(act)\n        body.append(\n            wn(nn.Conv2d(block_feats, n_feats, kernel_size, padding=kernel_size//2)))\n\n        self.body = nn.Sequential(*body)\n\n    def forward(self, x):\n        res = self.body(x) * self.res_scale\n        res += x\n        return res\n\nclass MODEL(nn.Module):\n    def __init__(self, args):\n        super(MODEL, self).__init__()\n        # hyper-params\n        self.args = args\n        scale = args.scale[0]\n        n_resblocks = args.n_resblocks\n        n_feats = args.n_feats\n        kernel_size = 3\n        act = nn.ReLU(True)\n        # wn = lambda x: x\n        wn = lambda x: torch.nn.utils.weight_norm(x)\n\n        self.rgb_mean = torch.autograd.Variable(torch.FloatTensor(\n            [args.r_mean, args.g_mean, args.b_mean])).view([1, 3, 1, 1])\n\n        # define head module\n        head = []\n        head.append(\n            wn(nn.Conv2d(args.n_colors, n_feats, 3, padding=3//2)))\n\n        # define body module\n        body = []\n        for i in range(n_resblocks):\n            body.append(\n                Block(n_feats, kernel_size, args.block_feats, wn=wn, res_scale=args.res_scale, act=act))\n\n        # define tail module\n        tail = []\n        out_feats = scale*scale*args.n_colors\n        tail.append(\n            wn(nn.Conv2d(n_feats, out_feats, 3, padding=3//2)))\n        tail.append(nn.PixelShuffle(scale))\n\n        skip = []\n        skip.append(\n            wn(nn.Conv2d(args.n_colors, out_feats, 5, padding=5//2))\n        )\n        skip.append(nn.PixelShuffle(scale))\n\n        # make object members\n        self.head = nn.Sequential(*head)\n        self.body = nn.Sequential(*body)\n        self.tail = nn.Sequential(*tail)\n        self.skip = nn.Sequential(*skip)\n\n    def forward(self, x):\n        x = (x - self.rgb_mean.cuda()*255)/127.5\n        s = self.skip(x)\n        x = self.head(x)\n        x = self.body(x)\n        x = self.tail(x)\n        x += s\n        x = x*127.5 + self.rgb_mean.cuda()*255\n        return x\n'"
wdsr_b.py,4,"b'import math\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn.parameter import Parameter\n\nclass Block(nn.Module):\n    def __init__(\n        self, n_feats, kernel_size, wn, act=nn.ReLU(True), res_scale=1):\n        super(Block, self).__init__()\n        self.res_scale = res_scale\n        body = []\n        expand = 6\n        linear = 0.8\n        body.append(\n            wn(nn.Conv2d(n_feats, n_feats*expand, 1, padding=1//2)))\n        body.append(act)\n        body.append(\n            wn(nn.Conv2d(n_feats*expand, int(n_feats*linear), 1, padding=1//2)))\n        body.append(\n            wn(nn.Conv2d(int(n_feats*linear), n_feats, kernel_size, padding=kernel_size//2)))\n\n        self.body = nn.Sequential(*body)\n\n    def forward(self, x):\n        res = self.body(x) * self.res_scale\n        res += x\n        return res\n\nclass MODEL(nn.Module):\n    def __init__(self, args):\n        super(MODEL, self).__init__()\n        # hyper-params\n        self.args = args\n        scale = args.scale[0]\n        n_resblocks = args.n_resblocks\n        n_feats = args.n_feats\n        kernel_size = 3\n        act = nn.ReLU(True)\n        # wn = lambda x: x\n        wn = lambda x: torch.nn.utils.weight_norm(x)\n\n        self.rgb_mean = torch.autograd.Variable(torch.FloatTensor(\n            [args.r_mean, args.g_mean, args.b_mean])).view([1, 3, 1, 1])\n\n        # define head module\n        head = []\n        head.append(\n            wn(nn.Conv2d(args.n_colors, n_feats, 3, padding=3//2)))\n\n        # define body module\n        body = []\n        for i in range(n_resblocks):\n            body.append(\n                Block(n_feats, kernel_size, act=act, res_scale=args.res_scale, wn=wn))\n\n        # define tail module\n        tail = []\n        out_feats = scale*scale*args.n_colors\n        tail.append(\n            wn(nn.Conv2d(n_feats, out_feats, 3, padding=3//2)))\n        tail.append(nn.PixelShuffle(scale))\n\n        skip = []\n        skip.append(\n            wn(nn.Conv2d(args.n_colors, out_feats, 5, padding=5//2))\n        )\n        skip.append(nn.PixelShuffle(scale))\n\n        # make object members\n        self.head = nn.Sequential(*head)\n        self.body = nn.Sequential(*body)\n        self.tail = nn.Sequential(*tail)\n        self.skip = nn.Sequential(*skip)\n\n    def forward(self, x):\n        x = (x - self.rgb_mean.cuda()*255)/127.5\n        s = self.skip(x)\n        x = self.head(x)\n        x = self.body(x)\n        x = self.tail(x)\n        x += s\n        x = x*127.5 + self.rgb_mean.cuda()*255\n        return x\n'"
