file_path,api_count,code
launch_gym_server.py,0,"b'#!/usr/bin/env python\n""""""\nPytorch-cpp-rl OpenAI gym server main script.\n""""""\nimport logging\n\nfrom gym_server.server import Server\nfrom gym_server.zmq_client import ZmqClient\n\n\ndef main():\n    """"""\n    Host the server.\n    """"""\n    # If anything is logged during imports, it messes up our logging so we\n    # reset the logging module here\n    root_logger = logging.getLogger()\n    if root_logger.handlers:\n        for handler in root_logger.handlers:\n            root_logger.removeHandler(handler)\n    logging.basicConfig(level=logging.DEBUG,\n                        format=(\'%(asctime)s %(funcName)s \'\n                                \'[%(levelname)s]: %(message)s\'),\n                        datefmt=\'%Y%m%d %H:%M:%S\')\n    logging.info(""Initializing gym server"")\n\n    zmq_client = ZmqClient(10201)\n    logging.info(""Connecting to client"")\n    zmq_client.send(""Connection established"")\n    logging.info(""Connected"")\n    server = Server(zmq_client)\n\n    try:\n        server.serve()\n    except:  # pylint: disable=bare-except\n        import pdb\n        pdb.post_mortem()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
gym_server/__init__.py,0,b''
gym_server/envs.py,0,"b'""""""\nAdapted from:\ngithub.com/ikostrikov/pytorch-a2c-ppo-acktr/blob/master/a2c_ppo_acktr/envs.py\n\nProvides utility functions for making Gym environments.\n""""""\nimport gym\nfrom gym.spaces import Box\nimport numpy as np\n\nfrom baselines.common.vec_env import VecEnvWrapper\nfrom baselines.common.atari_wrappers import make_atari, wrap_deepmind\nfrom baselines.common.vec_env.subproc_vec_env import SubprocVecEnv\nfrom baselines.common.vec_env.dummy_vec_env import DummyVecEnv\nfrom baselines.common.vec_env.vec_normalize import (VecNormalize\n                                                    as VecNormalize_)\n\n\nclass TransposeImage(gym.ObservationWrapper):\n    def __init__(self, env=None):\n        super(TransposeImage, self).__init__(env)\n        obs_shape = self.observation_space.shape\n        self.observation_space = Box(\n            self.observation_space.low[0, 0, 0],\n            self.observation_space.high[0, 0, 0],\n            [obs_shape[2], obs_shape[1], obs_shape[0]],\n            dtype=self.observation_space.dtype)\n\n    def observation(self, observation):\n        return observation.transpose(2, 0, 1)\n\n\nclass VecFrameStack(VecEnvWrapper):\n    def __init__(self, venv, nstack):\n        self.venv = venv\n        self.nstack = nstack\n        wos = venv.observation_space  # wrapped ob space\n        low = np.repeat(wos.low, self.nstack, axis=0)\n        high = np.repeat(wos.high, self.nstack, axis=0)\n        self.stackedobs = np.zeros((venv.num_envs,) + low.shape, low.dtype)\n        observation_space = gym.spaces.Box(\n            low=low, high=high, dtype=venv.observation_space.dtype)\n        VecEnvWrapper.__init__(self, venv, observation_space=observation_space)\n\n    def step_wait(self):\n        obs, rews, news, infos = self.venv.step_wait()\n        self.stackedobs = np.roll(self.stackedobs, shift=-1, axis=0)\n        for (i, new) in enumerate(news):\n            if new:\n                self.stackedobs[i] = 0\n        self.stackedobs[..., -obs.shape[-1]:] = obs\n        return self.stackedobs, rews, news, infos\n\n    def reset(self):\n        obs = self.venv.reset()\n        self.stackedobs[...] = 0\n        self.stackedobs[-obs.shape[-1]:, ...] = obs\n        return self.stackedobs\n\n\nclass VecRewardInfo(VecEnvWrapper):\n    def __init__(self, venv):\n        self.venv = venv\n        VecEnvWrapper.__init__(self, venv)\n\n    def step_wait(self):\n        obs, rews, news, infos = self.venv.step_wait()\n        infos = {\'reward\': np.expand_dims(rews, -1)}\n        return obs, rews, news, infos\n\n    def reset(self):\n        obs = self.venv.reset()\n        return obs\n\n\nclass VecNormalize(VecNormalize_):\n    def __init__(self, *args, **kwargs):\n        super(VecNormalize, self).__init__(*args, **kwargs)\n        self.training = True\n\n    def _obfilt(self, obs):\n        if self.ob_rms:\n            if self.training:\n                self.ob_rms.update(obs)\n            obs = np.clip((obs - self.ob_rms.mean)\n                          / np.sqrt(self.ob_rms.var + self.epsilon),\n                          -self.clipob, self.clipob)\n        return obs\n\n    def train(self):\n        self.training = True\n\n    def eval(self):\n        self.training = False\n\n    def step_wait(self):\n        obs, rews, news, infos = self.venv.step_wait()\n        infos = {\'reward\': np.expand_dims(rews, -1)}\n        self.ret = self.ret * self.gamma + rews\n        obs = self._obfilt(obs)\n        if self.ret_rms:\n            self.ret_rms.update(self.ret)\n            rews = np.clip(rews / np.sqrt(self.ret_rms.var + self.epsilon),\n                           -self.cliprew,\n                           self.cliprew)\n        self.ret[news] = 0.\n        return obs, rews, news, infos\n\n\ndef make_env(env_id, seed, rank):\n    def _thunk():\n        env = gym.make(env_id)\n\n        is_atari = hasattr(gym.envs, \'atari\') and isinstance(\n            env.unwrapped, gym.envs.atari.atari_env.AtariEnv)\n        if is_atari:\n            env = make_atari(env_id)\n\n        env.seed(seed + rank)\n\n        obs_shape = env.observation_space.shape\n\n        if is_atari:\n            if len(env.observation_space.shape) == 3:\n                env = wrap_deepmind(env)\n        elif len(env.observation_space.shape) == 3:\n            raise NotImplementedError(""CNN models work only for atari,\\n""\n                                      ""please use a custom wrapper for a ""\n                                      ""custom pixel input env.\\n See ""\n                                      ""wrap_deepmind for an example."")\n\n        # If the input has shape (W,H,3), wrap for PyTorch convolutions\n        obs_shape = env.observation_space.shape\n        if len(obs_shape) == 3 and obs_shape[2] in [1, 3]:\n            env = TransposeImage(env)\n\n        return env\n    return _thunk\n\n\ndef make_vec_envs(env_name, seed, num_processes, num_frame_stack=None):\n    envs = [make_env(env_name, seed, i) for i in range(num_processes)]\n\n    if len(envs) > 1:\n        envs = SubprocVecEnv(envs)\n    else:\n        envs = DummyVecEnv(envs)\n\n    envs = VecRewardInfo(envs)\n\n    if num_frame_stack is not None:\n        envs = VecFrameStack(envs, num_frame_stack)\n    elif len(envs.observation_space.shape) == 3:\n        envs = VecFrameStack(envs, 4)\n\n    return envs\n'"
gym_server/messages.py,0,"b'""""""\nClasses for building requests to send to pytorch-cpp-rl.\n""""""\nfrom abc import ABC, abstractmethod\nimport numpy as np\nimport msgpack\n\n\nclass Message(ABC):\n    """"""\n    Base class for messages.\n    """"""\n    @abstractmethod\n    def to_msg(self) -> bytes:\n        """"""\n        Creates the JSON for the request.\n        """"""\n\n\nclass InfoMessage(Message):\n    """"""\n    Builds the JSON for returning the result of an info() action.\n    """"""\n\n    def __init__(self, action_space_type, action_space_shape,\n                 observation_space_type, observation_space_shape):\n        self.action_space_type = action_space_type\n        self.action_space_shape = action_space_shape\n        self.observation_space_type = observation_space_type\n        self.observation_space_shape = observation_space_shape\n\n    def to_msg(self) -> bytes:\n        request = {\n            ""action_space_type"": self.action_space_type,\n            ""action_space_shape"": self.action_space_shape,\n            ""observation_space_type"": self.observation_space_type,\n            ""observation_space_shape"": self.observation_space_shape\n        }\n        return msgpack.packb(request)\n\n\nclass MakeMessage(Message):\n    """"""\n    Builds the JSON for returning the result of an make_env() action.\n    """"""\n\n    def to_msg(self) -> bytes:\n        request = {\n            ""result"": ""OK""\n        }\n        return msgpack.packb(request)\n\n\nclass ResetMessage(Message):\n    """"""\n    Builds the JSON for returning the result of an env.reset() action.\n    """"""\n\n    def __init__(self, observation: np.ndarray):\n        self.observation = observation\n\n    def to_msg(self) -> bytes:\n        request = {\n            ""observation"": self.observation.tolist()\n        }\n        return msgpack.packb(request)\n\n\nclass StepMessage(Message):\n    """"""\n    Builds the JSON for returning the result of an env.step() action.\n    """"""\n\n    def __init__(self,\n                 observation: np.ndarray,\n                 reward: np.ndarray,\n                 done: np.ndarray,\n                 real_reward: np.ndarray):\n        self.observation = observation\n        self.reward = reward\n        self.done = done\n        self.real_reward = real_reward\n\n    def to_msg(self) -> bytes:\n        request = {\n            ""observation"": self.observation.tolist(),\n            ""reward"": self.reward.tolist(),\n            ""done"": self.done.tolist(),\n            ""real_reward"": self.real_reward.tolist()\n        }\n        return msgpack.packb(request)\n'"
gym_server/server.py,0,"b'""""""\nContains a class that trains an agent.\n""""""\nimport logging\nfrom typing import Tuple\nimport numpy as np\nimport gym\n\nfrom gym_server.envs import make_vec_envs\nfrom gym_server.messages import (InfoMessage, MakeMessage, ResetMessage,\n                                 StepMessage)\nfrom gym_server.zmq_client import ZmqClient\n\n\nRUNNING_REWARD_HORIZON = 10\n\n\nclass Server:\n    """"""\n    When `Server.serve()` is called, provides a ZMQ based API for training\n    RL agents on OpenAI gym environments.\n    """"""\n\n    def __init__(self, zmq_client: ZmqClient):\n        self.zmq_client: ZmqClient = zmq_client\n        self.env: gym.Env = None\n        logging.info(""Gym server initialized"")\n\n    def serve(self):\n        """"""\n        Run the server.\n        """"""\n        logging.info(""Serving"")\n        try:\n            self.__serve()\n        except KeyboardInterrupt:\n            pass\n\n    def _serve(self):\n        while True:\n            request = self.zmq_client.receive()\n            method = request[\'method\']\n            param = request[\'param\']\n\n            if method == \'info\':\n                (action_space_type,\n                 action_space_shape,\n                 observation_space_type,\n                 observation_space_shape) = self.__info()\n                self.zmq_client.send(InfoMessage(action_space_type,\n                                                 action_space_shape,\n                                                 observation_space_type,\n                                                 observation_space_shape))\n\n            elif method == \'make\':\n                self.__make(param[\'env_name\'], param[\'num_envs\'])\n                self.zmq_client.send(MakeMessage())\n\n            elif method == \'reset\':\n                observation = self.__reset()\n                self.zmq_client.send(ResetMessage(observation))\n\n            elif method == \'step\':\n                if \'render\' in param:\n                    result = self.__step(\n                        np.array(param[\'actions\']), param[\'render\'])\n                else:\n                    result = self.__step(np.array(param[\'actions\']))\n                self.zmq_client.send(StepMessage(result[0],\n                                                 result[1],\n                                                 result[2],\n                                                 result[3][\'reward\']))\n\n    def info(self):\n        """"""\n        Return info about the currently loaded environment\n        """"""\n        action_space_type = self.env.action_space.__class__.__name__\n        if action_space_type == \'Discrete\':\n            action_space_shape = [self.env.action_space.n]\n        else:\n            action_space_shape = self.env.action_space.shape\n        observation_space_type = self.env.observation_space.__class__.__name__\n        observation_space_shape = self.env.observation_space.shape\n        return (action_space_type, action_space_shape, observation_space_type,\n                observation_space_shape)\n\n    def make(self, env_name, num_envs):\n        """"""\n        Makes a vectorized environment of the type and number specified.\n        """"""\n        logging.info(""Making %d %ss"", num_envs, env_name)\n        self.env = make_vec_envs(env_name, 0, num_envs)\n\n    def reset(self) -> np.ndarray:\n        """"""\n        Resets the environments.\n        """"""\n        logging.info(""Resetting environments"")\n        return self.env.reset()\n\n    def step(self,\n             actions: np.ndarray,\n             render: bool = False) -> Tuple[np.ndarray, np.ndarray,\n                                            np.ndarray, np.ndarray]:\n        """"""\n        Steps the environments.\n        """"""\n        if isinstance(self.env.action_space, gym.spaces.Discrete):\n            actions = actions.squeeze(-1)\n            actions = actions.astype(np.int)\n        observation, reward, done, info = self.env.step(actions)\n        reward = np.expand_dims(reward, -1)\n        done = np.expand_dims(done, -1)\n        if render:\n            self.env.render()\n        return observation, reward, done, info\n\n    __info = info\n    __make = make\n    __reset = reset\n    __serve = _serve\n    __step = step\n'"
gym_server/zmq_client.py,0,"b'""""""\nPytorch-cpp-rl OpenAI gym server ZMQ client.\n""""""\nimport zmq\nimport msgpack\n\n\nclass ZmqClient:\n    """"""\n    Provides a ZeroMQ interface for communicating with client.\n    """"""\n\n    def __init__(self, port: int):\n        context = zmq.Context()\n        self.socket = context.socket(zmq.PAIR)\n        self.socket.bind(f""tcp://*:{port}"")\n\n    def receive(self) -> bytes:\n        """"""\n        Gets a message from the client.\n        Blocks until a message is received.\n        """"""\n        message = self.socket.recv()\n        try:\n            response = msgpack.unpackb(message, raw=False)\n        except msgpack.exceptions.ExtraData:\n            response = message\n        return response\n\n    def send(self, message: object):\n        """"""\n        Sends a message to the client.\n        """"""\n        if isinstance(message, str):\n            self.socket.send_string(message)\n        else:\n            self.socket.send(message.to_msg())\n'"
