file_path,api_count,code
max_ssim.py,4,"b'import pytorch_ssim\nimport torch\nfrom torch.autograd import Variable\nfrom torch import optim\nimport cv2\nimport numpy as np\n\nnpImg1 = cv2.imread(""einstein.png"")\n\nimg1 = torch.from_numpy(np.rollaxis(npImg1, 2)).float().unsqueeze(0)/255.0\nimg2 = torch.rand(img1.size())\n\nif torch.cuda.is_available():\n    img1 = img1.cuda()\n    img2 = img2.cuda()\n\n\nimg1 = Variable( img1,  requires_grad=False)\nimg2 = Variable( img2, requires_grad = True)\n\n\n# Functional: pytorch_ssim.ssim(img1, img2, window_size = 11, size_average = True)\nssim_value = pytorch_ssim.ssim(img1, img2).data[0]\nprint(""Initial ssim:"", ssim_value)\n\n# Module: pytorch_ssim.SSIM(window_size = 11, size_average = True)\nssim_loss = pytorch_ssim.SSIM()\n\noptimizer = optim.Adam([img2], lr=0.01)\n\nwhile ssim_value < 0.95:\n    optimizer.zero_grad()\n    ssim_out = -ssim_loss(img1, img2)\n    ssim_value = - ssim_out.data[0]\n    print(ssim_value)\n    ssim_out.backward()\n    optimizer.step()\n'"
setup.py,0,"b""from distutils.core import setup\nsetup(\n  name = 'pytorch_ssim',\n  packages = ['pytorch_ssim'], # this must be the same as the name above\n  version = '0.1',\n  description = 'Differentiable structural similarity (SSIM) index',\n  author = 'Po-Hsun (Evan) Su',\n  author_email = 'evan.pohsun.su@gmail.com',\n  url = 'https://github.com/Po-Hsun-Su/pytorch-ssim', # use the URL to the github repo\n  download_url = 'https://github.com/Po-Hsun-Su/pytorch-ssim/archive/0.1.tar.gz', # I'll explain this in a second\n  keywords = ['pytorch', 'image-processing', 'deep-learning'], # arbitrary keywords\n  classifiers = [],\n)\n"""
pytorch_ssim/__init__.py,4,"b'import torch\nimport torch.nn.functional as F\nfrom torch.autograd import Variable\nimport numpy as np\nfrom math import exp\n\ndef gaussian(window_size, sigma):\n    gauss = torch.Tensor([exp(-(x - window_size//2)**2/float(2*sigma**2)) for x in range(window_size)])\n    return gauss/gauss.sum()\n\ndef create_window(window_size, channel):\n    _1D_window = gaussian(window_size, 1.5).unsqueeze(1)\n    _2D_window = _1D_window.mm(_1D_window.t()).float().unsqueeze(0).unsqueeze(0)\n    window = Variable(_2D_window.expand(channel, 1, window_size, window_size).contiguous())\n    return window\n\ndef _ssim(img1, img2, window, window_size, channel, size_average = True):\n    mu1 = F.conv2d(img1, window, padding = window_size//2, groups = channel)\n    mu2 = F.conv2d(img2, window, padding = window_size//2, groups = channel)\n\n    mu1_sq = mu1.pow(2)\n    mu2_sq = mu2.pow(2)\n    mu1_mu2 = mu1*mu2\n\n    sigma1_sq = F.conv2d(img1*img1, window, padding = window_size//2, groups = channel) - mu1_sq\n    sigma2_sq = F.conv2d(img2*img2, window, padding = window_size//2, groups = channel) - mu2_sq\n    sigma12 = F.conv2d(img1*img2, window, padding = window_size//2, groups = channel) - mu1_mu2\n\n    C1 = 0.01**2\n    C2 = 0.03**2\n\n    ssim_map = ((2*mu1_mu2 + C1)*(2*sigma12 + C2))/((mu1_sq + mu2_sq + C1)*(sigma1_sq + sigma2_sq + C2))\n\n    if size_average:\n        return ssim_map.mean()\n    else:\n        return ssim_map.mean(1).mean(1).mean(1)\n\nclass SSIM(torch.nn.Module):\n    def __init__(self, window_size = 11, size_average = True):\n        super(SSIM, self).__init__()\n        self.window_size = window_size\n        self.size_average = size_average\n        self.channel = 1\n        self.window = create_window(window_size, self.channel)\n\n    def forward(self, img1, img2):\n        (_, channel, _, _) = img1.size()\n\n        if channel == self.channel and self.window.data.type() == img1.data.type():\n            window = self.window\n        else:\n            window = create_window(self.window_size, channel)\n            \n            if img1.is_cuda:\n                window = window.cuda(img1.get_device())\n            window = window.type_as(img1)\n            \n            self.window = window\n            self.channel = channel\n\n\n        return _ssim(img1, img2, window, self.window_size, channel, self.size_average)\n\ndef ssim(img1, img2, window_size = 11, size_average = True):\n    (_, channel, _, _) = img1.size()\n    window = create_window(window_size, channel)\n    \n    if img1.is_cuda:\n        window = window.cuda(img1.get_device())\n    window = window.type_as(img1)\n    \n    return _ssim(img1, img2, window, window_size, channel, size_average)\n'"
