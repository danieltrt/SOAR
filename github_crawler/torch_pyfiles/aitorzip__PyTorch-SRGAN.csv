file_path,api_count,code
models.py,3,"b'# -*- coding: utf-8 -*-\n""""""Implements SRGAN models: https://arxiv.org/abs/1609.04802\n\nTODO:\n\n""""""\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.autograd import Variable\n\ndef swish(x):\n    return x * F.sigmoid(x)\n\nclass FeatureExtractor(nn.Module):\n    def __init__(self, cnn, feature_layer=11):\n        super(FeatureExtractor, self).__init__()\n        self.features = nn.Sequential(*list(cnn.features.children())[:(feature_layer+1)])\n\n    def forward(self, x):\n        return self.features(x)\n\n\nclass residualBlock(nn.Module):\n    def __init__(self, in_channels=64, k=3, n=64, s=1):\n        super(residualBlock, self).__init__()\n\n        self.conv1 = nn.Conv2d(in_channels, n, k, stride=s, padding=1)\n        self.bn1 = nn.BatchNorm2d(n)\n        self.conv2 = nn.Conv2d(n, n, k, stride=s, padding=1)\n        self.bn2 = nn.BatchNorm2d(n)\n\n    def forward(self, x):\n        y = swish(self.bn1(self.conv1(x)))\n        return self.bn2(self.conv2(y)) + x\n\nclass upsampleBlock(nn.Module):\n    # Implements resize-convolution\n    def __init__(self, in_channels, out_channels):\n        super(upsampleBlock, self).__init__()\n        self.conv = nn.Conv2d(in_channels, out_channels, 3, stride=1, padding=1)\n        self.shuffler = nn.PixelShuffle(2)\n\n    def forward(self, x):\n        return swish(self.shuffler(self.conv(x)))\n\nclass Generator(nn.Module):\n    def __init__(self, n_residual_blocks, upsample_factor):\n        super(Generator, self).__init__()\n        self.n_residual_blocks = n_residual_blocks\n        self.upsample_factor = upsample_factor\n\n        self.conv1 = nn.Conv2d(3, 64, 9, stride=1, padding=4)\n\n        for i in range(self.n_residual_blocks):\n            self.add_module(\'residual_block\' + str(i+1), residualBlock())\n\n        self.conv2 = nn.Conv2d(64, 64, 3, stride=1, padding=1)\n        self.bn2 = nn.BatchNorm2d(64)\n\n        for i in range(self.upsample_factor/2):\n            self.add_module(\'upsample\' + str(i+1), upsampleBlock(64, 256))\n\n        self.conv3 = nn.Conv2d(64, 3, 9, stride=1, padding=4)\n\n    def forward(self, x):\n        x = swish(self.conv1(x))\n\n        y = x.clone()\n        for i in range(self.n_residual_blocks):\n            y = self.__getattr__(\'residual_block\' + str(i+1))(y)\n\n        x = self.bn2(self.conv2(y)) + x\n\n        for i in range(self.upsample_factor/2):\n            x = self.__getattr__(\'upsample\' + str(i+1))(x)\n\n        return self.conv3(x)\n\nclass Discriminator(nn.Module):\n    def __init__(self):\n        super(Discriminator, self).__init__()\n        self.conv1 = nn.Conv2d(3, 64, 3, stride=1, padding=1)\n\n        self.conv2 = nn.Conv2d(64, 64, 3, stride=2, padding=1)\n        self.bn2 = nn.BatchNorm2d(64)\n        self.conv3 = nn.Conv2d(64, 128, 3, stride=1, padding=1)\n        self.bn3 = nn.BatchNorm2d(128)\n        self.conv4 = nn.Conv2d(128, 128, 3, stride=2, padding=1)\n        self.bn4 = nn.BatchNorm2d(128)\n        self.conv5 = nn.Conv2d(128, 256, 3, stride=1, padding=1)\n        self.bn5 = nn.BatchNorm2d(256)\n        self.conv6 = nn.Conv2d(256, 256, 3, stride=2, padding=1)\n        self.bn6 = nn.BatchNorm2d(256)\n        self.conv7 = nn.Conv2d(256, 512, 3, stride=1, padding=1)\n        self.bn7 = nn.BatchNorm2d(512)\n        self.conv8 = nn.Conv2d(512, 512, 3, stride=2, padding=1)\n        self.bn8 = nn.BatchNorm2d(512)\n\n        # Replaced original paper FC layers with FCN\n        self.conv9 = nn.Conv2d(512, 1, 1, stride=1, padding=1)\n\n    def forward(self, x):\n        x = swish(self.conv1(x))\n\n        x = swish(self.bn2(self.conv2(x)))\n        x = swish(self.bn3(self.conv3(x)))\n        x = swish(self.bn4(self.conv4(x)))\n        x = swish(self.bn5(self.conv5(x)))\n        x = swish(self.bn6(self.conv6(x)))\n        x = swish(self.bn7(self.conv7(x)))\n        x = swish(self.bn8(self.conv8(x)))\n\n        x = self.conv9(x)\n        return F.sigmoid(F.avg_pool2d(x, x.size()[2:])).view(x.size()[0], -1)\n'"
utils.py,0,"b'# -*- coding: utf-8 -*-\n""""""Implements some utils\n\nTODO:\n""""""\n\nimport random\n\nfrom torchvision import transforms\nimport matplotlib.pyplot as plt\n\nclass Visualizer:\n    def __init__(self, show_step=10, image_size=30):\n        self.transform = transforms.Compose([transforms.Normalize(mean = [-2.118, -2.036, -1.804], # Equivalent to un-normalizing ImageNet (for correct visualization)\n                                                                    std = [4.367, 4.464, 4.444]),\n                                            transforms.ToPILImage(),\n                                            transforms.Scale(image_size)])\n\n        self.show_step = show_step\n        self.step = 0\n\n        self.figure, (self.lr_plot, self.hr_plot, self.fake_plot) = plt.subplots(1,3)\n        self.figure.show()\n\n        self.lr_image_ph = None\n        self.hr_image_ph = None\n        self.fake_hr_image_ph = None\n\n    def show(self, inputsG, inputsD_real, inputsD_fake):\n\n        self.step += 1\n        if self.step == self.show_step:\n            self.step = 0\n\n            i = random.randint(0, inputsG.size(0) -1)\n\n            lr_image = self.transform(inputsG[i])\n            hr_image = self.transform(inputsD_real[i])\n            fake_hr_image = self.transform(inputsD_fake[i])\n\n            if self.lr_image_ph is None:\n                self.lr_image_ph = self.lr_plot.imshow(lr_image)\n                self.hr_image_ph = self.hr_plot.imshow(hr_image)\n                self.fake_hr_image_ph = self.fake_plot.imshow(fake_hr_image)\n            else:\n                self.lr_image_ph.set_data(lr_image)\n                self.hr_image_ph.set_data(hr_image)\n                self.fake_hr_image_ph.set_data(fake_hr_image)\n\n            self.figure.canvas.draw()\n'"
