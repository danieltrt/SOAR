file_path,api_count,code
pytorch/IP.py,0,"b'#from gurobipy import *\nfrom pulp import *\nimport cv2\nimport numpy as np\nimport sys\nimport csv\nimport copy\nfrom utils import *\nfrom skimage import measure\n\nGAPS = {\'wall_extraction\': 5, \'door_extraction\': 5, \'icon_extraction\': 5, \'wall_neighbor\': 5, \'door_neighbor\': 5, \'icon_neighbor\': 5, \'wall_conflict\': 5, \'door_conflict\': 5, \'icon_conflict\': 5, \'wall_icon_neighbor\': 5, \'wall_icon_conflict\': 5, \'wall_door_neighbor\': 5, \'door_point_conflict\': 5}\nDISTANCES = {\'wall_icon\': 5, \'point\': 5, \'wall\': 10, \'door\': 5, \'icon\': 5}\nLENGTH_THRESHOLDS = {\'wall\': 5, \'door\': 5, \'icon\': 5}\n\n\njunctionWeight = 100\naugmentedJunctionWeight = 50\nlabelWeight = 1\n\nwallWeight = 10\ndoorWeight = 10\niconWeight = 10\n\n#wallTypeWeight = 10\n#doorTypeWeight = 10\niconTypeWeight = 10\n\nwallLineWidth = 3\ndoorLineWidth = 2\n#doorExposureWeight = 0\n\n\nNUM_WALL_TYPES = 1\nNUM_DOOR_TYPES = 2\n#NUM_LABELS = NUM_WALL_TYPES + NUM_DOOR_TYPES + NUM_ICONS + NUM_ROOMS + 1\nNUM_LABELS = NUM_ICONS + NUM_ROOMS\n\nWALL_LABEL_OFFSET = NUM_ROOMS + 1\nDOOR_LABEL_OFFSET = NUM_ICONS + 1\nICON_LABEL_OFFSET = 0\nROOM_LABEL_OFFSET = NUM_ICONS\n\n\ncolorMap = ColorPalette(NUM_CORNERS).getColorMap()\n\nwidth = 256\nheight = 256\nmaxDim = max(width, height)\nsizes = np.array([width, height])\n\nORIENTATION_RANGES = getOrientationRanges(width, height)\n\niconNames = getIconNames()\niconNameNumberMap = dict(zip(iconNames, range(len(iconNames))))\niconNumberNameMap = dict(zip(range(len(iconNames)), iconNames))\n\n\n## Extract corners from corner heatmp predictions\ndef extractCorners(heatmaps, threshold, gap, cornerType = \'wall\', augment=False, gt=False):\n  if gt:\n    orientationPoints = heatmaps\n  else:\n    orientationPoints = extractCornersFromHeatmaps(heatmaps, threshold)\n    pass\n\n  if cornerType == \'wall\':\n    cornerOrientations = []\n    for orientations in POINT_ORIENTATIONS:\n      cornerOrientations += orientations\n      continue\n  elif cornerType == \'door\':\n    cornerOrientations = POINT_ORIENTATIONS[0]\n  else:\n    cornerOrientations = POINT_ORIENTATIONS[1]\n    pass\n  #print(orientationPoints)\n  if augment:\n    orientationMap = {}\n    for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n      for orientation, orientations in enumerate(orientationOrientations):\n        orientationMap[orientations] = orientation\n        continue\n      continue\n\n    for orientationIndex, corners in enumerate(orientationPoints):\n      if len(corners) > 3:\n        continue #skip aug\n      pointType = orientationIndex // 4\n      if pointType in [2]:\n        orientation = orientationIndex % 4\n        orientations = POINT_ORIENTATIONS[pointType][orientation]\n        for i in range(len(orientations)):\n          newOrientations = list(orientations)\n          newOrientations.remove(orientations[i])\n          newOrientations = tuple(newOrientations)\n          if not newOrientations in orientationMap:\n            continue\n          newOrientation = orientationMap[newOrientations]\n          for corner in corners:\n            orientationPoints[(pointType - 1) * 4 + newOrientation].append(corner + (True, ))\n            continue\n          continue\n      elif pointType in [1]:\n        orientation = orientationIndex % 4\n        orientations = POINT_ORIENTATIONS[pointType][orientation]\n        for orientation in range(4):\n          if orientation in orientations:\n            continue\n          newOrientations = list(orientations)\n          newOrientations.append(orientation)\n          newOrientations = tuple(newOrientations)\n          if not newOrientations in orientationMap:\n            continue\n          newOrientation = orientationMap[newOrientations]\n          for corner in corners:\n            orientationPoints[(pointType + 1) * 4 + newOrientation].append(corner + (True, ))\n            continue\n          continue\n        pass\n      continue\n    pass\n  #print(orientationPoints)\n  pointOffset = 0\n  pointOffsets = []\n  points = []\n  pointOrientationLinesMap = []\n  for orientationIndex, corners in enumerate(orientationPoints):\n    pointOffsets.append(pointOffset)\n    orientations = cornerOrientations[orientationIndex]\n    for point in corners:\n      orientationLines = {}\n      for orientation in orientations:\n        orientationLines[orientation] = []\n        continue\n      pointOrientationLinesMap.append(orientationLines)\n      continue\n\n    pointOffset += len(corners)\n\n    if cornerType == \'wall\':\n      points += [[corner[0][0], corner[0][1], orientationIndex // 4, orientationIndex % 4] for corner in corners]\n    elif cornerType == \'door\':\n      points += [[corner[0][0], corner[0][1], 0, orientationIndex] for corner in corners]\n    else:\n      points += [[corner[0][0], corner[0][1], 1, orientationIndex] for corner in corners]\n      pass\n    continue\n\n  augmentedPointMask = {}\n\n\n  lines = []\n  pointNeighbors = [[] for point in points]\n\n  for orientationIndex, corners in enumerate(orientationPoints):\n    orientations = cornerOrientations[orientationIndex]\n    for orientation in orientations:\n      if orientation not in [1, 2]:\n        continue\n      oppositeOrientation = (orientation + 2) % 4\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n\n      for cornerIndex, corner in enumerate(corners):\n        pointIndex = pointOffsets[orientationIndex] + cornerIndex\n        #print(corner)\n        if len(corner) > 3:\n          augmentedPointMask[pointIndex] = True\n          pass\n\n        ranges = copy.deepcopy(ORIENTATION_RANGES[orientation])\n\n        ranges[lineDim] = min(ranges[lineDim], corner[0][lineDim])\n        ranges[lineDim + 2] = max(ranges[lineDim + 2], corner[0][lineDim])\n        ranges[1 - lineDim] = min(ranges[1 - lineDim], corner[1][1 - lineDim] - gap)\n        ranges[1 - lineDim + 2] = max(ranges[1 - lineDim + 2], corner[2][1 - lineDim] + gap)\n\n        for oppositeOrientationIndex, oppositeCorners in enumerate(orientationPoints):\n          if oppositeOrientation not in cornerOrientations[oppositeOrientationIndex]:\n            continue\n          for oppositeCornerIndex, oppositeCorner in enumerate(oppositeCorners):\n            if orientationIndex == oppositeOrientationIndex and oppositeCornerIndex == cornerIndex:\n              continue\n\n            oppositePointIndex = pointOffsets[oppositeOrientationIndex] + oppositeCornerIndex\n\n\n            if oppositeCorner[0][lineDim] < ranges[lineDim] or oppositeCorner[0][lineDim] > ranges[lineDim + 2] or ranges[1 - lineDim] > oppositeCorner[2][1 - lineDim] or ranges[1 - lineDim + 2] < oppositeCorner[1][1 - lineDim]:\n              continue\n\n\n            if abs(oppositeCorner[0][lineDim] - corner[0][lineDim]) < LENGTH_THRESHOLDS[cornerType]:\n              continue\n\n            lineIndex = len(lines)\n            pointOrientationLinesMap[pointIndex][orientation].append(lineIndex)\n            pointOrientationLinesMap[oppositePointIndex][oppositeOrientation].append(lineIndex)\n            pointNeighbors[pointIndex].append(oppositePointIndex)\n            pointNeighbors[oppositePointIndex].append(pointIndex)\n\n            lines.append((pointIndex, oppositePointIndex))\n            continue\n          continue\n        continue\n      continue\n    continue\n  return points, lines, pointOrientationLinesMap, pointNeighbors, augmentedPointMask\n\n\n## Corner type augmentation to enrich the candidate set (e.g., a T-shape corner can be treated as a L-shape corner)\ndef augmentPoints(points, decreasingTypes = [2], increasingTypes = [1]):\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = orientation\n      continue\n    continue\n\n  newPoints = []\n  for pointIndex, point in enumerate(points):\n    if point[2] not in decreasingTypes:\n      continue\n    orientations = POINT_ORIENTATIONS[point[2]][point[3]]\n    for i in range(len(orientations)):\n      newOrientations = list(orientations)\n      newOrientations.remove(orientations[i])\n      newOrientations = tuple(newOrientations)\n      if not newOrientations in orientationMap:\n        continue\n      newOrientation = orientationMap[newOrientations]\n      newPoints.append([point[0], point[1], point[2] - 1, newOrientation])\n      continue\n    continue\n\n  for pointIndex, point in enumerate(points):\n    if point[2] not in increasingTypes:\n      continue\n    orientations = POINT_ORIENTATIONS[point[2]][point[3]]\n    for orientation in range(4):\n      if orientation in orientations:\n        continue\n\n      oppositeOrientation = (orientation + 2) % 4\n      ranges = copy.deepcopy(ORIENTATION_RANGES[orientation])\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n      deltas = [0, 0]\n\n      if lineDim == 1:\n        deltas[0] = gap\n      else:\n        deltas[1] = gap\n        pass\n\n      for c in range(2):\n        ranges[c] = min(ranges[c], point[c] - deltas[c])\n        ranges[c + 2] = max(ranges[c + 2], point[c] + deltas[c])\n        continue\n\n      hasNeighbor = False\n      for neighborPointIndex, neighborPoint in enumerate(points):\n        if neighborPointIndex == pointIndex:\n          continue\n\n        neighborOrientations = POINT_ORIENTATIONS[neighborPoint[2]][neighborPoint[3]]\n        if oppositeOrientation not in neighborOrientations:\n          continue\n\n        inRange = True\n        for c in range(2):\n          if neighborPoint[c] < ranges[c] or neighborPoint[c] > ranges[c + 2]:\n            inRange = False\n            break\n          continue\n\n        if not inRange or abs(neighborPoint[lineDim] - point[lineDim]) < max(abs(neighborPoint[1 - lineDim] - point[1 - lineDim]), 1):\n          continue\n\n        hasNeighbor = True\n        break\n\n      if not hasNeighbor:\n        continue\n\n      newOrientations = list(orientations)\n      newOrientations.append(orientation)\n      newOrientations = tuple(newOrientations)\n      if not newOrientations in orientationMap:\n        continue\n      newOrientation = orientationMap[newOrientations]\n      newPoints.append([point[0], point[1], point[2] + 1, newOrientation])\n      continue\n    continue\n  return points + newPoints\n\n\n## Remove invalid walls as preprocessing\ndef filterWalls(wallPoints, wallLines):\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = orientation\n      continue\n    continue\n\n  #print(POINT_ORIENTATIONS)\n\n  while True:\n    pointOrientationNeighborsMap = {}\n    for line in wallLines:\n      lineDim = calcLineDim(wallPoints, line)\n      for c, pointIndex in enumerate(line):\n        if lineDim == 0:\n          if c == 0:\n            orientation = 1\n          else:\n            orientation = 3\n        else:\n          if c == 0:\n            orientation = 2\n          else:\n            orientation = 0\n            pass\n          pass\n\n        if pointIndex not in pointOrientationNeighborsMap:\n          pointOrientationNeighborsMap[pointIndex] = {}\n          pass\n        if orientation not in pointOrientationNeighborsMap[pointIndex]:\n          pointOrientationNeighborsMap[pointIndex][orientation] = []\n          pass\n        pointOrientationNeighborsMap[pointIndex][orientation].append(line[1 - c])\n        continue\n      continue\n\n\n    invalidPointMask = {}\n    for pointIndex, point in enumerate(wallPoints):\n      if pointIndex not in pointOrientationNeighborsMap:\n        invalidPointMask[pointIndex] = True\n        continue\n      orientationNeighborMap = pointOrientationNeighborsMap[pointIndex]\n      orientations = POINT_ORIENTATIONS[point[2]][point[3]]\n      if len(orientationNeighborMap) < len(orientations):\n        if len(orientationNeighborMap) >= 2 and tuple(orientationNeighborMap.keys()) in orientationMap:\n          newOrientation = orientationMap[tuple(orientationNeighborMap.keys())]\n          wallPoints[pointIndex][2] = len(orientationNeighborMap) - 1\n          wallPoints[pointIndex][3] = newOrientation\n          #print(orientationNeighborMap)\n          #print(\'new\', len(orientationNeighborMap), newOrientation)\n          continue\n        invalidPointMask[pointIndex] = True\n        pass\n      continue\n\n    if len(invalidPointMask) == 0:\n      break\n\n    newWallPoints = []\n    pointIndexMap = {}\n    for pointIndex, point in enumerate(wallPoints):\n      if pointIndex not in invalidPointMask:\n        pointIndexMap[pointIndex] = len(newWallPoints)\n        newWallPoints.append(point)\n        pass\n      continue\n\n    wallPoints = newWallPoints\n\n    newWallLines = []\n    for lineIndex, line in enumerate(wallLines):\n      if line[0] in pointIndexMap and line[1] in pointIndexMap:\n        newLine = (pointIndexMap[line[0]], pointIndexMap[line[1]])\n        newWallLines.append(newLine)\n        pass\n      continue\n    wallLines = newWallLines\n    continue\n\n  pointOrientationLinesMap = [{} for _ in range(len(wallPoints))]\n  pointNeighbors = [[] for _ in range(len(wallPoints))]\n\n  for lineIndex, line in enumerate(wallLines):\n    lineDim = calcLineDim(wallPoints, line)\n    for c, pointIndex in enumerate(line):\n      if lineDim == 0:\n        if wallPoints[pointIndex][lineDim] < wallPoints[line[1 - c]][lineDim]:\n          orientation = 1\n        else:\n          orientation = 3\n          pass\n      else:\n        if wallPoints[pointIndex][lineDim] < wallPoints[line[1 - c]][lineDim]:\n          orientation = 2\n        else:\n          orientation = 0\n          pass\n        pass\n\n      if orientation not in pointOrientationLinesMap[pointIndex]:\n        pointOrientationLinesMap[pointIndex][orientation] = []\n        pass\n      pointOrientationLinesMap[pointIndex][orientation].append(lineIndex)\n      pointNeighbors[pointIndex].append(line[1 - c])\n      continue\n    continue\n\n  return wallPoints, wallLines, pointOrientationLinesMap, pointNeighbors\n\n## Write wall points to result file\ndef writePoints(points, pointLabels, output_prefix=\'test/\'):\n  with open(output_prefix + \'points_out.txt\', \'w\') as points_file:\n    for point in points:\n      points_file.write(str(point[0] + 1) + \'\\t\' + str(point[1] + 1) + \'\\t\')\n      points_file.write(str(point[0] + 1) + \'\\t\' + str(point[1] + 1) + \'\\t\')\n      points_file.write(\'point\\t\')\n      points_file.write(str(point[2] + 1) + \'\\t\' + str(point[3] + 1) + \'\\n\')\n  points_file.close()\n\n  with open(output_prefix + \'point_labels.txt\', \'w\') as point_label_file:\n    for point in pointLabels:\n      point_label_file.write(str(point[0]) + \'\\t\' + str(point[1]) + \'\\t\' + str(point[2]) + \'\\t\' + str(point[3]) + \'\\n\')\n  point_label_file.close()\n\n## Write doors to result file\ndef writeDoors(points, lines, doorTypes, output_prefix=\'test/\'):\n  with open(output_prefix + \'doors_out.txt\', \'w\') as doors_file:\n    for lineIndex, line in enumerate(lines):\n      point_1 = points[line[0]]\n      point_2 = points[line[1]]\n\n      doors_file.write(str(point_1[0] + 1) + \'\\t\' + str(point_1[1] + 1) + \'\\t\')\n      doors_file.write(str(point_2[0] + 1) + \'\\t\' + str(point_2[1] + 1) + \'\\t\')\n      doors_file.write(\'door\\t\')\n      doors_file.write(str(doorTypes[lineIndex] + 1) + \'\\t1\\n\')\n    doors_file.close()\n\n## Write icons to result file    \ndef writeIcons(points, icons, iconTypes, output_prefix=\'test/\'):\n  with open(output_prefix + \'icons_out.txt\', \'w\') as icons_file:\n    for iconIndex, icon in enumerate(icons):\n      point_1 = points[icon[0]]\n      point_2 = points[icon[1]]\n      point_3 = points[icon[2]]\n      point_4 = points[icon[3]]\n\n      x_1 = int(round((point_1[0] + point_3[0]) // 2)) + 1\n      x_2 = int(round((point_2[0] + point_4[0]) // 2)) + 1\n      y_1 = int(round((point_1[1] + point_2[1]) // 2)) + 1\n      y_2 = int(round((point_3[1] + point_4[1]) // 2)) + 1\n\n      icons_file.write(str(x_1) + \'\\t\' + str(y_1) + \'\\t\')\n      icons_file.write(str(x_2) + \'\\t\' + str(y_2) + \'\\t\')\n      icons_file.write(iconNumberNameMap[iconTypes[iconIndex]] + \'\\t\')\n      #icons_file.write(str(iconNumberStyleMap[iconTypes[iconIndex]]) + \'\\t\')\n      icons_file.write(\'1\\t\')\n      icons_file.write(\'1\\n\')\n    icons_file.close()\n\n\n## Adjust wall corner locations to align with each other after optimization\ndef adjustPoints(points, lines):\n  lineNeighbors = []\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    neighbors = []\n    for neighborLineIndex, neighborLine in enumerate(lines):\n      if neighborLineIndex <= lineIndex:\n        continue\n      neighborLineDim = calcLineDim(points, neighborLine)\n      point_1 = points[neighborLine[0]]\n      point_2 = points[neighborLine[1]]\n      lineDimNeighbor = calcLineDim(points, neighborLine)\n\n      if lineDimNeighbor != lineDim:\n        continue\n      if neighborLine[0] != line[0] and neighborLine[0] != line[1] and neighborLine[1] != line[0] and neighborLine[1] != line[1]:\n        continue\n      neighbors.append(neighborLineIndex)\n      continue\n    lineNeighbors.append(neighbors)\n    continue\n\n  visitedLines = {}\n  for lineIndex in range(len(lines)):\n    if lineIndex in visitedLines:\n      continue\n    lineGroup = [lineIndex]\n    while True:\n      newLineGroup = lineGroup\n      hasChange = False\n      for line in lineGroup:\n        neighbors = lineNeighbors[line]\n        for neighbor in neighbors:\n          if neighbor not in newLineGroup:\n            newLineGroup.append(neighbor)\n            hasChange = True\n            pass\n          continue\n        continue\n      if not hasChange:\n        break\n      lineGroup = newLineGroup\n      continue\n\n    for line in lineGroup:\n      visitedLines[line] = True\n      continue\n\n    #print([[points[pointIndex] for pointIndex in lines[lineIndex]] for lineIndex in lineGroup], calcLineDim(points, lines[lineGroup[0]]))\n\n    pointGroup = []\n    for line in lineGroup:\n      for index in range(2):\n        pointIndex = lines[line][index]\n        if pointIndex not in pointGroup:\n          pointGroup.append(pointIndex)\n          pass\n        continue\n      continue\n\n    #lineDim = calcLineDim(points, lines[lineGroup[0]])\n    xy = np.concatenate([np.array([points[pointIndex][:2] for pointIndex in lines[lineIndex]]) for lineIndex in lineGroup], axis=0)\n    mins = xy.min(0)\n    maxs = xy.max(0)\n    if maxs[0] - mins[0] > maxs[1] - mins[1]:\n      lineDim = 0\n    else:\n      lineDim = 1\n      pass\n\n    fixedValue = 0\n    for point in pointGroup:\n      fixedValue += points[point][1 - lineDim]\n      continue\n    fixedValue /= len(pointGroup)\n\n    for point in pointGroup:\n      points[point][1 - lineDim] = fixedValue\n      continue\n    continue\n  return\n\n## Merge two close points after optimization\ndef mergePoints(points, lines):\n  validPointMask = {}\n  for line in lines:\n    validPointMask[line[0]] = True\n    validPointMask[line[1]] = True\n    continue\n\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = (pointType, orientation)\n      continue\n    continue\n\n  for pointIndex_1, point_1 in enumerate(points):\n    if pointIndex_1 not in validPointMask:\n      continue\n    for pointIndex_2, point_2 in enumerate(points):\n      if pointIndex_2 <= pointIndex_1:\n        continue\n      if pointIndex_2 not in validPointMask:\n        continue\n      if pointDistance(point_1[:2], point_2[:2]) <= DISTANCES[\'point\']:\n        orientations = list(POINT_ORIENTATIONS[point_1[2]][point_1[3]] + POINT_ORIENTATIONS[point_2[2]][point_2[3]])\n        if len([line for line in lines if pointIndex_1 in line and pointIndex_2 in line]) > 0:\n          if abs(point_1[0] - point_2[0]) > abs(point_1[1] - point_2[1]):\n            orientations.remove(1)\n            orientations.remove(3)\n          else:\n            orientations.remove(0)\n            orientations.remove(2)\n            pass\n          pass\n        orientations = tuple(set(orientations))\n        if orientations not in orientationMap:\n          for lineIndex, line in enumerate(lines):\n            if pointIndex_1 in line and pointIndex_2 in line:\n              lines[lineIndex] = (-1, -1)\n              pass\n            continue\n\n          lineIndices_1 = [(lineIndex, tuple(set(line) - set((pointIndex_1, )))[0]) for lineIndex, line in enumerate(lines) if pointIndex_1 in line and pointIndex_2 not in line]\n          lineIndices_2 = [(lineIndex, tuple(set(line) - set((pointIndex_2, )))[0]) for lineIndex, line in enumerate(lines) if pointIndex_2 in line and pointIndex_1 not in line]\n          if len(lineIndices_1) == 1 and len(lineIndices_2) == 1:\n            lineIndex_1, index_1 = lineIndices_1[0]\n            lineIndex_2, index_2 = lineIndices_2[0]\n            lines[lineIndex_1] = (index_1, index_2)\n            lines[lineIndex_2] = (-1, -1)\n            pass\n          continue\n\n        pointInfo = orientationMap[orientations]\n        newPoint = [(point_1[0] + point_2[0]) // 2, (point_1[1] + point_2[1]) // 2, pointInfo[0], pointInfo[1]]\n        points[pointIndex_1] = newPoint\n        for lineIndex, line in enumerate(lines):\n          if pointIndex_2 == line[0]:\n            lines[lineIndex] = (pointIndex_1, line[1])\n            pass\n          if pointIndex_2 == line[1]:\n            lines[lineIndex] = (line[0], pointIndex_1)\n            pass\n          continue\n        pass\n      continue\n    continue\n  return\n\n## Adjust door corner locations to align with each other after optimization\ndef adjustDoorPoints(doorPoints, doorLines, wallPoints, wallLines, doorWallMap):\n  for doorLineIndex, doorLine in enumerate(doorLines):\n    lineDim = calcLineDim(doorPoints, doorLine)\n    wallLine = wallLines[doorWallMap[doorLineIndex]]\n    wallPoint_1 = wallPoints[wallLine[0]]\n    wallPoint_2 = wallPoints[wallLine[1]]\n    fixedValue = (wallPoint_1[1 - lineDim] + wallPoint_2[1 - lineDim]) // 2\n    for endPointIndex in range(2):\n      doorPoints[doorLine[endPointIndex]][1 - lineDim] = fixedValue\n      continue\n    continue\n\n## Generate icon candidates\ndef findIconsFromLines(iconPoints, iconLines):\n  icons = []\n  pointOrientationNeighborsMap = {}\n  for line in iconLines:\n    lineDim = calcLineDim(iconPoints, line)\n    for c, pointIndex in enumerate(line):\n      if lineDim == 0:\n        if c == 0:\n          orientation = 1\n        else:\n          orientation = 3\n      else:\n        if c == 0:\n          orientation = 2\n        else:\n          orientation = 0\n          pass\n        pass\n\n      if pointIndex not in pointOrientationNeighborsMap:\n        pointOrientationNeighborsMap[pointIndex] = {}\n        pass\n      if orientation not in pointOrientationNeighborsMap[pointIndex]:\n        pointOrientationNeighborsMap[pointIndex][orientation] = []\n        pass\n      pointOrientationNeighborsMap[pointIndex][orientation].append(line[1 - c])\n      continue\n    continue\n\n  for pointIndex, orientationNeighborMap in pointOrientationNeighborsMap.items():\n    if 1 not in orientationNeighborMap or 2 not in orientationNeighborMap:\n      continue\n    for neighborIndex_1 in orientationNeighborMap[1]:\n      if 2 not in pointOrientationNeighborsMap[neighborIndex_1]:\n        continue\n      lastCornerCandiates = pointOrientationNeighborsMap[neighborIndex_1][2]\n      for neighborIndex_2 in orientationNeighborMap[2]:\n        if 1 not in pointOrientationNeighborsMap[neighborIndex_2]:\n          continue\n        for lastCornerIndex in pointOrientationNeighborsMap[neighborIndex_2][1]:\n          if lastCornerIndex not in lastCornerCandiates:\n            continue\n\n          point_1 = iconPoints[pointIndex]\n          point_2 = iconPoints[neighborIndex_1]\n          point_3 = iconPoints[neighborIndex_2]\n          point_4 = iconPoints[lastCornerIndex]\n\n          x_1 = int((point_1[0] + point_3[0]) // 2)\n          x_2 = int((point_2[0] + point_4[0]) // 2)\n          y_1 = int((point_1[1] + point_2[1]) // 2)\n          y_2 = int((point_3[1] + point_4[1]) // 2)\n\n          #if x_2 <= x_1 or y_2 <= y_1:\n          #continue\n          if (x_2 - x_1 + 1) * (y_2 - y_1 + 1) <= LENGTH_THRESHOLDS[\'icon\'] * LENGTH_THRESHOLDS[\'icon\']:\n            continue\n\n          icons.append((pointIndex, neighborIndex_1, neighborIndex_2, lastCornerIndex))\n          continue\n        continue\n      continue\n    continue\n  return icons\n\n\n## Find two wall lines facing each other and accumuate semantic information in between\ndef findLineNeighbors(points, lines, labelVotesMap, gap):\n  lineNeighbors = [[{}, {}] for lineIndex in range(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    for neighborLineIndex, neighborLine in enumerate(lines):\n      if neighborLineIndex <= lineIndex:\n        continue\n      neighborLineDim = calcLineDim(points, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = points[line[0]][1 - lineDim]\n      fixedValue_2 = points[neighborLine[0]][1 - lineDim]\n\n      minValue = int(minValue)\n      maxValue = int(maxValue)\n      fixedValue_1 = int(fixedValue_1)\n      fixedValue_2 = int(fixedValue_2)\n\n      if abs(fixedValue_2 - fixedValue_1) < gap:\n        continue\n      if lineDim == 0:\n        if fixedValue_1 < fixedValue_2:\n          region = ((minValue, fixedValue_1), (maxValue, fixedValue_2))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][0][lineIndex] = region\n        else:\n          region = ((minValue, fixedValue_2), (maxValue, fixedValue_1))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][1][lineIndex] = region\n      else:\n        if fixedValue_1 < fixedValue_2:\n          region = ((fixedValue_1, minValue), (fixedValue_2, maxValue))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][1][lineIndex] = region\n        else:\n          region = ((fixedValue_2, minValue), (fixedValue_1, maxValue))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][0][lineIndex] = region\n          pass\n        pass\n      continue\n    continue\n\n  # remove neighbor pairs which are separated by another line\n  while True:\n    hasChange = False\n    for lineIndex, neighbors in enumerate(lineNeighbors):\n      lineDim = calcLineDim(points, lines[lineIndex])\n      for neighbor_1, region_1 in neighbors[1].items():\n        for neighbor_2, _ in neighbors[0].items():\n          if neighbor_2 not in lineNeighbors[neighbor_1][0]:\n            continue\n          region_2 = lineNeighbors[neighbor_1][0][neighbor_2]\n          if region_1[0][lineDim] < region_2[0][lineDim] + gap and region_1[1][lineDim] > region_2[1][lineDim] - gap:\n            lineNeighbors[neighbor_1][0].pop(neighbor_2)\n            lineNeighbors[neighbor_2][1].pop(neighbor_1)\n            hasChange = True\n            pass\n          continue\n        continue\n      continue\n    if not hasChange:\n      break\n\n\n  for lineIndex, directionNeighbors in enumerate(lineNeighbors):\n    for direction, neighbors in enumerate(directionNeighbors):\n      for neighbor, region in neighbors.items():\n        labelVotes = labelVotesMap[:, region[1][1], region[1][0]] + labelVotesMap[:, region[0][1], region[0][0]] - labelVotesMap[:, region[0][1], region[1][0]] - labelVotesMap[:, region[1][1], region[0][0]]\n        neighbors[neighbor] = labelVotes\n        continue\n      continue\n    continue\n  return lineNeighbors\n\n\n## Find neighboring wall line/icon pairs\ndef findRectangleLineNeighbors(rectanglePoints, rectangles, linePoints, lines, lineNeighbors, gap, distanceThreshold):\n  rectangleLineNeighbors = [{} for rectangleIndex in range(len(rectangles))]\n  minDistanceLineNeighbors = {}\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    for lineIndex, line in enumerate(lines):\n      lineDim = calcLineDim(linePoints, line)\n\n      minValue = max(rectanglePoints[rectangle[0]][lineDim], rectanglePoints[rectangle[2 - lineDim]][lineDim], linePoints[line[0]][lineDim])\n      maxValue = min(rectanglePoints[rectangle[1 + lineDim]][lineDim], rectanglePoints[rectangle[3]][lineDim], linePoints[line[1]][lineDim])\n\n      if maxValue - minValue < gap:\n        continue\n\n      rectangleFixedValue_1 = (rectanglePoints[rectangle[0]][1 - lineDim] + rectanglePoints[rectangle[1 + lineDim]][1 - lineDim]) // 2\n      rectangleFixedValue_2 = (rectanglePoints[rectangle[2 - lineDim]][1 - lineDim] + rectanglePoints[rectangle[3]][1 - lineDim]) // 2\n      lineFixedValue = (linePoints[line[0]][1 - lineDim] + linePoints[line[1]][1 - lineDim]) // 2\n\n      if lineFixedValue < rectangleFixedValue_2 - gap and lineFixedValue > rectangleFixedValue_1 + gap:\n        continue\n\n      if lineFixedValue <= rectangleFixedValue_1 + gap:\n        index = lineDim * 2 + 0\n        distance = rectangleFixedValue_1 - lineFixedValue\n        if index not in minDistanceLineNeighbors or distance < minDistanceLineNeighbors[index][1]:\n          minDistanceLineNeighbors[index] = (lineIndex, distance, 1 - lineDim)\n      else:\n        index = lineDim * 2 + 1\n        distance = lineFixedValue - rectangleFixedValue_2\n        if index not in minDistanceLineNeighbors or distance < minDistanceLineNeighbors[index][1]:\n          minDistanceLineNeighbors[index] = (lineIndex, distance, lineDim)\n\n      if lineFixedValue < rectangleFixedValue_1 - distanceThreshold or lineFixedValue > rectangleFixedValue_2 + distanceThreshold:\n        continue\n\n      if lineFixedValue <= rectangleFixedValue_1 + gap:\n        if lineDim == 0:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 1\n        else:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 0\n          pass\n        pass\n      else:\n        if lineDim == 0:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 0\n        else:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 1\n          pass\n        pass\n\n      continue\n    if len(rectangleLineNeighbors[rectangleIndex]) == 0 or True:\n      for index, lineNeighbor in minDistanceLineNeighbors.items():\n        rectangleLineNeighbors[rectangleIndex][lineNeighbor[0]] = lineNeighbor[2]\n        continue\n      pass\n    continue\n\n  return rectangleLineNeighbors\n\n## Find the door line to wall line map\ndef findLineMap(points, lines, points_2, lines_2, gap):\n  lineMap = [{} for lineIndex in range(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    for neighborLineIndex, neighborLine in enumerate(lines_2):\n      neighborLineDim = calcLineDim(points_2, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points_2[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points_2[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) // 2\n      fixedValue_2 = (points_2[neighborLine[0]][1 - lineDim] + points_2[neighborLine[1]][1 - lineDim]) // 2\n\n      if abs(fixedValue_2 - fixedValue_1) > gap:\n        continue\n\n      lineMinValue = points[line[0]][lineDim]\n      lineMaxValue = points[line[1]][lineDim]\n      ratio = float(maxValue - minValue + 1) / (lineMaxValue - lineMinValue + 1)\n\n      lineMap[lineIndex][neighborLineIndex] = ratio\n      continue\n    continue\n\n  return lineMap\n\n\n## Find the one-to-one door line to wall line map after optimization\ndef findLineMapSingle(points, lines, points_2, lines_2, gap):\n  lineMap = []\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    minDistance = max(width, height)\n    minDistanceLineIndex = -1\n    for neighborLineIndex, neighborLine in enumerate(lines_2):\n      neighborLineDim = calcLineDim(points_2, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points_2[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points_2[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) // 2\n      fixedValue_2 = (points_2[neighborLine[0]][1 - lineDim] + points_2[neighborLine[1]][1 - lineDim]) // 2\n\n      distance = abs(fixedValue_2 - fixedValue_1)\n      if distance < minDistance:\n        minDistance = distance\n        minDistanceLineIndex = neighborLineIndex\n        pass\n      continue\n\n    #if abs(fixedValue_2 - fixedValue_1) > gap:\n    #continue\n    #print((lineIndex, minDistance, minDistanceLineIndex))\n    lineMap.append(minDistanceLineIndex)\n    continue\n\n  return lineMap\n\n\n## Find conflicting line pairs\ndef findConflictLinePairs(points, lines, gap, distanceThreshold, considerEndPoints=False):\n  conflictLinePairs = []\n  for lineIndex_1, line_1 in enumerate(lines):\n    lineDim_1 = calcLineDim(points, line_1)\n    point_1 = points[line_1[0]]\n    point_2 = points[line_1[1]]\n    fixedValue_1 = int(round((point_1[1 - lineDim_1] + point_2[1 - lineDim_1]) // 2))\n    minValue_1 = int(min(point_1[lineDim_1], point_2[lineDim_1]))\n    maxValue_1 = int(max(point_1[lineDim_1], point_2[lineDim_1]))\n\n    for lineIndex_2, line_2 in enumerate(lines):\n      if lineIndex_2 <= lineIndex_1:\n        continue\n\n      lineDim_2 = calcLineDim(points, line_2)\n      point_1 = points[line_2[0]]\n      point_2 = points[line_2[1]]\n\n      if lineDim_2 == lineDim_1:\n        if line_1[0] == line_2[0] or line_1[1] == line_2[1]:\n          conflictLinePairs.append((lineIndex_1, lineIndex_2))\n          continue\n        elif line_1[0] == line_2[1] or line_1[1] == line_2[0]:\n          continue\n        pass\n      else:\n        if (line_1[0] in line_2 or line_1[1] in line_2):\n          continue\n        pass\n\n      if considerEndPoints:\n        if min([pointDistance(points[line_1[0]], points[line_2[0]]), pointDistance(points[line_1[0]], points[line_2[1]]), pointDistance(points[line_1[1]], points[line_2[0]]), pointDistance(points[line_1[1]], points[line_2[1]])]) <= gap:\n          conflictLinePairs.append((lineIndex_1, lineIndex_2))\n          continue\n        pass\n\n      fixedValue_2 = int(round((point_1[1 - lineDim_2] + point_2[1 - lineDim_2]) // 2))\n      minValue_2 = int(min(point_1[lineDim_2], point_2[lineDim_2]))\n      maxValue_2 = int(max(point_1[lineDim_2], point_2[lineDim_2]))\n\n      if lineDim_1 == lineDim_2:\n        if abs(fixedValue_2 - fixedValue_1) >= distanceThreshold or minValue_1 > maxValue_2 - gap or minValue_2 > maxValue_1 - gap:\n          continue\n\n        conflictLinePairs.append((lineIndex_1, lineIndex_2))\n        #drawLines(output_prefix + \'lines_\' + str(lineIndex_1) + ""_"" + str(lineIndex_2) + \'.png\', width, height, points, [line_1, line_2])\n      else:\n        if minValue_1 > fixedValue_2 - gap or maxValue_1 < fixedValue_2 + gap or minValue_2 > fixedValue_1 - gap or maxValue_2 < fixedValue_1 + gap:\n          continue\n\n        conflictLinePairs.append((lineIndex_1, lineIndex_2))\n        pass\n      continue\n    continue\n\n  return conflictLinePairs\n\n\n## Find conflicting line/icon pairs\ndef findConflictRectanglePairs(points, rectangles, gap):\n  conflictRectanglePairs = []\n  for rectangleIndex_1, rectangle_1 in enumerate(rectangles):\n    for rectangleIndex_2, rectangle_2 in enumerate(rectangles):\n      if rectangleIndex_2 <= rectangleIndex_1:\n        continue\n\n      conflict = False\n      for cornerIndex in range(4):\n        if rectangle_1[cornerIndex] == rectangle_2[cornerIndex]:\n          conflictRectanglePairs.append((rectangleIndex_1, rectangleIndex_2))\n          conflict = True\n          break\n        continue\n\n      if conflict:\n        continue\n\n      minX = max((points[rectangle_1[0]][0] + points[rectangle_1[2]][0]) // 2, (points[rectangle_2[0]][0] + points[rectangle_2[2]][0]) // 2)\n      maxX = min((points[rectangle_1[1]][0] + points[rectangle_1[3]][0]) // 2, (points[rectangle_2[1]][0] + points[rectangle_2[3]][0]) // 2)\n      if minX > maxX - gap:\n        continue\n      minY = max((points[rectangle_1[0]][1] + points[rectangle_1[1]][1]) // 2, (points[rectangle_2[0]][1] + points[rectangle_2[1]][1]) // 2)\n      maxY = min((points[rectangle_1[2]][1] + points[rectangle_1[3]][1]) // 2, (points[rectangle_2[2]][1] + points[rectangle_2[3]][1]) // 2)\n      if minY > maxY - gap:\n        continue\n      conflictRectanglePairs.append((rectangleIndex_1, rectangleIndex_2))\n      continue\n    continue\n\n  return conflictRectanglePairs\n\n\n## Find conflicting icon pairs\ndef findConflictRectangleLinePairs(rectanglePoints, rectangles, linePoints, lines, gap):\n  conflictRectangleLinePairs = []\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    for lineIndex, line in enumerate(lines):\n      lineDim = calcLineDim(linePoints, line)\n      if lineDim == 0:\n        minX = max(rectanglePoints[rectangle[0]][0], rectanglePoints[rectangle[2]][0], linePoints[line[0]][0])\n        maxX = min(rectanglePoints[rectangle[1]][0], rectanglePoints[rectangle[3]][0], linePoints[line[1]][0])\n        if minX > maxX - gap:\n          continue\n        if max(rectanglePoints[rectangle[0]][1], rectanglePoints[rectangle[1]][1]) + gap > min(linePoints[line[0]][1], linePoints[line[1]][1]):\n          continue\n        if min(rectanglePoints[rectangle[2]][1], rectanglePoints[rectangle[3]][1]) - gap < max(linePoints[line[0]][1], linePoints[line[1]][1]):\n          continue\n\n      elif lineDim == 1:\n        minY = max(rectanglePoints[rectangle[0]][1], rectanglePoints[rectangle[1]][1], linePoints[line[0]][1])\n        maxY = min(rectanglePoints[rectangle[2]][1], rectanglePoints[rectangle[3]][1], linePoints[line[1]][1])\n        if minY > maxY - gap:\n          continue\n        if max(rectanglePoints[rectangle[0]][0], rectanglePoints[rectangle[2]][0]) + gap > min(linePoints[line[0]][0], linePoints[line[1]][0]):\n          continue\n        if min(rectanglePoints[rectangle[1]][0], rectanglePoints[rectangle[3]][0]) - gap < max(linePoints[line[0]][0], linePoints[line[1]][0]):\n          continue\n\n      conflictRectangleLinePairs.append((rectangleIndex, lineIndex))\n      continue\n    continue\n\n  return conflictRectangleLinePairs\n\n## Find point to line map\ndef findLinePointMap(points, lines, points_2, gap):\n  lineMap = [[] for lineIndex in range(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    fixedValue = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) // 2\n    for neighborPointIndex, neighborPoint in enumerate(points_2):\n      if neighborPoint[lineDim] < points[line[0]][lineDim] + gap or neighborPoint[lineDim] > points[line[1]][lineDim] - gap:\n        continue\n\n      if abs((neighborPoint[1 - lineDim] + neighborPoint[1 - lineDim]) // 2 - fixedValue) > gap:\n        continue\n\n      lineMap[lineIndex].append(neighborPointIndex)\n      continue\n    continue\n  return lineMap\n\n## Generate primitive candidates from heatmaps\ndef findCandidatesFromHeatmaps(iconHeatmaps, iconPointOffset, doorPointOffset):\n  newIcons = []\n  newIconPoints = []\n  newDoorLines = []\n  newDoorPoints = []\n  for iconIndex in range(1, NUM_ICONS + 2):\n    heatmap = iconHeatmaps[:, :, iconIndex] > 0.5\n    kernel = np.ones((3, 3), dtype=np.uint8)\n    heatmap = cv2.dilate(cv2.erode(heatmap.astype(np.uint8), kernel), kernel)\n    regions = measure.label(heatmap, background=0)\n    for regionIndex in range(regions.min() + 1, regions.max() + 1):\n      regionMask = regions == regionIndex\n      ys, xs = regionMask.nonzero()\n      minX, maxX = xs.min(), xs.max()\n      minY, maxY = ys.min(), ys.max()\n      if iconIndex <= NUM_ICONS:\n        if maxX - minX < GAPS[\'icon_extraction\'] or maxY - minY < GAPS[\'icon_extraction\']:\n          continue\n        mask = regionMask[minY:maxY + 1, minX:maxX + 1]\n        sizeX, sizeY = maxX - minX + 1, maxY - minY + 1\n        sumX = mask.sum(0)\n\n        for x in range(sizeX):\n          if sumX[x] * 2 >= sizeY:\n            break\n          minX += 1\n          continue\n\n        for x in range(sizeX - 1, -1, -1):\n          if sumX[x] * 2 >= sizeY:\n            break\n          maxX -= 1\n          continue\n\n\n        sumY = mask.sum(1)\n        for y in range(sizeY):\n          if sumY[y] * 2 >= sizeX:\n            break\n          minY += 1\n          continue\n\n        for y in range(sizeY - 1, -1, -1):\n          if sumY[y] * 2 >= sizeX:\n            break\n          maxY -= 1\n          continue\n        if (maxY - minY + 1) * (maxX - minX + 1) <= LENGTH_THRESHOLDS[\'icon\'] * LENGTH_THRESHOLDS[\'icon\'] * 2:\n          continue\n        newIconPoints += [[minX, minY, 1, 2], [maxX, minY, 1, 3], [minX, maxY, 1, 1], [maxX, maxY, 1, 0]]\n        newIcons.append((iconPointOffset, iconPointOffset + 1, iconPointOffset + 2, iconPointOffset + 3))\n        iconPointOffset += 4\n      else:\n        sizeX, sizeY = maxX - minX + 1, maxY - minY + 1\n        if sizeX >= LENGTH_THRESHOLDS[\'door\'] and sizeY * 2 <= sizeX:\n          newDoorPoints += [[minX, (minY + maxY) // 2, 0, 1], [maxX, (minY + maxY) // 2, 0, 3]]\n          newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n          doorPointOffset += 2\n        elif sizeY >= LENGTH_THRESHOLDS[\'door\'] and sizeX * 2 <= sizeY:\n          newDoorPoints += [[(minX + maxX) // 2, minY, 0, 2], [(minX + maxX) // 2, maxY, 0, 0]]\n          newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n          doorPointOffset += 2\n        elif sizeX >= LENGTH_THRESHOLDS[\'door\'] and sizeY >= LENGTH_THRESHOLDS[\'door\']:\n          mask = regionMask[minY:maxY + 1, minX:maxX + 1]\n          sumX = mask.sum(0)\n          minOffset, maxOffset = 0, 0\n          for x in range(sizeX):\n            if sumX[x] * 2 >= sizeY:\n              break\n            minOffset += 1\n            continue\n\n          for x in range(sizeX - 1, -1, -1):\n            if sumX[x] * 2 >= sizeY:\n              break\n            maxOffset += 1\n            continue\n\n          if (sizeX - minOffset - maxOffset) * 2 <= sizeY and sizeX - minOffset - maxOffset > 0:\n            newDoorPoints += [[(minX + minOffset + maxX - maxOffset) // 2, minY, 0, 2], [(minX + minOffset + maxX - maxOffset) // 2, maxY, 0, 0]]\n            newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n            doorPointOffset += 2\n            pass\n\n          sumY = mask.sum(1)\n          minOffset, maxOffset = 0, 0\n          for y in range(sizeY):\n            if sumY[y] * 2 >= sizeX:\n              break\n            minOffset += 1\n            continue\n\n          for y in range(sizeY - 1, -1, -1):\n            if sumY[y] * 2 >= sizeX:\n              break\n            maxOffset += 1\n            continue\n\n          if (sizeY - minOffset - maxOffset) * 2 <= sizeX and sizeY - minOffset - maxOffset > 0:\n            newDoorPoints += [[minX, (minY + minOffset + maxY - maxOffset) // 2, 0, 1], [maxX, (minY + minOffset + maxY - maxOffset) // 2, 0, 3]]\n            newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n            doorPointOffset += 2\n            pass\n          pass\n        pass\n      continue\n    continue\n  return newIcons, newIconPoints, newDoorLines, newDoorPoints\n\n## Sort lines so that the first point always has smaller x or y\ndef sortLines(points, lines):\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    if points[line[0]][lineDim] > points[line[1]][lineDim]:\n      lines[lineIndex] = (line[1], line[0])\n      pass\n    continue\n\n## Reconstruct a floorplan via IP optimization\ndef reconstructFloorplan(wallCornerHeatmaps, doorCornerHeatmaps, iconCornerHeatmaps, iconHeatmaps, roomHeatmaps, output_prefix=\'test/\', densityImage=None, gt_dict=None, gt=False, gap=-1, distanceThreshold=-1, lengthThreshold=-1, debug_prefix=\'test\', heatmapValueThresholdWall=None, heatmapValueThresholdDoor=None, heatmapValueThresholdIcon=None, enableAugmentation=False):\n  print(\'reconstruct\')\n\n  wallPoints = []\n  iconPoints = []\n  doorPoints = []\n  \n  numWallPoints = 100\n  numDoorPoints = 100\n  numIconPoints = 100\n  if heatmapValueThresholdWall is None:\n    heatmapValueThresholdWall = 0.5\n    pass\n  heatmapValueThresholdDoor = 0.5\n  heatmapValueThresholdIcon = 0.5\n\n  if gap > 0:\n    for k in GAPS:\n      GAPS[k] = gap\n      continue\n    pass\n  if distanceThreshold > 0:\n    for k in DISTANCES:\n      DISTANCES[k] = distanceThreshold\n      continue\n    pass\n  if lengthThreshold > 0:\n    for k in LENGTH_THRESHOLDS:\n      LENGTH_THRESHOLDS[k] = lengthThreshold\n      continue\n    pass\n\n  wallPoints, wallLines, wallPointOrientationLinesMap, wallPointNeighbors, augmentedPointMask = extractCorners(wallCornerHeatmaps, heatmapValueThresholdWall, gap=GAPS[\'wall_extraction\'], augment=enableAugmentation, gt=gt)\n  doorPoints, doorLines, doorPointOrientationLinesMap, doorPointNeighbors, _ = extractCorners(doorCornerHeatmaps, heatmapValueThresholdDoor, gap=GAPS[\'door_extraction\'], cornerType=\'door\', gt=gt)\n  iconPoints, iconLines, iconPointOrientationLinesMap, iconPointNeighbors, _ = extractCorners(iconCornerHeatmaps, heatmapValueThresholdIcon, gap=GAPS[\'icon_extraction\'], cornerType=\'icon\', gt=gt)\n\n  if not gt:\n    for pointIndex, point in enumerate(wallPoints):\n      #print((pointIndex, np.array(point[:2]).astype(np.int32).tolist(), point[2], point[3]))\n      continue\n\n    wallPoints, wallLines, wallPointOrientationLinesMap, wallPointNeighbors = filterWalls(wallPoints, wallLines)\n    pass\n\n\n  sortLines(doorPoints, doorLines)\n  sortLines(wallPoints, wallLines)\n\n  print(\'the number of points\', len(wallPoints), len(doorPoints), len(iconPoints))\n  print(\'the number of lines\', len(wallLines), len(doorLines), len(iconLines))\n\n\n  drawPoints(os.path.join(debug_prefix, ""points.png""), width, height, wallPoints, densityImage, pointSize=3)\n  drawPointsSeparately(os.path.join(debug_prefix, \'points\'), width, height, wallPoints, densityImage, pointSize=3)\n  drawLines(os.path.join(debug_prefix, \'lines.png\'), width, height, wallPoints, wallLines, [], None, 1, lineColor=255)\n\n  wallMask = drawLineMask(width, height, wallPoints, wallLines)\n\n  labelVotesMap = np.zeros((NUM_ROOMS, height, width))\n  #labelMap = np.zeros((NUM_LABELS, height, width))\n  #semanticHeatmaps = np.concatenate([iconHeatmaps, roomHeatmaps], axis=2)\n  for segmentIndex in range(NUM_ROOMS):\n    segmentation_img = roomHeatmaps[:, :, segmentIndex]\n    #segmentation_img = (segmentation_img > 0.5).astype(np.float)\n    labelVotesMap[segmentIndex] = segmentation_img\n    #labelMap[segmentIndex] = segmentation_img\n    continue\n\n  labelVotesMap = np.cumsum(np.cumsum(labelVotesMap, axis=1), axis=2)\n\n  icons = findIconsFromLines(iconPoints, iconLines)\n\n  if not gt:\n    newIcons, newIconPoints, newDoorLines, newDoorPoints = findCandidatesFromHeatmaps(iconHeatmaps, len(iconPoints), len(doorPoints))\n\n    icons += newIcons\n    iconPoints += newIconPoints\n    doorLines += newDoorLines\n    doorPoints += newDoorPoints\n    pass\n\n  if True:\n    drawLines(os.path.join(debug_prefix, \'lines.png\'), width, height, wallPoints, wallLines, [], None, 2, lineColor=255)\n    drawLines(os.path.join(debug_prefix, \'doors.png\'), width, height, doorPoints, doorLines, [], None, 2, lineColor=255)\n    drawRectangles(os.path.join(debug_prefix, \'icons.png\'), width, height, iconPoints, icons, {}, 2)\n    print(\'number of walls: \' + str(len(wallLines)))\n    print(\'number of doors: \' + str(len(doorLines)))\n    print(\'number of icons: \' + str(len(icons)))\n    pass\n\n\n  doorWallLineMap = findLineMap(doorPoints, doorLines, wallPoints, wallLines, gap=GAPS[\'wall_door_neighbor\'])\n\n  newDoorLines = []\n  newDoorWallLineMap = []\n  for lineIndex, walls in enumerate(doorWallLineMap):\n    if len(walls) > 0:\n      newDoorLines.append(doorLines[lineIndex])\n      newDoorWallLineMap.append(walls)\n      pass\n    continue\n  doorLines = newDoorLines\n  doorWallLineMap = newDoorWallLineMap\n\n\n  conflictWallLinePairs = findConflictLinePairs(wallPoints, wallLines, gap=GAPS[\'wall_conflict\'], distanceThreshold=DISTANCES[\'wall\'], considerEndPoints=True)\n\n  conflictDoorLinePairs = findConflictLinePairs(doorPoints, doorLines, gap=GAPS[\'door_conflict\'], distanceThreshold=DISTANCES[\'door\'])\n  conflictIconPairs = findConflictRectanglePairs(iconPoints, icons, gap=GAPS[\'icon_conflict\'])\n\n  if False:\n    print(wallLines)\n    os.system(\'mkdir \' + debug_prefix + \'/lines\')\n    for lineIndex, line in enumerate(wallLines):\n      drawLines(os.path.join(debug_prefix, \'lines/line_\' + str(lineIndex) + \'.png\'), width, height, wallPoints, [line], [], lineColor=255)\n      continue\n    exit(1)\n    pass\n\n\n  wallLineNeighbors = findLineNeighbors(wallPoints, wallLines, labelVotesMap, gap=GAPS[\'wall_neighbor\'])\n\n  iconWallLineNeighbors = findRectangleLineNeighbors(iconPoints, icons, wallPoints, wallLines, wallLineNeighbors, gap=GAPS[\'wall_icon_neighbor\'], distanceThreshold=DISTANCES[\'wall_icon\'])\n  conflictIconWallPairs = findConflictRectangleLinePairs(iconPoints, icons, wallPoints, wallLines, gap=GAPS[\'wall_icon_conflict\'])\n\n\n  if False:\n    print(conflictWallLinePairs)\n    for wallIndex in [0, 17]:\n      print(wallLines[wallIndex])\n      print([wallPoints[pointIndex] for pointIndex in wallLines[wallIndex]])\n      print(wallPointOrientationLinesMap[wallLines[wallIndex][0]])\n      print(wallPointOrientationLinesMap[wallLines[wallIndex][1]])\n      continue\n    exit(1)\n    pass\n\n\n  exteriorLines = {}\n  for lineIndex, neighbors in enumerate(wallLineNeighbors):\n    if len(neighbors[0]) == 0 and len(neighbors[1]) > 0:\n      exteriorLines[lineIndex] = 0\n    elif len(neighbors[0]) > 0 and len(neighbors[1]) == 0:\n      exteriorLines[lineIndex] = 1\n      pass\n    continue\n  #print(exteriorLines)\n\n  if False:\n    filteredWallLines = []\n    for lineIndex, neighbors in enumerate(wallLineNeighbors):\n      if len(neighbors[0]) == 0 and len(neighbors[1]) > 0:\n        print(lineIndex)\n        filteredWallLines.append(wallLines[lineIndex])\n        pass\n      continue\n    drawLines(os.path.join(debug_prefix, \'exterior_1.png\'), width, height, wallPoints, filteredWallLines, lineColor=255)\n\n    filteredWallLines = []\n    for lineIndex, neighbors in enumerate(wallLineNeighbors):\n      if len(neighbors[0]) > 0 and len(neighbors[1]) == 0:\n        print(lineIndex)\n        filteredWallLines.append(wallLines[lineIndex])\n        pass\n      continue\n    drawLines(os.path.join(debug_prefix, \'exterior_2.png\'), width, height, wallPoints, filteredWallLines, lineColor=255)\n    exit(1)\n    pass\n\n  if True:\n    #model = Model(""JunctionFilter"")\n    model = LpProblem(""JunctionFilter"", LpMinimize)\n\n    #add variables\n    w_p = [LpVariable(cat=LpBinary, name=""point_"" + str(pointIndex)) for pointIndex in range(len(wallPoints))]\n    w_l = [LpVariable(cat=LpBinary, name=""line_"" + str(lineIndex)) for lineIndex in range(len(wallLines))]\n\n    d_l = [LpVariable(cat=LpBinary, name=""door_line_"" + str(lineIndex)) for lineIndex in range(len(doorLines))]\n\n    i_r = [LpVariable(cat=LpBinary, name=""icon_rectangle_"" + str(lineIndex)) for lineIndex in range(len(icons))]\n\n    i_types = []\n    for iconIndex in range(len(icons)):\n      i_types.append([LpVariable(cat=LpBinary, name=""icon_type_"" + str(iconIndex) + ""_"" + str(typeIndex)) for typeIndex in range(NUM_ICONS)])\n      continue\n\n    l_dir_labels = []\n    for lineIndex in range(len(wallLines)):\n      dir_labels = []\n      for direction in range(2):\n        labels = []\n        for label in range(NUM_ROOMS):\n          labels.append(LpVariable(cat=LpBinary, name=""line_"" + str(lineIndex) + ""_"" + str(direction) + ""_"" + str(label)))\n        dir_labels.append(labels)\n      l_dir_labels.append(dir_labels)\n\n\n\n    #model.update()\n    #obj = QuadExpr()\n    obj = LpAffineExpression()\n    \n    if gt:\n      for pointIndex in range(len(wallPoints)):\n        model += (w_p[pointIndex] == 1, \'gt_point_active_\' + str(pointIndex))\n        continue\n\n      pointIconMap = {}\n      for iconIndex, icon in enumerate(icons):\n        for pointIndex in icon:\n          if pointIndex not in pointIconMap:\n            pointIconMap[pointIndex] = []\n            pass\n          pointIconMap[pointIndex].append(iconIndex)\n          continue\n        continue\n      for pointIndex, iconIndices in pointIconMap.items():\n        break\n        iconSum = LpAffineExpression()\n        for iconIndex in iconIndices:\n          iconSum += i_r[iconIndex]\n          continue\n        model += (iconSum == 1)\n        continue\n      pass\n\n    ## Semantic label one hot constraints\n    for lineIndex in range(len(wallLines)):\n      for direction in range(2):\n        labelSum = LpAffineExpression()\n        for label in range(NUM_ROOMS):\n          labelSum += l_dir_labels[lineIndex][direction][label]\n          continue\n        model += (labelSum == w_l[lineIndex], \'label_sum_\' + str(lineIndex) + \'_\' + str(direction))\n        continue\n      continue\n\n    ## Opposite room constraints\n    if False:\n      oppositeRoomPairs = [(1, 1), (2, 2), (4, 4), (5, 5), (7, 7), (9, 9)]\n      for lineIndex in range(len(wallLines)):\n        for oppositeRoomPair in oppositeRoomPairs:\n          model += (l_dir_labels[lineIndex][0][oppositeRoomPair[0]] + l_dir_labels[lineIndex][0][oppositeRoomPair[1]] <= 1)\n          if oppositeRoomPair[0] != oppositeRoomPair[1]:\n            model += (l_dir_labels[lineIndex][0][oppositeRoomPair[1]] + l_dir_labels[lineIndex][0][oppositeRoomPair[0]] <= 1)\n            pass\n          continue\n        continue\n      pass\n\n    ## Loop constraints\n    closeRooms = {}\n    for label in range(NUM_ROOMS):\n      closeRooms[label] = True\n      continue\n    closeRooms[1] = False\n    closeRooms[2] = False\n    #closeRooms[3] = False\n    closeRooms[8] = False\n    closeRooms[9] = False\n\n    for label in range(NUM_ROOMS):\n      if not closeRooms[label]:\n        continue\n      for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n        for orientation, lines in orientationLinesMap.items():\n          direction = int(orientation in [1, 2])\n          lineSum = LpAffineExpression()\n          for lineIndex in lines:\n            lineSum += l_dir_labels[lineIndex][direction][label]\n            continue\n          for nextOrientation in range(orientation + 1, 8):\n            if not (nextOrientation % 4) in orientationLinesMap:\n              continue\n            nextLines = orientationLinesMap[nextOrientation % 4]\n            nextDirection = int((nextOrientation % 4) in [0, 3])\n            nextLineSum = LpAffineExpression()\n            for nextLineIndex in nextLines:\n              nextLineSum += l_dir_labels[nextLineIndex][nextDirection][label]\n              continue\n            model += (lineSum == nextLineSum)\n            break\n          continue\n        continue\n      continue\n\n\n    ## Exterior constraints\n    exteriorLineSum = LpAffineExpression()\n    for lineIndex in range(len(wallLines)):\n      if lineIndex not in exteriorLines:\n        continue\n      #direction = exteriorLines[lineIndex]\n      label = 0\n      model += (l_dir_labels[lineIndex][0][label] + l_dir_labels[lineIndex][1][label] == w_l[lineIndex], \'exterior_wall_\' + str(lineIndex))\n      exteriorLineSum += w_l[lineIndex]\n      continue\n    model += (exteriorLineSum >= 1, \'exterior_wall_sum\')\n\n\n    ## Wall line room semantic objectives\n    for lineIndex, directionNeighbors in enumerate(wallLineNeighbors):\n      for direction, neighbors in enumerate(directionNeighbors):\n        labelVotesSum = np.zeros(NUM_ROOMS)\n        for neighbor, labelVotes in neighbors.items():\n          labelVotesSum += labelVotes\n          continue\n\n        votesSum = labelVotesSum.sum()\n        if votesSum == 0:\n          continue\n        labelVotesSum /= votesSum\n\n        for label in range(NUM_ROOMS):\n          obj += (l_dir_labels[lineIndex][direction][label] * (0.0 - labelVotesSum[label]) * labelWeight)\n          continue\n        continue\n      continue\n\n    ## Icon corner constraints (one icon corner belongs to at most one icon)\n    pointIconsMap = {}\n    for iconIndex, icon in enumerate(icons):\n      for cornerIndex in range(4):\n        pointIndex = icon[cornerIndex]\n        if pointIndex not in pointIconsMap:\n          pointIconsMap[pointIndex] = []\n          pass\n        pointIconsMap[pointIndex].append(iconIndex)\n        continue\n      continue\n\n    for pointIndex, iconIndices in pointIconsMap.items():\n      iconSum = LpAffineExpression()\n      for iconIndex in iconIndices:\n        iconSum += i_r[iconIndex]\n        continue\n      model += (iconSum <= 1)\n      continue\n\n    ## Wall confidence objective\n    wallLineConfidenceMap = roomHeatmaps[:, :, WALL_LABEL_OFFSET]\n    #cv2.imwrite(output_prefix + \'confidence.png\', (wallLineConfidenceMap * 255).astype(np.uint8))\n    wallConfidences = []\n    for lineIndex, line in enumerate(wallLines):\n      point_1 = np.array(wallPoints[line[0]][:2])\n      point_2 = np.array(wallPoints[line[1]][:2])\n      lineDim = calcLineDim(wallPoints, line)\n\n      fixedValue = int(round((point_1[1 - lineDim] + point_2[1 - lineDim]) // 2))\n      point_1[lineDim], point_2[lineDim] = min(point_1[lineDim], point_2[lineDim]), max(point_1[lineDim], point_2[lineDim])\n\n      point_1[1 - lineDim] = fixedValue - wallLineWidth\n      point_2[1 - lineDim] = fixedValue + wallLineWidth\n\n      point_1 = np.maximum(point_1, 0).astype(np.int32)\n      point_2 = np.minimum(point_2, sizes - 1).astype(np.int32)\n\n      wallLineConfidence = np.sum(wallLineConfidenceMap[point_1[1]:point_2[1] + 1, point_1[0]:point_2[0] + 1]) / ((point_2[1] + 1 - point_1[1]) * (point_2[0] + 1 - point_1[0])) - 0.5\n\n      obj += (-wallLineConfidence * w_l[lineIndex] * wallWeight)\n\n      wallConfidences.append(wallLineConfidence)\n      continue\n\n    if not gt:\n      for wallIndex, wallLine in enumerate(wallLines):\n        #print(\'wall confidence\', wallIndex, [np.array(wallPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in wallLine], wallConfidences[wallIndex])\n        continue\n      pass\n\n\n    ## Door confidence objective\n    doorLineConfidenceMap = iconHeatmaps[:, :, DOOR_LABEL_OFFSET]\n    #cv2.imwrite(output_prefix + \'confidence.png\', (doorLineConfidenceMap * 255).astype(np.uint8))\n    #cv2.imwrite(output_prefix + \'segmentation.png\', drawSegmentationImage(doorCornerHeatmaps))\n\n    for lineIndex, line in enumerate(doorLines):\n      point_1 = np.array(doorPoints[line[0]][:2])\n      point_2 = np.array(doorPoints[line[1]][:2])\n      lineDim = calcLineDim(doorPoints, line)\n\n      fixedValue = int(round((point_1[1 - lineDim] + point_2[1 - lineDim]) // 2))\n\n      #assert(point_1[lineDim] < point_2[lineDim], \'door line reversed\')\n      point_1[lineDim], point_2[lineDim] = min(point_1[lineDim], point_2[lineDim]), max(point_1[lineDim], point_2[lineDim])\n\n      point_1[1 - lineDim] = fixedValue - doorLineWidth\n      point_2[1 - lineDim] = fixedValue + doorLineWidth\n\n      point_1 = np.maximum(point_1, 0).astype(np.int32)\n      point_2 = np.minimum(point_2, sizes - 1).astype(np.int32)\n\n      if not gt:\n        doorLineConfidence = np.sum(doorLineConfidenceMap[point_1[1]:point_2[1] + 1, point_1[0]:point_2[0] + 1]) / ((point_2[1] + 1 - point_1[1]) * (point_2[0] + 1 - point_1[0]))\n\n        if lineDim == 0:\n          doorPointConfidence = (doorCornerHeatmaps[point_1[1], point_1[0], 3] + doorCornerHeatmaps[point_2[1], point_2[0], 1]) / 2\n        else:\n          doorPointConfidence = (doorCornerHeatmaps[point_1[1], point_1[0], 0] + doorCornerHeatmaps[point_2[1], point_2[0], 2]) / 2\n          pass\n        doorConfidence = (doorLineConfidence + doorPointConfidence) * 0.5 - 0.5\n        #print(\'door confidence\', doorConfidence)\n        obj += (-doorConfidence * d_l[lineIndex] * doorWeight)\n      else:\n        obj += (-0.5 * d_l[lineIndex] * doorWeight)\n        pass\n      continue\n\n    ## Icon confidence objective  \n    for iconIndex, icon in enumerate(icons):\n      point_1 = iconPoints[icon[0]]\n      point_2 = iconPoints[icon[1]]\n      point_3 = iconPoints[icon[2]]\n      point_4 = iconPoints[icon[3]]\n\n      x_1 = int((point_1[0] + point_3[0]) // 2)\n      x_2 = int((point_2[0] + point_4[0]) // 2)\n      y_1 = int((point_1[1] + point_2[1]) // 2)\n      y_2 = int((point_3[1] + point_4[1]) // 2)\n\n      iconArea = (x_2 - x_1 + 1) * (y_2 - y_1 + 1)\n\n      if iconArea <= 1e-4:\n        print(icon)\n        print([iconPoints[pointIndex] for pointIndex in icon])\n        print(\'zero size icon\')\n        exit(1)\n        pass\n\n      iconTypeConfidence = iconHeatmaps[y_1:y_2 + 1, x_1:x_2 + 1, :NUM_ICONS + 1].sum(axis=(0, 1)) / iconArea\n      iconTypeConfidence = iconTypeConfidence[1:] - iconTypeConfidence[0]\n\n      if not gt:\n        iconPointConfidence = (iconCornerHeatmaps[int(round(point_1[1])), int(round(point_1[0])), 2] + iconCornerHeatmaps[int(round(point_2[1])), int(round(point_2[0])), 3] + iconCornerHeatmaps[int(round(point_3[1])), int(round(point_3[0])), 1] + iconCornerHeatmaps[int(round(point_4[1])), int(round(point_4[0])), 0]) // 4 - 0.5\n        iconConfidence = (iconTypeConfidence + iconPointConfidence) * 0.5\n      else:\n        iconConfidence = iconTypeConfidence\n        pass\n\n      #print(\'icon confidence\', iconConfidence)\n      for typeIndex in range(NUM_ICONS):\n        obj += (-i_types[iconIndex][typeIndex] * (iconConfidence[typeIndex]) * iconTypeWeight)\n        continue\n      continue\n\n    ## Icon type one hot constraints\n    for iconIndex in range(len(icons)):\n      typeSum = LpAffineExpression()\n      for typeIndex in range(NUM_ICONS - 1):\n        typeSum += i_types[iconIndex][typeIndex]\n        continue\n      model += (typeSum == i_r[iconIndex])\n      continue\n\n\n    ## Line sum constraints (each orientation has at most one wall line)\n    for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n      for orientation, lines in orientationLinesMap.items():\n        #if len(lines) > 1:\n        #print(lines)\n        lineSum = LpAffineExpression()\n        for lineIndex in lines:\n          lineSum += w_l[lineIndex]\n          continue\n\n        model += (lineSum == w_p[pointIndex], ""line_sum_"" + str(pointIndex) + ""_"" + str(orientation))\n        continue\n      continue\n\n    ## Conflict constraints\n    for index, conflictLinePair in enumerate(conflictWallLinePairs):\n      model += (w_l[conflictLinePair[0]] + w_l[conflictLinePair[1]] <= 1, \'conflict_wall_line_pair_\' + str(index))\n      continue\n\n    for index, conflictLinePair in enumerate(conflictDoorLinePairs):\n      model += (d_l[conflictLinePair[0]] + d_l[conflictLinePair[1]] <= 1, \'conflict_door_line_pair_\' + str(index))\n      continue\n\n    for index, conflictIconPair in enumerate(conflictIconPairs):\n      model += (i_r[conflictIconPair[0]] + i_r[conflictIconPair[1]] <= 1, \'conflict_icon_pair_\' + str(index))\n      continue\n\n    for index, conflictLinePair in enumerate(conflictIconWallPairs):\n      model += (i_r[conflictLinePair[0]] + w_l[conflictLinePair[1]] <= 1, \'conflict_icon_wall_pair_\' + str(index))\n      continue\n\n\n    ## Door wall constraints (a door must sit on one and only one wall)\n    for doorIndex, lines in enumerate(doorWallLineMap):\n      if len(lines) == 0:\n        model += (d_l[doorIndex] == 0, \'door_not_on_walls_\' + str(doorIndex))\n        continue\n      lineSum = LpAffineExpression()\n      for lineIndex in lines:\n        lineSum += w_l[lineIndex]\n        continue\n      model += (d_l[doorIndex] <= lineSum, \'d_wall_line_sum_\' + str(doorIndex))\n      continue\n\n    doorWallPointMap = findLinePointMap(doorPoints, doorLines, wallPoints, gap=GAPS[\'door_point_conflict\'])\n    for doorIndex, points in enumerate(doorWallPointMap):\n      if len(points) == 0:\n        continue\n      pointSum = LpAffineExpression()\n      for pointIndex in points:\n        model += (d_l[doorIndex] + w_p[pointIndex] <= 1, \'door_on_two_walls_\' + str(doorIndex) + \'_\' + str(pointIndex))\n        continue\n      continue\n\n    if False:\n      #model += (w_l[6] == 1)\n      pass\n\n    model += obj\n    model.solve()\n\n    #model.writeLP(debug_prefix + \'/model.lp\')\n    print(\'Optimization information\', LpStatus[model.status], value(model.objective))\n\n    if LpStatus[model.status] == \'Optimal\':\n      filteredWallLines = []\n      filteredWallLabels = []\n      filteredWallTypes = []\n      wallPointLabels = [[-1, -1, -1, -1] for pointIndex in range(len(wallPoints))]\n\n      for lineIndex, lineVar in enumerate(w_l):\n        if lineVar.varValue < 0.5:\n          continue\n        filteredWallLines.append(wallLines[lineIndex])\n\n        filteredWallTypes.append(0)\n\n        labels = [11, 11]\n        for direction in range(2):\n          for label in range(NUM_ROOMS):\n            if l_dir_labels[lineIndex][direction][label].varValue > 0.5:\n              labels[direction] = label\n              break\n            continue\n          continue\n\n        filteredWallLabels.append(labels)\n        print(\'wall\', lineIndex, labels, [np.array(wallPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in wallLines[lineIndex]], wallLineNeighbors[lineIndex][0].keys(), wallLineNeighbors[lineIndex][1].keys())\n        line = wallLines[lineIndex]\n        lineDim = calcLineDim(wallPoints, line)\n        if lineDim == 0:\n          wallPointLabels[line[0]][0] = labels[0]\n          wallPointLabels[line[0]][1] = labels[1]\n          wallPointLabels[line[1]][3] = labels[0]\n          wallPointLabels[line[1]][2] = labels[1]\n        else:\n          wallPointLabels[line[0]][1] = labels[0]\n          wallPointLabels[line[0]][2] = labels[1]\n          wallPointLabels[line[1]][0] = labels[0]\n          wallPointLabels[line[1]][3] = labels[1]\n          pass\n        continue\n\n      if not gt:\n        adjustPoints(wallPoints, filteredWallLines)\n        mergePoints(wallPoints, filteredWallLines)\n        adjustPoints(wallPoints, filteredWallLines)\n        filteredWallLabels = [filteredWallLabels[lineIndex] for lineIndex in range(len(filteredWallLines)) if filteredWallLines[lineIndex][0] != filteredWallLines[lineIndex][1]]\n        filteredWallLines = [line for line in filteredWallLines if line[0] != line[1]]\n        pass\n\n\n      drawLines(output_prefix + \'result_line.png\', width, height, wallPoints, filteredWallLines, filteredWallLabels, lineColor=255)\n      #resultImage = drawLines(\'\', width, height, wallPoints, filteredWallLines, filteredWallLabels, None, lineWidth=5, lineColor=255)\n\n      filteredDoorLines = []\n      filteredDoorTypes = []\n      for lineIndex, lineVar in enumerate(d_l):\n        if lineVar.varValue < 0.5:\n          continue\n        print((\'door\', lineIndex, [doorPoints[pointIndex][:2] for pointIndex in doorLines[lineIndex]]))\n        filteredDoorLines.append(doorLines[lineIndex])\n\n        filteredDoorTypes.append(0)\n        continue\n\n      filteredDoorWallMap = findLineMapSingle(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, gap=GAPS[\'wall_door_neighbor\'])\n      adjustDoorPoints(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, filteredDoorWallMap)\n      drawLines(output_prefix + \'result_door.png\', width, height, doorPoints, filteredDoorLines, lineColor=255)\n\n      filteredIcons = []\n      filteredIconTypes = []\n      for iconIndex, iconVar in enumerate(i_r):\n        if iconVar.varValue < 0.5:\n          continue\n\n        filteredIcons.append(icons[iconIndex])\n        iconType = -1\n        for typeIndex in range(NUM_ICONS):\n          if i_types[iconIndex][typeIndex].varValue > 0.5:\n            iconType = typeIndex\n            break\n          continue\n\n        print((\'icon\', iconIndex, iconType, [iconPoints[pointIndex][:2] for pointIndex in icons[iconIndex]]))\n\n        filteredIconTypes.append(iconType)\n        continue\n\n      #adjustPoints(iconPoints, filteredIconLines)\n      #drawLines(output_prefix + \'lines_results_icon.png\', width, height, iconPoints, filteredIconLines)\n      drawRectangles(output_prefix + \'result_icon.png\', width, height, iconPoints, filteredIcons, filteredIconTypes)\n\n      #resultImage = drawLines(\'\', width, height, doorPoints, filteredDoorLines, [], resultImage, lineWidth=3, lineColor=0)\n      #resultImage = drawRectangles(\'\', width, height, iconPoints, filteredIcons, filteredIconTypes, 2, resultImage)\n      #cv2.imwrite(output_prefix + \'result.png\', resultImage)\n\n      filteredWallPoints = []\n      filteredWallPointLabels = []\n      orientationMap = {}\n      for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n        for orientation, orientations in enumerate(orientationOrientations):\n          orientationMap[orientations] = orientation\n\n      for pointIndex, point in enumerate(wallPoints):\n        orientations = []\n        orientationLines = {}\n        for orientation, lines in wallPointOrientationLinesMap[pointIndex].items():\n          orientationLine = -1\n          for lineIndex in lines:\n            if w_l[lineIndex].varValue > 0.5:\n              orientations.append(orientation)\n              orientationLines[orientation] = lineIndex\n              break\n            continue\n          continue\n\n        if len(orientations) == 0:\n          continue\n\n        #print((pointIndex, orientationLines))\n\n        if len(orientations) < len(wallPointOrientationLinesMap[pointIndex]):\n          print(\'invalid point\', pointIndex, orientations, wallPointOrientationLinesMap[pointIndex])\n          print(wallPoints[pointIndex])\n          wallPoints[pointIndex][2] = len(orientations) - 1\n          orientations = tuple(orientations)\n          if orientations not in orientationMap:\n            continue\n          wallPoints[pointIndex][3] = orientationMap[orientations]\n          print(wallPoints[pointIndex])\n          exit(1)\n          pass\n\n        filteredWallPoints.append(wallPoints[pointIndex])\n        filteredWallPointLabels.append(wallPointLabels[pointIndex])\n        continue\n\n\n      with open(output_prefix + \'floorplan.txt\', \'w\') as result_file:\n        result_file.write(str(width) + \'\\t\' + str(height) + \'\\n\')\n        result_file.write(str(len(filteredWallLines)) + \'\\n\')\n        for wallIndex, wall in enumerate(filteredWallLines):\n          point_1 = wallPoints[wall[0]]\n          point_2 = wallPoints[wall[1]]\n\n          result_file.write(str(point_1[0]) + \'\\t\' + str(point_1[1]) + \'\\t\')\n          result_file.write(str(point_2[0]) + \'\\t\' + str(point_2[1]) + \'\\t\')\n          result_file.write(str(filteredWallLabels[wallIndex][0]) + \'\\t\' + str(filteredWallLabels[wallIndex][1]) + \'\\n\')\n\n        for doorIndex, door in enumerate(filteredDoorLines):\n          point_1 = doorPoints[door[0]]\n          point_2 = doorPoints[door[1]]\n\n          result_file.write(str(point_1[0]) + \'\\t\' + str(point_1[1]) + \'\\t\')\n          result_file.write(str(point_2[0]) + \'\\t\' + str(point_2[1]) + \'\\t\')\n          result_file.write(\'door\\t\')\n          result_file.write(str(filteredDoorTypes[doorIndex] + 1) + \'\\t1\\n\')\n\n        for iconIndex, icon in enumerate(filteredIcons):\n          point_1 = iconPoints[icon[0]]\n          point_2 = iconPoints[icon[1]]\n          point_3 = iconPoints[icon[2]]\n          point_4 = iconPoints[icon[3]]\n\n          x_1 = int((point_1[0] + point_3[0]) // 2)\n          x_2 = int((point_2[0] + point_4[0]) // 2)\n          y_1 = int((point_1[1] + point_2[1]) // 2)\n          y_2 = int((point_3[1] + point_4[1]) // 2)\n\n          result_file.write(str(x_1) + \'\\t\' + str(y_1) + \'\\t\')\n          result_file.write(str(x_2) + \'\\t\' + str(y_2) + \'\\t\')\n          result_file.write(iconNumberNameMap[filteredIconTypes[iconIndex]] + \'\\t\')\n          #result_file.write(str(iconNumberStyleMap[filteredIconTypes[iconIndex]]) + \'\\t\')\n          result_file.write(\'1\\t\')\n          result_file.write(\'1\\n\')\n\n        result_file.close()\n\n\n      # writePoints(filteredWallPoints, filteredWallPointLabels, output_prefix=output_prefix)\n        \n      # if len(filteredDoorLines) > 0:\n      #   writeDoors(doorPoints, filteredDoorLines, filteredDoorTypes, output_prefix=output_prefix)\n      #   pass\n      # else:\n      #   try:\n      #     os.remove(output_prefix + \'doors_out.txt\')\n      #   except OSError:\n      #     pass\n\n      # if len(filteredIcons) > 0:\n      #   writeIcons(iconPoints, filteredIcons, filteredIconTypes, output_prefix=output_prefix)\n      #   pass\n      # else:\n      #   try:\n      #     os.remove(output_prefix + \'icons_out.txt\')\n      #   except OSError:\n      #     pass\n      #   pass\n\n    else:\n      print(\'infeasible\')\n      #model.ComputeIIS()\n      #model.write(""test/model.ilp"")\n      return {}\n      pass\n\n  result_dict = {\'wall\': [wallPoints, filteredWallLines, filteredWallLabels], \'door\': [doorPoints, filteredDoorLines, []], \'icon\': [iconPoints, filteredIcons, filteredIconTypes]}\n  return result_dict\n'"
pytorch/IP_gurobi.py,0,"b'from gurobipy import *\nimport cv2\nimport numpy as np\nimport sys\nimport csv\nimport copy\nfrom utils import *\nfrom floorplan_utils import *\nfrom skimage import measure\n\n# if len(sys.argv) == 2 and int(sys.argv[1]) == 1:\n#   withoutQP = True\n# else:\n#   withoutQP = False\n#   pass\nwithoutQP = False\n\n#GAP = 5\n#GAPS = {\'wall_extraction\': 10, \'door_extraction\': 5, \'icon_extraction\': 5, \'wall_neighbor\': 10, \'door_neighbor\': 10, \'icon_neighbor\': 10, \'wall_conflict\': 10, \'door_conflict\': 10, \'icon_conflict\': 10, \'wall_icon_neighbor\': 5, \'wall_icon_conflict\': 5, \'wall_door_neighbor\': 5}\n#DISTANCES = {\'wall_icon\': 10, \'point\': 10, \'wall\': 10, \'door\': 10, \'icon\': 10}\n\nGAPS = {\'wall_extraction\': 5, \'door_extraction\': 5, \'icon_extraction\': 5, \'wall_neighbor\': 5, \'door_neighbor\': 5, \'icon_neighbor\': 5, \'wall_conflict\': 5, \'door_conflict\': 5, \'icon_conflict\': 5, \'wall_icon_neighbor\': 5, \'wall_icon_conflict\': 5, \'wall_door_neighbor\': 5, \'door_point_conflict\': 5}\nDISTANCES = {\'wall_icon\': 5, \'point\': 5, \'wall\': 10, \'door\': 5, \'icon\': 5}\nLENGTH_THRESHOLDS = {\'wall\': 5, \'door\': 5, \'icon\': 5}\n\n\njunctionWeight = 100\naugmentedJunctionWeight = 50\nlabelWeight = 1\n\nwallWeight = 10\ndoorWeight = 10\niconWeight = 10\n\n#wallTypeWeight = 10\n#doorTypeWeight = 10\niconTypeWeight = 10\n\nwallLineWidth = 3\ndoorLineWidth = 2\n#doorExposureWeight = 0\n\n\nNUM_WALL_TYPES = 1\nNUM_DOOR_TYPES = 2\n#NUM_LABELS = NUM_WALL_TYPES + NUM_DOOR_TYPES + NUM_ICONS + NUM_ROOMS + 1\nNUM_LABELS = NUM_ICONS + NUM_ROOMS\n\nWALL_LABEL_OFFSET = NUM_FINAL_ROOMS\nDOOR_LABEL_OFFSET = NUM_FINAL_ICONS + 1\nICON_LABEL_OFFSET = 0\nROOM_LABEL_OFFSET = NUM_ICONS\n\n\ncolorMap = ColorPalette(NUM_CORNERS).getColorMap()\n\n\n#colorMap = np.random.rand(11, 3) * 255\n#colorMap[0] = 160\n# iconWallTypesMap[0] = \'bathtub\'\n# iconWallTypesMap[1] = \'cooking counter\'\n# iconWallTypesMap[2] = \'toilet\'\n# iconWallTypesMap[3] = \'entrance\'\n# iconWallTypesMap[4] = \'washing basin\'\n# iconWallTypesMap[5] = \'washing machine\'\n# iconWallTypesMap[6] = \'washing basin\'\n# iconWallTypesMap[7] = \'cross\'\n# iconWallTypesMap[8] = \'column\'\n# iconWallTypesMap[9] = \'stairs\'\n\n#floorplan = cv2.imread(\'test/floorplan.png\')\n\n\nwidth = 256\nheight = 256\nmaxDim = max(width, height)\nsizes = np.array([width, height])\n\nORIENTATION_RANGES = getOrientationRanges(width, height)\n\n#iconStyles = [1, 1, 1, 1, 1, 2, 1, 1, 3, 1]\niconNames = getIconNames()\niconNameNumberMap = dict(zip(iconNames, range(len(iconNames))))\niconNumberNameMap = dict(zip(range(len(iconNames)), iconNames))\n#iconNumberStyleMap = dict(zip(range(len(iconStyles)), iconStyles))\n\ndef findMatches(pred_dict, gt_dict, distanceThreshold, width=256, height=256):\n  correctSums = {k: 0.0 for k in gt_dict}\n  countsGT = {k: 0.0 for k in gt_dict}\n  countsPred = {k: 0.0 for k in gt_dict}\n  for objectType, objects in gt_dict.iteritems():\n    if objectType not in pred_dict:\n      print(objectType + \' not in prediction\')\n      continue\n\n    pointsGT = objects[0]\n    pointsPred = pred_dict[objectType][0]\n    if objectType == \'wall\':\n      validPointMaskGT = {}\n      for line in objects[1]:\n        validPointMaskGT[line[0]] = True\n        validPointMaskGT[line[1]] = True\n        continue\n      validPointsGT = [pointsGT[pointIndex] for pointIndex in validPointMaskGT]\n\n      #print([(pred_dict[objectType][0][line[0]][:2], pred_dict[objectType][0][line[1]][:2]) for line in pred_dict[objectType][1]])\n      #exit(1)\n      validPointMaskPred = {}\n      for line in pred_dict[objectType][1]:\n        validPointMaskPred[line[0]] = True\n        validPointMaskPred[line[1]] = True\n        continue\n      validPointsPred = [pointsPred[pointIndex] for pointIndex in validPointMaskPred]\n\n      if True:\n        # degree insensitive\n        pointIndexMap = []\n        for pointIndexGT, pointGT in enumerate(validPointsGT):\n          matchedPointMask = {}\n          for pointIndexPred, pointPred in enumerate(validPointsPred):\n            if pointPred[2] == pointGT[2] and pointPred[3] == pointGT[3] and pointDistance(pointPred[0:2], pointGT[0:2]) < distanceThreshold:\n              matchedPointMask[pointIndexPred] = True\n              pass\n            continue\n          if len(matchedPointMask) == 0:\n            print(pointIndexGT, pointGT, \'point not found\')\n            pass\n          pointIndexMap.append(matchedPointMask)\n          continue\n\n        correctSums[objectType] += len([indexMap for indexMap in pointIndexMap if len(indexMap) > 0])\n        countsGT[objectType] += len(validPointsGT)\n        countsPred[objectType] += len(validPointsPred)\n      else:\n        numMatches = 0\n        matchedMask = {}\n        pointMatchMap = {}\n        for pointIndexPred, pointPred in enumerate(validPointsPred):\n          minDistancePair = (10000, -1)\n          for pointIndexGT, pointGT in enumerate(validPointsGT):\n            distance = pointDistance(pointPred[0:2], pointGT[0:2])\n            if distance < minDistancePair[0]:\n              minDistancePair = (distance, pointIndexGT)\n              pass\n            continue\n          pointMatchMap[pointIndexPred] = minDistancePair[1]\n          continue\n\n        for pointIndexGT, pointGT in enumerate(validPointsGT):\n          matchedOrientations = {}\n          for orientation in POINT_ORIENTATIONS[pointGT[2]][pointGT[3]]:\n            matchedOrientations[orientation] = False\n            continue\n          for pointIndexPred, pointPred in enumerate(validPointsPred):\n            if pointMatchMap[pointIndexPred] != pointIndexGT:\n              continue\n            if pointDistance(pointPred[0:2], pointGT[0:2]) < distanceThreshold:\n              for orientation in POINT_ORIENTATIONS[pointPred[2]][pointPred[3]]:\n                if orientation in matchedOrientations and matchedOrientations[orientation] == False:\n                  if (pointIndexPred, orientation) not in matchedMask:\n                    matchedMask[(pointIndexPred, orientation)] = True\n                    matchedOrientations[orientation] = True\n                    pass\n                  pass\n                continue\n              pass\n            continue\n          for orientation, hasMatch in matchedOrientations.iteritems():\n            if not hasMatch:\n              print(pointIndexGT, pointGT, orientation, \'point not found\')\n              pass\n            continue\n          numMatches += len([orientation for orientation, value in matchedOrientations.iteritems() if value == True])\n          continue\n\n        correctSums[objectType] += numMatches\n        countsGT[objectType] += sum([point[2] + 1 for point in validPointsGT])\n        countsPred[objectType] += sum([point[2] + 1 for point in validPointsPred])\n\n      continue\n\n    if objectType == \'door\':\n      linesGT = objects[1]\n      linesPred = pred_dict[objectType][1]\n      lineIndexMap = []\n      for lineIndexGT, lineGT in enumerate(linesGT):\n        matchedLineMask = {}\n        for lineIndexPred, linePred in enumerate(linesPred):\n          #if (linePred[0] in pointIndexMap[lineGT[0]] and linePred[1] in pointIndexMap[lineGT[1]]) or (linePred[1] in pointIndexMap[lineGT[0]] and linePred[0] in pointIndexMap[lineGT[1]]):\n          if (pointDistance(pointsPred[linePred[0]], pointsGT[lineGT[0]]) < distanceThreshold and pointDistance(pointsPred[linePred[1]], pointsGT[lineGT[1]]) < distanceThreshold) or (pointDistance(pointsPred[linePred[0]], pointsGT[lineGT[1]]) < distanceThreshold and pointDistance(pointsPred[linePred[1]], pointsGT[lineGT[0]]) < distanceThreshold):\n            matchedLineMask[lineIndexPred] = True\n            #print(\'match\', lineGT, linePred)\n            pass\n          continue\n        if len(matchedLineMask) == 0:\n          print(lineIndexGT, lineGT, [pointsGT[pointIndex][:2] for pointIndex in lineGT], \'door not found\')\n          pass\n        lineIndexMap.append(matchedLineMask)\n        continue\n\n      correctSums[objectType] += len([indexMap for indexMap in lineIndexMap if len(indexMap) > 0])\n      countsGT[objectType] += len(linesGT)\n      countsPred[objectType] += len(linesPred)\n      continue\n\n    if objectType == \'icon\':\n      rectanglesGT = objects[1]\n      rectanglesPred = pred_dict[objectType][1]\n      labelsGT = objects[2]\n      labelsPred = pred_dict[objectType][2]\n\n      rectangleIndexMap = []\n      for indexGT, rectangleGT in enumerate(rectanglesGT):\n        matchedRectangleMask = {}\n        for indexPred, rectanglePred in enumerate(rectanglesPred):\n          if labelsGT[indexGT] == labelsPred[indexPred] and calcIOU([pointsPred[pointIndex] for pointIndex in rectanglePred], [pointsGT[pointIndex] for pointIndex in rectangleGT]) >= 0.3:\n            matchedRectangleMask[indexPred] = True\n            pass\n          continue\n        if len(matchedRectangleMask) == 0:\n          print(indexGT, rectangleGT, [pointsGT[pointIndex][:2] for pointIndex in rectangleGT], \'icon not found\')\n          pass\n        rectangleIndexMap.append(matchedRectangleMask)\n        continue\n\n      correctSums[objectType] += len([indexMap for indexMap in rectangleIndexMap if len(indexMap) > 0])\n      countsGT[objectType] += len(rectanglesGT)\n      countsPred[objectType] += len(rectanglesPred)\n      pass\n    continue\n\n  roomsInfo = []\n  wallLineWidth = 3\n  dicts = [gt_dict, pred_dict]\n  for dictIndex in range(2):\n    wall_dict = dicts[dictIndex][\'wall\']\n    wallMask = drawWallMask([(wall_dict[0][line[0]], wall_dict[0][line[1]]) for line in wall_dict[1]], width, height, thickness=wallLineWidth)\n    roomRegions = measure.label(1 - wallMask, background=0)\n    cv2.imwrite(\'test/\' + str(dictIndex) + \'_segmentation_regions.png\', drawSegmentationImage(roomRegions))\n    backgroundIndex = roomRegions.min()\n    wallPoints = wall_dict[0]\n    roomSegmentation = np.zeros(roomRegions.shape, dtype=np.int32)\n    roomLabels = {}\n    adjacentRoomPairs = []\n    for wallIndex, wallLabels in enumerate(wall_dict[2]):\n      wallLine = wall_dict[1][wallIndex]\n      lineDim = calcLineDim(wallPoints, wallLine)\n      center = np.round((np.array(wallPoints[wallLine[0]][:2]) + np.array(wallPoints[wallLine[1]][:2])) / 2).astype(np.int32)\n      adjacentRoomPair = []\n      for c in range(2):\n        direction = c * 2 - 1\n        if lineDim == 1:\n          direction *= -1\n          pass\n        point = center\n        for offset in range(10):\n          point[1 - lineDim] += direction\n          if point[lineDim] < 0 or point[lineDim] >= sizes[lineDim]:\n            break\n          roomIndex = roomRegions[point[1], point[0]]\n          if roomIndex != backgroundIndex:\n            #print(wallIndex, center.tolist(), point.tolist(), wallLabels[c])\n            # if wallLabels[c] not in rooms:\n            #   rooms[wallLabels[c]] = []\n            #   pass\n            mask = roomRegions == roomIndex\n            roomSegmentation[mask] = wallLabels[c]\n            #rooms[wallLabels[c]].append(cv2.dilate(mask.astype(np.uint8), np.ones((3, 3)), iterations=wallLineWidth))\n            #roomRegions[mask] = backgroundIndex\n            if roomIndex not in roomLabels:\n              roomLabels[roomIndex] = {}\n              pass\n            roomLabels[roomIndex][wallLabels[c]] = True\n            adjacentRoomPair.append(roomIndex)\n            break\n            pass\n          continue\n        continue\n      if len(adjacentRoomPair) == 2:\n        adjacentRoomPairs.append(adjacentRoomPair)\n        pass\n      continue\n\n    neighborRoomPairs = []\n    door_dict = dicts[dictIndex][\'door\']\n    for doorLine in door_dict[1]:\n      lineDim = calcLineDim(door_dict[0], doorLine)\n      center = np.round((np.array(door_dict[0][doorLine[0]][:2]) + np.array(door_dict[0][doorLine[1]][:2])) / 2).astype(np.int32)\n      neighborRoomPair = []\n      for c in range(2):\n        direction = c * 2 - 1\n        point = center\n        for offset in range(10):\n          point[1 - lineDim] += direction\n          if point[lineDim] < 0 or point[lineDim] >= sizes[lineDim]:\n            break\n          roomIndex = roomRegions[point[1], point[0]]\n          if roomIndex != backgroundIndex:\n            neighborRoomPair.append(roomIndex)\n            break\n            pass\n          continue\n        continue\n      if len(neighborRoomPair) == 2:\n        neighborRoomPairs.append(neighborRoomPair)\n        pass\n      continue\n\n    rooms = []\n    indexMap = {}\n    for roomIndex, labels in roomLabels.iteritems():\n      indexMap[roomIndex] = len(rooms)\n      mask = roomRegions == roomIndex\n      mask = cv2.dilate(mask.astype(np.uint8), np.ones((3, 3)), iterations=wallLineWidth)\n      if 7 in labels and 2 not in labels:\n        labels[2] = True\n        pass\n      if 5 in labels and 3 not in labels:\n        labels[3] = True\n        pass\n      if 9 in labels and 1 not in labels:\n        labels[1] = True\n        pass\n      rooms.append((mask, labels))\n      continue\n\n    neighborRoomPairs = [(indexMap[neighborRoomPair[0]], indexMap[neighborRoomPair[1]]) for neighborRoomPair in neighborRoomPairs]\n    neighborMatrix = np.zeros((len(rooms), len(rooms)))\n    for neighborRoomPair in neighborRoomPairs:\n      neighborMatrix[neighborRoomPair[0]][neighborRoomPair[1]] = 1\n      neighborMatrix[neighborRoomPair[1]][neighborRoomPair[0]] = 1\n      continue\n\n    adjacentRoomPairs = [(indexMap[adjacentRoomPair[0]], indexMap[adjacentRoomPair[1]]) for adjacentRoomPair in adjacentRoomPairs]\n    adjacentMatrix = np.zeros((len(rooms), len(rooms)))\n    for adjacentRoomPair in adjacentRoomPairs:\n      adjacentMatrix[adjacentRoomPair[0]][adjacentRoomPair[1]] = 1\n      adjacentMatrix[adjacentRoomPair[1]][adjacentRoomPair[0]] = 1\n      continue\n    #exit(1)\n    roomsInfo.append([rooms, neighborMatrix, adjacentMatrix])\n    continue\n\n  #gt_dict[\'room\'] = zip(*roomsInfo[0][0])\n  #pred_dict[\'room\'] = zip(*roomsInfo[1][0])\n\n  #countsPred[\'room\'] = sum([len(roomsPred) for roomLabel, roomsPred in labelRooms[1].iteritems()])\n  countsPred[\'room\'] = len(roomsInfo[1][0])\n  countsGT[\'room\'] = len(roomsInfo[0][0])\n  correctSums[\'room\'] = 0.0\n  for roomGT in roomsInfo[0][0]:\n    hasMatch = False\n    for roomPred in roomsInfo[1][0]:\n      hasCommonLabel = False\n      for labelGT in roomGT[1]:\n        if labelGT in roomPred[1]:\n          hasCommonLabel = True\n          break\n        continue\n      # if 8 in roomGT[1]:\n      #   print(roomPred[1], calcIOUMask(roomPred[0], roomGT[0]))\n      #   pass\n      if hasCommonLabel and calcIOUMask(roomPred[0], roomGT[0]) >= 0.5:\n        correctSums[\'room\'] += 1\n        hasMatch = True\n        break\n      continue\n    if not hasMatch:\n      print(roomGT[1].keys(), roomGT[0].max(0).nonzero()[0].mean(), roomGT[0].max(1).nonzero()[0].mean(), \'room not found\')\n      pass\n    continue\n  #print(labelRooms[1])\n  statistics = {k: [v, countsGT[k], countsPred[k]] for k, v in correctSums.iteritems()}\n\n\n  roomIndexMap = np.zeros(len(roomsInfo[1][0]))\n  orderedRoomPred = {}\n  for roomIndexPred, roomPred in enumerate(roomsInfo[1][0]):\n    maxIOURoom = (0, -1)\n    for roomIndexGT, roomGT in enumerate(roomsInfo[0][0]):\n      IOU = calcIOUMask(roomPred[0], roomGT[0])\n      if IOU > maxIOURoom[0]:\n        maxIOURoom = (IOU, roomIndexGT)\n        pass\n      continue\n    if maxIOURoom[1] < 0:\n      print(roomPred[1].keys(), roomPred[0].max(0).nonzero()[0].mean(), roomPred[0].max(1).nonzero()[0].mean(), \'room has no match\')\n      exit(1)\n      pass\n    roomIndexGT = maxIOURoom[1]\n    roomIndexMap[roomIndexPred] = roomIndexGT\n    if roomIndexGT not in orderedRoomPred:\n      orderedRoomPred[roomIndexGT] = roomPred\n    else:\n      mask = orderedRoomPred[roomIndexGT][0] + roomPred[0]\n      roomLabels = {}\n      for label in orderedRoomPred[roomIndexGT][1]:\n        roomLabels[label] = True\n        continue\n      for label in roomPred[1]:\n        roomLabels[label] = True\n        continue\n      orderedRoomPred[roomIndexGT] = (mask, roomLabels)\n      pass\n    continue\n  roomIndexMap = (np.expand_dims(roomIndexMap, -1) == np.expand_dims(np.arange(len(roomsInfo[0][0]), dtype=np.int32), 0)).astype(np.int32)\n\n  # print(\'GT\', [(roomIndexGT, roomGT[1].keys(), roomGT[0].max(0).nonzero()[0].mean(), roomGT[0].max(1).nonzero()[0].mean()) for roomIndexGT, roomGT in enumerate(roomsInfo[0][0])])\n  # print(\'Pred\', [(roomIndexPred, roomPred[1].keys(), roomPred[0].max(0).nonzero()[0].mean(), roomPred[0].max(1).nonzero()[0].mean()) for roomIndexPred, roomPred in enumerate(roomsInfo[1][0])])\n  # print(roomsInfo[0][1], roomsInfo[0][2])\n  # print(roomsInfo[1][1], roomsInfo[1][2])\n  # print(roomIndexMap)\n  roomsInfo[1][1] = np.matmul(roomIndexMap.transpose(), np.matmul(roomsInfo[1][1], roomIndexMap))\n  roomsInfo[1][2] = np.matmul(roomIndexMap.transpose(), np.matmul(roomsInfo[1][2], roomIndexMap))\n  #print(roomsInfo[1][1], roomsInfo[1][2])\n  #print(roomsInfo[0][1], roomsInfo[0][2])\n  # exit(1)\n\n  topologyStatistics = {k: [0.0, 0.0, 0.0] for k in [\'adjacent\', \'neighbor\', \'neighbor_foreground\', \'adjacent_all\' , \'neighbor_all\', \'neighbor_all_foreground\', \'all\', \'all_foreground\']}\n  for k in [\'adjacent_all\' , \'neighbor_all\', \'all\']:\n    topologyStatistics[k][1] = topologyStatistics[k][2] = len(roomsInfo[0][0])\n    continue\n  for k in [\'neighbor_all_foreground\', \'all_foreground\']:\n    topologyStatistics[k][1] = topologyStatistics[k][2] = len(roomsInfo[0][0]) - 1\n    continue\n\n  for roomIndex, roomGT in enumerate(roomsInfo[0][0]):\n    if roomIndex not in orderedRoomPred:\n      continue\n    roomPred = orderedRoomPred[roomIndex]\n    hasCommonLabel = False\n    for labelGT in roomGT[1]:\n      if labelGT in roomPred[1]:\n        hasCommonLabel = True\n        break\n      continue\n    if hasCommonLabel and calcIOUMask(roomPred[0], roomGT[0]) >= 0.5:\n      neighborMatchMask = roomsInfo[0][1][roomIndex] == roomsInfo[1][1][roomIndex]\n      topologyStatistics[\'neighbor\'][0] += (neighborMatchMask * roomsInfo[0][1][roomIndex]).sum()\n      topologyStatistics[\'neighbor\'][1] += roomsInfo[0][1][roomIndex].sum()\n      topologyStatistics[\'neighbor\'][2] += roomsInfo[1][1][roomIndex].sum()\n      topologyStatistics[\'neighbor_all\'][0] += int(np.all(neighborMatchMask))\n\n      adjacentMatchMask = roomsInfo[0][2][roomIndex] == roomsInfo[1][2][roomIndex]\n      topologyStatistics[\'adjacent\'][0] += (adjacentMatchMask * roomsInfo[0][2][roomIndex]).sum()\n      topologyStatistics[\'adjacent\'][1] += roomsInfo[0][2][roomIndex].sum()\n      topologyStatistics[\'adjacent\'][2] += roomsInfo[1][2][roomIndex].sum()\n      topologyStatistics[\'adjacent_all\'][0] += int(np.all(adjacentMatchMask))\n\n      topologyStatistics[\'all\'][0] += int(np.all(neighborMatchMask) and np.all(adjacentMatchMask))\n\n      if roomIndex > 0:\n        topologyStatistics[\'neighbor_foreground\'][0] += (neighborMatchMask[1:] * roomsInfo[0][1][roomIndex][1:]).sum()\n        topologyStatistics[\'neighbor_foreground\'][1] += roomsInfo[0][1][roomIndex][1:].sum()\n        topologyStatistics[\'neighbor_foreground\'][2] += roomsInfo[1][1][roomIndex][1:].sum()\n        topologyStatistics[\'neighbor_all_foreground\'][0] += int(np.all(neighborMatchMask[1:]))\n        topologyStatistics[\'all_foreground\'][0] += int(np.all(neighborMatchMask[1:]) and np.all(adjacentMatchMask[1:]))\n        pass\n    else:\n      print(\'incorrect label\')\n      print(roomGT[1].keys(), roomGT[0].max(0).nonzero()[0].mean(), roomGT[0].max(1).nonzero()[0].mean())\n      print(roomPred[1].keys(), roomPred[0].max(0).nonzero()[0].mean(), roomPred[0].max(1).nonzero()[0].mean())\n      pass\n    continue\n  #print(roomsInfo[0][1], roomsInfo[1][1], roomsInfo[0][2], roomsInfo[1][2])\n  #print(\'topology\', len(roomsInfo[0][0]), numMatchedRooms)\n\n  #print(statistics[\'room\'])\n\n  #topologyStatistics = {k: topologyStatistics[k] for k in [\'neighbor_foreground\', \'neighbor\', \'neighbor_all\', \'neighbor_all_foreground\']}\n\n  for k in [\'neighbor_foreground\', \'neighbor_all_foreground\']:\n    statistics[k[:-11]] = topologyStatistics[k]\n    continue\n  return statistics\n\n\ndef extractCorners(heatmaps, threshold, gap, cornerType = \'wall\', augment=False, h_points=False, gt=False):\n  if gt:\n    orientationPoints = heatmaps\n  else:\n    orientationPoints = extractCornersFromHeatmaps(heatmaps, threshold)\n    pass\n  #print(orientationPoints[7])\n  #print(orientationPoints[12])\n  #exit(1)\n  if cornerType == \'wall\':\n    cornerOrientations = []\n    for orientations in POINT_ORIENTATIONS:\n      cornerOrientations += orientations\n      continue\n  elif cornerType == \'door\':\n    cornerOrientations = POINT_ORIENTATIONS[0]\n  else:\n    cornerOrientations = POINT_ORIENTATIONS[1]\n    pass\n  #print(orientationPoints)\n  if h_points:\n    res = myaugmenthack(orientationPoints, cornerOrientations, cornerType, gap)\n    totalAugmentedPts = 0\n    for k,v in res.items():\n      orientationPoints[k].extend(v)\n      totalAugmentedPts += len(v)\n    print(""total augmented points"", totalAugmentedPts)\n\n  if augment:\n    orientationMap = {}\n    for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n      for orientation, orientations in enumerate(orientationOrientations):\n        orientationMap[orientations] = orientation\n        continue\n      continue\n\n    for orientationIndex, corners in enumerate(orientationPoints):\n      if len(corners) > 3:\n        continue #skip aug\n      pointType = orientationIndex / 4\n      if pointType in [2]:\n        orientation = orientationIndex % 4\n        orientations = POINT_ORIENTATIONS[pointType][orientation]\n        for i in range(len(orientations)):\n          newOrientations = list(orientations)\n          newOrientations.remove(orientations[i])\n          newOrientations = tuple(newOrientations)\n          if not newOrientations in orientationMap:\n            continue\n          newOrientation = orientationMap[newOrientations]\n          for corner in corners:\n            orientationPoints[(pointType - 1) * 4 + newOrientation].append(corner + (True, ))\n            continue\n          continue\n      elif pointType in [1]:\n        orientation = orientationIndex % 4\n        orientations = POINT_ORIENTATIONS[pointType][orientation]\n        for orientation in range(4):\n          if orientation in orientations:\n            continue\n          newOrientations = list(orientations)\n          newOrientations.append(orientation)\n          newOrientations = tuple(newOrientations)\n          if not newOrientations in orientationMap:\n            continue\n          newOrientation = orientationMap[newOrientations]\n          for corner in corners:\n            orientationPoints[(pointType + 1) * 4 + newOrientation].append(corner + (True, ))\n            continue\n          continue\n        pass\n      continue\n    pass\n  #print(orientationPoints)\n  pointOffset = 0\n  pointOffsets = []\n  points = []\n  pointOrientationLinesMap = []\n  for orientationIndex, corners in enumerate(orientationPoints):\n    pointOffsets.append(pointOffset)\n    orientations = cornerOrientations[orientationIndex]\n    for point in corners:\n      orientationLines = {}\n      for orientation in orientations:\n        orientationLines[orientation] = []\n        continue\n      pointOrientationLinesMap.append(orientationLines)\n      continue\n\n    pointOffset += len(corners)\n\n    if cornerType == \'wall\':\n      points += [[corner[0][0], corner[0][1], orientationIndex / 4, orientationIndex % 4] for corner in corners]\n    elif cornerType == \'door\':\n      points += [[corner[0][0], corner[0][1], 0, orientationIndex] for corner in corners]\n    else:\n      points += [[corner[0][0], corner[0][1], 1, orientationIndex] for corner in corners]\n      pass\n    continue\n\n  augmentedPointMask = {}\n\n\n  lines = []\n  pointNeighbors = [[] for point in points]\n\n  for orientationIndex, corners in enumerate(orientationPoints):\n    orientations = cornerOrientations[orientationIndex]\n    for orientation in orientations:\n      if orientation not in [1, 2]:\n        continue\n      oppositeOrientation = (orientation + 2) % 4\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n\n      for cornerIndex, corner in enumerate(corners):\n        pointIndex = pointOffsets[orientationIndex] + cornerIndex\n        #print(corner)\n        if len(corner) > 3:\n          augmentedPointMask[pointIndex] = True\n          pass\n\n        ranges = copy.deepcopy(ORIENTATION_RANGES[orientation])\n\n        ranges[lineDim] = min(ranges[lineDim], corner[0][lineDim])\n        ranges[lineDim + 2] = max(ranges[lineDim + 2], corner[0][lineDim])\n        ranges[1 - lineDim] = min(ranges[1 - lineDim], corner[1][1 - lineDim] - gap)\n        ranges[1 - lineDim + 2] = max(ranges[1 - lineDim + 2], corner[2][1 - lineDim] + gap)\n\n        for oppositeOrientationIndex, oppositeCorners in enumerate(orientationPoints):\n          if oppositeOrientation not in cornerOrientations[oppositeOrientationIndex]:\n            continue\n          for oppositeCornerIndex, oppositeCorner in enumerate(oppositeCorners):\n            if orientationIndex == oppositeOrientationIndex and oppositeCornerIndex == cornerIndex:\n              continue\n\n            oppositePointIndex = pointOffsets[oppositeOrientationIndex] + oppositeCornerIndex\n\n\n            if oppositeCorner[0][lineDim] < ranges[lineDim] or oppositeCorner[0][lineDim] > ranges[lineDim + 2] or ranges[1 - lineDim] > oppositeCorner[2][1 - lineDim] or ranges[1 - lineDim + 2] < oppositeCorner[1][1 - lineDim]:\n              continue\n\n\n            if abs(oppositeCorner[0][lineDim] - corner[0][lineDim]) < LENGTH_THRESHOLDS[cornerType]:\n              continue\n\n            lineIndex = len(lines)\n            pointOrientationLinesMap[pointIndex][orientation].append(lineIndex)\n            pointOrientationLinesMap[oppositePointIndex][oppositeOrientation].append(lineIndex)\n            pointNeighbors[pointIndex].append(oppositePointIndex)\n            pointNeighbors[oppositePointIndex].append(pointIndex)\n\n            lines.append((pointIndex, oppositePointIndex))\n            continue\n          continue\n        continue\n      continue\n    continue\n      # pointType = orientationIndex / 4\n      # orientation = orientationIndex % 4\n      # orientations = POINT_ORIENTATIONS[pointType][orientation]\n      # for i in range(len(orientations)):\n      #   newOrientations = list(orientations)\n      #   newOrientations.remove(orientations[i])\n      #   newOrientations = tuple(newOrientations)\n      #   if not newOrientations in orientationMap:\n      #     continue\n      #   newOrientation = orientationMap[newOrientations]\n      #   for corner in corners:\n      #     orientationPoints[(pointType - 1) * 4 + newOrientation].append(corner + (True, ))\n      #     continue\n      #   continue\n      # continue\n  #print(\'augs\', len(augmentedPointMask))\n  return points, lines, pointOrientationLinesMap, pointNeighbors, augmentedPointMask\n\ndef myaugmenthack(orientationPoints, cornerOrientations, cornerType, gap):\n  lines = []\n  pointOffset = 0\n  pointOffsets = []\n  points = []\n  pointOrientationLinesMap = []\n  for orientationIndex, corners in enumerate(orientationPoints):\n    pointOffsets.append(pointOffset)\n    orientations = cornerOrientations[orientationIndex]\n    for point in corners:\n      orientationLines = {}\n      for orientation in orientations:\n        orientationLines[orientation] = []\n        continue\n      pointOrientationLinesMap.append(orientationLines)\n      continue\n\n    pointOffset += len(corners)\n\n    if cornerType == \'wall\':\n      points += [[corner[0][0], corner[0][1], orientationIndex / 4, orientationIndex % 4] for corner in corners]\n    elif cornerType == \'door\':\n      points += [[corner[0][0], corner[0][1], 0, orientationIndex] for corner in corners]\n    else:\n      points += [[corner[0][0], corner[0][1], 1, orientationIndex] for corner in corners]\n      pass\n    continue\n\n  augmentedPointMask = {}\n\n\n  lines = []\n  pointNeighbors = [[] for point in points]\n\n  for orientationIndex, corners in enumerate(orientationPoints):\n    orientations = cornerOrientations[orientationIndex]\n    for orientation in orientations:\n      if orientation not in [1, 2]:\n        continue\n      oppositeOrientation = (orientation + 2) % 4\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n\n      for cornerIndex, corner in enumerate(corners):\n        pointIndex = pointOffsets[orientationIndex] + cornerIndex\n\n        ranges = copy.deepcopy(ORIENTATION_RANGES[orientation])\n\n        ranges[lineDim] = min(ranges[lineDim], corner[0][lineDim])\n        ranges[lineDim + 2] = max(ranges[lineDim + 2], corner[0][lineDim])\n        ranges[1 - lineDim] = min(ranges[1 - lineDim], corner[1][1 - lineDim] - gap)\n        ranges[1 - lineDim + 2] = max(ranges[1 - lineDim + 2], corner[2][1 - lineDim] + gap)\n\n        for oppositeOrientationIndex, oppositeCorners in enumerate(orientationPoints):\n          if oppositeOrientation not in cornerOrientations[oppositeOrientationIndex]:\n            continue\n          for oppositeCornerIndex, oppositeCorner in enumerate(oppositeCorners):\n            if orientationIndex == oppositeOrientationIndex and oppositeCornerIndex == cornerIndex:\n              continue\n\n            oppositePointIndex = pointOffsets[oppositeOrientationIndex] + oppositeCornerIndex\n\n\n            if oppositeCorner[0][lineDim] < ranges[lineDim] or oppositeCorner[0][lineDim] > ranges[lineDim + 2] or ranges[1 - lineDim] > oppositeCorner[2][1 - lineDim] or ranges[1 - lineDim + 2] < oppositeCorner[1][1 - lineDim]:\n              continue\n\n\n            if abs(oppositeCorner[0][lineDim] - corner[0][lineDim]) < LENGTH_THRESHOLDS[cornerType]:\n              continue\n\n            lineIndex = len(lines)\n            pointOrientationLinesMap[pointIndex][orientation].append(lineIndex)\n            pointOrientationLinesMap[oppositePointIndex][oppositeOrientation].append(lineIndex)\n            pointNeighbors[pointIndex].append(oppositePointIndex)\n            pointNeighbors[oppositePointIndex].append(pointIndex)\n\n            lines.append((pointIndex, oppositePointIndex))\n            continue\n          continue\n        continue\n      continue\n    continue\n  augmented_points = {}\n  # for orientationIndex, corners in enumerate(orientationPoints):\n  #   augmented_points[orientationIndex] = []\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = pointType*4 + orientation\n      continue\n    continue\n  # for k,vs in enumerate(pointNeighbors):\n  #   for v in vs:\n  #     print(points[k], points[v])\n  for orientationIndex1, corners1 in enumerate(orientationPoints):\n    for cornerIndex1, corner1 in enumerate(corners1):\n      pointIndex1 = pointOffsets[orientationIndex1] + cornerIndex1\n      point1 = points[pointIndex1]\n      for orientationIndex2, corners2 in enumerate(orientationPoints):\n        for cornerIndex2, corner2 in enumerate(corners2):\n          if orientationIndex2 == orientationIndex1 and cornerIndex2 == cornerIndex1:\n            continue\n          pointIndex2 = pointOffsets[orientationIndex2] + cornerIndex2\n          point2 = points[pointIndex2]\n          for orientationIndex3, corners3 in enumerate(orientationPoints):\n            for cornerIndex3, corner3 in enumerate(corners3):\n              if orientationIndex3 == orientationIndex1 and cornerIndex3 == cornerIndex1:\n                continue\n              if orientationIndex3 == orientationIndex2 and cornerIndex3 == cornerIndex2:\n                continue\n              pointIndex3 = pointOffsets[orientationIndex3] + cornerIndex3\n              point3 = points[pointIndex3]\n              if pointIndex2 in pointNeighbors[pointIndex1] and pointIndex3 in pointNeighbors[pointIndex2]:\n                if abs(point1[0] - point3[0]) < gap or abs(point1[1] - point3[1]) < gap:\n                  continue\n                fourthPoints = set(pointNeighbors[pointIndex1]) & set(pointNeighbors[pointIndex3])\n                valid_fourth = []\n                for point4 in fourthPoints:\n                  if abs(points[point4][0] - point2[0]) > gap and abs(points[point4][1] - point2[1]) > gap:\n                    valid_fourth.append(point4)\n                    pass\n                  pass\n                # usable_orientations = set(range(len(POINT_ORIENTATIONS[point1[2]])))\n                # used_orientation = set([point1[3], point2[3], point3[3]])\n                # fourth_orientation = usable_orientations - used_orientation\n                pt2_has = set(POINT_ORIENTATIONS[point2[2]][point2[3]])\n                oppositeOrientation2 = set([(orient+2)%4for orient in pt2_has])\n\n                pt1_has = set(POINT_ORIENTATIONS[point1[2]][point1[3]])\n                oppositeOrientation1 = set([(orient+2)%4for orient in pt1_has])\n                # pt1_needed = oppositeOrientation1 - pt2_has\n\n                pt3_has = set(POINT_ORIENTATIONS[point3[2]][point3[3]])\n                oppositeOrientation3 = set([(orient+2)%4for orient in pt3_has])\n                # pt3_needed = oppositeOrientation3 - pt2_has\n                newPoint_orientation = orientationMap[tuple(oppositeOrientation2)]\n                print(\'orient\', newPoint_orientation, oppositeOrientation2)\n                if len(valid_fourth) == 0:\n\n\n                  print(\'test orientation\', oppositeOrientation2, oppositeOrientation1, oppositeOrientation3)\n                  newPoint1 = [point1[0], point3[1], newPoint_orientation/4, newPoint_orientation%4]\n                  newPoint2 = [point3[0], point1[1], newPoint_orientation/4, newPoint_orientation%4]\n                  verify11 = myVerifyCompatibility(oppositeOrientation1, oppositeOrientation2, point1, newPoint1, gap)\n                  verify31 = myVerifyCompatibility(oppositeOrientation3, oppositeOrientation2, point3, newPoint1, gap)\n                  verify12 = myVerifyCompatibility(oppositeOrientation1, oppositeOrientation2, point1, newPoint2, gap)\n                  verify32 = myVerifyCompatibility(oppositeOrientation3, oppositeOrientation2, point3, newPoint2, gap)\n                  if abs(newPoint1[0] - point2[0]) > gap and abs(newPoint1[1] - point2[1]) > gap and verify11 and verify31:\n                    if newPoint_orientation not in augmented_points:\n                      augmented_points[newPoint_orientation] = []\n                    print(\'case1\', newPoint1, point1, point2, point3, abs(newPoint1[0] - point2[0]), abs(newPoint1[1]-point2[1]))\n                    augmented_points[newPoint_orientation].append(((newPoint1[0], newPoint1[1]) ,(newPoint1[0]-gap, newPoint1[1]-gap), (newPoint1[0]+gap,newPoint1[1]+gap), True))\n                    pass\n                  elif verify12 and verify32:\n                    if newPoint_orientation not in augmented_points:\n                      augmented_points[newPoint_orientation] = []\n                      pass\n                    print(\'case2\', newPoint2, point1, point2, point3, abs(newPoint2[0] - point2[0]), abs(newPoint2[1]-point2[1]))\n                    augmented_points[newPoint_orientation].append(((newPoint2[0], newPoint2[1]) ,(newPoint2[0]-gap,newPoint2[1]-gap), (newPoint2[0]+gap,newPoint2[1]+gap), True))\n                    pass\n\n\n                  pass\n                pass\n              continue\n            continue\n          continue\n        continue\n      continue\n    continue\n  pass\n\n  return augmented_points\ndef myVerifyCompatibility(orients1, orients2, pt1, pt2, gap):\n  verification_set = orients1 & orients2\n  passed_verification = False\n  for v in verification_set:\n    if v == 0:\n      if pt2[1] - pt1[1] > 0 and abs(pt1[0] - pt2[0]) < gap:\n        passed_verification = True\n    if v == 1:\n      if pt2[0] - pt1[0] < 0 and abs(pt1[1] - pt2[1]) < gap:\n        passed_verification = True\n      pass\n    if v == 2:\n      if pt2[1] - pt1[1] < 0 and abs(pt1[0] - pt2[0]) < gap:\n        passed_verification = True\n      pass\n    if v == 3:\n      if pt2[0] - pt1[0] > 0 and abs(pt1[1] - pt2[1]) < gap:\n        passed_verification = True\n      pass\n  return passed_verification\n\ndef augmentPoints(points, decreasingTypes = [2], increasingTypes = [1]):\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = orientation\n      continue\n    continue\n\n  newPoints = []\n  for pointIndex, point in enumerate(points):\n    if point[2] not in decreasingTypes:\n      continue\n    orientations = POINT_ORIENTATIONS[point[2]][point[3]]\n    for i in range(len(orientations)):\n      newOrientations = list(orientations)\n      newOrientations.remove(orientations[i])\n      newOrientations = tuple(newOrientations)\n      if not newOrientations in orientationMap:\n        continue\n      newOrientation = orientationMap[newOrientations]\n      newPoints.append([point[0], point[1], point[2] - 1, newOrientation])\n      continue\n    continue\n\n  for pointIndex, point in enumerate(points):\n    if point[2] not in increasingTypes:\n      continue\n    orientations = POINT_ORIENTATIONS[point[2]][point[3]]\n    for orientation in range(4):\n      if orientation in orientations:\n        continue\n\n      oppositeOrientation = (orientation + 2) % 4\n      ranges = copy.deepcopy(ORIENTATION_RANGES[orientation])\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n      deltas = [0, 0]\n\n      if lineDim == 1:\n        deltas[0] = gap\n      else:\n        deltas[1] = gap\n        pass\n\n      for c in range(2):\n        ranges[c] = min(ranges[c], point[c] - deltas[c])\n        ranges[c + 2] = max(ranges[c + 2], point[c] + deltas[c])\n        continue\n\n      hasNeighbor = False\n      for neighborPointIndex, neighborPoint in enumerate(points):\n        if neighborPointIndex == pointIndex:\n          continue\n\n        neighborOrientations = POINT_ORIENTATIONS[neighborPoint[2]][neighborPoint[3]]\n        if oppositeOrientation not in neighborOrientations:\n          continue\n\n        inRange = True\n        for c in range(2):\n          if neighborPoint[c] < ranges[c] or neighborPoint[c] > ranges[c + 2]:\n            inRange = False\n            break\n          continue\n\n        if not inRange or abs(neighborPoint[lineDim] - point[lineDim]) < max(abs(neighborPoint[1 - lineDim] - point[1 - lineDim]), 1):\n          continue\n\n        hasNeighbor = True\n        break\n\n      if not hasNeighbor:\n        continue\n\n      newOrientations = list(orientations)\n      newOrientations.append(orientation)\n      newOrientations = tuple(newOrientations)\n      if not newOrientations in orientationMap:\n        continue\n      newOrientation = orientationMap[newOrientations]\n      newPoints.append([point[0], point[1], point[2] + 1, newOrientation])\n      continue\n    continue\n  return points + newPoints\n\n\ndef filterWalls(wallPoints, wallLines):\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = orientation\n      continue\n    continue\n\n  #print(POINT_ORIENTATIONS)\n\n  while True:\n    pointOrientationNeighborsMap = {}\n    for line in wallLines:\n      lineDim = calcLineDim(wallPoints, line)\n      for c, pointIndex in enumerate(line):\n        if lineDim == 0:\n          if c == 0:\n            orientation = 1\n          else:\n            orientation = 3\n        else:\n          if c == 0:\n            orientation = 2\n          else:\n            orientation = 0\n            pass\n          pass\n\n        if pointIndex not in pointOrientationNeighborsMap:\n          pointOrientationNeighborsMap[pointIndex] = {}\n          pass\n        if orientation not in pointOrientationNeighborsMap[pointIndex]:\n          pointOrientationNeighborsMap[pointIndex][orientation] = []\n          pass\n        pointOrientationNeighborsMap[pointIndex][orientation].append(line[1 - c])\n        continue\n      continue\n\n\n    invalidPointMask = {}\n    for pointIndex, point in enumerate(wallPoints):\n      if pointIndex not in pointOrientationNeighborsMap:\n        invalidPointMask[pointIndex] = True\n        continue\n      orientationNeighborMap = pointOrientationNeighborsMap[pointIndex]\n      orientations = POINT_ORIENTATIONS[point[2]][point[3]]\n      if len(orientationNeighborMap) < len(orientations):\n        if len(orientationNeighborMap) >= 2 and tuple(orientationNeighborMap.keys()) in orientationMap:\n          newOrientation = orientationMap[tuple(orientationNeighborMap.keys())]\n          wallPoints[pointIndex][2] = len(orientationNeighborMap) - 1\n          wallPoints[pointIndex][3] = newOrientation\n          #print(orientationNeighborMap)\n          #print(\'new\', len(orientationNeighborMap), newOrientation)\n          continue\n        invalidPointMask[pointIndex] = True\n        pass\n      continue\n\n    if len(invalidPointMask) == 0:\n      break\n\n    newWallPoints = []\n    pointIndexMap = {}\n    for pointIndex, point in enumerate(wallPoints):\n      if pointIndex not in invalidPointMask:\n        pointIndexMap[pointIndex] = len(newWallPoints)\n        newWallPoints.append(point)\n        pass\n      continue\n\n    print(pointIndexMap)\n    # for pointIndex, point in enumerate(wallPoints):\n    #   if pointIndex in pointOrientationNeighborsMap:\n    #     print(pointIndex, point, pointOrientationNeighborsMap[pointIndex])\n    #     pass\n    #   continue\n\n    #print(len(wallPoints), len(newWallPoints), len(wallLines))\n    #print(invalidPointMask)\n    #exit(1)\n\n    wallPoints = newWallPoints\n\n    newWallLines = []\n    for lineIndex, line in enumerate(wallLines):\n      if line[0] in pointIndexMap and line[1] in pointIndexMap:\n        newLine = (pointIndexMap[line[0]], pointIndexMap[line[1]])\n        newWallLines.append(newLine)\n        pass\n      continue\n    wallLines = newWallLines\n    continue\n\n  pointOrientationLinesMap = [{} for _ in range(len(wallPoints))]\n  pointNeighbors = [[] for _ in range(len(wallPoints))]\n\n  #print(wallLines[76])\n  #print(wallPoints[wallLines[76][0]], wallPoints[wallLines[76][1]])\n\n  for lineIndex, line in enumerate(wallLines):\n    lineDim = calcLineDim(wallPoints, line)\n    for c, pointIndex in enumerate(line):\n      if lineDim == 0:\n        if wallPoints[pointIndex][lineDim] < wallPoints[line[1 - c]][lineDim]:\n          orientation = 1\n        else:\n          orientation = 3\n          pass\n      else:\n        if wallPoints[pointIndex][lineDim] < wallPoints[line[1 - c]][lineDim]:\n          orientation = 2\n        else:\n          orientation = 0\n          pass\n        pass\n\n      if orientation not in pointOrientationLinesMap[pointIndex]:\n        pointOrientationLinesMap[pointIndex][orientation] = []\n        pass\n      pointOrientationLinesMap[pointIndex][orientation].append(lineIndex)\n      pointNeighbors[pointIndex].append(line[1 - c])\n      continue\n    continue\n\n  return wallPoints, wallLines, pointOrientationLinesMap, pointNeighbors\n\n\ndef filterWallsDynamic(wallPoints, wallLines):\n  iteration = 0\n  while True:\n    pointOrientationNeighborsMap = {}\n    for line in wallLines:\n      lineDim = calcLineDim(wallPoints, line)\n      #print(line, lineDim)\n\n      for c, pointIndex in enumerate(line):\n        if lineDim == 0:\n          if c == 0:\n            orientation = 1\n          else:\n            orientation = 3\n        else:\n          if c == 0:\n            orientation = 2\n          else:\n            orientation = 0\n            pass\n          pass\n\n        if pointIndex not in pointOrientationNeighborsMap:\n          pointOrientationNeighborsMap[pointIndex] = {}\n          pass\n        if orientation not in pointOrientationNeighborsMap[pointIndex]:\n          pointOrientationNeighborsMap[pointIndex][orientation] = []\n          pass\n        pointOrientationNeighborsMap[pointIndex][orientation].append(line[1 - c])\n        continue\n      continue\n\n    #print(pointOrientationNeighborsMap[3])\n    #print(pointOrientationNeighborsMap[8])\n    #print(pointOrientationNeighborsMap[12])\n    #exit(1)\n\n    invalidPointMask = {}\n    for pointIndex, point in enumerate(wallPoints):\n      if pointIndex not in pointOrientationNeighborsMap:\n        invalidPointMask[pointIndex] = True\n        continue\n      orientationNeighborMap = pointOrientationNeighborsMap[pointIndex]\n      orientations = POINT_ORIENTATIONS[point[2]][point[3]]\n      for orientation in orientations:\n        if orientation not in orientationNeighborMap:\n          invalidPointMask[pointIndex] = True\n          break\n        continue\n      continue\n\n    if len(invalidPointMask) == 0:\n      break\n\n    image = drawLines(\'\', width, height, wallPoints, wallLines, [], None, lineWidth=0, lineColor=np.array([0, 0, 128]))\n    image = drawPoints(\'\', width, height, wallPoints, image, pointSize=3, pointColor=255)\n    cv2.imwrite(\'test/walls/walls_\' + str(iteration) + \'.png\', image)\n    for pointIndex, _ in invalidPointMask.iteritems():\n      newImage = image.copy()\n      newImage = drawPoints(\'\', width, height, [wallPoints[pointIndex]], newImage, pointSize=3, pointColor=np.array([255, 0, 255]))\n      connectingLines = []\n      for line in wallLines:\n        if pointIndex in line:\n          connectingLines.append(line)\n          pass\n        continue\n      print(iteration, pointIndex, wallPoints[pointIndex])\n      newImage = drawLines(\'\', width, height, wallPoints, connectingLines, [], newImage, 1, lineColor=np.array([255, 0, 0]))\n      cv2.imwrite(\'test/walls/walls_\' + str(iteration) + \'_\' + str(pointIndex) + \'.png\', newImage)\n      continue\n\n    newWallPoints = []\n    pointIndexMap = {}\n    for pointIndex, point in enumerate(wallPoints):\n      if pointIndex not in invalidPointMask:\n        pointIndexMap[pointIndex] = len(newWallPoints)\n        newWallPoints.append(point)\n        pass\n      continue\n\n    # for pointIndex, point in enumerate(wallPoints):\n    #   if pointIndex in pointOrientationNeighborsMap:\n    #     print(pointIndex, point, pointOrientationNeighborsMap[pointIndex])\n    #     pass\n    #   continue\n\n    #print(len(wallPoints), len(newWallPoints), len(wallLines))\n    #print(invalidPointMask)\n    #exit(1)\n\n    wallPoints = newWallPoints\n\n    newWallLines = []\n    for lineIndex, line in enumerate(wallLines):\n      if line[0] in pointIndexMap and line[1] in pointIndexMap:\n        newLine = (pointIndexMap[line[0]], pointIndexMap[line[1]])\n        newWallLines.append(newLine)\n        pass\n      continue\n    wallLines = newWallLines\n    iteration += 1\n    continue\n\n  pointOrientationLinesMap = [{} for _ in range(len(wallPoints))]\n  pointNeighbors = [[] for _ in range(len(wallPoints))]\n\n  for lineIndex, line in enumerate(wallLines):\n    lineDim = calcLineDim(wallPoints, line)\n    for c, pointIndex in enumerate(line):\n      if lineDim == 0:\n        if c == 0:\n          orientation = 1\n        else:\n          orientation = 3\n      else:\n        if c == 0:\n          orientation = 2\n        else:\n          orientation = 0\n          pass\n        pass\n\n      if orientation not in pointOrientationLinesMap[pointIndex]:\n        pointOrientationLinesMap[pointIndex][orientation] = []\n        pass\n      pointOrientationLinesMap[pointIndex][orientation].append(lineIndex)\n      pointNeighbors[pointIndex].append(line[1 - c])\n      continue\n    continue\n\n  return wallPoints, wallLines, pointOrientationLinesMap, pointNeighbors\n\n\ndef writePoints(points, pointLabels):\n  with open(\'test/points_out.txt\', \'w\') as points_file:\n    for point in points:\n      points_file.write(str(point[0] + 1) + \'\\t\' + str(point[1] + 1) + \'\\t\')\n      points_file.write(str(point[0] + 1) + \'\\t\' + str(point[1] + 1) + \'\\t\')\n      points_file.write(\'point\\t\')\n      points_file.write(str(point[2] + 1) + \'\\t\' + str(point[3] + 1) + \'\\n\')\n  points_file.close()\n\n  with open(\'test/point_labels.txt\', \'w\') as point_label_file:\n    for point in pointLabels:\n      point_label_file.write(str(point[0]) + \'\\t\' + str(point[1]) + \'\\t\' + str(point[2]) + \'\\t\' + str(point[3]) + \'\\n\')\n  point_label_file.close()\n\ndef writeDoors(points, lines, doorTypes):\n  with open(\'test/doors_out.txt\', \'w\') as doors_file:\n    for lineIndex, line in enumerate(lines):\n      point_1 = points[line[0]]\n      point_2 = points[line[1]]\n\n      doors_file.write(str(point_1[0] + 1) + \'\\t\' + str(point_1[1] + 1) + \'\\t\')\n      doors_file.write(str(point_2[0] + 1) + \'\\t\' + str(point_2[1] + 1) + \'\\t\')\n      doors_file.write(\'door\\t\')\n      doors_file.write(str(doorTypes[lineIndex] + 1) + \'\\t1\\n\')\n    doors_file.close()\n\ndef writeIcons(points, icons, iconTypes):\n  with open(\'test/icons_out.txt\', \'w\') as icons_file:\n    for iconIndex, icon in enumerate(icons):\n      point_1 = points[icon[0]]\n      point_2 = points[icon[1]]\n      point_3 = points[icon[2]]\n      point_4 = points[icon[3]]\n\n      x_1 = int(round((point_1[0] + point_3[0]) / 2)) + 1\n      x_2 = int(round((point_2[0] + point_4[0]) / 2)) + 1\n      y_1 = int(round((point_1[1] + point_2[1]) / 2)) + 1\n      y_2 = int(round((point_3[1] + point_4[1]) / 2)) + 1\n\n      icons_file.write(str(x_1) + \'\\t\' + str(y_1) + \'\\t\')\n      icons_file.write(str(x_2) + \'\\t\' + str(y_2) + \'\\t\')\n      icons_file.write(iconNumberNameMap[iconTypes[iconIndex]] + \'\\t\')\n      #icons_file.write(str(iconNumberStyleMap[iconTypes[iconIndex]]) + \'\\t\')\n      icons_file.write(\'1\\t\')\n      icons_file.write(\'1\\n\')\n    icons_file.close()\n\n\ndef adjustPoints(points, lines):\n  lineNeighbors = []\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    neighbors = []\n    for neighborLineIndex, neighborLine in enumerate(lines):\n      if neighborLineIndex <= lineIndex:\n        continue\n      neighborLineDim = calcLineDim(points, neighborLine)\n      point_1 = points[neighborLine[0]]\n      point_2 = points[neighborLine[1]]\n      lineDimNeighbor = calcLineDim(points, neighborLine)\n\n      if lineDimNeighbor != lineDim:\n        continue\n      if neighborLine[0] != line[0] and neighborLine[0] != line[1] and neighborLine[1] != line[0] and neighborLine[1] != line[1]:\n        continue\n      neighbors.append(neighborLineIndex)\n      continue\n    lineNeighbors.append(neighbors)\n    continue\n\n  visitedLines = {}\n  for lineIndex in range(len(lines)):\n    if lineIndex in visitedLines:\n      continue\n    lineGroup = [lineIndex]\n    while True:\n      newLineGroup = lineGroup\n      hasChange = False\n      for line in lineGroup:\n        neighbors = lineNeighbors[line]\n        for neighbor in neighbors:\n          if neighbor not in newLineGroup:\n            newLineGroup.append(neighbor)\n            hasChange = True\n            pass\n          continue\n        continue\n      if not hasChange:\n        break\n      lineGroup = newLineGroup\n      continue\n\n    for line in lineGroup:\n      visitedLines[line] = True\n      continue\n\n    #print([[points[pointIndex] for pointIndex in lines[lineIndex]] for lineIndex in lineGroup], calcLineDim(points, lines[lineGroup[0]]))\n\n    pointGroup = []\n    for line in lineGroup:\n      for index in range(2):\n        pointIndex = lines[line][index]\n        if pointIndex not in pointGroup:\n          pointGroup.append(pointIndex)\n          pass\n        continue\n      continue\n\n    #lineDim = calcLineDim(points, lines[lineGroup[0]])\n    xy = np.concatenate([np.array([points[pointIndex][:2] for pointIndex in lines[lineIndex]]) for lineIndex in lineGroup], axis=0)\n    mins = xy.min(0)\n    maxs = xy.max(0)\n    if maxs[0] - mins[0] > maxs[1] - mins[1]:\n      lineDim = 0\n    else:\n      lineDim = 1\n      pass\n\n    fixedValue = 0\n    for point in pointGroup:\n      fixedValue += points[point][1 - lineDim]\n      continue\n    fixedValue /= len(pointGroup)\n\n    for point in pointGroup:\n      points[point][1 - lineDim] = fixedValue\n      continue\n    continue\n  return\n\ndef mergePoints(points, lines):\n  validPointMask = {}\n  for line in lines:\n    validPointMask[line[0]] = True\n    validPointMask[line[1]] = True\n    continue\n\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = (pointType, orientation)\n      continue\n    continue\n\n  for pointIndex_1, point_1 in enumerate(points):\n    if pointIndex_1 not in validPointMask:\n      continue\n    for pointIndex_2, point_2 in enumerate(points):\n      if pointIndex_2 <= pointIndex_1:\n        continue\n      if pointIndex_2 not in validPointMask:\n        continue\n      if pointDistance(point_1[:2], point_2[:2]) <= DISTANCES[\'point\']:\n        orientations = list(POINT_ORIENTATIONS[point_1[2]][point_1[3]] + POINT_ORIENTATIONS[point_2[2]][point_2[3]])\n        if len([line for line in lines if pointIndex_1 in line and pointIndex_2 in line]) > 0:\n          if abs(point_1[0] - point_2[0]) > abs(point_1[1] - point_2[1]):\n            orientations.remove(1)\n            orientations.remove(3)\n          else:\n            orientations.remove(0)\n            orientations.remove(2)\n            pass\n          pass\n        orientations = tuple(set(orientations))\n        if orientations not in orientationMap:\n          for lineIndex, line in enumerate(lines):\n            if pointIndex_1 in line and pointIndex_2 in line:\n              lines[lineIndex] = (-1, -1)\n              pass\n            continue\n\n          lineIndices_1 = [(lineIndex, tuple(set(line) - set((pointIndex_1, )))[0]) for lineIndex, line in enumerate(lines) if pointIndex_1 in line and pointIndex_2 not in line]\n          lineIndices_2 = [(lineIndex, tuple(set(line) - set((pointIndex_2, )))[0]) for lineIndex, line in enumerate(lines) if pointIndex_2 in line and pointIndex_1 not in line]\n          if len(lineIndices_1) == 1 and len(lineIndices_2) == 1:\n            lineIndex_1, index_1 = lineIndices_1[0]\n            lineIndex_2, index_2 = lineIndices_2[0]\n            lines[lineIndex_1] = (index_1, index_2)\n            lines[lineIndex_2] = (-1, -1)\n            pass\n          continue\n\n        pointInfo = orientationMap[orientations]\n        newPoint = [(point_1[0] + point_2[0]) / 2, (point_1[1] + point_2[1]) / 2, pointInfo[0], pointInfo[1]]\n        points[pointIndex_1] = newPoint\n        for lineIndex, line in enumerate(lines):\n          if pointIndex_2 == line[0]:\n            lines[lineIndex] = (pointIndex_1, line[1])\n            pass\n          if pointIndex_2 == line[1]:\n            lines[lineIndex] = (line[0], pointIndex_1)\n            pass\n          continue\n        pass\n      continue\n    continue\n  return\n\ndef adjustDoorPoints(doorPoints, doorLines, wallPoints, wallLines, doorWallMap):\n  for doorLineIndex, doorLine in enumerate(doorLines):\n    lineDim = calcLineDim(doorPoints, doorLine)\n    wallLine = wallLines[doorWallMap[doorLineIndex]]\n    wallPoint_1 = wallPoints[wallLine[0]]\n    wallPoint_2 = wallPoints[wallLine[1]]\n    fixedValue = (wallPoint_1[1 - lineDim] + wallPoint_2[1 - lineDim]) / 2\n    for endPointIndex in range(2):\n      doorPoints[doorLine[endPointIndex]][1 - lineDim] = fixedValue\n      continue\n    continue\n\n\ndef findIconsFromLines(iconPoints, iconLines):\n  icons = []\n  pointOrientationNeighborsMap = {}\n  for line in iconLines:\n    lineDim = calcLineDim(iconPoints, line)\n    for c, pointIndex in enumerate(line):\n      if lineDim == 0:\n        if c == 0:\n          orientation = 1\n        else:\n          orientation = 3\n      else:\n        if c == 0:\n          orientation = 2\n        else:\n          orientation = 0\n          pass\n        pass\n\n      if pointIndex not in pointOrientationNeighborsMap:\n        pointOrientationNeighborsMap[pointIndex] = {}\n        pass\n      if orientation not in pointOrientationNeighborsMap[pointIndex]:\n        pointOrientationNeighborsMap[pointIndex][orientation] = []\n        pass\n      pointOrientationNeighborsMap[pointIndex][orientation].append(line[1 - c])\n      continue\n    continue\n\n  for pointIndex, orientationNeighborMap in pointOrientationNeighborsMap.iteritems():\n    if 1 not in orientationNeighborMap or 2 not in orientationNeighborMap:\n      continue\n    for neighborIndex_1 in orientationNeighborMap[1]:\n      if 2 not in pointOrientationNeighborsMap[neighborIndex_1]:\n        continue\n      lastCornerCandiates = pointOrientationNeighborsMap[neighborIndex_1][2]\n      for neighborIndex_2 in orientationNeighborMap[2]:\n        if 1 not in pointOrientationNeighborsMap[neighborIndex_2]:\n          continue\n        for lastCornerIndex in pointOrientationNeighborsMap[neighborIndex_2][1]:\n          if lastCornerIndex not in lastCornerCandiates:\n            continue\n\n          point_1 = iconPoints[pointIndex]\n          point_2 = iconPoints[neighborIndex_1]\n          point_3 = iconPoints[neighborIndex_2]\n          point_4 = iconPoints[lastCornerIndex]\n\n          x_1 = int((point_1[0] + point_3[0]) / 2)\n          x_2 = int((point_2[0] + point_4[0]) / 2)\n          y_1 = int((point_1[1] + point_2[1]) / 2)\n          y_2 = int((point_3[1] + point_4[1]) / 2)\n\n          #if x_2 <= x_1 or y_2 <= y_1:\n          #continue\n          if (x_2 - x_1 + 1) * (y_2 - y_1 + 1) <= LENGTH_THRESHOLDS[\'icon\'] * LENGTH_THRESHOLDS[\'icon\']:\n            continue\n\n          icons.append((pointIndex, neighborIndex_1, neighborIndex_2, lastCornerIndex))\n          continue\n        continue\n      continue\n    continue\n  return icons\n\n\ndef findLineNeighbors(points, lines, labelVotesMap, gap):\n  lineNeighbors = [[{}, {}] for lineIndex in range(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    for neighborLineIndex, neighborLine in enumerate(lines):\n      if neighborLineIndex <= lineIndex:\n        continue\n      neighborLineDim = calcLineDim(points, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = points[line[0]][1 - lineDim]\n      fixedValue_2 = points[neighborLine[0]][1 - lineDim]\n\n      minValue = int(minValue)\n      maxValue = int(maxValue)\n      fixedValue_1 = int(fixedValue_1)\n      fixedValue_2 = int(fixedValue_2)\n\n      if abs(fixedValue_2 - fixedValue_1) < gap:\n        continue\n      if lineDim == 0:\n        if fixedValue_1 < fixedValue_2:\n          region = ((minValue, fixedValue_1), (maxValue, fixedValue_2))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][0][lineIndex] = region\n        else:\n          region = ((minValue, fixedValue_2), (maxValue, fixedValue_1))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][1][lineIndex] = region\n      else:\n        if fixedValue_1 < fixedValue_2:\n          region = ((fixedValue_1, minValue), (fixedValue_2, maxValue))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][1][lineIndex] = region\n        else:\n          region = ((fixedValue_2, minValue), (fixedValue_1, maxValue))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][0][lineIndex] = region\n          pass\n        pass\n      continue\n    continue\n\n  # remove neighbor pairs which are separated by another line\n  while True:\n    hasChange = False\n    for lineIndex, neighbors in enumerate(lineNeighbors):\n      lineDim = calcLineDim(points, lines[lineIndex])\n      for neighbor_1, region_1 in neighbors[1].iteritems():\n        for neighbor_2, _ in neighbors[0].iteritems():\n          if neighbor_2 not in lineNeighbors[neighbor_1][0]:\n            continue\n          region_2 = lineNeighbors[neighbor_1][0][neighbor_2]\n          if region_1[0][lineDim] < region_2[0][lineDim] + gap and region_1[1][lineDim] > region_2[1][lineDim] - gap:\n            lineNeighbors[neighbor_1][0].pop(neighbor_2)\n            lineNeighbors[neighbor_2][1].pop(neighbor_1)\n            hasChange = True\n            pass\n          continue\n        continue\n      continue\n    if not hasChange:\n      break\n\n\n  for lineIndex, directionNeighbors in enumerate(lineNeighbors):\n    for direction, neighbors in enumerate(directionNeighbors):\n      for neighbor, region in neighbors.iteritems():\n        labelVotes = labelVotesMap[:, region[1][1], region[1][0]] + labelVotesMap[:, region[0][1], region[0][0]] - labelVotesMap[:, region[0][1], region[1][0]] - labelVotesMap[:, region[1][1], region[0][0]]\n        neighbors[neighbor] = labelVotes\n        continue\n      continue\n    continue\n  return lineNeighbors\n\n\ndef findRectangleLineNeighbors(rectanglePoints, rectangles, linePoints, lines, lineNeighbors, gap, distanceThreshold):\n  rectangleLineNeighbors = [{} for rectangleIndex in range(len(rectangles))]\n  minDistanceLineNeighbors = {}\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    for lineIndex, line in enumerate(lines):\n      lineDim = calcLineDim(linePoints, line)\n\n      minValue = max(rectanglePoints[rectangle[0]][lineDim], rectanglePoints[rectangle[2 - lineDim]][lineDim], linePoints[line[0]][lineDim])\n      maxValue = min(rectanglePoints[rectangle[1 + lineDim]][lineDim], rectanglePoints[rectangle[3]][lineDim], linePoints[line[1]][lineDim])\n\n      if maxValue - minValue < gap:\n        continue\n\n      rectangleFixedValue_1 = (rectanglePoints[rectangle[0]][1 - lineDim] + rectanglePoints[rectangle[1 + lineDim]][1 - lineDim]) / 2\n      rectangleFixedValue_2 = (rectanglePoints[rectangle[2 - lineDim]][1 - lineDim] + rectanglePoints[rectangle[3]][1 - lineDim]) / 2\n      lineFixedValue = (linePoints[line[0]][1 - lineDim] + linePoints[line[1]][1 - lineDim]) / 2\n\n      if lineFixedValue < rectangleFixedValue_2 - gap and lineFixedValue > rectangleFixedValue_1 + gap:\n        continue\n\n      if lineFixedValue <= rectangleFixedValue_1 + gap:\n        index = lineDim * 2 + 0\n        distance = rectangleFixedValue_1 - lineFixedValue\n        if index not in minDistanceLineNeighbors or distance < minDistanceLineNeighbors[index][1]:\n          minDistanceLineNeighbors[index] = (lineIndex, distance, 1 - lineDim)\n      else:\n        index = lineDim * 2 + 1\n        distance = lineFixedValue - rectangleFixedValue_2\n        if index not in minDistanceLineNeighbors or distance < minDistanceLineNeighbors[index][1]:\n          minDistanceLineNeighbors[index] = (lineIndex, distance, lineDim)\n\n      if lineFixedValue < rectangleFixedValue_1 - distanceThreshold or lineFixedValue > rectangleFixedValue_2 + distanceThreshold:\n        continue\n\n      if lineFixedValue <= rectangleFixedValue_1 + gap:\n        if lineDim == 0:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 1\n        else:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 0\n          pass\n        pass\n      else:\n        if lineDim == 0:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 0\n        else:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 1\n          pass\n        pass\n\n      continue\n    if len(rectangleLineNeighbors[rectangleIndex]) == 0 or True:\n      for index, lineNeighbor in minDistanceLineNeighbors.iteritems():\n        rectangleLineNeighbors[rectangleIndex][lineNeighbor[0]] = lineNeighbor[2]\n        continue\n      pass\n    continue\n\n  return rectangleLineNeighbors\n\n\ndef findLineMap(points, lines, points_2, lines_2, gap):\n  lineMap = [{} for lineIndex in range(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    for neighborLineIndex, neighborLine in enumerate(lines_2):\n      neighborLineDim = calcLineDim(points_2, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points_2[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points_2[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) / 2\n      fixedValue_2 = (points_2[neighborLine[0]][1 - lineDim] + points_2[neighborLine[1]][1 - lineDim]) / 2\n\n      if abs(fixedValue_2 - fixedValue_1) > gap:\n        continue\n\n      lineMinValue = points[line[0]][lineDim]\n      lineMaxValue = points[line[1]][lineDim]\n      ratio = float(maxValue - minValue + 1) / (lineMaxValue - lineMinValue + 1)\n\n      lineMap[lineIndex][neighborLineIndex] = ratio\n      continue\n    continue\n\n  return lineMap\n\n\ndef findLineMapSingle(points, lines, points_2, lines_2, gap):\n  lineMap = []\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    minDistance = max(width, height)\n    minDistanceLineIndex = -1\n    for neighborLineIndex, neighborLine in enumerate(lines_2):\n      neighborLineDim = calcLineDim(points_2, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points_2[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points_2[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) / 2\n      fixedValue_2 = (points_2[neighborLine[0]][1 - lineDim] + points_2[neighborLine[1]][1 - lineDim]) / 2\n\n      distance = abs(fixedValue_2 - fixedValue_1)\n      if distance < minDistance:\n        minDistance = distance\n        minDistanceLineIndex = neighborLineIndex\n        pass\n      continue\n\n    #if abs(fixedValue_2 - fixedValue_1) > gap:\n    #continue\n    #print((lineIndex, minDistance, minDistanceLineIndex))\n    lineMap.append(minDistanceLineIndex)\n    continue\n\n  return lineMap\n\n\ndef findConflictLinePairs(points, lines, gap, distanceThreshold, considerEndPoints=False):\n  conflictLinePairs = []\n  for lineIndex_1, line_1 in enumerate(lines):\n    lineDim_1 = calcLineDim(points, line_1)\n    point_1 = points[line_1[0]]\n    point_2 = points[line_1[1]]\n    fixedValue_1 = int(round((point_1[1 - lineDim_1] + point_2[1 - lineDim_1]) / 2))\n    minValue_1 = int(min(point_1[lineDim_1], point_2[lineDim_1]))\n    maxValue_1 = int(max(point_1[lineDim_1], point_2[lineDim_1]))\n\n    for lineIndex_2, line_2 in enumerate(lines):\n      if lineIndex_2 <= lineIndex_1:\n        continue\n\n      lineDim_2 = calcLineDim(points, line_2)\n      point_1 = points[line_2[0]]\n      point_2 = points[line_2[1]]\n\n      if lineDim_2 == lineDim_1:\n        if line_1[0] == line_2[0] or line_1[1] == line_2[1]:\n          conflictLinePairs.append((lineIndex_1, lineIndex_2))\n          continue\n        elif line_1[0] == line_2[1] or line_1[1] == line_2[0]:\n          continue\n        pass\n      else:\n        if (line_1[0] in line_2 or line_1[1] in line_2):\n          continue\n        pass\n\n      if considerEndPoints:\n        if min([pointDistance(points[line_1[0]], points[line_2[0]]), pointDistance(points[line_1[0]], points[line_2[1]]), pointDistance(points[line_1[1]], points[line_2[0]]), pointDistance(points[line_1[1]], points[line_2[1]])]) <= gap:\n          conflictLinePairs.append((lineIndex_1, lineIndex_2))\n          continue\n        pass\n\n      fixedValue_2 = int(round((point_1[1 - lineDim_2] + point_2[1 - lineDim_2]) / 2))\n      minValue_2 = int(min(point_1[lineDim_2], point_2[lineDim_2]))\n      maxValue_2 = int(max(point_1[lineDim_2], point_2[lineDim_2]))\n\n      # if lineIndex_1 == 3 and lineIndex_2 == 4:\n      #   print(line_1)\n      #   print(line_2)\n      #   print(points[line_1[0]])\n      #   print(points[line_1[1]])\n      #   print(point_1)\n      #   print(point_2)\n      #   print((fixedValue_2, fixedValue_1, minValue_1, maxValue_2))\n      #   exit(1)\n\n      if lineDim_1 == lineDim_2:\n        if abs(fixedValue_2 - fixedValue_1) >= distanceThreshold or minValue_1 > maxValue_2 - gap or minValue_2 > maxValue_1 - gap:\n          continue\n\n        #print(\'parallel\', lineIndex_1, lineIndex_2)\n        #print([points[pointIndex] for pointIndex in lines[lineIndex_1]], [points[pointIndex] for pointIndex in lines[lineIndex_2]])\n\n        conflictLinePairs.append((lineIndex_1, lineIndex_2))\n        #drawLines(\'test/lines_\' + str(lineIndex_1) + ""_"" + str(lineIndex_2) + \'.png\', width, height, points, [line_1, line_2])\n      else:\n        if minValue_1 > fixedValue_2 - gap or maxValue_1 < fixedValue_2 + gap or minValue_2 > fixedValue_1 - gap or maxValue_2 < fixedValue_1 + gap:\n          continue\n\n        #print(\'vertical\', lineIndex_1, lineIndex_2)\n        #print([points[pointIndex] for pointIndex in lines[lineIndex_1]], [points[pointIndex] for pointIndex in lines[lineIndex_2]])\n\n        conflictLinePairs.append((lineIndex_1, lineIndex_2))\n        pass\n      continue\n    continue\n\n  return conflictLinePairs\n\n\ndef findConflictRectanglePairs(points, rectangles, gap):\n  conflictRectanglePairs = []\n  for rectangleIndex_1, rectangle_1 in enumerate(rectangles):\n    for rectangleIndex_2, rectangle_2 in enumerate(rectangles):\n      if rectangleIndex_2 <= rectangleIndex_1:\n        continue\n\n      conflict = False\n      for cornerIndex in range(4):\n        if rectangle_1[cornerIndex] == rectangle_2[cornerIndex]:\n          conflictRectanglePairs.append((rectangleIndex_1, rectangleIndex_2))\n          conflict = True\n          break\n        continue\n\n      if conflict:\n        continue\n\n      minX = max((points[rectangle_1[0]][0] + points[rectangle_1[2]][0]) / 2, (points[rectangle_2[0]][0] + points[rectangle_2[2]][0]) / 2)\n      maxX = min((points[rectangle_1[1]][0] + points[rectangle_1[3]][0]) / 2, (points[rectangle_2[1]][0] + points[rectangle_2[3]][0]) / 2)\n      if minX > maxX - gap:\n        continue\n      minY = max((points[rectangle_1[0]][1] + points[rectangle_1[1]][1]) / 2, (points[rectangle_2[0]][1] + points[rectangle_2[1]][1]) / 2)\n      maxY = min((points[rectangle_1[2]][1] + points[rectangle_1[3]][1]) / 2, (points[rectangle_2[2]][1] + points[rectangle_2[3]][1]) / 2)\n      if minY > maxY - gap:\n        continue\n      conflictRectanglePairs.append((rectangleIndex_1, rectangleIndex_2))\n      continue\n    continue\n\n  return conflictRectanglePairs\n\n\ndef findConflictRectangleLinePairs(rectanglePoints, rectangles, linePoints, lines, gap):\n  conflictRectangleLinePairs = []\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    for lineIndex, line in enumerate(lines):\n      # for c in range(4):\n      #   print(rectanglePoints[rectangle[c]])\n      #   continue\n      # for c in range(2):\n      #   print(linePoints[line[c]])\n      #   continue\n      lineDim = calcLineDim(linePoints, line)\n      if lineDim == 0:\n        minX = max(rectanglePoints[rectangle[0]][0], rectanglePoints[rectangle[2]][0], linePoints[line[0]][0])\n        maxX = min(rectanglePoints[rectangle[1]][0], rectanglePoints[rectangle[3]][0], linePoints[line[1]][0])\n        if minX > maxX - gap:\n          continue\n        if max(rectanglePoints[rectangle[0]][1], rectanglePoints[rectangle[1]][1]) + gap > min(linePoints[line[0]][1], linePoints[line[1]][1]):\n          continue\n        if min(rectanglePoints[rectangle[2]][1], rectanglePoints[rectangle[3]][1]) - gap < max(linePoints[line[0]][1], linePoints[line[1]][1]):\n          continue\n\n      elif lineDim == 1:\n        minY = max(rectanglePoints[rectangle[0]][1], rectanglePoints[rectangle[1]][1], linePoints[line[0]][1])\n        maxY = min(rectanglePoints[rectangle[2]][1], rectanglePoints[rectangle[3]][1], linePoints[line[1]][1])\n        if minY > maxY - gap:\n          continue\n        if max(rectanglePoints[rectangle[0]][0], rectanglePoints[rectangle[2]][0]) + gap > min(linePoints[line[0]][0], linePoints[line[1]][0]):\n          continue\n        if min(rectanglePoints[rectangle[1]][0], rectanglePoints[rectangle[3]][0]) - gap < max(linePoints[line[0]][0], linePoints[line[1]][0]):\n          continue\n\n      conflictRectangleLinePairs.append((rectangleIndex, lineIndex))\n      continue\n    continue\n\n  return conflictRectangleLinePairs\n\ndef findLinePointMap(points, lines, points_2, gap):\n  lineMap = [[] for lineIndex in range(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    fixedValue = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) / 2\n    for neighborPointIndex, neighborPoint in enumerate(points_2):\n      if neighborPoint[lineDim] < points[line[0]][lineDim] + gap or neighborPoint[lineDim] > points[line[1]][lineDim] - gap:\n        continue\n\n      if abs((neighborPoint[1 - lineDim] + neighborPoint[1 - lineDim]) / 2 - fixedValue) > gap:\n        continue\n\n      lineMap[lineIndex].append(neighborPointIndex)\n      continue\n    continue\n  return lineMap\n\ndef scalePoints(points, sampleDim):\n  for point in points:\n    point[0] *= width / sampleDim\n    point[1] *= height / sampleDim\n    continue\n  return points\n\ndef findCandidatesFromHeatmaps(iconHeatmaps, iconPointOffset, doorPointOffset):\n  newIcons = []\n  newIconPoints = []\n  newDoorLines = []\n  newDoorPoints = []\n  for iconIndex in range(1, 13):\n    heatmap = iconHeatmaps[:, :, iconIndex] > 0.5\n    kernel = np.ones((3, 3), dtype=np.uint8)\n    heatmap = cv2.dilate(cv2.erode(heatmap.astype(np.uint8), kernel), kernel)\n    regions = measure.label(heatmap, background=0)\n    for regionIndex in range(regions.min() + 1, regions.max() + 1):\n      regionMask = regions == regionIndex\n      ys, xs = regionMask.nonzero()\n      minX, maxX = xs.min(), xs.max()\n      minY, maxY = ys.min(), ys.max()\n      if iconIndex <= 10:\n        if maxX - minX < GAPS[\'icon_extraction\'] or maxY - minY < GAPS[\'icon_extraction\']:\n          continue\n        mask = regionMask[minY:maxY + 1, minX:maxX + 1]\n        sizeX, sizeY = maxX - minX + 1, maxY - minY + 1\n        sumX = mask.sum(0)\n\n        for x in range(sizeX):\n          if sumX[x] * 2 >= sizeY:\n            break\n          minX += 1\n          continue\n\n        for x in range(sizeX - 1, -1, -1):\n          if sumX[x] * 2 >= sizeY:\n            break\n          maxX -= 1\n          continue\n\n\n        sumY = mask.sum(1)\n        for y in range(sizeY):\n          if sumY[y] * 2 >= sizeX:\n            break\n          minY += 1\n          continue\n\n        for y in range(sizeY - 1, -1, -1):\n          if sumY[y] * 2 >= sizeX:\n            break\n          maxY -= 1\n          continue\n        if (maxY - minY + 1) * (maxX - minX + 1) <= LENGTH_THRESHOLDS[\'icon\'] * LENGTH_THRESHOLDS[\'icon\'] * 2:\n          continue\n        newIconPoints += [[minX, minY, 1, 2], [maxX, minY, 1, 3], [minX, maxY, 1, 1], [maxX, maxY, 1, 0]]\n        newIcons.append((iconPointOffset, iconPointOffset + 1, iconPointOffset + 2, iconPointOffset + 3))\n        iconPointOffset += 4\n      else:\n        sizeX, sizeY = maxX - minX + 1, maxY - minY + 1\n        if sizeX >= LENGTH_THRESHOLDS[\'door\'] and sizeY * 2 <= sizeX:\n          newDoorPoints += [[minX, (minY + maxY) / 2, 0, 1], [maxX, (minY + maxY) / 2, 0, 3]]\n          newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n          doorPointOffset += 2\n        elif sizeY >= LENGTH_THRESHOLDS[\'door\'] and sizeX * 2 <= sizeY:\n          newDoorPoints += [[(minX + maxX) / 2, minY, 0, 2], [(minX + maxX) / 2, maxY, 0, 0]]\n          newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n          doorPointOffset += 2\n        elif sizeX >= LENGTH_THRESHOLDS[\'door\'] and sizeY >= LENGTH_THRESHOLDS[\'door\']:\n          mask = regionMask[minY:maxY + 1, minX:maxX + 1]\n          sumX = mask.sum(0)\n          minOffset, maxOffset = 0, 0\n          for x in range(sizeX):\n            if sumX[x] * 2 >= sizeY:\n              break\n            minOffset += 1\n            continue\n\n          for x in range(sizeX - 1, -1, -1):\n            if sumX[x] * 2 >= sizeY:\n              break\n            maxOffset += 1\n            continue\n\n          if (sizeX - minOffset - maxOffset) * 2 <= sizeY and sizeX - minOffset - maxOffset > 0:\n            newDoorPoints += [[(minX + minOffset + maxX - maxOffset) / 2, minY, 0, 2], [(minX + minOffset + maxX - maxOffset) / 2, maxY, 0, 0]]\n            newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n            doorPointOffset += 2\n            pass\n\n          sumY = mask.sum(1)\n          minOffset, maxOffset = 0, 0\n          for y in range(sizeY):\n            if sumY[y] * 2 >= sizeX:\n              break\n            minOffset += 1\n            continue\n\n          for y in range(sizeY - 1, -1, -1):\n            if sumY[y] * 2 >= sizeX:\n              break\n            maxOffset += 1\n            continue\n\n          if (sizeY - minOffset - maxOffset) * 2 <= sizeX and sizeY - minOffset - maxOffset > 0:\n            newDoorPoints += [[minX, (minY + minOffset + maxY - maxOffset) / 2, 0, 1], [maxX, (minY + minOffset + maxY - maxOffset) / 2, 0, 3]]\n            newDoorLines.append((doorPointOffset, doorPointOffset + 1))\n            doorPointOffset += 2\n            pass\n          pass\n        pass\n      continue\n    continue\n  return newIcons, newIconPoints, newDoorLines, newDoorPoints\n\ndef sortLines(points, lines):\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    if points[line[0]][lineDim] > points[line[1]][lineDim]:\n      lines[lineIndex] = (line[1], line[0])\n      pass\n    continue\n\ndef reconstructFloorplan(wallCornerHeatmaps, doorCornerHeatmaps, iconCornerHeatmaps, iconHeatmaps, roomHeatmaps, densityImage=None, gt_dict=None, gt=False, gap=-1, distanceThreshold=-1, lengthThreshold=-1, debug_prefix=\'test\', heatmapValueThresholdWall=None, heatmapValueThresholdDoor=None, heatmapValueThresholdIcon=None):\n  print(\'reconstruct\')\n\n  wallPoints = []\n  iconPoints = []\n  doorPoints = []\n  if withoutQP:\n    numWallPoints = 30\n    numDoorPoints = 30\n    numIconPoints = 30\n    heatmapValueThresholdWall = 0.5\n    heatmapValueThresholdDoor = 0.5\n    heatmapValueThresholdIcon = 0.5\n  else:\n    numWallPoints = 100\n    numDoorPoints = 100\n    numIconPoints = 100\n    if heatmapValueThresholdWall is None:\n      heatmapValueThresholdWall = 0.5\n\n    heatmapValueThresholdDoor = 0.5\n\n    heatmapValueThresholdIcon = 0.5\n    pass\n\n  if gap > 0:\n    for k in GAPS:\n      GAPS[k] = gap\n      continue\n    pass\n  if distanceThreshold > 0:\n    for k in DISTANCES:\n      DISTANCES[k] = distanceThreshold\n      continue\n    pass\n  if lengthThreshold > 0:\n    for k in LENGTH_THRESHOLDS:\n      LENGTH_THRESHOLDS[k] = lengthThreshold\n      continue\n    pass\n  enable_augment = not gt\n  enable_augment = False\n  wallPoints, wallLines, wallPointOrientationLinesMap, wallPointNeighbors, augmentedPointMask = extractCorners(wallCornerHeatmaps, heatmapValueThresholdWall, gap=GAPS[\'wall_extraction\'], augment=enable_augment, h_points=enable_augment, gt=gt)\n  doorPoints, doorLines, doorPointOrientationLinesMap, doorPointNeighbors, _ = extractCorners(doorCornerHeatmaps, heatmapValueThresholdDoor, gap=GAPS[\'door_extraction\'], cornerType=\'door\', gt=gt)\n  iconPoints, iconLines, iconPointOrientationLinesMap, iconPointNeighbors, _ = extractCorners(iconCornerHeatmaps, heatmapValueThresholdIcon, gap=GAPS[\'icon_extraction\'], cornerType=\'icon\', gt=gt)\n\n  if not gt:\n    #print([[wallPoints[pointIndex] for pointIndex in wallLines[wallIndex]] for wallIndex in range(len(wallLines))])\n    for pointIndex, point in enumerate(wallPoints):\n      print((pointIndex, np.array(point[:2]).astype(np.int32).tolist(), point[2], point[3]))\n      continue\n    # print(wallPoints[19])\n    # print(wallPointNeighbors[19])\n    # print(wallPointOrientationLinesMap[19])\n\n    wallPoints, wallLines, wallPointOrientationLinesMap, wallPointNeighbors = filterWalls(wallPoints, wallLines)\n    #wallPoints, wallLines, wallPointOrientationLinesMap, wallPointNeighbors = filterWallsDynamic(wallPoints, wallLines)\n    #print(\'after filtering\')\n    #print([[wallPoints[pointIndex] for pointIndex in wallLines[wallIndex]] for wallIndex in range(len(wallLines))])\n\n    # for pointIndex, point in enumerate(wallPoints):\n    #   print((pointIndex, np.array(point[:2]).astype(np.int32).tolist(), point[2], point[3]))\n    #   continue\n    # print(wallPoints[15])\n    # print(wallPointNeighbors[15])\n    # print(wallPointOrientationLinesMap[15])\n    # exit(1)\n    pass\n\n\n  sortLines(doorPoints, doorLines)\n  sortLines(wallPoints, wallLines)\n\n  print(\'the number of points\', len(wallPoints), len(doorPoints), len(iconPoints))\n  print(\'the number of lines\', len(wallLines), len(doorLines), len(iconLines))\n\n  #print(wallPointNeighbors[26])\n  #print(wallPointOrientationLinesMap[26])\n  #exit(1)\n\n  if True:\n    #densityImg = cv2.imread(\'test/predict_density.png\', 0)\n    drawPoints(os.path.join(debug_prefix, ""points.png""), width, height, wallPoints, densityImage, pointSize=3)\n    drawPointsSeparately(os.path.join(debug_prefix, \'points\'), width, height, wallPoints, densityImage, pointSize=3)\n    drawLines(os.path.join(debug_prefix, \'lines.png\'), width, height, wallPoints, wallLines, [], None, 1, lineColor=255)\n  else:\n    drawPoints(os.path.join(debug_prefix, \'points.png\'), width, height, wallPoints)\n    drawPointsSeparately(os.path.join(debug_prefix, \'points\'), wallPoints)\n    drawLines(os.path.join(debug_prefix, \'lines.png\'), width, height, wallPoints, wallLines, [], None, 2, lineColor=255)\n    pass\n\n  if gt_dict != None and False:\n    findMatches({\'wall\': [wallPoints, wallLines, []]}, gt_dict, distanceThreshold=DISTANCES[\'wall\'])\n    pass\n\n  wallMask = drawLineMask(width, height, wallPoints, wallLines)\n  print(\'gt\', gt)\n\n  labelVotesMap = np.zeros((NUM_FINAL_ROOMS, height, width))\n  #labelMap = np.zeros((NUM_LABELS, height, width))\n  #semanticHeatmaps = np.concatenate([iconHeatmaps, roomHeatmaps], axis=2)\n  for segmentIndex in range(NUM_FINAL_ROOMS):\n    segmentation_img = roomHeatmaps[:, :, segmentIndex]\n    #segmentation_img = (segmentation_img > 0.5).astype(np.float)\n    labelVotesMap[segmentIndex] = segmentation_img\n    #labelMap[segmentIndex] = segmentation_img\n    continue\n\n  labelVotesMap = np.cumsum(np.cumsum(labelVotesMap, axis=1), axis=2)\n\n  #doorLines, doorPointOrientationLinesMap, doorPointNeighbors = calcPointInfo(doorPoints, gap, True)\n  #icons = findIcons(iconPoints, GAP, False)\n  icons = findIconsFromLines(iconPoints, iconLines)\n\n  if not gt:\n    newIcons, newIconPoints, newDoorLines, newDoorPoints = findCandidatesFromHeatmaps(iconHeatmaps, len(iconPoints), len(doorPoints))\n\n    icons += newIcons\n    iconPoints += newIconPoints\n    doorLines += newDoorLines\n    doorPoints += newDoorPoints\n    pass\n\n  # print([(doorPoints[line[0]][:2], doorPoints[line[1]][:2]) for line in newDoorLines])\n  # print([(iconPoints[icon[0]][:2], iconPoints[icon[1]][:2], iconPoints[icon[2]][:2], iconPoints[icon[3]][:2]) for icon in newIcons])\n  # print(\'num icons\', len(icons), len(newIcons))\n  # if len(newIcons) > 10:\n  #   exit(1)\n  #   pass\n\n\n  #print([(doorPoints[line[0]][:2], doorPoints[line[1]][:2]) for line in newDoorLines])\n  #print([(iconPoints[icon[0]][:2], iconPoints[icon[1]][:2], iconPoints[icon[2]][:2], iconPoints[icon[3]][:2]) for icon in newIcons])\n  #print([(iconPoints[icon[0]][:2], iconPoints[icon[1]][:2], iconPoints[icon[2]][:2], iconPoints[icon[3]][:2]) for icon in icons[:10]])\n  #exit(1)\n\n\n  #icons = [icons[0]]\n  #iconLines, iconPointOrientationLinesMap, iconPointNeighbors = calcPointInfo(iconPoints, gap, True)\n\n  if True:\n    drawLines(os.path.join(debug_prefix, \'lines.png\'), width, height, wallPoints, wallLines, [], None, 2, lineColor=255)\n    drawLines(os.path.join(debug_prefix, \'doors.png\'), width, height, doorPoints, doorLines, [], None, 2, lineColor=255)\n    drawRectangles(os.path.join(debug_prefix, \'icons.png\'), width, height, iconPoints, icons, {}, 2)\n    print(\'number of walls: \' + str(len(wallLines)))\n    print(\'number of doors: \' + str(len(doorLines)))\n    print(\'number of icons: \' + str(len(icons)))\n    pass\n\n\n  doorWallLineMap = findLineMap(doorPoints, doorLines, wallPoints, wallLines, gap=GAPS[\'wall_door_neighbor\'])\n\n  newDoorLines = []\n  newDoorWallLineMap = []\n  for lineIndex, walls in enumerate(doorWallLineMap):\n    if len(walls) > 0:\n      newDoorLines.append(doorLines[lineIndex])\n      newDoorWallLineMap.append(walls)\n      pass\n    continue\n  doorLines = newDoorLines\n  doorWallLineMap = newDoorWallLineMap\n\n\n  #print(len(wallLines))\n  conflictWallLinePairs = findConflictLinePairs(wallPoints, wallLines, gap=GAPS[\'wall_conflict\'], distanceThreshold=DISTANCES[\'wall\'], considerEndPoints=True)\n  #print(len(wallLines))\n\n  # print([(pointIndex, wallPoints[pointIndex]) for pointIndex in range(len(wallPoints))])\n  # print(wallPointNeighbors[15])\n  # print([(lineIndex, wallLine) for lineIndex, wallLine in enumerate(wallLines)])\n\n\n  conflictDoorLinePairs = findConflictLinePairs(doorPoints, doorLines, gap=GAPS[\'door_conflict\'], distanceThreshold=DISTANCES[\'door\'])\n  conflictIconPairs = findConflictRectanglePairs(iconPoints, icons, gap=GAPS[\'icon_conflict\'])\n  #print(conflictIconPairs)\n  #print([[[np.array(iconPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in icons[iconIndex]] for iconIndex in iconPair] for iconPair in conflictIconPairs])\n  #print([(iconIndex, [np.array(iconPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in icons[iconIndex]]) for iconIndex in range(len(icons))])\n  #exit(1)\n\n\n\n  if False:\n    # for lineIndex, line in enumerate(doorLines):\n    #   drawLines(\'test/doors/line_\' + str(lineIndex) + \'.png\', width, height, doorPoints, [line])\n    #   continue\n\n    print(wallLines)\n\n    os.system(\'mkdir \' + debug_prefix + \'/lines\')\n    for lineIndex, line in enumerate(wallLines):\n      drawLines(os.path.join(debug_prefix, \'lines/line_\' + str(lineIndex) + \'.png\'), width, height, wallPoints, [line], [], lineColor=255)\n      continue\n    exit(1)\n    pass\n\n\n  wallLineNeighbors = findLineNeighbors(wallPoints, wallLines, labelVotesMap, gap=GAPS[\'wall_neighbor\'])\n\n  iconWallLineNeighbors = findRectangleLineNeighbors(iconPoints, icons, wallPoints, wallLines, wallLineNeighbors, gap=GAPS[\'wall_icon_neighbor\'], distanceThreshold=DISTANCES[\'wall_icon\'])\n  conflictIconWallPairs = findConflictRectangleLinePairs(iconPoints, icons, wallPoints, wallLines, gap=GAPS[\'wall_icon_conflict\'])\n\n\n  # print(wallLineNeighbors[18])\n  # print(wallLineNeighbors[35])\n  # print([pair for pair in conflictWallLinePairs if 35 in pair])\n  # exit(1)\n\n  if False:\n    print(conflictWallLinePairs)\n    #for wallIndex in [0, 1, 29, 48, 34, 59, 37, 61]:\n    for wallIndex in [0, 17]:\n      print(wallLines[wallIndex])\n      print([wallPoints[pointIndex] for pointIndex in wallLines[wallIndex]])\n      print(wallPointOrientationLinesMap[wallLines[wallIndex][0]])\n      print(wallPointOrientationLinesMap[wallLines[wallIndex][1]])\n      continue\n    exit(1)\n    pass\n\n\n  exteriorLines = {}\n  for lineIndex, neighbors in enumerate(wallLineNeighbors):\n    if len(neighbors[0]) == 0 and len(neighbors[1]) > 0:\n      exteriorLines[lineIndex] = 0\n    elif len(neighbors[0]) > 0 and len(neighbors[1]) == 0:\n      exteriorLines[lineIndex] = 1\n      pass\n    continue\n\n  #print(exteriorLines)\n  #exit(1)\n\n  if False:\n    # for i in range(2):\n    #   print(wallLineNeighbors[43][i].keys())\n    #   print(wallLineNeighbors[81][i].keys())\n    #   print(wallLineNeighbors[84][i].keys())\n    # exit(1)\n    filteredWallLines = []\n    for lineIndex, neighbors in enumerate(wallLineNeighbors):\n      if len(neighbors[0]) == 0 and len(neighbors[1]) > 0:\n        print(lineIndex)\n        filteredWallLines.append(wallLines[lineIndex])\n        pass\n      continue\n    drawLines(os.path.join(debug_prefix, \'exterior_1.png\'), width, height, wallPoints, filteredWallLines, lineColor=255)\n\n    filteredWallLines = []\n    for lineIndex, neighbors in enumerate(wallLineNeighbors):\n      if len(neighbors[0]) > 0 and len(neighbors[1]) == 0:\n        print(lineIndex)\n        filteredWallLines.append(wallLines[lineIndex])\n        pass\n      continue\n    drawLines(os.path.join(debug_prefix, \'exterior_2.png\'), width, height, wallPoints, filteredWallLines, lineColor=255)\n    exit(1)\n    pass\n\n\n\n  try:\n  #if True:\n    model = Model(""JunctionFilter"")\n\n    #add variables\n    w_p = [model.addVar(vtype = GRB.BINARY, name=""point_"" + str(pointIndex)) for pointIndex in range(len(wallPoints))]\n    w_l = [model.addVar(vtype = GRB.BINARY, name=""line_"" + str(lineIndex)) for lineIndex in range(len(wallLines))]\n\n    d_l = [model.addVar(vtype = GRB.BINARY, name=""door_line_"" + str(lineIndex)) for lineIndex in range(len(doorLines))]\n\n    i_r = [model.addVar(vtype = GRB.BINARY, name=""icon_rectangle_"" + str(lineIndex)) for lineIndex in range(len(icons))]\n\n    i_types = []\n    for iconIndex in range(len(icons)):\n      i_types.append([model.addVar(vtype = GRB.BINARY, name=""icon_type_"" + str(iconIndex) + ""_"" + str(typeIndex)) for typeIndex in range(NUM_FINAL_ICONS)])\n      continue\n\n    l_dir_labels = []\n    for lineIndex in range(len(wallLines)):\n      dir_labels = []\n      for direction in range(2):\n        labels = []\n        for label in range(NUM_FINAL_ROOMS):\n          labels.append(model.addVar(vtype = GRB.BINARY, name=""line_"" + str(lineIndex) + ""_"" + str(direction) + ""_"" + str(label)))\n        dir_labels.append(labels)\n      l_dir_labels.append(dir_labels)\n\n\n\n    #model.update()\n    obj = QuadExpr()\n\n    if gt:\n      for pointIndex in range(len(wallPoints)):\n        model.addConstr(w_p[pointIndex] == 1, \'gt_point_active_\' + str(pointIndex))\n        continue\n\n      pointIconMap = {}\n      for iconIndex, icon in enumerate(icons):\n        for pointIndex in icon:\n          if pointIndex not in pointIconMap:\n            pointIconMap[pointIndex] = []\n            pass\n          pointIconMap[pointIndex].append(iconIndex)\n          continue\n        continue\n      for pointIndex, iconIndices in pointIconMap.iteritems():\n        break\n        iconSum = LinExpr()\n        for iconIndex in iconIndices:\n          iconSum += i_r[iconIndex]\n          continue\n        model.addConstr(iconSum == 1)\n        continue\n      pass\n\n\n    #label sum constraints\n    for lineIndex in range(len(wallLines)):\n      for direction in range(2):\n        labelSum = LinExpr()\n        for label in range(NUM_FINAL_ROOMS):\n          labelSum += l_dir_labels[lineIndex][direction][label]\n          continue\n        model.addConstr(labelSum == w_l[lineIndex], \'label_sum\')\n        continue\n      continue\n\n\n    #opposite room constraints\n    if False:\n      oppositeRoomPairs = [(1, 1), (2, 2), (4, 4), (5, 5), (7, 7), (9, 9)]\n      for lineIndex in range(len(wallLines)):\n        for oppositeRoomPair in oppositeRoomPairs:\n          model.addConstr(l_dir_labels[lineIndex][0][oppositeRoomPair[0]] + l_dir_labels[lineIndex][0][oppositeRoomPair[1]] <= 1)\n          if oppositeRoomPair[0] != oppositeRoomPair[1]:\n            model.addConstr(l_dir_labels[lineIndex][0][oppositeRoomPair[1]] + l_dir_labels[lineIndex][0][oppositeRoomPair[0]] <= 1)\n            pass\n          continue\n        continue\n      pass\n\n    #loop constraints\n    closeRooms = {}\n    for label in range(NUM_FINAL_ROOMS):\n      closeRooms[label] = True\n      continue\n    closeRooms[1] = False\n    closeRooms[2] = False\n    #closeRooms[3] = False\n    closeRooms[8] = False\n    closeRooms[9] = False\n\n    for label in range(NUM_FINAL_ROOMS):\n      if not closeRooms[label]:\n        continue\n      for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n        for orientation, lines in orientationLinesMap.iteritems():\n          direction = int(orientation in [1, 2])\n          lineSum = LinExpr()\n          for lineIndex in lines:\n            lineSum += l_dir_labels[lineIndex][direction][label]\n            continue\n          for nextOrientation in range(orientation + 1, 8):\n            if not (nextOrientation % 4) in orientationLinesMap:\n              continue\n            nextLines = orientationLinesMap[nextOrientation % 4]\n            nextDirection = int((nextOrientation % 4) in [0, 3])\n            nextLineSum = LinExpr()\n            for nextLineIndex in nextLines:\n              nextLineSum += l_dir_labels[nextLineIndex][nextDirection][label]\n              continue\n            model.addConstr(lineSum == nextLineSum)\n            break\n          continue\n        continue\n      continue\n\n\n    #exterior constraints\n    exteriorLineSum = LinExpr()\n    for lineIndex in range(len(wallLines)):\n      if lineIndex not in exteriorLines:\n        continue\n      #direction = exteriorLines[lineIndex]\n      label = 0\n      model.addConstr(l_dir_labels[lineIndex][0][label] + l_dir_labels[lineIndex][1][label] == w_l[lineIndex], \'exterior_wall\')\n      exteriorLineSum += w_l[lineIndex]\n      continue\n    model.addConstr(exteriorLineSum >= 1, \'exterior_wall_sum\')\n\n\n    #line label constraints and objectives\n    for lineIndex, directionNeighbors in enumerate(wallLineNeighbors):\n      for direction, neighbors in enumerate(directionNeighbors):\n        labelVotesSum = np.zeros(NUM_FINAL_ROOMS)\n        for neighbor, labelVotes in neighbors.iteritems():\n          labelVotesSum += labelVotes\n          continue\n\n        votesSum = labelVotesSum.sum()\n        if votesSum == 0:\n          continue\n        labelVotesSum /= votesSum\n\n\n        for label in range(NUM_FINAL_ROOMS):\n          obj += l_dir_labels[lineIndex][direction][label] * (0.0 - labelVotesSum[label]) * labelWeight\n          continue\n        continue\n      continue\n\n\n    # if not gt:\n    #   print(wallLineNeighbors[47][1])\n    #   print(wallLineNeighbors[140][1])\n    #   print(wallLineNeighbors[67][0])\n    #   print(wallLineNeighbors[128][0])\n    #   pass\n\n\n    # for pointIndex in range(len(wallPoints)):\n    #   if pointIndex not in augmentedPointMask:\n    #     obj += (1 - w_p[pointIndex]) * junctionWeight #* len(wallPointOrientationLinesMap[pointIndex])\n    #   else:\n    #     obj += w_p[pointIndex] * augmentedJunctionWeight #* len(wallPointOrientationLinesMap[pointIndex])\n    #   continue\n\n\n    #door endpoint constraints\n    pointDoorsMap = {}\n    for doorIndex, line in enumerate(doorLines):\n      for endpointIndex in range(2):\n        pointIndex = line[endpointIndex]\n        if pointIndex not in pointDoorsMap:\n          pointDoorsMap[pointIndex] = []\n          pass\n        pointDoorsMap[pointIndex].append(doorIndex)\n        continue\n      continue\n\n\n\n    # confidence insensitive objectives\n    # for pointIndex, doorIndices in pointDoorsMap.iteritems():\n    #   doorSum = LinExpr(0)\n    #   for doorIndex in doorIndices:\n    #     doorSum += d_l[doorIndex]\n    #     continue\n    #   obj += (1 - doorSum) * doorWeight\n    #   #model.addConstr(doorSum <= 1, ""door_line_sum_"" + str(pointIndex) + ""_"" + str(orientation))\n    #   continue\n\n\n\n\n    #icon corner constraints\n    pointIconsMap = {}\n    for iconIndex, icon in enumerate(icons):\n      for cornerIndex in range(4):\n        pointIndex = icon[cornerIndex]\n        if pointIndex not in pointIconsMap:\n          pointIconsMap[pointIndex] = []\n          pass\n        pointIconsMap[pointIndex].append(iconIndex)\n        continue\n      continue\n\n    for pointIndex, iconIndices in pointIconsMap.iteritems():\n      iconSum = LinExpr(0)\n      for iconIndex in iconIndices:\n        iconSum += i_r[iconIndex]\n        continue\n      #obj += (1 - iconSum) * iconWeight\n      #print(iconIndices)\n      model.addConstr(iconSum <= 1)\n      continue\n\n    #exit(1)\n    #print(pointIconsMap)\n\n\n    #gapWeight = 1\n    #pixelEvidenceWeight = 1\n\n\n    if False:\n      for lineIndex, line in enumerate(wallLines):\n        point = wallPoints[line[0]]\n        neighborPoint = wallPoints[line[1]]\n        lineDim = calcLineDim(wallPoints, line)\n        #wallCost = (abs(neighborPoint[1 - lineDim] - point[1 - lineDim]) / GAP - 0.5) * gapWeight\n        #obj += w_l[lineIndex] * wallCost * wallWeight\n\n        fixedValue = int(round((neighborPoint[1 - lineDim] + point[1 - lineDim]) / 2))\n\n        # wallEvidenceSums = [0, 0]\n        # for delta in range(int(abs(neighborPoint[lineDim] - point[lineDim]) + 1)):\n        #   intermediatePoint = [0, 0]\n        #   intermediatePoint[lineDim] = int(min(neighborPoint[lineDim], point[lineDim]) + delta)\n        #   intermediatePoint[1 - lineDim] = fixedValue\n        #   for typeIndex in range(NUM_WALL_TYPES):\n        #     wallEvidenceSums[typeIndex] += labelMap[WALL_LABEL_OFFSET + typeIndex][min(max(intermediatePoint[1], 0), height - 1)][min(max(intermediatePoint[0], 0), width - 1)]\n        #     continue\n        #   continue\n        # wallEvidenceSum = wallEvidenceSums[0] + wallEvidenceSums[1]\n        # wallEvidenceSum /= maxDim\n\n        wallEvidenceSum = 0.0\n        count = 0\n\n        for delta in range(int(round(abs(neighborPoint[lineDim] - point[lineDim]))) + 1):\n          intermediatePoint = [0, 0]\n          intermediatePoint[lineDim] = int(min(neighborPoint[lineDim], point[lineDim]) + delta)\n          intermediatePoint[1 - lineDim] = fixedValue\n          if lineDim == 0:\n            fixedValue_1 = min(max(intermediatePoint[1] - wallLineWidth, 0), height - 1)\n            fixedValue_2 = min(max(intermediatePoint[1] + wallLineWidth + 1, 0), height - 1)\n            wallEvidenceSum += roomHeatmaps[fixedValue_1:fixedValue_2, min(max(intermediatePoint[0], 0), width - 1), WALL_LABEL_OFFSET].sum()\n          else:\n            fixedValue_1 = min(max(intermediatePoint[0] - wallLineWidth, 0), width - 1)\n            fixedValue_2 = min(max(intermediatePoint[0] + wallLineWidth + 1, 0), width - 1)\n            wallEvidenceSum += roomHeatmaps[min(max(intermediatePoint[1], 0), height - 1), fixedValue_1:fixedValue_2, WALL_LABEL_OFFSET].sum()\n            pass\n          count += fixedValue_2 - fixedValue_1\n          continue\n        wallEvidenceSum /= count\n        #print(lineIndex, wallEvidenceSum, [wallPoints[pointIndex] for pointIndex in wallLines[lineIndex]])\n        obj += -wallEvidenceSum * w_l[lineIndex] * wallWeight\n        continue\n    else:\n      wallLineConfidenceMap = roomHeatmaps[:, :, WALL_LABEL_OFFSET]\n      wallConfidences = []\n      for lineIndex, line in enumerate(wallLines):\n        point_1 = np.array(wallPoints[line[0]][:2])\n        point_2 = np.array(wallPoints[line[1]][:2])\n        lineDim = calcLineDim(wallPoints, line)\n\n        fixedValue = int(round((point_1[1 - lineDim] + point_2[1 - lineDim]) / 2))\n        point_1[lineDim], point_2[lineDim] = min(point_1[lineDim], point_2[lineDim]), max(point_1[lineDim], point_2[lineDim])\n\n        point_1[1 - lineDim] = fixedValue - wallLineWidth\n        point_2[1 - lineDim] = fixedValue + wallLineWidth\n\n\n        point_1 = np.maximum(point_1, 0).astype(np.int32)\n        point_2 = np.minimum(point_2, sizes - 1).astype(np.int32)\n\n        wallLineConfidence = np.sum(wallLineConfidenceMap[point_1[1]:point_2[1] + 1, point_1[0]:point_2[0] + 1]) / ((point_2[1] + 1 - point_1[1]) * (point_2[0] + 1 - point_1[0])) - 0.5\n\n        obj += -wallLineConfidence * w_l[lineIndex] * wallWeight\n\n        wallConfidences.append(wallLineConfidence)\n        continue\n      pass\n\n    if not gt:\n      for wallIndex, wallLine in enumerate(wallLines):\n        print(wallIndex, [np.array(wallPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in wallLine], wallConfidences[wallIndex])\n        continue\n      #model.addConstr(w_l[28] == 1)\n      pass\n\n\n    doorLineConfidenceMap = iconHeatmaps[:, :, DOOR_LABEL_OFFSET] + iconHeatmaps[:, :, DOOR_LABEL_OFFSET + 1]\n    for lineIndex, line in enumerate(doorLines):\n      #obj += -d_l[lineIndex] * doorWeight * abs(neighborPoint[lineDim] - point[lineDim] + 1) / maxDim\n      #continue\n      point_1 = np.array(doorPoints[line[0]][:2])\n      point_2 = np.array(doorPoints[line[1]][:2])\n      lineDim = calcLineDim(doorPoints, line)\n\n      #doorCost = (abs(neighborPoint[1 - lineDim] - point[1 - lineDim]) / gap - 1) * gapWeight\n      #obj += d_l[lineIndex] * doorCost * doorWeight\n      fixedValue = int(round((point_1[1 - lineDim] + point_2[1 - lineDim]) / 2))\n\n      #assert(point_1[lineDim] < point_2[lineDim], \'door line reversed\')\n      point_1[lineDim], point_2[lineDim] = min(point_1[lineDim], point_2[lineDim]), max(point_1[lineDim], point_2[lineDim])\n\n      point_1[1 - lineDim] = fixedValue - doorLineWidth\n      point_2[1 - lineDim] = fixedValue + doorLineWidth\n\n      point_1 = np.maximum(point_1, 0).astype(np.int32)\n      point_2 = np.minimum(point_2, sizes - 1).astype(np.int32)\n\n      if not gt:\n        doorLineConfidence = np.sum(doorLineConfidenceMap[point_1[1]:point_2[1] + 1, point_1[0]:point_2[0] + 1]) / ((point_2[1] + 1 - point_1[1]) * (point_2[0] + 1 - point_1[0]))\n\n        if lineDim == 0:\n          doorPointConfidence = (doorCornerHeatmaps[point_1[1], point_1[0], 3] + doorCornerHeatmaps[point_2[1], point_2[0], 1]) / 2\n        else:\n          doorPointConfidence = (doorCornerHeatmaps[point_1[1], point_1[0], 0] + doorCornerHeatmaps[point_2[1], point_2[0], 2]) / 2\n          pass\n        doorConfidence = (doorLineConfidence + doorPointConfidence) / 2 - 0.5\n        obj += -doorConfidence * d_l[lineIndex] * doorWeight\n      else:\n        obj += -0.5 * d_l[lineIndex] * doorWeight\n        pass\n\n      #doorEvidenceSums = [0 for typeIndex in range(NUM_DOOR_TYPES)]\n      #doorEvidenceSum = 0\n      # for delta in range(int(abs(neighborPoint[lineDim] - point[lineDim]) + 1)):\n      #   intermediatePoint = [0, 0]\n      #   intermediatePoint[lineDim] = int(min(neighborPoint[lineDim], point[lineDim]) + delta)\n      #   intermediatePoint[1 - lineDim] = fixedValue\n\n      #   doorEvidenceSum += np.sum(labelMap[DOOR_LABEL_OFFSET:DOOR_LABEL_OFFSET + NUM_DOOR_TYPES, min(max(intermediatePoint[1], 0), height - 1), min(max(intermediatePoint[0], 0), width - 1)])\n      #   continue\n      # doorEvidenceSum /= maxDim\n\n      #print(point_1.tolist(), point_2.tolist(), doorConfidence)\n\n      #print((\'door confidence\', lineIndex, [np.array(doorPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in doorLines[lineIndex]]))\n\n\n      continue\n\n\n    for iconIndex, icon in enumerate(icons):\n      point_1 = iconPoints[icon[0]]\n      point_2 = iconPoints[icon[1]]\n      point_3 = iconPoints[icon[2]]\n      point_4 = iconPoints[icon[3]]\n\n      x_1 = int((point_1[0] + point_3[0]) / 2)\n      x_2 = int((point_2[0] + point_4[0]) / 2)\n      y_1 = int((point_1[1] + point_2[1]) / 2)\n      y_2 = int((point_3[1] + point_4[1]) / 2)\n\n      iconArea = (x_2 - x_1 + 1) * (y_2 - y_1 + 1)\n      #iconEvidenceSums = labelVotesMap[ICON_LABEL_OFFSET:ICON_LABEL_OFFSET + NUM_FINAL_ICONS, y_2, x_2] + labelVotesMap[ICON_LABEL_OFFSET:ICON_LABEL_OFFSET + NUM_FINAL_ICONS, y_1, x_1] - labelVotesMap[ICON_LABEL_OFFSET:ICON_LABEL_OFFSET + NUM_FINAL_ICONS, y_2, x_1] - labelVotesMap[ICON_LABEL_OFFSET:ICON_LABEL_OFFSET + NUM_FINAL_ICONS, y_1, x_2]\n\n      # for typeIndex in range(NUM_FINAL_ICONS):\n      #   iconRatio = iconEvidenceSums[typeIndex] / iconArea\n      #   if iconRatio < 0.5 and False:\n      #     model.addConstr(i_types[iconIndex][typeIndex] == 0)\n      #   else:\n      #     obj += i_types[iconIndex][typeIndex] * (0 - iconEvidenceSums[typeIndex] / iconArea) * iconTypeWeight\n      #   continue\n      # continue\n\n      if iconArea <= 1e-4:\n        print(icon)\n        print([iconPoints[pointIndex] for pointIndex in icon])\n        print(\'zero size icon\')\n        exit(1)\n        pass\n\n      iconTypeConfidence = iconHeatmaps[y_1:y_2 + 1, x_1:x_2 + 1, :NUM_FINAL_ICONS + 1].sum(axis=(0, 1)) / iconArea\n      iconTypeConfidence[1] += iconTypeConfidence[8]\n      iconTypeConfidence[6] += iconTypeConfidence[9]\n      iconTypeConfidence[8] = 0\n      iconTypeConfidence[9] = 0\n      iconTypeConfidence = iconTypeConfidence[1:] - iconTypeConfidence[0]\n\n      if not gt:\n        #iconPointConfidence = (iconCornerHeatmaps[y_1, x_1, 2] + iconCornerHeatmaps[y_1, x_2, 3] + iconCornerHeatmaps[y_2, x_1, 1] + iconCornerHeatmaps[y_2, x_2, 0]) / 4 - 0.5\n        iconPointConfidence = (iconCornerHeatmaps[int(round(point_1[1])), int(round(point_1[0])), 2] + iconCornerHeatmaps[int(round(point_2[1])), int(round(point_2[0])), 3] + iconCornerHeatmaps[int(round(point_3[1])), int(round(point_3[0])), 1] + iconCornerHeatmaps[int(round(point_4[1])), int(round(point_4[0])), 0]) / 4 - 0.5\n        iconConfidence = (iconTypeConfidence + iconPointConfidence) / 2\n      else:\n        iconConfidence = iconTypeConfidence\n        pass\n\n      #iconTypeConfidence[1:] = 0\n      #iconTypeConfidence[0] = 0\n      for typeIndex in range(NUM_FINAL_ICONS):\n        obj += -i_types[iconIndex][typeIndex] * (iconConfidence[typeIndex]) * iconTypeWeight\n        continue\n\n      #print(\'icon confidence\', iconIndex, x_1, y_1, x_2, y_2, iconTypeConfidence.argmax(), iconTypeConfidence[iconTypeConfidence.argmax()], iconConfidence[iconTypeConfidence.argmax()])\n      continue\n\n    #if not gt:\n    #exit(1)\n\n    for iconIndex in range(len(icons)):\n      typeSum = LinExpr(0)\n      for typeIndex in range(NUM_FINAL_ICONS - 1):\n        typeSum += i_types[iconIndex][typeIndex]\n        continue\n      model.addConstr(typeSum == i_r[iconIndex])\n      continue\n\n\n    #line sum constraints and objectives\n    for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n      pointLineSum = LinExpr(0)\n      for orientation, lines in orientationLinesMap.iteritems():\n        #if len(lines) > 1:\n        #print(lines)\n        lineSum = LinExpr(0)\n        for lineIndex in lines:\n          lineSum += w_l[lineIndex]\n          continue\n\n        model.addConstr(lineSum == w_p[pointIndex], ""line_sum_"" + str(pointIndex) + ""_"" + str(orientation))\n        #obj += (w_p[pointIndex] - lineSum) * junctionLineWeight\n        #obj += (1 - lineSum) * junctionWeight\n        pointLineSum += lineSum\n        continue\n\n      #if wallPoints[pointIndex][2] > 0:\n      #model.addConstr(pointLineSum >= wallPoints[pointIndex][2] * w_p[pointIndex], \'point line sum\')\n        #model.addConstr(pointLineSum >= 2 * w_p[pointIndex], \'point line sum\')\n        #pass\n\n      continue\n\n\n    # #close points constraints\n    # for pointIndex, point in enumerate(wallPoints):\n    #   for neighborPointIndex, neighborPoint in enumerate(wallPoints):\n    #     if neighborPointIndex <= pointIndex:\n    #       continue\n    #     distance = pow(pow(point[0] - neighborPoint[0], 2) + pow(point[1] - neighborPoint[1], 2), 0.5)\n    #     if distance < DISTANCES[\'point\'] and neighborPointIndex not in wallPointNeighbors[pointIndex]:\n    #       #print(\'close point\', pointIndex, neighborPointIndex)\n    #       #obj += p[pointIndex] * p[neighborPointIndex] * closePointWeight\n    #       model.addConstr(w_p[pointIndex] + w_p[neighborPointIndex] <= 1, \'close point\')\n    #       pass\n    #     continue\n    #   continue\n\n\n    # print(\'conflict\')\n    # conflictLines = [0, ]\n    # for conflictLinePair in conflictWallLinePairs:\n    #   if conflictLinePair[0] == 0:\n    #     conflictLines.append(conflictLinePair[1])\n    #     pass\n    #   for c in range(2):\n    #     if conflictLinePair[c] in [1, 29, 48, 34, 59, 37, 61] and conflictLinePair[1 - c] not in conflictLines:\n    #       print(conflictLinePair)\n    #       pass\n    #     if conflictLinePair[c] in [1, 29, 48, 34, 59, 37, 61] and conflictLinePair[1 - c] in [1, 29, 48, 34, 59, 37, 61]:\n    #       print(conflictLinePair)\n    #       pass\n    #     continue\n    #   continue\n    # drawLines(\'test/lines/line_0_combined.png\', width, height, wallPoints, [wallLines[lineIndex] for lineIndex in [1, 29, 48, 34, 59, 37, 61]], [], None, 2, lineColor=255)\n    # exit(1)\n\n\n    #conflict pair constraints\n\n    # ratio_1 = 0.47\n    # ratio_2 = 0.5\n    #print(\'ratio\', int(round(len(conflictWallLinePairs) * ratio_1)), int(round(len(conflictWallLinePairs) * ratio_2)), len(conflictWallLinePairs))\n    # conflictWallLinePairs = conflictWallLinePairs[int(round(len(conflictWallLinePairs) * ratio_1)):int(round(len(conflictWallLinePairs) * ratio_2))]\n\n\n    #print(len(conflictWallLinePairs))\n    #conflictWallLinePairs = conflictWallLinePairs[135:136] + conflictWallLinePairs[240:]\n    #conflictWallLinePairs = []\n    #print(conflictWallLinePairs[135:136])\n    #exit(1)\n\n\n    for conflictLinePair in conflictWallLinePairs:\n      model.addConstr(w_l[conflictLinePair[0]] + w_l[conflictLinePair[1]] <= 1, \'conflict_wall_line_pair\')\n      continue\n\n    for conflictLinePair in conflictDoorLinePairs:\n      model.addConstr(d_l[conflictLinePair[0]] + d_l[conflictLinePair[1]] <= 1, \'conflict_door_line_pair\')\n      continue\n\n    for conflictIconPair in conflictIconPairs:\n      model.addConstr(i_r[conflictIconPair[0]] + i_r[conflictIconPair[1]] <= 1, \'conflict_icon_pair\')\n      continue\n\n    for conflictLinePair in conflictIconWallPairs:\n      model.addConstr(i_r[conflictLinePair[0]] + w_l[conflictLinePair[1]] <= 1, \'conflict_icon_wall_pair\')\n      continue\n\n\n    #door wall line map constraints\n    for doorIndex, lines in enumerate(doorWallLineMap):\n      if len(lines) == 0:\n        model.addConstr(d_l[doorIndex] == 0, \'door_not_on_walls\')\n        continue\n      lineSum = LinExpr(0)\n      for lineIndex in lines:\n        lineSum += w_l[lineIndex]\n        continue\n      model.addConstr(d_l[doorIndex] <= lineSum, \'d<=line_sum\')\n      continue\n\n    doorWallPointMap = findLinePointMap(doorPoints, doorLines, wallPoints, gap=GAPS[\'door_point_conflict\'])\n    for doorIndex, points in enumerate(doorWallPointMap):\n      if len(points) == 0:\n        continue\n      #print(\'door\', [doorPoints[pointIndex] for pointIndex in doorLines[doorIndex][:2]])\n      #print([wallPoints[pointIndex][:2] for pointIndex in points])\n      pointSum = LinExpr(0)\n      for pointIndex in points:\n        model.addConstr(d_l[doorIndex] + w_p[pointIndex] <= 1, \'door_on_two_walls\')\n        continue\n      continue\n    #exit(1)\n\n\n    if not gt:\n      # print(wallLines[91])\n      #print(wallPointOrientationLinesMap[24])\n      #print(wallPointNeighbors[24])\n      #exit(1)\n\n      #print(conflictWallLinePairs)\n\n      #1, 29, 48, 34, 59, 37, 61\n      #model.addConstr(w_l[13] == 0)\n      #model.addConstr(w_p[7] == 1)\n      #model.addConstr(w_l[55] == 1)\n      #model.addConstr(w_l[63] == 1)\n\n      #model.addConstr(w_l[45] == 0)\n\n      # for wallIndex in [44, 57, 60]:\n      #   model.addConstr(w_l[wallIndex] == 1)\n      #   continue\n\n      #model.addConstr(d_l[3] == 1)\n      #print(wallLines[90])\n      #print(wallLines[62])\n      #print(wallLines[73])\n      #print(wallLines[107])\n      #print(wallLines[111])\n      #print(wallPointOrientationLinesMap[wallLines[0][0]])\n      #print(wallPointOrientationLinesMap[wallLines[111][1]])\n      #print(wallPointOrientationLinesMap[25])\n      #print(wallLines[])\n      #exit(1)\n      #model.addConstr(d_l[8] == 1)\n      #model.addConstr(i_types[8][1] == 1)\n      #model.addConstr(l_dir_labels[39][1][7] == 1)\n      #exit(1)\n      pass\n\n\n    model.setObjective(obj, GRB.MINIMIZE)\n    #model.update()\n    model.setParam(\'TimeLimit\', 120)\n    model.optimize()\n\n\n    if model.status == GRB.Status.INF_OR_UNBD:\n      # Turn presolve off to determine whether model is infeasible\n      # or unbounded\n      model.setParam(GRB.Param.Presolve, 0)\n      model.optimize()\n\n    model.write(\'test/model.lp\')\n    #print(model.status)\n    if model.status == GRB.Status.OPTIMAL:\n      filteredWallLines = []\n      filteredWallLabels = []\n      filteredWallTypes = []\n      wallPointLabels = [[-1, -1, -1, -1] for pointIndex in range(len(wallPoints))]\n\n      for lineIndex, lineVar in enumerate(w_l):\n        if lineVar.x < 0.5:\n          continue\n        filteredWallLines.append(wallLines[lineIndex])\n\n        filteredWallTypes.append(0)\n\n        labels = [11, 11]\n        for direction in range(2):\n          for label in range(NUM_FINAL_ROOMS):\n            if l_dir_labels[lineIndex][direction][label].x > 0.5:\n              labels[direction] = label\n              break\n            continue\n          continue\n\n        filteredWallLabels.append(labels)\n        print(\'wall\', lineIndex, labels, [np.array(wallPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in wallLines[lineIndex]], wallLineNeighbors[lineIndex][0].keys(), wallLineNeighbors[lineIndex][1].keys())\n        line = wallLines[lineIndex]\n        lineDim = calcLineDim(wallPoints, line)\n        if lineDim == 0:\n          wallPointLabels[line[0]][0] = labels[0]\n          wallPointLabels[line[0]][1] = labels[1]\n          wallPointLabels[line[1]][3] = labels[0]\n          wallPointLabels[line[1]][2] = labels[1]\n        else:\n          wallPointLabels[line[0]][1] = labels[0]\n          wallPointLabels[line[0]][2] = labels[1]\n          wallPointLabels[line[1]][0] = labels[0]\n          wallPointLabels[line[1]][3] = labels[1]\n          pass\n        continue\n\n\n      #if not gt:\n      #print([(lineIndex, [np.array(wallPoints[pointIndex][:2]).astype(np.int32).tolist() for pointIndex in wallLine]) for lineIndex, wallLine in enumerate(filteredWallLines)])\n      #exit(1)\n\n      if not gt:\n        adjustPoints(wallPoints, filteredWallLines)\n        mergePoints(wallPoints, filteredWallLines)\n        adjustPoints(wallPoints, filteredWallLines)\n        filteredWallLabels = [filteredWallLabels[lineIndex] for lineIndex in range(len(filteredWallLines)) if filteredWallLines[lineIndex][0] != filteredWallLines[lineIndex][1]]\n        filteredWallLines = [line for line in filteredWallLines if line[0] != line[1]]\n        pass\n\n\n      drawLines(\'test/result_line.png\', width, height, wallPoints, filteredWallLines, filteredWallLabels, lineColor=255)\n      #resultImage = drawLines(\'\', width, height, wallPoints, filteredWallLines, filteredWallLabels, None, lineWidth=5, lineColor=255)\n\n      filteredDoorLines = []\n      filteredDoorTypes = []\n      for lineIndex, lineVar in enumerate(d_l):\n        if lineVar.x < 0.5:\n          continue\n        print((\'door\', lineIndex, [doorPoints[pointIndex][:2] for pointIndex in doorLines[lineIndex]]))\n        filteredDoorLines.append(doorLines[lineIndex])\n\n        filteredDoorTypes.append(0)\n        continue\n\n      filteredDoorWallMap = findLineMapSingle(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, gap=GAPS[\'wall_door_neighbor\'])\n      adjustDoorPoints(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, filteredDoorWallMap)\n      drawLines(\'test/result_door.png\', width, height, doorPoints, filteredDoorLines, lineColor=255)\n\n      filteredIcons = []\n      filteredIconTypes = []\n      for iconIndex, iconVar in enumerate(i_r):\n        if iconVar.x < 0.5:\n          continue\n\n        filteredIcons.append(icons[iconIndex])\n        iconType = -1\n        for typeIndex in range(NUM_FINAL_ICONS):\n          if i_types[iconIndex][typeIndex].x > 0.5:\n            iconType = typeIndex\n            break\n          continue\n\n        print((\'icon\', iconIndex, iconType, [iconPoints[pointIndex][:2] for pointIndex in icons[iconIndex]]))\n\n        filteredIconTypes.append(iconType)\n        continue\n\n\n\n      # print(icons)\n      # print(conflictIconWallPairs)\n      # print(filteredIcons)\n      # exit(1)\n\n      #adjustPoints(iconPoints, filteredIconLines)\n      #drawLines(\'test/lines_results_icon.png\', width, height, iconPoints, filteredIconLines)\n      drawRectangles(\'test/result_icon.png\', width, height, iconPoints, filteredIcons, filteredIconTypes)\n\n\n      #resultImage = drawLines(\'\', width, height, doorPoints, filteredDoorLines, [], resultImage, lineWidth=3, lineColor=0)\n      #resultImage = drawRectangles(\'\', width, height, iconPoints, filteredIcons, filteredIconTypes, 2, resultImage)\n      #cv2.imwrite(\'test/result.png\', resultImage)\n\n\n      filteredWallPoints = []\n      filteredWallPointLabels = []\n      orientationMap = {}\n      for pointType, orientationOrientations in enumerate(POINT_ORIENTATIONS):\n        for orientation, orientations in enumerate(orientationOrientations):\n          orientationMap[orientations] = orientation\n\n      for pointIndex, point in enumerate(wallPoints):\n        #if w_p[pointIndex].x < 0.5:\n        #continue\n\n        orientations = []\n        orientationLines = {}\n        for orientation, lines in wallPointOrientationLinesMap[pointIndex].iteritems():\n          orientationLine = -1\n          for lineIndex in lines:\n            if w_l[lineIndex].x > 0.5:\n              orientations.append(orientation)\n              orientationLines[orientation] = lineIndex\n              break\n            continue\n          continue\n\n        if len(orientations) == 0:\n          continue\n\n        #print((pointIndex, orientationLines))\n\n        if len(orientations) < len(wallPointOrientationLinesMap[pointIndex]):\n          print(\'invalid point\', pointIndex, orientations, wallPointOrientationLinesMap[pointIndex])\n          print(wallPoints[pointIndex])\n          wallPoints[pointIndex][2] = len(orientations) - 1\n          orientations = tuple(orientations)\n          if orientations not in orientationMap:\n            continue\n          wallPoints[pointIndex][3] = orientationMap[orientations]\n          print(wallPoints[pointIndex])\n          exit(1)\n          pass\n\n        filteredWallPoints.append(wallPoints[pointIndex])\n        filteredWallPointLabels.append(wallPointLabels[pointIndex])\n        continue\n\n\n      writePoints(filteredWallPoints, filteredWallPointLabels)\n\n\n      with open(\'test/floorplan.txt\', \'w\') as result_file:\n        result_file.write(str(width) + \'\\t\' + str(height) + \'\\n\')\n        result_file.write(str(len(filteredWallLines)) + \'\\n\')\n        for wallIndex, wall in enumerate(filteredWallLines):\n          point_1 = wallPoints[wall[0]]\n          point_2 = wallPoints[wall[1]]\n\n          result_file.write(str(point_1[0]) + \'\\t\' + str(point_1[1]) + \'\\t\')\n          result_file.write(str(point_2[0]) + \'\\t\' + str(point_2[1]) + \'\\t\')\n          result_file.write(str(filteredWallLabels[wallIndex][0]) + \'\\t\' + str(filteredWallLabels[wallIndex][1]) + \'\\n\')\n\n        for doorIndex, door in enumerate(filteredDoorLines):\n          point_1 = doorPoints[door[0]]\n          point_2 = doorPoints[door[1]]\n\n          result_file.write(str(point_1[0]) + \'\\t\' + str(point_1[1]) + \'\\t\')\n          result_file.write(str(point_2[0]) + \'\\t\' + str(point_2[1]) + \'\\t\')\n          result_file.write(\'door\\t\')\n          result_file.write(str(filteredDoorTypes[doorIndex] + 1) + \'\\t1\\n\')\n\n        for iconIndex, icon in enumerate(filteredIcons):\n          point_1 = iconPoints[icon[0]]\n          point_2 = iconPoints[icon[1]]\n          point_3 = iconPoints[icon[2]]\n          point_4 = iconPoints[icon[3]]\n\n          x_1 = int((point_1[0] + point_3[0]) / 2)\n          x_2 = int((point_2[0] + point_4[0]) / 2)\n          y_1 = int((point_1[1] + point_2[1]) / 2)\n          y_2 = int((point_3[1] + point_4[1]) / 2)\n\n          result_file.write(str(x_1) + \'\\t\' + str(y_1) + \'\\t\')\n          result_file.write(str(x_2) + \'\\t\' + str(y_2) + \'\\t\')\n          result_file.write(iconNumberNameMap[filteredIconTypes[iconIndex]] + \'\\t\')\n          #result_file.write(str(iconNumberStyleMap[filteredIconTypes[iconIndex]]) + \'\\t\')\n          result_file.write(\'1\\t\')\n          result_file.write(\'1\\n\')\n\n        result_file.close()\n\n\n      if len(filteredDoorLines) > 0:\n        writeDoors(doorPoints, filteredDoorLines, filteredDoorTypes)\n        pass\n      else:\n        try:\n          os.remove(\'test/doors_out.txt\')\n        except OSError:\n          pass\n\n      if len(filteredIcons) > 0:\n        writeIcons(iconPoints, filteredIcons, filteredIconTypes)\n        pass\n      else:\n        try:\n          os.remove(\'test/icons_out.txt\')\n        except OSError:\n          pass\n        pass\n\n\n\n    elif model.status != GRB.Status.INFEASIBLE:\n      print(\'Optimization was stopped with status %d\' % model.status)\n      return {}\n    else:\n      print(\'infeasible\')\n      #model.ComputeIIS()\n      #model.write(""test/model.ilp"")\n      return {}\n      pass\n\n  except GurobiError as e:\n    print(\'Error code \' + str(e.errno) + "": "" + str(e))\n    return {}\n    pass\n  except AttributeError:\n    print(\'Encountered an attribute error\')\n    return {}\n    pass\n\n  result_dict = {\'wall\': [wallPoints, filteredWallLines, filteredWallLabels], \'door\': [doorPoints, filteredDoorLines, []], \'icon\': [iconPoints, filteredIcons, filteredIconTypes]}\n  return result_dict\n'"
pytorch/options.py,0,"b'import argparse\n\ndef parse_args():\n    """"""\n    Parse input arguments\n    """"""\n    parser = argparse.ArgumentParser(description=\'PlaneFlow\')\n    \n    parser.add_argument(\'--task\', dest=\'task\',\n                        help=\'task type: [train, test, predict]\',\n                        default=\'train\', type=str)\n    parser.add_argument(\'--restore\', dest=\'restore\',\n                        help=\'how to restore the model\',\n                        default=1, type=int)\n    parser.add_argument(\'--batchSize\', dest=\'batchSize\',\n                        help=\'batch size\',\n                        default=16, type=int)\n    parser.add_argument(\'--dataset\', dest=\'dataset\',\n                        help=\'dataset name for training\',\n                        default=\'scannet\', type=str)\n    parser.add_argument(\'--testingDataset\', dest=\'testingDataset\',\n                        help=\'dataset name for test/predict\',\n                        default=\'scannet\', type=str)\n    parser.add_argument(\'--numTrainingImages\', dest=\'numTrainingImages\',\n                        help=\'the number of images to train\',\n                        default=10000, type=int)\n    parser.add_argument(\'--numTestingImages\', dest=\'numTestingImages\',\n                        help=\'the number of images to test/predict\',\n                        default=100, type=int)\n    parser.add_argument(\'--LR\', dest=\'LR\',\n                        help=\'learning rate\',\n                        default=2.5e-4, type=float)\n    parser.add_argument(\'--numEpochs\', dest=\'numEpochs\',\n                        help=\'the number of epochs\',\n                        default=1000, type=int)\n    parser.add_argument(\'--startEpoch\', dest=\'startEpoch\',\n                        help=\'starting epoch index\',\n                        default=0, type=int)\n    parser.add_argument(\'--modelType\', dest=\'modelType\',\n                        help=\'model type\',\n                        default=\'\', type=str)\n    parser.add_argument(\'--heatmapThreshold\', dest=\'heatmapThreshold\',\n                        help=\'heatmap threshold for positive predictions\',\n                        default=0.5, type=float)\n    parser.add_argument(\'--distanceThreshold3D\', dest=\'distanceThreshold3D\',\n                        help=\'distance threshold 3D\',\n                        default=0.2, type=float)\n    parser.add_argument(\'--distanceThreshold2D\', dest=\'distanceThreshold2D\',\n                        help=\'distance threshold 2D\',\n                        default=20, type=float)\n    parser.add_argument(\'--numInputPlanes\', dest=\'numInputPlanes\',\n                        help=\'the number of input planes\',\n                        default=1024, type=int)\n    parser.add_argument(\'--numOutputPlanes\', dest=\'numOutputPlanes\',\n                        help=\'the number of output planes\',\n                        default=10, type=int)\n    parser.add_argument(\'--numInputClasses\', dest=\'numInputClasses\',\n                        help=\'the number of input classes\',\n                        default=0, type=int)\n    parser.add_argument(\'--numOutputClasses\', dest=\'numOutputClasses\',\n                        help=\'the number of output classes\',\n                        default=0, type=int)    \n    parser.add_argument(\'--width\', dest=\'width\',\n                        help=\'input width\',\n                        default=256, type=int)\n    parser.add_argument(\'--height\', dest=\'height\',\n                        help=\'input height\',\n                        default=256, type=int)\n    parser.add_argument(\'--outputWidth\', dest=\'outputWidth\',\n                        help=\'output width\',\n                        default=256, type=int)\n    parser.add_argument(\'--outputHeight\', dest=\'outputHeight\',\n                        help=\'output height\',\n                        default=192, type=int)\n    ## Flags\n    parser.add_argument(\'--visualizeMode\', dest=\'visualizeMode\',\n                        help=\'visualization mode\',\n                        default=\'\', type=str)    \n    parser.add_argument(\'--suffix\', dest=\'suffix\',\n                        help=\'suffix to distinguish experiments\',\n                        default=\'\', type=str)    \n    \n    args = parser.parse_args()\n    return args\n'"
pytorch/train.py,14,"b'import torch\nfrom torch.utils.data import DataLoader\n\nfrom tqdm import tqdm\nimport numpy as np\nimport os\nimport cv2\n\nfrom utils import *\nfrom options import parse_args\n\nfrom models.model import Model\n\nfrom datasets.floorplan_dataset import FloorplanDataset\nfrom IP import reconstructFloorplan\n\ndef main(options):\n    if not os.path.exists(options.checkpoint_dir):\n        os.system(""mkdir -p %s""%options.checkpoint_dir)\n        pass\n    if not os.path.exists(options.test_dir):\n        os.system(""mkdir -p %s""%options.test_dir)\n        pass\n\n    dataset = FloorplanDataset(options, split=\'train\', random=True)\n\n    print(\'the number of images\', len(dataset))    \n\n    dataloader = DataLoader(dataset, batch_size=options.batchSize, shuffle=True, num_workers=16)\n\n    model = Model(options)\n    model.cuda()\n    model.train()\n\n    if options.restore == 1:\n        print(\'restore\')\n        model.load_state_dict(torch.load(options.checkpoint_dir + \'/checkpoint.pth\'))\n        pass\n\n    \n    if options.task == \'test\':\n        dataset_test = FloorplanDataset(options, split=\'test\', random=False)\n        testOneEpoch(options, model, dataset_test)\n        exit(1)\n    \n    optimizer = torch.optim.Adam(model.parameters(), lr = options.LR)\n    if options.restore == 1 and os.path.exists(options.checkpoint_dir + \'/optim.pth\'):\n        optimizer.load_state_dict(torch.load(options.checkpoint_dir + \'/optim.pth\'))\n        pass\n\n    for epoch in range(options.numEpochs):\n        epoch_losses = []\n        data_iterator = tqdm(dataloader, total=len(dataset) // options.batchSize + 1)\n        for sampleIndex, sample in enumerate(data_iterator):\n            optimizer.zero_grad()\n            \n            images, corner_gt, icon_gt, room_gt = sample[0].cuda(), sample[1].cuda(), sample[2].cuda(), sample[3].cuda()\n\n            corner_pred, icon_pred, room_pred = model(images)\n            #print([(v.shape, v.min(), v.max()) for v in [corner_pred, icon_pred, room_pred, corner_gt, icon_gt, room_gt]])\n            #exit(1)\n            #print(corner_pred.shape, corner_gt.shape)\n            #exit(1)\n            corner_loss = torch.nn.functional.binary_cross_entropy(corner_pred, corner_gt)\n            icon_loss = torch.nn.functional.cross_entropy(icon_pred.view(-1, NUM_ICONS + 2), icon_gt.view(-1))\n            room_loss = torch.nn.functional.cross_entropy(room_pred.view(-1, NUM_ROOMS + 2), room_gt.view(-1))            \n            losses = [corner_loss, icon_loss, room_loss]\n            loss = sum(losses)\n\n            loss_values = [l.data.item() for l in losses]\n            epoch_losses.append(loss_values)\n            status = str(epoch + 1) + \' loss: \'\n            for l in loss_values:\n                status += \'%0.5f \'%l\n                continue\n            data_iterator.set_description(status)\n            loss.backward()\n            optimizer.step()\n\n            if sampleIndex % 500 == 0:\n                visualizeBatch(options, images.detach().cpu().numpy(), [(\'gt\', {\'corner\': corner_gt.detach().cpu().numpy(), \'icon\': icon_gt.detach().cpu().numpy(), \'room\': room_gt.detach().cpu().numpy()}), (\'pred\', {\'corner\': corner_pred.max(-1)[1].detach().cpu().numpy(), \'icon\': icon_pred.max(-1)[1].detach().cpu().numpy(), \'room\': room_pred.max(-1)[1].detach().cpu().numpy()})])\n                if options.visualizeMode == \'debug\':\n                    exit(1)\n                    pass\n            continue\n        print(\'loss\', np.array(epoch_losses).mean(0))\n        if True:\n            torch.save(model.state_dict(), options.checkpoint_dir + \'/checkpoint.pth\')\n            torch.save(optimizer.state_dict(), options.checkpoint_dir + \'/optim.pth\')\n            pass\n\n        #testOneEpoch(options, model, dataset_test)        \n        continue\n    return\n\ndef testOneEpoch(options, model, dataset):\n    model.eval()\n    \n    dataloader = DataLoader(dataset, batch_size=options.batchSize, shuffle=False, num_workers=1)\n    \n    epoch_losses = []    \n    data_iterator = tqdm(dataloader, total=len(dataset) // options.batchSize + 1)\n    for sampleIndex, sample in enumerate(data_iterator):\n\n        images, corner_gt, icon_gt, room_gt = sample[0].cuda(), sample[1].cuda(), sample[2].cuda(), sample[3].cuda()\n        \n        corner_pred, icon_pred, room_pred = model(images)\n        corner_loss = torch.nn.functional.binary_cross_entropy(corner_pred, corner_gt)\n        icon_loss = torch.nn.functional.cross_entropy(icon_pred.view(-1, NUM_ICONS + 2), icon_gt.view(-1))\n        room_loss = torch.nn.functional.cross_entropy(room_pred.view(-1, NUM_ROOMS + 2), room_gt.view(-1))            \n        losses = [corner_loss, icon_loss, room_loss]\n        \n        loss = sum(losses)\n\n        loss_values = [l.data.item() for l in losses]\n        epoch_losses.append(loss_values)\n        status = \'val loss: \'\n        for l in loss_values:\n            status += \'%0.5f \'%l\n            continue\n        data_iterator.set_description(status)\n\n        if sampleIndex % 500 == 0:\n            visualizeBatch(options, images.detach().cpu().numpy(), [(\'gt\', {\'corner\': corner_gt.detach().cpu().numpy(), \'icon\': icon_gt.detach().cpu().numpy(), \'room\': room_gt.detach().cpu().numpy()}), (\'pred\', {\'corner\': corner_pred.max(-1)[1].detach().cpu().numpy(), \'icon\': icon_pred.max(-1)[1].detach().cpu().numpy(), \'room\': room_pred.max(-1)[1].detach().cpu().numpy()})])            \n            for batchIndex in range(len(images)):\n                corner_heatmaps = corner_pred[batchIndex].detach().cpu().numpy()\n                icon_heatmaps = torch.nn.functional.softmax(icon_pred[batchIndex], dim=-1).detach().cpu().numpy()\n                room_heatmaps = torch.nn.functional.softmax(room_pred[batchIndex], dim=-1).detach().cpu().numpy()                \n                reconstructFloorplan(corner_heatmaps[:, :, :NUM_WALL_CORNERS], corner_heatmaps[:, :, NUM_WALL_CORNERS:NUM_WALL_CORNERS + 4], corner_heatmaps[:, :, -4:], icon_heatmaps, room_heatmaps, output_prefix=options.test_dir + \'/\' + str(batchIndex) + \'_\', densityImage=None, gt_dict=None, gt=False, gap=-1, distanceThreshold=-1, lengthThreshold=-1, debug_prefix=\'test\', heatmapValueThresholdWall=None, heatmapValueThresholdDoor=None, heatmapValueThresholdIcon=None, enableAugmentation=True)\n                continue\n            if options.visualizeMode == \'debug\':\n                exit(1)\n                pass\n        continue\n    print(\'validation loss\', np.array(epoch_losses).mean(0))\n\n    model.train()\n    return\n\ndef visualizeBatch(options, images, dicts, indexOffset=0, prefix=\'\'):\n    #cornerColorMap = {\'gt\': np.array([255, 0, 0]), \'pred\': np.array([0, 0, 255]), \'inp\': np.array([0, 255, 0])}\n    #pointColorMap = ColorPalette(20).getColorMap()\n    images = ((images.transpose((0, 2, 3, 1)) + 0.5) * 255).astype(np.uint8)\n    for batchIndex in range(len(images)):\n        image = images[batchIndex].copy()\n        filename = options.test_dir + \'/\' + str(indexOffset + batchIndex) + \'_image.png\'\n        cv2.imwrite(filename, image)\n        for name, result_dict in dicts:\n            for info in [\'corner\', \'icon\', \'room\']:\n                cv2.imwrite(filename.replace(\'image\', info + \'_\' + name), drawSegmentationImage(result_dict[info][batchIndex], blackIndex=0, blackThreshold=0.5))\n                continue\n            continue\n        continue\n    return\n\nif __name__ == \'__main__\':\n    args = parse_args()\n    \n    args.keyname = \'floorplan\'\n    #args.keyname += \'_\' + args.dataset\n\n    if args.suffix != \'\':\n        args.keyname += \'_\' + suffix\n        pass\n    \n    args.checkpoint_dir = \'checkpoint/\' + args.keyname\n    args.test_dir = \'test/\' + args.keyname\n\n    print(\'keyname=%s task=%s started\'%(args.keyname, args.task))\n\n    main(args)\n'"
pytorch/utils.py,0,"b'import numpy as np\nimport cv2\n\nNUM_WALL_CORNERS = 13\nNUM_CORNERS = 21\n#CORNER_RANGES = {\'wall\': (0, 13), \'opening\': (13, 17), \'icon\': (17, 21)}\n\nNUM_ICONS = 7\nNUM_ROOMS = 10\nPOINT_ORIENTATIONS = [[(2, ), (3, ), (0, ), (1, )], [(0, 3), (0, 1), (1, 2), (2, 3)], [(1, 2, 3), (0, 2, 3), (0, 1, 3), (0, 1, 2)], [(0, 1, 2, 3)]]\n\nclass ColorPalette:\n    def __init__(self, numColors):\n        #np.random.seed(2)\n        #self.colorMap = np.random.randint(255, size = (numColors, 3))\n        #self.colorMap[0] = 0\n\n        \n        self.colorMap = np.array([[255, 0, 0],\n                                  [0, 255, 0],\n                                  [0, 0, 255],\n                                  [80, 128, 255],\n                                  [255, 230, 180],\n                                  [255, 0, 255],\n                                  [0, 255, 255],\n                                  [100, 0, 0],\n                                  [0, 100, 0],                                   \n                                  [255, 255, 0],                                  \n                                  [50, 150, 0],\n                                  [200, 255, 255],\n                                  [255, 200, 255],\n                                  [128, 128, 80],\n                                  [0, 50, 128],                                  \n                                  [0, 100, 100],\n                                  [0, 255, 128],                                  \n                                  [0, 128, 255],\n                                  [255, 0, 128],                                  \n                                  [128, 0, 255],\n                                  [255, 128, 0],                                  \n                                  [128, 255, 0],                                                                    \n        ])\n\n        if numColors > self.colorMap.shape[0]:\n            self.colorMap = np.random.randint(255, size = (numColors, 3))\n            pass\n        \n        return\n\n    def getColorMap(self):\n        return self.colorMap\n    \n    def getColor(self, index):\n        if index >= colorMap.shape[0]:\n            return np.random.randint(255, size = (3))\n        else:\n            return self.colorMap[index]\n            pass\n        return\n\ndef isManhattan(line, gap=3):\n    return min(abs(line[0][0] - line[1][0]), abs(line[0][1] - line[1][1])) < gap\n\ndef calcLineDim(points, line):\n    point_1 = points[line[0]]\n    point_2 = points[line[1]]\n    if abs(point_2[0] - point_1[0]) > abs(point_2[1] - point_1[1]):\n        lineDim = 0\n    else:\n        lineDim = 1\n        pass\n    return lineDim\n\ndef calcLineDirection(line, gap=3):\n    return int(abs(line[0][0] - line[1][0]) < abs(line[0][1] - line[1][1]))\n\n## Draw segmentation image. The input could be either HxW or HxWxC\ndef drawSegmentationImage(segmentations, numColors=42, blackIndex=-1, blackThreshold=-1):\n    if segmentations.ndim == 2:\n        numColors = max(numColors, segmentations.max() + 2)\n    else:\n        if blackThreshold > 0:\n            segmentations = np.concatenate([segmentations, np.ones((segmentations.shape[0], segmentations.shape[1], 1)) * blackThreshold], axis=2)\n            blackIndex = segmentations.shape[2] - 1\n            pass\n\n        numColors = max(numColors, segmentations.shape[2] + 2)\n        pass\n    randomColor = ColorPalette(numColors).getColorMap()\n    if blackIndex >= 0:\n        randomColor[blackIndex] = 0\n        pass\n    width = segmentations.shape[1]\n    height = segmentations.shape[0]\n    if segmentations.ndim == 3:\n        #segmentation = (np.argmax(segmentations, 2) + 1) * (np.max(segmentations, 2) > 0.5)\n        segmentation = np.argmax(segmentations, 2)\n    else:\n        segmentation = segmentations\n        pass\n\n    segmentation = segmentation.astype(np.int32)\n    return randomColor[segmentation.reshape(-1)].reshape((height, width, 3))\n\n\ndef drawWallMask(walls, width, height, thickness=3, indexed=False):\n    if indexed:\n        wallMask = np.full((height, width), -1, dtype=np.int32)\n        for wallIndex, wall in enumerate(walls):\n            cv2.line(wallMask, (int(wall[0][0]), int(wall[0][1])), (int(wall[1][0]), int(wall[1][1])), color=wallIndex, thickness=thickness)\n            continue\n    else:\n        wallMask = np.zeros((height, width), dtype=np.int32)\n        for wall in walls:\n            cv2.line(wallMask, (int(wall[0][0]), int(wall[0][1])), (int(wall[1][0]), int(wall[1][1])), color=1, thickness=thickness)\n            continue\n        wallMask = wallMask.astype(np.bool)\n        pass\n    return wallMask\n\n\ndef extractCornersFromHeatmaps(heatmaps, heatmapThreshold=0.5, numPixelsThreshold=5, returnRanges=True):\n    """"""Extract corners from heatmaps""""""\n    from skimage import measure\n    heatmaps = (heatmaps > heatmapThreshold).astype(np.float32)\n    orientationPoints = []\n    #kernel = np.ones((3, 3), np.float32)\n    for heatmapIndex in range(0, heatmaps.shape[-1]):\n        heatmap = heatmaps[:, :, heatmapIndex]\n        #heatmap = cv2.dilate(cv2.erode(heatmap, kernel), kernel)\n        components = measure.label(heatmap, background=0)\n        points = []\n        for componentIndex in range(components.min() + 1, components.max() + 1):\n            ys, xs = (components == componentIndex).nonzero()\n            if ys.shape[0] <= numPixelsThreshold:\n                continue\n            #print(heatmapIndex, xs.shape, ys.shape, componentIndex)\n            if returnRanges:\n                points.append(((xs.mean(), ys.mean()), (xs.min(), ys.min()), (xs.max(), ys.max())))\n            else:\n                points.append((xs.mean(), ys.mean()))\n                pass\n            continue\n        orientationPoints.append(points)\n        continue\n    return orientationPoints\n\ndef extractCornersFromSegmentation(segmentation, cornerTypeRange=[0, 13]):\n    """"""Extract corners from segmentation""""""\n    from skimage import measure\n    orientationPoints = []\n    for heatmapIndex in range(cornerTypeRange[0], cornerTypeRange[1]):\n        heatmap = segmentation == heatmapIndex\n        #heatmap = cv2.dilate(cv2.erode(heatmap, kernel), kernel)\n        components = measure.label(heatmap, background=0)\n        points = []\n        for componentIndex in range(components.min()+1, components.max() + 1):\n            ys, xs = (components == componentIndex).nonzero()\n            points.append((xs.mean(), ys.mean()))\n            continue\n        orientationPoints.append(points)\n        continue\n    return orientationPoints\n\ndef getOrientationRanges(width, height):\n    orientationRanges = [[width, 0, 0, 0], [width, height, width, 0], [width, height, 0, height], [0, height, 0, 0]]\n    return orientationRanges\n\ndef getIconNames():\n    iconNames = []\n    iconLabelMap = getIconLabelMap()\n    for iconName, _ in iconLabelMap.items():\n        iconNames.append(iconName)\n        continue\n    return iconNames\n\ndef getIconLabelMap():\n    labelMap = {}\n    labelMap[\'bathtub\'] = 1\n    labelMap[\'cooking_counter\'] = 2\n    labelMap[\'toilet\'] = 3\n    labelMap[\'entrance\'] = 4\n    labelMap[\'washing_basin\'] = 5\n    labelMap[\'special\'] = 6\n    labelMap[\'stairs\'] = 7\n    labelMap[\'door\'] = 8\n    return labelMap\n\n\ndef drawPoints(filename, width, height, points, backgroundImage=None, pointSize=5, pointColor=None):\n  colorMap = ColorPalette(NUM_CORNERS).getColorMap()\n  if np.all(np.equal(backgroundImage, None)):\n    image = np.zeros((height, width, 3), np.uint8)\n  else:\n    if backgroundImage.ndim == 2:\n      image = np.tile(np.expand_dims(backgroundImage, -1), [1, 1, 3])\n    else:\n      image = backgroundImage\n      pass\n  pass\n  no_point_color = pointColor is None\n  for point in points:\n    if no_point_color:\n        pointColor = colorMap[point[2] * 4 + point[3]]\n        pass\n    #print(\'used\', pointColor)\n    #print(\'color\', point[2] , point[3])\n    image[max(int(round(point[1])) - pointSize, 0):min(int(round(point[1])) + pointSize, height), max(int(round(point[0])) - pointSize, 0):min(int(round(point[0])) + pointSize, width)] = pointColor\n    continue\n\n  if filename != \'\':\n    cv2.imwrite(filename, image)\n    return\n  else:\n    return image\n\ndef drawPointsSeparately(path, width, height, points, backgroundImage=None, pointSize=5):\n  if np.all(np.equal(backgroundImage, None)):\n    image = np.zeros((height, width, 13), np.uint8)\n  else:\n    image = np.tile(np.expand_dims(backgroundImage, -1), [1, 1, 13])\n    pass\n\n  for point in points:\n    image[max(int(round(point[1])) - pointSize, 0):min(int(round(point[1])) + pointSize, height), max(int(round(point[0])) - pointSize, 0):min(int(round(point[0])) + pointSize, width), int(point[2] * 4 + point[3])] = 255\n    continue\n  for channel in range(13):\n    cv2.imwrite(path + \'_\' + str(channel) + \'.png\', image[:, :, channel])\n    continue\n  return\n\ndef drawLineMask(width, height, points, lines, lineWidth = 5, backgroundImage = None):\n  lineMask = np.zeros((height, width))\n\n  for lineIndex, line in enumerate(lines):\n    point_1 = points[line[0]]\n    point_2 = points[line[1]]\n    direction = calcLineDirectionPoints(points, line)\n\n    fixedValue = int(round((point_1[1 - direction] + point_2[1 - direction]) / 2))\n    minValue = int(min(point_1[direction], point_2[direction]))\n    maxValue = int(max(point_1[direction], point_2[direction]))\n    if direction == 0:\n      lineMask[max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth + 1, height), minValue:maxValue + 1] = 1\n    else:\n      lineMask[minValue:maxValue + 1, max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth + 1, width)] = 1\n      pass\n    continue\n  return lineMask\n\n\n\ndef drawLines(filename, width, height, points, lines, lineLabels = [], backgroundImage = None, lineWidth = 5, lineColor = None):\n  colorMap = ColorPalette(len(lines)).getColorMap()\n  if backgroundImage is None:\n    image = np.ones((height, width, 3), np.uint8) * 0\n  else:\n    if backgroundImage.ndim == 2:\n      image = np.stack([backgroundImage, backgroundImage, backgroundImage], axis=2)\n    else:\n      image = backgroundImage\n      pass\n    pass\n\n  for lineIndex, line in enumerate(lines):\n    point_1 = points[line[0]]\n    point_2 = points[line[1]]\n    direction = calcLineDirectionPoints(points, line)\n\n\n    fixedValue = int(round((point_1[1 - direction] + point_2[1 - direction]) / 2))\n    minValue = int(round(min(point_1[direction], point_2[direction])))\n    maxValue = int(round(max(point_1[direction], point_2[direction])))\n    if len(lineLabels) == 0:\n      if np.any(lineColor == None):\n        lineColor = np.random.rand(3) * 255\n        pass\n      if direction == 0:\n        image[max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth + 1, height), minValue:maxValue + 1, :] = lineColor\n      else:\n        image[minValue:maxValue + 1, max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth + 1, width), :] = lineColor\n    else:\n      labels = lineLabels[lineIndex]\n      isExterior = False\n      if direction == 0:\n        for c in range(3):\n          image[max(fixedValue - lineWidth, 0):min(fixedValue, height), minValue:maxValue, c] = colorMap[labels[0]][c]\n          image[max(fixedValue, 0):min(fixedValue + lineWidth + 1, height), minValue:maxValue, c] = colorMap[labels[1]][c]\n          continue\n      else:\n        for c in range(3):\n          image[minValue:maxValue, max(fixedValue - lineWidth, 0):min(fixedValue, width), c] = colorMap[labels[1]][c]\n          image[minValue:maxValue, max(fixedValue, 0):min(fixedValue + lineWidth + 1, width), c] = colorMap[labels[0]][c]\n          continue\n        pass\n      pass\n    continue\n\n  if filename == \'\':\n    return image\n  else:\n    cv2.imwrite(filename, image)\n\n\ndef drawRectangles(filename, width, height, points, rectangles, labels, lineWidth = 2, backgroundImage = None, rectangleColor = None):\n  colorMap = ColorPalette(NUM_ICONS).getColorMap()\n  if backgroundImage is None:\n    image = np.ones((height, width, 3), np.uint8) * 0\n  else:\n    image = backgroundImage\n    pass\n\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    point_1 = points[rectangle[0]]\n    point_2 = points[rectangle[1]]\n    point_3 = points[rectangle[2]]\n    point_4 = points[rectangle[3]]\n\n\n    if len(labels) == 0:\n      if rectangleColor is None:\n        color = np.random.rand(3) * 255\n      else:\n        color = rectangleColor\n    else:\n      color = colorMap[labels[rectangleIndex]]\n      pass\n\n    x_1 = int(round((point_1[0] + point_3[0]) / 2))\n    x_2 = int(round((point_2[0] + point_4[0]) / 2))\n    y_1 = int(round((point_1[1] + point_2[1]) / 2))\n    y_2 = int(round((point_3[1] + point_4[1]) / 2))\n\n    cv2.rectangle(image, (x_1, y_1), (x_2, y_2), color=tuple(color.tolist()), thickness = 2)\n    continue\n\n  if filename == \'\':\n    return image\n  else:\n    cv2.imwrite(filename, image)\n    pass\n\ndef pointDistance(point_1, point_2):\n    #return np.sqrt(pow(point_1[0] - point_2[0], 2) + pow(point_1[1] - point_2[1], 2))\n    return max(abs(point_1[0] - point_2[0]), abs(point_1[1] - point_2[1]))\n\ndef calcLineDirectionPoints(points, line):\n  point_1 = points[line[0]]\n  point_2 = points[line[1]]\n  if isinstance(point_1[0], tuple):\n      point_1 = point_1[0]\n      pass\n  if isinstance(point_2[0], tuple):\n      point_2 = point_2[0]\n      pass\n  return calcLineDirection((point_1, point_2))\n'"
rendering/floorplan.py,0,"b'from panda3d.egg import *\nfrom panda3d.core import *\nfrom obj2egg import ObjMaterial\nfrom copy import deepcopy\nimport numpy as np\nimport cv2\nimport copy\n\ndef calcDistance(point_1, point_2):\n  return pow(pow(point_1[0] - point_2[0], 2) + pow(point_1[1] - point_2[1], 2), 0.5)\n\ndef calcLineDim(line, lineWidth = -1):\n  if abs(line[0][0] - line[1][0]) > abs(line[0][1] - line[1][1]):\n    if lineWidth < 0 or abs(line[0][1] - line[1][1]) <= lineWidth:\n      return 0\n    pass\n  elif abs(line[0][0] - line[1][0]) < abs(line[0][1] - line[1][1]):\n    if lineWidth < 0 or abs(line[0][0] - line[1][0]) <= lineWidth:\n      return 1\n  else:\n    return -1\n  \nclass Floorplan():\n  def __init__(self, filename):\n    self.wallWidth = 0.005\n    self.wallHeight = 0.3\n    self.doorWidth = self.wallWidth\n    self.doorHeight = self.wallHeight * 0.8\n    self.windowWidth = self.wallWidth + 0.0001\n    self.windowHeight = self.wallHeight * 0.5\n    self.windowOffset = self.wallHeight * 0.4\n    self.filename = filename\n    \n    self.floorMat = ObjMaterial()\n    #self.floorMat.filename = self.filename + \'.png\'\n    self.floorMat.name = \'floor\'\n    self.floorMat.put(\'map_Kd\', self.filename + \'.png\')\n\n    self.ceilingMat = ObjMaterial()\n    self.ceilingMat.name = \'ceiling\'\n    self.ceilingMat.put(\'map_Kd\', \'data/ceiling.jpg\')\n\n    self.wallMats = []\n    wallMat_1 = ObjMaterial()\n    wallMat_1.name = \'wall_1\'\n    wallMat_1.put(\'map_Kd\', \'data/bedroom_wall.jpg\')\n    wallMat_2 = ObjMaterial()\n    wallMat_2.name = \'wall_2\'\n    wallMat_2.put(\'map_Kd\', \'data/kitchen_wall.jpg\')\n    wallMat_3 = ObjMaterial()\n    wallMat_3.name = \'wall_3\'\n    wallMat_3.put(\'map_Kd\', \'data/dining_wall.jpg\')\n    wallMat_4 = ObjMaterial()\n    wallMat_4.name = \'wall_4\'\n    wallMat_4.put(\'map_Kd\', \'data/bathroom_wall.jpg\')\n    wallMat_5 = ObjMaterial()\n    wallMat_5.name = \'wall_5\'\n    wallMat_5.put(\'map_Kd\', \'data/wall.jpg\')\n\n    self.wallMats.append(wallMat_3)\n    self.wallMats.append(wallMat_2)\n    self.wallMats.append(wallMat_1)\n    self.wallMats.append(wallMat_4)\n    self.wallMats.append(wallMat_4)\n    self.wallMats.append(wallMat_1)\n    self.wallMats.append(wallMat_5)\n    self.wallMats.append(wallMat_2)\n    self.wallMats.append(wallMat_4)\n    self.wallMats.append(wallMat_5)\n    self.wallMats.append(wallMat_5)\n\n\n    self.doorMat = ObjMaterial()\n    self.doorMat.name = \'door\'\n    self.doorMat.put(\'map_Kd\', \'data/door.jpg\')\n\n    self.windowMat = ObjMaterial()\n    self.windowMat.name = \'window\'\n    self.windowMat.put(\'map_Kd\', \'data/window.jpg\')\n\n    self.iconNodes = {}\n    self.iconNodes[\'cooking_counter\'] = base.loader.loadModel(\'data/cooking_counter.egg\')\n    self.iconNodes[\'bathtub\'] = base.loader.loadModel(\'data/bathtub.egg\')\n    self.iconNodes[\'toilet\'] = base.loader.loadModel(\'data/toilet.egg\')\n    self.iconNodes[\'washing_basin\'] = base.loader.loadModel(\'data/washing_basin.egg\')\n    return\n\n\n  def read(self):\n    floorplanFile = open(self.filename + \'.txt\', \'r\')\n    self.walls = []\n    self.doors = []\n    self.icons = []\n    self.wallsInt = []\n    for line in floorplanFile.readlines():\n      line = line.strip()\n      values = line.split(\'\\t\')\n      if len(values) == 2:\n        self.width = float(values[0])\n        self.height = float(values[1])\n        self.maxDim = max(self.width, self.height)\n      elif len(values) == 6:\n        wall = []\n        for i in xrange(4):\n          wall.append(float(values[i]))\n          continue\n        lineDim = calcLineDim(((wall[0], wall[1]), (wall[2], wall[3])))\n        wall[lineDim], wall[2 + lineDim] = min(wall[lineDim], wall[2 + lineDim]), max(wall[lineDim], wall[2 + lineDim])\n        wall[1 - lineDim] = wall[3 - lineDim] = (wall[1 - lineDim] + wall[3 - lineDim]) / 2\n        wall.append(int(values[4]) - 1)\n        wall.append(int(values[5]) - 1)\n        for pointIndex in xrange(2):\n          wall[pointIndex * 2 + 0] /= self.maxDim\n          wall[pointIndex * 2 + 1] /= self.maxDim\n          continue\n        self.walls.append(wall)\n\n        wallInt = []\n        for i in xrange(4):\n          wallInt.append(int(values[i]))\n          continue\n        wallInt[lineDim], wallInt[2 + lineDim] = min(wallInt[lineDim], wallInt[2 + lineDim]), max(wallInt[lineDim], wallInt[2 + lineDim])\n        self.wallsInt.append(wallInt)\n      elif len(values) == 7:\n        item = []\n        for i in xrange(4):\n          item.append(float(values[i]))\n\n        for pointIndex in xrange(2):\n          item[pointIndex * 2 + 0] /= self.maxDim\n          item[pointIndex * 2 + 1] /= self.maxDim\n          continue\n\n        if values[4] == \'door\':\n          self.doors.append(item)\n        else:\n          item.append(values[4])\n          self.icons.append(item)\n          pass\n        pass\n      continue\n    return\n  \n  def generateFloor(self, data):\n    floorGroup = EggGroup(\'floor\')\n    data.addChild(floorGroup)\n    \n    vp = EggVertexPool(\'floor_vertex\')\n    floorGroup.addChild(vp)\n\n\n    exteriorWalls = []\n    for wall in self.walls:\n      if wall[4] == 10 or wall[5] == 10:\n        exteriorWalls.append(copy.deepcopy(wall))\n        pass\n      continue    \n\n\n    exteriorOpenings = []\n    for wall in exteriorWalls:\n      lineDim = calcLineDim((wall[:2], wall[2:4]))\n      for doorIndex, door in enumerate(self.doors):\n        if calcLineDim((door[:2], door[2:4])) != lineDim:\n          continue\n        if door[lineDim] >= wall[lineDim] and door[2 + lineDim] <= wall[2 + lineDim] and abs(door[1 - lineDim] - wall[1 - lineDim]) <= self.wallWidth:\n          exteriorOpenings.append(doorIndex)\n          pass\n        continue\n      continue\n\n    minDistance = 10000\n    mainDoorIndex = -1\n    for icon in self.icons:\n      if icon[4] == \'entrance\':\n        for doorIndex in exteriorOpenings:\n          door = self.doors[doorIndex]\n          distance = pow(pow((door[0] + door[2]) / 2 - (icon[0] + icon[2]) / 2, 2) + pow((door[1] + door[3]) / 2 - (icon[1] + icon[3]) / 2, 2), 0.5)\n          if distance < minDistance:\n            minDistance = distance\n            mainDoorIndex = doorIndex\n            pass\n          continue\n        break\n      continue\n\n    self.startCameraPos = [0.5, -0.5, self.wallHeight * 0.5]\n    self.startTarget = [0.5, 0.5, self.wallHeight * 0.5]\n    if mainDoorIndex >= 0:\n      mainDoor = self.doors[mainDoorIndex]\n      lineDim = calcLineDim((mainDoor[:2], mainDoor[2:4]))\n      fixedValue = (mainDoor[1 - lineDim] + mainDoor[3 - lineDim]) / 2\n      imageSize = [self.width / self.maxDim, self.height / self.maxDim]\n      side = int(fixedValue < imageSize[1 - lineDim] * 0.5) * 2 - 1\n      self.startCameraPos[lineDim] = (mainDoor[lineDim] + mainDoor[2 + lineDim]) / 2\n      self.startTarget[lineDim] = (mainDoor[lineDim] + mainDoor[2 + lineDim]) / 2\n      self.startCameraPos[1 - lineDim] = fixedValue - 0.5 * side\n      self.startTarget[1 - lineDim] = fixedValue + 0.5 * side\n      \n      self.startCameraPos[0] = 1 - self.startCameraPos[0]\n      self.startTarget[0] = 1 - self.startTarget[0]\n      pass\n    \n    newDoors = []\n    self.windows = []\n    for doorIndex, door in enumerate(self.doors):\n      if doorIndex == mainDoorIndex or doorIndex not in exteriorOpenings:\n        newDoors.append(door)\n      else:\n        self.windows.append(door)\n        pass\n      continue\n    self.doors = newDoors\n\n\n    exteriorWallLoops = []\n    visitedMask = {}\n    gap = 5.0 / self.maxDim\n    for wallIndex, wall in enumerate(exteriorWalls):\n      if wallIndex in visitedMask:\n        continue\n      visitedMask[wallIndex] = True\n      exteriorWallLoop = []\n      exteriorWallLoop.append(wall)\n      for loopWall in exteriorWallLoop:\n        for neighborWallIndex, neighborWall in enumerate(exteriorWalls):\n          if neighborWallIndex in visitedMask:\n            continue\n          #if calcDistance(neighborWall[:2], loopWall[:2]) < gap or calcDistance(neighborWall[2:4], loopWall[:2]) < gap or calcDistance(neighborWall[:2], loopWall[2:4]) < gap or calcDistance(neighborWall[2:4], loopWall[2:4]) < gap:\n          if calcDistance(neighborWall[:2], loopWall[2:4]) < gap:\n            exteriorWallLoop.append(neighborWall)\n            visitedMask[neighborWallIndex] = True\n            break\n          elif calcDistance(neighborWall[2:4], loopWall[2:4]) < gap:\n            neighborWall[0], neighborWall[2] = neighborWall[2], neighborWall[0]\n            neighborWall[1], neighborWall[3] = neighborWall[3], neighborWall[1]\n            exteriorWallLoop.append(neighborWall)\n            visitedMask[neighborWallIndex] = True\n            break\n          continue\n        continue\n      exteriorWallLoops.append(exteriorWallLoop)\n      continue\n\n\n    for exteriorWallLoop in exteriorWallLoops:\n      poly = EggPolygon()\n      floorGroup.addChild(poly)\n      \n      poly.setTexture(self.floorMat.getEggTexture())\n      poly.setMaterial(self.floorMat.getEggMaterial())\n\n      for wallIndex, wall in enumerate(exteriorWallLoop):\n        if wallIndex == 0:\n          v = EggVertex()\n          v.setPos(Point3D(1 - wall[0], wall[1], 0))\n          v.setUv(Point2D(wall[0] * self.maxDim / self.width, 1 - wall[1] * self.maxDim / self.height))\n          poly.addVertex(vp.addVertex(v))\n        else:\n          v = EggVertex()\n          v.setPos(Point3D(1 - (wall[0] + exteriorWallLoop[wallIndex - 1][2]) / 2, (wall[1] + exteriorWallLoop[wallIndex - 1][3]) / 2, 0))\n          v.setUv(Point2D((wall[0] + exteriorWallLoop[wallIndex - 1][2]) / 2 * self.maxDim / self.width, 1 - (wall[1] + exteriorWallLoop[wallIndex - 1][3]) / 2 * self.maxDim / self.height))\n          poly.addVertex(vp.addVertex(v))\n          pass\n        if wallIndex == len(exteriorWallLoop) - 1:\n          v = EggVertex()\n          v.setPos(Point3D(1 - wall[2], wall[3], 0))\n          v.setUv(Point2D(wall[2] * self.maxDim / self.width, 1 - wall[3] * self.maxDim / self.height))\n          poly.addVertex(vp.addVertex(v))\n          pass\n        continue\n      continue\n\n\n    ceilingGroup = EggGroup(\'ceiling\')\n    data.addChild(ceilingGroup)\n    \n    vp = EggVertexPool(\'ceiling_vertex\')\n    ceilingGroup.addChild(vp)\n\n    for exteriorWallLoop in exteriorWallLoops:\n      poly = EggPolygon()\n      ceilingGroup.addChild(poly)\n      \n      poly.setTexture(self.ceilingMat.getEggTexture())\n      poly.setMaterial(self.ceilingMat.getEggMaterial())\n\n      for wallIndex, wall in enumerate(exteriorWallLoop):\n        if wallIndex == 0:\n          v = EggVertex()\n          v.setPos(Point3D(1 - wall[0], wall[1], self.wallHeight))\n          v.setUv(Point2D(wall[0], 1 - wall[1]))\n          poly.addVertex(vp.addVertex(v))\n        else:\n          v = EggVertex()\n          v.setPos(Point3D(1 - (wall[0] + exteriorWallLoop[wallIndex - 1][2]) / 2, (wall[1] + exteriorWallLoop[wallIndex - 1][3]) / 2, self.wallHeight))\n          v.setUv(Point2D((wall[0] + exteriorWallLoop[wallIndex - 1][2]) / 2, 1 - (wall[1] + exteriorWallLoop[wallIndex - 1][3]) / 2))\n          poly.addVertex(vp.addVertex(v))\n          pass\n        if wallIndex == len(exteriorWallLoop) - 1:\n          v = EggVertex()\n          v.setPos(Point3D(1 - wall[2], wall[3], self.wallHeight))\n          v.setUv(Point2D(wall[2], 1 - wall[3]))\n          poly.addVertex(vp.addVertex(v))\n          pass\n        continue\n      continue\n\n    return\n\n\n  def generateWalls(self, data):\n\n    wallsGroup = EggGroup(\'walls\')\n    data.addChild(wallsGroup)\n    \n    vp = EggVertexPool(\'wall_vertex\')\n    data.addChild(vp)\n\n    for wallIndex, wall in enumerate(self.walls):\n      wallGroup = EggGroup(\'wall\')\n      wallsGroup.addChild(wallGroup)\n      lineDim = calcLineDim((wall[:2], wall[2:4]))\n      # if lineDim == 0:\n      #   if wall[lineDim] < wall[2 + lineDim]:\n      #     deltas = (-self.wallWidth, self.wallWidth, self.wallWidth, self.wallWidth)\n      #   else:\n      #     deltas = (self.wallWidth, self.wallWidth, -self.wallWidth, self.wallWidth)\n      #     pass\n      # else:\n      #   if wall[lineDim] < wall[2 + lineDim]:\n      #     deltas = (self.wallWidth, -self.wallWidth, self.wallWidth, self.wallWidth)\n      #   else:\n      #     deltas = (self.wallWidth, self.wallWidth, self.wallWidth, -self.wallWidth)\n      #     pass\n      #   pass\n\n      #print(self.wallsInt[wallIndex])\n      #print(wall)\n      if lineDim == 0:\n        deltas = (0, self.wallWidth)\n      else:\n        deltas = (self.wallWidth, 0)\n        pass\n\n      poly = EggPolygon()\n      wallGroup.addChild(poly)\n\n      if lineDim == 0:\n        poly.setTexture(self.wallMats[wall[4]].getEggTexture())\n        poly.setMaterial(self.wallMats[wall[4]].getEggMaterial())\n      else:\n        poly.setTexture(self.wallMats[wall[5]].getEggTexture())\n        poly.setMaterial(self.wallMats[wall[5]].getEggMaterial())\n        pass\n\n\n      values = [wall[lineDim] - self.wallWidth + 0.0001, wall[2 + lineDim] + self.wallWidth - 0.0001]\n      for door in self.doors:\n        if calcLineDim((door[:2], door[2:4])) != lineDim:\n          continue\n        if door[lineDim] >= wall[lineDim] and door[2 + lineDim] <= wall[2 + lineDim] and abs(door[1 - lineDim] - wall[1 - lineDim]) <= self.wallWidth:\n          values.append(door[lineDim])\n          values.append(door[2 + lineDim])\n          #doors.append(door)\n          pass\n        continue\n\n      values.sort()\n\n      fixedValue = (wall[1 - lineDim] + wall[3 - lineDim]) / 2\n      for valueIndex, value in enumerate(values):\n        if valueIndex % 2 == 0 and valueIndex > 0:\n          v = EggVertex()\n          if lineDim == 0:\n            v.setPos(Point3D(1 - (value - deltas[0]), fixedValue - deltas[1], self.doorHeight))\n          else:\n            v.setPos(Point3D(1 - (fixedValue - deltas[0]), value - deltas[1], self.doorHeight))\n            pass\n          v.setUv(Point2D(self.doorHeight / self.wallHeight, (value - wall[lineDim]) / (wall[2 + lineDim] - wall[lineDim])))\n          poly.addVertex(vp.addVertex(v))\n          pass\n\n        v = EggVertex()\n        if lineDim == 0:\n          v.setPos(Point3D(1 - (value - deltas[0]), fixedValue - deltas[1], 0))\n        else:\n          v.setPos(Point3D(1 - (fixedValue - deltas[0]), value - deltas[1], 0))\n          pass\n        v.setUv(Point2D(0, (value - wall[lineDim]) / (wall[2 + lineDim] - wall[lineDim])))\n        poly.addVertex(vp.addVertex(v))\n        \n        if valueIndex % 2 == 1 and valueIndex + 1 < len(values):\n          v = EggVertex()\n          if lineDim == 0:\n            v.setPos(Point3D(1 - (value - deltas[0]), fixedValue - deltas[1], self.doorHeight))\n          else:\n            v.setPos(Point3D(1 - (fixedValue - deltas[0]), value - deltas[1], self.doorHeight))\n            pass\n          v.setUv(Point2D(self.doorHeight / self.wallHeight, (value - wall[lineDim]) / (wall[2 + lineDim] - wall[lineDim])))\n          poly.addVertex(vp.addVertex(v))\n          pass\n        continue\n      # v = EggVertex()\n      # v.setPos(Point3D(wall[0] - deltas[0], wall[1] - deltas[1], 0))\n      # v.setUv(Point2D(0, 0))\n      # poly.addVertex(vp.addVertex(v))\n\n      # v = EggVertex()\n      # v.setPos(Point3D(wall[2] - deltas[0], wall[3] - deltas[1], 0))\n      # v.setUv(Point2D(0, 1))\n      # poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      if lineDim == 0:\n        v.setPos(Point3D(1 - (values[len(values) - 1] - deltas[0]), fixedValue - deltas[1], self.wallHeight))\n      else:\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[len(values) - 1] - deltas[1], self.wallHeight))\n        pass\n      v.setUv(Point2D(1, 1))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      if lineDim == 0:\n        v.setPos(Point3D(1 - (values[0] - deltas[0]), fixedValue - deltas[1], self.wallHeight))\n      else:\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[0] - deltas[1], self.wallHeight))\n        pass\n      v.setUv(Point2D(1, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      # for v in poly.getVertices():\n      #   print(v)\n      #   continue\n\n      poly = EggPolygon()\n      wallGroup.addChild(poly)\n      if lineDim == 0:\n        poly.setTexture(self.wallMats[wall[5]].getEggTexture())\n        poly.setMaterial(self.wallMats[wall[5]].getEggMaterial())\n      else:\n        poly.setTexture(self.wallMats[wall[4]].getEggTexture())\n        poly.setMaterial(self.wallMats[wall[4]].getEggMaterial())\n        pass\n\n      #deltas = (0.1, 0.1)\n\n      for valueIndex, value in enumerate(values):\n        if valueIndex % 2 == 0 and valueIndex > 0:\n          v = EggVertex()\n          if lineDim == 0:\n            v.setPos(Point3D(1 - (value + deltas[0]), fixedValue + deltas[1], self.doorHeight))\n          else:\n            v.setPos(Point3D(1 - (fixedValue + deltas[0]), value + deltas[1], self.doorHeight))\n            pass\n          v.setUv(Point2D(self.doorHeight / self.wallHeight, (value - wall[lineDim]) / (wall[2 + lineDim] - wall[lineDim])))\n          poly.addVertex(vp.addVertex(v))\n          pass\n\n        v = EggVertex()\n        if lineDim == 0:\n          v.setPos(Point3D(1 - (value + deltas[0]), fixedValue + deltas[1], 0))\n        else:\n          v.setPos(Point3D(1 - (fixedValue + deltas[0]), value + deltas[1], 0))\n          pass\n        v.setUv(Point2D(0, (value - wall[lineDim]) / (wall[2 + lineDim] - wall[lineDim])))\n        poly.addVertex(vp.addVertex(v))\n        \n        if valueIndex % 2 == 1 and valueIndex + 1 < len(values):\n          v = EggVertex()\n          if lineDim == 0:\n            v.setPos(Point3D(1 - (value + deltas[0]), fixedValue + deltas[1], self.doorHeight))\n          else:\n            v.setPos(Point3D(1 - (fixedValue + deltas[0]), value + deltas[1], self.doorHeight))\n            pass\n          v.setUv(Point2D(self.doorHeight / self.wallHeight, (value - wall[lineDim]) / (wall[2 + lineDim] - wall[lineDim])))\n          poly.addVertex(vp.addVertex(v))\n          pass\n        continue\n      # v = EggVertex()\n      # v.setPos(Point3D(wall[0] + deltas[0], wall[1] + deltas[1], 0))\n      # v.setUv(Point2D(0, 0))\n      # poly.addVertex(vp.addVertex(v))\n\n      # v = EggVertex()\n      # v.setPos(Point3D(wall[2] + deltas[0], wall[3] + deltas[1], 0))\n      # v.setUv(Point2D(0, 1))\n      # poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      if lineDim == 0:\n        v.setPos(Point3D(1 - (values[len(values) - 1] + deltas[0]), fixedValue + deltas[1], self.wallHeight))\n      else:\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[len(values) - 1] + deltas[1], self.wallHeight))\n        pass\n      v.setUv(Point2D(1, 1))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      if lineDim == 0:\n        v.setPos(Point3D(1 - (values[0] + deltas[0]), fixedValue + deltas[1], self.wallHeight))\n      else:\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[0] + deltas[1], self.wallHeight))\n        pass\n      v.setUv(Point2D(1, 0))\n      poly.addVertex(vp.addVertex(v))\n\n\n\n\n      if lineDim == 0:\n        poly = EggPolygon()\n        wallGroup.addChild(poly)\n        poly.setTexture(self.wallMats[10].getEggTexture())\n        poly.setMaterial(self.wallMats[10].getEggMaterial())\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[0], fixedValue - deltas[1], 0))\n        v.setUv(Point2D(0, 0))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[0], fixedValue - deltas[1], self.wallHeight))\n        v.setUv(Point2D(0, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[0], fixedValue + deltas[1], self.wallHeight))\n        v.setUv(Point2D(1, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[0], fixedValue + deltas[1], 0))\n        v.setUv(Point2D(1, 0))\n        poly.addVertex(vp.addVertex(v))\n\n\n        poly = EggPolygon()\n        wallGroup.addChild(poly)\n        poly.setTexture(self.wallMats[10].getEggTexture())\n        poly.setMaterial(self.wallMats[10].getEggMaterial())\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[0], fixedValue - deltas[1], self.wallHeight))\n        v.setUv(Point2D(0, 0))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[len(values) - 1], fixedValue - deltas[1], self.wallHeight))\n        v.setUv(Point2D(0, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[len(values) - 1], fixedValue + deltas[1], self.wallHeight))\n        v.setUv(Point2D(1, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[0], fixedValue + deltas[1], self.wallHeight))\n        v.setUv(Point2D(1, 0))\n        poly.addVertex(vp.addVertex(v))\n\n\n        poly = EggPolygon()\n        wallGroup.addChild(poly)\n        poly.setTexture(self.wallMats[10].getEggTexture())\n        poly.setMaterial(self.wallMats[10].getEggMaterial())\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[len(values) - 1], fixedValue - deltas[1], self.wallHeight))\n        v.setUv(Point2D(0, 0))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[len(values) - 1], fixedValue - deltas[1], 0))\n        v.setUv(Point2D(0, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[len(values) - 1], fixedValue + deltas[1], 0))\n        v.setUv(Point2D(1, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - values[len(values) - 1], fixedValue + deltas[1], self.wallHeight))\n        v.setUv(Point2D(1, 0))\n        poly.addVertex(vp.addVertex(v))\n        \n      else:\n        poly = EggPolygon()\n        wallGroup.addChild(poly)\n        poly.setTexture(self.wallMats[10].getEggTexture())\n        poly.setMaterial(self.wallMats[10].getEggMaterial())\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[0], 0))\n        v.setUv(Point2D(0, 0))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[0], self.wallHeight))\n        v.setUv(Point2D(0, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[0], self.wallHeight))\n        v.setUv(Point2D(1, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[0], 0))\n        v.setUv(Point2D(1, 0))\n        poly.addVertex(vp.addVertex(v))\n\n\n        poly = EggPolygon()\n        wallGroup.addChild(poly)\n        poly.setTexture(self.wallMats[10].getEggTexture())\n        poly.setMaterial(self.wallMats[10].getEggMaterial())\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[0], self.wallHeight))\n        v.setUv(Point2D(0, 0))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[len(values) - 1], self.wallHeight))\n        v.setUv(Point2D(0, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[len(values) - 1], self.wallHeight))\n        v.setUv(Point2D(1, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[0], self.wallHeight))\n        v.setUv(Point2D(1, 0))\n        poly.addVertex(vp.addVertex(v))\n\n\n        poly = EggPolygon()\n        wallGroup.addChild(poly)\n        poly.setTexture(self.wallMats[10].getEggTexture())\n        poly.setMaterial(self.wallMats[10].getEggMaterial())\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[len(values) - 1], self.wallHeight))\n        v.setUv(Point2D(0, 0))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue - deltas[0]), values[len(values) - 1], 0))\n        v.setUv(Point2D(0, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[len(values) - 1], 0))\n        v.setUv(Point2D(1, 1))\n        poly.addVertex(vp.addVertex(v))\n\n        v = EggVertex()\n        v.setPos(Point3D(1 - (fixedValue + deltas[0]), values[len(values) - 1], self.wallHeight))\n        v.setUv(Point2D(1, 0))\n        poly.addVertex(vp.addVertex(v))\n\n      continue\n    return\n\n\n  def generateDoors(self, data):\n    doorsGroup = EggGroup(\'doors\')\n    data.addChild(doorsGroup)\n    \n    vp = EggVertexPool(\'door_vertex\')\n    doorsGroup.addChild(vp)\n\n    for doorIndex, door in enumerate(self.doors):\n      doorGroup = EggGroup(\'door_\' + str(doorIndex))\n      doorsGroup.addChild(doorGroup)\n      \n      lineDim = calcLineDim((door[:2], door[2:4]))\n      \n      if lineDim == 0:\n        deltas = (0, self.doorWidth)\n      else:\n        deltas = (self.doorWidth, 0)\n        pass\n\n      poly = EggPolygon()\n      doorGroup.addChild(poly)\n      poly.setTexture(self.doorMat.getEggTexture())\n      poly.setMaterial(self.doorMat.getEggMaterial())\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[0] - deltas[0]), door[1] - deltas[1], 0))\n      v.setUv(Point2D(0, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[2] - deltas[0]), door[3] - deltas[1], 0))\n      v.setUv(Point2D(1, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[2] - deltas[0]), door[3] - deltas[1], self.doorHeight))\n      v.setUv(Point2D(1, 1))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[0] - deltas[0]), door[1] - deltas[1], self.doorHeight))\n      v.setUv(Point2D(0, 1))\n      poly.addVertex(vp.addVertex(v))\n\n\n      poly = EggPolygon()\n      doorGroup.addChild(poly)\n      poly.setTexture(self.doorMat.getEggTexture())\n      poly.setMaterial(self.doorMat.getEggMaterial())\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[0] + deltas[0]), door[1] + deltas[1], 0))\n      v.setUv(Point2D(0, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[2] + deltas[0]), door[3] + deltas[1], 0))\n      v.setUv(Point2D(1, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[2] + deltas[0]), door[3] + deltas[1], self.doorHeight))\n      v.setUv(Point2D(1, 1))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (door[0] + deltas[0]), door[1] + deltas[1], self.doorHeight))\n      v.setUv(Point2D(0, 1))\n      poly.addVertex(vp.addVertex(v))\n      \n      continue\n    return\n\n\n  def generateWindows(self, data):\n    windowsGroup = EggGroup(\'windows\')\n    data.addChild(windowsGroup)\n    \n    vp = EggVertexPool(\'window_vertex\')\n    windowsGroup.addChild(vp)\n\n    for windowIndex, window in enumerate(self.windows):\n      windowGroup = EggGroup(\'window_\' + str(windowIndex))\n      windowsGroup.addChild(windowGroup)\n      \n      lineDim = calcLineDim((window[:2], window[2:4]))\n      \n      if lineDim == 0:\n        deltas = (0, self.windowWidth)\n      else:\n        deltas = (self.windowWidth, 0)\n        pass\n\n      poly = EggPolygon()\n      windowGroup.addChild(poly)\n      poly.setTexture(self.windowMat.getEggTexture())\n      poly.setMaterial(self.windowMat.getEggMaterial())\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[0] - deltas[0]), window[1] - deltas[1], self.windowOffset))\n      v.setUv(Point2D(0, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[2] - deltas[0]), window[3] - deltas[1], self.windowOffset))\n      v.setUv(Point2D(1, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[2] - deltas[0]), window[3] - deltas[1], self.windowOffset + self.windowHeight))\n      v.setUv(Point2D(1, 1))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[0] - deltas[0]), window[1] - deltas[1], self.windowOffset + self.windowHeight))\n      v.setUv(Point2D(0, 1))\n      poly.addVertex(vp.addVertex(v))\n\n\n      poly = EggPolygon()\n      windowGroup.addChild(poly)\n      poly.setTexture(self.windowMat.getEggTexture())\n      poly.setMaterial(self.windowMat.getEggMaterial())\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[0] + deltas[0]), window[1] + deltas[1], self.windowOffset))\n      v.setUv(Point2D(0, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[2] + deltas[0]), window[3] + deltas[1], self.windowOffset))\n      v.setUv(Point2D(1, 0))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[2] + deltas[0]), window[3] + deltas[1], self.windowOffset + self.windowHeight))\n      v.setUv(Point2D(1, 1))\n      poly.addVertex(vp.addVertex(v))\n\n      v = EggVertex()\n      v.setPos(Point3D(1 - (window[0] + deltas[0]), window[1] + deltas[1], self.windowOffset + self.windowHeight))\n      v.setUv(Point2D(0, 1))\n      poly.addVertex(vp.addVertex(v))\n      \n      continue\n    return\n\n\n  def generateIcons(self, scene):\n    for icon in self.icons:\n      if icon[4] not in self.iconNodes:\n        continue\n      #self.iconNodes[icon[4]].reparentTo(scene)\n      node = deepcopy(self.iconNodes[icon[4]])\n      node.setHpr(0, -90, 0)\n      mins, maxs = node.getTightBounds()\n      dimensions = Point3(maxs - mins)\n      \n      minDistances = [self.maxDim, self.maxDim, self.maxDim, self.maxDim]\n      for wall in self.walls:\n        lineDim = calcLineDim(((wall[0], wall[1]), (wall[2], wall[3])))\n        if lineDim == -1:\n          continue\n        if ((icon[lineDim] + icon[2 + lineDim]) / 2 - wall[lineDim]) * ((icon[lineDim] + icon[2 + lineDim]) / 2 - wall[2 + lineDim]) > 0:\n          continue\n        side = int(wall[1 - lineDim] > (icon[1 - lineDim] + icon[3 - lineDim]) / 2)\n        index = lineDim * 2 + side\n        distance = abs(wall[1 - lineDim] - icon[1 - lineDim + side * 2])\n        if distance < minDistances[index]:\n          minDistances[index] = distance\n          pass\n        continue\n\n\n      orientation = 0\n      if icon[4] in [\'cooking_counter\']:\n        if icon[2] - icon[0] > icon[3] - icon[1]:\n          if minDistances[0] < minDistances[1]:\n            orientation = 0\n          else:\n            orientation = 1\n        else:\n          if minDistances[2] < minDistances[3]:\n            orientation = 2\n          else:\n            orientation = 3\n            pass\n          pass\n      elif icon[4] in [\'toilet\']:\n        if icon[2] - icon[0] < icon[3] - icon[1]:\n          if minDistances[0] < minDistances[1]:\n            orientation = 0\n          else:\n            orientation = 1\n        else:\n          if minDistances[2] < minDistances[3]:\n            orientation = 2\n          else:\n            orientation = 3\n            pass\n          pass          \n      elif icon[4] in [\'washing_basin\']:\n        orientation = np.argmin(minDistances)\n        pass\n\n \n      if orientation == 1:\n        node.setH(180)\n      elif orientation == 2:\n        node.setH(90)\n      elif orientation == 3:\n        node.setH(270)\n        pass\n      if icon[4] == \'washing_basin\':\n        node.setH(90 + node.getH())\n      mins, maxs = node.getTightBounds()\n      dimensions = Point3(maxs - mins)\n\n      # if ((maxs.getX() - mins.getX()) - (maxs.getY() - mins.getY())) * ((icon[2] - icon[0]) - (icon[3] - icon[1])) > 0:\n      #   scaleX = (icon[2] - icon[0]) / dimensions.getX()\n      #   scaleZ = (icon[3] - icon[1]) / dimensions.getZ()\n      #   scaleY = max(scaleX, scaleZ)\n      #   node.setScale(scaleX, scaleY, scaleZ)\n      #   node.setHpr(0, -90, 0)\n      #   node.setPos(icon[0] - mins.getX() * scaleX, icon[1] - mins.getZ() * scaleZ, maxs.getY() * scaleY)\n      #   orientation\n      # else:\n      #   scaleX = (icon[3] - icon[1]) / dimensions.getX()\n      #   scaleZ = (icon[2] - icon[0]) / dimensions.getZ()\n      #   scaleY = max(scaleX, scaleZ)\n      #   node.setScale(scaleX, scaleY, scaleZ)\n      #   node.setHpr(90, -90, 0)\n      #   node.setPos(icon[0] + maxs.getZ() * scaleZ, icon[1] - mins.getX() * scaleX, maxs.getY() * scaleY)\n      #   #pivotNode = scene.attachNewNode(""pivot"")\n      #   #pivotNode.setPos(icon[0] - mins.getX() * scaleX, icon[1] - mins.getZ() * scaleZ, maxs.getY() * scaleY)\n      #   #node.wrtReparentTo(pivotNode)\n      #   #pivotNode.setHpr(90, 0, 0)\n      #   pass\n\n\n      scaleX = (icon[2] - icon[0]) / dimensions.getX()\n      scaleY = (icon[3] - icon[1]) / dimensions.getY()\n      scaleZ = max(scaleX, scaleY)\n      node.setScale(scaleX, scaleY, scaleZ)\n      node.setPos(1 - icon[0] - maxs.getX() * scaleX, icon[1] - mins.getY() * scaleY, -mins.getZ() * scaleZ)\n      \n      node.setTwoSided(True)\n      node.reparentTo(scene)\n      #data.addChild(node.node())\n      #node.setPos(icon[0], icon[1], 0)\n      #node.reparentTo(data)\n      continue\n    return\n    \n  def generateEggModel(self):\n    data = EggData()\n    model = EggGroup(\'model\')\n    data.addChild(model)\n    self.generateFloor(model)\n    self.generateWalls(model)\n    self.generateDoors(model)\n    self.generateWindows(model)\n    data.writeEgg(Filename(""test/floorplan.egg""))\n    scene = NodePath(loadEggData(data))\n    self.generateIcons(scene)\n    return scene\n    \n    poly = EggPolygon()\n    data.addChild(poly)\n\n\n    v = EggVertex()\n    v.setPos(Point3D(0, 0, 0))\n    v.setUv(Point2D(0, 0))\n    poly.addVertex(vp.addVertex(v))    \n    \n    v = EggVertex()\n    v.setPos(Point3D(1, 0, 0))\n    v.setUv(Point2D(1, 0))\n    poly.addVertex(vp.addVertex(v))\n\n    v = EggVertex()\n    v.setPos(Point3D(1, 0, 1))\n    v.setUv(Point2D(1, 1))\n    poly.addVertex(vp.addVertex(v))\n\n    v = EggVertex()\n    v.setPos(Point3D(0, 0, 1))\n    v.setUv(Point2D(0, 1))\n    poly.addVertex(vp.addVertex(v))\n\n    # To write the egg file to disk, use this:\n    data.writeEgg(Filename(""floorplan.egg""))\n    \n    # To load the egg file and render it immediately, use this:\n    node = loadEggData(data)\n    scene = NodePath(node)\n    return scene\n\n  def segmentRooms(self):\n    wallMask = np.ones((self.height, self.width), np.uint8) * 255\n    for wall in self.wallsInt:\n      lineDim = calcLineDim(((wall[0], wall[1]), (wall[2], wall[3])))\n      if lineDim == 0:\n        wallMask[wall[1], wall[0]:wall[2] + 1] = 0\n      else:\n        wallMask[wall[1]:wall[3] + 1, wall[0]] = 0\n        pass\n      continue\n    cv2.imwrite(\'test/walls.png\', wallMask)\n    \n    numLabels, labels, stats, centroids = cv2.connectedComponentsWithStats(wallMask, 4)\n    print(numLabels.shape)\n    print(labels.shape)\n    print(stats.shape)\n    print(centroids.shape)    \n    cv2.imwrite(\'test/rooms.png\', labels)\n'"
rendering/obj2egg.py,0,"b'#!/usr/bin/python\n""""""\n    This Version: $Id: obj2egg.py,v 1.7 2008/05/26 17:42:53 andyp Exp $\n    Info: info >at< pfastergames.com\n\n    Extended from: http://panda3d.org/phpbb2/viewtopic.php?t=3378\n    .___..__ .___.___.___.__..__ .  .\n      |  [__)[__ [__ [__ |  |[__)|\\/|\n      |  |  \\[___[___|   |__||  \\|  |\n    obj2egg.py [n##][b][t][s] filename1.obj ...\n        -n regenerate normals with # degree smoothing\n            exaple -n30  (normals at less 30 degrees will be smoothed)\n        -b make binarmals\n        -t make tangents\n        -s show in pview\n\n    licensed under WTFPL (http://sam.zoy.org/wtfpl/)\n""""""\n\nfrom pandac.PandaModules import *\nimport math\nimport string\nimport getopt\nimport sys, os\n\n\ndef floats(float_list):\n    """"""coerce a list of strings that represent floats into a list of floats""""""\n    return [ float(number) for number in float_list ]\n\ndef ints(int_list):\n    """"""coerce a list of strings that represent integers into a list of integers""""""\n    return [ int(number) for number in int_list ]\n\n\nclass ObjMaterial:\n    """"""a wavefront material""""""\n    def __init__(self):\n        self.filename = None\n        self.name = ""default""\n        self.eggdiffusetexture = None\n        self.eggmaterial = None\n        self.attrib = {}\n        self.attrib[""Ns""] = 100.0\n        self.attrib[""d""] = 1.0\n        self.attrib[""illum""] = 2\n        # ""magenta""\n        self.attrib[""Kd""] = [1.0, 1.0, 1.0]\n        self.attrib[""Ka""] = [0.0, 0.0, 0.0]\n        self.attrib[""Ks""] = [0.0, 0.0, 0.0]\n        self.attrib[""Ke""] = [0.0, 0.0, 0.0]\n\n    def put(self, key, value):\n        self.attrib[key] = value\n        return self\n\n    def get(self, key):\n        if self.attrib.has_key(key):\n            return self.attrib[key]\n        return None\n\n    def has_key(self, key):\n        return self.attrib.has_key(key)\n\n    def isTextured(self):\n        # for k in (""map_Kd"", ""map_Bump"", ""map_Ks""):    <-- NOT YET\n        if self.attrib.has_key(""map_Kd""):\n            return True;\n        return False;\n\n    def getEggTexture(self):\n        if self.eggdiffusetexture:\n            return self.eggdiffusetexture\n        if not self.isTextured():\n            return None\n        m = EggTexture(self.name + ""_diffuse"", self.get(""map_Kd""))\n        m.setFormat(EggTexture.FRgb)\n        m.setMagfilter(EggTexture.FTLinearMipmapLinear)\n        m.setMinfilter(EggTexture.FTLinearMipmapLinear)\n        m.setWrapU(EggTexture.WMRepeat)\n        m.setWrapV(EggTexture.WMRepeat)\n        self.eggdiffusetexture = m\n        return self.eggdiffusetexture\n\n    def getEggMaterial(self):\n        if self.eggmaterial:\n            return self.eggmaterial\n        m = EggMaterial(self.name + ""_mat"")\n        # XXX TODO: add support for specular, and obey illum setting\n        # XXX as best as we can\n        rgb = self.get(""Kd"")\n        if rgb is not None:\n            m.setDiff(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n        rgb = self.get(""Ka"")\n        if rgb is not None:\n            m.setAmb(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n        rgb = self.get(""Ks"")\n        if rgb is not None:\n            m.setSpec(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n        ns = self.get(""Ns"")\n        if ns is not None:\n            m.setShininess(ns)\n        self.eggmaterial = m\n        return self.eggmaterial\n\nclass MtlFile:\n    """"""an object representing all Wavefront materials in a .mtl file""""""\n    def __init__(self, filename=None):\n        self.filename = None\n        self.materials = {}\n        self.comments = {}\n        if filename is not None:\n            self.read(filename)\n\n    def read(self, filename, verbose=False):\n        self.filename = filename\n        self.materials = {}\n        self.comments = {}\n        try:\n            file = open(filename)\n        except:\n            return self\n        linenumber = 0\n        mat = None\n        for line in file.readlines():\n            line = line.strip()\n            linenumber = linenumber + 1\n            if not line:\n                continue\n            if line[0] == \'#\':\n                self.comments[linenumber] = line\n                print line\n                continue\n            tokens = line.split()\n            if not tokens:\n                continue\n            if verbose: print ""tokens[0]:"", tokens\n            if tokens[0] == ""newmtl"":\n                mat = ObjMaterial()\n                mat.filename = filename\n                mat.name = tokens[1]\n                self.materials[mat.name] = mat\n                if verbose: print ""newmtl:"", mat.name\n                continue\n            if tokens[0] in (""Ns"", ""d"", ""Tr""):\n                # ""d factor"" - specifies the dissovle for the current material,\n                #              1.0 is full opaque\n                # ""Ns exponent"" - specifies the specular exponent.  A high exponent\n                #               results in a tight, concentrated highlight.\n                mat.put(tokens[0], float(tokens[1]))\n                continue\n            if tokens[0] in (""illum""):\n                # according to http://www.fileformat.info/format/material/\n                # 0 = Color on and Ambient off\n                # 1 = Color on and Ambient on\n                # 2 = Highlight on\n                # 3 = Reflection on and Ray trace on\n                # 4 = Transparency: Glass on, Reflection: Ray trace on\n                # 5 = Reflection: Fesnel on and Ray trace on\n                # 6 = Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                # 7 = Transparency: Refraction on, Refelction: Fresnel on and Ray Trace on\n                # 8 = Reflection on and Ray trace off\n                # 9 = Transparency: Glass on, Reflection: Ray trace off\n                # 10 = Casts shadows onto invisible surfaces\n                mat.put(tokens[0], int(tokens[1]))\n                continue\n            if tokens[0] in (""Kd"", ""Ka"", ""Ks"", ""Ke""):\n                mat.put(tokens[0], floats(tokens[1:]))\n                continue\n            if tokens[0] in (""map_Kd"", ""map_Bump"", ""map_Ks"", ""map_bump"", ""bump""):\n                # Ultimate Unwrap 3D Pro emits these:\n                # map_Kd == diffuse\n                # map_Bump == bump\n                # map_Ks == specular\n                mat.put(tokens[0], pathify(tokens[1]))\n                if verbose: print ""map:"", mat.name, tokens[0], mat.get(tokens[0])\n                continue\n            if tokens[0] in (""Ni""):\n                # blender\'s .obj exporter can emit this ""Ni 1.000000""\n                mat.put(tokens[0], float(tokens[1]))\n                continue\n            print ""file \\""%s\\"": line %d: unrecognized:"" % (filename, linenumber), tokens\n        file.close()\n        if verbose: print ""%d materials"" % len(self.materials), ""loaded from"", filename\n        return self\n\nclass ObjFile:\n    """"""a representation of a wavefront .obj file""""""\n    def __init__(self, filename=None):\n        self.filename = None\n        self.objects = [""defaultobject""]\n        self.groups = [""defaultgroup""]\n        self.points = []\n        self.uvs = []\n        self.normals = []\n        self.faces = []\n        self.polylines = []\n        self.matlibs = []\n        self.materialsbyname = {}\n        self.comments = {}\n        self.currentobject = self.objects[0]\n        self.currentgroup = self.groups[0]\n        self.currentmaterial = None\n        if filename is not None:\n            self.read(filename)\n\n    def read(self, filename, verbose=False):\n        if verbose: print ""ObjFile.read:"", ""filename:"", filename\n        self.filename = filename\n        self.objects = [""defaultobject""]\n        self.groups = [""defaultgroup""]\n        self.points = []\n        self.uvs = []\n        self.normals = []\n        self.faces = []\n        self.polylines = []\n        self.matlibs = []\n        self.materialsbyname = {}\n        self.comments = {}\n        self.currentobject = self.objects[0]\n        self.currentgroup = self.groups[0]\n        self.currentmaterial = None\n        try:\n            file = open(filename)\n        except:\n            return self\n        linenumber = 0\n        for line in file.readlines():\n            line = line.strip()\n            linenumber = linenumber + 1\n            if not line:\n                continue\n            if line[0] == \'#\':\n                self.comments[linenumber] = line\n                print line\n                continue\n            tokens = line.split()\n            if not tokens:\n                continue\n            if tokens[0] == ""mtllib"":\n                if verbose: print ""mtllib:"", tokens[1:]\n                mtllib = MtlFile(tokens[1])\n                # if verbose: print mtllib\n                self.matlibs.append(mtllib)\n                self.indexmaterials(mtllib)\n                continue\n            if tokens[0] == ""g"":\n                if verbose: print ""g:"", tokens[1:]\n                self.__newgroup("""".join(tokens[1:]))\n                continue\n            if tokens[0] == ""o"":\n                if verbose: print ""o:"", tokens[1:]\n                self.__newobject("""".join(tokens[1:]))\n                continue\n            if tokens[0] == ""usemtl"":\n                if verbose: print ""usemtl:"", tokens[1:]\n                self.__usematerial(tokens[1])\n                continue\n            if tokens[0] == ""v"":\n                if verbose: print ""v:"", tokens[1:]\n                self.__newv(tokens[1:])\n                continue\n            if tokens[0] == ""vn"":\n                if verbose: print ""vn:"", tokens[1:]\n                self.__newnormal(tokens[1:])\n                continue\n            if tokens[0] == ""vt"":\n                if verbose: print ""vt:"", tokens[1:]\n                self.__newuv(tokens[1:])\n                continue\n            if tokens[0] == ""f"":\n                if verbose: print ""f:"", tokens[1:]\n                self.__newface(tokens[1:])\n                continue\n            if tokens[0] == ""s"":\n                # apparently, this enables/disables smoothing\n                print ""%s:%d:"" % (filename, linenumber), ""ignoring:"", tokens\n                continue\n            if tokens[0] == ""l"":\n                if verbose: print ""l:"", tokens[1:]\n                self.__newpolyline(tokens[1:])\n                continue\n            print ""%s:%d:"" % (filename, linenumber), ""unknown:"", tokens\n        file.close()\n        return self\n\n    def __vertlist(self, lst):\n        res = []\n        for vert in lst:\n            vinfo = vert.split(""/"")\n            vlen = len(vinfo)\n            vertex = {\'v\':None, \'vt\':None, \'vn\':None}\n            if vlen == 1:\n                vertex[\'v\'] = int(vinfo[0])\n            elif vlen == 2:\n                if vinfo[0] != \'\':\n                    vertex[\'v\'] = int(vinfo[0])\n                if vinfo[1] != \'\':\n                    vertex[\'vt\'] = int(vinfo[1])\n            elif vlen == 3:\n                if vinfo[0] != \'\':\n                    vertex[\'v\'] = int(vinfo[0])\n                if vinfo[1] != \'\':\n                    vertex[\'vt\'] = int(vinfo[1])\n                if vinfo[2] != \'\':\n                    vertex[\'vn\'] = int(vinfo[2])\n            else:\n                print ""aborting...""\n                raise UNKNOWN, res\n            res.append(vertex)\n        if False: print res\n        return res\n\n    def __enclose(self, lst):\n        mdata = (self.currentobject, self.currentgroup, self.currentmaterial)\n        return (lst, mdata)\n\n    def __newpolyline(self, l):\n        polyline = self.__vertlist(l)\n        if False: print ""__newline:"", polyline\n        self.polylines.append(self.__enclose(polyline))\n        return self\n\n    def __newface(self, f):\n        face = self.__vertlist(f)\n        if False: print face\n        self.faces.append(self.__enclose(face))\n        return self\n\n    def __newuv(self, uv):\n        self.uvs.append(floats(uv))\n        return self\n\n    def __newnormal(self, normal):\n        self.normals.append(floats(normal))\n        return self\n\n    def __newv(self, v):\n        # capture the current metadata with vertices\n        vdata = floats(v)\n        mdata = (self.currentobject, self.currentgroup, self.currentmaterial)\n        vinfo = (vdata, mdata)\n        self.points.append(vinfo)\n        return self\n\n    def indexmaterials(self, mtllib, verbose=False):\n        # traverse the materials defined in mtllib, indexing\n        # them by name.\n        for mname in mtllib.materials:\n            mobj = mtllib.materials[mname]\n            self.materialsbyname[mobj.name] = mobj\n        if verbose: \n            print ""indexmaterials:"", mtllib.filename, ""materials:"", self.materialsbyname.keys()\n        return self\n\n    def __closeobject(self):\n        self.currentobject = ""defaultobject""\n        return self\n\n    def __newobject(self, object):\n        self.__closeobject()\n        if False: print ""__newobject:"", ""object:"", object\n        self.currentobject = object\n        self.objects.append(object)\n        return self\n\n    def __closegroup(self):\n        self.currentgroup = ""defaultgroup""\n        return self\n\n    def __newgroup(self, group):\n        self.__closegroup()\n        if False: print ""__newgroup:"", ""group:"", group\n        self.currentgroup = group\n        self.groups.append(group)\n        return self\n\n    def __usematerial(self, material):\n        if False: print ""__usematerial:"", ""material:"", material\n        if self.materialsbyname.has_key(material):\n            self.currentmaterial = material\n        else:\n            print ""warning:"", ""__usematerial:"", ""unknown material:"", material\n        return self\n\n    def __itemsby(self, itemlist, objname, groupname):\n        res = []\n        for item in itemlist:\n            vlist, mdata = item\n            wobj, wgrp, wmat = mdata\n            if (wobj == objname) and (wgrp == groupname):\n                res.append(item)\n        return res\n\n    def __facesby(self, objname, groupname):\n        return self.__itemsby(self.faces, objname, groupname)\n\n    def __linesby(self, objname, groupname):\n        return self.__itemsby(self.polylines, objname, groupname)\n\n    def __eggifyverts(self, eprim, evpool, vlist):\n        for vertex in vlist:\n            ixyz = vertex[\'v\']\n            vinfo = self.points[ixyz-1]\n            vxyz, vmeta = vinfo\n            ev = EggVertex()\n            ev.setPos(Point3D(vxyz[0], vxyz[1], vxyz[2]))\n            iuv = vertex[\'vt\']\n            if iuv is not None:\n                vuv = self.uvs[iuv-1]\n                ev.setUv(Point2D(vuv[0], vuv[1]))\n            inormal = vertex[\'vn\']\n            if inormal is not None:\n                vn = self.normals[inormal-1]\n                ev.setNormal(Vec3D(vn[0], vn[1], vn[2]))\n            evpool.addVertex(ev)\n            eprim.addVertex(ev)\n        return self\n\n    def __eggifymats(self, eprim, wmat):\n        if self.materialsbyname.has_key(wmat):\n            mtl = self.materialsbyname[wmat]\n            if mtl.isTextured():\n                eprim.setTexture(mtl.getEggTexture())\n                # NOTE: it looks like you almost always want to setMaterial()\n                #       for textured polys.... [continued below...]\n                eprim.setMaterial(mtl.getEggMaterial())\n            rgb = mtl.get(""Kd"")\n            if rgb is not None:\n                # ... and some untextured .obj\'s store the color of the\n                # material # in the Kd settings...\n                eprim.setColor(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n            # [continued...] but you may *not* always want to assign\n            # materials to untextured polys...  hmmmm.\n            if False:\n                eprim.setMaterial(mtl.getEggMaterial())\n        return self\n\n    def __facestoegg(self, egg, objname, groupname):\n        selectedfaces = self.__facesby(objname, groupname)\n        if len(selectedfaces) == 0:\n            return self\n        eobj = EggGroup(objname)\n        egg.addChild(eobj)\n        egrp = EggGroup(groupname)\n        eobj.addChild(egrp)\n        evpool = EggVertexPool(groupname)\n        egrp.addChild(evpool)\n        for face in selectedfaces:\n            vlist, mdata = face\n            wobj, wgrp, wmat = mdata\n            epoly = EggPolygon()\n            egrp.addChild(epoly)\n            self.__eggifymats(epoly, wmat)\n            self.__eggifyverts(epoly, evpool, vlist)\n        #; each matching face\n        return self\n\n    def __polylinestoegg(self, egg, objname, groupname):\n        selectedlines = self.__linesby(objname, groupname)\n        if len(selectedlines) == 0:\n            return self\n        eobj = EggGroup(objname)\n        egg.addChild(eobj)\n        egrp = EggGroup(groupname)\n        eobj.addChild(egrp)\n        evpool = EggVertexPool(groupname)\n        egrp.addChild(evpool)\n        for line in selectedlines:\n            vlist, mdata = line\n            wobj, wgrp, wmat = mdata\n            eline = EggLine()\n            egrp.addChild(eline)\n            self.__eggifymats(eline, wmat)\n            self.__eggifyverts(eline, evpool, vlist)\n        #; each matching line\n        return self\n\n    def toEgg(self, verbose=True):\n        if verbose: print ""converting...""\n        # make a new egg\n        egg = EggData()\n        # convert polygon faces\n        if len(self.faces) > 0:\n            for objname in self.objects:\n                for groupname in self.groups:\n                    self.__facestoegg(egg, objname, groupname)\n        # convert polylines\n        if len(self.polylines) > 0:\n            for objname in self.objects:\n                for groupname in self.groups:\n                    self.__polylinestoegg(egg, objname, groupname)\n        return egg\n\ndef pathify(path):\n    if os.path.isfile(path):\n        return path\n    # if it was written on win32, it may have \\\'s in it, and\n    # also a full rather than relative pathname (Hexagon does this... ick)\n    orig = path\n    path = path.lower()\n    path = path.replace(""\\\\"", ""/"")\n    h, t = os.path.split(path)\n    if os.path.isfile(t):\n        return t\n    print ""warning: can\'t make sense of this map file name:"", orig\n    return t\n    \ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv\n    try:\n        opts, args = getopt.getopt(argv[1:], ""hn:bs"", [""help"", ""normals"", ""binormals"", ""show""])\n    except getopt.error, msg:\n        print msg\n        print __doc__\n        return 2\n    show = False\n    for o, a in opts:\n        if o in (""-h"", ""--help""):\n            print __doc__\n            return 0\n        elif o in (""-s"", ""--show""):\n            show = True\n    for infile in args:\n        try:\n            if "".obj"" not in infile:\n                print ""WARNING"", finfile, ""does not look like a valid obj file""\n                continue\n            obj = ObjFile(infile)\n            egg = obj.toEgg()\n            f, e = os.path.splitext(infile)\n            outfile = f + "".egg""\n            for o, a in opts:\n                if o in (""-n"", ""--normals""):\n                    egg.recomputeVertexNormals(float(a))\n                elif o in (""-b"", ""--binormals""):\n                    egg.recomputeTangentBinormal(GlobPattern(""""))\n            egg.removeUnusedVertices(GlobPattern(""""))\n            if True:\n                egg.triangulatePolygons(EggData.TConvex & EggData.TPolygon)\n            if True:\n                egg.recomputePolygonNormals()\n            egg.writeEgg(Filename(outfile))\n            if show:\n                os.system(""pview "" + outfile)\n        except Exception,e:\n            print e\n    return 0\n\nif __name__ == ""__main__"":\n    sys.exit(main())\n\n\n'"
rendering/renderer.py,0,"b'from panda3d.core import *\nfrom direct.showbase.ShowBase import ShowBase\nimport cv2\nfrom floorplan import Floorplan\nimport numpy as np\nimport random\nimport math\n\nclass Renderer(ShowBase):\n  def __init__(self):\n    #self.scene = self.loader.loadModel(""floorplan_1.txt-floor.obj"")\n    loadPrcFileData("""", ""window-type offscreen"")\n    loadPrcFileData("""", ""win-size 128 128"")\n    ShowBase.__init__(self)\n    \n    self.scene = NodePath(""Scene"")\n    self.scene.reparentTo(self.render)\n    self.scene.setScale(1, 1, 1)\n    self.scene.setTwoSided(True)\n    self.scene.setPos(0, 0, 0)\n    self.scene.setHpr(0, 0, 0)\n    self.near_plane = 0.1\n    self.far_plane = 5.0\n    self.resolution = 128\n    self.max_16bit_val = 65535\n    self.light_sources = []\n    self.light_nodes = []\n\n    self.alight = AmbientLight(\'alight\')\n    self.alight.setColor(VBase4(0.2, 0.2, 0.2, 1))\n    self.alnp = self.render.attachNewNode(self.alight)\n    self.render.setLight(self.alnp)\n    self.attenuation = False\n    \n    base.camLens.setNear(self.near_plane)\n    base.camLens.setFar(self.far_plane)\n    \n    self.generate_depth = True\n    if self.generate_depth is True:\n      self.depth_tex = Texture()\n      self.depth_tex.setFormat(Texture.FDepthComponent)\n      self.depth_buffer = base.win.makeTextureBuffer(\'depthmap\', self.resolution, self.resolution, self.depth_tex, to_ram=True)\n      self.depth_cam = self.makeCamera(self.depth_buffer, lens = base.camLens)\n      print(self.depth_cam.node().getLens().getFilmSize())\n      self.depth_cam.reparentTo(base.render)\n      pass\n\n    self.models = []\n    self.backgrounds = []\n    self.model = None\n\n    self.createLightSources()\n    return\n  \n  def delete(self):\n    self.alnp.removeNode()\n    for n in self.light_nodes:\n      n.removeNode()\n      continue\n    for m in self.models:\n      self.loader.unloadModel(m)\n      continue\n    base.destroy()\n    return\n\n  def selectModel(self, model_ind):\n    self.model = self.models[model_ind]\n    self.model.reparentTo(self.scene)\n    \n  def unselectModel(self, model_ind):\n    self.model.detachNode()\n    self.model = None\n    \n  def loadModels(self, filenames):\n    self.models = []\n    for filename in filenames:\n      floorplan = Floorplan(filename)\n      floorplan.read()\n      floorplan.segmentRooms()\n      exit(1)\n      self.models.append(floorplan.generateEggModel())\n      continue\n    return\n\n  def createLightSources(self):\n    for i in range(0, 7):\n      plight = PointLight(\'plight\')\n      if self.attenuation is True:\n        plight.setAttenuation((1, 0, 1))\n        pass\n      plight.setColor(VBase4(0, 0, 0, 0))\n      self.light_sources.append(plight)\n      plnp = self.render.attachNewNode(plight)\n      plnp.setPos(3, 3, 3)\n      render.setLight(plnp)\n      self.light_nodes.append(plnp)\n      continue\n    return\n\n  def activateLightSources(self, light_sources, spher=True):\n    i = 0\n    for lght in light_sources:\n      lp_rad = lght[0]\n      lp_el = lght[1]\n      lp_az = lght[2]\n      lp_int = lght[3]\n      if spher:\n        self.light_nodes[i].setPos(\n          lp_rad*math.cos(lp_el)*math.cos(lp_az),\n          lp_rad*math.cos(lp_el)*math.sin(lp_az),\n          lp_rad*math.sin(lp_el))\n      else:\n        self.light_nodes[i].setPos(lp_rad, lp_el, lp_az)\n        pass\n      self.light_sources[i].setColor(VBase4(lp_int, lp_int, lp_int, 1))\n      i += 1\n      continue\n    return\n  \n  def deactivateLightSources(self):\n    for i in range(0, 7):\n      self.light_sources[i].setColor(VBase4(0, 0, 0, 0))\n      continue\n    return\n\n  def textureToImage(self, texture):\n    im = texture.getRamImageAs(""RGB"")\n    strim = im.getData()\n    image = np.fromstring(strim, dtype=\'uint8\')\n    #image = image.reshape(1200, 1200)\n    #cv2.imwrite(\'test/test.png\', image.astype(np.uint8))\n    image = image.reshape(self.resolution, self.resolution, 3)\n    image = np.flipud(image)\n    return image\n\n  def setCameraPosition(self, pos, target):\n    self.camera.setPos(pos[0], pos[1], pos[2])\n    self.camera.lookAt(target[0], target[1], target[2])\n\n    if self.generate_depth is True:\n      self.depth_cam.setPos(pos[0], pos[1], pos[2])\n      self.depth_cam.lookAt(target[0], target[1], target[2])\n      pass\n    return\n  \n  def renderView(self, camera_pos, light_sources):\n    angle = math.radians(random.randint(0, 360))\n    target = (camera_pos[0] + math.sin(angle), camera_pos[1] + math.cos(angle), camera_pos[2])\n    self.setCameraPosition(camera_pos, target)\n\n    self.activateLightSources(light_sources)\n\n    base.graphicsEngine.renderFrame()\n    tex = base.win.getScreenshot()\n    im = self.textureToImage(tex)\n    \n    dm_uint = False\n    \n    if self.generate_depth is True:\n      depth_im = PNMImage()\n      self.depth_tex.store(depth_im)\n      \n      depth_map = np.zeros([self.resolution, self.resolution], dtype=\'float\')\n      for i in range(0, self.resolution):\n        for j in range(0, self.resolution):\n          depth_val = depth_im.getGray(j, i)\n          depth_map[i, j] = self.far_plane * self.near_plane / (self.far_plane - depth_val * (self.far_plane - self.near_plane))\n          depth_map[i, j] = depth_map[i, j] / self.far_plane\n          continue\n        continue\n      dm_uint = np.round(depth_map * self.max_16bit_val).astype(\'uint16\')\n      pass\n    \n    \n    im = im.astype(dtype=np.uint8)\n    self.deactivateLightSources()\n    return im, dm_uint\n\n\nrenderer = Renderer()\nrenderer.loadModels([\'test/floorplan_2\', ])\nrenderer.selectModel(0)\n\nnum_light = random.randint(2, 4)\nlights = []\nfor nl in range(0, num_light):\n  light_pos = [random.random()*2. + 2.5,\n               random.randint(-90, 90),\n               random.randint(0, 360),\n               random.randint(10, 15)]\n  lights.append(light_pos)\n  continue\n\nfor im_num in range(0, 20):\n  x = random.random()\n  y = random.random()\n  z = 0.15\n  im, dm = renderer.renderView([x, y, z], lights)\n  cv2.imwrite(\'test/rendering_\' + str(im_num) + \'.png\', (np.asarray(im)).astype(np.uint8))\n  cv2.imwrite(\'test/depth_\' + str(im_num) + \'.png\', (np.asarray(1 / (dm / 65535.0) * 255)).astype(np.uint8))\n  continue\n\nexit(1)\n'"
rendering/viewer.py,0,"b'from math import pi, sin, cos\nfrom panda3d.core import *\nfrom direct.showbase.ShowBase import ShowBase\nfrom direct.task import Task\nfrom floorplan import Floorplan\nimport numpy as np\nimport random\nimport copy\n\nclass Viewer(ShowBase):\n  def __init__(self):\n\n    ShowBase.__init__(self)\n    #self.scene = self.loader.loadModel(""floorplan_1.txt-floor.obj"")\n    #self.scene = base.loader.loadModel(""floorplan_1.txt-floor.egg"")\n    #self.scene = base.loader.loadModel(""panda.egg"")\n\n    #self.scene = base.loader.loadModel(""environment"")\n\n    base.setBackgroundColor(0, 0, 0)\n    self.angle = 0.0\n    lens = PerspectiveLens()\n    lens.setFov(60)\n    lens.setNear(0.01)\n    lens.setFar(100000)\n    base.cam.node().setLens(lens)\n    floorplan = Floorplan(\'test/floorplan_7\')\n    #floorplan.setFilename(\'test/floorplan_2\')\n    floorplan.read()\n    self.scene = floorplan.generateEggModel()\n    self.scene.reparentTo(self.render)\n    #self.scene.setScale(0.01, 0.01, 0.01)\n    #self.scene.setTwoSided(True)\n    self.scene.setTwoSided(True)\n    #self.scene.setPos(0, 0, 3)\n    #texture = loader.loadTexture(""floorplan_1.png"")\n    #self.scene.setTexture(texture)\n    #self.scene.setHpr(0, 0, 0)\n    \n    # angleDegrees = 0\n    # angleRadians = angleDegrees * (pi / 180.0)\n    # self.camera.setPos(20 * sin(angleRadians), -20 * cos(angleRadians), 3)\n    # self.camera.setHpr(angleDegrees, 0, 0)\n    #self.camera.lookAt(0, 0, 0)\n    \n    self.alight = AmbientLight(\'alight\')\n    self.alight.setColor(VBase4(0.2, 0.2, 0.2, 1))\n    self.alnp = self.render.attachNewNode(self.alight)\n    self.render.setLight(self.alnp)\n\n    dlight = DirectionalLight(\'dlight\')\n    dlight.setColor(VBase4(1, 1, 1, 1))\n    dlnp = self.render.attachNewNode(dlight)\n    #dlnp.setHpr(0, -90, 0)\n    dlnp.setPos(0.5, 0.5, 3)\n    dlnp.lookAt(0.5, 0.5, 2)\n    self.render.setLight(dlnp)\n    \n    for i in xrange(10):\n      plight = PointLight(\'plight\')\n      plight.setAttenuation((1, 0, 1))\n      color = random.randint(10, 15)\n      plight.setColor(VBase4(color, color, color, 1))\n      plnp = self.render.attachNewNode(plight)\n      if i == 0:\n        plnp.setPos(0.5, 0.5, 3)\n      else:\n        plnp.setPos(1 * random.random(), 1 * random.random(), 0.3)\n        pass\n      self.render.setLight(plnp)\n\n\n\n    #base.useTrackball()\n    #base.trackball.node().setPos(2.0, 0, 3)\n    #base.trackball.node().setHpr(0, 0, 3)\n    #base.enableMouse()\n    #base.useDrive()\n    base.disableMouse()\n    self.taskMgr.add(self.spinCameraTask, ""SpinCameraTask"")\n    #self.accept(\'arrow_up\', self.moveForward)\n    #self.accept(\'arrow_up_-repeat\', self.moveForward)\n    self.topDownCameraPos = [0.5, 0.5, 1.5]\n    self.topDownTarget = [0.5, 0.499, 0.5]\n    self.topDownH = 0\n    self.startCameraPos = floorplan.startCameraPos\n    self.startTarget = floorplan.startTarget\n    self.startH = 0\n    \n    self.cameraPos = self.topDownCameraPos\n    self.target = self.topDownTarget\n    self.H = self.topDownH\n\n    self.accept(\'space\', self.openDoor)\n    self.accept(\'enter\', self.startChangingView)\n\n    self.viewMode = \'T\'\n    self.viewChangingProgress = 1.02\n\n    ceiling = self.scene.find(""**/ceiling"")\n    ceiling.hide()\n    \n    return\n\n  def moveForward(self):\n    self.cameraPos[0] -= 0.1\n\n  def openDoor(self):\n    minDistance = 10000\n    doors = self.scene.find(""**/doors"")\n    for door in doors.getChildren():\n      mins, maxs = door.getTightBounds()\n\n      vec_1 = (mins + maxs) / 2 - Vec3(self.target[0], self.target[1], (mins[2] + maxs[2]) / 2)\n      vec_2 = (mins + maxs) / 2 - Vec3(self.cameraPos[0], self.cameraPos[1], (mins[2] + maxs[2]) / 2)\n      if (vec_1.dot(vec_2) > 0 and vec_1.length() > vec_2.length()) or np.arccos(abs(vec_1.dot(vec_2)) / (vec_1.length() * vec_2.length())) > np.pi / 4:\n        continue\n\n      distance = pow(pow(self.cameraPos[0] - (mins[0] + maxs[0]) / 2, 2) + pow(self.cameraPos[1] - (mins[1] + maxs[1]) / 2, 2) + pow(self.cameraPos[2] - (mins[2] + maxs[2]) / 2, 2), 0.5)\n      if distance < minDistance:\n        minDistanceDoor = door\n        minDistance = distance\n        pass\n      continue\n\n    if minDistance > 1:\n      return\n    mins, maxs = minDistanceDoor.getTightBounds()\n    if abs(maxs[0] - mins[0]) > abs(maxs[1] - mins[1]):\n      minsExpected = Vec3(mins[0] - (maxs[1] - mins[1]), mins[1], mins[2])\n      maxsExpected = Vec3(mins[0], mins[1] + (maxs[0] - mins[0]), maxs[2])\n    else:\n      minsExpected = Vec3(mins[0] - (maxs[1] - mins[1]) + (maxs[0] - mins[0]), mins[1] - (maxs[0] - mins[0]), mins[2])\n      maxsExpected = Vec3(mins[0] + (maxs[0] - mins[0]), mins[1] + (maxs[0] - mins[0]) - (maxs[0] - mins[0]), maxs[2])\n      pass\n    minDistanceDoor.setH(minDistanceDoor, 90)\n    mins, maxs = minDistanceDoor.getTightBounds()\n    minDistanceDoor.setPos(minDistanceDoor, minsExpected[1] - mins[1], -minsExpected[0] + mins[0], 0)\n    #print(scene.findAllMatches(\'doors\'))\n    return\n\n  def startChangingView(self):\n    self.viewChangingProgress = 0\n    self.prevCameraPos = copy.deepcopy(self.cameraPos)\n    self.prevTarget = copy.deepcopy(self.target)\n    self.prevH = self.camera.getR()\n    if self.viewMode == \'T\':\n      self.newCameraPos = self.startCameraPos\n      self.newTarget = self.startTarget\n      self.newH = self.startH\n      self.viewMode = \'C\'\n    else:\n      self.newCameraPos = self.topDownCameraPos\n      self.newTarget = self.topDownTarget\n      self.newH = self.topDownH\n      self.startCameraPos = copy.deepcopy(self.cameraPos)\n      self.startTarget = copy.deepcopy(self.target)\n      self.startH = self.camera.getR()\n      self.viewMode = \'T\'\n      pass\n    return\n\n\n  def changeView(self):\n    self.cameraPos = []\n    self.target = []\n    for c in xrange(3):\n      self.cameraPos.append(self.prevCameraPos[c] + (self.newCameraPos[c] - self.prevCameraPos[c]) * self.viewChangingProgress)\n      self.target.append(self.prevTarget[c] + (self.newTarget[c] - self.prevTarget[c]) * self.viewChangingProgress)\n      continue\n    self.H = self.prevH + (self.newH - self.prevH) * self.viewChangingProgress\n\n    if self.viewChangingProgress + 0.02 >= 1 and self.viewMode == \'C\':\n      ceiling = self.scene.find(""**/ceiling"")\n      ceiling.show()\n      pass\n\n    if self.viewChangingProgress <= 0.02 and self.viewMode == \'T\':\n      ceiling = self.scene.find(""**/ceiling"")\n      ceiling.hide()\n      pass\n    return\n  \n  def spinCameraTask(self, task):\n    #print(task.time)\n    #angleDegrees = task.time * 6.0\n    movementStep = 0.003\n    if self.viewChangingProgress <= 1.01:\n      self.changeView()\n      self.viewChangingProgress += 0.02\n      pass\n    \n    if base.mouseWatcherNode.is_button_down(\'w\'):\n      for c in xrange(2):\n        step = movementStep * (self.target[c] - self.cameraPos[c])\n        self.cameraPos[c] += step\n        self.target[c] += step\n        continue\n      pass\n    if base.mouseWatcherNode.is_button_down(\'s\'):\n      for c in xrange(2):\n        step = movementStep * (self.target[c] - self.cameraPos[c])\n        self.cameraPos[c] -= step\n        self.target[c] -= step\n        continue\n      pass\n    if base.mouseWatcherNode.is_button_down(\'a\'):\n      step = movementStep * (self.target[0] - self.cameraPos[0])\n      self.cameraPos[1] += step\n      self.target[1] += step\n      step = movementStep * (self.target[1] - self.cameraPos[1])\n      self.cameraPos[0] -= step\n      self.target[0] -= step\n      pass\n    if base.mouseWatcherNode.is_button_down(\'d\'):\n      step = movementStep * (self.target[0] - self.cameraPos[0])\n      self.cameraPos[1] -= step\n      self.target[1] -= step\n      step = movementStep * (self.target[1] - self.cameraPos[1])\n      self.cameraPos[0] += step\n      self.target[0] += step\n      pass\n    \n    rotationStep = 0.02\n    if base.mouseWatcherNode.is_button_down(\'arrow_left\'):\n      angle = np.angle(complex(self.target[0] - self.cameraPos[0], self.target[1] - self.cameraPos[1]))\n      angle += rotationStep\n      self.target[0] = self.cameraPos[0] + np.cos(angle)\n      self.target[1] = self.cameraPos[1] + np.sin(angle)\n      pass\n    if base.mouseWatcherNode.is_button_down(\'arrow_right\'):\n      angle = np.angle(complex(self.target[0] - self.cameraPos[0], self.target[1] - self.cameraPos[1]))\n      angle -= rotationStep\n      self.target[0] = self.cameraPos[0] + np.cos(angle)\n      self.target[1] = self.cameraPos[1] + np.sin(angle)\n      pass\n\n    if base.mouseWatcherNode.is_button_down(\'arrow_up\'):\n      angle = np.arcsin(self.target[2] - self.cameraPos[2])\n      angle += rotationStep\n      self.target[2] = self.cameraPos[2] + np.sin(angle)\n      pass\n    if base.mouseWatcherNode.is_button_down(\'arrow_down\'):\n      angle = np.arcsin(self.target[2] - self.cameraPos[2])\n      angle -= rotationStep\n      self.target[2] = self.cameraPos[2] + np.sin(angle)\n      pass\n\n    angleDegrees = self.angle\n    angleRadians = angleDegrees * (pi / 180.0)\n    #self.camera.setPos(2.0 * sin(angleRadians), -2.0 * cos(angleRadians), 3)\n    self.camera.setPos(self.cameraPos[0], self.cameraPos[1], self.cameraPos[2])\n    #self.camera.setHpr(angleDegrees, 0, 0)\n    #self.camera.lookAt(0, 0, 0)\n    self.camera.lookAt(self.target[0], self.target[1], self.target[2])\n    self.camera.setR(self.H)\n    #if base.mouseWatcherNode.hasMouse()\n    return Task.cont\n  \napp = Viewer()\napp.run()\n'"
code/PostProcessing/QP.py,0,"b'from gurobipy import *\nimport cv2\nimport numpy as np\nimport sys\nimport csv\nimport copy\n\nif len(sys.argv) == 2 and int(sys.argv[1]) == 1:\n  withoutQP = True\nelse:\n  withoutQP = False\n  pass\n\n\ngap = 10\n\npointWeight = 10000\njunctionWeight = 100\naugmentedJunctionWeight = 50\nlabelWeight = 10\n\nwallWeight = 10\ndoorWeight = 10\niconWeight = 10\n\n#wallTypeWeight = 10\n#doorTypeWeight = 10\niconTypeWeight = 10\n\n#doorExposureWeight = 0\n\n\nnumWallTypes = 2\nnumDoorTypes = 6\nnumIconTypes = 10\nnumRoomTypes = 11\nnumLabels = numWallTypes + numDoorTypes + numIconTypes + numRoomTypes + 1\n\niconOffset = 13\nwallOffset = 11\ndoorOffset = 23\n\n\ncolorMap = [\n  [128, 128, 128],\n  [0, 0, 255],\n  [64, 128, 192],\n  [0, 128, 0],\n  [192, 0, 0],\n  [128, 0, 128],\n  [128, 128, 192],\n  [128, 192, 192],\n  [0, 128, 0],\n  [0, 0, 128],\n  [128, 128, 0],\n  [0, 128, 128]\n  #[0, 128, 128],\n  #[128, 0, 128],\n]\n\n#colorMap = np.random.rand(11, 3) * 255\n#colorMap[0] = 160\n# iconWallTypesMap[0] = \'bathtub\'\n# iconWallTypesMap[1] = \'cooking counter\'\n# iconWallTypesMap[2] = \'toilet\'\n# iconWallTypesMap[3] = \'entrance\'\n# iconWallTypesMap[4] = \'washing basin\'\n# iconWallTypesMap[5] = \'washing machine\'\n# iconWallTypesMap[6] = \'washing basin\'\n# iconWallTypesMap[7] = \'cross\'\n# iconWallTypesMap[8] = \'column\'\n# iconWallTypesMap[9] = \'stairs\'\n\n\n\nfloorplan = cv2.imread(\'test/floorplan.png\')\n\n\n\nwidth = floorplan.shape[1]\nheight = floorplan.shape[0]\nmaxDim = max(width, height)\n\npointOrientations = [[(2, ), (3, ), (0, ), (1, )], [(0, 3), (0, 1), (1, 2), (2, 3)], [(1, 2, 3), (0, 2, 3), (0, 1, 3), (0, 1, 2)], [(0, 1, 2, 3)]]\norientationRanges = [[width, 0, 0, 0], [width, height, width, 0], [width, height, 0, height], [0, height, 0, 0]]\n\n\n\niconNames = [\'bathtub\', \'cooking_counter\', \'toilet\', \'entrance\', \'washing_basin\', \'washing_basin\', \'washing_basin\', \'special\', \'special\', \'stairs\']\niconStyles = [1, 1, 1, 1, 1, 2, 1, 1, 3, 1]\niconNameNumberMap = dict(zip(iconNames, xrange(len(iconNames))))\niconNumberNameMap = dict(zip(xrange(len(iconNames)), iconNames))\niconNumberStyleMap = dict(zip(xrange(len(iconStyles)), iconStyles))\n\ndef calcLineDim(points, line):\n  point_1 = points[line[0]]\n  point_2 = points[line[1]]\n  if point_2[0] - point_1[0] > point_2[1] - point_1[1]:\n    lineDim = 0\n  else:\n    lineDim = 1\n  return lineDim\n\ndef writePoints(points, pointLabels):\n  with open(\'test/points_out.txt\', \'w\') as points_file:\n    for point in points:\n      points_file.write(str(point[0] + 1) + \'\\t\' + str(point[1] + 1) + \'\\t\')\n      points_file.write(str(point[0] + 1) + \'\\t\' + str(point[1] + 1) + \'\\t\')\n      points_file.write(\'point\\t\')\n      points_file.write(str(point[2] + 1) + \'\\t\' + str(point[3] + 1) + \'\\n\')\n  points_file.close()\n\n  with open(\'test/point_labels.txt\', \'w\') as point_label_file:\n    for point in pointLabels:\n      point_label_file.write(str(point[0]) + \'\\t\' + str(point[1]) + \'\\t\' + str(point[2]) + \'\\t\' + str(point[3]) + \'\\n\')\n  point_label_file.close()\n\ndef writeDoors(points, lines, doorTypes):\n  with open(\'test/doors_out.txt\', \'w\') as doors_file:\n    for lineIndex, line in enumerate(lines):\n      point_1 = points[line[0]]\n      point_2 = points[line[1]]\n\n      doors_file.write(str(point_1[0] + 1) + \'\\t\' + str(point_1[1] + 1) + \'\\t\')\n      doors_file.write(str(point_2[0] + 1) + \'\\t\' + str(point_2[1] + 1) + \'\\t\')\n      doors_file.write(\'door\\t\')\n      doors_file.write(str(doorTypes[lineIndex] + 1) + \'\\t1\\n\')\n    doors_file.close()\n\ndef writeIcons(points, icons, iconTypes):\n  with open(\'test/icons_out.txt\', \'w\') as icons_file:\n    for iconIndex, icon in enumerate(icons):\n      point_1 = points[icon[0]]\n      point_2 = points[icon[1]]\n      point_3 = points[icon[2]]\n      point_4 = points[icon[3]]\n\n      x_1 = int(round((point_1[0] + point_3[0]) / 2)) + 1\n      x_2 = int(round((point_2[0] + point_4[0]) / 2)) + 1\n      y_1 = int(round((point_1[1] + point_2[1]) / 2)) + 1\n      y_2 = int(round((point_3[1] + point_4[1]) / 2)) + 1\n\n      icons_file.write(str(x_1) + \'\\t\' + str(y_1) + \'\\t\')\n      icons_file.write(str(x_2) + \'\\t\' + str(y_2) + \'\\t\')\n      icons_file.write(iconNumberNameMap[iconTypes[iconIndex]] + \'\\t\')\n      icons_file.write(str(iconNumberStyleMap[iconTypes[iconIndex]]) + \'\\t\')\n      icons_file.write(\'1\\n\')\n    icons_file.close()\n\n\ndef adjustPoints(points, lines):\n  lineNeighbors = []\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    neighbors = []\n    for neighborLineIndex, neighborLine in enumerate(lines):\n      if neighborLineIndex <= lineIndex:\n        continue\n      neighborLineDim = calcLineDim(points, neighborLine)\n      point_1 = points[neighborLine[0]]\n      point_2 = points[neighborLine[1]]\n      if point_2[0] - point_1[0] > point_2[1] - point_1[1]:\n        lineDimNeighbor = 0\n      else:\n        lineDimNeighbor = 1\n        pass\n\n      if lineDimNeighbor != lineDim:\n        continue\n      if neighborLine[0] != line[0] and neighborLine[0] != line[1] and neighborLine[1] != line[0] and neighborLine[1] != line[1]:\n        continue\n      neighbors.append(neighborLineIndex)\n      continue\n    lineNeighbors.append(neighbors)\n    continue\n\n  visitedLines = {}\n  for lineIndex in xrange(len(lines)):\n    if lineIndex in visitedLines:\n      continue\n    lineGroup = [lineIndex]\n    while True:\n      newLineGroup = lineGroup\n      hasChange = False\n      for line in lineGroup:\n        neighbors = lineNeighbors[line]\n        for neighbor in neighbors:\n          if neighbor not in newLineGroup:\n            newLineGroup.append(neighbor)\n            hasChange = True\n            pass\n          continue\n        continue\n      if not hasChange:\n        break\n      lineGroup = newLineGroup\n      continue\n\n    for line in lineGroup:\n      visitedLines[line] = True\n      continue\n\n    pointGroup = []\n    for line in lineGroup:\n      for index in xrange(2):\n        pointIndex = lines[line][index]\n        if pointIndex not in pointGroup:\n          pointGroup.append(pointIndex)\n          pass\n        continue\n      continue\n\n    lineDim = calcLineDim(points, lines[lineGroup[0]])\n    fixedValue = 0\n    for point in pointGroup:\n      fixedValue += points[point][1 - lineDim]\n      continue\n    fixedValue /= len(pointGroup)\n\n    for point in pointGroup:\n      points[point][1 - lineDim] = fixedValue\n      continue\n    continue\n\n\ndef adjustDoorPoints(doorPoints, doorLines, wallPoints, wallLines, doorWallMap):\n  for doorLineIndex, doorLine in enumerate(doorLines):\n    lineDim = calcLineDim(doorPoints, doorLine)\n    wallLine = wallLines[doorWallMap[doorLineIndex]]\n    wallPoint_1 = wallPoints[wallLine[0]]\n    wallPoint_2 = wallPoints[wallLine[1]]\n    fixedValue = (wallPoint_1[1 - lineDim] + wallPoint_2[1 - lineDim]) / 2\n    for endPointIndex in xrange(2):\n      doorPoints[doorLine[endPointIndex]][1 - lineDim] = fixedValue\n      continue\n    continue\n\n\ndef drawLineMask(points, lines, lineWidth = 5, backgroundImage = None):\n  lineMask = np.zeros((height, width))\n\n  for lineIndex, line in enumerate(lines):\n    point_1 = points[line[0]]\n    point_2 = points[line[1]]\n    lineDim = calcLineDim(points, line)\n\n\n    fixedValue = int(round((point_1[1 - lineDim] + point_2[1 - lineDim]) / 2))\n    minValue = int(min(point_1[lineDim], point_2[lineDim]))\n    maxValue = int(max(point_1[lineDim], point_2[lineDim]))\n    if lineDim == 0:\n      lineMask[max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, height), minValue:maxValue + 1] = 1\n    else:\n      lineMask[minValue:maxValue + 1, max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, width)] = 1\n      pass\n    continue\n  return lineMask\n\n\ndef drawLinesToyExample(filename, width, height, points, lines, lineLabels = [], backgroundImage = None, lineWidth = 5, lineColor = 0):\n  if backgroundImage is None:\n    image = np.ones((height, width, 4), np.uint8) * 255\n    image[:, :, 3] = 0\n  else:\n    image = backgroundImage\n    pass\n\n  for lineIndex, line in enumerate(lines):\n    point_1 = points[line[0]]\n    point_2 = points[line[1]]\n    lineDim = calcLineDim(points, line)\n\n\n    fixedValue = int(round((point_1[1 - lineDim] + point_2[1 - lineDim]) / 2))\n    minValue = int(round(min(point_1[lineDim], point_2[lineDim])))\n    maxValue = int(round(max(point_1[lineDim], point_2[lineDim])))\n    if len(lineLabels) == 0:\n      #lineColor = np.random.rand(3) * 255\n      if lineDim == 0:\n        image[max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, height), minValue:maxValue + 1, :] = lineColor\n      else:\n        image[minValue:maxValue + 1, max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, width), :] = lineColor\n    else:\n      labels = lineLabels[lineIndex]\n      isExterior = False\n      if lineDim == 0:\n        for c in xrange(3):\n          if labels[0] == 0 and lineIndex not in [15, 12]:\n            image[max(fixedValue - lineWidth, 0):min(fixedValue, height), minValue - lineWidth:maxValue + lineWidth, c] = colorMap[labels[0]][c]\n            isExterior = True\n          else:\n            image[max(fixedValue - lineWidth, 0):min(fixedValue, height), minValue:maxValue, c] = colorMap[labels[0]][c]\n            pass\n          if labels[1] == 0 and lineIndex not in [15, 12]:\n            image[max(fixedValue, 0):min(fixedValue + lineWidth, height), minValue - lineWidth:maxValue + lineWidth, c] = colorMap[labels[1]][c]\n            isExterior = True\n          else:\n            image[max(fixedValue, 0):min(fixedValue + lineWidth, height), minValue:maxValue, c] = colorMap[labels[1]][c]\n            pass\n          continue\n        if isExterior:\n          image[max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, height), minValue - lineWidth:maxValue + lineWidth, 3] = 255\n        else:\n          image[max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, height), minValue:maxValue, 3] = 255\n      else:\n        for c in xrange(3):\n          if labels[1] == 0 and lineIndex not in [15, 12]:\n            image[minValue - lineWidth:maxValue + lineWidth, max(fixedValue - lineWidth, 0):min(fixedValue, width), c] = colorMap[labels[1]][c]\n            isExterior = True\n          else:\n            image[minValue:maxValue, max(fixedValue - lineWidth, 0):min(fixedValue, width), c] = colorMap[labels[1]][c]\n            pass\n          if labels[0] == 0 and lineIndex not in [15, 12]:\n            image[minValue - lineWidth:maxValue + lineWidth, max(fixedValue, 0):min(fixedValue + lineWidth, width), c] = colorMap[labels[0]][c]\n            isExterior = True\n          else:\n            image[minValue:maxValue, max(fixedValue, 0):min(fixedValue + lineWidth, width), c] = colorMap[labels[0]][c]\n            pass\n          continue\n        if isExterior:\n          image[minValue - lineWidth:maxValue + lineWidth, max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, width), 3] = 255\n        else:\n          image[minValue:maxValue, max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, width), 3] = 255\n\n  if filename == \'\':\n    return image\n  else:\n    cv2.imwrite(filename, image)\n\n\n\ndef drawLines(filename, width, height, points, lines, lineLabels = [], backgroundImage = None, lineWidth = 5, lineColor = 255):\n  if backgroundImage is None:\n    image = np.ones((height, width, 3), np.uint8) * 0\n  else:\n    image = backgroundImage\n    pass\n\n  for lineIndex, line in enumerate(lines):\n    point_1 = points[line[0]]\n    point_2 = points[line[1]]\n    lineDim = calcLineDim(points, line)\n\n\n    fixedValue = int(round((point_1[1 - lineDim] + point_2[1 - lineDim]) / 2))\n    minValue = int(round(min(point_1[lineDim], point_2[lineDim])))\n    maxValue = int(round(max(point_1[lineDim], point_2[lineDim])))\n    if len(lineLabels) == 0:\n      lineColor = np.random.rand(3) * 255\n      if lineDim == 0:\n        image[max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, height), minValue:maxValue + 1, :] = lineColor\n      else:\n        image[minValue:maxValue + 1, max(fixedValue - lineWidth, 0):min(fixedValue + lineWidth, width), :] = lineColor\n    else:\n      labels = lineLabels[lineIndex]\n      isExterior = False\n      if lineDim == 0:\n        for c in xrange(3):\n          image[max(fixedValue - lineWidth, 0):min(fixedValue, height), minValue:maxValue, c] = colorMap[labels[0]][c]\n          image[max(fixedValue, 0):min(fixedValue + lineWidth, height), minValue:maxValue, c] = colorMap[labels[1]][c]\n          continue\n      else:\n        for c in xrange(3):\n          image[minValue:maxValue, max(fixedValue - lineWidth, 0):min(fixedValue, width), c] = colorMap[labels[1]][c]\n          image[minValue:maxValue, max(fixedValue, 0):min(fixedValue + lineWidth, width), c] = colorMap[labels[0]][c]\n          continue\n        pass\n      pass\n    continue\n\n  if filename == \'\':\n    return image\n  else:\n    cv2.imwrite(filename, image)\n\n\ndef drawRectangles(filename, width, height, points, rectangles, labels, lineWidth = 2, backgroundImage = None, rectangleColor = None):\n  if backgroundImage is None:\n    image = np.ones((height, width, 3), np.uint8) * 0\n  else:\n    image = backgroundImage\n    pass\n\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    point_1 = points[rectangle[0]]\n    point_2 = points[rectangle[1]]\n    point_3 = points[rectangle[2]]\n    point_4 = points[rectangle[3]]\n\n    point_1 = (int(point_1[0]), int(point_1[1]))\n    point_2 = (int(point_2[0]), int(point_2[1]))\n    point_3 = (int(point_3[0]), int(point_3[1]))\n    point_4 = (int(point_4[0]), int(point_4[1]))\n\n\n    if len(labels) == 0:\n      if rectangleColor is None:\n        color = np.random.rand(3) * 255\n      else:\n        color = rectangleColor\n    else:\n      color = colorMap[labels[rectangleIndex]]\n\n    image[max(point_1[1] - lineWidth, 0):min(point_1[1] + lineWidth, height), point_1[0]:point_2[0] + 1, :] = color\n    image[max(point_3[1] - lineWidth, 0):min(point_3[1] + lineWidth, height), point_3[0]:point_4[0] + 1, :] = color\n    image[point_1[1]:point_3[1] + 1, max(point_1[0] - lineWidth, 0):min(point_1[0] + lineWidth, width), :] = color\n    image[point_2[1]:point_4[1] + 1, max(point_2[0] - lineWidth, 0):min(point_2[0] + lineWidth, width), :] = color\n\n    continue\n\n  if filename == \'\':\n    return image\n  else:\n    cv2.imwrite(filename, image)\n\n\ndef calcPointInfo(points, gap, minDistanceOnly = False, doubleDirection = False):\n  lines = []\n  pointOrientationLinesMap = []\n  pointNeighbors = [[] for point in points]\n\n  for pointIndex, point in enumerate(points):\n    pointType = point[2]\n    orientations = pointOrientations[pointType][point[3]]\n    orientationLines = {}\n    for orientation in orientations:\n      orientationLines[orientation] = []\n      continue\n    pointOrientationLinesMap.append(orientationLines)\n    continue\n\n\n  for pointIndex, point in enumerate(points):\n    pointType = point[2]\n    orientations = pointOrientations[pointType][point[3]]\n    for orientation in orientations:\n      oppositeOrientation = (orientation + 2) % 4\n      ranges = copy.deepcopy(orientationRanges[orientation])\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n      deltas = [0, 0]\n\n\n      if lineDim == 1:\n        deltas[0] = gap\n      else:\n        deltas[1] = gap\n        pass\n\n      for c in xrange(2):\n        ranges[c] = min(ranges[c], point[c] - deltas[c])\n        ranges[c + 2] = max(ranges[c + 2], point[c] + deltas[c])\n        continue\n\n      neighborPoints = []\n      minDistance = max(width, height)\n      minDistanceNeighborPoint = -1\n\n      for neighborPointIndex, neighborPoint in enumerate(points):\n        if (neighborPointIndex <= pointIndex and not doubleDirection) or neighborPointIndex == pointIndex:\n          continue\n\n        neighborOrientations = pointOrientations[neighborPoint[2]][neighborPoint[3]]\n        if oppositeOrientation not in neighborOrientations:\n          continue\n\n\n        inRange = True\n        for c in xrange(2):\n          if neighborPoint[c] < ranges[c] or neighborPoint[c] > ranges[c + 2]:\n            inRange = False\n            break\n          continue\n\n        if not inRange or abs(neighborPoint[lineDim] - point[lineDim]) < max(abs(neighborPoint[1 - lineDim] - point[1 - lineDim]), 1):\n          continue\n\n        if minDistanceOnly:\n          distance = abs(neighborPoint[lineDim] - point[lineDim])\n          if distance < minDistance:\n            minDistance = distance\n            minDistanceNeighborPoint = neighborPointIndex\n            pass\n        else:\n          neighborPoints.append(neighborPointIndex)\n          pass\n        continue\n\n\n      if minDistanceOnly and minDistanceNeighborPoint >= 0:\n        neighborPoints.append(minDistanceNeighborPoint)\n        pass\n\n\n      for neighborPointIndex in neighborPoints:\n        neighborPoint = points[neighborPointIndex]\n\n        if doubleDirection and ((pointIndex, neighborPointIndex) in lines or (neighborPointIndex, pointIndex) in lines):\n          continue\n\n        lineIndex = len(lines)\n        pointOrientationLinesMap[pointIndex][orientation].append(lineIndex)\n        #print(str(neighborPointIndex) + \' \' + str(oppositeOrientation))\n        #if neighborPoint[2] == 0:\n        #pointOrientationLinesMap[neighborPointIndex][pointOrientationLinesMap[neighborPointIndex].keys()[0]].append(lineIndex)\n        #else:\n        pointOrientationLinesMap[neighborPointIndex][oppositeOrientation].append(lineIndex)\n        pointNeighbors[pointIndex].append(neighborPointIndex)\n        pointNeighbors[neighborPointIndex].append(pointIndex)\n\n        if points[pointIndex][0] + points[pointIndex][1] < points[neighborPointIndex][0] + points[neighborPointIndex][1]:\n          #lines.append([pointIndex, neighborPointIndex, cost, point[4]])\n          lines.append((pointIndex, neighborPointIndex))\n        else:\n          #lines.append([neighborPointIndex, pointIndex, cost, point[4]])\n          lines.append((neighborPointIndex, pointIndex))\n          pass\n        continue\n      continue\n    continue\n\n\n  return lines, pointOrientationLinesMap, pointNeighbors\n\n\ndef findIcons(points, gap, minDistanceOnly = False, maxLengths = (10000, 10000)):\n  pointOrientationNeighborsMap = []\n\n  for pointIndex, point in enumerate(points):\n    pointType = point[2]\n    orientations = pointOrientations[pointType][point[3]]\n    orientationNeighbors = {}\n    for orientation in orientations:\n      orientationNeighbors[orientation] = []\n      continue\n    pointOrientationNeighborsMap.append(orientationNeighbors)\n    continue\n\n\n  for pointIndex, point in enumerate(points):\n    pointType = point[2]\n    orientations = pointOrientations[pointType][point[3]]\n    for orientation in orientations:\n      oppositeOrientation = (orientation + 2) % 4\n      ranges = copy.deepcopy(orientationRanges[orientation])\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n      deltas = [0, 0]\n\n\n      if lineDim == 1:\n        deltas[0] = gap\n      else:\n        deltas[1] = gap\n        pass\n\n      for c in xrange(2):\n        ranges[c] = min(ranges[c], point[c] - deltas[c])\n        ranges[c + 2] = max(ranges[c + 2], point[c] + deltas[c])\n        continue\n\n      neighborPoints = []\n      minDistance = max(width, height)\n      minDistanceNeighborPoint = -1\n\n      for neighborPointIndex, neighborPoint in enumerate(points):\n        if neighborPointIndex <= pointIndex:\n          continue\n        neighborOrientations = pointOrientations[neighborPoint[2]][neighborPoint[3]]\n        if oppositeOrientation not in neighborOrientations:\n          continue\n\n        inRange = True\n        for c in xrange(2):\n          if neighborPoint[c] < ranges[c] or neighborPoint[c] > ranges[c + 2]:\n            inRange = False\n            break\n          continue\n\n        if not inRange or abs(neighborPoint[lineDim] - point[lineDim]) < max(abs(neighborPoint[1 - lineDim] - point[1 - lineDim]), gap):\n          continue\n\n        distance = abs(neighborPoint[lineDim] - point[lineDim])\n        if distance > maxLengths[lineDim]:\n          continue\n\n        if minDistanceOnly:\n          if distance < minDistance:\n            minDistance = distance\n            minDistanceNeighborPoint = neighborPointIndex\n            pass\n          pass\n        else:\n          neighborPoints.append(neighborPointIndex)\n          pass\n        continue\n\n      if minDistanceOnly and minDistanceNeighborPoint >= 0:\n        neighborPoints.append(minDistanceNeighborPoint)\n        pass\n\n      for neighborPointIndex in neighborPoints:\n        pointOrientationNeighborsMap[pointIndex][orientation].append(neighborPointIndex)\n        pointOrientationNeighborsMap[neighborPointIndex][oppositeOrientation].append(pointIndex)\n        continue\n      continue\n    continue\n\n\n  icons = []\n  orderedOrientations = (1, 2, 3, 0)\n  for pointIndex_1, orientationNeighbors in enumerate(pointOrientationNeighborsMap):\n    if orderedOrientations[0] not in orientationNeighbors or ((orderedOrientations[3] + 2) % 4) not in orientationNeighbors:\n      continue\n    pointIndices_4 = orientationNeighbors[(orderedOrientations[3] + 2) % 4]\n    for pointIndex_2 in orientationNeighbors[orderedOrientations[0]]:\n      if orderedOrientations[1] not in pointOrientationNeighborsMap[pointIndex_2]:\n        continue\n      for pointIndex_3 in pointOrientationNeighborsMap[pointIndex_2][orderedOrientations[1]]:\n        if orderedOrientations[2] not in pointOrientationNeighborsMap[pointIndex_3]:\n          continue\n        for pointIndex_4 in pointOrientationNeighborsMap[pointIndex_3][orderedOrientations[2]]:\n          if pointIndex_4 in pointIndices_4:\n            icons.append((pointIndex_1, pointIndex_2, pointIndex_4, pointIndex_3, (points[pointIndex_1][4] + points[pointIndex_2][4] + points[pointIndex_3][4] + points[pointIndex_4][4]) / 4))\n            pass\n          continue\n        continue\n      continue\n    continue\n\n  return icons\n\n\ndef findLineNeighbors(points, lines, gap):\n  lineNeighbors = [[{}, {}] for lineIndex in xrange(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    for neighborLineIndex, neighborLine in enumerate(lines):\n      if neighborLineIndex <= lineIndex:\n        continue\n      neighborLineDim = calcLineDim(points, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = points[line[0]][1 - lineDim]\n      fixedValue_2 = points[neighborLine[0]][1 - lineDim]\n\n      minValue = int(minValue)\n      maxValue = int(maxValue)\n      fixedValue_1 = int(fixedValue_1)\n      fixedValue_2 = int(fixedValue_2)\n\n      if abs(fixedValue_2 - fixedValue_1) < gap:\n        continue\n      if lineDim == 0:\n        if fixedValue_1 < fixedValue_2:\n          #labelVotes = (labelVotesMap[:, fixedValue_2, maxValue] + labelVotesMap[:, fixedValue_1, minValue] - labelVotesMap[:, fixedValue_2, minValue] - labelVotesMap[:, fixedValue_1, maxValue])\n          region = ((minValue, fixedValue_1), (maxValue, fixedValue_2))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][0][lineIndex] = region\n        else:\n          #labelVotes = (labelVotesMap[:, fixedValue_1, maxValue] + labelVotesMap[:, fixedValue_2, minValue] - labelVotesMap[:, fixedValue_1, minValue] - labelVotesMap[:, fixedValue_2, maxValue])\n          region = ((minValue, fixedValue_2), (maxValue, fixedValue_1))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][1][lineIndex] = region\n      else:\n        if fixedValue_1 < fixedValue_2:\n          #labelVotes = (labelVotesMap[:, maxValue, fixedValue_2] + labelVotesMap[:, minValue, fixedValue_1] - labelVotesMap[:, minValue, fixedValue_2] - labelVotesMap[:, maxValue, fixedValue_1])\n          region = ((fixedValue_1, minValue), (fixedValue_2, maxValue))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][1][lineIndex] = region\n        else:\n          #labelVotes = (labelVotesMap[:, maxValue, fixedValue_1] + labelVotesMap[:, minValue, fixedValue_2] - labelVotesMap[:, minValue, fixedValue_1] - labelVotesMap[:, maxValue, fixedValue_2])\n          region = ((fixedValue_2, minValue), (fixedValue_1, maxValue))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          lineNeighbors[neighborLineIndex][0][lineIndex] = region\n          pass\n        pass\n      continue\n    continue\n\n  while True:\n    hasChange = False\n    for lineIndex, neighbors in enumerate(lineNeighbors):\n      lineDim = calcLineDim(points, lines[lineIndex])\n      for neighbor_1, region_1 in neighbors[1].iteritems():\n        for neighbor_2, _ in neighbors[0].iteritems():\n          if neighbor_2 not in lineNeighbors[neighbor_1][0]:\n            continue\n          region_2 = lineNeighbors[neighbor_1][0][neighbor_2]\n          if region_1[0][lineDim] < region_2[0][lineDim] + gap and region_1[1][lineDim] > region_2[1][lineDim] - gap:\n            lineNeighbors[neighbor_1][0].pop(neighbor_2)\n            lineNeighbors[neighbor_2][1].pop(neighbor_1)\n            hasChange = True\n            pass\n          continue\n        continue\n      continue\n    if not hasChange:\n      break\n\n\n  for lineIndex, directionNeighbors in enumerate(lineNeighbors):\n    for direction, neighbors in enumerate(directionNeighbors):\n      for neighbor, region in neighbors.iteritems():\n        labelVotes = labelVotesMap[:, region[1][1], region[1][0]] + labelVotesMap[:, region[0][1], region[0][0]] - labelVotesMap[:, region[0][1], region[1][0]] - labelVotesMap[:, region[1][1], region[0][0]]\n        neighbors[neighbor] = labelVotes\n        continue\n      continue\n    continue\n\n\n  return lineNeighbors\n\n\n\ndef findLineNeighborsCross(points, lines, points_2, lines_2, lineNeighbors_2, gap):\n  lineNeighbors = [[{}, {}] for lineIndex in xrange(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    for neighborLineIndex, neighborLine in enumerate(lines_2):\n      neighborLineDim = calcLineDim(points_2, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points_2[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points_2[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = points[line[0]][1 - lineDim]\n      fixedValue_2 = points_2[neighborLine[0]][1 - lineDim]\n\n      if abs(fixedValue_2 - fixedValue_1) < gap:\n        continue\n      minValue = int(minValue)\n      maxValue = int(maxValue)\n      fixedValue_1 = int(fixedValue_1)\n      fixedValue_2 = int(fixedValue_2)\n\n      if lineDim == 0:\n        if fixedValue_1 < fixedValue_2:\n          #labelVotes = (labelVotesMap[:, fixedValue_2, maxValue] + labelVotesMap[:, fixedValue_1, minValue] - labelVotesMap[:, fixedValue_2, minValue] - labelVotesMap[:, fixedValue_1, maxValue])\n          region = ((minValue, fixedValue_1), (maxValue, fixedValue_2))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          #lineNeighbors[neighborLineIndex][0][lineIndex] = region\n        else:\n          #labelVotes = (labelVotesMap[:, fixedValue_1, maxValue] + labelVotesMap[:, fixedValue_2, minValue] - labelVotesMap[:, fixedValue_1, minValue] - labelVotesMap[:, fixedValue_2, maxValue])\n          region = ((minValue, fixedValue_2), (maxValue, fixedValue_1))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          #lineNeighbors[neighborLineIndex][1][lineIndex] = region\n      else:\n        if fixedValue_1 < fixedValue_2:\n          #labelVotes = (labelVotesMap[:, maxValue, fixedValue_2] + labelVotesMap[:, minValue, fixedValue_1] - labelVotesMap[:, minValue, fixedValue_2] - labelVotesMap[:, maxValue, fixedValue_1])\n          region = ((fixedValue_1, minValue), (fixedValue_2, maxValue))\n          lineNeighbors[lineIndex][0][neighborLineIndex] = region\n          #lineNeighbors[neighborLineIndex][1][lineIndex] = region\n        else:\n          #labelVotes = (labelVotesMap[:, maxValue, fixedValue_1] + labelVotesMap[:, minValue, fixedValue_2] - labelVotesMap[:, minValue, fixedValue_1] - labelVotesMap[:, maxValue, fixedValue_2])\n          region = ((fixedValue_2, minValue), (fixedValue_1, maxValue))\n          lineNeighbors[lineIndex][1][neighborLineIndex] = region\n          #lineNeighbors[neighborLineIndex][0][lineIndex] = region\n          pass\n        pass\n      continue\n    continue\n\n\n  newLineNeighbors = [[{}, {}] for lineIndex in xrange(len(lines))]\n  for lineIndex, neighbors in enumerate(lineNeighbors):\n    lineDim = calcLineDim(points, lines[lineIndex])\n    for direction in xrange(2):\n      for neighbor_1, region_1 in neighbors[direction].iteritems():\n        neighborValid = True\n        for neighbor_2, region_2 in neighbors[direction].iteritems():\n          if neighbor_2 == neighbor_1:\n            continue\n          if neighbor_1 not in lineNeighbors_2[neighbor_2][direction]:\n            continue\n          if region_2[0][lineDim] < region_1[0][lineDim] + gap and region_2[1][lineDim] > region_1[1][lineDim] - gap:\n            neighborValid = False\n            break\n          continue\n\n        if neighborValid:\n          newLineNeighbors[lineIndex][direction][neighbor_1] = region_1\n          pass\n        continue\n      continue\n    continue\n\n  return newLineNeighbors\n\n\ndef findRectangleLineNeighbors(rectanglePoints, rectangles, linePoints, lines, lineNeighbors, gap, distanceThreshold):\n  rectangleLineNeighbors = [{} for rectangleIndex in xrange(len(rectangles))]\n  minDistanceLineNeighbors = {}\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    for lineIndex, line in enumerate(lines):\n      lineDim = calcLineDim(linePoints, line)\n\n      minValue = max(rectanglePoints[rectangle[0]][lineDim], rectanglePoints[rectangle[2 - lineDim]][lineDim], linePoints[line[0]][lineDim])\n      maxValue = min(rectanglePoints[rectangle[1 + lineDim]][lineDim], rectanglePoints[rectangle[3]][lineDim], linePoints[line[1]][lineDim])\n\n      if maxValue - minValue < gap:\n        continue\n\n      rectangleFixedValue_1 = (rectanglePoints[rectangle[0]][1 - lineDim] + rectanglePoints[rectangle[1 + lineDim]][1 - lineDim]) / 2\n      rectangleFixedValue_2 = (rectanglePoints[rectangle[2 - lineDim]][1 - lineDim] + rectanglePoints[rectangle[3]][1 - lineDim]) / 2\n      lineFixedValue = (linePoints[line[0]][1 - lineDim] + linePoints[line[1]][1 - lineDim]) / 2\n\n      if lineFixedValue < rectangleFixedValue_2 - gap and lineFixedValue > rectangleFixedValue_1 + gap:\n        continue\n\n      if lineFixedValue <= rectangleFixedValue_1 + gap:\n        index = lineDim * 2 + 0\n        distance = rectangleFixedValue_1 - lineFixedValue\n        if index not in minDistanceLineNeighbors or distance < minDistanceLineNeighbors[index][1]:\n          minDistanceLineNeighbors[index] = (lineIndex, distance, 1 - lineDim)\n      else:\n        index = lineDim * 2 + 1\n        distance = lineFixedValue - rectangleFixedValue_2\n        if index not in minDistanceLineNeighbors or distance < minDistanceLineNeighbors[index][1]:\n          minDistanceLineNeighbors[index] = (lineIndex, distance, lineDim)\n\n      if lineFixedValue < rectangleFixedValue_1 - distanceThreshold or lineFixedValue > rectangleFixedValue_2 + distanceThreshold:\n        continue\n\n      if lineFixedValue <= rectangleFixedValue_1 + gap:\n        if lineDim == 0:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 1\n        else:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 0\n          pass\n        pass\n      else:\n        if lineDim == 0:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 0\n        else:\n          rectangleLineNeighbors[rectangleIndex][lineIndex] = 1\n          pass\n        pass\n\n      continue\n    if len(rectangleLineNeighbors[rectangleIndex]) == 0 or True:\n      for index, lineNeighbor in minDistanceLineNeighbors.iteritems():\n        rectangleLineNeighbors[rectangleIndex][lineNeighbor[0]] = lineNeighbor[2]\n        continue\n      pass\n    continue\n\n  return rectangleLineNeighbors\n\n\ndef findLineMap(points, lines, points_2, lines_2, gap):\n  lineMap = [{} for lineIndex in xrange(len(lines))]\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    for neighborLineIndex, neighborLine in enumerate(lines_2):\n      neighborLineDim = calcLineDim(points_2, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points_2[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points_2[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) / 2\n      fixedValue_2 = (points_2[neighborLine[0]][1 - lineDim] + points_2[neighborLine[1]][1 - lineDim]) / 2\n\n      if abs(fixedValue_2 - fixedValue_1) > gap:\n        continue\n\n      lineMinValue = points[line[0]][lineDim]\n      lineMaxValue = points[line[1]][lineDim]\n      ratio = float(maxValue - minValue + 1) / (lineMaxValue - lineMinValue + 1)\n\n      lineMap[lineIndex][neighborLineIndex] = ratio\n      continue\n    continue\n\n  return lineMap\n\n\ndef findLineMapSingle(points, lines, points_2, lines_2, gap):\n  lineMap = []\n  for lineIndex, line in enumerate(lines):\n    lineDim = calcLineDim(points, line)\n    minDistance = max(width, height)\n    minDistanceLineIndex = -1\n    for neighborLineIndex, neighborLine in enumerate(lines_2):\n      neighborLineDim = calcLineDim(points_2, neighborLine)\n      if lineDim != neighborLineDim:\n        continue\n\n      minValue = max(points[line[0]][lineDim], points_2[neighborLine[0]][lineDim])\n      maxValue = min(points[line[1]][lineDim], points_2[neighborLine[1]][lineDim])\n      if maxValue - minValue < gap:\n        continue\n      fixedValue_1 = (points[line[0]][1 - lineDim] + points[line[1]][1 - lineDim]) / 2\n      fixedValue_2 = (points_2[neighborLine[0]][1 - lineDim] + points_2[neighborLine[1]][1 - lineDim]) / 2\n\n      distance = abs(fixedValue_2 - fixedValue_1)\n      if distance < minDistance:\n        minDistance = distance\n        minDistanceLineIndex = neighborLineIndex\n        pass\n      continue\n\n    #if abs(fixedValue_2 - fixedValue_1) > gap:\n    #continue\n    #print((lineIndex, minDistance, minDistanceLineIndex))\n    lineMap.append(minDistanceLineIndex)\n    continue\n\n  return lineMap\n\n\ndef findConflictLinePairs(points, lines, gap):\n  conflictLinePairs = []\n  for lineIndex_1, line_1 in enumerate(lines):\n    point_1 = points[line_1[0]]\n    point_2 = points[line_1[1]]\n    if point_2[0] - point_1[0] > point_2[1] - point_1[1]:\n      lineDim_1 = 0\n    else:\n      lineDim_1 = 1\n      pass\n\n    fixedValue_1 = int(round((point_1[1 - lineDim_1] + point_2[1 - lineDim_1]) / 2))\n    minValue_1 = int(min(point_1[lineDim_1], point_2[lineDim_1]))\n    maxValue_1 = int(max(point_1[lineDim_1], point_2[lineDim_1]))\n\n    for lineIndex_2, line_2 in enumerate(lines):\n      if lineIndex_2 <= lineIndex_1:\n        continue\n\n      point_1 = points[line_2[0]]\n      point_2 = points[line_2[1]]\n      if point_2[0] - point_1[0] > point_2[1] - point_1[1]:\n        lineDim_2 = 0\n      else:\n        lineDim_2 = 1\n        pass\n\n      if (line_1[0] == line_2[0] or line_1[1] == line_2[1]) and lineDim_2 == lineDim_1:\n        conflictLinePairs.append((lineIndex_1, lineIndex_2))\n        continue\n\n      fixedValue_2 = int(round((point_1[1 - lineDim_2] + point_2[1 - lineDim_2]) / 2))\n      minValue_2 = int(min(point_1[lineDim_2], point_2[lineDim_2]))\n      maxValue_2 = int(max(point_1[lineDim_2], point_2[lineDim_2]))\n\n      # if lineIndex_1 == 3 and lineIndex_2 == 4:\n      #   print(line_1)\n      #   print(line_2)\n      #   print(points[line_1[0]])\n      #   print(points[line_1[1]])\n      #   print(point_1)\n      #   print(point_2)\n      #   print((fixedValue_2, fixedValue_1, minValue_1, maxValue_2))\n      #   exit(1)\n\n      if lineDim_1 == lineDim_2:\n        if abs(fixedValue_2 - fixedValue_1) > gap / 2 or minValue_1 > maxValue_2 - gap or minValue_2 > maxValue_1 - gap:\n          continue\n        conflictLinePairs.append((lineIndex_1, lineIndex_2))\n        #drawLines(\'test/lines_\' + str(lineIndex_1) + ""_"" + str(lineIndex_2) + \'.png\', width, height, points, [line_1, line_2])\n      else:\n        if minValue_1 > fixedValue_2 - gap or maxValue_1 < fixedValue_2 + gap or minValue_2 > fixedValue_1 - gap or maxValue_2 < fixedValue_1 + gap:\n          continue\n        conflictLinePairs.append((lineIndex_1, lineIndex_2))\n        pass\n      continue\n    continue\n\n  return conflictLinePairs\n\n\ndef findConflictRectanglePairs(points, rectangles, gap):\n  conflictRectanglePairs = []\n  for rectangleIndex_1, rectangle_1 in enumerate(rectangles):\n    for rectangleIndex_2, rectangle_2 in enumerate(rectangles):\n      if rectangleIndex_2 <= rectangleIndex_1:\n        continue\n\n      conflict = False\n      for cornerIndex in xrange(4):\n        if rectangle_1[cornerIndex] == rectangle_2[cornerIndex]:\n          conflictRectanglePairs.append((rectangleIndex_1, rectangleIndex_2))\n          conflict = True\n          break\n        continue\n\n      if conflict:\n        continue\n\n      minX = max(points[rectangle_1[0]][0], points[rectangle_1[2]][0], points[rectangle_2[0]][0], points[rectangle_2[2]][0])\n      maxX = min(points[rectangle_1[1]][0], points[rectangle_1[3]][0], points[rectangle_2[1]][0], points[rectangle_2[3]][0])\n      if minX > maxX - gap:\n        continue\n      minY = max(points[rectangle_1[0]][1], points[rectangle_1[1]][1], points[rectangle_2[0]][1], points[rectangle_2[1]][1])\n      maxY = min(points[rectangle_1[2]][1], points[rectangle_1[3]][1], points[rectangle_2[2]][1], points[rectangle_2[3]][1])\n      if minY > maxY - gap:\n        continue\n      conflictRectanglePairs.append((rectangleIndex_1, rectangleIndex_2))\n      continue\n    continue\n\n  return conflictRectanglePairs\n\n\ndef findConflictRectangleLinePairs(rectanglePoints, rectangles, linePoints, lines, gap):\n  conflictRectangleLinePairs = []\n  for rectangleIndex, rectangle in enumerate(rectangles):\n    for lineIndex, line in enumerate(lines):\n      # for c in xrange(4):\n      #   print(rectanglePoints[rectangle[c]])\n      #   continue\n      # for c in xrange(2):\n      #   print(linePoints[line[c]])\n      #   continue\n      lineDim = calcLineDim(linePoints, line)\n      if lineDim == 0:\n        minX = max(rectanglePoints[rectangle[0]][0], rectanglePoints[rectangle[2]][0], linePoints[line[0]][0])\n        maxX = min(rectanglePoints[rectangle[1]][0], rectanglePoints[rectangle[3]][0], linePoints[line[1]][0])\n        if minX > maxX - gap:\n          continue\n        if max(rectanglePoints[rectangle[0]][1], rectanglePoints[rectangle[1]][1]) + gap > min(linePoints[line[0]][1], linePoints[line[1]][1]):\n          continue\n        if min(rectanglePoints[rectangle[2]][1], rectanglePoints[rectangle[3]][1]) - gap < max(linePoints[line[0]][1], linePoints[line[1]][1]):\n          continue\n\n      elif lineDim == 1:\n        minY = max(rectanglePoints[rectangle[0]][1], rectanglePoints[rectangle[1]][1], linePoints[line[0]][1])\n        maxY = min(rectanglePoints[rectangle[2]][1], rectanglePoints[rectangle[3]][1], linePoints[line[1]][1])\n        if minY > maxY - gap:\n          continue\n        if max(rectanglePoints[rectangle[0]][0], rectanglePoints[rectangle[2]][0]) + gap > min(linePoints[line[0]][0], linePoints[line[1]][0]):\n          continue\n        if min(rectanglePoints[rectangle[1]][0], rectanglePoints[rectangle[3]][0]) - gap < max(linePoints[line[0]][0], linePoints[line[1]][0]):\n          continue\n\n      conflictRectangleLinePairs.append((rectangleIndex, lineIndex))\n      continue\n    continue\n\n  return conflictRectangleLinePairs\n\n\ndef findConflictLinePairsCross(points_1, lines_1, points_2, lines_2, gap):\n  conflictLinePairs = []\n  for lineIndex_1, line_1 in enumerate(lines_1):\n    point_1 = points_1[line_1[0]]\n    point_2 = points_1[line_1[1]]\n    if point_2[0] - point_1[0] > point_2[1] - point_1[1]:\n      lineDim_1 = 0\n    else:\n      lineDim_1 = 1\n      pass\n\n    fixedValue_1 = int(round((point_1[1 - lineDim_1] + point_2[1 - lineDim_1]) / 2))\n    minValue_1 = int(min(point_1[lineDim_1], point_2[lineDim_1]))\n    maxValue_1 = int(max(point_1[lineDim_1], point_2[lineDim_1]))\n\n    for lineIndex_2, line_2 in enumerate(lines_2):\n      point_1 = points_2[line_2[0]]\n      point_2 = points_2[line_2[1]]\n      if point_2[0] - point_1[0] > point_2[1] - point_1[1]:\n        lineDim_2 = 0\n      else:\n        lineDim_2 = 1\n        pass\n\n      fixedValue_2 = int(round((point_1[1 - lineDim_2] + point_2[1 - lineDim_2]) / 2))\n      minValue_2 = int(min(point_1[lineDim_2], point_2[lineDim_2]))\n      maxValue_2 = int(max(point_1[lineDim_2], point_2[lineDim_2]))\n\n      if lineDim_1 == lineDim_2:\n        continue\n\n      if minValue_1 > fixedValue_2 - gap or maxValue_1 < fixedValue_2 + gap or minValue_2 > fixedValue_1 - gap or maxValue_2 < fixedValue_1 + gap:\n        continue\n      conflictLinePairs.append((lineIndex_1, lineIndex_2))\n      continue\n    continue\n\n  return conflictLinePairs\n\ndef maximumSuppression(mask, x, y, heatmapValueThreshold):\n  value = mask[y][x]\n  mask[y][x] = -1\n  deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n  for delta in deltas:\n    neighborX = x + delta[0]\n    neighborY = y + delta[1]\n    if neighborX < 0 or neighborY < 0 or neighborX >= width or neighborY >= height:\n      continue\n    neighborValue = mask[neighborY][neighborX]\n    if neighborValue <= value and neighborValue > heatmapValueThreshold:\n      maximumSuppression(mask, neighborX, neighborY, heatmapValueThreshold)\n      pass\n    continue\n\n\n\ndef extractLocalMaximum(maskImg, numPoints, info, heatmapValueThreshold = 0.5, closePointSuppression = False, lineWidth = 5, maskIndex = -1):\n  mask = copy.deepcopy(maskImg)\n  points = []\n  #pointMask = np.zeros(maskImg.shape)\n  pointMask = cv2.cvtColor(floorplan, cv2.COLOR_BGR2GRAY)\n  for pointIndex in xrange(numPoints):\n    index = np.argmax(mask)\n    y, x = np.unravel_index(index, mask.shape)\n    maxValue = mask[y, x]\n    if maxValue <= heatmapValueThreshold:\n      break\n\n    pointMask[max(y - lineWidth, 0):min(y + lineWidth, height - 1), max(x - lineWidth, 0):min(x + lineWidth, width - 1)] = 1\n\n    points.append([float(x), float(y)] + info + [maxValue, ])\n\n    maximumSuppression(mask, x, y, heatmapValueThreshold)\n    if closePointSuppression:\n      mask[max(y - gap, 0):min(y + gap, height - 1), max(x - gap, 0):min(x + gap, width - 1)] = 0\n\n\n    # print(suppressedPoints)\n    # meanX = 0\n    # meanY = 0\n    # for point in suppressedPoints:\n    #   meanX += point[0]\n    #   meanY += point[1]\n    #   continue\n    # meanX = float(meanX) / len(suppressedPoints)\n    # meanY = float(meanY) / len(suppressedPoints)\n    # points.append([meanX, meanY] + info + [maxValue, ])\n\n\n    #cv2.imwrite(\'test/mask_\' + str(pointIndex) + \'.png\', (mask * 255).astype(np.uint8))\n    continue\n  if maskIndex >= 0:\n    cv2.imwrite(\'test/mask_\' + str(maskIndex) + \'.png\', (pointMask * 255).astype(np.uint8))\n\n  #points = scalePoints(points, 256)\n  return points\n\n\ndef scalePoints(points, sampleDim):\n  for point in points:\n    point[0] *= width / sampleDim\n    point[1] *= height / sampleDim\n    continue\n  return points\n\n\ndef augmentPoints(points):\n  orientationMap = {}\n  for pointType, orientationOrientations in enumerate(pointOrientations):\n    for orientation, orientations in enumerate(orientationOrientations):\n      orientationMap[orientations] = orientation\n      continue\n    continue\n\n  newPoints = []\n  for pointIndex, point in enumerate(points):\n    if point[2] not in [2, 3]:\n      continue\n    orientations = pointOrientations[point[2]][point[3]]\n    for i in xrange(len(orientations)):\n      newOrientations = list(orientations)\n      newOrientations.remove(orientations[i])\n      newOrientations = tuple(newOrientations)\n      if not newOrientations in orientationMap:\n        continue\n      newOrientation = orientationMap[newOrientations]\n      newPoints.append([point[0], point[1], point[2] - 1, newOrientation])\n      continue\n    continue\n\n  for pointIndex, point in enumerate(points):\n    if point[2] not in [1, 2]:\n      continue\n    orientations = pointOrientations[point[2]][point[3]]\n    for orientation in xrange(4):\n      if orientation in orientations:\n        continue\n\n      oppositeOrientation = (orientation + 2) % 4\n      ranges = copy.deepcopy(orientationRanges[orientation])\n      lineDim = -1\n      if orientation == 0 or orientation == 2:\n        lineDim = 1\n      else:\n        lineDim = 0\n        pass\n      deltas = [0, 0]\n\n\n      if lineDim == 1:\n        deltas[0] = gap\n      else:\n        deltas[1] = gap\n        pass\n\n      for c in xrange(2):\n        ranges[c] = min(ranges[c], point[c] - deltas[c])\n        ranges[c + 2] = max(ranges[c + 2], point[c] + deltas[c])\n        continue\n\n      hasNeighbor = False\n      for neighborPointIndex, neighborPoint in enumerate(points):\n        if neighborPointIndex == pointIndex:\n          continue\n\n        neighborOrientations = pointOrientations[neighborPoint[2]][neighborPoint[3]]\n        if oppositeOrientation not in neighborOrientations:\n          continue\n\n        inRange = True\n        for c in xrange(2):\n          if neighborPoint[c] < ranges[c] or neighborPoint[c] > ranges[c + 2]:\n            inRange = False\n            break\n          continue\n\n        if not inRange or abs(neighborPoint[lineDim] - point[lineDim]) < max(abs(neighborPoint[1 - lineDim] - point[1 - lineDim]), 1):\n          continue\n\n        hasNeighbor = True\n        break\n\n      if not hasNeighbor:\n        continue\n\n      newOrientations = list(orientations)\n      newOrientations.append(orientation)\n      newOrientations = tuple(newOrientations)\n      if not newOrientations in orientationMap:\n        continue\n      newOrientation = orientationMap[newOrientations]\n      newPoints.append([point[0], point[1], point[2] + 1, newOrientation])\n      continue\n    continue\n\n  return points + newPoints\n\n\n\nwallPoints = []\niconPoints = []\ndoorPoints = []\n\n\n\nif withoutQP:\n  numWallPoints = 30\n  numDoorPoints = 30\n  numIconPoints = 30\n  heatmapValueThresholdWall = 0.4\n  heatmapValueThresholdDoor = 0.4\n  heatmapValueThresholdIcon = 0.4\nelse:\n  numWallPoints = 100\n  numDoorPoints = 100\n  numIconPoints = 100\n  heatmapValueThresholdWall = 0.4\n  heatmapValueThresholdDoor = 0.4\n  heatmapValueThresholdIcon = 0.4\n  pass\n\n\nheatmaps = np.zeros((13, height, width))\nfor junctionType in xrange(13):\n  heatmap = cv2.imread(\'test/heatmaps/junction_heatmap_\' + str(junctionType + 1) + \'.png\', 0)\n  #heatmap = cv2.blur(heatmap, (5, 5))\n  heatmap = heatmap.astype(np.float32) / 255\n  heatmaps[junctionType] = heatmap\n  continue\n\nwallPoints = []\nfor junctionType in xrange(13):\n  #cv2.imwrite(\'test/heatmap_\' + str(junctionType) + \'.png\', (heatmaps[junctionType] * 255).astype(np.uint8))\n  points = extractLocalMaximum(heatmaps[junctionType], numWallPoints, [junctionType / 4, junctionType % 4], heatmapValueThresholdWall)\n  wallPoints += points\n  continue\n\naugmentedPointOffset = len(wallPoints)\nif not withoutQP:\n  wallPoints = augmentPoints(wallPoints)\n#print(wallPoints)\n\n\n\nwallLines, wallPointOrientationLinesMap, wallPointNeighbors = calcPointInfo(wallPoints, gap)\n#print(\'original number of walls: \' + str(len(wallLines)))\nif len(wallLines) > 150 and False:\n  wallPoints = []\n  for junctionType in xrange(13):\n    points = extractLocalMaximum(heatmaps[junctionType], numWallPoints, [junctionType / 4, junctionType % 4], heatmapValueThresholdWall)\n    wallPoints += points\n    continue\n  wallLines, wallPointOrientationLinesMap, wallPointNeighbors = calcPointInfo(wallPoints, gap)\n\nwallMask = drawLineMask(wallPoints, wallLines)\n\n\nfor orientation in xrange(4):\n  heatmap = cv2.imread(\'test/heatmaps/door_heatmap_\' + str(orientation + 1) + \'.png\', 0)\n  #heatmap = cv2.blur(heatmap, (5, 5))\n  heatmap = heatmap.astype(np.float32) / 255\n\n  heatmap *= wallMask\n  points = extractLocalMaximum(heatmap, numDoorPoints, [0, orientation], heatmapValueThresholdDoor)\n  doorPoints += points\n  continue\n\nfor orientation in xrange(4):\n  heatmap = cv2.imread(\'test/heatmaps/icon_heatmap_\' + str(orientation + 1) + \'.png\', 0)\n  #heatmap = cv2.blur(heatmap, (5, 5))\n  heatmap = heatmap.astype(np.float32) / 255\n\n  points = extractLocalMaximum(heatmap, numIconPoints, [1, orientation], heatmapValueThresholdIcon, True, 5, orientation)\n  iconPoints += points\n  continue\n\n#doorPoints = []\n#iconPoints = []\n\n\nlabelVotesMap = np.zeros((numLabels, height, width))\nlabelMap = np.zeros((numLabels, height, width))\nfor segmentIndex in xrange(numLabels):\n  segmentation_img = cv2.imread(\'test/segmentation/segment_\' + str(segmentIndex + 1) + \'.png\', 0)\n  #_, segmentation_img = cv2.threshold(segmentation_img, 127, 255, cv2.THRESH_BINARY)\n  #kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))\n  #segmentation_img = cv2.morphologyEx(segmentation_img, cv2.MORPH_CLOSE, kernel)\n\n  segmentation_img = segmentation_img.astype(np.float32) / 255\n  #segmentation_img = (segmentation_img > 0.5).astype(np.float)\n  labelVotesMap[segmentIndex] = segmentation_img\n  labelMap[segmentIndex] = segmentation_img\n  continue\n\nfor y in xrange(height):\n  for x in xrange(width):\n    if y == 0 and x > 0:\n      labelVotesMap[:, y, x] += labelVotesMap[:, y, x - 1]\n    elif x == 0 and y > 0:\n      labelVotesMap[:, y, x] += labelVotesMap[:, y - 1, x]\n    elif x > 0 and y > 0:\n      labelVotesMap[:, y, x] += labelVotesMap[:, y - 1, x] + labelVotesMap[:, y, x - 1] - labelVotesMap[:, y - 1, x - 1]\n      pass\n    continue\n  continue\n\n\n\ndoorLines, doorPointOrientationLinesMap, doorPointNeighbors = calcPointInfo(doorPoints, gap, True)\nicons = findIcons(iconPoints, gap, False)\n#icons = [icons[0]]\n#iconLines, iconPointOrientationLinesMap, iconPointNeighbors = calcPointInfo(iconPoints, gap, True)\n\nconflictWallLinePairs = findConflictLinePairs(wallPoints, wallLines, gap)\nconflictDoorLinePairs = findConflictLinePairs(doorPoints, doorLines, gap)\nconflictIconPairs = findConflictRectanglePairs(iconPoints, icons, gap)\n\n\nif withoutQP:\n\n  # wallEvidences = []\n  # for lineIndex, line in enumerate(wallLines):\n  #   point = wallPoints[line[0]]\n  #   neighborPoint = wallPoints[line[1]]\n  #   lineDim = calcLineDim(wallPoints, line)\n  #   fixedValue = int(round((neighborPoint[1 - lineDim] + point[1 - lineDim]) / 2))\n  #   wallEvidence = 0\n  #   for delta in xrange(int(abs(neighborPoint[lineDim] - point[lineDim]) + 1)):\n  #     intermediatePoint = [0, 0]\n  #     intermediatePoint[lineDim] = int(min(neighborPoint[lineDim], point[lineDim]) + delta)\n  #     intermediatePoint[1 - lineDim] = fixedValue\n  #     for typeIndex in xrange(numWallTypes):\n  #       wallEvidenceSum += labelMap[wallOffset + typeIndex][min(max(intermediatePoint[1], 0), height - 1)][min(max(intermediatePoint[0], 0), width - 1)]\n  #       continue\n  #     continue\n  #   wallEvidences.append(wallEvidenceSum)\n  #   continue\n\n  # invalidWalls = {}\n  # for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n  #   for orientation, lines in orientationLinesMap.iteritems():\n  #     maxEvidence = 0\n  #     maxEvidenceLineIndex = -1\n  #     for lineIndex in lines:\n  #       if wallEvidences[lineIndex] > maxEvidence:\n  #         maxEvidence = wallEvidences[lineIndex]\n  #         maxEvidenceLineIndex = lineIndex\n  #         pass\n  #       continue\n  #     for lineIndex in lines:\n  #       if lineIndex != maxEvidenceLineIndex:\n  #         invalidWalls[lineIndex] = True\n  #     continue\n  #   continue\n    # numValidOrientations = 0\n    # for orientation, lines in orientationLinesMap.iteritems():\n    #   for lineIndex in lines:\n    #     if lineIndex not in invalidWalls:\n    #       numValidOrientation += 1\n    #       break\n    #     continue\n    #   continue\n\n\n  filteredWallPoints = []\n  validPointMask = {}\n  for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n    if len(orientationLinesMap) == wallPoints[pointIndex][2] + 1:\n      filteredWallPoints.append(wallPoints[pointIndex])\n      validPointMask[pointIndex] = True\n      pass\n    continue\n\n  filteredWallLines= []\n  for wallLine in wallLines:\n    if wallLine[0] in validPointMask and wallLine[1] in validPointMask:\n      filteredWallLines.append(wallLine)\n      pass\n    continue\n\n  #adjustPoints(wallPoints, filteredWallLines)\n  writePoints(filteredWallPoints, [])\n\n  doorTypes = []\n  for lineIndex, line in enumerate(doorLines):\n    point = doorPoints[line[0]]\n    neighborPoint = doorPoints[line[1]]\n    lineDim = calcLineDim(doorPoints, line)\n    fixedValue = int(round((neighborPoint[1 - lineDim] + point[1 - lineDim]) / 2))\n    doorEvidenceSums = [0 for typeIndex in xrange(numDoorTypes)]\n    for delta in xrange(int(abs(neighborPoint[lineDim] - point[lineDim]) + 1)):\n      intermediatePoint = [0, 0]\n      intermediatePoint[lineDim] = int(min(neighborPoint[lineDim], point[lineDim]) + delta)\n      intermediatePoint[1 - lineDim] = fixedValue\n      for typeIndex in xrange(numDoorTypes):\n        doorEvidenceSums[typeIndex] += labelMap[doorOffset + typeIndex][min(max(intermediatePoint[1], 0), height - 1)][min(max(intermediatePoint[0], 0), width - 1)]\n        continue\n      continue\n    doorTypes.append((lineIndex, np.argmax(doorEvidenceSums), np.max(doorEvidenceSums)))\n    continue\n\n\n  doorTypesOri = copy.deepcopy(doorTypes)\n  doorTypes.sort(key=lambda doorType: doorType[2], reverse=True)\n\n\n  invalidDoors = {}\n  doorConflictMap = {}\n  for conflictPair in conflictDoorLinePairs:\n    if conflictPair[0] not in doorConflictMap:\n      doorConflictMap[conflictPair[0]] = []\n      pass\n    doorConflictMap[conflictPair[0]].append(conflictPair[1])\n\n    if conflictPair[1] not in doorConflictMap:\n      doorConflictMap[conflictPair[1]] = []\n      pass\n    doorConflictMap[conflictPair[1]].append(conflictPair[0])\n    continue\n\n\n  for index, doorType in enumerate(doorTypes):\n    break\n    doorIndex = doorType[0]\n    if doorIndex in invalidDoors:\n      continue\n    if doorIndex not in doorConflictMap:\n      continue\n    for otherIndex, otherDoorType in enumerate(doorTypes):\n      if otherIndex <= index:\n        continue\n      otherDoorIndex = otherDoorType[0]\n      if otherDoorIndex in doorConflictMap[doorIndex]:\n        invalidDoors[otherDoorIndex] = True\n        pass\n      continue\n    continue\n\n  filteredDoorLines = []\n  filteredDoorTypes = []\n  for doorIndex, door in enumerate(doorLines):\n    if doorIndex not in invalidDoors:\n      filteredDoorLines.append(door)\n      filteredDoorTypes.append(doorTypesOri[doorIndex][1])\n      pass\n    continue\n\n  filteredDoorWallMap = findLineMapSingle(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, gap / 2)\n  adjustDoorPoints(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, filteredDoorWallMap)\n  writeDoors(doorPoints, filteredDoorLines, filteredDoorTypes)\n\n\n  iconTypes = []\n  for iconIndex, icon in enumerate(icons):\n    iconEvidenceSums = []\n    point_1 = iconPoints[icon[0]]\n    point_2 = iconPoints[icon[1]]\n    point_3 = iconPoints[icon[2]]\n    point_4 = iconPoints[icon[3]]\n\n    x_1 = int((point_1[0] + point_3[0]) / 2)\n    x_2 = int((point_2[0] + point_4[0]) / 2)\n    y_1 = int((point_1[1] + point_2[1]) / 2)\n    y_2 = int((point_3[1] + point_4[1]) / 2)\n\n    iconArea = (x_2 - x_1) * (y_2 - y_1)\n    iconEvidenceSums = labelVotesMap[iconOffset:iconOffset + numIconTypes, y_2, x_2] + labelVotesMap[iconOffset:iconOffset + numIconTypes, y_1, x_1] - labelVotesMap[iconOffset:iconOffset + numIconTypes, y_2, x_1] - labelVotesMap[iconOffset:iconOffset + numIconTypes, y_1, x_2]\n    iconTypes.append((iconIndex, np.argmax(iconEvidenceSums), np.max(iconEvidenceSums) / iconArea))\n    continue\n\n  iconTypesOri = copy.deepcopy(iconTypes)\n  iconTypes.sort(key=lambda iconType: iconType[2], reverse=True)\n\n  invalidIcons = {}\n  iconConflictMap = {}\n  for conflictPair in conflictIconPairs:\n    if conflictPair[0] not in iconConflictMap:\n      iconConflictMap[conflictPair[0]] = []\n      pass\n    iconConflictMap[conflictPair[0]].append(conflictPair[1])\n\n    if conflictPair[1] not in iconConflictMap:\n      iconConflictMap[conflictPair[1]] = []\n      pass\n    iconConflictMap[conflictPair[1]].append(conflictPair[0])\n    continue\n\n\n  for index, iconType in enumerate(iconTypes):\n    break\n    iconIndex = iconType[0]\n    if iconIndex in invalidIcons:\n      continue\n    if iconIndex not in iconConflictMap:\n      continue\n    for otherIndex, otherIconType in enumerate(iconTypes):\n      if otherIndex <= index:\n        continue\n      otherIconIndex = otherIconType[0]\n      if otherIconIndex in iconConflictMap[iconIndex]:\n        invalidIcons[otherIconIndex] = True\n        pass\n      continue\n    continue\n\n\n\n  filteredIcons = []\n  filteredIconTypes = []\n  for iconIndex, icon in enumerate(icons):\n    if iconIndex not in invalidIcons:\n      filteredIcons.append(icon)\n      filteredIconTypes.append(iconTypesOri[iconIndex][1])\n      pass\n    continue\n\n\n\n  #conflictIconPairs = findConflictRectanglePairs(iconPoints, filteredIcons, gap)\n  writeIcons(iconPoints, filteredIcons, filteredIconTypes)\n\n  drawLines(\'test/lines.png\', width, height, wallPoints, wallLines)\n  drawLines(\'test/doors.png\', width, height, doorPoints, doorLines)\n  drawRectangles(\'test/icons.png\', width, height, iconPoints, icons, {}, 2, floorplan)\n  print(\'number of walls: \' + str(len(wallLines)))\n  print(\'number of doors: \' + str(len(doorLines)))\n  print(\'number of icons: \' + str(len(icons)))\n  exit(1)\n\n\nif False:\n  #lines = [51]\n  #filteredWallLines = []\n\n  for lineIndex, line in enumerate(doorLines):\n    #print(wallLines[lineIndex])\n    #filteredWallLines.append(wallLines[lineIndex])\n    #continue\n    drawLines(\'test/doors/line_\' + str(lineIndex) + \'.png\', width, height, doorPoints, [line])\n    continue\n\n  for lineIndex, line in enumerate(wallLines):\n    #print(wallLines[lineIndex])\n    #filteredWallLines.append(wallLines[lineIndex])\n    #continue\n    drawLines(\'test/lines/line_\' + str(lineIndex) + \'.png\', width, height, wallPoints, [line], [])\n    continue\n  exit(1)\n  pass\n\n\nwallLineNeighbors = findLineNeighbors(wallPoints, wallLines, gap)\n#iconWallLineNeighbors = findLineNeighborsCross(iconPoints, iconLines, wallPoints, wallLines, wallLineNeighbors, gap)\niconWallLineNeighbors = findRectangleLineNeighbors(iconPoints, icons, wallPoints, wallLines, wallLineNeighbors, gap, gap * 2)\n\ndoorWallLineMap = findLineMap(doorPoints, doorLines, wallPoints, wallLines, gap / 2)\n\n\nnewDoorLines = []\nnewDoorWallLineMap = []\nfor lineIndex, walls in enumerate(doorWallLineMap):\n  if len(walls) > 0:\n    newDoorLines.append(doorLines[lineIndex])\n    newDoorWallLineMap.append(walls)\n    pass\n  continue\ndoorLines = newDoorLines\ndoorWallLineMap = newDoorWallLineMap\nconflictDoorLinePairs = findConflictLinePairs(doorPoints, doorLines, gap)\n\nconflictIconWallPairs = findConflictRectangleLinePairs(iconPoints, icons, wallPoints, wallLines, gap)\n\nexteriorLines = {}\nfor lineIndex, neighbors in enumerate(wallLineNeighbors):\n  if len(neighbors[0]) == 0 and len(neighbors[1]) > 0:\n    exteriorLines[lineIndex] = 0\n  elif len(neighbors[0]) > 0 and len(neighbors[1]) == 0:\n    exteriorLines[lineIndex] = 1\n    pass\n  continue\n\n\n\nif True:\n  drawLines(\'test/lines.png\', width, height, wallPoints, wallLines, [], None, 2)\n  drawLines(\'test/doors.png\', width, height, doorPoints, doorLines, [], None, 2)\n  drawRectangles(\'test/icons.png\', width, height, iconPoints, icons, {}, 2)\n  print(\'number of walls: \' + str(len(wallLines)))\n  print(\'number of doors: \' + str(len(doorLines)))\n  print(\'number of icons: \' + str(len(icons)))\n  #exit(1)\n  pass\n\n\nif False:\n  for i in xrange(2):\n    print(wallLineNeighbors[43][i].keys())\n    print(wallLineNeighbors[81][i].keys())\n    print(wallLineNeighbors[84][i].keys())\n  exit(1)\n  filteredWallLines = []\n  for lineIndex, neighbors in enumerate(wallLineNeighbors):\n    if len(neighbors[0]) == 0 and len(neighbors[1]) > 0:\n      print(lineIndex)\n      filteredWallLines.append(wallLines[lineIndex])\n      pass\n    continue\n  drawLines(\'test/exterior_1.png\', width, height, wallPoints, filteredWallLines)\n\n  filteredWallLines = []\n  for lineIndex, neighbors in enumerate(wallLineNeighbors):\n    if len(neighbors[0]) > 0 and len(neighbors[1]) == 0:\n      print(lineIndex)\n      filteredWallLines.append(wallLines[lineIndex])\n      pass\n    continue\n  drawLines(\'test/exterior_2.png\', width, height, wallPoints, filteredWallLines)\n  exit(1)\n  pass\n\n\n\ntry:\n  model = Model(""JunctionFilter"")\n\n  #add variables\n  w_p = [model.addVar(vtype = GRB.BINARY, name=""point_"" + str(pointIndex)) for pointIndex in xrange(len(wallPoints))]\n  w_l = [model.addVar(vtype = GRB.BINARY, name=""line_"" + str(lineIndex)) for lineIndex in xrange(len(wallLines))]\n\n  d_l = [model.addVar(vtype = GRB.BINARY, name=""door_line_"" + str(lineIndex)) for lineIndex in xrange(len(doorLines))]\n\n  i_r = [model.addVar(vtype = GRB.BINARY, name=""icon_rectangle_"" + str(lineIndex)) for lineIndex in xrange(len(icons))]\n\n  i_types = []\n  for iconIndex in xrange(len(icons)):\n    i_types.append([model.addVar(vtype = GRB.BINARY, name=""icon_type_"" + str(iconIndex) + ""_"" + str(typeIndex)) for typeIndex in xrange(numIconTypes)])\n    continue\n\n  l_dir_labels = []\n  for lineIndex in xrange(len(wallLines)):\n    dir_labels = []\n    for direction in xrange(2):\n      labels = []\n      for label in xrange(numRoomTypes):\n        labels.append(model.addVar(vtype = GRB.BINARY, name=""line_"" + str(lineIndex) + ""_"" + str(direction) + ""_"" + str(label)))\n      dir_labels.append(labels)\n    l_dir_labels.append(dir_labels)\n\n\n\n  #model.update()\n  obj = QuadExpr()\n\n\n  #label sum constraints\n  for lineIndex in xrange(len(wallLines)):\n    for direction in xrange(2):\n      labelSum = LinExpr()\n      for label in xrange(numRoomTypes):\n        labelSum += l_dir_labels[lineIndex][direction][label]\n        continue\n      model.addConstr(labelSum == w_l[lineIndex], \'label sum\')\n      continue\n    continue\n\n\n  # #opposite label constraints\n  # singleRooms = {}\n  # for label in xrange(numRoomTypes):\n  #   singleRooms[label] = True\n  #   continue\n  # singleRooms[1] = False\n  # singleRooms[2] = False\n  # singleRooms[3] = False\n  # singleRooms[7] = False\n  # singleRooms[9] = False\n\n  # for label in xrange(numRoomTypes):\n  #   if not singleRooms[label]:\n  #     continue\n  #   for lineIndex in xrange(len(wallLines)):\n  #     model.addConstr(l_dir_labels[lineIndex][0][label] + l_dir_labels[lineIndex][1][label] <= 1, \'single room\')\n  #     continue\n\n\n\n  #loop constraints\n  closeRooms = {}\n  for label in xrange(numRoomTypes):\n    closeRooms[label] = True\n  closeRooms[1] = False\n  closeRooms[2] = False\n  #closeRooms[3] = False\n  closeRooms[8] = False\n  closeRooms[9] = False\n\n  for label in xrange(numRoomTypes):\n    if not closeRooms[label]:\n      continue\n    for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n      for orientation, lines in orientationLinesMap.iteritems():\n        direction = int(orientation in [1, 2])\n        lineSum = LinExpr()\n        for lineIndex in lines:\n          lineSum += l_dir_labels[lineIndex][direction][label]\n          continue\n        for nextOrientation in xrange(orientation + 1, 8):\n          if not (nextOrientation % 4) in orientationLinesMap:\n            continue\n          nextLines = orientationLinesMap[nextOrientation % 4]\n          nextDirection = int((nextOrientation % 4) in [0, 3])\n          nextLineSum = LinExpr()\n          for nextLineIndex in nextLines:\n            nextLineSum += l_dir_labels[nextLineIndex][nextDirection][label]\n            continue\n          model.addConstr(lineSum == nextLineSum)\n          break\n        continue\n      continue\n    continue\n\n\n\n  #exteriorConstraints\n  exteriorLineSum = LinExpr()\n  for lineIndex in xrange(len(wallLines)):\n    if lineIndex not in exteriorLines:\n      continue\n    #direction = exteriorLines[lineIndex]\n    label = 0\n    model.addConstr(l_dir_labels[lineIndex][0][label] + l_dir_labels[lineIndex][1][label] == w_l[lineIndex], \'exterior wall\')\n    exteriorLineSum += w_l[lineIndex]\n    continue\n  model.addConstr(exteriorLineSum >= 1, \'exterior wall sum\')\n\n\n  #line label constraints and objectives\n  for lineIndex, directionNeighbors in enumerate(wallLineNeighbors):\n    for direction, neighbors in enumerate(directionNeighbors):\n      labelVotesSum = np.zeros(numRoomTypes)\n      for neighbor, labelVotes in neighbors.iteritems():\n        labelVotesSum[1:numRoomTypes] += labelVotes[:numRoomTypes - 1]\n        continue\n\n      votesSum = labelVotesSum.sum()\n      if votesSum == 0:\n        continue\n      labelVotesSum /= votesSum\n\n\n      for label in xrange(numRoomTypes):\n        obj += l_dir_labels[lineIndex][direction][label] * (0.0 - labelVotesSum[label]) * labelWeight\n        continue\n      continue\n    continue\n\n\n\n  #data terms\n  #print(augmentedPointOffset)\n  #print(len(wallPoints))\n\n  for pointIndex in xrange(len(wallPoints)):\n    if pointIndex < augmentedPointOffset:\n      obj += (1 - w_p[pointIndex]) * junctionWeight #* len(wallPointOrientationLinesMap[pointIndex])\n    else:\n      obj += w_p[pointIndex] * augmentedJunctionWeight #* len(wallPointOrientationLinesMap[pointIndex])\n    continue\n\n  #door endpoint constraints\n  pointDoorsMap = {}\n  for doorIndex, line in enumerate(doorLines):\n    for endpointIndex in xrange(2):\n      pointIndex = line[endpointIndex]\n      if pointIndex not in pointDoorsMap:\n        pointDoorsMap[pointIndex] = []\n        pass\n      pointDoorsMap[pointIndex].append(doorIndex)\n      continue\n    continue\n\n\n  for pointIndex, doorIndices in pointDoorsMap.iteritems():\n    doorSum = LinExpr(0)\n    for doorIndex in doorIndices:\n      doorSum += d_l[doorIndex]\n      continue\n    obj += (1 - doorSum) * junctionWeight\n    #model.addConstr(doorSum <= 1, ""door_line_sum_"" + str(pointIndex) + ""_"" + str(orientation))\n    continue\n\n\n\n  #icon corner constraints\n  pointIconsMap = {}\n  for iconIndex, icon in enumerate(icons):\n    for cornerIndex in xrange(4):\n      pointIndex = icon[cornerIndex]\n      if pointIndex not in pointIconsMap:\n        pointIconsMap[pointIndex] = []\n        pass\n      pointIconsMap[pointIndex].append(iconIndex)\n      continue\n    continue\n  #print(pointIconsMap)\n\n  for pointIndex, iconIndices in pointIconsMap.iteritems():\n    iconSum = LinExpr(0)\n    for iconIndex in iconIndices:\n      iconSum += i_r[iconIndex]\n      continue\n    obj += (1 - iconSum) * junctionWeight\n    continue\n\n\n\n  gapWeight = 1\n  pixelEvidenceWeight = 1\n\n  for lineIndex, line in enumerate(wallLines):\n    point = wallPoints[line[0]]\n    neighborPoint = wallPoints[line[1]]\n    lineDim = calcLineDim(wallPoints, line)\n    wallCost = (abs(neighborPoint[1 - lineDim] - point[1 - lineDim]) / gap - 0.5) * gapWeight\n    #obj += w_l[lineIndex] * wallCost * wallWeight\n\n    fixedValue = int(round((neighborPoint[1 - lineDim] + point[1 - lineDim]) / 2))\n    wallEvidenceSums = [0, 0]\n    for delta in xrange(int(abs(neighborPoint[lineDim] - point[lineDim]) + 1)):\n      intermediatePoint = [0, 0]\n      intermediatePoint[lineDim] = int(min(neighborPoint[lineDim], point[lineDim]) + delta)\n      intermediatePoint[1 - lineDim] = fixedValue\n      for typeIndex in xrange(numWallTypes):\n        wallEvidenceSums[typeIndex] += labelMap[wallOffset + typeIndex][min(max(intermediatePoint[1], 0), height - 1)][min(max(intermediatePoint[0], 0), width - 1)]\n        continue\n      continue\n    wallEvidenceSum = wallEvidenceSums[0] + wallEvidenceSums[1]\n\n    wallEvidenceSum /= maxDim\n    obj += -wallEvidenceSum * w_l[lineIndex] * wallWeight\n\n\n\n  for lineIndex, line in enumerate(doorLines):\n    #obj += -d_l[lineIndex] * doorWeight * abs(neighborPoint[lineDim] - point[lineDim] + 1) / maxDim\n    #continue\n\n    point = doorPoints[line[0]]\n    neighborPoint = doorPoints[line[1]]\n    lineDim = calcLineDim(doorPoints, line)\n    #doorCost = (abs(neighborPoint[1 - lineDim] - point[1 - lineDim]) / gap - 1) * gapWeight\n    #obj += d_l[lineIndex] * doorCost * doorWeight\n\n    fixedValue = int(round((neighborPoint[1 - lineDim] + point[1 - lineDim]) / 2))\n    #doorEvidenceSums = [0 for typeIndex in xrange(numDoorTypes)]\n    doorEvidenceSum = 0\n\n    for delta in xrange(int(abs(neighborPoint[lineDim] - point[lineDim]) + 1)):\n      intermediatePoint = [0, 0]\n      intermediatePoint[lineDim] = int(min(neighborPoint[lineDim], point[lineDim]) + delta)\n      intermediatePoint[1 - lineDim] = fixedValue\n\n      doorEvidenceSum += np.sum(labelMap[doorOffset:doorOffset + numDoorTypes, min(max(intermediatePoint[1], 0), height - 1), min(max(intermediatePoint[0], 0), width - 1)])\n      #doorEvidenceSum += float(np.sum(labelMap[doorOffset:doorOffset + numDoorTypes, min(max(intermediatePoint[1], 0), height - 1), min(max(intermediatePoint[0], 0), width - 1)]) > 0.5) * 2 - 1\n      continue\n\n    doorEvidenceSum /= maxDim\n    obj += -doorEvidenceSum * d_l[lineIndex] * doorWeight\n\n\n  for iconIndex, icon in enumerate(icons):\n    point_1 = iconPoints[icon[0]]\n    point_2 = iconPoints[icon[1]]\n    point_3 = iconPoints[icon[2]]\n    point_4 = iconPoints[icon[3]]\n\n    x_1 = int((point_1[0] + point_3[0]) / 2)\n    x_2 = int((point_2[0] + point_4[0]) / 2)\n    y_1 = int((point_1[1] + point_2[1]) / 2)\n    y_2 = int((point_3[1] + point_4[1]) / 2)\n\n    iconArea = (x_2 - x_1) * (y_2 - y_1)\n    iconEvidenceSums = labelVotesMap[iconOffset:iconOffset + numIconTypes, y_2, x_2] + labelVotesMap[iconOffset:iconOffset + numIconTypes, y_1, x_1] - labelVotesMap[iconOffset:iconOffset + numIconTypes, y_2, x_1] - labelVotesMap[iconOffset:iconOffset + numIconTypes, y_1, x_2]\n\n\n    for typeIndex in xrange(numIconTypes):\n      iconRatio = iconEvidenceSums[typeIndex] / iconArea\n      if iconRatio < 0.5 and False:\n        model.addConstr(i_types[iconIndex][typeIndex] == 0)\n      else:\n        obj += i_types[iconIndex][typeIndex] * (0 - iconEvidenceSums[typeIndex] / iconArea) * iconTypeWeight\n      continue\n    continue\n\n\n  for iconIndex in xrange(len(icons)):\n    typeSum = LinExpr(0)\n    for typeIndex in xrange(numIconTypes):\n      typeSum += i_types[iconIndex][typeIndex]\n      continue\n    model.addConstr(typeSum == i_r[iconIndex])\n    continue\n\n\n\n  # #icon wall constraints\n  # iconWallTypesMap = {}\n  # iconWallTypesMap[0] = (4, )\n  # iconWallTypesMap[1] = (1, 2, 3)\n  # iconWallTypesMap[2] = (4, 5)\n  # iconWallTypesMap[3] = (1, 2, 3, 8)\n  # iconWallTypesMap[4] = (4, 5, 8, 9)\n  # iconWallTypesMap[5] = (1, 2, 3, 4, 5, 6, 8, 9)\n  # iconWallTypesMap[6] = (1, 2, 3, 4, 5, 6, 8, 9)\n  # #iconWallTypesMap[7] = (1, 2, 6, 10)\n  # iconWallTypesMap[9] = (1, 2, 3, 8)\n\n  # #print(iconWallLineNeighbors[8])\n  # for iconIndex, lines in enumerate(iconWallLineNeighbors):\n  #   for typeIndex in xrange(numIconTypes):\n  #     if typeIndex not in iconWallTypesMap:\n  #       continue\n  #     wallSum = LinExpr()\n  #     for wallType in iconWallTypesMap[typeIndex]:\n  #       for lineIndex, direction in lines.iteritems():\n  #         wallSum += l_dir_labels[lineIndex][direction][wallType]\n  #         continue\n  #       continue\n  #     model.addConstr(i_types[iconIndex][typeIndex] <= wallSum)\n  #     continue\n  #   continue\n\n\n  #line sum constraints and objectives\n  for pointIndex, orientationLinesMap in enumerate(wallPointOrientationLinesMap):\n    pointLineSum = LinExpr(0)\n    for orientation, lines in orientationLinesMap.iteritems():\n      #if len(lines) > 1:\n      #print(lines)\n      lineSum = LinExpr(0)\n      for lineIndex in lines:\n        lineSum += w_l[lineIndex]\n        continue\n\n      model.addConstr(lineSum == w_p[pointIndex], ""line_sum_"" + str(pointIndex) + ""_"" + str(orientation))\n      #obj += (w_p[pointIndex] - lineSum) * junctionLineWeight\n      #obj += (1 - lineSum) * junctionWeight\n      pointLineSum += lineSum\n      continue\n\n    #if wallPoints[pointIndex][2] > 0:\n    #model.addConstr(pointLineSum >= wallPoints[pointIndex][2] * w_p[pointIndex], \'point line sum\')\n      #model.addConstr(pointLineSum >= 2 * w_p[pointIndex], \'point line sum\')\n      #pass\n\n    continue\n\n\n  #close points constraints\n  for pointIndex, point in enumerate(wallPoints):\n    for neighborPointIndex, neighborPoint in enumerate(wallPoints):\n      if neighborPointIndex <= pointIndex:\n        continue\n      distance = pow(pow(point[0] - neighborPoint[0], 2) + pow(point[1] - neighborPoint[1], 2), 0.5)\n      if distance < gap and neighborPointIndex not in wallPointNeighbors[pointIndex]:\n        #obj += p[pointIndex] * p[neighborPointIndex] * closePointWeight\n        model.addConstr(w_p[pointIndex] + w_p[neighborPointIndex] <= 1, \'close point\')\n        pass\n      continue\n    continue\n\n\n  #conflict pair constraints\n  for conflictLinePair in conflictWallLinePairs:\n    model.addConstr(w_l[conflictLinePair[0]] + w_l[conflictLinePair[1]] <= 1, \'conflict wall line pair\')\n\n  for conflictLinePair in conflictDoorLinePairs:\n    model.addConstr(d_l[conflictLinePair[0]] + d_l[conflictLinePair[1]] <= 1, \'conflict door line pair\')\n\n  for conflictIconPair in conflictIconPairs:\n    model.addConstr(i_r[conflictIconPair[0]] + i_r[conflictIconPair[1]] <= 1, \'conflict icon pair\')\n\n  for conflictLinePair in conflictIconWallPairs:\n    model.addConstr(i_r[conflictLinePair[0]] + w_l[conflictLinePair[1]] <= 1, \'conflict icon wall pair\')\n\n\n  #door wall line map constraints\n  for doorIndex, lines in enumerate(doorWallLineMap):\n    if len(lines) == 0:\n      model.addConstr(d_l[doorIndex] == 0, \'door not on walls\')\n      continue\n    lineSum = LinExpr(0)\n    for lineIndex in lines:\n      lineSum += w_l[lineIndex]\n      continue\n    model.addConstr(d_l[doorIndex] <= lineSum, \'d <= line sum\')\n    continue\n\n\n\n\n  if False:\n    #print(conflictWallLinePairs)\n    model.addConstr(w_l[1] == 1)\n    #model.addConstr(d_l[3] == 1)\n    #print(wallLines[90])\n    #print(wallLines[62])\n    #print(wallLines[73])\n    #print(wallLines[107])\n    #print(wallLines[111])\n    #print(wallPointOrientationLinesMap[wallLines[0][0]])\n    #print(wallPointOrientationLinesMap[wallLines[111][1]])\n    #print(wallPointOrientationLinesMap[25])\n    #print(wallLines[])\n    #exit(1)\n    #model.addConstr(d_l[8] == 1)\n    #model.addConstr(i_types[8][1] == 1)\n    #model.addConstr(l_dir_labels[39][1][7] == 1)\n    #exit(1)\n\n  model.setObjective(obj, GRB.MINIMIZE)\n  model.update()\n  model.setParam(\'TimeLimit\', 60)\n  model.optimize()\n\n  if model.status == GRB.Status.INF_OR_UNBD:\n    # Turn presolve off to determine whether model is infeasible\n    # or unbounded\n    model.setParam(GRB.Param.Presolve, 0)\n    model.optimize()\n\n  model.write(\'test/model.lp\')\n  #print(model.status)\n  if model.status == GRB.Status.OPTIMAL:\n    filteredWallLines = []\n    filteredWallLabels = []\n    filteredWallTypes = []\n    wallPointLabels = [[-1, -1, -1, -1] for pointIndex in xrange(len(wallPoints))]\n\n    for lineIndex, lineVar in enumerate(w_l):\n      if lineVar.x < 0.5:\n        continue\n      filteredWallLines.append(wallLines[lineIndex])\n\n      filteredWallTypes.append(0)\n\n      labels = [11, 11]\n      for direction in xrange(2):\n        for label in xrange(numRoomTypes):\n          if l_dir_labels[lineIndex][direction][label].x > 0.5:\n            labels[direction] = label\n            break\n          continue\n        continue\n\n      filteredWallLabels.append(labels)\n      print(\'wall\', lineIndex, labels)\n      line = wallLines[lineIndex]\n      lineDim = calcLineDim(wallPoints, line)\n      if lineDim == 0:\n        wallPointLabels[line[0]][0] = labels[0]\n        wallPointLabels[line[0]][1] = labels[1]\n        wallPointLabels[line[1]][3] = labels[0]\n        wallPointLabels[line[1]][2] = labels[1]\n      else:\n        wallPointLabels[line[0]][1] = labels[0]\n        wallPointLabels[line[0]][2] = labels[1]\n        wallPointLabels[line[1]][0] = labels[0]\n        wallPointLabels[line[1]][3] = labels[1]\n        pass\n      continue\n\n    adjustPoints(wallPoints, filteredWallLines)\n    drawLines(\'test/result_line.png\', width, height, wallPoints, filteredWallLines, filteredWallLabels)\n    resultImage = drawLines(\'\', width, height, wallPoints, filteredWallLines, filteredWallLabels, None, 10)\n\n    filteredDoorLines = []\n    filteredDoorTypes = []\n    for lineIndex, lineVar in enumerate(d_l):\n      if lineVar.x < 0.5:\n        continue\n      print((\'door\', lineIndex))\n      filteredDoorLines.append(doorLines[lineIndex])\n\n      filteredDoorTypes.append(0)\n      continue\n\n    filteredDoorWallMap = findLineMapSingle(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, gap / 2)\n    adjustDoorPoints(doorPoints, filteredDoorLines, wallPoints, filteredWallLines, filteredDoorWallMap)\n    drawLines(\'test/result_door.png\', width, height, doorPoints, filteredDoorLines)\n\n    filteredIcons = []\n    filteredIconTypes = []\n    for iconIndex, iconVar in enumerate(i_r):\n      if iconVar.x < 0.5:\n        continue\n\n\n      filteredIcons.append(icons[iconIndex])\n      iconType = -1\n      for typeIndex in xrange(numIconTypes):\n        if i_types[iconIndex][typeIndex].x > 0.5:\n          iconType = typeIndex\n          break\n        continue\n\n      print((\'icon\', iconIndex, iconType))\n\n      filteredIconTypes.append(iconType)\n      continue\n\n    #adjustPoints(iconPoints, filteredIconLines)\n    #drawLines(\'test/lines_results_icon.png\', width, height, iconPoints, filteredIconLines)\n    drawRectangles(\'test/result_icon.png\', width, height, iconPoints, filteredIcons, filteredIconTypes)\n\n\n    #resultImage = drawLines(\'\', width, height, doorPoints, filteredDoorLines, [], resultImage, 4, 255)\n    #resultImage = drawRectangles(\'\', width, height, iconPoints, filteredIcons, filteredIconTypes, 2, resultImage)\n    cv2.imwrite(\'test/result.png\', resultImage)\n\n\n    filteredWallPoints = []\n    filteredWallPointLabels = []\n    orientationMap = {}\n    for pointType, orientationOrientations in enumerate(pointOrientations):\n      for orientation, orientations in enumerate(orientationOrientations):\n        orientationMap[orientations] = orientation\n\n    for pointIndex, point in enumerate(wallPoints):\n      #if w_p[pointIndex].x < 0.5:\n      #continue\n\n      orientations = []\n      for orientation, lines in wallPointOrientationLinesMap[pointIndex].iteritems():\n        orientationLine = -1\n        for lineIndex in lines:\n          if w_l[lineIndex].x > 0.5:\n            orientations.append(orientation)\n            break\n          continue\n        continue\n\n      if len(orientations) == 0:\n        continue\n\n      if len(orientations) < len(wallPointOrientationLinesMap[pointIndex]):\n        print(pointIndex)\n        print(wallPoints[pointIndex])\n        wallPoints[pointIndex][2] = len(orientations) - 1\n        orientations = tuple(orientations)\n        if orientations not in orientationMap:\n          continue\n        wallPoints[pointIndex][3] = orientationMap[orientations]\n        print(wallPoints[pointIndex])\n\n\n      filteredWallPoints.append(wallPoints[pointIndex])\n      filteredWallPointLabels.append(wallPointLabels[pointIndex])\n\n\n    writePoints(filteredWallPoints, filteredWallPointLabels)\n\n\n    with open(\'test/floorplan.txt\', \'w\') as result_file:\n      result_file.write(str(width) + \'\\t\' + str(height) + \'\\n\')\n      result_file.write(str(len(filteredWallLines)) + \'\\n\')\n      for wallIndex, wall in enumerate(filteredWallLines):\n        point_1 = wallPoints[wall[0]]\n        point_2 = wallPoints[wall[1]]\n\n        #result_file.write(str(int(round(point_1[0]))) + \'\\t\' + str(int(round(point_1[1]))) + \'\\t\')\n        #result_file.write(str(int(round(point_2[0]))) + \'\\t\' + str(int(round(point_2[1]))) + \'\\t\')\n        result_file.write(str(point_1[0]) + \'\\t\' + str(point_1[1]) + \'\\t\')\n        result_file.write(str(point_2[0]) + \'\\t\' + str(point_2[1]) + \'\\t\')\n        result_file.write(str(filteredWallLabels[wallIndex][0]) + \'\\t\' + str(filteredWallLabels[wallIndex][1]) + \'\\n\')\n\n      for doorIndex, door in enumerate(filteredDoorLines):\n        point_1 = doorPoints[door[0]]\n        point_2 = doorPoints[door[1]]\n\n        #result_file.write(str(int(round(point_1[0]))) + \'\\t\' + str(int(round(point_1[1]))) + \'\\t\')\n        #result_file.write(str(int(round(point_2[0]))) + \'\\t\' + str(int(round(point_2[1]))) + \'\\t\')\n        result_file.write(str(point_1[0]) + \'\\t\' + str(point_1[1]) + \'\\t\')\n        result_file.write(str(point_2[0]) + \'\\t\' + str(point_2[1]) + \'\\t\')\n        result_file.write(\'door\\t\')\n        result_file.write(str(filteredDoorTypes[doorIndex] + 1) + \'\\t1\\n\')\n\n      for iconIndex, icon in enumerate(filteredIcons):\n        point_1 = iconPoints[icon[0]]\n        point_2 = iconPoints[icon[1]]\n        point_3 = iconPoints[icon[2]]\n        point_4 = iconPoints[icon[3]]\n\n        # x_1 = int(round((point_1[0] + point_3[0]) / 2))\n        # x_2 = int(round((point_2[0] + point_4[0]) / 2))\n        # y_1 = int(round((point_1[1] + point_2[1]) / 2))\n        # y_2 = int(round((point_3[1] + point_4[1]) / 2))\n        x_1 = int((point_1[0] + point_3[0]) / 2)\n        x_2 = int((point_2[0] + point_4[0]) / 2)\n        y_1 = int((point_1[1] + point_2[1]) / 2)\n        y_2 = int((point_3[1] + point_4[1]) / 2)\n\n        result_file.write(str(x_1) + \'\\t\' + str(y_1) + \'\\t\')\n        result_file.write(str(x_2) + \'\\t\' + str(y_2) + \'\\t\')\n        result_file.write(iconNumberNameMap[filteredIconTypes[iconIndex]] + \'\\t\')\n        result_file.write(str(iconNumberStyleMap[filteredIconTypes[iconIndex]]) + \'\\t\')\n        result_file.write(\'1\\n\')\n\n      result_file.close()\n\n\n    if len(filteredDoorLines) > 0:\n      writeDoors(doorPoints, filteredDoorLines, filteredDoorTypes)\n      pass\n    else:\n      try:\n        os.remove(\'test/doors_out.txt\')\n      except OSError:\n        pass\n\n    if len(filteredIcons) > 0:\n      writeIcons(iconPoints, filteredIcons, filteredIconTypes)\n      pass\n    else:\n      try:\n        os.remove(\'test/icons_out.txt\')\n      except OSError:\n        pass\n      pass\n\n\n\n  elif model.status != GRB.Status.INFEASIBLE:\n    print(\'Optimization was stopped with status %d\' % model.status)\n  else:\n    print(\'infeasible\')\n    #model.ComputeIIS()\n    #model.write(""test/model.ilp"")\n\nexcept GurobiError as e:\n  print(\'Error code \' + str(e.errno) + "": "" + str(e))\n\nexcept AttributeError:\n  print(\'Encountered an attribute error\')\n'"
pytorch/datasets/floorplan_dataset.py,1,"b""from torch.utils.data import Dataset\n\nimport numpy as np\nimport time\n\n#from plane_dataset_scannet import PlaneDatasetScanNet\n#from augmentation import *\nfrom utils import *\nfrom skimage import measure\nimport cv2\nimport copy\n\n\ndef lineRange(line):\n    direction = calcLineDirection(line)\n    fixedValue = (line[0][1 - direction] + line[1][1 - direction]) // 2\n    minValue = min(line[0][direction], line[1][direction])\n    maxValue = max(line[0][direction], line[1][direction])\n    return direction, fixedValue, minValue, maxValue\n\ndef pointDistance(point_1, point_2):\n    #return np.sqrt(pow(point_1[0] - point_2[0], 2) + pow(point_1[1] - point_2[1], 2))\n    return max(abs(point_1[0] - point_2[0]), abs(point_1[1] - point_2[1]))\n\ndef divideWalls(walls):\n    horizontalWalls = []\n    verticalWalls = []\n    for wall in walls:\n        if calcLineDirection(wall) == 0:\n            horizontalWalls.append(wall)\n        else:\n            verticalWalls.append(wall)\n            pass\n        continue\n    return horizontalWalls, verticalWalls\n\ndef mergeLines(line_1, line_2):\n    direction_1, fixedValue_1, min_1, max_1 = lineRange(line_1)\n    direction_2, fixedValue_2, min_2, max_2 = lineRange(line_2)\n    fixedValue = (fixedValue_1 + fixedValue_2) // 2\n    if direction_1 == 0:\n        return [(min(min_1, min_2), fixedValue), (max(max_1, max_2), fixedValue)]\n    else:\n        return [(fixedValue, min(min_1, min_2)), (fixedValue, max(max_1, max_2))]\n    return\n\ndef findConnections(line_1, line_2, gap):\n    connection_1 = -1\n    connection_2 = -1\n    pointConnected = False\n    for c_1 in range(2):\n        if pointConnected:\n            break\n        for c_2 in range(2):\n            if pointDistance(line_1[c_1], line_2[c_2]) > gap:\n                continue\n\n            connection_1 = c_1\n            connection_2 = c_2\n            connectionPoint = ((line_1[c_1][0] + line_2[c_2][0]) // 2, (line_1[c_1][1] + line_2[c_2][1]) // 2)\n            pointConnected = True\n            break\n        continue\n    if pointConnected:\n        return [connection_1, connection_2], connectionPoint\n    direction_1, fixedValue_1, min_1, max_1 = lineRange(line_1)\n    direction_2, fixedValue_2, min_2, max_2 = lineRange(line_2)\n    if direction_1 == direction_2:\n        return [-1, -1], (0, 0)\n\n    #print(fixedValue_1, min_1, max_1, fixedValue_2, min_2, max_2)\n    if min(fixedValue_1, max_2) < max(fixedValue_1, min_2) - gap or min(fixedValue_2, max_1) < max(fixedValue_2, min_1) - gap:\n        return [-1, -1], (0, 0)\n\n    if abs(min_1 - fixedValue_2) <= gap:\n        return [0, 2], (fixedValue_2, fixedValue_1)\n    if abs(max_1 - fixedValue_2) <= gap:\n        return [1, 2], (fixedValue_2, fixedValue_1)\n    if abs(min_2 - fixedValue_1) <= gap:\n        return [2, 0], (fixedValue_2, fixedValue_1)\n    if abs(max_2 - fixedValue_1) <= gap:\n        return [2, 1], (fixedValue_2, fixedValue_1)\n    return [2, 2], (fixedValue_2, fixedValue_1)\n\ndef lines2Corners(lines, gap):\n    success = True\n    corners = []\n    lineConnections = []\n    for _ in range(len(lines)):\n        lineConnections.append({})\n        continue\n\n    connectionCornerMap = {}\n    connectionCornerMap[(1, 1)] = 4\n    connectionCornerMap[(0, 1)] = 5\n    connectionCornerMap[(0, 0)] = 6\n    connectionCornerMap[(1, 0)] = 7\n    connectionCornerMap[(2, 0)] = 8\n    connectionCornerMap[(1, 2)] = 9\n    connectionCornerMap[(2, 1)] = 10\n    connectionCornerMap[(0, 2)] = 11\n    connectionCornerMap[(2, 2)] = 12\n    corners = []\n    for lineIndex_1, line_1 in enumerate(lines):\n        for lineIndex_2, line_2 in enumerate(lines):\n            if lineIndex_2 == lineIndex_1:\n                continue\n            connections, connectionPoint = findConnections(line_1, line_2, gap=gap)\n            if connections[0] == -1 and connections[1] == -1:\n                continue\n            if calcLineDirection(line_1) == calcLineDirection(line_2) and isManhattan(line_1) and isManhattan(line_2):\n                #print('overlap', line_1, line_2, connections)\n                success = False\n                #exit(1)                \n                continue\n            if calcLineDirection(line_1) == 1:\n                continue\n\n            indices = [lineIndex_1, lineIndex_2]\n            #print(lineIndex_1, lineIndex_2, connections)\n            for c in range(2):\n                if connections[c] in [0, 1] and connections[c] in lineConnections[indices[c]] and isManhattan(line_1) and isManhattan(line_2):\n                    #print('duplicate corner', line_1, line_2, connections)\n                    success = False\n                    #exit(1)                    \n                    continue\n\n                lineConnections[indices[c]][connections[c]] = True\n                continue\n            corners.append((connectionPoint, connectionCornerMap[tuple(connections)]))\n            continue\n        continue\n    return corners, success\n\ndef getRoomLabelMap():\n    labelMap = {}\n    labelMap['living_room'] = 1\n    labelMap['kitchen'] = 2\n    labelMap['bedroom'] = 3\n    labelMap['bathroom'] = 4\n    labelMap['restroom'] = 4\n    labelMap['washing_room'] = 4    \n    labelMap['office'] = 3\n    labelMap['closet'] = 6\n    labelMap['balcony'] = 7\n    labelMap['corridor'] = 8\n    labelMap['dining_room'] = 9\n    labelMap['laundry_room'] = 10\n    labelMap['PS'] = 10    \n    return labelMap\n\ndef getIconLabelMap():\n    labelMap = {}\n    labelMap['bathtub'] = 1\n    labelMap['cooking_counter'] = 2\n    labelMap['toilet'] = 3\n    labelMap['entrance'] = 4\n    labelMap['washing_basin'] = 5\n    labelMap['special'] = 6\n    labelMap['stairs'] = 7\n    return labelMap\n\ndef loadLabelMap():\n    roomMap = getRoomLabelMap()\n    iconMap = getIconLabelMap()\n\n    labelMap = {}\n    for icon, label in iconMap.items():\n        labelMap[icon] = ('icons', label)\n        continue\n    for room, label in roomMap.items():    \n        labelMap[room] = ('rooms', label)\n        continue\n    labelMap['door'] = 8\n    return labelMap\n\ndef augmentSample(options, image, background_colors=[], split='train'):\n    max_size = np.random.randint(low=int(options.width * 3 / 4), high=options.width + 1)\n    if split != 'train':\n        max_size = options.width\n        pass\n    image_sizes = np.array(image.shape[:2]).astype(np.float32)\n    transformation = np.zeros((3, 3))\n    transformation[0][0] = transformation[1][1] = float(max_size) / image_sizes.max()\n    transformation[2][2] = 1\n    image_sizes = (image_sizes / image_sizes.max() * max_size).astype(np.int32)\n    \n    if image_sizes[1] == options.width or split != 'train':\n        offset_x = 0\n    else:\n        offset_x = np.random.randint(options.width - image_sizes[1])\n        pass\n    if image_sizes[0] == options.height or split != 'train':\n        offset_y = 0\n    else:\n        offset_y = np.random.randint(options.height - image_sizes[0])\n        pass\n\n    transformation[0][2] = offset_x\n    transformation[1][2] = offset_y\n\n    if len(background_colors) == 0:\n        full_image = np.full((options.height, options.width, 3), fill_value=255)\n    else:\n        full_image = background_colors[np.random.choice(np.arange(len(background_colors), dtype=np.int32), options.width * options.height)].reshape((options.height, options.width, 3))\n        pass\n        \n    #full_image = np.full((options.height, options.width, 3), fill_value=-1, dtype=np.float32)\n    full_image[offset_y:offset_y + image_sizes[0], offset_x:offset_x + image_sizes[1]] = cv2.resize(image, (image_sizes[1], image_sizes[0]))\n    image = full_image\n\n    if np.random.randint(2) == 0 and split == 'train':\n        image = np.ascontiguousarray(image[:, ::-1])\n        transformation[0][0] *= -1\n        transformation[0][2] = options.width - transformation[0][2]\n        pass\n    return image, transformation\n\ndef convertToPoint(x, y):\n    return (int(round(float(x))), int(round(float(y))))\n\ndef transformPoint(transformation, point):\n    point = np.array(point)\n    point = np.concatenate([point, np.ones(1)], axis=0)\n    point = np.matmul(transformation, point)\n    return tuple(np.round(point[:2] / point[2]).astype(np.int32).tolist())\n\n## Plane dataset class\nclass FloorplanDataset(Dataset):\n    def __init__(self, options, split, random=True):\n        self.options = options\n        self.split = split\n        self.random = random\n        self.imagePaths = []\n        self.dataFolder = '../data/'\n        with open(self.dataFolder + split + '.txt') as f:\n            for line in f:\n                self.imagePaths.append([value.strip() for value in line.split('\\t')])\n                continue\n            \n        if options.numTrainingImages > 0 and split == 'train':\n            self.numImages = options.numTrainingImages\n        else:\n            self.numImages = len(self.imagePaths)            \n            pass\n        self.labelMap = loadLabelMap()        \n        return\n    \n    def __len__(self):\n        return self.numImages\n\n    def __getitem__(self, index):\n        if self.random:\n            t = int(time.time() * 1000000)\n            np.random.seed(((t & 0xff000000) >> 24) +\n                           ((t & 0x00ff0000) >> 8) +\n                           ((t & 0x0000ff00) << 8) +\n                           ((t & 0x000000ff) << 24))\n            index = np.random.randint(len(self.imagePaths))\n        else:\n            index = index % len(self.imagePaths)\n            pass\n\n        debug = -1\n        if debug >= 0:\n            index = debug\n            print(index, self.imagePaths[index][1])\n            pass\n        \n        image = cv2.imread(self.dataFolder + self.imagePaths[index][0])\n        image_ori = image\n        image_width, image_height = image.shape[1], image.shape[0]\n\n        #def transformPoint(x, y, resize=False):\n        #if resize:\n        #return (int(round(float(x) * self.options.width / image_width)), int(round(float(y) * self.options.height / image_height)))\n        #else:\n        #return (int(round(float(x))), int(round(float(y))))            \n        \n        walls = []\n        wall_types = []\n        doors = []\n        semantics = {}\n        with open(self.dataFolder + self.imagePaths[index][1]) as info_file:\n            line_index = 0\n            for line in info_file:\n                line = line.split('\\t')\n                label = line[4].strip()\n                if label == 'wall':\n                    walls.append((convertToPoint(line[0], line[1]), convertToPoint(line[2], line[3])))\n                    wall_types.append(int(line[5].strip()) - 1)\n                elif label in ['door', 'window']:\n                    doors.append((convertToPoint(line[0], line[1]), convertToPoint(line[2], line[3])))\n                else:\n                    if label not in semantics:\n                        semantics[label] = []\n                        pass\n                    semantics[label].append((convertToPoint(line[0], line[1]), convertToPoint(line[2], line[3])))\n                    pass\n                continue\n            pass\n\n        gap = 5\n        #print(semantics)\n        invalid_indices = {}\n        for wall_index_1, (wall_1, wall_type_1) in enumerate(zip(walls, wall_types)):\n            for wall_index_2, (wall_2, wall_type_2) in enumerate(zip(walls, wall_types)):\n                if wall_type_1 == 0 and wall_type_2 == 1 and calcLineDirection(wall_1) == calcLineDirection(wall_2):\n                    if min([pointDistance(wall_1[c_1], wall_2[c_2]) for c_1, c_2 in [(0, 0), (0, 1), (1, 0), (1, 1)]]) <= gap * 2:\n                        walls[wall_index_1] = mergeLines(wall_1, wall_2)\n                        invalid_indices[wall_index_2] = True\n                        pass\n                    pass\n                continue\n            continue\n        walls = [wall for wall_index, wall in enumerate(walls) if wall_index not in invalid_indices]\n\n        background_mask = measure.label(1 - drawWallMask(walls, image_width, image_height), background=0)\n        wall_index = background_mask.min()\n        background_colors = []\n        if np.random.randint(2) == 0:\n            for pixel in [(0, 0), (0, background_mask.shape[0] - 1), (background_mask.shape[1] - 1, 0), (background_mask.shape[1] - 1, background_mask.shape[0] - 1)]:\n                index = background_mask[pixel[1]][pixel[0]]\n                if index != wall_index:\n                    background_colors = image[background_mask == index]\n                    break\n                continue\n            pass\n        \n        #walls = connectWalls(walls, roomSegmentation, gap=gap)\n        \n        corners, success = lines2Corners(walls, gap=gap)\n        if not success:\n            #print('warning', index, self.imagePaths[index][1])\n            pass\n\n\n        if self.split == 'train':\n            image, transformation = augmentSample(self.options, image, background_colors)\n        else:\n            image, transformation = augmentSample(self.options, image, background_colors, split=self.split)\n            pass\n        \n        corners = [(transformPoint(transformation, corner[0]), corner[1]) for corner in corners]\n        walls = [[transformPoint(transformation, wall[c]) for c in range(2)] for wall in walls]\n        doors = [[transformPoint(transformation, door[c]) for c in range(2)] for door in doors]        \n        for semantic, items in semantics.items():\n            semantics[semantic] = [[transformPoint(transformation, item[c]) for c in range(2)] for item in items]\n            continue\n\n        width = self.options.width\n        height = self.options.height\n        \n        roomSegmentation = np.zeros((height, width), dtype=np.uint8)\n        for line in walls:\n            #cv2.line(roomSegmentation, line[0], line[1], color=NUM_ROOMS + 1 + calcLineDirection(line), thickness=gap)\n            cv2.line(roomSegmentation, line[0], line[1], color=NUM_ROOMS + 1, thickness=gap)\n            continue\n\n        rooms = measure.label(roomSegmentation == 0, background=0)\n        \n        corner_gt = []\n        for corner in corners:\n            corner_gt.append((corner[0][0], corner[0][1], corner[1] + 1))\n            continue\n\n        openingCornerMap = [[3, 1], [0, 2]]\n        for opening in doors:\n            direction = calcLineDirection(opening)\n            for cornerIndex, corner in enumerate(opening):\n                corner_gt.append((int(round(corner[0])), int(round(corner[1])), 14 + openingCornerMap[direction][cornerIndex]))\n                continue\n            continue\n\n        wallIndex = rooms.min()\n        for pixel in [(0, 0), (0, height - 1), (width - 1, 0), (width - 1, height - 1)]:\n            backgroundIndex = rooms[pixel[1]][pixel[0]]\n            if backgroundIndex != wallIndex:\n                break\n            continue\n        iconSegmentation = np.zeros((height, width), dtype=np.uint8)\n        for line in doors:\n            cv2.line(iconSegmentation, line[0], line[1], color = self.labelMap['door'], thickness=gap - 1)\n            continue\n\n        roomLabelMap = {}\n        for semantic, items in semantics.items():\n            group, label = self.labelMap[semantic]\n            for corners in items:\n                if group == 'icons':\n                    if label == 0:\n                        continue\n                    cv2.rectangle(iconSegmentation, (int(round(corners[0][0])), int(round(corners[0][1]))), (int(round(corners[1][0])), int(round(corners[1][1]))), color=label, thickness=-1)\n                    corner_gt.append((corners[0][0], corners[0][1], 18 + 2))\n                    corner_gt.append((corners[0][0], corners[1][1], 18 + 1))\n                    corner_gt.append((corners[1][0], corners[0][1], 18 + 3))\n                    corner_gt.append((corners[1][0], corners[1][1], 18 + 0))\n                else:\n                    roomIndex = rooms[(corners[0][1] + corners[1][1]) // 2][(corners[0][0] + corners[1][0]) // 2]\n                    if roomIndex == wallIndex or roomIndex == backgroundIndex:\n                        #if roomIndex == backgroundIndex:\n                        #print('label on background', corners, semantic, index, self.imagePaths[index][1])\n                        #pass\n                        continue\n                    if roomIndex in roomLabelMap:\n                        #print('room has more than one labels', corners, label, roomLabelMap[roomIndex])\n                        #exit(1)\n                        continue\n                        pass\n                    roomLabelMap[roomIndex] = label\n                    roomSegmentation[rooms == roomIndex] = label\n                    pass\n                continue\n            continue\n        \n        #print(roomLabelMap)\n        if debug >= 0:\n            cv2.imwrite('test/floorplan/rooms.png', drawSegmentationImage(rooms, blackIndex=backgroundIndex))\n            exit(1)\n            pass\n        \n        for roomIndex in range(rooms.min(), rooms.max() + 1):\n            if roomIndex == wallIndex or roomIndex == backgroundIndex:\n                continue\n            if roomIndex not in roomLabelMap:\n                roomSegmentation[rooms == roomIndex] = 10\n                #print('room has no label', roomIndex, rooms.max(), np.stack((rooms == roomIndex).nonzero(), axis=-1).mean(0)[::-1])\n                #exit(1)\n                pass\n            continue\n\n        cornerSegmentation = np.zeros((height, width, 21), dtype=np.uint8)\n        for corner in corner_gt:\n            cornerSegmentation[min(max(corner[1], 0), height - 1), min(max(corner[0], 0), width - 1), corner[2] - 1] = 1\n            continue\n\n        if False:\n            cv2.imwrite('test/image.png', image_ori)\n            cv2.imwrite('test/icon_segmentation.png', drawSegmentationImage(iconSegmentation))\n            cv2.imwrite('test/room_segmentation.png', drawSegmentationImage(roomSegmentation))\n            cv2.imwrite('test/corner_segmentation.png', drawSegmentationImage(cornerSegmentation, blackIndex=0))\n            print([(seg.min(), seg.max(), seg.shape) for seg in [cornerSegmentation, iconSegmentation, roomSegmentation]])\n            exit(1)            \n            pass\n\n\n        image = (image.astype(np.float32) / 255 - 0.5).transpose((2, 0, 1))\n        kernel = np.zeros((3, 3), dtype=np.uint8)\n        kernel[1] = 1\n        kernel[:, 1] = 1\n        cornerSegmentation = cv2.dilate(cornerSegmentation, kernel, iterations=5)\n\n        sample = [image, cornerSegmentation.astype(np.float32), iconSegmentation.astype(np.int64), roomSegmentation.astype(np.int64)]\n        return sample\n"""
pytorch/models/drn.py,3,"b""import pdb\n\nimport torch.nn as nn\nimport math\nimport torch.utils.model_zoo as model_zoo\nfrom torch.nn import functional as F\n\n__all__ = ['DRN', 'drn26', 'drn42', 'drn58']\n\n\nwebroot = 'https://tigress-web.princeton.edu/~fy/drn/models/'\n\nmodel_urls = {\n    'drn-c-26': webroot + 'drn_c_26-ddedf421.pth',\n    'drn-c-42': webroot + 'drn_c_42-9d336e8c.pth',\n    'drn-c-58': webroot + 'drn_c_58-0a53a92c.pth',\n    'drn-d-22': webroot + 'drn_d_22-4bd2f8ea.pth',\n    'drn-d-38': webroot + 'drn_d_38-eebb45f0.pth',\n    'drn-d-54': webroot + 'drn_d_54-0e0534ff.pth',\n    'drn-d-105': webroot + 'drn_d_105-12b40979.pth'\n}\n\n\ndef conv3x3(in_planes, out_planes, stride=1, padding=1, dilation=1):\n    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride,\n                     padding=padding, bias=False, dilation=dilation)\n\n\nclass BasicBlock(nn.Module):\n    expansion = 1\n\n    def __init__(self, inplanes, planes, stride=1, downsample=None,\n                 dilation=(1, 1), residual=True):\n        super(BasicBlock, self).__init__()\n        self.conv1 = conv3x3(inplanes, planes, stride,\n                             padding=dilation[0], dilation=dilation[0])\n        self.bn1 = nn.BatchNorm2d(planes)\n        self.relu = nn.ReLU(inplace=True)\n        self.conv2 = conv3x3(planes, planes,\n                             padding=dilation[1], dilation=dilation[1])\n        self.bn2 = nn.BatchNorm2d(planes)\n        self.downsample = downsample\n        self.stride = stride\n        self.residual = residual\n\n    def forward(self, x):\n        residual = x\n\n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = self.relu(out)\n\n        out = self.conv2(out)\n        out = self.bn2(out)\n\n        if self.downsample is not None:\n            residual = self.downsample(x)\n        if self.residual:\n            out += residual\n        out = self.relu(out)\n\n        return out\n\n\nclass Bottleneck(nn.Module):\n    expansion = 4\n\n    def __init__(self, inplanes, planes, stride=1, downsample=None,\n                 dilation=(1, 1), residual=True):\n        super(Bottleneck, self).__init__()\n        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(planes)\n        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=stride,\n                               padding=dilation[1], bias=False,\n                               dilation=dilation[1])\n        self.bn2 = nn.BatchNorm2d(planes)\n        self.conv3 = nn.Conv2d(planes, planes * 4, kernel_size=1, bias=False)\n        self.bn3 = nn.BatchNorm2d(planes * 4)\n        self.relu = nn.ReLU(inplace=True)\n        self.downsample = downsample\n        self.stride = stride\n\n    def forward(self, x):\n        residual = x\n\n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = self.relu(out)\n\n        out = self.conv2(out)\n        out = self.bn2(out)\n        out = self.relu(out)\n\n        out = self.conv3(out)\n        out = self.bn3(out)\n\n        if self.downsample is not None:\n            residual = self.downsample(x)\n\n        out += residual\n        out = self.relu(out)\n\n        return out\n\n\nclass DRN(nn.Module):\n\n    def __init__(self, block, layers, num_classes=1000,\n                 channels=(16, 32, 64, 128, 256, 512, 512, 512),\n                 out_map=-1, out_middle=False, pool_size=28, arch='D'):\n        super(DRN, self).__init__()\n        self.inplanes = channels[0]\n        self.out_map = out_map\n        self.out_dim = channels[-1]\n        self.out_middle = out_middle\n        self.arch = arch\n\n        if arch == 'C':\n            self.conv1 = nn.Conv2d(3, channels[0], kernel_size=7, stride=1,\n                                   padding=3, bias=False)\n            self.bn1 = nn.BatchNorm2d(channels[0])\n            self.relu = nn.ReLU(inplace=True)\n\n            self.layer1 = self._make_layer(\n                BasicBlock, channels[0], layers[0], stride=1)\n            self.layer2 = self._make_layer(\n                BasicBlock, channels[1], layers[1], stride=2)\n        elif arch == 'D':\n            self.layer0 = nn.Sequential(\n                nn.Conv2d(3, channels[0], kernel_size=7, stride=1, padding=3,\n                          bias=False),\n                nn.BatchNorm2d(channels[0]),\n                nn.ReLU(inplace=True)\n            )\n\n            self.layer1 = self._make_conv_layers(\n                channels[0], layers[0], stride=1)\n            self.layer2 = self._make_conv_layers(\n                channels[1], layers[1], stride=2)\n\n        self.layer3 = self._make_layer(block, channels[2], layers[2], stride=2)\n        self.layer4 = self._make_layer(block, channels[3], layers[3], stride=2)\n        self.layer5 = self._make_layer(block, channels[4], layers[4], dilation=2,\n                                       new_level=False)\n        self.layer6 = None if layers[5] == 0 else \\\n            self._make_layer(block, channels[5], layers[5], dilation=4,\n                             new_level=False)\n\n        if arch == 'C':\n            self.layer7 = None if layers[6] == 0 else \\\n                self._make_layer(BasicBlock, channels[6], layers[6], dilation=2,\n                                 new_level=False, residual=False)\n            self.layer8 = None if layers[7] == 0 else \\\n                self._make_layer(BasicBlock, channels[7], layers[7], dilation=1,\n                                 new_level=False, residual=False)\n        elif arch == 'D':\n            self.layer7 = None if layers[6] == 0 else \\\n                self._make_conv_layers(channels[6], layers[6], dilation=2)\n            self.layer8 = None if layers[7] == 0 else \\\n                self._make_conv_layers(channels[7], layers[7], dilation=1)\n\n        self.num_classes = num_classes\n        if self.num_classes > 0:\n            self.avgpool = nn.AvgPool2d(pool_size)\n            self.pred = nn.Conv2d(self.out_dim, num_classes, kernel_size=1,\n                                  stride=1, padding=0, bias=True)\n\n        for m in self.modules():\n            if isinstance(m, nn.Conv2d):\n                n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels\n                m.weight.data.normal_(0, math.sqrt(2. / n))\n            elif isinstance(m, nn.BatchNorm2d):\n                m.weight.data.fill_(1)\n                m.bias.data.zero_()\n\n        if self.out_map < 32:\n            self.out_pool = nn.MaxPool2d(32 // self.out_map)\n            pass\n\n    def _make_layer(self, block, planes, blocks, stride=1, dilation=1,\n                    new_level=True, residual=True):\n        assert dilation == 1 or dilation % 2 == 0\n        downsample = None\n        if stride != 1 or self.inplanes != planes * block.expansion:\n            downsample = nn.Sequential(\n                nn.Conv2d(self.inplanes, planes * block.expansion,\n                          kernel_size=1, stride=stride, bias=False),\n                nn.BatchNorm2d(planes * block.expansion),\n            )\n\n        layers = list()\n        layers.append(block(\n            self.inplanes, planes, stride, downsample,\n            dilation=(1, 1) if dilation == 1 else (\n                dilation // 2 if new_level else dilation, dilation),\n            residual=residual))\n        self.inplanes = planes * block.expansion\n        for i in range(1, blocks):\n            layers.append(block(self.inplanes, planes, residual=residual,\n                                dilation=(dilation, dilation)))\n\n        return nn.Sequential(*layers)\n\n    def _make_conv_layers(self, channels, convs, stride=1, dilation=1):\n        modules = []\n        for i in range(convs):\n            modules.extend([\n                nn.Conv2d(self.inplanes, channels, kernel_size=3,\n                          stride=stride if i == 0 else 1,\n                          padding=dilation, bias=False, dilation=dilation),\n                nn.BatchNorm2d(channels),\n                nn.ReLU(inplace=True)])\n            self.inplanes = channels\n        return nn.Sequential(*modules)\n\n    def forward(self, x):\n        y = list()\n\n        if self.arch == 'C':\n            x = self.conv1(x)\n            x = self.bn1(x)\n            x = self.relu(x)\n        elif self.arch == 'D':\n            x = self.layer0(x)\n\n        x = self.layer1(x)\n        y.append(x)\n        x = self.layer2(x)\n        y.append(x)\n\n        x = self.layer3(x)\n        y.append(x)\n\n        x = self.layer4(x)\n        y.append(x)\n\n        x = self.layer5(x)\n        y.append(x)\n\n        if self.layer6 is not None:\n            x = self.layer6(x)\n            y.append(x)\n\n        if self.layer7 is not None:\n            x = self.layer7(x)\n            y.append(x)\n\n        if self.layer8 is not None:\n            x = self.layer8(x)\n            y.append(x)\n\n        if self.out_map > 0:\n            if self.num_classes > 0:\n                if self.out_map == x.shape[2]:\n                    x = self.pred(x)\n                elif self.out_map > x.shape[2]:\n                    x = self.pred(x)\n                    x = F.upsample(input=x, size=(self.out_map, self.out_map), mode='bilinear')\n                else:\n                    x = self.out_pool(x)\n                    y.append(x)\n                    x = self.pred(x)\n                    pass\n            else:\n                if self.out_map > x.shape[3]:\n                    x = F.upsample(input=x, size=(self.out_map, self.out_map), mode='bilinear')\n                    pass\n                pass\n        else:\n            x = self.avgpool(x)\n            x = self.pred(x)\n            x = x.view(x.size(0), -1)\n\n        if self.out_middle:\n            return x, y\n        else:\n            return x\n\n\ndef drn_c_26(pretrained=False, **kwargs):\n    model = DRN(BasicBlock, [1, 1, 2, 2, 2, 2, 1, 1], arch='C', **kwargs)\n    if pretrained:\n        model.load_state_dict(model_zoo.load_url(model_urls['drn-c-26']))\n    return model\n\n\ndef drn_c_42(pretrained=False, **kwargs):\n    model = DRN(BasicBlock, [1, 1, 3, 4, 6, 3, 1, 1], arch='C', **kwargs)\n    if pretrained:\n        model.load_state_dict(model_zoo.load_url(model_urls['drn-c-42']))\n    return model\n\n\ndef drn_c_58(pretrained=False, **kwargs):\n    model = DRN(Bottleneck, [1, 1, 3, 4, 6, 3, 1, 1], arch='C', **kwargs)\n    if pretrained:\n        model.load_state_dict(model_zoo.load_url(model_urls['drn-c-58']))\n    return model\n\n\ndef drn_d_22(pretrained=False, **kwargs):\n    model = DRN(BasicBlock, [1, 1, 2, 2, 2, 2, 1, 1], arch='D', **kwargs)\n    if pretrained:\n        model.load_state_dict(model_zoo.load_url(model_urls['drn-d-22']))\n    return model\n\n\ndef drn_d_38(pretrained=False, **kwargs):\n    model = DRN(BasicBlock, [1, 1, 3, 4, 6, 3, 1, 1], arch='D', **kwargs)\n    if pretrained:\n        model.load_state_dict(model_zoo.load_url(model_urls['drn-d-38']))\n    return model\n\n\ndef drn_d_54(pretrained=False, out_map=256, num_classes=20, **kwargs):\n    model = DRN(Bottleneck, [1, 1, 3, 4, 6, 3, 1, 1], arch='D', out_map=out_map, num_classes=num_classes, **kwargs)\n    if pretrained:\n        pretrained_dict = model_zoo.load_url(model_urls['drn-d-54'], model_dir='checkpoint/')\n        pretrained_dict = {k: v for k, v in pretrained_dict.items() if 'fc' not in k}\n        state = model.state_dict()\n        state.update(pretrained_dict)\n        model.load_state_dict(state)\n    return model\n\n\ndef drn_d_105(pretrained=False, **kwargs):\n    model = DRN(Bottleneck, [1, 1, 3, 4, 23, 3, 1, 1], arch='D', **kwargs)\n    if pretrained:\n        model.load_state_dict(model_zoo.load_url(model_urls['drn-d-105']))\n    return model\n"""
pytorch/models/model.py,2,"b""from models.drn import drn_d_54\nfrom torch import nn\nfrom models.modules import *\n\nclass Model(nn.Module):\n    def __init__(self, options):\n        super(Model, self).__init__()\n        \n        self.options = options        \n        self.drn = drn_d_54(pretrained=True, out_map=32, num_classes=-1, out_middle=False)\n        self.pyramid = PyramidModule(options, 512, 128)\n        self.feature_conv = ConvBlock(1024, 512)\n        self.segmentation_pred = nn.Conv2d(512, NUM_CORNERS + NUM_ICONS + 2 + NUM_ROOMS + 2, kernel_size=1)\n        self.upsample = torch.nn.Upsample(size=(options.height, options.width), mode='bilinear')\n        return\n\n    def forward(self, inp):\n        features = self.drn(inp)\n        features = self.pyramid(features)\n        features = self.feature_conv(features)\n        segmentation = self.upsample(self.segmentation_pred(features))\n        segmentation = segmentation.transpose(1, 2).transpose(2, 3).contiguous()\n        return torch.sigmoid(segmentation[:, :, :, :NUM_CORNERS]), segmentation[:, :, :, NUM_CORNERS:NUM_CORNERS + NUM_ICONS + 2], segmentation[:, :, :, -(NUM_ROOMS + 2):]\n"""
pytorch/models/modules.py,21,"b""import torch\nfrom torch import nn\nimport numpy as np\nfrom utils import *\n\n## Conv + bn + relu\nclass ConvBlock(nn.Module):\n    def __init__(self, in_planes, out_planes, kernel_size=3, stride=1, padding=None, mode='conv', use_bn=True):\n        super(ConvBlock, self).__init__()\n\n        self.use_bn = use_bn\n        \n        if padding == None:\n            padding = (kernel_size - 1) // 2\n            pass\n        if mode == 'conv':\n            self.conv = nn.Conv2d(in_planes, out_planes, kernel_size=kernel_size, stride=stride, padding=padding, bias=False)\n        elif mode == 'deconv':\n            self.conv = nn.ConvTranspose2d(in_planes, out_planes, kernel_size=kernel_size, stride=stride, padding=padding, bias=False)\n        elif mode == 'conv_3d':\n            self.conv = nn.Conv3d(in_planes, out_planes, kernel_size=kernel_size, stride=stride, padding=padding, bias=False)\n        elif mode == 'deconv_3d':\n            self.conv = nn.ConvTranspose3d(in_planes, out_planes, kernel_size=kernel_size, stride=stride, padding=padding, bias=False)\n        else:\n            print('conv mode not supported', mode)\n            exit(1)\n            pass\n        if self.use_bn:\n            if '3d' not in mode:\n                self.bn = nn.BatchNorm2d(out_planes)\n            else:\n                self.bn = nn.BatchNorm3d(out_planes)\n                pass\n            pass\n        self.relu = nn.ReLU(inplace=True)\n        return\n   \n    def forward(self, inp):\n        #return self.relu(self.conv(inp))\n        if self.use_bn:\n            return self.relu(self.bn(self.conv(inp)))\n        else:\n            return self.relu(self.conv(inp))\n\n## The pyramid module from pyramid scene parsing\nclass PyramidModule(nn.Module):\n    def __init__(self, options, in_planes, middle_planes, scales=[32, 16, 8, 4]):\n        super(PyramidModule, self).__init__()\n        \n        self.pool_1 = torch.nn.AvgPool2d((scales[0] * options.height // options.width, scales[0]))\n        self.pool_2 = torch.nn.AvgPool2d((scales[1] * options.height // options.width, scales[1]))        \n        self.pool_3 = torch.nn.AvgPool2d((scales[2] * options.height // options.width, scales[2]))\n        self.pool_4 = torch.nn.AvgPool2d((scales[3] * options.height // options.width, scales[3]))        \n        self.conv_1 = ConvBlock(in_planes, middle_planes, kernel_size=1, use_bn=False)\n        self.conv_2 = ConvBlock(in_planes, middle_planes, kernel_size=1)\n        self.conv_3 = ConvBlock(in_planes, middle_planes, kernel_size=1)\n        self.conv_4 = ConvBlock(in_planes, middle_planes, kernel_size=1)\n        self.upsample = torch.nn.Upsample(size=(scales[0] * options.height // options.width, scales[0]), mode='bilinear')\n        return\n    \n    def forward(self, inp):\n        x_1 = self.upsample(self.conv_1(self.pool_1(inp)))\n        x_2 = self.upsample(self.conv_2(self.pool_2(inp)))\n        x_3 = self.upsample(self.conv_3(self.pool_3(inp)))\n        x_4 = self.upsample(self.conv_4(self.pool_4(inp)))\n        out = torch.cat([inp, x_1, x_2, x_3, x_4], dim=1)\n        return out\n\n\n## The module to compute plane depths from plane parameters\ndef calcPlaneDepthsModule(width, height, planes, metadata, return_ranges=False):\n    urange = (torch.arange(width, dtype=torch.float32).cuda().view((1, -1)).repeat(height, 1) / (float(width) + 1) * (metadata[4] + 1) - metadata[2]) / metadata[0]\n    vrange = (torch.arange(height, dtype=torch.float32).cuda().view((-1, 1)).repeat(1, width) / (float(height) + 1) * (metadata[5] + 1) - metadata[3]) / metadata[1]\n    ranges = torch.stack([urange, torch.ones(urange.shape).cuda(), -vrange], dim=-1)\n    \n    planeOffsets = torch.norm(planes, dim=-1, keepdim=True)\n    planeNormals = planes / torch.clamp(planeOffsets, min=1e-4)\n\n    normalXYZ = torch.sum(ranges.unsqueeze(-2) * planeNormals.unsqueeze(-3).unsqueeze(-3), dim=-1)\n    normalXYZ[normalXYZ == 0] = 1e-4\n    planeDepths = planeOffsets.squeeze(-1).unsqueeze(-2).unsqueeze(-2) / normalXYZ\n    planeDepths = torch.clamp(planeDepths, min=0, max=MAX_DEPTH)\n    if return_ranges:\n        return planeDepths, ranges\n    return planeDepths\n\n\n## The module to compute depth from plane information\ndef calcDepthModule(width, height, planes, segmentation, non_plane_depth, metadata):\n    planeDepths = calcPlaneDepthsModule(width, height, planes, metadata)\n    allDepths = torch.cat([planeDepths.transpose(-1, -2).transpose(-2, -3), non_plane_depth], dim=1)\n    return torch.sum(allDepths * segmentation, dim=1)\n\n\n## Compute matching with the auction-based approximation algorithm\ndef assignmentModule(W):\n    O = calcAssignment(W.detach().cpu().numpy())\n    return torch.from_numpy(O).cuda()\n\ndef calcAssignment(W):\n    numOwners = int(W.shape[0])\n    numGoods = int(W.shape[1])    \n    P = np.zeros(numGoods)\n    O = np.full(shape=(numGoods, ), fill_value=-1)\n    delta = 1.0 / (numGoods + 1)\n    queue = list(range(numOwners))\n    while len(queue) > 0:\n        ownerIndex = queue[0]\n        queue = queue[1:]\n        weights = W[ownerIndex]\n        goodIndex = (weights - P).argmax()\n        if weights[goodIndex] >= P[goodIndex]:\n            if O[goodIndex] >= 0:\n                queue.append(O[goodIndex])\n                pass\n            O[goodIndex] = ownerIndex\n            P[goodIndex] += delta\n            pass\n        continue\n    return O\n\n## Get one-hot tensor\ndef oneHotModule(inp, depth):\n    inpShape = [int(size) for size in inp.shape]\n    inp = inp.view(-1)\n    out = torch.zeros(int(inp.shape[0]), depth).cuda()\n    out.scatter_(1, inp.unsqueeze(-1), 1)\n    out = out.view(inpShape + [depth])\n    return out\n\n## Warp image\ndef warpImages(options, planes, images, transformations, metadata):\n    planeDepths, ranges = calcPlaneDepthsModule(options.width, options.height, planes, metadata, return_ranges=True)\n    print(planeDepths.shape, ranges.shape, transformations.shape)\n    exit(1)\n    XYZ = planeDepths.unsqueeze(-1) * ranges.unsqueeze(-2)\n    XYZ = torch.cat([XYZ, torch.ones([int(size) for size in XYZ.shape[:-1]] + [1]).cuda()], dim=-1)\n    XYZ = torch.matmul(XYZ.unsqueeze(-3), transformations.unsqueeze(-4).unsqueeze(-4))\n    UVs = XYZ[:, :, :, :, :, :2] / XYZ[:, :, :, :, :, 2:3]\n    UVs = (UVs * metadata[:2] + metadata[2:4]) / metadata[4:6] * 2 - 1\n    warpedImages = []\n    for imageIndex in range(options.numNeighborImages):\n        warpedImage = []\n        image = images[:, imageIndex]\n        for planeIndex in range(options.numOutputPlanes):\n            warpedImage.append(F.grid_sample(image, UVs[:, :, :, imageIndex, planeIndex]))\n            continue\n        warpedImages.append(torch.stack(warpedImage, 1))\n        continue\n    warpedImages = torch.stack(warpedImages, 2)\n    return warpedImages\n"""
rendering/data/obj2egg.py,0,"b'#!/usr/bin/python\n""""""\n    This Version: $Id: obj2egg.py,v 1.7 2008/05/26 17:42:53 andyp Exp $\n    Info: info >at< pfastergames.com\n\n    Extended from: http://panda3d.org/phpbb2/viewtopic.php?t=3378\n    .___..__ .___.___.___.__..__ .  .\n      |  [__)[__ [__ [__ |  |[__)|\\/|\n      |  |  \\[___[___|   |__||  \\|  |\n    obj2egg.py [n##][b][t][s] filename1.obj ...\n        -n regenerate normals with # degree smoothing\n            exaple -n30  (normals at less 30 degrees will be smoothed)\n        -b make binarmals\n        -t make tangents\n        -s show in pview\n\n    licensed under WTFPL (http://sam.zoy.org/wtfpl/)\n""""""\n\nfrom pandac.PandaModules import *\nimport math\nimport string\nimport getopt\nimport sys, os\n\n\ndef floats(float_list):\n    """"""coerce a list of strings that represent floats into a list of floats""""""\n    return [ float(number) for number in float_list ]\n\ndef ints(int_list):\n    """"""coerce a list of strings that represent integers into a list of integers""""""\n    return [ int(number) for number in int_list ]\n\n\nclass ObjMaterial:\n    """"""a wavefront material""""""\n    def __init__(self):\n        self.filename = None\n        self.name = ""default""\n        self.eggdiffusetexture = None\n        self.eggmaterial = None\n        self.attrib = {}\n        self.attrib[""Ns""] = 100.0\n        self.attrib[""d""] = 1.0\n        self.attrib[""illum""] = 2\n        # ""magenta""\n        self.attrib[""Kd""] = [1.0, 0.0, 1.0]\n        self.attrib[""Ka""] = [0.0, 0.0, 0.0]\n        self.attrib[""Ks""] = [0.0, 0.0, 0.0]\n        self.attrib[""Ke""] = [0.0, 0.0, 0.0]\n\n    def put(self, key, value):\n        self.attrib[key] = value\n        return self\n\n    def get(self, key):\n        if self.attrib.has_key(key):\n            return self.attrib[key]\n        return None\n\n    def has_key(self, key):\n        return self.attrib.has_key(key)\n\n    def isTextured(self):\n        # for k in (""map_Kd"", ""map_Bump"", ""map_Ks""):    <-- NOT YET\n        if self.attrib.has_key(""map_Kd""):\n            return True;\n        return False;\n\n    def getEggTexture(self):\n        if self.eggdiffusetexture:\n            return self.eggdiffusetexture\n        if not self.isTextured():\n            return None\n        m = EggTexture(self.name + ""_diffuse"", self.get(""map_Kd""))\n        m.setFormat(EggTexture.FRgb)\n        m.setMagfilter(EggTexture.FTLinearMipmapLinear)\n        m.setMinfilter(EggTexture.FTLinearMipmapLinear)\n        m.setWrapU(EggTexture.WMRepeat)\n        m.setWrapV(EggTexture.WMRepeat)\n        self.eggdiffusetexture = m\n        return self.eggdiffusetexture\n\n    def getEggMaterial(self):\n        if self.eggmaterial:\n            return self.eggmaterial\n        m = EggMaterial(self.name + ""_mat"")\n        # XXX TODO: add support for specular, and obey illum setting\n        # XXX as best as we can\n        rgb = self.get(""Kd"")\n        if rgb is not None:\n            m.setDiff(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n        rgb = self.get(""Ka"")\n        if rgb is not None:\n            m.setAmb(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n        rgb = self.get(""Ks"")\n        if rgb is not None:\n            m.setSpec(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n        ns = self.get(""Ns"")\n        if ns is not None:\n            m.setShininess(ns)\n        self.eggmaterial = m\n        return self.eggmaterial\n\nclass MtlFile:\n    """"""an object representing all Wavefront materials in a .mtl file""""""\n    def __init__(self, filename=None):\n        self.filename = None\n        self.materials = {}\n        self.comments = {}\n        if filename is not None:\n            self.read(filename)\n\n    def read(self, filename, verbose=False):\n        self.filename = filename\n        self.materials = {}\n        self.comments = {}\n        try:\n            file = open(filename)\n        except:\n            return self\n        linenumber = 0\n        mat = None\n        for line in file.readlines():\n            line = line.strip()\n            linenumber = linenumber + 1\n            if not line:\n                continue\n            if line[0] == \'#\':\n                self.comments[linenumber] = line\n                print line\n                continue\n            tokens = line.split()\n            if not tokens:\n                continue\n            if verbose: print ""tokens[0]:"", tokens\n            if tokens[0] == ""newmtl"":\n                mat = ObjMaterial()\n                mat.filename = filename\n                mat.name = tokens[1]\n                self.materials[mat.name] = mat\n                if verbose: print ""newmtl:"", mat.name\n                continue\n            if tokens[0] in (""Ns"", ""d"", ""Tr""):\n                # ""d factor"" - specifies the dissovle for the current material,\n                #              1.0 is full opaque\n                # ""Ns exponent"" - specifies the specular exponent.  A high exponent\n                #               results in a tight, concentrated highlight.\n                mat.put(tokens[0], float(tokens[1]))\n                continue\n            if tokens[0] in (""illum""):\n                # according to http://www.fileformat.info/format/material/\n                # 0 = Color on and Ambient off\n                # 1 = Color on and Ambient on\n                # 2 = Highlight on\n                # 3 = Reflection on and Ray trace on\n                # 4 = Transparency: Glass on, Reflection: Ray trace on\n                # 5 = Reflection: Fesnel on and Ray trace on\n                # 6 = Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                # 7 = Transparency: Refraction on, Refelction: Fresnel on and Ray Trace on\n                # 8 = Reflection on and Ray trace off\n                # 9 = Transparency: Glass on, Reflection: Ray trace off\n                # 10 = Casts shadows onto invisible surfaces\n                mat.put(tokens[0], int(tokens[1]))\n                continue\n            if tokens[0] in (""Kd"", ""Ka"", ""Ks"", ""Ke""):\n                mat.put(tokens[0], floats(tokens[1:]))\n                continue\n            if tokens[0] in (""map_Kd"", ""map_Bump"", ""map_Ks"", ""map_bump"", ""bump""):\n                # Ultimate Unwrap 3D Pro emits these:\n                # map_Kd == diffuse\n                # map_Bump == bump\n                # map_Ks == specular\n                mat.put(tokens[0], pathify(tokens[1]))\n                if verbose: print ""map:"", mat.name, tokens[0], mat.get(tokens[0])\n                continue\n            if tokens[0] in (""Ni""):\n                # blender\'s .obj exporter can emit this ""Ni 1.000000""\n                mat.put(tokens[0], float(tokens[1]))\n                continue\n            print ""file \\""%s\\"": line %d: unrecognized:"" % (filename, linenumber), tokens\n        file.close()\n        if verbose: print ""%d materials"" % len(self.materials), ""loaded from"", filename\n        return self\n\nclass ObjFile:\n    """"""a representation of a wavefront .obj file""""""\n    def __init__(self, filename=None):\n        self.filename = None\n        self.objects = [""defaultobject""]\n        self.groups = [""defaultgroup""]\n        self.points = []\n        self.uvs = []\n        self.normals = []\n        self.faces = []\n        self.polylines = []\n        self.matlibs = []\n        self.materialsbyname = {}\n        self.comments = {}\n        self.currentobject = self.objects[0]\n        self.currentgroup = self.groups[0]\n        self.currentmaterial = None\n        if filename is not None:\n            self.read(filename)\n\n    def read(self, filename, verbose=False):\n        if verbose: print ""ObjFile.read:"", ""filename:"", filename\n        self.filename = filename\n        self.objects = [""defaultobject""]\n        self.groups = [""defaultgroup""]\n        self.points = []\n        self.uvs = []\n        self.normals = []\n        self.faces = []\n        self.polylines = []\n        self.matlibs = []\n        self.materialsbyname = {}\n        self.comments = {}\n        self.currentobject = self.objects[0]\n        self.currentgroup = self.groups[0]\n        self.currentmaterial = None\n        try:\n            file = open(filename)\n        except:\n            return self\n        linenumber = 0\n        for line in file.readlines():\n            line = line.strip()\n            linenumber = linenumber + 1\n            if not line:\n                continue\n            if line[0] == \'#\':\n                self.comments[linenumber] = line\n                print line\n                continue\n            tokens = line.split()\n            if not tokens:\n                continue\n            if tokens[0] == ""mtllib"":\n                if verbose: print ""mtllib:"", tokens[1:]\n                mtllib = MtlFile(tokens[1])\n                # if verbose: print mtllib\n                self.matlibs.append(mtllib)\n                self.indexmaterials(mtllib)\n                continue\n            if tokens[0] == ""g"":\n                if verbose: print ""g:"", tokens[1:]\n                self.__newgroup("""".join(tokens[1:]))\n                continue\n            if tokens[0] == ""o"":\n                if verbose: print ""o:"", tokens[1:]\n                self.__newobject("""".join(tokens[1:]))\n                continue\n            if tokens[0] == ""usemtl"":\n                if verbose: print ""usemtl:"", tokens[1:]\n                self.__usematerial(tokens[1])\n                continue\n            if tokens[0] == ""v"":\n                if verbose: print ""v:"", tokens[1:]\n                self.__newv(tokens[1:])\n                continue\n            if tokens[0] == ""vn"":\n                if verbose: print ""vn:"", tokens[1:]\n                self.__newnormal(tokens[1:])\n                continue\n            if tokens[0] == ""vt"":\n                if verbose: print ""vt:"", tokens[1:]\n                self.__newuv(tokens[1:])\n                continue\n            if tokens[0] == ""f"":\n                if verbose: print ""f:"", tokens[1:]\n                self.__newface(tokens[1:])\n                continue\n            if tokens[0] == ""s"":\n                # apparently, this enables/disables smoothing\n                print ""%s:%d:"" % (filename, linenumber), ""ignoring:"", tokens\n                continue\n            if tokens[0] == ""l"":\n                if verbose: print ""l:"", tokens[1:]\n                self.__newpolyline(tokens[1:])\n                continue\n            print ""%s:%d:"" % (filename, linenumber), ""unknown:"", tokens\n        file.close()\n        return self\n\n    def __vertlist(self, lst):\n        res = []\n        for vert in lst:\n            vinfo = vert.split(""/"")\n            vlen = len(vinfo)\n            vertex = {\'v\':None, \'vt\':None, \'vn\':None}\n            if vlen == 1:\n                vertex[\'v\'] = int(vinfo[0])\n            elif vlen == 2:\n                if vinfo[0] != \'\':\n                    vertex[\'v\'] = int(vinfo[0])\n                if vinfo[1] != \'\':\n                    vertex[\'vt\'] = int(vinfo[1])\n            elif vlen == 3:\n                if vinfo[0] != \'\':\n                    vertex[\'v\'] = int(vinfo[0])\n                if vinfo[1] != \'\':\n                    vertex[\'vt\'] = int(vinfo[1])\n                if vinfo[2] != \'\':\n                    vertex[\'vn\'] = int(vinfo[2])\n            else:\n                print ""aborting...""\n                raise UNKNOWN, res\n            res.append(vertex)\n        if False: print res\n        return res\n\n    def __enclose(self, lst):\n        mdata = (self.currentobject, self.currentgroup, self.currentmaterial)\n        return (lst, mdata)\n\n    def __newpolyline(self, l):\n        polyline = self.__vertlist(l)\n        if False: print ""__newline:"", polyline\n        self.polylines.append(self.__enclose(polyline))\n        return self\n\n    def __newface(self, f):\n        face = self.__vertlist(f)\n        if False: print face\n        self.faces.append(self.__enclose(face))\n        return self\n\n    def __newuv(self, uv):\n        self.uvs.append(floats(uv))\n        return self\n\n    def __newnormal(self, normal):\n        self.normals.append(floats(normal))\n        return self\n\n    def __newv(self, v):\n        # capture the current metadata with vertices\n        vdata = floats(v)\n        mdata = (self.currentobject, self.currentgroup, self.currentmaterial)\n        vinfo = (vdata, mdata)\n        self.points.append(vinfo)\n        return self\n\n    def indexmaterials(self, mtllib, verbose=False):\n        # traverse the materials defined in mtllib, indexing\n        # them by name.\n        for mname in mtllib.materials:\n            mobj = mtllib.materials[mname]\n            self.materialsbyname[mobj.name] = mobj\n        if verbose: \n            print ""indexmaterials:"", mtllib.filename, ""materials:"", self.materialsbyname.keys()\n        return self\n\n    def __closeobject(self):\n        self.currentobject = ""defaultobject""\n        return self\n\n    def __newobject(self, object):\n        self.__closeobject()\n        if False: print ""__newobject:"", ""object:"", object\n        self.currentobject = object\n        self.objects.append(object)\n        return self\n\n    def __closegroup(self):\n        self.currentgroup = ""defaultgroup""\n        return self\n\n    def __newgroup(self, group):\n        self.__closegroup()\n        if False: print ""__newgroup:"", ""group:"", group\n        self.currentgroup = group\n        self.groups.append(group)\n        return self\n\n    def __usematerial(self, material):\n        if False: print ""__usematerial:"", ""material:"", material\n        if self.materialsbyname.has_key(material):\n            self.currentmaterial = material\n        else:\n            print ""warning:"", ""__usematerial:"", ""unknown material:"", material\n        return self\n\n    def __itemsby(self, itemlist, objname, groupname):\n        res = []\n        for item in itemlist:\n            vlist, mdata = item\n            wobj, wgrp, wmat = mdata\n            if (wobj == objname) and (wgrp == groupname):\n                res.append(item)\n        return res\n\n    def __facesby(self, objname, groupname):\n        return self.__itemsby(self.faces, objname, groupname)\n\n    def __linesby(self, objname, groupname):\n        return self.__itemsby(self.polylines, objname, groupname)\n\n    def __eggifyverts(self, eprim, evpool, vlist):\n        for vertex in vlist:\n            ixyz = vertex[\'v\']\n            vinfo = self.points[ixyz-1]\n            vxyz, vmeta = vinfo\n            ev = EggVertex()\n            ev.setPos(Point3D(vxyz[0], vxyz[1], vxyz[2]))\n            iuv = vertex[\'vt\']\n            if iuv is not None:\n                vuv = self.uvs[iuv-1]\n                ev.setUv(Point2D(vuv[0], vuv[1]))\n            inormal = vertex[\'vn\']\n            if inormal is not None:\n                vn = self.normals[inormal-1]\n                ev.setNormal(Vec3D(vn[0], vn[1], vn[2]))\n            evpool.addVertex(ev)\n            eprim.addVertex(ev)\n        return self\n\n    def __eggifymats(self, eprim, wmat):\n        if self.materialsbyname.has_key(wmat):\n            mtl = self.materialsbyname[wmat]\n            if mtl.isTextured():\n                eprim.setTexture(mtl.getEggTexture())\n                # NOTE: it looks like you almost always want to setMaterial()\n                #       for textured polys.... [continued below...]\n                eprim.setMaterial(mtl.getEggMaterial())\n            rgb = mtl.get(""Kd"")\n            if rgb is not None:\n                # ... and some untextured .obj\'s store the color of the\n                # material # in the Kd settings...\n                eprim.setColor(Vec4(rgb[0], rgb[1], rgb[2], 1.0))\n            # [continued...] but you may *not* always want to assign\n            # materials to untextured polys...  hmmmm.\n            if False:\n                eprim.setMaterial(mtl.getEggMaterial())\n        return self\n\n    def __facestoegg(self, egg, objname, groupname):\n        selectedfaces = self.__facesby(objname, groupname)\n        if len(selectedfaces) == 0:\n            return self\n        eobj = EggGroup(objname)\n        egg.addChild(eobj)\n        egrp = EggGroup(groupname)\n        eobj.addChild(egrp)\n        evpool = EggVertexPool(groupname)\n        egrp.addChild(evpool)\n        for face in selectedfaces:\n            vlist, mdata = face\n            wobj, wgrp, wmat = mdata\n            epoly = EggPolygon()\n            egrp.addChild(epoly)\n            self.__eggifymats(epoly, wmat)\n            self.__eggifyverts(epoly, evpool, vlist)\n        #; each matching face\n        return self\n\n    def __polylinestoegg(self, egg, objname, groupname):\n        selectedlines = self.__linesby(objname, groupname)\n        if len(selectedlines) == 0:\n            return self\n        eobj = EggGroup(objname)\n        egg.addChild(eobj)\n        egrp = EggGroup(groupname)\n        eobj.addChild(egrp)\n        evpool = EggVertexPool(groupname)\n        egrp.addChild(evpool)\n        for line in selectedlines:\n            vlist, mdata = line\n            wobj, wgrp, wmat = mdata\n            eline = EggLine()\n            egrp.addChild(eline)\n            self.__eggifymats(eline, wmat)\n            self.__eggifyverts(eline, evpool, vlist)\n        #; each matching line\n        return self\n\n    def toEgg(self, verbose=True):\n        if verbose: print ""converting...""\n        # make a new egg\n        egg = EggData()\n        # convert polygon faces\n        if len(self.faces) > 0:\n            for objname in self.objects:\n                for groupname in self.groups:\n                    self.__facestoegg(egg, objname, groupname)\n        # convert polylines\n        if len(self.polylines) > 0:\n            for objname in self.objects:\n                for groupname in self.groups:\n                    self.__polylinestoegg(egg, objname, groupname)\n        return egg\n\ndef pathify(path):\n    if os.path.isfile(path):\n        return path\n    # if it was written on win32, it may have \\\'s in it, and\n    # also a full rather than relative pathname (Hexagon does this... ick)\n    orig = path\n    path = path.lower()\n    path = path.replace(""\\\\"", ""/"")\n    h, t = os.path.split(path)\n    if os.path.isfile(t):\n        return t\n    print ""warning: can\'t make sense of this map file name:"", orig\n    return t\n    \ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv\n    try:\n        opts, args = getopt.getopt(argv[1:], ""hn:bs"", [""help"", ""normals"", ""binormals"", ""show""])\n    except getopt.error, msg:\n        print msg\n        print __doc__\n        return 2\n    show = False\n    for o, a in opts:\n        if o in (""-h"", ""--help""):\n            print __doc__\n            return 0\n        elif o in (""-s"", ""--show""):\n            show = True\n    for infile in args:\n        try:\n            if "".obj"" not in infile:\n                print ""WARNING"", finfile, ""does not look like a valid obj file""\n                continue\n            obj = ObjFile(infile)\n            egg = obj.toEgg()\n            f, e = os.path.splitext(infile)\n            outfile = f + "".egg""\n            for o, a in opts:\n                if o in (""-n"", ""--normals""):\n                    egg.recomputeVertexNormals(float(a))\n                elif o in (""-b"", ""--binormals""):\n                    egg.recomputeTangentBinormal(GlobPattern(""""))\n            egg.removeUnusedVertices(GlobPattern(""""))\n            if True:\n                egg.triangulatePolygons(EggData.TConvex & EggData.TPolygon)\n            if True:\n                egg.recomputePolygonNormals()\n            egg.writeEgg(Filename(outfile))\n            if show:\n                os.system(""pview "" + outfile)\n        except Exception,e:\n            print e\n    return 0\n\nif __name__ == ""__main__"":\n    sys.exit(main())\n\n\n'"
util/py/augment_samples.py,0,"b'#!/usr/local/bin/python\n\n# Augment samples\nimport os\nimport sys\nimport json\nimport math\nimport numpy as np\n\nmax_theta = math.pi / 4\nmax_scale_delta = 0.2\n\ndef img_size(imgname):\n    w, h = os.popen(\'identify -format ""%wx%h"" \' + imgname).read().split(""x"")\n    return int(w), int(h)\n\ndef img_rotate_scale(imgname, angle, scale, landmark, dest_dir, annotate=False):\n    # Rotate image.\n    noext, ext = os.path.splitext(imgname)\n    angle_degree = angle / math.pi * 180\n\n    w, h = img_size(imgname)\n    x0, y0 = float(w) / 2, float(h) / 2\n\n    c = math.cos(angle)\n    s = math.sin(angle)\n\n    xs = landmark[""x""]\n    ys = landmark[""y""]\n\n    # Convert landmark accordingly.\n    new_xs = []\n    new_ys = []\n    for i in range(len(xs)):\n        dx = xs[i] - x0\n        dy = ys[i] - y0\n\n        new_xs.append(int(scale * (dx * c - dy * s) + x0 + 0.5))\n        new_ys.append(int(scale * (dx * s + dy * c) + y0 + 0.5))\n\n    annotation_command = """"\n    if annotate:\n        annotation_command = ""-fill \'#0008\'""\n        annotation_command += \\\n            """".join(["" -draw \'rectangle %d,%d,%d,%d\'"" % (xx - 2, yy - 2, xx + 2, yy + 2) for xx, yy in zip(new_xs, new_ys)])\n\n    fn_output = noext + ""_a%.3f_s%.3f.png"" % (angle_degree, scale)\n    os.system(""convert %s -distort SRT \'%f,%f %f,%f %f\' %s %s"" % (imgname, x0, y0, scale, scale, angle_degree, annotation_command, os.path.join(dest_dir, fn_output) ))\n\n    return fn_output, { ""x"" : new_xs, ""y"" : new_ys }\n\n# Load stuff from current dir.\n\'\'\'\nInput: landmarks.json and a dest_dir (sys.argv[1])\n    landmarks.json has the following format:\n    {\n        filename1 : landmark_location1\n        filename2 : landmark_location2\n    }\n\n    landmark_location1 = { x : [x1, x2, x3], y : [y1, y2, y3] }\n\n    sys.argv[1] is the directory we want to save all deformed image to\nOutput: \n    A bunch of images within the dest_dir with a landmarks.json.\n\n\'\'\'\n\nlandmarks = json.load(open(os.path.join(os.getcwd(), ""landmarks.json""), ""r""))\ndest_dir = sys.argv[1]\nos.system(""mkdir -p "" + dest_dir)\n\nangles = np.linspace(-max_theta, max_theta, 20)\nscales = np.linspace(1 - max_scale_delta, 1 + max_scale_delta, 20)\n\noutput_landmarks = {}\nnum_landmarks = 0\ncount = 0\nfor fn, landmark in landmarks.iteritems():\n    if not isinstance(landmark, dict): continue\n    print(""Deal with image = "" + fn)\n    for angle in angles:\n        for scale in scales:\n            fn_output, new_landmark = img_rotate_scale(fn, angle, scale, landmark, dest_dir, False)\n            output_landmarks.update({\n                fn_output : new_landmark\n            })\n            count += 1\n    num_landmarks = len(landmark[""x""])\n\noutput_landmarks.update({\n    ""num_landmarks"" : num_landmarks,\n    ""num_images"" : count \n})\n\njson.dump(output_landmarks, open(os.path.join(dest_dir, ""landmarks.json""), ""w""), sort_keys=True, indent=4)\n'"
util/py/check_gpu.py,0,"b'import os\nimport sys\nimport subprocess\nimport re\nimport math\nimport signal\n\n\n################## generate hosts list  #####################\nprefix = \'visiongpu\'\nsuffix = \'bill\'\nind_list = range(1, 15)     # range(14)?\nind_high_priority_list = [2,4,5,12,13,14]\nind_low_priority_list = [ind for ind in ind_list if ind not in ind_high_priority_list]\nhosts_hp = []\nfor ind in ind_high_priority_list:\n    host = prefix + ""{:0>2d}"".format(ind)\n    if ind > 11:\n        host += suffix\n    hosts_hp.append(host)\n\nhosts_lp = []\nfor ind in ind_low_priority_list:\n    host = prefix + ""{:0>2d}"".format(ind)\n    if ind > 11:\n        host += suffix\n    hosts_lp.append(host)\n\n\nusers = [\'ckzhang\',\'jiajunwu\']\ntimeout_limit = 4 # sec\n\n####################### util functions ########################\n\n#### Timeout Control ###\nclass TimeoutError(Exception):\n    pass\n\nclass timeout:\n    def __init__(self, seconds=10, error_message=\'Timeout\'):\n        self.seconds = seconds\n        self.error_message = error_message\n    def handle_timeout(self, signum, frame):\n        raise TimeoutError(self.error_message)\n    def __enter__(self):\n        signal.signal(signal.SIGALRM, self.handle_timeout)\n        signal.alarm(self.seconds)\n    def __exit__(self, type, value, traceback):\n        signal.alarm(0)\n\n#### Color output ####\nclass bcolors:\n    HEADER = \'\\033[95m\'\n    OKBLUE = \'\\033[94m\'\n    OKGREEN = \'\\033[92m\'\n    WARNING = \'\\033[93m\'\n    FAIL = \'\\033[91m\'\n    ENDC = \'\\033[0m\'\n    BOLD = \'\\033[1m\'\n    UNDERLINE = \'\\033[4m\'\n\n###################### Basic functions #######################\n\ndef ssh_nvidia(host):\n    """""" retrieve nvidia-smi data from given host""""""\n    print ""checking ""+host+\'\\t\',\n    try:\n        with timeout(seconds=timeout_limit):\n            result = subprocess.check_output(\'ssh \'+host+\' ""nvidia-smi;exit""\', shell=True)\n            print ""done""\n            return result\n    except TimeoutError, exc:\n        print ""timeout""\n        return """"\n\ndef parse_nvidia(output, users=None):\n    """"""\n    @param output nvidia-smi output\n    @return list of tuples of (occupied mem, total mem, util percentile, user memory usage), one for each gpu\n    """"""\n    if output == """":\n        return [(-1, -1, -1, 0)]\n    lines = output.strip().split(\'\\n\')\n    gpu_counter = 0\n    result = []\n    for line in lines:\n        # gpu line\n        if len(re.findall(\'[0-9]+MiB\\s*/\\s*[0-9]+MiB\', line)) > 0:\n            data = re.findall(\'[0-9]+MiB\\s*/\\s*[0-9]+MiB\\s*\\|\\s*[0-9]+%\', line)[0]\n            occupied = int(re.findall(\'[0-9]+\', data)[0])\n            total =  int(re.findall(\'[0-9]+\',data)[1])\n            util = int(re.findall(\'[0-9]+\',data)[2])\n            result.append( (occupied, total, util))\n\n            gpu_counter += 1\n\n    usage = [0]*gpu_counter\n    if users != None:\n        user_pattern = ""|"".join(users)\n        for line in lines:\n            # find user\'s usage\n            if len(re.findall(user_pattern, line)) > 0:\n                gpu_id = int(re.findall(\'[0-9]+\',line)[0])\n                mem = int(re.findall(\'[0-9]+MiB\',line)[-1][:-3])\n                usage[gpu_id] += mem\n    for gpu_id in xrange(len(usage)):\n        result[gpu_id] = result[gpu_id] + tuple([usage[gpu_id]])\n\n    return result\n\ndef collect_gpu_data(hosts, users=None):\n    """""" given list of hosts, return map of hostname to gpu usage list defined by parse_nvidia""""""\n    result = dict()\n    for host in hosts:\n        result[host] = parse_nvidia(ssh_nvidia(host), users)\n    return result\n\ndef sort_gpu(hosts_lp, hosts_hp=[], util_thres=10, mem_thres=1000):\n    """"""\n    Given lists of hosts and threshold, return number of available hosts\n    """"""\n    map_hp = collect_gpu_data(hosts_hp, users)\n    map_lp = collect_gpu_data(hosts_lp, users)\n    print ""All GPU checked. ""\n    print ""Sorting...""\n    map_merge = map_hp.copy()\n    map_merge.update(map_lp)\n    map_avail = dict()\n    for host in map_merge:\n        usable = 0\n        mem = 0\n        for gpu in map_merge[host]:\n            if gpu[0] < 0:  # Timeout\n                mem = -1\n                usable = -1\n            elif gpu[0] < mem_thres and gpu[2] < util_thres:\n                mem += (gpu[1]-gpu[0])/1000             # available memory\n                usable += 1                             # available gpu\n        map_avail[host] = (usable, mem)\n\n    hosts_lp_sorted = sorted(hosts_lp, key=lambda host: map_avail[host], reverse=True)\n    hosts_hp_sorted = sorted(hosts_hp, key=lambda host: map_avail[host], reverse=True)\n\n    return hosts_hp_sorted + hosts_lp_sorted, map_merge, map_avail\n\ndef display(hosts, resources, map_avail):\n    """""" Given list of hosts, map to resources and map to available gpu numbers and total memories, display them in order\n        Display format: hostname, available # gpu, total mem of available gpu, user used mem, then mem usage of each gpu is displayed.\n    """"""\n    print bcolors.HEADER + ""hostname\\t#gpus\\tava mem\\tuser mem gpu-specific mem usage"" + bcolors.ENDC\n\n    for host in hosts:\n        if resources[host][0][0] == -1: # Timeout\n            out = host+\'\\t\'+""Timeout""\n        else:\n            out = host+\'\\t\'+ str(map_avail[host][0])+\'\\t\'+ str(map_avail[host][1])+\'G\'+\'\\t\'+ str(int(math.ceil(sum([gpu[3] for gpu in resources[host]])/1000.)))+\'G\\t\'\n            for gpu in resources[host]:\n                out += str(gpu[0]).rjust(6)+\'/\'+str(gpu[1]).rjust(6)+\'\\t\'\n\n        if map_avail[host][0] == 4:\n            print bcolors.OKGREEN + out + bcolors.ENDC\n        elif sum([gpu[3] for gpu in resources[host]]) > 0:\n            print bcolors.OKBLUE + out + bcolors.ENDC\n        elif resources[host][0][0] == -1: # Timeout\n            print bcolors.FAIL + out + bcolors.ENDC\n        else:\n            print out\n\n## test ##\n\n#hosts_sorted, resources, map_avail = sort_gpu([], hosts_hp)\nhosts_sorted, resources, map_avail = sort_gpu(hosts_lp, hosts_hp)\ndisplay(hosts_sorted, resources, map_avail)\n\n\n\n\n'"
util/py/preprocess_face.py,0,"b'#!/usr/local/bin/python\nimport os;\nimport numpy as np\nimport json\nimport glob\nimport sys\nfrom StringIO import StringIO\n\nprefix = sys.argv[1];\n\nmargin_ratio = 0.15\nrectified_size = 50;\nput_annotation = False\n\ndef make_square(box):\n\tcx = box[0] + box[2] / 2;\n\tcy = box[1] + box[3] / 2;\n\thalf_side = min(box[2], box[3]) / 2;\n\treturn [cx - half_side, cy - half_side, 2 * half_side + 1, 2 * half_side + 1]\n\ndef convert_img(filename, box, r, annotation=None):\n\tif annotation is not None:\n\t\tannotation_command = ""-fill \'#0008\'""\n\t\tannotation_command += \\\n\t\t    """".join(["" -draw \'rectangle %d,%d,%d,%d\'"" % (x - 2, y - 2, x + 2, y + 2) for x, y in zip(annotation[""x""], annotation[""y""])])\n\telse:\n\t\tannotation_command = """";\n\n\tcommand = ""convert %s.png -crop %dx%d+%d+%d -resize %dx%d %s %s%s.png"" % (filename, int(box[2]), int(box[3]), int(box[0]), int(box[1]), r, r, annotation_command, prefix, filename)\n\t# print(command)\n\n\tif any(x < 0 for x in box) or r < 0:\n\t\tprint command;\n\telse:\n\t\tos.system(command)\n\nnum_landmarks = 68;\n# Indices start from zero.\nselected_indices = [v - 1 for v in [37, 40, 43, 46, 34, 49, 55]]\n\nannotation = {\n\t""num_landmarks"" : num_landmarks\n};\n\ncount = 0;\nfor filename in glob.glob(""*.pts""):\n\tlm_data = os.popen(""sed -n \'4,71p\' "" + filename).read();\n\t# print(lm_data)\n\tlandmarks = np.loadtxt(StringIO(lm_data));\n\tif landmarks.shape[0] != num_landmarks: continue;\n\n\t# Expand it\n\timgname, ext = os.path.splitext(filename)\n\tw, h = os.popen(\'identify -format ""%wx%h"" \' + imgname + \'.png\').read().split(""x"")\n\tw, h = int(w), int(h)\n\n\tmax_limits = np.amax(landmarks, axis=0);\n\tmin_limits = np.amin(landmarks, axis=0);\n\tw_win, h_win = max_limits[0] - min_limits[0], max_limits[1] - min_limits[1]\n\n\tw_margin, h_margin = w_win * margin_ratio, h_win * margin_ratio\n\n\tmax_limits[0] = min(max_limits[0] + w_margin, w - 1)\n\tmax_limits[1] = min(max_limits[1] + h_margin, h - 1)\n\tmin_limits[0] = max(min_limits[0] - w_margin, 0)\n\tmin_limits[1] = max(min_limits[1] - h_margin, 0)\n\n\t# print(max_limits)\n\t# print(min_limits)\n\tbox = [ min_limits[0], min_limits[1],\n\t        max_limits[0] - min_limits[0], max_limits[1] - min_limits[1]]\n\n\t# Make the box square.\n\tbox = make_square(box)\n\n\tscale = float(rectified_size) / box[2];\n\n\t# if box[2] > box[3]:\n\t# \tscale = float(rectified_size) / box[3];\n\t# \tr = [int(box[2] * scale), rectified_size]\n\t# else:\n\t# \tscale = float(rectified_size) / box[2];\n\t# \tr = [rectified_size, int(box[3] * scale)]\n\n\t# Crop and resize.\n\t# Then open the file and only crop the image.\n\tanno = {\n\t   ""x"" : [int((v - box[0]) * scale + 0.5) for v in landmarks[selected_indices, 0]],\n\t   ""y"" : [int((v - box[1]) * scale + 0.5) for v in landmarks[selected_indices, 1]],\n\t}\n\n\tif put_annotation:\n\t    convert_img(imgname, box, rectified_size, annotation=anno)\n\telse:\n            convert_img(imgname, box, rectified_size)\n\tannotation.update({ prefix + imgname + "".png"" : anno })\n\tcount += 1;\n\nannotation.update({ ""num_images"" : count })\njson.dump(annotation, open(""landmarks.json"", ""w""), sort_keys=True, indent=4);\n'"
util/py/pyutils.py,0,"b""import sys\nimport os\n\ndef compute_line_limits(w, rect):\n    '''For a line defined as ax + by + c = 0, find its two endpoints within the bounding box [x1, y1, x2, y2]'''\n    # First check the sign of the four points.\n    a, b, c = w\n    x1, y1, x2, y2 = rect\n\n    ax1 = a * x1\n    ax2 = a * x2\n    by1 = b * y1\n    by2 = b * y2\n    s11 = ax1 + by1 + c\n    s12 = ax1 + by2 + c\n    s21 = ax2 + by1 + c\n    s22 = ax2 + by2 + c\n\n    intersect = []\n    if s11 * s21 < 0: intersect.append( (-(c+by1) / float(a), y1) )\n    if s21 * s22 < 0: intersect.append( (x2, -(c+ax2) / float(b)) )\n    if s12 * s22 < 0: intersect.append( (-(c+by2) / float(a), y2) )\n    if s11 * s12 < 0: intersect.append( (x1, -(c+ax1) / float(b)) )\n\n    if len(intersect) < 2:\n        if s11 == 0: intersect.append((x1, y1))\n        if s12 == 0: intersect.append((x1, y2))\n        if s21 == 0: intersect.append((x2, y1))\n        if s22 == 0: intersect.append((x2, y2))\n\n    return intersect\n"""
