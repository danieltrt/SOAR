file_path,api_count,code
train.py,1,"b""from __future__ import  absolute_import\n# though cupy is not used but without this line, it raise errors...\nimport cupy as cp\nimport os\n\nimport ipdb\nimport matplotlib\nfrom tqdm import tqdm\n\nfrom utils.config import opt\nfrom data.dataset import Dataset, TestDataset, inverse_normalize\nfrom model import FasterRCNNVGG16\nfrom torch.utils import data as data_\nfrom trainer import FasterRCNNTrainer\nfrom utils import array_tool as at\nfrom utils.vis_tool import visdom_bbox\nfrom utils.eval_tool import eval_detection_voc\n\n# fix for ulimit\n# https://github.com/pytorch/pytorch/issues/973#issuecomment-346405667\nimport resource\n\nrlimit = resource.getrlimit(resource.RLIMIT_NOFILE)\nresource.setrlimit(resource.RLIMIT_NOFILE, (20480, rlimit[1]))\n\nmatplotlib.use('agg')\n\n\ndef eval(dataloader, faster_rcnn, test_num=10000):\n    pred_bboxes, pred_labels, pred_scores = list(), list(), list()\n    gt_bboxes, gt_labels, gt_difficults = list(), list(), list()\n    for ii, (imgs, sizes, gt_bboxes_, gt_labels_, gt_difficults_) in tqdm(enumerate(dataloader)):\n        sizes = [sizes[0][0].item(), sizes[1][0].item()]\n        pred_bboxes_, pred_labels_, pred_scores_ = faster_rcnn.predict(imgs, [sizes])\n        gt_bboxes += list(gt_bboxes_.numpy())\n        gt_labels += list(gt_labels_.numpy())\n        gt_difficults += list(gt_difficults_.numpy())\n        pred_bboxes += pred_bboxes_\n        pred_labels += pred_labels_\n        pred_scores += pred_scores_\n        if ii == test_num: break\n\n    result = eval_detection_voc(\n        pred_bboxes, pred_labels, pred_scores,\n        gt_bboxes, gt_labels, gt_difficults,\n        use_07_metric=True)\n    return result\n\n\ndef train(**kwargs):\n    opt._parse(kwargs)\n\n    dataset = Dataset(opt)\n    print('load data')\n    dataloader = data_.DataLoader(dataset, \\\n                                  batch_size=1, \\\n                                  shuffle=True, \\\n                                  # pin_memory=True,\n                                  num_workers=opt.num_workers)\n    testset = TestDataset(opt)\n    test_dataloader = data_.DataLoader(testset,\n                                       batch_size=1,\n                                       num_workers=opt.test_num_workers,\n                                       shuffle=False, \\\n                                       pin_memory=True\n                                       )\n    faster_rcnn = FasterRCNNVGG16()\n    print('model construct completed')\n    trainer = FasterRCNNTrainer(faster_rcnn).cuda()\n    if opt.load_path:\n        trainer.load(opt.load_path)\n        print('load pretrained model from %s' % opt.load_path)\n    trainer.vis.text(dataset.db.label_names, win='labels')\n    best_map = 0\n    lr_ = opt.lr\n    for epoch in range(opt.epoch):\n        trainer.reset_meters()\n        for ii, (img, bbox_, label_, scale) in tqdm(enumerate(dataloader)):\n            scale = at.scalar(scale)\n            img, bbox, label = img.cuda().float(), bbox_.cuda(), label_.cuda()\n            trainer.train_step(img, bbox, label, scale)\n\n            if (ii + 1) % opt.plot_every == 0:\n                if os.path.exists(opt.debug_file):\n                    ipdb.set_trace()\n\n                # plot loss\n                trainer.vis.plot_many(trainer.get_meter_data())\n\n                # plot groud truth bboxes\n                ori_img_ = inverse_normalize(at.tonumpy(img[0]))\n                gt_img = visdom_bbox(ori_img_,\n                                     at.tonumpy(bbox_[0]),\n                                     at.tonumpy(label_[0]))\n                trainer.vis.img('gt_img', gt_img)\n\n                # plot predicti bboxes\n                _bboxes, _labels, _scores = trainer.faster_rcnn.predict([ori_img_], visualize=True)\n                pred_img = visdom_bbox(ori_img_,\n                                       at.tonumpy(_bboxes[0]),\n                                       at.tonumpy(_labels[0]).reshape(-1),\n                                       at.tonumpy(_scores[0]))\n                trainer.vis.img('pred_img', pred_img)\n\n                # rpn confusion matrix(meter)\n                trainer.vis.text(str(trainer.rpn_cm.value().tolist()), win='rpn_cm')\n                # roi confusion matrix\n                trainer.vis.img('roi_cm', at.totensor(trainer.roi_cm.conf, False).float())\n        eval_result = eval(test_dataloader, faster_rcnn, test_num=opt.test_num)\n        trainer.vis.plot('test_map', eval_result['map'])\n        lr_ = trainer.faster_rcnn.optimizer.param_groups[0]['lr']\n        log_info = 'lr:{}, map:{},loss:{}'.format(str(lr_),\n                                                  str(eval_result['map']),\n                                                  str(trainer.get_meter_data()))\n        trainer.vis.log(log_info)\n\n        if eval_result['map'] > best_map:\n            best_map = eval_result['map']\n            best_path = trainer.save(best_map=best_map)\n        if epoch == 9:\n            trainer.load(best_path)\n            trainer.faster_rcnn.scale_lr(opt.lr_decay)\n            lr_ = lr_ * opt.lr_decay\n\n        if epoch == 13: \n            break\n\n\nif __name__ == '__main__':\n    import fire\n\n    fire.Fire()\n"""
trainer.py,4,"b'from __future__ import  absolute_import\nimport os\nfrom collections import namedtuple\nimport time\nfrom torch.nn import functional as F\nfrom model.utils.creator_tool import AnchorTargetCreator, ProposalTargetCreator\n\nfrom torch import nn\nimport torch as t\nfrom utils import array_tool as at\nfrom utils.vis_tool import Visualizer\n\nfrom utils.config import opt\nfrom torchnet.meter import ConfusionMeter, AverageValueMeter\n\nLossTuple = namedtuple(\'LossTuple\',\n                       [\'rpn_loc_loss\',\n                        \'rpn_cls_loss\',\n                        \'roi_loc_loss\',\n                        \'roi_cls_loss\',\n                        \'total_loss\'\n                        ])\n\n\nclass FasterRCNNTrainer(nn.Module):\n    """"""wrapper for conveniently training. return losses\n\n    The losses include:\n\n    * :obj:`rpn_loc_loss`: The localization loss for \\\n        Region Proposal Network (RPN).\n    * :obj:`rpn_cls_loss`: The classification loss for RPN.\n    * :obj:`roi_loc_loss`: The localization loss for the head module.\n    * :obj:`roi_cls_loss`: The classification loss for the head module.\n    * :obj:`total_loss`: The sum of 4 loss above.\n\n    Args:\n        faster_rcnn (model.FasterRCNN):\n            A Faster R-CNN model that is going to be trained.\n    """"""\n\n    def __init__(self, faster_rcnn):\n        super(FasterRCNNTrainer, self).__init__()\n\n        self.faster_rcnn = faster_rcnn\n        self.rpn_sigma = opt.rpn_sigma\n        self.roi_sigma = opt.roi_sigma\n\n        # target creator create gt_bbox gt_label etc as training targets. \n        self.anchor_target_creator = AnchorTargetCreator()\n        self.proposal_target_creator = ProposalTargetCreator()\n\n        self.loc_normalize_mean = faster_rcnn.loc_normalize_mean\n        self.loc_normalize_std = faster_rcnn.loc_normalize_std\n\n        self.optimizer = self.faster_rcnn.get_optimizer()\n        # visdom wrapper\n        self.vis = Visualizer(env=opt.env)\n\n        # indicators for training status\n        self.rpn_cm = ConfusionMeter(2)\n        self.roi_cm = ConfusionMeter(21)\n        self.meters = {k: AverageValueMeter() for k in LossTuple._fields}  # average loss\n\n    def forward(self, imgs, bboxes, labels, scale):\n        """"""Forward Faster R-CNN and calculate losses.\n\n        Here are notations used.\n\n        * :math:`N` is the batch size.\n        * :math:`R` is the number of bounding boxes per image.\n\n        Currently, only :math:`N=1` is supported.\n\n        Args:\n            imgs (~torch.autograd.Variable): A variable with a batch of images.\n            bboxes (~torch.autograd.Variable): A batch of bounding boxes.\n                Its shape is :math:`(N, R, 4)`.\n            labels (~torch.autograd..Variable): A batch of labels.\n                Its shape is :math:`(N, R)`. The background is excluded from\n                the definition, which means that the range of the value\n                is :math:`[0, L - 1]`. :math:`L` is the number of foreground\n                classes.\n            scale (float): Amount of scaling applied to\n                the raw image during preprocessing.\n\n        Returns:\n            namedtuple of 5 losses\n        """"""\n        n = bboxes.shape[0]\n        if n != 1:\n            raise ValueError(\'Currently only batch size 1 is supported.\')\n\n        _, _, H, W = imgs.shape\n        img_size = (H, W)\n\n        features = self.faster_rcnn.extractor(imgs)\n\n        rpn_locs, rpn_scores, rois, roi_indices, anchor = \\\n            self.faster_rcnn.rpn(features, img_size, scale)\n\n        # Since batch size is one, convert variables to singular form\n        bbox = bboxes[0]\n        label = labels[0]\n        rpn_score = rpn_scores[0]\n        rpn_loc = rpn_locs[0]\n        roi = rois\n\n        # Sample RoIs and forward\n        # it\'s fine to break the computation graph of rois, \n        # consider them as constant input\n        sample_roi, gt_roi_loc, gt_roi_label = self.proposal_target_creator(\n            roi,\n            at.tonumpy(bbox),\n            at.tonumpy(label),\n            self.loc_normalize_mean,\n            self.loc_normalize_std)\n        # NOTE it\'s all zero because now it only support for batch=1 now\n        sample_roi_index = t.zeros(len(sample_roi))\n        roi_cls_loc, roi_score = self.faster_rcnn.head(\n            features,\n            sample_roi,\n            sample_roi_index)\n\n        # ------------------ RPN losses -------------------#\n        gt_rpn_loc, gt_rpn_label = self.anchor_target_creator(\n            at.tonumpy(bbox),\n            anchor,\n            img_size)\n        gt_rpn_label = at.totensor(gt_rpn_label).long()\n        gt_rpn_loc = at.totensor(gt_rpn_loc)\n        rpn_loc_loss = _fast_rcnn_loc_loss(\n            rpn_loc,\n            gt_rpn_loc,\n            gt_rpn_label.data,\n            self.rpn_sigma)\n\n        # NOTE: default value of ignore_index is -100 ...\n        rpn_cls_loss = F.cross_entropy(rpn_score, gt_rpn_label.cuda(), ignore_index=-1)\n        _gt_rpn_label = gt_rpn_label[gt_rpn_label > -1]\n        _rpn_score = at.tonumpy(rpn_score)[at.tonumpy(gt_rpn_label) > -1]\n        self.rpn_cm.add(at.totensor(_rpn_score, False), _gt_rpn_label.data.long())\n\n        # ------------------ ROI losses (fast rcnn loss) -------------------#\n        n_sample = roi_cls_loc.shape[0]\n        roi_cls_loc = roi_cls_loc.view(n_sample, -1, 4)\n        roi_loc = roi_cls_loc[t.arange(0, n_sample).long().cuda(), \\\n                              at.totensor(gt_roi_label).long()]\n        gt_roi_label = at.totensor(gt_roi_label).long()\n        gt_roi_loc = at.totensor(gt_roi_loc)\n\n        roi_loc_loss = _fast_rcnn_loc_loss(\n            roi_loc.contiguous(),\n            gt_roi_loc,\n            gt_roi_label.data,\n            self.roi_sigma)\n\n        roi_cls_loss = nn.CrossEntropyLoss()(roi_score, gt_roi_label.cuda())\n\n        self.roi_cm.add(at.totensor(roi_score, False), gt_roi_label.data.long())\n\n        losses = [rpn_loc_loss, rpn_cls_loss, roi_loc_loss, roi_cls_loss]\n        losses = losses + [sum(losses)]\n\n        return LossTuple(*losses)\n\n    def train_step(self, imgs, bboxes, labels, scale):\n        self.optimizer.zero_grad()\n        losses = self.forward(imgs, bboxes, labels, scale)\n        losses.total_loss.backward()\n        self.optimizer.step()\n        self.update_meters(losses)\n        return losses\n\n    def save(self, save_optimizer=False, save_path=None, **kwargs):\n        """"""serialize models include optimizer and other info\n        return path where the model-file is stored.\n\n        Args:\n            save_optimizer (bool): whether save optimizer.state_dict().\n            save_path (string): where to save model, if it\'s None, save_path\n                is generate using time str and info from kwargs.\n        \n        Returns:\n            save_path(str): the path to save models.\n        """"""\n        save_dict = dict()\n\n        save_dict[\'model\'] = self.faster_rcnn.state_dict()\n        save_dict[\'config\'] = opt._state_dict()\n        save_dict[\'other_info\'] = kwargs\n        save_dict[\'vis_info\'] = self.vis.state_dict()\n\n        if save_optimizer:\n            save_dict[\'optimizer\'] = self.optimizer.state_dict()\n\n        if save_path is None:\n            timestr = time.strftime(\'%m%d%H%M\')\n            save_path = \'checkpoints/fasterrcnn_%s\' % timestr\n            for k_, v_ in kwargs.items():\n                save_path += \'_%s\' % v_\n\n        save_dir = os.path.dirname(save_path)\n        if not os.path.exists(save_dir):\n            os.makedirs(save_dir)\n\n        t.save(save_dict, save_path)\n        self.vis.save([self.vis.env])\n        return save_path\n\n    def load(self, path, load_optimizer=True, parse_opt=False, ):\n        state_dict = t.load(path)\n        if \'model\' in state_dict:\n            self.faster_rcnn.load_state_dict(state_dict[\'model\'])\n        else:  # legacy way, for backward compatibility\n            self.faster_rcnn.load_state_dict(state_dict)\n            return self\n        if parse_opt:\n            opt._parse(state_dict[\'config\'])\n        if \'optimizer\' in state_dict and load_optimizer:\n            self.optimizer.load_state_dict(state_dict[\'optimizer\'])\n        return self\n\n    def update_meters(self, losses):\n        loss_d = {k: at.scalar(v) for k, v in losses._asdict().items()}\n        for key, meter in self.meters.items():\n            meter.add(loss_d[key])\n\n    def reset_meters(self):\n        for key, meter in self.meters.items():\n            meter.reset()\n        self.roi_cm.reset()\n        self.rpn_cm.reset()\n\n    def get_meter_data(self):\n        return {k: v.value()[0] for k, v in self.meters.items()}\n\n\ndef _smooth_l1_loss(x, t, in_weight, sigma):\n    sigma2 = sigma ** 2\n    diff = in_weight * (x - t)\n    abs_diff = diff.abs()\n    flag = (abs_diff.data < (1. / sigma2)).float()\n    y = (flag * (sigma2 / 2.) * (diff ** 2) +\n         (1 - flag) * (abs_diff - 0.5 / sigma2))\n    return y.sum()\n\n\ndef _fast_rcnn_loc_loss(pred_loc, gt_loc, gt_label, sigma):\n    in_weight = t.zeros(gt_loc.shape).cuda()\n    # Localization loss is calculated only for positive rois.\n    # NOTE:  unlike origin implementation, \n    # we don\'t need inside_weight and outside_weight, they can calculate by gt_label\n    in_weight[(gt_label > 0).view(-1, 1).expand_as(in_weight).cuda()] = 1\n    loc_loss = _smooth_l1_loss(pred_loc, gt_loc, in_weight.detach(), sigma)\n    # Normalize by total number of negtive and positive rois.\n    loc_loss /= ((gt_label >= 0).sum().float()) # ignore gt_label==-1 for rpn_loss\n    return loc_loss\n'"
data/__init__.py,0,b''
data/dataset.py,0,"b'from __future__ import  absolute_import\nfrom __future__ import  division\nimport torch as t\nfrom data.voc_dataset import VOCBboxDataset\nfrom skimage import transform as sktsf\nfrom torchvision import transforms as tvtsf\nfrom data import util\nimport numpy as np\nfrom utils.config import opt\n\n\ndef inverse_normalize(img):\n    if opt.caffe_pretrain:\n        img = img + (np.array([122.7717, 115.9465, 102.9801]).reshape(3, 1, 1))\n        return img[::-1, :, :]\n    # approximate un-normalize for visualize\n    return (img * 0.225 + 0.45).clip(min=0, max=1) * 255\n\n\ndef pytorch_normalze(img):\n    """"""\n    https://github.com/pytorch/vision/issues/223\n    return appr -1~1 RGB\n    """"""\n    normalize = tvtsf.Normalize(mean=[0.485, 0.456, 0.406],\n                                std=[0.229, 0.224, 0.225])\n    img = normalize(t.from_numpy(img))\n    return img.numpy()\n\n\ndef caffe_normalize(img):\n    """"""\n    return appr -125-125 BGR\n    """"""\n    img = img[[2, 1, 0], :, :]  # RGB-BGR\n    img = img * 255\n    mean = np.array([122.7717, 115.9465, 102.9801]).reshape(3, 1, 1)\n    img = (img - mean).astype(np.float32, copy=True)\n    return img\n\n\ndef preprocess(img, min_size=600, max_size=1000):\n    """"""Preprocess an image for feature extraction.\n\n    The length of the shorter edge is scaled to :obj:`self.min_size`.\n    After the scaling, if the length of the longer edge is longer than\n    :param min_size:\n    :obj:`self.max_size`, the image is scaled to fit the longer edge\n    to :obj:`self.max_size`.\n\n    After resizing the image, the image is subtracted by a mean image value\n    :obj:`self.mean`.\n\n    Args:\n        img (~numpy.ndarray): An image. This is in CHW and RGB format.\n            The range of its value is :math:`[0, 255]`.\n\n    Returns:\n        ~numpy.ndarray: A preprocessed image.\n\n    """"""\n    C, H, W = img.shape\n    scale1 = min_size / min(H, W)\n    scale2 = max_size / max(H, W)\n    scale = min(scale1, scale2)\n    img = img / 255.\n    img = sktsf.resize(img, (C, H * scale, W * scale), mode=\'reflect\',anti_aliasing=False)\n    # both the longer and shorter should be less than\n    # max_size and min_size\n    if opt.caffe_pretrain:\n        normalize = caffe_normalize\n    else:\n        normalize = pytorch_normalze\n    return normalize(img)\n\n\nclass Transform(object):\n\n    def __init__(self, min_size=600, max_size=1000):\n        self.min_size = min_size\n        self.max_size = max_size\n\n    def __call__(self, in_data):\n        img, bbox, label = in_data\n        _, H, W = img.shape\n        img = preprocess(img, self.min_size, self.max_size)\n        _, o_H, o_W = img.shape\n        scale = o_H / H\n        bbox = util.resize_bbox(bbox, (H, W), (o_H, o_W))\n\n        # horizontally flip\n        img, params = util.random_flip(\n            img, x_random=True, return_param=True)\n        bbox = util.flip_bbox(\n            bbox, (o_H, o_W), x_flip=params[\'x_flip\'])\n\n        return img, bbox, label, scale\n\n\nclass Dataset:\n    def __init__(self, opt):\n        self.opt = opt\n        self.db = VOCBboxDataset(opt.voc_data_dir)\n        self.tsf = Transform(opt.min_size, opt.max_size)\n\n    def __getitem__(self, idx):\n        ori_img, bbox, label, difficult = self.db.get_example(idx)\n\n        img, bbox, label, scale = self.tsf((ori_img, bbox, label))\n        # TODO: check whose stride is negative to fix this instead copy all\n        # some of the strides of a given numpy array are negative.\n        return img.copy(), bbox.copy(), label.copy(), scale\n\n    def __len__(self):\n        return len(self.db)\n\n\nclass TestDataset:\n    def __init__(self, opt, split=\'test\', use_difficult=True):\n        self.opt = opt\n        self.db = VOCBboxDataset(opt.voc_data_dir, split=split, use_difficult=use_difficult)\n\n    def __getitem__(self, idx):\n        ori_img, bbox, label, difficult = self.db.get_example(idx)\n        img = preprocess(ori_img)\n        return img, ori_img.shape[1:], bbox, label, difficult\n\n    def __len__(self):\n        return len(self.db)\n'"
data/util.py,0,"b'import numpy as np\nfrom PIL import Image\nimport random\n\n\ndef read_image(path, dtype=np.float32, color=True):\n    """"""Read an image from a file.\n\n    This function reads an image from given file. The image is CHW format and\n    the range of its value is :math:`[0, 255]`. If :obj:`color = True`, the\n    order of the channels is RGB.\n\n    Args:\n        path (str): A path of image file.\n        dtype: The type of array. The default value is :obj:`~numpy.float32`.\n        color (bool): This option determines the number of channels.\n            If :obj:`True`, the number of channels is three. In this case,\n            the order of the channels is RGB. This is the default behaviour.\n            If :obj:`False`, this function returns a grayscale image.\n\n    Returns:\n        ~numpy.ndarray: An image.\n    """"""\n\n    f = Image.open(path)\n    try:\n        if color:\n            img = f.convert(\'RGB\')\n        else:\n            img = f.convert(\'P\')\n        img = np.asarray(img, dtype=dtype)\n    finally:\n        if hasattr(f, \'close\'):\n            f.close()\n\n    if img.ndim == 2:\n        # reshape (H, W) -> (1, H, W)\n        return img[np.newaxis]\n    else:\n        # transpose (H, W, C) -> (C, H, W)\n        return img.transpose((2, 0, 1))\n\n\ndef resize_bbox(bbox, in_size, out_size):\n    """"""Resize bounding boxes according to image resize.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): An array whose shape is :math:`(R, 4)`.\n            :math:`R` is the number of bounding boxes.\n        in_size (tuple): A tuple of length 2. The height and the width\n            of the image before resized.\n        out_size (tuple): A tuple of length 2. The height and the width\n            of the image after resized.\n\n    Returns:\n        ~numpy.ndarray:\n        Bounding boxes rescaled according to the given image shapes.\n\n    """"""\n    bbox = bbox.copy()\n    y_scale = float(out_size[0]) / in_size[0]\n    x_scale = float(out_size[1]) / in_size[1]\n    bbox[:, 0] = y_scale * bbox[:, 0]\n    bbox[:, 2] = y_scale * bbox[:, 2]\n    bbox[:, 1] = x_scale * bbox[:, 1]\n    bbox[:, 3] = x_scale * bbox[:, 3]\n    return bbox\n\n\ndef flip_bbox(bbox, size, y_flip=False, x_flip=False):\n    """"""Flip bounding boxes accordingly.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): An array whose shape is :math:`(R, 4)`.\n            :math:`R` is the number of bounding boxes.\n        size (tuple): A tuple of length 2. The height and the width\n            of the image before resized.\n        y_flip (bool): Flip bounding box according to a vertical flip of\n            an image.\n        x_flip (bool): Flip bounding box according to a horizontal flip of\n            an image.\n\n    Returns:\n        ~numpy.ndarray:\n        Bounding boxes flipped according to the given flips.\n\n    """"""\n    H, W = size\n    bbox = bbox.copy()\n    if y_flip:\n        y_max = H - bbox[:, 0]\n        y_min = H - bbox[:, 2]\n        bbox[:, 0] = y_min\n        bbox[:, 2] = y_max\n    if x_flip:\n        x_max = W - bbox[:, 1]\n        x_min = W - bbox[:, 3]\n        bbox[:, 1] = x_min\n        bbox[:, 3] = x_max\n    return bbox\n\n\ndef crop_bbox(\n        bbox, y_slice=None, x_slice=None,\n        allow_outside_center=True, return_param=False):\n    """"""Translate bounding boxes to fit within the cropped area of an image.\n\n    This method is mainly used together with image cropping.\n    This method translates the coordinates of bounding boxes like\n    :func:`data.util.translate_bbox`. In addition,\n    this function truncates the bounding boxes to fit within the cropped area.\n    If a bounding box does not overlap with the cropped area,\n    this bounding box will be removed.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): Bounding boxes to be transformed. The shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n        y_slice (slice): The slice of y axis.\n        x_slice (slice): The slice of x axis.\n        allow_outside_center (bool): If this argument is :obj:`False`,\n            bounding boxes whose centers are outside of the cropped area\n            are removed. The default value is :obj:`True`.\n        return_param (bool): If :obj:`True`, this function returns\n            indices of kept bounding boxes.\n\n    Returns:\n        ~numpy.ndarray or (~numpy.ndarray, dict):\n\n        If :obj:`return_param = False`, returns an array :obj:`bbox`.\n\n        If :obj:`return_param = True`,\n        returns a tuple whose elements are :obj:`bbox, param`.\n        :obj:`param` is a dictionary of intermediate parameters whose\n        contents are listed below with key, value-type and the description\n        of the value.\n\n        * **index** (*numpy.ndarray*): An array holding indices of used \\\n            bounding boxes.\n\n    """"""\n\n    t, b = _slice_to_bounds(y_slice)\n    l, r = _slice_to_bounds(x_slice)\n    crop_bb = np.array((t, l, b, r))\n\n    if allow_outside_center:\n        mask = np.ones(bbox.shape[0], dtype=bool)\n    else:\n        center = (bbox[:, :2] + bbox[:, 2:]) / 2.0\n        mask = np.logical_and(crop_bb[:2] <= center, center < crop_bb[2:]) \\\n            .all(axis=1)\n\n    bbox = bbox.copy()\n    bbox[:, :2] = np.maximum(bbox[:, :2], crop_bb[:2])\n    bbox[:, 2:] = np.minimum(bbox[:, 2:], crop_bb[2:])\n    bbox[:, :2] -= crop_bb[:2]\n    bbox[:, 2:] -= crop_bb[:2]\n\n    mask = np.logical_and(mask, (bbox[:, :2] < bbox[:, 2:]).all(axis=1))\n    bbox = bbox[mask]\n\n    if return_param:\n        return bbox, {\'index\': np.flatnonzero(mask)}\n    else:\n        return bbox\n\n\ndef _slice_to_bounds(slice_):\n    if slice_ is None:\n        return 0, np.inf\n\n    if slice_.start is None:\n        l = 0\n    else:\n        l = slice_.start\n\n    if slice_.stop is None:\n        u = np.inf\n    else:\n        u = slice_.stop\n\n    return l, u\n\n\ndef translate_bbox(bbox, y_offset=0, x_offset=0):\n    """"""Translate bounding boxes.\n\n    This method is mainly used together with image transforms, such as padding\n    and cropping, which translates the left top point of the image from\n    coordinate :math:`(0, 0)` to coordinate\n    :math:`(y, x) = (y_{offset}, x_{offset})`.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): Bounding boxes to be transformed. The shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n        y_offset (int or float): The offset along y axis.\n        x_offset (int or float): The offset along x axis.\n\n    Returns:\n        ~numpy.ndarray:\n        Bounding boxes translated according to the given offsets.\n\n    """"""\n\n    out_bbox = bbox.copy()\n    out_bbox[:, :2] += (y_offset, x_offset)\n    out_bbox[:, 2:] += (y_offset, x_offset)\n\n    return out_bbox\n\n\ndef random_flip(img, y_random=False, x_random=False,\n                return_param=False, copy=False):\n    """"""Randomly flip an image in vertical or horizontal direction.\n\n    Args:\n        img (~numpy.ndarray): An array that gets flipped. This is in\n            CHW format.\n        y_random (bool): Randomly flip in vertical direction.\n        x_random (bool): Randomly flip in horizontal direction.\n        return_param (bool): Returns information of flip.\n        copy (bool): If False, a view of :obj:`img` will be returned.\n\n    Returns:\n        ~numpy.ndarray or (~numpy.ndarray, dict):\n\n        If :obj:`return_param = False`,\n        returns an array :obj:`out_img` that is the result of flipping.\n\n        If :obj:`return_param = True`,\n        returns a tuple whose elements are :obj:`out_img, param`.\n        :obj:`param` is a dictionary of intermediate parameters whose\n        contents are listed below with key, value-type and the description\n        of the value.\n\n        * **y_flip** (*bool*): Whether the image was flipped in the\\\n            vertical direction or not.\n        * **x_flip** (*bool*): Whether the image was flipped in the\\\n            horizontal direction or not.\n\n    """"""\n    y_flip, x_flip = False, False\n    if y_random:\n        y_flip = random.choice([True, False])\n    if x_random:\n        x_flip = random.choice([True, False])\n\n    if y_flip:\n        img = img[:, ::-1, :]\n    if x_flip:\n        img = img[:, :, ::-1]\n\n    if copy:\n        img = img.copy()\n\n    if return_param:\n        return img, {\'y_flip\': y_flip, \'x_flip\': x_flip}\n    else:\n        return img\n'"
data/voc_dataset.py,0,"b'import os\nimport xml.etree.ElementTree as ET\n\nimport numpy as np\n\nfrom .util import read_image\n\n\nclass VOCBboxDataset:\n    """"""Bounding box dataset for PASCAL `VOC`_.\n\n    .. _`VOC`: http://host.robots.ox.ac.uk/pascal/VOC/voc2012/\n\n    The index corresponds to each image.\n\n    When queried by an index, if :obj:`return_difficult == False`,\n    this dataset returns a corresponding\n    :obj:`img, bbox, label`, a tuple of an image, bounding boxes and labels.\n    This is the default behaviour.\n    If :obj:`return_difficult == True`, this dataset returns corresponding\n    :obj:`img, bbox, label, difficult`. :obj:`difficult` is a boolean array\n    that indicates whether bounding boxes are labeled as difficult or not.\n\n    The bounding boxes are packed into a two dimensional tensor of shape\n    :math:`(R, 4)`, where :math:`R` is the number of bounding boxes in\n    the image. The second axis represents attributes of the bounding box.\n    They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`, where the\n    four attributes are coordinates of the top left and the bottom right\n    vertices.\n\n    The labels are packed into a one dimensional tensor of shape :math:`(R,)`.\n    :math:`R` is the number of bounding boxes in the image.\n    The class name of the label :math:`l` is :math:`l` th element of\n    :obj:`VOC_BBOX_LABEL_NAMES`.\n\n    The array :obj:`difficult` is a one dimensional boolean array of shape\n    :math:`(R,)`. :math:`R` is the number of bounding boxes in the image.\n    If :obj:`use_difficult` is :obj:`False`, this array is\n    a boolean array with all :obj:`False`.\n\n    The type of the image, the bounding boxes and the labels are as follows.\n\n    * :obj:`img.dtype == numpy.float32`\n    * :obj:`bbox.dtype == numpy.float32`\n    * :obj:`label.dtype == numpy.int32`\n    * :obj:`difficult.dtype == numpy.bool`\n\n    Args:\n        data_dir (string): Path to the root of the training data. \n            i.e. ""/data/image/voc/VOCdevkit/VOC2007/""\n        split ({\'train\', \'val\', \'trainval\', \'test\'}): Select a split of the\n            dataset. :obj:`test` split is only available for\n            2007 dataset.\n        year ({\'2007\', \'2012\'}): Use a dataset prepared for a challenge\n            held in :obj:`year`.\n        use_difficult (bool): If :obj:`True`, use images that are labeled as\n            difficult in the original annotation.\n        return_difficult (bool): If :obj:`True`, this dataset returns\n            a boolean array\n            that indicates whether bounding boxes are labeled as difficult\n            or not. The default value is :obj:`False`.\n\n    """"""\n\n    def __init__(self, data_dir, split=\'trainval\',\n                 use_difficult=False, return_difficult=False,\n                 ):\n\n        # if split not in [\'train\', \'trainval\', \'val\']:\n        #     if not (split == \'test\' and year == \'2007\'):\n        #         warnings.warn(\n        #             \'please pick split from \\\'train\\\', \\\'trainval\\\', \\\'val\\\'\'\n        #             \'for 2012 dataset. For 2007 dataset, you can pick \\\'test\\\'\'\n        #             \' in addition to the above mentioned splits.\'\n        #         )\n        id_list_file = os.path.join(\n            data_dir, \'ImageSets/Main/{0}.txt\'.format(split))\n\n        self.ids = [id_.strip() for id_ in open(id_list_file)]\n        self.data_dir = data_dir\n        self.use_difficult = use_difficult\n        self.return_difficult = return_difficult\n        self.label_names = VOC_BBOX_LABEL_NAMES\n\n    def __len__(self):\n        return len(self.ids)\n\n    def get_example(self, i):\n        """"""Returns the i-th example.\n\n        Returns a color image and bounding boxes. The image is in CHW format.\n        The returned image is RGB.\n\n        Args:\n            i (int): The index of the example.\n\n        Returns:\n            tuple of an image and bounding boxes\n\n        """"""\n        id_ = self.ids[i]\n        anno = ET.parse(\n            os.path.join(self.data_dir, \'Annotations\', id_ + \'.xml\'))\n        bbox = list()\n        label = list()\n        difficult = list()\n        for obj in anno.findall(\'object\'):\n            # when in not using difficult split, and the object is\n            # difficult, skipt it.\n            if not self.use_difficult and int(obj.find(\'difficult\').text) == 1:\n                continue\n\n            difficult.append(int(obj.find(\'difficult\').text))\n            bndbox_anno = obj.find(\'bndbox\')\n            # subtract 1 to make pixel indexes 0-based\n            bbox.append([\n                int(bndbox_anno.find(tag).text) - 1\n                for tag in (\'ymin\', \'xmin\', \'ymax\', \'xmax\')])\n            name = obj.find(\'name\').text.lower().strip()\n            label.append(VOC_BBOX_LABEL_NAMES.index(name))\n        bbox = np.stack(bbox).astype(np.float32)\n        label = np.stack(label).astype(np.int32)\n        # When `use_difficult==False`, all elements in `difficult` are False.\n        difficult = np.array(difficult, dtype=np.bool).astype(np.uint8)  # PyTorch don\'t support np.bool\n\n        # Load a image\n        img_file = os.path.join(self.data_dir, \'JPEGImages\', id_ + \'.jpg\')\n        img = read_image(img_file, color=True)\n\n        # if self.return_difficult:\n        #     return img, bbox, label, difficult\n        return img, bbox, label, difficult\n\n    __getitem__ = get_example\n\n\nVOC_BBOX_LABEL_NAMES = (\n    \'aeroplane\',\n    \'bicycle\',\n    \'bird\',\n    \'boat\',\n    \'bottle\',\n    \'bus\',\n    \'car\',\n    \'cat\',\n    \'chair\',\n    \'cow\',\n    \'diningtable\',\n    \'dog\',\n    \'horse\',\n    \'motorbike\',\n    \'person\',\n    \'pottedplant\',\n    \'sheep\',\n    \'sofa\',\n    \'train\',\n    \'tvmonitor\')\n'"
misc/convert_caffe_pretrain.py,2,"b'# code from ruotian luo\n# https://github.com/ruotianluo/pytorch-faster-rcnn\nimport torch\nfrom torch.utils.model_zoo import load_url\nfrom torchvision import models\n\nsd = load_url(""https://s3-us-west-2.amazonaws.com/jcjohns-models/vgg16-00b39a1b.pth"")\nsd[\'classifier.0.weight\'] = sd[\'classifier.1.weight\']\nsd[\'classifier.0.bias\'] = sd[\'classifier.1.bias\']\ndel sd[\'classifier.1.weight\']\ndel sd[\'classifier.1.bias\']\n\nsd[\'classifier.3.weight\'] = sd[\'classifier.4.weight\']\nsd[\'classifier.3.bias\'] = sd[\'classifier.4.bias\']\ndel sd[\'classifier.4.weight\']\ndel sd[\'classifier.4.bias\']\n\nimport  os\n# speicify the path to save\nif not os.path.exists(\'checkpoints\'):\n    os.makedirs(\'checkpoints\')\ntorch.save(sd, ""checkpoints/vgg16_caffe.pth"")'"
misc/train_fast.py,1,"b""import os\n\nimport ipdb\nimport matplotlib\nfrom tqdm import tqdm\n\nfrom utils.config import opt\nfrom data.dataset import Dataset, TestDataset\nfrom model import FasterRCNNVGG16\nfrom torch.utils import data as data_\nfrom trainer import FasterRCNNTrainer\nfrom utils import array_tool as at\nfrom utils.vis_tool import visdom_bbox\nfrom utils.eval_tool import eval_detection_voc\n\nmatplotlib.use('agg')\n\ndef eval(dataloader, faster_rcnn, test_num=10000):\n    pred_bboxes, pred_labels, pred_scores = list(), list(), list()\n    gt_bboxes, gt_labels, gt_difficults = list(), list(), list()\n    for ii, (imgs, sizes, gt_bboxes_, gt_labels_, gt_difficults_) in tqdm(enumerate(dataloader)):\n        sizes = [sizes[0][0], sizes[1][0]]\n        pred_bboxes_, pred_labels_, pred_scores_ = faster_rcnn.predict(imgs, [sizes])\n        gt_bboxes += list(gt_bboxes_.numpy())\n        gt_labels += list(gt_labels_.numpy())\n        gt_difficults += list(gt_difficults_.numpy())\n        pred_bboxes += pred_bboxes_\n        pred_labels += pred_labels_\n        pred_scores += pred_scores_\n        if ii == test_num: break\n\n    result = eval_detection_voc(\n        pred_bboxes, pred_labels, pred_scores,\n        gt_bboxes, gt_labels, gt_difficults,\n        use_07_metric=True)\n    return result\n\n\ndef train(**kwargs):\n    opt._parse(kwargs)\n\n    dataset = Dataset(opt)\n    print('load data')\n    dataloader = data_.DataLoader(dataset, \\\n                                  batch_size=1, \\\n                                  shuffle=True, \\\n                                  # pin_memory=True,\n                                  num_workers=opt.num_workers)\n    testset = TestDataset(opt)\n    test_dataloader = data_.DataLoader(testset,\n                                       batch_size=1,\n                                       num_workers=2,\n                                       shuffle=False, \\\n                                       # pin_memory=True\n                                       )\n    faster_rcnn = FasterRCNNVGG16()\n    print('model construct completed')\n    trainer = FasterRCNNTrainer(faster_rcnn).cuda()\n    if opt.load_path:\n        trainer.load(opt.load_path)\n        print('load pretrained model from %s' % opt.load_path)\n\n    trainer.vis.text(dataset.db.label_names, win='labels')\n    best_map = 0\n    for epoch in range(7):\n        trainer.reset_meters()\n        for ii, (img, bbox_, label_, scale, ori_img) in tqdm(enumerate(dataloader)):\n            scale = at.scalar(scale)\n            img, bbox, label = img.cuda().float(), bbox_.cuda(), label_.cuda()\n            losses = trainer.train_step(img, bbox, label, scale)\n\n            if (ii + 1) % opt.plot_every == 0:\n                if os.path.exists(opt.debug_file):\n                    ipdb.set_trace()\n\n                # plot loss\n                trainer.vis.plot_many(trainer.get_meter_data())\n\n                # plot groud truth bboxes\n                ori_img_ = (img * 0.225 + 0.45).clamp(min=0, max=1) * 255\n                gt_img = visdom_bbox(at.tonumpy(ori_img_)[0], \n                                    at.tonumpy(bbox_)[0], \n                                    label_[0].numpy())\n                trainer.vis.img('gt_img', gt_img)\n\n                # plot predicti bboxes\n                _bboxes, _labels, _scores = trainer.faster_rcnn.predict(ori_img,visualize=True)\n                pred_img = visdom_bbox( at.tonumpy(ori_img[0]), \n                                        at.tonumpy(_bboxes[0]),\n                                        at.tonumpy(_labels[0]).reshape(-1), \n                                        at.tonumpy(_scores[0]))\n                trainer.vis.img('pred_img', pred_img)\n\n                # rpn confusion matrix(meter)\n                trainer.vis.text(str(trainer.rpn_cm.value().tolist()), win='rpn_cm')\n                # roi confusion matrix\n                trainer.vis.img('roi_cm', at.totensor(trainer.roi_cm.conf, False).float())\n        if epoch==4:\n            trainer.faster_rcnn.scale_lr(opt.lr_decay)\n\n    eval_result = eval(test_dataloader, faster_rcnn, test_num=1e100)\n    print('eval_result')\n    trainer.save(mAP=eval_result['map'])\n\nif __name__ == '__main__':\n    import fire\n\n    fire.Fire()\n"""
model/__init__.py,0,b'from model.faster_rcnn_vgg16 import FasterRCNNVGG16\n'
model/faster_rcnn.py,2,"b'from __future__ import  absolute_import\nfrom __future__ import division\nimport torch as t\nimport numpy as np\nimport cupy as cp\nfrom utils import array_tool as at\nfrom model.utils.bbox_tools import loc2bbox\nfrom model.utils.nms import non_maximum_suppression\n\nfrom torch import nn\nfrom data.dataset import preprocess\nfrom torch.nn import functional as F\nfrom utils.config import opt\n\n\ndef nograd(f):\n    def new_f(*args,**kwargs):\n        with t.no_grad():\n           return f(*args,**kwargs)\n    return new_f\n\nclass FasterRCNN(nn.Module):\n    """"""Base class for Faster R-CNN.\n\n    This is a base class for Faster R-CNN links supporting object detection\n    API [#]_. The following three stages constitute Faster R-CNN.\n\n    1. **Feature extraction**: Images are taken and their \\\n        feature maps are calculated.\n    2. **Region Proposal Networks**: Given the feature maps calculated in \\\n        the previous stage, produce set of RoIs around objects.\n    3. **Localization and Classification Heads**: Using feature maps that \\\n        belong to the proposed RoIs, classify the categories of the objects \\\n        in the RoIs and improve localizations.\n\n    Each stage is carried out by one of the callable\n    :class:`torch.nn.Module` objects :obj:`feature`, :obj:`rpn` and :obj:`head`.\n\n    There are two functions :meth:`predict` and :meth:`__call__` to conduct\n    object detection.\n    :meth:`predict` takes images and returns bounding boxes that are converted\n    to image coordinates. This will be useful for a scenario when\n    Faster R-CNN is treated as a black box function, for instance.\n    :meth:`__call__` is provided for a scnerario when intermediate outputs\n    are needed, for instance, for training and debugging.\n\n    Links that support obejct detection API have method :meth:`predict` with\n    the same interface. Please refer to :meth:`predict` for\n    further details.\n\n    .. [#] Shaoqing Ren, Kaiming He, Ross Girshick, Jian Sun. \\\n    Faster R-CNN: Towards Real-Time Object Detection with \\\n    Region Proposal Networks. NIPS 2015.\n\n    Args:\n        extractor (nn.Module): A module that takes a BCHW image\n            array and returns feature maps.\n        rpn (nn.Module): A module that has the same interface as\n            :class:`model.region_proposal_network.RegionProposalNetwork`.\n            Please refer to the documentation found there.\n        head (nn.Module): A module that takes\n            a BCHW variable, RoIs and batch indices for RoIs. This returns class\n            dependent localization paramters and class scores.\n        loc_normalize_mean (tuple of four floats): Mean values of\n            localization estimates.\n        loc_normalize_std (tupler of four floats): Standard deviation\n            of localization estimates.\n\n    """"""\n\n    def __init__(self, extractor, rpn, head,\n                loc_normalize_mean = (0., 0., 0., 0.),\n                loc_normalize_std = (0.1, 0.1, 0.2, 0.2)\n    ):\n        super(FasterRCNN, self).__init__()\n        self.extractor = extractor\n        self.rpn = rpn\n        self.head = head\n\n        # mean and std\n        self.loc_normalize_mean = loc_normalize_mean\n        self.loc_normalize_std = loc_normalize_std\n        self.use_preset(\'evaluate\')\n\n    @property\n    def n_class(self):\n        # Total number of classes including the background.\n        return self.head.n_class\n\n    def forward(self, x, scale=1.):\n        """"""Forward Faster R-CNN.\n\n        Scaling paramter :obj:`scale` is used by RPN to determine the\n        threshold to select small objects, which are going to be\n        rejected irrespective of their confidence scores.\n\n        Here are notations used.\n\n        * :math:`N` is the number of batch size\n        * :math:`R\'` is the total number of RoIs produced across batches. \\\n            Given :math:`R_i` proposed RoIs from the :math:`i` th image, \\\n            :math:`R\' = \\\\sum _{i=1} ^ N R_i`.\n        * :math:`L` is the number of classes excluding the background.\n\n        Classes are ordered by the background, the first class, ..., and\n        the :math:`L` th class.\n\n        Args:\n            x (autograd.Variable): 4D image variable.\n            scale (float): Amount of scaling applied to the raw image\n                during preprocessing.\n\n        Returns:\n            Variable, Variable, array, array:\n            Returns tuple of four values listed below.\n\n            * **roi_cls_locs**: Offsets and scalings for the proposed RoIs. \\\n                Its shape is :math:`(R\', (L + 1) \\\\times 4)`.\n            * **roi_scores**: Class predictions for the proposed RoIs. \\\n                Its shape is :math:`(R\', L + 1)`.\n            * **rois**: RoIs proposed by RPN. Its shape is \\\n                :math:`(R\', 4)`.\n            * **roi_indices**: Batch indices of RoIs. Its shape is \\\n                :math:`(R\',)`.\n\n        """"""\n        img_size = x.shape[2:]\n\n        h = self.extractor(x)\n        rpn_locs, rpn_scores, rois, roi_indices, anchor = \\\n            self.rpn(h, img_size, scale)\n        roi_cls_locs, roi_scores = self.head(\n            h, rois, roi_indices)\n        return roi_cls_locs, roi_scores, rois, roi_indices\n\n    def use_preset(self, preset):\n        """"""Use the given preset during prediction.\n\n        This method changes values of :obj:`self.nms_thresh` and\n        :obj:`self.score_thresh`. These values are a threshold value\n        used for non maximum suppression and a threshold value\n        to discard low confidence proposals in :meth:`predict`,\n        respectively.\n\n        If the attributes need to be changed to something\n        other than the values provided in the presets, please modify\n        them by directly accessing the public attributes.\n\n        Args:\n            preset ({\'visualize\', \'evaluate\'): A string to determine the\n                preset to use.\n\n        """"""\n        if preset == \'visualize\':\n            self.nms_thresh = 0.3\n            self.score_thresh = 0.7\n        elif preset == \'evaluate\':\n            self.nms_thresh = 0.3\n            self.score_thresh = 0.05\n        else:\n            raise ValueError(\'preset must be visualize or evaluate\')\n\n    def _suppress(self, raw_cls_bbox, raw_prob):\n        bbox = list()\n        label = list()\n        score = list()\n        # skip cls_id = 0 because it is the background class\n        for l in range(1, self.n_class):\n            cls_bbox_l = raw_cls_bbox.reshape((-1, self.n_class, 4))[:, l, :]\n            prob_l = raw_prob[:, l]\n            mask = prob_l > self.score_thresh\n            cls_bbox_l = cls_bbox_l[mask]\n            prob_l = prob_l[mask]\n            keep = non_maximum_suppression(\n                cp.array(cls_bbox_l), self.nms_thresh, prob_l)\n            keep = cp.asnumpy(keep)\n            bbox.append(cls_bbox_l[keep])\n            # The labels are in [0, self.n_class - 2].\n            label.append((l - 1) * np.ones((len(keep),)))\n            score.append(prob_l[keep])\n        bbox = np.concatenate(bbox, axis=0).astype(np.float32)\n        label = np.concatenate(label, axis=0).astype(np.int32)\n        score = np.concatenate(score, axis=0).astype(np.float32)\n        return bbox, label, score\n\n    @nograd\n    def predict(self, imgs,sizes=None,visualize=False):\n        """"""Detect objects from images.\n\n        This method predicts objects for each image.\n\n        Args:\n            imgs (iterable of numpy.ndarray): Arrays holding images.\n                All images are in CHW and RGB format\n                and the range of their value is :math:`[0, 255]`.\n\n        Returns:\n           tuple of lists:\n           This method returns a tuple of three lists,\n           :obj:`(bboxes, labels, scores)`.\n\n           * **bboxes**: A list of float arrays of shape :math:`(R, 4)`, \\\n               where :math:`R` is the number of bounding boxes in a image. \\\n               Each bouding box is organized by \\\n               :math:`(y_{min}, x_{min}, y_{max}, x_{max})` \\\n               in the second axis.\n           * **labels** : A list of integer arrays of shape :math:`(R,)`. \\\n               Each value indicates the class of the bounding box. \\\n               Values are in range :math:`[0, L - 1]`, where :math:`L` is the \\\n               number of the foreground classes.\n           * **scores** : A list of float arrays of shape :math:`(R,)`. \\\n               Each value indicates how confident the prediction is.\n\n        """"""\n        self.eval()\n        if visualize:\n            self.use_preset(\'visualize\')\n            prepared_imgs = list()\n            sizes = list()\n            for img in imgs:\n                size = img.shape[1:]\n                img = preprocess(at.tonumpy(img))\n                prepared_imgs.append(img)\n                sizes.append(size)\n        else:\n             prepared_imgs = imgs \n        bboxes = list()\n        labels = list()\n        scores = list()\n        for img, size in zip(prepared_imgs, sizes):\n            img = at.totensor(img[None]).float()\n            scale = img.shape[3] / size[1]\n            roi_cls_loc, roi_scores, rois, _ = self(img, scale=scale)\n            # We are assuming that batch size is 1.\n            roi_score = roi_scores.data\n            roi_cls_loc = roi_cls_loc.data\n            roi = at.totensor(rois) / scale\n\n            # Convert predictions to bounding boxes in image coordinates.\n            # Bounding boxes are scaled to the scale of the input images.\n            mean = t.Tensor(self.loc_normalize_mean).cuda(). \\\n                repeat(self.n_class)[None]\n            std = t.Tensor(self.loc_normalize_std).cuda(). \\\n                repeat(self.n_class)[None]\n\n            roi_cls_loc = (roi_cls_loc * std + mean)\n            roi_cls_loc = roi_cls_loc.view(-1, self.n_class, 4)\n            roi = roi.view(-1, 1, 4).expand_as(roi_cls_loc)\n            cls_bbox = loc2bbox(at.tonumpy(roi).reshape((-1, 4)),\n                                at.tonumpy(roi_cls_loc).reshape((-1, 4)))\n            cls_bbox = at.totensor(cls_bbox)\n            cls_bbox = cls_bbox.view(-1, self.n_class * 4)\n            # clip bounding box\n            cls_bbox[:, 0::2] = (cls_bbox[:, 0::2]).clamp(min=0, max=size[0])\n            cls_bbox[:, 1::2] = (cls_bbox[:, 1::2]).clamp(min=0, max=size[1])\n\n            prob = at.tonumpy(F.softmax(at.totensor(roi_score), dim=1))\n\n            raw_cls_bbox = at.tonumpy(cls_bbox)\n            raw_prob = at.tonumpy(prob)\n\n            bbox, label, score = self._suppress(raw_cls_bbox, raw_prob)\n            bboxes.append(bbox)\n            labels.append(label)\n            scores.append(score)\n\n        self.use_preset(\'evaluate\')\n        self.train()\n        return bboxes, labels, scores\n\n    def get_optimizer(self):\n        """"""\n        return optimizer, It could be overwriten if you want to specify \n        special optimizer\n        """"""\n        lr = opt.lr\n        params = []\n        for key, value in dict(self.named_parameters()).items():\n            if value.requires_grad:\n                if \'bias\' in key:\n                    params += [{\'params\': [value], \'lr\': lr * 2, \'weight_decay\': 0}]\n                else:\n                    params += [{\'params\': [value], \'lr\': lr, \'weight_decay\': opt.weight_decay}]\n        if opt.use_adam:\n            self.optimizer = t.optim.Adam(params)\n        else:\n            self.optimizer = t.optim.SGD(params, momentum=0.9)\n        return self.optimizer\n\n    def scale_lr(self, decay=0.1):\n        for param_group in self.optimizer.param_groups:\n            param_group[\'lr\'] *= decay\n        return self.optimizer\n\n\n\n\n'"
model/faster_rcnn_vgg16.py,0,"b'from __future__ import  absolute_import\nimport torch as t\nfrom torch import nn\nfrom torchvision.models import vgg16\nfrom model.region_proposal_network import RegionProposalNetwork\nfrom model.faster_rcnn import FasterRCNN\nfrom model.roi_module import RoIPooling2D\nfrom utils import array_tool as at\nfrom utils.config import opt\n\n\ndef decom_vgg16():\n    # the 30th layer of features is relu of conv5_3\n    if opt.caffe_pretrain:\n        model = vgg16(pretrained=False)\n        if not opt.load_path:\n            model.load_state_dict(t.load(opt.caffe_pretrain_path))\n    else:\n        model = vgg16(not opt.load_path)\n\n    features = list(model.features)[:30]\n    classifier = model.classifier\n\n    classifier = list(classifier)\n    del classifier[6]\n    if not opt.use_drop:\n        del classifier[5]\n        del classifier[2]\n    classifier = nn.Sequential(*classifier)\n\n    # freeze top4 conv\n    for layer in features[:10]:\n        for p in layer.parameters():\n            p.requires_grad = False\n\n    return nn.Sequential(*features), classifier\n\n\nclass FasterRCNNVGG16(FasterRCNN):\n    """"""Faster R-CNN based on VGG-16.\n    For descriptions on the interface of this model, please refer to\n    :class:`model.faster_rcnn.FasterRCNN`.\n\n    Args:\n        n_fg_class (int): The number of classes excluding the background.\n        ratios (list of floats): This is ratios of width to height of\n            the anchors.\n        anchor_scales (list of numbers): This is areas of anchors.\n            Those areas will be the product of the square of an element in\n            :obj:`anchor_scales` and the original area of the reference\n            window.\n\n    """"""\n\n    feat_stride = 16  # downsample 16x for output of conv5 in vgg16\n\n    def __init__(self,\n                 n_fg_class=20,\n                 ratios=[0.5, 1, 2],\n                 anchor_scales=[8, 16, 32]\n                 ):\n                 \n        extractor, classifier = decom_vgg16()\n\n        rpn = RegionProposalNetwork(\n            512, 512,\n            ratios=ratios,\n            anchor_scales=anchor_scales,\n            feat_stride=self.feat_stride,\n        )\n\n        head = VGG16RoIHead(\n            n_class=n_fg_class + 1,\n            roi_size=7,\n            spatial_scale=(1. / self.feat_stride),\n            classifier=classifier\n        )\n\n        super(FasterRCNNVGG16, self).__init__(\n            extractor,\n            rpn,\n            head,\n        )\n\n\nclass VGG16RoIHead(nn.Module):\n    """"""Faster R-CNN Head for VGG-16 based implementation.\n    This class is used as a head for Faster R-CNN.\n    This outputs class-wise localizations and classification based on feature\n    maps in the given RoIs.\n    \n    Args:\n        n_class (int): The number of classes possibly including the background.\n        roi_size (int): Height and width of the feature maps after RoI-pooling.\n        spatial_scale (float): Scale of the roi is resized.\n        classifier (nn.Module): Two layer Linear ported from vgg16\n\n    """"""\n\n    def __init__(self, n_class, roi_size, spatial_scale,\n                 classifier):\n        # n_class includes the background\n        super(VGG16RoIHead, self).__init__()\n\n        self.classifier = classifier\n        self.cls_loc = nn.Linear(4096, n_class * 4)\n        self.score = nn.Linear(4096, n_class)\n\n        normal_init(self.cls_loc, 0, 0.001)\n        normal_init(self.score, 0, 0.01)\n\n        self.n_class = n_class\n        self.roi_size = roi_size\n        self.spatial_scale = spatial_scale\n        self.roi = RoIPooling2D(self.roi_size, self.roi_size, self.spatial_scale)\n\n    def forward(self, x, rois, roi_indices):\n        """"""Forward the chain.\n\n        We assume that there are :math:`N` batches.\n\n        Args:\n            x (Variable): 4D image variable.\n            rois (Tensor): A bounding box array containing coordinates of\n                proposal boxes.  This is a concatenation of bounding box\n                arrays from multiple images in the batch.\n                Its shape is :math:`(R\', 4)`. Given :math:`R_i` proposed\n                RoIs from the :math:`i` th image,\n                :math:`R\' = \\\\sum _{i=1} ^ N R_i`.\n            roi_indices (Tensor): An array containing indices of images to\n                which bounding boxes correspond to. Its shape is :math:`(R\',)`.\n\n        """"""\n        # in case roi_indices is  ndarray\n        roi_indices = at.totensor(roi_indices).float()\n        rois = at.totensor(rois).float()\n        indices_and_rois = t.cat([roi_indices[:, None], rois], dim=1)\n        # NOTE: important: yx->xy\n        xy_indices_and_rois = indices_and_rois[:, [0, 2, 1, 4, 3]]\n        indices_and_rois =  xy_indices_and_rois.contiguous()\n\n        pool = self.roi(x, indices_and_rois)\n        pool = pool.view(pool.size(0), -1)\n        fc7 = self.classifier(pool)\n        roi_cls_locs = self.cls_loc(fc7)\n        roi_scores = self.score(fc7)\n        return roi_cls_locs, roi_scores\n\n\ndef normal_init(m, mean, stddev, truncated=False):\n    """"""\n    weight initalizer: truncated normal and random normal.\n    """"""\n    # x is a parameter\n    if truncated:\n        m.weight.data.normal_().fmod_(2).mul_(stddev).add_(mean)  # not a perfect approximation\n    else:\n        m.weight.data.normal_(mean, stddev)\n        m.bias.data.zero_()\n'"
model/region_proposal_network.py,5,"b'import numpy as np\nfrom torch.nn import functional as F\nimport torch as t\nfrom torch import nn\n\nfrom model.utils.bbox_tools import generate_anchor_base\nfrom model.utils.creator_tool import ProposalCreator\n\n\nclass RegionProposalNetwork(nn.Module):\n    """"""Region Proposal Network introduced in Faster R-CNN.\n\n    This is Region Proposal Network introduced in Faster R-CNN [#]_.\n    This takes features extracted from images and propose\n    class agnostic bounding boxes around ""objects"".\n\n    .. [#] Shaoqing Ren, Kaiming He, Ross Girshick, Jian Sun. \\\n    Faster R-CNN: Towards Real-Time Object Detection with \\\n    Region Proposal Networks. NIPS 2015.\n\n    Args:\n        in_channels (int): The channel size of input.\n        mid_channels (int): The channel size of the intermediate tensor.\n        ratios (list of floats): This is ratios of width to height of\n            the anchors.\n        anchor_scales (list of numbers): This is areas of anchors.\n            Those areas will be the product of the square of an element in\n            :obj:`anchor_scales` and the original area of the reference\n            window.\n        feat_stride (int): Stride size after extracting features from an\n            image.\n        initialW (callable): Initial weight value. If :obj:`None` then this\n            function uses Gaussian distribution scaled by 0.1 to\n            initialize weight.\n            May also be a callable that takes an array and edits its values.\n        proposal_creator_params (dict): Key valued paramters for\n            :class:`model.utils.creator_tools.ProposalCreator`.\n\n    .. seealso::\n        :class:`~model.utils.creator_tools.ProposalCreator`\n\n    """"""\n\n    def __init__(\n            self, in_channels=512, mid_channels=512, ratios=[0.5, 1, 2],\n            anchor_scales=[8, 16, 32], feat_stride=16,\n            proposal_creator_params=dict(),\n    ):\n        super(RegionProposalNetwork, self).__init__()\n        self.anchor_base = generate_anchor_base(\n            anchor_scales=anchor_scales, ratios=ratios)\n        self.feat_stride = feat_stride\n        self.proposal_layer = ProposalCreator(self, **proposal_creator_params)\n        n_anchor = self.anchor_base.shape[0]\n        self.conv1 = nn.Conv2d(in_channels, mid_channels, 3, 1, 1)\n        self.score = nn.Conv2d(mid_channels, n_anchor * 2, 1, 1, 0)\n        self.loc = nn.Conv2d(mid_channels, n_anchor * 4, 1, 1, 0)\n        normal_init(self.conv1, 0, 0.01)\n        normal_init(self.score, 0, 0.01)\n        normal_init(self.loc, 0, 0.01)\n\n    def forward(self, x, img_size, scale=1.):\n        """"""Forward Region Proposal Network.\n\n        Here are notations.\n\n        * :math:`N` is batch size.\n        * :math:`C` channel size of the input.\n        * :math:`H` and :math:`W` are height and witdh of the input feature.\n        * :math:`A` is number of anchors assigned to each pixel.\n\n        Args:\n            x (~torch.autograd.Variable): The Features extracted from images.\n                Its shape is :math:`(N, C, H, W)`.\n            img_size (tuple of ints): A tuple :obj:`height, width`,\n                which contains image size after scaling.\n            scale (float): The amount of scaling done to the input images after\n                reading them from files.\n\n        Returns:\n            (~torch.autograd.Variable, ~torch.autograd.Variable, array, array, array):\n\n            This is a tuple of five following values.\n\n            * **rpn_locs**: Predicted bounding box offsets and scales for \\\n                anchors. Its shape is :math:`(N, H W A, 4)`.\n            * **rpn_scores**:  Predicted foreground scores for \\\n                anchors. Its shape is :math:`(N, H W A, 2)`.\n            * **rois**: A bounding box array containing coordinates of \\\n                proposal boxes.  This is a concatenation of bounding box \\\n                arrays from multiple images in the batch. \\\n                Its shape is :math:`(R\', 4)`. Given :math:`R_i` predicted \\\n                bounding boxes from the :math:`i` th image, \\\n                :math:`R\' = \\\\sum _{i=1} ^ N R_i`.\n            * **roi_indices**: An array containing indices of images to \\\n                which RoIs correspond to. Its shape is :math:`(R\',)`.\n            * **anchor**: Coordinates of enumerated shifted anchors. \\\n                Its shape is :math:`(H W A, 4)`.\n\n        """"""\n        n, _, hh, ww = x.shape\n        anchor = _enumerate_shifted_anchor(\n            np.array(self.anchor_base),\n            self.feat_stride, hh, ww)\n\n        n_anchor = anchor.shape[0] // (hh * ww)\n        h = F.relu(self.conv1(x))\n\n        rpn_locs = self.loc(h)\n        # UNNOTE: check whether need contiguous\n        # A: Yes\n        rpn_locs = rpn_locs.permute(0, 2, 3, 1).contiguous().view(n, -1, 4)\n        rpn_scores = self.score(h)\n        rpn_scores = rpn_scores.permute(0, 2, 3, 1).contiguous()\n        rpn_softmax_scores = F.softmax(rpn_scores.view(n, hh, ww, n_anchor, 2), dim=4)\n        rpn_fg_scores = rpn_softmax_scores[:, :, :, :, 1].contiguous()\n        rpn_fg_scores = rpn_fg_scores.view(n, -1)\n        rpn_scores = rpn_scores.view(n, -1, 2)\n\n        rois = list()\n        roi_indices = list()\n        for i in range(n):\n            roi = self.proposal_layer(\n                rpn_locs[i].cpu().data.numpy(),\n                rpn_fg_scores[i].cpu().data.numpy(),\n                anchor, img_size,\n                scale=scale)\n            batch_index = i * np.ones((len(roi),), dtype=np.int32)\n            rois.append(roi)\n            roi_indices.append(batch_index)\n\n        rois = np.concatenate(rois, axis=0)\n        roi_indices = np.concatenate(roi_indices, axis=0)\n        return rpn_locs, rpn_scores, rois, roi_indices, anchor\n\n\ndef _enumerate_shifted_anchor(anchor_base, feat_stride, height, width):\n    # Enumerate all shifted anchors:\n    #\n    # add A anchors (1, A, 4) to\n    # cell K shifts (K, 1, 4) to get\n    # shift anchors (K, A, 4)\n    # reshape to (K*A, 4) shifted anchors\n    # return (K*A, 4)\n\n    # !TODO: add support for torch.CudaTensor\n    # xp = cuda.get_array_module(anchor_base)\n    # it seems that it can\'t be boosed using GPU\n    import numpy as xp\n    shift_y = xp.arange(0, height * feat_stride, feat_stride)\n    shift_x = xp.arange(0, width * feat_stride, feat_stride)\n    shift_x, shift_y = xp.meshgrid(shift_x, shift_y)\n    shift = xp.stack((shift_y.ravel(), shift_x.ravel(),\n                      shift_y.ravel(), shift_x.ravel()), axis=1)\n\n    A = anchor_base.shape[0]\n    K = shift.shape[0]\n    anchor = anchor_base.reshape((1, A, 4)) + \\\n             shift.reshape((1, K, 4)).transpose((1, 0, 2))\n    anchor = anchor.reshape((K * A, 4)).astype(np.float32)\n    return anchor\n\n\ndef _enumerate_shifted_anchor_torch(anchor_base, feat_stride, height, width):\n    # Enumerate all shifted anchors:\n    #\n    # add A anchors (1, A, 4) to\n    # cell K shifts (K, 1, 4) to get\n    # shift anchors (K, A, 4)\n    # reshape to (K*A, 4) shifted anchors\n    # return (K*A, 4)\n\n    # !TODO: add support for torch.CudaTensor\n    # xp = cuda.get_array_module(anchor_base)\n    import torch as t\n    shift_y = t.arange(0, height * feat_stride, feat_stride)\n    shift_x = t.arange(0, width * feat_stride, feat_stride)\n    shift_x, shift_y = xp.meshgrid(shift_x, shift_y)\n    shift = xp.stack((shift_y.ravel(), shift_x.ravel(),\n                      shift_y.ravel(), shift_x.ravel()), axis=1)\n\n    A = anchor_base.shape[0]\n    K = shift.shape[0]\n    anchor = anchor_base.reshape((1, A, 4)) + \\\n             shift.reshape((1, K, 4)).transpose((1, 0, 2))\n    anchor = anchor.reshape((K * A, 4)).astype(np.float32)\n    return anchor\n\n\ndef normal_init(m, mean, stddev, truncated=False):\n    """"""\n    weight initalizer: truncated normal and random normal.\n    """"""\n    # x is a parameter\n    if truncated:\n        m.weight.data.normal_().fmod_(2).mul_(stddev).add_(mean)  # not a perfect approximation\n    else:\n        m.weight.data.normal_(mean, stddev)\n        m.bias.data.zero_()\n'"
model/roi_module.py,3,"b""from collections import namedtuple\nfrom string import Template\n\nimport cupy, torch\nimport cupy as cp\nimport torch as t\nfrom torch.autograd import Function\n\nfrom model.utils.roi_cupy import kernel_backward, kernel_forward\n\nStream = namedtuple('Stream', ['ptr'])\n\n\n@cupy.util.memoize(for_each_device=True)\ndef load_kernel(kernel_name, code, **kwargs):\n    cp.cuda.runtime.free(0)\n    code = Template(code).substitute(**kwargs)\n    kernel_code = cupy.cuda.compile_with_cache(code)\n    return kernel_code.get_function(kernel_name)\n\n\nCUDA_NUM_THREADS = 1024\n\n\ndef GET_BLOCKS(N, K=CUDA_NUM_THREADS):\n    return (N + K - 1) // K\n\n\nclass RoI(Function):\n    def __init__(self, outh, outw, spatial_scale):\n        self.forward_fn = load_kernel('roi_forward', kernel_forward)\n        self.backward_fn = load_kernel('roi_backward', kernel_backward)\n        self.outh, self.outw, self.spatial_scale = outh, outw, spatial_scale\n\n    def forward(self, x, rois):\n        # NOTE: MAKE SURE input is contiguous too\n        x = x.contiguous()\n        rois = rois.contiguous()\n        self.in_size = B, C, H, W = x.size()\n        self.N = N = rois.size(0)\n        output = t.zeros(N, C, self.outh, self.outw).cuda()\n        self.argmax_data = t.zeros(N, C, self.outh, self.outw).int().cuda()\n        self.rois = rois\n        args = [x.data_ptr(), rois.data_ptr(),\n                output.data_ptr(),\n                self.argmax_data.data_ptr(),\n                self.spatial_scale, C, H, W,\n                self.outh, self.outw,\n                output.numel()]\n        stream = Stream(ptr=torch.cuda.current_stream().cuda_stream)\n        self.forward_fn(args=args,\n                        block=(CUDA_NUM_THREADS, 1, 1),\n                        grid=(GET_BLOCKS(output.numel()), 1, 1),\n                        stream=stream)\n        return output\n\n    def backward(self, grad_output):\n        ##NOTE: IMPORTANT CONTIGUOUS\n        # TODO: input\n        grad_output = grad_output.contiguous()\n        B, C, H, W = self.in_size\n        grad_input = t.zeros(self.in_size).cuda()\n        stream = Stream(ptr=torch.cuda.current_stream().cuda_stream)\n        args = [grad_output.data_ptr(),\n                self.argmax_data.data_ptr(),\n                self.rois.data_ptr(),\n                grad_input.data_ptr(),\n                self.N, self.spatial_scale, C, H, W, self.outh, self.outw,\n                grad_input.numel()]\n        self.backward_fn(args=args,\n                         block=(CUDA_NUM_THREADS, 1, 1),\n                         grid=(GET_BLOCKS(grad_input.numel()), 1, 1),\n                         stream=stream\n                         )\n        return grad_input, None\n\n\nclass RoIPooling2D(t.nn.Module):\n\n    def __init__(self, outh, outw, spatial_scale):\n        super(RoIPooling2D, self).__init__()\n        self.RoI = RoI(outh, outw, spatial_scale)\n\n    def forward(self, x, rois):\n        return self.RoI(x, rois)\n\n\ndef test_roi_module():\n    ## fake data###\n    B, N, C, H, W, PH, PW = 2, 8, 4, 32, 32, 7, 7\n\n    bottom_data = t.randn(B, C, H, W).cuda()\n    bottom_rois = t.randn(N, 5)\n    bottom_rois[:int(N / 2), 0] = 0\n    bottom_rois[int(N / 2):, 0] = 1\n    bottom_rois[:, 1:] = (t.rand(N, 4) * 100).float()\n    bottom_rois = bottom_rois.cuda()\n    spatial_scale = 1. / 16\n    outh, outw = PH, PW\n\n    # pytorch version\n    module = RoIPooling2D(outh, outw, spatial_scale)\n    x = bottom_data.requires_grad_()\n    rois = bottom_rois.detach()\n\n    output = module(x, rois)\n    output.sum().backward()\n\n    def t2c(variable):\n        npa = variable.data.cpu().numpy()\n        return cp.array(npa)\n\n    def test_eq(variable, array, info):\n        cc = cp.asnumpy(array)\n        neq = (cc != variable.data.cpu().numpy())\n        assert neq.sum() == 0, 'test failed: %s' % info\n\n    # chainer version,if you're going to run this\n    # pip install chainer \n    import chainer.functions as F\n    from chainer import Variable\n    x_cn = Variable(t2c(x))\n\n    o_cn = F.roi_pooling_2d(x_cn, t2c(rois), outh, outw, spatial_scale)\n    test_eq(output, o_cn.array, 'forward')\n    F.sum(o_cn).backward()\n    test_eq(x.grad, x_cn.grad, 'backward')\n    print('test pass')\n"""
utils/__init__.py,0,"b'#    Copyright 2017 cy\n# \n#    Licensed under the Apache License, Version 2.0 (the ""License"");\n#    you may not use this file except in compliance with the License.\n#    You may obtain a copy of the License at\n# \n#        http://www.apache.org/licenses/LICENSE-2.0\n# \n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an ""AS IS"" BASIS,\n#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#    See the License for the specific language governing permissions and\n#    limitations under the License.\n\n'"
utils/array_tool.py,0,"b'""""""\ntools to convert specified type\n""""""\nimport torch as t\nimport numpy as np\n\n\ndef tonumpy(data):\n    if isinstance(data, np.ndarray):\n        return data\n    if isinstance(data, t.Tensor):\n        return data.detach().cpu().numpy()\n\n\ndef totensor(data, cuda=True):\n    if isinstance(data, np.ndarray):\n        tensor = t.from_numpy(data)\n    if isinstance(data, t.Tensor):\n        tensor = data.detach()\n    if cuda:\n        tensor = tensor.cuda()\n    return tensor\n\n\ndef scalar(data):\n    if isinstance(data, np.ndarray):\n        return data.reshape(1)[0]\n    if isinstance(data, t.Tensor):\n        return data.item()'"
utils/config.py,0,"b'from pprint import pprint\n\n\n# Default Configs for training\n# NOTE that, config items could be overwriten by passing argument through command line.\n# e.g. --voc-data-dir=\'./data/\'\n\nclass Config:\n    # data\n    voc_data_dir = \'/home/cy/.chainer/dataset/pfnet/chainercv/voc/VOCdevkit/VOC2007/\'\n    min_size = 600  # image resize\n    max_size = 1000 # image resize\n    num_workers = 8\n    test_num_workers = 8\n\n    # sigma for l1_smooth_loss\n    rpn_sigma = 3.\n    roi_sigma = 1.\n\n    # param for optimizer\n    # 0.0005 in origin paper but 0.0001 in tf-faster-rcnn\n    weight_decay = 0.0005\n    lr_decay = 0.1  # 1e-3 -> 1e-4\n    lr = 1e-3\n\n\n    # visualization\n    env = \'faster-rcnn\'  # visdom env\n    port = 8097\n    plot_every = 40  # vis every N iter\n\n    # preset\n    data = \'voc\'\n    pretrained_model = \'vgg16\'\n\n    # training\n    epoch = 14\n\n\n    use_adam = False # Use Adam optimizer\n    use_chainer = False # try match everything as chainer\n    use_drop = False # use dropout in RoIHead\n    # debug\n    debug_file = \'/tmp/debugf\'\n\n    test_num = 10000\n    # model\n    load_path = None\n\n    caffe_pretrain = False # use caffe pretrained model instead of torchvision\n    caffe_pretrain_path = \'checkpoints/vgg16_caffe.pth\'\n\n    def _parse(self, kwargs):\n        state_dict = self._state_dict()\n        for k, v in kwargs.items():\n            if k not in state_dict:\n                raise ValueError(\'UnKnown Option: ""--%s""\' % k)\n            setattr(self, k, v)\n\n        print(\'======user config========\')\n        pprint(self._state_dict())\n        print(\'==========end============\')\n\n    def _state_dict(self):\n        return {k: getattr(self, k) for k, _ in Config.__dict__.items() \\\n                if not k.startswith(\'_\')}\n\n\nopt = Config()\n'"
utils/eval_tool.py,0,"b'from __future__ import division\n\nfrom collections import defaultdict\nimport itertools\nimport numpy as np\nimport six\n\nfrom model.utils.bbox_tools import bbox_iou\n\n\ndef eval_detection_voc(\n        pred_bboxes, pred_labels, pred_scores, gt_bboxes, gt_labels,\n        gt_difficults=None,\n        iou_thresh=0.5, use_07_metric=False):\n    """"""Calculate average precisions based on evaluation code of PASCAL VOC.\n\n    This function evaluates predicted bounding boxes obtained from a dataset\n    which has :math:`N` images by using average precision for each class.\n    The code is based on the evaluation code used in PASCAL VOC Challenge.\n\n    Args:\n        pred_bboxes (iterable of numpy.ndarray): An iterable of :math:`N`\n            sets of bounding boxes.\n            Its index corresponds to an index for the base dataset.\n            Each element of :obj:`pred_bboxes` is a set of coordinates\n            of bounding boxes. This is an array whose shape is :math:`(R, 4)`,\n            where :math:`R` corresponds\n            to the number of bounding boxes, which may vary among boxes.\n            The second axis corresponds to\n            :math:`y_{min}, x_{min}, y_{max}, x_{max}` of a bounding box.\n        pred_labels (iterable of numpy.ndarray): An iterable of labels.\n            Similar to :obj:`pred_bboxes`, its index corresponds to an\n            index for the base dataset. Its length is :math:`N`.\n        pred_scores (iterable of numpy.ndarray): An iterable of confidence\n            scores for predicted bounding boxes. Similar to :obj:`pred_bboxes`,\n            its index corresponds to an index for the base dataset.\n            Its length is :math:`N`.\n        gt_bboxes (iterable of numpy.ndarray): An iterable of ground truth\n            bounding boxes\n            whose length is :math:`N`. An element of :obj:`gt_bboxes` is a\n            bounding box whose shape is :math:`(R, 4)`. Note that the number of\n            bounding boxes in each image does not need to be same as the number\n            of corresponding predicted boxes.\n        gt_labels (iterable of numpy.ndarray): An iterable of ground truth\n            labels which are organized similarly to :obj:`gt_bboxes`.\n        gt_difficults (iterable of numpy.ndarray): An iterable of boolean\n            arrays which is organized similarly to :obj:`gt_bboxes`.\n            This tells whether the\n            corresponding ground truth bounding box is difficult or not.\n            By default, this is :obj:`None`. In that case, this function\n            considers all bounding boxes to be not difficult.\n        iou_thresh (float): A prediction is correct if its Intersection over\n            Union with the ground truth is above this value.\n        use_07_metric (bool): Whether to use PASCAL VOC 2007 evaluation metric\n            for calculating average precision. The default value is\n            :obj:`False`.\n\n    Returns:\n        dict:\n\n        The keys, value-types and the description of the values are listed\n        below.\n\n        * **ap** (*numpy.ndarray*): An array of average precisions. \\\n            The :math:`l`-th value corresponds to the average precision \\\n            for class :math:`l`. If class :math:`l` does not exist in \\\n            either :obj:`pred_labels` or :obj:`gt_labels`, the corresponding \\\n            value is set to :obj:`numpy.nan`.\n        * **map** (*float*): The average of Average Precisions over classes.\n\n    """"""\n\n    prec, rec = calc_detection_voc_prec_rec(\n        pred_bboxes, pred_labels, pred_scores,\n        gt_bboxes, gt_labels, gt_difficults,\n        iou_thresh=iou_thresh)\n\n    ap = calc_detection_voc_ap(prec, rec, use_07_metric=use_07_metric)\n\n    return {\'ap\': ap, \'map\': np.nanmean(ap)}\n\n\ndef calc_detection_voc_prec_rec(\n        pred_bboxes, pred_labels, pred_scores, gt_bboxes, gt_labels,\n        gt_difficults=None,\n        iou_thresh=0.5):\n    """"""Calculate precision and recall based on evaluation code of PASCAL VOC.\n\n    This function calculates precision and recall of\n    predicted bounding boxes obtained from a dataset which has :math:`N`\n    images.\n    The code is based on the evaluation code used in PASCAL VOC Challenge.\n\n    Args:\n        pred_bboxes (iterable of numpy.ndarray): An iterable of :math:`N`\n            sets of bounding boxes.\n            Its index corresponds to an index for the base dataset.\n            Each element of :obj:`pred_bboxes` is a set of coordinates\n            of bounding boxes. This is an array whose shape is :math:`(R, 4)`,\n            where :math:`R` corresponds\n            to the number of bounding boxes, which may vary among boxes.\n            The second axis corresponds to\n            :math:`y_{min}, x_{min}, y_{max}, x_{max}` of a bounding box.\n        pred_labels (iterable of numpy.ndarray): An iterable of labels.\n            Similar to :obj:`pred_bboxes`, its index corresponds to an\n            index for the base dataset. Its length is :math:`N`.\n        pred_scores (iterable of numpy.ndarray): An iterable of confidence\n            scores for predicted bounding boxes. Similar to :obj:`pred_bboxes`,\n            its index corresponds to an index for the base dataset.\n            Its length is :math:`N`.\n        gt_bboxes (iterable of numpy.ndarray): An iterable of ground truth\n            bounding boxes\n            whose length is :math:`N`. An element of :obj:`gt_bboxes` is a\n            bounding box whose shape is :math:`(R, 4)`. Note that the number of\n            bounding boxes in each image does not need to be same as the number\n            of corresponding predicted boxes.\n        gt_labels (iterable of numpy.ndarray): An iterable of ground truth\n            labels which are organized similarly to :obj:`gt_bboxes`.\n        gt_difficults (iterable of numpy.ndarray): An iterable of boolean\n            arrays which is organized similarly to :obj:`gt_bboxes`.\n            This tells whether the\n            corresponding ground truth bounding box is difficult or not.\n            By default, this is :obj:`None`. In that case, this function\n            considers all bounding boxes to be not difficult.\n        iou_thresh (float): A prediction is correct if its Intersection over\n            Union with the ground truth is above this value..\n\n    Returns:\n        tuple of two lists:\n        This function returns two lists: :obj:`prec` and :obj:`rec`.\n\n        * :obj:`prec`: A list of arrays. :obj:`prec[l]` is precision \\\n            for class :math:`l`. If class :math:`l` does not exist in \\\n            either :obj:`pred_labels` or :obj:`gt_labels`, :obj:`prec[l]` is \\\n            set to :obj:`None`.\n        * :obj:`rec`: A list of arrays. :obj:`rec[l]` is recall \\\n            for class :math:`l`. If class :math:`l` that is not marked as \\\n            difficult does not exist in \\\n            :obj:`gt_labels`, :obj:`rec[l]` is \\\n            set to :obj:`None`.\n\n    """"""\n\n    pred_bboxes = iter(pred_bboxes)\n    pred_labels = iter(pred_labels)\n    pred_scores = iter(pred_scores)\n    gt_bboxes = iter(gt_bboxes)\n    gt_labels = iter(gt_labels)\n    if gt_difficults is None:\n        gt_difficults = itertools.repeat(None)\n    else:\n        gt_difficults = iter(gt_difficults)\n\n    n_pos = defaultdict(int)\n    score = defaultdict(list)\n    match = defaultdict(list)\n\n    for pred_bbox, pred_label, pred_score, gt_bbox, gt_label, gt_difficult in \\\n            six.moves.zip(\n                pred_bboxes, pred_labels, pred_scores,\n                gt_bboxes, gt_labels, gt_difficults):\n\n        if gt_difficult is None:\n            gt_difficult = np.zeros(gt_bbox.shape[0], dtype=bool)\n\n        for l in np.unique(np.concatenate((pred_label, gt_label)).astype(int)):\n            pred_mask_l = pred_label == l\n            pred_bbox_l = pred_bbox[pred_mask_l]\n            pred_score_l = pred_score[pred_mask_l]\n            # sort by score\n            order = pred_score_l.argsort()[::-1]\n            pred_bbox_l = pred_bbox_l[order]\n            pred_score_l = pred_score_l[order]\n\n            gt_mask_l = gt_label == l\n            gt_bbox_l = gt_bbox[gt_mask_l]\n            gt_difficult_l = gt_difficult[gt_mask_l]\n\n            n_pos[l] += np.logical_not(gt_difficult_l).sum()\n            score[l].extend(pred_score_l)\n\n            if len(pred_bbox_l) == 0:\n                continue\n            if len(gt_bbox_l) == 0:\n                match[l].extend((0,) * pred_bbox_l.shape[0])\n                continue\n\n            # VOC evaluation follows integer typed bounding boxes.\n            pred_bbox_l = pred_bbox_l.copy()\n            pred_bbox_l[:, 2:] += 1\n            gt_bbox_l = gt_bbox_l.copy()\n            gt_bbox_l[:, 2:] += 1\n\n            iou = bbox_iou(pred_bbox_l, gt_bbox_l)\n            gt_index = iou.argmax(axis=1)\n            # set -1 if there is no matching ground truth\n            gt_index[iou.max(axis=1) < iou_thresh] = -1\n            del iou\n\n            selec = np.zeros(gt_bbox_l.shape[0], dtype=bool)\n            for gt_idx in gt_index:\n                if gt_idx >= 0:\n                    if gt_difficult_l[gt_idx]:\n                        match[l].append(-1)\n                    else:\n                        if not selec[gt_idx]:\n                            match[l].append(1)\n                        else:\n                            match[l].append(0)\n                    selec[gt_idx] = True\n                else:\n                    match[l].append(0)\n\n    for iter_ in (\n            pred_bboxes, pred_labels, pred_scores,\n            gt_bboxes, gt_labels, gt_difficults):\n        if next(iter_, None) is not None:\n            raise ValueError(\'Length of input iterables need to be same.\')\n\n    n_fg_class = max(n_pos.keys()) + 1\n    prec = [None] * n_fg_class\n    rec = [None] * n_fg_class\n\n    for l in n_pos.keys():\n        score_l = np.array(score[l])\n        match_l = np.array(match[l], dtype=np.int8)\n\n        order = score_l.argsort()[::-1]\n        match_l = match_l[order]\n\n        tp = np.cumsum(match_l == 1)\n        fp = np.cumsum(match_l == 0)\n\n        # If an element of fp + tp is 0,\n        # the corresponding element of prec[l] is nan.\n        prec[l] = tp / (fp + tp)\n        # If n_pos[l] is 0, rec[l] is None.\n        if n_pos[l] > 0:\n            rec[l] = tp / n_pos[l]\n\n    return prec, rec\n\n\ndef calc_detection_voc_ap(prec, rec, use_07_metric=False):\n    """"""Calculate average precisions based on evaluation code of PASCAL VOC.\n\n    This function calculates average precisions\n    from given precisions and recalls.\n    The code is based on the evaluation code used in PASCAL VOC Challenge.\n\n    Args:\n        prec (list of numpy.array): A list of arrays.\n            :obj:`prec[l]` indicates precision for class :math:`l`.\n            If :obj:`prec[l]` is :obj:`None`, this function returns\n            :obj:`numpy.nan` for class :math:`l`.\n        rec (list of numpy.array): A list of arrays.\n            :obj:`rec[l]` indicates recall for class :math:`l`.\n            If :obj:`rec[l]` is :obj:`None`, this function returns\n            :obj:`numpy.nan` for class :math:`l`.\n        use_07_metric (bool): Whether to use PASCAL VOC 2007 evaluation metric\n            for calculating average precision. The default value is\n            :obj:`False`.\n\n    Returns:\n        ~numpy.ndarray:\n        This function returns an array of average precisions.\n        The :math:`l`-th value corresponds to the average precision\n        for class :math:`l`. If :obj:`prec[l]` or :obj:`rec[l]` is\n        :obj:`None`, the corresponding value is set to :obj:`numpy.nan`.\n\n    """"""\n\n    n_fg_class = len(prec)\n    ap = np.empty(n_fg_class)\n    for l in six.moves.range(n_fg_class):\n        if prec[l] is None or rec[l] is None:\n            ap[l] = np.nan\n            continue\n\n        if use_07_metric:\n            # 11 point metric\n            ap[l] = 0\n            for t in np.arange(0., 1.1, 0.1):\n                if np.sum(rec[l] >= t) == 0:\n                    p = 0\n                else:\n                    p = np.max(np.nan_to_num(prec[l])[rec[l] >= t])\n                ap[l] += p / 11\n        else:\n            # correct AP calculation\n            # first append sentinel values at the end\n            mpre = np.concatenate(([0], np.nan_to_num(prec[l]), [0]))\n            mrec = np.concatenate(([0], rec[l], [1]))\n\n            mpre = np.maximum.accumulate(mpre[::-1])[::-1]\n\n            # to calculate area under PR curve, look for points\n            # where X axis (recall) changes value\n            i = np.where(mrec[1:] != mrec[:-1])[0]\n\n            # and sum (\\Delta recall) * prec\n            ap[l] = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])\n\n    return ap\n'"
utils/vis_tool.py,0,"b'import time\n\nimport numpy as np\nimport matplotlib\nimport torch as t\nimport visdom\n\nmatplotlib.use(\'Agg\')\nfrom matplotlib import pyplot as plot\n\n# from data.voc_dataset import VOC_BBOX_LABEL_NAMES\n\n\nVOC_BBOX_LABEL_NAMES = (\n    \'fly\',\n    \'bike\',\n    \'bird\',\n    \'boat\',\n    \'pin\',\n    \'bus\',\n    \'c\',\n    \'cat\',\n    \'chair\',\n    \'cow\',\n    \'table\',\n    \'dog\',\n    \'horse\',\n    \'moto\',\n    \'p\',\n    \'plant\',\n    \'shep\',\n    \'sofa\',\n    \'train\',\n    \'tv\',\n)\n\n\ndef vis_image(img, ax=None):\n    """"""Visualize a color image.\n\n    Args:\n        img (~numpy.ndarray): An array of shape :math:`(3, height, width)`.\n            This is in RGB format and the range of its value is\n            :math:`[0, 255]`.\n        ax (matplotlib.axes.Axis): The visualization is displayed on this\n            axis. If this is :obj:`None` (default), a new axis is created.\n\n    Returns:\n        ~matploblib.axes.Axes:\n        Returns the Axes object with the plot for further tweaking.\n\n    """"""\n\n    if ax is None:\n        fig = plot.figure()\n        ax = fig.add_subplot(1, 1, 1)\n    # CHW -> HWC\n    img = img.transpose((1, 2, 0))\n    ax.imshow(img.astype(np.uint8))\n    return ax\n\n\ndef vis_bbox(img, bbox, label=None, score=None, ax=None):\n    """"""Visualize bounding boxes inside image.\n\n    Args:\n        img (~numpy.ndarray): An array of shape :math:`(3, height, width)`.\n            This is in RGB format and the range of its value is\n            :math:`[0, 255]`.\n        bbox (~numpy.ndarray): An array of shape :math:`(R, 4)`, where\n            :math:`R` is the number of bounding boxes in the image.\n            Each element is organized\n            by :math:`(y_{min}, x_{min}, y_{max}, x_{max})` in the second axis.\n        label (~numpy.ndarray): An integer array of shape :math:`(R,)`.\n            The values correspond to id for label names stored in\n            :obj:`label_names`. This is optional.\n        score (~numpy.ndarray): A float array of shape :math:`(R,)`.\n             Each value indicates how confident the prediction is.\n             This is optional.\n        label_names (iterable of strings): Name of labels ordered according\n            to label ids. If this is :obj:`None`, labels will be skipped.\n        ax (matplotlib.axes.Axis): The visualization is displayed on this\n            axis. If this is :obj:`None` (default), a new axis is created.\n\n    Returns:\n        ~matploblib.axes.Axes:\n        Returns the Axes object with the plot for further tweaking.\n\n    """"""\n\n    label_names = list(VOC_BBOX_LABEL_NAMES) + [\'bg\']\n    # add for index `-1`\n    if label is not None and not len(bbox) == len(label):\n        raise ValueError(\'The length of label must be same as that of bbox\')\n    if score is not None and not len(bbox) == len(score):\n        raise ValueError(\'The length of score must be same as that of bbox\')\n\n    # Returns newly instantiated matplotlib.axes.Axes object if ax is None\n    ax = vis_image(img, ax=ax)\n\n    # If there is no bounding box to display, visualize the image and exit.\n    if len(bbox) == 0:\n        return ax\n\n    for i, bb in enumerate(bbox):\n        xy = (bb[1], bb[0])\n        height = bb[2] - bb[0]\n        width = bb[3] - bb[1]\n        ax.add_patch(plot.Rectangle(\n            xy, width, height, fill=False, edgecolor=\'red\', linewidth=2))\n\n        caption = list()\n\n        if label is not None and label_names is not None:\n            lb = label[i]\n            if not (-1 <= lb < len(label_names)):  # modfy here to add backgroud\n                raise ValueError(\'No corresponding name is given\')\n            caption.append(label_names[lb])\n        if score is not None:\n            sc = score[i]\n            caption.append(\'{:.2f}\'.format(sc))\n\n        if len(caption) > 0:\n            ax.text(bb[1], bb[0],\n                    \': \'.join(caption),\n                    style=\'italic\',\n                    bbox={\'facecolor\': \'white\', \'alpha\': 0.5, \'pad\': 0})\n    return ax\n\n\ndef fig2data(fig):\n    """"""\n    brief Convert a Matplotlib figure to a 4D numpy array with RGBA \n    channels and return it\n\n    @param fig: a matplotlib figure\n    @return a numpy 3D array of RGBA values\n    """"""\n    # draw the renderer\n    fig.canvas.draw()\n\n    # Get the RGBA buffer from the figure\n    w, h = fig.canvas.get_width_height()\n    buf = np.fromstring(fig.canvas.tostring_argb(), dtype=np.uint8)\n    buf.shape = (w, h, 4)\n\n    # canvas.tostring_argb give pixmap in ARGB mode. Roll the ALPHA channel to have it in RGBA mode\n    buf = np.roll(buf, 3, axis=2)\n    return buf.reshape(h, w, 4)\n\n\ndef fig4vis(fig):\n    """"""\n    convert figure to ndarray\n    """"""\n    ax = fig.get_figure()\n    img_data = fig2data(ax).astype(np.int32)\n    plot.close()\n    # HWC->CHW\n    return img_data[:, :, :3].transpose((2, 0, 1)) / 255.\n\n\ndef visdom_bbox(*args, **kwargs):\n    fig = vis_bbox(*args, **kwargs)\n    data = fig4vis(fig)\n    return data\n\n\nclass Visualizer(object):\n    """"""\n    wrapper for visdom\n    you can still access naive visdom function by \n    self.line, self.scater,self._send,etc.\n    due to the implementation of `__getattr__`\n    """"""\n\n    def __init__(self, env=\'default\', **kwargs):\n        self.vis = visdom.Visdom(env=env, use_incoming_socket=False, **kwargs)\n        self._vis_kw = kwargs\n\n        # e.g.(\'loss\',23) the 23th value of loss\n        self.index = {}\n        self.log_text = \'\'\n\n    def reinit(self, env=\'default\', **kwargs):\n        """"""\n        change the config of visdom\n        """"""\n        self.vis = visdom.Visdom(env=env, **kwargs)\n        return self\n\n    def plot_many(self, d):\n        """"""\n        plot multi values\n        @params d: dict (name,value) i.e. (\'loss\',0.11)\n        """"""\n        for k, v in d.items():\n            if v is not None:\n                self.plot(k, v)\n\n    def img_many(self, d):\n        for k, v in d.items():\n            self.img(k, v)\n\n    def plot(self, name, y, **kwargs):\n        """"""\n        self.plot(\'loss\',1.00)\n        """"""\n        x = self.index.get(name, 0)\n        self.vis.line(Y=np.array([y]), X=np.array([x]),\n                      win=name,\n                      opts=dict(title=name),\n                      update=None if x == 0 else \'append\',\n                      **kwargs\n                      )\n        self.index[name] = x + 1\n\n    def img(self, name, img_, **kwargs):\n        """"""\n        self.img(\'input_img\',t.Tensor(64,64))\n        self.img(\'input_imgs\',t.Tensor(3,64,64))\n        self.img(\'input_imgs\',t.Tensor(100,1,64,64))\n        self.img(\'input_imgs\',t.Tensor(100,3,64,64),nrows=10)\n        !!don\'t ~~self.img(\'input_imgs\',t.Tensor(100,64,64),nrows=10)~~!!\n        """"""\n        self.vis.images(t.Tensor(img_).cpu().numpy(),\n                        win=name,\n                        opts=dict(title=name),\n                        **kwargs\n                        )\n\n    def log(self, info, win=\'log_text\'):\n        """"""\n        self.log({\'loss\':1,\'lr\':0.0001})\n        """"""\n        self.log_text += (\'[{time}] {info} <br>\'.format(\n            time=time.strftime(\'%m%d_%H%M%S\'), \\\n            info=info))\n        self.vis.text(self.log_text, win)\n\n    def __getattr__(self, name):\n        return getattr(self.vis, name)\n\n    def state_dict(self):\n        return {\n            \'index\': self.index,\n            \'vis_kw\': self._vis_kw,\n            \'log_text\': self.log_text,\n            \'env\': self.vis.env\n        }\n\n    def load_state_dict(self, d):\n        self.vis = visdom.Visdom(env=d.get(\'env\', self.vis.env), **(self.d.get(\'vis_kw\')))\n        self.log_text = d.get(\'log_text\', \'\')\n        self.index = d.get(\'index\', dict())\n        return self\n'"
model/utils/__init__.py,0,b''
model/utils/bbox_tools.py,0,"b'import numpy as np\nimport numpy as xp\n\nimport six\nfrom six import __init__\n\n\ndef loc2bbox(src_bbox, loc):\n    """"""Decode bounding boxes from bounding box offsets and scales.\n\n    Given bounding box offsets and scales computed by\n    :meth:`bbox2loc`, this function decodes the representation to\n    coordinates in 2D image coordinates.\n\n    Given scales and offsets :math:`t_y, t_x, t_h, t_w` and a bounding\n    box whose center is :math:`(y, x) = p_y, p_x` and size :math:`p_h, p_w`,\n    the decoded bounding box\'s center :math:`\\\\hat{g}_y`, :math:`\\\\hat{g}_x`\n    and size :math:`\\\\hat{g}_h`, :math:`\\\\hat{g}_w` are calculated\n    by the following formulas.\n\n    * :math:`\\\\hat{g}_y = p_h t_y + p_y`\n    * :math:`\\\\hat{g}_x = p_w t_x + p_x`\n    * :math:`\\\\hat{g}_h = p_h \\\\exp(t_h)`\n    * :math:`\\\\hat{g}_w = p_w \\\\exp(t_w)`\n\n    The decoding formulas are used in works such as R-CNN [#]_.\n\n    The output is same type as the type of the inputs.\n\n    .. [#] Ross Girshick, Jeff Donahue, Trevor Darrell, Jitendra Malik. \\\n    Rich feature hierarchies for accurate object detection and semantic \\\n    segmentation. CVPR 2014.\n\n    Args:\n        src_bbox (array): A coordinates of bounding boxes.\n            Its shape is :math:`(R, 4)`. These coordinates are\n            :math:`p_{ymin}, p_{xmin}, p_{ymax}, p_{xmax}`.\n        loc (array): An array with offsets and scales.\n            The shapes of :obj:`src_bbox` and :obj:`loc` should be same.\n            This contains values :math:`t_y, t_x, t_h, t_w`.\n\n    Returns:\n        array:\n        Decoded bounding box coordinates. Its shape is :math:`(R, 4)`. \\\n        The second axis contains four values \\\n        :math:`\\\\hat{g}_{ymin}, \\\\hat{g}_{xmin},\n        \\\\hat{g}_{ymax}, \\\\hat{g}_{xmax}`.\n\n    """"""\n\n    if src_bbox.shape[0] == 0:\n        return xp.zeros((0, 4), dtype=loc.dtype)\n\n    src_bbox = src_bbox.astype(src_bbox.dtype, copy=False)\n\n    src_height = src_bbox[:, 2] - src_bbox[:, 0]\n    src_width = src_bbox[:, 3] - src_bbox[:, 1]\n    src_ctr_y = src_bbox[:, 0] + 0.5 * src_height\n    src_ctr_x = src_bbox[:, 1] + 0.5 * src_width\n\n    dy = loc[:, 0::4]\n    dx = loc[:, 1::4]\n    dh = loc[:, 2::4]\n    dw = loc[:, 3::4]\n\n    ctr_y = dy * src_height[:, xp.newaxis] + src_ctr_y[:, xp.newaxis]\n    ctr_x = dx * src_width[:, xp.newaxis] + src_ctr_x[:, xp.newaxis]\n    h = xp.exp(dh) * src_height[:, xp.newaxis]\n    w = xp.exp(dw) * src_width[:, xp.newaxis]\n\n    dst_bbox = xp.zeros(loc.shape, dtype=loc.dtype)\n    dst_bbox[:, 0::4] = ctr_y - 0.5 * h\n    dst_bbox[:, 1::4] = ctr_x - 0.5 * w\n    dst_bbox[:, 2::4] = ctr_y + 0.5 * h\n    dst_bbox[:, 3::4] = ctr_x + 0.5 * w\n\n    return dst_bbox\n\n\ndef bbox2loc(src_bbox, dst_bbox):\n    """"""Encodes the source and the destination bounding boxes to ""loc"".\n\n    Given bounding boxes, this function computes offsets and scales\n    to match the source bounding boxes to the target bounding boxes.\n    Mathematcially, given a bounding box whose center is\n    :math:`(y, x) = p_y, p_x` and\n    size :math:`p_h, p_w` and the target bounding box whose center is\n    :math:`g_y, g_x` and size :math:`g_h, g_w`, the offsets and scales\n    :math:`t_y, t_x, t_h, t_w` can be computed by the following formulas.\n\n    * :math:`t_y = \\\\frac{(g_y - p_y)} {p_h}`\n    * :math:`t_x = \\\\frac{(g_x - p_x)} {p_w}`\n    * :math:`t_h = \\\\log(\\\\frac{g_h} {p_h})`\n    * :math:`t_w = \\\\log(\\\\frac{g_w} {p_w})`\n\n    The output is same type as the type of the inputs.\n    The encoding formulas are used in works such as R-CNN [#]_.\n\n    .. [#] Ross Girshick, Jeff Donahue, Trevor Darrell, Jitendra Malik. \\\n    Rich feature hierarchies for accurate object detection and semantic \\\n    segmentation. CVPR 2014.\n\n    Args:\n        src_bbox (array): An image coordinate array whose shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n            These coordinates are\n            :math:`p_{ymin}, p_{xmin}, p_{ymax}, p_{xmax}`.\n        dst_bbox (array): An image coordinate array whose shape is\n            :math:`(R, 4)`.\n            These coordinates are\n            :math:`g_{ymin}, g_{xmin}, g_{ymax}, g_{xmax}`.\n\n    Returns:\n        array:\n        Bounding box offsets and scales from :obj:`src_bbox` \\\n        to :obj:`dst_bbox`. \\\n        This has shape :math:`(R, 4)`.\n        The second axis contains four values :math:`t_y, t_x, t_h, t_w`.\n\n    """"""\n\n    height = src_bbox[:, 2] - src_bbox[:, 0]\n    width = src_bbox[:, 3] - src_bbox[:, 1]\n    ctr_y = src_bbox[:, 0] + 0.5 * height\n    ctr_x = src_bbox[:, 1] + 0.5 * width\n\n    base_height = dst_bbox[:, 2] - dst_bbox[:, 0]\n    base_width = dst_bbox[:, 3] - dst_bbox[:, 1]\n    base_ctr_y = dst_bbox[:, 0] + 0.5 * base_height\n    base_ctr_x = dst_bbox[:, 1] + 0.5 * base_width\n\n    eps = xp.finfo(height.dtype).eps\n    height = xp.maximum(height, eps)\n    width = xp.maximum(width, eps)\n\n    dy = (base_ctr_y - ctr_y) / height\n    dx = (base_ctr_x - ctr_x) / width\n    dh = xp.log(base_height / height)\n    dw = xp.log(base_width / width)\n\n    loc = xp.vstack((dy, dx, dh, dw)).transpose()\n    return loc\n\n\ndef bbox_iou(bbox_a, bbox_b):\n    """"""Calculate the Intersection of Unions (IoUs) between bounding boxes.\n\n    IoU is calculated as a ratio of area of the intersection\n    and area of the union.\n\n    This function accepts both :obj:`numpy.ndarray` and :obj:`cupy.ndarray` as\n    inputs. Please note that both :obj:`bbox_a` and :obj:`bbox_b` need to be\n    same type.\n    The output is same type as the type of the inputs.\n\n    Args:\n        bbox_a (array): An array whose shape is :math:`(N, 4)`.\n            :math:`N` is the number of bounding boxes.\n            The dtype should be :obj:`numpy.float32`.\n        bbox_b (array): An array similar to :obj:`bbox_a`,\n            whose shape is :math:`(K, 4)`.\n            The dtype should be :obj:`numpy.float32`.\n\n    Returns:\n        array:\n        An array whose shape is :math:`(N, K)`. \\\n        An element at index :math:`(n, k)` contains IoUs between \\\n        :math:`n` th bounding box in :obj:`bbox_a` and :math:`k` th bounding \\\n        box in :obj:`bbox_b`.\n\n    """"""\n    if bbox_a.shape[1] != 4 or bbox_b.shape[1] != 4:\n        raise IndexError\n\n    # top left\n    tl = xp.maximum(bbox_a[:, None, :2], bbox_b[:, :2])\n    # bottom right\n    br = xp.minimum(bbox_a[:, None, 2:], bbox_b[:, 2:])\n\n    area_i = xp.prod(br - tl, axis=2) * (tl < br).all(axis=2)\n    area_a = xp.prod(bbox_a[:, 2:] - bbox_a[:, :2], axis=1)\n    area_b = xp.prod(bbox_b[:, 2:] - bbox_b[:, :2], axis=1)\n    return area_i / (area_a[:, None] + area_b - area_i)\n\n\ndef __test():\n    pass\n\n\nif __name__ == \'__main__\':\n    __test()\n\n\ndef generate_anchor_base(base_size=16, ratios=[0.5, 1, 2],\n                         anchor_scales=[8, 16, 32]):\n    """"""Generate anchor base windows by enumerating aspect ratio and scales.\n\n    Generate anchors that are scaled and modified to the given aspect ratios.\n    Area of a scaled anchor is preserved when modifying to the given aspect\n    ratio.\n\n    :obj:`R = len(ratios) * len(anchor_scales)` anchors are generated by this\n    function.\n    The :obj:`i * len(anchor_scales) + j` th anchor corresponds to an anchor\n    generated by :obj:`ratios[i]` and :obj:`anchor_scales[j]`.\n\n    For example, if the scale is :math:`8` and the ratio is :math:`0.25`,\n    the width and the height of the base window will be stretched by :math:`8`.\n    For modifying the anchor to the given aspect ratio,\n    the height is halved and the width is doubled.\n\n    Args:\n        base_size (number): The width and the height of the reference window.\n        ratios (list of floats): This is ratios of width to height of\n            the anchors.\n        anchor_scales (list of numbers): This is areas of anchors.\n            Those areas will be the product of the square of an element in\n            :obj:`anchor_scales` and the original area of the reference\n            window.\n\n    Returns:\n        ~numpy.ndarray:\n        An array of shape :math:`(R, 4)`.\n        Each element is a set of coordinates of a bounding box.\n        The second axis corresponds to\n        :math:`(y_{min}, x_{min}, y_{max}, x_{max})` of a bounding box.\n\n    """"""\n    py = base_size / 2.\n    px = base_size / 2.\n\n    anchor_base = np.zeros((len(ratios) * len(anchor_scales), 4),\n                           dtype=np.float32)\n    for i in six.moves.range(len(ratios)):\n        for j in six.moves.range(len(anchor_scales)):\n            h = base_size * anchor_scales[j] * np.sqrt(ratios[i])\n            w = base_size * anchor_scales[j] * np.sqrt(1. / ratios[i])\n\n            index = i * len(anchor_scales) + j\n            anchor_base[index, 0] = py - h / 2.\n            anchor_base[index, 1] = px - w / 2.\n            anchor_base[index, 2] = py + h / 2.\n            anchor_base[index, 3] = px + w / 2.\n    return anchor_base\n'"
model/utils/creator_tool.py,0,"b'import numpy as np\nimport cupy as cp\n\nfrom model.utils.bbox_tools import bbox2loc, bbox_iou, loc2bbox\nfrom model.utils.nms import non_maximum_suppression\n\n\nclass ProposalTargetCreator(object):\n    """"""Assign ground truth bounding boxes to given RoIs.\n\n    The :meth:`__call__` of this class generates training targets\n    for each object proposal.\n    This is used to train Faster RCNN [#]_.\n\n    .. [#] Shaoqing Ren, Kaiming He, Ross Girshick, Jian Sun. \\\n    Faster R-CNN: Towards Real-Time Object Detection with \\\n    Region Proposal Networks. NIPS 2015.\n\n    Args:\n        n_sample (int): The number of sampled regions.\n        pos_ratio (float): Fraction of regions that is labeled as a\n            foreground.\n        pos_iou_thresh (float): IoU threshold for a RoI to be considered as a\n            foreground.\n        neg_iou_thresh_hi (float): RoI is considered to be the background\n            if IoU is in\n            [:obj:`neg_iou_thresh_hi`, :obj:`neg_iou_thresh_hi`).\n        neg_iou_thresh_lo (float): See above.\n\n    """"""\n\n    def __init__(self,\n                 n_sample=128,\n                 pos_ratio=0.25, pos_iou_thresh=0.5,\n                 neg_iou_thresh_hi=0.5, neg_iou_thresh_lo=0.0\n                 ):\n        self.n_sample = n_sample\n        self.pos_ratio = pos_ratio\n        self.pos_iou_thresh = pos_iou_thresh\n        self.neg_iou_thresh_hi = neg_iou_thresh_hi\n        self.neg_iou_thresh_lo = neg_iou_thresh_lo  # NOTE:default 0.1 in py-faster-rcnn\n\n    def __call__(self, roi, bbox, label,\n                 loc_normalize_mean=(0., 0., 0., 0.),\n                 loc_normalize_std=(0.1, 0.1, 0.2, 0.2)):\n        """"""Assigns ground truth to sampled proposals.\n\n        This function samples total of :obj:`self.n_sample` RoIs\n        from the combination of :obj:`roi` and :obj:`bbox`.\n        The RoIs are assigned with the ground truth class labels as well as\n        bounding box offsets and scales to match the ground truth bounding\n        boxes. As many as :obj:`pos_ratio * self.n_sample` RoIs are\n        sampled as foregrounds.\n\n        Offsets and scales of bounding boxes are calculated using\n        :func:`model.utils.bbox_tools.bbox2loc`.\n        Also, types of input arrays and output arrays are same.\n\n        Here are notations.\n\n        * :math:`S` is the total number of sampled RoIs, which equals \\\n            :obj:`self.n_sample`.\n        * :math:`L` is number of object classes possibly including the \\\n            background.\n\n        Args:\n            roi (array): Region of Interests (RoIs) from which we sample.\n                Its shape is :math:`(R, 4)`\n            bbox (array): The coordinates of ground truth bounding boxes.\n                Its shape is :math:`(R\', 4)`.\n            label (array): Ground truth bounding box labels. Its shape\n                is :math:`(R\',)`. Its range is :math:`[0, L - 1]`, where\n                :math:`L` is the number of foreground classes.\n            loc_normalize_mean (tuple of four floats): Mean values to normalize\n                coordinates of bouding boxes.\n            loc_normalize_std (tupler of four floats): Standard deviation of\n                the coordinates of bounding boxes.\n\n        Returns:\n            (array, array, array):\n\n            * **sample_roi**: Regions of interests that are sampled. \\\n                Its shape is :math:`(S, 4)`.\n            * **gt_roi_loc**: Offsets and scales to match \\\n                the sampled RoIs to the ground truth bounding boxes. \\\n                Its shape is :math:`(S, 4)`.\n            * **gt_roi_label**: Labels assigned to sampled RoIs. Its shape is \\\n                :math:`(S,)`. Its range is :math:`[0, L]`. The label with \\\n                value 0 is the background.\n\n        """"""\n        n_bbox, _ = bbox.shape\n\n        roi = np.concatenate((roi, bbox), axis=0)\n\n        pos_roi_per_image = np.round(self.n_sample * self.pos_ratio)\n        iou = bbox_iou(roi, bbox)\n        gt_assignment = iou.argmax(axis=1)\n        max_iou = iou.max(axis=1)\n        # Offset range of classes from [0, n_fg_class - 1] to [1, n_fg_class].\n        # The label with value 0 is the background.\n        gt_roi_label = label[gt_assignment] + 1\n\n        # Select foreground RoIs as those with >= pos_iou_thresh IoU.\n        pos_index = np.where(max_iou >= self.pos_iou_thresh)[0]\n        pos_roi_per_this_image = int(min(pos_roi_per_image, pos_index.size))\n        if pos_index.size > 0:\n            pos_index = np.random.choice(\n                pos_index, size=pos_roi_per_this_image, replace=False)\n\n        # Select background RoIs as those within\n        # [neg_iou_thresh_lo, neg_iou_thresh_hi).\n        neg_index = np.where((max_iou < self.neg_iou_thresh_hi) &\n                             (max_iou >= self.neg_iou_thresh_lo))[0]\n        neg_roi_per_this_image = self.n_sample - pos_roi_per_this_image\n        neg_roi_per_this_image = int(min(neg_roi_per_this_image,\n                                         neg_index.size))\n        if neg_index.size > 0:\n            neg_index = np.random.choice(\n                neg_index, size=neg_roi_per_this_image, replace=False)\n\n        # The indices that we\'re selecting (both positive and negative).\n        keep_index = np.append(pos_index, neg_index)\n        gt_roi_label = gt_roi_label[keep_index]\n        gt_roi_label[pos_roi_per_this_image:] = 0  # negative labels --> 0\n        sample_roi = roi[keep_index]\n\n        # Compute offsets and scales to match sampled RoIs to the GTs.\n        gt_roi_loc = bbox2loc(sample_roi, bbox[gt_assignment[keep_index]])\n        gt_roi_loc = ((gt_roi_loc - np.array(loc_normalize_mean, np.float32)\n                       ) / np.array(loc_normalize_std, np.float32))\n\n        return sample_roi, gt_roi_loc, gt_roi_label\n\n\nclass AnchorTargetCreator(object):\n    """"""Assign the ground truth bounding boxes to anchors.\n\n    Assigns the ground truth bounding boxes to anchors for training Region\n    Proposal Networks introduced in Faster R-CNN [#]_.\n\n    Offsets and scales to match anchors to the ground truth are\n    calculated using the encoding scheme of\n    :func:`model.utils.bbox_tools.bbox2loc`.\n\n    .. [#] Shaoqing Ren, Kaiming He, Ross Girshick, Jian Sun. \\\n    Faster R-CNN: Towards Real-Time Object Detection with \\\n    Region Proposal Networks. NIPS 2015.\n\n    Args:\n        n_sample (int): The number of regions to produce.\n        pos_iou_thresh (float): Anchors with IoU above this\n            threshold will be assigned as positive.\n        neg_iou_thresh (float): Anchors with IoU below this\n            threshold will be assigned as negative.\n        pos_ratio (float): Ratio of positive regions in the\n            sampled regions.\n\n    """"""\n\n    def __init__(self,\n                 n_sample=256,\n                 pos_iou_thresh=0.7, neg_iou_thresh=0.3,\n                 pos_ratio=0.5):\n        self.n_sample = n_sample\n        self.pos_iou_thresh = pos_iou_thresh\n        self.neg_iou_thresh = neg_iou_thresh\n        self.pos_ratio = pos_ratio\n\n    def __call__(self, bbox, anchor, img_size):\n        """"""Assign ground truth supervision to sampled subset of anchors.\n\n        Types of input arrays and output arrays are same.\n\n        Here are notations.\n\n        * :math:`S` is the number of anchors.\n        * :math:`R` is the number of bounding boxes.\n\n        Args:\n            bbox (array): Coordinates of bounding boxes. Its shape is\n                :math:`(R, 4)`.\n            anchor (array): Coordinates of anchors. Its shape is\n                :math:`(S, 4)`.\n            img_size (tuple of ints): A tuple :obj:`H, W`, which\n                is a tuple of height and width of an image.\n\n        Returns:\n            (array, array):\n\n            #NOTE: it\'s scale not only  offset\n            * **loc**: Offsets and scales to match the anchors to \\\n                the ground truth bounding boxes. Its shape is :math:`(S, 4)`.\n            * **label**: Labels of anchors with values \\\n                :obj:`(1=positive, 0=negative, -1=ignore)`. Its shape \\\n                is :math:`(S,)`.\n\n        """"""\n\n        img_H, img_W = img_size\n\n        n_anchor = len(anchor)\n        inside_index = _get_inside_index(anchor, img_H, img_W)\n        anchor = anchor[inside_index]\n        argmax_ious, label = self._create_label(\n            inside_index, anchor, bbox)\n\n        # compute bounding box regression targets\n        loc = bbox2loc(anchor, bbox[argmax_ious])\n\n        # map up to original set of anchors\n        label = _unmap(label, n_anchor, inside_index, fill=-1)\n        loc = _unmap(loc, n_anchor, inside_index, fill=0)\n\n        return loc, label\n\n    def _create_label(self, inside_index, anchor, bbox):\n        # label: 1 is positive, 0 is negative, -1 is dont care\n        label = np.empty((len(inside_index),), dtype=np.int32)\n        label.fill(-1)\n\n        argmax_ious, max_ious, gt_argmax_ious = \\\n            self._calc_ious(anchor, bbox, inside_index)\n\n        # assign negative labels first so that positive labels can clobber them\n        label[max_ious < self.neg_iou_thresh] = 0\n\n        # positive label: for each gt, anchor with highest iou\n        label[gt_argmax_ious] = 1\n\n        # positive label: above threshold IOU\n        label[max_ious >= self.pos_iou_thresh] = 1\n\n        # subsample positive labels if we have too many\n        n_pos = int(self.pos_ratio * self.n_sample)\n        pos_index = np.where(label == 1)[0]\n        if len(pos_index) > n_pos:\n            disable_index = np.random.choice(\n                pos_index, size=(len(pos_index) - n_pos), replace=False)\n            label[disable_index] = -1\n\n        # subsample negative labels if we have too many\n        n_neg = self.n_sample - np.sum(label == 1)\n        neg_index = np.where(label == 0)[0]\n        if len(neg_index) > n_neg:\n            disable_index = np.random.choice(\n                neg_index, size=(len(neg_index) - n_neg), replace=False)\n            label[disable_index] = -1\n\n        return argmax_ious, label\n\n    def _calc_ious(self, anchor, bbox, inside_index):\n        # ious between the anchors and the gt boxes\n        ious = bbox_iou(anchor, bbox)\n        argmax_ious = ious.argmax(axis=1)\n        max_ious = ious[np.arange(len(inside_index)), argmax_ious]\n        gt_argmax_ious = ious.argmax(axis=0)\n        gt_max_ious = ious[gt_argmax_ious, np.arange(ious.shape[1])]\n        gt_argmax_ious = np.where(ious == gt_max_ious)[0]\n\n        return argmax_ious, max_ious, gt_argmax_ious\n\n\ndef _unmap(data, count, index, fill=0):\n    # Unmap a subset of item (data) back to the original set of items (of\n    # size count)\n\n    if len(data.shape) == 1:\n        ret = np.empty((count,), dtype=data.dtype)\n        ret.fill(fill)\n        ret[index] = data\n    else:\n        ret = np.empty((count,) + data.shape[1:], dtype=data.dtype)\n        ret.fill(fill)\n        ret[index, :] = data\n    return ret\n\n\ndef _get_inside_index(anchor, H, W):\n    # Calc indicies of anchors which are located completely inside of the image\n    # whose size is speficied.\n    index_inside = np.where(\n        (anchor[:, 0] >= 0) &\n        (anchor[:, 1] >= 0) &\n        (anchor[:, 2] <= H) &\n        (anchor[:, 3] <= W)\n    )[0]\n    return index_inside\n\n\nclass ProposalCreator:\n    # unNOTE: I\'ll make it undifferential\n    # unTODO: make sure it\'s ok\n    # It\'s ok\n    """"""Proposal regions are generated by calling this object.\n\n    The :meth:`__call__` of this object outputs object detection proposals by\n    applying estimated bounding box offsets\n    to a set of anchors.\n\n    This class takes parameters to control number of bounding boxes to\n    pass to NMS and keep after NMS.\n    If the paramters are negative, it uses all the bounding boxes supplied\n    or keep all the bounding boxes returned by NMS.\n\n    This class is used for Region Proposal Networks introduced in\n    Faster R-CNN [#]_.\n\n    .. [#] Shaoqing Ren, Kaiming He, Ross Girshick, Jian Sun. \\\n    Faster R-CNN: Towards Real-Time Object Detection with \\\n    Region Proposal Networks. NIPS 2015.\n\n    Args:\n        nms_thresh (float): Threshold value used when calling NMS.\n        n_train_pre_nms (int): Number of top scored bounding boxes\n            to keep before passing to NMS in train mode.\n        n_train_post_nms (int): Number of top scored bounding boxes\n            to keep after passing to NMS in train mode.\n        n_test_pre_nms (int): Number of top scored bounding boxes\n            to keep before passing to NMS in test mode.\n        n_test_post_nms (int): Number of top scored bounding boxes\n            to keep after passing to NMS in test mode.\n        force_cpu_nms (bool): If this is :obj:`True`,\n            always use NMS in CPU mode. If :obj:`False`,\n            the NMS mode is selected based on the type of inputs.\n        min_size (int): A paramter to determine the threshold on\n            discarding bounding boxes based on their sizes.\n\n    """"""\n\n    def __init__(self,\n                 parent_model,\n                 nms_thresh=0.7,\n                 n_train_pre_nms=12000,\n                 n_train_post_nms=2000,\n                 n_test_pre_nms=6000,\n                 n_test_post_nms=300,\n                 min_size=16\n                 ):\n        self.parent_model = parent_model\n        self.nms_thresh = nms_thresh\n        self.n_train_pre_nms = n_train_pre_nms\n        self.n_train_post_nms = n_train_post_nms\n        self.n_test_pre_nms = n_test_pre_nms\n        self.n_test_post_nms = n_test_post_nms\n        self.min_size = min_size\n\n    def __call__(self, loc, score,\n                 anchor, img_size, scale=1.):\n        """"""input should  be ndarray\n        Propose RoIs.\n\n        Inputs :obj:`loc, score, anchor` refer to the same anchor when indexed\n        by the same index.\n\n        On notations, :math:`R` is the total number of anchors. This is equal\n        to product of the height and the width of an image and the number of\n        anchor bases per pixel.\n\n        Type of the output is same as the inputs.\n\n        Args:\n            loc (array): Predicted offsets and scaling to anchors.\n                Its shape is :math:`(R, 4)`.\n            score (array): Predicted foreground probability for anchors.\n                Its shape is :math:`(R,)`.\n            anchor (array): Coordinates of anchors. Its shape is\n                :math:`(R, 4)`.\n            img_size (tuple of ints): A tuple :obj:`height, width`,\n                which contains image size after scaling.\n            scale (float): The scaling factor used to scale an image after\n                reading it from a file.\n\n        Returns:\n            array:\n            An array of coordinates of proposal boxes.\n            Its shape is :math:`(S, 4)`. :math:`S` is less than\n            :obj:`self.n_test_post_nms` in test time and less than\n            :obj:`self.n_train_post_nms` in train time. :math:`S` depends on\n            the size of the predicted bounding boxes and the number of\n            bounding boxes discarded by NMS.\n\n        """"""\n        # NOTE: when test, remember\n        # faster_rcnn.eval()\n        # to set self.traing = False\n        if self.parent_model.training:\n            n_pre_nms = self.n_train_pre_nms\n            n_post_nms = self.n_train_post_nms\n        else:\n            n_pre_nms = self.n_test_pre_nms\n            n_post_nms = self.n_test_post_nms\n\n        # Convert anchors into proposal via bbox transformations.\n        # roi = loc2bbox(anchor, loc)\n        roi = loc2bbox(anchor, loc)\n\n        # Clip predicted boxes to image.\n        roi[:, slice(0, 4, 2)] = np.clip(\n            roi[:, slice(0, 4, 2)], 0, img_size[0])\n        roi[:, slice(1, 4, 2)] = np.clip(\n            roi[:, slice(1, 4, 2)], 0, img_size[1])\n\n        # Remove predicted boxes with either height or width < threshold.\n        min_size = self.min_size * scale\n        hs = roi[:, 2] - roi[:, 0]\n        ws = roi[:, 3] - roi[:, 1]\n        keep = np.where((hs >= min_size) & (ws >= min_size))[0]\n        roi = roi[keep, :]\n        score = score[keep]\n\n        # Sort all (proposal, score) pairs by score from highest to lowest.\n        # Take top pre_nms_topN (e.g. 6000).\n        order = score.ravel().argsort()[::-1]\n        if n_pre_nms > 0:\n            order = order[:n_pre_nms]\n        roi = roi[order, :]\n\n        # Apply nms (e.g. threshold = 0.7).\n        # Take after_nms_topN (e.g. 300).\n\n        # unNOTE: somthing is wrong here!\n        # TODO: remove cuda.to_gpu\n        keep = non_maximum_suppression(\n            cp.ascontiguousarray(cp.asarray(roi)),\n            thresh=self.nms_thresh)\n        if n_post_nms > 0:\n            keep = keep[:n_post_nms]\n        roi = roi[keep]\n        return roi\n'"
model/utils/roi_cupy.py,0,"b'kernel_forward = \'\'\'\n    extern ""C""\n    __global__ void roi_forward(const float* const bottom_data,const float* const bottom_rois,\n                float* top_data, int* argmax_data,\n                const double spatial_scale,const int channels,const int height, \n                const int width, const int pooled_height, \n                const int pooled_width,const int NN\n    ){\n        \n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if(idx>=NN)\n        return;\n    const int pw = idx % pooled_width;\n    const int ph = (idx / pooled_width) % pooled_height;\n    const int c = (idx / pooled_width / pooled_height) % channels;\n    int num = idx / pooled_width / pooled_height / channels;\n    const int roi_batch_ind = bottom_rois[num * 5 + 0];\n    const int roi_start_w = round(bottom_rois[num * 5 + 1] * spatial_scale);\n    const int roi_start_h = round(bottom_rois[num * 5 + 2] * spatial_scale);\n    const int roi_end_w = round(bottom_rois[num * 5 + 3] * spatial_scale);\n    const int roi_end_h = round(bottom_rois[num * 5 + 4] * spatial_scale);\n    // Force malformed ROIs to be 1x1\n    const int roi_width = max(roi_end_w - roi_start_w + 1, 1);\n    const int roi_height = max(roi_end_h - roi_start_h + 1, 1);\n    const float bin_size_h = static_cast<float>(roi_height)\n                    / static_cast<float>(pooled_height);\n    const float bin_size_w = static_cast<float>(roi_width)\n                    / static_cast<float>(pooled_width);\n\n    int hstart = static_cast<int>(floor(static_cast<float>(ph)\n                                    * bin_size_h));\n        int wstart = static_cast<int>(floor(static_cast<float>(pw)\n                                    * bin_size_w));\n    int hend = static_cast<int>(ceil(static_cast<float>(ph + 1)\n                                * bin_size_h));\n        int wend = static_cast<int>(ceil(static_cast<float>(pw + 1)\n                                * bin_size_w));\n\n    // Add roi offsets and clip to input boundaries\n    hstart = min(max(hstart + roi_start_h, 0), height);\n    hend = min(max(hend + roi_start_h, 0), height);\n    wstart = min(max(wstart + roi_start_w, 0), width);\n    wend = min(max(wend + roi_start_w, 0), width);\n    bool is_empty = (hend <= hstart) || (wend <= wstart);\n\n    // Define an empty pooling region to be zero\n    float maxval = is_empty ? 0 : -1E+37;\n    // If nothing is pooled, argmax=-1 causes nothing to be backprop\'d\n    int maxidx = -1;\n    const int data_offset = (roi_batch_ind * channels + c) * height * width;\n    for (int h = hstart; h < hend; ++h) {\n        for (int w = wstart; w < wend; ++w) {\n            int bottom_index = h * width + w;\n            if (bottom_data[data_offset + bottom_index] > maxval) {\n                maxval = bottom_data[data_offset + bottom_index];\n                maxidx = bottom_index;\n            }\n        }\n    }\n    top_data[idx]=maxval;\n    argmax_data[idx]=maxidx;\n    }\n\'\'\'\nkernel_backward = \'\'\'\n    extern ""C""\n    __global__ void roi_backward(const float* const top_diff,\n         const int* const argmax_data,const float* const bottom_rois,\n         float* bottom_diff, const int num_rois,\n         const double spatial_scale, int channels,\n         int height, int width, int pooled_height,\n          int pooled_width,const int NN)\n    {\n\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    ////Importtan >= instead of >\n    if(idx>=NN)\n        return;\n    int w = idx % width;\n    int h = (idx / width) % height;\n    int c = (idx/ (width * height)) % channels;\n    int num = idx / (width * height * channels);\n\n    float gradient = 0;\n    // Accumulate gradient over all ROIs that pooled this element\n    for (int roi_n = 0; roi_n < num_rois; ++roi_n) {\n        // Skip if ROI\'s batch index doesn\'t match num\n        if (num != static_cast<int>(bottom_rois[roi_n * 5])) {\n            continue;\n        }\n\n        int roi_start_w = round(bottom_rois[roi_n * 5 + 1]\n                                * spatial_scale);\n        int roi_start_h = round(bottom_rois[roi_n * 5 + 2]\n                                * spatial_scale);\n        int roi_end_w = round(bottom_rois[roi_n * 5 + 3]\n                                * spatial_scale);\n        int roi_end_h = round(bottom_rois[roi_n * 5 + 4]\n                                * spatial_scale);\n\n        // Skip if ROI doesn\'t include (h, w)\n        const bool in_roi = (w >= roi_start_w && w <= roi_end_w &&\n                                h >= roi_start_h && h <= roi_end_h);\n        if (!in_roi) {\n            continue;\n        }\n\n        int offset = (roi_n * channels + c) * pooled_height\n                        * pooled_width;\n\n        // Compute feasible set of pooled units that could have pooled\n        // this bottom unit\n\n        // Force malformed ROIs to be 1x1\n        int roi_width = max(roi_end_w - roi_start_w + 1, 1);\n        int roi_height = max(roi_end_h - roi_start_h + 1, 1);\n\n        float bin_size_h = static_cast<float>(roi_height)\n                        / static_cast<float>(pooled_height);\n        float bin_size_w = static_cast<float>(roi_width)\n                        / static_cast<float>(pooled_width);\n\n        int phstart = floor(static_cast<float>(h - roi_start_h)\n                            / bin_size_h);\n        int phend = ceil(static_cast<float>(h - roi_start_h + 1)\n                            / bin_size_h);\n        int pwstart = floor(static_cast<float>(w - roi_start_w)\n                            / bin_size_w);\n        int pwend = ceil(static_cast<float>(w - roi_start_w + 1)\n                            / bin_size_w);\n\n        phstart = min(max(phstart, 0), pooled_height);\n        phend = min(max(phend, 0), pooled_height);\n        pwstart = min(max(pwstart, 0), pooled_width);\n        pwend = min(max(pwend, 0), pooled_width);\n        for (int ph = phstart; ph < phend; ++ph) {\n            for (int pw = pwstart; pw < pwend; ++pw) {\n                int index_ = ph * pooled_width + pw + offset;\n                if (argmax_data[index_] == (h * width + w)) {\n                    gradient += top_diff[index_];\n                }\n            }\n        }\n    }\n    bottom_diff[idx] = gradient;\n    }\n\'\'\'\n'"
model/utils/nms/__init__.py,0,b'from model.utils.nms.non_maximum_suppression import non_maximum_suppression'
model/utils/nms/_nms_gpu_post_py.py,0,"b'\nimport numpy as np\n\ndef _nms_gpu_post( mask,\n                  n_bbox,\n                   threads_per_block,\n                   col_blocks\n                  ):\n    n_selection = 0\n    one_ull = np.array([1],dtype=np.uint64)\n    selection = np.zeros((n_bbox,), dtype=np.int32)\n    remv = np.zeros((col_blocks,), dtype=np.uint64)\n\n    for i in range(n_bbox):\n        nblock = i // threads_per_block\n        inblock = i % threads_per_block\n\n        if not (remv[nblock] & one_ull << inblock):\n            selection[n_selection] = i\n            n_selection += 1\n\n            index = i * col_blocks\n            for j in range(nblock, col_blocks):\n                remv[j] |= mask[index + j]\n    return selection, n_selection\n'"
model/utils/nms/build.py,0,"b'from distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\nimport numpy\n#ext_modules = [Extension(""_nms_gpu_post"", [""_nms_gpu_post.pyx""])]\next_modules = [Extension(""_nms_gpu_post"", [""_nms_gpu_post.pyx""],\n include_dirs=[numpy.get_include()])]\nsetup(\n    name=""nms pyx"",\n    cmdclass={\'build_ext\': build_ext},\n    ext_modules=ext_modules\n)\n'"
model/utils/nms/non_maximum_suppression.py,0,"b'from __future__ import division\nimport numpy as np\nimport cupy as cp\nimport torch as t\ntry:\n    from ._nms_gpu_post import _nms_gpu_post\nexcept:\n    import warnings\n    warnings.warn(\'\'\'\n    the python code for non_maximum_suppression is about 2x slow\n    It is strongly recommended to build cython code: \n    `cd model/utils/nms/; python3 build.py build_ext --inplace\'\'\')\n    from ._nms_gpu_post_py import _nms_gpu_post\n\n\n@cp.util.memoize(for_each_device=True)\ndef _load_kernel(kernel_name, code, options=()):\n    cp.cuda.runtime.free(0)\n    assert isinstance(options, tuple)\n    kernel_code = cp.cuda.compile_with_cache(code, options=options)\n    return kernel_code.get_function(kernel_name)\n\n\ndef non_maximum_suppression(bbox, thresh, score=None,\n                            limit=None):\n    """"""Suppress bounding boxes according to their IoUs.\n\n    This method checks each bounding box sequentially and selects the bounding\n    box if the Intersection over Unions (IoUs) between the bounding box and the\n    previously selected bounding boxes is less than :obj:`thresh`. This method\n    is mainly used as postprocessing of object detection.\n    The bounding boxes are selected from ones with higher scores.\n    If :obj:`score` is not provided as an argument, the bounding box\n    is ordered by its index in ascending order.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    :obj:`score` is a float array of shape :math:`(R,)`. Each score indicates\n    confidence of prediction.\n\n    This function accepts both :obj:`numpy.ndarray` and :obj:`cupy.ndarray` as\n    an input. Please note that both :obj:`bbox` and :obj:`score` need to be\n    the same type.\n    The type of the output is the same as the input.\n\n    Args:\n        bbox (array): Bounding boxes to be transformed. The shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n        thresh (float): Threshold of IoUs.\n        score (array): An array of confidences whose shape is :math:`(R,)`.\n        limit (int): The upper bound of the number of the output bounding\n            boxes. If it is not specified, this method selects as many\n            bounding boxes as possible.\n\n    Returns:\n        array:\n        An array with indices of bounding boxes that are selected. \\\n        They are sorted by the scores of bounding boxes in descending \\\n        order. \\\n        The shape of this array is :math:`(K,)` and its dtype is\\\n        :obj:`numpy.int32`. Note that :math:`K \\\\leq R`.\n\n    """"""\n\n    return _non_maximum_suppression_gpu(bbox, thresh, score, limit)\n\n\ndef _non_maximum_suppression_gpu(bbox, thresh, score=None, limit=None):\n    if len(bbox) == 0:\n        return cp.zeros((0,), dtype=np.int32)\n\n    n_bbox = bbox.shape[0]\n\n    if score is not None:\n        order = score.argsort()[::-1].astype(np.int32)\n    else:\n        order = cp.arange(n_bbox, dtype=np.int32)\n\n    sorted_bbox = bbox[order, :]\n    selec, n_selec = _call_nms_kernel(\n        sorted_bbox, thresh)\n    selec = selec[:n_selec]\n    selec = order[selec]\n    if limit is not None:\n        selec = selec[:limit]\n    return cp.asnumpy(selec)\n\n\n_nms_gpu_code = \'\'\'\n#define DIVUP(m,n) ((m) / (n) + ((m) % (n) > 0))\nint const threadsPerBlock = sizeof(unsigned long long) * 8;\n\n__device__\ninline float devIoU(float const *const bbox_a, float const *const bbox_b) {\n  float top = max(bbox_a[0], bbox_b[0]);\n  float bottom = min(bbox_a[2], bbox_b[2]);\n  float left = max(bbox_a[1], bbox_b[1]);\n  float right = min(bbox_a[3], bbox_b[3]);\n  float height = max(bottom - top, 0.f);\n  float width = max(right - left, 0.f);\n  float area_i = height * width;\n  float area_a = (bbox_a[2] - bbox_a[0]) * (bbox_a[3] - bbox_a[1]);\n  float area_b = (bbox_b[2] - bbox_b[0]) * (bbox_b[3] - bbox_b[1]);\n  return area_i / (area_a + area_b - area_i);\n}\n\nextern ""C""\n__global__\nvoid nms_kernel(const int n_bbox, const float thresh,\n                const float *dev_bbox,\n                unsigned long long *dev_mask) {\n  const int row_start = blockIdx.y;\n  const int col_start = blockIdx.x;\n\n  const int row_size =\n        min(n_bbox - row_start * threadsPerBlock, threadsPerBlock);\n  const int col_size =\n        min(n_bbox - col_start * threadsPerBlock, threadsPerBlock);\n\n  __shared__ float block_bbox[threadsPerBlock * 4];\n  if (threadIdx.x < col_size) {\n    block_bbox[threadIdx.x * 4 + 0] =\n        dev_bbox[(threadsPerBlock * col_start + threadIdx.x) * 4 + 0];\n    block_bbox[threadIdx.x * 4 + 1] =\n        dev_bbox[(threadsPerBlock * col_start + threadIdx.x) * 4 + 1];\n    block_bbox[threadIdx.x * 4 + 2] =\n        dev_bbox[(threadsPerBlock * col_start + threadIdx.x) * 4 + 2];\n    block_bbox[threadIdx.x * 4 + 3] =\n        dev_bbox[(threadsPerBlock * col_start + threadIdx.x) * 4 + 3];\n  }\n  __syncthreads();\n\n  if (threadIdx.x < row_size) {\n    const int cur_box_idx = threadsPerBlock * row_start + threadIdx.x;\n    const float *cur_box = dev_bbox + cur_box_idx * 4;\n    int i = 0;\n    unsigned long long t = 0;\n    int start = 0;\n    if (row_start == col_start) {\n      start = threadIdx.x + 1;\n    }\n    for (i = start; i < col_size; i++) {\n      if (devIoU(cur_box, block_bbox + i * 4) >= thresh) {\n        t |= 1ULL << i;\n      }\n    }\n    const int col_blocks = DIVUP(n_bbox, threadsPerBlock);\n    dev_mask[cur_box_idx * col_blocks + col_start] = t;\n  }\n}\n\'\'\'\n\n\ndef _call_nms_kernel(bbox, thresh):\n    # PyTorch does not support unsigned long Tensor.\n    # Doesn\'t matter,since it returns ndarray finally.\n    # So I\'ll keep it unmodified.\n    n_bbox = bbox.shape[0]\n    threads_per_block = 64\n    col_blocks = np.ceil(n_bbox / threads_per_block).astype(np.int32)\n    blocks = (col_blocks, col_blocks, 1)\n    threads = (threads_per_block, 1, 1)\n\n    mask_dev = cp.zeros((n_bbox * col_blocks,), dtype=np.uint64)\n    bbox = cp.ascontiguousarray(bbox, dtype=np.float32)\n    kern = _load_kernel(\'nms_kernel\', _nms_gpu_code)\n    kern(blocks, threads, args=(cp.int32(n_bbox), cp.float32(thresh),\n                                bbox, mask_dev))\n\n    mask_host = mask_dev.get()\n    selection, n_selec = _nms_gpu_post(\n        mask_host, n_bbox, threads_per_block, col_blocks)\n    return selection, n_selec\n'"
