file_path,api_count,code
data.py,12,"b'import torch\nimport torch.utils.data as data\nimport torchvision.transforms as transforms\nimport os\nimport nltk\nfrom PIL import Image\nfrom pycocotools.coco import COCO\nimport numpy as np\nimport json as jsonmod\n\n\ndef get_paths(path, name=\'coco\', use_restval=False):\n    """"""\n    Returns paths to images and annotations for the given datasets. For MSCOCO\n    indices are also returned to control the data split being used.\n    The indices are extracted from the Karpathy et al. splits using this\n    snippet:\n\n    >>> import json\n    >>> dataset=json.load(open(\'dataset_coco.json\',\'r\'))\n    >>> A=[]\n    >>> for i in range(len(D[\'images\'])):\n    ...   if D[\'images\'][i][\'split\'] == \'val\':\n    ...     A+=D[\'images\'][i][\'sentids\'][:5]\n    ...\n\n    :param name: Dataset names\n    :param use_restval: If True, the the `restval` data is included in train.\n    """"""\n    roots = {}\n    ids = {}\n    if \'coco\' == name:\n        imgdir = os.path.join(path, \'images\')\n        capdir = os.path.join(path, \'annotations\')\n        roots[\'train\'] = {\n            \'img\': os.path.join(imgdir, \'train2014\'),\n            \'cap\': os.path.join(capdir, \'captions_train2014.json\')\n        }\n        roots[\'val\'] = {\n            \'img\': os.path.join(imgdir, \'val2014\'),\n            \'cap\': os.path.join(capdir, \'captions_val2014.json\')\n        }\n        roots[\'test\'] = {\n            \'img\': os.path.join(imgdir, \'val2014\'),\n            \'cap\': os.path.join(capdir, \'captions_val2014.json\')\n        }\n        roots[\'trainrestval\'] = {\n            \'img\': (roots[\'train\'][\'img\'], roots[\'val\'][\'img\']),\n            \'cap\': (roots[\'train\'][\'cap\'], roots[\'val\'][\'cap\'])\n        }\n        ids[\'train\'] = np.load(os.path.join(capdir, \'coco_train_ids.npy\'))\n        ids[\'val\'] = np.load(os.path.join(capdir, \'coco_dev_ids.npy\'))[:5000]\n        ids[\'test\'] = np.load(os.path.join(capdir, \'coco_test_ids.npy\'))\n        ids[\'trainrestval\'] = (\n            ids[\'train\'],\n            np.load(os.path.join(capdir, \'coco_restval_ids.npy\')))\n        if use_restval:\n            roots[\'train\'] = roots[\'trainrestval\']\n            ids[\'train\'] = ids[\'trainrestval\']\n    elif \'f8k\' == name:\n        imgdir = os.path.join(path, \'images\')\n        cap = os.path.join(path, \'dataset_flickr8k.json\')\n        roots[\'train\'] = {\'img\': imgdir, \'cap\': cap}\n        roots[\'val\'] = {\'img\': imgdir, \'cap\': cap}\n        roots[\'test\'] = {\'img\': imgdir, \'cap\': cap}\n        ids = {\'train\': None, \'val\': None, \'test\': None}\n    elif \'f30k\' == name:\n        imgdir = os.path.join(path, \'images\')\n        cap = os.path.join(path, \'dataset_flickr30k.json\')\n        roots[\'train\'] = {\'img\': imgdir, \'cap\': cap}\n        roots[\'val\'] = {\'img\': imgdir, \'cap\': cap}\n        roots[\'test\'] = {\'img\': imgdir, \'cap\': cap}\n        ids = {\'train\': None, \'val\': None, \'test\': None}\n\n    return roots, ids\n\n\nclass CocoDataset(data.Dataset):\n    """"""COCO Custom Dataset compatible with torch.utils.data.DataLoader.""""""\n\n    def __init__(self, root, json, vocab, transform=None, ids=None):\n        """"""\n        Args:\n            root: image directory.\n            json: coco annotation file path.\n            vocab: vocabulary wrapper.\n            transform: transformer for image.\n        """"""\n        self.root = root\n        # when using `restval`, two json files are needed\n        if isinstance(json, tuple):\n            self.coco = (COCO(json[0]), COCO(json[1]))\n        else:\n            self.coco = (COCO(json),)\n            self.root = (root,)\n        # if ids provided by get_paths, use split-specific ids\n        if ids is None:\n            self.ids = list(self.coco.anns.keys())\n        else:\n            self.ids = ids\n\n        # if `restval` data is to be used, record the break point for ids\n        if isinstance(self.ids, tuple):\n            self.bp = len(self.ids[0])\n            self.ids = list(self.ids[0]) + list(self.ids[1])\n        else:\n            self.bp = len(self.ids)\n        self.vocab = vocab\n        self.transform = transform\n\n    def __getitem__(self, index):\n        """"""This function returns a tuple that is further passed to collate_fn\n        """"""\n        vocab = self.vocab\n        root, caption, img_id, path, image = self.get_raw_item(index)\n\n        if self.transform is not None:\n            image = self.transform(image)\n\n        # Convert caption (string) to word ids.\n        tokens = nltk.tokenize.word_tokenize(\n            str(caption).lower().decode(\'utf-8\'))\n        caption = []\n        caption.append(vocab(\'<start>\'))\n        caption.extend([vocab(token) for token in tokens])\n        caption.append(vocab(\'<end>\'))\n        target = torch.Tensor(caption)\n        return image, target, index, img_id\n\n    def get_raw_item(self, index):\n        if index < self.bp:\n            coco = self.coco[0]\n            root = self.root[0]\n        else:\n            coco = self.coco[1]\n            root = self.root[1]\n        ann_id = self.ids[index]\n        caption = coco.anns[ann_id][\'caption\']\n        img_id = coco.anns[ann_id][\'image_id\']\n        path = coco.loadImgs(img_id)[0][\'file_name\']\n        image = Image.open(os.path.join(root, path)).convert(\'RGB\')\n\n        return root, caption, img_id, path, image\n\n    def __len__(self):\n        return len(self.ids)\n\n\nclass FlickrDataset(data.Dataset):\n    """"""\n    Dataset loader for Flickr30k and Flickr8k full datasets.\n    """"""\n\n    def __init__(self, root, json, split, vocab, transform=None):\n        self.root = root\n        self.vocab = vocab\n        self.split = split\n        self.transform = transform\n        self.dataset = jsonmod.load(open(json, \'r\'))[\'images\']\n        self.ids = []\n        for i, d in enumerate(self.dataset):\n            if d[\'split\'] == split:\n                self.ids += [(i, x) for x in range(len(d[\'sentences\']))]\n\n    def __getitem__(self, index):\n        """"""This function returns a tuple that is further passed to collate_fn\n        """"""\n        vocab = self.vocab\n        root = self.root\n        ann_id = self.ids[index]\n        img_id = ann_id[0]\n        caption = self.dataset[img_id][\'sentences\'][ann_id[1]][\'raw\']\n        path = self.dataset[img_id][\'filename\']\n\n        image = Image.open(os.path.join(root, path)).convert(\'RGB\')\n        if self.transform is not None:\n            image = self.transform(image)\n\n        # Convert caption (string) to word ids.\n        tokens = nltk.tokenize.word_tokenize(\n            str(caption).lower().decode(\'utf-8\'))\n        caption = []\n        caption.append(vocab(\'<start>\'))\n        caption.extend([vocab(token) for token in tokens])\n        caption.append(vocab(\'<end>\'))\n        target = torch.Tensor(caption)\n        return image, target, index, img_id\n\n    def __len__(self):\n        return len(self.ids)\n\n\nclass PrecompDataset(data.Dataset):\n    """"""\n    Load precomputed captions and image features\n    Possible options: f8k, f30k, coco, 10crop\n    """"""\n\n    def __init__(self, data_path, data_split, vocab):\n        self.vocab = vocab\n        loc = data_path + \'/\'\n\n        # Captions\n        self.captions = []\n        with open(loc+\'%s_caps.txt\' % data_split, \'rb\') as f:\n            for line in f:\n                self.captions.append(line.strip())\n\n        # Image features\n        self.images = np.load(loc+\'%s_ims.npy\' % data_split)\n        self.length = len(self.captions)\n        # rkiros data has redundancy in images, we divide by 5, 10crop doesn\'t\n        if self.images.shape[0] != self.length:\n            self.im_div = 5\n        else:\n            self.im_div = 1\n        # the development set for coco is large and so validation would be slow\n        if data_split == \'dev\':\n            self.length = 5000\n\n    def __getitem__(self, index):\n        # handle the image redundancy\n        img_id = index/self.im_div\n        image = torch.Tensor(self.images[img_id])\n        caption = self.captions[index]\n        vocab = self.vocab\n\n        # Convert caption (string) to word ids.\n        tokens = nltk.tokenize.word_tokenize(\n            str(caption).lower().decode(\'utf-8\'))\n        caption = []\n        caption.append(vocab(\'<start>\'))\n        caption.extend([vocab(token) for token in tokens])\n        caption.append(vocab(\'<end>\'))\n        target = torch.Tensor(caption)\n        return image, target, index, img_id\n\n    def __len__(self):\n        return self.length\n\n\ndef collate_fn(data):\n    """"""Build mini-batch tensors from a list of (image, caption) tuples.\n    Args:\n        data: list of (image, caption) tuple.\n            - image: torch tensor of shape (3, 256, 256).\n            - caption: torch tensor of shape (?); variable length.\n\n    Returns:\n        images: torch tensor of shape (batch_size, 3, 256, 256).\n        targets: torch tensor of shape (batch_size, padded_length).\n        lengths: list; valid length for each padded caption.\n    """"""\n    # Sort a data list by caption length\n    data.sort(key=lambda x: len(x[1]), reverse=True)\n    images, captions, ids, img_ids = zip(*data)\n\n    # Merge images (convert tuple of 3D tensor to 4D tensor)\n    images = torch.stack(images, 0)\n\n    # Merget captions (convert tuple of 1D tensor to 2D tensor)\n    lengths = [len(cap) for cap in captions]\n    targets = torch.zeros(len(captions), max(lengths)).long()\n    for i, cap in enumerate(captions):\n        end = lengths[i]\n        targets[i, :end] = cap[:end]\n\n    return images, targets, lengths, ids\n\n\ndef get_loader_single(data_name, split, root, json, vocab, transform,\n                      batch_size=100, shuffle=True,\n                      num_workers=2, ids=None, collate_fn=collate_fn):\n    """"""Returns torch.utils.data.DataLoader for custom coco dataset.""""""\n    if \'coco\' in data_name:\n        # COCO custom dataset\n        dataset = CocoDataset(root=root,\n                              json=json,\n                              vocab=vocab,\n                              transform=transform, ids=ids)\n    elif \'f8k\' in data_name or \'f30k\' in data_name:\n        dataset = FlickrDataset(root=root,\n                                split=split,\n                                json=json,\n                                vocab=vocab,\n                                transform=transform)\n\n    # Data loader\n    data_loader = torch.utils.data.DataLoader(dataset=dataset,\n                                              batch_size=batch_size,\n                                              shuffle=shuffle,\n                                              pin_memory=True,\n                                              num_workers=num_workers,\n                                              collate_fn=collate_fn)\n    return data_loader\n\n\ndef get_precomp_loader(data_path, data_split, vocab, opt, batch_size=100,\n                       shuffle=True, num_workers=2):\n    """"""Returns torch.utils.data.DataLoader for custom coco dataset.""""""\n    dset = PrecompDataset(data_path, data_split, vocab)\n\n    data_loader = torch.utils.data.DataLoader(dataset=dset,\n                                              batch_size=batch_size,\n                                              shuffle=shuffle,\n                                              pin_memory=True,\n                                              collate_fn=collate_fn)\n    return data_loader\n\n\ndef get_transform(data_name, split_name, opt):\n    normalizer = transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                                      std=[0.229, 0.224, 0.225])\n    t_list = []\n    if split_name == \'train\':\n        t_list = [transforms.RandomResizedCrop(opt.crop_size),\n                  transforms.RandomHorizontalFlip()]\n    elif split_name == \'val\':\n        t_list = [transforms.Resize(256), transforms.CenterCrop(224)]\n    elif split_name == \'test\':\n        t_list = [transforms.Resize(256), transforms.CenterCrop(224)]\n\n    t_end = [transforms.ToTensor(), normalizer]\n    transform = transforms.Compose(t_list + t_end)\n    return transform\n\n\ndef get_loaders(data_name, vocab, crop_size, batch_size, workers, opt):\n    dpath = os.path.join(opt.data_path, data_name)\n    if opt.data_name.endswith(\'_precomp\'):\n        train_loader = get_precomp_loader(dpath, \'train\', vocab, opt,\n                                          batch_size, True, workers)\n        val_loader = get_precomp_loader(dpath, \'dev\', vocab, opt,\n                                        batch_size, False, workers)\n    else:\n        # Build Dataset Loader\n        roots, ids = get_paths(dpath, data_name, opt.use_restval)\n\n        transform = get_transform(data_name, \'train\', opt)\n        train_loader = get_loader_single(opt.data_name, \'train\',\n                                         roots[\'train\'][\'img\'],\n                                         roots[\'train\'][\'cap\'],\n                                         vocab, transform, ids=ids[\'train\'],\n                                         batch_size=batch_size, shuffle=True,\n                                         num_workers=workers,\n                                         collate_fn=collate_fn)\n\n        transform = get_transform(data_name, \'val\', opt)\n        val_loader = get_loader_single(opt.data_name, \'val\',\n                                       roots[\'val\'][\'img\'],\n                                       roots[\'val\'][\'cap\'],\n                                       vocab, transform, ids=ids[\'val\'],\n                                       batch_size=batch_size, shuffle=False,\n                                       num_workers=workers,\n                                       collate_fn=collate_fn)\n\n    return train_loader, val_loader\n\n\ndef get_test_loader(split_name, data_name, vocab, crop_size, batch_size,\n                    workers, opt):\n    dpath = os.path.join(opt.data_path, data_name)\n    if opt.data_name.endswith(\'_precomp\'):\n        test_loader = get_precomp_loader(dpath, split_name, vocab, opt,\n                                         batch_size, False, workers)\n    else:\n        # Build Dataset Loader\n        roots, ids = get_paths(dpath, data_name, opt.use_restval)\n\n        transform = get_transform(data_name, split_name, opt)\n        test_loader = get_loader_single(opt.data_name, split_name,\n                                        roots[split_name][\'img\'],\n                                        roots[split_name][\'cap\'],\n                                        vocab, transform, ids=ids[split_name],\n                                        batch_size=batch_size, shuffle=False,\n                                        num_workers=workers,\n                                        collate_fn=collate_fn)\n\n    return test_loader\n'"
evaluation.py,6,"b'from __future__ import print_function\nimport os\nimport pickle\n\nimport numpy\nfrom data import get_test_loader\nimport time\nimport numpy as np\nfrom vocab import Vocabulary  # NOQA\nimport torch\nfrom model import VSE, order_sim\nfrom collections import OrderedDict\n\n\nclass AverageMeter(object):\n    """"""Computes and stores the average and current value""""""\n\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n\n    def update(self, val, n=0):\n        self.val = val\n        self.sum += val * n\n        self.count += n\n        self.avg = self.sum / (.0001 + self.count)\n\n    def __str__(self):\n        """"""String representation for logging\n        """"""\n        # for values that should be recorded exactly e.g. iteration number\n        if self.count == 0:\n            return str(self.val)\n        # for stats\n        return \'%.4f (%.4f)\' % (self.val, self.avg)\n\n\nclass LogCollector(object):\n    """"""A collection of logging objects that can change from train to val""""""\n\n    def __init__(self):\n        # to keep the order of logged variables deterministic\n        self.meters = OrderedDict()\n\n    def update(self, k, v, n=0):\n        # create a new meter if previously not recorded\n        if k not in self.meters:\n            self.meters[k] = AverageMeter()\n        self.meters[k].update(v, n)\n\n    def __str__(self):\n        """"""Concatenate the meters in one log line\n        """"""\n        s = \'\'\n        for i, (k, v) in enumerate(self.meters.iteritems()):\n            if i > 0:\n                s += \'  \'\n            s += k + \' \' + str(v)\n        return s\n\n    def tb_log(self, tb_logger, prefix=\'\', step=None):\n        """"""Log using tensorboard\n        """"""\n        for k, v in self.meters.iteritems():\n            tb_logger.log_value(prefix + k, v.val, step=step)\n\n\ndef encode_data(model, data_loader, log_step=10, logging=print):\n    """"""Encode all images and captions loadable by `data_loader`\n    """"""\n    batch_time = AverageMeter()\n    val_logger = LogCollector()\n\n    # switch to evaluate mode\n    model.val_start()\n\n    end = time.time()\n\n    # numpy array to keep all the embeddings\n    img_embs = None\n    cap_embs = None\n    for i, (images, captions, lengths, ids) in enumerate(data_loader):\n        # make sure val logger is used\n        model.logger = val_logger\n\n        # compute the embeddings\n        img_emb, cap_emb = model.forward_emb(images, captions, lengths,\n                                             volatile=True)\n\n        # initialize the numpy arrays given the size of the embeddings\n        if img_embs is None:\n            img_embs = np.zeros((len(data_loader.dataset), img_emb.size(1)))\n            cap_embs = np.zeros((len(data_loader.dataset), cap_emb.size(1)))\n\n        # preserve the embeddings by copying from gpu and converting to numpy\n        img_embs[ids] = img_emb.data.cpu().numpy().copy()\n        cap_embs[ids] = cap_emb.data.cpu().numpy().copy()\n\n        # measure accuracy and record loss\n        model.forward_loss(img_emb, cap_emb)\n\n        # measure elapsed time\n        batch_time.update(time.time() - end)\n        end = time.time()\n\n        if i % log_step == 0:\n            logging(\'Test: [{0}/{1}]\\t\'\n                    \'{e_log}\\t\'\n                    \'Time {batch_time.val:.3f} ({batch_time.avg:.3f})\\t\'\n                    .format(\n                        i, len(data_loader), batch_time=batch_time,\n                        e_log=str(model.logger)))\n        del images, captions\n\n    return img_embs, cap_embs\n\n\ndef evalrank(model_path, data_path=None, split=\'dev\', fold5=False):\n    """"""\n    Evaluate a trained model on either dev or test. If `fold5=True`, 5 fold\n    cross-validation is done (only for MSCOCO). Otherwise, the full data is\n    used for evaluation.\n    """"""\n    # load model and options\n    checkpoint = torch.load(model_path)\n    opt = checkpoint[\'opt\']\n    if data_path is not None:\n        opt.data_path = data_path\n\n    # load vocabulary used by the model\n    with open(os.path.join(opt.vocab_path,\n                           \'%s_vocab.pkl\' % opt.data_name), \'rb\') as f:\n        vocab = pickle.load(f)\n    opt.vocab_size = len(vocab)\n\n    # construct model\n    model = VSE(opt)\n\n    # load model state\n    model.load_state_dict(checkpoint[\'model\'])\n\n    print(\'Loading dataset\')\n    data_loader = get_test_loader(split, opt.data_name, vocab, opt.crop_size,\n                                  opt.batch_size, opt.workers, opt)\n\n    print(\'Computing results...\')\n    img_embs, cap_embs = encode_data(model, data_loader)\n    print(\'Images: %d, Captions: %d\' %\n          (img_embs.shape[0] / 5, cap_embs.shape[0]))\n\n    if not fold5:\n        # no cross-validation, full evaluation\n        r, rt = i2t(img_embs, cap_embs, measure=opt.measure, return_ranks=True)\n        ri, rti = t2i(img_embs, cap_embs,\n                      measure=opt.measure, return_ranks=True)\n        ar = (r[0] + r[1] + r[2]) / 3\n        ari = (ri[0] + ri[1] + ri[2]) / 3\n        rsum = r[0] + r[1] + r[2] + ri[0] + ri[1] + ri[2]\n        print(""rsum: %.1f"" % rsum)\n        print(""Average i2t Recall: %.1f"" % ar)\n        print(""Image to text: %.1f %.1f %.1f %.1f %.1f"" % r)\n        print(""Average t2i Recall: %.1f"" % ari)\n        print(""Text to image: %.1f %.1f %.1f %.1f %.1f"" % ri)\n    else:\n        # 5fold cross-validation, only for MSCOCO\n        results = []\n        for i in range(5):\n            r, rt0 = i2t(img_embs[i * 5000:(i + 1) * 5000],\n                         cap_embs[i * 5000:(i + 1) *\n                                  5000], measure=opt.measure,\n                         return_ranks=True)\n            print(""Image to text: %.1f, %.1f, %.1f, %.1f, %.1f"" % r)\n            ri, rti0 = t2i(img_embs[i * 5000:(i + 1) * 5000],\n                           cap_embs[i * 5000:(i + 1) *\n                                    5000], measure=opt.measure,\n                           return_ranks=True)\n            if i == 0:\n                rt, rti = rt0, rti0\n            print(""Text to image: %.1f, %.1f, %.1f, %.1f, %.1f"" % ri)\n            ar = (r[0] + r[1] + r[2]) / 3\n            ari = (ri[0] + ri[1] + ri[2]) / 3\n            rsum = r[0] + r[1] + r[2] + ri[0] + ri[1] + ri[2]\n            print(""rsum: %.1f ar: %.1f ari: %.1f"" % (rsum, ar, ari))\n            results += [list(r) + list(ri) + [ar, ari, rsum]]\n\n        print(""-----------------------------------"")\n        print(""Mean metrics: "")\n        mean_metrics = tuple(np.array(results).mean(axis=0).flatten())\n        print(""rsum: %.1f"" % (mean_metrics[10] * 6))\n        print(""Average i2t Recall: %.1f"" % mean_metrics[11])\n        print(""Image to text: %.1f %.1f %.1f %.1f %.1f"" %\n              mean_metrics[:5])\n        print(""Average t2i Recall: %.1f"" % mean_metrics[12])\n        print(""Text to image: %.1f %.1f %.1f %.1f %.1f"" %\n              mean_metrics[5:10])\n\n    torch.save({\'rt\': rt, \'rti\': rti}, \'ranks.pth.tar\')\n\n\ndef i2t(images, captions, npts=None, measure=\'cosine\', return_ranks=False):\n    """"""\n    Images->Text (Image Annotation)\n    Images: (5N, K) matrix of images\n    Captions: (5N, K) matrix of captions\n    """"""\n    if npts is None:\n        npts = images.shape[0] / 5\n    index_list = []\n\n    ranks = numpy.zeros(npts)\n    top1 = numpy.zeros(npts)\n    for index in range(npts):\n\n        # Get query image\n        im = images[5 * index].reshape(1, images.shape[1])\n\n        # Compute scores\n        if measure == \'order\':\n            bs = 100\n            if index % bs == 0:\n                mx = min(images.shape[0], 5 * (index + bs))\n                im2 = images[5 * index:mx:5]\n                d2 = order_sim(torch.Tensor(im2).cuda(),\n                               torch.Tensor(captions).cuda())\n                d2 = d2.cpu().numpy()\n            d = d2[index % bs]\n        else:\n            d = numpy.dot(im, captions.T).flatten()\n        inds = numpy.argsort(d)[::-1]\n        index_list.append(inds[0])\n\n        # Score\n        rank = 1e20\n        for i in range(5 * index, 5 * index + 5, 1):\n            tmp = numpy.where(inds == i)[0][0]\n            if tmp < rank:\n                rank = tmp\n        ranks[index] = rank\n        top1[index] = inds[0]\n\n    # Compute metrics\n    r1 = 100.0 * len(numpy.where(ranks < 1)[0]) / len(ranks)\n    r5 = 100.0 * len(numpy.where(ranks < 5)[0]) / len(ranks)\n    r10 = 100.0 * len(numpy.where(ranks < 10)[0]) / len(ranks)\n    medr = numpy.floor(numpy.median(ranks)) + 1\n    meanr = ranks.mean() + 1\n    if return_ranks:\n        return (r1, r5, r10, medr, meanr), (ranks, top1)\n    else:\n        return (r1, r5, r10, medr, meanr)\n\n\ndef t2i(images, captions, npts=None, measure=\'cosine\', return_ranks=False):\n    """"""\n    Text->Images (Image Search)\n    Images: (5N, K) matrix of images\n    Captions: (5N, K) matrix of captions\n    """"""\n    if npts is None:\n        npts = images.shape[0] / 5\n    ims = numpy.array([images[i] for i in range(0, len(images), 5)])\n\n    ranks = numpy.zeros(5 * npts)\n    top1 = numpy.zeros(5 * npts)\n    for index in range(npts):\n\n        # Get query captions\n        queries = captions[5 * index:5 * index + 5]\n\n        # Compute scores\n        if measure == \'order\':\n            bs = 100\n            if 5 * index % bs == 0:\n                mx = min(captions.shape[0], 5 * index + bs)\n                q2 = captions[5 * index:mx]\n                d2 = order_sim(torch.Tensor(ims).cuda(),\n                               torch.Tensor(q2).cuda())\n                d2 = d2.cpu().numpy()\n\n            d = d2[:, (5 * index) % bs:(5 * index) % bs + 5].T\n        else:\n            d = numpy.dot(queries, ims.T)\n        inds = numpy.zeros(d.shape)\n        for i in range(len(inds)):\n            inds[i] = numpy.argsort(d[i])[::-1]\n            ranks[5 * index + i] = numpy.where(inds[i] == index)[0][0]\n            top1[5 * index + i] = inds[i][0]\n\n    # Compute metrics\n    r1 = 100.0 * len(numpy.where(ranks < 1)[0]) / len(ranks)\n    r5 = 100.0 * len(numpy.where(ranks < 5)[0]) / len(ranks)\n    r10 = 100.0 * len(numpy.where(ranks < 10)[0]) / len(ranks)\n    medr = numpy.floor(numpy.median(ranks)) + 1\n    meanr = ranks.mean() + 1\n    if return_ranks:\n        return (r1, r5, r10, medr, meanr), (ranks, top1)\n    else:\n        return (r1, r5, r10, medr, meanr)\n'"
model.py,18,"b'import torch\nimport torch.nn as nn\nimport torch.nn.init\nimport torchvision.models as models\nfrom torch.autograd import Variable\nfrom torch.nn.utils.rnn import pack_padded_sequence, pad_packed_sequence\nimport torch.backends.cudnn as cudnn\nfrom torch.nn.utils.clip_grad import clip_grad_norm\nimport numpy as np\nfrom collections import OrderedDict\n\n\ndef l2norm(X):\n    """"""L2-normalize columns of X\n    """"""\n    norm = torch.pow(X, 2).sum(dim=1, keepdim=True).sqrt()\n    X = torch.div(X, norm)\n    return X\n\n\ndef EncoderImage(data_name, img_dim, embed_size, finetune=False,\n                 cnn_type=\'vgg19\', use_abs=False, no_imgnorm=False):\n    """"""A wrapper to image encoders. Chooses between an encoder that uses\n    precomputed image features, `EncoderImagePrecomp`, or an encoder that\n    computes image features on the fly `EncoderImageFull`.\n    """"""\n    if data_name.endswith(\'_precomp\'):\n        img_enc = EncoderImagePrecomp(\n            img_dim, embed_size, use_abs, no_imgnorm)\n    else:\n        img_enc = EncoderImageFull(\n            embed_size, finetune, cnn_type, use_abs, no_imgnorm)\n\n    return img_enc\n\n\n# tutorials/09 - Image Captioning\nclass EncoderImageFull(nn.Module):\n\n    def __init__(self, embed_size, finetune=False, cnn_type=\'vgg19\',\n                 use_abs=False, no_imgnorm=False):\n        """"""Load pretrained VGG19 and replace top fc layer.""""""\n        super(EncoderImageFull, self).__init__()\n        self.embed_size = embed_size\n        self.no_imgnorm = no_imgnorm\n        self.use_abs = use_abs\n\n        # Load a pre-trained model\n        self.cnn = self.get_cnn(cnn_type, True)\n\n        # For efficient memory usage.\n        for param in self.cnn.parameters():\n            param.requires_grad = finetune\n\n        # Replace the last fully connected layer of CNN with a new one\n        if cnn_type.startswith(\'vgg\'):\n            self.fc = nn.Linear(self.cnn.classifier._modules[\'6\'].in_features,\n                                embed_size)\n            self.cnn.classifier = nn.Sequential(\n                *list(self.cnn.classifier.children())[:-1])\n        elif cnn_type.startswith(\'resnet\'):\n            self.fc = nn.Linear(self.cnn.module.fc.in_features, embed_size)\n            self.cnn.module.fc = nn.Sequential()\n\n        self.init_weights()\n\n    def get_cnn(self, arch, pretrained):\n        """"""Load a pretrained CNN and parallelize over GPUs\n        """"""\n        if pretrained:\n            print(""=> using pre-trained model \'{}\'"".format(arch))\n            model = models.__dict__[arch](pretrained=True)\n        else:\n            print(""=> creating model \'{}\'"".format(arch))\n            model = models.__dict__[arch]()\n\n        if arch.startswith(\'alexnet\') or arch.startswith(\'vgg\'):\n            model.features = nn.DataParallel(model.features)\n            model.cuda()\n        else:\n            model = nn.DataParallel(model).cuda()\n\n        return model\n\n    def load_state_dict(self, state_dict):\n        """"""\n        Handle the models saved before commit pytorch/vision@989d52a\n        """"""\n        if \'cnn.classifier.1.weight\' in state_dict:\n            state_dict[\'cnn.classifier.0.weight\'] = state_dict[\n                \'cnn.classifier.1.weight\']\n            del state_dict[\'cnn.classifier.1.weight\']\n            state_dict[\'cnn.classifier.0.bias\'] = state_dict[\n                \'cnn.classifier.1.bias\']\n            del state_dict[\'cnn.classifier.1.bias\']\n            state_dict[\'cnn.classifier.3.weight\'] = state_dict[\n                \'cnn.classifier.4.weight\']\n            del state_dict[\'cnn.classifier.4.weight\']\n            state_dict[\'cnn.classifier.3.bias\'] = state_dict[\n                \'cnn.classifier.4.bias\']\n            del state_dict[\'cnn.classifier.4.bias\']\n\n        super(EncoderImageFull, self).load_state_dict(state_dict)\n\n    def init_weights(self):\n        """"""Xavier initialization for the fully connected layer\n        """"""\n        r = np.sqrt(6.) / np.sqrt(self.fc.in_features +\n                                  self.fc.out_features)\n        self.fc.weight.data.uniform_(-r, r)\n        self.fc.bias.data.fill_(0)\n\n    def forward(self, images):\n        """"""Extract image feature vectors.""""""\n        features = self.cnn(images)\n\n        # normalization in the image embedding space\n        features = l2norm(features)\n\n        # linear projection to the joint embedding space\n        features = self.fc(features)\n\n        # normalization in the joint embedding space\n        if not self.no_imgnorm:\n            features = l2norm(features)\n\n        # take the absolute value of the embedding (used in order embeddings)\n        if self.use_abs:\n            features = torch.abs(features)\n\n        return features\n\n\nclass EncoderImagePrecomp(nn.Module):\n\n    def __init__(self, img_dim, embed_size, use_abs=False, no_imgnorm=False):\n        super(EncoderImagePrecomp, self).__init__()\n        self.embed_size = embed_size\n        self.no_imgnorm = no_imgnorm\n        self.use_abs = use_abs\n\n        self.fc = nn.Linear(img_dim, embed_size)\n\n        self.init_weights()\n\n    def init_weights(self):\n        """"""Xavier initialization for the fully connected layer\n        """"""\n        r = np.sqrt(6.) / np.sqrt(self.fc.in_features +\n                                  self.fc.out_features)\n        self.fc.weight.data.uniform_(-r, r)\n        self.fc.bias.data.fill_(0)\n\n    def forward(self, images):\n        """"""Extract image feature vectors.""""""\n        # assuming that the precomputed features are already l2-normalized\n\n        features = self.fc(images)\n\n        # normalize in the joint embedding space\n        if not self.no_imgnorm:\n            features = l2norm(features)\n\n        # take the absolute value of embedding (used in order embeddings)\n        if self.use_abs:\n            features = torch.abs(features)\n\n        return features\n\n    def load_state_dict(self, state_dict):\n        """"""Copies parameters. overwritting the default one to\n        accept state_dict from Full model\n        """"""\n        own_state = self.state_dict()\n        new_state = OrderedDict()\n        for name, param in state_dict.items():\n            if name in own_state:\n                new_state[name] = param\n\n        super(EncoderImagePrecomp, self).load_state_dict(new_state)\n\n\n# tutorials/08 - Language Model\n# RNN Based Language Model\nclass EncoderText(nn.Module):\n\n    def __init__(self, vocab_size, word_dim, embed_size, num_layers,\n                 use_abs=False):\n        super(EncoderText, self).__init__()\n        self.use_abs = use_abs\n        self.embed_size = embed_size\n\n        # word embedding\n        self.embed = nn.Embedding(vocab_size, word_dim)\n\n        # caption embedding\n        self.rnn = nn.GRU(word_dim, embed_size, num_layers, batch_first=True)\n\n        self.init_weights()\n\n    def init_weights(self):\n        self.embed.weight.data.uniform_(-0.1, 0.1)\n\n    def forward(self, x, lengths):\n        """"""Handles variable size captions\n        """"""\n        # Embed word ids to vectors\n        x = self.embed(x)\n        packed = pack_padded_sequence(x, lengths, batch_first=True)\n\n        # Forward propagate RNN\n        out, _ = self.rnn(packed)\n\n        # Reshape *final* output to (batch_size, hidden_size)\n        padded = pad_packed_sequence(out, batch_first=True)\n        I = torch.LongTensor(lengths).view(-1, 1, 1)\n        I = Variable(I.expand(x.size(0), 1, self.embed_size)-1).cuda()\n        out = torch.gather(padded[0], 1, I).squeeze(1)\n\n        # normalization in the joint embedding space\n        out = l2norm(out)\n\n        # take absolute value, used by order embeddings\n        if self.use_abs:\n            out = torch.abs(out)\n\n        return out\n\n\ndef cosine_sim(im, s):\n    """"""Cosine similarity between all the image and sentence pairs\n    """"""\n    return im.mm(s.t())\n\n\ndef order_sim(im, s):\n    """"""Order embeddings similarity measure $max(0, s-im)$\n    """"""\n    YmX = (s.unsqueeze(1).expand(s.size(0), im.size(0), s.size(1))\n           - im.unsqueeze(0).expand(s.size(0), im.size(0), s.size(1)))\n    score = -YmX.clamp(min=0).pow(2).sum(2).sqrt().t()\n    return score\n\n\nclass ContrastiveLoss(nn.Module):\n    """"""\n    Compute contrastive loss\n    """"""\n\n    def __init__(self, margin=0, measure=False, max_violation=False):\n        super(ContrastiveLoss, self).__init__()\n        self.margin = margin\n        if measure == \'order\':\n            self.sim = order_sim\n        else:\n            self.sim = cosine_sim\n\n        self.max_violation = max_violation\n\n    def forward(self, im, s):\n        # compute image-sentence score matrix\n        scores = self.sim(im, s)\n        diagonal = scores.diag().view(im.size(0), 1)\n        d1 = diagonal.expand_as(scores)\n        d2 = diagonal.t().expand_as(scores)\n\n        # compare every diagonal score to scores in its column\n        # caption retrieval\n        cost_s = (self.margin + scores - d1).clamp(min=0)\n        # compare every diagonal score to scores in its row\n        # image retrieval\n        cost_im = (self.margin + scores - d2).clamp(min=0)\n\n        # clear diagonals\n        mask = torch.eye(scores.size(0)) > .5\n        I = Variable(mask)\n        if torch.cuda.is_available():\n            I = I.cuda()\n        cost_s = cost_s.masked_fill_(I, 0)\n        cost_im = cost_im.masked_fill_(I, 0)\n\n        # keep the maximum violating negative for each query\n        if self.max_violation:\n            cost_s = cost_s.max(1)[0]\n            cost_im = cost_im.max(0)[0]\n\n        return cost_s.sum() + cost_im.sum()\n\n\nclass VSE(object):\n    """"""\n    rkiros/uvs model\n    """"""\n\n    def __init__(self, opt):\n        # tutorials/09 - Image Captioning\n        # Build Models\n        self.grad_clip = opt.grad_clip\n        self.img_enc = EncoderImage(opt.data_name, opt.img_dim, opt.embed_size,\n                                    opt.finetune, opt.cnn_type,\n                                    use_abs=opt.use_abs,\n                                    no_imgnorm=opt.no_imgnorm)\n        self.txt_enc = EncoderText(opt.vocab_size, opt.word_dim,\n                                   opt.embed_size, opt.num_layers,\n                                   use_abs=opt.use_abs)\n        if torch.cuda.is_available():\n            self.img_enc.cuda()\n            self.txt_enc.cuda()\n            cudnn.benchmark = True\n\n        # Loss and Optimizer\n        self.criterion = ContrastiveLoss(margin=opt.margin,\n                                         measure=opt.measure,\n                                         max_violation=opt.max_violation)\n        params = list(self.txt_enc.parameters())\n        params += list(self.img_enc.fc.parameters())\n        if opt.finetune:\n            params += list(self.img_enc.cnn.parameters())\n        self.params = params\n\n        self.optimizer = torch.optim.Adam(params, lr=opt.learning_rate)\n\n        self.Eiters = 0\n\n    def state_dict(self):\n        state_dict = [self.img_enc.state_dict(), self.txt_enc.state_dict()]\n        return state_dict\n\n    def load_state_dict(self, state_dict):\n        self.img_enc.load_state_dict(state_dict[0])\n        self.txt_enc.load_state_dict(state_dict[1])\n\n    def train_start(self):\n        """"""switch to train mode\n        """"""\n        self.img_enc.train()\n        self.txt_enc.train()\n\n    def val_start(self):\n        """"""switch to evaluate mode\n        """"""\n        self.img_enc.eval()\n        self.txt_enc.eval()\n\n    def forward_emb(self, images, captions, lengths, volatile=False):\n        """"""Compute the image and caption embeddings\n        """"""\n        # Set mini-batch dataset\n        images = Variable(images, volatile=volatile)\n        captions = Variable(captions, volatile=volatile)\n        if torch.cuda.is_available():\n            images = images.cuda()\n            captions = captions.cuda()\n\n        # Forward\n        img_emb = self.img_enc(images)\n        cap_emb = self.txt_enc(captions, lengths)\n        return img_emb, cap_emb\n\n    def forward_loss(self, img_emb, cap_emb, **kwargs):\n        """"""Compute the loss given pairs of image and caption embeddings\n        """"""\n        loss = self.criterion(img_emb, cap_emb)\n        self.logger.update(\'Le\', loss.data[0], img_emb.size(0))\n        return loss\n\n    def train_emb(self, images, captions, lengths, ids=None, *args):\n        """"""One training step given images and captions.\n        """"""\n        self.Eiters += 1\n        self.logger.update(\'Eit\', self.Eiters)\n        self.logger.update(\'lr\', self.optimizer.param_groups[0][\'lr\'])\n\n        # compute the embeddings\n        img_emb, cap_emb = self.forward_emb(images, captions, lengths)\n\n        # measure accuracy and record loss\n        self.optimizer.zero_grad()\n        loss = self.forward_loss(img_emb, cap_emb)\n\n        # compute gradient and do SGD step\n        loss.backward()\n        if self.grad_clip > 0:\n            clip_grad_norm(self.params, self.grad_clip)\n        self.optimizer.step()\n'"
train.py,2,"b'import pickle\nimport os\nimport time\nimport shutil\n\nimport torch\n\nimport data\nfrom vocab import Vocabulary  # NOQA\nfrom model import VSE\nfrom evaluation import i2t, t2i, AverageMeter, LogCollector, encode_data\n\nimport logging\nimport tensorboard_logger as tb_logger\n\nimport argparse\n\n\ndef main():\n    # Hyper Parameters\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'--data_path\', default=\'/w/31/faghri/vsepp_data/\',\n                        help=\'path to datasets\')\n    parser.add_argument(\'--data_name\', default=\'precomp\',\n                        help=\'{coco,f8k,f30k,10crop}_precomp|coco|f8k|f30k\')\n    parser.add_argument(\'--vocab_path\', default=\'./vocab/\',\n                        help=\'Path to saved vocabulary pickle files.\')\n    parser.add_argument(\'--margin\', default=0.2, type=float,\n                        help=\'Rank loss margin.\')\n    parser.add_argument(\'--num_epochs\', default=30, type=int,\n                        help=\'Number of training epochs.\')\n    parser.add_argument(\'--batch_size\', default=128, type=int,\n                        help=\'Size of a training mini-batch.\')\n    parser.add_argument(\'--word_dim\', default=300, type=int,\n                        help=\'Dimensionality of the word embedding.\')\n    parser.add_argument(\'--embed_size\', default=1024, type=int,\n                        help=\'Dimensionality of the joint embedding.\')\n    parser.add_argument(\'--grad_clip\', default=2., type=float,\n                        help=\'Gradient clipping threshold.\')\n    parser.add_argument(\'--crop_size\', default=224, type=int,\n                        help=\'Size of an image crop as the CNN input.\')\n    parser.add_argument(\'--num_layers\', default=1, type=int,\n                        help=\'Number of GRU layers.\')\n    parser.add_argument(\'--learning_rate\', default=.0002, type=float,\n                        help=\'Initial learning rate.\')\n    parser.add_argument(\'--lr_update\', default=15, type=int,\n                        help=\'Number of epochs to update the learning rate.\')\n    parser.add_argument(\'--workers\', default=10, type=int,\n                        help=\'Number of data loader workers.\')\n    parser.add_argument(\'--log_step\', default=10, type=int,\n                        help=\'Number of steps to print and record the log.\')\n    parser.add_argument(\'--val_step\', default=500, type=int,\n                        help=\'Number of steps to run validation.\')\n    parser.add_argument(\'--logger_name\', default=\'runs/runX\',\n                        help=\'Path to save the model and Tensorboard log.\')\n    parser.add_argument(\'--resume\', default=\'\', type=str, metavar=\'PATH\',\n                        help=\'path to latest checkpoint (default: none)\')\n    parser.add_argument(\'--max_violation\', action=\'store_true\',\n                        help=\'Use max instead of sum in the rank loss.\')\n    parser.add_argument(\'--img_dim\', default=4096, type=int,\n                        help=\'Dimensionality of the image embedding.\')\n    parser.add_argument(\'--finetune\', action=\'store_true\',\n                        help=\'Fine-tune the image encoder.\')\n    parser.add_argument(\'--cnn_type\', default=\'vgg19\',\n                        help=""""""The CNN used for image encoder\n                        (e.g. vgg19, resnet152)"""""")\n    parser.add_argument(\'--use_restval\', action=\'store_true\',\n                        help=\'Use the restval data for training on MSCOCO.\')\n    parser.add_argument(\'--measure\', default=\'cosine\',\n                        help=\'Similarity measure used (cosine|order)\')\n    parser.add_argument(\'--use_abs\', action=\'store_true\',\n                        help=\'Take the absolute value of embedding vectors.\')\n    parser.add_argument(\'--no_imgnorm\', action=\'store_true\',\n                        help=\'Do not normalize the image embeddings.\')\n    parser.add_argument(\'--reset_train\', action=\'store_true\',\n                        help=\'Ensure the training is always done in \'\n                        \'train mode (Not recommended).\')\n    opt = parser.parse_args()\n    print(opt)\n\n    logging.basicConfig(format=\'%(asctime)s %(message)s\', level=logging.INFO)\n    tb_logger.configure(opt.logger_name, flush_secs=5)\n\n    # Load Vocabulary Wrapper\n    vocab = pickle.load(open(os.path.join(\n        opt.vocab_path, \'%s_vocab.pkl\' % opt.data_name), \'rb\'))\n    opt.vocab_size = len(vocab)\n\n    # Load data loaders\n    train_loader, val_loader = data.get_loaders(\n        opt.data_name, vocab, opt.crop_size, opt.batch_size, opt.workers, opt)\n\n    # Construct the model\n    model = VSE(opt)\n\n    # optionally resume from a checkpoint\n    if opt.resume:\n        if os.path.isfile(opt.resume):\n            print(""=> loading checkpoint \'{}\'"".format(opt.resume))\n            checkpoint = torch.load(opt.resume)\n            start_epoch = checkpoint[\'epoch\']\n            best_rsum = checkpoint[\'best_rsum\']\n            model.load_state_dict(checkpoint[\'model\'])\n            # Eiters is used to show logs as the continuation of another\n            # training\n            model.Eiters = checkpoint[\'Eiters\']\n            print(""=> loaded checkpoint \'{}\' (epoch {}, best_rsum {})""\n                  .format(opt.resume, start_epoch, best_rsum))\n            validate(opt, val_loader, model)\n        else:\n            print(""=> no checkpoint found at \'{}\'"".format(opt.resume))\n\n    # Train the Model\n    best_rsum = 0\n    for epoch in range(opt.num_epochs):\n        adjust_learning_rate(opt, model.optimizer, epoch)\n\n        # train for one epoch\n        train(opt, train_loader, model, epoch, val_loader)\n\n        # evaluate on validation set\n        rsum = validate(opt, val_loader, model)\n\n        # remember best R@ sum and save checkpoint\n        is_best = rsum > best_rsum\n        best_rsum = max(rsum, best_rsum)\n        save_checkpoint({\n            \'epoch\': epoch + 1,\n            \'model\': model.state_dict(),\n            \'best_rsum\': best_rsum,\n            \'opt\': opt,\n            \'Eiters\': model.Eiters,\n        }, is_best, prefix=opt.logger_name + \'/\')\n\n\ndef train(opt, train_loader, model, epoch, val_loader):\n    # average meters to record the training statistics\n    batch_time = AverageMeter()\n    data_time = AverageMeter()\n    train_logger = LogCollector()\n\n    # switch to train mode\n    model.train_start()\n\n    end = time.time()\n    for i, train_data in enumerate(train_loader):\n        if opt.reset_train:\n            # Always reset to train mode, this is not the default behavior\n            model.train_start()\n\n        # measure data loading time\n        data_time.update(time.time() - end)\n\n        # make sure train logger is used\n        model.logger = train_logger\n\n        # Update the model\n        model.train_emb(*train_data)\n\n        # measure elapsed time\n        batch_time.update(time.time() - end)\n        end = time.time()\n\n        # Print log info\n        if model.Eiters % opt.log_step == 0:\n            logging.info(\n                \'Epoch: [{0}][{1}/{2}]\\t\'\n                \'{e_log}\\t\'\n                \'Time {batch_time.val:.3f} ({batch_time.avg:.3f})\\t\'\n                \'Data {data_time.val:.3f} ({data_time.avg:.3f})\\t\'\n                .format(\n                    epoch, i, len(train_loader), batch_time=batch_time,\n                    data_time=data_time, e_log=str(model.logger)))\n\n        # Record logs in tensorboard\n        tb_logger.log_value(\'epoch\', epoch, step=model.Eiters)\n        tb_logger.log_value(\'step\', i, step=model.Eiters)\n        tb_logger.log_value(\'batch_time\', batch_time.val, step=model.Eiters)\n        tb_logger.log_value(\'data_time\', data_time.val, step=model.Eiters)\n        model.logger.tb_log(tb_logger, step=model.Eiters)\n\n        # validate at every val_step\n        if model.Eiters % opt.val_step == 0:\n            validate(opt, val_loader, model)\n\n\ndef validate(opt, val_loader, model):\n    # compute the encoding for all the validation images and captions\n    img_embs, cap_embs = encode_data(\n        model, val_loader, opt.log_step, logging.info)\n\n    # caption retrieval\n    (r1, r5, r10, medr, meanr) = i2t(img_embs, cap_embs, measure=opt.measure)\n    logging.info(""Image to text: %.1f, %.1f, %.1f, %.1f, %.1f"" %\n                 (r1, r5, r10, medr, meanr))\n    # image retrieval\n    (r1i, r5i, r10i, medri, meanr) = t2i(\n        img_embs, cap_embs, measure=opt.measure)\n    logging.info(""Text to image: %.1f, %.1f, %.1f, %.1f, %.1f"" %\n                 (r1i, r5i, r10i, medri, meanr))\n    # sum of recalls to be used for early stopping\n    currscore = r1 + r5 + r10 + r1i + r5i + r10i\n\n    # record metrics in tensorboard\n    tb_logger.log_value(\'r1\', r1, step=model.Eiters)\n    tb_logger.log_value(\'r5\', r5, step=model.Eiters)\n    tb_logger.log_value(\'r10\', r10, step=model.Eiters)\n    tb_logger.log_value(\'medr\', medr, step=model.Eiters)\n    tb_logger.log_value(\'meanr\', meanr, step=model.Eiters)\n    tb_logger.log_value(\'r1i\', r1i, step=model.Eiters)\n    tb_logger.log_value(\'r5i\', r5i, step=model.Eiters)\n    tb_logger.log_value(\'r10i\', r10i, step=model.Eiters)\n    tb_logger.log_value(\'medri\', medri, step=model.Eiters)\n    tb_logger.log_value(\'meanr\', meanr, step=model.Eiters)\n    tb_logger.log_value(\'rsum\', currscore, step=model.Eiters)\n\n    return currscore\n\n\ndef save_checkpoint(state, is_best, filename=\'checkpoint.pth.tar\', prefix=\'\'):\n    torch.save(state, prefix + filename)\n    if is_best:\n        shutil.copyfile(prefix + filename, prefix + \'model_best.pth.tar\')\n\n\ndef adjust_learning_rate(opt, optimizer, epoch):\n    """"""Sets the learning rate to the initial LR\n       decayed by 10 every 30 epochs""""""\n    lr = opt.learning_rate * (0.1 ** (epoch // opt.lr_update))\n    for param_group in optimizer.param_groups:\n        param_group[\'lr\'] = lr\n\n\ndef accuracy(output, target, topk=(1,)):\n    """"""Computes the precision@k for the specified values of k""""""\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n\nif __name__ == \'__main__\':\n    main()\n'"
vocab.py,0,"b'# Create a vocabulary wrapper\nimport nltk\nimport pickle\nfrom collections import Counter\nfrom pycocotools.coco import COCO\nimport json\nimport argparse\nimport os\n\nannotations = {\n    \'coco_precomp\': [\'train_caps.txt\', \'dev_caps.txt\'],\n    \'coco\': [\'annotations/captions_train2014.json\',\n             \'annotations/captions_val2014.json\'],\n    \'f8k_precomp\': [\'train_caps.txt\', \'dev_caps.txt\'],\n    \'10crop_precomp\': [\'train_caps.txt\', \'dev_caps.txt\'],\n    \'f30k_precomp\': [\'train_caps.txt\', \'dev_caps.txt\'],\n    \'f8k\': [\'dataset_flickr8k.json\'],\n    \'f30k\': [\'dataset_flickr30k.json\'],\n}\n\n\nclass Vocabulary(object):\n    """"""Simple vocabulary wrapper.""""""\n\n    def __init__(self):\n        self.word2idx = {}\n        self.idx2word = {}\n        self.idx = 0\n\n    def add_word(self, word):\n        if word not in self.word2idx:\n            self.word2idx[word] = self.idx\n            self.idx2word[self.idx] = word\n            self.idx += 1\n\n    def __call__(self, word):\n        if word not in self.word2idx:\n            return self.word2idx[\'<unk>\']\n        return self.word2idx[word]\n\n    def __len__(self):\n        return len(self.word2idx)\n\n\ndef from_coco_json(path):\n    coco = COCO(path)\n    ids = coco.anns.keys()\n    captions = []\n    for i, idx in enumerate(ids):\n        captions.append(str(coco.anns[idx][\'caption\']))\n\n    return captions\n\n\ndef from_flickr_json(path):\n    dataset = json.load(open(path, \'r\'))[\'images\']\n    captions = []\n    for i, d in enumerate(dataset):\n        captions += [str(x[\'raw\']) for x in d[\'sentences\']]\n\n    return captions\n\n\ndef from_txt(txt):\n    captions = []\n    with open(txt, \'rb\') as f:\n        for line in f:\n            captions.append(line.strip())\n    return captions\n\n\ndef build_vocab(data_path, data_name, jsons, threshold):\n    """"""Build a simple vocabulary wrapper.""""""\n    counter = Counter()\n    for path in jsons[data_name]:\n        full_path = os.path.join(os.path.join(data_path, data_name), path)\n        if data_name == \'coco\':\n            captions = from_coco_json(full_path)\n        elif data_name == \'f8k\' or data_name == \'f30k\':\n            captions = from_flickr_json(full_path)\n        else:\n            captions = from_txt(full_path)\n        for i, caption in enumerate(captions):\n            tokens = nltk.tokenize.word_tokenize(\n                caption.lower().decode(\'utf-8\'))\n            counter.update(tokens)\n\n            if i % 1000 == 0:\n                print(""[%d/%d] tokenized the captions."" % (i, len(captions)))\n\n    # Discard if the occurrence of the word is less than min_word_cnt.\n    words = [word for word, cnt in counter.items() if cnt >= threshold]\n\n    # Create a vocab wrapper and add some special tokens.\n    vocab = Vocabulary()\n    vocab.add_word(\'<pad>\')\n    vocab.add_word(\'<start>\')\n    vocab.add_word(\'<end>\')\n    vocab.add_word(\'<unk>\')\n\n    # Add words to the vocabulary.\n    for i, word in enumerate(words):\n        vocab.add_word(word)\n    return vocab\n\n\ndef main(data_path, data_name):\n    vocab = build_vocab(data_path, data_name, jsons=annotations, threshold=4)\n    with open(\'./vocab/%s_vocab.pkl\' % data_name, \'wb\') as f:\n        pickle.dump(vocab, f, pickle.HIGHEST_PROTOCOL)\n    print(""Saved vocabulary file to "", \'./vocab/%s_vocab.pkl\' % data_name)\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'--data_path\', default=\'/w/31/faghri/vsepp_data/\')\n    parser.add_argument(\'--data_name\', default=\'coco\',\n                        help=\'{coco,f8k,f30k,10crop}_precomp|coco|f8k|f30k\')\n    opt = parser.parse_args()\n    main(opt.data_path, opt.data_name)\n'"
