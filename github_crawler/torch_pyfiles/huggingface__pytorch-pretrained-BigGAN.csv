file_path,api_count,code
setup.py,0,"b'""""""\nSimple check list from AllenNLP repo: https://github.com/allenai/allennlp/blob/master/setup.py\n\nTo create the package for pypi.\n\n1. Change the version in __init__.py and setup.py.\n\n2. Commit these changes with the message: ""Release: VERSION""\n\n3. Add a tag in git to mark the release: ""git tag VERSION -m\'Adds tag VERSION for pypi\' ""\n   Push the tag to git: git push --tags origin master\n\n4. Build both the sources and the wheel. Do not change anything in setup.py between\n   creating the wheel and the source distribution (obviously).\n\n   For the wheel, run: ""python setup.py bdist_wheel"" in the top level allennlp directory.\n   (this will build a wheel for the python version you use to build it - make sure you use python 3.x).\n\n   For the sources, run: ""python setup.py sdist""\n   You should now have a /dist directory with both .whl and .tar.gz source versions of allennlp.\n\n5. Check that everything looks correct by uploading the package to the pypi test server:\n\n   twine upload dist/* -r pypitest\n   (pypi suggest using twine as other methods upload files via plaintext.)\n\n   Check that you can install it in a virtualenv by running:\n   pip install -i https://testpypi.python.org/pypi allennlp\n\n6. Upload the final version to actual pypi:\n   twine upload dist/* -r pypi\n\n7. Copy the release notes from RELEASE.md to the tag in github once everything is looking hunky-dory.\n\n""""""\nfrom io import open\nfrom setuptools import find_packages, setup\n\nsetup(\n    name=""pytorch_pretrained_biggan"",\n    version=""0.1.0"",\n    author=""Thomas Wolf"",\n    author_email=""thomas@huggingface.co"",\n    description=""PyTorch version of DeepMind\'s BigGAN model with pre-trained models"",\n    long_description=open(""README.md"", ""r"", encoding=\'utf-8\').read(),\n    long_description_content_type=""text/markdown"",\n    keywords=\'BIGGAN GAN deep learning google deepmind\',\n    license=\'Apache\',\n    url=""https://github.com/huggingface/pytorch-pretrained-BigGAN"",\n    packages=find_packages(exclude=[""*.tests"", ""*.tests.*"",\n                                    ""tests.*"", ""tests""]),\n    install_requires=[\'torch>=0.4.1\',\n                      \'numpy\',\n                      \'boto3\',\n                      \'requests\',\n                      \'tqdm\'],\n    tests_require=[\'pytest\'],\n    entry_points={\n      \'console_scripts\': [\n        ""pytorch_pretrained_biggan=pytorch_pretrained_biggan.convert_tf_to_pytorch:main"",\n      ]\n    },\n    classifiers=[\n          \'Intended Audience :: Science/Research\',\n          \'License :: OSI Approved :: Apache Software License\',\n          \'Programming Language :: Python :: 3\',\n          \'Topic :: Scientific/Engineering :: Artificial Intelligence\',\n    ],\n)\n'"
pytorch_pretrained_biggan/__init__.py,0,"b'from .config import BigGANConfig\nfrom .model import BigGAN\nfrom .file_utils import PYTORCH_PRETRAINED_BIGGAN_CACHE, cached_path\nfrom .utils import (truncated_noise_sample, save_as_images,\n                    convert_to_images, display_in_terminal,\n                    one_hot_from_int, one_hot_from_names)\n'"
pytorch_pretrained_biggan/config.py,0,"b'# coding: utf-8\n""""""\nBigGAN config.\n""""""\nfrom __future__ import (absolute_import, division, print_function, unicode_literals)\n\nimport copy\nimport json\n\nclass BigGANConfig(object):\n    """""" Configuration class to store the configuration of a `BigGAN`. \n        Defaults are for the 128x128 model.\n        layers tuple are (up-sample in the layer ?, input channels, output channels)\n    """"""\n    def __init__(self,\n                 output_dim=128,\n                 z_dim=128,\n                 class_embed_dim=128,\n                 channel_width=128,\n                 num_classes=1000,\n                 layers=[(False, 16, 16),\n                         (True, 16, 16),\n                         (False, 16, 16),\n                         (True, 16, 8),\n                         (False, 8, 8),\n                         (True, 8, 4),\n                         (False, 4, 4),\n                         (True, 4, 2),\n                         (False, 2, 2),\n                         (True, 2, 1)],\n                 attention_layer_position=8,\n                 eps=1e-4,\n                 n_stats=51):\n        """"""Constructs BigGANConfig. """"""\n        self.output_dim = output_dim\n        self.z_dim = z_dim\n        self.class_embed_dim = class_embed_dim\n        self.channel_width = channel_width\n        self.num_classes = num_classes\n        self.layers = layers\n        self.attention_layer_position = attention_layer_position\n        self.eps = eps\n        self.n_stats = n_stats\n\n    @classmethod\n    def from_dict(cls, json_object):\n        """"""Constructs a `BigGANConfig` from a Python dictionary of parameters.""""""\n        config = BigGANConfig()\n        for key, value in json_object.items():\n            config.__dict__[key] = value\n        return config\n\n    @classmethod\n    def from_json_file(cls, json_file):\n        """"""Constructs a `BigGANConfig` from a json file of parameters.""""""\n        with open(json_file, ""r"", encoding=\'utf-8\') as reader:\n            text = reader.read()\n        return cls.from_dict(json.loads(text))\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n'"
pytorch_pretrained_biggan/convert_tf_to_pytorch.py,14,"b'# coding: utf-8\n""""""\nConvert a TF Hub model for BigGAN in a PT one.\n""""""\nfrom __future__ import (absolute_import, division, print_function, unicode_literals)\n\nfrom itertools import chain\n\nimport os\nimport argparse\nimport logging\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn.functional import normalize\n\nfrom .model import BigGAN, WEIGHTS_NAME, CONFIG_NAME\nfrom .config import BigGANConfig\n\nlogger = logging.getLogger(__name__)\n\n\ndef extract_batch_norm_stats(tf_model_path, batch_norm_stats_path=None):\n    try:\n        import numpy as np\n        import tensorflow as tf\n        import tensorflow_hub as hub\n    except ImportError:\n        raise ImportError(""Loading a TensorFlow models in PyTorch, requires TensorFlow and TF Hub to be installed. ""\n                          ""Please see https://www.tensorflow.org/install/ for installation instructions for TensorFlow. ""\n                          ""And see https://github.com/tensorflow/hub for installing Hub. ""\n                          ""Probably pip install tensorflow tensorflow-hub"")\n    tf.reset_default_graph()\n    logger.info(\'Loading BigGAN module from: {}\'.format(tf_model_path))\n    module = hub.Module(tf_model_path)\n    inputs = {k: tf.placeholder(v.dtype, v.get_shape().as_list(), k)\n              for k, v in module.get_input_info_dict().items()}\n    output = module(inputs)\n\n    initializer = tf.global_variables_initializer()\n    sess = tf.Session()\n    stacks = sum(((i*10 + 1, i*10 + 3, i*10 + 6, i*10 + 8) for i in range(50)), ())\n    numpy_stacks = []\n    for i in stacks:\n        logger.info(""Retrieving module_apply_default/stack_{}"".format(i))\n        try:\n            stack_var = tf.get_default_graph().get_tensor_by_name(""module_apply_default/stack_%d:0"" % i)\n        except KeyError:\n            break  # We have all the stats\n        numpy_stacks.append(sess.run(stack_var))\n\n    if batch_norm_stats_path is not None:\n        torch.save(numpy_stacks, batch_norm_stats_path)\n    else:\n        return numpy_stacks\n\n\ndef build_tf_to_pytorch_map(model, config):\n    """""" Build a map from TF variables to PyTorch modules. """"""\n    tf_to_pt_map = {}\n\n    # Embeddings and GenZ\n    tf_to_pt_map.update({\'linear/w/ema_0.9999\': model.embeddings.weight,\n                         \'Generator/GenZ/G_linear/b/ema_0.9999\': model.generator.gen_z.bias,\n                         \'Generator/GenZ/G_linear/w/ema_0.9999\': model.generator.gen_z.weight_orig,\n                         \'Generator/GenZ/G_linear/u0\': model.generator.gen_z.weight_u})\n\n    # GBlock blocks\n    model_layer_idx = 0\n    for i, (up, in_channels, out_channels) in enumerate(config.layers):\n        if i == config.attention_layer_position:\n            model_layer_idx += 1\n        layer_str = ""Generator/GBlock_%d/"" % i if i > 0 else ""Generator/GBlock/""\n        layer_pnt = model.generator.layers[model_layer_idx]\n        for i in range(4):  #  Batchnorms\n            batch_str = layer_str + (""BatchNorm_%d/"" % i if i > 0 else ""BatchNorm/"")\n            batch_pnt = getattr(layer_pnt, \'bn_%d\' % i)\n            for name in (\'offset\', \'scale\'):\n                sub_module_str = batch_str + name + ""/""\n                sub_module_pnt = getattr(batch_pnt, name)\n                tf_to_pt_map.update({sub_module_str + ""w/ema_0.9999"": sub_module_pnt.weight_orig,\n                                     sub_module_str + ""u0"": sub_module_pnt.weight_u})\n        for i in range(4):  # Convolutions\n            conv_str = layer_str + ""conv%d/"" % i\n            conv_pnt = getattr(layer_pnt, \'conv_%d\' % i)\n            tf_to_pt_map.update({conv_str + ""b/ema_0.9999"": conv_pnt.bias,\n                                 conv_str + ""w/ema_0.9999"": conv_pnt.weight_orig,\n                                 conv_str + ""u0"": conv_pnt.weight_u})\n        model_layer_idx += 1\n\n    # Attention block\n    layer_str = ""Generator/attention/""\n    layer_pnt = model.generator.layers[config.attention_layer_position]\n    tf_to_pt_map.update({layer_str + ""gamma/ema_0.9999"": layer_pnt.gamma})\n    for pt_name, tf_name in zip([\'snconv1x1_g\', \'snconv1x1_o_conv\', \'snconv1x1_phi\', \'snconv1x1_theta\'],\n                                [\'g/\', \'o_conv/\', \'phi/\', \'theta/\']):\n        sub_module_str = layer_str + tf_name\n        sub_module_pnt = getattr(layer_pnt, pt_name)\n        tf_to_pt_map.update({sub_module_str + ""w/ema_0.9999"": sub_module_pnt.weight_orig,\n                             sub_module_str + ""u0"": sub_module_pnt.weight_u})\n\n    # final batch norm and conv to rgb\n    layer_str = ""Generator/BatchNorm/""\n    layer_pnt = model.generator.bn\n    tf_to_pt_map.update({layer_str + ""offset/ema_0.9999"": layer_pnt.bias,\n                         layer_str + ""scale/ema_0.9999"": layer_pnt.weight})\n    layer_str = ""Generator/conv_to_rgb/""\n    layer_pnt = model.generator.conv_to_rgb\n    tf_to_pt_map.update({layer_str + ""b/ema_0.9999"": layer_pnt.bias,\n                         layer_str + ""w/ema_0.9999"": layer_pnt.weight_orig,\n                         layer_str + ""u0"": layer_pnt.weight_u})\n    return tf_to_pt_map\n\n\ndef load_tf_weights_in_biggan(model, config, tf_model_path, batch_norm_stats_path=None):\n    """""" Load tf checkpoints and standing statistics in a pytorch model\n    """"""\n    try:\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        raise ImportError(""Loading a TensorFlow models in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n    # Load weights from TF model\n    checkpoint_path = tf_model_path + ""/variables/variables""\n    init_vars = tf.train.list_variables(checkpoint_path)\n    from pprint import pprint\n    pprint(init_vars)\n\n    # Extract batch norm statistics from model if needed\n    if batch_norm_stats_path:\n        stats = torch.load(batch_norm_stats_path)\n    else:\n        logger.info(""Extracting batch norm stats"")\n        stats = extract_batch_norm_stats(tf_model_path)\n\n    # Build TF to PyTorch weights loading map\n    tf_to_pt_map = build_tf_to_pytorch_map(model, config)\n\n    tf_weights = {}\n    for name in tf_to_pt_map.keys():\n        array = tf.train.load_variable(checkpoint_path, name)\n        tf_weights[name] = array\n        # logger.info(""Loading TF weight {} with shape {}"".format(name, array.shape))\n\n    # Load parameters\n    with torch.no_grad():\n        pt_params_pnt = set()\n        for name, pointer in tf_to_pt_map.items():\n            array = tf_weights[name]\n            if pointer.dim() == 1:\n                if pointer.dim() < array.ndim:\n                    array = np.squeeze(array)\n            elif pointer.dim() == 2:  # Weights\n                array = np.transpose(array)\n            elif pointer.dim() == 4:  # Convolutions\n                array = np.transpose(array, (3, 2, 0, 1))\n            else:\n                raise ""Wrong dimensions to adjust: "" + str((pointer.shape, array.shape))\n            if pointer.shape != array.shape:\n                raise ValueError(""Wrong dimensions: "" + str((pointer.shape, array.shape)))\n            logger.info(""Initialize PyTorch weight {} with shape {}"".format(name, pointer.shape))\n            pointer.data = torch.from_numpy(array) if isinstance(array, np.ndarray) else torch.tensor(array)\n            tf_weights.pop(name, None)\n            pt_params_pnt.add(pointer.data_ptr())\n\n        # Prepare SpectralNorm buffers by running one step of Spectral Norm (no need to train the model):\n        for module in model.modules():\n            for n, buffer in module.named_buffers():\n                if n == \'weight_v\':\n                    weight_mat = module.weight_orig\n                    weight_mat = weight_mat.reshape(weight_mat.size(0), -1)\n                    u = module.weight_u\n\n                    v = normalize(torch.mv(weight_mat.t(), u), dim=0, eps=config.eps)\n                    buffer.data = v\n                    pt_params_pnt.add(buffer.data_ptr())\n\n                    u = normalize(torch.mv(weight_mat, v), dim=0, eps=config.eps)\n                    module.weight_u.data = u\n                    pt_params_pnt.add(module.weight_u.data_ptr())\n\n        # Load batch norm statistics\n        index = 0\n        for layer in model.generator.layers:\n            if not hasattr(layer, \'bn_0\'):\n                continue\n            for i in range(4):  #  Batchnorms\n                bn_pointer = getattr(layer, \'bn_%d\' % i)\n                pointer = bn_pointer.running_means\n                if pointer.shape != stats[index].shape:\n                    raise ""Wrong dimensions: "" + str((pointer.shape, stats[index].shape))\n                pointer.data = torch.from_numpy(stats[index])\n                pt_params_pnt.add(pointer.data_ptr())\n\n                pointer = bn_pointer.running_vars\n                if pointer.shape != stats[index+1].shape:\n                    raise ""Wrong dimensions: "" + str((pointer.shape, stats[index].shape))\n                pointer.data = torch.from_numpy(stats[index+1])\n                pt_params_pnt.add(pointer.data_ptr())\n\n                index += 2\n\n        bn_pointer = model.generator.bn\n        pointer = bn_pointer.running_means\n        if pointer.shape != stats[index].shape:\n            raise ""Wrong dimensions: "" + str((pointer.shape, stats[index].shape))\n        pointer.data = torch.from_numpy(stats[index])\n        pt_params_pnt.add(pointer.data_ptr())\n\n        pointer = bn_pointer.running_vars\n        if pointer.shape != stats[index+1].shape:\n            raise ""Wrong dimensions: "" + str((pointer.shape, stats[index].shape))\n        pointer.data = torch.from_numpy(stats[index+1])\n        pt_params_pnt.add(pointer.data_ptr())\n\n    remaining_params = list(n for n, t in chain(model.named_parameters(), model.named_buffers()) \\\n                            if t.data_ptr() not in pt_params_pnt)\n\n    logger.info(""TF Weights not copied to PyTorch model: {} -"".format(\', \'.join(tf_weights.keys())))\n    logger.info(""Remanining parameters/buffers from PyTorch model: {} -"".format(\', \'.join(remaining_params)))\n\n    return model\n\n\nBigGAN128 = BigGANConfig(output_dim=128, z_dim=128, class_embed_dim=128, channel_width=128, num_classes=1000,\n                         layers=[(False, 16, 16),\n                                 (True, 16, 16),\n                                 (False, 16, 16),\n                                 (True, 16, 8),\n                                 (False, 8, 8),\n                                 (True, 8, 4),\n                                 (False, 4, 4),\n                                 (True, 4, 2),\n                                 (False, 2, 2),\n                                 (True, 2, 1)],\n                         attention_layer_position=8, eps=1e-4, n_stats=51)\n\nBigGAN256 = BigGANConfig(output_dim=256, z_dim=128, class_embed_dim=128, channel_width=128, num_classes=1000,\n                         layers=[(False, 16, 16),\n                                 (True, 16, 16),\n                                 (False, 16, 16),\n                                 (True, 16, 8),\n                                 (False, 8, 8),\n                                 (True, 8, 8),\n                                 (False, 8, 8),\n                                 (True, 8, 4),\n                                 (False, 4, 4),\n                                 (True, 4, 2),\n                                 (False, 2, 2),\n                                 (True, 2, 1)],\n                         attention_layer_position=8, eps=1e-4, n_stats=51)\n\nBigGAN512 = BigGANConfig(output_dim=512, z_dim=128, class_embed_dim=128, channel_width=128, num_classes=1000,\n                         layers=[(False, 16, 16),\n                                 (True, 16, 16),\n                                 (False, 16, 16),\n                                 (True, 16, 8),\n                                 (False, 8, 8),\n                                 (True, 8, 8),\n                                 (False, 8, 8),\n                                 (True, 8, 4),\n                                 (False, 4, 4),\n                                 (True, 4, 2),\n                                 (False, 2, 2),\n                                 (True, 2, 1),\n                                 (False, 1, 1),\n                                 (True, 1, 1)],\n                         attention_layer_position=8, eps=1e-4, n_stats=51)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=""Convert a BigGAN TF Hub model in a PyTorch model"")\n    parser.add_argument(""--model_type"", type=str, default="""", required=True,\n                        help=""BigGAN model type (128, 256, 512)"")\n    parser.add_argument(""--tf_model_path"", type=str, default="""", required=True,\n                        help=""Path of the downloaded TF Hub model"")\n    parser.add_argument(""--pt_save_path"", type=str, default="""",\n                        help=""Folder to save the PyTorch model (default: Folder of the TF Hub model)"")\n    parser.add_argument(""--batch_norm_stats_path"", type=str, default="""",\n                        help=""Path of previously extracted batch norm statistics"")\n    args = parser.parse_args()\n\n    logging.basicConfig(level=logging.INFO)\n\n    if not args.pt_save_path:\n        args.pt_save_path = args.tf_model_path\n\n    if args.model_type == ""128"":\n        config = BigGAN128\n    elif args.model_type == ""256"":\n        config = BigGAN256\n    elif args.model_type == ""512"":\n        config = BigGAN512\n    else:\n        raise ValueError(""model_type should be one of 128, 256 or 512"")\n\n    model = BigGAN(config)\n    model = load_tf_weights_in_biggan(model, config, args.tf_model_path, args.batch_norm_stats_path)\n\n    model_save_path = os.path.join(args.pt_save_path, WEIGHTS_NAME)\n    config_save_path = os.path.join(args.pt_save_path, CONFIG_NAME)\n\n    logger.info(""Save model dump to {}"".format(model_save_path))\n    torch.save(model.state_dict(), model_save_path)\n    logger.info(""Save configuration file to {}"".format(config_save_path))\n    with open(config_save_path, ""w"", encoding=""utf-8"") as f:\n        f.write(config.to_json_string())\n\nif __name__ == ""__main__"":\n    main()\n'"
pytorch_pretrained_biggan/file_utils.py,0,"b'""""""\nUtilities for working with the local dataset cache.\nThis file is adapted from the AllenNLP library at https://github.com/allenai/allennlp\nCopyright by the AllenNLP authors.\n""""""\nfrom __future__ import (absolute_import, division, print_function, unicode_literals)\n\nimport json\nimport logging\nimport os\nimport shutil\nimport tempfile\nfrom functools import wraps\nfrom hashlib import sha256\nimport sys\nfrom io import open\n\nimport boto3\nimport requests\nfrom botocore.exceptions import ClientError\nfrom tqdm import tqdm\n\ntry:\n    from urllib.parse import urlparse\nexcept ImportError:\n    from urlparse import urlparse\n\ntry:\n    from pathlib import Path\n    PYTORCH_PRETRAINED_BIGGAN_CACHE = Path(os.getenv(\'PYTORCH_PRETRAINED_BIGGAN_CACHE\',\n                                                   Path.home() / \'.pytorch_pretrained_biggan\'))\nexcept (AttributeError, ImportError):\n    PYTORCH_PRETRAINED_BIGGAN_CACHE = os.getenv(\'PYTORCH_PRETRAINED_BIGGAN_CACHE\',\n                                              os.path.join(os.path.expanduser(""~""), \'.pytorch_pretrained_biggan\'))\n\nlogger = logging.getLogger(__name__)  # pylint: disable=invalid-name\n\n\ndef url_to_filename(url, etag=None):\n    """"""\n    Convert `url` into a hashed filename in a repeatable way.\n    If `etag` is specified, append its hash to the url\'s, delimited\n    by a period.\n    """"""\n    url_bytes = url.encode(\'utf-8\')\n    url_hash = sha256(url_bytes)\n    filename = url_hash.hexdigest()\n\n    if etag:\n        etag_bytes = etag.encode(\'utf-8\')\n        etag_hash = sha256(etag_bytes)\n        filename += \'.\' + etag_hash.hexdigest()\n\n    return filename\n\n\ndef filename_to_url(filename, cache_dir=None):\n    """"""\n    Return the url and etag (which may be ``None``) stored for `filename`.\n    Raise ``EnvironmentError`` if `filename` or its stored metadata do not exist.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_PRETRAINED_BIGGAN_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    cache_path = os.path.join(cache_dir, filename)\n    if not os.path.exists(cache_path):\n        raise EnvironmentError(""file {} not found"".format(cache_path))\n\n    meta_path = cache_path + \'.json\'\n    if not os.path.exists(meta_path):\n        raise EnvironmentError(""file {} not found"".format(meta_path))\n\n    with open(meta_path, encoding=""utf-8"") as meta_file:\n        metadata = json.load(meta_file)\n    url = metadata[\'url\']\n    etag = metadata[\'etag\']\n\n    return url, etag\n\n\ndef cached_path(url_or_filename, cache_dir=None):\n    """"""\n    Given something that might be a URL (or might be a local path),\n    determine which. If it\'s a URL, download the file and cache it, and\n    return the path to the cached file. If it\'s already a local path,\n    make sure the file exists and then return the path.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_PRETRAINED_BIGGAN_CACHE\n    if sys.version_info[0] == 3 and isinstance(url_or_filename, Path):\n        url_or_filename = str(url_or_filename)\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    parsed = urlparse(url_or_filename)\n\n    if parsed.scheme in (\'http\', \'https\', \'s3\'):\n        # URL, so get it from the cache (downloading if necessary)\n        return get_from_cache(url_or_filename, cache_dir)\n    elif os.path.exists(url_or_filename):\n        # File, and it exists.\n        return url_or_filename\n    elif parsed.scheme == \'\':\n        # File, but it doesn\'t exist.\n        raise EnvironmentError(""file {} not found"".format(url_or_filename))\n    else:\n        # Something unknown\n        raise ValueError(""unable to parse {} as a URL or as a local path"".format(url_or_filename))\n\n\ndef split_s3_path(url):\n    """"""Split a full s3 path into the bucket name and path.""""""\n    parsed = urlparse(url)\n    if not parsed.netloc or not parsed.path:\n        raise ValueError(""bad s3 path {}"".format(url))\n    bucket_name = parsed.netloc\n    s3_path = parsed.path\n    # Remove \'/\' at beginning of path.\n    if s3_path.startswith(""/""):\n        s3_path = s3_path[1:]\n    return bucket_name, s3_path\n\n\ndef s3_request(func):\n    """"""\n    Wrapper function for s3 requests in order to create more helpful error\n    messages.\n    """"""\n\n    @wraps(func)\n    def wrapper(url, *args, **kwargs):\n        try:\n            return func(url, *args, **kwargs)\n        except ClientError as exc:\n            if int(exc.response[""Error""][""Code""]) == 404:\n                raise EnvironmentError(""file {} not found"".format(url))\n            else:\n                raise\n\n    return wrapper\n\n\n@s3_request\ndef s3_etag(url):\n    """"""Check ETag on S3 object.""""""\n    s3_resource = boto3.resource(""s3"")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_object = s3_resource.Object(bucket_name, s3_path)\n    return s3_object.e_tag\n\n\n@s3_request\ndef s3_get(url, temp_file):\n    """"""Pull a file directly from S3.""""""\n    s3_resource = boto3.resource(""s3"")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)\n\n\ndef http_get(url, temp_file):\n    req = requests.get(url, stream=True)\n    content_length = req.headers.get(\'Content-Length\')\n    total = int(content_length) if content_length is not None else None\n    progress = tqdm(unit=""B"", total=total)\n    for chunk in req.iter_content(chunk_size=1024):\n        if chunk: # filter out keep-alive new chunks\n            progress.update(len(chunk))\n            temp_file.write(chunk)\n    progress.close()\n\n\ndef get_from_cache(url, cache_dir=None):\n    """"""\n    Given a URL, look for the corresponding dataset in the local cache.\n    If it\'s not there, download it. Then return the path to the cached file.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_PRETRAINED_BIGGAN_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    # Get eTag to add to filename, if it exists.\n    if url.startswith(""s3://""):\n        etag = s3_etag(url)\n    else:\n        response = requests.head(url, allow_redirects=True)\n        if response.status_code != 200:\n            raise IOError(""HEAD request failed for url {} with status code {}""\n                          .format(url, response.status_code))\n        etag = response.headers.get(""ETag"")\n\n    filename = url_to_filename(url, etag)\n\n    # get cache path to put the file\n    cache_path = os.path.join(cache_dir, filename)\n\n    if not os.path.exists(cache_path):\n        # Download to temporary file, then copy to cache dir once finished.\n        # Otherwise you get corrupt cache entries if the download gets interrupted.\n        with tempfile.NamedTemporaryFile() as temp_file:\n            logger.info(""%s not found in cache, downloading to %s"", url, temp_file.name)\n\n            # GET file object\n            if url.startswith(""s3://""):\n                s3_get(url, temp_file)\n            else:\n                http_get(url, temp_file)\n\n            # we are copying the file before closing it, so flush to avoid truncation\n            temp_file.flush()\n            # shutil.copyfileobj() starts at the current position, so go to the start\n            temp_file.seek(0)\n\n            logger.info(""copying %s to cache at %s"", temp_file.name, cache_path)\n            with open(cache_path, \'wb\') as cache_file:\n                shutil.copyfileobj(temp_file, cache_file)\n\n            logger.info(""creating metadata file for %s"", cache_path)\n            meta = {\'url\': url, \'etag\': etag}\n            meta_path = cache_path + \'.json\'\n            with open(meta_path, \'w\', encoding=""utf-8"") as meta_file:\n                json.dump(meta, meta_file)\n\n            logger.info(""removing temp file %s"", temp_file.name)\n\n    return cache_path\n\n\ndef read_set_from_file(filename):\n    \'\'\'\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \'\'\'\n    collection = set()\n    with open(filename, \'r\', encoding=\'utf-8\') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection\n\n\ndef get_file_extension(path, dot=True, lower=True):\n    ext = os.path.splitext(path)[1]\n    ext = ext if dot else ext[1:]\n    return ext.lower() if lower else ext\n'"
pytorch_pretrained_biggan/model.py,18,"b'# coding: utf-8\n"""""" BigGAN PyTorch model.\n    From ""Large Scale GAN Training for High Fidelity Natural Image Synthesis""\n    By Andrew Brock\x03y, Jeff Donahuey and Karen Simonyan.\n    https://openreview.net/forum?id=B1xsqj09Fm\n\n    PyTorch version implemented from the computational graph of the TF Hub module for BigGAN.\n    Some part of the code are adapted from https://github.com/brain-research/self-attention-gan\n\n    This version only comprises the generator (since the discriminator\'s weights are not released).\n    This version only comprises the ""deep"" version of BigGAN (see publication).\n""""""\nfrom __future__ import (absolute_import, division, print_function, unicode_literals)\n\nimport os\nimport logging\nimport math\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom .config import BigGANConfig\nfrom .file_utils import cached_path\n\nlogger = logging.getLogger(__name__)\n\nPRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'biggan-deep-128\': ""https://s3.amazonaws.com/models.huggingface.co/biggan/biggan-deep-128-pytorch_model.bin"",\n    \'biggan-deep-256\': ""https://s3.amazonaws.com/models.huggingface.co/biggan/biggan-deep-256-pytorch_model.bin"",\n    \'biggan-deep-512\': ""https://s3.amazonaws.com/models.huggingface.co/biggan/biggan-deep-512-pytorch_model.bin"",\n}\n\nPRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'biggan-deep-128\': ""https://s3.amazonaws.com/models.huggingface.co/biggan/biggan-deep-128-config.json"",\n    \'biggan-deep-256\': ""https://s3.amazonaws.com/models.huggingface.co/biggan/biggan-deep-256-config.json"",\n    \'biggan-deep-512\': ""https://s3.amazonaws.com/models.huggingface.co/biggan/biggan-deep-512-config.json"",\n}\n\nWEIGHTS_NAME = \'pytorch_model.bin\'\nCONFIG_NAME = \'config.json\'\n\n\ndef snconv2d(eps=1e-12, **kwargs):\n    return nn.utils.spectral_norm(nn.Conv2d(**kwargs), eps=eps)\n\ndef snlinear(eps=1e-12, **kwargs):\n    return nn.utils.spectral_norm(nn.Linear(**kwargs), eps=eps)\n\ndef sn_embedding(eps=1e-12, **kwargs):\n    return nn.utils.spectral_norm(nn.Embedding(**kwargs), eps=eps)\n\nclass SelfAttn(nn.Module):\n    """""" Self attention Layer""""""\n    def __init__(self, in_channels, eps=1e-12):\n        super(SelfAttn, self).__init__()\n        self.in_channels = in_channels\n        self.snconv1x1_theta = snconv2d(in_channels=in_channels, out_channels=in_channels//8,\n                                        kernel_size=1, bias=False, eps=eps)\n        self.snconv1x1_phi = snconv2d(in_channels=in_channels, out_channels=in_channels//8,\n                                      kernel_size=1, bias=False, eps=eps)\n        self.snconv1x1_g = snconv2d(in_channels=in_channels, out_channels=in_channels//2,\n                                    kernel_size=1, bias=False, eps=eps)\n        self.snconv1x1_o_conv = snconv2d(in_channels=in_channels//2, out_channels=in_channels,\n                                         kernel_size=1, bias=False, eps=eps)\n        self.maxpool = nn.MaxPool2d(2, stride=2, padding=0)\n        self.softmax  = nn.Softmax(dim=-1)\n        self.gamma = nn.Parameter(torch.zeros(1))\n\n    def forward(self, x):\n        _, ch, h, w = x.size()\n        # Theta path\n        theta = self.snconv1x1_theta(x)\n        theta = theta.view(-1, ch//8, h*w)\n        # Phi path\n        phi = self.snconv1x1_phi(x)\n        phi = self.maxpool(phi)\n        phi = phi.view(-1, ch//8, h*w//4)\n        # Attn map\n        attn = torch.bmm(theta.permute(0, 2, 1), phi)\n        attn = self.softmax(attn)\n        # g path\n        g = self.snconv1x1_g(x)\n        g = self.maxpool(g)\n        g = g.view(-1, ch//2, h*w//4)\n        # Attn_g - o_conv\n        attn_g = torch.bmm(g, attn.permute(0, 2, 1))\n        attn_g = attn_g.view(-1, ch//2, h, w)\n        attn_g = self.snconv1x1_o_conv(attn_g)\n        # Out\n        out = x + self.gamma*attn_g\n        return out\n\n\nclass BigGANBatchNorm(nn.Module):\n    """""" This is a batch norm module that can handle conditional input and can be provided with pre-computed\n        activation means and variances for various truncation parameters.\n\n        We cannot just rely on torch.batch_norm since it cannot handle\n        batched weights (pytorch 1.0.1). We computate batch_norm our-self without updating running means and variances.\n        If you want to train this model you should add running means and variance computation logic.\n    """"""\n    def __init__(self, num_features, condition_vector_dim=None, n_stats=51, eps=1e-4, conditional=True):\n        super(BigGANBatchNorm, self).__init__()\n        self.num_features = num_features\n        self.eps = eps\n        self.conditional = conditional\n\n        # We use pre-computed statistics for n_stats values of truncation between 0 and 1\n        self.register_buffer(\'running_means\', torch.zeros(n_stats, num_features))\n        self.register_buffer(\'running_vars\', torch.ones(n_stats, num_features))\n        self.step_size = 1.0 / (n_stats - 1)\n\n        if conditional:\n            assert condition_vector_dim is not None\n            self.scale = snlinear(in_features=condition_vector_dim, out_features=num_features, bias=False, eps=eps)\n            self.offset = snlinear(in_features=condition_vector_dim, out_features=num_features, bias=False, eps=eps)\n        else:\n            self.weight = torch.nn.Parameter(torch.Tensor(num_features))\n            self.bias = torch.nn.Parameter(torch.Tensor(num_features))\n\n    def forward(self, x, truncation, condition_vector=None):\n        # Retreive pre-computed statistics associated to this truncation\n        coef, start_idx = math.modf(truncation / self.step_size)\n        start_idx = int(start_idx)\n        if coef != 0.0:  # Interpolate\n            running_mean = self.running_means[start_idx] * coef + self.running_means[start_idx + 1] * (1 - coef)\n            running_var = self.running_vars[start_idx] * coef + self.running_vars[start_idx + 1] * (1 - coef)\n        else:\n            running_mean = self.running_means[start_idx]\n            running_var = self.running_vars[start_idx]\n\n        if self.conditional:\n            running_mean = running_mean.unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n            running_var = running_var.unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n\n            weight = 1 + self.scale(condition_vector).unsqueeze(-1).unsqueeze(-1)\n            bias = self.offset(condition_vector).unsqueeze(-1).unsqueeze(-1)\n\n            out = (x - running_mean) / torch.sqrt(running_var + self.eps) * weight + bias\n        else:\n            out = F.batch_norm(x, running_mean, running_var, self.weight, self.bias,\n                               training=False, momentum=0.0, eps=self.eps)\n\n        return out\n\n\nclass GenBlock(nn.Module):\n    def __init__(self, in_size, out_size, condition_vector_dim, reduction_factor=4, up_sample=False,\n                 n_stats=51, eps=1e-12):\n        super(GenBlock, self).__init__()\n        self.up_sample = up_sample\n        self.drop_channels = (in_size != out_size)\n        middle_size = in_size // reduction_factor\n\n        self.bn_0 = BigGANBatchNorm(in_size, condition_vector_dim, n_stats=n_stats, eps=eps, conditional=True)\n        self.conv_0 = snconv2d(in_channels=in_size, out_channels=middle_size, kernel_size=1, eps=eps)\n\n        self.bn_1 = BigGANBatchNorm(middle_size, condition_vector_dim, n_stats=n_stats, eps=eps, conditional=True)\n        self.conv_1 = snconv2d(in_channels=middle_size, out_channels=middle_size, kernel_size=3, padding=1, eps=eps)\n\n        self.bn_2 = BigGANBatchNorm(middle_size, condition_vector_dim, n_stats=n_stats, eps=eps, conditional=True)\n        self.conv_2 = snconv2d(in_channels=middle_size, out_channels=middle_size, kernel_size=3, padding=1, eps=eps)\n\n        self.bn_3 = BigGANBatchNorm(middle_size, condition_vector_dim, n_stats=n_stats, eps=eps, conditional=True)\n        self.conv_3 = snconv2d(in_channels=middle_size, out_channels=out_size, kernel_size=1, eps=eps)\n\n        self.relu = nn.ReLU()\n\n    def forward(self, x, cond_vector, truncation):\n        x0 = x\n\n        x = self.bn_0(x, truncation, cond_vector)\n        x = self.relu(x)\n        x = self.conv_0(x)\n\n        x = self.bn_1(x, truncation, cond_vector)\n        x = self.relu(x)\n        if self.up_sample:\n            x = F.interpolate(x, scale_factor=2, mode=\'nearest\')\n        x = self.conv_1(x)\n\n        x = self.bn_2(x, truncation, cond_vector)\n        x = self.relu(x)\n        x = self.conv_2(x)\n\n        x = self.bn_3(x, truncation, cond_vector)\n        x = self.relu(x)\n        x = self.conv_3(x)\n\n        if self.drop_channels:\n            new_channels = x0.shape[1] // 2\n            x0 = x0[:, :new_channels, ...]\n        if self.up_sample:\n            x0 = F.interpolate(x0, scale_factor=2, mode=\'nearest\')\n\n        out = x + x0\n        return out\n\nclass Generator(nn.Module):\n    def __init__(self, config):\n        super(Generator, self).__init__()\n        self.config = config\n        ch = config.channel_width\n        condition_vector_dim = config.z_dim * 2\n\n        self.gen_z = snlinear(in_features=condition_vector_dim,\n                              out_features=4 * 4 * 16 * ch, eps=config.eps)\n\n        layers = []\n        for i, layer in enumerate(config.layers):\n            if i == config.attention_layer_position:\n                layers.append(SelfAttn(ch*layer[1], eps=config.eps))\n            layers.append(GenBlock(ch*layer[1],\n                                   ch*layer[2],\n                                   condition_vector_dim,\n                                   up_sample=layer[0],\n                                   n_stats=config.n_stats,\n                                   eps=config.eps))\n        self.layers = nn.ModuleList(layers)\n\n        self.bn = BigGANBatchNorm(ch, n_stats=config.n_stats, eps=config.eps, conditional=False)\n        self.relu = nn.ReLU()\n        self.conv_to_rgb = snconv2d(in_channels=ch, out_channels=ch, kernel_size=3, padding=1, eps=config.eps)\n        self.tanh = nn.Tanh()\n\n    def forward(self, cond_vector, truncation):\n        z = self.gen_z(cond_vector)\n\n        # We use this conversion step to be able to use TF weights:\n        # TF convention on shape is [batch, height, width, channels]\n        # PT convention on shape is [batch, channels, height, width]\n        z = z.view(-1, 4, 4, 16 * self.config.channel_width)\n        z = z.permute(0, 3, 1, 2).contiguous()\n\n        for i, layer in enumerate(self.layers):\n            if isinstance(layer, GenBlock):\n                z = layer(z, cond_vector, truncation)\n            else:\n                z = layer(z)\n\n        z = self.bn(z, truncation)\n        z = self.relu(z)\n        z = self.conv_to_rgb(z)\n        z = z[:, :3, ...]\n        z = self.tanh(z)\n        return z\n\nclass BigGAN(nn.Module):\n    """"""BigGAN Generator.""""""\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, cache_dir=None, *inputs, **kwargs):\n        if pretrained_model_name_or_path in PRETRAINED_MODEL_ARCHIVE_MAP:\n            model_file = PRETRAINED_MODEL_ARCHIVE_MAP[pretrained_model_name_or_path]\n            config_file = PRETRAINED_CONFIG_ARCHIVE_MAP[pretrained_model_name_or_path]\n        else:\n            model_file = os.path.join(pretrained_model_name_or_path, WEIGHTS_NAME)\n            config_file = os.path.join(pretrained_model_name_or_path, CONFIG_NAME)\n\n        try:\n            resolved_model_file = cached_path(model_file, cache_dir=cache_dir)\n            resolved_config_file = cached_path(config_file, cache_dir=cache_dir)\n        except EnvironmentError:\n            logger.error(""Wrong model name, should be a valid path to a folder containing ""\n                         ""a {} file and a {} file or a model name in {}"".format(\n                         WEIGHTS_NAME, CONFIG_NAME, PRETRAINED_MODEL_ARCHIVE_MAP.keys()))\n            raise\n\n        logger.info(""loading model {} from cache at {}"".format(pretrained_model_name_or_path, resolved_model_file))\n\n        # Load config\n        config = BigGANConfig.from_json_file(resolved_config_file)\n        logger.info(""Model config {}"".format(config))\n\n        # Instantiate model.\n        model = cls(config, *inputs, **kwargs)\n        state_dict = torch.load(resolved_model_file, map_location=\'cpu\' if not torch.cuda.is_available() else None)\n        model.load_state_dict(state_dict, strict=False)\n        return model\n\n    def __init__(self, config):\n        super(BigGAN, self).__init__()\n        self.config = config\n        self.embeddings = nn.Linear(config.num_classes, config.z_dim, bias=False)\n        self.generator = Generator(config)\n\n    def forward(self, z, class_label, truncation):\n        assert 0 < truncation <= 1\n\n        embed = self.embeddings(class_label)\n        cond_vector = torch.cat((z, embed), dim=1)\n\n        z = self.generator(cond_vector, truncation)\n        return z\n\n\nif __name__ == ""__main__"":\n    import PIL\n    from .utils import truncated_noise_sample, save_as_images, one_hot_from_names\n    from .convert_tf_to_pytorch import load_tf_weights_in_biggan\n\n    load_cache = False\n    cache_path = \'./saved_model.pt\'\n    config = BigGANConfig()\n    model = BigGAN(config)\n    if not load_cache:\n        model = load_tf_weights_in_biggan(model, config, \'./models/model_128/\', \'./models/model_128/batchnorms_stats.bin\')\n        torch.save(model.state_dict(), cache_path)\n    else:\n        model.load_state_dict(torch.load(cache_path))\n\n    model.eval()\n\n    truncation = 0.4\n    noise = truncated_noise_sample(batch_size=2, truncation=truncation)\n    label = one_hot_from_names(\'diver\', batch_size=2)\n\n    # Tests\n    # noise = np.zeros((1, 128))\n    # label = [983]\n\n    noise = torch.tensor(noise, dtype=torch.float)\n    label = torch.tensor(label, dtype=torch.float)\n    with torch.no_grad():\n        outputs = model(noise, label, truncation)\n    print(outputs.shape)\n\n    save_as_images(outputs)\n'"
pytorch_pretrained_biggan/utils.py,0,"b'# coding: utf-8\n"""""" BigGAN utilities to prepare truncated noise samples and convert/save/display output images.\n    Also comprise ImageNet utilities to prepare one hot input vectors for ImageNet classes.\n    We use Wordnet so you can just input a name in a string and automatically get a corresponding\n    imagenet class if it exists (or a hypo/hypernym exists in imagenet).\n""""""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nfrom io import BytesIO\n\nimport numpy as np\nfrom scipy.stats import truncnorm\n\nlogger = logging.getLogger(__name__)\n\nNUM_CLASSES = 1000\n\n\ndef truncated_noise_sample(batch_size=1, dim_z=128, truncation=1., seed=None):\n    """""" Create a truncated noise vector.\n        Params:\n            batch_size: batch size.\n            dim_z: dimension of z\n            truncation: truncation value to use\n            seed: seed for the random generator\n        Output:\n            array of shape (batch_size, dim_z)\n    """"""\n    state = None if seed is None else np.random.RandomState(seed)\n    values = truncnorm.rvs(-2, 2, size=(batch_size, dim_z), random_state=state).astype(np.float32)\n    return truncation * values\n\n\ndef convert_to_images(obj):\n    """""" Convert an output tensor from BigGAN in a list of images.\n        Params:\n            obj: tensor or numpy array of shape (batch_size, channels, height, width)\n        Output:\n            list of Pillow Images of size (height, width)\n    """"""\n    try:\n        import PIL\n    except ImportError:\n        raise ImportError(""Please install Pillow to use images: pip install Pillow"")\n\n    if not isinstance(obj, np.ndarray):\n        obj = obj.detach().numpy()\n\n    obj = obj.transpose((0, 2, 3, 1))\n    obj = np.clip(((obj + 1) / 2.0) * 256, 0, 255)\n\n    img = []\n    for i, out in enumerate(obj):\n        out_array = np.asarray(np.uint8(out), dtype=np.uint8)\n        img.append(PIL.Image.fromarray(out_array))\n    return img\n\n\ndef save_as_images(obj, file_name=\'output\'):\n    """""" Convert and save an output tensor from BigGAN in a list of saved images.\n        Params:\n            obj: tensor or numpy array of shape (batch_size, channels, height, width)\n            file_name: path and beggingin of filename to save.\n                Images will be saved as `file_name_{image_number}.png`\n    """"""\n    img = convert_to_images(obj)\n\n    for i, out in enumerate(img):\n        current_file_name = file_name + \'_%d.png\' % i\n        logger.info(""Saving image to {}"".format(current_file_name))\n        out.save(current_file_name, \'png\')\n\n\ndef display_in_terminal(obj):\n    """""" Convert and display an output tensor from BigGAN in the terminal.\n        This function use `libsixel` and will only work in a libsixel-compatible terminal.\n        Please refer to https://github.com/saitoha/libsixel for more details.\n\n        Params:\n            obj: tensor or numpy array of shape (batch_size, channels, height, width)\n            file_name: path and beggingin of filename to save.\n                Images will be saved as `file_name_{image_number}.png`\n    """"""\n    try:\n        import PIL\n        from libsixel import (sixel_output_new, sixel_dither_new, sixel_dither_initialize,\n                              sixel_dither_set_palette, sixel_dither_set_pixelformat,\n                              sixel_dither_get, sixel_encode, sixel_dither_unref,\n                              sixel_output_unref, SIXEL_PIXELFORMAT_RGBA8888,\n                              SIXEL_PIXELFORMAT_RGB888, SIXEL_PIXELFORMAT_PAL8,\n                              SIXEL_PIXELFORMAT_G8, SIXEL_PIXELFORMAT_G1)\n    except ImportError:\n        raise ImportError(""Display in Terminal requires Pillow, libsixel ""\n                          ""and a libsixel compatible terminal. ""\n                          ""Please read info at https://github.com/saitoha/libsixel ""\n                          ""and install with pip install Pillow libsixel-python"")\n\n    s = BytesIO()\n\n    images = convert_to_images(obj)\n    widths, heights = zip(*(i.size for i in images))\n\n    output_width = sum(widths)\n    output_height = max(heights)\n\n    output_image = PIL.Image.new(\'RGB\', (output_width, output_height))\n\n    x_offset = 0\n    for im in images:\n        output_image.paste(im, (x_offset,0))\n        x_offset += im.size[0]\n\n    try:\n        data = output_image.tobytes()\n    except NotImplementedError:\n        data = output_image.tostring()\n    output = sixel_output_new(lambda data, s: s.write(data), s)\n\n    try:\n        if output_image.mode == \'RGBA\':\n            dither = sixel_dither_new(256)\n            sixel_dither_initialize(dither, data, output_width, output_height, SIXEL_PIXELFORMAT_RGBA8888)\n        elif output_image.mode == \'RGB\':\n            dither = sixel_dither_new(256)\n            sixel_dither_initialize(dither, data, output_width, output_height, SIXEL_PIXELFORMAT_RGB888)\n        elif output_image.mode == \'P\':\n            palette = output_image.getpalette()\n            dither = sixel_dither_new(256)\n            sixel_dither_set_palette(dither, palette)\n            sixel_dither_set_pixelformat(dither, SIXEL_PIXELFORMAT_PAL8)\n        elif output_image.mode == \'L\':\n            dither = sixel_dither_get(SIXEL_BUILTIN_G8)\n            sixel_dither_set_pixelformat(dither, SIXEL_PIXELFORMAT_G8)\n        elif output_image.mode == \'1\':\n            dither = sixel_dither_get(SIXEL_BUILTIN_G1)\n            sixel_dither_set_pixelformat(dither, SIXEL_PIXELFORMAT_G1)\n        else:\n            raise RuntimeError(\'unexpected output_image mode\')\n        try:\n            sixel_encode(data, output_width, output_height, 1, dither, output)\n            print(s.getvalue().decode(\'ascii\'))\n        finally:\n            sixel_dither_unref(dither)\n    finally:\n        sixel_output_unref(output)\n\n\ndef one_hot_from_int(int_or_list, batch_size=1):\n    """""" Create a one-hot vector from a class index or a list of class indices.\n        Params:\n            int_or_list: int, or list of int, of the imagenet classes (between 0 and 999)\n            batch_size: batch size.\n                If int_or_list is an int create a batch of identical classes.\n                If int_or_list is a list, we should have `len(int_or_list) == batch_size`\n        Output:\n            array of shape (batch_size, 1000)\n    """"""\n    if isinstance(int_or_list, int):\n        int_or_list = [int_or_list]\n\n    if len(int_or_list) == 1 and batch_size > 1:\n        int_or_list = [int_or_list[0]] * batch_size\n\n    assert batch_size == len(int_or_list)\n\n    array = np.zeros((batch_size, NUM_CLASSES), dtype=np.float32)\n    for i, j in enumerate(int_or_list):\n        array[i, j] = 1.0\n    return array\n\n\ndef one_hot_from_names(class_name_or_list, batch_size=1):\n    """""" Create a one-hot vector from the name of an imagenet class (\'tennis ball\', \'daisy\', ...).\n        We use NLTK\'s wordnet search to try to find the relevant synset of ImageNet and take the first one.\n        If we can\'t find it direcly, we look at the hyponyms and hypernyms of the class name.\n\n        Params:\n            class_name_or_list: string containing the name of an imagenet object or a list of such strings (for a batch).\n        Output:\n            array of shape (batch_size, 1000)\n    """"""\n    try:\n        from nltk.corpus import wordnet as wn\n    except ImportError:\n        raise ImportError(""You need to install nltk to use this function"")\n\n    if not isinstance(class_name_or_list, (list, tuple)):\n        class_name_or_list = [class_name_or_list]\n    else:\n        batch_size = max(batch_size, len(class_name_or_list))\n\n    classes = []\n    for class_name in class_name_or_list:\n        class_name = class_name.replace("" "", ""_"")\n\n        original_synsets = wn.synsets(class_name)\n        original_synsets = list(filter(lambda s: s.pos() == \'n\', original_synsets))  # keep only names\n        if not original_synsets:\n            return None\n\n        possible_synsets = list(filter(lambda s: s.offset() in IMAGENET, original_synsets))\n        if possible_synsets:\n            classes.append(IMAGENET[possible_synsets[0].offset()])\n        else:\n            # try hypernyms and hyponyms\n            possible_synsets = sum([s.hypernyms() + s.hyponyms() for s in original_synsets], [])\n            possible_synsets = list(filter(lambda s: s.offset() in IMAGENET, possible_synsets))\n            if possible_synsets:\n                classes.append(IMAGENET[possible_synsets[0].offset()])\n\n    return one_hot_from_int(classes, batch_size=batch_size)\n\n\nIMAGENET = {1440764: 0, 1443537: 1, 1484850: 2, 1491361: 3, 1494475: 4, 1496331: 5, 1498041: 6, 1514668: 7, 1514859: 8, 1518878: 9, 1530575: 10, 1531178: 11, 1532829: 12, 1534433: 13, 1537544: 14, 1558993: 15, 1560419: 16, 1580077: 17, 1582220: 18, 1592084: 19, 1601694: 20, 1608432: 21, 1614925: 22, 1616318: 23, 1622779: 24, 1629819: 25, 1630670: 26, 1631663: 27, 1632458: 28, 1632777: 29, 1641577: 30, 1644373: 31, 1644900: 32, 1664065: 33, 1665541: 34, 1667114: 35, 1667778: 36, 1669191: 37, 1675722: 38, 1677366: 39, 1682714: 40, 1685808: 41, 1687978: 42, 1688243: 43, 1689811: 44, 1692333: 45, 1693334: 46, 1694178: 47, 1695060: 48, 1697457: 49, 1698640: 50, 1704323: 51, 1728572: 52, 1728920: 53, 1729322: 54, 1729977: 55, 1734418: 56, 1735189: 57, 1737021: 58, 1739381: 59, 1740131: 60, 1742172: 61, 1744401: 62, 1748264: 63, 1749939: 64, 1751748: 65, 1753488: 66, 1755581: 67, 1756291: 68, 1768244: 69, 1770081: 70, 1770393: 71, 1773157: 72, 1773549: 73, 1773797: 74, 1774384: 75, 1774750: 76, 1775062: 77, 1776313: 78, 1784675: 79, 1795545: 80, 1796340: 81, 1797886: 82, 1798484: 83, 1806143: 84, 1806567: 85, 1807496: 86, 1817953: 87, 1818515: 88, 1819313: 89, 1820546: 90, 1824575: 91, 1828970: 92, 1829413: 93, 1833805: 94, 1843065: 95, 1843383: 96, 1847000: 97, 1855032: 98, 1855672: 99, 1860187: 100, 1871265: 101, 1872401: 102, 1873310: 103, 1877812: 104, 1882714: 105, 1883070: 106, 1910747: 107, 1914609: 108, 1917289: 109, 1924916: 110, 1930112: 111, 1943899: 112, 1944390: 113, 1945685: 114, 1950731: 115, 1955084: 116, 1968897: 117, 1978287: 118, 1978455: 119, 1980166: 120, 1981276: 121, 1983481: 122, 1984695: 123, 1985128: 124, 1986214: 125, 1990800: 126, 2002556: 127, 2002724: 128, 2006656: 129, 2007558: 130, 2009229: 131, 2009912: 132, 2011460: 133, 2012849: 134, 2013706: 135, 2017213: 136, 2018207: 137, 2018795: 138, 2025239: 139, 2027492: 140, 2028035: 141, 2033041: 142, 2037110: 143, 2051845: 144, 2056570: 145, 2058221: 146, 2066245: 147, 2071294: 148, 2074367: 149, 2077923: 150, 2085620: 151, 2085782: 152, 2085936: 153, 2086079: 154, 2086240: 155, 2086646: 156, 2086910: 157, 2087046: 158, 2087394: 159, 2088094: 160, 2088238: 161, 2088364: 162, 2088466: 163, 2088632: 164, 2089078: 165, 2089867: 166, 2089973: 167, 2090379: 168, 2090622: 169, 2090721: 170, 2091032: 171, 2091134: 172, 2091244: 173, 2091467: 174, 2091635: 175, 2091831: 176, 2092002: 177, 2092339: 178, 2093256: 179, 2093428: 180, 2093647: 181, 2093754: 182, 2093859: 183, 2093991: 184, 2094114: 185, 2094258: 186, 2094433: 187, 2095314: 188, 2095570: 189, 2095889: 190, 2096051: 191, 2096177: 192, 2096294: 193, 2096437: 194, 2096585: 195, 2097047: 196, 2097130: 197, 2097209: 198, 2097298: 199, 2097474: 200, 2097658: 201, 2098105: 202, 2098286: 203, 2098413: 204, 2099267: 205, 2099429: 206, 2099601: 207, 2099712: 208, 2099849: 209, 2100236: 210, 2100583: 211, 2100735: 212, 2100877: 213, 2101006: 214, 2101388: 215, 2101556: 216, 2102040: 217, 2102177: 218, 2102318: 219, 2102480: 220, 2102973: 221, 2104029: 222, 2104365: 223, 2105056: 224, 2105162: 225, 2105251: 226, 2105412: 227, 2105505: 228, 2105641: 229, 2105855: 230, 2106030: 231, 2106166: 232, 2106382: 233, 2106550: 234, 2106662: 235, 2107142: 236, 2107312: 237, 2107574: 238, 2107683: 239, 2107908: 240, 2108000: 241, 2108089: 242, 2108422: 243, 2108551: 244, 2108915: 245, 2109047: 246, 2109525: 247, 2109961: 248, 2110063: 249, 2110185: 250, 2110341: 251, 2110627: 252, 2110806: 253, 2110958: 254, 2111129: 255, 2111277: 256, 2111500: 257, 2111889: 258, 2112018: 259, 2112137: 260, 2112350: 261, 2112706: 262, 2113023: 263, 2113186: 264, 2113624: 265, 2113712: 266, 2113799: 267, 2113978: 268, 2114367: 269, 2114548: 270, 2114712: 271, 2114855: 272, 2115641: 273, 2115913: 274, 2116738: 275, 2117135: 276, 2119022: 277, 2119789: 278, 2120079: 279, 2120505: 280, 2123045: 281, 2123159: 282, 2123394: 283, 2123597: 284, 2124075: 285, 2125311: 286, 2127052: 287, 2128385: 288, 2128757: 289, 2128925: 290, 2129165: 291, 2129604: 292, 2130308: 293, 2132136: 294, 2133161: 295, 2134084: 296, 2134418: 297, 2137549: 298, 2138441: 299, 2165105: 300, 2165456: 301, 2167151: 302, 2168699: 303, 2169497: 304, 2172182: 305, 2174001: 306, 2177972: 307, 2190166: 308, 2206856: 309, 2219486: 310, 2226429: 311, 2229544: 312, 2231487: 313, 2233338: 314, 2236044: 315, 2256656: 316, 2259212: 317, 2264363: 318, 2268443: 319, 2268853: 320, 2276258: 321, 2277742: 322, 2279972: 323, 2280649: 324, 2281406: 325, 2281787: 326, 2317335: 327, 2319095: 328, 2321529: 329, 2325366: 330, 2326432: 331, 2328150: 332, 2342885: 333, 2346627: 334, 2356798: 335, 2361337: 336, 2363005: 337, 2364673: 338, 2389026: 339, 2391049: 340, 2395406: 341, 2396427: 342, 2397096: 343, 2398521: 344, 2403003: 345, 2408429: 346, 2410509: 347, 2412080: 348, 2415577: 349, 2417914: 350, 2422106: 351, 2422699: 352, 2423022: 353, 2437312: 354, 2437616: 355, 2441942: 356, 2442845: 357, 2443114: 358, 2443484: 359, 2444819: 360, 2445715: 361, 2447366: 362, 2454379: 363, 2457408: 364, 2480495: 365, 2480855: 366, 2481823: 367, 2483362: 368, 2483708: 369, 2484975: 370, 2486261: 371, 2486410: 372, 2487347: 373, 2488291: 374, 2488702: 375, 2489166: 376, 2490219: 377, 2492035: 378, 2492660: 379, 2493509: 380, 2493793: 381, 2494079: 382, 2497673: 383, 2500267: 384, 2504013: 385, 2504458: 386, 2509815: 387, 2510455: 388, 2514041: 389, 2526121: 390, 2536864: 391, 2606052: 392, 2607072: 393, 2640242: 394, 2641379: 395, 2643566: 396, 2655020: 397, 2666196: 398, 2667093: 399, 2669723: 400, 2672831: 401, 2676566: 402, 2687172: 403, 2690373: 404, 2692877: 405, 2699494: 406, 2701002: 407, 2704792: 408, 2708093: 409, 2727426: 410, 2730930: 411, 2747177: 412, 2749479: 413, 2769748: 414, 2776631: 415, 2777292: 416, 2782093: 417, 2783161: 418, 2786058: 419, 2787622: 420, 2788148: 421, 2790996: 422, 2791124: 423, 2791270: 424, 2793495: 425, 2794156: 426, 2795169: 427, 2797295: 428, 2799071: 429, 2802426: 430, 2804414: 431, 2804610: 432, 2807133: 433, 2808304: 434, 2808440: 435, 2814533: 436, 2814860: 437, 2815834: 438, 2817516: 439, 2823428: 440, 2823750: 441, 2825657: 442, 2834397: 443, 2835271: 444, 2837789: 445, 2840245: 446, 2841315: 447, 2843684: 448, 2859443: 449, 2860847: 450, 2865351: 451, 2869837: 452, 2870880: 453, 2871525: 454, 2877765: 455, 2879718: 456, 2883205: 457, 2892201: 458, 2892767: 459, 2894605: 460, 2895154: 461, 2906734: 462, 2909870: 463, 2910353: 464, 2916936: 465, 2917067: 466, 2927161: 467, 2930766: 468, 2939185: 469, 2948072: 470, 2950826: 471, 2951358: 472, 2951585: 473, 2963159: 474, 2965783: 475, 2966193: 476, 2966687: 477, 2971356: 478, 2974003: 479, 2977058: 480, 2978881: 481, 2979186: 482, 2980441: 483, 2981792: 484, 2988304: 485, 2992211: 486, 2992529: 487, 2999410: 488, 3000134: 489, 3000247: 490, 3000684: 491, 3014705: 492, 3016953: 493, 3017168: 494, 3018349: 495, 3026506: 496, 3028079: 497, 3032252: 498, 3041632: 499, 3042490: 500, 3045698: 501, 3047690: 502, 3062245: 503, 3063599: 504, 3063689: 505, 3065424: 506, 3075370: 507, 3085013: 508, 3089624: 509, 3095699: 510, 3100240: 511, 3109150: 512, 3110669: 513, 3124043: 514, 3124170: 515, 3125729: 516, 3126707: 517, 3127747: 518, 3127925: 519, 3131574: 520, 3133878: 521, 3134739: 522, 3141823: 523, 3146219: 524, 3160309: 525, 3179701: 526, 3180011: 527, 3187595: 528, 3188531: 529, 3196217: 530, 3197337: 531, 3201208: 532, 3207743: 533, 3207941: 534, 3208938: 535, 3216828: 536, 3218198: 537, 3220513: 538, 3223299: 539, 3240683: 540, 3249569: 541, 3250847: 542, 3255030: 543, 3259280: 544, 3271574: 545, 3272010: 546, 3272562: 547, 3290653: 548, 3291819: 549, 3297495: 550, 3314780: 551, 3325584: 552, 3337140: 553, 3344393: 554, 3345487: 555, 3347037: 556, 3355925: 557, 3372029: 558, 3376595: 559, 3379051: 560, 3384352: 561, 3388043: 562, 3388183: 563, 3388549: 564, 3393912: 565, 3394916: 566, 3400231: 567, 3404251: 568, 3417042: 569, 3424325: 570, 3425413: 571, 3443371: 572, 3444034: 573, 3445777: 574, 3445924: 575, 3447447: 576, 3447721: 577, 3450230: 578, 3452741: 579, 3457902: 580, 3459775: 581, 3461385: 582, 3467068: 583, 3476684: 584, 3476991: 585, 3478589: 586, 3481172: 587, 3482405: 588, 3483316: 589, 3485407: 590, 3485794: 591, 3492542: 592, 3494278: 593, 3495258: 594, 3496892: 595, 3498962: 596, 3527444: 597, 3529860: 598, 3530642: 599, 3532672: 600, 3534580: 601, 3535780: 602, 3538406: 603, 3544143: 604, 3584254: 605, 3584829: 606, 3590841: 607, 3594734: 608, 3594945: 609, 3595614: 610, 3598930: 611, 3599486: 612, 3602883: 613, 3617480: 614, 3623198: 615, 3627232: 616, 3630383: 617, 3633091: 618, 3637318: 619, 3642806: 620, 3649909: 621, 3657121: 622, 3658185: 623, 3661043: 624, 3662601: 625, 3666591: 626, 3670208: 627, 3673027: 628, 3676483: 629, 3680355: 630, 3690938: 631, 3691459: 632, 3692522: 633, 3697007: 634, 3706229: 635, 3709823: 636, 3710193: 637, 3710637: 638, 3710721: 639, 3717622: 640, 3720891: 641, 3721384: 642, 3724870: 643, 3729826: 644, 3733131: 645, 3733281: 646, 3733805: 647, 3742115: 648, 3743016: 649, 3759954: 650, 3761084: 651, 3763968: 652, 3764736: 653, 3769881: 654, 3770439: 655, 3770679: 656, 3773504: 657, 3775071: 658, 3775546: 659, 3776460: 660, 3777568: 661, 3777754: 662, 3781244: 663, 3782006: 664, 3785016: 665, 3786901: 666, 3787032: 667, 3788195: 668, 3788365: 669, 3791053: 670, 3792782: 671, 3792972: 672, 3793489: 673, 3794056: 674, 3796401: 675, 3803284: 676, 3804744: 677, 3814639: 678, 3814906: 679, 3825788: 680, 3832673: 681, 3837869: 682, 3838899: 683, 3840681: 684, 3841143: 685, 3843555: 686, 3854065: 687, 3857828: 688, 3866082: 689, 3868242: 690, 3868863: 691, 3871628: 692, 3873416: 693, 3874293: 694, 3874599: 695, 3876231: 696, 3877472: 697, 3877845: 698, 3884397: 699, 3887697: 700, 3888257: 701, 3888605: 702, 3891251: 703, 3891332: 704, 3895866: 705, 3899768: 706, 3902125: 707, 3903868: 708, 3908618: 709, 3908714: 710, 3916031: 711, 3920288: 712, 3924679: 713, 3929660: 714, 3929855: 715, 3930313: 716, 3930630: 717, 3933933: 718, 3935335: 719, 3937543: 720, 3938244: 721, 3942813: 722, 3944341: 723, 3947888: 724, 3950228: 725, 3954731: 726, 3956157: 727, 3958227: 728, 3961711: 729, 3967562: 730, 3970156: 731, 3976467: 732, 3976657: 733, 3977966: 734, 3980874: 735, 3982430: 736, 3983396: 737, 3991062: 738, 3992509: 739, 3995372: 740, 3998194: 741, 4004767: 742, 4005630: 743, 4008634: 744, 4009552: 745, 4019541: 746, 4023962: 747, 4026417: 748, 4033901: 749, 4033995: 750, 4037443: 751, 4039381: 752, 4040759: 753, 4041544: 754, 4044716: 755, 4049303: 756, 4065272: 757, 4067472: 758, 4069434: 759, 4070727: 760, 4074963: 761, 4081281: 762, 4086273: 763, 4090263: 764, 4099969: 765, 4111531: 766, 4116512: 767, 4118538: 768, 4118776: 769, 4120489: 770, 4125021: 771, 4127249: 772, 4131690: 773, 4133789: 774, 4136333: 775, 4141076: 776, 4141327: 777, 4141975: 778, 4146614: 779, 4147183: 780, 4149813: 781, 4152593: 782, 4153751: 783, 4154565: 784, 4162706: 785, 4179913: 786, 4192698: 787, 4200800: 788, 4201297: 789, 4204238: 790, 4204347: 791, 4208210: 792, 4209133: 793, 4209239: 794, 4228054: 795, 4229816: 796, 4235860: 797, 4238763: 798, 4239074: 799, 4243546: 800, 4251144: 801, 4252077: 802, 4252225: 803, 4254120: 804, 4254680: 805, 4254777: 806, 4258138: 807, 4259630: 808, 4263257: 809, 4264628: 810, 4265275: 811, 4266014: 812, 4270147: 813, 4273569: 814, 4275548: 815, 4277352: 816, 4285008: 817, 4286575: 818, 4296562: 819, 4310018: 820, 4311004: 821, 4311174: 822, 4317175: 823, 4325704: 824, 4326547: 825, 4328186: 826, 4330267: 827, 4332243: 828, 4335435: 829, 4336792: 830, 4344873: 831, 4346328: 832, 4347754: 833, 4350905: 834, 4355338: 835, 4355933: 836, 4356056: 837, 4357314: 838, 4366367: 839, 4367480: 840, 4370456: 841, 4371430: 842, 4371774: 843, 4372370: 844, 4376876: 845, 4380533: 846, 4389033: 847, 4392985: 848, 4398044: 849, 4399382: 850, 4404412: 851, 4409515: 852, 4417672: 853, 4418357: 854, 4423845: 855, 4428191: 856, 4429376: 857, 4435653: 858, 4442312: 859, 4443257: 860, 4447861: 861, 4456115: 862, 4458633: 863, 4461696: 864, 4462240: 865, 4465501: 866, 4467665: 867, 4476259: 868, 4479046: 869, 4482393: 870, 4483307: 871, 4485082: 872, 4486054: 873, 4487081: 874, 4487394: 875, 4493381: 876, 4501370: 877, 4505470: 878, 4507155: 879, 4509417: 880, 4515003: 881, 4517823: 882, 4522168: 883, 4523525: 884, 4525038: 885, 4525305: 886, 4532106: 887, 4532670: 888, 4536866: 889, 4540053: 890, 4542943: 891, 4548280: 892, 4548362: 893, 4550184: 894, 4552348: 895, 4553703: 896, 4554684: 897, 4557648: 898, 4560804: 899, 4562935: 900, 4579145: 901, 4579432: 902, 4584207: 903, 4589890: 904, 4590129: 905, 4591157: 906, 4591713: 907, 4592741: 908, 4596742: 909, 4597913: 910, 4599235: 911, 4604644: 912, 4606251: 913, 4612504: 914, 4613696: 915, 6359193: 916, 6596364: 917, 6785654: 918, 6794110: 919, 6874185: 920, 7248320: 921, 7565083: 922, 7579787: 923, 7583066: 924, 7584110: 925, 7590611: 926, 7613480: 927, 7614500: 928, 7615774: 929, 7684084: 930, 7693725: 931, 7695742: 932, 7697313: 933, 7697537: 934, 7711569: 935, 7714571: 936, 7714990: 937, 7715103: 938, 7716358: 939, 7716906: 940, 7717410: 941, 7717556: 942, 7718472: 943, 7718747: 944, 7720875: 945, 7730033: 946, 7734744: 947, 7742313: 948, 7745940: 949, 7747607: 950, 7749582: 951, 7753113: 952, 7753275: 953, 7753592: 954, 7754684: 955, 7760859: 956, 7768694: 957, 7802026: 958, 7831146: 959, 7836838: 960, 7860988: 961, 7871810: 962, 7873807: 963, 7875152: 964, 7880968: 965, 7892512: 966, 7920052: 967, 7930864: 968, 7932039: 969, 9193705: 970, 9229709: 971, 9246464: 972, 9256479: 973, 9288635: 974, 9332890: 975, 9399592: 976, 9421951: 977, 9428293: 978, 9468604: 979, 9472597: 980, 9835506: 981, 10148035: 982, 10565667: 983, 11879895: 984, 11939491: 985, 12057211: 986, 12144580: 987, 12267677: 988, 12620546: 989, 12768682: 990, 12985857: 991, 12998815: 992, 13037406: 993, 13040303: 994, 13044778: 995, 13052670: 996, 13054560: 997, 13133613: 998, 15075141: 999}\n'"
