file_path,api_count,code
bertviz/__init__.py,0,b'from .head_view import head_view\nfrom .model_view import model_view'
bertviz/head_view.py,1,"b'import json\nfrom IPython.core.display import display, HTML, Javascript\nimport os\nfrom .util import format_special_chars, format_attention\n\n\ndef head_view(attention, tokens, sentence_b_start = None, prettify_tokens=True):\n    """"""Render head view\n\n        Args:\n            attention: list of ``torch.FloatTensor``(one for each layer) of shape\n                ``(batch_size(must be 1), num_heads, sequence_length, sequence_length)``\n            tokens: list of tokens\n            sentence_b_index: index of first wordpiece in sentence B if input text is sentence pair (optional)\n            prettify_tokens: indicates whether to remove special characters in wordpieces, e.g. \xc4\xa0\n    """"""\n\n    if sentence_b_start is not None:\n        vis_html = """"""\n        <span style=""user-select:none"">\n            Layer: <select id=""layer""></select>\n            Attention: <select id=""filter"">\n              <option value=""all"">All</option>\n              <option value=""aa"">Sentence A -> Sentence A</option>\n              <option value=""ab"">Sentence A -> Sentence B</option>\n              <option value=""ba"">Sentence B -> Sentence A</option>\n              <option value=""bb"">Sentence B -> Sentence B</option>\n            </select>\n            </span>\n        <div id=\'vis\'></div>\n        """"""\n    else:\n        vis_html = """"""\n              <span style=""user-select:none"">\n                Layer: <select id=""layer""></select>\n              </span>\n              <div id=\'vis\'></div> \n            """"""\n\n    display(HTML(vis_html))\n    __location__ = os.path.realpath(\n        os.path.join(os.getcwd(), os.path.dirname(__file__)))\n    vis_js = open(os.path.join(__location__, \'head_view.js\')).read()\n\n    if prettify_tokens:\n        tokens = format_special_chars(tokens)\n\n    attn = format_attention(attention)\n    attn_data = {\n        \'all\': {\n            \'attn\': attn.tolist(),\n            \'left_text\': tokens,\n            \'right_text\': tokens\n        }\n    }\n    if sentence_b_start is not None:\n        slice_a = slice(0, sentence_b_start)  # Positions corresponding to sentence A in input\n        slice_b = slice(sentence_b_start, len(tokens))  # Position corresponding to sentence B in input\n        attn_data[\'aa\'] = {\n            \'attn\': attn[:, :, slice_a, slice_a].tolist(),\n            \'left_text\': tokens[slice_a],\n            \'right_text\': tokens[slice_a]\n        }\n        attn_data[\'bb\'] = {\n            \'attn\': attn[:, :, slice_b, slice_b].tolist(),\n            \'left_text\': tokens[slice_b],\n            \'right_text\': tokens[slice_b]\n        }\n        attn_data[\'ab\'] = {\n            \'attn\': attn[:, :, slice_a, slice_b].tolist(),\n            \'left_text\': tokens[slice_a],\n            \'right_text\': tokens[slice_b]\n        }\n        attn_data[\'ba\'] = {\n            \'attn\': attn[:, :, slice_b, slice_a].tolist(),\n            \'left_text\': tokens[slice_b],\n            \'right_text\': tokens[slice_a]\n        }\n    params = {\n        \'attention\': attn_data,\n        \'default_filter\': ""all""\n    }\n    attn_seq_len = len(attn_data[\'all\'][\'attn\'][0][0])\n    if attn_seq_len != len(tokens):\n        raise ValueError(f""Attention has {attn_seq_len} positions, while number of tokens is {len(tokens)}"")\n\n    display(Javascript(\'window.params = %s\' % json.dumps(params)))\n    display(Javascript(vis_js))'"
bertviz/model_view.py,1,"b'import json\nfrom IPython.core.display import display, HTML, Javascript\nimport os\nfrom .util import format_special_chars, format_attention\n\ndef model_view(attention, tokens, sentence_b_start=None, prettify_tokens=True):\n    """"""Render model view\n\n        Args:\n            attention: list of ``torch.FloatTensor``(one for each layer) of shape\n                ``(batch_size(must be 1), num_heads, sequence_length, sequence_length)``\n            tokens: list of tokens\n            sentence_b_index: index of first wordpiece in sentence B if input text is sentence pair (optional)\n            prettify_tokens: indicates whether to remove special characters in wordpieces, e.g. \xc4\xa0\n    """"""\n\n    if sentence_b_start is not None:\n        vis_html = """"""\n        <span style=""user-select:none"">\n            Attention: <select id=""filter"">\n              <option value=""all"">All</option>\n              <option value=""aa"">Sentence A -> Sentence A</option>\n              <option value=""ab"">Sentence A -> Sentence B</option>\n              <option value=""ba"">Sentence B -> Sentence A</option>\n              <option value=""bb"">Sentence B -> Sentence B</option>\n            </select>\n            </span>\n        <div id=\'vis\'></div>\n        """"""\n    else:\n        vis_html = """"""\n          <div id=\'vis\'></div> \n        """"""\n\n    display(HTML(vis_html))\n    __location__ = os.path.realpath(\n        os.path.join(os.getcwd(), os.path.dirname(__file__)))\n    vis_js = open(os.path.join(__location__, \'model_view.js\')).read()\n\n    if prettify_tokens:\n        tokens = format_special_chars(tokens)\n\n    attn = format_attention(attention)\n    attn_data = {\n        \'all\': {\n            \'attn\': attn.tolist(),\n            \'left_text\': tokens,\n            \'right_text\': tokens\n        }\n    }\n    if sentence_b_start is not None:\n        slice_a = slice(0, sentence_b_start)  # Positions corresponding to sentence A in input\n        slice_b = slice(sentence_b_start, len(tokens))  # Position corresponding to sentence B in input\n        attn_data[\'aa\'] = {\n            \'attn\': attn[:, :, slice_a, slice_a].tolist(),\n            \'left_text\': tokens[slice_a],\n            \'right_text\': tokens[slice_a]\n        }\n        attn_data[\'bb\'] = {\n            \'attn\': attn[:, :, slice_b, slice_b].tolist(),\n            \'left_text\': tokens[slice_b],\n            \'right_text\': tokens[slice_b]\n        }\n        attn_data[\'ab\'] = {\n            \'attn\': attn[:, :, slice_a, slice_b].tolist(),\n            \'left_text\': tokens[slice_a],\n            \'right_text\': tokens[slice_b]\n        }\n        attn_data[\'ba\'] = {\n            \'attn\': attn[:, :, slice_b, slice_a].tolist(),\n            \'left_text\': tokens[slice_b],\n            \'right_text\': tokens[slice_a]\n        }\n    params = {\n        \'attention\': attn_data,\n        \'default_filter\': ""all""\n    }\n    attn_seq_len = len(attn_data[\'all\'][\'attn\'][0][0])\n    if attn_seq_len != len(tokens):\n        raise ValueError(f""Attention has {attn_seq_len} positions, while number of tokens is {len(tokens)}"")\n    display(Javascript(\'window.params = %s\' % json.dumps(params)))\n    display(Javascript(vis_js))'"
bertviz/neuron_view.py,3,"b'# coding=utf-8\n# Copyright 2018 The Tensor2Tensor Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# Change log\n# 12/12/18  Jesse Vig   Adapted to BERT model\n# 12/19/18  Jesse Vig   Assorted cleanup. Changed orientation of attention matrices. Updated comments.\n\n\n""""""Module for postprocessing and displaying transformer attentions.\n\nThis module is designed to be called from an ipython notebook.\n""""""\n\nimport json\nfrom IPython.core.display import display, HTML, Javascript\nimport os\nimport torch\nfrom collections import defaultdict\n\ndef show(model, model_type, tokenizer, sentence_a, sentence_b=None):\n    if sentence_b:\n        vis_html = """"""\n          <span style=""user-select:none"">\n            Layer: <select id=""layer""></select>\n            Head: <select id=""att_head""></select>\n            Attention: <select id=""filter"">\n              <option value=""all"">All</option>\n              <option value=""aa"">Sentence A -> Sentence A</option>\n              <option value=""ab"">Sentence A -> Sentence B</option>\n              <option value=""ba"">Sentence B -> Sentence A</option>\n              <option value=""bb"">Sentence B -> Sentence B</option>\n            </select>\n          </span>\n          <div id=\'vis\'></div>\n        """"""\n    else:\n        vis_html = """"""\n          <span style=""user-select:none"">\n            Layer: <select id=""layer""></select>\n            Head: <select id=""att_head""></select>\n          </span>\n          <div id=\'vis\'></div>\n        """"""\n    display(HTML(vis_html))\n    __location__ = os.path.realpath(\n        os.path.join(os.getcwd(), os.path.dirname(__file__)))\n    vis_js = open(os.path.join(__location__, \'neuron_view.js\')).read()\n    attn_data = get_attention(model, model_type, tokenizer, sentence_a, sentence_b, include_queries_and_keys=True)\n    if model_type == \'gpt2\':\n        bidirectional = False\n    else:\n        bidirectional = True\n    params = {\n        \'attention\': attn_data,\n        \'default_filter\': ""all"",\n        \'bidirectional\': bidirectional\n    }\n    display(Javascript(\'window.params = %s\' % json.dumps(params)))\n    display(Javascript(vis_js))\n\n\ndef get_attention(model, model_type, tokenizer, sentence_a, sentence_b=None, include_queries_and_keys=False):\n    """"""Compute representation of attention to pass to the d3 visualization\n\n    Args:\n        model: pytorch-transformers model\n        model_type: type of model. Valid values \'bert\', \'gpt2\', \'xlnet\', \'roberta\'\n        tokenizer: pytorch-transformers tokenizer\n        sentence_a: Sentence A string\n        sentence_b: Sentence B string\n        include_queries_and_keys: Indicates whether to include queries/keys in results\n\n    Returns:\n      Dictionary of attn representations with the structure:\n      {\n        \'all\': All attention (source = AB, target = AB)\n        \'aa\': Sentence A self-attention (source = A, target = A) (if sentence_b is not None)\n        \'bb\': Sentence B self-attention (source = B, target = B) (if sentence_b is not None)\n        \'ab\': Sentence A -> Sentence B attention (source = A, target = B) (if sentence_b is not None)\n        \'ba\': Sentence B -> Sentence A attention (source = B, target = A) (if sentence_b is not None)\n      }\n      where each value is a dictionary:\n      {\n        \'left_text\': list of source tokens, to be displayed on the left of the vis\n        \'right_text\': list of target tokens, to be displayed on the right of the vis\n        \'attn\': list of attention matrices, one for each layer. Each has shape [num_heads, source_seq_len, target_seq_len]\n        \'queries\' (optional): list of query vector arrays, one for each layer. Each has shape (num_heads, source_seq_len, vector_size)\n        \'keys\' (optional): list of key vector arrays, one for each layer. Each has shape (num_heads, target_seq_len, vector_size)\n      }\n    """"""\n\n    if model_type not in (\'bert\', \'gpt2\', \'xlnet\', \'roberta\'):\n        raise ValueError(""Invalid model type:"", model_type)\n    if not sentence_a:\n        raise ValueError(""Sentence A is required"")\n    is_sentence_pair = bool(sentence_b)\n    if is_sentence_pair and model_type not in (\'bert\', \'roberta\', \'xlnet\'):\n        raise ValueError(f\'Model {model_type} does not support sentence pairs\')\n    if is_sentence_pair and model_type == \'xlnet\':\n        raise NotImplementedError(""Sentence-pair inputs for XLNet not currently supported."")\n\n    # Prepare inputs to model\n    tokens_a = None\n    tokens_b = None\n    token_type_ids = None\n    if not is_sentence_pair:  # Single sentence\n        if model_type in (\'bert\', \'roberta\'):\n            tokens_a = [tokenizer.cls_token] + tokenizer.tokenize(sentence_a) + [tokenizer.sep_token]\n        elif model_type == \'xlnet\':\n            tokens_a = tokenizer.tokenize(sentence_a) + [tokenizer.sep_token] + [tokenizer.cls_token]\n        else:\n            tokens_a = tokenizer.tokenize(sentence_a)\n    else:\n        if model_type == \'bert\':\n            tokens_a = [tokenizer.cls_token] + tokenizer.tokenize(sentence_a) + [tokenizer.sep_token]\n            tokens_b = tokenizer.tokenize(sentence_b) + [tokenizer.sep_token]\n            token_type_ids = torch.LongTensor([[0] * len(tokens_a) + [1] * len(tokens_b)])\n        elif model_type == \'roberta\':\n            tokens_a = [tokenizer.cls_token] + tokenizer.tokenize(sentence_a) + [tokenizer.sep_token]\n            tokens_b = [tokenizer.sep_token] + tokenizer.tokenize(sentence_b) + [tokenizer.sep_token]\n            # Roberta doesn\'t use token type embeddings per https://github.com/huggingface/pytorch-transformers/blob/master/pytorch_transformers/convert_roberta_checkpoint_to_pytorch.py\n        else:\n            tokens_b = tokenizer.tokenize(sentence_b)\n\n    token_ids = tokenizer.convert_tokens_to_ids(tokens_a + (tokens_b if tokens_b else []))\n    tokens_tensor = torch.tensor(token_ids).unsqueeze(0)\n\n    # Call model to get attention data\n    model.eval()\n    if token_type_ids is not None:\n        output = model(tokens_tensor, token_type_ids=token_type_ids)\n    else:\n        output = model(tokens_tensor)\n    attn_data_list = output[-1]\n\n    # Populate map with attn data and, optionally, query, key data\n    attn_dict = defaultdict(list)\n    if include_queries_and_keys:\n        queries_dict = defaultdict(list)\n        keys_dict = defaultdict(list)\n\n    if is_sentence_pair:\n        slice_a = slice(0, len(tokens_a))  # Positions corresponding to sentence A in input\n        slice_b = slice(len(tokens_a), len(tokens_a) + len(tokens_b))  # Position corresponding to sentence B in input\n    for layer, attn_data in enumerate(attn_data_list):\n        # Process attention\n        attn = attn_data[\'attn\'][0]  # assume batch_size=1; shape = [num_heads, source_seq_len, target_seq_len]\n        attn_dict[\'all\'].append(attn.tolist())\n        if is_sentence_pair:\n            attn_dict[\'aa\'].append(\n                attn[:, slice_a, slice_a].tolist())  # Append A->A attention for layer, across all heads\n            attn_dict[\'bb\'].append(\n                attn[:, slice_b, slice_b].tolist())  # Append B->B attention for layer, across all heads\n            attn_dict[\'ab\'].append(\n                attn[:, slice_a, slice_b].tolist())  # Append A->B attention for layer, across all heads\n            attn_dict[\'ba\'].append(\n                attn[:, slice_b, slice_a].tolist())  # Append B->A attention for layer, across all heads\n        # Process queries and keys\n        if include_queries_and_keys:\n            queries = attn_data[\'queries\'][0]  # assume batch_size=1; shape = [num_heads, seq_len, vector_size]\n            keys = attn_data[\'keys\'][0]  # assume batch_size=1; shape = [num_heads, seq_len, vector_size]\n            queries_dict[\'all\'].append(queries.tolist())\n            keys_dict[\'all\'].append(keys.tolist())\n            if is_sentence_pair:\n                queries_dict[\'a\'].append(queries[:, slice_a, :].tolist())\n                keys_dict[\'a\'].append(keys[:, slice_a, :].tolist())\n                queries_dict[\'b\'].append(queries[:, slice_b, :].tolist())\n                keys_dict[\'b\'].append(keys[:, slice_b, :].tolist())\n\n    tokens_a = format_special_chars(tokens_a)\n    if tokens_b:\n        tokens_b = format_special_chars(tokens_b)\n    if model_type != \'gpt2\':\n        tokens_a = format_delimiters(tokens_a, tokenizer)\n        if tokens_b:\n            tokens_b = format_delimiters(tokens_b, tokenizer)\n\n    results = {\n        \'all\': {\n            \'attn\': attn_dict[\'all\'],\n            \'left_text\': tokens_a + (tokens_b if tokens_b else []),\n            \'right_text\': tokens_a + (tokens_b if tokens_b else [])\n        }\n    }\n    if is_sentence_pair:\n        results.update({\n            \'aa\': {\n                \'attn\': attn_dict[\'aa\'],\n                \'left_text\': tokens_a,\n                \'right_text\': tokens_a\n            },\n            \'bb\': {\n                \'attn\': attn_dict[\'bb\'],\n                \'left_text\': tokens_b,\n                \'right_text\': tokens_b\n            },\n            \'ab\': {\n                \'attn\': attn_dict[\'ab\'],\n                \'left_text\': tokens_a,\n                \'right_text\': tokens_b\n            },\n            \'ba\': {\n                \'attn\': attn_dict[\'ba\'],\n                \'left_text\': tokens_b,\n                \'right_text\': tokens_a\n            }\n        })\n    if include_queries_and_keys:\n        results[\'all\'].update({\n            \'queries\': queries_dict[\'all\'],\n            \'keys\': keys_dict[\'all\'],\n        })\n        if is_sentence_pair:\n            results[\'aa\'].update({\n                \'queries\': queries_dict[\'a\'],\n                \'keys\': keys_dict[\'a\'],\n            })\n            results[\'bb\'].update({\n                \'queries\': queries_dict[\'b\'],\n                \'keys\': keys_dict[\'b\'],\n            })\n            results[\'ab\'].update({\n                \'queries\': queries_dict[\'a\'],\n                \'keys\': keys_dict[\'b\'],\n            })\n            results[\'ba\'].update({\n                \'queries\': queries_dict[\'b\'],\n                \'keys\': keys_dict[\'a\'],\n            })\n    return results\n\n\ndef format_special_chars(tokens):\n    return [t.replace(\'\xc4\xa0\', \' \').replace(\'\xe2\x96\x81\', \' \') for t in tokens]\n\n\ndef format_delimiters(tokens, tokenizer):\n    formatted_tokens = []\n    for t in tokens:\n        if tokenizer.sep_token:\n            t = t.replace(tokenizer.sep_token, \'[SEP]\')\n        if tokenizer.cls_token:\n            t = t.replace(tokenizer.cls_token, \'[CLS]\')\n        formatted_tokens.append(t)\n    return formatted_tokens\n'"
bertviz/util.py,1,"b'import torch\n\ndef format_attention(attention):\n    squeezed = []\n    for layer_attention in attention:\n        # 1 x num_heads x seq_len x seq_len\n        if len(layer_attention.shape) != 4:\n            raise ValueError(""The attention tensor does not have the correct number of dimensions. Make sure you set ""\n                             ""output_attentions=True when initializing your model."")\n        squeezed.append(layer_attention.squeeze(0))\n    # num_layers x num_heads x seq_len x seq_len\n    return torch.stack(squeezed)\n\ndef format_special_chars(tokens):\n    return [t.replace(\'\xc4\xa0\', \' \').replace(\'\xe2\x96\x81\', \' \').replace(\'</w>\', \'\') for t in tokens]\n'"
bertviz/tests/test_attention.py,30,"b'from bertviz.neuron_view import get_attention\nfrom bertviz.transformers_neuron_view import BertTokenizer, BertModel, BertConfig, GPT2Model, GPT2Tokenizer, \\\n    XLNetModel, XLNetTokenizer, BertForSequenceClassification, BertForQuestionAnswering, RobertaModel, RobertaTokenizer\n\nimport unittest\nimport torch\nimport os\n\nclass TestAttention(unittest.TestCase):\n\n    def setUp(self):\n        do_tests = os.environ.get(\'BERTVIZ_DO_TESTS\')\n        if not do_tests == \'true\':\n            print(\'You must set environmental variable BERTVIZ_DO_TESTS to ""true"" in order to perform unit tests. (The tests consume a large amount of disk space.)\')\n            quit()\n\n    def test_bert_attn(self):\n        config = BertConfig.from_json_file(\'fixtures/config.json\')\n        tokenizer = BertTokenizer(\'fixtures/vocab.txt\')\n        for model_class in (BertModel, BertForSequenceClassification, BertForQuestionAnswering):\n            model = model_class(config)\n            sentence1 = \'The quickest brown fox jumped over the lazy dog\'\n            sentence2 = ""the quick brown fox jumped over the laziest elmo""\n            attn_data = get_attention(model, \'bert\', tokenizer, sentence1, sentence2,\n                                           include_queries_and_keys=False)\n            tokens_1 = [\'[CLS]\', \'the\', \'quick\', \'##est\', \'brown\', \'fox\', \'jumped\', \'over\', \'the\', \'lazy\', \'dog\',\n                        \'[SEP]\']\n            tokens_2 = [\'the\', \'quick\', \'brown\', \'fox\', \'jumped\', \'over\', \'the\', \'la\', \'##zie\', \'##st\', \'[UNK]\',\n                        \'[SEP]\']\n            self.assertEqual(attn_data[\'all\'][\'left_text\'], tokens_1 + tokens_2)\n            self.assertEqual(attn_data[\'all\'][\'right_text\'], tokens_1 + tokens_2)\n            self.assertEqual(attn_data[\'aa\'][\'left_text\'], tokens_1)\n            self.assertEqual(attn_data[\'aa\'][\'right_text\'], tokens_1)\n            self.assertEqual(attn_data[\'ab\'][\'left_text\'], tokens_1)\n            self.assertEqual(attn_data[\'ab\'][\'right_text\'], tokens_2)\n            self.assertEqual(attn_data[\'ba\'][\'left_text\'], tokens_2)\n            self.assertEqual(attn_data[\'ba\'][\'right_text\'], tokens_1)\n            self.assertEqual(attn_data[\'bb\'][\'left_text\'], tokens_2)\n            self.assertEqual(attn_data[\'bb\'][\'right_text\'], tokens_2)\n\n            attn_all = attn_data[\'all\'][\'attn\']\n            attn_aa = attn_data[\'aa\'][\'attn\']\n            attn_ab = attn_data[\'ab\'][\'attn\']\n            attn_ba = attn_data[\'ba\'][\'attn\']\n            attn_bb = attn_data[\'bb\'][\'attn\']\n            num_layers = len(attn_all)\n            for layer in range(num_layers):\n                attn_all_layer = torch.tensor(attn_all[layer])\n                num_heads, seq_len, _ = attn_all_layer.size()\n                # Check that probabilities sum to one\n                sum_probs = attn_all_layer.sum(dim=-1)\n                expected = torch.ones(num_heads, seq_len, dtype=torch.float32)\n                self.assertTrue(torch.allclose(sum_probs, expected))\n                # Reassemble attention from components and verify is correct\n                attn_aa_layer = torch.tensor(attn_aa[layer])\n                attn_ab_layer = torch.tensor(attn_ab[layer])\n                attn_ba_layer = torch.tensor(attn_ba[layer])\n                attn_bb_layer = torch.tensor(attn_bb[layer])\n                top_half = torch.cat((attn_aa_layer, attn_ab_layer), dim=-1)\n                bottom_half = torch.cat((attn_ba_layer, attn_bb_layer), dim=-1)\n                whole = torch.cat((top_half, bottom_half), dim=-2)\n                # assert self.assertAlmostEqual(torch.sum(torch.abs(whole - attn_all[layer])), 0)\n                self.assertTrue(torch.allclose(whole, attn_all_layer))\n        for model_class in (BertModel, BertForSequenceClassification, BertForQuestionAnswering):\n            model = model_class(config)\n            sentence1 = \'The quickest brown fox jumped over the lazy dog\'\n            sentence2 = None\n            attn_data = get_attention(model, \'bert\', tokenizer, sentence1, sentence2,\n                                           include_queries_and_keys=False)\n            tokens_1 = [\'[CLS]\', \'the\', \'quick\', \'##est\', \'brown\', \'fox\', \'jumped\', \'over\', \'the\', \'lazy\', \'dog\',\n                        \'[SEP]\']\n            tokens_2 = []\n            self.assertEqual(attn_data[\'all\'][\'left_text\'], tokens_1 + tokens_2)\n            self.assertEqual(attn_data[\'all\'][\'right_text\'], tokens_1 + tokens_2)\n            self.assertTrue(\'aa\' not in attn_data)\n\n            attn_all = attn_data[\'all\'][\'attn\']\n            num_layers = len(attn_all)\n            for layer in range(num_layers):\n                attn_all_layer = torch.tensor(attn_all[layer])\n                num_heads, seq_len, _ = attn_all_layer.size()\n                # Check that probabilities sum to one\n                sum_probs = attn_all_layer.sum(dim=-1)\n                expected = torch.ones(num_heads, seq_len, dtype=torch.float32)\n                self.assertTrue(torch.allclose(sum_probs, expected))\n\n    def test_roberta_attn(self):\n        model = RobertaModel.from_pretrained(\'roberta-base\')\n        tokenizer = RobertaTokenizer.from_pretrained(\'roberta-base\')\n        sentence1 = \'The quickest brown fox jumped over the lazy dog\'\n        sentence2 = ""the quick brown fox jumped over the laziest dog""\n        attn_data = get_attention(model, \'roberta\', tokenizer, sentence1, sentence2,\n                                       include_queries_and_keys=False)\n        tokens_1 = [\'[CLS]\', \'The\', \' quickest\', \' brown\', \' fox\', \' jumped\', \' over\', \' the\', \' lazy\', \' dog\',\n                    \'[SEP]\']\n        tokens_2 = [\'[SEP]\', \'the\', \' quick\', \' brown\', \' fox\', \' jumped\', \' over\', \' the\', \' laz\', \'iest\', \' dog\',\n                    \'[SEP]\']\n        self.assertEqual(attn_data[\'all\'][\'left_text\'], tokens_1 + tokens_2)\n        self.assertEqual(attn_data[\'all\'][\'right_text\'], tokens_1 + tokens_2)\n        self.assertEqual(attn_data[\'aa\'][\'left_text\'], tokens_1)\n        self.assertEqual(attn_data[\'aa\'][\'right_text\'], tokens_1)\n        self.assertEqual(attn_data[\'ab\'][\'left_text\'], tokens_1)\n        self.assertEqual(attn_data[\'ab\'][\'right_text\'], tokens_2)\n        self.assertEqual(attn_data[\'ba\'][\'left_text\'], tokens_2)\n        self.assertEqual(attn_data[\'ba\'][\'right_text\'], tokens_1)\n        self.assertEqual(attn_data[\'bb\'][\'left_text\'], tokens_2)\n        self.assertEqual(attn_data[\'bb\'][\'right_text\'], tokens_2)\n\n        attn_all = attn_data[\'all\'][\'attn\']\n        attn_aa = attn_data[\'aa\'][\'attn\']\n        attn_ab = attn_data[\'ab\'][\'attn\']\n        attn_ba = attn_data[\'ba\'][\'attn\']\n        attn_bb = attn_data[\'bb\'][\'attn\']\n        num_layers = len(attn_all)\n        for layer in range(num_layers):\n            attn_all_layer = torch.tensor(attn_all[layer])\n            num_heads, seq_len, _ = attn_all_layer.size()\n            # Check that probabilities sum to one\n            sum_probs = attn_all_layer.sum(dim=-1)\n            expected = torch.ones(num_heads, seq_len, dtype=torch.float32)\n            self.assertTrue(torch.allclose(sum_probs, expected))\n            # Reassemble attention from components and verify is correct\n            attn_aa_layer = torch.tensor(attn_aa[layer])\n            attn_ab_layer = torch.tensor(attn_ab[layer])\n            attn_ba_layer = torch.tensor(attn_ba[layer])\n            attn_bb_layer = torch.tensor(attn_bb[layer])\n            top_half = torch.cat((attn_aa_layer, attn_ab_layer), dim=-1)\n            bottom_half = torch.cat((attn_ba_layer, attn_bb_layer), dim=-1)\n            whole = torch.cat((top_half, bottom_half), dim=-2)\n            # assert self.assertAlmostEqual(torch.sum(torch.abs(whole - attn_all[layer])), 0)\n            self.assertTrue(torch.allclose(whole, attn_all_layer))\n\n        sentence1 = \'The quickest brown fox jumped over the lazy dog\'\n        sentence2 = None\n        attn_data = get_attention(model, \'roberta\', tokenizer, sentence1, sentence2,\n                                       include_queries_and_keys=False)\n        tokens_1 = [\'[CLS]\', \'The\', \' quickest\', \' brown\', \' fox\', \' jumped\', \' over\', \' the\', \' lazy\', \' dog\',\n                    \'[SEP]\']\n        tokens_2 = []\n        self.assertEqual(attn_data[\'all\'][\'left_text\'], tokens_1 + tokens_2)\n        self.assertEqual(attn_data[\'all\'][\'right_text\'], tokens_1 + tokens_2)\n        self.assertTrue(\'aa\' not in attn_data)\n\n        attn_all = attn_data[\'all\'][\'attn\']\n        num_layers = len(attn_all)\n        for layer in range(num_layers):\n            attn_all_layer = torch.tensor(attn_all[layer])\n            num_heads, seq_len, _ = attn_all_layer.size()\n            # Check that probabilities sum to one\n            sum_probs = attn_all_layer.sum(dim=-1)\n            expected = torch.ones(num_heads, seq_len, dtype=torch.float32)\n            self.assertTrue(torch.allclose(sum_probs, expected))\n\n    def test_gpt2_attn(self):\n        model = GPT2Model.from_pretrained(\'gpt2\')\n        tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n        text = \'Bert is a yellow muppet character\'\n        attn_data = get_attention(model, \'gpt2\', tokenizer, text, include_queries_and_keys=False)[\'all\']\n        tokens = [\'B\', \'ert\', \' is\', \' a\', \' yellow\', \' m\', \'uppet\', \' character\']\n        self.assertEqual(attn_data[\'left_text\'], tokens)\n        self.assertEqual(attn_data[\'right_text\'], tokens)\n        seq_len = len(tokens)\n        layer = 0\n        head = 0\n        att_matrix = attn_data[\'attn\'][layer][head]\n        for i in range(seq_len):\n            for j in range(seq_len):\n                if i >= j:\n                    self.assertNotEqual(att_matrix[i][j], 0)\n                else:\n                    self.assertEqual(att_matrix[i][j], 0)\n            sum_probs = sum(att_matrix[i])\n            self.assertAlmostEqual(sum_probs, 1, 4)\n\n    def test_xlnet_attn(self):\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLNetModel.from_pretrained(\'xlnet-large-cased\')\n        text = \'Bert is a yellow muppet character\'\n        attn_data = get_attention(model, \'xlnet\', tokenizer, text, include_queries_and_keys=False)[\'all\']\n        tokens = [\' Bert\', \' is\', \' a\', \' yellow\', \' \', \'m\', \'up\', \'pet\', \' character\', \'[SEP]\', \'[CLS]\']\n        self.assertEqual(attn_data[\'left_text\'], tokens)\n        self.assertEqual(attn_data[\'right_text\'], tokens)\n        seq_len = len(tokens)\n        layer = 0\n        head = 0\n        att_matrix = attn_data[\'attn\'][layer][head]\n        for i in range(seq_len):\n            sum_probs = sum(att_matrix[i])\n            self.assertAlmostEqual(sum_probs, 1, 4)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
bertviz/transformers_neuron_view/__init__.py,0,"b'__version__ = ""1.1.0""\nfrom .tokenization_bert import BertTokenizer, BasicTokenizer, WordpieceTokenizer\nfrom .tokenization_openai import OpenAIGPTTokenizer\nfrom .tokenization_transfo_xl import (TransfoXLTokenizer, TransfoXLCorpus)\nfrom .tokenization_gpt2 import GPT2Tokenizer\nfrom .tokenization_xlnet import XLNetTokenizer, SPIECE_UNDERLINE\nfrom .tokenization_xlm import XLMTokenizer\nfrom .tokenization_roberta import RobertaTokenizer\n\nfrom .tokenization_utils import (PreTrainedTokenizer)\n\nfrom .modeling_bert import (BertConfig, BertPreTrainedModel, BertModel, BertForPreTraining,\n                            BertForMaskedLM, BertForNextSentencePrediction,\n                            BertForSequenceClassification, BertForMultipleChoice,\n                            BertForTokenClassification, BertForQuestionAnswering,\n                            load_tf_weights_in_bert, BERT_PRETRAINED_MODEL_ARCHIVE_MAP,\n                            BERT_PRETRAINED_CONFIG_ARCHIVE_MAP)\nfrom .modeling_openai import (OpenAIGPTConfig, OpenAIGPTPreTrainedModel, OpenAIGPTModel,\n                              OpenAIGPTLMHeadModel, OpenAIGPTDoubleHeadsModel,\n                              load_tf_weights_in_openai_gpt, OPENAI_GPT_PRETRAINED_CONFIG_ARCHIVE_MAP,\n                              OPENAI_GPT_PRETRAINED_MODEL_ARCHIVE_MAP)\nfrom .modeling_transfo_xl import (TransfoXLConfig, TransfoXLModel, TransfoXLLMHeadModel,\n                                  load_tf_weights_in_transfo_xl, TRANSFO_XL_PRETRAINED_CONFIG_ARCHIVE_MAP,\n                                  TRANSFO_XL_PRETRAINED_MODEL_ARCHIVE_MAP)\nfrom .modeling_gpt2 import (GPT2Config, GPT2PreTrainedModel, GPT2Model,\n                            GPT2LMHeadModel, GPT2DoubleHeadsModel,\n                            load_tf_weights_in_gpt2, GPT2_PRETRAINED_CONFIG_ARCHIVE_MAP,\n                            GPT2_PRETRAINED_MODEL_ARCHIVE_MAP)\nfrom .modeling_xlnet import (XLNetConfig,\n                             XLNetPreTrainedModel, XLNetModel, XLNetLMHeadModel,\n                             XLNetForSequenceClassification, XLNetForQuestionAnswering,\n                             load_tf_weights_in_xlnet, XLNET_PRETRAINED_CONFIG_ARCHIVE_MAP,\n                             XLNET_PRETRAINED_MODEL_ARCHIVE_MAP)\nfrom .modeling_xlm import (XLMConfig, XLMPreTrainedModel , XLMModel,\n                           XLMWithLMHeadModel, XLMForSequenceClassification,\n                           XLMForQuestionAnswering, XLM_PRETRAINED_CONFIG_ARCHIVE_MAP,\n                           XLM_PRETRAINED_MODEL_ARCHIVE_MAP)\nfrom .modeling_roberta import (RobertaConfig, RobertaForMaskedLM, RobertaModel, RobertaForSequenceClassification,\n                               ROBERTA_PRETRAINED_CONFIG_ARCHIVE_MAP, ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP)\nfrom .modeling_utils import (WEIGHTS_NAME, CONFIG_NAME, TF_WEIGHTS_NAME,\n                          PretrainedConfig, PreTrainedModel, prune_layer, Conv1D)\n\n# from .optimization import (AdamW, ConstantLRSchedule, WarmupConstantSchedule, WarmupCosineSchedule,\n#                            WarmupCosineWithHardRestartsSchedule, WarmupLinearSchedule)\n\nfrom .file_utils import (PYTORCH_TRANSFORMERS_CACHE, PYTORCH_PRETRAINED_BERT_CACHE, cached_path)\n'"
bertviz/transformers_neuron_view/file_utils.py,1,"b'""""""\nUtilities for working with the local dataset cache.\nThis file is adapted from the AllenNLP library at https://github.com/allenai/allennlp\nCopyright by the AllenNLP authors.\n""""""\nfrom __future__ import (absolute_import, division, print_function, unicode_literals)\n\nimport sys\nimport json\nimport logging\nimport os\nimport shutil\nimport tempfile\nimport fnmatch\nfrom functools import wraps\nfrom hashlib import sha256\nfrom io import open\n\nimport boto3\nimport requests\nfrom botocore.exceptions import ClientError\nfrom tqdm import tqdm\n\ntry:\n    from torch.hub import _get_torch_home\n    torch_cache_home = _get_torch_home()\nexcept ImportError:\n    torch_cache_home = os.path.expanduser(\n        os.getenv(\'TORCH_HOME\', os.path.join(\n            os.getenv(\'XDG_CACHE_HOME\', \'~/.cache\'), \'torch\')))\ndefault_cache_path = os.path.join(torch_cache_home, \'pytorch_transformers\')\n\ntry:\n    from urllib.parse import urlparse\nexcept ImportError:\n    from urlparse import urlparse\n\ntry:\n    from pathlib import Path\n    PYTORCH_PRETRAINED_BERT_CACHE = Path(\n        os.getenv(\'PYTORCH_TRANSFORMERS_CACHE\', os.getenv(\'PYTORCH_PRETRAINED_BERT_CACHE\', default_cache_path)))\nexcept (AttributeError, ImportError):\n    PYTORCH_PRETRAINED_BERT_CACHE = os.getenv(\'PYTORCH_TRANSFORMERS_CACHE\',\n                                              os.getenv(\'PYTORCH_PRETRAINED_BERT_CACHE\',\n                                                        default_cache_path))\n\nPYTORCH_TRANSFORMERS_CACHE = PYTORCH_PRETRAINED_BERT_CACHE  # Kept for backward compatibility\n\nlogger = logging.getLogger(__name__)  # pylint: disable=invalid-name\n\n\ndef url_to_filename(url, etag=None):\n    """"""\n    Convert `url` into a hashed filename in a repeatable way.\n    If `etag` is specified, append its hash to the url\'s, delimited\n    by a period.\n    """"""\n    url_bytes = url.encode(\'utf-8\')\n    url_hash = sha256(url_bytes)\n    filename = url_hash.hexdigest()\n\n    if etag:\n        etag_bytes = etag.encode(\'utf-8\')\n        etag_hash = sha256(etag_bytes)\n        filename += \'.\' + etag_hash.hexdigest()\n\n    return filename\n\n\ndef filename_to_url(filename, cache_dir=None):\n    """"""\n    Return the url and etag (which may be ``None``) stored for `filename`.\n    Raise ``EnvironmentError`` if `filename` or its stored metadata do not exist.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    cache_path = os.path.join(cache_dir, filename)\n    if not os.path.exists(cache_path):\n        raise EnvironmentError(""file {} not found"".format(cache_path))\n\n    meta_path = cache_path + \'.json\'\n    if not os.path.exists(meta_path):\n        raise EnvironmentError(""file {} not found"".format(meta_path))\n\n    with open(meta_path, encoding=""utf-8"") as meta_file:\n        metadata = json.load(meta_file)\n    url = metadata[\'url\']\n    etag = metadata[\'etag\']\n\n    return url, etag\n\n\ndef cached_path(url_or_filename, cache_dir=None):\n    """"""\n    Given something that might be a URL (or might be a local path),\n    determine which. If it\'s a URL, download the file and cache it, and\n    return the path to the cached file. If it\'s already a local path,\n    make sure the file exists and then return the path.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(url_or_filename, Path):\n        url_or_filename = str(url_or_filename)\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    parsed = urlparse(url_or_filename)\n\n    if parsed.scheme in (\'http\', \'https\', \'s3\'):\n        # URL, so get it from the cache (downloading if necessary)\n        return get_from_cache(url_or_filename, cache_dir)\n    elif os.path.exists(url_or_filename):\n        # File, and it exists.\n        return url_or_filename\n    elif parsed.scheme == \'\':\n        # File, but it doesn\'t exist.\n        raise EnvironmentError(""file {} not found"".format(url_or_filename))\n    else:\n        # Something unknown\n        raise ValueError(""unable to parse {} as a URL or as a local path"".format(url_or_filename))\n\n\ndef split_s3_path(url):\n    """"""Split a full s3 path into the bucket name and path.""""""\n    parsed = urlparse(url)\n    if not parsed.netloc or not parsed.path:\n        raise ValueError(""bad s3 path {}"".format(url))\n    bucket_name = parsed.netloc\n    s3_path = parsed.path\n    # Remove \'/\' at beginning of path.\n    if s3_path.startswith(""/""):\n        s3_path = s3_path[1:]\n    return bucket_name, s3_path\n\n\ndef s3_request(func):\n    """"""\n    Wrapper function for s3 requests in order to create more helpful error\n    messages.\n    """"""\n\n    @wraps(func)\n    def wrapper(url, *args, **kwargs):\n        try:\n            return func(url, *args, **kwargs)\n        except ClientError as exc:\n            if int(exc.response[""Error""][""Code""]) == 404:\n                raise EnvironmentError(""file {} not found"".format(url))\n            else:\n                raise\n\n    return wrapper\n\n\n@s3_request\ndef s3_etag(url):\n    """"""Check ETag on S3 object.""""""\n    s3_resource = boto3.resource(""s3"")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_object = s3_resource.Object(bucket_name, s3_path)\n    return s3_object.e_tag\n\n\n@s3_request\ndef s3_get(url, temp_file):\n    """"""Pull a file directly from S3.""""""\n    s3_resource = boto3.resource(""s3"")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)\n\n\ndef http_get(url, temp_file):\n    req = requests.get(url, stream=True)\n    content_length = req.headers.get(\'Content-Length\')\n    total = int(content_length) if content_length is not None else None\n    progress = tqdm(unit=""B"", total=total)\n    for chunk in req.iter_content(chunk_size=1024):\n        if chunk: # filter out keep-alive new chunks\n            progress.update(len(chunk))\n            temp_file.write(chunk)\n    progress.close()\n\n\ndef get_from_cache(url, cache_dir=None):\n    """"""\n    Given a URL, look for the corresponding dataset in the local cache.\n    If it\'s not there, download it. Then return the path to the cached file.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n    if sys.version_info[0] == 2 and not isinstance(cache_dir, str):\n        cache_dir = str(cache_dir)\n\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    # Get eTag to add to filename, if it exists.\n    if url.startswith(""s3://""):\n        etag = s3_etag(url)\n    else:\n        try:\n            response = requests.head(url, allow_redirects=True)\n            if response.status_code != 200:\n                etag = None\n            else:\n                etag = response.headers.get(""ETag"")\n        except EnvironmentError:\n            etag = None\n\n    if sys.version_info[0] == 2 and etag is not None:\n        etag = etag.decode(\'utf-8\')\n    filename = url_to_filename(url, etag)\n\n    # get cache path to put the file\n    cache_path = os.path.join(cache_dir, filename)\n\n    # If we don\'t have a connection (etag is None) and can\'t identify the file\n    # try to get the last downloaded one\n    if not os.path.exists(cache_path) and etag is None:\n        matching_files = fnmatch.filter(os.listdir(cache_dir), filename + \'.*\')\n        matching_files = list(filter(lambda s: not s.endswith(\'.json\'), matching_files))\n        if matching_files:\n            cache_path = os.path.join(cache_dir, matching_files[-1])\n\n    if not os.path.exists(cache_path):\n        # Download to temporary file, then copy to cache dir once finished.\n        # Otherwise you get corrupt cache entries if the download gets interrupted.\n        with tempfile.NamedTemporaryFile() as temp_file:\n            logger.info(""%s not found in cache, downloading to %s"", url, temp_file.name)\n\n            # GET file object\n            if url.startswith(""s3://""):\n                s3_get(url, temp_file)\n            else:\n                http_get(url, temp_file)\n\n            # we are copying the file before closing it, so flush to avoid truncation\n            temp_file.flush()\n            # shutil.copyfileobj() starts at the current position, so go to the start\n            temp_file.seek(0)\n\n            logger.info(""copying %s to cache at %s"", temp_file.name, cache_path)\n            with open(cache_path, \'wb\') as cache_file:\n                shutil.copyfileobj(temp_file, cache_file)\n\n            logger.info(""creating metadata file for %s"", cache_path)\n            meta = {\'url\': url, \'etag\': etag}\n            meta_path = cache_path + \'.json\'\n            with open(meta_path, \'w\') as meta_file:\n                output_string = json.dumps(meta)\n                if sys.version_info[0] == 2 and isinstance(output_string, str):\n                    output_string = unicode(output_string, \'utf-8\')  # The beauty of python 2\n                meta_file.write(output_string)\n\n            logger.info(""removing temp file %s"", temp_file.name)\n\n    return cache_path\n'"
bertviz/transformers_neuron_view/modeling_bert.py,86,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# Change log\n# 7/14/19  Jesse Vig   Adapted for use in visualization\n\n\n""""""PyTorch BERT model.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_utils import (WEIGHTS_NAME, CONFIG_NAME, PretrainedConfig, PreTrainedModel,\n                             prune_linear_layer, add_start_docstrings)\n\nlogger = logging.getLogger(__name__)\n\nBERT_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-pytorch_model.bin"",\n    \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-pytorch_model.bin"",\n    \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-pytorch_model.bin"",\n    \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-pytorch_model.bin"",\n    \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-pytorch_model.bin"",\n    \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-pytorch_model.bin"",\n    \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-pytorch_model.bin"",\n    \'bert-base-german-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-cased-pytorch_model.bin"",\n    \'bert-large-uncased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-pytorch_model.bin"",\n    \'bert-large-cased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-pytorch_model.bin"",\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-finetuned-squad-pytorch_model.bin"",\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-finetuned-squad-pytorch_model.bin"",\n    \'bert-base-cased-finetuned-mrpc\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-finetuned-mrpc-pytorch_model.bin"",\n}\n\nBERT_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-config.json"",\n    \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-config.json"",\n    \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-config.json"",\n    \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-config.json"",\n    \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-config.json"",\n    \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-config.json"",\n    \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-config.json"",\n    \'bert-base-german-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-cased-config.json"",\n    \'bert-large-uncased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-config.json"",\n    \'bert-large-cased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-config.json"",\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-finetuned-squad-config.json"",\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-finetuned-squad-config.json"",\n    \'bert-base-cased-finetuned-mrpc\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-finetuned-mrpc-config.json"",\n}\n\n\ndef load_tf_weights_in_bert(model, config, tf_checkpoint_path):\n    """""" Load tf checkpoints in a pytorch model.\n    """"""\n    try:\n        import re\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    tf_path = os.path.abspath(tf_checkpoint_path)\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array)\n\n    for name, array in zip(names, arrays):\n        name = name.split(\'/\')\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if any(n in [""adam_v"", ""adam_m"", ""global_step""] for n in name):\n            logger.info(""Skipping {}"".format(""/"".join(name)))\n            continue\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+_\\d+\', m_name):\n                l = re.split(r\'_(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'kernel\' or l[0] == \'gamma\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'output_bias\' or l[0] == \'beta\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'output_weights\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'squad\':\n                pointer = getattr(pointer, \'classifier\')\n            else:\n                try:\n                    pointer = getattr(pointer, l[0])\n                except AttributeError:\n                    logger.info(""Skipping {}"".format(""/"".join(name)))\n                    continue\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        if m_name[-11:] == \'_embeddings\':\n            pointer = getattr(pointer, \'weight\')\n        elif m_name == \'kernel\':\n            array = np.transpose(array)\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\n\ndef gelu(x):\n    """"""Implementation of the gelu activation function.\n        For information: OpenAI GPT\'s gelu is slightly different (and gives slightly different results):\n        0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    return x * 0.5 * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT2FN = {""gelu"": gelu, ""relu"": torch.nn.functional.relu, ""swish"": swish}\n\n\nclass BertConfig(PretrainedConfig):\n    r""""""\n        :class:`~pytorch_transformers.BertConfig` is the configuration class to store the configuration of a\n        `BertModel`.\n\n\n        Arguments:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `BertModel`.\n            hidden_size: Size of the encoder layers and the pooler layer.\n            num_hidden_layers: Number of hidden layers in the Transformer encoder.\n            num_attention_heads: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n                layer in the Transformer encoder.\n            hidden_act: The non-linear activation function (function or string) in the\n                encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n            hidden_dropout_prob: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attention_probs_dropout_prob: The dropout ratio for the attention\n                probabilities.\n            max_position_embeddings: The maximum sequence length that this model might\n                ever be used with. Typically set this to something large just in case\n                (e.g., 512 or 1024 or 2048).\n            type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n                `BertModel`.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n            layer_norm_eps: The epsilon used by LayerNorm.\n    """"""\n    pretrained_config_archive_map = BERT_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=30522,\n                 hidden_size=768,\n                 num_hidden_layers=12,\n                 num_attention_heads=12,\n                 intermediate_size=3072,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=2,\n                 initializer_range=0.02,\n                 layer_norm_eps=1e-12,\n                 **kwargs):\n        super(BertConfig, self).__init__(**kwargs)\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.hidden_size = hidden_size\n            self.num_hidden_layers = num_hidden_layers\n            self.num_attention_heads = num_attention_heads\n            self.hidden_act = hidden_act\n            self.intermediate_size = intermediate_size\n            self.hidden_dropout_prob = hidden_dropout_prob\n            self.attention_probs_dropout_prob = attention_probs_dropout_prob\n            self.max_position_embeddings = max_position_embeddings\n            self.type_vocab_size = type_vocab_size\n            self.initializer_range = initializer_range\n            self.layer_norm_eps = layer_norm_eps\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             ""or the path to a pretrained model config file (str)"")\n\n\n\ntry:\n    from apex.normalization.fused_layer_norm import FusedLayerNorm as BertLayerNorm\nexcept (ImportError, AttributeError) as e:\n    logger.info(""Better speed can be achieved with apex installed from https://www.github.com/nvidia/apex ."")\n    class BertLayerNorm(nn.Module):\n        def __init__(self, hidden_size, eps=1e-12):\n            """"""Construct a layernorm module in the TF style (epsilon inside the square root).\n            """"""\n            super(BertLayerNorm, self).__init__()\n            self.weight = nn.Parameter(torch.ones(hidden_size))\n            self.bias = nn.Parameter(torch.zeros(hidden_size))\n            self.variance_epsilon = eps\n\n        def forward(self, x):\n            u = x.mean(-1, keepdim=True)\n            s = (x - u).pow(2).mean(-1, keepdim=True)\n            x = (x - u) / torch.sqrt(s + self.variance_epsilon)\n            return self.weight * x + self.bias\n\nclass BertEmbeddings(nn.Module):\n    """"""Construct the embeddings from word, position and token_type embeddings.\n    """"""\n    def __init__(self, config):\n        super(BertEmbeddings, self).__init__()\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=0)\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)\n\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\n        # any TensorFlow checkpoint file\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        words_embeddings = self.word_embeddings(input_ids)\n        position_embeddings = self.position_embeddings(position_ids)\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\n\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\n        embeddings = self.LayerNorm(embeddings)\n        embeddings = self.dropout(embeddings)\n        return embeddings\n\n\nclass BertSelfAttention(nn.Module):\n    def __init__(self, config):\n        super(BertSelfAttention, self).__init__()\n        if config.hidden_size % config.num_attention_heads != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.hidden_size, config.num_attention_heads))\n        self.output_attentions = config.output_attentions\n\n        self.num_attention_heads = config.num_attention_heads\n        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)\n        self.all_head_size = self.num_attention_heads * self.attention_head_size\n\n        self.query = nn.Linear(config.hidden_size, self.all_head_size)\n        self.key = nn.Linear(config.hidden_size, self.all_head_size)\n        self.value = nn.Linear(config.hidden_size, self.all_head_size)\n\n        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)\n\n    def transpose_for_scores(self, x):\n        new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size)\n        x = x.view(*new_x_shape)\n        return x.permute(0, 2, 1, 3)\n\n    def forward(self, hidden_states, attention_mask, head_mask=None):\n        mixed_query_layer = self.query(hidden_states)\n        mixed_key_layer = self.key(hidden_states)\n        mixed_value_layer = self.value(hidden_states)\n\n        query_layer = self.transpose_for_scores(mixed_query_layer)\n        key_layer = self.transpose_for_scores(mixed_key_layer)\n        value_layer = self.transpose_for_scores(mixed_value_layer)\n\n        # Take the dot product between ""query"" and ""key"" to get the raw attention scores.\n        attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))\n        attention_scores = attention_scores / math.sqrt(self.attention_head_size)\n        # Apply the attention mask is (precomputed for all layers in BertModel forward() function)\n        attention_scores = attention_scores + attention_mask\n\n        # Normalize the attention scores to probabilities.\n        attention_probs = nn.Softmax(dim=-1)(attention_scores)\n\n        # This is actually dropping out entire tokens to attend to, which might\n        # seem a bit unusual, but is taken from the original Transformer paper.\n        attention_probs = self.dropout(attention_probs)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attention_probs = attention_probs * head_mask\n\n        context_layer = torch.matmul(attention_probs, value_layer)\n\n        context_layer = context_layer.permute(0, 2, 1, 3).contiguous()\n        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)\n        context_layer = context_layer.view(*new_context_layer_shape)\n\n        if self.output_attentions:\n            attn_data = {\n                \'attn\': attention_probs,\n                \'queries\': query_layer,\n                \'keys\': key_layer\n            }\n            outputs = (context_layer, attn_data)\n        else:\n            outputs = (context_layer,)\n        return outputs\n\n\nclass BertSelfOutput(nn.Module):\n    def __init__(self, config):\n        super(BertSelfOutput, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertAttention(nn.Module):\n    def __init__(self, config):\n        super(BertAttention, self).__init__()\n        self.self = BertSelfAttention(config)\n        self.output = BertSelfOutput(config)\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.self.num_attention_heads, self.self.attention_head_size)\n        for head in heads:\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        # Prune linear layers\n        self.self.query = prune_linear_layer(self.self.query, index)\n        self.self.key = prune_linear_layer(self.self.key, index)\n        self.self.value = prune_linear_layer(self.self.value, index)\n        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)\n        # Update hyper params\n        self.self.num_attention_heads = self.self.num_attention_heads - len(heads)\n        self.self.all_head_size = self.self.attention_head_size * self.self.num_attention_heads\n\n    def forward(self, input_tensor, attention_mask, head_mask=None):\n        self_outputs = self.self(input_tensor, attention_mask, head_mask)\n        attention_output = self.output(self_outputs[0], input_tensor)\n        outputs = (attention_output,) + self_outputs[1:]  # add attentions if we output them\n        return outputs\n\n\nclass BertIntermediate(nn.Module):\n    def __init__(self, config):\n        super(BertIntermediate, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.intermediate_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.intermediate_act_fn = config.hidden_act\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.intermediate_act_fn(hidden_states)\n        return hidden_states\n\n\nclass BertOutput(nn.Module):\n    def __init__(self, config):\n        super(BertOutput, self).__init__()\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertLayer(nn.Module):\n    def __init__(self, config):\n        super(BertLayer, self).__init__()\n        self.attention = BertAttention(config)\n        self.intermediate = BertIntermediate(config)\n        self.output = BertOutput(config)\n\n    def forward(self, hidden_states, attention_mask, head_mask=None):\n        attention_outputs = self.attention(hidden_states, attention_mask, head_mask)\n        attention_output = attention_outputs[0]\n        intermediate_output = self.intermediate(attention_output)\n        layer_output = self.output(intermediate_output, attention_output)\n        outputs = (layer_output,) + attention_outputs[1:]  # add attentions if we output them\n        return outputs\n\n\nclass BertEncoder(nn.Module):\n    def __init__(self, config):\n        super(BertEncoder, self).__init__()\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n        self.layer = nn.ModuleList([BertLayer(config) for _ in range(config.num_hidden_layers)])\n\n    def forward(self, hidden_states, attention_mask, head_mask=None):\n        all_hidden_states = ()\n        all_attentions = ()\n        for i, layer_module in enumerate(self.layer):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states,)\n\n            layer_outputs = layer_module(hidden_states, attention_mask, head_mask[i])\n            hidden_states = layer_outputs[0]\n\n            if self.output_attentions:\n                all_attentions = all_attentions + (layer_outputs[1],)\n\n        # Add last layer\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        outputs = (hidden_states,)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (all_attentions,)\n        return outputs  # outputs, (hidden states), (attentions)\n\n\nclass BertPooler(nn.Module):\n    def __init__(self, config):\n        super(BertPooler, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.activation = nn.Tanh()\n\n    def forward(self, hidden_states):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token.\n        first_token_tensor = hidden_states[:, 0]\n        pooled_output = self.dense(first_token_tensor)\n        pooled_output = self.activation(pooled_output)\n        return pooled_output\n\n\nclass BertPredictionHeadTransform(nn.Module):\n    def __init__(self, config):\n        super(BertPredictionHeadTransform, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.transform_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.transform_act_fn = config.hidden_act\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.transform_act_fn(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states)\n        return hidden_states\n\n\nclass BertLMPredictionHead(nn.Module):\n    def __init__(self, config):\n        super(BertLMPredictionHead, self).__init__()\n        self.transform = BertPredictionHeadTransform(config)\n\n        # The output weights are the same as the input embeddings, but there is\n        # an output-only bias for each token.\n        self.decoder = nn.Linear(config.hidden_size,\n                                 config.vocab_size,\n                                 bias=False)\n\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\n\n    def forward(self, hidden_states):\n        hidden_states = self.transform(hidden_states)\n        hidden_states = self.decoder(hidden_states) + self.bias\n        return hidden_states\n\n\nclass BertOnlyMLMHead(nn.Module):\n    def __init__(self, config):\n        super(BertOnlyMLMHead, self).__init__()\n        self.predictions = BertLMPredictionHead(config)\n\n    def forward(self, sequence_output):\n        prediction_scores = self.predictions(sequence_output)\n        return prediction_scores\n\n\nclass BertOnlyNSPHead(nn.Module):\n    def __init__(self, config):\n        super(BertOnlyNSPHead, self).__init__()\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, pooled_output):\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return seq_relationship_score\n\n\nclass BertPreTrainingHeads(nn.Module):\n    def __init__(self, config):\n        super(BertPreTrainingHeads, self).__init__()\n        self.predictions = BertLMPredictionHead(config)\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, sequence_output, pooled_output):\n        prediction_scores = self.predictions(sequence_output)\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return prediction_scores, seq_relationship_score\n\n\nclass BertPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = BertConfig\n    pretrained_model_archive_map = BERT_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_bert\n    base_model_prefix = ""bert""\n\n    def __init__(self, *inputs, **kwargs):\n        super(BertPreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, BertLayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n\nBERT_START_DOCSTRING = r""""""    The BERT model was proposed in\n    `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_\n    by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova. It\'s a bidirectional transformer\n    pre-trained using a combination of masked language modeling objective and next sentence prediction\n    on a large corpus comprising the Toronto Book Corpus and Wikipedia.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`:\n        https://arxiv.org/abs/1810.04805\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~pytorch_transformers.BertConfig`): Model configuration class with all the parameters of the model.\n""""""\n\nBERT_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            To match pre-training, BERT input sequence should be formatted with [CLS] and [SEP] tokens as follows:\n\n            (a) For sequence pairs:\n\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]``\n                \n                ``token_type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1``\n\n            (b) For single sequences:\n\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\n                \n                ``token_type_ids:   0   0   0   0  0     0   0``\n    \n            Indices can be obtained using :class:`pytorch_transformers.BertTokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Segment token indices to indicate first and second portions of the inputs.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n            corresponds to a `sentence B` token\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare Bert Model transformer outputing raw hidden-states without any specific head on top."",\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertModel(BertPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the output of the last layer of the model.\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\n            Last layer hidden-state of the first token of the sequence (classification token)\n            further processed by a Linear layer and a Tanh activation function. The Linear\n            layer weights are trained from the next sentence prediction (classification)\n            objective during Bert pretraining. This output is usually *not* a good summary\n            of the semantic content of the input, you\'re often better with averaging or pooling\n            the sequence of hidden-states for the whole input sequence.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertModel.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(BertModel, self).__init__(config)\n        config.output_attentions = True\n        self.embeddings = BertEmbeddings(config)\n        self.encoder = BertEncoder(config)\n        self.pooler = BertPooler(config)\n\n        self.apply(self.init_weights)\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        old_embeddings = self.embeddings.word_embeddings\n        new_embeddings = self._get_resized_embeddings(old_embeddings, new_num_tokens)\n        self.embeddings.word_embeddings = new_embeddings\n        return self.embeddings.word_embeddings\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n            See base class PreTrainedModel\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, position_ids=None, head_mask=None):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        # We create a 3D attention mask from a 2D tensor mask.\n        # Sizes are [batch_size, 1, 1, to_seq_length]\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n        # this attention mask is more simple than the triangular masking of causal attention\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n        # masked positions, this operation will create a tensor which is 0.0 for\n        # positions we want to attend and -10000.0 for masked positions.\n        # Since we are adding it to the raw scores before the softmax, this is\n        # effectively the same as removing these entirely.\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.num_hidden_layers, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.num_hidden_layers\n\n        embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids)\n        encoder_outputs = self.encoder(embedding_output,\n                                       extended_attention_mask,\n                                       head_mask=head_mask)\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output)\n\n        outputs = (sequence_output, pooled_output,) + encoder_outputs[1:]  # add hidden_states and attentions if they are here\n        return outputs  # sequence_output, pooled_output, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with two heads on top as done during the pre-training:\n    a `masked language modeling` head and a `next sentence prediction (classification)` head. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForPreTraining(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when both ``masked_lm_labels`` and ``next_sentence_label`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total loss as the sum of the masked language modeling loss and the next sequence prediction (classification) loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForPreTraining.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        prediction_scores, seq_relationship_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForPreTraining, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertPreTrainingHeads(config)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, masked_lm_labels=None,\n                next_sentence_label=None, position_ids=None, head_mask=None):\n        outputs = self.bert(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n\n        sequence_output, pooled_output = outputs[:2]\n        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\n\n        outputs = (prediction_scores, seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if masked_lm_labels is not None and next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            total_loss = masked_lm_loss + next_sentence_loss\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a `language modeling` head on top. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForMaskedLM(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Masked language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMaskedLM.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, masked_lm_labels=input_ids)\n        loss, prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForMaskedLM, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertOnlyMLMHead(config)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, masked_lm_labels=None,\n                position_ids=None, head_mask=None):\n        outputs = self.bert(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n\n        sequence_output = outputs[0]\n        prediction_scores = self.cls(sequence_output)\n\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\n        if masked_lm_labels is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            outputs = (masked_lm_loss,) + outputs\n\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a `next sentence prediction (classification)` head on top. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForNextSentencePrediction(BertPreTrainedModel):\n    r""""""\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``next_sentence_label`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Next sequence prediction (classification) loss.\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForNextSentencePrediction.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        seq_relationship_scores = outputs[0]\n\n    """"""\n    def __init__(self, config):\n        super(BertForNextSentencePrediction, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertOnlyNSPHead(config)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, next_sentence_label=None,\n                position_ids=None, head_mask=None):\n        outputs = self.bert(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n        pooled_output = outputs[1]\n\n        seq_relationship_score = self.cls(pooled_output)\n\n        outputs = (seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\n        if next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            outputs = (next_sentence_loss,) + outputs\n\n        return outputs  # (next_sentence_loss), seq_relationship_score, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model transformer with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForSequenceClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForSequenceClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, self.config.num_labels)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None,\n                position_ids=None, head_mask=None):\n        outputs = self.bert(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a multiple choice classification head on top (a linear layer on top of\n    the pooled output and a softmax) e.g. for RocStories/SWAG tasks. """""",\n    BERT_START_DOCSTRING)\nclass BertForMultipleChoice(BertPreTrainedModel):\n    r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            To match pre-training, BERT input sequence should be formatted with [CLS] and [SEP] tokens as follows:\n\n            (a) For sequence pairs:\n\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]``\n                \n                ``token_type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1``\n\n            (b) For single sequences:\n\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\n                \n                ``token_type_ids:   0   0   0   0  0     0   0``\n    \n            Indices can be obtained using :class:`pytorch_transformers.BertTokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Segment token indices to indicate first and second portions of the inputs.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n            corresponds to a `sentence B` token\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above).\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMultipleChoice.from_pretrained(\'bert-base-uncased\')\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, classification_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForMultipleChoice, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None,\n                position_ids=None, head_mask=None):\n        num_choices = input_ids.shape[1]\n\n        flat_input_ids = input_ids.view(-1, input_ids.size(-1))\n        flat_position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None\n        flat_token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\n        flat_attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\n        outputs = self.bert(flat_input_ids, position_ids=flat_position_ids, token_type_ids=flat_token_type_ids,\n                            attention_mask=flat_attention_mask, head_mask=head_mask)\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, num_choices)\n\n        outputs = (reshaped_logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), reshaped_logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a token classification head on top (a linear layer on top of\n    the hidden-states output) e.g. for Named-Entity-Recognition (NER) tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForTokenClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the token classification loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.num_labels)``\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForTokenClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForTokenClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None,\n                position_ids=None, head_mask=None):\n        outputs = self.bert(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n        sequence_output = outputs[0]\n\n        sequence_output = self.dropout(sequence_output)\n        logits = self.classifier(sequence_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            # Only keep active parts of the loss\n            if attention_mask is not None:\n                active_loss = attention_mask.view(-1) == 1\n                active_logits = logits.view(-1, self.num_labels)[active_loss]\n                active_labels = labels.view(-1)[active_loss]\n                loss = loss_fct(active_logits, active_labels)\n            else:\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForQuestionAnswering(BertPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForQuestionAnswering.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForQuestionAnswering, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, start_positions=None,\n                end_positions=None, position_ids=None, head_mask=None):\n        outputs = self.bert(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n        sequence_output = outputs[0]\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        outputs = (start_logits, end_logits,) + outputs[2:]\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), start_logits, end_logits, (hidden_states), (attentions)\n'"
bertviz/transformers_neuron_view/modeling_gpt2.py,55,"b'# coding=utf-8\n# Copyright 2018 The OpenAI Team Authors and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# Change log\n# 7/14/19  Jesse Vig   Adapted for use in visualization\n\n""""""PyTorch OpenAI GPT-2 model.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn.parameter import Parameter\n\nfrom .modeling_utils import (Conv1D, CONFIG_NAME, WEIGHTS_NAME, PretrainedConfig,\n                             PreTrainedModel, prune_conv1d_layer, SequenceSummary,\n                             add_start_docstrings)\nfrom .modeling_bert import BertLayerNorm as LayerNorm\n\nlogger = logging.getLogger(__name__)\n\nGPT2_PRETRAINED_MODEL_ARCHIVE_MAP = {""gpt2"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-pytorch_model.bin"",\n                                     ""gpt2-medium"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-pytorch_model.bin""}\nGPT2_PRETRAINED_CONFIG_ARCHIVE_MAP = {""gpt2"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-config.json"",\n                                      ""gpt2-medium"": ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-config.json""}\n\ndef load_tf_weights_in_gpt2(model, config, gpt2_checkpoint_path):\n    """""" Load tf checkpoints in a pytorch model\n    """"""\n    try:\n        import re\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    tf_path = os.path.abspath(gpt2_checkpoint_path)\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array.squeeze())\n\n    for name, array in zip(names, arrays):\n        name = name[6:]  # skip ""model/""\n        name = name.split(\'/\')\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+\\d+\', m_name):\n                l = re.split(r\'(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'w\' or l[0] == \'g\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'b\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'wpe\' or l[0] == \'wte\':\n                pointer = getattr(pointer, l[0])\n                pointer = getattr(pointer, \'weight\')\n            else:\n                pointer = getattr(pointer, l[0])\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\n\ndef gelu(x):\n    return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n\n\nclass GPT2Config(PretrainedConfig):\n    """"""Configuration class to store the configuration of a `GPT2Model`.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `GPT2Model` or a configuration json file.\n        n_positions: Number of positional embeddings.\n        n_ctx: Size of the causal mask (usually same as n_positions).\n        n_embd: Dimensionality of the embeddings and hidden states.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        layer_norm_epsilon: epsilon to use in the layer norm layers\n        resid_pdrop: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        attn_pdrop: The dropout ratio for the attention\n            probabilities.\n        embd_pdrop: The dropout ratio for the embeddings.\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n    """"""\n    pretrained_config_archive_map = GPT2_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(\n        self,\n        vocab_size_or_config_json_file=50257,\n        n_positions=1024,\n        n_ctx=1024,\n        n_embd=768,\n        n_layer=12,\n        n_head=12,\n        resid_pdrop=0.1,\n        embd_pdrop=0.1,\n        attn_pdrop=0.1,\n        layer_norm_epsilon=1e-5,\n        initializer_range=0.02,\n\n        num_labels=1,\n        summary_type=\'cls_index\',\n        summary_use_proj=True,\n        summary_activation=None,\n        summary_proj_to_labels=True,\n        summary_first_dropout=0.1,\n        **kwargs\n    ):\n        """"""Constructs GPT2Config.\n\n        Args:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `GPT2Model` or a configuration json file.\n            n_positions: Number of positional embeddings.\n            n_ctx: Size of the causal mask (usually same as n_positions).\n            n_embd: Dimensionality of the embeddings and hidden states.\n            n_layer: Number of hidden layers in the Transformer encoder.\n            n_head: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            layer_norm_epsilon: epsilon to use in the layer norm layers\n            resid_pdrop: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attn_pdrop: The dropout ratio for the attention\n                probabilities.\n            embd_pdrop: The dropout ratio for the embeddings.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n        """"""\n        super(GPT2Config, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=""utf-8"") as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.n_ctx = n_ctx\n            self.n_positions = n_positions\n            self.n_embd = n_embd\n            self.n_layer = n_layer\n            self.n_head = n_head\n            self.resid_pdrop = resid_pdrop\n            self.embd_pdrop = embd_pdrop\n            self.attn_pdrop = attn_pdrop\n            self.layer_norm_epsilon = layer_norm_epsilon\n            self.initializer_range = initializer_range\n\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_first_dropout = summary_first_dropout\n            self.summary_proj_to_labels = summary_proj_to_labels\n        else:\n            raise ValueError(\n                ""First argument must be either a vocabulary size (int)""\n                ""or the path to a pretrained model config file (str)""\n            )\n\n    @property\n    def max_position_embeddings(self):\n        return self.n_positions\n\n    @property\n    def hidden_size(self):\n        return self.n_embd\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n\n\n\nclass Attention(nn.Module):\n    def __init__(self, nx, n_ctx, config, scale=False):\n        super(Attention, self).__init__()\n        self.output_attentions = config.output_attentions\n\n        n_state = nx  # in Attention: n_state=768 (nx=n_embd)\n        # [switch nx => n_state from Block to Attention to keep identical to TF implem]\n        assert n_state % config.n_head == 0\n        self.register_buffer(""bias"", torch.tril(torch.ones(n_ctx, n_ctx)).view(1, 1, n_ctx, n_ctx))\n        self.n_head = config.n_head\n        self.split_size = n_state\n        self.scale = scale\n\n        self.c_attn = Conv1D(n_state * 3, nx)\n        self.c_proj = Conv1D(n_state, nx)\n        self.attn_dropout = nn.Dropout(config.attn_pdrop)\n        self.resid_dropout = nn.Dropout(config.resid_pdrop)\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.n_head, self.split_size // self.n_head)\n        for head in heads:\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        index_attn = torch.cat([index, index + self.split_size, index + (2*self.split_size)])\n        # Prune conv1d layers\n        self.c_attn = prune_conv1d_layer(self.c_attn, index_attn, dim=1)\n        self.c_proj = prune_conv1d_layer(self.c_proj, index, dim=0)\n        # Update hyper params\n        self.split_size = (self.split_size // self.n_head) * (self.n_head - len(heads))\n        self.n_head = self.n_head - len(heads)\n\n    def _attn(self, q, k, v, head_mask=None):\n        w = torch.matmul(q, k)\n        if self.scale:\n            w = w / math.sqrt(v.size(-1))\n        nd, ns = w.size(-2), w.size(-1)\n        b = self.bias[:, :, ns-nd:ns, :ns]\n        w = w * b - 1e4 * (1 - b)\n\n        w = nn.Softmax(dim=-1)(w)\n        w = self.attn_dropout(w)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            w = w * head_mask\n\n        outputs = [torch.matmul(w, v)]\n        if self.output_attentions:\n            outputs.append(w)\n        return outputs\n\n    def merge_heads(self, x):\n        x = x.permute(0, 2, 1, 3).contiguous()\n        new_x_shape = x.size()[:-2] + (x.size(-2) * x.size(-1),)\n        return x.view(*new_x_shape)  # in Tensorflow implem: fct merge_states\n\n    def split_heads(self, x, k=False):\n        new_x_shape = x.size()[:-1] + (self.n_head, x.size(-1) // self.n_head)\n        x = x.view(*new_x_shape)  # in Tensorflow implem: fct split_states\n        if k:\n            return x.permute(0, 2, 3, 1)  # (batch, head, head_features, seq_length)\n        else:\n            return x.permute(0, 2, 1, 3)  # (batch, head, seq_length, head_features)\n\n    def forward(self, x, layer_past=None, head_mask=None):\n        x = self.c_attn(x)\n        query, key, value = x.split(self.split_size, dim=2)\n        query = self.split_heads(query)\n        key = self.split_heads(key, k=True)\n        value = self.split_heads(value)\n        if layer_past is not None:\n            past_key, past_value = layer_past[0].transpose(-2, -1), layer_past[1]  # transpose back cf below\n            key = torch.cat((past_key, key), dim=-1)\n            value = torch.cat((past_value, value), dim=-2)\n        present = torch.stack((key.transpose(-2, -1), value))  # transpose to have same shapes for stacking\n\n        attn_outputs = self._attn(query, key, value, head_mask)\n        a = attn_outputs[0]\n\n        a = self.merge_heads(a)\n        a = self.c_proj(a)\n        a = self.resid_dropout(a)\n\n\n        if self.output_attentions:\n            attention_probs = attn_outputs[1]\n            attn_data = {\n                \'attn\': attention_probs,\n                \'queries\': query,\n                \'keys\': key.transpose(-1, -2)\n            }\n            outputs = [a, present, attn_data]\n        else:\n            outputs = [a, present]\n        return outputs  # a, present, (attentions)\n\n\nclass MLP(nn.Module):\n    def __init__(self, n_state, config):  # in MLP: n_state=3072 (4 * n_embd)\n        super(MLP, self).__init__()\n        nx = config.n_embd\n        self.c_fc = Conv1D(n_state, nx)\n        self.c_proj = Conv1D(nx, n_state)\n        self.act = gelu\n        self.dropout = nn.Dropout(config.resid_pdrop)\n\n    def forward(self, x):\n        h = self.act(self.c_fc(x))\n        h2 = self.c_proj(h)\n        return self.dropout(h2)\n\n\nclass Block(nn.Module):\n    def __init__(self, n_ctx, config, scale=False):\n        super(Block, self).__init__()\n        nx = config.n_embd\n        self.ln_1 = LayerNorm(nx, eps=config.layer_norm_epsilon)\n        self.attn = Attention(nx, n_ctx, config, scale)\n        self.ln_2 = LayerNorm(nx, eps=config.layer_norm_epsilon)\n        self.mlp = MLP(4 * nx, config)\n\n    def forward(self, x, layer_past=None, head_mask=None):\n        output_attn = self.attn(self.ln_1(x), layer_past=layer_past, head_mask=head_mask)\n        a = output_attn[0]  # output_attn: a, present, (attentions)\n\n        x = x + a\n        m = self.mlp(self.ln_2(x))\n        x = x + m\n\n        outputs = [x] + output_attn[1:]\n        return outputs  # x, present, (attentions)\n\n\nclass GPT2PreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = GPT2Config\n    pretrained_model_archive_map = GPT2_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_gpt2\n    base_model_prefix = ""transformer""\n\n    def __init__(self, *inputs, **kwargs):\n        super(GPT2PreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding, Conv1D)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if isinstance(module, (nn.Linear, Conv1D)) and module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n\nGPT2_START_DOCSTRING = r""""""    OpenAI GPT-2 model was proposed in\n    `Language Models are Unsupervised Multitask Learners`_\n    by Alec Radford*, Jeffrey Wu*, Rewon Child, David Luan, Dario Amodei** and Ilya Sutskever**.\n    It\'s a causal (unidirectional) transformer pre-trained using  language modeling on a very large\n    corpus of ~40 GB of text data.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Language Models are Unsupervised Multitask Learners`:\n        https://openai.com/blog/better-language-models/\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~pytorch_transformers.GPT2Config`): Model configuration class with all the parameters of the model.\n""""""\n\nGPT2_INPUTS_DOCSTRING = r""""""    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            Indices can be obtained using :class:`pytorch_transformers.BPT2Tokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `past` output below). Can be used to speed up sequential decoding.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare GPT2 Model transformer outputing raw hidden-states without any specific head on top."",\n                      GPT2_START_DOCSTRING, GPT2_INPUTS_DOCSTRING)\nclass GPT2Model(GPT2PreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n        model = GPT2Model.from_pretrained(\'gpt2\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(GPT2Model, self).__init__(config)\n        self.output_hidden_states = config.output_hidden_states\n        config.output_attentions = True\n        self.output_attentions = config.output_attentions\n\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n        self.wpe = nn.Embedding(config.n_positions, config.n_embd)\n        self.drop = nn.Dropout(config.embd_pdrop)\n        self.h = nn.ModuleList([Block(config.n_ctx, config, scale=True) for _ in range(config.n_layer)])\n        self.ln_f = LayerNorm(config.n_embd, eps=config.layer_norm_epsilon)\n\n        self.apply(self.init_weights)\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.wte = self._get_resized_embeddings(self.wte, new_num_tokens)\n        return self.wte\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.h[layer].attn.prune_heads(heads)\n\n    def forward(self, input_ids, position_ids=None, token_type_ids=None, past=None, head_mask=None):\n        if past is None:\n            past_length = 0\n            past = [None] * len(self.h)\n        else:\n            past_length = past[0][0].size(-2)\n        if position_ids is None:\n            position_ids = torch.arange(past_length, input_ids.size(-1) + past_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # head_mask has shape n_layer x batch x n_heads x N x N\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.n_layer\n\n        input_shape = input_ids.size()\n        input_ids = input_ids.view(-1, input_ids.size(-1))\n        position_ids = position_ids.view(-1, position_ids.size(-1))\n\n        inputs_embeds = self.wte(input_ids)\n        position_embeds = self.wpe(position_ids)\n        if token_type_ids is not None:\n            token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1))\n            token_type_embeds = self.wte(token_type_ids)\n        else:\n            token_type_embeds = 0\n        hidden_states = inputs_embeds + position_embeds + token_type_embeds\n        hidden_states = self.drop(hidden_states)\n\n        output_shape = input_shape + (hidden_states.size(-1),)\n\n        presents = ()\n        all_attentions = []\n        all_hidden_states = ()\n        for i, (block, layer_past) in enumerate(zip(self.h, past)):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states.view(*output_shape),)\n\n            outputs = block(hidden_states, layer_past, head_mask[i])\n            hidden_states, present = outputs[:2]\n            presents = presents + (present,)\n\n            if self.output_attentions:\n                all_attentions.append(outputs[2])\n\n        hidden_states = self.ln_f(hidden_states)\n\n        hidden_states = hidden_states.view(*output_shape)\n        # Add last hidden state\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        outputs = (hidden_states, presents)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            # # let the number of heads free (-1) so we can extract attention even after head pruning\n            # attention_output_shape = input_shape[:-1] + (-1,) + all_attentions[0].shape[-2:]\n            # all_attentions = tuple(t.view(*attention_output_shape) for t in all_attentions)\n            outputs = outputs + (all_attentions,)\n        return outputs  # last hidden state, presents, (all hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""The GPT2 Model transformer with a language modeling head on top\n(linear layer with weights tied to the input embeddings). """""", GPT2_START_DOCSTRING, GPT2_INPUTS_DOCSTRING)\nclass GPT2LMHeadModel(GPT2PreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n        model = GPT2LMHeadModel.from_pretrained(\'gpt2\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=input_ids)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(GPT2LMHeadModel, self).__init__(config)\n        self.transformer = GPT2Model(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.wte)\n\n    def forward(self, input_ids, position_ids=None, token_type_ids=None, labels=None, past=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                                               past=past, head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states)\n\n        outputs = (lm_logits,) + transformer_outputs[1:]\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), lm_logits, presents, (all hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""The GPT2 Model transformer with a language modeling and a multiple-choice classification\nhead on top e.g. for RocStories/SWAG tasks. The two heads are two linear layers.\nThe language modeling head has its weights tied to the input embeddings,\nthe classification head takes as input the input of a specified classification token index in the intput sequence).\n"""""", GPT2_START_DOCSTRING)\nclass GPT2DoubleHeadsModel(GPT2PreTrainedModel):\n    r""""""    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Indices can be obtained using :class:`pytorch_transformers.BPT2Tokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **mc_token_ids**: ``torch.LongTensor`` of shape ``(batch_size, num_choices)``:\n            Index of the classification token in each input sequence.\n            Selected in the range ``[0, input_ids.size(-1) - 1[``.\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `past` output below). Can be used to speed up sequential decoding.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n        **lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n        **multiple_choice_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n            `multiple_choice_labels`: optional multiple choice labels: ``torch.LongTensor`` of shape [batch_size]\n                with indices selected in [0, ..., num_choices].\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **lm_loss**: (`optional`, returned when ``lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **mc_loss**: (`optional`, returned when ``multiple_choice_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Multiple choice classification loss.\n        **lm_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **mc_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)``\n            Prediction scores of the multiplechoice classification head (scores for each choice before SoftMax).\n        **past**:\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            that contains pre-computed hidden-states (key and values in the attention blocks).\n            Can be used (see `past` input) to speed up sequential decoding.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n        model = GPT2DoubleHeadsModel.from_pretrained(\'gpt2\')\n        tokenizer.add_special_tokens({\'cls_token\': \'[CLS]\'})  # Add a [CLS] to the vocabulary (we should train it also!)\n        choices = [""Hello, my dog is cute [CLS]"", ""Hello, my cat is cute [CLS]""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        mc_token_ids = torch.tensor([input_ids.size(-1), input_ids.size(-1)]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, mc_token_ids)\n        lm_prediction_scores, mc_prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(GPT2DoubleHeadsModel, self).__init__(config)\n        self.transformer = GPT2Model(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n        self.multiple_choice_head = SequenceSummary(config)\n\n        self.apply(self.init_weights)\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.wte)\n\n    def forward(self, input_ids, mc_token_ids=None, lm_labels=None, mc_labels=None, token_type_ids=None,\n                position_ids=None, past=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                                               past=past, head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states)\n        mc_logits = self.multiple_choice_head(hidden_states, mc_token_ids).squeeze(-1)\n\n        outputs = (lm_logits, mc_logits) + transformer_outputs[1:]\n        if mc_labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(mc_logits.view(-1, mc_logits.size(-1)),\n                            mc_labels.view(-1))\n            outputs = (loss,) + outputs\n        if lm_labels is not None:\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = lm_labels[..., 1:].contiguous()\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (lm loss), (mc loss), lm logits, mc logits, presents, (all hidden_states), (attentions)\n'"
bertviz/transformers_neuron_view/modeling_openai.py,51,"b'# coding=utf-8\n# Copyright 2018 The OpenAI Team Authors and HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch OpenAI GPT model.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn.parameter import Parameter\n\nfrom .modeling_utils import (Conv1D, CONFIG_NAME, WEIGHTS_NAME, PretrainedConfig,\n                             PreTrainedModel, prune_conv1d_layer, SequenceSummary,\n                             add_start_docstrings)\nfrom .modeling_bert import BertLayerNorm as LayerNorm\n\nlogger = logging.getLogger(__name__)\n\nOPENAI_GPT_PRETRAINED_MODEL_ARCHIVE_MAP = {""openai-gpt"": ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-pytorch_model.bin""}\nOPENAI_GPT_PRETRAINED_CONFIG_ARCHIVE_MAP = {""openai-gpt"": ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-config.json""}\n\n\ndef load_tf_weights_in_openai_gpt(model, config, openai_checkpoint_folder_path):\n    """""" Load tf pre-trained weights in a pytorch model (from NumPy arrays here)\n    """"""\n    import re\n    import numpy as np\n\n    if \'.ckpt\' in openai_checkpoint_folder_path:\n        openai_checkpoint_folder_path = os.path.dirname(openai_checkpoint_folder_path)\n\n    logger.info(""Loading weights from {}"".format(openai_checkpoint_folder_path))\n\n    names = json.load(open(openai_checkpoint_folder_path + \'/parameters_names.json\', ""r"", encoding=\'utf-8\'))\n    shapes = json.load(open(openai_checkpoint_folder_path + \'/params_shapes.json\', ""r"", encoding=\'utf-8\'))\n    offsets = np.cumsum([np.prod(shape) for shape in shapes])\n    init_params = [np.load(openai_checkpoint_folder_path + \'/params_{}.npy\'.format(n)) for n in range(10)]\n    init_params = np.split(np.concatenate(init_params, 0), offsets)[:-1]\n    init_params = [param.reshape(shape) for param, shape in zip(init_params, shapes)]\n\n    # This was used when we had a single embedding matrix for positions and tokens\n    # init_params[0] = np.concatenate([init_params[1], init_params[0]], 0)\n    # del init_params[1]\n    init_params = [arr.squeeze() for arr in init_params]\n\n    try:\n        assert model.tokens_embed.weight.shape == init_params[1].shape\n        assert model.positions_embed.weight.shape == init_params[0].shape\n    except AssertionError as e:\n        e.args += (model.tokens_embed.weight.shape, init_params[1].shape)\n        e.args += (model.positions_embed.weight.shape, init_params[0].shape)\n        raise\n\n    model.tokens_embed.weight.data = torch.from_numpy(init_params[1])\n    model.positions_embed.weight.data = torch.from_numpy(init_params[0])\n    names.pop(0)\n    # Pop position and token embedding arrays\n    init_params.pop(0)\n    init_params.pop(0)\n\n    for name, array in zip(names, init_params): # names[1:n_transfer], init_params[1:n_transfer]):\n        name = name[6:]  # skip ""model/""\n        assert name[-2:] == "":0""\n        name = name[:-2]\n        name = name.split(\'/\')\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+\\d+\', m_name):\n                l = re.split(r\'(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'g\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'b\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'w\':\n                pointer = getattr(pointer, \'weight\')\n            else:\n                pointer = getattr(pointer, l[0])\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\n\ndef gelu(x):\n    return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT_FNS = {""relu"": nn.ReLU, ""swish"": swish, ""gelu"": gelu}\n\n\nclass OpenAIGPTConfig(PretrainedConfig):\n    """"""\n    Configuration class to store the configuration of a `OpenAIGPTModel`.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `OpenAIGPTModel` or a configuration json file.\n        n_special: The number of special tokens to learn during fine-tuning (\'[SEP]\', \'[CLF]\', ...)\n        n_positions: Number of positional embeddings.\n        n_ctx: Size of the causal mask (usually same as n_positions).\n        n_embd: Dimensionality of the embeddings and hidden states.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        afn: The non-linear activation function (function or string) in the\n            encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n        resid_pdrop: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        attn_pdrop: The dropout ratio for the attention\n            probabilities.\n        embd_pdrop: The dropout ratio for the embeddings.\n        layer_norm_epsilon: epsilon to use in the layer norm layers\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n        predict_special_tokens: should we predict special tokens (when the model has a LM head)\n    """"""\n    pretrained_config_archive_map = OPENAI_GPT_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(\n        self,\n        vocab_size_or_config_json_file=40478,\n        n_positions=512,\n        n_ctx=512,\n        n_embd=768,\n        n_layer=12,\n        n_head=12,\n        afn=""gelu"",\n        resid_pdrop=0.1,\n        embd_pdrop=0.1,\n        attn_pdrop=0.1,\n        layer_norm_epsilon=1e-5,\n        initializer_range=0.02,\n        predict_special_tokens=True,\n\n        num_labels=1,\n        summary_type=\'cls_index\',\n        summary_use_proj=True,\n        summary_activation=None,\n        summary_proj_to_labels=True,\n        summary_first_dropout=0.1,\n        **kwargs\n    ):\n        """"""Constructs OpenAIGPTConfig.\n        """"""\n        super(OpenAIGPTConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=""utf-8"") as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.n_ctx = n_ctx\n            self.n_positions = n_positions\n            self.n_embd = n_embd\n            self.n_layer = n_layer\n            self.n_head = n_head\n            self.afn = afn\n            self.resid_pdrop = resid_pdrop\n            self.embd_pdrop = embd_pdrop\n            self.attn_pdrop = attn_pdrop\n            self.layer_norm_epsilon = layer_norm_epsilon\n            self.initializer_range = initializer_range\n            self.predict_special_tokens = predict_special_tokens\n\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_first_dropout = summary_first_dropout\n            self.summary_proj_to_labels = summary_proj_to_labels\n        else:\n            raise ValueError(\n                ""First argument must be either a vocabulary size (int)""\n                ""or the path to a pretrained model config file (str)""\n            )\n\n    @property\n    def max_position_embeddings(self):\n        return self.n_positions\n\n    @property\n    def hidden_size(self):\n        return self.n_embd\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n\n\nclass Attention(nn.Module):\n    def __init__(self, nx, n_ctx, config, scale=False):\n        super(Attention, self).__init__()\n        n_state = nx  # in Attention: n_state=768 (nx=n_embd)\n        # [switch nx => n_state from Block to Attention to keep identical to TF implem]\n        assert n_state % config.n_head == 0\n        self.register_buffer(""bias"", torch.tril(torch.ones(n_ctx, n_ctx)).view(1, 1, n_ctx, n_ctx))\n        self.n_head = config.n_head\n        self.split_size = n_state\n        self.scale = scale\n\n        self.output_attentions = config.output_attentions\n\n        self.c_attn = Conv1D(n_state * 3, nx)\n        self.c_proj = Conv1D(n_state, nx)\n        self.attn_dropout = nn.Dropout(config.attn_pdrop)\n        self.resid_dropout = nn.Dropout(config.resid_pdrop)\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.n_head, self.split_size // self.n_head)\n        for head in heads:\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        index_attn = torch.cat([index, index + self.split_size, index + (2*self.split_size)])\n        # Prune conv1d layers\n        self.c_attn = prune_conv1d_layer(self.c_attn, index_attn, dim=1)\n        self.c_proj = prune_conv1d_layer(self.c_proj, index, dim=0)\n        # Update hyper params\n        self.split_size = (self.split_size // self.n_head) * (self.n_head - len(heads))\n        self.n_head = self.n_head - len(heads)\n\n    def _attn(self, q, k, v, head_mask=None):\n        w = torch.matmul(q, k)\n        if self.scale:\n            w = w / math.sqrt(v.size(-1))\n        # w = w * self.bias + -1e9 * (1 - self.bias)  # TF implem method: mask_attn_weights\n        # XD: self.b may be larger than w, so we need to crop it\n        b = self.bias[:, :, : w.size(-2), : w.size(-1)]\n        w = w * b + -1e9 * (1 - b)\n\n        w = nn.Softmax(dim=-1)(w)\n        w = self.attn_dropout(w)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            w = w * head_mask\n\n        outputs = [torch.matmul(w, v)]\n        if self.output_attentions:\n            outputs.append(w)\n        return outputs\n\n    def merge_heads(self, x):\n        x = x.permute(0, 2, 1, 3).contiguous()\n        new_x_shape = x.size()[:-2] + (x.size(-2) * x.size(-1),)\n        return x.view(*new_x_shape)  # in Tensorflow implem: fct merge_states\n\n    def split_heads(self, x, k=False):\n        new_x_shape = x.size()[:-1] + (self.n_head, x.size(-1) // self.n_head)\n        x = x.view(*new_x_shape)  # in Tensorflow implem: fct split_states\n        if k:\n            return x.permute(0, 2, 3, 1)\n        else:\n            return x.permute(0, 2, 1, 3)\n\n    def forward(self, x, head_mask=None):\n        x = self.c_attn(x)\n        query, key, value = x.split(self.split_size, dim=2)\n        query = self.split_heads(query)\n        key = self.split_heads(key, k=True)\n        value = self.split_heads(value)\n\n        attn_outputs = self._attn(query, key, value, head_mask)\n        a = attn_outputs[0]\n\n        a = self.merge_heads(a)\n        a = self.c_proj(a)\n        a = self.resid_dropout(a)\n\n        outputs = [a] + attn_outputs[1:]\n        return outputs  # a, (attentions)\n\n\nclass MLP(nn.Module):\n    def __init__(self, n_state, config):  # in MLP: n_state=3072 (4 * n_embd)\n        super(MLP, self).__init__()\n        nx = config.n_embd\n        self.c_fc = Conv1D(n_state, nx)\n        self.c_proj = Conv1D(nx, n_state)\n        self.act = ACT_FNS[config.afn]\n        self.dropout = nn.Dropout(config.resid_pdrop)\n\n    def forward(self, x):\n        h = self.act(self.c_fc(x))\n        h2 = self.c_proj(h)\n        return self.dropout(h2)\n\n\nclass Block(nn.Module):\n    def __init__(self, n_ctx, config, scale=False):\n        super(Block, self).__init__()\n        nx = config.n_embd\n        self.attn = Attention(nx, n_ctx, config, scale)\n        self.ln_1 = LayerNorm(nx, eps=config.layer_norm_epsilon)\n        self.mlp = MLP(4 * nx, config)\n        self.ln_2 = LayerNorm(nx, eps=config.layer_norm_epsilon)\n\n    def forward(self, x, head_mask=None):\n        attn_outputs = self.attn(x, head_mask=head_mask)\n        a = attn_outputs[0]\n\n        n = self.ln_1(x + a)\n        m = self.mlp(n)\n        h = self.ln_2(n + m)\n\n        outputs = [h] + attn_outputs[1:]\n        return outputs\n\n\nclass OpenAIGPTPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = OpenAIGPTConfig\n    pretrained_model_archive_map = OPENAI_GPT_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_openai_gpt\n    base_model_prefix = ""transformer""\n\n    def __init__(self, *inputs, **kwargs):\n        super(OpenAIGPTPreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding, Conv1D)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if isinstance(module, (nn.Linear, Conv1D)) and module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n\nOPENAI_GPT_START_DOCSTRING = r""""""    OpenAI GPT model was proposed in\n    `Improving Language Understanding by Generative Pre-Training`_\n    by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever.\n    It\'s a causal (unidirectional) transformer pre-trained using language modeling on a large\n    corpus will long range dependencies, the Toronto Book Corpus.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Improving Language Understanding by Generative Pre-Training`:\n        https://openai.com/blog/language-unsupervised/\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~pytorch_transformers.OpenAIGPTConfig`): Model configuration class with all the parameters of the model.\n""""""\n\nOPENAI_GPT_INPUTS_DOCSTRING = r""""""    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            Indices can be obtained using :class:`pytorch_transformers.BPT2Tokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare OpenAI GPT transformer model outputing raw hidden-states without any specific head on top."",\n                      OPENAI_GPT_START_DOCSTRING, OPENAI_GPT_INPUTS_DOCSTRING)\nclass OpenAIGPTModel(OpenAIGPTPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = OpenAIGPTTokenizer.from_pretrained(\'openai-gpt\')\n        model = OpenAIGPTModel.from_pretrained(\'openai-gpt\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(OpenAIGPTModel, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        self.tokens_embed = nn.Embedding(config.vocab_size, config.n_embd)\n        self.positions_embed = nn.Embedding(config.n_positions, config.n_embd)\n        self.drop = nn.Dropout(config.embd_pdrop)\n        self.h = nn.ModuleList([Block(config.n_ctx, config, scale=True) for _ in range(config.n_layer)])\n\n        self.apply(self.init_weights)\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.tokens_embed = self._get_resized_embeddings(self.tokens_embed, new_num_tokens)\n        return self.tokens_embed\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.h[layer].attn.prune_heads(heads)\n\n    def forward(self, input_ids, position_ids=None, token_type_ids=None, head_mask=None):\n        if position_ids is None:\n            # This was used when we had a single embedding matrice from position and token embeddings\n            # start = self.config.vocab_size + self.config.n_special\n            # end = start + input_ids.size(-1)\n            # position_ids = torch.arange(start, end, dtype=torch.long, device=input_ids.device)\n            position_ids = torch.arange(input_ids.size(-1), dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # head_mask has shape n_layer x batch x n_heads x N x N\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.n_layer\n\n        input_shape = input_ids.size()\n        input_ids = input_ids.view(-1, input_ids.size(-1))\n        position_ids = position_ids.view(-1, position_ids.size(-1))\n\n        inputs_embeds = self.tokens_embed(input_ids)\n        position_embeds = self.positions_embed(position_ids)\n        if token_type_ids is not None:\n            token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1))\n            token_type_embeds = self.tokens_embed(token_type_ids)\n        else:\n            token_type_embeds = 0\n        hidden_states = inputs_embeds + position_embeds + token_type_embeds\n        hidden_states = self.drop(hidden_states)\n\n        output_shape = input_shape + (hidden_states.size(-1),)\n\n        all_attentions = ()\n        all_hidden_states = ()\n        for i, block in enumerate(self.h):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states.view(*output_shape),)\n\n            outputs = block(hidden_states, head_mask[i])\n            hidden_states = outputs[0]\n            if self.output_attentions:\n                all_attentions = all_attentions + (outputs[1],)\n\n        # Add last layer\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states.view(*output_shape),)\n\n        outputs = (hidden_states.view(*output_shape),)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (all_attentions,)\n        return outputs  # last hidden state, (all hidden states), (all attentions)\n\n\n@add_start_docstrings(""""""OpenAI GPT Model transformer with a language modeling head on top\n(linear layer with weights tied to the input embeddings). """""", OPENAI_GPT_START_DOCSTRING, OPENAI_GPT_INPUTS_DOCSTRING)\nclass OpenAIGPTLMHeadModel(OpenAIGPTPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = OpenAIGPTTokenizer.from_pretrained(\'openai-gpt\')\n        model = OpenAIGPTLMHeadModel.from_pretrained(\'openai-gpt\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=input_ids)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(OpenAIGPTLMHeadModel, self).__init__(config)\n        self.transformer = OpenAIGPTModel(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.tokens_embed)\n\n    def forward(self, input_ids, position_ids=None, token_type_ids=None, labels=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                                               head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n        lm_logits = self.lm_head(hidden_states)\n\n        outputs = (lm_logits,) + transformer_outputs[1:]\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), lm_logits, (all hidden states), (all attentions)\n\n\n@add_start_docstrings(""""""OpenAI GPT Model transformer with a language modeling and a multiple-choice classification\nhead on top e.g. for RocStories/SWAG tasks. The two heads are two linear layers.\nThe language modeling head has its weights tied to the input embeddings,\nthe classification head takes as input the input of a specified classification token index in the intput sequence).\n"""""", OPENAI_GPT_START_DOCSTRING)\nclass OpenAIGPTDoubleHeadsModel(OpenAIGPTPreTrainedModel):\n    r""""""    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            The second dimension of the input (`num_choices`) indicates the number of choices to score.\n            Indices can be obtained using :class:`pytorch_transformers.BPT2Tokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **mc_token_ids**: ``torch.LongTensor`` of shape ``(batch_size, num_choices)``:\n            Index of the classification token in each input sequence.\n            Selected in the range ``[0, input_ids.size(-1) - 1[``.\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n        **lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n        **multiple_choice_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n            `multiple_choice_labels`: optional multiple choice labels: ``torch.LongTensor`` of shape [batch_size]\n                with indices selected in [0, ..., num_choices].\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **lm_loss**: (`optional`, returned when ``lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **mc_loss**: (`optional`, returned when ``multiple_choice_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Multiple choice classification loss.\n        **lm_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **mc_prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)``\n            Prediction scores of the multiplechoice classification head (scores for each choice before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = OpenAIGPTTokenizer.from_pretrained(\'openai-gpt\')\n        model = OpenAIGPTDoubleHeadsModel.from_pretrained(\'openai-gpt\')\n        tokenizer.add_special_tokens({\'cls_token\': \'[CLS]\'})  # Add a [CLS] to the vocabulary (we should train it also!)\n        choices = [""Hello, my dog is cute [CLS]"", ""Hello, my cat is cute [CLS]""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        mc_token_ids = torch.tensor([input_ids.size(-1), input_ids.size(-1)]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, mc_token_ids)\n        lm_prediction_scores, mc_prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(OpenAIGPTDoubleHeadsModel, self).__init__(config)\n\n        self.transformer = OpenAIGPTModel(config)\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n        self.multiple_choice_head = SequenceSummary(config)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head,\n                                   self.transformer.tokens_embed)\n\n    def forward(self, input_ids, mc_token_ids=None, lm_labels=None, mc_labels=None, token_type_ids=None,\n                position_ids=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                                               head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n\n        lm_logits = self.lm_head(hidden_states)\n        mc_logits = self.multiple_choice_head(hidden_states, mc_token_ids).squeeze(-1)\n\n        outputs = (lm_logits, mc_logits) + transformer_outputs[1:]\n        if mc_labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(mc_logits.view(-1, mc_logits.size(-1)),\n                            mc_labels.view(-1))\n            outputs = (loss,) + outputs\n        if lm_labels is not None:\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = lm_labels[..., 1:].contiguous()\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (lm loss), (mc loss), lm logits, mc logits, (all hidden_states), (attentions)\n'"
bertviz/transformers_neuron_view/modeling_roberta.py,31,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch RoBERTa model. """"""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_bert import (BertConfig, BertEmbeddings,\n                                                BertLayerNorm, BertModel,\n                                                BertPreTrainedModel, gelu)\n\nfrom .modeling_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-pytorch_model.bin"",\n    \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-pytorch_model.bin"",\n    \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-pytorch_model.bin"",\n}\n\nROBERTA_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-config.json"",\n    \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-config.json"",\n    \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-config.json"",\n}\n\n\nclass RobertaEmbeddings(BertEmbeddings):\n    """"""\n    Same as BertEmbeddings with a tiny tweak for positional embeddings indexing.\n    """"""\n    def __init__(self, config):\n        super(RobertaEmbeddings, self).__init__(config)\n        self.padding_idx = 1\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            # Position numbers begin at padding_idx+1. Padding symbols are ignored.\n            # cf. fairseq\'s `utils.make_positions`\n            position_ids = torch.arange(self.padding_idx+1, seq_length+self.padding_idx+1, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        return super(RobertaEmbeddings, self).forward(input_ids, token_type_ids=token_type_ids, position_ids=position_ids)\n\n\nclass RobertaConfig(BertConfig):\n    pretrained_config_archive_map = ROBERTA_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n\nROBERTA_START_DOCSTRING = r""""""    The RoBERTa model was proposed in\n    `RoBERTa: A Robustly Optimized BERT Pretraining Approach`_\n    by Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer,\n    Veselin Stoyanov. It is based on Google\'s BERT model released in 2018.\n    \n    It builds on BERT and modifies key hyperparameters, removing the next-sentence pretraining\n    objective and training with much larger mini-batches and learning rates.\n    \n    This implementation is the same as BertModel with a tiny embeddings tweak as well as a setup for Roberta pretrained \n    models.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`RoBERTa: A Robustly Optimized BERT Pretraining Approach`:\n        https://arxiv.org/abs/1907.11692\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~pytorch_transformers.RobertaConfig`): Model configuration class with all the parameters of the \n            model.\n""""""\n\nROBERTA_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            To match pre-training, RoBERTa input sequence should be formatted with [CLS] and [SEP] tokens as follows:\n\n            (a) For sequence pairs:\n\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP][SEP] no it is not . [SEP]``\n\n            (b) For single sequences:\n\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\n\n            Fully encoded sequences or sequence pairs can be obtained using the RobertaTokenizer.encode function with \n            the ``add_special_tokens`` parameter set to ``True``.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1[``.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare RoBERTa Model transformer outputing raw hidden-states without any specific head on top."",\n                      ROBERTA_START_DOCSTRING, ROBERTA_INPUTS_DOCSTRING)\nclass RobertaModel(BertModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the output of the last layer of the model.\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\n            Last layer hidden-state of the first token of the sequence (classification token)\n            further processed by a Linear layer and a Tanh activation function. The Linear\n            layer weights are trained from the next sentence prediction (classification)\n            objective during Bert pretraining. This output is usually *not* a good summary\n            of the semantic content of the input, you\'re often better with averaging or pooling\n            the sequence of hidden-states for the whole input sequence.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = RobertaTokenizer.from_pretrained(\'roberta-base\')\n        model = RobertaModel.from_pretrained(\'roberta-base\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    config_class = RobertaConfig\n    pretrained_model_archive_map = ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""roberta""\n\n    def __init__(self, config):\n        super(RobertaModel, self).__init__(config)\n\n        self.embeddings = RobertaEmbeddings(config)\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, position_ids=None, head_mask=None):\n        if input_ids[:, 0].sum().item() != 0:\n            logger.warning(""A sequence with no special tokens has been passed to the RoBERTa model. ""\n                           ""This model requires special tokens in order to work. ""\n                           ""Please specify add_special_tokens=True in your encoding."")\n        return super(RobertaModel, self).forward(input_ids, token_type_ids, attention_mask, position_ids, head_mask)\n\n\n@add_start_docstrings(""""""RoBERTa Model with a `language modeling` head on top. """""",\n    ROBERTA_START_DOCSTRING, ROBERTA_INPUTS_DOCSTRING)\nclass RobertaForMaskedLM(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Masked language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = RobertaTokenizer.from_pretrained(\'roberta-base\')\n        model = RobertaForMaskedLM.from_pretrained(\'roberta-base\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, masked_lm_labels=input_ids)\n        loss, prediction_scores = outputs[:2]\n\n    """"""\n    config_class = RobertaConfig\n    pretrained_model_archive_map = ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""roberta""\n\n    def __init__(self, config):\n        super(RobertaForMaskedLM, self).__init__(config)\n\n        self.roberta = RobertaModel(config)\n        self.lm_head = RobertaLMHead(config)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.lm_head.decoder, self.roberta.embeddings.word_embeddings)\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, masked_lm_labels=None, position_ids=None,\n                head_mask=None):\n        outputs = self.roberta(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n        sequence_output = outputs[0]\n        prediction_scores = self.lm_head(sequence_output)\n\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\n\n        if masked_lm_labels is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            outputs = (masked_lm_loss,) + outputs\n\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\n\n\nclass RobertaLMHead(nn.Module):\n    """"""Roberta Head for masked language modeling.""""""\n\n    def __init__(self, config):\n        super(RobertaLMHead, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.layer_norm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n\n        self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\n\n    def forward(self, features, **kwargs):\n        x = self.dense(features)\n        x = gelu(x)\n        x = self.layer_norm(x)\n\n        # project back to size of vocabulary with bias\n        x = self.decoder(x) + self.bias\n\n        return x\n\n\n@add_start_docstrings(""""""RoBERTa Model transformer with a sequence classification/regression head on top (a linear layer \n    on top of the pooled output) e.g. for GLUE tasks. """""",\n    ROBERTA_START_DOCSTRING, ROBERTA_INPUTS_DOCSTRING)\nclass RobertaForSequenceClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = RoertaTokenizer.from_pretrained(\'roberta-base\')\n        model = RobertaForSequenceClassification.from_pretrained(\'roberta-base\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    config_class = RobertaConfig\n    pretrained_model_archive_map = ROBERTA_PRETRAINED_MODEL_ARCHIVE_MAP\n    base_model_prefix = ""roberta""\n\n    def __init__(self, config):\n        super(RobertaForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.roberta = RobertaModel(config)\n        self.classifier = RobertaClassificationHead(config)\n    \n    def forward(self, input_ids, token_type_ids=None, attention_mask=None, labels=None,\n                position_ids=None, head_mask=None):\n        outputs = self.roberta(input_ids, position_ids=position_ids, token_type_ids=token_type_ids,\n                            attention_mask=attention_mask, head_mask=head_mask)\n        sequence_output = outputs[0]\n        logits = self.classifier(sequence_output)\n\n        outputs = (logits,) + outputs[2:]\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), logits, (hidden_states), (attentions)\n\n\n\nclass RobertaClassificationHead(nn.Module):\n    """"""Head for sentence-level classification tasks.""""""\n\n    def __init__(self, config):\n        super(RobertaClassificationHead, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.out_proj = nn.Linear(config.hidden_size, config.num_labels)\n\n    def forward(self, features, **kwargs):\n        x = features[:, 0, :]  # take <s> token (equiv. to [CLS])\n        x = self.dropout(x)\n        x = self.dense(x)\n        x = torch.tanh(x)\n        x = self.dropout(x)\n        x = self.out_proj(x)\n        return x\n'"
bertviz/transformers_neuron_view/modeling_transfo_xl.py,77,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" PyTorch Transformer XL model.\n    Adapted from https://github.com/kimiyoung/transformer-xl.\n    In particular https://github.com/kimiyoung/transformer-xl/blob/master/pytorch/mem_transformer.py\n""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport os\nimport json\nimport math\nimport logging\nimport collections\nimport sys\nfrom io import open\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn.parameter import Parameter\n\nfrom .modeling_bert import BertLayerNorm as LayerNorm\nfrom .modeling_transfo_xl_utilities import ProjectedAdaptiveLogSoftmax, sample_logits\nfrom .modeling_utils import (PretrainedConfig, PreTrainedModel, add_start_docstrings)\n\nlogger = logging.getLogger(__name__)\n\nTRANSFO_XL_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-pytorch_model.bin"",\n}\nTRANSFO_XL_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-config.json"",\n}\n\ndef build_tf_to_pytorch_map(model, config):\n    """""" A map of modules from TF to PyTorch.\n        This time I use a map to keep the PyTorch model as identical to the original PyTorch model as possible.\n    """"""\n    tf_to_pt_map = {}\n\n    if hasattr(model, \'transformer\'):\n        # We are loading in a TransfoXLLMHeadModel => we will load also the Adaptive Softmax\n        tf_to_pt_map.update({\n            ""transformer/adaptive_softmax/cutoff_0/cluster_W"": model.crit.cluster_weight,\n            ""transformer/adaptive_softmax/cutoff_0/cluster_b"": model.crit.cluster_bias})\n        for i, (out_l, proj_l, tie_proj) in enumerate(zip(\n                                model.crit.out_layers,\n                                model.crit.out_projs,\n                                config.tie_projs)):\n            layer_str = ""transformer/adaptive_softmax/cutoff_%d/"" % i\n            if config.tie_weight:\n                tf_to_pt_map.update({\n                    layer_str + \'b\': out_l.bias})\n            else:\n                raise NotImplementedError\n                # I don\'t think this is implemented in the TF code\n                tf_to_pt_map.update({\n                    layer_str + \'lookup_table\': out_l.weight,\n                    layer_str + \'b\': out_l.bias})\n            if not tie_proj:\n                tf_to_pt_map.update({\n                    layer_str + \'proj\': proj_l\n                    })\n        # Now load the rest of the transformer\n        model = model.transformer\n\n    # Embeddings\n    for i, (embed_l, proj_l) in enumerate(zip(model.word_emb.emb_layers, model.word_emb.emb_projs)):\n        layer_str = ""transformer/adaptive_embed/cutoff_%d/"" % i\n        tf_to_pt_map.update({\n            layer_str + \'lookup_table\': embed_l.weight,\n            layer_str + \'proj_W\': proj_l\n            })\n\n    # Transformer blocks\n    for i, b in enumerate(model.layers):\n        layer_str = ""transformer/layer_%d/"" % i\n        tf_to_pt_map.update({\n            layer_str + ""rel_attn/LayerNorm/gamma"": b.dec_attn.layer_norm.weight,\n            layer_str + ""rel_attn/LayerNorm/beta"": b.dec_attn.layer_norm.bias,\n            layer_str + ""rel_attn/o/kernel"": b.dec_attn.o_net.weight,\n            layer_str + ""rel_attn/qkv/kernel"": b.dec_attn.qkv_net.weight,\n            layer_str + ""rel_attn/r/kernel"": b.dec_attn.r_net.weight,\n            layer_str + ""ff/LayerNorm/gamma"": b.pos_ff.layer_norm.weight,\n            layer_str + ""ff/LayerNorm/beta"": b.pos_ff.layer_norm.bias,\n            layer_str + ""ff/layer_1/kernel"": b.pos_ff.CoreNet[0].weight,\n            layer_str + ""ff/layer_1/bias"": b.pos_ff.CoreNet[0].bias,\n            layer_str + ""ff/layer_2/kernel"": b.pos_ff.CoreNet[3].weight,\n            layer_str + ""ff/layer_2/bias"": b.pos_ff.CoreNet[3].bias,\n        })\n\n    # Relative positioning biases\n    if config.untie_r:\n        r_r_list = []\n        r_w_list = []\n        for b in model.layers:\n            r_r_list.append(b.dec_attn.r_r_bias)\n            r_w_list.append(b.dec_attn.r_w_bias)\n    else:\n        r_r_list = [model.r_r_bias]\n        r_w_list = [model.r_w_bias]\n    tf_to_pt_map.update({\n        \'transformer/r_r_bias\': r_r_list,\n        \'transformer/r_w_bias\': r_w_list})\n    return tf_to_pt_map\n\ndef load_tf_weights_in_transfo_xl(model, config, tf_path):\n    """""" Load tf checkpoints in a pytorch model\n    """"""\n    try:\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow models in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    # Build TF to PyTorch weights loading map\n    tf_to_pt_map = build_tf_to_pytorch_map(model, config)\n\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    tf_weights = {}\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        tf_weights[name] = array\n\n    for name, pointer in tf_to_pt_map.items():\n        assert name in tf_weights\n        array = tf_weights[name]\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if \'kernel\' in name or \'proj\' in name:\n            array = np.transpose(array)\n        if (\'r_r_bias\' in name or \'r_w_bias\' in name) and len(pointer) > 1:\n            # Here we will split the TF weigths\n            assert len(pointer) == array.shape[0]\n            for i, p_i in enumerate(pointer):\n                arr_i = array[i, ...]\n                try:\n                    assert p_i.shape == arr_i.shape\n                except AssertionError as e:\n                    e.args += (p_i.shape, arr_i.shape)\n                    raise\n                logger.info(""Initialize PyTorch weight {} for layer {}"".format(name, i))\n                p_i.data = torch.from_numpy(arr_i)\n        else:\n            try:\n                assert pointer.shape == array.shape\n            except AssertionError as e:\n                e.args += (pointer.shape, array.shape)\n                raise\n            logger.info(""Initialize PyTorch weight {}"".format(name))\n            pointer.data = torch.from_numpy(array)\n        tf_weights.pop(name, None)\n        tf_weights.pop(name + \'/Adam\', None)\n        tf_weights.pop(name + \'/Adam_1\', None)\n\n    logger.info(""Weights not copied to PyTorch model: {}"".format(\', \'.join(tf_weights.keys())))\n    return model\n\n\nclass TransfoXLConfig(PretrainedConfig):\n    """"""Configuration class to store the configuration of a `TransfoXLModel`.\n\n        Args:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `TransfoXLModel` or a configuration json file.\n            cutoffs: cutoffs for the adaptive softmax\n            d_model: Dimensionality of the model\'s hidden states.\n            d_embed: Dimensionality of the embeddings\n            d_head: Dimensionality of the model\'s heads.\n            div_val: divident value for adapative input and softmax\n            pre_lnorm: apply LayerNorm to the input instead of the output\n            d_inner: Inner dimension in FF\n            n_layer: Number of hidden layers in the Transformer encoder.\n            n_head: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            tgt_len: number of tokens to predict\n            ext_len: length of the extended context\n            mem_len: length of the retained previous heads\n            same_length: use the same attn length for all tokens\n            proj_share_all_but_first: True to share all but first projs, False not to share.\n            attn_type: attention type. 0 for Transformer-XL, 1 for Shaw et al, 2 for Vaswani et al, 3 for Al Rfou et al.\n            clamp_len: use the same pos embeddings after clamp_len\n            sample_softmax: number of samples in sampled softmax\n            adaptive: use adaptive softmax\n            tie_weight: tie the word embedding and softmax weights\n            dropout: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            dropatt: The dropout ratio for the attention probabilities.\n            untie_r: untie relative position biases\n            embd_pdrop: The dropout ratio for the embeddings.\n            init: parameter initializer to use\n            init_range: parameters initialized by U(-init_range, init_range).\n            proj_init_std: parameters initialized by N(0, init_std)\n            init_std: parameters initialized by N(0, init_std)\n    """"""\n    pretrained_config_archive_map = TRANSFO_XL_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=267735,\n                 cutoffs=[20000, 40000, 200000],\n                 d_model=1024,\n                 d_embed=1024,\n                 n_head=16,\n                 d_head=64,\n                 d_inner=4096,\n                 div_val=4,\n                 pre_lnorm=False,\n                 n_layer=18,\n                 tgt_len=128,\n                 ext_len=0,\n                 mem_len=1600,\n                 clamp_len=1000,\n                 same_length=True,\n                 proj_share_all_but_first=True,\n                 attn_type=0,\n                 sample_softmax=-1,\n                 adaptive=True,\n                 tie_weight=True,\n                 dropout=0.1,\n                 dropatt=0.0,\n                 untie_r=True,\n                 init=""normal"",\n                 init_range=0.01,\n                 proj_init_std=0.01,\n                 init_std=0.02,\n                 **kwargs):\n        """"""Constructs TransfoXLConfig.\n        """"""\n        super(TransfoXLConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.n_token = vocab_size_or_config_json_file\n            self.cutoffs = []\n            self.cutoffs.extend(cutoffs)\n            self.tie_weight = tie_weight\n            if proj_share_all_but_first:\n                self.tie_projs = [False] + [True] * len(self.cutoffs)\n            else:\n                self.tie_projs = [False] + [False] * len(self.cutoffs)\n            self.d_model = d_model\n            self.d_embed = d_embed\n            self.d_head = d_head\n            self.d_inner = d_inner\n            self.div_val = div_val\n            self.pre_lnorm = pre_lnorm\n            self.n_layer = n_layer\n            self.n_head = n_head\n            self.tgt_len = tgt_len\n            self.ext_len = ext_len\n            self.mem_len = mem_len\n            self.same_length = same_length\n            self.attn_type = attn_type\n            self.clamp_len = clamp_len\n            self.sample_softmax = sample_softmax\n            self.adaptive = adaptive\n            self.dropout = dropout\n            self.dropatt = dropatt\n            self.untie_r = untie_r\n            self.init = init\n            self.init_range = init_range\n            self.proj_init_std = proj_init_std\n            self.init_std = init_std\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             ""or the path to a pretrained model config file (str)"")\n\n    @property\n    def max_position_embeddings(self):\n        return self.tgt_len + self.ext_len + self.mem_len\n\n    @property\n    def vocab_size(self):\n        return self.n_token\n\n    @vocab_size.setter\n    def vocab_size(self, value):\n        self.n_token = value\n\n    @property\n    def hidden_size(self):\n        return self.d_model\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n\n\nclass PositionalEmbedding(nn.Module):\n    def __init__(self, demb):\n        super(PositionalEmbedding, self).__init__()\n\n        self.demb = demb\n\n        inv_freq = 1 / (10000 ** (torch.arange(0.0, demb, 2.0) / demb))\n        self.register_buffer(\'inv_freq\', inv_freq)\n\n    def forward(self, pos_seq, bsz=None):\n        sinusoid_inp = torch.ger(pos_seq, self.inv_freq)\n        pos_emb = torch.cat([sinusoid_inp.sin(), sinusoid_inp.cos()], dim=-1)\n\n        if bsz is not None:\n            return pos_emb[:,None,:].expand(-1, bsz, -1)\n        else:\n            return pos_emb[:,None,:]\n\n\n\nclass PositionwiseFF(nn.Module):\n    def __init__(self, d_model, d_inner, dropout, pre_lnorm=False):\n        super(PositionwiseFF, self).__init__()\n\n        self.d_model = d_model\n        self.d_inner = d_inner\n        self.dropout = dropout\n\n        self.CoreNet = nn.Sequential(\n            nn.Linear(d_model, d_inner), nn.ReLU(inplace=True),\n            nn.Dropout(dropout),\n            nn.Linear(d_inner, d_model),\n            nn.Dropout(dropout),\n        )\n\n        self.layer_norm = LayerNorm(d_model)\n\n        self.pre_lnorm = pre_lnorm\n\n    def forward(self, inp):\n        if self.pre_lnorm:\n            ##### layer normalization + positionwise feed-forward\n            core_out = self.CoreNet(self.layer_norm(inp))\n\n            ##### residual connection\n            output = core_out + inp\n        else:\n            ##### positionwise feed-forward\n            core_out = self.CoreNet(inp)\n\n            ##### residual connection + layer normalization\n            output = self.layer_norm(inp + core_out)\n\n        return output\n\n\n\nclass MultiHeadAttn(nn.Module):\n    def __init__(self, n_head, d_model, d_head, dropout, dropatt=0, \n                 pre_lnorm=False, r_r_bias=None, r_w_bias=None, output_attentions=False):\n        super(MultiHeadAttn, self).__init__()\n\n        self.output_attentions = output_attentions\n        self.n_head = n_head\n        self.d_model = d_model\n        self.d_head = d_head\n        self.dropout = dropout\n\n        self.q_net = nn.Linear(d_model, n_head * d_head, bias=False)\n        self.kv_net = nn.Linear(d_model, 2 * n_head * d_head, bias=False)\n\n        self.drop = nn.Dropout(dropout)\n        self.dropatt = nn.Dropout(dropatt)\n        self.o_net = nn.Linear(n_head * d_head, d_model, bias=False)\n\n        self.layer_norm = LayerNorm(d_model)\n\n        self.scale = 1 / (d_head ** 0.5)\n\n        self.pre_lnorm = pre_lnorm\n\n        if r_r_bias is None or r_w_bias is None: # Biases are not shared\n            self.r_r_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n            self.r_w_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        else:\n            self.r_r_bias = r_r_bias\n            self.r_w_bias = r_w_bias\n\n    def forward(self, h, attn_mask=None, mems=None, head_mask=None):\n        ##### multihead attention\n        # [hlen x bsz x n_head x d_head]\n\n        if mems is not None:\n            c = torch.cat([mems, h], 0)\n        else:\n            c = h\n\n        if self.pre_lnorm:\n            ##### layer normalization\n            c = self.layer_norm(c)\n\n        head_q = self.q_net(h)\n        head_k, head_v = torch.chunk(self.kv_net(c), 2, -1)\n\n        head_q = head_q.view(h.size(0), h.size(1), self.n_head, self.d_head)\n        head_k = head_k.view(c.size(0), c.size(1), self.n_head, self.d_head)\n        head_v = head_v.view(c.size(0), c.size(1), self.n_head, self.d_head)\n\n        # [qlen x klen x bsz x n_head]\n        attn_score = torch.einsum(\'ibnd,jbnd->ijbn\', (head_q, head_k))\n        attn_score.mul_(self.scale)\n        if attn_mask is not None and attn_mask.any().item():\n            if attn_mask.dim() == 2:\n                attn_score.masked_fill_(attn_mask[None,:,:,None], -float(\'inf\'))\n            elif attn_mask.dim() == 3:\n                attn_score.masked_fill_(attn_mask[:,:,:,None], -float(\'inf\'))\n\n        # [qlen x klen x bsz x n_head]\n        attn_prob = F.softmax(attn_score, dim=1)\n        attn_prob = self.dropatt(attn_prob)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attn_prob = attn_prob * head_mask\n\n        # [qlen x klen x bsz x n_head] + [klen x bsz x n_head x d_head] -> [qlen x bsz x n_head x d_head]\n        attn_vec = torch.einsum(\'ijbn,jbnd->ibnd\', (attn_prob, head_v))\n        attn_vec = attn_vec.contiguous().view(\n            attn_vec.size(0), attn_vec.size(1), self.n_head * self.d_head)\n\n        ##### linear projection\n        attn_out = self.o_net(attn_vec)\n        attn_out = self.drop(attn_out)\n\n        if self.pre_lnorm:\n            ##### residual connection\n            outputs = [h + attn_out]\n        else:\n            ##### residual connection + layer normalization\n            outputs = [self.layer_norm(h + attn_out)]\n\n        if self.output_attentions:\n            outputs.append(attn_prob)\n\n        return outputs\n\nclass RelMultiHeadAttn(nn.Module):\n    def __init__(self, n_head, d_model, d_head, dropout, dropatt=0,\n                 tgt_len=None, ext_len=None, mem_len=None, pre_lnorm=False,\n                 r_r_bias=None, r_w_bias=None, output_attentions=False):\n        super(RelMultiHeadAttn, self).__init__()\n\n        self.output_attentions = output_attentions\n        self.n_head = n_head\n        self.d_model = d_model\n        self.d_head = d_head\n        self.dropout = dropout\n\n        self.qkv_net = nn.Linear(d_model, 3 * n_head * d_head, bias=False)\n\n        self.drop = nn.Dropout(dropout)\n        self.dropatt = nn.Dropout(dropatt)\n        self.o_net = nn.Linear(n_head * d_head, d_model, bias=False)\n\n        self.layer_norm = LayerNorm(d_model)\n\n        self.scale = 1 / (d_head ** 0.5)\n\n        self.pre_lnorm = pre_lnorm\n\n        if r_r_bias is None or r_w_bias is None: # Biases are not shared\n            self.r_r_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n            self.r_w_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        else:\n            self.r_r_bias = r_r_bias\n            self.r_w_bias = r_w_bias\n\n    def _parallelogram_mask(self, h, w, left=False):\n        mask = torch.ones((h, w)).byte()\n        m = min(h, w)\n        mask[:m,:m] = torch.triu(mask[:m,:m])\n        mask[-m:,-m:] = torch.tril(mask[-m:,-m:])\n\n        if left:\n            return mask\n        else:\n            return mask.flip(0)\n\n    def _shift(self, x, qlen, klen, mask, left=False):\n        if qlen > 1:\n            zero_pad = torch.zeros((x.size(0), qlen-1, x.size(2), x.size(3)),\n                                    device=x.device, dtype=x.dtype)\n        else:\n            zero_pad = torch.zeros(0, device=x.device, dtype=x.dtype)\n\n        if left:\n            mask = mask.flip(1)\n            x_padded = torch.cat([zero_pad, x], dim=1).expand(qlen, -1, -1, -1)\n        else:\n            x_padded = torch.cat([x, zero_pad], dim=1).expand(qlen, -1, -1, -1)\n\n        x = x_padded.masked_select(mask[:,:,None,None]) \\\n                    .view(qlen, klen, x.size(2), x.size(3))\n\n        return x\n\n    def _rel_shift(self, x, zero_triu=False):\n        zero_pad_shape = (x.size(0), 1) + x.size()[2:]\n        zero_pad = torch.zeros(zero_pad_shape, device=x.device, dtype=x.dtype)\n        x_padded = torch.cat([zero_pad, x], dim=1)\n\n        x_padded_shape = (x.size(1) + 1, x.size(0)) + x.size()[2:]\n        x_padded = x_padded.view(*x_padded_shape)\n\n        x = x_padded[1:].view_as(x)\n\n        if zero_triu:\n            ones = torch.ones((x.size(0), x.size(1)))\n            x = x * torch.tril(ones, x.size(1) - x.size(0))[:,:,None,None]\n\n        return x\n\n    def forward(self, w, r, attn_mask=None, mems=None):\n        raise NotImplementedError\n\nclass RelPartialLearnableMultiHeadAttn(RelMultiHeadAttn):\n    def __init__(self, *args, **kwargs):\n        super(RelPartialLearnableMultiHeadAttn, self).__init__(*args, **kwargs)\n\n        self.r_net = nn.Linear(self.d_model, self.n_head * self.d_head, bias=False)\n\n    def forward(self, w, r, attn_mask=None, mems=None, head_mask=None):\n        qlen, rlen, bsz = w.size(0), r.size(0), w.size(1)\n\n        if mems is not None:\n            cat = torch.cat([mems, w], 0)\n            if self.pre_lnorm:\n                w_heads = self.qkv_net(self.layer_norm(cat))\n            else:\n                w_heads = self.qkv_net(cat)\n            r_head_k = self.r_net(r)\n\n            w_head_q, w_head_k, w_head_v = torch.chunk(w_heads, 3, dim=-1)\n            w_head_q = w_head_q[-qlen:]\n        else:\n            if self.pre_lnorm:\n                w_heads = self.qkv_net(self.layer_norm(w))\n            else:\n                w_heads = self.qkv_net(w)\n            r_head_k = self.r_net(r)\n\n            w_head_q, w_head_k, w_head_v = torch.chunk(w_heads, 3, dim=-1)\n\n        klen = w_head_k.size(0)\n\n        w_head_q = w_head_q.view(qlen, bsz, self.n_head, self.d_head)           # qlen x bsz x n_head x d_head\n        w_head_k = w_head_k.view(klen, bsz, self.n_head, self.d_head)           # qlen x bsz x n_head x d_head\n        w_head_v = w_head_v.view(klen, bsz, self.n_head, self.d_head)           # qlen x bsz x n_head x d_head\n\n        r_head_k = r_head_k.view(rlen, self.n_head, self.d_head)                # qlen x n_head x d_head\n\n        #### compute attention score\n        rw_head_q = w_head_q + self.r_w_bias                                    # qlen x bsz x n_head x d_head\n        AC = torch.einsum(\'ibnd,jbnd->ijbn\', (rw_head_q, w_head_k))             # qlen x klen x bsz x n_head\n\n        rr_head_q = w_head_q + self.r_r_bias\n        BD = torch.einsum(\'ibnd,jnd->ijbn\', (rr_head_q, r_head_k))              # qlen x klen x bsz x n_head\n        BD = self._rel_shift(BD)\n\n        # [qlen x klen x bsz x n_head]\n        attn_score = AC + BD\n        attn_score.mul_(self.scale)\n\n        #### compute attention probability\n        if attn_mask is not None and attn_mask.any().item():\n            if attn_mask.dim() == 2:\n                attn_score = attn_score.float().masked_fill(\n                    attn_mask[None,:,:,None], -1e30).type_as(attn_score)\n            elif attn_mask.dim() == 3:\n                attn_score = attn_score.float().masked_fill(\n                    attn_mask[:,:,:,None], -1e30).type_as(attn_score)\n\n        # [qlen x klen x bsz x n_head]\n        attn_prob = F.softmax(attn_score, dim=1)\n        attn_prob = self.dropatt(attn_prob)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attn_prob = attn_prob * head_mask\n\n        #### compute attention vector\n        attn_vec = torch.einsum(\'ijbn,jbnd->ibnd\', (attn_prob, w_head_v))\n\n        # [qlen x bsz x n_head x d_head]\n        attn_vec = attn_vec.contiguous().view(\n            attn_vec.size(0), attn_vec.size(1), self.n_head * self.d_head)\n\n        ##### linear projection\n        attn_out = self.o_net(attn_vec)\n        attn_out = self.drop(attn_out)\n\n        if self.pre_lnorm:\n            ##### residual connection\n            outputs = [w + attn_out]\n        else:\n            ##### residual connection + layer normalization\n            outputs = [self.layer_norm(w + attn_out)]\n\n        if self.output_attentions:\n            outputs.append(attn_prob)\n\n        return outputs\n\nclass RelLearnableMultiHeadAttn(RelMultiHeadAttn):\n    def __init__(self, *args, **kwargs):\n        super(RelLearnableMultiHeadAttn, self).__init__(*args, **kwargs)\n\n    def forward(self, w, r_emb, r_w_bias, r_bias, attn_mask=None, mems=None, head_mask=None):\n        # r_emb: [klen, n_head, d_head], used for term B\n        # r_w_bias: [n_head, d_head], used for term C\n        # r_bias: [klen, n_head], used for term D\n\n        qlen, bsz = w.size(0), w.size(1)\n\n        if mems is not None:\n            cat = torch.cat([mems, w], 0)\n            if self.pre_lnorm:\n                w_heads = self.qkv_net(self.layer_norm(cat))\n            else:\n                w_heads = self.qkv_net(cat)\n            w_head_q, w_head_k, w_head_v = torch.chunk(w_heads, 3, dim=-1)\n\n            w_head_q = w_head_q[-qlen:]\n        else:\n            if self.pre_lnorm:\n                w_heads = self.qkv_net(self.layer_norm(w))\n            else:\n                w_heads = self.qkv_net(w)\n            w_head_q, w_head_k, w_head_v = torch.chunk(w_heads, 3, dim=-1)\n\n        klen = w_head_k.size(0)\n\n        w_head_q = w_head_q.view(qlen, bsz, self.n_head, self.d_head)\n        w_head_k = w_head_k.view(klen, bsz, self.n_head, self.d_head)\n        w_head_v = w_head_v.view(klen, bsz, self.n_head, self.d_head)\n\n        if klen > r_emb.size(0):\n            r_emb_pad = r_emb[0:1].expand(klen-r_emb.size(0), -1, -1)\n            r_emb = torch.cat([r_emb_pad, r_emb], 0)\n            r_bias_pad = r_bias[0:1].expand(klen-r_bias.size(0), -1)\n            r_bias = torch.cat([r_bias_pad, r_bias], 0)\n        else:\n            r_emb = r_emb[-klen:]\n            r_bias = r_bias[-klen:]\n\n        #### compute attention score\n        rw_head_q = w_head_q + r_w_bias[None]                                   # qlen x bsz x n_head x d_head\n\n        AC = torch.einsum(\'ibnd,jbnd->ijbn\', (rw_head_q, w_head_k))             # qlen x klen x bsz x n_head\n        B_ = torch.einsum(\'ibnd,jnd->ijbn\', (w_head_q, r_emb))                  # qlen x klen x bsz x n_head\n        D_ = r_bias[None, :, None]                                              # 1    x klen x 1   x n_head\n        BD = self._rel_shift(B_ + D_)\n\n        # [qlen x klen x bsz x n_head]\n        attn_score = AC + BD\n        attn_score.mul_(self.scale)\n\n        #### compute attention probability\n        if attn_mask is not None and attn_mask.any().item():\n            if attn_mask.dim() == 2:\n                attn_score.masked_fill_(attn_mask[None,:,:,None], -float(\'inf\'))\n            elif attn_mask.dim() == 3:\n                attn_score.masked_fill_(attn_mask[:,:,:,None], -float(\'inf\'))\n\n        # [qlen x klen x bsz x n_head]\n        attn_prob = F.softmax(attn_score, dim=1)\n        attn_prob = self.dropatt(attn_prob)\n\n        if head_mask is not None:\n            attn_prob = attn_prob * head_mask\n\n        #### compute attention vector\n        attn_vec = torch.einsum(\'ijbn,jbnd->ibnd\', (attn_prob, w_head_v))\n\n        # [qlen x bsz x n_head x d_head]\n        attn_vec = attn_vec.contiguous().view(\n            attn_vec.size(0), attn_vec.size(1), self.n_head * self.d_head)\n\n        ##### linear projection\n        attn_out = self.o_net(attn_vec)\n        attn_out = self.drop(attn_out)\n\n        if self.pre_lnorm:\n            ##### residual connection\n            outputs = [w + attn_out]\n        else:\n            ##### residual connection + layer normalization\n            outputs = [self.layer_norm(w + attn_out)]\n\n        if self.output_attentions:\n            outputs.append(attn_prob)\n\n        return outputs\n\n\n\nclass DecoderLayer(nn.Module):\n    def __init__(self, n_head, d_model, d_head, d_inner, dropout, **kwargs):\n        super(DecoderLayer, self).__init__()\n\n        self.dec_attn = MultiHeadAttn(n_head, d_model, d_head, dropout, **kwargs)\n        self.pos_ff = PositionwiseFF(d_model, d_inner, dropout, \n                                     pre_lnorm=kwargs.get(\'pre_lnorm\'))\n\n    def forward(self, dec_inp, dec_attn_mask=None, mems=None, head_mask=None):\n\n        attn_outputs = self.dec_attn(dec_inp, attn_mask=dec_attn_mask,\n                               mems=mems, head_mask=head_mask)\n        ff_output = self.pos_ff(attn_outputs[0])\n\n        outputs = [ff_output] + attn_outputs[1:]\n\n        return outputs\n\nclass RelLearnableDecoderLayer(nn.Module):\n    def __init__(self, n_head, d_model, d_head, d_inner, dropout,\n                 **kwargs):\n        super(RelLearnableDecoderLayer, self).__init__()\n\n        self.dec_attn = RelLearnableMultiHeadAttn(n_head, d_model, d_head, dropout,\n                                         **kwargs)\n        self.pos_ff = PositionwiseFF(d_model, d_inner, dropout, \n                                     pre_lnorm=kwargs.get(\'pre_lnorm\'))\n\n    def forward(self, dec_inp, r_emb, r_w_bias, r_bias, dec_attn_mask=None, mems=None, head_mask=None):\n\n        attn_outputs = self.dec_attn(dec_inp, r_emb, r_w_bias, r_bias,\n                               attn_mask=dec_attn_mask,\n                               mems=mems, head_mask=head_mask)\n        ff_output = self.pos_ff(attn_outputs[0])\n\n        outputs = [ff_output] + attn_outputs[1:]\n\n        return outputs\n\nclass RelPartialLearnableDecoderLayer(nn.Module):\n    def __init__(self, n_head, d_model, d_head, d_inner, dropout,\n                 **kwargs):\n        super(RelPartialLearnableDecoderLayer, self).__init__()\n\n        self.dec_attn = RelPartialLearnableMultiHeadAttn(n_head, d_model,\n                            d_head, dropout, **kwargs)\n        self.pos_ff = PositionwiseFF(d_model, d_inner, dropout, \n                                     pre_lnorm=kwargs.get(\'pre_lnorm\'))\n\n    def forward(self, dec_inp, r, dec_attn_mask=None, mems=None, head_mask=None):\n\n        attn_outputs = self.dec_attn(dec_inp, r,\n                               attn_mask=dec_attn_mask,\n                               mems=mems, head_mask=head_mask)\n        ff_output = self.pos_ff(attn_outputs[0])\n\n        outputs = [ff_output] + attn_outputs[1:]\n\n        return outputs\n\n\n\nclass AdaptiveEmbedding(nn.Module):\n    def __init__(self, n_token, d_embed, d_proj, cutoffs, div_val=1, \n                 sample_softmax=False):\n        super(AdaptiveEmbedding, self).__init__()\n\n        self.n_token = n_token\n        self.d_embed = d_embed\n\n        self.cutoffs = cutoffs + [n_token]\n        self.div_val = div_val\n        self.d_proj = d_proj\n\n        self.emb_scale = d_proj ** 0.5\n\n        self.cutoff_ends = [0] + self.cutoffs\n\n        self.emb_layers = nn.ModuleList()\n        self.emb_projs = nn.ParameterList()\n        if div_val == 1:\n            self.emb_layers.append(\n                nn.Embedding(n_token, d_embed, sparse=sample_softmax>0)\n            )\n            if d_proj != d_embed:\n                self.emb_projs.append(nn.Parameter(torch.FloatTensor(d_proj, d_embed)))\n        else:\n            for i in range(len(self.cutoffs)):\n                l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i+1]\n                d_emb_i = d_embed // (div_val ** i)\n                self.emb_layers.append(nn.Embedding(r_idx-l_idx, d_emb_i))\n                self.emb_projs.append(nn.Parameter(torch.FloatTensor(d_proj, d_emb_i)))\n\n    def forward(self, inp):\n        if self.div_val == 1:\n            embed = self.emb_layers[0](inp)\n            if self.d_proj != self.d_embed:\n                embed  = F.linear(embed, self.emb_projs[0])\n        else:\n            param = next(self.parameters())\n            inp_flat = inp.view(-1)\n            emb_flat = torch.zeros([inp_flat.size(0), self.d_proj], \n                dtype=param.dtype, device=param.device)\n            for i in range(len(self.cutoffs)):\n                l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i + 1]\n\n                mask_i = (inp_flat >= l_idx) & (inp_flat < r_idx)\n                indices_i = mask_i.nonzero().squeeze()\n\n                if indices_i.numel() == 0:\n                    continue\n\n                inp_i = inp_flat.index_select(0, indices_i) - l_idx\n                emb_i = self.emb_layers[i](inp_i)\n                emb_i = F.linear(emb_i, self.emb_projs[i])\n\n                emb_flat.index_copy_(0, indices_i, emb_i)\n\n            embed_shape = inp.size() + (self.d_proj,)\n            embed = emb_flat.view(embed_shape)\n\n        embed.mul_(self.emb_scale)\n\n        return embed\n\n\nclass TransfoXLPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = TransfoXLConfig\n    pretrained_model_archive_map = TRANSFO_XL_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_transfo_xl\n    base_model_prefix = ""transformer""\n\n    def __init__(self, *inputs, **kwargs):\n        super(TransfoXLPreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def _init_weight(self, weight):\n        if self.config.init == \'uniform\':\n            nn.init.uniform_(weight, -self.config.init_range, self.config.init_range)\n        elif self.config.init == \'normal\':\n            nn.init.normal_(weight, 0.0, self.config.init_std)\n\n    def _init_bias(self, bias):\n        nn.init.constant_(bias, 0.0)\n\n    def init_weights(self, m):\n        """""" Initialize the weights.\n        """"""\n        classname = m.__class__.__name__\n        if classname.find(\'Linear\') != -1:\n            if hasattr(m, \'weight\') and m.weight is not None:\n                self._init_weight(m.weight)\n            if hasattr(m, \'bias\') and m.bias is not None:\n                self._init_bias(m.bias)\n        elif classname.find(\'AdaptiveEmbedding\') != -1:\n            if hasattr(m, \'emb_projs\'):\n                for i in range(len(m.emb_projs)):\n                    if m.emb_projs[i] is not None:\n                        nn.init.normal_(m.emb_projs[i], 0.0, self.config.proj_init_std)\n        elif classname.find(\'Embedding\') != -1:\n            if hasattr(m, \'weight\'):\n                self._init_weight(m.weight)\n        elif classname.find(\'ProjectedAdaptiveLogSoftmax\') != -1:\n            if hasattr(m, \'cluster_weight\') and m.cluster_weight is not None:\n                self._init_weight(m.cluster_weight)\n            if hasattr(m, \'cluster_bias\') and m.cluster_bias is not None:\n                self._init_bias(m.cluster_bias)\n            if hasattr(m, \'out_projs\'):\n                for i in range(len(m.out_projs)):\n                    if m.out_projs[i] is not None:\n                        nn.init.normal_(m.out_projs[i], 0.0, self.config.proj_init_std)\n        elif classname.find(\'LayerNorm\') != -1:\n            if hasattr(m, \'weight\'):\n                nn.init.normal_(m.weight, 1.0, self.config.init_std)\n            if hasattr(m, \'bias\') and m.bias is not None:\n                self._init_bias(m.bias)\n        else:\n            if hasattr(m, \'r_emb\'):\n                self._init_weight(m.r_emb)\n            if hasattr(m, \'r_w_bias\'):\n                self._init_weight(m.r_w_bias)\n            if hasattr(m, \'r_r_bias\'):\n                self._init_weight(m.r_r_bias)\n            if hasattr(m, \'r_bias\'):\n                self._init_bias(m.r_bias)\n\n    def set_num_special_tokens(self, num_special_tokens):\n        pass\n\n\nTRANSFO_XL_START_DOCSTRING = r""""""    The Transformer-XL model was proposed in\n    `Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context`_\n    by Zihang Dai*, Zhilin Yang*, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov.\n    It\'s a causal (uni-directional) transformer with relative positioning (sinuso\xc3\xafdal) embeddings which can reuse\n    previously computed hidden-states to attend to longer context (memory).\n    This model also uses adaptive softmax inputs and outputs (tied).\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context`:\n        https://arxiv.org/abs/1901.02860\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~pytorch_transformers.TransfoXLConfig`): Model configuration class with all the parameters of the model.\n""""""\n\nTRANSFO_XL_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            Indices can be obtained using :class:`pytorch_transformers.TransfoXLTokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **mems**: (`optional`)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` output below). Can be used to speed up sequential decoding and attend to longer context.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare Bert Model transformer outputing raw hidden-states without any specific head on top."",\n                      TRANSFO_XL_START_DOCSTRING, TRANSFO_XL_INPUTS_DOCSTRING)\nclass TransfoXLModel(TransfoXLPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = TransfoXLTokenizer.from_pretrained(\'transfo-xl-wt103\')\n        model = TransfoXLModel.from_pretrained(\'transfo-xl-wt103\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states, mems = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        raise NotImplementedError(""BertViz does not currently support Transformer-XL"")\n        super(TransfoXLModel, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        self.n_token = config.n_token\n\n        self.d_embed = config.d_embed\n        self.d_model = config.d_model\n        self.n_head = config.n_head\n        self.d_head = config.d_head\n\n        self.word_emb = AdaptiveEmbedding(config.n_token, config.d_embed, config.d_model, config.cutoffs, \n                                          div_val=config.div_val)\n\n        self.drop = nn.Dropout(config.dropout)\n\n        self.n_layer = config.n_layer\n\n        self.tgt_len = config.tgt_len\n        self.mem_len = config.mem_len\n        self.ext_len = config.ext_len\n        self.max_klen = config.tgt_len + config.ext_len + config.mem_len\n\n        self.attn_type = config.attn_type\n\n        if not config.untie_r:\n            self.r_w_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n            self.r_r_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n\n        self.layers = nn.ModuleList()\n        if config.attn_type == 0: # the default attention\n            for i in range(config.n_layer):\n                self.layers.append(\n                    RelPartialLearnableDecoderLayer(\n                        config.n_head, config.d_model, config.d_head, config.d_inner, config.dropout,\n                        tgt_len=config.tgt_len, ext_len=config.ext_len, mem_len=config.mem_len,\n                        dropatt=config.dropatt, pre_lnorm=config.pre_lnorm,\n                        r_w_bias=None if config.untie_r else self.r_w_bias,\n                        r_r_bias=None if config.untie_r else self.r_r_bias,\n                        output_attentions=self.output_attentions)\n                )\n        elif config.attn_type == 1: # learnable embeddings\n            for i in range(config.n_layer):\n                self.layers.append(\n                    RelLearnableDecoderLayer(\n                        config.n_head, config.d_model, config.d_head, config.d_inner, config.dropout,\n                        tgt_len=config.tgt_len, ext_len=config.ext_len, mem_len=config.mem_len,\n                        dropatt=config.dropatt, pre_lnorm=config.pre_lnorm,\n                        r_w_bias=None if config.untie_r else self.r_w_bias,\n                        r_r_bias=None if config.untie_r else self.r_r_bias,\n                        output_attentions=self.output_attentions)\n                )\n        elif config.attn_type in [2, 3]: # absolute embeddings\n            for i in range(config.n_layer):\n                self.layers.append(\n                    DecoderLayer(\n                        config.n_head, config.d_model, config.d_head, config.d_inner, config.dropout,\n                        dropatt=config.dropatt, pre_lnorm=config.pre_lnorm,\n                        r_w_bias=None if config.untie_r else self.r_w_bias,\n                        r_r_bias=None if config.untie_r else self.r_r_bias,\n                        output_attentions=self.output_attentions)\n                )\n\n        self.same_length = config.same_length\n        self.clamp_len = config.clamp_len\n\n        if self.attn_type == 0: # default attention\n            self.pos_emb = PositionalEmbedding(self.d_model)\n        elif self.attn_type == 1: # learnable\n            self.r_emb = nn.Parameter(torch.FloatTensor(\n                    self.n_layer, self.max_klen, self.n_head, self.d_head))\n            self.r_bias = nn.Parameter(torch.FloatTensor(\n                    self.n_layer, self.max_klen, self.n_head))\n        elif self.attn_type == 2: # absolute standard\n            self.pos_emb = PositionalEmbedding(self.d_model)\n        elif self.attn_type == 3: # absolute deeper SA\n            self.r_emb = nn.Parameter(torch.FloatTensor(\n                    self.n_layer, self.max_klen, self.n_head, self.d_head))\n\n        self.apply(self.init_weights)\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        return self.word_emb\n\n    def backward_compatible(self):\n        self.sample_softmax = -1\n\n    def reset_length(self, tgt_len, ext_len, mem_len):\n        self.tgt_len = tgt_len\n        self.mem_len = mem_len\n        self.ext_len = ext_len\n\n    def _prune_heads(self, heads):\n        logger.info(""Head pruning is not implemented for Transformer-XL model"")\n        pass\n\n    def init_mems(self, data):\n        if self.mem_len > 0:\n            mems = []\n            param = next(self.parameters())\n            for i in range(self.n_layer):\n                empty = torch.zeros(self.mem_len, data.size(1), self.config.d_model,\n                                    dtype=param.dtype, device=param.device)\n                mems.append(empty)\n\n            return mems\n        else:\n            return None\n\n    def _update_mems(self, hids, mems, qlen, mlen):\n        # does not deal with None\n        if mems is None: return None\n\n        # mems is not None\n        assert len(hids) == len(mems), \'len(hids) != len(mems)\'\n\n        # There are `mlen + qlen` steps that can be cached into mems\n        # For the next step, the last `ext_len` of the `qlen` tokens\n        # will be used as the extended context. Hence, we only cache\n        # the tokens from `mlen + qlen - self.ext_len - self.mem_len`\n        # to `mlen + qlen - self.ext_len`.\n        with torch.no_grad():\n            new_mems = []\n            end_idx = mlen + max(0, qlen - 0 - self.ext_len)\n            beg_idx = max(0, end_idx - self.mem_len)\n            for i in range(len(hids)):\n\n                cat = torch.cat([mems[i], hids[i]], dim=0)\n                new_mems.append(cat[beg_idx:end_idx].detach())\n\n        return new_mems\n\n    def _forward(self, dec_inp, mems=None, head_mask=None):\n        qlen, bsz = dec_inp.size()\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads] (a head_mask for each layer)\n        # and head_mask is converted to shape [num_hidden_layers x qlen x klen x bsz x n_head]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(0).unsqueeze(0)\n                head_mask = head_mask.expand(self.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(1).unsqueeze(1)\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.n_layer\n\n        word_emb = self.word_emb(dec_inp)\n\n        mlen = mems[0].size(0) if mems is not None else 0\n        klen = mlen + qlen\n        if self.same_length:\n            all_ones = word_emb.new_ones(qlen, klen)\n            mask_len = klen - self.mem_len\n            if mask_len > 0:\n                mask_shift_len = qlen - mask_len\n            else:\n                mask_shift_len = qlen\n            dec_attn_mask = (torch.triu(all_ones, 1+mlen)\n                    + torch.tril(all_ones, -mask_shift_len)).byte()[:, :, None] # -1\n        else:\n            dec_attn_mask = torch.triu(\n                word_emb.new_ones(qlen, klen), diagonal=1+mlen).byte()[:,:,None]\n\n        hids = []\n        attentions = []\n        if self.attn_type == 0: # default\n            pos_seq = torch.arange(klen-1, -1, -1.0, device=word_emb.device, \n                                   dtype=word_emb.dtype)\n            if self.clamp_len > 0:\n                pos_seq.clamp_(max=self.clamp_len)\n            pos_emb = self.pos_emb(pos_seq)\n\n            core_out = self.drop(word_emb)\n            pos_emb = self.drop(pos_emb)\n\n            for i, layer in enumerate(self.layers):\n                hids.append(core_out)\n                mems_i = None if mems is None else mems[i]\n                layer_outputs = layer(core_out, pos_emb, dec_attn_mask=dec_attn_mask,\n                                      mems=mems_i, head_mask=head_mask[i])\n                core_out = layer_outputs[0]\n                if self.output_attentions:\n                    attentions.append(layer_outputs[1])\n        elif self.attn_type == 1: # learnable\n            core_out = self.drop(word_emb)\n            for i, layer in enumerate(self.layers):\n                hids.append(core_out)\n                if self.clamp_len > 0:\n                    r_emb = self.r_emb[i][-self.clamp_len :]\n                    r_bias = self.r_bias[i][-self.clamp_len :]\n                else:\n                    r_emb, r_bias = self.r_emb[i], self.r_bias[i]\n\n                mems_i = None if mems is None else mems[i]\n                layer_outputs = layer(core_out, r_emb, self.r_w_bias[i],\n                                      r_bias, dec_attn_mask=dec_attn_mask,\n                                      mems=mems_i, head_mask=head_mask[i])\n                core_out = layer_outputs[0]\n                if self.output_attentions:\n                    attentions.append(layer_outputs[1])\n        elif self.attn_type == 2: # absolute\n            pos_seq = torch.arange(klen - 1, -1, -1.0, device=word_emb.device,\n                                   dtype=word_emb.dtype)\n            if self.clamp_len > 0:\n                pos_seq.clamp_(max=self.clamp_len)\n            pos_emb = self.pos_emb(pos_seq)\n\n            core_out = self.drop(word_emb + pos_emb[-qlen:])\n\n            for i, layer in enumerate(self.layers):\n                hids.append(core_out)\n                mems_i = None if mems is None else mems[i]\n                if mems_i is not None and i == 0:\n                    mems_i += pos_emb[:mlen]\n                layer_outputs = layer(core_out, dec_attn_mask=dec_attn_mask,\n                                 mems=mems_i, head_mask=head_mask[i])\n                core_out = layer_outputs[0]\n                if self.output_attentions:\n                    attentions.append(layer_outputs[1])\n        elif self.attn_type == 3:\n            core_out = self.drop(word_emb)\n\n            for i, layer in enumerate(self.layers):\n                hids.append(core_out)\n                mems_i = None if mems is None else mems[i]\n                if mems_i is not None and mlen > 0:\n                    cur_emb = self.r_emb[i][:-qlen]\n                    cur_size = cur_emb.size(0)\n                    if cur_size < mlen:\n                        cur_emb_pad = cur_emb[0:1].expand(mlen-cur_size, -1, -1)\n                        cur_emb = torch.cat([cur_emb_pad, cur_emb], 0)\n                    else:\n                        cur_emb = cur_emb[-mlen:]\n                    mems_i += cur_emb.view(mlen, 1, -1)\n                core_out += self.r_emb[i][-qlen:].view(qlen, 1, -1)\n\n                layer_outputs = layer(core_out, dec_attn_mask=dec_attn_mask,\n                                      mems=mems_i, head_mask=head_mask[i])\n                core_out = layer_outputs[0]\n                if self.output_attentions:\n                    attentions.append(layer_outputs[1])\n\n        core_out = self.drop(core_out)\n\n        new_mems = self._update_mems(hids, mems, mlen, qlen)\n\n        # We transpose back here to shape [bsz, len, hidden_dim]\n        outputs = [core_out.transpose(0, 1).contiguous(), new_mems]\n        if self.output_hidden_states:\n            # Add last layer and transpose to library standard shape [bsz, len, hidden_dim]\n            hids.append(core_out)\n            hids = list(t.transpose(0, 1).contiguous() for t in hids)\n            outputs.append(hids)\n        if self.output_attentions:\n            # Transpose to library standard shape [bsz, n_heads, query_seq_len, key_seq_len]\n            attentions = list(t.permute(2, 3, 0, 1).contiguous() for t in attentions)\n            outputs.append(attentions)\n        return outputs  # last hidden state, new_mems, (all hidden states), (all attentions)\n\n    def forward(self, input_ids, mems=None, head_mask=None):\n        # the original code for Transformer-XL used shapes [len, bsz] but we want a unified interface in the library\n        # so we transpose here from shape [bsz, len] to shape [len, bsz]\n        input_ids = input_ids.transpose(0, 1).contiguous()\n\n        if mems is None:\n            mems = self.init_mems(input_ids)\n        outputs = self._forward(input_ids, mems=mems, head_mask=head_mask)\n\n        return outputs  # last hidden state, new_mems, (all hidden states), (all attentions)\n\n\n@add_start_docstrings(""""""The Transformer-XL Model with a language modeling head on top\n    (adaptive softmax with weights tied to the adaptive input embeddings)"""""",\n    TRANSFO_XL_START_DOCSTRING, TRANSFO_XL_INPUTS_DOCSTRING)\nclass TransfoXLLMHeadModel(TransfoXLPreTrainedModel):\n    r""""""\n        **lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``None`` if ``lm_labels`` is provided else ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n            We don\'t output them when the loss is computed to speedup adaptive softmax decoding.\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = TransfoXLTokenizer.from_pretrained(\'transfo-xl-wt103\')\n        model = TransfoXLLMHeadModel.from_pretrained(\'transfo-xl-wt103\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        prediction_scores, mems = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(TransfoXLLMHeadModel, self).__init__(config)\n        self.transformer = TransfoXLModel(config)\n        self.sample_softmax = config.sample_softmax\n        # use sampled softmax\n        if config.sample_softmax > 0:\n            self.out_layer = nn.Linear(config.d_model, config.n_token)\n            self.sampler = LogUniformSampler(config.n_token, config.sample_softmax)\n        # use adaptive softmax (including standard softmax)\n        else:\n            self.crit = ProjectedAdaptiveLogSoftmax(config.n_token, config.d_embed, config.d_model, \n                                                    config.cutoffs, div_val=config.div_val)\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """"""\n        Run this to be sure output and input (adaptive) softmax weights are tied\n        """"""\n        # sampled softmax\n        if self.sample_softmax > 0:\n            if self.config.tie_weight:\n                self.out_layer.weight = self.transformer.word_emb.weight\n        # adaptive softmax (including standard softmax)\n        else:\n            if self.config.tie_weight:\n                for i in range(len(self.crit.out_layers)):\n                    self._tie_or_clone_weights(self.crit.out_layers[i],\n                                               self.transformer.word_emb.emb_layers[i])\n            if self.config.tie_projs:\n                for i, tie_proj in enumerate(self.config.tie_projs):\n                    if tie_proj and self.config.div_val == 1 and self.config.d_model != self.config.d_embed:\n                        if self.config.torchscript:\n                            self.crit.out_projs[i] = nn.Parameter(self.transformer.word_emb.emb_projs[0].clone())\n                        else:\n                            self.crit.out_projs[i] = self.transformer.word_emb.emb_projs[0]\n                    elif tie_proj and self.config.div_val != 1:\n                        if self.config.torchscript:\n                            self.crit.out_projs[i] = nn.Parameter(self.transformer.word_emb.emb_projs[i].clone())\n                        else:\n                            self.crit.out_projs[i] = self.transformer.word_emb.emb_projs[i]\n\n    def reset_length(self, tgt_len, ext_len, mem_len):\n        self.transformer.reset_length(tgt_len, ext_len, mem_len)\n\n    def init_mems(self, data):\n        return self.transformer.init_mems(data)\n\n    def forward(self, input_ids, labels=None, mems=None, head_mask=None):\n        bsz = input_ids.size(0)\n        tgt_len = input_ids.size(1)\n\n        transformer_outputs = self.transformer(input_ids, mems=mems, head_mask=head_mask)\n\n        last_hidden = transformer_outputs[0]\n        pred_hid = last_hidden[:, -tgt_len:]\n        outputs = transformer_outputs[1:]\n        if self.sample_softmax > 0 and self.training:\n            assert self.config.tie_weight\n            logit = sample_logits(self.transformer.word_emb, self.out_layer.bias, labels, pred_hid, self.sampler)\n            softmax_output = -F.log_softmax(logit, -1)[:, :, 0]\n            outputs = [softmax_output] + outputs\n            if labels is not None:\n                # TODO: This is not implemented\n                raise NotImplementedError\n        else:\n            softmax_output = self.crit(pred_hid.view(-1, pred_hid.size(-1)), labels)\n            if labels is None:\n                softmax_output = softmax_output.view(bsz, tgt_len, -1)\n                outputs = [softmax_output] + outputs\n            else:\n                softmax_output = softmax_output.view(bsz, tgt_len)\n                outputs = [softmax_output, None] + outputs\n\n        return outputs  # (loss), logits or None if labels is not None (speed up adaptive softmax), new_mems, (all hidden states), (all attentions)\n'"
bertviz/transformers_neuron_view/modeling_transfo_xl_utilities.py,23,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Utilities for PyTorch Transformer XL model.\n    Directly adapted from https://github.com/kimiyoung/transformer-xl.\n""""""\n\nfrom collections import defaultdict\n\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n# CUDA_MAJOR = int(torch.version.cuda.split(\'.\')[0])\n# CUDA_MINOR = int(torch.version.cuda.split(\'.\')[1])\n\nclass ProjectedAdaptiveLogSoftmax(nn.Module):\n    def __init__(self, n_token, d_embed, d_proj, cutoffs, div_val=1,\n                 keep_order=False):\n        super(ProjectedAdaptiveLogSoftmax, self).__init__()\n\n        self.n_token = n_token\n        self.d_embed = d_embed\n        self.d_proj = d_proj\n\n        self.cutoffs = cutoffs + [n_token]\n        self.cutoff_ends = [0] + self.cutoffs\n        self.div_val = div_val\n\n        self.shortlist_size = self.cutoffs[0]\n        self.n_clusters = len(self.cutoffs) - 1\n        self.head_size = self.shortlist_size + self.n_clusters\n\n        if self.n_clusters > 0:\n            self.cluster_weight = nn.Parameter(torch.zeros(self.n_clusters, self.d_embed))\n            self.cluster_bias = nn.Parameter(torch.zeros(self.n_clusters))\n\n        self.out_layers = nn.ModuleList()\n        self.out_projs = nn.ParameterList()\n\n        if div_val == 1:\n            for i in range(len(self.cutoffs)):\n                if d_proj != d_embed:\n                    self.out_projs.append(\n                        nn.Parameter(torch.FloatTensor(d_proj, d_embed))\n                    )\n                else:\n                    self.out_projs.append(None)\n\n            self.out_layers.append(nn.Linear(d_embed, n_token))\n        else:\n            for i in range(len(self.cutoffs)):\n                l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i+1]\n                d_emb_i = d_embed // (div_val ** i)\n\n                self.out_projs.append(\n                    nn.Parameter(torch.FloatTensor(d_proj, d_emb_i))\n                )\n\n                self.out_layers.append(nn.Linear(d_emb_i, r_idx-l_idx))\n\n        self.keep_order = keep_order\n\n    def _compute_logit(self, hidden, weight, bias, proj):\n        if proj is None:\n            logit = F.linear(hidden, weight, bias=bias)\n        else:\n            # if CUDA_MAJOR <= 9 and CUDA_MINOR <= 1:\n            proj_hid = F.linear(hidden, proj.t().contiguous())\n            logit = F.linear(proj_hid, weight, bias=bias)\n            # else:\n            #     logit = torch.einsum(\'bd,de,ev->bv\', (hidden, proj, weight.t()))\n            #     if bias is not None:\n            #         logit = logit + bias\n\n        return logit\n\n    def forward(self, hidden, labels=None, keep_order=False):\n        \'\'\'\n            Params:\n                hidden :: [len*bsz x d_proj]\n                labels :: [len*bsz]\n            Return:\n                if labels is None:\n                    out :: [len*bsz] Negative log likelihood\n                else:\n                    out :: [len*bsz x n_tokens] log probabilities of tokens over the vocabulary\n            We could replace this implementation by the native PyTorch one\n            if their\'s had an option to set bias on all clusters in the native one.\n            here: https://github.com/pytorch/pytorch/blob/dbe6a7a9ff1a364a8706bf5df58a1ca96d2fd9da/torch/nn/modules/adaptive.py#L138\n        \'\'\'\n\n        if labels is not None:\n            labels = labels.view(-1)\n            if hidden.size(0) != labels.size(0):\n                raise RuntimeError(\'Input and labels should have the same size \'\n                                \'in the batch dimension.\')\n\n        if self.n_clusters == 0:\n            logit = self._compute_logit(hidden, self.out_layers[0].weight,\n                                        self.out_layers[0].bias, self.out_projs[0])\n            if labels is not None:\n                out = -F.log_softmax(logit, dim=-1) \\\n                        .gather(1, labels.unsqueeze(1)).squeeze(1)\n            else:\n                out = F.log_softmax(logit, dim=-1)\n        else:\n            # construct weights and biases\n            weights, biases = [], []\n            for i in range(len(self.cutoffs)):\n                if self.div_val == 1:\n                    l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i + 1]\n                    weight_i = self.out_layers[0].weight[l_idx:r_idx]\n                    bias_i = self.out_layers[0].bias[l_idx:r_idx]\n                else:\n                    weight_i = self.out_layers[i].weight\n                    bias_i = self.out_layers[i].bias\n\n                if i == 0:\n                    weight_i = torch.cat(\n                        [weight_i, self.cluster_weight], dim=0)\n                    bias_i = torch.cat(\n                        [bias_i, self.cluster_bias], dim=0)\n\n                weights.append(weight_i)\n                biases.append(bias_i)\n\n            head_weight, head_bias, head_proj = weights[0], biases[0], self.out_projs[0]\n\n            head_logit = self._compute_logit(hidden, head_weight, head_bias, head_proj)\n            head_logprob = F.log_softmax(head_logit, dim=1)\n\n            if labels is None:\n                out = hidden.new_empty((head_logit.size(0), self.n_token))\n            else:\n                out = torch.zeros_like(labels, dtype=hidden.dtype, device=hidden.device)\n\n            offset = 0\n            cutoff_values = [0] + self.cutoffs\n            for i in range(len(cutoff_values) - 1):\n                l_idx, r_idx = cutoff_values[i], cutoff_values[i + 1]\n\n                if labels is not None:\n                    mask_i = (labels >= l_idx) & (labels < r_idx)\n                    indices_i = mask_i.nonzero().squeeze()\n\n                    if indices_i.numel() == 0:\n                        continue\n\n                    target_i = labels.index_select(0, indices_i) - l_idx\n                    head_logprob_i = head_logprob.index_select(0, indices_i)\n                    hidden_i = hidden.index_select(0, indices_i)\n                else:\n                    hidden_i = hidden\n\n                if i == 0:\n                    if labels is not None:\n                        logprob_i = head_logprob_i.gather(1, target_i[:, None]).squeeze(1)\n                    else:\n                        out[:, :self.cutoffs[0]] = head_logprob[:, :self.cutoffs[0]]\n                else:\n                    weight_i, bias_i, proj_i = weights[i], biases[i], self.out_projs[i]\n\n                    tail_logit_i = self._compute_logit(hidden_i, weight_i, bias_i, proj_i)\n                    tail_logprob_i = F.log_softmax(tail_logit_i, dim=1)\n                    cluster_prob_idx = self.cutoffs[0] + i - 1  # No probability for the head cluster\n                    if labels is not None:\n                        logprob_i = head_logprob_i[:, cluster_prob_idx] \\\n                                + tail_logprob_i.gather(1, target_i[:, None]).squeeze(1)\n                    else:\n                        logprob_i = head_logprob[:, cluster_prob_idx, None] + tail_logprob_i\n                        out[:, l_idx:r_idx] = logprob_i\n\n                if labels is not None:\n                    if (hasattr(self, \'keep_order\') and self.keep_order) or keep_order:\n                        out.index_copy_(0, indices_i, -logprob_i)\n                    else:\n                        out[offset:offset+logprob_i.size(0)].copy_(-logprob_i)\n                    offset += logprob_i.size(0)\n\n        return out\n\n\n    def log_prob(self, hidden):\n        r"""""" Computes log probabilities for all :math:`n\\_classes`\n        From: https://github.com/pytorch/pytorch/blob/master/torch/nn/modules/adaptive.py\n        Args:\n            hidden (Tensor): a minibatch of examples\n        Returns:\n            log-probabilities of for each class :math:`c`\n            in range :math:`0 <= c <= n\\_classes`, where :math:`n\\_classes` is a\n            parameter passed to ``AdaptiveLogSoftmaxWithLoss`` constructor.\n        Shape:\n            - Input: :math:`(N, in\\_features)`\n            - Output: :math:`(N, n\\_classes)`\n        """"""\n        if self.n_clusters == 0:\n            logit = self._compute_logit(hidden, self.out_layers[0].weight,\n                                        self.out_layers[0].bias, self.out_projs[0])\n            return F.log_softmax(logit, dim=-1)\n        else:\n            # construct weights and biases\n            weights, biases = [], []\n            for i in range(len(self.cutoffs)):\n                if self.div_val == 1:\n                    l_idx, r_idx = self.cutoff_ends[i], self.cutoff_ends[i + 1]\n                    weight_i = self.out_layers[0].weight[l_idx:r_idx]\n                    bias_i = self.out_layers[0].bias[l_idx:r_idx]\n                else:\n                    weight_i = self.out_layers[i].weight\n                    bias_i = self.out_layers[i].bias\n\n                if i == 0:\n                    weight_i = torch.cat(\n                        [weight_i, self.cluster_weight], dim=0)\n                    bias_i = torch.cat(\n                        [bias_i, self.cluster_bias], dim=0)\n\n                weights.append(weight_i)\n                biases.append(bias_i)\n\n            head_weight, head_bias, head_proj = weights[0], biases[0], self.out_projs[0]\n            head_logit = self._compute_logit(hidden, head_weight, head_bias, head_proj)\n\n            out = hidden.new_empty((head_logit.size(0), self.n_token))\n            head_logprob = F.log_softmax(head_logit, dim=1)\n\n            cutoff_values = [0] + self.cutoffs\n            for i in range(len(cutoff_values) - 1):\n                start_idx, stop_idx = cutoff_values[i], cutoff_values[i + 1]\n\n                if i == 0:\n                    out[:, :self.cutoffs[0]] = head_logprob[:, :self.cutoffs[0]]\n                else:\n                    weight_i, bias_i, proj_i = weights[i], biases[i], self.out_projs[i]\n\n                    tail_logit_i = self._compute_logit(hidden, weight_i, bias_i, proj_i)\n                    tail_logprob_i = F.log_softmax(tail_logit_i, dim=1)\n\n                    logprob_i = head_logprob[:, -i] + tail_logprob_i\n                    out[:, start_idx, stop_idx] = logprob_i\n\n            return out\n\n\nclass LogUniformSampler(object):\n    def __init__(self, range_max, n_sample):\n        """"""\n        Reference : https://github.com/tensorflow/tensorflow/blob/r1.10/tensorflow/python/ops/candidate_sampling_ops.py\n            `P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)`\n\n        expected count can be approximated by 1 - (1 - p)^n\n        and we use a numerically stable version -expm1(num_tries * log1p(-p))\n\n        Our implementation fixes num_tries at 2 * n_sample, and the actual #samples will vary from run to run\n        """"""\n        with torch.no_grad():\n            self.range_max = range_max\n            log_indices = torch.arange(1., range_max+2., 1.).log_()\n            self.dist = (log_indices[1:] - log_indices[:-1]) / log_indices[-1]\n\n            self.log_q = (- (-self.dist.double().log1p_() * 2 * n_sample).expm1_()).log_().float()\n\n        self.n_sample = n_sample\n\n    def sample(self, labels):\n        """"""\n            labels: [b1, b2]\n        Return\n            true_log_probs: [b1, b2]\n            samp_log_probs: [n_sample]\n            neg_samples: [n_sample]\n        """"""\n\n        # neg_samples = torch.empty(0).long()\n        n_sample = self.n_sample\n        n_tries = 2 * n_sample\n\n        with torch.no_grad():\n            neg_samples = torch.multinomial(self.dist, n_tries, replacement=True).unique()\n            device = labels.device\n            neg_samples = neg_samples.to(device)\n            true_log_probs = self.log_q[labels].to(device)\n            samp_log_probs = self.log_q[neg_samples].to(device)\n            return true_log_probs, samp_log_probs, neg_samples\n\ndef sample_logits(embedding, bias, labels, inputs, sampler):\n    """"""\n        embedding: an nn.Embedding layer\n        bias: [n_vocab]\n        labels: [b1, b2]\n        inputs: [b1, b2, n_emb]\n        sampler: you may use a LogUniformSampler\n    Return\n        logits: [b1, b2, 1 + n_sample]\n    """"""\n    true_log_probs, samp_log_probs, neg_samples = sampler.sample(labels)\n    n_sample = neg_samples.size(0)\n    b1, b2 = labels.size(0), labels.size(1)\n    all_ids = torch.cat([labels.view(-1), neg_samples])\n    all_w = embedding(all_ids)\n    true_w = all_w[: -n_sample].view(b1, b2, -1)\n    sample_w = all_w[- n_sample:].view(n_sample, -1)\n\n    all_b = bias[all_ids]\n    true_b = all_b[: -n_sample].view(b1, b2)\n    sample_b = all_b[- n_sample:]\n\n    hit = (labels[:, :, None] == neg_samples).detach()\n\n    true_logits = torch.einsum(\'ijk,ijk->ij\',\n        [true_w, inputs]) + true_b - true_log_probs\n    sample_logits = torch.einsum(\'lk,ijk->ijl\',\n        [sample_w, inputs]) + sample_b - samp_log_probs\n    sample_logits.masked_fill_(hit, -1e30)\n    logits = torch.cat([true_logits[:, :, None], sample_logits], -1)\n\n    return logits\n'"
bertviz/transformers_neuron_view/modeling_utils.py,37,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# Change log\n# 7/14/19  Jesse Vig   Adapted for use in visualization\n\n""""""PyTorch BERT model.""""""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport copy\nimport json\nimport logging\nimport os\nfrom io import open\n\nimport six\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn import functional as F\n\nfrom .file_utils import cached_path\n\nlogger = logging.getLogger(__name__)\n\nCONFIG_NAME = ""config.json""\nWEIGHTS_NAME = ""pytorch_model.bin""\nTF_WEIGHTS_NAME = \'model.ckpt\'\n\n\ntry:\n    from torch.nn import Identity\nexcept ImportError:\n    # Older PyTorch compatibility\n    class Identity(nn.Module):\n        r""""""A placeholder identity operator that is argument-insensitive.\n        """"""\n        def __init__(self, *args, **kwargs):\n            super(Identity, self).__init__()\n\n        def forward(self, input):\n            return input\n\n\nif not six.PY2:\n    def add_start_docstrings(*docstr):\n        def docstring_decorator(fn):\n            fn.__doc__ = \'\'.join(docstr) + fn.__doc__\n            return fn\n        return docstring_decorator\nelse:\n    # Not possible to update class docstrings on python2\n    def add_start_docstrings(*docstr):\n        def docstring_decorator(fn):\n            return fn\n        return docstring_decorator\n\n\nclass PretrainedConfig(object):\n    r"""""" Base class for all configuration classes.\n        Handles a few parameters common to all models\' configurations as well as methods for loading/downloading/saving configurations.\n\n        Class attributes (overridden by derived classes):\n            - ``pretrained_config_archive_map``: a python ``dict`` of with `short-cut-names` (string) as keys and `url` (string) of associated pretrained model configurations as values.\n\n        Parameters:\n            ``finetuning_task``: string, default `None`. Name of the task used to fine-tune the model. This can be used when converting from an original (TensorFlow or PyTorch) checkpoint.\n            ``num_labels``: integer, default `2`. Number of classes to use when the model is a classification model (sequences/tokens)\n            ``output_attentions``: boolean, default `False`. Should the model returns attentions weights.\n            ``output_hidden_states``: string, default `False`. Should the model returns all hidden-states.\n            ``torchscript``: string, default `False`. Is the model used with Torchscript.\n    """"""\n    pretrained_config_archive_map = {}\n\n    def __init__(self, **kwargs):\n        self.finetuning_task = kwargs.pop(\'finetuning_task\', None)\n        self.num_labels = kwargs.pop(\'num_labels\', 2)\n        self.output_attentions = kwargs.pop(\'output_attentions\', False)\n        self.output_hidden_states = kwargs.pop(\'output_hidden_states\', False)\n        self.torchscript = kwargs.pop(\'torchscript\', False)\n\n    def save_pretrained(self, save_directory):\n        """""" Save a configuration object to the directory `save_directory`, so that it\n            can be re-loaded using the :func:`~pytorch_transformers.PretrainedConfig.from_pretrained` class method.\n        """"""\n        assert os.path.isdir(save_directory), ""Saving path should be a directory where the model and configuration can be saved""\n\n        # If we save using the predefined names, we can load using `from_pretrained`\n        output_config_file = os.path.join(save_directory, CONFIG_NAME)\n\n        self.to_json_file(output_config_file)\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, **kwargs):\n        r"""""" Instantiate a :class:`~pytorch_transformers.PretrainedConfig` (or a derived class) from a pre-trained model configuration.\n\n        Parameters:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model configuration to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing a configuration file saved using the :func:`~pytorch_transformers.PretrainedConfig.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - a path or url to a saved configuration JSON `file`, e.g.: ``./my_model_directory/configuration.json``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            kwargs: (`optional`) dict: key/value pairs with which to update the configuration object after loading.\n\n                - The values in kwargs of any keys which are configuration attributes will be used to override the loaded values.\n                - Behavior concerning key/value pairs whose keys are *not* configuration attributes is controlled by the `return_unused_kwargs` keyword parameter.\n\n            return_unused_kwargs: (`optional`) bool:\n\n                - If False, then this function returns just the final configuration object.\n                - If True, then this functions returns a tuple `(config, unused_kwargs)` where `unused_kwargs` is a dictionary consisting of the key/value pairs whose keys are not configuration attributes: ie the part of kwargs which has not been used to update `config` and is otherwise ignored.\n\n        Examples::\n\n            # We can\'t instantiate directly the base class `PretrainedConfig` so let\'s show the examples on a\n            # derived class: BertConfig\n            config = BertConfig.from_pretrained(\'bert-base-uncased\')    # Download configuration from S3 and cache.\n            config = BertConfig.from_pretrained(\'./test/saved_model/\')  # E.g. config (or model) was saved using `save_pretrained(\'./test/saved_model/\')`\n            config = BertConfig.from_pretrained(\'./test/saved_model/my_configuration.json\')\n            config = BertConfig.from_pretrained(\'bert-base-uncased\', output_attention=True, foo=False)\n            assert config.output_attention == True\n            config, unused_kwargs = BertConfig.from_pretrained(\'bert-base-uncased\', output_attention=True,\n                                                               foo=False, return_unused_kwargs=True)\n            assert config.output_attention == True\n            assert unused_kwargs == {\'foo\': False}\n\n        """"""\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        return_unused_kwargs = kwargs.pop(\'return_unused_kwargs\', False)\n\n        if pretrained_model_name_or_path in cls.pretrained_config_archive_map:\n            config_file = cls.pretrained_config_archive_map[pretrained_model_name_or_path]\n        elif os.path.isdir(pretrained_model_name_or_path):\n            config_file = os.path.join(pretrained_model_name_or_path, CONFIG_NAME)\n        else:\n            config_file = pretrained_model_name_or_path\n        # redirect to the cache, if necessary\n        try:\n            resolved_config_file = cached_path(config_file, cache_dir=cache_dir)\n        except EnvironmentError:\n            if pretrained_model_name_or_path in cls.pretrained_config_archive_map:\n                logger.error(\n                    ""Couldn\'t reach server at \'{}\' to download pretrained model configuration file."".format(\n                        config_file))\n            else:\n                logger.error(\n                    ""Model name \'{}\' was not found in model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url but couldn\'t find any file ""\n                    ""associated to this path or url."".format(\n                        pretrained_model_name_or_path,\n                        \', \'.join(cls.pretrained_config_archive_map.keys()),\n                        config_file))\n            return None\n        if resolved_config_file == config_file:\n            logger.info(""loading configuration file {}"".format(config_file))\n        else:\n            logger.info(""loading configuration file {} from cache at {}"".format(\n                config_file, resolved_config_file))\n\n        # Load config\n        config = cls.from_json_file(resolved_config_file)\n\n        # Update config with kwargs if needed\n        to_remove = []\n        for key, value in kwargs.items():\n            if hasattr(config, key):\n                setattr(config, key, value)\n                to_remove.append(key)\n        for key in to_remove:\n            kwargs.pop(key, None)\n\n        logger.info(""Model config %s"", config)\n        if return_unused_kwargs:\n            return config, kwargs\n        else:\n            return config\n\n    @classmethod\n    def from_dict(cls, json_object):\n        """"""Constructs a `Config` from a Python dictionary of parameters.""""""\n        config = cls(vocab_size_or_config_json_file=-1)\n        for key, value in json_object.items():\n            config.__dict__[key] = value\n        return config\n\n    @classmethod\n    def from_json_file(cls, json_file):\n        """"""Constructs a `BertConfig` from a json file of parameters.""""""\n        with open(json_file, ""r"", encoding=\'utf-8\') as reader:\n            text = reader.read()\n        return cls.from_dict(json.loads(text))\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n    def to_json_file(self, json_file_path):\n        """""" Save this instance to a json file.""""""\n        with open(json_file_path, ""w"", encoding=\'utf-8\') as writer:\n            writer.write(self.to_json_string())\n\n\nclass PreTrainedModel(nn.Module):\n    r"""""" Base class for all models.\n\n        :class:`~pytorch_transformers.PreTrainedModel` takes care of storing the configuration of the models and handles methods for loading/downloading/saving models\n        as well as a few methods commons to all models to (i) resize the input embeddings and (ii) prune heads in the self-attention heads.\n\n        Class attributes (overridden by derived classes):\n            - ``config_class``: a class derived from :class:`~pytorch_transformers.PretrainedConfig` to use as configuration class for this model architecture.\n            - ``pretrained_model_archive_map``: a python ``dict`` of with `short-cut-names` (string) as keys and `url` (string) of associated pretrained weights as values.\n            - ``load_tf_weights``: a python ``method`` for loading a TensorFlow checkpoint in a PyTorch model, taking as arguments:\n\n                - ``model``: an instance of the relevant subclass of :class:`~pytorch_transformers.PreTrainedModel`,\n                - ``config``: an instance of the relevant subclass of :class:`~pytorch_transformers.PretrainedConfig`,\n                - ``path``: a path (string) to the TensorFlow checkpoint.\n\n            - ``base_model_prefix``: a string indicating the attribute associated to the base model in derived classes of the same architecture adding modules on top of the base model.\n    """"""\n    config_class = None\n    pretrained_model_archive_map = {}\n    load_tf_weights = lambda model, config, path: None\n    base_model_prefix = """"\n\n    def __init__(self, config, *inputs, **kwargs):\n        super(PreTrainedModel, self).__init__()\n        if not isinstance(config, PretrainedConfig):\n            raise ValueError(\n                ""Parameter config in `{}(config)` should be an instance of class `PretrainedConfig`. ""\n                ""To create a model from a pretrained model use ""\n                ""`model = {}.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(\n                    self.__class__.__name__, self.__class__.__name__\n                ))\n        # Save config in model\n        self.config = config\n\n    def _get_resized_embeddings(self, old_embeddings, new_num_tokens=None):\n        """""" Build a resized Embedding Module from a provided token Embedding Module.\n            Increasing the size will add newly initialized vectors at the end\n            Reducing the size will remove vectors from the end\n\n        Args:\n            new_num_tokens: (`optional`) int\n                New number of tokens in the embedding matrix.\n                Increasing the size will add newly initialized vectors at the end\n                Reducing the size will remove vectors from the end\n                If not provided or None: return the provided token Embedding Module.\n        Return: ``torch.nn.Embeddings``\n            Pointer to the resized Embedding Module or the old Embedding Module if new_num_tokens is None\n        """"""\n        if new_num_tokens is None:\n            return old_embeddings\n\n        old_num_tokens, old_embedding_dim = old_embeddings.weight.size()\n        if old_num_tokens == new_num_tokens:\n            return old_embeddings\n\n        # Build new embeddings\n        new_embeddings = nn.Embedding(new_num_tokens, old_embedding_dim)\n        new_embeddings.to(old_embeddings.weight.device)\n\n        # initialize all new embeddings (in particular added tokens)\n        self.init_weights(new_embeddings)\n\n        # Copy word embeddings from the previous weights\n        num_tokens_to_copy = min(old_num_tokens, new_num_tokens)\n        new_embeddings.weight.data[:num_tokens_to_copy, :] = old_embeddings.weight.data[:num_tokens_to_copy, :]\n\n        return new_embeddings\n\n    def _tie_or_clone_weights(self, first_module, second_module):\n        """""" Tie or clone module weights depending of weither we are using TorchScript or not\n        """"""\n        if self.config.torchscript:\n            first_module.weight = nn.Parameter(second_module.weight.clone())\n        else:\n            first_module.weight = second_module.weight\n\n    def resize_token_embeddings(self, new_num_tokens=None):\n        """""" Resize input token embeddings matrix of the model if new_num_tokens != config.vocab_size.\n        Take care of tying weights embeddings afterwards if the model class has a `tie_weights()` method.\n\n        Arguments:\n\n            new_num_tokens: (`optional`) int:\n                New number of tokens in the embedding matrix. Increasing the size will add newly initialized vectors at the end. Reducing the size will remove vectors from the end.\n                If not provided or None: does nothing and just returns a pointer to the input tokens ``torch.nn.Embeddings`` Module of the model.\n\n        Return: ``torch.nn.Embeddings``\n            Pointer to the input tokens Embeddings Module of the model\n        """"""\n        base_model = getattr(self, self.base_model_prefix, self)  # get the base model if needed\n        model_embeds = base_model._resize_token_embeddings(new_num_tokens)\n        if new_num_tokens is None:\n            return model_embeds\n\n        # Update base model and current model config\n        self.config.vocab_size = new_num_tokens\n        base_model.vocab_size = new_num_tokens\n\n        # Tie weights again if needed\n        if hasattr(self, \'tie_weights\'):\n            self.tie_weights()\n\n        return model_embeds\n\n    def prune_heads(self, heads_to_prune):\n        raise NotImplementedError(""Not supported in this fork"")\n        """""" Prunes heads of the base model.\n\n            Arguments:\n\n                heads_to_prune: dict with keys being selected layer indices (`int`) and associated values being the list of heads to prune in said layer (list of `int`).\n        """"""\n        base_model = getattr(self, self.base_model_prefix, self)  # get the base model if needed\n        base_model._prune_heads(heads_to_prune)\n\n    def save_pretrained(self, save_directory):\n        """""" Save a model and its configuration file to a directory, so that it\n            can be re-loaded using the `:func:`~pytorch_transformers.PreTrainedModel.from_pretrained`` class method.\n        """"""\n        assert os.path.isdir(save_directory), ""Saving path should be a directory where the model and configuration can be saved""\n\n        # Only save the model it-self if we are using distributed training\n        model_to_save = self.module if hasattr(self, \'module\') else self\n\n        # Save configuration file\n        model_to_save.config.save_pretrained(save_directory)\n\n        # If we save using the predefined names, we can load using `from_pretrained`\n        output_model_file = os.path.join(save_directory, WEIGHTS_NAME)\n\n        torch.save(model_to_save.state_dict(), output_model_file)\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n        r""""""Instantiate a pretrained pytorch model from a pre-trained model configuration.\n\n        The model is set in evaluation mode by default using ``model.eval()`` (Dropout modules are deactivated)\n        To train the model, you should first set it back in training mode with ``model.train()``\n\n        The warning ``Weights from XXX not initialized from pretrained model`` means that the weights of XXX do not come pre-trained with the rest of the model.\n        It is up to you to train those weights with a downstream fine-tuning task.\n\n        The warning ``Weights from XXX not used in YYY`` means that the layer XXX is not used by YYY, therefore those weights are discarded.\n\n        Parameters:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing model weights saved using :func:`~pytorch_transformers.PreTrainedModel.save_pretrained`, e.g.: ``./my_model_directory/``.\n                - a path or url to a `tensorflow index checkpoint file` (e.g. `./tf_model/model.ckpt.index`). In this case, ``from_tf`` should be set to True and a configuration object should be provided as ``config`` argument. This loading path is slower than converting the TensorFlow checkpoint in a PyTorch model using the provided conversion scripts and loading the PyTorch model afterwards.\n\n            model_args: (`optional`) Sequence of positional arguments:\n                All remaning positional arguments will be passed to the underlying model\'s ``__init__`` method\n\n            config: (`optional`) instance of a class derived from :class:`~pytorch_transformers.PretrainedConfig`:\n                Configuration for the model to use instead of an automatically loaded configuation. Configuration can be automatically loaded when:\n\n                - the model is a model provided by the library (loaded with the ``shortcut-name`` string of a pretrained model), or\n                - the model was saved using :func:`~pytorch_transformers.PreTrainedModel.save_pretrained` and is reloaded by suppling the save directory.\n                - the model is loaded by suppling a local directory as ``pretrained_model_name_or_path`` and a configuration JSON file named `config.json` is found in the directory.\n\n            state_dict: (`optional`) dict:\n                an optional state dictionnary for the model to use instead of a state dictionary loaded from saved weights file.\n                This option can be used if you want to create a model from a pretrained configuration but load your own weights.\n                In this case though, you should check if using :func:`~pytorch_transformers.PreTrainedModel.save_pretrained` and :func:`~pytorch_transformers.PreTrainedModel.from_pretrained` is not a simpler option.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            output_loading_info: (`optional`) boolean:\n                Set to ``True`` to also return a dictionnary containing missing keys, unexpected keys and error messages.\n\n            kwargs: (`optional`) Remaining dictionary of keyword arguments:\n                Can be used to update the configuration object (after it being loaded) and initiate the model. (e.g. ``output_attention=True``). Behave differently depending on whether a `config` is provided or automatically loaded:\n\n                - If a configuration is provided with ``config``, ``**kwargs`` will be directly passed to the underlying model\'s ``__init__`` method (we assume all relevant updates to the configuration have already been done)\n                - If a configuration is not provided, ``kwargs`` will be first passed to the configuration class initialization function (:func:`~pytorch_transformers.PretrainedConfig.from_pretrained`). Each key of ``kwargs`` that corresponds to a configuration attribute will be used to override said attribute with the supplied ``kwargs`` value. Remaining keys that do not correspond to any configuration attribute will be passed to the underlying model\'s ``__init__`` function.\n\n        Examples::\n\n            model = BertModel.from_pretrained(\'bert-base-uncased\')    # Download model and configuration from S3 and cache.\n            model = BertModel.from_pretrained(\'./test/saved_model/\')  # E.g. model was saved using `save_pretrained(\'./test/saved_model/\')`\n            model = BertModel.from_pretrained(\'bert-base-uncased\', output_attention=True)  # Update configuration during loading\n            assert model.config.output_attention == True\n            # Loading from a TF checkpoint file instead of a PyTorch model (slower)\n            config = BertConfig.from_json_file(\'./tf_model/my_tf_model_config.json\')\n            model = BertModel.from_pretrained(\'./tf_model/my_tf_checkpoint.ckpt.index\', from_tf=True, config=config)\n\n        """"""\n        config = kwargs.pop(\'config\', None)\n        state_dict = kwargs.pop(\'state_dict\', None)\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        from_tf = kwargs.pop(\'from_tf\', False)\n        output_loading_info = kwargs.pop(\'output_loading_info\', False)\n\n        # Load config\n        if config is None:\n            config, model_kwargs = cls.config_class.from_pretrained(\n                pretrained_model_name_or_path, *model_args,\n                cache_dir=cache_dir, return_unused_kwargs=True,\n                **kwargs\n            )\n        else:\n            model_kwargs = kwargs\n\n        # Load model\n        if pretrained_model_name_or_path in cls.pretrained_model_archive_map:\n            archive_file = cls.pretrained_model_archive_map[pretrained_model_name_or_path]\n        elif os.path.isdir(pretrained_model_name_or_path):\n            if from_tf:\n                # Directly load from a TensorFlow checkpoint\n                archive_file = os.path.join(pretrained_model_name_or_path, TF_WEIGHTS_NAME + "".index"")\n            else:\n                archive_file = os.path.join(pretrained_model_name_or_path, WEIGHTS_NAME)\n        else:\n            if from_tf:\n                # Directly load from a TensorFlow checkpoint\n                archive_file = pretrained_model_name_or_path + "".index""\n            else:\n                archive_file = pretrained_model_name_or_path\n        # redirect to the cache, if necessary\n        try:\n            resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)\n        except EnvironmentError:\n            if pretrained_model_name_or_path in cls.pretrained_model_archive_map:\n                logger.error(\n                    ""Couldn\'t reach server at \'{}\' to download pretrained weights."".format(\n                        archive_file))\n            else:\n                logger.error(\n                    ""Model name \'{}\' was not found in model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url but couldn\'t find any file ""\n                    ""associated to this path or url."".format(\n                        pretrained_model_name_or_path,\n                        \', \'.join(cls.pretrained_model_archive_map.keys()),\n                        archive_file))\n            return None\n        if resolved_archive_file == archive_file:\n            logger.info(""loading weights file {}"".format(archive_file))\n        else:\n            logger.info(""loading weights file {} from cache at {}"".format(\n                archive_file, resolved_archive_file))\n\n        # Instantiate model.\n        model = cls(config, *model_args, **model_kwargs)\n\n        if state_dict is None and not from_tf:\n            state_dict = torch.load(resolved_archive_file, map_location=\'cpu\')\n        if from_tf:\n            # Directly load from a TensorFlow checkpoint\n            return cls.load_tf_weights(model, config, resolved_archive_file[:-6])  # Remove the \'.index\'\n\n        # Convert old format to new format if needed from a PyTorch state_dict\n        old_keys = []\n        new_keys = []\n        for key in state_dict.keys():\n            new_key = None\n            if \'gamma\' in key:\n                new_key = key.replace(\'gamma\', \'weight\')\n            if \'beta\' in key:\n                new_key = key.replace(\'beta\', \'bias\')\n            if new_key:\n                old_keys.append(key)\n                new_keys.append(new_key)\n        for old_key, new_key in zip(old_keys, new_keys):\n            state_dict[new_key] = state_dict.pop(old_key)\n\n        # Load from a PyTorch state_dict\n        missing_keys = []\n        unexpected_keys = []\n        error_msgs = []\n        # copy state_dict so _load_from_state_dict can modify it\n        metadata = getattr(state_dict, \'_metadata\', None)\n        state_dict = state_dict.copy()\n        if metadata is not None:\n            state_dict._metadata = metadata\n\n        def load(module, prefix=\'\'):\n            local_metadata = {} if metadata is None else metadata.get(prefix[:-1], {})\n            module._load_from_state_dict(\n                state_dict, prefix, local_metadata, True, missing_keys, unexpected_keys, error_msgs)\n            for name, child in module._modules.items():\n                if child is not None:\n                    load(child, prefix + name + \'.\')\n\n        # Make sure we are able to load base models as well as derived models (with heads)\n        start_prefix = \'\'\n        model_to_load = model\n        if not hasattr(model, cls.base_model_prefix) and any(s.startswith(cls.base_model_prefix) for s in state_dict.keys()):\n            start_prefix = cls.base_model_prefix + \'.\'\n        if hasattr(model, cls.base_model_prefix) and not any(s.startswith(cls.base_model_prefix) for s in state_dict.keys()):\n            model_to_load = getattr(model, cls.base_model_prefix)\n\n        load(model_to_load, prefix=start_prefix)\n        if len(missing_keys) > 0:\n            logger.info(""Weights of {} not initialized from pretrained model: {}"".format(\n                model.__class__.__name__, missing_keys))\n        if len(unexpected_keys) > 0:\n            logger.info(""Weights from pretrained model not used in {}: {}"".format(\n                model.__class__.__name__, unexpected_keys))\n        if len(error_msgs) > 0:\n            raise RuntimeError(\'Error(s) in loading state_dict for {}:\\n\\t{}\'.format(\n                               model.__class__.__name__, ""\\n\\t"".join(error_msgs)))\n\n        if hasattr(model, \'tie_weights\'):\n            model.tie_weights()  # make sure word embedding weights are still tied\n\n        # Set model in evaluation mode to desactivate DropOut modules by default\n        model.eval()\n\n        if output_loading_info:\n            loading_info = {""missing_keys"": missing_keys, ""unexpected_keys"": unexpected_keys, ""error_msgs"": error_msgs}\n            return model, loading_info\n\n        return model\n\n\nclass Conv1D(nn.Module):\n    def __init__(self, nf, nx):\n        """""" Conv1D layer as defined by Radford et al. for OpenAI GPT (and also used in GPT-2)\n            Basically works like a Linear layer but the weights are transposed\n        """"""\n        super(Conv1D, self).__init__()\n        self.nf = nf\n        w = torch.empty(nx, nf)\n        nn.init.normal_(w, std=0.02)\n        self.weight = nn.Parameter(w)\n        self.bias = nn.Parameter(torch.zeros(nf))\n\n    def forward(self, x):\n        size_out = x.size()[:-1] + (self.nf,)\n        x = torch.addmm(self.bias, x.view(-1, x.size(-1)), self.weight)\n        x = x.view(*size_out)\n        return x\n\n\nclass PoolerStartLogits(nn.Module):\n    """""" Compute SQuAD start_logits from sequence hidden states. """"""\n    def __init__(self, config):\n        super(PoolerStartLogits, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, 1)\n\n    def forward(self, hidden_states, p_mask=None):\n        """""" Args:\n            **p_mask**: (`optional`) ``torch.FloatTensor`` of shape `(batch_size, seq_len)`\n                invalid position mask such as query and special symbols (PAD, SEP, CLS)\n                1.0 means token should be masked.\n        """"""\n        x = self.dense(hidden_states).squeeze(-1)\n\n        if p_mask is not None:\n            x = x * (1 - p_mask) - 1e30 * p_mask\n\n        return x\n\n\nclass PoolerEndLogits(nn.Module):\n    """""" Compute SQuAD end_logits from sequence hidden states and start token hidden state.\n    """"""\n    def __init__(self, config):\n        super(PoolerEndLogits, self).__init__()\n        self.dense_0 = nn.Linear(config.hidden_size * 2, config.hidden_size)\n        self.activation = nn.Tanh()\n        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dense_1 = nn.Linear(config.hidden_size, 1)\n\n    def forward(self, hidden_states, start_states=None, start_positions=None, p_mask=None):\n        """""" Args:\n            One of ``start_states``, ``start_positions`` should be not None.\n            If both are set, ``start_positions`` overrides ``start_states``.\n\n            **start_states**: ``torch.LongTensor`` of shape identical to hidden_states\n                hidden states of the first tokens for the labeled span.\n            **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n                position of the first token for the labeled span:\n            **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, seq_len)``\n                Mask of invalid position such as query and special symbols (PAD, SEP, CLS)\n                1.0 means token should be masked.\n        """"""\n        assert start_states is not None or start_positions is not None, ""One of start_states, start_positions should be not None""\n        if start_positions is not None:\n            slen, hsz = hidden_states.shape[-2:]\n            start_positions = start_positions[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            start_states = hidden_states.gather(-2, start_positions) # shape (bsz, 1, hsz)\n            start_states = start_states.expand(-1, slen, -1) # shape (bsz, slen, hsz)\n\n        x = self.dense_0(torch.cat([hidden_states, start_states], dim=-1))\n        x = self.activation(x)\n        x = self.LayerNorm(x)\n        x = self.dense_1(x).squeeze(-1)\n\n        if p_mask is not None:\n            x = x * (1 - p_mask) - 1e30 * p_mask\n\n        return x\n\n\nclass PoolerAnswerClass(nn.Module):\n    """""" Compute SQuAD 2.0 answer class from classification and start tokens hidden states. """"""\n    def __init__(self, config):\n        super(PoolerAnswerClass, self).__init__()\n        self.dense_0 = nn.Linear(config.hidden_size * 2, config.hidden_size)\n        self.activation = nn.Tanh()\n        self.dense_1 = nn.Linear(config.hidden_size, 1, bias=False)\n\n    def forward(self, hidden_states, start_states=None, start_positions=None, cls_index=None):\n        """"""\n        Args:\n            One of ``start_states``, ``start_positions`` should be not None.\n            If both are set, ``start_positions`` overrides ``start_states``.\n\n            **start_states**: ``torch.LongTensor`` of shape identical to ``hidden_states``.\n                hidden states of the first tokens for the labeled span.\n            **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n                position of the first token for the labeled span.\n            **cls_index**: torch.LongTensor of shape ``(batch_size,)``\n                position of the CLS token. If None, take the last token.\n\n            note(Original repo):\n                no dependency on end_feature so that we can obtain one single `cls_logits`\n                for each sample\n        """"""\n        hsz = hidden_states.shape[-1]\n        assert start_states is not None or start_positions is not None, ""One of start_states, start_positions should be not None""\n        if start_positions is not None:\n            start_positions = start_positions[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            start_states = hidden_states.gather(-2, start_positions).squeeze(-2) # shape (bsz, hsz)\n\n        if cls_index is not None:\n            cls_index = cls_index[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            cls_token_state = hidden_states.gather(-2, cls_index).squeeze(-2) # shape (bsz, hsz)\n        else:\n            cls_token_state = hidden_states[:, -1, :] # shape (bsz, hsz)\n\n        x = self.dense_0(torch.cat([start_states, cls_token_state], dim=-1))\n        x = self.activation(x)\n        x = self.dense_1(x).squeeze(-1)\n\n        return x\n\n\nclass SQuADHead(nn.Module):\n    r"""""" A SQuAD head inspired by XLNet.\n\n    Parameters:\n        config (:class:`~pytorch_transformers.XLNetConfig`): Model configuration class with all the parameters of the model.\n\n    Inputs:\n        **hidden_states**: ``torch.FloatTensor`` of shape ``(batch_size, seq_len, hidden_size)``\n            hidden states of sequence tokens\n        **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            position of the first token for the labeled span.\n        **end_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            position of the last token for the labeled span.\n        **cls_index**: torch.LongTensor of shape ``(batch_size,)``\n            position of the CLS token. If None, take the last token.\n        **is_impossible**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            Whether the question has a possible answer in the paragraph or not.\n        **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, seq_len)``\n            Mask of invalid position such as query and special symbols (PAD, SEP, CLS)\n            1.0 means token should be masked.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned if both ``start_positions`` and ``end_positions`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss as the sum of start token, end token (and is_impossible if provided) classification losses.\n        **start_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top)``\n            Log probabilities for the top config.start_n_top start token possibilities (beam-search).\n        **start_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top)``\n            Indices for the top config.start_n_top start token possibilities (beam-search).\n        **end_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Log probabilities for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **end_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Indices for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **cls_logits**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size,)``\n            Log probabilities for the ``is_impossible`` label of the answers.\n    """"""\n    def __init__(self, config):\n        super(SQuADHead, self).__init__()\n        self.start_n_top = config.start_n_top\n        self.end_n_top = config.end_n_top\n\n        self.start_logits = PoolerStartLogits(config)\n        self.end_logits = PoolerEndLogits(config)\n        self.answer_class = PoolerAnswerClass(config)\n\n    def forward(self, hidden_states, start_positions=None, end_positions=None,\n                cls_index=None, is_impossible=None, p_mask=None):\n        outputs = ()\n\n        start_logits = self.start_logits(hidden_states, p_mask=p_mask)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, let\'s remove the dimension added by batch splitting\n            for x in (start_positions, end_positions, cls_index, is_impossible):\n                if x is not None and x.dim() > 1:\n                    x.squeeze_(-1)\n\n            # during training, compute the end logits based on the ground truth of the start position\n            end_logits = self.end_logits(hidden_states, start_positions=start_positions, p_mask=p_mask)\n\n            loss_fct = CrossEntropyLoss()\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n\n            if cls_index is not None and is_impossible is not None:\n                # Predict answerability from the representation of CLS and START\n                cls_logits = self.answer_class(hidden_states, start_positions=start_positions, cls_index=cls_index)\n                loss_fct_cls = nn.BCEWithLogitsLoss()\n                cls_loss = loss_fct_cls(cls_logits, is_impossible)\n\n                # note(zhiliny): by default multiply the loss by 0.5 so that the scale is comparable to start_loss and end_loss\n                total_loss += cls_loss * 0.5\n\n            outputs = (total_loss,) + outputs\n\n        else:\n            # during inference, compute the end logits based on beam search\n            bsz, slen, hsz = hidden_states.size()\n            start_log_probs = F.softmax(start_logits, dim=-1) # shape (bsz, slen)\n\n            start_top_log_probs, start_top_index = torch.topk(start_log_probs, self.start_n_top, dim=-1) # shape (bsz, start_n_top)\n            start_top_index_exp = start_top_index.unsqueeze(-1).expand(-1, -1, hsz) # shape (bsz, start_n_top, hsz)\n            start_states = torch.gather(hidden_states, -2, start_top_index_exp) # shape (bsz, start_n_top, hsz)\n            start_states = start_states.unsqueeze(1).expand(-1, slen, -1, -1) # shape (bsz, slen, start_n_top, hsz)\n\n            hidden_states_expanded = hidden_states.unsqueeze(2).expand_as(start_states) # shape (bsz, slen, start_n_top, hsz)\n            p_mask = p_mask.unsqueeze(-1) if p_mask is not None else None\n            end_logits = self.end_logits(hidden_states_expanded, start_states=start_states, p_mask=p_mask)\n            end_log_probs = F.softmax(end_logits, dim=1) # shape (bsz, slen, start_n_top)\n\n            end_top_log_probs, end_top_index = torch.topk(end_log_probs, self.end_n_top, dim=1) # shape (bsz, end_n_top, start_n_top)\n            end_top_log_probs = end_top_log_probs.view(-1, self.start_n_top * self.end_n_top)\n            end_top_index = end_top_index.view(-1, self.start_n_top * self.end_n_top)\n\n            start_states = torch.einsum(""blh,bl->bh"", hidden_states, start_log_probs)\n            cls_logits = self.answer_class(hidden_states, start_states=start_states, cls_index=cls_index)\n\n            outputs = (start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits) + outputs\n\n        # return start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits\n        # or (if labels are provided) (total_loss,)\n        return outputs\n\n\nclass SequenceSummary(nn.Module):\n    r"""""" Compute a single vector summary of a sequence hidden states according to various possibilities:\n        Args of the config class:\n            summary_type:\n                - \'last\' => [default] take the last token hidden state (like XLNet)\n                - \'first\' => take the first token hidden state (like Bert)\n                - \'mean\' => take the mean of all tokens hidden states\n                - \'cls_index\' => supply a Tensor of classification token position (GPT/GPT-2)\n                - \'attn\' => Not implemented now, use multi-head attention\n            summary_use_proj: Add a projection after the vector extraction\n            summary_proj_to_labels: If True, the projection outputs to config.num_labels classes (otherwise to hidden_size). Default: False.\n            summary_activation: \'tanh\' => add a tanh activation to the output, Other => no activation. Default\n            summary_first_dropout: Add a dropout before the projection and activation\n            summary_last_dropout: Add a dropout after the projection and activation\n    """"""\n    def __init__(self, config):\n        super(SequenceSummary, self).__init__()\n\n        self.summary_type = config.summary_type if hasattr(config, \'summary_use_proj\') else \'last\'\n        if self.summary_type == \'attn\':\n            # We should use a standard multi-head attention module with absolute positional embedding for that.\n            # Cf. https://github.com/zihangdai/xlnet/blob/master/modeling.py#L253-L276\n            # We can probably just use the multi-head attention module of PyTorch >=1.1.0\n            raise NotImplementedError\n\n        self.summary = Identity()\n        if hasattr(config, \'summary_use_proj\') and config.summary_use_proj:\n            if hasattr(config, \'summary_proj_to_labels\') and config.summary_proj_to_labels and config.num_labels > 0:\n                num_classes = config.num_labels\n            else:\n                num_classes = config.hidden_size\n            self.summary = nn.Linear(config.hidden_size, num_classes)\n\n        self.activation = Identity()\n        if hasattr(config, \'summary_activation\') and config.summary_activation == \'tanh\':\n            self.activation = nn.Tanh()\n\n        self.first_dropout = Identity()\n        if hasattr(config, \'summary_first_dropout\') and config.summary_first_dropout > 0:\n            self.first_dropout = nn.Dropout(config.summary_first_dropout)\n\n        self.last_dropout = Identity()\n        if hasattr(config, \'summary_last_dropout\') and config.summary_last_dropout > 0:\n            self.last_dropout = nn.Dropout(config.summary_last_dropout)\n\n    def forward(self, hidden_states, cls_index=None):\n        """""" hidden_states: float Tensor in shape [bsz, seq_len, hidden_size], the hidden-states of the last layer.\n            cls_index: [optional] position of the classification token if summary_type == \'cls_index\',\n                shape (bsz,) or more generally (bsz, ...) where ... are optional leading dimensions of hidden_states.\n                if summary_type == \'cls_index\' and cls_index is None:\n                    we take the last token of the sequence as classification token\n        """"""\n        if self.summary_type == \'last\':\n            output = hidden_states[:, -1]\n        elif self.summary_type == \'first\':\n            output = hidden_states[:, 0]\n        elif self.summary_type == \'mean\':\n            output = hidden_states.mean(dim=1)\n        elif self.summary_type == \'cls_index\':\n            if cls_index is None:\n                cls_index = torch.full_like(hidden_states[..., :1, :], hidden_states.shape[-2]-1, dtype=torch.long)\n            else:\n                cls_index = cls_index.unsqueeze(-1).unsqueeze(-1)\n                cls_index = cls_index.expand((-1,) * (cls_index.dim()-1) + (hidden_states.size(-1),))\n            # shape of cls_index: (bsz, XX, 1, hidden_size) where XX are optional leading dim of hidden_states\n            output = hidden_states.gather(-2, cls_index).squeeze(-2) # shape (bsz, XX, hidden_size)\n        elif self.summary_type == \'attn\':\n            raise NotImplementedError\n\n        output = self.first_dropout(output)\n        output = self.summary(output)\n        output = self.activation(output)\n        output = self.last_dropout(output)\n\n        return output\n\n\ndef prune_linear_layer(layer, index, dim=0):\n    """""" Prune a linear layer (a model parameters) to keep only entries in index.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    index = index.to(layer.weight.device)\n    W = layer.weight.index_select(dim, index).clone().detach()\n    if layer.bias is not None:\n        if dim == 1:\n            b = layer.bias.clone().detach()\n        else:\n            b = layer.bias[index].clone().detach()\n    new_size = list(layer.weight.size())\n    new_size[dim] = len(index)\n    new_layer = nn.Linear(new_size[1], new_size[0], bias=layer.bias is not None).to(layer.weight.device)\n    new_layer.weight.requires_grad = False\n    new_layer.weight.copy_(W.contiguous())\n    new_layer.weight.requires_grad = True\n    if layer.bias is not None:\n        new_layer.bias.requires_grad = False\n        new_layer.bias.copy_(b.contiguous())\n        new_layer.bias.requires_grad = True\n    return new_layer\n\n\ndef prune_conv1d_layer(layer, index, dim=1):\n    """""" Prune a Conv1D layer (a model parameters) to keep only entries in index.\n        A Conv1D work as a Linear layer (see e.g. BERT) but the weights are transposed.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    index = index.to(layer.weight.device)\n    W = layer.weight.index_select(dim, index).clone().detach()\n    if dim == 0:\n        b = layer.bias.clone().detach()\n    else:\n        b = layer.bias[index].clone().detach()\n    new_size = list(layer.weight.size())\n    new_size[dim] = len(index)\n    new_layer = Conv1D(new_size[1], new_size[0]).to(layer.weight.device)\n    new_layer.weight.requires_grad = False\n    new_layer.weight.copy_(W.contiguous())\n    new_layer.weight.requires_grad = True\n    new_layer.bias.requires_grad = False\n    new_layer.bias.copy_(b.contiguous())\n    new_layer.bias.requires_grad = True\n    return new_layer\n\n\ndef prune_layer(layer, index, dim=None):\n    """""" Prune a Conv1D or nn.Linear layer (a model parameters) to keep only entries in index.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    if isinstance(layer, nn.Linear):\n        return prune_linear_layer(layer, index, dim=0 if dim is None else dim)\n    elif isinstance(layer, Conv1D):\n        return prune_conv1d_layer(layer, index, dim=1 if dim is None else dim)\n    else:\n        raise ValueError(""Can\'t prune layer of class {}"".format(layer.__class__))\n'"
bertviz/transformers_neuron_view/modeling_xlm.py,57,"b'# coding=utf-8\n# Copyright 2019-present, Facebook, Inc and the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" PyTorch XLM model.\n""""""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport math\nimport sys\nfrom io import open\n\nimport itertools\nimport numpy as np\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_utils import (PretrainedConfig, PreTrainedModel, add_start_docstrings,\n                             prune_linear_layer, SequenceSummary, SQuADHead)\n\nlogger = logging.getLogger(__name__)\n\nXLM_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-pytorch_model.bin"",\n    \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-pytorch_model.bin"",\n    \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-pytorch_model.bin"",\n    \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-pytorch_model.bin"",\n    \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-pytorch_model.bin"",\n    \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-pytorch_model.bin"",\n    \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-enfr-1024-pytorch_model.bin"",\n    \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-ende-1024-pytorch_model.bin"",\n}\nXLM_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-config.json"",\n    \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-config.json"",\n    \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-config.json"",\n    \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-config.json"",\n    \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-config.json"",\n    \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-config.json"",\n    \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-enfr-1024-config.json"",\n    \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-ende-1024-config.json"",\n}\n\n\nclass XLMConfig(PretrainedConfig):\n    """"""Configuration class to store the configuration of a `XLMModel`.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `XLMModel`.\n        d_model: Size of the encoder layers and the pooler layer.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        d_inner: The size of the ""intermediate"" (i.e., feed-forward)\n            layer in the Transformer encoder.\n        ff_activation: The non-linear activation function (function or string) in the\n            encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n        untie_r: untie relative position biases\n        attn_type: \'bi\' for XLM, \'uni\' for Transformer-XL\n\n        dropout: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        dropatt: The dropout ratio for the attention\n            probabilities.\n        max_position_embeddings: The maximum sequence length that this model might\n            ever be used with. Typically set this to something large just in case\n            (e.g., 512 or 1024 or 2048).\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n        layer_norm_eps: The epsilon used by LayerNorm.\n\n        dropout: float, dropout rate.\n        dropatt: float, dropout rate on attention probabilities.\n        init: str, the initialization scheme, either ""normal"" or ""uniform"".\n        init_range: float, initialize the parameters with a uniform distribution\n            in [-init_range, init_range]. Only effective when init=""uniform"".\n        init_std: float, initialize the parameters with a normal distribution\n            with mean 0 and stddev init_std. Only effective when init=""normal"".\n        mem_len: int, the number of tokens to cache.\n        reuse_len: int, the number of tokens in the currect batch to be cached\n            and reused in the future.\n        bi_data: bool, whether to use bidirectional input pipeline.\n            Usually set to True during pretraining and False during finetuning.\n        clamp_len: int, clamp all relative distances larger than clamp_len.\n            -1 means no clamping.\n        same_length: bool, whether to use the same attention length for each token.\n    """"""\n    pretrained_config_archive_map = XLM_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=30145,\n                 emb_dim=2048,\n                 n_layers=12,\n                 n_heads=16,\n                 dropout=0.1,\n                 attention_dropout=0.1,\n                 gelu_activation=True,\n                 sinusoidal_embeddings=False,\n                 causal=False,\n                 asm=False,\n                 n_langs=1,\n                 max_position_embeddings=512,\n                 embed_init_std=2048 ** -0.5,\n                 layer_norm_eps=1e-12,\n                 init_std=0.02,\n                 bos_index=0,\n                 eos_index=1,\n                 pad_index=2,\n                 unk_index=3,\n                 mask_index=5,\n                 is_encoder=True,\n\n                 finetuning_task=None,\n                 num_labels=2,\n                 summary_type=\'first\',\n                 summary_use_proj=True,\n                 summary_activation=None,\n                 summary_proj_to_labels=True,\n                 summary_first_dropout=0.1,\n                 start_n_top=5,\n                 end_n_top=5,\n                 **kwargs):\n        """"""Constructs XLMConfig.\n        """"""\n        super(XLMConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.n_words = vocab_size_or_config_json_file\n            self.emb_dim = emb_dim\n            self.n_layers = n_layers\n            self.n_heads = n_heads\n            self.dropout = dropout\n            self.attention_dropout = attention_dropout\n            self.gelu_activation = gelu_activation\n            self.sinusoidal_embeddings = sinusoidal_embeddings\n            self.causal = causal\n            self.asm = asm\n            self.n_langs = n_langs\n            self.layer_norm_eps = layer_norm_eps\n            self.bos_index = bos_index\n            self.eos_index = eos_index\n            self.pad_index = pad_index\n            self.unk_index = unk_index\n            self.mask_index = mask_index\n            self.is_encoder = is_encoder\n            self.max_position_embeddings = max_position_embeddings\n            self.embed_init_std = embed_init_std\n            self.init_std = init_std\n            self.finetuning_task = finetuning_task\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_proj_to_labels = summary_proj_to_labels\n            self.summary_first_dropout = summary_first_dropout\n            self.start_n_top = start_n_top\n            self.end_n_top = end_n_top\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             ""or the path to a pretrained model config file (str)"")\n\n    @property\n    def vocab_size(self):\n        return self.n_words\n\n    @vocab_size.setter\n    def vocab_size(self, value):\n        self.n_words = value\n\n    @property\n    def hidden_size(self):\n        return self.emb_dim\n\n    @property\n    def num_attention_heads(self):\n        return self.n_heads\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layers\n\n\ndef create_sinusoidal_embeddings(n_pos, dim, out):\n    position_enc = np.array([\n        [pos / np.power(10000, 2 * (j // 2) / dim) for j in range(dim)]\n        for pos in range(n_pos)\n    ])\n    out[:, 0::2] = torch.FloatTensor(np.sin(position_enc[:, 0::2]))\n    out[:, 1::2] = torch.FloatTensor(np.cos(position_enc[:, 1::2]))\n    out.detach_()\n    out.requires_grad = False\n\n\ndef gelu(x):\n    """"""\n    GELU activation\n    https://arxiv.org/abs/1606.08415\n    https://github.com/huggingface/pytorch-openai-transformer-lm/blob/master/model_pytorch.py#L14\n    https://github.com/huggingface/pytorch-transformers/blob/master/modeling.py\n    """"""\n    # return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n    return 0.5 * x * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\n\ndef get_masks(slen, lengths, causal, padding_mask=None):\n    """"""\n    Generate hidden states mask, and optionally an attention mask.\n    """"""\n    bs = lengths.size(0)\n    if padding_mask is not None:\n        mask = padding_mask\n    else:\n        assert lengths.max().item() <= slen\n        alen = torch.arange(slen, dtype=torch.long, device=lengths.device)\n        mask = alen < lengths[:, None]\n\n    # attention mask is the same as mask, or triangular inferior attention (causal)\n    if causal:\n        attn_mask = alen[None, None, :].repeat(bs, slen, 1) <= alen[None, :, None]\n    else:\n        attn_mask = mask\n\n    # sanity check\n    assert mask.size() == (bs, slen)\n    assert causal is False or attn_mask.size() == (bs, slen, slen)\n\n    return mask, attn_mask\n\n\nclass MultiHeadAttention(nn.Module):\n\n    NEW_ID = itertools.count()\n\n    def __init__(self, n_heads, dim, config):\n        super(MultiHeadAttention, self).__init__()\n        self.layer_id = next(MultiHeadAttention.NEW_ID)\n        self.output_attentions = config.output_attentions\n        self.dim = dim\n        self.n_heads = n_heads\n        self.dropout = config.attention_dropout\n        assert self.dim % self.n_heads == 0\n\n        self.q_lin = nn.Linear(dim, dim)\n        self.k_lin = nn.Linear(dim, dim)\n        self.v_lin = nn.Linear(dim, dim)\n        self.out_lin = nn.Linear(dim, dim)\n\n    def prune_heads(self, heads):\n        attention_head_size = self.dim // self.n_heads\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.n_heads, attention_head_size)\n        for head in heads:\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n        # Prune linear layers\n        self.q_lin = prune_linear_layer(self.q_lin, index)\n        self.k_lin = prune_linear_layer(self.k_lin, index)\n        self.v_lin = prune_linear_layer(self.v_lin, index)\n        self.out_lin = prune_linear_layer(self.out_lin, index, dim=1)\n        # Update hyper params\n        self.n_heads = self.n_heads - len(heads)\n        self.dim = attention_head_size * self.n_heads\n\n    def forward(self, input, mask, kv=None, cache=None, head_mask=None):\n        """"""\n        Self-attention (if kv is None) or attention over source sentence (provided by kv).\n        """"""\n        # Input is (bs, qlen, dim)\n        # Mask is (bs, klen) (non-causal) or (bs, klen, klen)\n        bs, qlen, dim = input.size()\n        if kv is None:\n            klen = qlen if cache is None else cache[\'slen\'] + qlen\n        else:\n            klen = kv.size(1)\n        # assert dim == self.dim, \'Dimensions do not match: %s input vs %s configured\' % (dim, self.dim)\n        n_heads = self.n_heads\n        dim_per_head = self.dim // n_heads\n        mask_reshape = (bs, 1, qlen, klen) if mask.dim() == 3 else (bs, 1, 1, klen)\n\n        def shape(x):\n            """"""  projection """"""\n            return x.view(bs, -1, self.n_heads, dim_per_head).transpose(1, 2)\n\n        def unshape(x):\n            """"""  compute context """"""\n            return x.transpose(1, 2).contiguous().view(bs, -1, self.n_heads * dim_per_head)\n\n        q = shape(self.q_lin(input))                                          # (bs, n_heads, qlen, dim_per_head)\n        if kv is None:\n            k = shape(self.k_lin(input))                                      # (bs, n_heads, qlen, dim_per_head)\n            v = shape(self.v_lin(input))                                      # (bs, n_heads, qlen, dim_per_head)\n        elif cache is None or self.layer_id not in cache:\n            k = v = kv\n            k = shape(self.k_lin(k))                                          # (bs, n_heads, qlen, dim_per_head)\n            v = shape(self.v_lin(v))                                          # (bs, n_heads, qlen, dim_per_head)\n\n        if cache is not None:\n            if self.layer_id in cache:\n                if kv is None:\n                    k_, v_ = cache[self.layer_id]\n                    k = torch.cat([k_, k], dim=2)                             # (bs, n_heads, klen, dim_per_head)\n                    v = torch.cat([v_, v], dim=2)                             # (bs, n_heads, klen, dim_per_head)\n                else:\n                    k, v = cache[self.layer_id]\n            cache[self.layer_id] = (k, v)\n\n        q = q / math.sqrt(dim_per_head)                                       # (bs, n_heads, qlen, dim_per_head)\n        scores = torch.matmul(q, k.transpose(2, 3))                           # (bs, n_heads, qlen, klen)\n        mask = (mask == 0).view(mask_reshape).expand_as(scores)               # (bs, n_heads, qlen, klen)\n        scores.masked_fill_(mask, -float(\'inf\'))                              # (bs, n_heads, qlen, klen)\n\n        weights = F.softmax(scores.float(), dim=-1).type_as(scores)           # (bs, n_heads, qlen, klen)\n        weights = F.dropout(weights, p=self.dropout, training=self.training)  # (bs, n_heads, qlen, klen)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            weights = weights * head_mask\n\n        context = torch.matmul(weights, v)                                    # (bs, n_heads, qlen, dim_per_head)\n        context = unshape(context)                                            # (bs, qlen, dim)\n\n        outputs = (self.out_lin(context),)\n        if self.output_attentions:\n            outputs = outputs + (weights,)\n        return outputs\n\n\nclass TransformerFFN(nn.Module):\n\n    def __init__(self, in_dim, dim_hidden, out_dim, config):\n        super(TransformerFFN, self).__init__()\n        self.dropout = config.dropout\n        self.lin1 = nn.Linear(in_dim, dim_hidden)\n        self.lin2 = nn.Linear(dim_hidden, out_dim)\n        self.act = gelu if config.gelu_activation else F.relu\n\n    def forward(self, input):\n        x = self.lin1(input)\n        x = self.act(x)\n        x = self.lin2(x)\n        x = F.dropout(x, p=self.dropout, training=self.training)\n        return x\n\n\nclass XLMPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = XLMConfig\n    pretrained_model_archive_map = XLM_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = None\n    base_model_prefix = ""transformer""\n\n    def __init__(self, *inputs, **kwargs):\n        super(XLMPreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def init_weights(self, module):\n        """""" Initialize the weights. """"""\n        if isinstance(module, nn.Embedding):\n            if self.config is not None and self.config.embed_init_std is not None:\n                nn.init.normal_(module.weight, mean=0, std=self.config.embed_init_std)\n        if isinstance(module, nn.Linear):\n            if self.config is not None and self.config.init_std is not None:\n                nn.init.normal_(module.weight, mean=0, std=self.config.init_std)\n                if hasattr(module, \'bias\') and module.bias is not None:\n                    nn.init.constant_(module.bias, 0.)\n        if isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n\nXLM_START_DOCSTRING = r""""""    The XLM model was proposed in\n    `Cross-lingual Language Model Pretraining`_\n    by Guillaume Lample*, Alexis Conneau*. It\'s a transformer pre-trained using one of the following objectives:\n\n        - a causal language modeling (CLM) objective (next token prediction),\n        - a masked language modeling (MLM) objective (Bert-like), or\n        - a Translation Language Modeling (TLM) object (extension of Bert\'s MLM to multiple language inputs)\n\n    Original code can be found `here`_.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`Cross-lingual Language Model Pretraining`:\n        https://arxiv.org/abs/1901.07291\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    .. _`here`:\n        https://github.com/facebookresearch/XLM\n\n    Parameters:\n        config (:class:`~pytorch_transformers.XLMConfig`): Model configuration class with all the parameters of the model.\n""""""\n\nXLM_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            Indices can be obtained using :class:`pytorch_transformers.XLMTokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **langs**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens to be used to indicate the language of each token in the input.\n            Indices are selected in the pre-trained language vocabulary,\n            i.e. in the range ``[0, config.n_langs - 1[``.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **lengths**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Length of each sentence that can be used to avoid performing attention on padding token indices.\n            You can also use `attention_mask` for the same result (see above), kept here for compatbility.\n            Indices selected in ``[0, ..., input_ids.size(-1)]``:\n        **cache**:\n            dictionary with ``torch.FloatTensor`` that contains pre-computed\n            hidden-states (key and values in the attention blocks) as computed by the model\n            (see `cache` output below). Can be used to speed up sequential decoding.\n            The dictionary object will be modified in-place during the forward pass to add newly computed hidden-states.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare XLM Model transformer outputing raw hidden-states without any specific head on top."",\n                      XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMModel(XLMPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMModel.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    ATTRIBUTES = [\'encoder\', \'eos_index\', \'pad_index\',  # \'with_output\', \n                  \'n_langs\', \'n_words\', \'dim\', \'n_layers\', \'n_heads\', \n                  \'hidden_dim\', \'dropout\', \'attention_dropout\', \'asm\',\n                  \'asm_cutoffs\', \'asm_div_value\']\n\n    def __init__(self, config):  #, dico, is_encoder, with_output):\n        raise NotImplementedError(""BertViz does not currently support XLM"")\n        super(XLMModel, self).__init__(config)\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        # encoder / decoder, output layer\n        self.is_encoder = config.is_encoder\n        self.is_decoder = not config.is_encoder\n        if self.is_decoder:\n            raise NotImplementedError(""Currently XLM can only be used as an encoder"")\n        # self.with_output = with_output\n        self.causal = config.causal\n\n        # dictionary / languages\n        self.n_langs = config.n_langs\n        self.n_words = config.n_words\n        self.eos_index = config.eos_index\n        self.pad_index = config.pad_index\n        # self.dico = dico\n        # self.id2lang = config.id2lang\n        # self.lang2id = config.lang2id\n        # assert len(self.dico) == self.n_words\n        # assert len(self.id2lang) == len(self.lang2id) == self.n_langs\n\n        # model parameters\n        self.dim = config.emb_dim       # 512 by default\n        self.hidden_dim = self.dim * 4  # 2048 by default\n        self.n_heads = config.n_heads   # 8 by default\n        self.n_layers = config.n_layers\n        self.dropout = config.dropout\n        self.attention_dropout = config.attention_dropout\n        assert self.dim % self.n_heads == 0, \'transformer dim must be a multiple of n_heads\'\n\n        # embeddings\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, self.dim)\n        if config.sinusoidal_embeddings:\n            create_sinusoidal_embeddings(config.max_position_embeddings, self.dim, out=self.position_embeddings.weight)\n        if config.n_langs > 1:\n            self.lang_embeddings = nn.Embedding(self.n_langs, self.dim)\n        self.embeddings = nn.Embedding(self.n_words, self.dim, padding_idx=self.pad_index)\n        self.layer_norm_emb = nn.LayerNorm(self.dim, eps=config.layer_norm_eps)\n\n        # transformer layers\n        self.attentions = nn.ModuleList()\n        self.layer_norm1 = nn.ModuleList()\n        self.ffns = nn.ModuleList()\n        self.layer_norm2 = nn.ModuleList()\n        # if self.is_decoder:\n        #     self.layer_norm15 = nn.ModuleList()\n        #     self.encoder_attn = nn.ModuleList()\n\n        for _ in range(self.n_layers):\n            self.attentions.append(MultiHeadAttention(self.n_heads, self.dim, config=config))\n            self.layer_norm1.append(nn.LayerNorm(self.dim, eps=config.layer_norm_eps))\n            # if self.is_decoder:\n            #     self.layer_norm15.append(nn.LayerNorm(self.dim, eps=config.layer_norm_eps))\n            #     self.encoder_attn.append(MultiHeadAttention(self.n_heads, self.dim, dropout=self.attention_dropout))\n            self.ffns.append(TransformerFFN(self.dim, self.hidden_dim, self.dim, config=config))\n            self.layer_norm2.append(nn.LayerNorm(self.dim, eps=config.layer_norm_eps))\n\n        self.apply(self.init_weights)\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.embeddings = self._get_resized_embeddings(self.embeddings, new_num_tokens)\n        return self.embeddings\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n            See base class PreTrainedModel\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.attentions[layer].prune_heads(heads)\n\n    def forward(self, input_ids, lengths=None, position_ids=None, langs=None,\n                token_type_ids=None, attention_mask=None, cache=None, head_mask=None):  # src_enc=None, src_len=None, \n        if lengths is None:\n            lengths = (input_ids != self.pad_index).sum(dim=1).long()\n        # mask = input_ids != self.pad_index\n\n        # check inputs\n        bs, slen = input_ids.size()\n        assert lengths.size(0) == bs\n        assert lengths.max().item() <= slen\n        # input_ids = input_ids.transpose(0, 1)  # batch size as dimension 0\n        # assert (src_enc is None) == (src_len is None)\n        # if src_enc is not None:\n        #     assert self.is_decoder\n        #     assert src_enc.size(0) == bs\n\n        # generate masks\n        mask, attn_mask = get_masks(slen, lengths, self.causal, padding_mask=attention_mask)\n        # if self.is_decoder and src_enc is not None:\n        #     src_mask = torch.arange(src_len.max(), dtype=torch.long, device=lengths.device) < src_len[:, None]\n\n        # position_ids\n        if position_ids is None:\n            position_ids = input_ids.new((slen,)).long()\n            position_ids = torch.arange(slen, out=position_ids).unsqueeze(0)\n        else:\n            assert position_ids.size() == (bs, slen)  # (slen, bs)\n            # position_ids = position_ids.transpose(0, 1)\n\n        # langs\n        if langs is not None:\n            assert langs.size() == (bs, slen)  # (slen, bs)\n            # langs = langs.transpose(0, 1)\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x qlen x klen]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.n_layers, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.n_layers\n\n        # do not recompute cached elements\n        if cache is not None:\n            _slen = slen - cache[\'slen\']\n            input_ids = input_ids[:, -_slen:]\n            position_ids = position_ids[:, -_slen:]\n            if langs is not None:\n                langs = langs[:, -_slen:]\n            mask = mask[:, -_slen:]\n            attn_mask = attn_mask[:, -_slen:]\n\n        # embeddings\n        tensor = self.embeddings(input_ids)\n        tensor = tensor + self.position_embeddings(position_ids).expand_as(tensor)\n        if langs is not None:\n            tensor = tensor + self.lang_embeddings(langs)\n        if token_type_ids is not None:\n            tensor = tensor + self.embeddings(token_type_ids)\n        tensor = self.layer_norm_emb(tensor)\n        tensor = F.dropout(tensor, p=self.dropout, training=self.training)\n        tensor *= mask.unsqueeze(-1).to(tensor.dtype)\n\n        # transformer layers\n        hidden_states = ()\n        attentions = ()\n        for i in range(self.n_layers):\n            if self.output_hidden_states:\n                hidden_states = hidden_states + (tensor,)\n\n            # self attention\n            attn_outputs = self.attentions[i](tensor, attn_mask, cache=cache, head_mask=head_mask[i])\n            attn = attn_outputs[0]\n            if self.output_attentions:\n                attentions = attentions + (attn_outputs[1],)\n            attn = F.dropout(attn, p=self.dropout, training=self.training)\n            tensor = tensor + attn\n            tensor = self.layer_norm1[i](tensor)\n\n            # encoder attention (for decoder only)\n            # if self.is_decoder and src_enc is not None:\n            #     attn = self.encoder_attn[i](tensor, src_mask, kv=src_enc, cache=cache)\n            #     attn = F.dropout(attn, p=self.dropout, training=self.training)\n            #     tensor = tensor + attn\n            #     tensor = self.layer_norm15[i](tensor)\n\n            # FFN\n            tensor = tensor + self.ffns[i](tensor)\n            tensor = self.layer_norm2[i](tensor)\n            tensor *= mask.unsqueeze(-1).to(tensor.dtype)\n\n        # Add last hidden state\n        if self.output_hidden_states:\n            hidden_states = hidden_states + (tensor,)\n\n        # update cache length\n        if cache is not None:\n            cache[\'slen\'] += tensor.size(1)\n\n        # move back sequence length to dimension 0\n        # tensor = tensor.transpose(0, 1)\n\n        outputs = (tensor,)\n        if self.output_hidden_states:\n            outputs = outputs + (hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (attentions,)\n        return outputs  # outputs, (hidden_states), (attentions)\n\n\nclass XLMPredLayer(nn.Module):\n    """"""\n    Prediction layer (cross_entropy or adaptive_softmax).\n    """"""\n    def __init__(self, config):\n        super(XLMPredLayer, self).__init__()\n        self.asm = config.asm\n        self.n_words = config.n_words\n        self.pad_index = config.pad_index\n        dim = config.emb_dim\n\n        if config.asm is False:\n            self.proj = nn.Linear(dim, config.n_words, bias=True)\n        else:\n            self.proj = nn.AdaptiveLogSoftmaxWithLoss(\n                in_features=dim,\n                n_classes=config.n_words,\n                cutoffs=config.asm_cutoffs,\n                div_value=config.asm_div_value,\n                head_bias=True,  # default is False\n            )\n\n    def forward(self, x, y=None):\n        """""" Compute the loss, and optionally the scores.\n        """"""\n        outputs = ()\n        if self.asm is False:\n            scores = self.proj(x).view(-1, self.n_words)\n            outputs = (scores,) + outputs\n            if y is not None:\n                loss = F.cross_entropy(scores, y, reduction=\'elementwise_mean\')\n                outputs = (loss,) + outputs\n        else:\n            scores = self.proj.log_prob(x)\n            outputs = (scores,) + outputs\n            if y is not None:\n                _, loss = self.proj(x, y)\n                outputs = (loss,) + outputs\n\n        return outputs\n\n\n@add_start_docstrings(""""""The XLM Model transformer with a language modeling head on top\n    (linear layer with weights tied to the input embeddings). """""",\n    XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMWithLMHeadModel(XLMPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMWithLMHeadModel.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(XLMWithLMHeadModel, self).__init__(config)\n        self.transformer = XLMModel(config)\n        self.pred_layer = XLMPredLayer(config)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the embeddings\n        """"""\n        self._tie_or_clone_weights(self.pred_layer.proj, self.transformer.embeddings)\n\n    def forward(self, input_ids, lengths=None, position_ids=None, langs=None, token_type_ids=None,\n                attention_mask=None, cache=None, labels=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, lengths=lengths, position_ids=position_ids,\n                                               token_type_ids=token_type_ids, langs=langs,\n                                               attention_mask=attention_mask, cache=cache, head_mask=head_mask)\n\n        output = transformer_outputs[0]\n        outputs = self.pred_layer(output, labels)\n        outputs = outputs + transformer_outputs[1:]  # Keep new_mems and attention/hidden states if they are here\n\n        return outputs\n\n\n@add_start_docstrings(""""""XLM Model with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n    XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMForSequenceClassification(XLMPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMForSequenceClassification.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLMForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.transformer = XLMModel(config)\n        self.sequence_summary = SequenceSummary(config)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, lengths=None, position_ids=None, langs=None, token_type_ids=None,\n                attention_mask=None, cache=None, labels=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, lengths=lengths, position_ids=position_ids,\n                                               token_type_ids=token_type_ids, langs=langs,\n                                               attention_mask=attention_mask, cache=cache, head_mask=head_mask)\n\n        output = transformer_outputs[0]\n        logits = self.sequence_summary(output)\n\n        outputs = (logits,) + transformer_outputs[1:]  # Keep new_mems and attention/hidden states if they are here\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs\n\n\n@add_start_docstrings(""""""XLM Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    XLM_START_DOCSTRING, XLM_INPUTS_DOCSTRING)\nclass XLMForQuestionAnswering(XLMPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **is_impossible**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels whether a question has an answer or no answer (SQuAD 2.0)\n        **cls_index**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the classification token to use as input for computing plausibility of the answer.\n        **p_mask**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Optional mask of tokens which can\'t be in answers (e.g. [CLS], [PAD], ...) \n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMForQuestionAnswering.from_pretrained(\'xlm-mlm-en-2048\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLMForQuestionAnswering, self).__init__(config)\n\n        self.transformer = XLMModel(config)\n        self.qa_outputs = SQuADHead(config)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, lengths=None, position_ids=None, langs=None, token_type_ids=None,\n                attention_mask=None, cache=None, start_positions=None, end_positions=None,\n                cls_index=None, is_impossible=None, p_mask=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, lengths=lengths, position_ids=position_ids,\n                                               token_type_ids=token_type_ids, langs=langs,\n                                               attention_mask=attention_mask, cache=cache, head_mask=head_mask)\n\n        output = transformer_outputs[0]\n\n        outputs = self.qa_outputs(output, start_positions=start_positions, end_positions=end_positions,\n                                  cls_index=cls_index, is_impossible=is_impossible, p_mask=p_mask)\n\n        outputs = outputs + transformer_outputs[1:]  # Keep new_mems and attention/hidden states if they are here\n\n        return outputs\n'"
bertviz/transformers_neuron_view/modeling_xlnet.py,115,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# Change log\n# 7/14/19  Jesse Vig   Adapted for use in visualization\n\n"""""" PyTorch XLNet model.\n""""""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_utils import (CONFIG_NAME, WEIGHTS_NAME, PretrainedConfig, PreTrainedModel,\n                             SequenceSummary, PoolerAnswerClass, PoolerEndLogits, PoolerStartLogits,\n                             add_start_docstrings)\n\n\nlogger = logging.getLogger(__name__)\n\nXLNET_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'xlnet-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-base-cased-pytorch_model.bin"",\n    \'xlnet-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-large-cased-pytorch_model.bin"",\n}\nXLNET_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \'xlnet-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-base-cased-config.json"",\n    \'xlnet-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-large-cased-config.json"",\n}\n\n\ndef build_tf_xlnet_to_pytorch_map(model, config, tf_weights=None):\n    """""" A map of modules from TF to PyTorch.\n        I use a map to keep the PyTorch model as\n        identical to the original PyTorch model as possible.\n    """"""\n\n    tf_to_pt_map = {}\n\n    if hasattr(model, \'transformer\'):\n        if hasattr(model, \'lm_loss\'):\n            # We will load also the output bias\n            tf_to_pt_map[\'model/lm_loss/bias\'] = model.lm_loss.bias\n        if hasattr(model, \'sequence_summary\') and \'model/sequnece_summary/summary/kernel\' in tf_weights:\n            # We will load also the sequence summary\n            tf_to_pt_map[\'model/sequnece_summary/summary/kernel\'] = model.sequence_summary.summary.weight\n            tf_to_pt_map[\'model/sequnece_summary/summary/bias\'] = model.sequence_summary.summary.bias\n        if hasattr(model, \'logits_proj\') and config.finetuning_task is not None \\\n                and \'model/regression_{}/logit/kernel\'.format(config.finetuning_task) in tf_weights:\n            tf_to_pt_map[\'model/regression_{}/logit/kernel\'.format(config.finetuning_task)] = model.logits_proj.weight\n            tf_to_pt_map[\'model/regression_{}/logit/bias\'.format(config.finetuning_task)] = model.logits_proj.bias\n\n        # Now load the rest of the transformer\n        model = model.transformer\n\n    # Embeddings and output\n    tf_to_pt_map.update({\'model/transformer/word_embedding/lookup_table\': model.word_embedding.weight,\n                         \'model/transformer/mask_emb/mask_emb\': model.mask_emb})\n\n    # Transformer blocks\n    for i, b in enumerate(model.layer):\n        layer_str = ""model/transformer/layer_%d/"" % i\n        tf_to_pt_map.update({\n            layer_str + ""rel_attn/LayerNorm/gamma"": b.rel_attn.layer_norm.weight,\n            layer_str + ""rel_attn/LayerNorm/beta"": b.rel_attn.layer_norm.bias,\n            layer_str + ""rel_attn/o/kernel"": b.rel_attn.o,\n            layer_str + ""rel_attn/q/kernel"": b.rel_attn.q,\n            layer_str + ""rel_attn/k/kernel"": b.rel_attn.k,\n            layer_str + ""rel_attn/r/kernel"": b.rel_attn.r,\n            layer_str + ""rel_attn/v/kernel"": b.rel_attn.v,\n            layer_str + ""ff/LayerNorm/gamma"": b.ff.layer_norm.weight,\n            layer_str + ""ff/LayerNorm/beta"": b.ff.layer_norm.bias,\n            layer_str + ""ff/layer_1/kernel"": b.ff.layer_1.weight,\n            layer_str + ""ff/layer_1/bias"": b.ff.layer_1.bias,\n            layer_str + ""ff/layer_2/kernel"": b.ff.layer_2.weight,\n            layer_str + ""ff/layer_2/bias"": b.ff.layer_2.bias,\n        })\n\n    # Relative positioning biases\n    if config.untie_r:\n        r_r_list = []\n        r_w_list = []\n        r_s_list = []\n        seg_embed_list = []\n        for b in model.layer:\n            r_r_list.append(b.rel_attn.r_r_bias)\n            r_w_list.append(b.rel_attn.r_w_bias)\n            r_s_list.append(b.rel_attn.r_s_bias)\n            seg_embed_list.append(b.rel_attn.seg_embed)\n    else:\n        r_r_list = [model.r_r_bias]\n        r_w_list = [model.r_w_bias]\n        r_s_list = [model.r_s_bias]\n        seg_embed_list = [model.seg_embed]\n    tf_to_pt_map.update({\n        \'model/transformer/r_r_bias\': r_r_list,\n        \'model/transformer/r_w_bias\': r_w_list,\n        \'model/transformer/r_s_bias\': r_s_list,\n        \'model/transformer/seg_embed\': seg_embed_list})\n    return tf_to_pt_map\n\ndef load_tf_weights_in_xlnet(model, config, tf_path):\n    """""" Load tf checkpoints in a pytorch model\n    """"""\n    try:\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow models in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    tf_weights = {}\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        tf_weights[name] = array\n\n    # Build TF to PyTorch weights loading map\n    tf_to_pt_map = build_tf_xlnet_to_pytorch_map(model, config, tf_weights)\n\n    for name, pointer in tf_to_pt_map.items():\n        logger.info(""Importing {}"".format(name))\n        if name not in tf_weights:\n            logger.info(""{} not in tf pre-trained weights, skipping"".format(name))\n            continue\n        array = tf_weights[name]\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if \'kernel\' in name and (\'ff\' in name or \'summary\' in name or \'logit\' in name):\n            logger.info(""Transposing"")\n            array = np.transpose(array)\n        if isinstance(pointer, list):\n            # Here we will split the TF weigths\n            assert len(pointer) == array.shape[0]\n            for i, p_i in enumerate(pointer):\n                arr_i = array[i, ...]\n                try:\n                    assert p_i.shape == arr_i.shape\n                except AssertionError as e:\n                    e.args += (p_i.shape, arr_i.shape)\n                    raise\n                logger.info(""Initialize PyTorch weight {} for layer {}"".format(name, i))\n                p_i.data = torch.from_numpy(arr_i)\n        else:\n            try:\n                assert pointer.shape == array.shape\n            except AssertionError as e:\n                e.args += (pointer.shape, array.shape)\n                raise\n            logger.info(""Initialize PyTorch weight {}"".format(name))\n            pointer.data = torch.from_numpy(array)\n        tf_weights.pop(name, None)\n        tf_weights.pop(name + \'/Adam\', None)\n        tf_weights.pop(name + \'/Adam_1\', None)\n\n    logger.info(""Weights not copied to PyTorch model: {}"".format(\', \'.join(tf_weights.keys())))\n    return model\n\n\ndef gelu(x):\n    """""" Implementation of the gelu activation function.\n        XLNet is using OpenAI GPT\'s gelu (not exactly the same as BERT)\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    cdf = 0.5 * (1.0 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n    return x * cdf\n\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT2FN = {""gelu"": gelu, ""relu"": torch.nn.functional.relu, ""swish"": swish}\n\n\nclass XLNetConfig(PretrainedConfig):\n    """"""Configuration class to store the configuration of a ``XLNetModel``.\n\n    Args:\n        vocab_size_or_config_json_file: Vocabulary size of ``inputs_ids`` in ``XLNetModel``.\n        d_model: Size of the encoder layers and the pooler layer.\n        n_layer: Number of hidden layers in the Transformer encoder.\n        n_head: Number of attention heads for each attention layer in\n            the Transformer encoder.\n        d_inner: The size of the ""intermediate"" (i.e., feed-forward)\n            layer in the Transformer encoder.\n        ff_activation: The non-linear activation function (function or string) in the\n            encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n        untie_r: untie relative position biases\n        attn_type: \'bi\' for XLNet, \'uni\' for Transformer-XL\n\n        dropout: The dropout probabilitiy for all fully connected\n            layers in the embeddings, encoder, and pooler.\n        dropatt: The dropout ratio for the attention\n            probabilities.\n        initializer_range: The sttdev of the truncated_normal_initializer for\n            initializing all weight matrices.\n        layer_norm_eps: The epsilon used by LayerNorm.\n\n        dropout: float, dropout rate.\n        dropatt: float, dropout rate on attention probabilities.\n        init: str, the initialization scheme, either ""normal"" or ""uniform"".\n        init_range: float, initialize the parameters with a uniform distribution\n            in [-init_range, init_range]. Only effective when init=""uniform"".\n        init_std: float, initialize the parameters with a normal distribution\n            with mean 0 and stddev init_std. Only effective when init=""normal"".\n        mem_len: int, the number of tokens to cache.\n        reuse_len: int, the number of tokens in the currect batch to be cached\n            and reused in the future.\n        bi_data: bool, whether to use bidirectional input pipeline.\n            Usually set to True during pretraining and False during finetuning.\n        clamp_len: int, clamp all relative distances larger than clamp_len.\n            -1 means no clamping.\n        same_length: bool, whether to use the same attention length for each token.\n        finetuning_task: name of the glue task on which the model was fine-tuned if any\n    """"""\n    pretrained_config_archive_map = XLNET_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=32000,\n                 d_model=1024,\n                 n_layer=24,\n                 n_head=16,\n                 d_inner=4096,\n                 ff_activation=""gelu"",\n                 untie_r=True,\n                 attn_type=""bi"",\n\n                 initializer_range=0.02,\n                 layer_norm_eps=1e-12,\n\n                 dropout=0.1,\n                 mem_len=None,\n                 reuse_len=None,\n                 bi_data=False,\n                 clamp_len=-1,\n                 same_length=False,\n\n                 finetuning_task=None,\n                 num_labels=2,\n                 summary_type=\'last\',\n                 summary_use_proj=True,\n                 summary_activation=\'tanh\',\n                 summary_last_dropout=0.1,\n                 start_n_top=5,\n                 end_n_top=5,\n                 **kwargs):\n        """"""Constructs XLNetConfig.\n        """"""\n        super(XLNetConfig, self).__init__(**kwargs)\n\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.n_token = vocab_size_or_config_json_file\n            self.d_model = d_model\n            self.n_layer = n_layer\n            self.n_head = n_head\n            assert d_model % n_head == 0\n            self.d_head = d_model // n_head\n            self.ff_activation = ff_activation\n            self.d_inner = d_inner\n            self.untie_r = untie_r\n            self.attn_type = attn_type\n\n            self.initializer_range = initializer_range\n            self.layer_norm_eps = layer_norm_eps\n\n            self.dropout = dropout\n            self.mem_len = mem_len\n            self.reuse_len = reuse_len\n            self.bi_data = bi_data\n            self.clamp_len = clamp_len\n            self.same_length = same_length\n\n            self.finetuning_task = finetuning_task\n            self.num_labels = num_labels\n            self.summary_type = summary_type\n            self.summary_use_proj = summary_use_proj\n            self.summary_activation = summary_activation\n            self.summary_last_dropout = summary_last_dropout\n            self.start_n_top = start_n_top\n            self.end_n_top = end_n_top\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             ""or the path to a pretrained model config file (str)"")\n\n    @property\n    def max_position_embeddings(self):\n        return -1\n\n    @property\n    def vocab_size(self):\n        return self.n_token\n\n    @vocab_size.setter\n    def vocab_size(self, value):\n        self.n_token = value\n\n    @property\n    def hidden_size(self):\n        return self.d_model\n\n    @property\n    def num_attention_heads(self):\n        return self.n_head\n\n    @property\n    def num_hidden_layers(self):\n        return self.n_layer\n\n\ntry:\n    from apex.normalization.fused_layer_norm import FusedLayerNorm as XLNetLayerNorm\nexcept (ImportError, AttributeError) as e:\n    logger.info(""Better speed can be achieved with apex installed from https://www.github.com/nvidia/apex ."")\n    class XLNetLayerNorm(nn.Module):\n        def __init__(self, d_model, eps=1e-12):\n            """"""Construct a layernorm module in the TF style (epsilon inside the square root).\n            """"""\n            super(XLNetLayerNorm, self).__init__()\n            self.weight = nn.Parameter(torch.ones(d_model))\n            self.bias = nn.Parameter(torch.zeros(d_model))\n            self.variance_epsilon = eps\n\n        def forward(self, x):\n            u = x.mean(-1, keepdim=True)\n            s = (x - u).pow(2).mean(-1, keepdim=True)\n            x = (x - u) / torch.sqrt(s + self.variance_epsilon)\n            return self.weight * x + self.bias\n\nclass XLNetRelativeAttention(nn.Module):\n    def __init__(self, config):\n        super(XLNetRelativeAttention, self).__init__()\n        self.output_attentions = config.output_attentions\n\n        if config.d_model % config.n_head != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.d_model, config.n_head))\n\n        self.n_head = config.n_head\n        self.d_head = config.d_head\n        self.d_model = config.d_model\n        self.scale = 1 / (config.d_head ** 0.5)\n\n        self.q = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.k = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.v = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.o = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n        self.r = nn.Parameter(torch.FloatTensor(config.d_model, self.n_head, self.d_head))\n\n        self.r_r_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        self.r_s_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        self.r_w_bias = nn.Parameter(torch.FloatTensor(self.n_head, self.d_head))\n        self.seg_embed = nn.Parameter(torch.FloatTensor(2, self.n_head, self.d_head))\n\n        self.layer_norm = XLNetLayerNorm(config.d_model, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.dropout)\n\n    def prune_heads(self, heads):\n        raise NotImplementedError\n\n    @staticmethod\n    def rel_shift(x, klen=-1):\n        """"""perform relative shift to form the relative attention score.""""""\n        x_size = x.shape\n\n        x = x.reshape(x_size[1], x_size[0], x_size[2], x_size[3])\n        x = x[1:, ...]\n        x = x.reshape(x_size[0], x_size[1] - 1, x_size[2], x_size[3])\n        # x = x[:, 0:klen, :, :]\n        x = torch.index_select(x, 1, torch.arange(klen, device=x.device, dtype=torch.long))\n\n        return x\n\n    def rel_attn_core(self, q_head, k_head_h, v_head_h, k_head_r, seg_mat=None, attn_mask=None, head_mask=None):\n        """"""Core relative positional attention operations.""""""\n\n        # content based attention score\n        ac = torch.einsum(\'ibnd,jbnd->ijbn\', q_head + self.r_w_bias, k_head_h)\n\n        # position based attention score\n        bd = torch.einsum(\'ibnd,jbnd->ijbn\', q_head + self.r_r_bias, k_head_r)\n        bd = self.rel_shift(bd, klen=ac.shape[1])\n\n        # segment based attention score\n        if seg_mat is None:\n            ef = 0\n        else:\n            ef = torch.einsum(\'ibnd,snd->ibns\', q_head + self.r_s_bias, self.seg_embed)\n            ef = torch.einsum(\'ijbs,ibns->ijbn\', seg_mat, ef)\n\n        # merge attention scores and perform masking\n        attn_score = (ac + bd + ef) * self.scale\n        if attn_mask is not None:\n            # attn_score = attn_score * (1 - attn_mask) - 1e30 * attn_mask\n            attn_score = attn_score - 1e30 * attn_mask\n\n        # attention probability\n        attn_prob = F.softmax(attn_score, dim=1)\n        attn_prob = self.dropout(attn_prob)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attn_prob = attn_prob * head_mask\n\n        # attention output\n        attn_vec = torch.einsum(\'ijbn,jbnd->ibnd\', attn_prob, v_head_h)\n\n        if self.output_attentions:\n            return attn_vec, attn_prob\n\n        return attn_vec\n\n    def post_attention(self, h, attn_vec, residual=True):\n        """"""Post-attention processing.""""""\n        # post-attention projection (back to `d_model`)\n        attn_out = torch.einsum(\'ibnd,hnd->ibh\', attn_vec, self.o)\n\n        attn_out = self.dropout(attn_out)\n        if residual:\n            attn_out = attn_out + h\n        output = self.layer_norm(attn_out)\n\n        return output\n\n    def forward(self, h, g,\n                      attn_mask_h, attn_mask_g,\n                      r, seg_mat,\n                      mems=None, target_mapping=None, head_mask=None):\n        if g is not None:\n            ###### Two-stream attention with relative positional encoding.\n            # content based attention score\n            if mems is not None and mems.dim() > 1:\n                cat = torch.cat([mems, h], dim=0)\n            else:\n                cat = h\n\n            # content-based key head\n            k_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.k)\n\n            # content-based value head\n            v_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.v)\n\n            # position-based key head\n            k_head_r = torch.einsum(\'ibh,hnd->ibnd\', r, self.r)\n\n            ##### h-stream\n            # content-stream query head\n            q_head_h = torch.einsum(\'ibh,hnd->ibnd\', h, self.q)\n\n            # core attention ops\n            attn_vec_h = self.rel_attn_core(\n                q_head_h, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_h, head_mask=head_mask)\n\n            if self.output_attentions:\n                attn_vec_h, attn_prob_h = attn_vec_h\n\n            # post processing\n            output_h = self.post_attention(h, attn_vec_h)\n\n            ##### g-stream\n            # query-stream query head\n            q_head_g = torch.einsum(\'ibh,hnd->ibnd\', g, self.q)\n\n            # core attention ops\n            if target_mapping is not None:\n                q_head_g = torch.einsum(\'mbnd,mlb->lbnd\', q_head_g, target_mapping)\n                attn_vec_g = self.rel_attn_core(\n                    q_head_g, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_g, head_mask=head_mask)\n\n                if self.output_attentions:\n                    attn_vec_g, attn_prob_g = attn_vec_g\n\n                attn_vec_g = torch.einsum(\'lbnd,mlb->mbnd\', attn_vec_g, target_mapping)\n            else:\n                attn_vec_g = self.rel_attn_core(\n                    q_head_g, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_g, head_mask=head_mask)\n\n                if self.output_attentions:\n                    attn_vec_g, attn_prob_g = attn_vec_g\n\n            # post processing\n            output_g = self.post_attention(g, attn_vec_g)\n\n            if self.output_attentions:\n                attn_prob = attn_prob_h, attn_prob_g\n\n        else:\n            ###### Multi-head attention with relative positional encoding\n            if mems is not None and mems.dim() > 1:\n                cat = torch.cat([mems, h], dim=0)\n            else:\n                cat = h\n\n            # content heads\n            q_head_h = torch.einsum(\'ibh,hnd->ibnd\', h, self.q)\n            k_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.k)\n            v_head_h = torch.einsum(\'ibh,hnd->ibnd\', cat, self.v)\n\n            # positional heads\n            k_head_r = torch.einsum(\'ibh,hnd->ibnd\', r, self.r)\n\n            # core attention ops\n            attn_vec = self.rel_attn_core(\n                q_head_h, k_head_h, v_head_h, k_head_r, seg_mat=seg_mat, attn_mask=attn_mask_h, head_mask=head_mask)\n\n            if self.output_attentions:\n                attn_vec, attn_prob = attn_vec\n\n            # post processing\n            output_h = self.post_attention(h, attn_vec)\n            output_g = None\n\n        outputs = (output_h, output_g)\n        if self.output_attentions:\n            attn_data = {\n                \'attn\': attn_prob.permute(2, 3, 0, 1).contiguous(),\n            }\n            # T\xce\xa9\xce\xa9\xce\xa9 Add query, key, etc. info (Uses different mechanism than standard transformer)\n            outputs = outputs + (attn_data,)\n        return outputs\n\nclass XLNetFeedForward(nn.Module):\n    def __init__(self, config):\n        super(XLNetFeedForward, self).__init__()\n        self.layer_norm = XLNetLayerNorm(config.d_model, eps=config.layer_norm_eps)\n        self.layer_1 = nn.Linear(config.d_model, config.d_inner)\n        self.layer_2 = nn.Linear(config.d_inner, config.d_model)\n        self.dropout = nn.Dropout(config.dropout)\n        if isinstance(config.ff_activation, str) or \\\n                (sys.version_info[0] == 2 and isinstance(config.ff_activation, unicode)):\n            self.activation_function = ACT2FN[config.ff_activation]\n        else:\n            self.activation_function = config.ff_activation\n\n    def forward(self, inp):\n        output = inp\n        output = self.layer_1(output)\n        output = self.activation_function(output)\n        output = self.dropout(output)\n        output = self.layer_2(output)\n        output = self.dropout(output)\n        output = self.layer_norm(output + inp)\n        return output\n\nclass XLNetLayer(nn.Module):\n    def __init__(self, config):\n        super(XLNetLayer, self).__init__()\n        self.rel_attn = XLNetRelativeAttention(config)\n        self.ff = XLNetFeedForward(config)\n        self.dropout = nn.Dropout(config.dropout)\n\n    def forward(self, output_h, output_g,\n                attn_mask_h, attn_mask_g,\n                r, seg_mat, mems=None, target_mapping=None, head_mask=None):\n        outputs = self.rel_attn(output_h, output_g, attn_mask_h, attn_mask_g,\n                                r, seg_mat, mems=mems, target_mapping=target_mapping,\n                                head_mask=head_mask)\n        output_h, output_g = outputs[:2]\n\n        if output_g is not None:\n            output_g = self.ff(output_g)\n        output_h = self.ff(output_h)\n\n        outputs = (output_h, output_g) + outputs[2:]  # Add again attentions if there are there\n        return outputs\n\n\nclass XLNetPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = XLNetConfig\n    pretrained_model_archive_map = XLNET_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_xlnet\n    base_model_prefix = ""transformer""\n\n    def __init__(self, *inputs, **kwargs):\n        super(XLNetPreTrainedModel, self).__init__(*inputs, **kwargs)\n\n    def init_weights(self, module):\n        """""" Initialize the weights.\n        """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, XLNetLayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n        elif isinstance(module, XLNetRelativeAttention):\n            for param in [module.q, module.k, module.v, module.o, module.r,\n                          module.r_r_bias, module.r_s_bias, module.r_w_bias,\n                          module.seg_embed]:\n                param.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, XLNetModel):\n                module.mask_emb.data.normal_(mean=0.0, std=self.config.initializer_range)\n\n\nXLNET_START_DOCSTRING = r""""""    The XLNet model was proposed in\n    `XLNet: Generalized Autoregressive Pretraining for Language Understanding`_\n    by Zhilin Yang*, Zihang Dai*, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, Quoc V. Le.\n    XLnet is an extension of the Transformer-XL model pre-trained using an autoregressive method\n    to learn bidirectional contexts by maximizing the expected likelihood over all permutations\n    of the input sequence factorization order.\n\n    The specific attention pattern can be controlled at training and test time using the `perm_mask` input.\n\n    Do to the difficulty of training a fully auto-regressive model over various factorization order,\n    XLNet is pretrained using only a sub-set of the output tokens as target which are selected\n    with the `target_mapping` input.\n\n    To use XLNet for sequential decoding (i.e. not in fully bi-directional setting), use the `perm_mask` and\n    `target_mapping` inputs to control the attention span and outputs (see examples in `examples/run_generation.py`)\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`XLNet: Generalized Autoregressive Pretraining for Language Understanding`:\n        http://arxiv.org/abs/1906.08237\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~pytorch_transformers.XLNetConfig`): Model configuration class with all the parameters of the model.\n""""""\n\nXLNET_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            Indices can be obtained using :class:`pytorch_transformers.XLNetTokenizer`.\n            See :func:`pytorch_transformers.PreTrainedTokenizer.encode` and\n            :func:`pytorch_transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            A parallel sequence of tokens (can be used to indicate various portions of the inputs).\n            The embeddings from these tokens will be summed with the respective token embeddings.\n            Indices are selected in the vocabulary (unlike BERT which has a specific vocabulary for segment indices).\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **input_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Negative of `attention_mask`, i.e. with 0 for real tokens and 1 for padding.\n            Kept for compatibility with the original code base.\n            You can only uses one of `input_mask` and `attention_mask`\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are MASKED, ``0`` for tokens that are NOT MASKED.\n        **mems**: (`optional`)\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` output below). Can be used to speed up sequential decoding and attend to longer context.\n        **perm_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, sequence_length)``:\n            Mask to indicate the attention pattern for each input token with values selected in ``[0, 1]``:\n            If ``perm_mask[k, i, j] = 0``, i attend to j in batch k;\n            if ``perm_mask[k, i, j] = 1``, i does not attend to j in batch k.\n            If None, each token attends to all the others (full bidirectional attention).\n            Only used during pretraining (to define factorization order) or for sequential decoding (generation).\n        **target_mapping**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, num_predict, sequence_length)``:\n            Mask to indicate the output tokens to use.\n            If ``target_mapping[k, i, j] = 1``, the i-th predict in batch k is on the j-th token.\n            Only used during pretraining for partial prediction or for sequential decoding (generation).\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare XLNet Model transformer outputing raw hidden-states without any specific head on top."",\n                      XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetModel(XLNetPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the last layer of the model.\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLNetModel.from_pretrained(\'xlnet-large-cased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(XLNetModel, self).__init__(config)\n        config.output_attentions = True\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n\n        self.mem_len = config.mem_len\n        self.reuse_len = config.reuse_len\n        self.d_model = config.d_model\n        self.same_length = config.same_length\n        self.attn_type = config.attn_type\n        self.bi_data = config.bi_data\n        self.clamp_len = config.clamp_len\n        self.n_layer = config.n_layer\n\n        self.word_embedding = nn.Embedding(config.n_token, config.d_model)\n        self.mask_emb = nn.Parameter(torch.FloatTensor(1, 1, config.d_model))\n        self.layer = nn.ModuleList([XLNetLayer(config) for _ in range(config.n_layer)])\n        self.dropout = nn.Dropout(config.dropout)\n\n        self.apply(self.init_weights)\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        self.word_embedding = self._get_resized_embeddings(self.word_embedding, new_num_tokens)\n        return self.word_embedding\n\n    def _prune_heads(self, heads_to_prune):\n        raise NotImplementedError\n\n    def create_mask(self, qlen, mlen):\n        """"""\n        Creates causal attention mask. Float mask where 1.0 indicates masked, 0.0 indicates not-masked.\n\n        Args:\n            qlen: TODO Lysandre didn\'t fill\n            mlen: TODO Lysandre didn\'t fill\n\n        ::\n\n                  same_length=False:      same_length=True:\n                  <mlen > <  qlen >       <mlen > <  qlen >\n               ^ [0 0 0 0 0 1 1 1 1]     [0 0 0 0 0 1 1 1 1]\n                 [0 0 0 0 0 0 1 1 1]     [1 0 0 0 0 0 1 1 1]\n            qlen [0 0 0 0 0 0 0 1 1]     [1 1 0 0 0 0 0 1 1]\n                 [0 0 0 0 0 0 0 0 1]     [1 1 1 0 0 0 0 0 1]\n               v [0 0 0 0 0 0 0 0 0]     [1 1 1 1 0 0 0 0 0]\n\n        """"""\n        attn_mask = torch.ones([qlen, qlen])\n        mask_up = torch.triu(attn_mask, diagonal=1)\n        attn_mask_pad = torch.zeros([qlen, mlen])\n        ret = torch.cat([attn_mask_pad, mask_up], dim=1)\n        if self.same_length:\n            mask_lo = torch.tril(attn_mask, diagonal=-1)\n            ret = torch.cat([ret[:, :qlen] + mask_lo, ret[:, qlen:]], dim=1)\n\n        ret = ret.to(next(self.parameters()))\n        return ret\n\n    def cache_mem(self, curr_out, prev_mem):\n        """"""cache hidden states into memory.""""""\n        if self.mem_len is None or self.mem_len == 0:\n            return None\n        else:\n            if self.reuse_len is not None and self.reuse_len > 0:\n                curr_out = curr_out[:self.reuse_len]\n\n            if prev_mem is None:\n                new_mem = curr_out[-self.mem_len:]\n            else:\n                new_mem = torch.cat([prev_mem, curr_out], dim=0)[-self.mem_len:]\n\n        return new_mem.detach()\n\n    @staticmethod\n    def positional_embedding(pos_seq, inv_freq, bsz=None):\n        sinusoid_inp = torch.einsum(\'i,d->id\', pos_seq, inv_freq)\n        pos_emb = torch.cat([torch.sin(sinusoid_inp), torch.cos(sinusoid_inp)], dim=-1)\n        pos_emb = pos_emb[:, None, :]\n\n        if bsz is not None:\n            pos_emb = pos_emb.expand(-1, bsz, -1)\n\n        return pos_emb\n\n    def relative_positional_encoding(self, qlen, klen, bsz=None):\n        """"""create relative positional encoding.""""""\n        freq_seq = torch.arange(0, self.d_model, 2.0, dtype=torch.float)\n        inv_freq = 1 / torch.pow(10000, (freq_seq / self.d_model))\n\n        if self.attn_type == \'bi\':\n            # beg, end = klen - 1, -qlen\n            beg, end = klen, -qlen\n        elif self.attn_type == \'uni\':\n            # beg, end = klen - 1, -1\n            beg, end = klen, -1\n        else:\n            raise ValueError(\'Unknown `attn_type` {}.\'.format(self.attn_type))\n\n        if self.bi_data:\n            fwd_pos_seq = torch.arange(beg, end, -1.0, dtype=torch.float)\n            bwd_pos_seq = torch.arange(-beg, -end, 1.0, dtype=torch.float)\n\n            if self.clamp_len > 0:\n                fwd_pos_seq = fwd_pos_seq.clamp(-self.clamp_len, self.clamp_len)\n                bwd_pos_seq = bwd_pos_seq.clamp(-self.clamp_len, self.clamp_len)\n\n            if bsz is not None:\n                fwd_pos_emb = self.positional_embedding(fwd_pos_seq, inv_freq, bsz//2)\n                bwd_pos_emb = self.positional_embedding(bwd_pos_seq, inv_freq, bsz//2)\n            else:\n                fwd_pos_emb = self.positional_embedding(fwd_pos_seq, inv_freq)\n                bwd_pos_emb = self.positional_embedding(bwd_pos_seq, inv_freq)\n\n            pos_emb = torch.cat([fwd_pos_emb, bwd_pos_emb], dim=1)\n        else:\n            fwd_pos_seq = torch.arange(beg, end, -1.0)\n            if self.clamp_len > 0:\n                fwd_pos_seq = fwd_pos_seq.clamp(-self.clamp_len, self.clamp_len)\n            pos_emb = self.positional_embedding(fwd_pos_seq, inv_freq, bsz)\n\n        pos_emb = pos_emb.to(next(self.parameters()))\n        return pos_emb\n\n    def forward(self, input_ids, token_type_ids=None, input_mask=None, attention_mask=None,\n                mems=None, perm_mask=None, target_mapping=None, head_mask=None):\n        # the original code for XLNet uses shapes [len, bsz] with the batch dimension at the end\n        # but we want a unified interface in the library with the batch size on the first dimension\n        # so we move here the first dimension (batch) to the end\n        input_ids = input_ids.transpose(0, 1).contiguous()\n        token_type_ids = token_type_ids.transpose(0, 1).contiguous() if token_type_ids is not None else None\n        input_mask = input_mask.transpose(0, 1).contiguous() if input_mask is not None else None\n        attention_mask = attention_mask.transpose(0, 1).contiguous() if attention_mask is not None else None\n        perm_mask = perm_mask.permute(1, 2, 0).contiguous() if perm_mask is not None else None\n        target_mapping = target_mapping.permute(1, 2, 0).contiguous() if target_mapping is not None else None\n\n        qlen, bsz = input_ids.shape[0], input_ids.shape[1]\n        mlen = mems[0].shape[0] if mems is not None else 0\n        klen = mlen + qlen\n\n        dtype_float = next(self.parameters()).dtype\n        device = next(self.parameters()).device\n\n        ##### Attention mask\n        # causal attention mask\n        if self.attn_type == \'uni\':\n            attn_mask = self.create_mask(qlen, mlen)\n            attn_mask = attn_mask[:, :, None, None]\n        elif self.attn_type == \'bi\':\n            attn_mask = None\n        else:\n            raise ValueError(\'Unsupported attention type: {}\'.format(self.attn_type))\n\n        # data mask: input mask & perm mask\n        assert input_mask is None or attention_mask is None, ""You can only use one of input_mask (uses 1 for padding) ""\n        ""or attention_mask (uses 0 for padding, added for compatbility with BERT). Please choose one.""\n        if input_mask is None and attention_mask is not None:\n            input_mask = 1.0 - attention_mask\n        if input_mask is not None and perm_mask is not None:\n            data_mask = input_mask[None] + perm_mask\n        elif input_mask is not None and perm_mask is None:\n            data_mask = input_mask[None]\n        elif input_mask is None and perm_mask is not None:\n            data_mask = perm_mask\n        else:\n            data_mask = None\n\n        if data_mask is not None:\n            # all mems can be attended to\n            mems_mask = torch.zeros([data_mask.shape[0], mlen, bsz]).to(data_mask)\n            data_mask = torch.cat([mems_mask, data_mask], dim=1)\n            if attn_mask is None:\n                attn_mask = data_mask[:, :, :, None]\n            else:\n                attn_mask += data_mask[:, :, :, None]\n\n        if attn_mask is not None:\n            attn_mask = (attn_mask > 0).to(dtype_float)\n\n        if attn_mask is not None:\n            non_tgt_mask = -torch.eye(qlen).to(attn_mask)\n            non_tgt_mask = torch.cat([torch.zeros([qlen, mlen]).to(attn_mask), non_tgt_mask], dim=-1)\n            non_tgt_mask = ((attn_mask + non_tgt_mask[:, :, None, None]) > 0).to(attn_mask)\n        else:\n            non_tgt_mask = None\n\n        ##### Word embeddings and prepare h & g hidden states\n        word_emb_k = self.word_embedding(input_ids)\n        output_h = self.dropout(word_emb_k)\n        if target_mapping is not None:\n            word_emb_q = self.mask_emb.expand(target_mapping.shape[0], bsz, -1)\n        # else:  # We removed the inp_q input which was same as target mapping\n        #     inp_q_ext = inp_q[:, :, None]\n        #     word_emb_q = inp_q_ext * self.mask_emb + (1 - inp_q_ext) * word_emb_k\n            output_g = self.dropout(word_emb_q)\n        else:\n            output_g = None\n\n        ##### Segment embedding\n        if token_type_ids is not None:\n            # Convert `token_type_ids` to one-hot `seg_mat`\n            mem_pad = torch.zeros([mlen, bsz], dtype=torch.long, device=device)\n            cat_ids = torch.cat([mem_pad, token_type_ids], dim=0)\n\n            # `1` indicates not in the same segment [qlen x klen x bsz]\n            seg_mat = (token_type_ids[:, None] != cat_ids[None, :]).long()\n            seg_mat = F.one_hot(seg_mat, num_classes=2).to(dtype_float)\n        else:\n            seg_mat = None\n\n        ##### Positional encoding\n        pos_emb = self.relative_positional_encoding(qlen, klen, bsz=bsz)\n        pos_emb = self.dropout(pos_emb)\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads] (a head_mask for each layer)\n        # and head_mask is converted to shape [num_hidden_layers x qlen x klen x bsz x n_head]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(0).unsqueeze(0)\n                head_mask = head_mask.expand(self.n_layer, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(1).unsqueeze(1)\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.n_layer\n\n        new_mems = ()\n        if mems is None:\n            mems = [None] * len(self.layer)\n\n        attentions = []\n        hidden_states = []\n        for i, layer_module in enumerate(self.layer):\n            # cache new mems\n            new_mems = new_mems + (self.cache_mem(output_h, mems[i]),)\n            if self.output_hidden_states:\n                hidden_states.append((output_h, output_g) if output_g is not None else output_h)\n\n            outputs = layer_module(output_h, output_g, attn_mask_h=non_tgt_mask, attn_mask_g=attn_mask,\n                                   r=pos_emb, seg_mat=seg_mat, mems=mems[i], target_mapping=target_mapping,\n                                   head_mask=head_mask[i])\n            output_h, output_g = outputs[:2]\n            if self.output_attentions:\n                attentions.append(outputs[2])\n\n        # Add last hidden state\n        if self.output_hidden_states:\n            hidden_states.append((output_h, output_g) if output_g is not None else output_h)\n\n        output = self.dropout(output_g if output_g is not None else output_h)\n\n        # Prepare outputs, we transpose back here to shape [bsz, len, hidden_dim] (cf. beginning of forward() method)\n        outputs = (output.permute(1, 0, 2).contiguous(), new_mems)\n        if self.output_hidden_states:\n            if output_g is not None:\n                hidden_states = tuple(h.permute(1, 0, 2).contiguous() for hs in hidden_states for h in hs)\n            else:\n                hidden_states = tuple(hs.permute(1, 0, 2).contiguous() for hs in hidden_states)\n            outputs = outputs + (hidden_states,)\n        if self.output_attentions:\n#            attentions = tuple(t.permute(2, 3, 0, 1).contiguous() for t in attentions)\n            outputs = outputs + (attentions,)\n\n        return outputs  # outputs, new_mems, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""XLNet Model with a language modeling head on top\n    (linear layer with weights tied to the input embeddings). """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetLMHeadModel(XLNetPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for language modeling.\n            Note that the labels **are shifted** inside the model, i.e. you can set ``lm_labels = input_ids``\n            Indices are selected in ``[-1, 0, ..., config.vocab_size]``\n            All labels set to ``-1`` are ignored (masked), the loss is only\n            computed for labels in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLNetLMHeadModel.from_pretrained(\'xlnet-large-cased\')\n        # We show how to setup inputs to predict a next token using a bi-directional context.\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is very <mask>"")).unsqueeze(0)  # We will predict the masked token\n        perm_mask = torch.zeros((1, input_ids.shape[1], input_ids.shape[1]), dtype=torch.float)\n        perm_mask[:, :, -1] = 1.0  # Previous tokens don\'t see last token\n        target_mapping = torch.zeros((1, 1, input_ids.shape[1]), dtype=torch.float)  # Shape [1, 1, seq_length] => let\'s predict one token\n        target_mapping[0, 0, -1] = 1.0  # Our first (and only) prediction will be the last token of the sequence (the masked token)\n        outputs = model(input_ids, perm_mask=perm_mask, target_mapping=target_mapping)\n        next_token_logits = outputs[0]  # Output has shape [target_mapping.size(0), target_mapping.size(1), config.vocab_size]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetLMHeadModel, self).__init__(config)\n        self.attn_type = config.attn_type\n        self.same_length = config.same_length\n\n        self.transformer = XLNetModel(config)\n        self.lm_loss = nn.Linear(config.d_model, config.n_token, bias=True)\n\n        self.apply(self.init_weights)\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the embeddings\n        """"""\n        self._tie_or_clone_weights(self.lm_loss, self.transformer.word_embedding)\n\n    def forward(self, input_ids, token_type_ids=None, input_mask=None, attention_mask=None,\n                mems=None, perm_mask=None, target_mapping=None,\n                labels=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, token_type_ids=token_type_ids,\n                                               input_mask=input_mask, attention_mask=attention_mask,\n                                               mems=mems, perm_mask=perm_mask, target_mapping=target_mapping,\n                                               head_mask=head_mask)\n\n        logits = self.lm_loss(transformer_outputs[0])\n\n        outputs = (logits,) + transformer_outputs[1:]  # Keep mems, hidden states, attentions if there are in it\n\n        if labels is not None:\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            loss = loss_fct(logits.view(-1, logits.size(-1)),\n                            labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # return (loss), logits, mems, (hidden states), (attentions)\n\n\n@add_start_docstrings(""""""XLNet Model with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetForSequenceClassification(XLNetPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLNetTokenizer.from_pretrained(\'xlnet-large-cased\')\n        model = XLNetForSequenceClassification.from_pretrained(\'xlnet-large-cased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.transformer = XLNetModel(config)\n        self.sequence_summary = SequenceSummary(config)\n        self.logits_proj = nn.Linear(config.d_model, config.num_labels)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, input_mask=None, attention_mask=None,\n                mems=None, perm_mask=None, target_mapping=None,\n                labels=None, head_mask=None):\n        transformer_outputs = self.transformer(input_ids, token_type_ids=token_type_ids,\n                                               input_mask=input_mask, attention_mask=attention_mask,\n                                               mems=mems, perm_mask=perm_mask, target_mapping=target_mapping,\n                                               head_mask=head_mask)\n        output = transformer_outputs[0]\n\n        output = self.sequence_summary(output)\n        logits = self.logits_proj(output)\n\n        outputs = (logits,) + transformer_outputs[1:]  # Keep mems, hidden states, attentions if there are in it\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # return (loss), logits, mems, (hidden states), (attentions)\n\n\n@add_start_docstrings(""""""XLNet Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    XLNET_START_DOCSTRING, XLNET_INPUTS_DOCSTRING)\nclass XLNetForQuestionAnswering(XLNetPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **is_impossible**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels whether a question has an answer or no answer (SQuAD 2.0)\n        **cls_index**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the classification token to use as input for computing plausibility of the answer.\n        **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Optional mask of tokens which can\'t be in answers (e.g. [CLS], [PAD], ...).\n            1.0 means token should be masked. 0.0 mean token is not masked.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned if both ``start_positions`` and ``end_positions`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss as the sum of start token, end token (and is_impossible if provided) classification losses.\n        **start_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top)``\n            Log probabilities for the top config.start_n_top start token possibilities (beam-search).\n        **start_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top)``\n            Indices for the top config.start_n_top start token possibilities (beam-search).\n        **end_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Log probabilities for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **end_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Indices for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **cls_logits**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size,)``\n            Log probabilities for the ``is_impossible`` label of the answers.\n        **mems**:\n            list of ``torch.FloatTensor`` (one for each layer):\n            that contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model\n            (see `mems` input above). Can be used to speed up sequential decoding and attend to longer context.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = XLMTokenizer.from_pretrained(\'xlm-mlm-en-2048\')\n        model = XLMForQuestionAnswering.from_pretrained(\'xlnet-large-cased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(XLNetForQuestionAnswering, self).__init__(config)\n        self.start_n_top = config.start_n_top\n        self.end_n_top = config.end_n_top\n\n        self.transformer = XLNetModel(config)\n        self.start_logits = PoolerStartLogits(config)\n        self.end_logits = PoolerEndLogits(config)\n        self.answer_class = PoolerAnswerClass(config)\n\n        self.apply(self.init_weights)\n\n    def forward(self, input_ids, token_type_ids=None, input_mask=None, attention_mask=None,\n                mems=None, perm_mask=None, target_mapping=None,\n                start_positions=None, end_positions=None, cls_index=None, is_impossible=None, p_mask=None,\n                head_mask=None):\n        transformer_outputs = self.transformer(input_ids, token_type_ids=token_type_ids,\n                                               input_mask=input_mask, attention_mask=attention_mask,\n                                               mems=mems, perm_mask=perm_mask, target_mapping=target_mapping,\n                                               head_mask=head_mask)\n        hidden_states = transformer_outputs[0]\n        start_logits = self.start_logits(hidden_states, p_mask=p_mask)\n\n        outputs = transformer_outputs[1:]  # Keep mems, hidden states, attentions if there are in it\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, let\'s remove the dimension added by batch splitting\n            for x in (start_positions, end_positions, cls_index, is_impossible):\n                if x is not None and x.dim() > 1:\n                    x.squeeze_(-1)\n\n            # during training, compute the end logits based on the ground truth of the start position\n            end_logits = self.end_logits(hidden_states, start_positions=start_positions, p_mask=p_mask)\n\n            loss_fct = CrossEntropyLoss()\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n\n            if cls_index is not None and is_impossible is not None:\n                # Predict answerability from the representation of CLS and START\n                cls_logits = self.answer_class(hidden_states, start_positions=start_positions, cls_index=cls_index)\n                loss_fct_cls = nn.BCEWithLogitsLoss()\n                cls_loss = loss_fct_cls(cls_logits, is_impossible)\n\n                # note(zhiliny): by default multiply the loss by 0.5 so that the scale is comparable to start_loss and end_loss\n                total_loss += cls_loss * 0.5\n\n            outputs = (total_loss,) + outputs\n\n        else:\n            # during inference, compute the end logits based on beam search\n            bsz, slen, hsz = hidden_states.size()\n            start_log_probs = F.softmax(start_logits, dim=-1) # shape (bsz, slen)\n\n            start_top_log_probs, start_top_index = torch.topk(start_log_probs, self.start_n_top, dim=-1) # shape (bsz, start_n_top)\n            start_top_index_exp = start_top_index.unsqueeze(-1).expand(-1, -1, hsz) # shape (bsz, start_n_top, hsz)\n            start_states = torch.gather(hidden_states, -2, start_top_index_exp) # shape (bsz, start_n_top, hsz)\n            start_states = start_states.unsqueeze(1).expand(-1, slen, -1, -1) # shape (bsz, slen, start_n_top, hsz)\n\n            hidden_states_expanded = hidden_states.unsqueeze(2).expand_as(start_states) # shape (bsz, slen, start_n_top, hsz)\n            p_mask = p_mask.unsqueeze(-1) if p_mask is not None else None\n            end_logits = self.end_logits(hidden_states_expanded, start_states=start_states, p_mask=p_mask)\n            end_log_probs = F.softmax(end_logits, dim=1) # shape (bsz, slen, start_n_top)\n\n            end_top_log_probs, end_top_index = torch.topk(end_log_probs, self.end_n_top, dim=1) # shape (bsz, end_n_top, start_n_top)\n            end_top_log_probs = end_top_log_probs.view(-1, self.start_n_top * self.end_n_top)\n            end_top_index = end_top_index.view(-1, self.start_n_top * self.end_n_top)\n\n            start_states = torch.einsum(""blh,bl->bh"", hidden_states, start_log_probs)  # get the representation of START as weighted sum of hidden states\n            cls_logits = self.answer_class(hidden_states, start_states=start_states, cls_index=cls_index)  # Shape (batch size,): one single `cls_logits` for each sample\n\n            outputs = (start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits) + outputs\n\n        # return start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits\n        # or (if labels are provided) (total_loss,)\n        return outputs\n'"
bertviz/transformers_neuron_view/tokenization_bert.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport logging\nimport os\nimport unicodedata\nfrom io import open\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'vocab_file\': \'vocab.txt\'}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-vocab.txt"",\n        \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt"",\n        \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-vocab.txt"",\n        \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-vocab.txt"",\n        \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-vocab.txt"",\n        \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-vocab.txt"",\n        \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-vocab.txt"",\n        \'bert-base-german-cased\': ""https://int-deepset-models-bert.s3.eu-central-1.amazonaws.com/pytorch/bert-base-german-cased-vocab.txt"",\n        \'bert-large-uncased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-vocab.txt"",\n        \'bert-large-cased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-vocab.txt"",\n        \'bert-large-uncased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-finetuned-squad-vocab.txt"",\n        \'bert-large-cased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-finetuned-squad-vocab.txt"",\n        \'bert-base-cased-finetuned-mrpc\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-finetuned-mrpc-vocab.txt"",\n    }\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'bert-base-uncased\': 512,\n    \'bert-large-uncased\': 512,\n    \'bert-base-cased\': 512,\n    \'bert-large-cased\': 512,\n    \'bert-base-multilingual-uncased\': 512,\n    \'bert-base-multilingual-cased\': 512,\n    \'bert-base-chinese\': 512,\n    \'bert-base-german-cased\': 512,\n    \'bert-large-uncased-whole-word-masking\': 512,\n    \'bert-large-cased-whole-word-masking\': 512,\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': 512,\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': 512,\n    \'bert-base-cased-finetuned-mrpc\': 512,\n}\n\ndef load_vocab(vocab_file):\n    """"""Loads a vocabulary file into a dictionary.""""""\n    vocab = collections.OrderedDict()\n    with open(vocab_file, ""r"", encoding=""utf-8"") as reader:\n        tokens = reader.readlines()\n    for index, token in enumerate(tokens):\n        token = token.rstrip(\'\\n\')\n        vocab[token] = index\n    return vocab\n\n\ndef whitespace_tokenize(text):\n    """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n    text = text.strip()\n    if not text:\n        return []\n    tokens = text.split()\n    return tokens\n\n\nclass BertTokenizer(PreTrainedTokenizer):\n    r""""""\n    Constructs a BertTokenizer.\n    :class:`~pytorch_transformers.BertTokenizer` runs end-to-end tokenization: punctuation splitting + wordpiece\n\n    Args:\n        vocab_file: Path to a one-wordpiece-per-line vocabulary file\n        do_lower_case: Whether to lower case the input. Only has an effect when do_wordpiece_only=False\n        do_basic_tokenize: Whether to do basic tokenization before wordpiece.\n        max_len: An artificial maximum length to truncate tokenized sequences to; Effective maximum length is always the\n            minimum of this value (if specified) and the underlying BERT model\'s sequence length.\n        never_split: List of tokens which will never be split during tokenization. Only has an effect when\n            do_wordpiece_only=False\n    """"""\n\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, do_lower_case=True, do_basic_tokenize=True, never_split=None,\n                 unk_token=""[UNK]"", sep_token=""[SEP]"", pad_token=""[PAD]"", cls_token=""[CLS]"",\n                 mask_token=""[MASK]"", tokenize_chinese_chars=True, **kwargs):\n        """"""Constructs a BertTokenizer.\n\n        Args:\n            **vocab_file**: Path to a one-wordpiece-per-line vocabulary file\n            **do_lower_case**: (`optional`) boolean (default True)\n                Whether to lower case the input\n                Only has an effect when do_basic_tokenize=True\n            **do_basic_tokenize**: (`optional`) boolean (default True)\n                Whether to do basic tokenization before wordpiece.\n            **never_split**: (`optional`) list of string\n                List of tokens which will never be split during tokenization.\n                Only has an effect when do_basic_tokenize=True\n            **tokenize_chinese_chars**: (`optional`) boolean (default True)\n                Whether to tokenize Chinese characters.\n                This should likely be deactivated for Japanese:\n                see: https://github.com/huggingface/pytorch-pretrained-BERT/issues/328\n        """"""\n        super(BertTokenizer, self).__init__(unk_token=unk_token, sep_token=sep_token,\n                                            pad_token=pad_token, cls_token=cls_token,\n                                            mask_token=mask_token, **kwargs)\n        if not os.path.isfile(vocab_file):\n            raise ValueError(\n                ""Can\'t find a vocabulary file at path \'{}\'. To load the vocabulary from a Google pretrained ""\n                ""model use `tokenizer = BertTokenizer.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(vocab_file))\n        self.vocab = load_vocab(vocab_file)\n        self.ids_to_tokens = collections.OrderedDict(\n            [(ids, tok) for tok, ids in self.vocab.items()])\n        self.do_basic_tokenize = do_basic_tokenize\n        if do_basic_tokenize:\n            self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case,\n                                                  never_split=never_split,\n                                                  tokenize_chinese_chars=tokenize_chinese_chars)\n        self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab, unk_token=self.unk_token)\n\n    @property\n    def vocab_size(self):\n        return len(self.vocab)\n\n    def _tokenize(self, text):\n        split_tokens = []\n        if self.do_basic_tokenize:\n            for token in self.basic_tokenizer.tokenize(text, never_split=self.all_special_tokens):\n                for sub_token in self.wordpiece_tokenizer.tokenize(token):\n                    split_tokens.append(sub_token)\n        else:\n            split_tokens = self.wordpiece_tokenizer.tokenize(text)\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.vocab.get(token, self.vocab.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.ids_to_tokens.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \' \'.join(tokens).replace(\' ##\', \'\').strip()\n        return out_string\n\n    def add_special_tokens_single_sentence(self, token_ids):\n        """"""\n        Adds special tokens to the a sequence for sequence classification tasks.\n        A BERT sequence has the following format: [CLS] X [SEP]\n        """"""\n        return [self._convert_token_to_id(self.cls_token)] + token_ids + [self._convert_token_to_id(self.sep_token)]\n\n    def add_special_tokens_sentences_pair(self, token_ids_0, token_ids_1):\n        """"""\n        Adds special tokens to a sequence pair for sequence classification tasks.\n        A BERT sequence pair has the following format: [CLS] A [SEP] B [SEP]\n        """"""\n        sep = [self._convert_token_to_id(self.sep_token)]\n        cls = [self._convert_token_to_id(self.cls_token)]\n        return cls + token_ids_0 + sep + token_ids_1 + sep\n\n    def save_vocabulary(self, vocab_path):\n        """"""Save the tokenizer vocabulary to a directory or file.""""""\n        index = 0\n        if os.path.isdir(vocab_path):\n            vocab_file = os.path.join(vocab_path, VOCAB_FILES_NAMES[\'vocab_file\'])\n        with open(vocab_file, ""w"", encoding=""utf-8"") as writer:\n            for token, token_index in sorted(self.vocab.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: vocabulary indices are not consecutive.""\n                                   "" Please check that the vocabulary is not corrupted!"".format(vocab_file))\n                    index = token_index\n                writer.write(token + u\'\\n\')\n                index += 1\n        return (vocab_file,)\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *inputs, **kwargs):\n        """""" Instantiate a BertTokenizer from pre-trained vocabulary files.\n        """"""\n        if pretrained_model_name_or_path in PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES:\n            if \'-cased\' in pretrained_model_name_or_path and kwargs.get(\'do_lower_case\', True):\n                logger.warning(""The pre-trained model you are loading is a cased model but you have not set ""\n                               ""`do_lower_case` to False. We are setting `do_lower_case=False` for you but ""\n                               ""you may want to check this behavior."")\n                kwargs[\'do_lower_case\'] = False\n            elif \'-cased\' not in pretrained_model_name_or_path and not kwargs.get(\'do_lower_case\', True):\n                logger.warning(""The pre-trained model you are loading is an uncased model but you have set ""\n                               ""`do_lower_case` to False. We are setting `do_lower_case=True` for you ""\n                               ""but you may want to check this behavior."")\n                kwargs[\'do_lower_case\'] = True\n\n        return super(BertTokenizer, cls)._from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n\n\nclass BasicTokenizer(object):\n    """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n    def __init__(self, do_lower_case=True, never_split=None, tokenize_chinese_chars=True):\n        """""" Constructs a BasicTokenizer.\n\n        Args:\n            **do_lower_case**: Whether to lower case the input.\n            **never_split**: (`optional`) list of str\n                Kept for backward compatibility purposes.\n                Now implemented directly at the base class level (see :func:`PreTrainedTokenizer.tokenize`)\n                List of token not to split.\n            **tokenize_chinese_chars**: (`optional`) boolean (default True)\n                Whether to tokenize Chinese characters.\n                This should likely be deactivated for Japanese:\n                see: https://github.com/huggingface/pytorch-pretrained-BERT/issues/328\n        """"""\n        if never_split is None:\n            never_split = []\n        self.do_lower_case = do_lower_case\n        self.never_split = never_split\n        self.tokenize_chinese_chars = tokenize_chinese_chars\n\n    def tokenize(self, text, never_split=None):\n        """""" Basic Tokenization of a piece of text.\n            Split on ""white spaces"" only, for sub-word tokenization, see WordPieceTokenizer.\n\n        Args:\n            **never_split**: (`optional`) list of str\n                Kept for backward compatibility purposes.\n                Now implemented directly at the base class level (see :func:`PreTrainedTokenizer.tokenize`)\n                List of token not to split.\n        """"""\n        never_split = self.never_split + (never_split if never_split is not None else [])\n        text = self._clean_text(text)\n        # This was added on November 1st, 2018 for the multilingual and Chinese\n        # models. This is also applied to the English models now, but it doesn\'t\n        # matter since the English models were not trained on any Chinese data\n        # and generally don\'t have any Chinese data in them (there are Chinese\n        # characters in the vocabulary because Wikipedia does have some Chinese\n        # words in the English Wikipedia.).\n        if self.tokenize_chinese_chars:\n            text = self._tokenize_chinese_chars(text)\n        orig_tokens = whitespace_tokenize(text)\n        split_tokens = []\n        for token in orig_tokens:\n            if self.do_lower_case and token not in never_split:\n                token = token.lower()\n                token = self._run_strip_accents(token)\n            split_tokens.extend(self._run_split_on_punc(token))\n\n        output_tokens = whitespace_tokenize("" "".join(split_tokens))\n        return output_tokens\n\n    def _run_strip_accents(self, text):\n        """"""Strips accents from a piece of text.""""""\n        text = unicodedata.normalize(""NFD"", text)\n        output = []\n        for char in text:\n            cat = unicodedata.category(char)\n            if cat == ""Mn"":\n                continue\n            output.append(char)\n        return """".join(output)\n\n    def _run_split_on_punc(self, text, never_split=None):\n        """"""Splits punctuation on a piece of text.""""""\n        if never_split is not None and text in never_split:\n            return [text]\n        chars = list(text)\n        i = 0\n        start_new_word = True\n        output = []\n        while i < len(chars):\n            char = chars[i]\n            if _is_punctuation(char):\n                output.append([char])\n                start_new_word = True\n            else:\n                if start_new_word:\n                    output.append([])\n                start_new_word = False\n                output[-1].append(char)\n            i += 1\n\n        return ["""".join(x) for x in output]\n\n    def _tokenize_chinese_chars(self, text):\n        """"""Adds whitespace around any CJK character.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if self._is_chinese_char(cp):\n                output.append("" "")\n                output.append(char)\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n    def _is_chinese_char(self, cp):\n        """"""Checks whether CP is the codepoint of a CJK character.""""""\n        # This defines a ""chinese character"" as anything in the CJK Unicode block:\n        #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n        #\n        # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n        # despite its name. The modern Korean Hangul alphabet is a different block,\n        # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n        # space-separated words, so they are not treated specially and handled\n        # like the all of the other languages.\n        if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n                (cp >= 0x3400 and cp <= 0x4DBF) or  #\n                (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n                (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n                (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n                (cp >= 0x2B820 and cp <= 0x2CEAF) or\n                (cp >= 0xF900 and cp <= 0xFAFF) or  #\n                (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n            return True\n\n        return False\n\n    def _clean_text(self, text):\n        """"""Performs invalid character removal and whitespace cleanup on text.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if cp == 0 or cp == 0xfffd or _is_control(char):\n                continue\n            if _is_whitespace(char):\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n    """"""Runs WordPiece tokenization.""""""\n\n    def __init__(self, vocab, unk_token, max_input_chars_per_word=100):\n        self.vocab = vocab\n        self.unk_token = unk_token\n        self.max_input_chars_per_word = max_input_chars_per_word\n\n    def tokenize(self, text):\n        """"""Tokenizes a piece of text into its word pieces.\n\n        This uses a greedy longest-match-first algorithm to perform tokenization\n        using the given vocabulary.\n\n        For example:\n          input = ""unaffable""\n          output = [""un"", ""##aff"", ""##able""]\n\n        Args:\n          text: A single token or whitespace separated tokens. This should have\n            already been passed through `BasicTokenizer`.\n\n        Returns:\n          A list of wordpiece tokens.\n        """"""\n\n        output_tokens = []\n        for token in whitespace_tokenize(text):\n            chars = list(token)\n            if len(chars) > self.max_input_chars_per_word:\n                output_tokens.append(self.unk_token)\n                continue\n\n            is_bad = False\n            start = 0\n            sub_tokens = []\n            while start < len(chars):\n                end = len(chars)\n                cur_substr = None\n                while start < end:\n                    substr = """".join(chars[start:end])\n                    if start > 0:\n                        substr = ""##"" + substr\n                    if substr in self.vocab:\n                        cur_substr = substr\n                        break\n                    end -= 1\n                if cur_substr is None:\n                    is_bad = True\n                    break\n                sub_tokens.append(cur_substr)\n                start = end\n\n            if is_bad:\n                output_tokens.append(self.unk_token)\n            else:\n                output_tokens.extend(sub_tokens)\n        return output_tokens\n\n\ndef _is_whitespace(char):\n    """"""Checks whether `chars` is a whitespace character.""""""\n    # \\t, \\n, and \\r are technically contorl characters but we treat them\n    # as whitespace since they are generally considered as such.\n    if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return True\n    cat = unicodedata.category(char)\n    if cat == ""Zs"":\n        return True\n    return False\n\n\ndef _is_control(char):\n    """"""Checks whether `chars` is a control character.""""""\n    # These are technically control characters but we count them as whitespace\n    # characters.\n    if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return False\n    cat = unicodedata.category(char)\n    if cat.startswith(""C""):\n        return True\n    return False\n\n\ndef _is_punctuation(char):\n    """"""Checks whether `chars` is a punctuation character.""""""\n    cp = ord(char)\n    # We treat all non-letter/number ASCII as punctuation.\n    # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n    # Punctuation class but we treat them as punctuation anyways, for\n    # consistency.\n    if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n            (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n        return True\n    cat = unicodedata.category(char)\n    if cat.startswith(""P""):\n        return True\n    return False\n'"
bertviz/transformers_neuron_view/tokenization_gpt2.py,0,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport sys\nimport json\nimport logging\nimport os\nimport regex as re\nfrom io import open\n\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    # Just a dummy decorator to get the checks to run on python2\n    # because honestly I don\'t want to support a byte-level unicode BPE tokenizer on python 2 right now.\n    def lru_cache():\n        return lambda func: func\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'gpt2\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-vocab.json"",\n        \'gpt2-medium\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'gpt2\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-merges.txt"",\n        \'gpt2-medium\': ""https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-medium-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'gpt2\': 1024,\n    \'gpt2-medium\': 1024,\n}\n\n@lru_cache()\ndef bytes_to_unicode():\n    """"""\n    Returns list of utf-8 byte and a corresponding list of unicode strings.\n    The reversible bpe codes work on unicode strings.\n    This means you need a large # of unicode characters in your vocab if you want to avoid UNKs.\n    When you\'re at something like a 10B token dataset you end up needing around 5K for decent coverage.\n    This is a signficant percentage of your normal, say, 32K bpe vocab.\n    To avoid that, we want lookup tables between utf-8 bytes and unicode strings.\n    And avoids mapping to whitespace/control characters the bpe code barfs on.\n    """"""\n    _chr = unichr if sys.version_info[0] == 2 else chr\n    bs = list(range(ord(""!""), ord(""~"")+1))+list(range(ord(""\xc2\xa1""), ord(""\xc2\xac"")+1))+list(range(ord(""\xc2\xae""), ord(""\xc3\xbf"")+1))\n    cs = bs[:]\n    n = 0\n    for b in range(2**8):\n        if b not in bs:\n            bs.append(b)\n            cs.append(2**8+n)\n            n += 1\n    cs = [_chr(n) for n in cs]\n    return dict(zip(bs, cs))\n\ndef get_pairs(word):\n    """"""Return set of symbol pairs in a word.\n\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    """"""\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n    return pairs\n\nclass GPT2Tokenizer(PreTrainedTokenizer):\n    """"""\n    GPT-2 BPE tokenizer. Peculiarities:\n        - Byte-level BPE\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, errors=\'replace\', unk_token=""<|endoftext|>"",\n                 bos_token=""<|endoftext|>"", eos_token=""<|endoftext|>"", **kwargs):\n        super(GPT2Tokenizer, self).__init__(bos_token=bos_token, eos_token=eos_token, unk_token=unk_token, **kwargs)\n\n        self.encoder = json.load(open(vocab_file))\n        self.decoder = {v:k for k,v in self.encoder.items()}\n        self.errors = errors # how to handle errors in decoding\n        self.byte_encoder = bytes_to_unicode()\n        self.byte_decoder = {v:k for k, v in self.byte_encoder.items()}\n        bpe_data = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[1:-1]\n        bpe_merges = [tuple(merge.split()) for merge in bpe_data]\n        self.bpe_ranks = dict(zip(bpe_merges, range(len(bpe_merges))))\n        self.cache = {}\n\n        # Should haved added re.IGNORECASE so BPE merges can happen for capitalized versions of contractions\n        self.pat = re.compile(r""""""\'s|\'t|\'re|\'ve|\'m|\'ll|\'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+"""""")\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        if token in self.cache:\n            return self.cache[token]\n        word = tuple(token)\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token\n\n        while True:\n            bigram = min(pairs, key = lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \' \'.join(word)\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text):\n        """""" Tokenize a string. """"""\n        bpe_tokens = []\n        for token in re.findall(self.pat, text):\n            if sys.version_info[0] == 2:\n                token = \'\'.join(self.byte_encoder[ord(b)] for b in token)\n            else:\n                token = \'\'.join(self.byte_encoder[b] for b in token.encode(\'utf-8\'))\n            bpe_tokens.extend(bpe_token for bpe_token in self.bpe(token).split(\' \'))\n        return bpe_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.decoder.get(index)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        text = \'\'.join(tokens)\n        text = bytearray([self.byte_decoder[c] for c in text]).decode(\'utf-8\', errors=self.errors)\n        return text\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            writer.write(u\'#version: 0.2\\n\')\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file\n'"
bertviz/transformers_neuron_view/tokenization_openai.py,0,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport json\nimport logging\nimport os\nimport re\nfrom io import open\n\nfrom .tokenization_utils import PreTrainedTokenizer\nfrom .tokenization_bert import BasicTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'openai-gpt\': ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'openai-gpt\': ""https://s3.amazonaws.com/models.huggingface.co/bert/openai-gpt-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'openai-gpt\': 512,\n}\n\ndef get_pairs(word):\n    """"""\n    Return set of symbol pairs in a word.\n    word is represented as tuple of symbols (symbols being variable-length strings)\n    """"""\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n    return pairs\n\ndef text_standardize(text):\n    """"""\n    fixes some issues the spacy tokenizer had on books corpus\n    also does some whitespace standardization\n    """"""\n    text = text.replace(\'\xe2\x80\x94\', \'-\')\n    text = text.replace(\'\xe2\x80\x93\', \'-\')\n    text = text.replace(\'\xe2\x80\x95\', \'-\')\n    text = text.replace(\'\xe2\x80\xa6\', \'...\')\n    text = text.replace(\'\xc2\xb4\', ""\'"")\n    text = re.sub(r\'\'\'(-+|~+|!+|""+|;+|\\?+|\\++|,+|\\)+|\\(+|\\\\+|\\/+|\\*+|\\[+|\\]+|}+|{+|\\|+|_+)\'\'\', r\' \\1 \', text)\n    text = re.sub(r\'\\s*\\n\\s*\', \' \\n \', text)\n    text = re.sub(r\'[^\\S\\n]+\', \' \', text)\n    return text.strip()\n\nclass OpenAIGPTTokenizer(PreTrainedTokenizer):\n    """"""\n    BPE tokenizer. Peculiarities:\n        - lower case all inputs\n        - uses SpaCy tokenizer and ftfy for pre-BPE tokenization if they are installed, fallback to BERT\'s BasicTokenizer if not.\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, unk_token=""<unk>"", **kwargs):\n        super(OpenAIGPTTokenizer, self).__init__(unk_token=unk_token, **kwargs)\n\n        try:\n            import ftfy\n            import spacy\n            self.nlp = spacy.load(\'en\', disable=[\'parser\', \'tagger\', \'ner\', \'textcat\'])\n            self.fix_text = ftfy.fix_text\n        except ImportError:\n            logger.warning(""ftfy or spacy is not installed using BERT BasicTokenizer instead of SpaCy & ftfy."")\n            self.nlp = BasicTokenizer(do_lower_case=True)\n            self.fix_text = None\n\n        self.encoder = json.load(open(vocab_file, encoding=""utf-8""))\n        self.decoder = {v:k for k,v in self.encoder.items()}\n        merges = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[1:-1]\n        merges = [tuple(merge.split()) for merge in merges]\n        self.bpe_ranks = dict(zip(merges, range(len(merges))))\n        self.cache = {}\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        word = tuple(token[:-1]) + (token[-1] + \'</w>\',)\n        if token in self.cache:\n            return self.cache[token]\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token+\'</w>\'\n\n        while True:\n            bigram = min(pairs, key=lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \' \'.join(word)\n        if word == \'\\n  </w>\':\n            word = \'\\n</w>\'\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text):\n        """""" Tokenize a string. """"""\n        split_tokens = []\n        if self.fix_text is None:\n            # Using BERT\'s BasicTokenizer\n            text = self.nlp.tokenize(text)\n            for token in text:\n                split_tokens.extend([t for t in self.bpe(token).split(\' \')])\n        else:\n            # Using SpaCy & ftfy (original tokenization process of OpenAI GPT)\n            text = self.nlp(text_standardize(self.fix_text(text)))\n            for token in text:\n                split_tokens.extend([t for t in self.bpe(token.text.lower()).split(\' \')])\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an id in a token (BPE) using the vocab.""""""\n        return self.decoder.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \'\'.join(tokens).replace(\'</w>\', \' \').strip()\n        return out_string\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            writer.write(u\'#version: 0.2\\n\')\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file\n'"
bertviz/transformers_neuron_view/tokenization_roberta.py,0,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for RoBERTa.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport sys\nimport json\nimport logging\nimport os\nimport regex as re\nfrom io import open\n\nfrom .tokenization_gpt2 import bytes_to_unicode, get_pairs\nfrom .tokenization_utils import PreTrainedTokenizer\n\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    # Just a dummy decorator to get the checks to run on python2\n    # because honestly I don\'t want to support a byte-level unicode BPE tokenizer on python 2 right now.\n    def lru_cache():\n        return lambda func: func\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-vocab.json"",\n        \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-vocab.json"",\n        \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'roberta-base\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-base-merges.txt"",\n        \'roberta-large\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-merges.txt"",\n        \'roberta-large-mnli\': ""https://s3.amazonaws.com/models.huggingface.co/bert/roberta-large-mnli-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'roberta-base\': 512,\n    \'roberta-large\': 512,\n    \'roberta-large-mnli\': 512,\n}\n\n\nclass RobertaTokenizer(PreTrainedTokenizer):\n    """"""\n    RoBERTa BPE tokenizer, derived from the GPT-2 tokenizer. Peculiarities: Byte-level BPE\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, errors=\'replace\', bos_token=""<s>"", eos_token=""</s>"", sep_token=""</s>"",\n                 cls_token=""<s>"", unk_token=""<unk>"", pad_token=\'<pad>\', mask_token=\'<mask>\', **kwargs):\n        super(RobertaTokenizer, self).__init__(bos_token=bos_token, eos_token=eos_token, unk_token=unk_token,\n                                               sep_token=sep_token, cls_token=cls_token, pad_token=pad_token,\n                                               mask_token=mask_token, **kwargs)\n\n        self.encoder = json.load(open(vocab_file, encoding=""utf-8""))\n        self.decoder = {v: k for k, v in self.encoder.items()}\n        self.errors = errors  # how to handle errors in decoding\n        self.byte_encoder = bytes_to_unicode()\n        self.byte_decoder = {v: k for k, v in self.byte_encoder.items()}\n        bpe_data = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[1:-1]\n        bpe_merges = [tuple(merge.split()) for merge in bpe_data]\n        self.bpe_ranks = dict(zip(bpe_merges, range(len(bpe_merges))))\n        self.cache = {}\n\n        # Should haved added re.IGNORECASE so BPE merges can happen for capitalized versions of contractions\n        self.pat = re.compile(r""""""\'s|\'t|\'re|\'ve|\'m|\'ll|\'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+"""""")\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        if token in self.cache:\n            return self.cache[token]\n        word = tuple(token)\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token\n\n        while True:\n            bigram = min(pairs, key = lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \' \'.join(word)\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text):\n        """""" Tokenize a string. """"""\n        bpe_tokens = []\n        for token in re.findall(self.pat, text):\n            if sys.version_info[0] == 2:\n                token = \'\'.join(self.byte_encoder[ord(b)] for b in token)\n            else:\n                token = \'\'.join(self.byte_encoder[b] for b in token.encode(\'utf-8\'))\n            bpe_tokens.extend(bpe_token for bpe_token in self.bpe(token).split(\' \'))\n        return bpe_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.decoder.get(index)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        text = \'\'.join(tokens)\n        text = bytearray([self.byte_decoder[c] for c in text]).decode(\'utf-8\', errors=self.errors)\n        return text\n\n    def add_special_tokens_single_sentence(self, token_ids):\n        """"""\n        Adds special tokens to a sequence for sequence classification tasks.\n        A RoBERTa sequence has the following format: [CLS] X [SEP]\n        """"""\n        return [self._convert_token_to_id(self.cls_token)] + token_ids + [self._convert_token_to_id(self.sep_token)]\n\n    def add_special_tokens_sentences_pair(self, token_ids_0, token_ids_1):\n        """"""\n        Adds special tokens to a sequence pair for sequence classification tasks.\n        A RoBERTa sequence pair has the following format: [CLS] A [SEP][SEP] B [SEP]\n        """"""\n        sep = [self._convert_token_to_id(self.sep_token)]\n        cls = [self._convert_token_to_id(self.cls_token)]\n        return cls + token_ids_0 + sep + sep + token_ids_1 + sep\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            writer.write(u\'#version: 0.2\\n\')\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file\n'"
bertviz/transformers_neuron_view/tokenization_transfo_xl.py,13,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Tokenization classes for Transformer XL model.\n    Adapted from https://github.com/kimiyoung/transformer-xl.\n""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport glob\nimport logging\nimport os\nimport sys\nfrom collections import Counter, OrderedDict\nfrom io import open\n\nimport torch\nimport numpy as np\n\nfrom .file_utils import cached_path\nfrom .tokenization_utils import PreTrainedTokenizer\n\nif sys.version_info[0] == 2:\n    import cPickle as pickle\nelse:\n    import pickle\n\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'pretrained_vocab_file\': \'vocab.bin\', \'vocab_file\': \'vocab.txt\'}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'pretrained_vocab_file\':\n    {\n        \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-vocab.bin"",\n    }\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'transfo-xl-wt103\': None,\n}\n\nPRETRAINED_CORPUS_ARCHIVE_MAP = {\n    \'transfo-xl-wt103\': ""https://s3.amazonaws.com/models.huggingface.co/bert/transfo-xl-wt103-corpus.bin"",\n}\nCORPUS_NAME = \'corpus.bin\'\n\nclass TransfoXLTokenizer(PreTrainedTokenizer):\n    """"""\n    Transformer-XL tokenizer adapted from Vocab class in https://github.com/kimiyoung/transformer-xl\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, special=None, min_freq=0, max_size=None, lower_case=False,\n                 delimiter=None, vocab_file=None, pretrained_vocab_file=None,\n                 never_split=None, unk_token=""<unk>"", eos_token=""<eos>"",\n                 additional_special_tokens=[""<formula>""], **kwargs):\n        super(TransfoXLTokenizer, self).__init__(unk_token=unk_token, eos_token=eos_token,\n                                                 additional_special_tokens=additional_special_tokens,\n                                                 **kwargs)\n        if never_split is None:\n            never_split = self.all_special_tokens\n        if special is None:\n            special = []\n        self.counter = Counter()\n        self.special = special\n        self.min_freq = min_freq\n        self.max_size = max_size\n        self.lower_case = lower_case\n        self.delimiter = delimiter\n        self.vocab_file = vocab_file\n        self.never_split = never_split\n\n        if pretrained_vocab_file is not None:\n            # Hack because, honestly this tokenizer was not made to be used\n            # in a library like ours, at all.\n            vocab_dict = torch.load(pretrained_vocab_file)\n            for key, value in vocab_dict.items():\n                self.__dict__[key] = value\n\n        if vocab_file is not None:\n            self.build_vocab()\n\n    def count_file(self, path, verbose=False, add_eos=False):\n        if verbose: logger.info(\'counting file {} ...\'.format(path))\n        assert os.path.exists(path)\n\n        sents = []\n        with open(path, \'r\', encoding=\'utf-8\') as f:\n            for idx, line in enumerate(f):\n                if verbose and idx > 0 and idx % 500000 == 0:\n                    logger.info(\'    line {}\'.format(idx))\n                symbols = self.tokenize(line, add_eos=add_eos)\n                self.counter.update(symbols)\n                sents.append(symbols)\n\n        return sents\n\n    def count_sents(self, sents, verbose=False):\n        """"""\n            sents : a list of sentences, each a list of tokenized symbols\n        """"""\n        if verbose: logger.info(\'counting {} sents ...\'.format(len(sents)))\n        for idx, symbols in enumerate(sents):\n            if verbose and idx > 0 and idx % 500000 == 0:\n                logger.info(\'    line {}\'.format(idx))\n            self.counter.update(symbols)\n\n    def _build_from_file(self, vocab_file):\n        self.idx2sym = []\n        self.sym2idx = OrderedDict()\n\n        with open(vocab_file, \'r\', encoding=\'utf-8\') as f:\n            for line in f:\n                symb = line.strip().split()[0]\n                self.add_symbol(symb)\n        if \'<UNK>\' in self.sym2idx:\n            self.unk_idx = self.sym2idx[\'<UNK>\']\n        elif \'<unk>\' in self.sym2idx:\n            self.unk_idx = self.sym2idx[\'<unk>\']\n        else:\n            raise ValueError(\'No <unkown> token in vocabulary\')\n\n    def save_vocabulary(self, vocab_path):\n        """"""Save the tokenizer vocabulary to a directory or file.""""""\n        if os.path.isdir(vocab_path):\n            vocab_file = os.path.join(vocab_path, VOCAB_FILES_NAMES[\'pretrained_vocab_file\'])\n        torch.save(self.__dict__, vocab_file)\n        return (vocab_file,)\n\n    def build_vocab(self):\n        if self.vocab_file:\n            logger.info(\'building vocab from {}\'.format(self.vocab_file))\n            self._build_from_file(self.vocab_file)\n            logger.info(\'final vocab size {}\'.format(len(self)))\n        else:\n            logger.info(\'building vocab with min_freq={}, max_size={}\'.format(\n                self.min_freq, self.max_size))\n            self.idx2sym = []\n            self.sym2idx = OrderedDict()\n\n            for sym in self.special:\n                self.add_special(sym)\n\n            for sym, cnt in self.counter.most_common(self.max_size):\n                if cnt < self.min_freq: break\n                self.add_symbol(sym)\n\n            logger.info(\'final vocab size {} from {} unique tokens\'.format(\n                len(self), len(self.counter)))\n\n    def encode_file(self, path, ordered=False, verbose=False, add_eos=True,\n            add_double_eos=False):\n        if verbose: logger.info(\'encoding file {} ...\'.format(path))\n        assert os.path.exists(path)\n        encoded = []\n        with open(path, \'r\', encoding=\'utf-8\') as f:\n            for idx, line in enumerate(f):\n                if verbose and idx > 0 and idx % 500000 == 0:\n                    logger.info(\'    line {}\'.format(idx))\n                symbols = self.tokenize(line, add_eos=add_eos,\n                    add_double_eos=add_double_eos)\n                encoded.append(self.convert_to_tensor(symbols))\n\n        if ordered:\n            encoded = torch.cat(encoded)\n\n        return encoded\n\n    def encode_sents(self, sents, ordered=False, verbose=False):\n        if verbose: logger.info(\'encoding {} sents ...\'.format(len(sents)))\n        encoded = []\n        for idx, symbols in enumerate(sents):\n            if verbose and idx > 0 and idx % 500000 == 0:\n                logger.info(\'    line {}\'.format(idx))\n            encoded.append(self.convert_to_tensor(symbols))\n\n        if ordered:\n            encoded = torch.cat(encoded)\n\n        return encoded\n\n    def add_special(self, sym):\n        if sym not in self.sym2idx:\n            self.idx2sym.append(sym)\n            self.sym2idx[sym] = len(self.idx2sym) - 1\n            setattr(self, \'{}_idx\'.format(sym.strip(\'<>\')), self.sym2idx[sym])\n\n    def add_symbol(self, sym):\n        if sym not in self.sym2idx:\n            self.idx2sym.append(sym)\n            self.sym2idx[sym] = len(self.idx2sym) - 1\n\n    def _convert_id_to_token(self, idx):\n        """"""Converts an id in a token (BPE) using the vocab.""""""\n        assert 0 <= idx < len(self), \'Index {} out of vocabulary range\'.format(idx)\n        return self.idx2sym[idx]\n\n    def _convert_token_to_id(self, sym):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        if sym in self.sym2idx:\n            return self.sym2idx[sym]\n        else:\n            # logger.info(\'encounter unk {}\'.format(sym))\n            # assert \'<eos>\' not in sym\n            if hasattr(self, \'unk_idx\'):\n                return self.sym2idx.get(sym, self.unk_idx)\n            # Backward compatibility with pre-trained models\n            elif \'<unk>\' in self.sym2idx:\n                return self.sym2idx[\'<unk>\']\n            elif \'<UNK>\' in self.sym2idx:\n                return self.sym2idx[\'<UNK>\']\n            else:\n                raise ValueError(\'Token not in vocabulary and no <unk> token in vocabulary for replacement\')\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \' \'.join(tokens).strip()\n        return out_string\n\n    def convert_to_tensor(self, symbols):\n        return torch.LongTensor(self.convert_tokens_to_ids(symbols))\n\n    @property\n    def vocab_size(self):\n        return len(self.idx2sym)\n\n    def _tokenize(self, line, add_eos=False, add_double_eos=False):\n        line = line.strip()\n        # convert to lower case\n        if self.lower_case:\n            line = line.lower()\n\n        # empty delimiter \'\' will evaluate False\n        if self.delimiter == \'\':\n            symbols = line\n        else:\n            symbols = line.split(self.delimiter)\n\n        if add_double_eos: # lm1b\n            return [\'<S>\'] + symbols + [\'<S>\']\n        elif add_eos:\n            return symbols + [\'<eos>\']\n        else:\n            return symbols\n\n\nclass LMOrderedIterator(object):\n    def __init__(self, data, bsz, bptt, device=\'cpu\', ext_len=None):\n        """"""\n            data -- LongTensor -- the LongTensor is strictly ordered\n        """"""\n        self.bsz = bsz\n        self.bptt = bptt\n        self.ext_len = ext_len if ext_len is not None else 0\n\n        self.device = device\n\n        # Work out how cleanly we can divide the dataset into bsz parts.\n        self.n_step = data.size(0) // bsz\n\n        # Trim off any extra elements that wouldn\'t cleanly fit (remainders).\n        data = data.narrow(0, 0, self.n_step * bsz)\n\n        # Evenly divide the data across the bsz batches.\n        self.data = data.view(bsz, -1).t().contiguous().to(device)\n\n        # Number of mini-batches\n        self.n_batch = (self.n_step + self.bptt - 1) // self.bptt\n\n    def get_batch(self, i, bptt=None):\n        if bptt is None: bptt = self.bptt\n        seq_len = min(bptt, self.data.size(0) - 1 - i)\n\n        end_idx = i + seq_len\n        beg_idx = max(0, i - self.ext_len)\n\n        data = self.data[beg_idx:end_idx]\n        target = self.data[i+1:i+1+seq_len]\n\n        data_out = data.transpose(0, 1).contiguous().to(self.device)\n        target_out = target.transpose(0, 1).contiguous().to(self.device)\n\n        return data_out, target_out, seq_len\n\n    def get_fixlen_iter(self, start=0):\n        for i in range(start, self.data.size(0) - 1, self.bptt):\n            yield self.get_batch(i)\n\n    def get_varlen_iter(self, start=0, std=5, min_len=5, max_deviation=3):\n        max_len = self.bptt + max_deviation * std\n        i = start\n        while True:\n            bptt = self.bptt if np.random.random() < 0.95 else self.bptt / 2.\n            bptt = min(max_len, max(min_len, int(np.random.normal(bptt, std))))\n            data, target, seq_len = self.get_batch(i, bptt)\n            i += seq_len\n            yield data, target, seq_len\n            if i >= self.data.size(0) - 2:\n                break\n\n    def __iter__(self):\n        return self.get_fixlen_iter()\n\n\nclass LMShuffledIterator(object):\n    def __init__(self, data, bsz, bptt, device=\'cpu\', ext_len=None, shuffle=False):\n        """"""\n            data -- list[LongTensor] -- there is no order among the LongTensors\n        """"""\n        self.data = data\n\n        self.bsz = bsz\n        self.bptt = bptt\n        self.ext_len = ext_len if ext_len is not None else 0\n\n        self.device = device\n        self.shuffle = shuffle\n\n    def get_sent_stream(self):\n        # index iterator\n        epoch_indices = np.random.permutation(len(self.data)) if self.shuffle \\\n            else np.array(range(len(self.data)))\n\n        # sentence iterator\n        for idx in epoch_indices:\n            yield self.data[idx]\n\n    def stream_iterator(self, sent_stream):\n        # streams for each data in the batch\n        streams = [None] * self.bsz\n\n        data = torch.LongTensor(self.bptt, self.bsz)\n        target = torch.LongTensor(self.bptt, self.bsz)\n\n        n_retain = 0\n\n        while True:\n            # data   : [n_retain+bptt x bsz]\n            # target : [bptt x bsz]\n            data[n_retain:].fill_(-1)\n            target.fill_(-1)\n\n            valid_batch = True\n\n            for i in range(self.bsz):\n                n_filled = 0\n                try:\n                    while n_filled < self.bptt:\n                        if streams[i] is None or len(streams[i]) <= 1:\n                            streams[i] = next(sent_stream)\n                        # number of new tokens to fill in\n                        n_new = min(len(streams[i]) - 1, self.bptt - n_filled)\n                        # first n_retain tokens are retained from last batch\n                        data[n_retain+n_filled:n_retain+n_filled+n_new, i] = \\\n                            streams[i][:n_new]\n                        target[n_filled:n_filled+n_new, i] = \\\n                            streams[i][1:n_new+1]\n                        streams[i] = streams[i][n_new:]\n                        n_filled += n_new\n                except StopIteration:\n                    valid_batch = False\n                    break\n\n            if not valid_batch:\n                return\n\n            data_out = data.transpose(0, 1).contiguous().to(self.device)\n            target_out = target.transpose(0, 1).contiguous().to(self.device)\n\n            yield data_out, target_out, self.bptt\n\n            n_retain = min(data.size(0), self.ext_len)\n            if n_retain > 0:\n                data[:n_retain] = data[-n_retain:]\n            data.resize_(n_retain + self.bptt, data.size(1))\n\n    def __iter__(self):\n        # sent_stream is an iterator\n        sent_stream = self.get_sent_stream()\n\n        for batch in self.stream_iterator(sent_stream):\n            yield batch\n\n\nclass LMMultiFileIterator(LMShuffledIterator):\n    def __init__(self, paths, vocab, bsz, bptt, device=\'cpu\', ext_len=None,\n        shuffle=False):\n\n        self.paths = paths\n        self.vocab = vocab\n\n        self.bsz = bsz\n        self.bptt = bptt\n        self.ext_len = ext_len if ext_len is not None else 0\n\n        self.device = device\n        self.shuffle = shuffle\n\n    def get_sent_stream(self, path):\n        sents = self.vocab.encode_file(path, add_double_eos=True)\n        if self.shuffle:\n            np.random.shuffle(sents)\n        sent_stream = iter(sents)\n\n        return sent_stream\n\n    def __iter__(self):\n        if self.shuffle:\n            np.random.shuffle(self.paths)\n\n        for path in self.paths:\n            # sent_stream is an iterator\n            sent_stream = self.get_sent_stream(path)\n            for batch in self.stream_iterator(sent_stream):\n                yield batch\n\n\nclass TransfoXLCorpus(object):\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, cache_dir=None, *inputs, **kwargs):\n        """"""\n        Instantiate a pre-processed corpus.\n        """"""\n        vocab = TransfoXLTokenizer.from_pretrained(pretrained_model_name_or_path, *inputs, **kwargs)\n        if pretrained_model_name_or_path in PRETRAINED_CORPUS_ARCHIVE_MAP:\n            corpus_file = PRETRAINED_CORPUS_ARCHIVE_MAP[pretrained_model_name_or_path]\n        else:\n            corpus_file = os.path.join(pretrained_model_name_or_path, CORPUS_NAME)\n        # redirect to the cache, if necessary\n        try:\n            resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)\n        except EnvironmentError:\n            logger.error(\n                ""Corpus \'{}\' was not found in corpus list ({}). ""\n                ""We assumed \'{}\' was a path or url but couldn\'t find files {} ""\n                ""at this path or url."".format(\n                    pretrained_model_name_or_path,\n                    \', \'.join(PRETRAINED_CORPUS_ARCHIVE_MAP.keys()),\n                    pretrained_model_name_or_path,\n                    corpus_file))\n            return None\n        if resolved_corpus_file == corpus_file:\n            logger.info(""loading corpus file {}"".format(corpus_file))\n        else:\n            logger.info(""loading corpus file {} from cache at {}"".format(\n                corpus_file, resolved_corpus_file))\n\n        # Instantiate tokenizer.\n        corpus = cls(*inputs, **kwargs)\n        corpus_dict = torch.load(resolved_corpus_file)\n        for key, value in corpus_dict.items():\n            corpus.__dict__[key] = value\n        corpus.vocab = vocab\n        if corpus.train is not None:\n            corpus.train = torch.tensor(corpus.train, dtype=torch.long)\n        if corpus.valid is not None:\n            corpus.valid = torch.tensor(corpus.valid, dtype=torch.long)\n        if corpus.test is not None:\n            corpus.test = torch.tensor(corpus.test, dtype=torch.long)\n        return corpus\n\n    def __init__(self, *args, **kwargs):\n        self.vocab = TransfoXLTokenizer(*args, **kwargs)\n        self.dataset = None\n        self.train = None\n        self.valid = None\n        self.test = None\n\n    def build_corpus(self, path, dataset):\n        self.dataset = dataset\n\n        if self.dataset in [\'ptb\', \'wt2\', \'enwik8\', \'text8\']:\n            self.vocab.count_file(os.path.join(path, \'train.txt\'))\n            self.vocab.count_file(os.path.join(path, \'valid.txt\'))\n            self.vocab.count_file(os.path.join(path, \'test.txt\'))\n        elif self.dataset == \'wt103\':\n            self.vocab.count_file(os.path.join(path, \'train.txt\'))\n        elif self.dataset == \'lm1b\':\n            train_path_pattern = os.path.join(\n                path, \'1-billion-word-language-modeling-benchmark-r13output\',\n                \'training-monolingual.tokenized.shuffled\', \'news.en-*\')\n            train_paths = glob.glob(train_path_pattern)\n            # the vocab will load from file when build_vocab() is called\n\n        self.vocab.build_vocab()\n\n        if self.dataset in [\'ptb\', \'wt2\', \'wt103\']:\n            self.train = self.vocab.encode_file(\n                os.path.join(path, \'train.txt\'), ordered=True)\n            self.valid = self.vocab.encode_file(\n                os.path.join(path, \'valid.txt\'), ordered=True)\n            self.test = self.vocab.encode_file(\n                os.path.join(path, \'test.txt\'), ordered=True)\n        elif self.dataset in [\'enwik8\', \'text8\']:\n            self.train = self.vocab.encode_file(\n                os.path.join(path, \'train.txt\'), ordered=True, add_eos=False)\n            self.valid = self.vocab.encode_file(\n                os.path.join(path, \'valid.txt\'), ordered=True, add_eos=False)\n            self.test = self.vocab.encode_file(\n                os.path.join(path, \'test.txt\'), ordered=True, add_eos=False)\n        elif self.dataset == \'lm1b\':\n            self.train = train_paths\n            self.valid = self.vocab.encode_file(\n                os.path.join(path, \'valid.txt\'), ordered=False, add_double_eos=True)\n            self.test = self.vocab.encode_file(\n                os.path.join(path, \'test.txt\'), ordered=False, add_double_eos=True)\n\n    def get_iterator(self, split, *args, **kwargs):\n        if split == \'train\':\n            if self.dataset in [\'ptb\', \'wt2\', \'wt103\', \'enwik8\', \'text8\']:\n                data_iter = LMOrderedIterator(self.train, *args, **kwargs)\n            elif self.dataset == \'lm1b\':\n                kwargs[\'shuffle\'] = True\n                data_iter = LMMultiFileIterator(self.train, self.vocab, *args, **kwargs)\n        elif split in [\'valid\', \'test\']:\n            data = self.valid if split == \'valid\' else self.test\n            if self.dataset in [\'ptb\', \'wt2\', \'wt103\', \'enwik8\', \'text8\']:\n                data_iter = LMOrderedIterator(data, *args, **kwargs)\n            elif self.dataset == \'lm1b\':\n                data_iter = LMShuffledIterator(data, *args, **kwargs)\n\n        return data_iter\n\n\ndef get_lm_corpus(datadir, dataset):\n    fn = os.path.join(datadir, \'cache.pt\')\n    fn_pickle = os.path.join(datadir, \'cache.pkl\')\n    if os.path.exists(fn):\n        logger.info(\'Loading cached dataset...\')\n        corpus = torch.load(fn_pickle)\n    elif os.path.exists(fn):\n        logger.info(\'Loading cached dataset from pickle...\')\n        with open(fn, ""rb"") as fp:\n            corpus = pickle.load(fp)\n    else:\n        logger.info(\'Producing dataset {}...\'.format(dataset))\n        kwargs = {}\n        if dataset in [\'wt103\', \'wt2\']:\n            kwargs[\'special\'] = [\'<eos>\']\n            kwargs[\'lower_case\'] = False\n        elif dataset == \'ptb\':\n            kwargs[\'special\'] = [\'<eos>\']\n            kwargs[\'lower_case\'] = True\n        elif dataset == \'lm1b\':\n            kwargs[\'special\'] = []\n            kwargs[\'lower_case\'] = False\n            kwargs[\'vocab_file\'] = os.path.join(datadir, \'1b_word_vocab.txt\')\n        elif dataset in [\'enwik8\', \'text8\']:\n            pass\n\n        corpus = TransfoXLCorpus(datadir, dataset, **kwargs)\n        torch.save(corpus, fn)\n\n    return corpus\n'"
bertviz/transformers_neuron_view/tokenization_utils.py,0,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\nimport os\nimport json\nimport six\nfrom io import open\n\nfrom .file_utils import cached_path\n\nlogger = logging.getLogger(__name__)\n\nSPECIAL_TOKENS_MAP_FILE = \'special_tokens_map.json\'\nADDED_TOKENS_FILE = \'added_tokens.json\'\n\nclass PreTrainedTokenizer(object):\n    """""" Base class for all tokenizers.\n    Handle all the shared methods for tokenization and special tokens as well as methods dowloading/caching/loading pretrained tokenizers as well as adding tokens to the vocabulary.\n\n    This class also contain the added tokens in a unified way on top of all tokenizers so we don\'t have to handle the specific vocabulary augmentation methods of the various underlying dictionary structures (BPE, sentencepiece...).\n\n    Class attributes (overridden by derived classes):\n\n        - ``vocab_files_names``: a python ``dict`` with, as keys, the ``__init__`` keyword name of each vocabulary file required by the model, and as associated values, the filename for saving the associated file (string).\n        - ``pretrained_vocab_files_map``: a python ``dict of dict`` the high-level keys being the ``__init__`` keyword name of each vocabulary file required by the model, the low-level being the `short-cut-names` (string) of the pretrained models with, as associated values, the `url` (string) to the associated pretrained vocabulary file.\n        - ``max_model_input_sizes``: a python ``dict`` with, as keys, the `short-cut-names` (string) of the pretrained models, and as associated values, the maximum length of the sequence inputs of this model, or None if the model has no maximum input size.\n\n    Parameters:\n\n        - ``bos_token``: (`Optional`) string: a beginning of sentence token. Will be associated to ``self.bos_token``\n\n        - ``eos_token``: (`Optional`) string: an end of sentence token. Will be associated to ``self.eos_token``\n\n        - ``unk_token``: (`Optional`) string: an unknown token. Will be associated to ``self.unk_token``\n\n        - ``sep_token``: (`Optional`) string: a separation token (e.g. to separate context and query in an input sequence). Will be associated to ``self.sep_token``\n\n        - ``pad_token``: (`Optional`) string: a padding token. Will be associated to ``self.pad_token``\n\n        - ``cls_token``: (`Optional`) string: a classification token (e.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model). Will be associated to ``self.cls_token``\n\n        - ``mask_token``: (`Optional`) string: a masking token (e.g. when training a model with masked-language modeling). Will be associated to ``self.mask_token``\n\n        - ``additional_special_tokens``: (`Optional`) list: a list of additional special tokens. Adding all special tokens here ensure they won\'t be split by the tokenization process. Will be associated to ``self.additional_special_tokens``\n    """"""\n    vocab_files_names = {}\n    pretrained_vocab_files_map = {}\n    max_model_input_sizes = {}\n\n    SPECIAL_TOKENS_ATTRIBUTES = [""bos_token"", ""eos_token"", ""unk_token"", ""sep_token"",\n                                 ""pad_token"", ""cls_token"", ""mask_token"",\n                                 ""additional_special_tokens""]\n\n    @property\n    def bos_token(self):\n        """""" Beginning of sentence token (string). Log an error if used while not having been set. """"""\n        if self._bos_token is None:\n            logger.error(""Using bos_token, but it is not set yet."")\n        return self._bos_token\n\n    @property\n    def eos_token(self):\n        """""" End of sentence token (string). Log an error if used while not having been set. """"""\n        if self._eos_token is None:\n            logger.error(""Using eos_token, but it is not set yet."")\n        return self._eos_token\n\n    @property\n    def unk_token(self):\n        """""" Unknown token (string). Log an error if used while not having been set. """"""\n        if self._unk_token is None:\n            logger.error(""Using unk_token, but it is not set yet."")\n        return self._unk_token\n\n    @property\n    def sep_token(self):\n        """""" Separation token (string). E.g. separate context and query in an input sequence. Log an error if used while not having been set. """"""\n        if self._sep_token is None:\n            logger.error(""Using sep_token, but it is not set yet."")\n        return self._sep_token\n\n    @property\n    def pad_token(self):\n        """""" Padding token (string). Log an error if used while not having been set. """"""\n        if self._pad_token is None:\n            logger.error(""Using pad_token, but it is not set yet."")\n        return self._pad_token\n\n    @property\n    def cls_token(self):\n        """""" Classification token (string). E.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model. Log an error if used while not having been set. """"""\n        if self._cls_token is None:\n            logger.error(""Using cls_token, but it is not set yet."")\n        return self._cls_token\n\n    @property\n    def mask_token(self):\n        """""" Mask token (string). E.g. when training a model with masked-language modeling. Log an error if used while not having been set. """"""\n        if self._mask_token is None:\n            logger.error(""Using mask_token, but it is not set yet."")\n        return self._mask_token\n\n    @property\n    def additional_special_tokens(self):\n        """""" All the additional special tokens you may want to use (list of strings). Log an error if used while not having been set. """"""\n        if self._additional_special_tokens is None:\n            logger.error(""Using additional_special_tokens, but it is not set yet."")\n        return self._additional_special_tokens\n\n    @bos_token.setter\n    def bos_token(self, value):\n        self._bos_token = value\n\n    @eos_token.setter\n    def eos_token(self, value):\n        self._eos_token = value\n\n    @unk_token.setter\n    def unk_token(self, value):\n        self._unk_token = value\n\n    @sep_token.setter\n    def sep_token(self, value):\n        self._sep_token = value\n\n    @pad_token.setter\n    def pad_token(self, value):\n        self._pad_token = value\n\n    @cls_token.setter\n    def cls_token(self, value):\n        self._cls_token = value\n\n    @mask_token.setter\n    def mask_token(self, value):\n        self._mask_token = value\n\n    @additional_special_tokens.setter\n    def additional_special_tokens(self, value):\n        self._additional_special_tokens = value\n\n    def __init__(self, max_len=None, **kwargs):\n        self._bos_token = None\n        self._eos_token = None\n        self._unk_token = None\n        self._sep_token = None\n        self._pad_token = None\n        self._cls_token = None\n        self._mask_token = None\n        self._additional_special_tokens = []\n\n        self.max_len = max_len if max_len is not None else int(1e12)\n        self.added_tokens_encoder = {}\n        self.added_tokens_decoder = {}\n\n        for key, value in kwargs.items():\n            if key in self.SPECIAL_TOKENS_ATTRIBUTES:\n                if key == \'additional_special_tokens\':\n                    assert isinstance(value, (list, tuple)) and all(isinstance(t, str) or (six.PY2 and isinstance(t, unicode)) for t in value)\n                else:\n                    assert isinstance(value, str) or (six.PY2 and isinstance(value, unicode))\n                setattr(self, key, value)\n\n\n    @classmethod\n    def from_pretrained(cls, *inputs, **kwargs):\n        r""""""\n        Instantiate a :class:`~pytorch_transformers.PreTrainedTokenizer` (or a derived class) from a predefined tokenizer.\n\n        Args:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a predefined tokenizer to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing vocabulary files required by the tokenizer, for instance saved using the :func:`~pytorch_transformers.PreTrainedTokenizer.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - (not applicable to all derived classes) a path or url to a single saved vocabulary file if and only if the tokenizer only requires a single vocabulary file (e.g. Bert, XLNet), e.g.: ``./my_model_directory/vocab.txt``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded predefined tokenizer vocabulary files should be cached if the standard cache should not be used.\n\n            inputs: (`optional`) positional arguments: will be passed to the Tokenizer ``__init__`` method.\n\n            kwargs: (`optional`) keyword arguments: will be passed to the Tokenizer ``__init__`` method. Can be used to set special tokens like ``bos_token``, ``eos_token``, ``unk_token``, ``sep_token``, ``pad_token``, ``cls_token``, ``mask_token``, ``additional_special_tokens``. See parameters in the doc string of :class:`~pytorch_transformers.PreTrainedTokenizer` for details.\n\n        Examples::\n\n            # We can\'t instantiate directly the base class `PreTrainedTokenizer` so let\'s show our examples on a derived class: BertTokenizer\n\n            # Download vocabulary from S3 and cache.\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n\n            # If vocabulary files are in a directory (e.g. tokenizer was saved using `save_pretrained(\'./test/saved_model/\')`)\n            tokenizer = BertTokenizer.from_pretrained(\'./test/saved_model/\')\n\n            # If the tokenizer uses a single vocabulary file, you can point directly to this file\n            tokenizer = BertTokenizer.from_pretrained(\'./test/saved_model/my_vocab.txt\')\n\n            # You can link tokens to special vocabulary when instantiating\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\', unk_token=\'<unk>\')\n            # You should be sure \'<unk>\' is in the vocabulary when doing that.\n            # Otherwise use tokenizer.add_special_tokens({\'unk_token\': \'<unk>\'}) instead)\n            assert tokenizer.unk_token == \'<unk>\'\n\n        """"""\n        return cls._from_pretrained(*inputs, **kwargs)\n\n\n    @classmethod\n    def _from_pretrained(cls, pretrained_model_name_or_path, *inputs, **kwargs):\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n\n        s3_models = list(cls.max_model_input_sizes.keys())\n        vocab_files = {}\n        if pretrained_model_name_or_path in s3_models:\n            # Get the vocabulary from AWS S3 bucket\n            for file_id, map_list in cls.pretrained_vocab_files_map.items():\n                vocab_files[file_id] = map_list[pretrained_model_name_or_path]\n        else:\n            # Get the vocabulary from local files\n            logger.info(\n                ""Model name \'{}\' not found in model shortcut name list ({}). ""\n                ""Assuming \'{}\' is a path or url to a directory containing tokenizer files."".format(\n                    pretrained_model_name_or_path, \', \'.join(s3_models),\n                    pretrained_model_name_or_path))\n\n            # Look for the tokenizer main vocabulary files\n            for file_id, file_name in cls.vocab_files_names.items():\n                if os.path.isdir(pretrained_model_name_or_path):\n                    # If a directory is provided we look for the standard filenames\n                    full_file_name = os.path.join(pretrained_model_name_or_path, file_name)\n                else:\n                    # If a path to a file is provided we use it (will only work for non-BPE tokenizer using a single vocabulary file)\n                    full_file_name = pretrained_model_name_or_path\n                if not os.path.exists(full_file_name):\n                    logger.info(""Didn\'t find file {}. We won\'t load it."".format(full_file_name))\n                    full_file_name = None\n                vocab_files[file_id] = full_file_name\n\n            # Look for the additional tokens files\n            all_vocab_files_names = {\'added_tokens_file\': ADDED_TOKENS_FILE,\n                                     \'special_tokens_map_file\': SPECIAL_TOKENS_MAP_FILE}\n\n            # If a path to a file was provided, get the parent directory\n            saved_directory = pretrained_model_name_or_path\n            if os.path.exists(saved_directory) and not os.path.isdir(saved_directory):\n                saved_directory = os.path.dirname(saved_directory)\n\n            for file_id, file_name in all_vocab_files_names.items():\n                full_file_name = os.path.join(saved_directory, file_name)\n                if not os.path.exists(full_file_name):\n                    logger.info(""Didn\'t find file {}. We won\'t load it."".format(full_file_name))\n                    full_file_name = None\n                vocab_files[file_id] = full_file_name\n\n            if all(full_file_name is None for full_file_name in vocab_files.values()):\n                logger.error(\n                    ""Model name \'{}\' was not found in model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url but couldn\'t find tokenizer files""\n                    ""at this path or url."".format(\n                        pretrained_model_name_or_path, \', \'.join(s3_models),\n                        pretrained_model_name_or_path, ))\n                return None\n\n        # Get files from url, cache, or disk depending on the case\n        try:\n            resolved_vocab_files = {}\n            for file_id, file_path in vocab_files.items():\n                if file_path is None:\n                    resolved_vocab_files[file_id] = None\n                else:\n                    resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir)\n        except EnvironmentError:\n            if pretrained_model_name_or_path in s3_models:\n                logger.error(""Couldn\'t reach server to download vocabulary."")\n            else:\n                logger.error(\n                    ""Model name \'{}\' was not found in model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url but couldn\'t find files {} ""\n                    ""at this path or url."".format(\n                        pretrained_model_name_or_path, \', \'.join(s3_models),\n                        pretrained_model_name_or_path, str(vocab_files.keys())))\n            return None\n\n        for file_id, file_path in vocab_files.items():\n            if file_path == resolved_vocab_files[file_id]:\n                logger.info(""loading file {}"".format(file_path))\n            else:\n                logger.info(""loading file {} from cache at {}"".format(\n                    file_path, resolved_vocab_files[file_id]))\n\n        # Set max length if needed\n        if pretrained_model_name_or_path in cls.max_model_input_sizes:\n            # if we\'re using a pretrained model, ensure the tokenizer\n            # wont index sequences longer than the number of positional embeddings\n            max_len = cls.max_model_input_sizes[pretrained_model_name_or_path]\n            if max_len is not None and isinstance(max_len, (int, float)):\n                kwargs[\'max_len\'] = min(kwargs.get(\'max_len\', int(1e12)), max_len)\n\n        # Merge resolved_vocab_files arguments in kwargs.\n        added_tokens_file = resolved_vocab_files.pop(\'added_tokens_file\', None)\n        special_tokens_map_file = resolved_vocab_files.pop(\'special_tokens_map_file\', None)\n        for args_name, file_path in resolved_vocab_files.items():\n            if args_name not in kwargs:\n                kwargs[args_name] = file_path\n        if special_tokens_map_file is not None:\n            special_tokens_map = json.load(open(special_tokens_map_file, encoding=""utf-8""))\n            for key, value in special_tokens_map.items():\n                if key not in kwargs:\n                    kwargs[key] = value\n\n        # Instantiate tokenizer.\n        tokenizer = cls(*inputs, **kwargs)\n\n        # Add supplementary tokens.\n        if added_tokens_file is not None:\n            added_tok_encoder = json.load(open(added_tokens_file, encoding=""utf-8""))\n            added_tok_decoder = {v:k for k, v in added_tok_encoder.items()}\n            tokenizer.added_tokens_encoder.update(added_tok_encoder)\n            tokenizer.added_tokens_decoder.update(added_tok_decoder)\n\n        return tokenizer\n\n\n    def save_pretrained(self, save_directory):\n        """""" Save the tokenizer vocabulary files (with added tokens) and the\n            special-tokens-to-class-attributes-mapping to a directory.\n\n            This method make sure the full tokenizer can then be re-loaded using the :func:`~pytorch_transformers.PreTrainedTokenizer.from_pretrained` class method.\n        """"""\n        if not os.path.isdir(save_directory):\n            logger.error(""Saving directory ({}) should be a directory"".format(save_directory))\n            return\n\n        special_tokens_map_file = os.path.join(save_directory, SPECIAL_TOKENS_MAP_FILE)\n        added_tokens_file = os.path.join(save_directory, ADDED_TOKENS_FILE)\n\n        with open(special_tokens_map_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.special_tokens_map, ensure_ascii=False))\n\n        with open(added_tokens_file, \'w\', encoding=\'utf-8\') as f:\n            if self.added_tokens_encoder:\n                out_str = json.dumps(self.added_tokens_encoder, ensure_ascii=False)\n            else:\n                out_str = u""{}""\n            f.write(out_str)\n\n        vocab_files = self.save_vocabulary(save_directory)\n\n        return vocab_files + (special_tokens_map_file, added_tokens_file)\n\n\n    def save_vocabulary(self, save_directory):\n        """""" Save the tokenizer vocabulary to a directory. This method does *NOT* save added tokens\n            and special token mappings.\n\n            Please use :func:`~pytorch_transformers.PreTrainedTokenizer.save_pretrained` `()` to save the full Tokenizer state if you want to reload it using the :func:`~pytorch_transformers.PreTrainedTokenizer.from_pretrained` class method.\n        """"""\n        raise NotImplementedError\n\n\n    def vocab_size(self):\n        """""" Size of the base vocabulary (without the added tokens) """"""\n        raise NotImplementedError\n\n\n    def __len__(self):\n        """""" Size of the full vocabulary with the added tokens """"""\n        return self.vocab_size + len(self.added_tokens_encoder)\n\n\n    def add_tokens(self, new_tokens):\n        """"""\n        Add a list of new tokens to the tokenizer class. If the new tokens are not in the\n        vocabulary, they are added to it with indices starting from length of the current vocabulary.\n\n        Args:\n            new_tokens: list of string. Each string is a token to add. Tokens are only added if they are not already in the vocabulary (tested by checking if the tokenizer assign the index of the ``unk_token`` to them).\n\n        Returns:\n            Number of tokens added to the vocabulary.\n\n        Examples::\n\n            # Let\'s see how to increase the vocabulary of Bert model and tokenizer\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n            model = BertModel.from_pretrained(\'bert-base-uncased\')\n\n            num_added_toks = tokenizer.add_tokens([\'new_tok1\', \'my_new-tok2\'])\n            print(\'We have added\', num_added_toks, \'tokens\')\n            model.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.\n        """"""\n        if not new_tokens:\n            return 0\n\n        to_add_tokens = []\n        for token in new_tokens:\n            assert isinstance(token, str) or (six.PY2 and isinstance(token, unicode))\n            if token != self.unk_token and \\\n                    self.convert_tokens_to_ids(token) == self.convert_tokens_to_ids(self.unk_token):\n                to_add_tokens.append(token)\n                logger.info(""Adding %s to the vocabulary"", token)\n\n        added_tok_encoder = dict((tok, len(self) + i) for i, tok in enumerate(to_add_tokens))\n        added_tok_decoder = {v:k for k, v in added_tok_encoder.items()}\n        self.added_tokens_encoder.update(added_tok_encoder)\n        self.added_tokens_decoder.update(added_tok_decoder)\n\n        return len(to_add_tokens)\n\n\n    def add_special_tokens(self, special_tokens_dict):\n        """"""\n        Add a dictionary of special tokens (eos, pad, cls...) to the encoder and link them\n        to class attributes. If special tokens are NOT in the vocabulary, they are added\n        to it (indexed starting from the last index of the current vocabulary).\n\n        Args:\n            special_tokens_dict: dict of string. Keys should be in the list of predefined special attributes:\n                [``bos_token``, ``eos_token``, ``unk_token``, ``sep_token``, ``pad_token``, ``cls_token``, ``mask_token``,\n                ``additional_special_tokens``].\n\n                Tokens are only added if they are not already in the vocabulary (tested by checking if the tokenizer assign the index of the ``unk_token`` to them).\n\n        Returns:\n            Number of tokens added to the vocabulary.\n\n        Examples::\n\n            # Let\'s see how to add a new classification token to GPT-2\n            tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n            model = GPT2Model.from_pretrained(\'gpt2\')\n\n            special_tokens_dict = {\'cls_token\': \'<CLS>\'}\n\n            num_added_toks = tokenizer.add_special_tokens(special_tokens_dict)\n            print(\'We have added\', num_added_toks, \'tokens\')\n            model.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.\n\n            assert tokenizer.cls_token == \'<CLS>\'\n        """"""\n        if not special_tokens_dict:\n            return 0\n\n        added_tokens = 0\n        for key, value in special_tokens_dict.items():\n            assert key in self.SPECIAL_TOKENS_ATTRIBUTES\n            if key == \'additional_special_tokens\':\n                assert isinstance(value, (list, tuple)) and all(isinstance(t, str) or (six.PY2 and isinstance(t, unicode)) for t in value)\n                added_tokens += self.add_tokens(value)\n            else:\n                assert isinstance(value, str) or (six.PY2 and isinstance(value, unicode))\n                added_tokens += self.add_tokens([value])\n            logger.info(""Assigning %s to the %s key of the tokenizer"", value, key)\n            setattr(self, key, value)\n\n        return added_tokens\n\n    def tokenize(self, text, **kwargs):\n        """""" Converts a string in a sequence of tokens (string), using the tokenizer.\n            Split in words for word-based vocabulary or sub-words for sub-word-based\n            vocabularies (BPE/SentencePieces/WordPieces).\n\n            Take care of added tokens.\n        """"""\n        def split_on_tokens(tok_list, text):\n            if not text:\n                return []\n            if not tok_list:\n                return self._tokenize(text, **kwargs)\n            tok = tok_list[0]\n            split_text = text.split(tok)\n            return sum((split_on_tokens(tok_list[1:], sub_text.strip()) + [tok] \\\n                        for sub_text in split_text), [])[:-1]\n\n        added_tokens = list(self.added_tokens_encoder.keys()) + self.all_special_tokens\n        tokenized_text = split_on_tokens(added_tokens, text)\n        return tokenized_text\n\n    def _tokenize(self, text, **kwargs):\n        """""" Converts a string in a sequence of tokens (string), using the tokenizer.\n            Split in words for word-based vocabulary or sub-words for sub-word-based\n            vocabularies (BPE/SentencePieces/WordPieces).\n\n            Do NOT take care of added tokens.\n        """"""\n        raise NotImplementedError\n\n    def convert_tokens_to_ids(self, tokens):\n        """""" Converts a single token, or a sequence of tokens, (str/unicode) in a single integer id\n            (resp. a sequence of ids), using the vocabulary.\n        """"""\n        if isinstance(tokens, str) or (six.PY2 and isinstance(tokens, unicode)):\n            return self._convert_token_to_id_with_added_voc(tokens)\n\n        ids = []\n        for token in tokens:\n            ids.append(self._convert_token_to_id_with_added_voc(token))\n        if len(ids) > self.max_len:\n            logger.warning(""Token indices sequence length is longer than the specified maximum sequence length ""\n                           ""for this model ({} > {}). Running this sequence through the model will result in ""\n                           ""indexing errors"".format(len(ids), self.max_len))\n        return ids\n\n    def _convert_token_to_id_with_added_voc(self, token):\n        if token in self.added_tokens_encoder:\n            return self.added_tokens_encoder[token]\n        return self._convert_token_to_id(token)\n\n    def _convert_token_to_id(self, token):\n        raise NotImplementedError\n\n    def encode(self, text, text_pair=None, add_special_tokens=False):\n        """"""\n        Converts a string in a sequence of ids (integer), using the tokenizer and vocabulary.\n\n        Same as doing ``self.convert_tokens_to_ids(self.tokenize(text))``.\n\n        Args:\n            text: The first sequence to be encoded.\n            text_pair: Optional second sequence to be encoded.\n            add_special_tokens: if set to ``True``, the sequences will be encoded with the special tokens relative\n                to their model.\n        """"""\n        if text_pair is None:\n            if add_special_tokens:\n                return self.add_special_tokens_single_sentence(self.convert_tokens_to_ids(self.tokenize(text)))\n            else:\n                return self.convert_tokens_to_ids(self.tokenize(text))\n\n        first_sentence_tokens = [self._convert_token_to_id(token) for token in self.tokenize(text)]\n        second_sentence_tokens = [self._convert_token_to_id(token) for token in self.tokenize(text_pair)]\n\n        if add_special_tokens:\n            return self.add_special_tokens_sentences_pair(first_sentence_tokens, second_sentence_tokens)\n        else:\n            return first_sentence_tokens, second_sentence_tokens\n\n    def add_special_tokens_single_sentence(self, token_ids):\n        raise NotImplementedError\n\n    def add_special_tokens_sentences_pair(self, token_ids_0, token_ids_1):\n        raise NotImplementedError\n\n    def convert_ids_to_tokens(self, ids, skip_special_tokens=False):\n        """""" Converts a single index or a sequence of indices (integers) in a token ""\n            (resp.) a sequence of tokens (str/unicode), using the vocabulary and added tokens.\n\n            Args:\n                skip_special_tokens: Don\'t decode special tokens (self.all_special_tokens). Default: False\n        """"""\n        if isinstance(ids, int):\n            if ids in self.added_tokens_decoder:\n                return self.added_tokens_decoder[ids]\n            else:\n                return self._convert_id_to_token(ids)\n        tokens = []\n        for index in ids:\n            if index in self.all_special_ids and skip_special_tokens:\n                continue\n            if index in self.added_tokens_decoder:\n                tokens.append(self.added_tokens_decoder[index])\n            else:\n                tokens.append(self._convert_id_to_token(index))\n        return tokens\n\n    def _convert_id_to_token(self, index):\n        raise NotImplementedError\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string.\n            The most simple way to do it is \' \'.join(self.convert_ids_to_tokens(token_ids))\n            but we often want to remove sub-word tokenization artifacts at the same time.\n        """"""\n        return \' \'.join(self.convert_ids_to_tokens(tokens))\n\n    def decode(self, token_ids, skip_special_tokens=False, clean_up_tokenization_spaces=True):\n        """"""\n        Converts a sequence of ids (integer) in a string, using the tokenizer and vocabulary\n        with options to remove special tokens and clean up tokenization spaces.\n        Similar to doing ``self.convert_tokens_to_string(self.convert_ids_to_tokens(token_ids))``.\n        """"""\n        filtered_tokens = self.convert_ids_to_tokens(token_ids, skip_special_tokens=skip_special_tokens)\n        text = self.convert_tokens_to_string(filtered_tokens)\n\n        if self.sep_token is not None and self.sep_token in text:\n            text = text.replace(self.cls_token, self.sep_token)\n            split_text = list(filter(lambda sentence: len(sentence) > 0, text.split(self.sep_token)))\n            if clean_up_tokenization_spaces:\n                clean_text = [self.clean_up_tokenization(text) for text in split_text]\n                return clean_text\n            else:\n                return split_text\n        else:\n            if clean_up_tokenization_spaces:\n                clean_text = self.clean_up_tokenization(text)\n                return clean_text\n            else:\n                return text\n\n    @property\n    def special_tokens_map(self):\n        """""" A dictionary mapping special token class attribute (cls_token, unk_token...) to their\n            values (\'<unk>\', \'<cls>\'...)\n        """"""\n        set_attr = {}\n        for attr in self.SPECIAL_TOKENS_ATTRIBUTES:\n            attr_value = getattr(self, ""_"" + attr)\n            if attr_value:\n                set_attr[attr] = attr_value\n        return set_attr\n\n    @property\n    def all_special_tokens(self):\n        """""" List all the special tokens (\'<unk>\', \'<cls>\'...) mapped to class attributes\n            (cls_token, unk_token...).\n        """"""\n        all_toks = []\n        set_attr = self.special_tokens_map\n        for attr_value in set_attr.values():\n            all_toks = all_toks + (attr_value if isinstance(attr_value, (list, tuple)) else [attr_value])\n        all_toks = list(set(all_toks))\n        return all_toks\n\n    @property\n    def all_special_ids(self):\n        """""" List the vocabulary indices of the special tokens (\'<unk>\', \'<cls>\'...) mapped to\n            class attributes (cls_token, unk_token...).\n        """"""\n        all_toks = self.all_special_tokens\n        all_ids = list(self._convert_token_to_id(t) for t in all_toks)\n        return all_ids\n\n    @staticmethod\n    def clean_up_tokenization(out_string):\n        """""" Clean up a list of simple English tokenization artifacts like spaces before punctuations and abreviated forms.\n        """"""\n        out_string = out_string.replace(\' .\', \'.\').replace(\' ?\', \'?\').replace(\' !\', \'!\').replace(\' ,\', \',\'\n                        ).replace("" \' "", ""\'"").replace("" n\'t"", ""n\'t"").replace("" \'m"", ""\'m"").replace("" do not"", "" don\'t""\n                        ).replace("" \'s"", ""\'s"").replace("" \'ve"", ""\'ve"").replace("" \'re"", ""\'re"")\n        return out_string\n'"
bertviz/transformers_neuron_view/tokenization_xlm.py,0,"b'# coding=utf-8\n# Copyright 2019 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport json\nimport logging\nimport os\nimport re\nfrom io import open\n\nfrom .tokenization_utils import PreTrainedTokenizer\nfrom .tokenization_bert import BasicTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \'vocab_file\': \'vocab.json\',\n    \'merges_file\': \'merges.txt\',\n}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n        \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-vocab.json"",\n        \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-vocab.json"",\n        \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-vocab.json"",\n        \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-vocab.json"",\n        \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-vocab.json"",\n        \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-vocab.json"",\n        \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-enfr-1024-vocab.json"",\n        \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-clm-ende-1024-vocab.json"",\n    },\n    \'merges_file\':\n    {\n        \'xlm-mlm-en-2048\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-en-2048-merges.txt"",\n        \'xlm-mlm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-merges.txt"",\n        \'xlm-mlm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-merges.txt"",\n        \'xlm-mlm-enro-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enro-1024-merges.txt"",\n        \'xlm-mlm-tlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-tlm-xnli15-1024-merges.txt"",\n        \'xlm-mlm-xnli15-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-xnli15-1024-merges.txt"",\n        \'xlm-clm-enfr-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-enfr-1024-merges.txt"",\n        \'xlm-clm-ende-1024\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlm-mlm-ende-1024-merges.txt"",\n    },\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'xlm-mlm-en-2048\': 512,\n    \'xlm-mlm-ende-1024\': 512,\n    \'xlm-mlm-enfr-1024\': 512,\n    \'xlm-mlm-enro-1024\': 512,\n    \'xlm-mlm-tlm-xnli15-1024\': 512,\n    \'xlm-mlm-xnli15-1024\': 512,\n    \'xlm-clm-enfr-1024\': 512,\n    \'xlm-clm-ende-1024\': 512,\n}\n\ndef get_pairs(word):\n    """"""\n    Return set of symbol pairs in a word.\n    word is represented as tuple of symbols (symbols being variable-length strings)\n    """"""\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n    return pairs\n\ndef text_standardize(text):\n    """"""\n    fixes some issues the spacy tokenizer had on books corpus\n    also does some whitespace standardization\n    """"""\n    text = text.replace(\'\xe2\x80\x94\', \'-\')\n    text = text.replace(\'\xe2\x80\x93\', \'-\')\n    text = text.replace(\'\xe2\x80\x95\', \'-\')\n    text = text.replace(\'\xe2\x80\xa6\', \'...\')\n    text = text.replace(\'\xc2\xb4\', ""\'"")\n    text = re.sub(r\'\'\'(-+|~+|!+|""+|;+|\\?+|\\++|,+|\\)+|\\(+|\\\\+|\\/+|\\*+|\\[+|\\]+|}+|{+|\\|+|_+)\'\'\', r\' \\1 \', text)\n    text = re.sub(r\'\\s*\\n\\s*\', \' \\n \', text)\n    text = re.sub(r\'[^\\S\\n]+\', \' \', text)\n    return text.strip()\n\nclass XLMTokenizer(PreTrainedTokenizer):\n    """"""\n    BPE tokenizer for XLM, adapted from OpenAI BPE tokenizer. Peculiarities:\n\n        - lower case all inputs\n\n        - uses `SpaCy tokenizer <https://spacy.io/api/tokenizer/>`_ and \\\n        `ftfy <https://ftfy.readthedocs.io/en/latest/>`_ for pre-BPE tokenization if they are installed, \\\n        fallback to BERT\'s BasicTokenizer if not.\n\n        - argument ``special_tokens`` and function ``set_special_tokens``, can be used to add additional symbols \\\n        (ex: ""__classify__"") to a vocabulary.\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, merges_file, unk_token=""<unk>"", bos_token=""<s>"",\n                 sep_token=""</s>"", pad_token=""<pad>"", cls_token=""</s>"",\n                 mask_token=""<special1>"", additional_special_tokens=[""<special0>"",\n                 ""<special1>"", ""<special2>"", ""<special3>"", ""<special4>"", ""<special5>"",\n                 ""<special6>"", ""<special7>"", ""<special8>"", ""<special9>""], **kwargs):\n        super(XLMTokenizer, self).__init__(unk_token=unk_token, bos_token=bos_token,\n                                           sep_token=sep_token, pad_token=pad_token,\n                                           cls_token=cls_token, mask_token=mask_token,\n                                           additional_special_tokens=additional_special_tokens,\n                                           **kwargs)\n        try:\n            import ftfy\n            import spacy\n            self.nlp = spacy.load(\'en\', disable=[\'parser\', \'tagger\', \'ner\', \'textcat\'])\n            self.fix_text = ftfy.fix_text\n        except ImportError:\n            logger.warning(""ftfy or spacy is not installed using BERT BasicTokenizer instead of SpaCy & ftfy."")\n            self.nlp = BasicTokenizer(do_lower_case=True)\n            self.fix_text = None\n\n        self.encoder = json.load(open(vocab_file, encoding=""utf-8""))\n        self.decoder = {v:k for k,v in self.encoder.items()}\n        merges = open(merges_file, encoding=\'utf-8\').read().split(\'\\n\')[:-1]\n        merges = [tuple(merge.split()[:2]) for merge in merges]\n        self.bpe_ranks = dict(zip(merges, range(len(merges))))\n        self.cache = {}\n\n    @property\n    def vocab_size(self):\n        return len(self.encoder)\n\n    def bpe(self, token):\n        word = tuple(token[:-1]) + (token[-1] + \'</w>\',)\n        if token in self.cache:\n            return self.cache[token]\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token+\'</w>\'\n\n        while True:\n            bigram = min(pairs, key=lambda pair: self.bpe_ranks.get(pair, float(\'inf\')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = \' \'.join(word)\n        if word == \'\\n  </w>\':\n            word = \'\\n</w>\'\n        self.cache[token] = word\n        return word\n\n    def _tokenize(self, text):\n        """""" Tokenize a string. """"""\n        split_tokens = []\n        if self.fix_text is None:\n            # Using BERT\'s BasicTokenizer\n            text = self.nlp.tokenize(text)\n            for token in text:\n                split_tokens.extend([t for t in self.bpe(token).split(\' \')])\n        else:\n            # Using SpaCy & ftfy (original tokenization process of OpenAI GPT)\n            text = self.nlp(text_standardize(self.fix_text(text)))\n            for token in text:\n                split_tokens.extend([t for t in self.bpe(token.text.lower()).split(\' \')])\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.encoder.get(token, self.encoder.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.decoder.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \'\'.join(tokens).replace(\'</w>\', \' \').strip()\n        return out_string\n\n    def add_special_tokens_single_sentence(self, token_ids):\n        """"""\n        Adds special tokens to a sequence for sequence classification tasks.\n        An XLM sequence has the following format: [CLS] X [SEP]\n        """"""\n        return [self._convert_token_to_id(self.cls_token)] + token_ids + [self._convert_token_to_id(self.sep_token)]\n\n    def add_special_tokens_sentences_pair(self, token_ids_0, token_ids_1):\n        """"""\n        Adds special tokens to a sequence pair for sequence classification tasks.\n        An XLM sequence pair has the following format: [CLS] A [SEP] B [SEP]\n        """"""\n        sep = [self._convert_token_to_id(self.sep_token)]\n        cls = [self._convert_token_to_id(self.cls_token)]\n        return cls + token_ids_0 + sep + token_ids_1 + sep\n\n    def save_vocabulary(self, save_directory):\n        """"""Save the tokenizer vocabulary and merge files to a directory.""""""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n        merge_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'merges_file\'])\n\n        with open(vocab_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.encoder, ensure_ascii=False))\n\n        index = 0\n        with open(merge_file, ""w"", encoding=""utf-8"") as writer:\n            for bpe_tokens, token_index in sorted(self.bpe_ranks.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: BPE merge indices are not consecutive.""\n                                   "" Please check that the tokenizer is not corrupted!"".format(merge_file))\n                    index = token_index\n                writer.write(\' \'.join(bpe_tokens) + u\'\\n\')\n                index += 1\n\n        return vocab_file, merge_file\n'"
bertviz/transformers_neuron_view/tokenization_xlnet.py,0,"b'# coding=utf-8\n# Copyright 2018 Google AI, Google Brain and Carnegie Mellon University Authors and the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Tokenization classes for XLNet model.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\nimport os\nfrom shutil import copyfile\n\nimport unicodedata\nimport six\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'vocab_file\': \'spiece.model\'}\n\nPRETRAINED_VOCAB_FILES_MAP = {\n    \'vocab_file\':\n    {\n    \'xlnet-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-base-cased-spiece.model"",\n    \'xlnet-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/xlnet-large-cased-spiece.model"",\n    }\n}\n\nPRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = {\n    \'xlnet-base-cased\': None,\n    \'xlnet-large-cased\': None,\n}\n\nSPIECE_UNDERLINE = u\'\xe2\x96\x81\'\n\n# Segments (not really needed)\nSEG_ID_A   = 0\nSEG_ID_B   = 1\nSEG_ID_CLS = 2\nSEG_ID_SEP = 3\nSEG_ID_PAD = 4\n\nclass XLNetTokenizer(PreTrainedTokenizer):\n    """"""\n        SentencePiece based tokenizer. Peculiarities:\n\n            - requires `SentencePiece <https://github.com/google/sentencepiece>`_\n    """"""\n    vocab_files_names = VOCAB_FILES_NAMES\n    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n\n    def __init__(self, vocab_file, max_len=None,\n                 do_lower_case=False, remove_space=True, keep_accents=False,\n                 bos_token=""<s>"", eos_token=""</s>"", unk_token=""<unk>"", sep_token=""<sep>"",\n                 pad_token=""<pad>"", cls_token=""<cls>"", mask_token=""<mask>"",\n                 additional_special_tokens=[""<eop>"", ""<eod>""], **kwargs):\n        super(XLNetTokenizer, self).__init__(bos_token=bos_token, eos_token=eos_token,\n                                             unk_token=unk_token, sep_token=sep_token,\n                                             pad_token=pad_token, cls_token=cls_token,\n                                             mask_token=mask_token, additional_special_tokens=\n                                             additional_special_tokens, **kwargs)\n        try:\n            import sentencepiece as spm\n        except ImportError:\n            logger.warning(""You need to install SentencePiece to use XLNetTokenizer: https://github.com/google/sentencepiece""\n                           ""pip install sentencepiece"")\n\n        self.do_lower_case = do_lower_case\n        self.remove_space = remove_space\n        self.keep_accents = keep_accents\n        self.vocab_file = vocab_file\n\n        self.sp_model = spm.SentencePieceProcessor()\n        self.sp_model.Load(vocab_file)\n\n    @property\n    def vocab_size(self):\n        return len(self.sp_model)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        state[""sp_model""] = None\n        return state\n\n    def __setstate__(self, d):\n        self.__dict__ = d\n        try:\n            import sentencepiece as spm\n        except ImportError:\n            logger.warning(""You need to install SentencePiece to use XLNetTokenizer: https://github.com/google/sentencepiece""\n                           ""pip install sentencepiece"")\n        self.sp_model = spm.SentencePieceProcessor()\n        self.sp_model.Load(self.vocab_file)\n\n    def preprocess_text(self, inputs):\n        if self.remove_space:\n            outputs = \' \'.join(inputs.strip().split())\n        else:\n            outputs = inputs\n        outputs = outputs.replace(""``"", \'""\').replace(""\'\'"", \'""\')\n\n        if six.PY2 and isinstance(outputs, str):\n            outputs = outputs.decode(\'utf-8\')\n\n        if not self.keep_accents:\n            outputs = unicodedata.normalize(\'NFKD\', outputs)\n            outputs = \'\'.join([c for c in outputs if not unicodedata.combining(c)])\n        if self.do_lower_case:\n            outputs = outputs.lower()\n\n        return outputs\n\n    def _tokenize(self, text, return_unicode=True, sample=False):\n        """""" Tokenize a string.\n            return_unicode is used only for py2\n        """"""\n        text = self.preprocess_text(text)\n        # note(zhiliny): in some systems, sentencepiece only accepts str for py2\n        if six.PY2 and isinstance(text, unicode):\n            text = text.encode(\'utf-8\')\n\n        if not sample:\n            pieces = self.sp_model.EncodeAsPieces(text)\n        else:\n            pieces = self.sp_model.SampleEncodeAsPieces(text, 64, 0.1)\n        new_pieces = []\n        for piece in pieces:\n            if len(piece) > 1 and piece[-1] == \',\' and piece[-2].isdigit():\n                cur_pieces = self.sp_model.EncodeAsPieces(\n                    piece[:-1].replace(SPIECE_UNDERLINE, \'\'))\n                if piece[0] != SPIECE_UNDERLINE and cur_pieces[0][0] == SPIECE_UNDERLINE:\n                    if len(cur_pieces[0]) == 1:\n                        cur_pieces = cur_pieces[1:]\n                    else:\n                        cur_pieces[0] = cur_pieces[0][1:]\n                cur_pieces.append(piece[-1])\n                new_pieces.extend(cur_pieces)\n            else:\n                new_pieces.append(piece)\n\n        # note(zhiliny): convert back to unicode for py2\n        if six.PY2 and return_unicode:\n            ret_pieces = []\n            for piece in new_pieces:\n                if isinstance(piece, str):\n                    piece = piece.decode(\'utf-8\')\n                ret_pieces.append(piece)\n            new_pieces = ret_pieces\n\n        return new_pieces\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.sp_model.PieceToId(token)\n\n    def _convert_id_to_token(self, index, return_unicode=True):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        token = self.sp_model.IdToPiece(index)\n        if six.PY2 and return_unicode and isinstance(token, str):\n            token = token.decode(\'utf-8\')\n        return token\n\n    def convert_tokens_to_string(self, tokens):\n        """"""Converts a sequence of tokens (strings for sub-words) in a single string.""""""\n        out_string = \'\'.join(tokens).replace(SPIECE_UNDERLINE, \' \').strip()\n        return out_string\n\n    def add_special_tokens_single_sentence(self, token_ids):\n        """"""\n        Adds special tokens to a sequence pair for sequence classification tasks.\n        An XLNet sequence pair has the following format: A [SEP] B [SEP][CLS]\n        """"""\n        sep = [self._convert_token_to_id(self.sep_token)]\n        cls = [self._convert_token_to_id(self.cls_token)]\n        return token_ids + sep + cls\n\n    def add_special_tokens_sentences_pair(self, token_ids_0, token_ids_1):\n        """"""\n        Adds special tokens to a sequence for sequence classification tasks.\n        An XLNet sequence has the following format: X [SEP][CLS]\n        """"""\n        sep = [self._convert_token_to_id(self.sep_token)]\n        cls = [self._convert_token_to_id(self.cls_token)]\n        return token_ids_0 + sep + token_ids_1 + sep + cls\n\n    def save_vocabulary(self, save_directory):\n        """""" Save the sentencepiece vocabulary (copy original file) and special tokens file\n            to a directory.\n        """"""\n        if not os.path.isdir(save_directory):\n            logger.error(""Vocabulary path ({}) should be a directory"".format(save_directory))\n            return\n        out_vocab_file = os.path.join(save_directory, VOCAB_FILES_NAMES[\'vocab_file\'])\n\n        if os.path.abspath(self.vocab_file) != os.path.abspath(out_vocab_file):\n            copyfile(self.vocab_file, out_vocab_file)\n\n        return (out_vocab_file,)\n'"
