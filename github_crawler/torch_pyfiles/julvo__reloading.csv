file_path,api_count,code
setup.py,0,"b""from distutils.core import setup\n\nsetup(\n  name = 'reloading',         \n  packages = ['reloading'],   \n  version = '1.0.1',      \n  license='MIT',        \n  description = 'Reloads source code of a running program without losing state',\n  author = 'Julian Vossen',\n  author_email = 'pypi@julianvossen.de',\n  url = 'https://github.com/julvo/reloading',\n  download_url = 'https://github.com/julvo/reloading/archive/v1.0.1.tar.gz',\n  keywords = ['reload', 'reloading', 'refresh', 'loop', 'decorator'],\n  install_requires=[],\n  classifiers=[\n    'Development Status :: 3 - Alpha',\n    'Intended Audience :: Developers',\n    'Topic :: Utilities',\n    'License :: OSI Approved :: MIT License',\n    'Programming Language :: Python :: 3',\n    'Programming Language :: Python :: 3.4',\n    'Programming Language :: Python :: 3.5',\n    'Programming Language :: Python :: 3.6',\n    'Programming Language :: Python :: 3.7',\n    'Programming Language :: Python :: 3.8',\n  ],\n)\n"""
reloading/__init__.py,0,b'from .reloading import reloading\n'
reloading/reloading.py,0,"b'import time\nimport re\nimport inspect\nimport sys\nimport ast\nimport traceback\nimport types\nfrom itertools import chain\n\n\ndef reloading(fn_or_seq):\n    \'\'\'Wraps a loop iterator or decorates a function to reload source code.\n\n    A function that when wrapped around the outermost iterator in a for loop,\n    causes the loop body to reload from source before every iteration while\n    keeping the state.\n    When used as a function decorator, the function is reloaded from source \n    before each execution.\n\n    Args:\n        fn_or_seq (function | iterable): A function or loop iterator which should\n            be reloaded from source before each execution or iteration,\n            respectively\n    \'\'\'\n    if isinstance(fn_or_seq, types.FunctionType):\n        return _reloading_function(fn_or_seq)\n    return _reloading_loop(fn_or_seq)\n\n\ndef find_loop(tree):\n    for child in ast.walk(tree):\n        if not isinstance(child, ast.For):\n            continue\n        if not isinstance(child.iter, ast.Call):\n            continue\n        if child.iter.func.id == \'reloading\':\n            return child\n\n\ndef locate_loop_body(module, loop):\n    ends = set([ node.lineno \n                    for node in ast.walk(module) \n                    if hasattr(node, \'lineno\') and node.lineno > loop.lineno ])\n\n    starts = set()\n\n    def visit(node):\n        if hasattr(node, \'lineno\') and node.lineno > loop.lineno:\n            starts.add(node.lineno)\n            if node.lineno in ends:\n                ends.remove(node.lineno)\n        for child in ast.iter_child_nodes(node):\n            visit(child)\n\n    for stmt in loop.body:\n        visit(stmt)\n\n    if len(ends) == 0: \n        return min(starts), -1\n\n    return min(starts), min(ends)\n\n\ndef unique_name(used):\n    return max(used, key=len) + ""0""\n\n\ndef _reloading_loop(seq):\n    frame = inspect.currentframe()\n\n    caller_globals = frame.f_back.f_back.f_globals\n    caller_locals = frame.f_back.f_back.f_locals\n    unique = unique_name(chain(caller_locals.keys(), caller_globals.keys()))\n    for j in seq:\n        fpath = inspect.stack()[2][1]\n        with open(fpath, \'r\') as f:\n            src = f.read() + \'\\n\'\n\n        # find the iteration variables in the caller module\'s source\n        match = re.search(\'\\s*for (.+?) in reloading\', src)\n        if match is None:\n            break \n        itervars = match.group(1)\n\n        # find the loop body in the caller module\'s source\n        tree = ast.parse(src)\n        loop = find_loop(tree)\n        start, end = locate_loop_body(tree, loop)\n        lines  = src.split(\'\\n\')\n        if end < 0:\n            end = len(lines)\n        body_lines = lines[start-1:end-1] # -1 as line numbers are 1-indexed\n\n        # remove indent from lines in loop body, only if a line\n        # starts with this indentation as comments might not\n        indent = re.search(\'([ \\t]*)\\S\', body_lines[0])\n        body = \'\\n\'.join([ line[len(indent.group(1)):] \n            for line in body_lines \n            if line.startswith(indent.group(1))])\n\n        caller_locals[unique] = j\n        exec(itervars + \' = \' + unique, caller_globals, caller_locals)\n\n        try:\n            # run main loop body\n            exec(body, caller_globals, caller_locals)\n        except Exception:\n            exc = traceback.format_exc()\n            exc = exc.replace(\'File ""<string>""\', \'File ""{}""\'.format(fpath))\n            sys.stderr.write(exc + \'\\n\')\n            print(\'Edit {} and press return to continue with the next iteration\'.format(fpath))\n            sys.stdin.readline()\n\n    return []\n\n\ndef find_function_in_source(fn_name, src):\n    \'\'\'Finds line number of start and end of a function with a \n    given name within the given source code.\n    \'\'\'\n    tree = ast.parse(src)\n\n    # find the parent of the function definition so that we can find out\n    # where the function definition ends by using the starting line\n    # number of the subsequent child after the function definition\n    for parent in ast.walk(tree):\n        fn_end = len(src.split(\'\\n\'))\n\n        for child in reversed(list(ast.iter_child_nodes(parent))):\n            if not isinstance(child, ast.FunctionDef)\\\n               or child.name != fn_name\\\n               or not hasattr(child, \'decorator_list\')\\\n               or len([ \n                   dec \n                   for dec in child.decorator_list \n                   if dec.id == \'reloading\' ]) < 1:\n\n                if hasattr(child, \'lineno\'):\n                    fn_end = child.lineno - 1\n                continue\n\n            # if we arrived here, child is the function definition\n            fn_start = min([d.lineno for d in child.decorator_list])\n            return fn_start, fn_end, child.col_offset\n\n    return -1, -1, 0\n\n\ndef _reloading_function(fn):\n    frame, fpath = inspect.stack()[2][:2]\n    caller_locals = frame.f_locals\n    caller_globals = frame.f_globals\n\n    # if we are redefining the function, we need to load the file path\n    # from the function\'s dictionary as it would be `<string>` otherwise\n    # which happens when defining functions using `exec`\n    if fn.__name__ in caller_locals:\n        fpath = caller_locals[fn.__name__].__dict__[\'__fpath__\']\n\n    def wrapped(*args, **kwargs):\n        with open(fpath, \'r\') as f:\n            src = f.read()\n\n        start, end, indent = find_function_in_source(fn.__name__, src)\n        lines = src.split(\'\\n\')\n        fn_src = \'\\n\'.join([ l[indent:] for l in lines[start-1:end] ])\n\n        while True:\n            try:\n                exec(fn_src, caller_globals, caller_locals)\n                break\n            except Exception:\n                exc = traceback.format_exc()\n                exc = exc.replace(\'File ""<string>""\', \'File ""{}""\'.format(fpath))\n                sys.stderr.write(exc + \'\\n\')\n                print(\'Edit {} and press return to try again\'.format(fpath))\n                sys.stdin.readline()\n\n\n        # the newly defined function will also be decorated \n        # with `reloading` and, hence, we call the inner function without\n        # triggering another reload (and another one...)\n        inner = caller_locals[fn.__name__].__dict__[\'__inner__\']\n        return inner(*args, **kwargs)\n\n    # save the inner function to be able to call it without \n    # triggering infinitely recursive reloading\n    wrapped.__dict__[\'__inner__\'] = fn\n    # save the file path for later, as the original file path gets\n    # lost by reloading and redefining the function using `exec`\n    wrapped.__dict__[\'__fpath__\'] = fpath\n    wrapped.__name__ = fn.__name__\n    wrapped.__doc__ = fn.__doc__\n\n    return wrapped\n'"
reloading/test_reloading.py,0,"b'import unittest\nimport os\nimport subprocess as sp\nimport time\n\nfrom reloading import reloading\n\nSRC_FILE_NAME = \'temporary_testing_file.py\'\n\nTEST_CHANGING_SOURCE_LOOP_CONTENT = \'\'\'\nfrom reloading import reloading\nfrom time import sleep\n\nfor epoch in reloading(range(10)):\n    sleep(0.1)\n    print(\'INITIAL_FILE_CONTENTS\')\n\'\'\'\n\nTEST_CHANGING_SOURCE_FN_CONTENT = \'\'\'\nfrom reloading import reloading\nfrom time import sleep\n\n@reloading\ndef reload_this_fn():\n    print(\'INITIAL_FILE_CONTENTS\')\n\nfor epoch in reloading(range(10)):\n    sleep(0.1)\n    reload_this_fn()\n\'\'\'\n\nTEST_KEEP_LOCAL_VARIABLES_CONTENT = \'\'\'\nfrom reloading import reloading\nfrom time import sleep\n\nfpath = ""DON\'T CHANGE ME""\nfor epoch in reloading(range(1)):\n    assert fpath == ""DON\'T CHANGE ME""\n\'\'\'\n\nTEST_PERSIST_AFTER_LOOP = \'\'\'\nfrom reloading import reloading\nfrom time import sleep\n\nstate = \'INIT\'\nfor epoch in reloading(range(1)):\n    state = \'CHANGED\'\n\nassert state == \'CHANGED\'\n\'\'\'\n\nTEST_COMMENT_AFTER_LOOP_CONTENT = \'\'\'\nfrom reloading import reloading\nfrom time import sleep\n\nfor epoch in reloading(range(10)):\n    sleep(0.1)\n    print(\'INITIAL_FILE_CONTENTS\')\n\n# a comment here should not cause an error\n\'\'\'\n\nTEST_FORMAT_STR_IN_LOOP_CONTENT = \'\'\'\nfrom reloading import reloading\nfrom time import sleep\n\nfor epoch in reloading(range(10)):\n    sleep(0.1)\n    file_contents = \'FILE_CONTENTS\'\n    print(f\'INITIAL_{file_contents}\')\n\'\'\'\n\n\ndef run_and_update_source(init_src, updated_src=None, update_after=0.5):\n    \'\'\'Runs init_src in a subprocess and updates source to updated_src after\n    update_after seconds. Returns the standard output of the subprocess and\n    whether the subprocess produced an uncaught exception.\n    \'\'\'\n    with open(SRC_FILE_NAME, \'w\') as f:\n        f.write(init_src)\n\n    cmd = [\'python3\', SRC_FILE_NAME]\n    with sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE) as proc:\n        if updated_src != None:\n            time.sleep(update_after)\n            with open(SRC_FILE_NAME, \'w\') as f:\n                f.write(updated_src)\n\n        try:\n            stdout, _ = proc.communicate(timeout=2)\n            stdout = stdout.decode(\'utf-8\')\n            has_error = False\n        except:\n            stdout = \'\'\n            has_error = True\n            proc.terminate() \n\n    if os.path.isfile(SRC_FILE_NAME):\n        os.remove(SRC_FILE_NAME)\n\n    return stdout, has_error\n\n\nclass TestReloading(unittest.TestCase):\n\n    def test_simple_looping(self):\n        iters = 0\n        for _ in reloading(range(10)):\n            iters += 1\n\n    def test_changing_source_loop(self):\n        stdout, _ = run_and_update_source(\n          init_src=TEST_CHANGING_SOURCE_LOOP_CONTENT,\n          updated_src=TEST_CHANGING_SOURCE_LOOP_CONTENT.replace(\'INITIAL\', \'CHANGED\').rstrip(\'\\n\'))\n\n        self.assertTrue(\'INITIAL_FILE_CONTENTS\' in stdout and\n                        \'CHANGED_FILE_CONTENTS\' in stdout)\n\n    def test_comment_after_loop(self):\n        stdout, _ = run_and_update_source(\n          init_src=TEST_COMMENT_AFTER_LOOP_CONTENT,\n          updated_src=TEST_COMMENT_AFTER_LOOP_CONTENT.replace(\'INITIAL\', \'CHANGED\').rstrip(\'\\n\'))\n\n        self.assertTrue(\'INITIAL_FILE_CONTENTS\' in stdout and\n                        \'CHANGED_FILE_CONTENTS\' in stdout)\n\n    def test_format_str_in_loop(self):\n        stdout, _ = run_and_update_source(\n          init_src=TEST_FORMAT_STR_IN_LOOP_CONTENT,\n          updated_src=TEST_FORMAT_STR_IN_LOOP_CONTENT.replace(\'INITIAL\', \'CHANGED\').rstrip(\'\\n\'))\n\n        self.assertTrue(\'INITIAL_FILE_CONTENTS\' in stdout and\n                        \'CHANGED_FILE_CONTENTS\' in stdout)\n\n    def test_keep_local_variables(self):\n        _, has_error = run_and_update_source(init_src=TEST_KEEP_LOCAL_VARIABLES_CONTENT)\n        self.assertFalse(has_error)\n\n    def test_persist_after_loop(self):\n        _, has_error = run_and_update_source(init_src=TEST_PERSIST_AFTER_LOOP)\n        self.assertFalse(has_error)\n\n    def test_simple_function(self):\n        @reloading\n        def some_func():\n            return \'result\'\n        \n        self.assertTrue(some_func() == \'result\')\n\n    def test_changing_source_function(self):\n        stdout, _ = run_and_update_source(\n          init_src=TEST_CHANGING_SOURCE_FN_CONTENT,\n          updated_src=TEST_CHANGING_SOURCE_FN_CONTENT.replace(\'INITIAL\', \'CHANGED\').rstrip(\'\\n\'))\n\n        self.assertTrue(\'INITIAL_FILE_CONTENTS\' in stdout and\n                        \'CHANGED_FILE_CONTENTS\' in stdout)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
examples/demo/demo.py,0,"b""import time\nimport sys\nsys.path.insert(0, '../..')\nfrom reloading import reloading\n\nepochs = 10000\nloss = 100\nmodel = { 'weights': [0.2, 0.1, 0.4, 0.8, 0.1] }\n\nfor i in reloading(range(epochs)):\n    time.sleep(2)\n    loss /= 2\n\n    print('Epoch:', i, 'Loss:', loss)\n"""
examples/fastai/train.py,0,"b""import sys\nsys.path.insert(0, '../..')\nfrom reloading import reloading\n\nfrom fastai.basic_train import LearnerCallback\nfrom fastai.vision import (URLs, untar_data, ImageDataBunch, \n                           cnn_learner, models, accuracy)\n\n\n@reloading\ndef set_learning_rate(learner):\n    # Change the learning rate below during the training\n    learner.opt.opt.lr = 1e-3\n    print('Set LR to', learner.opt.opt.lr)\n\nclass LearningRateSetter(LearnerCallback):\n    def on_epoch_begin(self, **kwargs):\n        set_learning_rate(self.learn)\n\n\n@reloading\ndef print_model_statistics(model):\n    # Uncomment the following lines after during the training \n    # to start printing statistics\n    #\n    # print('{: <28}  {: <7}  {: <7}'.format('NAME', ' MEAN', ' STDDEV'))\n    # for name, param in model.named_parameters():\n    #     mean = param.mean().item()\n    #     std = param.std().item()\n    #     print('{: <28}  {: 6.4f}  {: 6.4f}'.format(name, mean, std))\n    pass\n\nclass ModelStatsPrinter(LearnerCallback):\n    def on_epoch_begin(self, **kwargs):\n        print_model_statistics(self.learn.model)\n\n\npath = untar_data(URLs.MNIST_SAMPLE)\ndata = ImageDataBunch.from_folder(path)\nlearn = cnn_learner(data, models.resnet18, metrics=accuracy, \n                    callback_fns=[ModelStatsPrinter, LearningRateSetter])\nlearn.fit(10)\n"""
examples/keras/train.py,0,"b""# Example taken from https://keras.io/getting-started/sequential-model-guide/#examples\nimport sys\nsys.path.insert(0, '../..')\nfrom reloading import reloading\n\nimport keras\nfrom keras import backend as K\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Activation\nfrom keras.optimizers import SGD\nfrom keras.callbacks import Callback\n\n\n@reloading\ndef set_learning_rate(model):\n    # Change the below value during training and see how it updates\n    K.set_value(model.optimizer.lr, 1e-3)\n    print('Set LR to', K.get_value(model.optimizer.lr))\n\nclass LearningRateSetter(Callback):\n    def on_epoch_begin(self, epoch, logs=None):\n        set_learning_rate(self.model)\n\n\n# Generate dummy data\nimport numpy as np\nx_train = np.random.random((10000, 20))\ny_train = keras.utils.to_categorical(np.random.randint(10, size=(10000, 1)), num_classes=10)\nx_test = np.random.random((1000, 20))\ny_test = keras.utils.to_categorical(np.random.randint(10, size=(1000, 1)), num_classes=10)\n\nmodel = Sequential()\nmodel.add(Dense(64, activation='relu', input_dim=20))\nmodel.add(Dense(10, activation='softmax'))\n\nsgd = SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True)\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=sgd,\n              metrics=['accuracy'])\n\nmodel.fit(x_train, y_train,\n          epochs=200,\n          batch_size=128,\n          callbacks=[LearningRateSetter()])\nscore = model.evaluate(x_test, y_test, batch_size=128)"""
examples/pytorch/train.py,3,"b""import sys\nsys.path.insert(0, '../..')\nfrom reloading import reloading\n\nfrom torch import nn\nfrom torch.optim import Adam\nimport torch.nn.functional as F\nfrom torchvision.models import resnet18\nfrom torchvision.datasets import FashionMNIST\nfrom torchvision.transforms import ToTensor\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\n\n\ndataset = FashionMNIST('.', download=True, transform=ToTensor())\ndataloader = DataLoader(dataset, batch_size=8)\n\nmodel = resnet18(pretrained=True)\nmodel.fc = nn.Linear(model.fc.in_features, 10)\n\noptimiser = Adam(model.parameters())\n\nfor epoch in reloading(range(1000)):\n    # Try to change the code inside this loop during the training and see how the\n    # changes are applied without restarting the training\n\n    model.train()\n    losses = []\n\n    for images, targets in tqdm(dataloader):\n        losses.append(1)\n\n        optimiser.zero_grad()\n        predictions = model(images.expand(8, 3, 28, 28))\n        loss = F.cross_entropy(predictions, targets)\n        loss.backward()\n        optimiser.step()\n        losses.append(loss.item())\n\n    # Here would be your validation code\n\n    print(f'Epoch {epoch} - Loss {sum(losses) / len(losses)}')\n\n\n"""
examples/tensorflow/train.py,0,"b""# Example from https://www.tensorflow.org/tutorials/quickstart/advanced\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport sys\nsys.path.insert(0, '../..')\nfrom reloading import reloading\n\nimport tensorflow as tf\nfrom tensorflow.keras.layers import Dense, Flatten, Conv2D\nfrom tensorflow.keras import Model\n\nfrom tqdm import tqdm\n\n(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()\nx_train, x_test = x_train / 255.0, x_test / 255.0\n\n# Add a channels dimension\nx_train = x_train[..., tf.newaxis]\nx_test = x_test[..., tf.newaxis]\n\ntrain_ds = tf.data.Dataset.from_tensor_slices(\n    (x_train, y_train)).shuffle(10000).batch(32)\n\ntest_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)\n\nclass MyModel(Model):\n  def __init__(self):\n    super(MyModel, self).__init__()\n    self.conv1 = Conv2D(32, 3, activation='relu')\n    self.flatten = Flatten()\n    self.d1 = Dense(128, activation='relu')\n    self.d2 = Dense(10)\n\n  def call(self, x):\n    x = self.conv1(x)\n    x = self.flatten(x)\n    x = self.d1(x)\n    return self.d2(x)\n\nmodel = MyModel()\n\nloss_object = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)\n\noptimizer = tf.keras.optimizers.Adam()\n\ntrain_loss = tf.keras.metrics.Mean(name='train_loss')\ntrain_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='train_accuracy')\n\ntest_loss = tf.keras.metrics.Mean(name='test_loss')\ntest_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='test_accuracy')\n\n@tf.function\ndef train_step(images, labels):\n  with tf.GradientTape() as tape:\n    predictions = model(images, training=True)\n    loss = loss_object(labels, predictions)\n  gradients = tape.gradient(loss, model.trainable_variables)\n  optimizer.apply_gradients(zip(gradients, model.trainable_variables))\n\n  train_loss(loss)\n  train_accuracy(labels, predictions)\n\n@tf.function\ndef test_step(images, labels):\n  predictions = model(images, training=False)\n  t_loss = loss_object(labels, predictions)\n\n  test_loss(t_loss)\n  test_accuracy(labels, predictions)\n\nEPOCHS = 5\n\nfor epoch in reloading(range(EPOCHS)):\n  # Try to change the source code inside this loop during the training to\n  # see how the changes are applied without restarting the training.\n  # You can use it e.g. to inspect the model or changing the learning rate.\n\n  train_loss.reset_states()\n  train_accuracy.reset_states()\n  test_loss.reset_states()\n  test_accuracy.reset_states()\n\n  for images, labels in tqdm(train_ds):\n    train_step(images, labels)\n\n  for test_images, test_labels in tqdm(test_ds):\n    test_step(test_images, test_labels)\n\n  template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}'\n  print(template.format(epoch+1,\n                        train_loss.result(),\n                        train_accuracy.result()*100,\n                        test_loss.result(),\n                        test_accuracy.result()*100))"""
